<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Design Needs when Debugging a SoftCore CPU</title>
  <meta name="description" content="Building your own [softcore](https://en.wikipedia.org/wiki/Soft_microprocessor)[CPU](https://en.wikipedia.org/wiki/Central_processing_unit) within an[FPGA](h...">

  <link rel="shortcut icon" type="image/x-icon" href="/img/GT.ico">
  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="http://zipcpu.com/zipcpu/2017/07/14/cpu-debugging-needs.html">
  <link rel="alternate" type="application/rss+xml" title="The ZipCPU by Gisselquist Technology" href="http://zipcpu.com/feed.xml">
</head>


  <body>

    <header class="site-header">
  <div id="banner">
  <a href="/"><picture>
    <img height=120 id="site-logo" src="/img/fullgqtech.png" alt="Gisselquist Technology, LLC">
  </picture></A>
  </div>

  <div class="site-nav">
<ul>

<li><a HREF="/">Main/Blog</a>


<li><a HREF="/about/">About Us</a>


<li><a HREF="/fpga-hell.html">FPGA Hell</a>


<li><a HREF="/projects.html">Projects</a>


<li><a HREF="/topics.html">Site Topics</a>

<li><a HREF="https://www.patreon.com/ZipCPU">Support this Blog</a>
</ul>
</div>


</header>


    <div class="page-content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">Design Needs when Debugging a SoftCore CPU</h1>
    <p class="post-meta"><time datetime="2017-07-14T00:00:00-04:00" itemprop="datePublished">Jul 14, 2017</time></p>
  </header>

  <div class="post-content" itemprop="articleBody">
    Building your own [soft
core](https://en.wikipedia.org/wiki/Soft_microprocessor)
[CPU](https://en.wikipedia.org/wiki/Central_processing_unit) within an
[FPGA](https://en.wikipedia.org/wiki/Field-programmable_gate_array)
can be a tremendous learning experience.  Doing so will provide you with an
in-depth insight into how a
[CPU](https://en.wikipedia.org/wiki/Central_processing_unit)
works that may be difficult to come by otherwise.

As you consider the requirements of the
[CPU](https://en.wikipedia.org/wiki/Central_processing_unit)
you would like to build, let
me also recommend that you consider what it will take to debug your
[CPU](https://en.wikipedia.org/wiki/Central_processing_unit) early
on.  It might keep you from rebuilding parts and pieces of your
[CPU](https://en.wikipedia.org/wiki/Central_processing_unit) later.

Sure, there's component testing to make sure the components of the
[CPU](https://en.wikipedia.org/wiki/Central_processing_unit) work,
but what will it take to actually debug the
[CPU](https://en.wikipedia.org/wiki/Central_processing_unit)--in
both hardware *and* software?

Let's look at this from two different standpoints.  First, what do you need
to debug a
[CPU](https://en.wikipedia.org/wiki/Central_processing_unit)
in general, and specifically what operations will your debugger
need to be able to perform.  Second, what are the different contexts that you
will need in order to debug your
[CPU](https://en.wikipedia.org/wiki/Central_processing_unit)?

## Debugging needs



If you've ever used a debugger, the debugger typically offers you several things
you can do with your program.

- **Reboot**:  You can start or restart the program.  On an embedded
  [CPU](https://en.wikipedia.org/wiki/Central_processing_unit) that
  doesn't support multiple independent programs, this may mean issuing a
  command to reboot
  [CPU](https://en.wikipedia.org/wiki/Central_processing_unit).

- **Step**: The
  [CPU](https://en.wikipedia.org/wiki/Central_processing_unit)
  will then either start, or start in a stopped state.
  While in this stopped state, you should be able to step your
  [CPU](https://en.wikipedia.org/wiki/Central_processing_unit)
  forward through its instructions.

  This often means something different depending upon context.

- **Stop on Breakpoint**: Stepping through a long list of instructions,
  such as a bootloader loading a program from ROM into RAM, before you get to
  the logic you actually want to debug can be a real drag.  For this reason,
  debuggers offer the capability to set and clear breakpoints within your
  [CPU](https://en.wikipedia.org/wiki/Central_processing_unit).

  The idea is basically this: once a breakpoint is set, the
  [CPU](https://en.wikipedia.org/wiki/Central_processing_unit)
  can be let loose to run.  When the CPU hits the breakpoint, it will halt
  and bring up the debugger for you to examine where it is at.

- **Examine CPU State**: Any time the CPU, or the program the
  [CPU](https://en.wikipedia.org/wiki/Central_processing_unit) is running,
  is stopped, the user should then be able to examine the
  [CPU](https://en.wikipedia.org/wiki/Central_processing_unit)'s state.  This
  may mean examining the
  [registers](https://en.wikipedia.org/wiki/Processor_register)
  of a register based
  [CPU](https://en.wikipedia.org/wiki/Central_processing_unit),
  or the stack of a [stack
  based CPU](https://en.wikipedia.org/wiki/Stack_machine)---perhaps even both.

  For example, on the
  [ZipCPU](/about/zipcpu.html),
  the assembly level debugger brings up a view of all 32
  [ZipCPU](/about/zipcpu.html)
  [registers](https://en.wikipedia.org/wiki/Processor_register),
  and the current instruction sequence (See Figs 1 or 2 below).  One of the
  two debugging views (Fig 2) also shows
  a couple variables on the top of the stack as well.

  When evaluating the
  [CPU](https://en.wikipedia.org/wiki/Central_processing_unit)
  within simulation, you'll also want to see internal
  variables that aren't typically considered an "official" part of the
  [CPU](https://en.wikipedia.org/wiki/Central_processing_unit)
  state, but yet form a part of the state that you need in order to debug it.

- **Continue**: If you've stopped the
  [CPU](https://en.wikipedia.org/wiki/Central_processing_unit),
  you'll also want the ability to
  restart it after you've examined what is going on within the
  [CPU](https://en.wikipedia.org/wiki/Central_processing_unit).

- **Trace**: This isn't normally a considered a debugger capability, and
  probably won't find this support within your typical debugger,
  yet being able to get a trace of what's going on within your
  [CPU](https://en.wikipedia.org/wiki/Central_processing_unit).
  is an important part of fault diagnosis.

  Creating a trace file on a fault is actually my only method of debugging the
  [CPU](https://en.wikipedia.org/wiki/Central_processing_unit)
  when dealing with an interrupt context, simply because it can be *so*
  difficult to predict when an interrupt takes place, or to stop and examine
  the [CPU](https://en.wikipedia.org/wiki/Central_processing_unit)
  on that interrupt along the way.

Your debugging support will need at least one more item of support, and that
item isn't really a debugging *operation*.  Specifically, you'll want some
way of reading the source code your
[CPU](https://en.wikipedia.org/wiki/Central_processing_unit)
is running as you debug your program.  Currently, the
[ZipCPU](/about/zipcpu.html)
has disassembly support and not source level support.
The reason is simply this: it's easier to build an assembly level debugger
than it is to build a source level debugger.

These are the things I've found useful when trying to debug the
[ZipCPU](/about/zipcpu.html).

Keep in mind, this is by no means a comprehensive list of all the tools you
might want or need to debug your
[CPU](https://en.wikipedia.org/wiki/Central_processing_unit).
However, you might find it to be a
sufficient list to get you started--particularly because certain items on
this list will require hardware support, and you may want to think about
this support early in your
[CPU](https://en.wikipedia.org/wiki/Central_processing_unit).
design phase.

## Debugging Contexts

From my own experience, I have found that there are three separate contexts
for debugging a computer program on a
[CPU](https://en.wikipedia.org/wiki/Central_processing_unit).  The
[ZipCPU](/about/zipcpu.html)
supports two of these contexts, and I have plans to support the third.

These are listed below:

1. **Simulator**: The first context you will want to debug your
   [CPU](https://en.wikipedia.org/wiki/Central_processing_unit) within
   is within a simulator.  Sure, the simulator isn't nearly as fast as the
   [FPGA](https://en.wikipedia.org/wiki/Field-programmable_gate_array),
   but within a simulator your debugger should be able to access the
   values of *every* internal variable within your design.


   <TABLE style="float: none"><caption>Fig 1: Debugging ZipCPU under Verilator</caption><TR><TD><IMG SRC="/img/zipdbg-simtest.png" ALT="The ZipCPU debugger under Verilator" width="780"></TD></TR></TABLE>

   The problem I struggled with is that there are only so many characters on the
   screen.  As a result, some of the items on the screen tend to be somewhat
   cryptic.  For example, consider the "PFCACH: v=0000007f" item below
   the user registers.  This tells me that the seven lowest number instruction
   [cache](https://en.wikipedia.org/wiki/Cache_(computing))
   lines are valid.  Cryptic, right?

   Still, even through this view is somewhat cryptic, each item on the screen
   was useful to me (at some time) to learn and know what was going on within
   the [CPU](https://en.wikipedia.org/wiki/Central_processing_unit).
   In particular, these many items were really easy to add to the
   screen when I needed them.

   In spite of the cryptic information within the screen, you can still see
   all of the
   [ZipCPU](/about/zipcpu.html)
   registers: sR0 throught sPC, and uR0 through uPC.  You can
   also see the instructions each of the various stages are working on,
   as well as the fact that each stage is being clocked (Ck on the left).

2. **Hardware**: Once you place
   your [CPU](https://en.wikipedia.org/wiki/Central_processing_unit)
   initially onto a piece of hardware, you'll want access to the
   [CPU](https://en.wikipedia.org/wiki/Central_processing_unit)
   to debug it.  This means that you want to be
   able to support all of your typical debugging actions, enumerated in the
   last section, yet you'll want to be able to invoke those operations from
   an external computer connected to your
   [soft-core](https://en.wikipedia.org/wiki/Soft_microprocessor)
   [CPU](https://en.wikipedia.org/wiki/Central_processing_unit).

   Remember the [debugging bus](https://github.com/ZipCPU/dbgbus) we put
   together?  I use a similar [debugging
   bus](https://github.com/ZipCPU/zbasic/blob/master/rtl/wbubus.v) to debug the
   [ZipCPU](/about/zipcpu.html).

   Of course, some things of necessity will change when you debug things in
   hardware.  Two examples will prove this point: First, you are not likely to
   have access to every wire within your design  when you wish to examine your
   [CPU](https://en.wikipedia.org/wiki/Central_processing_unit)
   state.  For this reason, the
   [ZipCPU](/about/zipcpu.html) debugger,
   [zipdbg](https://github.com/ZipCPU/openarty/blob/master/sw/zipdbg.cpp),
   provides access to all 32-registers within the
   [ZipCPU](/about/zipcpu.html),
   but not all that much more.  Second, your peripherals may not take well to
   stepping them by individual clock ticks.  Hence memory interactions may
   need to be stepped through, one interaction at a time.  For the
   [ZipCPU](/about/zipcpu.html),
   this has meant that the
   [CPU](https://en.wikipedia.org/wiki/Central_processing_unit)
   can only step by single instructions, rather
   than by individual clock ticks, when debugging the
   [CPU](https://en.wikipedia.org/wiki/Central_processing_unit) within the
   hardware.

   <TABLE style="float: none"><caption>Fig 2: Debugging ZipCPU on the Arty</caption><TR><TD><IMG SRC="/img/zipdbg-arty-cputest.png" ALT="The ZipCPU debugger under Verilator" width="780"></TD></TR></TABLE>

3. **Software**: What I mean by the *Software* context is that of a debugger,
   such as [gdb](https://www.gnu.org/software/dbg/), running natively from
   software within your
   [CPU](https://en.wikipedia.org/wiki/Central_processing_unit)
   and applied to debugging another process running on your
   [CPU](https://en.wikipedia.org/wiki/Central_processing_unit).

   While this might take some work to build, it's worth considering when you
   design your processor whether or not you want your processor to eventually
   support this type of capability.

One thing that will throw a thorn in all of these context's, though, is that
you may struggle to know what is happening on or within your
[CPU](https://en.wikipedia.org/wiki/Central_processing_unit) when it
responds to an interrupt.  Sure, there's a way to deal with this, but
interrupts can make debugging via either hardware or software less than
truly realistic.  This is where the capability of creating a full-speed
trace becomes important.


## All together

To wrap this up, Figure 3 (below) places these ideas in a conceptual
graphic, to help draw this discussion to memory.  Notice that all of the
operations we've discussed are shown on the left, and the three separate
contexts are shown across the top.

<TABLE style="float: none"><caption>Fig 3: Debugging Operations and Contexts</caption><TR><TD><IMG SRC="/img/cpu-dbg-needs.svg" ALT="Types of CPU Debugger Support" width="780"></TD></TR></TABLE>

One thing the chart doesn't show is that the columns (contexts) aren't totally
independent.  Before you leave your simulator debugging context, you'll want
to make sure that you have proven that your hardware debugging interface works
within the simulator.  Likewise, before you move from the hardware debugging
context to work on software debugging, you'll want to double check, via either
the hardware or simulator contexts, that the support you've placed within your
[CPU](https://en.wikipedia.org/wiki/Central_processing_unit)
for software debugging actually works.

Perhaps I should mention that this is not my first attempt at putting this
post together.  On my first attempt, I tried to describe how to perform
*every* one of the operations in *every* one of the contexts shown in Fig 3.
The result was too much information for a single post.  For now, just realize
that there's a different story behind each box on the chart, each choice of
context and operation.


  </div>

</article>



      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading">The ZipCPU by Gisselquist Technology</h2>
    
    <em>The entrance of thy words giveth light; it giveth understanding unto the simplle. (Ps 119:130)</em>
    

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <!-- <li></li> -->
          <li><a href="mailto:zipcpu@gmail.com">zipcpu@gmail.com</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="social-media-list">
          
          <li>
            <a href="https://github.com/ZipCPU"><span class="icon icon--github"><svg viewBox="0 0 16 16"><path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/></svg>
</span><span class="username">ZipCPU</span></a>

          </li>
          

          
          <li>
            <a href="https://twitter.com/zipcpu"><span class="icon icon--twitter"><svg viewBox="0 0 16 16"><path fill="#828282" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27 c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767 c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206 C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271 c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469 c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"/></svg>
</span><span class="username">zipcpu</span></a>

          </li>
          
        </ul>
      </div>

      <div class="footer-col footer-col-3">
        <p>The ZipCPU blog, featuring how to discussions of FPGA and CPU design. This site will be focused on Verilog solutions, using exclusively OpenSource IP products for FPGA design.
</p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
