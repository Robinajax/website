<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Debugging a CPU</title>
  <meta name="description" content="This is the story of finding a bug in the [ZipCPU](/about/zipcpu.html).">

  <link rel="shortcut icon" type="image/x-icon" href="/img/GT.ico">
  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://zipcpu.com/zipcpu/2019/02/04/debugging-that-cpu.html">
  <link rel="alternate" type="application/rss+xml" title="The ZipCPU by Gisselquist Technology" href="https://zipcpu.com/feed.xml">
</head>


  <body>

    <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-102570964-1', 'auto');
  ga('send', 'pageview');

</script>

    <header class="site-header">
  <div id="banner">
  <a href="/"><picture>
    <img height=120 id="site-logo" src="/img/fullgqtech.png" alt="Gisselquist Technology, LLC">
  </picture></A>
  </div>

  <div class="site-nav">
<ul>

<li><a HREF="/">Main/Blog</a>


<li><a HREF="/about/">About Us</a>


<li><a HREF="/fpga-hell.html">FPGA Hell</a>


<li><a HREF="/tutorial/">Tutorial</a>


<li><a HREF="/projects.html">Projects</a>


<li><a HREF="/topics.html">Site Index</a>


<li><a href="https://twitter.com/zipcpu"><span class="icon--twitter"><svg viewBox="0 0 400 400"><path fill="#1da1f2" d="M153.62,301.59c94.34,0,145.94-78.16,145.94-145.94,0-2.22,0-4.43-.15-6.63A104.36,104.36,0,0,0,325,122.47a102.38,102.38,0,0,1-29.46,8.07,51.47,51.47,0,0,0,22.55-28.37,102.79,102.79,0,0,1-32.57,12.45,51.34,51.34,0,0,0-87.41,46.78A145.62,145.62,0,0,1,92.4,107.81a51.33,51.33,0,0,0,15.88,68.47A50.91,50.91,0,0,1,85,169.86c0,.21,0,.43,0,.65a51.31,51.31,0,0,0,41.15,50.28,51.21,51.21,0,0,1-23.16.88,51.35,51.35,0,0,0,47.92,35.62,102.92,102.92,0,0,1-63.7,22A104.41,104.41,0,0,1,75,278.55a145.21,145.21,0,0,0,78.62,23"/></svg>
</span><span class="username">@zipcpu</span></a>

<li><a HREF="https://www.patreon.com/ZipCPU"><IMG SRC="/img/patreon_logomark_color_on_white.png" WIDTH="25"> Support</a>
</ul>
</div>


</header>


    <div class="page-content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="https://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">Debugging a CPU</h1>
    <p class="post-meta"><time datetime="2019-02-04T00:00:00-05:00" itemprop="datePublished">Feb 4, 2019</time></p>
  </header>

  <div class="post-content" itemprop="articleBody">
    This is the story of finding a bug in the [ZipCPU](/about/zipcpu.html).

It starts much like any other
[FPGA](https://en.wikipedia.org/wiki/Field-programmable_gate_array)
story: somewhere else.

<TABLE align="center" style="float: right"><CAPTION>Fig 1. Digilent's Arty Board</CAPTION><TR><TD><IMG SRC="/img/arty-board.png" ALT="" WIDTH="360"></TD></TR></TABLE>

Some time ago, [Digilent](https://store.digilentinc.com) replaced the [flash](https://en.wikipedia.org/wiki/Flash_memory)
chip within their
[Arty](https://store.digilentinc.com/arty-a7-artix-7-fpga-development-board-for-makers-and-hobbyists)
[FPGA](https://en.wikipedia.org/wiki/Field-programmable_gate_array) board.
They also created a line of new
[FPGA](https://en.wikipedia.org/wiki/Field-programmable_gate_array)
boards, so my
[Arty](https://store.digilentinc.com/arty-a7-artix-7-fpga-development-board-for-makers-and-hobbyists)
board has now been
rebranded as the
[Arty A7](https://store.digilentinc.com/arty-a7-artix-7-fpga-development-board-for-makers-and-hobbyists).  I never realized there was a difference until
[someone wrote to tell me the design didn't work
anymore](https://github.com/ZipCPU/openarty/issues/2).  With a
[little bit of digging](https://forum.digilentinc.com/topic/16908-arty-a7-flash-chip),
he and I discovered that the [flash](https://en.wikipedia.org/wiki/Flash_memory) chip had changed.  The new [flash](https://en.wikipedia.org/wiki/Flash_memory)
chip wasn't just another chip from the same vendor, it was now from a
different vendor entirely: from
[Micron](https://www.micron.com/~/media/documents/products/data-sheet/nor-flash/serial-nor/n25q/n25q_128mb_3v_65nm.pdf)
to Spansion.

This broke my old [flash controller](https://opencores.org/project/qspiflash).

Not a problem, I thought to my self, I was hoping to write a blog article on
how to build a [Universal Quad SPI flash
controller](https://github.com/ZipCPU/qspiflash/blob/master/rtl/qflexpress.v).
This [new controller](https://github.com/ZipCPU/qspiflash/blob/master/rtl/qflexpress.v) needed to be tested and proven in real hardware.  Let me just place
this [universal
controller](https://github.com/ZipCPU/qspiflash/blob/master/rtl/qflexpress.v)
into my [OpenArty](https://github.com/ZipCPU/openarty) design and then all
shall be well.  Indeed, all shall be better: my [universal Quad SPI flash
controller](https://github.com/ZipCPU/qspiflash/blob/master/rtl/qflexpress.v)
runs at twice the speed.  This will be a nice upgrade!

But what about the differences between the two
[flash](https://en.wikipedia.org/wiki/Flash_memory) chips?  I can use
[AutoFPGA](/zipcpu/2017/10/05/autofpga-intro.html)
to help me select between configurations of this [universal flash
controller](https://github.com/ZipCPU/qspiflash/blob/master/rtl/qflexpress.v).

<TABLE align="center" style="float: left; padding: 15px"><CAPTION>Fig 2. Original OpenArty Design</CAPTION><TR><TD><A HREF="/img/openarty.svg"><IMG SRC="/img/openarty.svg" ALT="" WIDTH="400"></A></TD></TR></TABLE>
The only problem is that the [OpenArty](https://github.com/ZipCPU/openarty)
design wasn't an
[AutoFPGA](/zipcpu/2017/10/05/autofpga-intro.html) design
to begin with.
Ok, that's not really a problem, we can update the
[OpenArty](https://github.com/ZipCPU/openarty) design so that it
uses [AutoFPGA](/zipcpu/2017/10/05/autofpga-intro.html).
That will make it even easier to test my [HyperRAM
controller](https://github.com/ZipCPU/wbhyperram)
as part of my [OpenArty](https://github.com/ZipCPU/openarty) project as well.

The next problem is that the original
[OpenArty](https://github.com/ZipCPU/openarty) design requires an [external
serial port](https://store.digilentinc.com/pmod-usbuart-usb-to-uart-interface/)
in addition to the one on the board.  This may have kept folks from using the
design, and so my newer designs have been multiplexing a console port onto the
serial debugging port.  This is a fairly simple upgrade, so we can do that too.

Further, when I was struggling to get the
[flash controller](https://github.com/ZipCPU/qspiflash/blob/master/rtl/qflexpress.v)
working, I had just had a bad experience with the [ZipCPU](/about/zipcpu.html) on the iCE40s that had
[forced me to change my default linker script(s)](/zipcpu/2018/12/22/autofpga-ld.html).  After a quick upgrade to [AutoFPGA](/zipcpu/2017/10/05/autofpga-intro.html), it now [supports multiple custom
linker scripts](/zipcpu/2018/12/22/autofpga-ld.html),
but that now meant that the
[bootloader](/zipcpu/2018/02/12/zbasic-intro.html)
needed to change as well.

Other things had changed and needed to be updated as well.  For example, the
[ZipCPU](/about/zipcpu.html) had now been
[formally verified](/blog/2017/10/19/formal-intro.html).  I
found a [lot of bugs in that
process](/blog/2018/04/02/formal-cpu-bugs.html) some time ago,
and so I was excited to be updating the design with the new
[formally verified](/blog/2017/10/19/formal-intro.html)
[CPU](/about/zipcpu.html).

In the middle of this, I chose to switch to Vivado 2018.3 from Vivado 2016.3.

Is this starting to sound all too familiar?

Years ago, when I studied Software Engineering, we would call each of these a
["Small matter of Programming" or
SMOP](https://en.wikipedia.org/wiki/Small_matter_of_programming).  This is
said in a tongue-in-cheek fashion, however, because *nothing* is truly ever a
["Small matter of
Programming"](https://en.wikipedia.org/wiki/Small_matter_of_programming).  As
an engineer I also tend to (inappropriately) judge each of these changes to be
small and simple matters.

The result was that, with so many changes, I was threatening to violate the
fundamental assumption of all debugging: "There's only ever one bug in the
design."  Sure, I know, that gets violated all the time, but think about it:
most debugging methodologies can only handle one bug at a time.

So, today's blog post is about the "final" bug in this process, and one I
certainly wasn't expecting.

## Background

We'll pick up the story from the point where I was working on my new [flash
controller](https://github.com/ZipCPU/qspiflash/blob/master/rtl/qflexpress.v).
In my mind, this was the only big thing that had changed in this design:

- [The CPU](/about/zipcpu.html) hadn't significantly changed

 - [It passed its self test](/zipcpu/2018/02/12/zbasic-intro.html)

 - It now passed
   [formal verification](/blog/2017/10/19/formal-intro.html)
   in [many different
   configurations](/zipcpu/2018/12/20/sby-makefile.html).

   This verified instructions up to the input of the
   [ALU](/2017/08/11/simple-alu.html).  [All instructions
   were known to be properly performed, the pipeline timing was known to not
   drop or skip instructions, and for not inserting instructions.  Further,
   the difficult part of making sure memory instructions were not issued
   unless I was willing to commit to them had also been
   verified](/blog/2018/04/02/formal-cpu-bugs.html).

- I had just recently found and fixed the bug that had prevented [the
  CPU](/about/zipcpu.html) from
  starting at an arbitrary address.  [The
  loader](https://github.com/ZipCPU/openarty/blob/master/sw/host/zipload.html)
  could now load a program and start it from any address--not just the reset
  address.

- The [ZipCPU](/about/zipcpu.html)
  simulator is supposed to be able to load any program into the
  [ZipCPU](/about/zipcpu.html),
  bypassing the
  [loader](https://github.com/ZipCPU/openarty/blob/autoarty/sw/host/zipload.cpp).
  This is primarily useful if you want to bypass writing to the
  [flash](https://en.wikipedia.org/wiki/Flash_memory) via the
  [flash driver](https://github.com/ZipCPU/openarty/blob/autoarty/sw/host/flashdrvr.cpp)
  using the cycle-accurate [flash simulator](https://github.com/ZipCPU/blob/autoarty/sim/verilated/flashsim.cpp),
  when you didn't expect a bug in the
  [flash](https://en.wikipedia.org/wiki/Flash_memory) interaction.
  Why wait to program the 
  [flash](https://en.wikipedia.org/wiki/Flash_memory)?
  The only problem was that this simulation loader had a bug in
  it that kept it from starting [ZipCPU](/about/zipcpu.html)
  at any address, restricting it to starting from the reset address only.

  This bug had now been found and fixed, and the "WARNING" statement indicating
  the presence of the bug has been removed.

- [The CPU](/about/zipcpu.html) now has a new
  [data cache](https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/dcache.v)

  This one I knew worked.  I'd also
  [formally verified](/blog/2017/10/19/formal-intro.html)
  it, and ran it through
  [simulations](/blog/2018/08/22/what-is-simulation.html),
  so I could be confident that this worked.  Or ... could I?

- [The CPU](/about/zipcpu.html)
  passed its [Dhrystone](https://en.wikipedia.org/wiki/Dhrystone) tests

I knew [the CPU](/about/zipcpu.html)
was ready.  That was the easy part.

The [AutoFPGA](/zipcpu/2017/10/05/autofpga-intro.html)
updates, those were a bit harder.  I had now switched conventions
regarding how I referenced peripherals.  All peripherals at fixed addresses
now had names starting with an underscore like `_flash`, `_sdram`, `_clrleds`,
and so forth.  These all had to be changed, and so the
[OpenArty](https://github.com/ZipCPU/openarty) [ZipCPU
software](https://github.com/ZipCPU/openarty/tree/master/sw/board) all
needed to be adjusted.

I also wanted to bring up the
[Arty](https://store.digilentinc.com/arty-a7-artix-7-fpga-development-board-for-makers-and-hobbyists)
with fewer capabilities--just to work one by
one through them.  This meant a limited
[AutoFPGA](/zipcpu/2017/10/05/autofpga-intro.html)
build, but it also broke many of the programs that now depended upon
non-existant hardware registers--since they weren't part of the limited
build.  This was easily fixed through the per-component `#define` macros
provided by
[AutoFPGA](/zipcpu/2017/10/05/autofpga-intro.html), but
it still required software to be updated to use those macros.

That brought me to the [new flash
controller](https://github.com/ZipCPU/qspiflash/blob/master/rtl/qflexpress.v).
I knew this [flash
controller](https://github.com/ZipCPU/qspiflash/blob/master/rtl/qflexpress.v)
was ready, but not yet hardware proven.  That was okay, since I was going to
use this opportunity to verify my [new universal QSPI flash
controller](https://github.com/ZipCPU/qspiflash/blob/master/rtl/qflexpress.v)
worked on real hardware, to finish testing the [driver for
it](https://github.com/ZipCPU/openarty/blob/autoarty/sw/host/flashdrvr.cpp)
and to blog about it next.  I just needed to get it working--at 2x the clock
and data speeds.  I expected this to take a bit of work.

Indeed, the [flash
controller](https://github.com/ZipCPU/qspiflash/blob/master/rtl/qflexpress.v)
took a lot of work.  I struggled to [read and understand the timing of
both Xilinx's `IDDR` and `ODDR`
modules](https://www.xilinx.com/support/documentation/user_guides/ug471_7Series_SelectIO.pdf).
I was struggling with things like the
[flash](https://en.wikipedia.org/wiki/Flash_memory) writing properly, but not
reading properly.  Or, perhaps worse, it would read *mostly* properly.  This
killed my
[loader](https://github.com/ZipCPU/openarty/blob/autoarty/sw/host/zipload.cpp),
since I would write the [ZipCPU](/about/zipcpu.html)
program to the [flash](https://en.wikipedia.org/wiki/Flash_memory), and then
attempt to read my data back in order to verify
it was correctly written.  If the reads were only somewhat reliable, then my
[flash driver](https://github.com/ZipCPU/openarty/blob/autoarty/sw/host/flashdrvr.cpp)
would always try to reprogram the
[flash](https://en.wikipedia.org/wiki/Flash_memory).
This reprogramming happened nearly all the time, even when reloading the same
program with the same instructions, indicating that something was broken.

This also left me wondering if
[the CPU](/about/zipcpu.html)
was reading the right program from the
[flash](https://en.wikipedia.org/wiki/Flash_memory).

For a while, I went forward with this "broken"
[flash controller](https://opencores.org/project/qspiflash)
anyway.

I got as far as the
[demonstration program that is designed to demonstrate the Arty's 100MHz MII
ethernet port](https://github.com/ZipCPU/openarty/blob/master/sw/board/simple_ping.c).
[This software](https://github.com/ZipCPU/openarty/blob/master/sw/board/simple_ping.c)
handles [ARP
transactions](https://en.wikipedia.org/wiki/Address_Resolution_Protocol), while
sending [pings](https://en.wikipedia.org/wiki/Internet_Control_Message_Protocol)
to a nearby host.  It's also supposed to be able to respond to a
[pings](https://en.wikipedia.org/wiki/Internet_Control_Message_Protocol)
request.  The program was failing.  For some reason it was locking
up mid-design.

I figured it must be a problem with my [new flash
controller](https://github.com/ZipCPU/qspiflash/blob/master/rtl/qflexpress.v).
Perhaps
[the CPU](/about/zipcpu.html)
was misreading its instructions from the [flash](https://en.wikipedia.org/wiki/Flash_memory).

While this post isn't about the bug in the [flash
controller](https://github.com/ZipCPU/qspiflash/blob/master/rtl/qflexpress.v),
that can wait for a later post, it is important that you understand what was
going on because it sets the background for what follows.  Basically, I was
able to write anything I wanted to the
[flash](https://en.wikipedia.org/wiki/Flash_memory)
without any problems, but reads were unreliable.  It might
be that they were 99.99% reliable and then there would be a bit flipped.  I
figured this could only be a timing problem, and that I was going to need
to write and blog about how to build a synchronization circuit.

In other words, when the [network
program](https://github.com/ZipCPU/openarty/blob/master/sw/board/simple_ping.c)
failed, I had no idea where within the design to look for the problem.

[`MAX BAXTER` from twitter](https://twitter.com/maxslug) suggested
I change the drive strength on the
[flash](https://en.wikipedia.org/wiki/Flash_memory).  The
[Micron](https://www.micron.com/~/media/documents/products/data-sheet/nor-flash/serial-nor/n25q/n25q_128mb_3v_65nm.pdf)
[flash](https://en.wikipedia.org/wiki/Flash_memory) chip has several
control registers, among them are the Extended Volatile configuration register
and the Extended Non-Volatile configuration register.  Both of these registers
can be used to adjust the drive strength in Ohms.  (Drive strength?  Shouldn't
the units of drive strength be Amps and not Ohms?)  The first adjustment I
tried worked, and so my [flash
controller](https://github.com/ZipCPU/qspiflash/blob/master/rtl/qflexpress.v),
was finally working!

So the [network ping
program](https://github.com/ZipCPU/openarty/blob/master/sw/board/simple_ping.c)
should too, right?

Wrong.

Okay, that was my last working hypothesis.  Now what's wrong?

## Symptoms

So let's start by taking stock of this situation.  My goal at this point is to
verify that the [MII Ethernet
controller](https://github.com/ZipCPU/openarty/blob/autoarty/rtl/enetpackets.v)
was fully functional, even after redesigning the top level of the project to
use [AutoFPGA](/zipcpu/2017/10/05/autofpga-intro.html).

- [Flash controller](https://github.com/ZipCPU/qspiflash/blob/master/rtl/qflexpress.v)

  [My new flash controller](https://github.com/ZipCPU/qspiflash/blob/master/rtl/qflexpress.v)
  now worked.  It could read and write the
  [flash](https://en.wikipedia.org/wiki/Flash_memory) at an SPI clock rate
  twice what it was before, and now equal to the system clock rate.
  If I wrote a design to the
  [flash](https://en.wikipedia.org/wiki/Flash_memory) at this point, I could
  read it back at any time to verify the correct design has been written.

  There were now no more differences between the data I wrote to the
  [flash](https://en.wikipedia.org/wiki/Flash_memory) and the data I read
  back out, so I figured there were no more bugs in the [flash
  controller](https://github.com/ZipCPU/qspiflash/blob/master/rtl/qflexpress.v).

<TABLE align="center" style="float: right"><CAPTION>Fig 3. Packet transactions required to get a ping response</CAPTION><TR><TD><IMG SRC="/img/ping.svg" ALT="" WIDTH="240"></TD></TR></TABLE>

- My goal was to test whether or not I could send and receive packets
  via the [Ethernet port](https://en.wikipedia.org/wiki/Ethernet).

  I have a ["manual" approach to sending a packet and receiving a
  packet](https://github.com/ZipCPU/openarty/blob/master/sw/host/manping.cpp).
  This doesn't use the [ZipCPU](/about/zipcpu.html) at all,
  but rather controls the [networking
  device](https://github.com/ZipCPU/openarty/blob/autoarty/rtl/enetpackets.v)
  through the
  [debugging port](/blog/2017/06/16/dbg-bus-forest.html).
  I could even do this via a shell script if I wanted--only it's harder to
  calculate/verify a CRC from a shell script.  Indeed, this [manual ping
  program](https://github.com/ZipCPU/openarty/blob/master/sw/host/manping.cpp)
  was how I originally built and tested the [network
  controller](https://github.com/ZipCPU/openarty/blob/autoarty/rtl/enetpackets.v).

  This [manual approach](https://github.com/ZipCPU/openarty/blob/master/sw/host/manping.cpp)
  isn't very useful for debugging a
  [ping](https://en.wikipedia.org/wiki/Internet_Control_Message_Protocol)
  interaction, though, since a proper
  [ping](https://en.wikipedia.org/wiki/Internet_Control_Message_Protocol)
  exchange requires an [ARP
  request](https://en.wikipedia.org/wiki/Address_Resolution_Protocol), then
  an [ARP response](https://en.wikipedia.org/wiki/Address_Resolution_Protocol),
  followed by sending the [ping packet](https://en.wikipedia.org/wiki/Internet_Control_Message_Protocol)
  itself, as shown in Fig 3 on the right.  The [manual
  approach](https://github.com/ZipCPU/openarty/blob/master/sw/host/manping.cpp)
  sends one packet and then waits until the first response is received.  This
  isn't enough to get a [ping
  response](https://en.wikipedia.org/wiki/Internet_Control_Message_Protocol)
  from my host machine.

  What I really wanted to know, was whether the [ping
  response](https://en.wikipedia.org/wiki/Internet_Control_Message_Protocol)
  was received from my host machine.  Once my desktop/host receives the [ping
  request](https://en.wikipedia.org/wiki/Internet_Control_Message_Protocol)
  from my [Arty](https://store.digilentinc.com/arty-a7-artix-7-fpga-development-board-for-makers-and-hobbyists)
  board, it then needs to send an
  [ARP request](https://en.wikipedia.org/wiki/Address_Resolution_Protocol) to
  my board, get an
  [ARP response](https://en.wikipedia.org/wiki/Address_Resolution_Protocol),
  and then finally return the
  [ping](https://en.wikipedia.org/wiki/Internet_Control_Message_Protocol).

  That's a lot of network transactions that are required just to implement a
  [ping](https://en.wikipedia.org/wiki/Internet_Control_Message_Protocol).

  The good news is that you can debug what goes over the channel using
  [Wireshark](https://www.wireshark.org).  Using
  [Wireshark](https://www.wireshark.org), I discovered ...

  1. That the network wasn't working at all initially.  I traced this down to
     a failure to send the reference clock to the PHY chip in the
     [Arty](https://store.digilentinc.com/arty-a7-artix-7-fpga-development-board-for-makers-and-hobbyists).

  2. That the [MAC address](https://en.wikipedia.org/wiki/MAC_address)
     from my device was being left at zero.  I traced this down to what might
     be a compiler issue.  (I'll need to come back to this, as it's been "fixed"
     but hasn't been fully chased down.)

  3. That my host computer is sending
     [ARP responses](https://en.wikipedia.org/wiki/Address_Resolution_Protocol),
     but that they aren't getting properly
     received.

  These could all be fixed fairly easily, once I realized what was taking place.
  Fixing these issues got me further along, just not quite there.

- Eventually, the [ZipCPU](/about/zipcpu.html) system
  hangs and stops running.

  I could tell this by using [global
  variables](https://en.wikipedia.org/wiki/Global_variable).

  As you may recall, I can [read and write any value within
  my design](/blog/2017/06/29/sw-dbg-interface.html)
  using `wbregs`.  The `wbregs` using in the
  [OpenArty](https://github.com/ZipCPU/openarty) distribution accepts an
  optional parameter telling it where to find a map file defining where all the
  variables are in memory.  The map file itself is generated by the linker,
  so there's no extra work in that part.  As an example, I can read the
  variable `user_heartbeats` by running,

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="gp">% </span>wbregs -m simple_ping.map user_heartbeats</code></pre></figure>

  I knew my program had stopped once this number had stopped incrementing.
  This is also how I can (somewhat) tell what's going on within my design even
  while a program is running, without needing to stop it.

- When the [ZipCPU](/about/zipcpu.html) hung, the
  [debugger](/blog/zipcpu/2017/08/25/hw-debugging.html)
  also failed.  Indeed, if you bring up the
  [debugger](/blog/zipcpu/2017/08/25/hw-debugging.html),
  it hangs waiting for the
  [ZipCPU](/about/zipcpu.html) to respond to it.

  This is disappointing.
  [The CPU](/about/zipcpu.html)
  isn't supposed to work like that.

  During this time, I can reset
  [the CPU](/about/zipcpu.html)
  to get into the
  [debugger](/blog/zipcpu/2017/08/25/hw-debugging.html),
  but doing so causes the system flags and the
  [program counter](https://en.wikipedia.org/wiki/Program_counter)
  to get reset.  Hence, I can't tell if
  [the CPU](/about/zipcpu.html)
  was in [supervisor mode or user
  mode](/zipcpu/2018/01/01/zipcpu-isa.html) when it crashed,
  nor if it was in
  [supervisor mode](/zipcpu/2018/01/01/zipcpu-isa.html)
  could I tell what the [program
  counter](https://en.wikipedia.org/wiki/Program_counter) was set to.

  Looking at the [user
  space](/zipcpu/2018/01/01/zipcpu-isa.html)
  [program counter](https://en.wikipedia.org/wiki/Program_counter)
  suggested that the
  [user space](/zipcpu/2018/01/01/zipcpu-isa.html)
  program always stopped at a compressed instruction.  Had I looked closer,
  I might have noticed that it wasn't always stopping at the same compressed
  instruction and realized the bug.

  I wrote this evidence off as not clear enough to use.

Ever been in this situation?

Now let me ask, how would you approach debugging this issue?

## Examining the tools

Let's take a quick look at the tools we have available to work with to find
this bug.

- Often the first method I turn to when I have a bug like this is "Voodoo
  computing."

  > Defn: Voodoo Computer
  >
  > To change what isn't broken, in an effort to fix what is

  In good voodoo programming fashion, I disabled the
  [data cache](https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/dcache.v).

  It didn't help.

  I tried playing with the [network control port](https://github.com/ZipCPU/blob/autoarty/rtl/enetctrl.v).

  It didn't help either.

  In many ways, most of the on-line forum requests I find, on either Digilent's
  or Xilinx's site, are Voodoo programming requests.  "I don't know what's
  going on, so I changed something I didn't understand, and now my design
  still doesn't work."

  Sure, "Voodoo computing" feels good, but it rarely leads you any closer to
  understanding what is going on within the design.  On the other hand, your
  likelihood of success with Voodoo computer is still better than your
  likelihood of winning the lottery.

- The other end of the spectrum of bug-fixing approaches is to guarantee that
  you never have the bug in the first place.  That's the purpose of both [formal
  verification](/blog/2017/10/19/formal-intro.html) and
  [simulation](/blog/2018/08/22/what-is-simulation.html).

  [My CPU](/about/zipcpu.html)
  [passed both formal
  verification](/blog/2018/04/02/formal-cpu-bugs.html)
  and [simulation](/zipcpu/2018/02/12/zbasic-intro.html),
  but was still failing in this instance.

  Now what?  I went back and double checked the proof of
  [the CPU](/about/zipcpu.html) and the
  network control interface.  They still passed.

  > While you might be able to
  > [simulate](/zipcpu/2018/02/12/zbasic-intro.html)
  > a commercial CPU, it is unlikely that you'll ever be able to
  > get access to the code or formal properties necessary to [formally
  > verify](/blog/2017/10/19/formal-intro.html) one.

- As I mentioned above, the [ZipCPU](/about/zipcpu.html)
  [debugger](/blog/zipcpu/2017/08/25/hw-debugging.html)
  fails

  Normally, I'd try to see what's going on within the
  [debugger](/blog/zipcpu/2017/08/25/hw-debugging.html).
  However, a failing
  [debugger](/blog/zipcpu/2017/08/25/hw-debugging.html)
  doesn't help much.

  > Most commercial CPU's have a debugger you can use.  Sometimes it helps.
  > Often, as in this case, it doesn't since few debuggers can examine a
  > program struggling with interrupt and non-interrupt contexts.

- [Global Variables](https://en.wikipedia.org/wiki/Global_variable)

  My [simple_ping](https://github.com/ZipCPU/openarty/blob/master/sw/board/simple_ping.c)
  program contains a variety of [global
  variables](https://en.wikipedia.org/wiki/Global_variable).

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="kt">unsigned</span>	<span class="n">pkts_received</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">replies_received</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">arp_requests_received</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
  		<span class="n">arp_pkt_count</span> <span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">arp_pkt_invalid</span> <span class="o">=</span><span class="mi">0</span><span class="p">,</span>
  		<span class="n">arp_missed_ip</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">arp_non_broadcast</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
  		<span class="n">ip_pkts_received</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ip_pkts_invalid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
  		<span class="n">icmp_echo_requests</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">icmp_invalid</span><span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
  		<span class="n">ping_reply_address_not_found</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ping_replies_sent</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
  		<span class="n">ping_reply_err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">user_tx_packets</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
  		<span class="n">user_heartbeats</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span></code></pre></figure>

  I do this on purpose.  Each of these particular variables is a
  counter of some type.  I can then use them to see if or when things
  are happening with [the CPU](/about/zipcpu.html) or not.

  By compiling my [simple_ping](https://github.com/ZipCPU/openarty/blob/master/sw/board/simple_ping.c)
  program with the linker flag, `-Wl,-Map=simple_ping.map`, the linker will
  then create a file for me containing the final addresses of all these
  [global variables](https://en.wikipedia.org/wiki/Global_variable).  Indeed,
  this is the very reason why they are
  *[global](https://en.wikipedia.org/wiki/Global_variable)* and not
  *[local](https://en.wikipedia.org/Local_variable)*
  variables: so that they will have a fixed address in memory.

  If you scroll through this map file, you'll find lines looking like,

<figure class="highlight"><pre><code class="language-text" data-lang="text"> .bss           0x000000000700c490       0x68 obj-zip/simple_ping.o
                0x000000000700c490                gbl_picv
                0x000000000700c494                subbeats
                0x000000000700c498                heartbeats
                0x000000000700c49c                pkt_id
                0x000000000700c4a0                router_mac_addr
                0x000000000700c4a8                ping_rx_count
                0x000000000700c4ac                ping_tx_count
                0x000000000700c4b0                ping_mac_addr
                0x000000000700c4b8                user_heartbeats
                0x000000000700c4bc                user_tx_packets
                0x000000000700c4c0                ping_reply_err
                0x000000000700c4c4                ping_replies_sent</code></pre></figure>

  These lines are created as the linker places the
  [simple_ping](https://github.com/ZipCPU/openarty/blob/master/sw/board/simple_ping.c)
  object file into my executable.  At that time, these variables can be found
  within the
  [BSS segment](https://en.wikipedia.org/wiki/.bss).
  Once these values are placed within the final executable, their addresses
  are then given on the left hand side, with the variables names on the right.

  Originally, I would read values from this list by looking up their addresses
  and then reading them with my [`wbregs`
  command](/blog/2017/06/29/sw-dbg-interface.html).
  This command implements a basic [peek/poke
  capability](https://en.wikipedia.org/wiki/PEEK_and_POKE)
  within the design.  The result might look something like:

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="gp">% </span>./wbregs 0x0700c498
0700c498 <span class="o">(</span>  <span class="o">(</span>null<span class="o">))</span> : <span class="o">[</span>....] 00000000</code></pre></figure>

  This would tell me that
  [the CPU](/about/zipcpu.html)
  had never gotten to the `heartbeats++` statement, and so I could
  track down what was taking place across interrupts even--without
  needing to disturb the running [CPU](/about/zipcpu.html).

  In this case, I knew
  [the CPU](/about/zipcpu.html)
  was failing.  These [global
  variables](https://en.wikipedia.org/wiki/Global_variable) gave me a good
  idea of *where* it was failing.  I just had no idea *why* it was failing.

  > This approach would work well with any CPU, commercial or otherwise,
  > as long as your design has some form of
  > [debugging bus](/blog/2017/06/16/dbg-bus-forest.html)
  > within it.

- BREAK statements

  The [ZipCPU](/about/zipcpu.html) supports a
  [break instruction,
  `BREAK`](/zipcpu/2018/01/01/zipcpu-isa.html).
  This `BREAK` instruction takes an optional immediate value, although
  it doesn't do anything different between one immediate value and any
  other.  When
  [the CPU](/about/zipcpu.html)
  encounters a
  [`BREAK` instruction](/zipcpu/2018/01/01/zipcpu-isa.html)
  in [supervisor mode](/zipcpu/2018/01/01/zipcpu-isa.html),
  all processing halts and waits for the
  [debugger](/blog/zipcpu/2017/08/25/hw-debugging.html)
  to rescue it.  If
  [the CPU](/about/zipcpu.html)
  encounters a
  [`BREAK` instruction](/zipcpu/2018/01/01/zipcpu-isa.html)
  in [user mode](/zipcpu/2018/01/01/zipcpu-isa.html),
  you can choose to have the statement halt
  [the CPU](/about/zipcpu.html)
  (the default), or just to return to
  [supervisor mode](/zipcpu/2018/01/01/zipcpu-isa.html).

  A [`BREAK` instruction](/zipcpu/2018/01/01/zipcpu-isa.html)
  can be added to any program by just calling the `zip_break()` function from
  your C/C++ source code.  This function call is treated specially by the
  [ZipCPU](/about/zipcpu.html) GCC back end, which then
  places a [`BREAK`
  instruction](/zipcpu/2018/01/01/zipcpu-isa.html) at that
  point in the instruction stream.

  <TABLE align="center" style="float: right"><CAPTION>Fig 4. Steps to Executing a Break-point</CAPTION><TR><TD><IMG SRC="/img/breakpoint.svg" ALT="" WIDTH="360"></TD></TR></TABLE>

  My intent has always been to [integrate this statement into the
  debugger](/zipcpu/2017/07/14/cpu-debugging-needs.html),
  so that the [debugger can create break points to help debug a
  program](/zipcpu/2017/07/14/cpu-debugging-needs.html).
  The debugger could then replace any user instruction with a `BREAK`
  instruction to create a breakpoint.  In order to continue,
  [the CPU](/about/zipcpu.html)
  would then return the `BREAK` instruction to its original value and then step
  forward by one instruction.  It could then replace the `BREAK`
  instruction so as to re-enable the breakpoint the next time it is seen.
  This is still on my to do list, however.

  Even without [break-point support in the
  debugger](/zipcpu/2017/07/14/cpu-debugging-needs.html),
  break points have been one of my "go-to" approaches to debugging.  If you
  know [the CPU](/about/zipcpu.html) hangs, you can often
  bisect your code with `BREAK` statements to slowly figure out where
  [the CPU](/about/zipcpu.html) hangs.  If it hits the
  breakpoint, then the hang must've occurred after that instruction.

  Because the break points are not (yet) supported by the
  [debugger](/blog/zipcpu/2017/08/25/hw-debugging.html),
  though, you currently need to remove the `BREAK` instruction by recompiling
  your program and reloading it.  It's not pretty, but it works.

  In this case, the `BREAK` instruction stopped
  [the CPU](/about/zipcpu.html)
  long before the problem.  So, it didn't help (much).

  > Many commercial CPUs have break point support as well.  This support
  > is usually integrated into the debuggers, and unavailable from the
  > compiler.  However, debuggers in general tend to struggle to handle
  > designs with interrupt contexts.

- LEDs

  We've discussed [using LEDs for debugging before](/blog/2017/05/19/blinky.html).
  [The CPU](/about/zipcpu.html)
  can set the LEDs to any particular value of interest, and you can then use
  the value of the LED register once
  [the CPU](/about/zipcpu.html)
  hangs to figure out where
  [the CPU](/about/zipcpu.html)
  hung, or in what kind of state it was in.  This is much like the
  [global variables](https://en.wikipedia.org/wiki/Global_variable) approach
  listed earlier, save that LEDs can be used without the
  [debugging bus](/blog/2017/06/29/sw-dbg-interface.html).

  In [one example](https://github.com/ZipCPU/s6soc), I set an LED on entering
  an interrupt routine and cleared it on leaving the routine.  Seeing a dimly
  lit LED was then my indication the design was still running.  In that
  example, when/if the design halted, I could clearly see what state
  [the CPU](/about/zipcpu.html)
  was in at the time.

  For this particular design, the LEDs got me closer.  Indeed, I was
  able to bisect the code down to the loop where it failed.  It just
  wasn't close enough for me to figure out where the bug was coming from.

  > This approach would also work nicely when debugging with any commercial CPU

- [Watchdog timer](https://en.wikipedia.org/wiki/Watchdog_timer)

  I've often been successful debugging a design by using a [watchdog
  timer](https://en.wikipedia.org/wiki/Watchdog_timer).  My [watchdog
  timer](https://en.wikipedia.org/wiki/Watchdog_timer) is essentially
  identical to the [ZipTimer we've discussed
  earlier](/zipcpu/2018/04/17/ziptimer.html), with one
  critical exception: when the timer goes off,
  [the CPU](/about/zipcpu.html)
  is reset.  You can then create a special bootloader to learn something about
  what happened.

  The trick to using the [watchdog timer](https://en.wikipedia.org/wiki/Watchdog_timer) is to sprinkle your code with
  commands to set the [count-down
  timer](/zipcpu/2018/04/17/ziptimer.html)
  to some number greater than zero.  Once the timer reaches zero,
  [the CPU](/about/zipcpu.html)
  resets.  In my case, this meant that
  [the CPU](/about/zipcpu.html)
  would halt, since I had it configured to halt on reset.

  This approach may have been most useful to me when debugging my
  [S6SoC design](https://github.com/ZipCPU/s6soc), where I couldn't fit the
  [debugging bus](/blog/2017/06/29/sw-dbg-interface.html)
  into the design.  Once the [watchdog
  timer](https://en.wikipedia.org/wiki/Watchdog_timer) would go off, [the
  CPU](/about/zipcpu.html) would read out to the
  serial port the values from the internal
  [Wishbone Scope](/blog/2017/07/08/getting-started-with-wbscope.html).
  The [routine to do this was carefully hand-crafted in
  assembly](https://github.com/ZipCPU/s6soc/blob/master/sw/dev/resetdump.s),
  so that I could be sure nothing would over-write any critical portions of
  the previous state.

  I liked that debugging approach so much, that nearly every CPU design I've
  put together since has had a [Wishbone
  Scope](/blog/2017/07/08/getting-started-with-wbscope.html)
  connection within it.

  In this case, the [watchdog
  timer](https://en.wikipedia.org/wiki/Watchdog_timer) felt useful but didn't
  provide me with any of the key information I needed to debug the problem.

  I needed more.

<TABLE align="center" style="float: right"><caption>Fig. 5: Looking back into the past</caption><TR><TD><IMG src="/img/scope-past.svg" ALT="A scope that looks back in time" width="240"></TD></TR></TABLE>

- This brings me back to my [Wishbone
  Scope](/blog/2017/07/08/getting-started-with-wbscope.html).

  As you may remember, the [Wishbone
  Scope](/blog/2017/07/08/getting-started-with-wbscope.html)
  is a [bus](/zipcpu/2017/11/07/wb-formal.html)-based scope.
  [It records any data you send it, and then stops some time following a
  trigger](/blog/2017/06/08/simple-scope.html) after which
  you'll need to read the data out via the
  [bus](/zipcpu/2017/11/07/wb-formal.html).  It
  is not a JTAG scope, such as Xilinx's ILA, but rather a scope that acts more
  like an integrated peripheral to the design.  This means that
  [the CPU](/about/zipcpu.html)
  can configure it as part of any program it might be running.

  The [Wishbone
  Scope](/blog/2017/07/08/getting-started-with-wbscope.html)
  has three big limitations.

  1. First, since it is a [bus](/zipcpu/2017/11/07/wb-formal.html)-based
     [scope](/blog/2017/06/08/simple-scope.html),
     your design needs a working and dependable peripheral
     [bus](/zipcpu/2017/11/07/wb-formal.html)
     within it in order for it to work.

     While the
     [Wishbone scope](/blog/2017/07/08/getting-started-with-wbscope.html).
     was built around the
     [Wishbone bus](/zipcpu/2017/11/07/wb-formal.html)
     [specification](/doc/wbspec_b4.pdf), I have other
     versions for both Avalon and
     [AXI-lite](/formal/2018/12/28/axilite.html) busses.

  2. Second, because it is a
     [bus](/zipcpu/2017/11/07/wb-formal.html)-based
     [scope](/blog/2017/06/08/simple-scope.html),
     it can only capture the width of the data
     [bus](/zipcpu/2017/11/07/wb-formal.html) on every clock
     period.  Since [my busses are all
     32-bits wide](/zipcpu/2017/11/07/wb-formal.html),
     this [scope](/blog/2017/06/08/simple-scope.html)
     will only ever capture 32-bit debugging words at any given time.

     Yes, I keep telling myself that it would be easy to strap two
     [scopes](/blog/2017/06/08/simple-scope.html)
     together, but the reality is that I have never done the software work
     necessary to make that possible.

     But what to capture?  I'd like to capture every time a register is written,
     both the name of the register (5-bits) and the value written to it
     (32-bits).  This busts my 32-bit limit, and I'm not even done with my
     requirements yet.  I'd also like to capture [bus](/zipcpu/2017/11/07/wb-formal.html) requests.  In the case of
     a [bus](/zipcpu/2017/11/07/wb-formal.html) read, I'd like to capture the read address (32-bits) and the
     returned value (32-bits, but on a later clock).  In the case of a write,
     I'd want to capture both the address (32-bits) and data written to the [bus](/zipcpu/2017/11/07/wb-formal.html)
     (another 32-bits).  I'd
     also like to be able to "see" how long it takes the [bus](/zipcpu/2017/11/07/wb-formal.html) to return a value
     (i.e. CYC, STB, WE, STALL, and ACK, or about 5 bits).
     What else?  I'd definitely like to capture any branch targets (32-bits),
     as well as all of the internal pipeline control flags within the
     [the CPU](/about/zipcpu.html).

     It should be pretty obvious that all of this information won't fit within
     a 32-bit word.

     My current solution to this problem is to multiplex several words together
     depending upon the conditions.

     a. If [the CPU](/about/zipcpu.html) is
        halted, set the 32'bits to be the [pipeline control
        signals](/zipcpu/2017/08/23/cpu-pipeline.html).

     b. If a register is written, record which register within
        [the set](/zipcpu/2018/01/01/zipcpu-isa.html),
        and 26-bits of that registers value

        <TABLE align="center" style="float: none"><caption>Fig. 6: Looking back into the past</caption><TR><TD><IMG src="/img/zipcpu-dbg-reg.svg" ALT="Capturing any register writes" width="480"></TD></TR></TABLE>

        Fig 6. above shows the format of this word.  It starts with a `T`
        bit, to indicate if this was the word that triggered the scope.  The
        `0` following identifies this encoding.  It's then followed by 4-bits
        identifying the register, and then 26-bits of the registers value.

     c. Anytime the pipeline is cleared, such as if we are jumping to a new
        address, record the bottom 28 bits of the address.  (Ignore the subword
        address bits, though, since the [ZipCPU](/about/zipcpu.html) can only jump to addresses on
        word boundaries.)

        <TABLE align="center" style="float: none"><caption>Fig. 7: On any jump, record the jump address</caption><TR><TD><IMG src="/img/zipcpu-dbg-branch.svg" ALT="Recording the branch address" width="480"></TD></TR></TABLE>

     d. Otherwise, if there is a memory operation taking place this cycle,
        return 27-bits of the data being written (if it is a write cycle),
        otherwise return 27-bits of the address.

        <TABLE align="center" style="float: none"><caption>Fig. 8: On any memory operation, record either the address or the value</caption><TR><TD><IMG src="/img/zipcpu-dbg-memory.svg" ALT="Recording a memory operation" width="480"></TD></TR></TABLE>

     e. Finally, if all else fails, just record the internal [CPU pipeline
        control signals](/zipcpu/2017/08/23/cpu-pipeline.html).

        These get kind of cluttered, so I'm not going to try to draw them here.
        Feel free to check out how `dbg_flags` are set [within the
        ZipCPU](https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v)
        if you are interested.

     That's four different possibilities, all nearly 32-bits in size.  The
     first couple bits of each of these possibilities, stored in the MSBs,
     are used to decode which of these possibilities was recorded.

     One sad reality, though, is that my [VCD writing
     script](/blog/2017/07/31/vcd.html)
     can't handle non-constant bit-mappings.  In other words, when I need to
     examine the captured data, I'll end up looking at an ad-hoc textual
     ([printf](http://www.cplusplus.com/reference/cstdo/printf/)) output
     describing what's going on.

     It works, but it isn't pretty.

  2. The third limitation with any [internal logic
     analyzer](/blog/2017/06/08/simple-scope.html),
     whether it be a [Wishbone
     Scope](/blog/2017/07/08/getting-started-with-wbscope.html)
     or something else, is that the size of the memory buffer has to
     compete with any other [block
     RAM](/zipcpu/2018/07/13/memories.html)
     requirements within the design.

     In other words, even though the
     [Wishbone Scope](/blog/2017/07/08/getting-started-with-wbscope.html)
     can record values from within any design at the speed of
     [the CPUs](/about/zipcpu.html) clock, it cannot
     do so for very long.  The only way to capture relevant data therefore is
     to use some kind of trigger signal in order to tell us when to
     [stop recording](/blog/2017/06/08/simple-scope.html),
     as I illustrated in Fig. 5 above.

     The other unfortunate consequence of adding a
     [scope](/blog/2017/06/08/simple-scope.html)
     into a design is that you might [need to adjust how much block
     RAM](/zipcpu/2018/02/12/zbasic-intro.html)
     [the CPU](/about/zipcpu.html) has available to it.
     Using [AutoFPGA](/zipcpu/2017/10/05/autofpga-intro.html),
     this is the easy part.  [One value controls the size of the block
     RAM](/zipcpu/2018/02/12/zbasic-intro.html), and
     re-running [AutoFPGA](/zipcpu/2017/10/05/autofpga-intro.html)
     will adjust the address space, adjust the pointer of where the block
     RAM is located that's used by the bootloader, and [build us a new linker
     script](/zipcpu/2018/12/22/autofpga-ld.html)
     to be used when we're using this smaller amount of block RAM.  Then, later,
     when we remove the
     [scope](/blog/2017/06/08/simple-scope.html)
     and change the block RAM usage number back,
     we'll return to our prior/original configuration.

  As with adjusting the block RAM size, the
  [scope](/blog/2017/06/08/simple-scope.html) size can also
  be adjusted by just changing a single number in the
  [scope](/blog/2017/06/08/simple-scope.html)
  [configuration](https://github.com/ZipCPU/openarty/blob/autoarty/autodata/cpuscope.txt).

  Even better, the
  [scope](/blog/2017/06/08/simple-scope.html)
  can be added (or removed) but just adding (or removing) the
  [scope](/blog/2017/06/08/simple-scope.html)'s
  [configuration filename](https://github.com/ZipCPU/openarty/blob/autoarty/master/autodata/cpuscope.txt)
  to/from the
  [AutoFPGA](/zipcpu/2017/10/05/autofpga-intro.html)
  [command line](https://github.com/ZipCPU/openarty/blob/autoarty/master/autodata/Makefile).
  All of the files then depending upon the
  [scope](/blog/2017/06/08/simple-scope.html) can be rebuilt,
  and pre-processor macros will be set so they can be built knowing whether or
  not the [scope](/blog/2017/06/08/simple-scope.html) is
  built into the design or not.

In the end, it was the [wishbone
scope](/blog/2017/07/08/getting-started-with-wbscope.html),
together with [formal
methods](/blog/2017/10/19/formal-intro.html),
that finally helped me find the bug.

To do this, I had to modify the trigger for the
[scope](/blog/2017/06/08/simple-scope.html).  That's the
next part of this story.

Normally, I have [the CPU](/about/zipcpu.html)'s
[scope](/blog/2017/06/08/simple-scope.html) trigger off of
any internal exception that would cause
[the CPU](/about/zipcpu.html) to halt unnaturally.

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">        <span class="k">initial</span> <span class="n">debug_trigger</span> <span class="o">=</span> <span class="mb">1'b0</span><span class="o">;</span>
        <span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
                <span class="n">debug_trigger</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="o">!</span><span class="n">i_halt</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">o_break</span><span class="p">)</span><span class="o">;</span></code></pre></figure>

This wouldn't work in this case, because the whole problem was that
[the CPU](/about/zipcpu.html) hung without properly halting.

So I adjusted my trigger logic.  I chose to count the number of clocks
since the last valid instruction retired.

Within the [ZipCPU](/about/zipcpu.html), any time a
non-memory instruction retires, it sets the `alu_pc_valid` flag.  This tells
[the CPU](https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v)
that the [program counter](https://en.wikipedia.org/wiki/Program_counter)
needs to be updated.  If `alu_pc_valid` isn't true for many cycles, then
we can conclude that [the CPU](/about/zipcpu.html)
must be hanging.

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="c1">// Look for a hang of 2048 cycles
</span>	<span class="kt">reg</span>     <span class="p">[</span><span class="mi">10</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span>  <span class="n">dbg_trigger_counter</span><span class="o">;</span>

        <span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">alu_pc_valid</span><span class="p">)</span>
                <span class="n">dbg_trigger_counter</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">else</span>
                <span class="n">dbg_trigger_counter</span> <span class="o">&lt;=</span> <span class="n">dbg_trigger_counter</span> <span class="o">+</span> <span class="mb">1'b1</span><span class="o">;</span>

        <span class="k">initial</span> <span class="n">debug_trigger</span> <span class="o">=</span> <span class="mb">1'b0</span><span class="o">;</span>
        <span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
                <span class="n">debug_trigger</span> <span class="o">&lt;=</span> <span class="p">((</span><span class="o">!</span><span class="n">i_halt</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">o_break</span><span class="p">))</span>
					<span class="o">||</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dbg_trigger_counter</span><span class="p">)</span><span class="o">;</span></code></pre></figure>

That's the idea.

The problem is that I only want to know when
[the CPU](/about/zipcpu.html) *hangs*.  What if it hasn't
been started in the first place?  What if I stop it in the
[debugger](/blog/zipcpu/2017/08/25/hw-debugging.html)?
What if [the CPU](/about/zipcpu.html)
is in [sleep mode waiting for an
interrupt](/zipcpu/2018/01/01/zipcpu-isa.html)?

I needed to adjust the counter just slightly to avoid these cases.

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">        <span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">alu_pc_valid</span><span class="p">)</span>
                <span class="n">dbg_trigger_counter</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="o">!</span><span class="n">i_halt</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">!</span><span class="n">sleep</span><span class="p">))</span>
                <span class="n">dbg_trigger_counter</span> <span class="o">&lt;=</span> <span class="n">dbg_trigger_counter</span> <span class="o">+</span> <span class="mb">1'b1</span><span class="o">;</span></code></pre></figure>

Now the [scope](/blog/2017/06/08/simple-scope.html) will trigger after 2048 clocks of
[the CPU](/about/zipcpu.html)
not updating the
[program counter](https://en.wikipedia.org/wiki/Program_counter).

But would this trigger on the bug?

## The Trace Result

Yes, the [scope](/blog/2017/06/08/simple-scope.html)
triggered!  The next time I ran
the [simple_ping](https://github.com/ZipCPU/openarty/blob/master/sw/board/simple_ping.c)
program on [the CPU](/about/zipcpu.html) it hung as I hoped
and expected.  As a result, I could check the trace capability and see that,
yes, the [scope](/blog/2017/06/08/simple-scope.html) had
triggered and there was a trace waiting for me.  (Yes, I'm skipping over
writing the software to read from the
[scope](/blog/2017/06/08/simple-scope.html) and to decode
its results--[we've already discussed that
before](/blog/2017/07/08/getting-started-with-wbscope.html).)

Since we are working with text, and not
[VCD files](/blog/2017/07/31/vcd.html), every line shows one
more clock step of what's going on.  The lines will start with the location
within the [scope](/blog/2017/06/08/simple-scope.html)'s
buffer, followed by the 32'bit word located there.  After that, the line
follows a custom ad-hoc decoding script.

<figure class="highlight"><pre><code class="language-text" data-lang="text">     6059 04012512:      R1 &lt;- 0x.0012512
     6060 0c7b3cd9:      R3 &lt;- 0x.07b3cd9
     6061 0c7b3cda:      R3 &lt;- 0x.07b3cda</code></pre></figure>

We'll pick it up at line 6059 out of 8191.  While it can be annoying to page
through thousands of lines of output just looking for the bug, in this case,
the bug was at the bottom of the trace.  Further, once
[the CPU](/about/zipcpu.html)
halted, all the trace words were identical--making it easy to quickly scan
about two pages of information from the bottom of the trace to find the
bug.

At line 6059, the trace looks fairly normal.
[The CPU](/about/zipcpu.html)
simply writes to registers `R1`, then `R3`, and then `R3` again.

Then there is a cycle where nothing is written to the registers.  This is
likely the result of a `CMP` (compare) instruction.  Such an instruction
consumes one clock, but doesn't write to any register values.

<figure class="highlight"><pre><code class="language-text" data-lang="text">     6062 5885b440:      FLAGS 5885b440 CE[DOA ] V[PDO ] MCE</code></pre></figure>

<TABLE align="center" style="float: right"><caption>Fig. 9: Pipeline stages of the ZipCPU</caption><TR><TD><IMG src="/img/zipcpu.svg" ALT="Pipeline steps of the ZipCPU" width="360"></TD></TR></TABLE>

This `FLAGS` response contains a large bit-field.  To help understand it,
I've shown a model of the
[ZipCPU pipeline](/zipcpu/2017/08/23/cpu-pipeline.html) in
Fig. 9 on the right.

I've tried to break out some of the trace fields in the line above.
For example, the `V[*]` section tells me which pipeline stages have [valid
entries within them: the prefetch, decode, and read-operands
stage](/zipcpu/2017/08/23/cpu-pipeline.html).  It also tells
me that the master CE (`MCE`) signal, the signal that controls whether any
instruction transitions from the read operands stage to the execution units,
is high.  Given that we have valid instructions, and `MCE` is high, [the
CPU](/about/zipcpu.html) is running at this trace point.
Finally, the trace line shows me [which pipeline stages are advancing.  These
are the ones with their respective `*_ce` flags
high](/zipcpu/2017/08/23/cpu-pipeline.html).

[As we discussed
before](/zipcpu/2017/08/23/cpu-pipeline.html), the
basic pipeline operation follows as,

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
<span class="k">if</span> <span class="p">(</span><span class="n">clear_pipeline</span><span class="p">)</span>
	<span class="n">stage_valid</span> <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="o">;</span>
<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">stage_ce</span><span class="p">)</span>
	<span class="n">stage_valid</span> <span class="o">&lt;=</span> <span class="n">prior_stage_valid</span><span class="o">;</span>
<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">next_stage_ce</span><span class="p">)</span>
	<span class="n">stage_valid</span> <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="o">;</span>

<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
<span class="k">if</span> <span class="p">(</span><span class="n">stage_ce</span><span class="p">)</span>
<span class="k">begin</span>
	<span class="c1">// Copy data from the previous pipeline
</span>	<span class="c1">// stage to this stage, operating on it as
</span>	<span class="c1">// necessary
</span><span class="k">end</span></code></pre></figure>

If the stage's `CE` line is high, the instruction moves from the previous
stage into the current stage stage.

In this case, instructions will be advancing from the `P`refetch to the
`D`ecode stage, from the `D`ecode stage to the read `O`perands stage, and
from the read `O`perands stage to the `A`LU stage.  That's the meaning of
the cryptic `CE[DOA ]` field.  This is all good: the
[pipeline](/zipcpu/2017/08/23/cpu-pipeline.html) is full,
and [the CPU](/about/zipcpu.html)
is operating normally--it just so happens that it is not writing to any
register values on this cycle.  Again, this is normal.

Following the compare (`CMP`) instruction, there's a
[branch instruction](https://en.wikipedia.org/wiki/Branch_(computer_science)).
This shows up as taking two clocks.  The first one is where the
[program counter](https://en.wikipedia.org/wiki/Program_counter)
is given a new value.  This is the same register write format we discussed
above in Fig. 6.  The second line shows where
[the CPU](/about/zipcpu.html)
actually sets the
[program counter](https://en.wikipedia.org/wiki/Program_counter) and
[clears the pipeline](/zipcpu/2017/08/23/cpu-pipeline.html).
This is the same format we showed in Fig. 7 above.

<figure class="highlight"><pre><code class="language-text" data-lang="text">     6063 3e801814:      PC &lt;- 0x.2801814
     6064 41a00605:      JMP 0x06801814</code></pre></figure>

At this point, we can finally identify where in the program code we are at.
By examining the disassembly of our
[simple_ping](https://github.com/ZipCPU/openarty/blob/master/sw/board/simple_ping.c)
program, we find that we are in a tight loop waiting for a network packet to be
received, or for the seconds-hand on the
[real-time clock](https://github.com/ZipCPU/rtcclock) to advance.

<figure class="highlight"><pre><code class="language-text" data-lang="text">	while(((_netp-&gt;n_rxcmd &amp; ENET_RXAVAIL)==0)
				&amp;&amp;(_rtc-&gt;r_clock == rtc))
			user_heartbeats++;</code></pre></figure>

Here you can see where I set one of those [global
variables](https://en.wikipedia.org/wiki/Global_variable), `user_heartbeats`.
This allowed me to tell, when using the 
[global variable](https://en.wikipedia.org/wiki/Global_variable)
debugging approach, when the program was hung, since this value would stop
changing.

Following the conditional
[branch](https://en.wikipedia.org/wiki/Branch_(computer_science)),
[the CPU](/about/zipcpu.html)
needed to [clear its
pipeline](/zipcpu/2017/08/23/cpu-pipeline.html).  This
required a couple of clock cycles, which are shown in the trace lines below.
As before, the `CE[]` block shows which pipeline stages, `D`ecode, `O`perands,
or `A`LU are accepting data, whereas the `V`alid block shows which stages
actually have valid instructions within them.  Hence, we are now watching
a new instruction stream move into the
[pipeline](/zipcpu/2017/08/23/cpu-pipeline.html).
The first of these new instructions will eventually write to the `R2` register,
as shown below.

<figure class="highlight"><pre><code class="language-text" data-lang="text">     6065 58810000:      FLAGS 58810000 CE[D   ] V[    ] MCE
     6066 58850000:      FLAGS 58850000 CE[D   ] V[P   ] MCE
     6067 5885a000:      FLAGS 5885a000 CE[DO  ] V[PD  ] MCE
     6068 5885b400:      FLAGS 5885b400 CE[DOA ] V[PDO ] MCE
     6069 087b3cda:      R2 &lt;- 0x.07b3cda</code></pre></figure>

The next instruction is a
[load word instruction](/zipcpu/2018/01/01/zipcpu-isa.html).
This instruction issues a
[bus](/zipcpu/2017/11/07/wb-formal.html)
transaction to read from location `0x03800000` in memory.

<figure class="highlight"><pre><code class="language-text" data-lang="text">     6070 70e00000:      MEM-R[0x.3800000] -&gt; (Not Givn) (GBL)</code></pre></figure>

While the [scope](/blog/2017/06/08/simple-scope.html)
hasn't captured all 32-bits of that address, I can infer it from the fact
that my design doesn't have more than 27-bits of address space,
and so the number of bits is sufficient.

This read polls the [network
interface](https://github.com/ZipCPU/openarty/blob/autoarty/rtl/enetpackets.v),
to query if any packets have been read.

The `(GBL)` flag indicates that this read is from the global address space,
rather than the processor's local peripheral address space.

As you might imagine, reading a value from the
[bus](/zipcpu/2017/11/07/wb-formal.html) stalls the
processor.  While there are waiting instructions in the prefetch, decode,
and read operands stages, nothing moves forward until this result comes
back--lest [the CPU](/about/zipcpu.html) need to undo and
re-perform any instructions.  (The
[ZipCPU](/about/zipcpu.html) is not an
"[out-of-order](https://en.wikipedia.org/wiki/Out-of-order_execution)"
machine.)

<figure class="highlight"><pre><code class="language-text" data-lang="text">     6071 5884d00c:      FLAGS 5884d00c CE[    ] V[PDO ] MCE DCD-STALL MEM-BUSY</code></pre></figure>

While it is waiting, we get another flags trace line.  In this case, we can see
that the memory unit is busy, `MEM-BUSY`.  `DCD-STALL` is an indication that
there is an instruction in the decode stage of our
[pipeline](/zipcpu/2017/08/23/cpu-pipeline.html)
that is stalled.  We'll come back to this later.

The memory instruction takes about five clock cycles.  During this
time, nothing changes within [the CPU](/about/zipcpu.html),
and so the [wishbone
scope](/blog/2017/07/08/getting-started-with-wbscope.html)
[control program](https://github.com/ZipCPU/openarty/blob/autoarty/sw/host/cpuscope.cpp)
outputs the line `**** ****` so we can tell that nothing is changing.

Once the memory read operation is complete, the result is written to `R1`.

<figure class="highlight"><pre><code class="language-text" data-lang="text"> **** ****
     6076 04020000:      R1 &lt;- 0x.0020000</code></pre></figure>

So far this all looks good.  We haven't hit the bug yet.

[The CPU](/about/zipcpu.html)
then issues an
[AND instruction](/zipcpu/2018/01/01/zipcpu-isa.html),
to check whether or not the [network
interface](https://github.com/ZipCPU/openarty/blob/autoarty/rtl/enetpackets.v)
has received any packets.
The result of this instruction is zero: there are no pending packets waiting.

<figure class="highlight"><pre><code class="language-text" data-lang="text">     6077 04000000:      R1 &lt;- 0x.0000000</code></pre></figure>

Based upon the zero flag, we then hit a conditional
[branch](https://en.wikipedia.org/wiki/Branch_(computer_science)),
and so we need to clear and load the
[pipeline](/zipcpu/2017/08/23/cpu-pipeline.html) again.

<figure class="highlight"><pre><code class="language-text" data-lang="text">     6078 3e80182c:      PC &lt;- 0x.280182c
     6079 41a0060b:      JMP 0x0680182c
     6080 58810000:      FLAGS 58810000 CE[D   ] V[    ] MCE
     6081 58850000:      FLAGS 58850000 CE[D   ] V[P   ] MCE
     6082 5885a000:      FLAGS 5885a000 CE[DO  ] V[PD  ] MCE
     6083 5885b020:      FLAGS 5885b020 CE[DO M] V[PDO ] MCE</code></pre></figure>

This time, we're going to read from address `0x05800060`: the
[real-time clock](https://github.com/ZipCPU/rtcclock) register.

<figure class="highlight"><pre><code class="language-text" data-lang="text">     6084 71600018:      MEM-R[0x.5800060] -&gt; (Not Givn) (GBL)
     6085 5884d00c:      FLAGS 5884d00c CE[    ] V[PDO ] MCE DCD-STALL MEM-BUSY
 **** ****
     6090 04012512:      R1 &lt;- 0x.0012512</code></pre></figure>

The result, `0x012512`, from the
[clock](https://github.com/ZipCPU/rtcclock)
is in [Binary Coded Decimal, or
BCD](https://en.wikipedia.org/wiki/Binary-coded_decomal).  You might
read it as `1:25:12`.  It indicates that it has now been one hour, twenty five
minutes, and twelve seconds since this design was initially loaded.  (No,
I never set the clock to real time--I was more focused on debugging all
this time.)

Again, so far this looks normal.

Then something different happens.  The trace ends.

<figure class="highlight"><pre><code class="language-text" data-lang="text">     6091 5884d000:      FLAGS 5884d000 CE[    ] V[PDO ] MCE DCD-STALL
 **** ****
     8127 d884d000: TRIG FLAGS d884d000 CE[    ] V[PDO ] MCE DCD-STALL &lt;--- TRIGGER
     8128 5884d000:      FLAGS 5884d000 CE[    ] V[PDO ] MCE DCD-STALL
 **** ****
     8191 5884d000:      FLAGS 5884d000 CE[    ] V[PDO ] MCE DCD-STALL</code></pre></figure>

Notice the trace location values: 6091, 8127, 8128, and then 8191.  These are
key.  `6091` is expected--that's the next clock cycle.  `8127` is unexpected.
That means that we just spent 2036 cycles *doing nothing*.

Wait, I thought we set
[the CPU](/about/zipcpu.html)
to count 2048 cycles before setting the trigger on our
[scope](/blog/2017/06/08/simple-scope.html)?
How did the count end up at 2036?

It ended up at 2036 because we only counted
[ALU](/2017/08/11/simple-alu.html)
results, not results from the memory unit.  Our last valid
[ALU](/2017/08/11/simple-alu.html)
result was on cycle 6078, we we're still good here.

Or rather, we're not good here:
[the CPU](/about/zipcpu.html)
just stopped.

The good news is that we know what instruction we were executing.  If you run
`objdump` on our executable, you can see an assembly listing showing the
instruction we just completed, and the context around it.  To generate a
listing, just type,

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="gp">% </span>zip-objdump -S -D simple_ping &gt; simple_ping.txt</code></pre></figure>

Indeed, I find listings of this type so valuable when debugging, that I have a
special [make](https://www.gnu.org/software/make) target just to create
listings.  The target looks like:

<figure class="highlight"><pre><code class="language-make" data-lang="make"><span class="nl">%.txt</span><span class="o">:</span> <span class="nf">%</span>
	<span class="nv">$(OBJDUMP)</span><span class="err"> -S -D $^ &gt; $@</span></code></pre></figure>

This will get turned into the command above any time I type

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="gp">% </span>make simple_ping.txt</code></pre></figure>

[Make](https://www.gnu.org/software/make) is smart enough to recognize, when I
type this, that if the source code for `simple_ping` has changed then it needs
to be rebuilt before dumping the assembly to `simple_ping.txt`.

Sadly, I've recompiled this routine since capturing my trace.  As a result,
the assembly below that matches the loop in question doesn't quite match
the trace.  Still, this was roughly the instruction we halted on.

<figure class="highlight"><pre><code class="language-text" data-lang="text"> 7001808:	84 a8 97 88 	LW         (R5),R0        | MOV        R1,R2</code></pre></figure>

The critical piece of this disassembly is that we were trying to execute a
two-instruction word, containing both a [load word
instruction (`LW`)](/zipcpu/2018/01/01/zipcpu-isa.html)
followed by a [register copy
(`MOV`) instruction](/zipcpu/2018/01/01/zipcpu-isa.html).
([ZipCPU](/about/zipcpu.html)
[assembly](/zipcpu/2018/01/01/zipcpu-isa.html)
reads left to right, hence the `MOV` instruction copies `R1` into `R2`.)

<TABLE align="center" style="float: right"><caption>Fig. 10: ZipCPU ISA Quick Reference Sheet</caption><TR><TD><A HREF="https://github.com/ZipCPU/zipcpu/raw/master/doc/nextgen.png"><IMG src="https://github.com/ZipCPU/zipcpu/raw/master/doc/nextgen.png" ALT="" width="360"></A></TD></TR></TABLE>

When I introduced the [ZipCPU
ISA](/zipcpu/2018/01/01/zipcpu-isa.html),
I didn't say much about compressed instructions.  Now, however, you need
to know a little bit about them to know what's going on.  Fig. 10 at the right
shows my quick reference sheet of
[ZipCPU](/about/zipcpu.html)
instructions.  The first line shows the basic format of most instructions.
The second line shows the format of a compressed instruction.  It starts with
a `1` in the MSB, followed by fifteen bits containing the first instruction,
an unused bit, then fifteen bits containing the second instruction.  The
opcodes for these compressed instructions are shown in the top half of the
third column: `SUB`, `AND`, `ADD`, `CMP`, `LW`, `SW`, `LDI`, and `MOV`.

[ZipCPU](/about/zipcpu.html) compressed instructions are
a little different from other architectures, because you cannot jump halfway
into a word.  All instruction words, whether compressed or not, are all word
aligned.  The assembler handles the compression, making certain for example that
[branch](https://en.wikipedia.org/wiki/Branch_(computer_science))
targets never get compressed into the middle of a compressed instruction word.

Further, the 
[ZipCPU](/about/zipcpu.html) disassembler displays both
instructions within a compressed instruction word on the same line, using
a `|` to separate them--as shown above.

This will all come into play in a moment.

From the trace we know that we executed the `LW` instruction, but that the
`MOV` instruction never made it into the execution unit(s).

Why not?  What happened?

## Moving from trace to bug

When I finally got to this point, I had no idea why
[the CPU](/about/zipcpu.html)
might stall like that.

Yes, it is
[my CPU](/about/zipcpu.html).  Yes, I did write [the code
for it](https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v).  Yes,
the [stall logic](/zipcpu/2017/08/23/cpu-pipeline.html)
is all my own handiwork.  Yes, I did just create this trace.  However,
when a design gets over 2500 lines, when you wrote it years ago, when
it has multiple options it can be built with ...  it can become difficult
to remember all the details.  Worse, even if you do remember them, do
you know why this happened?

So I turned to
[formal methods](/blog/2017/10/19/formal-intro.html).

Instead of proving that [the CPU](/about/zipcpu.html)
"worked", I wanted to prove that [the CPU](/about/zipcpu.html)
would never stall like this.  Hence, I wanted to say that: if there's an
instruction in the read-operands stage,
[the CPU](/about/zipcpu.html)
should always proceed to the
[execution stage](/2017/08/11/simple-alu.html).

So how might we write such an assertion?

Well, if there's a valid instruction in the read-operands stage, then it should
proceed to the execution stage, right?

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">op_valid</span><span class="p">)</span>
		<span class="k">assert</span><span class="p">(</span><span class="n">adf_ce_unconditional</span> <span class="o">|</span> <span class="n">mem_ce</span><span class="p">)</span><span class="o">;</span></code></pre></figure>

Here `adf_ce_unconditional` says the instruction will move forward into the
`ALU`, `DIV`ide or (not-yet-written) `FPU` (floating point unit), whereas
`mem_ce` says the instruction will move into the memory unit.

Only, that's not quite right.  We don't want to move forward if the
[debugging unit](/blog/zipcpu/2017/08/25/hw-debugging.html)
has requested that we halt.  In that case, `master_ce` will be low.
We also don't want to move forward on a reset, or anytime the
[pipeline](/zipcpu/2017/08/23/cpu-pipeline.html)
is cleared.  Further, we don't want to move to the execution stage
if any of the execution units is busy and its result might affect one
of our operands.

So, let's adjust our assertion.

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">op_valid</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">master_ce</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">!</span><span class="n">clear_pipeline</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">!</span><span class="n">i_reset</span><span class="p">)</span>
		<span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">!</span><span class="n">div_busy</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">!</span><span class="n">div_valid</span><span class="p">)</span>
		<span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">!</span><span class="n">mem_busy</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">!</span><span class="n">mem_valid</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">!</span><span class="n">bus_err</span><span class="p">)</span>
		<span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">!</span><span class="n">alu_busy</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">!</span><span class="n">alu_pc_valid</span><span class="p">)</span>
		<span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">!</span><span class="n">fpu_busy</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">!</span><span class="n">fpu_valid</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">!</span><span class="n">fpu_error</span><span class="p">))</span>
		<span class="k">assert</span><span class="p">(</span><span class="n">adf_ce_unconditional</span> <span class="o">|</span> <span class="n">mem_ce</span><span class="p">)</span><span class="o">;</span></code></pre></figure>

This assertion fails.

It has?  Aha!  Have I found my bug?

I pulled up the trace to look.  This time, it's a
[VCD file](/blog/2017/07/31/vcd.html)
created by [SymbiYosys](https://symbiyosys.readthedocs.io/en).  No, this
assertion hasn't found the bug.  Instead, all I found were examples of
other reasons why the instruction shouldn't move forward.

The execution units shouldn't accept any more instructions if ...

- If this is a `BREAK` instruction, `op_break`, the pipeline needs to stop just
  before the instruction gets to the execution unit.

- If [the CPU](/about/zipcpu.html)
  has halted on an error, `o_break` will be true and we'll need to
  make sure we are halted.

- If we just retired an illegal instruction, we need to halt.  Similarly, if
  the last memory instruction returned a bus error then we need to halt as
  well.

- If there's an interrupt pending or a trap was just executed,
  `w_switch_to_interrupt` will be true and we'll need to switch to
  [supervisor mode](/zipcpu/2018/01/01/zipcpu-isa.html).
  In this case, the instruction in the read operands stage won't move forward
  into any of the execution units either.

The list goes on.  In the end, I was surprised at how long it was.

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">op_valid</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">master_ce</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">!</span><span class="n">clear_pipeline</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">!</span><span class="n">i_reset</span><span class="p">)</span>
		<span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">!</span><span class="n">div_busy</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">!</span><span class="n">div_valid</span><span class="p">)</span>
		<span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">!</span><span class="n">mem_busy</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">!</span><span class="n">mem_valid</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">!</span><span class="n">bus_err</span><span class="p">)</span>
		<span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">!</span><span class="n">alu_busy</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">!</span><span class="n">alu_pc_valid</span><span class="p">)</span>
		<span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">!</span><span class="n">fpu_busy</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">!</span><span class="n">fpu_valid</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">!</span><span class="n">fpu_error</span><span class="p">)</span>
		<span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">!</span><span class="n">op_break</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">!</span><span class="n">o_break</span><span class="p">)</span>
		<span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">!</span><span class="n">w_switch_to_interrupt</span><span class="p">)</span>
		<span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">!</span><span class="n">alu_illegal</span><span class="p">)</span>
		<span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">!</span><span class="n">ibus_err_flag</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">!</span><span class="n">ill_err_i</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">!</span><span class="n">idiv_err_flag</span><span class="p">))</span>
		<span class="k">assert</span><span class="p">(</span><span class="n">adf_ce_unconditional</span> <span class="o">|</span> <span class="n">mem_ce</span><span class="p">)</span><span class="o">;</span></code></pre></figure>

At this point, however,
[SymbiYosys](https://symbiyosys.readthedocs.io/en)
had found my bug for me.

The problem was specific to the compressed instruction word.  In the
[ZipCPU](/about/zipcpu.html)
[ISA](/zipcpu/2018/01/01/zipcpu-isa.html),
two instruction words may optionally be packed into one, and the
[ZipCPU](/about/zipcpu.html) has no ability
to restart any instructions mid-word (currently).  I may need to come back
and "fix" this later, but the approach was chosen to simplify the
instruction decoder: all instruction words start on word boundaries, some
instruction words contain two instructions.

This was why the
[debugger](/blog/zipcpu/2017/08/25/hw-debugging.html) failed:
it had to wait for the second part of the compressed instruction word to
complete before
[the CPU](/about/zipcpu.html)
would halt, since there is (currently) no way to restart
[the CPU](/about/zipcpu.html)
mid-instruction word.

This also means that I cannot jump into an interrupt mid-word.
The internal flag, `w_switch_to_interrupt` properly captures this logic.
The stall signal, however, did not.  That meant that any time the interrupt
signal went high in the middle of a two-instruction word, the interrupt logic
would wait for the second instruction to complete while the stall logic would
prevent the second instruction from starting.

The conflicting logic lead to the [deadlock](https://en.wikipedia.org/wiki/Deadlock) causing
[the CPU](/about/zipcpu.html)
to hang.

The fix was simple: add a check to the stall logic so that we only stall
if an interrupt is pending *and* we are on a single-instruction word or the
second instruction of a double-instruction word.

Once fixed, my
[network ping program](https://github.com/ZipCPU/openarty/blob/master/sw/board/simple_ping.c)
worked as intended again.

## Wasn't the CPU Formally Verified?

Some time ago, I wrote about [all of the bugs I found when formally verifying
this CPU](/blog/2018/04/02/formal-cpu-bugs.html).
I even went to [ORCONF 2018 to discuss all of the lessons I learned
while going through this process](https://www.youtube.com/watch?v=7DHV_rJKSgo).

Shouldn't
[formal verification](/blog/2017/10/19/formal-intro.html)
have caught this bug?

Yes, I suppose it should have.

Why didn't it?

Because I never created a property asserting that
[the CPU](/about/zipcpu.html)
would never stall indefinitely.

I've now gone back to the proof and added a similar property to ensure that
[the CPU](/about/zipcpu.html)
will never stall in the decode stage either.

This wasn't the first time I found a bug in my now
[formally verified](/blog/2018/04/02/formal-cpu-bugs.html)
[CPU](/about/zipcpu.html).
The first time was when I tried setting the [program
counter](https://en.wikipedia.org/wiki/Program_counter) from the
[debugging port](/blog/zipcpu/2017/08/25/hw-debugging.html).
You may recall, I mentioned fixing this bug above.  This oversight happened
for the same reason: My initial set of formal properties was incomplete.

[The CPU](/about/zipcpu.html) now has a set of debugging
interface properties, "proving" that the
[debugger](/blog/zipcpu/2017/08/25/hw-debugging.html)
can set and adjust the [CPU](/about/zipcpu.html)'s state.

## What about simulation?

What about
[simulation](/blog/2018/08/22/what-is-simulation.html)?
Could this bug have been caught during
[simulation](/blog/2018/08/22/what-is-simulation.html)?
Why wasn't it?

I suppose this bug could have been caught in
[simulation](/blog/2018/08/22/what-is-simulation.html).

However, my current network packet simulator implements a loop-back mode only.
This isn't sufficient for testing the complex interaction of
[ARP requests](https://en.wikipedia.org/wiki/Address_Resolution_Protocol),
[ARP replies](https://en.wikipedia.org/wiki/Address_Resolution_Protocol),
and [ping requests and
replies](https://en.wikipedia.org/wiki/Internet_Control_Message_Protocol).

An online friend has recommended I try building a network simulator that
integrates into the Linux Kernel, so that other computers can actually interact
with my design while it is running in the simulator.  This would be a truly
awesome idea, and might well have caught this bug.  I might just need to update
my network simulation for this purpose.

## Conclusions

So what are some of the lessons we can learn from this whole exercise?

First, your current bug may not be in the last place you looked.  I had just
worked on the [flash controller](https://opencores.org/project/qspiflash).
Mentally, my mind was in a bug hunting mode within the
[flash controller](https://opencores.org/project/qspiflash).
Instead, the bug was somewhere else within my design--somewhere where I least
expected it.

Second, the more things you change within a design, the more painful it is
to find and fix the bugs within it.  In many ways, I set myself up for problems
with the shear number of things I had changed to get here.  Understand, just
because I presented one or two of these problems above, doesn't mean that these
were the only problems I had.

Third, did you notice how many tools I was using to debug the design?
Besides the tools for debugging [the CPU](/about/zipcpu.html)
listed above, I was also using [Wireshark](https://www.wireshark.org)
for debugging
[the network](https://en.wikipedia.org/wiki/Ethernet) as well.

Finally, [debugging a
CPU](/blog/zipcpu/2017/08/25/hw-debugging.html)
really crosses several disciplines.  While this is a "hardware" task,
look at what we needed to do in terms of support software along the way:
We needed a [debugging
port](/blog/zipcpu/2017/08/25/hw-debugging.html) to
[the CPU](/about/zipcpu.html)
(S/W+H/W), a [scope](/blog/2017/06/08/simple-scope.html) to
gather a trace from within [the CPU](/about/zipcpu.html)
(H/W), software to interpret that trace (S/W), a disassembly of the failing
program (compiler S/W), an understanding of the
[ZipCPU](/about/zipcpu.html) [instruction set (assembly
S/W)](/zipcpu/2018/01/01/zipcpu-isa.html),
and finally [formal
methods](/blog/2017/10/19/formal-intro.html)
to finally catch the bug in the end.

That's quite the cross-disciplinary task!

This also means that, if you are interested in learning hardware design, there
are several prerequisites before you dive into CPU design.  The other way of
looking at it is that CPU design is a wonderful field of study where you will
be forced to learn all kinds of details of how CPUs work that you would never
learn otherwise.

  </div>


<div class "verse">
<HR align="center;" width="25%">
<P><em>And he informed me, and talked with me, and said, O Daniel, I am now come forth to give thee skill and understanding.</em>


</article>

      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading">The ZipCPU by Gisselquist Technology</h2>
    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <!-- <li></li> -->
          <li><a href="mailto:zipcpu@gmail.com">zipcpu@gmail.com</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="soc-medlist">
          
          <li>
            <a href="https://github.com/ZipCPU"><span class="icon icon--github"><svg viewBox="0 0 16 16"><path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/></svg>
</span><span class="username">ZipCPU</span></a>

          </li>
          

          
          <li>
            <a href="https://twitter.com/zipcpu"><span class="icon icon--twitter"><svg viewBox="0 0 16 16"><path fill="#828282" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27 c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767 c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206 C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271 c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469 c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"/></svg>
</span><span class="username">@zipcpu</span></a>

          </li>
          
          
          <li><A href="https://www.patreon.com/ZipCPU"><img src="/img/become_a_patron_button.png"></a></li>
          

        </ul>
      </div>

      <div class="footer-col footer-col-3">
        <p>The ZipCPU blog, featuring how to discussions of FPGA and soft-core CPU design.  This site will be focused on Verilog solutions, using exclusively OpenSource IP products for FPGA design.  Particular focus areas include topics often left out of more mainstream FPGA design courses such as how to debug an FPGA design.
</p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
