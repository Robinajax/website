<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Want to use ZBasic?  Let's have some fun--no actual FPGA required!</title>
  <meta name="description" content="Now that[you've seen](/zipcpu/2018/01/31/cpu-build.html) the[ZipCPU](/about/zipcpu.html) by itself, and now that [you'vebuilt its tool chain](/zipcpu/2018/01...">

  <link rel="shortcut icon" type="image/x-icon" href="/img/GT.ico">
  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="http://zipcpu.com/zipcpu/2018/02/12/zbasic-intro.html">
  <link rel="alternate" type="application/rss+xml" title="The ZipCPU by Gisselquist Technology" href="http://zipcpu.com/feed.xml">
</head>


  <body>

    <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-102570964-1', 'auto');
  ga('send', 'pageview');

</script>

    <header class="site-header">
  <div id="banner">
  <a href="/"><picture>
    <img height=120 id="site-logo" src="/img/fullgqtech.png" alt="Gisselquist Technology, LLC">
  </picture></A>
  </div>

  <div class="site-nav">
<ul>

<li><a HREF="/">Main/Blog</a>


<li><a HREF="/about/">About Us</a>


<li><a HREF="/fpga-hell.html">FPGA Hell</a>


<li><a HREF="/projects.html">Projects</a>


<li><a HREF="/topics.html">Site Index</a>

<li><a HREF="https://www.patreon.com/ZipCPU"><IMG SRC="/img/patreon_logomark_color_on_white.png" WIDTH="25"> Support</a>
</ul>
</div>


</header>


    <div class="page-content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">Want to use ZBasic?  Let's have some fun--no actual FPGA required!</h1>
    <p class="post-meta"><time datetime="2018-02-12T00:00:00-05:00" itemprop="datePublished">Feb 12, 2018</time></p>
  </header>

  <div class="post-content" itemprop="articleBody">
    Now that
[you've seen](/zipcpu/2018/01/31/cpu-build.html) the
[ZipCPU](/about/zipcpu.html) by itself, and now that [you've
built its tool chain](/zipcpu/2018/01/31/cpu-build.html),
let's look at together at what you can do with the
[ZipCPU](/about/zipcpu.html)
as part of a larger design:
[ZBasic](https://github.com/ZipCPU/zbasic).
Today, I'd like to show you how to run the
[ZBasic](https://github.com/ZipCPU/zbasic)
design within a
[Verilator](https://www.veripool.org/wiki/verilator)-based
simulation environment--one that simulates
a [QSPI flash](https://www.opencores.org/project,wbqspiflash), a
[serial port](https://github.com/ZipCPU/wbuart32), and even
(optionally) an
[SD-Card](https://github.com/ZipCPU/sdspi/blob/master/bench/cpp/sdspisim.cpp).
If all goes well, we'll run the
[ZipCPU](/about/zipcpu.html)'s
[CPU-Test program](https://github.com/ZipCPU/zbasic/blob/master/sw/board/cputest.c),
and then even play
[4x4x4 Tic-tac-toe](https://github.com/ZipCPU/tttt).

But first, let's start with a little history.

## Why ZBasic?

When I first started out with the
[ZipCPU](/about/zipcpu.html),
my goal was to demonstrate it on a cheap hobbyist board.  After my first
development, on a [Digilent](https://store.digilentinc.com)
[Basys-3](https://store.digilentinc.com/basys-3-artix-7-fpga-trainer-board-recommended-for-introductory-users),
I then built demonstrations for an
[Xess.com](http://www.xess.com)
[XuLA2-LX25 board](http://www.xess.com/shop/product/xula2-lx25),
and then the
[Digilent](https://store.digilentinc.com)
[CMod S6](https://store.digilentinc.com/cmod-s6-breadboardable-spartan-6-fpga-module), the
[Arty](https://store.digilentinc.com/arty-artix-7-fpga-development-board-for-makers-and-hobbyists),
and most recently
[Nexys Video](https://store.digilentinc.com/nexys-video-artix-7-fpga-trainer-board-for-multimedia-applications)
boards.
You can still find most of these builds on-line in the
[XuLALX25SoC](https://github.com/ZipCPU/xulalx25soc),
[S6SoC](https://github.com/ZipCPU/s6soc),
[OpenArty](https://github.com/ZipCPU/openarty), and
[VideoZip](https://github.com/ZipCPU/videozip) repositories.  Indeed, my
[main Github page](https://github.com/ZipCPU) still highlights the
[OpenArty](https://github.com/ZipCPU/openarty) project.
Many of these boards are peripheral rich, and even for those that aren't I
purchased peripherals (mostly from
[Digilent](https://store.digilentinc.com)) to have something fun and new to
work with on each board.  I have found it to be a fun exercise to learn how
to build the RTL code to support a new peripheral and I would commend that
exercise to every RTL student.

I then ran into the problem of supporting someone who didn't have the
peripherals I had.  How could or should they use the
[ZipCPU](/about/zipcpu.html),
if their hardware didn't match the hardware of one of the demonstration designs?

So, I backed up and took a look at all the designs I had.  Almost all of them
had some type of serial
[flash](https://en.wikipedia.org/wiki/Flash_memory),
some amount of block RAM, and a serial port.
Why not then make a design that had *only* these peripherals?

That was, and still is, the purpose of the
[ZBasic](https://github.com/ZipCPU/zbasic)
design.

<TABLE align="center" style="float: none"><CAPTION>Fig 1. ZBasic Components and Peripherals</CAPTION><TR><TD><IMG SRC="/img/zbasic-blok.svg" ALT="" width="730"></TD></TR></TABLE>

Because [the design](https://github.com/ZipCPU/zbasic)
is intended to be generic, it has no
[SDRAM](https://en.wikipedia.org/wiki/Synchronous_dynamic_random-access_memory),
nor any [DDR3 SDRAM](https://en.wikipedia.org/wiki/DDR3_SDRAM),
nor any other type of external RAM chip.
These interfaces tend to be board specific, and I wanted
this distribution to be as basic and as simple as possible.  What that means,
though, is that the main
[ZBasic](https://github.com/ZipCPU/zbasic)
design requires 1MB of on-chip block RAM.  Well, "requires" is a harsh word,
what I mean to say is that the design as currently configured on
[github](https://github.com/ZipCPU/zbasic) will try to infer 1MB of block RAM.
While few chips have this much RAM, it allows the
[ZipCPU](/about/zipcpu.html),
within the
[ZBasic](https://github.com/ZipCPU/zbasic)
design to have access to an abundance of RAM without worrying about the
interface to the RAM.  Even better, this amount of RAM can be easily
changed using
[AutoFPGA](https://github.com/ZipCPU/autofpga),
by changing only one number in the
[AutoFPGA](https://github.com/ZipCPU/autofpga),
[block RAM config
file](https://github.com/ZipCPU/zbasic/blob/master/auto-data/bkram.txt)
and then rebuilding the design (i.e. `make autodata`).
If that's not enough, by just adding your own user code and
[AutoFPGA](https://github.com/ZipCPU/autofpga)
configuration file, you can add whatever additional hardware to the
[ZBasic](https://github.com/ZipCPU/zbasic)
distribution you want--[SDRAM](https://en.wikipedia.org/wiki/Synchronous_dynamic_random-access_memory)s included.

Okay, enough reminiscing, let's discuss how to use the
[ZBasic](https://github.com/ZipCPU/zbasic)
design within a
[Verilator](https://www.veripool.org/wiki/verilator)-based
simulation.

## Building ZBasic

Your first task in using the
[ZBasic](https://github.com/ZipCPU/zbasic)
design will be [building the
toolchain](/zipcpu/2018/01/31/cpu-build.html)
for the
[ZipCPU](/about/zipcpu.html):
[binutils](https://www.gnu.org/software/binutils)
[GCC](https://www.gcc.org)
and [newlib](https://sourceware.org/newlib).
I'll assume you've already done that, if not you'll need to
[back up a step](/zipcpu/2018/01/31/cpu-build.html).
I'm also going to assume that the toolchain is in your path, as we discussed
[when building it](/zipcpu/2018/01/31/cpu-build.html).
The next step is to clone the
[ZBasic](https://github.com/ZipCPU/zbasic)
repository and build it.  Since this repository doesn't include a copy of
[GCC](https://www.gcc.org),
it's fairly light and a straightforward clone will work.

<figure class="highlight"><pre><code class="language-bash" data-lang="bash">git clone https://github.com/ZipCPU/zbasic
<span class="nb">cd </span>zbasic
make</code></pre></figure>

Voila!  You have a ready built
[Verilator](https://www.veripool.org/wiki/verilator)-based
project ready to run!  (Please create an issue on
[Github](https://github.com/ZipCPU/zbasic)
if you have problems, and this doesn't work.)

Shall we run our first test?  This test will require two windows, and a little
bit of timing to do right.  In your first window, go ahead an type the
following--but don't hit return on that last line yet or you might miss some
of the simulation output.  This will run the main simulation "test-bench"
wrapper, and apply it to my ([more
modern](/zipcpu/2018/01/31/cpu-build.html)) [CPU test
software](https://github.com/ZipCPU/zbasic/blob/master/sw/board/cputest.c)--once
you hit return (don't do it yet).

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nb">cd </span>sim/verilated
./main_tb ../../sw/board/cputest</code></pre></figure>

In your second window, type the following--but don't hit return.  When you do
(eventually) hit return, this will connect you to the running
[ZBasic](https://github.com/ZipCPU/zbasic)
simulation.

<figure class="highlight"><pre><code class="language-bash" data-lang="bash">telnet localhost 8846</code></pre></figure>

Ok, now you can hit return in the first window and then the second.  You
should see the results of the [CPU
test](https://github.com/ZipCPU/zbasic/blob/master/sw/board/cputest.c),
such as Fig 2 illustrates.   

<TABLE align="center" style="float: none"><CAPTION>Fig 2. ZBasic CPU Test Results</CAPTION><TR><TD><IMG SRC="/img/zbasic-cpu-test.png" ALT="" width="563"></TD></TR></TABLE>

If you had wanted, you could also turn on
[VCD file](/blog/2017/07/31/vcd.html)
[generation](/blog/2017/06/21/looking-at-verilator.html)
by using the `-d` flag, and so trace every wire throughout the whole design as
it moves through this
[CPU test](https://github.com/ZipCPU/zbasic/blob/master/sw/board/cputest.c).

<figure class="highlight"><pre><code class="language-bash" data-lang="bash">./main_tb -d ../../sw/board/cputest</code></pre></figure>

Be aware, however, there's a reason this option is turned off by default: your
[VCD file](/blog/2017/07/31/vcd.html) could easily top 11GB.

Alternatively, you could have just started the design on its own without
giving a program to the
[ZipCPU](/about/zipcpu.html).
As the
[ZipCPU](/about/zipcpu.html)
is configured within the
[ZBasic](https://github.com/ZipCPU/zbasic)
design, it starts up in a halted configuration.  (This is optional--it can be
configured to start immediately on power up--see the
[spec](https://github.com/ZipCPU/zipcpu/raw/master/doc/spec.pdf)
for more details.)  If you give a program name as an argument, the
[simulation wrapper](/blog/2017/06/21/looking-at-verilator.html)
will load the program into memory and then clear the [halt bit from the
debugging interface](/zipcpu/2017/08/25/hw-debugging.html).
On the other hand, if you give the simulation driver no program name,

<figure class="highlight"><pre><code class="language-bash" data-lang="bash">./main_tb</code></pre></figure>

then you'll need to load the
[ZipCPU](/about/zipcpu.html)'s
program into memory--just as you would need to do on actual
[FPGA](https://en.wikipedia.org/wiki/Field-programmable_gate_array)
hardware.  This is done with the
[zipload](https://github.com/ZipCPU/zbasic/blob/master/sw/host/zipload.cpp)
program found in the
[sw/board](https://github.com/ZipCPU/zbasic/tree/master/sw/board/)
subdirectory.  We'll also give this program the '-r' switch, to indicate that
the [ZipCPU](/about/zipcpu.html)
should be started once the program is loaded into memory.

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nb">cd</span> <span class="o">[</span>path-to-zbasic]/sw/host
./zipload -r ../sw/board/cputest</code></pre></figure>

This does take a while, though, since we are first programming the [simulated
flash](https://github.com/ZipCPU/zbasic/blob/master/sim/verilated/qspiflashsim.cpp)
on board, and only then starting the
[CPU](/about/zipcpu.html).  The
[CPU](/about/zipcpu.html)
will then copy its machine code from
[flash](https://en.wikipedia.org/wiki/Flash_memory),
to RAM, and run.

There you have it!  You've just run your first
[ZipCPU](/about/zipcpu.html)
program in a (nearly)
[FPGA](https://en.wikipedia.org/wiki/Field-programmable_gate_array)
representative environment.

## Playing Tic-Tac-Toe

Ok, so you've run a
[CPU test](https://github.com/ZipCPU/zbasic/blob/master/sw/board/cputest.c).
I know, **BORING**!  So let's try and have a little more fun.  Let's now
play [4x4x4 tic-tac-toe](https://github.com/ZipCPU/tttt).

Unlike the
[CPU test](https://github.com/ZipCPU/zbasic/blob/master/sw/board/cputest.c),
which *only* tests the [CPU](/about/zipcpu.html) itself,
[4x4x4 tic-tac-toe](https://github.com/ZipCPU/tttt)
uses the
[C-library](https://en.wikipedia.org/wiki/C_standard_library)
as well, with such typical library system calls as `printf` and `fgets`.
These calls get routed, via a [board specific glue
file](https://github.com/ZipCPU/zbasic/blob/master/sw/zlib/syscalls.c)
to the
[simulated serial port](https://github.com/ZipCPU/zbasic/blob/master/sim/verilated/dbluartsim.cpp).

To try this out, change directory into the `sw/board` directory, and build
`tttt`.

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nb">cd</span> <span class="o">[</span>path-to-zbasic]/sw/board
make tttt</code></pre></figure>

If you get errors, relax.  The "make" command won't build
[tttt (4x4x4 tic-tac-toe)](https://github.com/ZipCPU/tttt)
successfully yet, but it should clone
[tttt](https://github.com/ZipCPU/tttt) as a submodule into a subdirectory of the
[sw/board](https://github.com/ZipCPU/zbasic/tree/blob/sw/board)
directory.

If it doesn't clone
[tttt](https://github.com/ZipCPU/tttt) (I've had mixed success with git
submodules so far--all probably due to a problem lying somewhere between my
keyboard and my chair ...), feel free to clone
[tttt](https://github.com/ZipCPU/tttt)
right there in that directory.

Once you have it cloned, you'll need to adjust a couple of lines within the
[sw/board/tttt/src/Makefile](https://github.com/ZipCPU/blob/master/src/Makefile)
to tell
[tttt](https://github.com/ZipCPU/tttt) where the
[C-library](https://en.wikipedia.org/wiki/C_standard_library)
is.  Therefore, open the
[Makefile](https://github.com/ZipCPU/tttt/blob/master/src/Makefile)
in your favorite editor and replace the lines,

<figure class="highlight"><pre><code class="language-make" data-lang="make"><span class="err">ifeq</span> <span class="err">($(ARCH),</span> <span class="err">zip)</span>
<span class="nv">XLIBD</span>    <span class="o">:=</span> ../../branch8b/sw/zlib
<span class="nv">XLIBS</span>    <span class="o">:=</span> -L<span class="nv">$(XLIBD)</span> -Wl,--start-group -Wl,--Map<span class="o">=</span>zip-tttt.map -larty
<span class="nv">LDSCRIPT</span> <span class="o">:=</span> <span class="nv">$(XLIBD)</span><span class="err">/../board/arty.ld</span></code></pre></figure>

with these lines,

<figure class="highlight"><pre><code class="language-make" data-lang="make"><span class="err">ifeq</span> <span class="err">($(ARCH),</span> <span class="err">zip)</span>
<span class="nv">XLIBD</span>    <span class="o">:=</span> ../../../zlib
<span class="nv">XLIBS</span>    <span class="o">:=</span> -L<span class="nv">$(XLIBD)</span> -Wl,--start-group -Wl,--Map<span class="o">=</span>zip-tttt.map -lzbasic -lc
<span class="nv">LDSCRIPT</span> <span class="o">:=</span> <span class="nv">$(XLIBD)</span><span class="err">/../board/board.ld</span></code></pre></figure>

At this point, you should just be able to build
[tttt](https://github.com/ZipCPU/tttt)
without further ado.  To do this, stay in the
[sw/board](http://github.com/ZipCPU/zbasic/tree/master/sw/board) directory
of the [ZBasic](http://github.com/ZipCPU/zbasic) project and type:

<figure class="highlight"><pre><code class="language-bash" data-lang="bash">make tttt</code></pre></figure>

This will make certain the cross-compiler environment variables are properly
set to build
[tttt](https://github.com/ZipCPU/tttt)
for the
[ZipCPU](/about/zipcpu.html).
(If you had instead cd'd into `tttt` and issued a `make` command, it would
build `tttt` for your local/host architecture.)

Now we can play.  Ready?

As before, we'll type in the command to start the simulator in one window,

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nb">cd</span> <span class="o">[</span>path-to-zbasic]/sim/verilated
./main_tb ../../sw/board/tttt/src/zip-tttt</code></pre></figure>

and connect to the simulated serial port from another window,

<figure class="highlight"><pre><code class="language-bash" data-lang="bash">telnet localhost 8846</code></pre></figure>

When you hit return on the two (in sequence), the `telnet` window will show
the following:

<figure class="highlight"><pre><code class="language-text" data-lang="text">Trying 127.0.0.1...
Connected to localhost.
Escape character is '^]'.

Welcome to 4x4x4 Tic-Tac-Toe

The goal of this game is to get 4 pieces in a row.  The board is three
dimensional, even though it will be displayed on a terminal screen.  Imagine
instead of seeing four 4x4 boards side by side, that these boards are
actually standing on top of each other.  A winning four in a row can exist
on any of the 4x4 levels.  A winning four in a row can also cross through
all levels.  Diagonals are valid, as are diagonal diagonals.

To specify your move, type in a string of three numbers each in the range of
1-4.  The first two numbers describe where you wish to move within one 4x4
board, where the first number is the position counting left to right and the
second number is the position counting from top down.  The last number is
which 4x4 board you wish to move to, counting from the 4x4 on the left to
the right

Current Board: (Empty)
----  ----  ----  ----  
----  ----  ----  ----  
----  ----  ----  ----  
----  ----  ----  ----  

Your move : </code></pre></figure>

You should be able to just type your move in as a series of three numbers,
each 1-4, as in `1 1 1`.  Have fun!

Be careful, although the computer isn't unbeatable, he does play a pretty
mean game!

## Homework

Care for some
[CPU](https://en.wikipedia.org/wiki/Central_processing_unit)
homework?  Here's a fascinating test you can try with the
[ZBasic](http://github.com/ZipCPU/zbasic)
distribution, one that will help to illustrate how important having a
hardware memory copy capability is.

The glue logic supporting the
[C-library](https://en.wikipedia.org/wiki/C_standard_library)
includes a file called
[crt0.c](https://github.com/ZipCPU/zbasic/blob/master/sw/zlib/crt0.c).
For most
[CPU](https://en.wikipedia.org/wiki/Central_processing_unit)'s this is an
[assembly language](https://en.wikipedia.org/wiki/Assembly_language)
file called crt0.s.  Not for the
[ZipCPU](/about/zipcpu.html).  For the
[ZipCPU](/about/zipcpu.html),
this file is written in C.  It contains two routines: `_start` and
`_bootloader`.

The first routine, `_start` starts the
[ZipCPU](/about/zipcpu.html)
by setting the stack pointer to the end of memory, and then jumping to a
function called `_bootloader`.  This is really an
[assembly language](/zicpu/2018/01/01/zipcpu-isa.html)
routine with a thin veneer of a C wrapper, but it's placed within the
[crt0.c](https://github.com/ZipCPU/zbasic/blob/master/sw/zlib/crt0.c)
file anyway.  When you strip away the cruft, it basicaly reads as,

<figure class="highlight"><pre><code class="language-asm" data-lang="asm">_start:		; Here's the global ZipCPU entry point upon reset/reboot
	LDI	_top_of_stack,SP	; Set up our supervisor stack ptr
	MOV	_kernel_is_dead(PC),uPC	; Set user PC pointer to somewhere valid
	JSR	_bootloader	; JSR to the bootloader routine
	OR	0x4000,CC	; Clear the data cache
        //
	CLR	R1		; argc = 0
	MOV	_argv(PC),R2	; argv = &amp;0
	LDI	__env,R3	; env = NULL
	JSR	main		; Call the user main() function
        //
_graceful_kernel_exit:		; Halt on any return from main--gracefully
	JSR	exit		; Call the _exit as part of exiting
_hw_shutdown:
	NEXIT	R1		; If in simulation, call an exit function
_kernel_is_dead:		; Halt the CPU\n"
	HALT			;</code></pre></figure>

The second routine within
[this file](https://github.com/ZipCPU/zbasic/blob/master/sw/zlib/crt0.c)
is the `_bootloader` routine that is called from the `_start` function above.
This is the routine I'd like to demonstrate for this homework lesson.

The `_bootloader` function itself is really nothing more than a series of
memory copy routines.  These are based around a couple of assumptions.  First,
[flash](https://en.wikipedia.org/wiki/Flash_memory)
is non-volatile (i.e. like a ROM) and so upon startup instructions can
be found there.  The second assumption is that the block RAM is faster than
[flash](https://en.wikipedia.org/wiki/Flash_memory).
Hence, we want to move our instructions (and data) from
[flash](https://en.wikipedia.org/wiki/Flash_memory)
into block RAM before starting any program.

First, the `_bootloader` copies memory from the
[flash](https://en.wikipedia.org/wiki/Flash_memory)
into block RAM.  This section is framed by an
`#ifdef _BOARD_HAS_KERNEL_SPACE`,  so that any
high priority (kernel) functions would be or could be placed into block RAM.

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="kt">void</span>	<span class="nf">_booloader</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// ...
</span>
<span class="cp">#ifdef  _BOARD_HAS_KERNEL_SPACE
</span>	<span class="n">rdp</span> <span class="o">=</span> <span class="n">_kernel_image_start</span><span class="p">;</span>
	<span class="n">wrp</span> <span class="o">=</span> <span class="n">_bkram</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">_kernel_image_end</span> <span class="o">!=</span> <span class="n">_kernel_image_start</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">do</span> <span class="p">{</span>
			<span class="o">*</span><span class="n">wrp</span><span class="o">++</span> <span class="o">=</span> <span class="o">*</span><span class="n">rdp</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">while</span><span class="p">(</span><span class="n">wrp</span> <span class="o">&lt;</span> <span class="n">_kernel_image_end</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">_kernel_image_end</span> <span class="o">&lt;</span> <span class="n">_sdram</span><span class="p">)</span>
			<span class="n">wrp</span> <span class="o">=</span> <span class="n">_sdram</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#else
</span>	<span class="n">rdp</span> <span class="o">=</span> <span class="n">_ram_image_start</span><span class="p">;</span>
	<span class="n">wrp</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span><span class="n">_ram</span><span class="p">;</span>
<span class="cp">#endif</span></code></pre></figure>

Second, the bootloader copies from
[flash](https://en.wikipedia.org/wiki/Flash_memory)
[SDRAM](https://en.wikipedia.org/wiki/Synchronous_dynamic_random-access_memory)
into any
[SDRAM](https://en.wikipedia.org/wiki/Synchronous_dynamic_random-access_memory)
the board might have,
as defined by the `_sdram` pointer.  Since
[ZBasic](https://github.com/ZipCPU/zbasic)
doesn't have any
[SDRAM](https://en.wikipedia.org/wiki/Synchronous_dynamic_random-access_memory),
this second memory copy ends up continuing the write into block RAM
instead.

<figure class="highlight"><pre><code class="language-c" data-lang="c">        <span class="k">while</span><span class="p">(</span><span class="n">wrp</span> <span class="o">&lt;</span> <span class="n">_ram_image_end</span><span class="p">)</span>
		<span class="o">*</span><span class="n">wrp</span><span class="o">++</span> <span class="o">=</span> <span class="o">*</span><span class="n">rdp</span><span class="o">++</span><span class="p">;</span></code></pre></figure>

The third section of memory is the BSS section.  This is a memory section
whose initial contents are all zeros.  The `_bootloader` fulfills this
commitment by writing zeros to all of the memory location within this
section.

<figure class="highlight"><pre><code class="language-c" data-lang="c">	<span class="c1">// ...
</span>	<span class="k">while</span><span class="p">(</span><span class="n">wrp</span> <span class="o">&lt;</span> <span class="n">_bss_image_end</span><span class="p">)</span>
		<span class="o">*</span><span class="n">wrp</span><span class="o">++</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

However, if you look inside the
[crt0.c](https://github.com/ZipCPU/zbasic/blob/master/sw/zlib/crt0.c)
file, you'll actually see two choices
for how to handle these memory copies.  The first choice is applied if
`USE_DMA` is defined.  This is set earlier in the file to be true only if
`_HAVE_ZIPSYS_DMA` is defined--something that comes from the
[cpudefs.v](https://github.com/ZipCPU/zbasic/blob/master/rtl/cpu/cpudefs.v)
configuration file.

For this homework assignment, turn on tracing with the `-d` flag (you do have
a rough 4GB available, right?) and run the
[4x4x4 tic-tac-toe program (tttt)](https://github.com/ZipCPU/tttt)
again.

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nb">cd</span> <span class="o">[</span>path-to-zbasic]/sim/verilated
./main_tb -d ../../sw/board/tttt/src/zip-tttt</code></pre></figure>

To keep it from taking up too much room on your
hard-drive, kill it as soon as the game instructions start coming up (i.e.
type Ctrl-C on the screen where you typed `main_tb -d ...`).
Copy the [trace file](/blog/2017/07/31/vcd.html)
from `trace.vcd` to `with-dma.vcd`.

<figure class="highlight"><pre><code class="language-bash" data-lang="bash">mv trace.vcd with-dma.vcd</code></pre></figure>

Then comment the `USE_DMA` define in
[crt0.c](https://github.com/ZipCPU/zbasic/blob/master/sw/zlib/crt0.c) by
placing two `//`s at the beginning of the line,

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="o">//</span> <span class="err">#</span><span class="n">define</span>	<span class="n">USE_DMA</span></code></pre></figure>

You can then rebuild in
[sw/zlib](https://github.com/ZipCPU/zbasic/tree/master/sw/zlib/) by typing
`make` in that directory, but you'll need to do a `make clean` in
[sw/board](https://github.com/ZipCPU/zbasic/tree/master/sw/board/)
before you can re-issue `make` again there.  Once done, you can issue a
`make` in
[sw/board](https://github.com/ZipCPU/zbasic/tree/master/sw/board/)
and then `make tttt`.  This will propagate this change throughout the
[C-library](https://en.wikipedia.org/wiki/C_standard_library)
and into the application software.

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nb">cd</span> <span class="o">[</span>path-to-zbasic]/sw/zlib
make
<span class="nb">cd</span> ../sw/board
make clean
make
make tttt</code></pre></figure>

Now run the simulator again, still with the -d option.

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nb">cd</span> <span class="o">[</span>path-to-zbasic]/sim/verilated
main_tb -d ../../sw/board/tttt/src/zip-tttt</code></pre></figure>

Kill it (Ctrl-C) as before when the characters start getting printed to the
terminal.  Then rename the `trace.vcd` file to be `without-dma.vcd`.

<figure class="highlight"><pre><code class="language-bash" data-lang="bash">mv trace.vcd without-dma.vcd</code></pre></figure>

Now that you have two comparison files, pull them both up in
[GtkWave](https://gtkwave.sourceforge.net).
Let's look specifically at the
serial output line `o_wbu_uart_tx` from the top level, and then from
within the top level, the
[wishbone strobe
line `wb_stb`](/blog/2017/11/07/wb-formal.html), the
`flash_sel` ([flash](https://en.wikipedia.org/wiki/Flash_memory)
select) line, and then `bkram_sel` (block RAM select)
lines.  As you may recall, `wb_stb` will be true anytime a request is being
made across the bus.  The other two lines indicate when the address
associated with this request is either referencing the
[flash](https://en.wikipedia.org/wiki/Flash_memory)
or the block RAM.

See a difference?

Here's my figure for running without the
[DMA](https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/wbdmac.v),

<TABLE align="center" style="float: none"><CAPTION>Fig 3. ZBasic Bootloader without DMA</CAPTION><TR><TD><IMG SRC="/img/zbasic-wodma.png" ALT="" width="780"></TD></TR></TABLE>

and again for running with the
[DMA](https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/wbdmac.v)
controller,

<TABLE align="center" style="float: none"><CAPTION>Fig 4. ZBasic Components and Peripherals</CAPTION><TR><TD><IMG SRC="/img/zbasic-wdma.png" ALT="" width="780"></TD></TR></TABLE>

If you look at the far right, when `o_wbu_uart_tx` starts toggling that's when
the first characters of the game are being sent to the serial port.  This
doesn't happen until the
[ZipCPU](/about/zipcpu.html)
`_bootloader` has finished.  Here, you can see that it takes about nine
seconds to copy everything from
[flash](https://en.wikipedia.org/wiki/Flash_memory)
when using the `_bootloader`, whereas it
takes over twenty seconds without!  You can also see a big difference in the
`flash_sel` and `bkram_sel` lines.  What's going on there?

Let's drill one level deeper and look at what's going on by zooming in.
Let's also add the `flash_ack` and `bkram_ack` lines--there are the
wishbone acknowledgement
lines from these two peripherals, and indicate when a request has been
fulfilled.

You can see the
[trace](/blog/2017/07/31/vcd.html)
without
[DMA](https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/wbdmac.v),
in Fig 5, below.

<TABLE align="center" style="float: none"><CAPTION>Fig 5. Zooming in on the ZBasic Bootloader without DMA</CAPTION><TR><TD><IMG SRC="/img/zbasic-wodma-zoom.png" ALT="" width="780"></TD></TR></TABLE>

What's not as readily apparent in this
[trace](/blog/2017/07/31/vcd.html)
is the context--it begins in the middle of a transaction.  A value has
already been requested from the
[flash](https://en.wikipedia.org/wiki/Flash_memory)
controller by the time my screen capture starts.  Once the
[flash controller](https://github.com/ZipCPU/zbasic/blob/master/rtl/wbqspiflash.v)
acknowledges the transaction, that is when `flash_ack` goes high, the data
becomes available to the `_bootloader`,
and it immediately turns around and writes to the block RAM.  Since the
block RAM is quite fast, it acknowledges its transaction almost immediately.
(Remember, transaction requests only take place when `wb_stb` is high, and
so Fig 6 only shows two transaction requests.)  The
[ZipCPU](/about/zipcpu.html)
then issues a read request of the
[flash](https://en.wikipedia.org/wiki/Flash_memory)
and ... everything stalls again waiting for the [flash
controller](https://github.com/ZipCPU/zbasic/blob/master/rtl/wbqspiflash.v)'s
acknowledgement.

This is *very* different from what happens when the
[DMA](https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/wbdmac.v),
is turned on.  For that case, you can see what happens when
in Fig 6 below.

<TABLE align="center" style="float: none"><CAPTION>Fig 6. Zooming in on the ZBasic Bootloader, with the DMA in use</CAPTION><TR><TD><IMG SRC="/img/zbasic-wdma-zoom.png" ALT="" width="780"></TD></TR></TABLE>

In this case, the
[DMA](https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/wbdmac.v)
reads multiple items from the
[flash](https://en.wikipedia.org/wiki/Flash_memory)
in a back to back
fashion--you can see all of the acknowledgement's in the `flash_ack` line
in Fig 6.  During this time, the block RAM is idle.  Once the
[DMA](https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/wbdmac.v)
has finished
reading a rough 1k words from the
[flash](https://en.wikipedia.org/wiki/Flash_memory),
it then bursts these to the block
RAM.  Look at the `wb_stb` line to see this--it's nearly a constant `ON`
signal, indicating that one request after another is being made.  In a
similar fashion, but unlike the
[flash](https://en.wikipedia.org/wiki/Flash_memory)
[controller](https://github.com/ZipCPU/zbasic/blob/master/rtl/wbqspiflash.v)'s
response, the block RAM's acknowledgment signal is also a constant high--since
the block RAM can respond to one request per clock.
As a result, this portion of the copy goes by very quickly.

Given this information, would you rather copy your data using the
[DMA](https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/wbdmac.v),
or a tight loop within the
[ZipCPU](/about/zipcpu.html)?

## How do I change the amount of block RAM?

Since I know this is going to come up, let me show you how easy it is to
change the amount of block RAM in this device.

First, look in the
[AutoFPGA](https://github.com/ZipCPU/autofpga) [block ram configuration
file](https://github.com/ZipCPU/zbasic/blob/master/auto-data/bkram.txt).
Within that file, find the line,

<figure class="highlight"><pre><code class="language-text" data-lang="text">@$LGMEMSZ=20</code></pre></figure>

This line defines a tag, `@LGMEMSZ`, specifies that it is a numerical
tag with the `@$` prefix, and then gives it the value of `20`.
This tag is used to specify that the log, based two, of the block RAM
memory size is twenty--meaning it should have 1MB, or `2^20` bytes, of
block RAM.  The key itself is unique to this
[block ram configuration
file](https://github.com/ZipCPU/zbasic/blob/master/auto-data/bkram.txt),
so you aren't likely to find it elsewhere.  It basically defines a local
variable within an [AutoFPGA](https://github.com/ZipCPU/autofpga) context.
However, with a bit of math and some substitution (remember, 
[AutoFPGA](https://github.com/ZipCPU/autofpga) is primarily a
copy/paste utility with a calculator and address assignment built
in), this number becomes the amount of block RAM called for in the
system design.

You can change this one number, and then run `make autodata` from the main
directory (assuming you have
[AutoFPGA](https://github.com/ZipCPU/autofpga) installed and in your path),
and the design will immediately be reconfigured for the new memory size.

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nb">cd</span> <span class="o">[</span>path-to-zbasic]/
make autodata</code></pre></figure>

Yes, you'll still need to run `make` from the main directory again once
you've done this,

<figure class="highlight"><pre><code class="language-bash" data-lang="bash">make</code></pre></figure>

so that this newly configured design has a chance to build.

What changes?

Well, first, the `@MAIN.INSERT` tag that same
[bkram.txt](https://github.com/ZipCPU/zbasic/blob/master/auto-data/bkram.txt)
file is used to tell
[AutoFPGA](https://github.com/ZipCPU/autofpga) what to place into your
[main.v](/blog/2017/10/05/autofpga-intro.html)
file.  In this case, it's a reference to a
[`memdev`](https://github.com/ZipCPU/zbasic/blob/master/rtl/memdev.v)
module which implements a block RAM device that is parameterized by its size.
`@THIS.LGMEMSZ` is used to control this parameter.  It's also used to
connect that design parameter to the number of address lines fed to this
component, and changing this size may cause the other peripherals on the bus
to be shuffled around to minimize the required bus logic.

Second, all of the addresses will (may) be re-assigned as I just mentioned.
This includes more than just the block RAM.  These new addresses can be found
listed in the
[regdefs.h](https://github.com/ZipCPU/zbasic/blob/master/sw/host/regdefs.h)
and
[board.h](https://github.com/ZipCPU/zbasic/blob/master/sw/board/board.h)
files based upon the `@REGS.*` and `@BDEF.OSVAL` tags.

Third, the [linker definition
script](https://github.com/ZipCPU/zbasic/blob/master/sw/board/board.ld)
will have changed, which will adjust the
`_bkram` pointer used by the `_bootloader` we discussed above.

Fourth, the `@SIM.LOAD` tag defines the software necessary to load a program
into this memory, given the new location and length found in the updated
[regdefs.h](https://github.com/ZipCPU/zbasic/blob/master/sw/host/regdefs.h)
file.

The result of all of this is that, following an
[AutoFPGA](https://github.com/ZipCPU/autofpga)
based reconfigure, all that is required is to rebuild the project and
we have a new amount of memory at a (potentially) different location.

## Next Steps

Now that you know how to run the
[ZBasic](https://github.com/ZipCPU/zbasic)
demonstration, the next step
will be to show how simple and easy it is to add a
[new component](https://github.com/ZipCPU/wbpmic)
using
[AutoFPGA](https://github.com/ZipCPU/autofpga),
and then to demonstrate how we can integrate this component into our
[simulation](/blog/2017/06/21/looking-at-verilator.html)
and ultimately the
[FPGA](https://en.wikipedia.org/wiki/Field-programmable_gate_array)
design as a whole.

My current plan is to do this with the
[WBPMIC](https://github.com/ZipCPU/wbpmic)
component.  This particular controller is designed to control a [MEMs audio
microphone](http://store.digilentinc.com/pmod-mic3-mems-microphone-with-adjustable-gain)
and [A/D](https://en.wikipedia.org/wiki/Analog-to-digital_converter)
sold by [Digilent](https://store.digilentinc.com)--their
"[PMod MIC3](http://store.digilentinc.com/pmod-mic3-mems-microphone-with-adjustable-gain)".

That will be our next step in this series, although there's really a lot
of information we can come back to--such as how the
[DMA controller](https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/wbdmac.v)
works in the first place.

  </div>


<div class "verse">
<HR align="center;" width="25%">
<P><em>Wilt thou play with him as with a bird? or wilt thou bind him for thy maidens? (Job 41:5)</em>


</article>

      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading">The ZipCPU by Gisselquist Technology</h2>
    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <!-- <li></li> -->
          <li><a href="mailto:zipcpu@gmail.com">zipcpu@gmail.com</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="social-media-list">
          
          <li>
            <a href="https://github.com/ZipCPU"><span class="icon icon--github"><svg viewBox="0 0 16 16"><path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/></svg>
</span><span class="username">ZipCPU</span></a>

          </li>
          

          
          <li>
            <a href="https://twitter.com/zipcpu"><span class="icon icon--twitter"><svg viewBox="0 0 16 16"><path fill="#828282" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27 c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767 c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206 C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271 c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469 c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"/></svg>
</span><span class="username">zipcpu</span></a>

          </li>
          
          
          <li><A href="https://www.patreon.com/ZipCPU"><img src="/img/become_a_patron_button.png"></a></li>
          

        </ul>
      </div>

      <div class="footer-col footer-col-3">
        <p>The ZipCPU blog, featuring how to discussions of FPGA and soft-core CPU design.  This site will be focused on Verilog solutions, using exclusively OpenSource IP products for FPGA design.  Particular focus areas include topics often left out of more mainstreeam FPGA design courses such as how to debug an FPGA design.
</p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
