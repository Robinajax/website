<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>The ZipCPU by Gisselquist Technology</title>
    <description>The ZipCPU blog, featuring how to discussions of FPGA and soft-core CPU design.  This site will be focused on Verilog solutions, using exclusively OpenSource IP products for FPGA design.  Particular focus areas include topics often left out of more mainstreeam FPGA design courses such as how to debug an FPGA design.
</description>
    <link>http://zipcpu.com/</link>
    <atom:link href="http://zipcpu.com/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Tue, 17 Apr 2018 12:50:28 -0400</pubDate>
    <lastBuildDate>Tue, 17 Apr 2018 12:50:28 -0400</lastBuildDate>
    <generator>Jekyll v3.0.1</generator>
    <image>
      <url>http://zipcpu.com/img/gt-rss.png</url>
      <title></title>
      <link></link>
    </image>
    
      <item>
        <title>Formally Verifying an Asynchronous Reset</title>
        <description>&lt;p&gt;&lt;a href=&quot;/blog/2017/10/20/cdc.html&quot;&gt;Clock Domain Crossings&lt;/a&gt;
can be difficult to get right.  This applies not only
to crossing data and logic from one clock domain to another, but also to
crossing resets from one clock domain to another.  The general rule is that all
logic &lt;a href=&quot;https://en.wikipedia.org/wiki/Flip-flop_(electronics)#Timing_considerations&quot;&gt;must have a guaranteed settling time before the next rising edge of
the next clock&lt;/a&gt;.
If this rule is violated then logic may enter a state that
is neither &lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt; nor &lt;code class=&quot;highlighter-rouge&quot;&gt;0&lt;/code&gt;, neither true nor false.&lt;/p&gt;

&lt;p&gt;This is
&lt;a href=&quot;https://en.wikipedia.org/wiki/Metastability_in_electronics&quot;&gt;metastability&lt;/a&gt;.
Avoid it at all costs.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 1. Synchronizing an Asynchronous Reset&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/areset-regions.svg&quot; width=&quot;360&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;In the case of an asynchronous reset, it usually doesn’t matter all that much
during which clock interval the design enters into the reset state.  As long
as the reset remains active long enough to fully propagate through the design,
everything will eventually enter into this state.  What matters is whether or
not the whole design leaves the reset state at the same time: on a clock edge.&lt;/p&gt;

&lt;p&gt;Fig 1. shows an example of such an asynchronous reset.  The negative logic
reset comes into the design with no guarantee of being synchronous with
the clock.
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flip-flop_(electronics)&quot;&gt;Flip-flops&lt;/a&gt;
dependent upon that reset may then enter into a metastable state, shown by
the pink background in the figure.  Logic within the design needs to
recognize this reset, and synchronize its release.  This is shown by the
green region, where the adjusted reset clears and returns to zero at
the sime time as the rising edge of the system clock.&lt;/p&gt;

&lt;p&gt;You may also notice from Fig 1 that the incoming asynchronous reset
signal is based upon negative logic.  In other words, to activate the reset
the logic needs to be pulled low.  This is a common practice in
&lt;a href=&quot;/blog/2017/10/13/fpga-v-asic.html&quot;&gt;ASIC designs&lt;/a&gt;,
since it allows a design to start entering into its reset state before
sufficient power is available to assert a positive going reset across the
entire design–although this isn’t usually required with FPGA designs.&lt;/p&gt;

&lt;p&gt;Since the logic necessary to do this is pretty simple, let’s take a look at it
in the next section.&lt;/p&gt;

&lt;h2 id=&quot;verilog&quot;&gt;Verilog&lt;/h2&gt;

&lt;p&gt;For our &lt;a href=&quot;/examples/areset.v&quot;&gt;simple Verilog example&lt;/a&gt;,
let’s create a synchronous positive logic
reset signal from a negative logic asynchronous reset.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: left&quot;&gt;&lt;caption&gt;Fig 2. Three Flip-flop Asynchronous Reset Synchronizer&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/areset-fifos.svg&quot; width=&quot;360&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;The &lt;a href=&quot;/examples/areset.v&quot;&gt;basic code&lt;/a&gt;
just sets the outgoing reset and the three
&lt;a href=&quot;/blog/2017/10/20/cdc.html&quot;&gt;flip-flop synchronizers&lt;/a&gt;
to &lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt; anytime the asynchronous reset is true, and then waits for three clock
edges to release.  You can see this basic logic pictorially in Fig 2 on the
left.&lt;/p&gt;

&lt;p&gt;Since &lt;a href=&quot;/examples/areset.v&quot;&gt;the code&lt;/a&gt;
itself is so short, I’ll spend a moment touching on some
details I usually avoid along the way.  For example, I (now) always start
any Verilog design by setting the &lt;code class=&quot;highlighter-rouge&quot;&gt;default_nettype&lt;/code&gt; to
&lt;code class=&quot;highlighter-rouge&quot;&gt;none&lt;/code&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;`default_nettype	none&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This one statement is really a blessing when it comes to finding
errors within your code.  Verilog specifies that the default synthesizer
behavior upon finding any undeclared identifier
is to assume that the identifier was supposed to reference a &lt;code class=&quot;highlighter-rouge&quot;&gt;wire&lt;/code&gt;, and so
the synthesizer will then quietly declare a &lt;code class=&quot;highlighter-rouge&quot;&gt;wire&lt;/code&gt; for you when you would have
rather had the synthesizer report an error due to your misspelling.  By
telling the synthesis tool not to do this, it becomes much easier to catch
errors you might have in your code.&lt;/p&gt;

&lt;p&gt;Our module will accept two inputs, and produce one output.  The two inputs will
be the clock, &lt;code class=&quot;highlighter-rouge&quot;&gt;i_clk&lt;/code&gt; and the negative going asynchronous reset, &lt;code class=&quot;highlighter-rouge&quot;&gt;i_areset_n&lt;/code&gt;.
The underscores here have specific meanings.  &lt;code class=&quot;highlighter-rouge&quot;&gt;i_&lt;/code&gt; references an input,
&lt;code class=&quot;highlighter-rouge&quot;&gt;o_&lt;/code&gt; in a moment will reference an output, and in the case of this reset the
&lt;code class=&quot;highlighter-rouge&quot;&gt;_n&lt;/code&gt; suffix references negative logic.  The last item in our portlist is
our synchronized output signal, &lt;code class=&quot;highlighter-rouge&quot;&gt;o_reset&lt;/code&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;module areset(i_clk, i_areset_n, o_reset);
	input	wire	i_clk, i_areset_n;
	output	reg	o_reset;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;To handle the synchronization, we’ll use a &lt;a href=&quot;/blog/2017/10/20/cdc.html&quot;&gt;three clock
synchronizer&lt;/a&gt;.  This requires
two internal state bits that we’ll call &lt;code class=&quot;highlighter-rouge&quot;&gt;sync_fifo&lt;/code&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	reg	[1:0]	sync_fifo;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;We’ll also assume the design begins in a reset state, and so initialize our
&lt;a href=&quot;/blog/2017/10/20/cdc.html&quot;&gt;synchronization FIFO&lt;/a&gt;
and our output to start in a reset condition.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	initial	sync_fifo = 2&#39;h3;
	initial	o_reset = 1&#39;b1;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Enough of the preliminaries.  What does it take to synchronize a reset?
Just the following four lines of code.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(posedge i_clk or negedge i_areset_n)
	if (!i_areset_n)
		{ o_reset, sync_fifo } &amp;lt;= 3&#39;h7;
	else
		{ o_reset, sync_fifo } &amp;lt;= { sync_fifo, 1&#39;b0 };&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;So how does this work?  As shown in Fig 1 above, anytime &lt;code class=&quot;highlighter-rouge&quot;&gt;i_areset_n&lt;/code&gt; goes low
(active), then we set the synchonizer and the output reset registers to all
ones.  Otherwise, if &lt;code class=&quot;highlighter-rouge&quot;&gt;i_areset_n&lt;/code&gt; is high (inactive), then on the positive
edge of the clock we’ll shift a zero into and through the the &lt;code class=&quot;highlighter-rouge&quot;&gt;sync_fifo&lt;/code&gt;
shift register until it clears the &lt;code class=&quot;highlighter-rouge&quot;&gt;o_reset&lt;/code&gt; output.&lt;/p&gt;

&lt;p&gt;That’s it.  There’s really not that much more to it.&lt;/p&gt;

&lt;p&gt;That is, there’s nothing more involved unless you want to
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formally verify&lt;/a&gt;
that this operation works as advertised.  Hence, let’s look at
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formally verifying&lt;/a&gt;
this reset logic in the next section.&lt;/p&gt;

&lt;h2 id=&quot;formal-properties&quot;&gt;Formal Properties&lt;/h2&gt;

&lt;p&gt;When it comes to
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal properties&lt;/a&gt;,
I’ve &lt;a href=&quot;/zipcpu/2018/03/21/dblfetch.html&quot;&gt;recently started including
“contracts”&lt;/a&gt; into the
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal properties&lt;/a&gt;
I write.  I’ve found it valuable to clearly indicate what the minimum
you want something to do is.  Let’s do that here.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;`ifdef	FORMAL
	////////////////////////////////////////////////////
	//
	// Our &quot;contract&quot;
	//
	////////////////////////////////////////////////////
	//&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;In this case, I can think of four basic properties that are relevant.&lt;/p&gt;

&lt;p&gt;The first is our one assumption that we always start in a reset state.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	initial	assume(!i_areset_n);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Our next property is that any time &lt;code class=&quot;highlighter-rouge&quot;&gt;i_areset_n&lt;/code&gt; is low (active) our outgoing
reset value &lt;code class=&quot;highlighter-rouge&quot;&gt;o_reset&lt;/code&gt; must be high (active).&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(*)
	if (!i_areset_n)
		assert(o_reset);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;At this point I can hear someone asking, doesn’t that make this an
asynchronous reset as well?&lt;/p&gt;

&lt;p&gt;Yes, technically it does.  However, &lt;code class=&quot;highlighter-rouge&quot;&gt;o_reset&lt;/code&gt; is guaranteed to also be high
for at least one clock before it is released, so we can (usually) just treat
it as a regular synchronous logic reset as well.  There is a risk
that this reset will send some
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flip-flop_(electronics)&quot;&gt;flip-flops&lt;/a&gt;
into a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Metastability_in_electronics&quot;&gt;metastable&lt;/a&gt; state
for one clock cycle.
While this is a possibility when using &lt;code class=&quot;highlighter-rouge&quot;&gt;o_reset&lt;/code&gt;, those
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flip-flop_(electronics)&quot;&gt;flip-flops&lt;/a&gt;
will be reset in the next clock interval.  If this is not acceptable
for your logic, then just treat &lt;code class=&quot;highlighter-rouge&quot;&gt;o_reset&lt;/code&gt; as an asynchronous reset.&lt;/p&gt;

&lt;p&gt;The third part of our contract is that we only ever leave the reset state
on the positive edge of any clock.  This property is a little less intuitive
to express as an &lt;code class=&quot;highlighter-rouge&quot;&gt;assert&lt;/code&gt;ion.  Specifically, we want to assert that any
time &lt;code class=&quot;highlighter-rouge&quot;&gt;o_reset&lt;/code&gt; transitions from &lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt; to &lt;code class=&quot;highlighter-rouge&quot;&gt;0&lt;/code&gt;, i.e. any time it &lt;em&gt;falls&lt;/em&gt;,
that the clock is also transitioning from &lt;code class=&quot;highlighter-rouge&quot;&gt;0&lt;/code&gt; to &lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt; (&lt;em&gt;rising&lt;/em&gt;).&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @($global_clock)
	if ($fell(o_reset))
		assert($rose(i_clk));&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;As one last part of our
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal proof&lt;/a&gt;,
let’s &lt;code class=&quot;highlighter-rouge&quot;&gt;cover()&lt;/code&gt; the release from reset to make certain this design will
release from reset like we expect it to.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(*)
		cover(!o_reset);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;At this point, if we only wanted to pass a bounded model check we’d be done.
If you instead want to &lt;em&gt;prove&lt;/em&gt; that this asynchronous reset works, then you’ll
&lt;a href=&quot;/blog/2018/03/10/induction-exercise.html&quot;&gt;need to create some more
formal properties&lt;/a&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	////////////////////////////////////////////////////
	//
	// Extras for passing induction
	//
	////////////////////////////////////////////////////&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;These extra properties are primarily used to make certain that the &lt;a href=&quot;/blog/2018/03/10/induction-exercise.html&quot;&gt;induction
engine doesn’t find the design in an unreachable
state&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;For the first of these properties, we’ll assert that any time the design
is not in a reset condition, then the &lt;code class=&quot;highlighter-rouge&quot;&gt;sync_fifo&lt;/code&gt; shift register bits should
be zero as well.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(*)
	if (!o_reset)
		assert(sync_fifo == 2&#39;b00);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;In a similar fashion, the &lt;code class=&quot;highlighter-rouge&quot;&gt;sync_fifo&lt;/code&gt; should &lt;em&gt;never&lt;/em&gt; be able to get into
a state where the bits are &lt;code class=&quot;highlighter-rouge&quot;&gt;2&#39;b01&lt;/code&gt;.  This property is necessary
to keep the &lt;a href=&quot;/blog/2018/03/10/induction-exercise.html&quot;&gt;induction stage from starting in this unreachable
state&lt;/a&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(*)
		assert(sync_fifo != 2&#39;b01);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Likewise, any time &lt;code class=&quot;highlighter-rouge&quot;&gt;sync_fifo[1]&lt;/code&gt; is &lt;em&gt;true&lt;/em&gt;, then &lt;code class=&quot;highlighter-rouge&quot;&gt;o_reset&lt;/code&gt; should be active.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(*)
	if (sync_fifo[1])
		assert(o_reset);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Finally, any time &lt;code class=&quot;highlighter-rouge&quot;&gt;i_areset_n&lt;/code&gt; is active (low), we’ll want to make certain
that &lt;code class=&quot;highlighter-rouge&quot;&gt;sync_fifo&lt;/code&gt; is in its full reset state as &lt;code class=&quot;highlighter-rouge&quot;&gt;2&#39;b11&lt;/code&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(*)
	if (!i_areset_n)
		assert(sync_fifo == 2&#39;b11);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;All four of these criteria are necessary to make certain that the design
passes induction.&lt;/p&gt;

&lt;p&gt;That also ends the
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal properties&lt;/a&gt;
of our asynchronous reset module.&lt;/p&gt;

&lt;h2 id=&quot;symbiyosys&quot;&gt;SymbiYosys&lt;/h2&gt;

&lt;p&gt;If you want to prove this design using
&lt;a href=&quot;https://symbiyosys.readthedocs.io/en/latest&quot;&gt;SymbiYosys&lt;/a&gt;,
you’ll need to put a
&lt;a href=&quot;https://symbiyosys.readthedocs.io/en/latest&quot;&gt;SymbiYosys&lt;/a&gt;
script together to do so.  Let’s take a quick moment to build this
&lt;a href=&quot;/examples/areset.sby&quot;&gt;script&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;We’ve discussed
&lt;a href=&quot;https://symbiyosys.readthedocs.io/en/latest&quot;&gt;SymbiYosys&lt;/a&gt;
scripts a little on the blog, although we haven’t discussed
&lt;a href=&quot;https://symbiyosys.readthedocs.io/en/latest&quot;&gt;SymbiYosys&lt;/a&gt;
&lt;em&gt;tasks&lt;/em&gt; much.  For this design, we’ll use a
&lt;a href=&quot;https://symbiyosys.readthedocs.io/en/latest&quot;&gt;SymbiYosys&lt;/a&gt;
task so that we can have
&lt;a href=&quot;https://symbiyosys.readthedocs.io/en/latest&quot;&gt;SymbiYosys&lt;/a&gt;
handle both &lt;em&gt;prove&lt;/em&gt;ing that our design works, as well as the &lt;em&gt;cover&lt;/em&gt; property
above.&lt;/p&gt;

&lt;p&gt;A &lt;a href=&quot;https://symbiyosys.readthedocs.io/en/latest&quot;&gt;SymbiYosys&lt;/a&gt;
&lt;a href=&quot;/examples/areset.sby&quot;&gt;script&lt;/a&gt;
with tasks in it starts with a &lt;code class=&quot;highlighter-rouge&quot;&gt;[tasks]&lt;/code&gt; section declaring the names
of the various tasks.  In our case, we’ll declare a &lt;code class=&quot;highlighter-rouge&quot;&gt;cover&lt;/code&gt; and a &lt;code class=&quot;highlighter-rouge&quot;&gt;prove&lt;/code&gt;
task.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;[tasks]
prove
cover&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The second section of the
&lt;a href=&quot;/examples/areset.sby&quot;&gt;SymbiYosys script&lt;/a&gt;
describes the options to be given to the formal solver.  The &lt;code class=&quot;highlighter-rouge&quot;&gt;mode&lt;/code&gt; option
selects what mode we wish to run the solvers in.  For the &lt;code class=&quot;highlighter-rouge&quot;&gt;prove&lt;/code&gt; task, we’ll
run in &lt;code class=&quot;highlighter-rouge&quot;&gt;prove&lt;/code&gt; mode.  This will apply both a bounded model check as well as
the &lt;em&gt;k&lt;/em&gt;-induction pass.  Passing this task will &lt;em&gt;prove&lt;/em&gt; that the safety
properties hold.  This applies to all of the &lt;code class=&quot;highlighter-rouge&quot;&gt;assume&lt;/code&gt;s and &lt;code class=&quot;highlighter-rouge&quot;&gt;assert&lt;/code&gt;s above.
The second mode, used by our
second task, is the &lt;code class=&quot;highlighter-rouge&quot;&gt;cover&lt;/code&gt; mode.  We’ll use this to make certain our
&lt;code class=&quot;highlighter-rouge&quot;&gt;cover&lt;/code&gt; statement is reached.  The final option, &lt;code class=&quot;highlighter-rouge&quot;&gt;multiclock on&lt;/code&gt;, applies
to both tasks.  This option tells
&lt;a href=&quot;https://symbiyosys.readthedocs.io/en/latest&quot;&gt;SymbiYosys&lt;/a&gt;
that we’ll be using the asynchronous or multiple clock capabilities of the
formal solvers.&lt;/p&gt;

&lt;p&gt;For those who have been following
&lt;a href=&quot;https://symbiyosys.readthedocs.io/en/latest&quot;&gt;SymbiYosys&lt;/a&gt;
development, this option replaces the &lt;code class=&quot;highlighter-rouge&quot;&gt;clk2fflogic&lt;/code&gt;
&lt;a href=&quot;http://www.clifford.at/yosys/&quot;&gt;yosys&lt;/a&gt;
option.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;[options]
prove: mode prove
cover: mode cover
multiclock on&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The third section is the &lt;code class=&quot;highlighter-rouge&quot;&gt;[engines]&lt;/code&gt; section.  This particular design doesn’t
really need any particular engine.  We’ll pick
&lt;a href=&quot;http://yices.csl.sri.com&quot;&gt;yices&lt;/a&gt;
therefore, since it is a good general purpose engine.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;[engines]
smtbmc yices&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Alternatively, we might have just stated &lt;code class=&quot;highlighter-rouge&quot;&gt;smtbmc&lt;/code&gt; without naming the
&lt;a href=&quot;http://yices.csl.sri.com&quot;&gt;yices&lt;/a&gt;
engine, since
&lt;a href=&quot;http://yices.csl.sri.com&quot;&gt;yices&lt;/a&gt; is the default engine anyway.&lt;/p&gt;

&lt;p&gt;That leaves two sections left.  The fourth section lists the commands that
&lt;a href=&quot;http://www.clifford.at/yosys/&quot;&gt;yosys&lt;/a&gt;
itself will use to prepare our design for the
&lt;a href=&quot;http://yices.csl.sri.com&quot;&gt;formal solver&lt;/a&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;[script]
read_verilog -formal areset.v
prep -top areset&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The final section lists all the files in our design–in this case, just
&lt;code class=&quot;highlighter-rouge&quot;&gt;areset.v&lt;/code&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;[files]
areset.v&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;We’re now ready to run
&lt;a href=&quot;https://symbiyosys.readthedocs.io/en/latest&quot;&gt;SymbiYosys&lt;/a&gt;!&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span class=&quot;gp&quot;&gt;&amp;gt; &lt;/span&gt;sby -f areset.sby&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;There’s really not much more to it.  That’s all that’s required to
formally verify
a simple
&lt;a href=&quot;/examples/areset.v&quot;&gt;asynchronous reset&lt;/a&gt;
design.&lt;/p&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;Proving that this &lt;a href=&quot;/examples/areset.v&quot;&gt;asynchronous reset to synchronous release
module&lt;/a&gt;
works may seem trivial, but it does demonstrate a lot of the capabilities of the
open source formal tools.  For example, did you notice that this proof applies
to &lt;em&gt;any&lt;/em&gt; clock structure?&lt;/p&gt;

&lt;p&gt;There are several other simple designs that can be proven just like this one.
Examples include a clock gate, clock switch, input or output DDR components
or even SERDES implementations.
I discuss each these projects in my Formal Verification course, before
offering them as student exercises.  &lt;a href=&quot;https://www.blueletterbible.org/kjv/jas/4/15&quot;&gt;If the Lord is
willing&lt;/a&gt;,
we’ll continue with these techniques to create and then &lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formally
verify&lt;/a&gt; an
&lt;a href=&quot;https://www.sunburst-design.com/papers/CummingsSNUG2002SJ_FIFO1.pdf&quot;&gt;asynchronous FIFO&lt;/a&gt;
as a future post.&lt;/p&gt;

&lt;hr /&gt;&lt;p&gt;&lt;em&gt;Come now, and let us reason together, saith the LORD: though your sins be as scarlet, they shall be as white as snow; though they be red like crimson, they shall be as wool.  (Is 1:18)&lt;/em&gt;</description>
        <pubDate>Thu, 12 Apr 2018 00:00:00 -0400</pubDate>
        <link>http://zipcpu.com/formal/2018/04/12/areset.html</link>
        <guid isPermaLink="true">http://zipcpu.com/formal/2018/04/12/areset.html</guid>
        
        
        <category>formal</category>
        
      </item>
    
      <item>
        <title>What would you like to see on the ZipCPU blog?</title>
        <description>&lt;p&gt;The &lt;a href=&quot;http://zipcpu.com/&quot;&gt;ZipCPU blog&lt;/a&gt; has recently picked
up a lot of readers in light of my
&lt;a href=&quot;/blog/2018/04/02/formal-cpu-bugs.html&quot;&gt;recent on-going work&lt;/a&gt;
to &lt;a href=&quot;/blog/2018/04/02/formal-cpu-bugs.html&quot;&gt;formally verify&lt;/a&gt;
the entire &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;To all of those new readers, &lt;em&gt;Welcome!&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;The &lt;a href=&quot;http://zipcpu.com/&quot;&gt;ZipCPU blog&lt;/a&gt; is dedicated to helping
FPGA designers avoid getting stuck in
&lt;a href=&quot;/blog/2017/05/19/fpga-hell.html&quot;&gt;FPGA Hell&lt;/a&gt;–a place where
&lt;a href=&quot;/blog/2017/09/14/even-i-get-stuck.html&quot;&gt;your design doesn’t work and you can’t figure out why
not&lt;/a&gt;.  To this end,
I’ve presented techniques for &lt;a href=&quot;/blog/2017/06/21/looking-at-verilator.html&quot;&gt;simulating your design using
Verilator&lt;/a&gt;,
&lt;a href=&quot;https://github.com/ZipCPU/dbgbus/blob/master/hexbus/README.md&quot;&gt;how to build a debugging
bus&lt;/a&gt; for
command, control, and internal register and state inspection, &lt;a href=&quot;/bog/2017/06/08/simple-scope.html&quot;&gt;how to build
your own internal logic
analyzer&lt;/a&gt;,
&lt;a href=&quot;/blog/2017/07/08/getting-started-with-wbscope.html&quot;&gt;how to use my own wishbone
scope&lt;/a&gt;,
&lt;a href=&quot;/blog/2017/07/31/vcd.html&quot;&gt;how the VCD file format expresses your logic
trace&lt;/a&gt;,
&lt;a href=&quot;/dsp/2017/07/24/dsp-debugging.html&quot;&gt;how to debug a DSP
algorithm&lt;/a&gt;,
&lt;a href=&quot;/blog/2017/06/17/why-network-debugging.html&quot;&gt;network debugging&lt;/a&gt;,
and more.&lt;/p&gt;

&lt;p&gt;Recently I’ve started learning about &lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal
verification&lt;/a&gt;,
and so I’ve added &lt;a href=&quot;/formal/formal.html&quot;&gt;that
topic&lt;/a&gt;
to my list as well.  As a result there have now been
&lt;a href=&quot;/formal/formal.html&quot;&gt;several articles&lt;/a&gt;
on how to &lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formally
verify&lt;/a&gt;
your logic as and after you have put it together, and &lt;a href=&quot;/blog/2018/03/14/is-formal-hard.html&quot;&gt;the value of formal
verification&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;What you as a reader need to know, however, is that these articles are
&lt;a href=&quot;https://www.patreon.com/ZipCPU&quot;&gt;sponsor supported&lt;/a&gt;.  If you find this blog
valuable, and would like to see it continue, then please consider becoming
one of my &lt;a href=&quot;https://www.patreon.com/ZipCPU&quot;&gt;Patreon Sponsors&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;One of the perks of being a
&lt;a href=&quot;https://www.patreon.com/ZipCPU&quot;&gt;sponsor&lt;/a&gt;
is that I am responsive to the topics my
&lt;a href=&quot;https://www.patreon.com/ZipCPU&quot;&gt;sponsors&lt;/a&gt;
are interested in.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.patreon.com/ZipCPU&quot;&gt;sponsors&lt;/a&gt;.
So, here’s a short list of some of the upcoming topics which I think would be
fun to post about.  If you are one of my
&lt;a href=&quot;https://www.patreon.com/ZipCPU&quot;&gt;sponsors&lt;/a&gt;,
then please consider yourself invited to contact me and let me know
which of these (or other) topics you might be interested in.  There
is also a more complete list of both past and upcoming topics in the site
&lt;a href=&quot;/topics.html&quot;&gt;topics&lt;/a&gt; list as well.&lt;/p&gt;

&lt;p&gt;So, without further delay, here are some of the topics I am considering
writing about in the near future, should &lt;a href=&quot;https://www.blueletterbible.org/kjv/jas/4/15&quot;&gt;the Lord be
willing&lt;/a&gt;:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;ZBasic ZipCPU Peripheral&lt;/strong&gt;: Some time ago, I promised I was going to
discuss how easy it was to add a peripheral to the
&lt;a href=&quot;https://github.com/ZipCPU/zbasic&quot;&gt;ZBasic&lt;/a&gt;
using &lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt;.
I am still fully intending to do this, although I am somewhat struggling to
decide what that example peripheral should be–there are just too many
&lt;a href=&quot;https://github.com/ZipCPU?tab=repositories&quot;&gt;possibilities&lt;/a&gt;.  Feel free
to make a suggestion if you would like.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Quadratic Sinewave generation&lt;/strong&gt;: &lt;a href=&quot;/dsp/2017/08/30/cordic.html&quot;&gt;CORDIC sinewave
generation&lt;/a&gt; is really cool,
but it can also be logically expensive within an FPGA.
A potentially cheaper algorithm, requiring only two multiplies, would be to
apply our &lt;a href=&quot;/dsp/2018/03/30/quadratic.html&quot;&gt;quadratic interpolation
techniques&lt;/a&gt;
to generating a cleaner sine wave.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Asynchronous FIFO&lt;/strong&gt;: I have a nice formal proof of &lt;a href=&quot;http://www.sunburst-design.com/papers/CummingsSNUG2002SJ_FIFO1.pdf&quot;&gt;Cliff Cummings’
asynchronous FIFO
design&lt;/a&gt;
that I think would be valuable to present as well.  Unlike many of &lt;a href=&quot;/formal/formal.html&quot;&gt;my other
formal articles&lt;/a&gt;, this one requires
a formal solution across more than one clock domain, and for arbitrary
clock speeds.  This will add to the interest and value of it.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Ethernet CRC&lt;/strong&gt;: When I recently built a Ethernet CRC module for the 1Gb
Ethernet port of the &lt;a href=&quot;https://store.digilentinc.com/nexys-video-artix-7-fpga-trainer-board-for-multimedia-applications&quot;&gt;Nexys Video
board&lt;/a&gt;,
I was surprised at how much formal methods could help simplify
the complicated math of a multi-stepping CRC generator.  This would
therefore be a fun topic to share, as there is a lot of practical
information within it.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Dual I/O SPI flash&lt;/strong&gt;: While I am personally quite biased towards a &lt;a href=&quot;http://opencores.org/project,qspiflash&quot;&gt;Quad
SPI flash implementation&lt;/a&gt;,
recent events have led me to need to build a
&lt;em&gt;Dual I/O SPI flash&lt;/em&gt; implementation for a couple of logic challenged
implementations.  This means that this controller should be simple enough to
both present and understand, and makes a nice blog topic&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;TinyFPGA&lt;/strong&gt;: I’m also building a &lt;a href=&quot;https://github.com/ZipCPU/tinyzip&quot;&gt;TinyFPGA BX
design&lt;/a&gt; using the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;, and would love to blog about
this design.  Yes, the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; does
fit nicely on that board with room to spare (when &lt;a href=&quot;https://github.com/ZipCPU/tinyzip/blob/master/rtl/cpu/cpudefs.v&quot;&gt;properly
trimmed&lt;/a&gt;),
however my &lt;a href=&quot;https://github.com/ZipCPU/s6soc/blob/master/rtl/qflashxpress.v&quot;&gt;minimal flash
controller&lt;/a&gt;
needed to be redesigned, and my C++ &lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/sim/verilated/qspiflashsim.cpp&quot;&gt;flash
simulator&lt;/a&gt;
needed to be adjusted to get this to work.  Once I’ve finished verifying
that I can program and run the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
on this board, then it would be fun to describe my experiences.  Because of
the dependence upon the flash controller, however, this post would follow the
discussion of the &lt;strong&gt;Dual I/O SPI flash&lt;/strong&gt; design.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Some Simple Formal Verification Proofs&lt;/strong&gt;: It might be nice to return to our
(event) &lt;a href=&quot;/blog/2017/06/02/generating-timing.html&quot;&gt;timing control solutions
post&lt;/a&gt;,
and take a new look at them in light of &lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal
verification&lt;/a&gt;.
For example, how would you verify that a timer provides you with the right
number of clock ticks, or how would you speed up an otherwise exceptionally
long proof.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Prefetch with Cache&lt;/strong&gt;: The
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; has a 1-way instruction
cache that would be fun to present, and would also conclude our discussion
of prefetch methods.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Data Movement&lt;/strong&gt;: One of the sad realities of FPGA work is that its not all
about data transformation.  There’s a lot to be done in data movement as well.&lt;/p&gt;

    &lt;p&gt;The &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZiPCPU&lt;/a&gt; contains a
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/wbdmac.v&quot;&gt;DMA controller&lt;/a&gt;
that can be set up to automatically move data from one place to another within
any &lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;wishbone based
design&lt;/a&gt;.  &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/wbdmac.v&quot;&gt;This
component&lt;/a&gt;,
and its formal properties would be useful to many of my readers.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Abstraction in Formal Verification&lt;/strong&gt;: The recent
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
&lt;a href=&quot;/blog/2018/04/02/formal-cpu-bugs.html&quot;&gt;verification work&lt;/a&gt;
depends heavily on formal verification concepts of abstraction and
invariance.  Both techniques are useful when trying to break a complicated
design, such as a full CPU, down into its subcomponents.&lt;/p&gt;

    &lt;p&gt;This article would present abstraction.  In short, abstraction is based upon
the statement that if &lt;code class=&quot;highlighter-rouge&quot;&gt;A&lt;/code&gt; implies &lt;code class=&quot;highlighter-rouge&quot;&gt;B&lt;/code&gt;, then &lt;code class=&quot;highlighter-rouge&quot;&gt;A&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;C&lt;/code&gt; must also imply
&lt;code class=&quot;highlighter-rouge&quot;&gt;B&lt;/code&gt;.  The figures and outline of this lesson would be taken from the
formal verification course I’ve put together for
&lt;a href=&quot;https://www.symbioticeda.com&quot;&gt;Symbiotic EDA&lt;/a&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Invariance in Formal Verification&lt;/strong&gt;: Invariance is a second very powerful
tool that can be used to simplify the formal prove of a component.  Put
simply, if you can prove the &lt;code class=&quot;highlighter-rouge&quot;&gt;A&lt;/code&gt; is true, you no longer need to prove &lt;code class=&quot;highlighter-rouge&quot;&gt;A&lt;/code&gt;
anymore.  The difference over what can, and cannot, be proven using this
technique can be drastic.&lt;/p&gt;

    &lt;p&gt;The figures and outline of this lesson would also be taken from the
formal verification course I’ve put together for
&lt;a href=&quot;https://www.symbioticeda.com&quot;&gt;Symbiotic EDA&lt;/a&gt;, as with the potential
abstraction course discussed above.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;More filtering&lt;/strong&gt;: We left our discussion of filtering incomplete, and
so I’d still like to come back to demonstrate both symmetric and halfband
filters.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Dhrystone&lt;/strong&gt;: Also on my list of items to discuss is Dhrystone, the
outdated-yet-still-useful CPU bench mark.  For all of you who are
interested in comparing your CPU’s performance against Dhrystone, this
article would take a quick look at how Dhrystone can be run within a
Verilator simulation, and how I’ve gone about interpreting the results.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Synchronization&lt;/strong&gt;: One common problem in &lt;a href=&quot;/dsp/dsp.html&quot;&gt;digital signal
processing&lt;/a&gt; is the
“two-clock” problem where data comes into the algorithm on one clock, and
yet needs to be output on the edges of an unrelated clock.  Now that we’ve
spent some time with
&lt;a href=&quot;/dsp/2018/03/30/quadratic.html&quot;&gt;interpolation&lt;/a&gt;, as well as
&lt;a href=&quot;/dsp/2017/12/14/logic-pll.html&quot;&gt;how to build a simple PLL
module&lt;/a&gt;, it only makes
sense that we would connect these two concepts to be able to synchronize
two data streams.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Generating an Arbitrary Clock Signal&lt;/strong&gt;: I also have a simple design
component that can be used to generate a clock signal at an arbitrary
frequency, without requiring any additional clock chips.  (The FPGA still
needs its input clock.)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Building a HyperRAM controller&lt;/strong&gt;:
&lt;a href=&quot;http://www.cypress.com/products/hyperram-memory&quot;&gt;HyperRAM&lt;/a&gt; is a powerful
RAM communication protocol.  Unlike
DDR3 SDRAM, building a controller for
&lt;a href=&quot;http://www.cypress.com/products/hyperram-memory&quot;&gt;HyperRAM&lt;/a&gt;
doesn’t require undocumented chip features.  This article would discuss
such a controller, both how to build it as well as how to formally verify
that it works.&lt;/p&gt;

    &lt;p&gt;If there’s enough demand, a separate article could discuss how to build a
simulation component for this device.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;If you’ve made it this far, let share this with you: I’m creating today
a &lt;a href=&quot;/formal/formal.html&quot;&gt;formal page&lt;/a&gt; which will capture
all of my formal verification posts.  This should make it easier for someone
who is only interested in &lt;a href=&quot;/formal/formal.html&quot;&gt;formal
verification&lt;/a&gt; to find articles that
discuss or provide examples of &lt;a href=&quot;/formal/formal.html&quot;&gt;formal
verification&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/formal/formal.html&quot;&gt;This new topical page&lt;/a&gt;
joins my prior &lt;a href=&quot;/dsp/dsp.html&quot;&gt;DSP topical page&lt;/a&gt;.  However,
&lt;em&gt;all&lt;/em&gt; articles will remain on the blog’s main page.&lt;/p&gt;

&lt;p&gt;Finally, if you are one of my 
&lt;a href=&quot;https://www.patreon.com/ZipCPU&quot;&gt;Patreon sponsors&lt;/a&gt;,
please feel free to contact me at the e-mail address below and let me know
which, if any, of these topics you might be interested in.  Even better,
these are only suggestions.  If you are interested in a topic that isn’t
listed above, please feel free to share that topic with me as well.  Just please
be aware that topics not on this list, such as creating a GCC port, might
take a bit longer to work up to.&lt;/p&gt;

&lt;p&gt;If you are not one of my 
&lt;a href=&quot;https://www.patreon.com/ZipCPU&quot;&gt;Patreon sponsors&lt;/a&gt;,
and yet you find this
&lt;a href=&quot;http://zipcpu.com/&quot;&gt;blog valuable&lt;/a&gt;, please consider joining
the team!  While I have no intention of restricting
&lt;a href=&quot;http://zipcpu.com/&quot;&gt;the blog&lt;/a&gt;’s content to subscribers only,
your support will help
&lt;a href=&quot;http://zipcpu.com/&quot;&gt;this blog&lt;/a&gt; continue into the future.&lt;/p&gt;
&lt;hr /&gt;&lt;p&gt;&lt;em&gt;The husbandman that laboureth must be first partaker of the fruits. (2Tim 2:6)&lt;/em&gt;</description>
        <pubDate>Thu, 05 Apr 2018 00:00:00 -0400</pubDate>
        <link>http://zipcpu.com/blog/2018/04/05/topatreon.html</link>
        <guid isPermaLink="true">http://zipcpu.com/blog/2018/04/05/topatreon.html</guid>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>Will formal methods ever find a bug in a working CPU?</title>
        <description>&lt;p&gt;Today, I’m starting what will likely be the slow process of
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formally verifying&lt;/a&gt;
the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;.  I’m going to use
&lt;a href=&quot;http://www.clifford.at/yosy&quot;&gt;yosys&lt;/a&gt; for this process initially, but given
&lt;a href=&quot;https://symbiyosys.readthedocs.io/en/latest&quot;&gt;SymbiYosys&lt;/a&gt;’s ability to
run multiple formal configurations as separate tasks, I will probably need to
switch after I get some distance along.&lt;/p&gt;

&lt;p&gt;At this point in the game, I’ve already &lt;a href=&quot;/blog/2018/01/22/formal-progress.html&quot;&gt;formally proven all of the
components&lt;/a&gt;
of the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;.
What remains is to prove the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/zipcpu.v&quot;&gt;CPU itself&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;So here’s my question: How many bugs would you expect to find in a “working”
soft-core CPU?  One?  Ten?  Twenty?  One hundred?  Shall we count?  I propose
keeping a running log of the bugs I find in the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; while using
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formally methods&lt;/a&gt;.
Perhaps this log will help to convince you the value of
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formally methods&lt;/a&gt;,
perhaps not.  Either way, I’ll keep it accurate to the information I discover.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;The memory manager refused to release the bus if the response came back
on the same cycle.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Certain errors should cause the CPU to halt–such as encountering a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_(computing)&quot;&gt;bus&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_error&quot;&gt;error&lt;/a&gt;
when reading from instruction memory.  Due to a (now locally fixed) bug
in the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;, these errors
would not cause the CPU to halt if they were one of the first couple
instructions.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; is designed so that
memory reads or writes &lt;em&gt;never&lt;/em&gt; need to be rolled back. This is to
facilitate using the memory bus for reading and
writing peripherals, such as the serial port.  Reads from such peripherals
have side effects that cannot be rolled back.  The formal methods however,
discovered an example where reading into the program counter, such as during
an indirect jump, my cause a following memory instruction to need to be
rolled back.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;’s current approach to
the compressed instruction set (CIS)
is to prevent the CPU from interrupting in the middle of a CIS instruction.
Formal methods, however, found an internal accounting bug which prevented
this logic from working properly.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Several bugs have been found in the debug infrastructure, allowing an
external debugger to change registers internal to the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;.&lt;/p&gt;

    &lt;p&gt;In one example, this was violating the rules the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; uses when issuing
pipelined memory instructions.&lt;/p&gt;

    &lt;p&gt;In another example, during a divide that was to write its results into &lt;code class=&quot;highlighter-rouge&quot;&gt;R0&lt;/code&gt;,
the external debug infrastructure was allowed to write to a register,
say &lt;code class=&quot;highlighter-rouge&quot;&gt;R1&lt;/code&gt;.  This would cause the divide to write its results into &lt;code class=&quot;highlighter-rouge&quot;&gt;R1&lt;/code&gt; upon
completion, rather than &lt;code class=&quot;highlighter-rouge&quot;&gt;R0&lt;/code&gt;.&lt;/p&gt;

    &lt;p&gt;The &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; has
therefore been adjusted so that the debug infrastructure
can only modify the value of a register if the CPU has been fully halted.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The flag indicating that the CPU is fully halted was not properly
implemented.  Specifically, the CPU might declare it was halted in the middle
of a CIS instruction when the second half of the instruction still needed
to be flushed through the pipeline.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;On a multi-cycle ALU operation (i.e. one of the multiplies), the flags
were being set before the operation was complete&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The clock-less version of the instruction decoder, used by the formal
properties alone to know what to expect from an instruction, didn’t match
the actual instruction decoder when it came to whether or not SIM
instructions should cause an illegal interrupt exception&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The divide wouldn’t wait for a multiply to complete before starting.  Such
a multiply might have provided the divide with its operand, but due to this
bug the divide input would’ve been the prior value of the register.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Under certain circumstances in the pipeline, the break instruction would
get bypassed.&lt;/p&gt;

    &lt;p&gt;I’m actually looking forward to simplifying this break logic by merging it
with the illegal instruction logic, since the two do the same thing in
different ways.  I’m holding off on this for now, however.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Writes to the user PC register, such as by the debug port or even the ALU,
   while in supervisor (not user) mode, would corrupt any logic depending
   upon the user PC register that was already in the pipeline.  Hence, the
   pipeline needs to be cleared following any such write.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;After making several fixes, the memory instruction following an illegal
instruction would be issued.  This error isn’t so much a bug in the working
CPU, but rather a bug in my pipeline logic rewrite.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Perhaps this would never happen.  However, the memory controller wouldn’t
stall when it ran out of internal memory to keep track of where the
write back results would be written to.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;On an early branch or an illegal instruction, the valid memory instruction
flag was still being set, eventually violating the contract with the memory
device.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The switch to interrupt flag wasn’t waiting for any ongoing memory
operations to complete first&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;On a divide error, the memory unit would still issue an instruction.
This creates a problem because a memory operation to a peripheral device
cannot be withdrawn, as the CPU tries to switch to its exception handling
code.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Under certain circumstances, the CPU would continue issuing instructions
following a bus error or division by zero error.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;At this point, I’m going to stop counting.  It’s not because there are so
many errors remaining, but rather because its no longer clear which of the
remaining errors were originally
in the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
and which ones were added while trying to fix the earlier bugs.&lt;/p&gt;

&lt;h2 id=&quot;bugs-in-the-formal-properties&quot;&gt;Bugs in the Formal Properties&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;The formal properties within the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;core&lt;/a&gt;,
as well as the abstracted components, are still quite immature.
Multiple bugs are still being found within them.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The &lt;a href=&quot;https://github.com/ZipCPU/blob/master/rtl/ex/wbdblpriarb.v&quot;&gt;Wishbone
arbiter&lt;/a&gt;
had a careless assumption within it.  This prevented the arbiter from ever
being fully tested and verified.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
recognizes two memory regions: a local region for CPU-specific
peripherals from &lt;code class=&quot;highlighter-rouge&quot;&gt;0xff000000&lt;/code&gt; to &lt;code class=&quot;highlighter-rouge&quot;&gt;0xffffffff&lt;/code&gt; (used by the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/zipsystem.v&quot;&gt;ZipSystem&lt;/a&gt;,
and a more global memory
region (everything else).  Crossing regions within the same memory operation
is a fault that needs to be prevented in software, and the formal
properties for describing this fault were &lt;code class=&quot;highlighter-rouge&quot;&gt;assert()&lt;/code&gt; functions rather than
&lt;code class=&quot;highlighter-rouge&quot;&gt;restrict()&lt;/code&gt; functions.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;current-status&quot;&gt;Current status&lt;/h2&gt;

&lt;p&gt;I’m currently fully verifying the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;’s
capability using an &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/formal/bench/formal/abs_prefetch.v&quot;&gt;abstract
prefetch&lt;/a&gt;,
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/formal/bench/formal/abs_div.v&quot;&gt;abstract
divide&lt;/a&gt;,
and an &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/dev/bench/formal/abs_mpy.v&quot;&gt;abstract
multiply&lt;/a&gt;.
Thanks to SymbiYosys and “abc pdr”, the pipeline properties I’ve now verified
constitutes a full formal proof (BMC + induction) of the first set of
formal properties for the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;. 
A second stage of properties have since been added, dependent upon the
synthesizer define &lt;code class=&quot;highlighter-rouge&quot;&gt;PHASE_ONE&lt;/code&gt;. The proof of this second set of properties
remains ongoing.&lt;/p&gt;

&lt;p&gt;First, the formal properties:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;I’ve proven that the assumptions within all of the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;’s
sub-modules hold.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;I’ve manage to verify that the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;’s
pipeline logic won’t accidentally “delete” an instruction in the pipeline.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;I’ve also added the properties that the operands given to the
ALU, memory, or divide unit, need to be valid.&lt;/p&gt;

    &lt;p&gt;This portion of the proof is ongoing.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Following any ALU or divide instruction, only the correct register will
ever be written if at all–I haven’t dealt with predicates yet.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;BREAK&lt;/code&gt; instructions never pass the OP stage as desired.  This makes certain
these instructions will not increment the PC when encountered.  This is
very similar to an illegal operand instruction, and the logic for these
may yet be merged.  For now, the &lt;code class=&quot;highlighter-rouge&quot;&gt;BREAK&lt;/code&gt; instruction bypasses the ALU
stage of the CPU as desired.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;I haven’t gotten to the cover properties yet, those are yet to come.  As a
result, I may have carelessly assumed away a portion of the proof and can’t
tell yet.&lt;/p&gt;

&lt;p&gt;Here’s how far I’ve gotten:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Without pipelining the memory bus, the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; made it for a full 40 clocks
in a bounded model check.  This was the extent of the test.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;With the pipelined memory bus, the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; has formally passed
&lt;em&gt;all of the formal properties&lt;/em&gt; now written for it&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The updated formal code is currently in a git repository branch that hasn’t
(yet) been pushed.  Upon request I have pushed components of this
proof into the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/tree/dev&quot;&gt;dev branc&lt;/a&gt;,
although I’d still be a bit embarrassed to present the (not quite working)
CPU yet.  This includes the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/dev/bench/formal/abs_mpy.v&quot;&gt;abstract
multiply&lt;/a&gt;
mentioned above, as well as the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/dev/rtl/core/mpyop.v&quot;&gt;multiply
module&lt;/a&gt; that it
replaces.&lt;/p&gt;

    &lt;p&gt;My apologies to all that have indicated an interest in seeing this code.
Thank you for your interest.  I guess it surprised me a bit.
I’m just not quite ready yet to post the code–mostly because things aren’t
fully working.  I do anticipate fully sharing this code in due time.  If
you are really interested in seeing this before it is complete, then
please send me an e-mail and I will consider placing it on
&lt;a href=&quot;https://gitlab.com&quot;&gt;gitlab&lt;/a&gt; where
&lt;a href=&quot;https://www.patreon.com/ZipCPU&quot;&gt;sponsors&lt;/a&gt; can have access to the current
work in progress.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;You can find and further follow my work through the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/tree/formal&quot;&gt;formal branch&lt;/a&gt;
of the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;github repository&lt;/a&gt;
for the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;.  Specifically,
you can find the properties that I’m working with at the bottom of the core
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/formal/rtl/core/zipcpu.v&quot;&gt;zipcpu.v&lt;/a&gt;
Verilog file.  I’m using a &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/formal/bench/formal/Makefile&quot;&gt;“make”
file&lt;/a&gt; within
the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/tree/bench/formal&quot;&gt;bench/forma&lt;/a&gt;
directory to control the process.&lt;/p&gt;
&lt;hr /&gt;&lt;p&gt;&lt;em&gt;Again, when the wicked man turneth away from his wickedness that he hath committed, and doeth that which is lawful and right, he shall save his soul alive.  (Ezek 18:27)&lt;/em&gt;</description>
        <pubDate>Mon, 02 Apr 2018 00:00:00 -0400</pubDate>
        <link>http://zipcpu.com/blog/2018/04/02/formal-cpu-bugs.html</link>
        <guid isPermaLink="true">http://zipcpu.com/blog/2018/04/02/formal-cpu-bugs.html</guid>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>Resurrection Day!</title>
        <description>&lt;p&gt;Buddha &lt;a href=&quot;https://en.wikipedia.org/wiki/Gautama_Buddha#Relics&quot;&gt;is dead&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Mohammed &lt;a href=&quot;https://en.wikipedia.org/wiki/Muhammad#Death_and_tomb&quot;&gt;is dead&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.blueletterbible.org/kjv/deu/34/1&quot;&gt;Moses died&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.blueletterbible/kjv/mat/27/50&quot;&gt;Jesus died&lt;/a&gt; as well, but unlike
these others &lt;a href=&quot;https://www.blueletterbible.org/kjv/mat/28/7&quot;&gt;He is dead no more&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;This simple fact &lt;a href=&quot;https://www.blueletterbible.org/kjv/act/17/31&quot;&gt;makes Christianity
different&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Today, we celebrate this difference.&lt;/p&gt;

&lt;h2 id=&quot;what-makes-jesus-special&quot;&gt;What makes Jesus special?&lt;/h2&gt;

&lt;p&gt;Jesus knew He was going to die.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;And as Moses lifted up the serpent in the wilderness
[&lt;a href=&quot;https://www.blueletterbible.org/kjv/num/21/8&quot;&gt;Num 21:8&lt;/a&gt;],
even so must the Son of man be lifted up [i.e. crucified]: That whosoever
believeth in him should not perish, but have eternal life.
(&lt;a href=&quot;https://www.blueletterbible.org/kjv/jhn/3/14&quot;&gt;John 3:14-15&lt;/a&gt;)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;This was His purpose in coming to the earth.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Now is my soul troubled; and what shall I say?  Father, save me from this
hour: but for this cause came I unto this hour.  Father, glorify thy name.
Then came there a voice from heaven, saying, I have both glorified it, and
will glorify it again.
(&lt;a href=&quot;https://www.blueletterbible.org/kjv/jhn/12/27&quot;&gt;John 12:27-28&lt;/a&gt;)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Jesus also knew that He could raise Himself up from the grave long before
He was put to death.  This was a commandment given to Him by His Father,
the one we call God.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Therefore doth my Father love me, because I lay down my life, that I might
take it again.  No man taketh it from me, but I lay it down of myself.
I have the power to lay it down, and I have the power to take it again.
This command have I received of my Father.
(&lt;a href=&quot;https://www.blueletterbible.org/kjv/jhn/10/17&quot;&gt;John 10:17-18&lt;/a&gt;)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;The disciples were falsely accused of hiding His body.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Saying, Say ye, His disciples came by night, and stole him away while we
slept.
(&lt;a href=&quot;https://www.blueletterbible.org/kjv/mat/28/13&quot;&gt;Mat 28:13&lt;/a&gt;).&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;In spite of this lie, no one found the missing body because there was no
missing body.  Jesus is no longer dead, He is risen!&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;And as they were afraid, and bowed down their faces to the earth, they
said unto them, “Why seek ye the living among the dead?”
(&lt;a href=&quot;https://www.blueletterbible.org/kjv/luk/24/5&quot;&gt;Luke 24:5&lt;/a&gt;)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;em&gt;(By the way, I love the song by this same name which comes from the musical
&lt;a href=&quot;https://www.youtube.com/watch?v=roxCbUndmR0&quot;&gt;The Choice&lt;/a&gt; by Nate Copeland.
[&lt;a href=&quot;https://www.youtube.com/watch?v=6bM3S5fBYec&quot;&gt;1&lt;/a&gt;],
[&lt;a href=&quot;https://www.youtube.com/watch?v=wZ-qPvYQNr4&quot;&gt;2&lt;/a&gt;],
[&lt;a href=&quot;https://www.youtube.com/watch?v=c2fg_hhDN94&quot;&gt;3&lt;/a&gt;],
[&lt;a href=&quot;https://www.youtube.com/watch?v=Osbuen8WkRI&quot;&gt;4&lt;/a&gt;])&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;The resurrection, evidenced by the empty tomb, proves the validity
of the message.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Because he hath appointed a day, in the which He will judge the world in
righteousness by that Man whom he hath ordained; whereof He hath given
assurance unto all men, in that He hath raised Him from the dead.
(&lt;a href=&quot;https://www.blueletterbible.org/kjv/act/17/31&quot;&gt;Acts 17:31&lt;/a&gt;)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Without the resurrection, there is no point in Christianity.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;And if Christ be not risen, then is our preaching vain, and your faith is
vain [i.e. useless or pointless].  Yea, and we are found false witnesses of
God [i.e. liars]; because we have testified of God that He raised up Christ:
whom He raised not up, if so be that the dead rise not.&lt;/p&gt;

  &lt;p&gt;For if the dead rise not, then is Christ not raised: and if Christ be not
raised, your faith is vain; ye are yet in your sins.
Then they also which are fallen asleep in Christ are perished.&lt;/p&gt;

  &lt;p&gt;If in this life only we have hope in Christ, we are of all men most miserable.
(&lt;a href=&quot;https://www.blueletterbible.org/kjv/1co/15/14&quot;&gt;1Cor 15:14-19&lt;/a&gt;)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Indeed, were there no resurrection, then there would be no hope in living.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;If after the manner of men I have fought with beasts at Ephesus, what
advantageth it me, if the dead rise not?  Let us eat and drink; for
tomorrow we die.
(&lt;a href=&quot;https://www.blueletterbible.org/kjv/eph/15/32&quot;&gt;Eph 15:32&lt;/a&gt;)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;But there is a resurrection!  We know this from the testimony of those who
have seen him.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;This Jesus hath God raised up, whereof we all are witnesses.
(&lt;a href=&quot;https://www.blueletterbible.org/kjv/act/4/32&quot;&gt;Acts 4:32&lt;/a&gt;)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;or again,&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;For I delivered unto you first of all that which I also received, how that
Christ died for our sins according to the scriptures;
And that he was buried, and that he rose again the third day according to
the scriptures:
And that he was seen of Cephas, then of the twelve: After that, he was seen
of above five hundred brethren at once; of whom the greater part remain to
this present, but some are fallen asleep.
After that, he was seen of James; then of all the apostles.
And last of all he was seen of me also, as of one born out of due time.
(&lt;a href=&quot;https://www.blueletterbible.org/kjv/jhn/10/17&quot;&gt;1 Cor 15:3-8&lt;/a&gt;)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;We also know this by the empty tomb, proving to all that He is the Christ!&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Therefore let all the house of Israel know assuredly, that God hath made
the same Jesus, whom ye have crucified, both Lord and Christ.
(&lt;a href=&quot;https://www.blueletterbible.org/kjv/act/4/36&quot;&gt;Acts 4:36&lt;/a&gt;)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;i-serve-a-risen-savior&quot;&gt;I serve a risen Savior&lt;/h2&gt;

&lt;p&gt;Because He lives, I have been
&lt;a href=&quot;https://www.blueletterbible.org/kjv/rom/8/1&quot;&gt;freed from my own personal sins&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Because He lives, I no longer need to live a life 
&lt;a href=&quot;https://www.blueletterbible.org/kjv/jhn/8/34&quot;&gt;controlled by my own wickedness&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Because He lives, &lt;a href=&quot;https://www.blueletterbible.org/kjv/jhn/10/28&quot;&gt;I have a
future&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Because He lives, &lt;a href=&quot;https://www.blueletterbible.org/kjv/col/3/23&quot;&gt;I blog&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Because He lives, &lt;a href=&quot;https://www.blueletterbible.org/kjv/jhn/6/37&quot;&gt;you may choose to have a future
  as well&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;If you know Christ, then
please join me today in celebrating the risen Savior, which is Christ the Lord.&lt;/p&gt;

&lt;p&gt;If you &lt;a href=&quot;https://www.blueletterbible.org/kjv/mat/7/23&quot;&gt;do not know Him&lt;/a&gt;,
or perhaps if you only know of or
&lt;a href=&quot;https://www.blueletterbible.org/kjv/jas/2/19&quot;&gt;about Him&lt;/a&gt;,
then please let me invite you discover Him through the letters His disciples
wrote describing their time with him:
&lt;a href=&quot;https://www.blueletterbible.org/kjv/mat/1&quot;&gt;Matthew&lt;/a&gt;,
&lt;a href=&quot;https://www.blueletterbible.org/kjv/mar/1&quot;&gt;Mark&lt;/a&gt;,
&lt;a href=&quot;https://www.blueletterbible.org/kjv/luk/1&quot;&gt;Luke&lt;/a&gt; and
&lt;a href=&quot;https://www.blueletterbible.org/kjv/jhn/1&quot;&gt;John&lt;/a&gt;.&lt;/p&gt;

&lt;hr /&gt;&lt;p&gt;&lt;em&gt;He is not here: for He is risen, as He said.  Come, see the place where the Lord lay. (Matthew 28:6)&lt;/em&gt;</description>
        <pubDate>Sun, 01 Apr 2018 00:00:00 -0400</pubDate>
        <link>http://zipcpu.com/blog/2018/04/01/resurrection-day.html</link>
        <guid isPermaLink="true">http://zipcpu.com/blog/2018/04/01/resurrection-day.html</guid>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>Quadratic fits are entirely inappropriate for DSP</title>
        <description>&lt;p&gt;Waveforms in nature have two characteristics that are difficult to handle in
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_signal_processing&quot;&gt;signal processing&lt;/a&gt;
applications: natural waveforms are
&lt;a href=&quot;https://en.wikipedia.org/wiki/Continuous_function&quot;&gt;continuous&lt;/a&gt;
and they are tend to last for a &lt;em&gt;long time&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;This is to be contrasted to the “signals” that &lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_signal_processing&quot;&gt;Digital Signal Processing
(DSP)&lt;/a&gt;
algorithms act upon.
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_signal_processing&quot;&gt;DSP&lt;/a&gt;
algorithms are applied to &lt;em&gt;finite&lt;/em&gt; sections of
(typically) longer waveforms that have been
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;sampled&lt;/a&gt;
at evenly spaced intervals.&lt;/p&gt;

&lt;p&gt;This leads to a fundamental problem: if you want to work on a waveform
as though it were
&lt;a href=&quot;https://en.wikipedia.org/wiki/Continuous_function&quot;&gt;continuous&lt;/a&gt;
instead of
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;sampled&lt;/a&gt;,
then you need to figure out how to reconstruct what the signal
&lt;em&gt;should be&lt;/em&gt; between the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;sample&lt;/a&gt;
points.  Perhaps you need to
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sample-rate_conversion&quot;&gt;resample&lt;/a&gt;
that signal at some new rate whose ratio is far from simple when compared
to the old rate.  Perhaps you need to
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sample-rate_conversion&quot;&gt;resample&lt;/a&gt;
your signal at locations driven by a tracking loop, such as a digital receiver
would need to do.  Perhaps you just want to zoom in on a screen plot of your
signal and &lt;a href=&quot;/dsp/2017/07/29/series-linear-interpolation.html&quot;&gt;linear
interpolation&lt;/a&gt;
leaves you with a signal that looks nothing like the original reality.  Either
way, if you want to
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;recover&lt;/a&gt;
what your signal does between
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;samples&lt;/a&gt;,
you’ll want to apply some form of
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolation&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;In the past, we’ve looked at both a &lt;a href=&quot;/dsp/2017/06/06/simple-interpolator.html&quot;&gt;sample-and-hold
“interpolator”&lt;/a&gt;
and a &lt;a href=&quot;/dsp/2017/07/29/series-linear-interpolation.html&quot;&gt;linear
interpolator&lt;/a&gt;
as possible subsample
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolation&lt;/a&gt; methods.
However, if &lt;a href=&quot;/dsp/2017/07/29/series-linear-interpolation.html&quot;&gt;linear
interpolation&lt;/a&gt;
isn’t good enough for your application, then the next best approach is some
form of &lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial_interpolation&quot;&gt;quadratic
interpolation&lt;/a&gt;.
Indeed, it’s not that hard to take three points and generate a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Quadratic_function&quot;&gt;quadratic&lt;/a&gt;
that will pass through all three of them.&lt;/p&gt;

&lt;p&gt;Stop.  Now.  Don’t do that.  Really.  Don’t.&lt;/p&gt;

&lt;p&gt;In a moment I’ll show you why not.  Then I’ll show you a better approach.
Further, when &lt;a href=&quot;https://github.com/ZipCPU/interpolation/blob/master/rtl/quadratic/quadinterp.v&quot;&gt;implemented in
logic&lt;/a&gt;,
this better approach will still use only the same two hardware multiplies that
a quadratic fit would’ve used.&lt;/p&gt;

&lt;h2 id=&quot;why-interpolation&quot;&gt;Why interpolation&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;Interpolation&lt;/a&gt; is the term used
to describe an algorithm that can be used to create (or estimate) data points
between
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;samples&lt;/a&gt;.
This is often called
&lt;a href=&quot;https://en.wikipedia.org/wiki/Upsamplers&quot;&gt;upsampling&lt;/a&gt; in a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_signal_processing&quot;&gt;Signal Processing&lt;/a&gt;
context, with the difference between
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolating&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Upsamplers&quot;&gt;upsamplers&lt;/a&gt;
and those that are not
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolating&lt;/a&gt;
is that the output of an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;
is guaranteed to go through the original
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;sample&lt;/a&gt;
points, whereas this is not necessarily the case of a more generic
&lt;a href=&quot;https://en.wikipedia.org/wiki/Upsamplers&quot;&gt;upsampler&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Today, we’ll be discussing
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolators&lt;/a&gt;
that are also infinite
&lt;a href=&quot;https://en.wikipedia.org/wiki/Upsamplers&quot;&gt;upsamplers&lt;/a&gt;, such as those &lt;a href=&quot;/dsp/2018/01/16/interpolation-is-convolution.html&quot;&gt;we
discussed earlier&lt;/a&gt;
when proving that all such
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolators&lt;/a&gt;
could be modeled as
&lt;a href=&quot;https://en.wikipedia.org/wiki/Convolution&quot;&gt;convolutions&lt;/a&gt;
of discrete-time signals with a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Continuous_function&quot;&gt;continuous&lt;/a&gt;
time filter.  Such 
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolators&lt;/a&gt;
can form the basis of an &lt;em&gt;asynchronous &lt;a href=&quot;https://en.wikipedia.org/wiki/Sample-rate_conversion&quot;&gt;sample rate
converter&lt;/a&gt;&lt;/em&gt;.
For our purposes today, though, we will limit our discussion to
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolators&lt;/a&gt;
which are simply the result of a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Piecewise&quot;&gt;piecewise&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial&quot;&gt;polynomial&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Upsamplers&quot;&gt;upsamplers&lt;/a&gt;.  We’ll even limit the
discussion further to that subset of all
&lt;a href=&quot;https://en.wikipedia.org/wiki/Piecewise&quot;&gt;piecewise&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial&quot;&gt;polynomial&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Upsamplers&quot;&gt;upsamplers&lt;/a&gt;
that is formed from quadratic
&lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial&quot;&gt;polynomials&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;I first learned the idea of
&lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial&quot;&gt;polynomial&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Upsamplers&quot;&gt;upsampling&lt;/a&gt;
from &lt;a href=&quot;http://ieeexplore.ieee.org/document/679201&quot;&gt;Harris&lt;/a&gt;,
although it seems as though
&lt;a href=&quot;http://ieeexplore.ieee.org/document/15483/&quot;&gt;Farrow&lt;/a&gt;
was the actual originator of the idea.  Hence, you might recognize our
ultimate solution as a
&lt;a href=&quot;http://ieeexplore.ieee.org/document/15483/&quot;&gt;Farrow&lt;/a&gt;
filter, although it may not look like any
&lt;a href=&quot;http://ieeexplore.ieee.org/document/15483/&quot;&gt;Farrow&lt;/a&gt;
filter you’ve seen before.  Even better, it will have provably better
asymptotic out of band performance than any
&lt;a href=&quot;http://ieeexplore.ieee.org/document/15483/&quot;&gt;Farrow&lt;/a&gt;
filter or approach I’ve seen published to date.&lt;/p&gt;

&lt;h2 id=&quot;the-problem-with-quadratic-fitting&quot;&gt;The Problem with Quadratic Fitting&lt;/h2&gt;

&lt;p&gt;I started out this post by declaring that using a quadratic fit to
the nearest three points were a horrible means of
&lt;a href=&quot;https://en.wikipedia.org/wiki/Upsamplers&quot;&gt;upsampling&lt;/a&gt;.
Let’s take a moment before going
further to see why this is the case.  We’ll do this by first creating a fit
to the nearest three points of a signal, and then examining what happens when
you extend this fit beyond those three points into the points nearby.&lt;/p&gt;

&lt;p&gt;As with any
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolation&lt;/a&gt;
problem, we’ll start with a signal, &lt;code class=&quot;highlighter-rouge&quot;&gt;x[n]&lt;/code&gt;.  I’ll
use the square brackets, &lt;code class=&quot;highlighter-rouge&quot;&gt;[]&lt;/code&gt;, to emphasize that this is a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;sampled signal&lt;/a&gt;
and hence only integer indices are allowed.  From this
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;sampled signal&lt;/a&gt;,
our goal will be to create a new signal, &lt;code class=&quot;highlighter-rouge&quot;&gt;y(t)&lt;/code&gt;, with a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Continuous_function&quot;&gt;continuous&lt;/a&gt;
index, &lt;code class=&quot;highlighter-rouge&quot;&gt;t&lt;/code&gt;–herein noted by the parentheses, &lt;code class=&quot;highlighter-rouge&quot;&gt;()&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;To create a quadratic fit, well pick three points from this signal,
&lt;code class=&quot;highlighter-rouge&quot;&gt;x[n-1]&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;x[n]&lt;/code&gt;, and &lt;code class=&quot;highlighter-rouge&quot;&gt;x[n+1]&lt;/code&gt;, and then fit a quadratic function, &lt;code class=&quot;highlighter-rouge&quot;&gt;f_n(t)&lt;/code&gt;
to these three points so that:&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/quadeqn-fit-genquad.png&quot; alt=&quot;f_n(t-n) = a(t-n)^2 + b(t-n) + c&quot; width=&quot;599&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Further, if we assume that our
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;samples&lt;/a&gt;
are spaced one unit apart, then&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/quadeqn-fit-triplet.png&quot; alt=&quot;&quot; width=&quot;203&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;The constant term of this quadratic
&lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial&quot;&gt;polynomial&lt;/a&gt;
is very simple to solve.  If we examine &lt;code class=&quot;highlighter-rouge&quot;&gt;t=n&lt;/code&gt;, then,&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/quadeqn-fit-fzero.png&quot; alt=&quot;f_0(0) = a(0)+b(0)+c&quot; width=&quot;418&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;The linear term is just a bit harder, but it can be obtained by subtracting
&lt;code class=&quot;highlighter-rouge&quot;&gt;f_n(-1)&lt;/code&gt; from &lt;code class=&quot;highlighter-rouge&quot;&gt;f_n(1)&lt;/code&gt;,&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/quadeqn-fit-fsub.png&quot; alt=&quot;&quot; width=&quot;605&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;In other words,&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/quadeqn-fit-b.png&quot; alt=&quot;&quot; width=&quot;296&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Getting the last coefficient is just a little bit more work, but follows from
adding the two end point values, &lt;code class=&quot;highlighter-rouge&quot;&gt;f_n(1)&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;f_n(-1)&lt;/code&gt; together,&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/quadeqn-fit-fsum.png&quot; alt=&quot;&quot; width=&quot;531&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;This yields our quadratic coefficint,&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/quadeqn-fit-a.png&quot; alt=&quot;&quot; width=&quot;367&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Therefore, we can fit any three
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;sample&lt;/a&gt;
values to the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial&quot;&gt;polynomial&lt;/a&gt;,&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/quadeqn-fit-complete.png&quot; alt=&quot;&quot; width=&quot;632&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Fig 1 shows an example of one such fit.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 1. An example quadratic fit of three points&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/quadeqn-fit-result.png&quot; alt=&quot;&quot; width=&quot;410&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;At first glance, this looks pretty good.  We started with three data points,
and now we’ve created a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Continuous_function&quot;&gt;continuous&lt;/a&gt;
line that smoothly
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolates&lt;/a&gt;
between these three data points.  What could the problem be?&lt;/p&gt;

&lt;p&gt;The problem comes into play when you expand out from these three data points
and examine the infinite set of
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;samples&lt;/a&gt;
that are the incoming data.  In this case, the quadratic fit turns from a nice
&lt;a href=&quot;https://en.wikipedia.org/wiki/Continuous_function&quot;&gt;continuous&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;,
to discontinuous
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;,
where the discontinuity takes place halfway between any pair of
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;samples&lt;/a&gt;.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 2. Using a quadratic fit across multiple sample points create discontinuities&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/interpolation-discontinuous-quadratic.png&quot; alt=&quot;&quot; width=&quot;603&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;What happened?&lt;/p&gt;

&lt;p&gt;What happened was that we chose to only use &lt;code class=&quot;highlighter-rouge&quot;&gt;f_n&lt;/code&gt; between &lt;code class=&quot;highlighter-rouge&quot;&gt;n-1/2&lt;/code&gt; and
&lt;code class=&quot;highlighter-rouge&quot;&gt;n+1/2&lt;/code&gt;.  Once past &lt;code class=&quot;highlighter-rouge&quot;&gt;n+1/2&lt;/code&gt;, we switched to a new
&lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial&quot;&gt;polynomial&lt;/a&gt;,
&lt;code class=&quot;highlighter-rouge&quot;&gt;f_{n+1}&lt;/code&gt;.  Since we did nothing to constrain our
&lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial&quot;&gt;polynomial&lt;/a&gt;
solution so that it was
&lt;a href=&quot;https://en.wikipedia.org/wiki/Continuous_function&quot;&gt;continuous&lt;/a&gt;
between data sets, the result wasn’t
&lt;a href=&quot;https://en.wikipedia.org/wiki/Continuous_function&quot;&gt;continuous&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Before going further, let’s consider my previous statement that “&lt;a href=&quot;/dsp/2018/01/16/interpolation-is-convolution.html&quot;&gt;Interpolation
is just a special type of
convolution&lt;/a&gt;.”
Why?  Because if you can understand this quadratic
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt; as just a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Convolution&quot;&gt;convolution&lt;/a&gt;
of your data with a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Continuous_function&quot;&gt;continuous function&lt;/a&gt;,&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/interp-is-convolution.png&quot; alt=&quot;&quot; width=&quot;275&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;then we can plot the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency_response&quot;&gt;frequency response&lt;/a&gt;
of this
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;.
Knowing that
&lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency_response&quot;&gt;frequency response&lt;/a&gt;
will allow us, further on, to compare  this quadratic fit
with other alternative quadratic
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolators&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;To see how this fits into the form of a filter’s
&lt;a href=&quot;https://en.wikipedia.org/wiki/Impulse_response&quot;&gt;impulse response&lt;/a&gt;, let’s
examine what happens when this
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;
is applied to an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Kronecker_delta&quot;&gt;impulse&lt;/a&gt;.
If we allow &lt;code class=&quot;highlighter-rouge&quot;&gt;x[n]&lt;/code&gt; to be a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Kronecker_delta&quot;&gt;Kronecker delta function&lt;/a&gt;,
where &lt;code class=&quot;highlighter-rouge&quot;&gt;x[n]=0&lt;/code&gt; for all &lt;code class=&quot;highlighter-rouge&quot;&gt;n&lt;/code&gt; save for &lt;code class=&quot;highlighter-rouge&quot;&gt;x[0]=1&lt;/code&gt;, then the result of applying
this quadratic fit to this
&lt;a href=&quot;https://en.wikipedia.org/wiki/Kronecker_delta&quot;&gt;sequence&lt;/a&gt;
will be the &lt;a href=&quot;https://en.wikipedia.org/wiki/Impulse_response&quot;&gt;impulse
response&lt;/a&gt;
of this &lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;.  Let’s do
that now.&lt;/p&gt;

&lt;p&gt;First, &lt;code class=&quot;highlighter-rouge&quot;&gt;f_{-1}(t+1)&lt;/code&gt; will
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;sample&lt;/a&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;x[0]=1&lt;/code&gt; in it’s &lt;code class=&quot;highlighter-rouge&quot;&gt;n+1&lt;/code&gt; term, yielding the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial&quot;&gt;polynomial&lt;/a&gt;,&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/quadeqn-fit-impulse-neg.png&quot; alt=&quot;&quot; width=&quot;354&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Likewise, &lt;code class=&quot;highlighter-rouge&quot;&gt;f_{0}(t)&lt;/code&gt; will
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;sample&lt;/a&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;x[0]=1&lt;/code&gt; in it’s &lt;code class=&quot;highlighter-rouge&quot;&gt;n&lt;/code&gt; term, yielding,&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/quadeqn-fit-impulse-zero.png&quot; alt=&quot;&quot; width=&quot;175&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Next, the &lt;code class=&quot;highlighter-rouge&quot;&gt;f_{1}(t)&lt;/code&gt; term will
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;sample&lt;/a&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;x[0]=1&lt;/code&gt; in it’s &lt;code class=&quot;highlighter-rouge&quot;&gt;n-1&lt;/code&gt; term, giving us
our final &lt;a href=&quot;https://en.wikipedia.org/wiki/Piecewise&quot;&gt;piecewise&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial&quot;&gt;polynomial&lt;/a&gt; component,&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/quadeqn-fit-impulse-pos.png&quot; alt=&quot;&quot; width=&quot;341&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Put together, you can see this
&lt;a href=&quot;https://en.wikipedia.org/wiki/Piecewise&quot;&gt;piecewise&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial&quot;&gt;polynomial&lt;/a&gt;
plotted out in Fig 3.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 3. Impulse response of a Quadratic Fit Interpolator&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/interpolation-fig-qfit.png&quot; alt=&quot;&quot; width=&quot;325&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;See what happened?  This
&lt;a href=&quot;https://en.wikipedia.org/wiki/Impulse_response&quot;&gt;impulse response&lt;/a&gt; isn’t
&lt;a href=&quot;https://en.wikipedia.org/wiki/Continuous_function&quot;&gt;continuous&lt;/a&gt;
at all!  This is the reason why our
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolated&lt;/a&gt;
signal wasn’t &lt;a href=&quot;https://en.wikipedia.org/wiki/Continuous_function&quot;&gt;continuous&lt;/a&gt;
either.&lt;/p&gt;

&lt;p&gt;Further, it only takes some basic integral calculus to plot the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency_response&quot;&gt;frequency response&lt;/a&gt;
of this function in Fig 4.  (I’ll spare you the calculation–while basic,
it isn’t pretty.)&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 4. Fourier Transform of a Quadratic Fit&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/interpolation-fig-qfit-H.png&quot; alt=&quot;&quot; width=&quot;325&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;The gray line in Fig 4 is proportional to &lt;code class=&quot;highlighter-rouge&quot;&gt;1/f&lt;/code&gt;, showing how this
&lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency_response&quot;&gt;frequency response&lt;/a&gt;
only slowly converges towards zero as &lt;code class=&quot;highlighter-rouge&quot;&gt;f&lt;/code&gt; goes to infinity.  This is the
consequence of the discontinuities in the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Impulse_response&quot;&gt;impulse response&lt;/a&gt;
of this fit.&lt;/p&gt;

&lt;p&gt;Now that you see the problem with using a simple quadratic fit as an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;,
let’s see if we can do better.&lt;/p&gt;

&lt;h2 id=&quot;a-better-interpolator&quot;&gt;A Better Interpolator&lt;/h2&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 5. A Piecewise Polynomial&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/interpolation-piecewise-poly.png&quot; alt=&quot;&quot; width=&quot;278&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Now that we know what can go wrong with a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Piecewise&quot;&gt;piecewise&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial&quot;&gt;polynomial&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;,
it’s time to return to where we left off in our &lt;a href=&quot;/dsp/2018/01/16/interpolation-is-convolution.html&quot;&gt;prior
post&lt;/a&gt;
on this topic, and use the principles we developed there to develop
a better &lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;.
In that post, we showed that all
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolators&lt;/a&gt;
that met a minimum set of problem related assumptions have the form of a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Piecewise&quot;&gt;piecewise&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial&quot;&gt;polynomial&lt;/a&gt;,
such as is shown in Fig 5.&lt;/p&gt;

&lt;p&gt;Further, &lt;a href=&quot;/dsp/2018/01/16/interpolation-is-convolution.html&quot;&gt;we pointed
out&lt;/a&gt;
that an &lt;code class=&quot;highlighter-rouge&quot;&gt;h(t)&lt;/code&gt; function that is given by a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Piecewise&quot;&gt;piecewise&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial&quot;&gt;polynomial&lt;/a&gt;,
such as the one shown in Fig 5, can be a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Linear_system&quot;&gt;linear&lt;/a&gt;,
discrete shift invariant,
&lt;a href=&quot;https://en.wikipedia.org/wiki/Upsamplers&quot;&gt;upsampler&lt;/a&gt;.
In Fig 5, you can see separate regions of an example filter, &lt;code class=&quot;highlighter-rouge&quot;&gt;h(t)&lt;/code&gt;, shown
in separate colors.  Each colored region represents a separate quadratic
&lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial&quot;&gt;polynomial&lt;/a&gt;.  Our goal will be
to try to use some criteria to create a useful set of
&lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial&quot;&gt;polynomials&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;As a first step to building our own, let’s define our component
&lt;a href=&quot;https://en.wikipedia.org/wiki/Piecewise&quot;&gt;piecewise&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial&quot;&gt;polynomials&lt;/a&gt; as,&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/quadeqn-nfit-piecewise-eqn.png&quot; alt=&quot;&quot; width=&quot;818&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;That is to say, we’re going to look for a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Piecewise&quot;&gt;piecewise&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial&quot;&gt;polynomials&lt;/a&gt;
function, &lt;code class=&quot;highlighter-rouge&quot;&gt;h(t)&lt;/code&gt;, defined by the equations,&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/quadeqn-criteria-eqn-defns.png&quot; alt=&quot;&quot; width=&quot;666&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Why only five intervals?  This is an arbitrary choice.
There’s no hard and fast rule here.  More intervals or a higher
&lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial&quot;&gt;polynomial&lt;/a&gt;
degree might produce a better filter, but one that will cost more logic to
calculate.  Such longer filters can be the topic for another
discussion on another day.  I do know that this setup will yield a nicely
implementable solution ultimately requiring only two RTL multiplies.&lt;/p&gt;

&lt;p&gt;Two multiplies you ask?  What about all those arbitrary coefficients in &lt;code class=&quot;highlighter-rouge&quot;&gt;h(t)&lt;/code&gt;?
Hang on, we’ll get there.&lt;/p&gt;

&lt;p&gt;Why is there no &lt;code class=&quot;highlighter-rouge&quot;&gt;b&lt;/code&gt; coefficient for the middle interval?  Or, equivalently,
why are the &lt;code class=&quot;highlighter-rouge&quot;&gt;*_1&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;*_2&lt;/code&gt; coefficients repeated?  Because I have chosen a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Linear_phase&quot;&gt;symmetric&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolation&lt;/a&gt;
filter, in the hopes of achieving a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Linear_phase&quot;&gt;linear phase&lt;/a&gt;
result.  Further, I’ve started this derivation often enough without
pre-specifying these certain coefficients, and I end up specifying
them via equations anyway.  By doing it this way, it just reduces the
number of coefficients we’ll need to solve for from the beginning.&lt;/p&gt;

&lt;p&gt;To get to our result, all that remains is to determine the coefficients of the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Piecewise&quot;&gt;piecewise&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial&quot;&gt;polynomials&lt;/a&gt;
in our chosen filter.  To do this, we’ll use some (rather ad-hoc) criteria to
set up a system of linear equations to yield the as yet unknown coefficients.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;Interpolator&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Our first criteria for &lt;code class=&quot;highlighter-rouge&quot;&gt;h(t)&lt;/code&gt; is that the resulting waveform needs to
   &lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolate&lt;/a&gt;
   the incoming waveform.  In other words, whenever &lt;code class=&quot;highlighter-rouge&quot;&gt;t&lt;/code&gt; is
   an integer, the output value should equal the input.  That is, if &lt;code class=&quot;highlighter-rouge&quot;&gt;t=n&lt;/code&gt;
   then &lt;code class=&quot;highlighter-rouge&quot;&gt;y(n) = x[n]&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;If we work this from the equation standpoint,&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/interp-is-convolution.png&quot; alt=&quot;&quot; width=&quot;275&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p style=&quot;list-style-type: none;&quot;&gt;you can see that if &lt;code class=&quot;highlighter-rouge&quot;&gt;t=n&lt;/code&gt; then &lt;code class=&quot;highlighter-rouge&quot;&gt;y(n)&lt;/code&gt; is composed of a summation across
   several &lt;code class=&quot;highlighter-rouge&quot;&gt;h(t)&lt;/code&gt;
   values, each with the index &lt;code class=&quot;highlighter-rouge&quot;&gt;n-k&lt;/code&gt;.  Further, when &lt;code class=&quot;highlighter-rouge&quot;&gt;n=k&lt;/code&gt; we get the one
   component we want, and all of the other components will just pull us off in
   one direction or another.  Hence, we need to insist that,&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/quadeqn-criteria-interpolator.png&quot; alt=&quot;&quot; width=&quot;364&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 6. An interpolating filter must go through zero for all integers but zero&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/quadeqn-criteria-interpolator-dots.png&quot; alt=&quot;&quot; width=&quot;325&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;This means that every one of our
&lt;a href=&quot;https://en.wikipedia.org/wiki/Piecewise&quot;&gt;piecewise&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial&quot;&gt;polynomial&lt;/a&gt; component
functions, save the one in the center, will need to go through zero
near the integer within it, as shown in Fig 6.  The point in the center,
on the other hand, will need to pass through &lt;code class=&quot;highlighter-rouge&quot;&gt;y=1&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;It shouldn’t take too much work to see that our set of
&lt;a href=&quot;https://en.wikipedia.org/wiki/Piecewise&quot;&gt;piecewise&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial&quot;&gt;polynomial&lt;/a&gt; will
meet this criteria if we simply set &lt;code class=&quot;highlighter-rouge&quot;&gt;c_1&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;c_2&lt;/code&gt; to be zero.  Indeed,
this is the reason why it was constructed it based upon &lt;code class=&quot;highlighter-rouge&quot;&gt;t-n&lt;/code&gt; terms in the
first place.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;DSP Guru Meditation&lt;/strong&gt;: It can be shown that if &lt;code class=&quot;highlighter-rouge&quot;&gt;h(n)&lt;/code&gt; is a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Kronecker_delta&quot;&gt;Kronecker Delta function&lt;/a&gt;,
then it must also be true that,&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/quadeqn-criteria-interpolator-guru-1.png&quot; alt=&quot;&quot; width=&quot;213&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;or, equivalently,&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/quadeqn-criteria-interpolator-guru-2.png&quot; alt=&quot;&quot; width=&quot;330&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;This, plus the fact that &lt;code class=&quot;highlighter-rouge&quot;&gt;h(t)&lt;/code&gt; is real, forces the awkward reality
that &lt;code class=&quot;highlighter-rouge&quot;&gt;H(1/2)&lt;/code&gt; &lt;em&gt;must be&lt;/em&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;1/2&lt;/code&gt; as well for all practical
&lt;a href=&quot;https://en.wikipedia.org/wiki/Low-pass_filter&quot;&gt;low-pass&lt;/a&gt;
filters.  Hence, this criteria alone forces the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Passband&quot;&gt;passband&lt;/a&gt; and
&lt;a href=&quot;https://en.wikipedia.org/wiki/Stopband&quot;&gt;stopband&lt;/a&gt;
cutoff frequencies of any
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;
to be &lt;code class=&quot;highlighter-rouge&quot;&gt;f=1/2&lt;/code&gt;.  This is a somewhat unfortunate limitation on the
performance that might be achieved using this approach.&lt;/p&gt;

&lt;p&gt;This criteria is also a point of separation from
&lt;a href=&quot;http://ieeexplore.ieee.org/document/15483/&quot;&gt;Farrow&lt;/a&gt;’s work, since
&lt;a href=&quot;http://ieeexplore.ieee.org/document/15483/&quot;&gt;Farrow&lt;/a&gt; never insisted that the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sample-rate_conversion&quot;&gt;resamplers&lt;/a&gt;
he developed went through the original
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;sample&lt;/a&gt;
points.&lt;/p&gt;

&lt;ol start=&quot;2&quot;&gt;
  &lt;li&gt;&lt;strong&gt;Constant -&amp;gt; Constant&lt;/strong&gt;: &lt;code class=&quot;highlighter-rouge&quot;&gt;x[n]=c&lt;/code&gt; implies &lt;code class=&quot;highlighter-rouge&quot;&gt;y(t)=c&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;When I built my first
&lt;a href=&quot;http://ieeexplore.ieee.org/document/15483/&quot;&gt;Farrow&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolation&lt;/a&gt;
filter
from a quadratic
&lt;a href=&quot;https://en.wikipedia.org/wiki/Piecewise&quot;&gt;piecewise&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial&quot;&gt;polynomial&lt;/a&gt;,
I was surprised to discover that a constant input to my filter was producing
a non-constant output.  Instead, there was a small but repeating quadratic
component.  How could this to happen?!  How could I call this an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;, if the
resulting
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolated&lt;/a&gt; waveform
didn’t smoothly go through the given points?&lt;/p&gt;

&lt;p&gt;So I then went back to my equations for &lt;code class=&quot;highlighter-rouge&quot;&gt;h(t)&lt;/code&gt; and the coefficients of the
component &lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial&quot;&gt;polynomials&lt;/a&gt;, 
and rebuilt them to insist that if &lt;code class=&quot;highlighter-rouge&quot;&gt;x[n]&lt;/code&gt; is the constant &lt;code class=&quot;highlighter-rouge&quot;&gt;c&lt;/code&gt;, then
&lt;code class=&quot;highlighter-rouge&quot;&gt;y(t)&lt;/code&gt; should equal that same constant &lt;code class=&quot;highlighter-rouge&quot;&gt;c&lt;/code&gt; as well.&lt;/p&gt;

&lt;p&gt;Let’s do that here.  With just a little manipulation, you’ll see that,&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/quadeqn-criteria-const-deriv.png&quot; alt=&quot;&quot; width=&quot;330&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Hence, we’ll want&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/quadeqn-criteria-const.png&quot; alt=&quot;&quot; width=&quot;375&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;for all possible values of &lt;code class=&quot;highlighter-rouge&quot;&gt;t&lt;/code&gt; between &lt;code class=&quot;highlighter-rouge&quot;&gt;-1/2&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;1/2&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;We can apply this criteria to our
&lt;a href=&quot;https://en.wikipedia.org/wiki/Piecewise&quot;&gt;piecewise&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial&quot;&gt;polynomial&lt;/a&gt;
filter without too much hassle.  I’ll spare you the gory details, although
you should know that the result is a set of equations further constraining our
&lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial&quot;&gt;polynomial&lt;/a&gt; coefficients.&lt;/p&gt;

&lt;p&gt;If we continue solving for our eight coefficients,
we’ll still need some more equations.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 7. The frequency response of a linear interpolator, showing a zero response for all integer frequencies but zero&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/quadeqn-criteria-const-H.png&quot; alt=&quot;&quot; width=&quot;378&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;&lt;strong&gt;DSP Guru Meditation&lt;/strong&gt;:
If you examine this property in
&lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency_response&quot;&gt;frequency&lt;/a&gt;,
it forces a unique and very desirable property upon the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolating&lt;/a&gt;
filter’s
&lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency_response&quot;&gt;frequency response&lt;/a&gt;.
In particular, the &lt;a href=&quot;https://en.wikipedia.org/wiki/Fourier_transform&quot;&gt;Fourier
transform&lt;/a&gt; of a constant
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;sampled&lt;/a&gt;
input has a component at &lt;code class=&quot;highlighter-rouge&quot;&gt;X(e^{j0})&lt;/code&gt; only, with &lt;code class=&quot;highlighter-rouge&quot;&gt;X(e^{j2pi f})=c delta(f)&lt;/code&gt;,
where &lt;code class=&quot;highlighter-rouge&quot;&gt;delta(f)&lt;/code&gt; is the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Dirac_delta_function&quot;&gt;Dirac delta function&lt;/a&gt;.
This would normally create aliasing components at frequencies &lt;code class=&quot;highlighter-rouge&quot;&gt;X(e^{j2pi m})&lt;/code&gt;
for all integers &lt;code class=&quot;highlighter-rouge&quot;&gt;m&lt;/code&gt; as well.  However, we just insisted that for a constant
input, the &lt;a href=&quot;https://en.wikipedia.org/wiki/Fourier_transform&quot;&gt;Fourier
transform&lt;/a&gt; of the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Continuous_function&quot;&gt;continuous&lt;/a&gt;
output function was to have a component at zero only.  Hence, we know that
&lt;code class=&quot;highlighter-rouge&quot;&gt;X(e^{j2pi f})H(f)&lt;/code&gt; must be nonzero for &lt;code class=&quot;highlighter-rouge&quot;&gt;f=0&lt;/code&gt;, and so we now know that
&lt;code class=&quot;highlighter-rouge&quot;&gt;H(0)=1&lt;/code&gt;.  We also know that &lt;code class=&quot;highlighter-rouge&quot;&gt;H(m)&lt;/code&gt; must be zero for all integers &lt;code class=&quot;highlighter-rouge&quot;&gt;m!=0&lt;/code&gt;,
&lt;code class=&quot;highlighter-rouge&quot;&gt;H(m)=0&lt;/code&gt;–just like a &lt;a href=&quot;https://en.wikipedia.org/wiki/Sinc_funtion&quot;&gt;sinc
function&lt;/a&gt; although other
functions can have this property as well.&lt;/p&gt;

&lt;p&gt;You can see this property shown in Fig 7 on the right.&lt;/p&gt;

&lt;ol start=&quot;3&quot;&gt;
  &lt;li&gt;&lt;strong&gt;Linear -&amp;gt; Linear&lt;/strong&gt;: &lt;code class=&quot;highlighter-rouge&quot;&gt;x[n] = n&lt;/code&gt; implies &lt;code class=&quot;highlighter-rouge&quot;&gt;y(t)=t&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Let’s follow that last criteria a bit further.  Instead of just insisting
that every constant produce a constant signal output, we can also insist
that every linear input produce a linear output.  Hence, if &lt;code class=&quot;highlighter-rouge&quot;&gt;x[n]=n&lt;/code&gt;,
then &lt;code class=&quot;highlighter-rouge&quot;&gt;y(t)&lt;/code&gt; should equal &lt;code class=&quot;highlighter-rouge&quot;&gt;t&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;As with our last criteria, we’ll apply our input, &lt;code class=&quot;highlighter-rouge&quot;&gt;x[n]=n&lt;/code&gt;, and then
insist that the result contains no &lt;code class=&quot;highlighter-rouge&quot;&gt;t^2&lt;/code&gt; terms.  (We already know it will
contain no constant terms.)&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 8. Constraining performance under linear inputs constrains the slope of the frequency response&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/quadeqn-criteria-const-Hdot.png&quot; alt=&quot;&quot; width=&quot;386&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;This will give us another linear constraint on our coefficients.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;DSP Guru Meditation&lt;/strong&gt;:
If you examine this criteria in
&lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency_response&quot;&gt;frequency&lt;/a&gt;, it basically
forces the slope of &lt;code class=&quot;highlighter-rouge&quot;&gt;H(m)&lt;/code&gt; to be zero for integers &lt;code class=&quot;highlighter-rouge&quot;&gt;m&lt;/code&gt;.  To be effective,
this criteria is dependent upon the constant criteria described above.&lt;/p&gt;

&lt;p&gt;This constraint therefore not only increases the width of our pass band,
but it also increases the depth of the nulls.&lt;/p&gt;

&lt;ol start=&quot;4&quot;&gt;
  &lt;li&gt;&lt;strong&gt;Quadratic -&amp;gt; Quadratic&lt;/strong&gt;: &lt;code class=&quot;highlighter-rouge&quot;&gt;x[n] = n^2&lt;/code&gt; implies &lt;code class=&quot;highlighter-rouge&quot;&gt;y(t)=t^2&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;For our fourth criteria, we’ll insist that if &lt;code class=&quot;highlighter-rouge&quot;&gt;x[n]=n^2&lt;/code&gt; then &lt;code class=&quot;highlighter-rouge&quot;&gt;y(t)&lt;/code&gt; should
equal &lt;code class=&quot;highlighter-rouge&quot;&gt;t^2&lt;/code&gt;.  In many ways this is similar to the linear criteria above.
As with the linear criteria, this also provides us with another equation
to add to the system of equations we are building to solve for &lt;code class=&quot;highlighter-rouge&quot;&gt;h(t)&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;DSP Guru Meditation&lt;/strong&gt;: This criteria constrains the second derivative of
the &lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency_response&quot;&gt;frequency response&lt;/a&gt;
near both &lt;code class=&quot;highlighter-rouge&quot;&gt;f=m&lt;/code&gt; for all integer frequencies &lt;code class=&quot;highlighter-rouge&quot;&gt;m&lt;/code&gt;, thus also widening our
passband, as well as the width of the nulls in the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency_response&quot;&gt;frequency response&lt;/a&gt;.
As a result, this criteria only intensifies our last constraint.&lt;/p&gt;

&lt;ol start=&quot;5&quot;&gt;
  &lt;li&gt;&lt;strong&gt;Continuous&lt;/strong&gt;: &lt;img src=&quot;/img/quadeqn-criteria-continuous.png&quot; width=&quot;233&quot; /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;As a final set of criteria, we’ll insist that our
&lt;a href=&quot;https://en.wikipedia.org/wiki/Piecewise&quot;&gt;piecewise&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial&quot;&gt;polynomial&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Impulse_response&quot;&gt;impulse response&lt;/a&gt; be
&lt;a href=&quot;https://en.wikipedia.org/wiki/Continuous_function&quot;&gt;continuous&lt;/a&gt;.
Hence, the &lt;code class=&quot;highlighter-rouge&quot;&gt;h(t)&lt;/code&gt; function must be
&lt;a href=&quot;https://en.wikipedia.org/wiki/Continuous_function&quot;&gt;continuous&lt;/a&gt;
at its seams: &lt;code class=&quot;highlighter-rouge&quot;&gt;t=-5/2&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;t=-3/2&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;t=-1/2&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;t=1/2&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;t=3/2&lt;/code&gt;, and &lt;code class=&quot;highlighter-rouge&quot;&gt;t=5/2&lt;/code&gt;.
However, since we constrained our
&lt;a href=&quot;https://en.wikipedia.org/wiki/Piecewise&quot;&gt;piecewise&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial&quot;&gt;polynomial&lt;/a&gt; to be
&lt;a href=&quot;https://en.wikipedia.org/wiki/Linear_phase&quot;&gt;symmetric&lt;/a&gt;
in time, we really only need to deal with half of those &lt;code class=&quot;highlighter-rouge&quot;&gt;t&lt;/code&gt; values.&lt;/p&gt;

&lt;p&gt;Because any linear combination of
&lt;a href=&quot;https://en.wikipedia.org/wiki/Continuous_function&quot;&gt;continuous functions&lt;/a&gt;
is also
&lt;a href=&quot;https://en.wikipedia.org/wiki/Continuous_function&quot;&gt;continuous&lt;/a&gt;,
&lt;code class=&quot;highlighter-rouge&quot;&gt;y(t)&lt;/code&gt; will be
&lt;a href=&quot;https://en.wikipedia.org/wiki/Continuous_function&quot;&gt;continuous&lt;/a&gt;
any time &lt;code class=&quot;highlighter-rouge&quot;&gt;h(t)&lt;/code&gt; is
&lt;a href=&quot;https://en.wikipedia.org/wiki/Continuous_function&quot;&gt;continuous&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;There’s an even more important consequence of this ad-hoc criteria: any
&lt;a href=&quot;https://en.wikipedia.org/wiki/Continuous_function&quot;&gt;continuous function&lt;/a&gt;
will have a &lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency_response&quot;&gt;frequency
response&lt;/a&gt;.
with an asymptotic decay proportional to &lt;code class=&quot;highlighter-rouge&quot;&gt;1/f^2&lt;/code&gt; or better.  This function
is no different.  Hence, when you put all of our constraints together, we’ve
now constrained the zero frequency, &lt;code class=&quot;highlighter-rouge&quot;&gt;f=0&lt;/code&gt;, and the first and second
derivatives of all integer frequencies.  By now insisting on a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Continuous_function&quot;&gt;continuous&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Impulse_response&quot;&gt;impulse response&lt;/a&gt;,
we’ve also constrained the asymptotic &lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency_response&quot;&gt;frequency
response&lt;/a&gt; of this
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolating&lt;/a&gt;
filter as well.&lt;/p&gt;

&lt;p&gt;In other words, we’ve just created an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolating&lt;/a&gt;
function with a very nice
&lt;a href=&quot;https://en.wikipedia.org/wiki/Low-pass_filter&quot;&gt;low-pass&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency_response&quot;&gt;frequency response&lt;/a&gt;–it
just doesn’t have a very narrow
&lt;a href=&quot;https://en.wikipedia.org/wiki/Transition_band&quot;&gt;transition band&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;DSP Guru Meditation&lt;/strong&gt;: I will contend, based more upon frustration then
proof, that it is actually impossible to create a finite quadratic
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolating&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial&quot;&gt;polynomial&lt;/a&gt; via this method that
will be &lt;a href=&quot;https://en.wikipedia.org/wiki/Continuous_function&quot;&gt;continuous&lt;/a&gt; in
its first derivative.  Before you jump to disprove me, remember my definition
of an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolating&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial&quot;&gt;polynomial&lt;/a&gt;, which requires that it
equal zero at all integer locations but zero.  Were we able to create such a
function, it would have an out of band asymptotic decay rate of &lt;code class=&quot;highlighter-rouge&quot;&gt;1/f^3&lt;/code&gt;–but
we’ll leave the discussion of such functions for a later discussion of either
higher order &lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolators&lt;/a&gt;,
or quadratic &lt;a href=&quot;https://en.wikipedia.org/wiki/Spline_interpolation&quot;&gt;splines&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;As an aside, it is possible to formulate the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Spline_interpolation&quot;&gt;splines&lt;/a&gt; problem in &lt;a href=&quot;/dsp/2018/01/16/interpolation-is-convolution.html&quot;&gt;this
fashion&lt;/a&gt;.
Doing so produces a solution that no longer requires solving for the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Piecewise&quot;&gt;piecewise&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial&quot;&gt;polynomial&lt;/a&gt; to be
coefficients at every step, while yielding a cleaner and (slightly) wider
&lt;a href=&quot;https://en.wikipedia.org/wiki/Passband&quot;&gt;passband&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;If you put all of the resulting equations together, for the constraints outlined
above, you will get an over-determined system.  This over determined system
will include several redundant equations which can be easily removed.  Once
the redundant equations are removed, you will then get the system
of linear equations below.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/quadeqn-criteria-eqns.png&quot; alt=&quot;&quot; width=&quot;441&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;In spite of starting with an over determined system in this process, we got
lucky: the system above has a unique solution given by,&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/quadeqn-criteria-soln.png&quot; alt=&quot;&quot; width=&quot;233&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Wow, that was a lot of work to just get a bunch of numbers.  So what,
right?  What’s the use of these five values?&lt;/p&gt;

&lt;p&gt;The value of this solution is seen in the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Impulse_response&quot;&gt;impulse response&lt;/a&gt; and
&lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency_response&quot;&gt;frequency response&lt;/a&gt;
shown in Fig 9.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 9. Impulse response (left) and Frequency Response (right) of this piecewise polynomial interpolator&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/interpolation-fig-betterq.png&quot; alt=&quot;&quot; width=&quot;728&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;As we required, the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Passband&quot;&gt;passband&lt;/a&gt; and
is “flat” near &lt;code class=&quot;highlighter-rouge&quot;&gt;f=0&lt;/code&gt;, and the nulls are deep.
Unlike both the &lt;a href=&quot;/dsp/2017/06/06/simple-interpolator.html&quot;&gt;nearest neighbor
interpolator&lt;/a&gt;
and the quadratic fit we
discussed above, the asymptotic fall off of this filter is proportional to
&lt;code class=&quot;highlighter-rouge&quot;&gt;1/f^2&lt;/code&gt;.  Further, unlike the &lt;a href=&quot;/dsp/2017/07/29/series-linear-interpolation.html&quot;&gt;linear interpolator we built
earlier&lt;/a&gt;
which also has an asymptotic fall off of &lt;code class=&quot;highlighter-rouge&quot;&gt;1/f^2&lt;/code&gt;, this
asymptotic fall off has a smaller proportionality coefficient of &lt;code class=&quot;highlighter-rouge&quot;&gt;1/f^2&lt;/code&gt;.
For comparison, consider Fix 7 above showing the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency_response&quot;&gt;frequency response&lt;/a&gt;
of the &lt;a href=&quot;/dsp/2017/07/29/series-linear-interpolation.html&quot;&gt;linear
interpolator&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;In other words, this quadratic
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt; forms a &lt;em&gt;nice&lt;/em&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Piecewise&quot;&gt;piecewise&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial&quot;&gt;polynomial&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolation&lt;/a&gt;
filter.&lt;/p&gt;

&lt;p&gt;Even better, with some careful coding (below) we can implement the coefficient
multiplication with only adds and subtracts.  This will mean that we can
evaluate this &lt;a href=&quot;https://github.com/ZipCPU/interpolation/blob/master/rtl/quadratic/quadinterp.v&quot;&gt;quadratic in
Verilog&lt;/a&gt;
using only two hardware multiplies–minimizing a precious resource found within
any digital logic component.&lt;/p&gt;

&lt;p&gt;Sadly, the development above is only an ad-hoc formulation.  While it
may be possible to truly generate &lt;em&gt;optimal&lt;/em&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolators&lt;/a&gt;
via this method, I have not yet pursued such a study in depth.&lt;/p&gt;

&lt;h2 id=&quot;three-interpolators-and-only-two-multiplies&quot;&gt;Three Interpolators and only Two Multiplies&lt;/h2&gt;

&lt;p&gt;In the next section, we’ll start discussing how to build the
&lt;a href=&quot;https://github.com/ZipCPU/interpolation/blob/master/rtl/quadratic/quadinterp.v&quot;&gt;Verilog code necessary to
implement&lt;/a&gt;
this &lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;.
Indeed, well even do one better than that: we’ll show
the Verilog code necessary to implement three separate quadratic
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolators&lt;/a&gt;–all with only
&lt;em&gt;two multiplies&lt;/em&gt;.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;The first &lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;
will be the one that results from the quadratic fit approach I was so
critical of above.  We’ll use this performance for reference below.  This
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;
is given by the equations we developed above:&lt;/li&gt;
&lt;/ol&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/quadeqn-fit-coeffs.png&quot; alt=&quot;&quot; width=&quot;367&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;As we discussed above, we can expect this
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;
to produce a discontinuous output waveform.&lt;/p&gt;

&lt;ol start=&quot;2&quot;&gt;
  &lt;li&gt;The second &lt;a href=&quot;https://en.wikipedia.org/wiki/Upsamplers&quot;&gt;upsampling&lt;/a&gt;
function may have the best &lt;a href=&quot;https://en.wikipedia.org/wiki/Stopband&quot;&gt;stopband&lt;/a&gt;
performance among all quadratic
&lt;a href=&quot;https://en.wikipedia.org/wiki/Upsamplers&quot;&gt;upsamplers&lt;/a&gt;, however it’s not a true
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;
since it doesn’t necessarily go through the original signal
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;sample&lt;/a&gt;
points.  We’ll call this the
non-&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;
for lack of a better term.  This
non-&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;
is a very valuable
&lt;a href=&quot;https://en.wikipedia.org/wiki/Upsamplers&quot;&gt;upsampling&lt;/a&gt;
function for the simple reason that its
&lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency_response&quot;&gt;frequency response&lt;/a&gt;
tail falls off faster (&lt;code class=&quot;highlighter-rouge&quot;&gt;1/f^3&lt;/code&gt;) than any other quadratic.  Indeed, it is
so valuable, that we may come back and use it to beat the performance of a
&lt;a href=&quot;/dsp/2017/08/30/cordic.html&quot;&gt;CORDIC&lt;/a&gt;–but
that will have to be the topic of a future article (it will still require
two multiples, something the
&lt;a href=&quot;/dsp/2017/08/30/cordic.html&quot;&gt;CORDIC&lt;/a&gt; doesn’t need).&lt;/li&gt;
&lt;/ol&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/quadeqn-cub-coeffs.png&quot; alt=&quot;&quot; width=&quot;383&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 11.  The impulse response of a rectangle convolved with itself three times&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/interpolation-fig-rcubd-impulse.png&quot; alt=&quot;&quot; width=&quot;325&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;This non-&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;
will not suffer from the discontinuities we discussed above.  Further, if you
are up to a calculus challenge, this function can be derived by
&lt;a href=&quot;https://en.wikipedia.org/wiki/Convolution&quot;&gt;convolving&lt;/a&gt; a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Rectangular_function&quot;&gt;rectangle function&lt;/a&gt;
with itself three separate times, hence its
&lt;a href=&quot;https://en.wikipedia.org/wiki/Impulse_response&quot;&gt;impulse response&lt;/a&gt;
is shown in Fig 11.&lt;/p&gt;

&lt;p&gt;One unique feature of this
&lt;a href=&quot;https://en.wikipedia.org/wiki/Upsamplers&quot;&gt;upsampler&lt;/a&gt;
is its properties when doing peak finding.  Indeed, peaks found following
this fit tend to be more accurately located than when using the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;
that is the topic of today’s development–but this again is a topic for
another day.&lt;/p&gt;

&lt;p&gt;Since the non-&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;’s
&lt;a href=&quot;https://en.wikipedia.org/wiki/Impulse_response&quot;&gt;impulse response&lt;/a&gt;
response is created by &lt;a href=&quot;https://en.wikipedia.org/wiki/Convolution&quot;&gt;convolving&lt;/a&gt; a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Rectangular_function&quot;&gt;rectangle function&lt;/a&gt;
with itself three separate times, its
&lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency_response&quot;&gt;frequency response&lt;/a&gt;
will be given by the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency_response&quot;&gt;frequency response&lt;/a&gt; of a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Rectangular_function&quot;&gt;rectangle function&lt;/a&gt;
cubed, or in other words by a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sinc_funtion&quot;&gt;sinc function&lt;/a&gt; cubed.&lt;/p&gt;

&lt;p&gt;Further, if you compare the coefficients of this
the non-&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;’s
&lt;a href=&quot;https://en.wikipedia.org/wiki/Impulse_response&quot;&gt;impulse response&lt;/a&gt;
with those of the quadratic fit (above), you’ll see that all but the
constant coefficients, &lt;code class=&quot;highlighter-rouge&quot;&gt;c_n&lt;/code&gt;, are identical.&lt;/p&gt;

&lt;p&gt;In &lt;a href=&quot;https://github.com/ZipCPU/interpolation/blob/master/rtl/quadratic/quadinterp.v&quot;&gt;our code&lt;/a&gt;
below, the parameter &lt;code class=&quot;highlighter-rouge&quot;&gt;OPT_IMPROVED_FIT&lt;/code&gt; will control whether or not this
non-&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolating&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Upsamplers&quot;&gt;upsampler&lt;/a&gt;
is generated or not.  If set, the traditional quadratic fit will be bypassed
for this alternative implementation.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;DSP Guru Meditation&lt;/strong&gt;: My statement above that the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency_response&quot;&gt;frequency response&lt;/a&gt;
tail of this filter asymptotically decays &lt;em&gt;faster than any other quadratic&lt;/em&gt;
isn’t quite true.  Quadratics filters composed of a linear combinations of
this filter function will also fall off at the &lt;code class=&quot;highlighter-rouge&quot;&gt;1/f^3&lt;/code&gt; rate … but we’ll
leave the further discussion of this approach to a future discussion of
quadratic (and/or cubic)
&lt;a href=&quot;https://en.wikipedia.org/wiki/Spline_interpolation&quot;&gt;splines&lt;/a&gt;, since that’s
where it is most relevant.&lt;/p&gt;

&lt;ol start=&quot;3&quot;&gt;
  &lt;li&gt;The third function we’ll implement is defined by the coefficient
equations we just developed in the last section above.&lt;/li&gt;
&lt;/ol&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/quadeqn-nfit-coeffs.png&quot; alt=&quot;&quot; width=&quot;675&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;This is the one we expect to see good results from–it is
&lt;a href=&quot;https://en.wikipedia.org/wiki/Continuous_function&quot;&gt;continuous&lt;/a&gt;,
and passes constants, lines, and quadratics without distortion.  Not
only that, the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;
generated by this function is guaranteed to go through the initial
&lt;code class=&quot;highlighter-rouge&quot;&gt;x[n]&lt;/code&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;sample&lt;/a&gt;
points given to it.&lt;/p&gt;

&lt;p&gt;The parameter &lt;code class=&quot;highlighter-rouge&quot;&gt;OPT_INTERPOLATOR&lt;/code&gt; in
&lt;a href=&quot;https://github.com/ZipCPU/interpolation/blob/master/rtl/quadratic/quadinterp.v&quot;&gt;our code below&lt;/a&gt;
will control whether or not this
implementation is used.  If set, &lt;code class=&quot;highlighter-rouge&quot;&gt;OPT_INTERPOLATOR&lt;/code&gt; will override the
&lt;code class=&quot;highlighter-rouge&quot;&gt;OPT_IMPROVED_FIT&lt;/code&gt; option parameter above, yielding an implementation of
this quadratic
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;We’ll use some careful coding techniques in the next section in order to
avoid using hardware multiplication elements when multiplying the quadratic
coefficients generated by the incoming data by these factors,
28, 16, 10, 3/4, etc.  The resulting algorithm will use only shifts and adds–up
until the final quadratic evaluation.  We will need to be careful
to make certain that we track the decimal point during this process though.&lt;/p&gt;

&lt;p&gt;When it comes to evaluating the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial&quot;&gt;polynomial&lt;/a&gt;
itself, if you’ve never implemented one numerically, then you should know
that there is a right and a wrong way to apply the multiply–a “trick” if you
will.  In particular, you don’t want to calculate your result by a
straight forward evaluation,&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/quadeqn-implementation-bad.png&quot; alt=&quot;&quot; width=&quot;243&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;This straight forward approach suffers from two problems.  The first problem is
that it costs three multiplies.  (Ouch!) The second problem is that this method
is susceptible to the loss of precision as the intermediate values are
truncated prior to their final addition.&lt;/p&gt;

&lt;p&gt;Instead, we’ll calculate this
&lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial&quot;&gt;polynomial&lt;/a&gt;’s
value based upon a different formulation:&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/quadeqn-implementation.png&quot; alt=&quot;&quot; width=&quot;217&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;This will solve both of these problems, yielding a nice solution suitable for
RTL implementation.&lt;/p&gt;

&lt;h2 id=&quot;fixed-point&quot;&gt;Fixed Point&lt;/h2&gt;

&lt;p&gt;Let’s pause for one more section before diving into
&lt;a href=&quot;https://github.com/ZipCPU/interpolation/blob/master/rtl/quadratic/quadinterp.v&quot;&gt;the code&lt;/a&gt;
below, to discuss how we are going to handle the evaluation of the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Piecewise&quot;&gt;piecewise&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial&quot;&gt;polynomial&lt;/a&gt;
function coefficients.&lt;/p&gt;

&lt;p&gt;Our first step will be to replace the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial&quot;&gt;polynomial&lt;/a&gt;,
coefficients with elements of a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;sample&lt;/a&gt;
based shift register.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
if (i_ce)
	{ x[3], x[2], x[1], x[0] } &amp;lt;= { x[2], x[1], x[0], in };&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This will eliminate the dependence of the algorithm on the integer &lt;code class=&quot;highlighter-rouge&quot;&gt;n&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;We’ll use the input data as the first element in this registers,
and use &lt;code class=&quot;highlighter-rouge&quot;&gt;x[0]&lt;/code&gt; to refer to the prior input, &lt;code class=&quot;highlighter-rouge&quot;&gt;x[1]&lt;/code&gt; to refer to the value
before that, etc.  Hence, we’ll map the following values:&lt;/p&gt;

&lt;table class=&quot;bordered-table&quot;&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Old name&lt;/th&gt;
      &lt;th&gt;New Name&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;x[n+2]&lt;/td&gt;
      &lt;td&gt;in&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;x[n+1]&lt;/td&gt;
      &lt;td&gt;x[0]&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;x[n+0]&lt;/td&gt;
      &lt;td&gt;x[1]&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;x[n-1]&lt;/td&gt;
      &lt;td&gt;x[2]&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;x[n-2]&lt;/td&gt;
      &lt;td&gt;x[3]&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;This allows us to re-express the above filter coefficient equations as,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;   16 av = 4(x[1]-8x[1])+16(x[0]+x[2])-2(in+x[3])
   16 bv = 2[(x[0]-x[2])+4(x[0]-x[2])]+(in-x[3])
   cv = x[1]&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;You may also notice that all of the multiplies necessary to calculate
the coefficients, &lt;code class=&quot;highlighter-rouge&quot;&gt;a_n&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;b_n&lt;/code&gt;, and &lt;code class=&quot;highlighter-rouge&quot;&gt;c_n&lt;/code&gt;,
have now been replaced with adds and shifts.  Instead of multiplying by &lt;code class=&quot;highlighter-rouge&quot;&gt;-28&lt;/code&gt;
for example, we can subtract &lt;code class=&quot;highlighter-rouge&quot;&gt;8x[1]&lt;/code&gt; from &lt;code class=&quot;highlighter-rouge&quot;&gt;x[1]&lt;/code&gt; and then shift the result left by two bits.  In a similar fashion, we can multiply &lt;code class=&quot;highlighter-rouge&quot;&gt;x[0]-x[2]&lt;/code&gt; by five
by adding &lt;code class=&quot;highlighter-rouge&quot;&gt;x[0]-x[2]&lt;/code&gt; to &lt;code class=&quot;highlighter-rouge&quot;&gt;4(x[0]-x[2])&lt;/code&gt;.  The final multiplication by
two, or rather left shift by one, just completes the desired multiply by ten.&lt;/p&gt;

&lt;p&gt;Even this is too hard, though, since it will take us a couple of clocks to
calculate these values.  Hence we’ll go about calculating our coefficients
in three steps each in a different clock cycle.&lt;/p&gt;

&lt;p&gt;We’ll start, therefore, by splitting this process into three sets of operations.
Eventually these will take place on separate clock cycles, but for now we can
draw them out as though they all happened at once.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;   pmidv = 8x[1] - x[1]; // = 7x[1]
   psumn =  x[0] + x[2];
   difn  =  x[0] - x[2];
   //
   diffn = difn + 4difn;	// = 5 * (x[0] - x[2])
   sumw  =   in  + x[3];
   diffw =   in  - x[3];
   midvpsumn = 4(psumn) - (pmidv); // = 4(x[0]+x[2])-7x[1]
   //
   16 av = 4(midvpsumn)-2(sumw)
   16 bv = 2(diffn)+(diffw)
   cv = x[1]&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This can then be rewritten into pseudo-RTL logic over the space of three clock
cycles.  Our notation for the shift register components from before, &lt;code class=&quot;highlighter-rouge&quot;&gt;in&lt;/code&gt;
through &lt;code class=&quot;highlighter-rouge&quot;&gt;x[3]&lt;/code&gt;, will be valid on the second clock cycle.  Hence, for the
first clock we’ll be referencing &lt;code class=&quot;highlighter-rouge&quot;&gt;in&lt;/code&gt; through &lt;code class=&quot;highlighter-rouge&quot;&gt;x[2]&lt;/code&gt; instead of &lt;code class=&quot;highlighter-rouge&quot;&gt;x[0]&lt;/code&gt;
through &lt;code class=&quot;highlighter-rouge&quot;&gt;x[3]&lt;/code&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
if (i_ce)
begin
   // First clock, pre-data
   pmidv &amp;lt;= 8x[0] - x[0]; // Was 8x[1] - x[1]
   psumn &amp;lt;=   in + x[1];  // Was x[0] + x[2]
   difn  &amp;lt;=   in - x[1];  // Was x[0] - x[2]&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This takes care of some of the inner operations from our equations above.
The next step handles some more of the “multiplies”.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;   // Second clock
   diffn &amp;lt;= difn + 4difn;	// = 5 * (x[0] - x[2])
   sumw  &amp;lt;=   in  + x[3];
   diffw &amp;lt;=   in  - x[3];
   midvpsumn &amp;lt;= 4(psumn) - (pmidv); // = 4(x[0]+x[2])-7x[1]&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;In the final clock cycle we’ll calculate the actual coefficients.  Because
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
math is primarily fixed point, we’ll leave the &lt;code class=&quot;highlighter-rouge&quot;&gt;16&lt;/code&gt; on the left–indicating
that we never divided by the necessary 16.  We’ll need to drop the extra four
bits later, but for now we’ll leave them in
place as long as possible to avoid loss of precision.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;   // Third clock, data delayed by one
   av &amp;lt;= 4(midvpsumn)-2(sumw); // * 2^4
   bv &amp;lt;= 2(diffn)+(diffw); // * 2^4
   cv &amp;lt;= x[2];
end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This gives us the coefficients of our
&lt;a href=&quot;https://en.wikipedia.org/wiki/Piecewise&quot;&gt;piecewise&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial&quot;&gt;polynomial&lt;/a&gt; for a given
set of five input samples.&lt;/p&gt;

&lt;p&gt;We still need to calculate the value of &lt;code class=&quot;highlighter-rouge&quot;&gt;t&lt;/code&gt; that needs to be used when
evaluating this &lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial&quot;&gt;polynomial&lt;/a&gt;.
This logic will follow directly from the &lt;a href=&quot;/dsp/2017/07/29/series-linear-interpolation.html&quot;&gt;linear interpolator
development&lt;/a&gt;,
and is even copied from that development.&lt;/p&gt;

&lt;p&gt;The only big difference between this and the &lt;a href=&quot;/dsp/2017/07/29/series-linear-interpolation.html&quot;&gt;linear
interpolator&lt;/a&gt;
development is that, unlike the
&lt;a href=&quot;/dsp/2017/07/29/series-linear-interpolation.html&quot;&gt;linear interpolator&lt;/a&gt;,
this &lt;a href=&quot;https://en.wikipedia.org/wiki/Piecewise&quot;&gt;piecewise&lt;/a&gt; quadratic
&lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial&quot;&gt;polynomial&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolates&lt;/a&gt;
from &lt;em&gt;around&lt;/em&gt; the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;sample&lt;/a&gt; points
(&lt;code class=&quot;highlighter-rouge&quot;&gt;|t|&amp;lt;1/2&lt;/code&gt;), rather than &lt;em&gt;between&lt;/em&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;sample&lt;/a&gt; points,
(&lt;code class=&quot;highlighter-rouge&quot;&gt;0&amp;lt;t&amp;lt;1&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;Perhaps this would make more sense with a figure.  Fig 12 therefore shows in
color how the quadratic
&lt;a href=&quot;https://en.wikipedia.org/wiki/Upsamplers&quot;&gt;upsampler&lt;/a&gt;
will interpolate from &lt;em&gt;around&lt;/em&gt; the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;sample&lt;/a&gt;
points on the left, rather than &lt;em&gt;between&lt;/em&gt; the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;sample&lt;/a&gt;
points as shown on the right.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 12. Piecewise quadratics interpolate around sample points (left), rather than between sample points (right)&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/quadeqn-intervals-compared.png&quot; alt=&quot;&quot; width=&quot;728&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;I’m not really sure why this is so, I just know that I haven’t managed to
build a symmetric quadratic
&lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial&quot;&gt;polynomial&lt;/a&gt;
&lt;em&gt;between&lt;/em&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;sample&lt;/a&gt; points
(right side of Fig. 12 above) that ended up being very useful.  To handle this
difference, we’ll keep track of the last coefficients.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
if (i_ce)
begin
	avold &amp;lt;= av;
	bvold &amp;lt;= bv;
	cvold &amp;lt;= cv;
end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Then, if our local &lt;code class=&quot;highlighter-rouge&quot;&gt;t&lt;/code&gt; value is less then zero (&lt;code class=&quot;highlighter-rouge&quot;&gt;MSB&lt;/code&gt; is set), we’ll
use the newer coefficients, &lt;code class=&quot;highlighter-rouge&quot;&gt;av&lt;/code&gt;-&lt;code class=&quot;highlighter-rouge&quot;&gt;cv&lt;/code&gt;, otherwise we’ll use the
older, delayed by one &lt;code class=&quot;highlighter-rouge&quot;&gt;avold&lt;/code&gt;-&lt;code class=&quot;highlighter-rouge&quot;&gt;cvold&lt;/code&gt; coefficients.&lt;/p&gt;

&lt;p&gt;We’d also like to add a half to &lt;code class=&quot;highlighter-rouge&quot;&gt;t&lt;/code&gt; at this point, so that it ranges between
&lt;code class=&quot;highlighter-rouge&quot;&gt;0&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt; instead of from &lt;code class=&quot;highlighter-rouge&quot;&gt;-0.5&lt;/code&gt; to &lt;code class=&quot;highlighter-rouge&quot;&gt;0.5&lt;/code&gt;.  It turns out that’s not needed.
&lt;code class=&quot;highlighter-rouge&quot;&gt;t&lt;/code&gt; naturally fits into place without change–all that’s required is to
re-interpret the signed &lt;code class=&quot;highlighter-rouge&quot;&gt;t&lt;/code&gt; value as an unsigned value and the conversion
is done.&lt;/p&gt;

&lt;p&gt;That gives us our three coefficients, &lt;code class=&quot;highlighter-rouge&quot;&gt;r_av&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;r_bv&lt;/code&gt;, and &lt;code class=&quot;highlighter-rouge&quot;&gt;r_cv&lt;/code&gt;,
together with our time offset, &lt;code class=&quot;highlighter-rouge&quot;&gt;r_offset&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Finally, as we go through the rest of the algorithm, we’ll use the prefixes
&lt;code class=&quot;highlighter-rouge&quot;&gt;r_&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;qp_&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;ls_&lt;/code&gt;, and &lt;code class=&quot;highlighter-rouge&quot;&gt;lp_&lt;/code&gt; to indicate which stage of the quadratic
algorithm we are in.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;The &lt;code class=&quot;highlighter-rouge&quot;&gt;r_&lt;/code&gt; prefix will hold the first copies of our variables in the “new”
sample rate domain.  This will include not only the quadratic coefficients,
&lt;code class=&quot;highlighter-rouge&quot;&gt;r_av&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;r_bv&lt;/code&gt;, and &lt;code class=&quot;highlighter-rouge&quot;&gt;r_cv&lt;/code&gt;, but also the value of &lt;code class=&quot;highlighter-rouge&quot;&gt;t&lt;/code&gt; associated with
these coefficients, held in &lt;code class=&quot;highlighter-rouge&quot;&gt;r_offset&lt;/code&gt;.  Finally, &lt;code class=&quot;highlighter-rouge&quot;&gt;r_ce&lt;/code&gt; will be true on
any clock where these values are valid.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The &lt;code class=&quot;highlighter-rouge&quot;&gt;qp_&lt;/code&gt; prefix will hold our variables immediately after taking
the &lt;em&gt;quadratic product&lt;/em&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;a*t&lt;/code&gt; or in terms of our registers,
&lt;code class=&quot;highlighter-rouge&quot;&gt;r_av * r_offset&lt;/code&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The &lt;code class=&quot;highlighter-rouge&quot;&gt;ls_&lt;/code&gt; prefix will refer to the variables associated with the
&lt;em&gt;linear sum&lt;/em&gt;, the result of adding &lt;code class=&quot;highlighter-rouge&quot;&gt;a*t+b&lt;/code&gt; or equivalently the output
of the quadratic product plus &lt;code class=&quot;highlighter-rouge&quot;&gt;r_bv&lt;/code&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The &lt;code class=&quot;highlighter-rouge&quot;&gt;lp_&lt;/code&gt; prefix will denote values associated with multiplying this
&lt;em&gt;last product&lt;/em&gt; and linear sum by our &lt;code class=&quot;highlighter-rouge&quot;&gt;t&lt;/code&gt; value one more time to get
&lt;code class=&quot;highlighter-rouge&quot;&gt;(at+b)*t&lt;/code&gt;.  As a result, when we add the constant to the result
of this last multiply, we’ll have our final value which we shall
call &lt;code class=&quot;highlighter-rouge&quot;&gt;r_done&lt;/code&gt;.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The algorithm below doesn’t do any rounding until the final step.  Instead,
it accumulates a lot of extra bits along the way, so that there’s not that
much precision lost along the way.&lt;/p&gt;

&lt;h2 id=&quot;the-code&quot;&gt;The Code&lt;/h2&gt;

&lt;p&gt;We’ve now made it far enough in our description that we can now walk through
the algorithm.  Feel free to skip this section if you would like and go
directly to the performance section below, and then return to this once you’ve
become convinced that you really are interested in the algorithmic details.
You can also just examine (or implement)
&lt;a href=&quot;https://github.com/ZipCPU/interpolation/blob/master/rtl/quadratic/quadinterp.v&quot;&gt;the code&lt;/a&gt;,
yourself to see what your thoughts are of it.&lt;/p&gt;

&lt;p&gt;The algorithm starts by defining some interface parameters.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	parameter	INW   = 25,	// Input width
			OWID  = INW,	// Output width
			MP    = 25,	// Multiply precision
			CTRBITS = 32;	// Bits in our counter&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;These are the input width, the output width, and the number of bits of our
time counter to use in the multiply.  The fourth value, &lt;code class=&quot;highlighter-rouge&quot;&gt;CTRBITS&lt;/code&gt;, controls
the total number of bits in the time counter.  In other words, how accurate
the fractional
&lt;a href=&quot;https://en.wikipedia.org/wiki/Upsamplers&quot;&gt;upsampling&lt;/a&gt;
ratio should be.  As with the &lt;a href=&quot;/dsp/2017/07/29/series-linear-interpolation.html&quot;&gt;linear
interpolator&lt;/a&gt;
development, this counter will step, on each input
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;sample&lt;/a&gt;,
by a step size given by the input &lt;code class=&quot;highlighter-rouge&quot;&gt;i_step&lt;/code&gt;,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;i_step = 2^(CTRBITS) (int)(old_sample_rate / new_sample_rate);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The number of bits in &lt;code class=&quot;highlighter-rouge&quot;&gt;CTRBITS&lt;/code&gt; will just control the accuracy and precision
of the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sample-rate_conversion&quot;&gt;resampling&lt;/a&gt;
function.&lt;/p&gt;

&lt;p&gt;The next two parameters, &lt;code class=&quot;highlighter-rouge&quot;&gt;OPT_INTERPOLATOR&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;OPT_IMPROVE_FIT&lt;/code&gt;, we
discussed earlier.  These control which quadratic
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sample-rate_conversion&quot;&gt;resampler&lt;/a&gt;
to implement among three defined in the code.  &lt;code class=&quot;highlighter-rouge&quot;&gt;OPT_INTERPOLATOR=1&lt;/code&gt; will
cause us to use the new
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;.
On the other hand, if &lt;code class=&quot;highlighter-rouge&quot;&gt;OPT_INTERPOLATOR=0&lt;/code&gt; but
&lt;code class=&quot;highlighter-rouge&quot;&gt;OPT_IMPROVED_FIT=1&lt;/code&gt;, then we’ll use the
non-&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;
output.  Finally, if both are zero the algorithm will calculate the
quadratic fit I’ve been so critical of.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	parameter  [0:0]	OPT_IMPROVED_FIT = 1&#39;b1;
	parameter  [0:0]	OPT_INTERPOLATOR = 1&#39;b1;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The last parameter, &lt;code class=&quot;highlighter-rouge&quot;&gt;GAIN_OFFSET&lt;/code&gt;, controls how far we shift the final result
to the right.  Ideally, this would be 4 if &lt;code class=&quot;highlighter-rouge&quot;&gt;OPT_INTERPOLATOR&lt;/code&gt; would be set in
order to divide by the factor of sixteen shown above.  Sadly, we can’t do that.
In particular, a set of constant maximum negative values surrounding a maximum
positive value, or vice versa, will yield filter results outside of that
incoming range.  Hence, to avoid overflow, we’ll only shift by three bits
(divide by eight), or two for the quadratic fit approaches.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	parameter		GAIN_OFFSET = (OPT_INTERPOLATOR)? 3:2;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The next step is to calculate the bit widths of various portions of this
algorithm.  These are held in local parameters, since they are calculated
from the main parameters above.  The first are the bit widths of the
coefficients,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;			// Bit-Width&#39;s of the quadratic, linear, and constant
			// coefficients
	localparam	AW = (OPT_INTERPOLATOR)?INW+6:INW+2,
			BW = (OPT_INTERPOLATOR)?INW+6:INW+1,
			CW = (OPT_INTERPOLATOR)?INW  :((OPT_IMPROVED_FIT)?(INW+3):INW),&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;followed by the number of bits we’ll have after the decimal place following each
computation,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;			ADEC=(OPT_INTERPOLATOR)? 4:1,
			BDEC=(OPT_INTERPOLATOR)? 4:1,
			CDEC=(OPT_INTERPOLATOR)? 0:((OPT_IMPROVED_FIT)? 3:0);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Remember, any time you want to multiply integers and fractions such as &lt;code class=&quot;highlighter-rouge&quot;&gt;A.B&lt;/code&gt;
times &lt;code class=&quot;highlighter-rouge&quot;&gt;X.Y&lt;/code&gt; (not the decimal place), you’ll need to first move the decimal
place to the far right so as to get &lt;code class=&quot;highlighter-rouge&quot;&gt;2^N(AB.)&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;2^M(XY.)&lt;/code&gt;.  Then, when
you multiply these numbers, you can shift them back to get the result you
were looking for back to where it belongs:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;A.B * X.Y = (AB. * XY.)*2^(-N-M)&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Of course, in practice this just means that we’ll track this resulting
decimal point, as you’ll see through &lt;a href=&quot;https://github.com/ZipCPU/interpolation/blob/master/rtl/quadratic/quadinterp.v&quot;&gt;the
code&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The final local parameter is the width of the internal calculations.
This is the number of bits that we will keep following each multiply.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	localparam	BMW = ((AW-ADEC&amp;gt;BW-BDEC) ? (AW-ADEC+BDEC) : BW);
	localparam	CMW = ((BMW+1-BDEC&amp;gt;CW-CDEC) ? (BMW+1-BDEC+CDEC) : CW);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;With these preliminaries aside, we can finally dig in to the
&lt;a href=&quot;https://github.com/ZipCPU/interpolation/blob/master/rtl/quadratic/quadinterp.v&quot;&gt;implementation&lt;/a&gt;
of our quadratic
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;,
beginning with how we generate the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial&quot;&gt;polynomial&lt;/a&gt;
coefficients themselves.  Since this will change depending upon our
choice of quadratic, we’ll use a generate block to select from among
several logic sets.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	generate if (OPT_INTERPOLATOR)
	begin&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;As our first step, we’ll calculate the shift register of data inputs
and a short history that we discussed above in the last section.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;		always @(posedge i_clk)
		if (i_ce)
			{ mem[3], mem[2], mem[1], mem[0] }
				&amp;lt;= { mem[2], mem[1], mem[0], i_data };&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Let’s take a moment here to discuss &lt;code class=&quot;highlighter-rouge&quot;&gt;i_ce&lt;/code&gt;.  This is the “global CE” signal
from our &lt;a href=&quot;/blog/2017/08/14/strategies-for-pipelining.html&quot;&gt;previous discussion on pipeline
strategies&lt;/a&gt;.
As you may recall from &lt;a href=&quot;/blog/2017/08/14/strategies-for-pipelining.html&quot;&gt;that
discussion&lt;/a&gt;,
the “global CE strategy” is very appropriate for
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_signal_processing&quot;&gt;signal processing&lt;/a&gt;
applications.  Further, you’ll want to remember the rules associated with the
“global CE” signal: &lt;em&gt;Nothing&lt;/em&gt; changes except on the clock that &lt;code class=&quot;highlighter-rouge&quot;&gt;i_ce&lt;/code&gt; is true.
Since this is a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sample-rate_conversion&quot;&gt;resampling&lt;/a&gt;
module, though, we’ll have to extend this rule.  Nothing on the incoming
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;sample&lt;/a&gt;,
rate side changes unless &lt;code class=&quot;highlighter-rouge&quot;&gt;i_ce&lt;/code&gt; is true.
We’ll use another CE signal, &lt;code class=&quot;highlighter-rouge&quot;&gt;r_ce&lt;/code&gt; for the output
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;sample&lt;/a&gt;
side in a moment.&lt;/p&gt;

&lt;p&gt;The next several calculations also follow directly from the last section
as well.  The only difference here is that this time we are applying the
necessary shifts to accomplish the needed “multiplies” from before.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;		always @(posedge i_clk)
		if (i_ce)
		begin
			pmidv &amp;lt;= { mem[0], 3&#39;b000 }
					- { {(3){mem[0][INW-1]}},mem[0]};// x7
			psumn &amp;lt;= { i_data[(INW-1)], i_data }
					+ { mem[1][(INW-1)], mem[1] };
			pdifn &amp;lt;= { i_data[(INW-1)], i_data }
					- { mem[1][(INW-1)], mem[1] };
			//
			sumw &amp;lt;= { mem[3][(INW-1)], mem[3] }
					+ { i_data[(INW-1)], i_data };
			// sumn &amp;lt;= psumn;
			diffn&amp;lt;= { pdifn[INW], pdifn, 2&#39;b00 }
					+ ,pdifn };// x5
			diffw&amp;lt;= { i_data[(INW-1)], i_data }
					- { mem[3][(INW-1)], mem[3] };
			// midv &amp;lt;= pmidv;
			midvpsumn &amp;lt;= -{ pmidv[(INW+2)],pmidv }
					+ { psumn[INW], psumn, 2&#39;h0 };//x7 + x4
		end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;That’s the first two clocks.  Then, on the third clock, we use these
intermediate expressions to generate the actual quadratic coefficients.
Remember, though, the &lt;code class=&quot;highlighter-rouge&quot;&gt;mem[x]&lt;/code&gt; values by this clock have shifted forward by
one extra
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;sample&lt;/a&gt;.
As a result, &lt;code class=&quot;highlighter-rouge&quot;&gt;cv&lt;/code&gt; is set to &lt;code class=&quot;highlighter-rouge&quot;&gt;mem[2]&lt;/code&gt; instead of &lt;code class=&quot;highlighter-rouge&quot;&gt;mem[1]&lt;/code&gt;.
Likewise, the &lt;code class=&quot;highlighter-rouge&quot;&gt;av&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;bv&lt;/code&gt; values here have been multiplied by sixteen
compared to the coefficients we want.  This factor of sixteen will ultimately,
and only partially, be corrected with the &lt;code class=&quot;highlighter-rouge&quot;&gt;GAIN_OFFSET&lt;/code&gt; when we are done.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;		initial	av = 0;
		initial	bv = 0;
		always @(posedge i_clk)
		if (i_ce)
		begin
			// av = x28 + x16 + x2
			// av = - { midv, 2&#39;b00 } + { sumn, 4&#39;h0 } - { sumw, 1&#39;b0 };
			av &amp;lt;= { midvpsumn, 2&#39;b00 }
					- { {(4){sumw[INW]}}, sumw, 1&#39;b0 };
			bv &amp;lt;= { diffn[INW+3],diffn, 1&#39;b0 }
				- { {(5){diffw[INW]}}, diffw };
			cv &amp;lt;= mem[2];
		end

	end else begin&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The next two sections in &lt;a href=&quot;https://github.com/ZipCPU/interpolation/blob/master/rtl/quadratic/quadinterp.v&quot;&gt;the
code&lt;/a&gt;
calculate the coefficients of the quadratic fit and
our non-&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolating&lt;/a&gt;
quadratic.  We’ll skip these here for simplicity, so that we can focus on
today’s quadratic &lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;,
however we’ll show the results of these
&lt;a href=&quot;https://en.wikipedia.org/wiki/Upsamplers&quot;&gt;upsampling&lt;/a&gt;
filters further down.&lt;/p&gt;

&lt;p&gt;At this point, then, we have our three quadratic coefficients, &lt;code class=&quot;highlighter-rouge&quot;&gt;av&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;bv&lt;/code&gt;,
and &lt;code class=&quot;highlighter-rouge&quot;&gt;cv&lt;/code&gt;–regardless of which algorithm generated them.&lt;/p&gt;

&lt;p&gt;We discussed in the last section the need for keeping the coefficients from
the last interval around, so we’ll copy them here.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(posedge i_clk)
	if (i_ce)
	begin
		avold &amp;lt;= av;
		bvold &amp;lt;= bv;
		cvold &amp;lt;= cv;
	end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;We’ll
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sample-rate_conversion&quot;&gt;resample&lt;/a&gt;
our data two clocks following any new incoming data, so let’s
capture that new value here.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(posedge i_clk)
		pre_ce &amp;lt;= i_ce;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;That brings us to calculating when to take our next
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;sample&lt;/a&gt;.
This code should be familiar, as it was lifted from our discussion on
&lt;a href=&quot;/dsp/2017/07/29/series-linear-interpolation.html&quot;&gt;linear interpolators&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;First, we calculate the when of the next
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;sample&lt;/a&gt;
point.  Our &lt;code class=&quot;highlighter-rouge&quot;&gt;t&lt;/code&gt; value is given by this counter.  When the counter overflows,
the next outgoing
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;sample&lt;/a&gt;
will require a new incoming
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;sample&lt;/a&gt;
so we’ll then stop moving forward and wait for that next
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;sample&lt;/a&gt;&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	// ...
	initial	r_ovfl  = 1&#39;b1;
	always @(posedge i_clk)
		if (i_ce)
			{ r_ovfl, r_counter } &amp;lt;= r_counter + i_step;
		else if (!r_ovfl)
			{ r_ovfl, r_counter } &amp;lt;= r_counter + i_step;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;In the end, the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;sample&lt;/a&gt;
indicator is a combination of either following a new
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;sample&lt;/a&gt;
value, or any other
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;sample&lt;/a&gt;
up until the counter overflows.  In this fashion, we’ll
&lt;a href=&quot;https://en.wikipedia.org/wiki/Upsamplers&quot;&gt;upsample&lt;/a&gt;
the incoming data.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	// ...
	initial	r_ce = 1&#39;b0;
	always @(posedge i_clk)
		r_ce &amp;lt;= ((pre_ce)||(!r_ovfl));&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Please feel free to refer back to the &lt;a href=&quot;/dsp/2017/07/29/series-linear-interpolation.html&quot;&gt;linear
interpolator&lt;/a&gt;
series if you find this logic difficult to understand.&lt;/p&gt;

&lt;p&gt;Two steps are left before evaluating the quadratic
&lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial&quot;&gt;polynomial&lt;/a&gt;: calculating &lt;code class=&quot;highlighter-rouge&quot;&gt;t&lt;/code&gt;,
and switching our coefficients so that the quadratic function we create
&lt;em&gt;surrounds&lt;/em&gt; our incoming data point. This accomplishes the transformation
illustrated in Fig 12 above.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(posedge i_clk)
	if (r_ce)
		pre_offset &amp;lt;= r_counter[(CTRBITS-1):(CTRBITS-MP)];

	// ...
	always @(posedge i_clk)
		if (r_ce)
		begin
			r_offset &amp;lt;= { pre_offset[MP-1], pre_offset[(MP-2):0] };
			if (pre_offset[(MP-1)])
			begin
				r_av &amp;lt;= av;
				r_bv &amp;lt;= bv;
				r_cv &amp;lt;= cv;
			end else begin
				r_av &amp;lt;= avold;
				r_bv &amp;lt;= bvold;
				r_cv &amp;lt;= cvold;
			end
		end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;At this point we now have our quadratic coefficients, &lt;code class=&quot;highlighter-rouge&quot;&gt;r_av&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;r_bv&lt;/code&gt;, and
&lt;code class=&quot;highlighter-rouge&quot;&gt;r_cv&lt;/code&gt;, together with our time offset, &lt;code class=&quot;highlighter-rouge&quot;&gt;r_offset&lt;/code&gt;.  These are the coefficients
of the quadratic we wish to evaluate.  Indeed, at this point all of the
difficult stuff is done.  All that remains is to handle the quadratic
evaluation itself.&lt;/p&gt;

&lt;p&gt;The first step is to multiply &lt;code class=&quot;highlighter-rouge&quot;&gt;a&lt;/code&gt; by &lt;code class=&quot;highlighter-rouge&quot;&gt;t&lt;/code&gt;.  To keep everything else aligned,
we’ll forward all of our other coefficients to the next clock.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(posedge i_clk)
	if (r_ce)
	begin
		qp_quad  &amp;lt;= r_av * r_offset;	// * 2^(-MP-ADEC)
		qp_bv    &amp;lt;= r_bv;		// * 2^(-BDEC)
		qp_cv    &amp;lt;= r_cv;		// * 2^(-CDEC)
		qp_offset&amp;lt;= r_offset;		// * 2^(-MP)
	end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Many FPGA’s have dedicated multiply accumulate capability in their
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_signal_processing&quot;&gt;DSP&lt;/a&gt;
hardware.  Such a capability would allow
us to calculate &lt;code class=&quot;highlighter-rouge&quot;&gt;r_av * r_offset + r_bv&lt;/code&gt;–with an appropriate bit select
along the way.  For right or wrong, this has never been my coding practice.
Perhaps I just want more control of the operation.  Either way, I will often
split these two calculations into two separate clocks.  That’s why we aren’t
adding the &lt;code class=&quot;highlighter-rouge&quot;&gt;bv&lt;/code&gt; coefficient to this multiplication result in this clock.&lt;/p&gt;

&lt;p&gt;Before the next step, let’s consider what we have.  We have three numbers,
with decimal points in varying locations.  &lt;code class=&quot;highlighter-rouge&quot;&gt;r_av&lt;/code&gt; for example has &lt;code class=&quot;highlighter-rouge&quot;&gt;ADEC&lt;/code&gt;
bits following the decimal point, and we just multiplied it by a value, &lt;code class=&quot;highlighter-rouge&quot;&gt;t&lt;/code&gt;,
all of whose bits were to the right of the decimal point.  Hence, we now
have &lt;code class=&quot;highlighter-rouge&quot;&gt;(MP+ADEC)&lt;/code&gt; bits following our decimal point in a number that is
&lt;code class=&quot;highlighter-rouge&quot;&gt;AW&lt;/code&gt; bits wide.  Let’s keep track of this decimal point as well as the
decimal point for &lt;code class=&quot;highlighter-rouge&quot;&gt;qb_bv&lt;/code&gt; in our notes.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	// qp_quad (AW-ADEC).(MP+ADEC)
	// qb_bv   (BW-BDEC).(BDEC)&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;We are now going to want to add the results of this multiply to our &lt;code class=&quot;highlighter-rouge&quot;&gt;b&lt;/code&gt;
coefficient in our next step.  To do this though, we’re going to first
need to normalize
both values so that they have the same number of decimal points.
In spite of the ugly looking code below, we’re just dropping the extra
bits off the bottom.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	// lw_quad (BW-BDEC).(BDEC)
	assign	lw_quad = { {(BMW-(AW+MP-(MP+ADEC-BDEC))){qp_quad[(AW+MP-1)]}},
				qp_quad[(AW+MP-1):(MP+ADEC-BDEC)] };&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Hence, we just shifted &lt;code class=&quot;highlighter-rouge&quot;&gt;qp_quad&lt;/code&gt; down by &lt;code class=&quot;highlighter-rouge&quot;&gt;(MP+ADEC-BDEC)&lt;/code&gt; binary decimal points,
so that it now has &lt;code class=&quot;highlighter-rouge&quot;&gt;BDEC&lt;/code&gt; bits following the decimal instead of &lt;code class=&quot;highlighter-rouge&quot;&gt;MP+ADEC&lt;/code&gt;.
The result, &lt;code class=&quot;highlighter-rouge&quot;&gt;lw_quad&lt;/code&gt;, now has the same number of decimal places as
&lt;code class=&quot;highlighter-rouge&quot;&gt;qp_bv&lt;/code&gt;, so we can now add these two numbers together.  As before, we’ll
forward the constants we haven’t yet used to the next clock cycle.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(posedge i_clk)
	if (r_ce)
	begin
		// ...
		ls_bv    &amp;lt;= { { (BMW+1-BW){qp_bv[BW-1] } }, qp_bv }
				+ { lw_quad[BMW-1], lw_quad };
		ls_cv    &amp;lt;= qp_cv;
		ls_offset&amp;lt;= qp_offset;
	end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;As a next step, we’ll calculate &lt;code class=&quot;highlighter-rouge&quot;&gt;(a*t+b)*t&lt;/code&gt; and place the result into &lt;code class=&quot;highlighter-rouge&quot;&gt;lp_bv&lt;/code&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(posedge i_clk)
	if (r_ce)
	begin
		lp_bv    &amp;lt;= ls_bv * ls_offset;	// * 2^(-MP-BDEC)
		lp_cv    &amp;lt;= ls_cv;		// * 2^(-   CDEC)
	end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;As before, we keep track of our decimal points at this step.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	// lp_bv (BMW+1-BDEC).(BDEC+MP)
	// lp_cv    (CW-CDEC).(CDEC)&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This helps us to know how much to shift &lt;code class=&quot;highlighter-rouge&quot;&gt;lp_bv&lt;/code&gt; by in order to align it with
&lt;code class=&quot;highlighter-rouge&quot;&gt;lp_cv&lt;/code&gt; so that the two can be added in the next step.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	wire	signed	[(CMW-1):0]	wp_bv;
	assign	wp_bv = { lp_bv[(BMW+MP):(MP+BDEC-CDEC)] };&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This brings us to the last part of calculating the quadratic, adding the
constant to the final result.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(posedge i_clk)
	if (r_ce)
		r_done &amp;lt;= { wp_bv[CMW-1], wp_bv }
				 + , lp_cv};&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;And we’re done!&lt;/p&gt;

&lt;p&gt;Okay, not quite.  We still need to drop a bunch of bits.
As &lt;a href=&quot;/dsp/2017/07/22/rounding.html&quot;&gt;we discussed earlier&lt;/a&gt;,
there’s a right and a wrong way to do drop bits in a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_signal_processing&quot;&gt;DSP&lt;/a&gt;
algorithm.  Hence, we’ll round towards the nearest even integer here
and then throw the rest of the bits away.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	generate if (CMW+1-GAIN_OFFSET &amp;gt; OWID)
	begin

		reg	[CMW-GAIN_OFFSET:0]	rounded;

		initial rounded = 0;
		always @(posedge i_clk)
		if (r_ce)
			rounded &amp;lt;= r_done[(CMW-GAIN_OFFSET):0]
				+ { {(OWID){1&#39;b0}},
					r_done[CMW-GAIN_OFFSET-OWID],
				{(CMW-OWID-GAIN_OFFSET-1)
					{!r_done[CMW-GAIN_OFFSET-OWID]}} };

		assign	o_data = rounded[(CMW-GAIN_OFFSET)
					:(CMW+1-GAIN_OFFSET-OWID)];&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The &lt;a href=&quot;https://github.com/ZipCPU/interpolation/blob/master/rtl/quadratic/quadinterp.v&quot;&gt;code&lt;/a&gt;
contains two other non-rounding choices, which we shall skip here
in our discussion.&lt;/p&gt;

&lt;p&gt;The final step is to note when this output is valid.  This involves
forwarding our new &lt;a href=&quot;/blog/2017/08/14/strategies-for-pipelining.html&quot;&gt;global CE pipeline control
signal&lt;/a&gt;
to the output.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	// ...
	end endgenerate

	assign	o_ce = r_ce;

	// ...
endmodule&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;At this, we are now done and our
&lt;a href=&quot;https://github.com/ZipCPU/interpolation/blob/master/rtl/quadratic/quadinterp.v&quot;&gt;code&lt;/a&gt;
is complete.  But does it work?  Let’s see in the next section.&lt;/p&gt;

&lt;h2 id=&quot;the-proof&quot;&gt;The Proof&lt;/h2&gt;

&lt;p&gt;I’ve always counseled individuals not to use a tool they aren’t familiar with.
Every tool in the shed has its purpose, its capabilities, and its limitations.
This &lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;
is no different from any other tool in that sense.  To see how well, or
poorly, this quadratic
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;
works, let’s test it.  In particular, we can sweep a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sine_wave&quot;&gt;sine wave&lt;/a&gt;
through the input and see what happens.  Further, let’s compare this 
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;
with four different
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolation&lt;/a&gt;
methods:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Our first method will be the simple &lt;a href=&quot;/dsp/2017/06/06/simple-interpolator.html&quot;&gt;sample and hold
circuit&lt;/a&gt; we
presented earlier.  Since the code within this module doesn’t really handle
&lt;a href=&quot;https://en.wikipedia.org/wiki/Upsamplers&quot;&gt;upsampling&lt;/a&gt;, we’ll use the &lt;a href=&quot;/blog/2017/08/14/strategies-for-pipelining.html&quot;&gt;global
CE&lt;/a&gt;
from the other
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolators&lt;/a&gt;
to know when to capture this output.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The second method will be a straight-forward
&lt;a href=&quot;/dsp/2017/07/29/series-linear-interpolation.html&quot;&gt;linear interpolator&lt;/a&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Our third choice will be the quadratic fit we developed above, allowing
you to see just how good, or poor, this
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt; is in practice.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;We’ll then use the nice quadratic
&lt;a href=&quot;https://en.wikipedia.org/wiki/Upsamplers&quot;&gt;upsampler&lt;/a&gt; from above,
the one that we chose to call the
non-&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The final test algorithm is today’s quadratic
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt; algorithm.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;While I won’t walk you through the test code (today), I will post it with the
rest of the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;’s
&lt;a href=&quot;https://github.com/ZipCPU/interpolation/blob/master/rtl/quadratic/quadinterp.v&quot;&gt;code&lt;/a&gt;
in my &lt;a href=&quot;https://github.com/ZipCPU/interpolation&quot;&gt;interpolation repository&lt;/a&gt;.
If you are interested in this test code, check out the
&lt;a href=&quot;https://github.com/ZipCPU/interpolation/tree/master/bench&quot;&gt;bench&lt;/a&gt;
subdirectories.  There you will find a &lt;a href=&quot;https://github.com/ZipCPU/interpolation/blob/master/bench/rtl/icomparison.v&quot;&gt;master Verilog
module&lt;/a&gt;
that instantiates examples of all of the filters below, as well as a &lt;a href=&quot;https://github.com/ZipCPU/interpolation/blob/master/bench/cpp/icompare.cpp&quot;&gt;Verilator
based C++&lt;/a&gt;
program that will exercise these filters and write the outputs to a data file.
Finally, there’s a &lt;a href=&quot;https://github.com/ZipCPU/interpolation/blob/master/bench/cpp/plotem.m&quot;&gt;Octave
script&lt;/a&gt;
that can be used to plot these results.&lt;/p&gt;

&lt;p&gt;Sadly, the resulting data is too voluminous to plot in its entirety here,
so I’ll just pick some useful and revealing sections of this data for
discussion.&lt;/p&gt;

&lt;p&gt;For four first example, let’s compare how these
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolation&lt;/a&gt;
functions perform for a low frequency
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sine_wave&quot;&gt;sine wave&lt;/a&gt;.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 13. Low frequency interpolation&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/quadeqn-result-lo.png&quot; alt=&quot;&quot; width=&quot;581&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;By visual inspection alone, most of the quadratic
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolators&lt;/a&gt;
did pretty well.  Even the linear
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;
seems to be tracking the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sine_wave&quot;&gt;sine wave&lt;/a&gt;.
quite nicely.&lt;/p&gt;

&lt;p&gt;If you look even closer, though, you may notice some minor discontinuities
in the quadratic fit, or locations where the quadratic
non-&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;
doesn’t go through the given
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;sample&lt;/a&gt;
points.  These effects are minimal at this low frequency, but they are present.&lt;/p&gt;

&lt;p&gt;So, let’s increase the frequency.&lt;/p&gt;

&lt;p&gt;Fig 14 below shows the same
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sine_wave&quot;&gt;sine wave&lt;/a&gt;,
but this time with a frequency between &lt;code class=&quot;highlighter-rouge&quot;&gt;0.25&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;0.3&lt;/code&gt; cycles per sample.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 14. Higher frequency interpolation&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/quadeqn-result-hi.png&quot; alt=&quot;&quot; width=&quot;582&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Here the differences become very stark.  The quadratic fit’s discontinuities
are much larger, and the
non-&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;
is clearly missing the input
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;sample&lt;/a&gt;
points.&lt;/p&gt;

&lt;p&gt;If you look closer, you may even see some kinks in the quadratic
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt; we just built.
These are a result of the fact that, although this
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt; is
&lt;a href=&quot;https://en.wikipedia.org/wiki/Continuous_function&quot;&gt;continuous&lt;/a&gt;,
it is not 
&lt;a href=&quot;https://en.wikipedia.org/wiki/Continuous_function&quot;&gt;continuous&lt;/a&gt;
in its first derivative.  Achieving that result will take more work–something
we’ll leave for another day.  Even still, though, this is probably good enough
for most purposes at this frequency.&lt;/p&gt;

&lt;p&gt;What about a higher frequency?  Why not push both of these
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolators&lt;/a&gt;
until they completely break down near the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Nyquist_frequency&quot;&gt;Nyquist frequency&lt;/a&gt;?&lt;/p&gt;

&lt;p&gt;That’s the purpose of the next figure, Fig 15.  In this figure, the incoming
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sine_wave&quot;&gt;sine wave&lt;/a&gt; is
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;sampled&lt;/a&gt;
right near the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Nyquist_frequency&quot;&gt;Nyquist cutoff frequency&lt;/a&gt;
of two samples per cycle.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 15. Interpolation near Nyquist&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/quadeqn-result-aliased.png&quot; alt=&quot;&quot; width=&quot;584&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Judging from the images above, it looks like the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolators&lt;/a&gt;
are tracking the outline of a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sine_wave&quot;&gt;sine wave&lt;/a&gt;
multiplied by some kind of envelope.  The
incoming signal, however, had no envelope function constraining it.  Indeed,
the incoming signal was nothing but a straight
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sine_wave&quot;&gt;sine wave&lt;/a&gt;.  Instead, this
apparent “envelope” is the result of undersampling a high frequency
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sine_wave&quot;&gt;sine wave&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Which &lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;
is better in this environment?  I might argue that none of them work well
this close to the &lt;a href=&quot;https://en.wikipedia.org/wiki/Nyquist_frequency&quot;&gt;Nyquist
frequency&lt;/a&gt;,
and that instead this final example frequency is really beyond their
capability.  This isn’t to say that better
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolators&lt;/a&gt;
do not exist, or that they cannot be developed.  Rather, it is simply a
statement of the reality that any
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;
will break down as it approaches the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Nyquist_frequency&quot;&gt;Nyquist frequency&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;For just the cost of a couple multiplies, several additions and bit selects,
and quite a few flip-flops, we’ve managed to implement a better
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;.
This &lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;
is better than a &lt;a href=&quot;/dsp/2017/06/06/simple-interpolator.html&quot;&gt;sample and
hold&lt;/a&gt;,
better than a
&lt;a href=&quot;/dsp/2017/07/29/series-linear-interpolation.html&quot;&gt;linear interpolator&lt;/a&gt;,
and even better than the straight forward quadratic fit we started with.
Further, unlike the more traditional
&lt;a href=&quot;http://ieeexplore.ieee.org/document/15483/&quot;&gt;Farrow&lt;/a&gt;
filter development, the output of the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sample-rate_conversion&quot;&gt;resampler&lt;/a&gt;
created by &lt;a href=&quot;https://github.com/ZipCPU/interpolation/blob/master/rtl/quadratic/quadinterp.v&quot;&gt;this interpolator&lt;/a&gt;
is actually constrained to go through the input samples.&lt;/p&gt;

&lt;p&gt;Does this mean that this is the best approach to
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolation&lt;/a&gt;?
By no means.  While &lt;a href=&quot;https://github.com/ZipCPU/interpolation/blob/master/rtl/quadratic/quadinterp.v&quot;&gt;this
solution&lt;/a&gt;
has some nice properties associated with it, it has no optimality properties.
In that sense, it’s just another ad-hoc development in a similar vein to
&lt;a href=&quot;http://ieeexplore.ieee.org/document/15483/&quot;&gt;Farrow&lt;/a&gt;’s.&lt;/p&gt;

&lt;p&gt;As with everything, though, you get want you pay for.  Better 
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolators&lt;/a&gt; of this
variety exist, but they do cost more.  For example, there’s another filter like
this one documented in my &lt;a href=&quot;https://github.com/ZipCPU/interpolation/raw/master/tutorial.pdf&quot;&gt;interpolation
tutorial&lt;/a&gt;,
although the coefficient multiplies are too difficult to do with just adds
and subtracts.  Indeed, they require a divide by 80!  Another approach is to use
&lt;a href=&quot;https://en.wikipedia.org/wiki/Spline_interpolation&quot;&gt;spline&lt;/a&gt; interpolation.
You may remember my earlier suggestion that
&lt;a href=&quot;https://en.wikipedia.org/wiki/Spline_interpolation&quot;&gt;spline&lt;/a&gt; interpolation could
be done without calculating a new matrix solution for every data point.&lt;/p&gt;

&lt;!-- Mention: Asynchronous Sample Rate Conversion? --&gt;

&lt;p&gt;This, though, will need to be a discussion for another day.&lt;/p&gt;
&lt;hr /&gt;&lt;p&gt;&lt;em&gt;And he spake also a parable unto them; No man putteth a piece of a new garment upon an old; if otherwise, then both the new maketh a rent, and the piece that was taken out of the new agreeth not with the old. (Luke 5:36)&lt;/em&gt;</description>
        <pubDate>Fri, 30 Mar 2018 00:00:00 -0400</pubDate>
        <link>http://zipcpu.com/dsp/2018/03/30/quadratic.html</link>
        <guid isPermaLink="true">http://zipcpu.com/dsp/2018/03/30/quadratic.html</guid>
        
        
        <category>dsp</category>
        
      </item>
    
      <item>
        <title>Pipelining a Prefetch</title>
        <description>&lt;p&gt;If you are familiar with the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;,
you’ll know that it was built in order to be a fully capable
&lt;a href=&quot;https://en.wikipedia.org/wiki/Soft_microprocessor&quot;&gt;CPU&lt;/a&gt;
while only using a
&lt;a href=&quot;/blog/2017/06/12/minimizing-luts.html&quot;&gt;minimal amount&lt;/a&gt; of
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt; logic.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 1. The ZipCPU&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/zipcpu.png&quot; alt=&quot;&quot; width=&quot;320&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;There’s a problem, though, with the phrase, “minimal amount of logic.”
Specifically, how much is minimal?  This is a difficult question,
since the answer changes from
&lt;a href=&quot;https://github.com/ZipCPU/s6soc&quot;&gt;one design&lt;/a&gt;
to the
&lt;a href=&quot;https://github.com/ZipCPU/openarty&quot;&gt;next&lt;/a&gt;.  When it comes to a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Soft_microprocessor&quot;&gt;soft-core CPU&lt;/a&gt;,
logic and performance start to trade off against each other as well.  What
I mean by that is that you can often spend logic within an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt; in order
to purchase better performance.  Hence, if you want to build a fast
&lt;a href=&quot;https://en.wikipedia.org/wiki/Soft_microprocessor&quot;&gt;CPU&lt;/a&gt;,
you’ll want to use as much logic as you can to purchase that high speed.  On
the other hand, if you want to &lt;a href=&quot;/blog/2017/06/12/minimizing-luts.html&quot;&gt;fit within a very small
space&lt;/a&gt;,
you might find that speed is not nearly as important.&lt;/p&gt;

&lt;p&gt;As an example, this was the trade-off within the
&lt;a href=&quot;https://github.com/ZipCPU/s6soc/&quot;&gt;S6SoC&lt;/a&gt;. The
&lt;a href=&quot;https://github.com/ZipCPU/s6soc/&quot;&gt;S6SoC&lt;/a&gt; as you
&lt;a href=&quot;/blog/2017/06/12/minimizing-luts.html&quot;&gt;may recall&lt;/a&gt;
is a demonstration
of the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; that runs within a
&lt;a href=&quot;https://www.xilinx.com/support/documentation/data_sheets/ds160.pdf&quot;&gt;Spartan 6 LX4&lt;/a&gt;–the
smallest &lt;a href=&quot;https://www.xilinx.com/support/documentation/data_sheets/ds160.pdf&quot;&gt;Spartan 6
(S6)&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
you could ever buy from
&lt;a href=&quot;https://www.xilinx.com&quot;&gt;Xilinx&lt;/a&gt;.  Getting a multi-tasking
&lt;a href=&quot;https://en.wikipedia.org/wiki/Soft_microprocessor&quot;&gt;CPU&lt;/a&gt; to fit within these
constraints was a challenge.  Getting that same
&lt;a href=&quot;https://en.wikipedia.org/wiki/Soft_microprocessor&quot;&gt;CPU&lt;/a&gt;
to have decent performance at the same time is even harder.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: left&quot;&gt;&lt;caption&gt;Fig 2. Digilent&#39;s CMod S6&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/cmods6.png&quot; alt=&quot;&quot; width=&quot;250&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Getting the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; to fit within the
&lt;a href=&quot;https://github.com/ZipCPU/s6soc&quot;&gt;S6SoC&lt;/a&gt; took a bit of trimming.  I got rid
of the
&lt;a href=&quot;/zipcpu/2017/08/23/cpu-pipeline.html&quot;&gt;pipelining&lt;/a&gt;,
switched to the lowest logic
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/memops.v&quot;&gt;memory controller&lt;/a&gt;
I knew how to
build and the lowest logic
&lt;a href=&quot;/zipcpu/2017/11/18/wb-prefetch.html&quot;&gt;prefetch&lt;/a&gt;.  I
removed the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/div.v&quot;&gt;divide unit&lt;/a&gt;
and removed
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/cpudefs.v&quot;&gt;early branching&lt;/a&gt;.
(All of these modifications can be made from within the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/cpudefs.v&quot;&gt;cpudefs.v&lt;/a&gt; file.)
I got rid of the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/zipcounter.v&quot;&gt;performance
counters&lt;/a&gt;,
the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/wbdmac.v&quot;&gt;DMA
engine&lt;/a&gt;,
and the various
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/ziptimer.v&quot;&gt;timers&lt;/a&gt;
that service the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt;.
I even had to remove the &lt;a href=&quot;/blog/2017/06/28/dbgbus-goal.html&quot;&gt;debugging
bus&lt;/a&gt;–there just wasn’t
room on the
&lt;a href=&quot;https://www.xilinx.com/support/documentation/data_sheets/ds160.pdf&quot;&gt;LX4&lt;/a&gt;.
With a bit of work, I managed to get this
&lt;a href=&quot;https://github.com/ZipCPU/s6soc/tree/master/rtl/cpu&quot;&gt;trimmed-down&lt;/a&gt;
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt; to fit within the
&lt;a href=&quot;https://www.xilinx.com/support/documentation/data_sheets/ds160.pdf&quot;&gt;S6&lt;/a&gt;
on board
&lt;a href=&quot;https://store.digilentinc.com&quot;&gt;Digilent&lt;/a&gt;’s &lt;a href=&quot;https://store.digilentinc.com/cmod-s6-breadboardable-spartan-6-fpga-module&quot;&gt;CMod
S6&lt;/a&gt;
board.&lt;/p&gt;

&lt;p&gt;Then I tried to apply this
&lt;a href=&quot;https://github.com/ZipCPU/s6soc/tree/master/rtl/cpu&quot;&gt;trimmed-down&lt;/a&gt;
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt; to an
audio application.  Oh, it was a simple
demonstration: when the button is pressed, play a doorbell sound from a
recorded &lt;code class=&quot;highlighter-rouge&quot;&gt;8 kHz&lt;/code&gt; audio sample array.&lt;/p&gt;

&lt;p&gt;The &lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt; wasn’t fast enough.&lt;/p&gt;

&lt;p&gt;All the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt; had to do was to
read the audio samples from
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt;
memory, service interrupts, and particularly service the audio interrupt to
write one sample at a time to the
&lt;a href=&quot;/blog/2017/09/04/pwm-reinvention.html&quot;&gt;audio controller&lt;/a&gt;.
(Remember, I had no room for the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/wbdmac.v&quot;&gt;DMA
engine&lt;/a&gt;
to do this automatically.)&lt;/p&gt;

&lt;p&gt;The &lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt; just wasn’t fast enough as
built for even that.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Speeding&lt;/em&gt; up a &lt;a href=&quot;https://en.wikipedia.org/wiki/Soft_microprocessor&quot;&gt;CPU&lt;/a&gt; in an
environment where
&lt;a href=&quot;/blog/2017/06/12/minimizing-luts.html&quot;&gt;every LUT matters&lt;/a&gt;
can be a challenge.&lt;/p&gt;

&lt;p&gt;The first thing I did was to move some of the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt;’s instructions from
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt;
to &lt;a href=&quot;https://en.wikipedia.org/wiki/Random-access_memory&quot;&gt;block RAM&lt;/a&gt;.
Since I didn’t have enough block
&lt;a href=&quot;https://en.wikipedia.org/wiki/Random-access_memory&quot;&gt;RAM&lt;/a&gt;
to do this for the whole multitasking
“O/S”, I only put the critical components into the limited
&lt;a href=&quot;https://en.wikipedia.org/wiki/Random-access_memory&quot;&gt;RAM&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;That still wasn’t fast enough.&lt;/p&gt;

&lt;p&gt;Then, in my last round with the &lt;a href=&quot;https://github.com/ZipCPU/s6soc&quot;&gt;S6SoC&lt;/a&gt;, I
created a better prefetch unit I called
&lt;a href=&quot;https://github.com/ZipCPU/s6soc/blob/master/rtl/cpu/dblfetch.v&quot;&gt;dblfetch&lt;/a&gt;.
&lt;a href=&quot;https://github.com/ZipCPU/s6soc/blob/master/rtl/cpu/dblfetch.v&quot;&gt;This prefetch&lt;/a&gt;
was low logic enough to fit within the space
I had, but also faster than the
&lt;a href=&quot;/zipcpu/2017/11/18/wb-prefetch.html&quot;&gt;simpler prefetch&lt;/a&gt;
I had started with.
&lt;a href=&quot;https://github.com/ZipCPU/s6soc/blob/master/rtl/cpu/dblfetch.v&quot;&gt;This prefetch&lt;/a&gt;
unit, or rather a slightly modified one, is also the subject of this article.&lt;/p&gt;

&lt;h2 id=&quot;measuring-memory-performance&quot;&gt;Measuring Memory Performance&lt;/h2&gt;

&lt;p&gt;Let’s start, though, by looking at how to measure memory performance.  In
a synchronous design, where everything takes place on a clock tick, then
memory performance can be quantified by how many clocks it takes per
transaction.&lt;/p&gt;

&lt;p&gt;When using the &lt;a href=&quot;http://opencores.org/cdn/downloads/wbspec_b3.pdf&quot;&gt;B3 version&lt;/a&gt;
of the
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;wishbone bus&lt;/a&gt;, there’s
a fixed number of clocks for every transaction–we’ll call this the
transaction’s latency, &lt;code class=&quot;highlighter-rouge&quot;&gt;L&lt;/code&gt;.  Hence, if you want to access &lt;code class=&quot;highlighter-rouge&quot;&gt;N&lt;/code&gt; memory locations,
this will cost you &lt;code class=&quot;highlighter-rouge&quot;&gt;LN&lt;/code&gt; clocks.&lt;/p&gt;

&lt;table style=&quot;float: left&quot;&gt;&lt;caption&gt;Fig 3: A pair of Wishbone bus requests&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/dblfetch-ram.svg&quot; alt=&quot;The trace for a pair of Wishbone bus requests, as drawn from the ZipCPU prefetch named dblfetch&quot; width=&quot;420&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;On the other hand, if you use the
&lt;a href=&quot;/blog/2017/08/14/strategies-for-pipelining.html&quot;&gt;pipelined&lt;/a&gt;
mode of the
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;wishbone bus&lt;/a&gt;
as illustrated in Fig 3 on the left
(&lt;a href=&quot;/doc/wbspec_b4.pdf&quot;&gt;version B4&lt;/a&gt; only), you can then have
multiple transactions in flight at the same
time.  In this case, the time it takes to accomplish a transaction becomes
&lt;code class=&quot;highlighter-rouge&quot;&gt;(N-1)S+L&lt;/code&gt;.  In other words, there’s an initial latency &lt;code class=&quot;highlighter-rouge&quot;&gt;L&lt;/code&gt;, followed by a
number of clocks &lt;code class=&quot;highlighter-rouge&quot;&gt;S&lt;/code&gt; for each additional transaction within the burst.&lt;/p&gt;

&lt;p&gt;If you look at this from a purely peripheral perspective, you can see six
separate peripheral implementations  (approximately) outlined in the table
below.&lt;/p&gt;

&lt;table class=&quot;bordered-table&quot;&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Peripheral&lt;/th&gt;
      &lt;th&gt;Clocks to access&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;a href=&quot;https://opencores.org/project,qspiflash&quot;&gt;Initial QSPI Flash&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;16N + 16&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;a href=&quot;https://github.com/ZipCPU/xulalx25soc/blob/master/rtl/wbspiflash.v&quot;&gt;Flash&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;32N + 40&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Dual SPI Flash, XIP&lt;/td&gt;
      &lt;td&gt;16N + 16&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;QSPI Flash, XIP&lt;/td&gt;
      &lt;td&gt;8N +  8&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;a href=&quot;https://github.com/ZipCPU/s6soc/blob/master/rtl/memdev.v&quot;&gt;Block RAM&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;N +  1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;a href=&quot;https://github.com/ZipCPU/xulalx25soc/blob/master/rtl/wbsdram.v&quot;&gt;SDRAM&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;2N +  6&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;DDR3 SDRAM&lt;/td&gt;
      &lt;td&gt;N + 22&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;My &lt;a href=&quot;https://github.com/ZipCPU/s6soc/blob/master/rtl/wbqspiflash.v&quot;&gt;initial controller for the QSPI
flash&lt;/a&gt;
on the &lt;a href=&quot;https://github.com/ZipCPU/s6soc&quot;&gt;S6SoC&lt;/a&gt; required 43-clocks
for a single transaction.  There was a delay or two within the logic of the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt; and the &lt;a href=&quot;https://github.com/ZipCPU/s6soc/blob/master/rtl/busmaster.v&quot;&gt;bus
structure&lt;/a&gt;–we’ll
say it was a two clock delay, with one clock on either side of the actual
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt;
access (shown in blue below).  Further, the
non-&lt;a href=&quot;/zipcpu/2017/08/23/cpu-pipeline.html&quot;&gt;pipelined&lt;/a&gt;
version of the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt; at the time
required 4 more clocks per instruction.  The result was that it cost the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt; 49 clocks per instruction (CPI).
With a 12ns clock, this meant that the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
could at best run 1.6 Million Instructions per Second (MIPS).&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 4. Unoptimized Prefetch from Flash and CPU Performance&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/pfpipe-slow-flash.svg&quot; alt=&quot;&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;At a rate of 1.6 MIPS I had 200 instructions to deal with each audio sample.
These 200 instructions had handle everything else as well: interrupts, button
presses, the software based real-time clock, etc.  No wonder it couldn’t keep
up with the 8kHz audio stream!&lt;/p&gt;

&lt;p&gt;Of course, the real answer to making a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Soft_microprocessor&quot;&gt;CPU&lt;/a&gt; faster would be to
&lt;a href=&quot;/zipcpu/2017/08/23/cpu-pipeline.html&quot;&gt;pipeline the CPU&lt;/a&gt;
and run with a &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/pfcache.v&quot;&gt;proper prefetch and instruction
cache&lt;/a&gt;–even
better, to run the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt; from an
on-board block
&lt;a href=&quot;https://en.wikipedia.org/wiki/Random-access_memory&quot;&gt;RAM&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/s6soc/blob/master/rtl/memdev.v&quot;&gt;device&lt;/a&gt;.
This approach would have the performance shown in Fig 5.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 5. Prefetch with Instruction Cache&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/pfpipe-wcache.svg&quot; alt=&quot;&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;If I only had the logic to do that, the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; would’ve ran close to one clock
per instruction, once the cache was loaded, and would then achieve nearly
82 MIPS (minus cache stalls) on the
&lt;a href=&quot;https://www.xilinx.com/support/documentation/data_sheets/ds160.pdf&quot;&gt;Spartan 6&lt;/a&gt;.
There just wasn’t enough logic in the
&lt;a href=&quot;https://www.xilinx.com/support/documentation/data_sheets/ds160.pdf&quot;&gt;LX4&lt;/a&gt;
to do this.&lt;/p&gt;

&lt;p&gt;What else could be done?&lt;/p&gt;

&lt;p&gt;If I placed the most common instructions into block
&lt;a href=&quot;https://en.wikipedia.org/wiki/Random-access_memory&quot;&gt;RAM&lt;/a&gt;,
as I discussed above, then the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt; could run at about
12 MIPS.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 6. Fetching instructions from Block RAM&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/pfpipe-bkram.svg&quot; alt=&quot;&quot; width=&quot;315&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Thanks to the author of the
&lt;a href=&quot;https://github.com/hgeisse/eco32&quot;&gt;ECO32 CPU&lt;/a&gt;
I was rather surprised to learn at the time that
&lt;a href=&quot;https://www.gnu.org/software/binutils&quot;&gt;binutils&lt;/a&gt; 
supported this sort of dual addressing–with some addresses in
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt;,
and other addresses in a section of
&lt;a href=&quot;https://en.wikipedia.org/wiki/Random-access_memory&quot;&gt;RAM&lt;/a&gt;
that had been copied/loaded from the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt;–all controlled from a
&lt;a href=&quot;https://github.com/ZipCPU/s6soc/blob/master/sw/dev/cmod.ld&quot;&gt;linker script&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;This would’ve been perfect except the
&lt;a href=&quot;https://www.xilinx.com/support/documentation/data_sheets/ds160.pdf&quot;&gt;S6 LX4&lt;/a&gt;
just doesn’t have that much block
&lt;a href=&quot;https://en.wikipedia.org/wiki/Random-access_memory&quot;&gt;RAM&lt;/a&gt;.
I &lt;em&gt;needed&lt;/em&gt; to run instructions from the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;In my case, there was more that could be done by trimming the &lt;a href=&quot;https://github.com/ZipCPU/s6soc/blob/master/rtl/wbqspiflash.v&quot;&gt;flash
controller&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;To understand the options and possibilities, let’s back up for a moment and
discuss what the
&lt;a href=&quot;https://www.cypress.com/file/177966/download&quot;&gt;QSPI flash protocol&lt;/a&gt;
requires.
After you give the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt;
a “Fast Read Quad Output” command (0xEBh), the
&lt;a href=&quot;https://www.cypress.com/file/177966/download&quot;&gt;QSPI flash&lt;/a&gt;
I was working with would enter into an eXecute In Place (XIP) mode.
From this XIP mode,
any new instruction requires lowering the &lt;code class=&quot;highlighter-rouge&quot;&gt;CS_n&lt;/code&gt; line, issuing an address,
then another byte indicating whether or not you wish to remain in XIP mode,
and then several dummy clocks.  Only after all this setup could you then read
one 32-bit value from the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt;
every eight clocks.&lt;/p&gt;

&lt;p&gt;Fig 7. below shows the clocks required in the setup.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 7. QSPI Flash Quad Read Protocol in XIP Mode&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/qspi-xip.png&quot; alt=&quot;&quot; width=&quot;600&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;This is the fastest way to read from the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt;,
although it requires an
SCK or two for setup and tear-down.
Using this mode, it will take 80 QSPI bits, or equivalently
20 QSPI SCK’s, to read any arbitrary 32-bits of data from the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;One problem with my
&lt;a href=&quot;https://opencores.org/project,qspiflash&quot;&gt;flash design&lt;/a&gt; at the time was
that it was creating a SPI
clock from logic.  On one clock cycle the SPI clock output would be a one,
then a zero, etc.  As a result, the fastest SPI clock, &lt;code class=&quot;highlighter-rouge&quot;&gt;SCK&lt;/code&gt;, I could create
was at half my system clock rate, or 41MHz.&lt;/p&gt;

&lt;p&gt;If I instead switched from a &lt;em&gt;logic generated&lt;/em&gt; clock to a clock generated by a
&lt;a href=&quot;https://www.xilinx.com&quot;&gt;Xilinx&lt;/a&gt;
&lt;a href=&quot;https://www.xilinx.com/support/documentation/sw_manuals/xilinx14_7/7series_hdl.pdf&quot;&gt;ODDR&lt;/a&gt;
primitive,
then the SPI clock &lt;code class=&quot;highlighter-rouge&quot;&gt;SCK&lt;/code&gt; would transition on each clock edge and run at the
same speed as the design’s system clock speed (82 MHz).
By doubling the speed of the SPI SCK, I could then also double the speed of the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt;
to roughly 22-clocks per fetch, or 28 clocks per instruction.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 8. Doubling the SCK speed via an ODDR&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/pfpipe-fast-flash.svg&quot; alt=&quot;&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;While a 2.9 MHz instruction rate is better than a 1.6 MHz rate, it’s still
quite dismal.&lt;/p&gt;

&lt;p&gt;If I cleaned up the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt; so that 2 of
the five stages were
&lt;a href=&quot;/zipcpu/2017/08/23/cpu-pipeline.html&quot;&gt;pipelined&lt;/a&gt;–the two
stages that didn’t suffer from
&lt;a href=&quot;/zipcpu/2017/08/23/cpu-pipeline.html&quot;&gt;pipeline&lt;/a&gt;
conflicts (prefetch and instruction decode), then I could get up to
3.0 MHz.  This would be a slight improvement.&lt;/p&gt;

&lt;p&gt;On the other hand, if I could fetch two instructions at a time, the second
instruction would benefit from the fact that the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt;
chip is already set
up to get a provide the next instruction word.  In this case, I could fetch
2 instructions in 36 clocks vice one instruction in 28 clocks.  When the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt; performance
was factored in, the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt; would now
(nominally) take 36 clocks per two instructions, or 18 clocks total (with
exceptions) per instruction.  This would mean that the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt;
could then speed up to a whopping
4.6 MIPS, based upon an (82 MHz/18 CPI).&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 9. Fetching two instructions from flash at a time&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/pfpipe-dblflash.svg&quot; alt=&quot;&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;This *was *going to be the topic of this article–how to read two instructions
at a time.  It was how I managed to speed up the
&lt;a href=&quot;https://github.com/ZipCPU/s6soc&quot;&gt;S6SoC&lt;/a&gt; at the time.  In a
moment, though, I’ll share a better, faster, and &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/dblfetch.v&quot;&gt;cheaper prefetch
module&lt;/a&gt; just
for this blog article.&lt;/p&gt;

&lt;p&gt;Before going there, though, I should finish the story of the
&lt;a href=&quot;https://github.com/ZipCPU/s6soc&quot;&gt;S6SoC&lt;/a&gt; since I made another
improvement as well: I compressed instructions.&lt;/p&gt;

&lt;p&gt;Using the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; compressed
instruction set, two 16-bit instructions can be
stored into a single 32-bit instruction word.  The performance isn’t
necessarily all that wonderful, but roughly two in ten instructions can
be packed together into a single word.
(A recent bug-fix suggests the true value might be four in ten instructions,
but I haven’t been able to measure this improvement properly yet–so we’ll
just use the two in ten number.)
I could probably do a bit better if
I taught the compiler or the assembler how to re-order instructions to maximize
this feature’s usage, but I’ll still take the 10% improvement.  Hence, the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; speed ultimately
became somewhere near (82/18/0.8) or 5.7 MHz.&lt;/p&gt;

&lt;p&gt;A funny thing happened, though, on the way to putting
&lt;a href=&quot;http://zipcpu.com/&quot;&gt;this blog&lt;/a&gt;
post together.  When I started using
&lt;a href=&quot;http://www.clifford.at/yosys&quot;&gt;yosys&lt;/a&gt;
to measure the logic usage of
&lt;a href=&quot;https://github.com/ZipCPU/s6soc/blob/master/rtl/cpu/dblfetch.v&quot;&gt;this prefetch&lt;/a&gt;,
I realized two things.  First, I was using more logic than I needed to, and
second I could adjust the algorithm so that the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt;
could run concurrently with this second fetch.  In this manner, the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/dblfetch.v&quot;&gt;prefetch&lt;/a&gt;
can run continuously.  As a result, the (new/modified) performance of this
algorithm is now shown below.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 10. Two-Instruction Prefetch&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/pfpipe-new-dblfetch.svg&quot; alt=&quot;&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;At (roughly) 8 clocks per instruction (between
&lt;a href=&quot;https://en.wikipedia.org/wiki/Branch_(computer_science)&quot;&gt;branches&lt;/a&gt;),
this new version should run at roughly
10 MIPS—a big improvement over the 2MIPS we started with.  When you
factor in the compressed instruction set, this yields an even better
12.8 MIPS when running from &lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt;
and an 82MHz clock.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 11. Two instructions sharing the same instruction word&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/pfpipe-cis.svg&quot; alt=&quot;&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Consider the difference this makes when trying to process an 8k audio stream.
Instead of struggling along at 200 &lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt;
instructions per audio sample, I now have closer to 1,600
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt; instructions per audio sample
(neglecting
&lt;a href=&quot;https://en.wikipedia.org/wiki/Branch_(computer_science)&quot;&gt;branches&lt;/a&gt;).
For just a little adjustment in logic, then, the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt; now runs &lt;em&gt;MUCH&lt;/em&gt; faster.&lt;/p&gt;

&lt;p&gt;Before leaving this topic, I would be remiss if I didn’t point out that the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; &lt;em&gt;can&lt;/em&gt; run a lot faster–it just
takes more logic to implement
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/pfcache.v&quot;&gt;the cache&lt;/a&gt;
necessary to do so.  Indeed, we may even be able to come back and discuss how
the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/pfcache.v&quot;&gt;prefetch plus instruction
cache&lt;/a&gt;
approach is put together in a later article–although we’ll have to see
if the &lt;a href=&quot;https://www.blueletterbible.org/kjv/jas/4/15&quot;&gt;Lord is willing&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;how-dblfetch-works&quot;&gt;How dblfetch Works&lt;/h2&gt;

&lt;p&gt;While I could spend some time discussing how to strip the performance of a QSPI
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt;
controller to its
&lt;a href=&quot;https://github.com/ZipCPU/s6soc/blob/master/rtl/qflashxpress.v&quot;&gt;bare minimums&lt;/a&gt;,
today’s topic is going to be how to keep an instruction fetch operation going
so as to achieve the performance shown in Fig 11 above.&lt;/p&gt;

&lt;table style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 12: The two interfaces to a prefetch&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/prefetch-interface.svg&quot; alt=&quot;A prefetch must support both an interface to a CPU and an interface to memory&quot; width=&quot;380&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;As you may recall from our earlier discussion of the
&lt;a href=&quot;/zipcpu/2017/11/18/wb-prefetch.html&quot;&gt;simpler prefetch&lt;/a&gt;,
the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; prefetch interacts with the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt;
using only a small handful of signals:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;The clock, &lt;code class=&quot;highlighter-rouge&quot;&gt;i_clk&lt;/code&gt;, and reset, &lt;code class=&quot;highlighter-rouge&quot;&gt;i_reset&lt;/code&gt;, wires should need no more
description.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;On any
&lt;a href=&quot;https://en.wikipedia.org/wiki/Branch_(computer_science)&quot;&gt;branch&lt;/a&gt;,
whether early (unconditional), or late (conditional or indirect), the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt; will raise an
&lt;code class=&quot;highlighter-rouge&quot;&gt;i_new_pc&lt;/code&gt; flag and set the new
&lt;a href=&quot;https://en.wikipedia.org/wiki/Program_counter&quot;&gt;program counter&lt;/a&gt; in &lt;code class=&quot;highlighter-rouge&quot;&gt;i_pc&lt;/code&gt;.
From then until the next
&lt;a href=&quot;https://en.wikipedia.org/wiki/Branch_(computer_science)&quot;&gt;branch&lt;/a&gt;, the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Program_counter&quot;&gt;program counter&lt;/a&gt;
will increment from one instruction to the next.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;There’s also an &lt;code class=&quot;highlighter-rouge&quot;&gt;i_clear_cache&lt;/code&gt; line, which is used to force the
prefetch
to mark any cached information as invalid.  This allows the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt;
to load instructions into a memory area, and then make sure the instructions
freshly loaded into memory are the ones the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt;
executes later.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;These are just the signaling wires coming from the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt;.  Most of the work within the
&lt;a href=&quot;/zipcpu/2017/11/18/wb-prefetch.html&quot;&gt;prefetch&lt;/a&gt;,
h, however, is done with the &lt;code class=&quot;highlighter-rouge&quot;&gt;o_valid&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;o_insn&lt;/code&gt; wires returned to the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt;.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;o_valid&lt;/code&gt; indicates that the instruction presented to the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
is a valid instruction, and by implication that the instruction fetch
has completed.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;o_insn&lt;/code&gt; is the instruction being presented to the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;.
It has meaning only if &lt;code class=&quot;highlighter-rouge&quot;&gt;o_valid&lt;/code&gt; is also true.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Basically, any time &lt;code class=&quot;highlighter-rouge&quot;&gt;o_valid&lt;/code&gt; is true, &lt;code class=&quot;highlighter-rouge&quot;&gt;o_insn&lt;/code&gt; must contain a valid
instruction.  Once set, these values must hold until the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
accepts them by raising the &lt;code class=&quot;highlighter-rouge&quot;&gt;i_stall_n&lt;/code&gt; line.  (Why this is a negative logic
signal, vs just a &lt;code class=&quot;highlighter-rouge&quot;&gt;*_ready&lt;/code&gt; line is a long story …)&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;i_stall_n&lt;/code&gt; is an active low line indicating that the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
is stalled when active (low).  For those familiar with the AXI ready
signals, this signal is basically a ready signal from the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;.
When this line is high, and &lt;code class=&quot;highlighter-rouge&quot;&gt;o_valid&lt;/code&gt; is high on the same clock, then the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
has just accepted an instruction from the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/dblfetch.v&quot;&gt;prefetch&lt;/a&gt;.
and it is time to move on to the next instruction.&lt;/p&gt;

    &lt;p&gt;This detail is key, so remember this: when &lt;code class=&quot;highlighter-rouge&quot;&gt;(o_valid)&amp;amp;&amp;amp;(i_stall_n)&lt;/code&gt;, the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
has just accepted an instruction and we can move forward.&lt;/p&gt;

    &lt;p&gt;Hence, any time &lt;code class=&quot;highlighter-rouge&quot;&gt;(o_valid)&amp;amp;&amp;amp;(!i_stall_n)&lt;/code&gt;, we’ll need to hold the
instruction valid and wait for the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
to read it.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;If this signaling system is new or confusing to you, then I’m going to
recommend that you go back and review the &lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;formal properties of the
wishbone bus&lt;/a&gt;,
and likewise the &lt;a href=&quot;/zipcpu/2017/11/18/wb-prefetch.html&quot;&gt;formal properties and initial
discussion&lt;/a&gt;
from when we examined the &lt;a href=&quot;/zipcpu/2017/11/18/wb-prefetch.html&quot;&gt;single instruction
prefetch&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;In this case, we’ll be building essentially the same &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/prefetch.v&quot;&gt;basic
prefetch&lt;/a&gt;
as &lt;a href=&quot;/zipcpu/2017/11/18/wb-prefetch.html&quot;&gt;before&lt;/a&gt;
save for a small number of changes.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;The first change is that we’ll allow up to two requests to be in flight
at a time.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The second change is that we’ll need to keep track of both responses, and
feed them to the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
one at a time.&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;The first response from the
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;
will go into the &lt;code class=&quot;highlighter-rouge&quot;&gt;o_insn&lt;/code&gt; register, and will set &lt;code class=&quot;highlighter-rouge&quot;&gt;o_valid&lt;/code&gt;.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;Subsequent responses will also go into the &lt;code class=&quot;highlighter-rouge&quot;&gt;o_insn&lt;/code&gt; register, if ever
&lt;code class=&quot;highlighter-rouge&quot;&gt;o_valid&lt;/code&gt; is false&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;If &lt;code class=&quot;highlighter-rouge&quot;&gt;o_valid&lt;/code&gt; is true, but &lt;code class=&quot;highlighter-rouge&quot;&gt;i_stall_n&lt;/code&gt; is low, indicating that the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
is stalled, we won’t be able to place the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_(computing)&quot;&gt;bus&lt;/a&gt;
return into the &lt;code class=&quot;highlighter-rouge&quot;&gt;o_insn&lt;/code&gt; wires to the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;.
Instead, we’ll create a one-instruction cache to place it into.&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;table align=&quot;center&quot; style=&quot;float: left&quot;&gt;&lt;caption&gt;Fig 13. Two bus requests issued&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/pfpipe-request.svg&quot; alt=&quot;The prefetch issues two requests to the bus&quot; width=&quot;400&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Let’s see if we can draw this out.  The process starts with a state machine
that will issue two requests.  Further requests will be issued if any
requests are outstanding when the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
accepts an instruction from the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/dblfetch.v&quot;&gt;prefetch&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The rule here, though, is that no request may be made of the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_(computing)&quot;&gt;bus&lt;/a&gt;
unless there’s a place to put the result.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 14. Responses go into an Instruction Queue&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/pfpipe-response.svg&quot; alt=&quot;The responses from these requests go into a two-instruction queue&quot; width=&quot;400&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;On the return end from the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_(computing)&quot;&gt;bus&lt;/a&gt;,
responses will go either into our &lt;code class=&quot;highlighter-rouge&quot;&gt;o_insn&lt;/code&gt;
register to be sent immediately to the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
or into the &lt;code class=&quot;highlighter-rouge&quot;&gt;cache_word&lt;/code&gt; if &lt;code class=&quot;highlighter-rouge&quot;&gt;o_insn&lt;/code&gt; already has a valid value within it.
Which location the return goes into
will be governed both by the &lt;code class=&quot;highlighter-rouge&quot;&gt;o_valid&lt;/code&gt; flag, indicating that &lt;code class=&quot;highlighter-rouge&quot;&gt;o_insn&lt;/code&gt;
has a valid instruction within it, by &lt;code class=&quot;highlighter-rouge&quot;&gt;cache_valid&lt;/code&gt;, indicating that
the &lt;code class=&quot;highlighter-rouge&quot;&gt;cache_word&lt;/code&gt; has a valid instruction within it, and &lt;code class=&quot;highlighter-rouge&quot;&gt;i_stall_n&lt;/code&gt;
indicating that everything is moving forward.&lt;/p&gt;

&lt;h2 id=&quot;the-cpus-contract-with-the-prefetch&quot;&gt;The CPU’s Contract with the Prefetch&lt;/h2&gt;

&lt;p&gt;Since I &lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;started working with formal
methods&lt;/a&gt;, I’ve
started thinking of modules
within a design as having a &lt;em&gt;contract&lt;/em&gt; with the rest of the design.  For
example, a memory module has a &lt;em&gt;contract&lt;/em&gt; to return the values found within
the memory at the requested address, and to allow you to change those
values and retrieve the changed values later.  In the case of a
&lt;a href=&quot;/zipcpu/2017/11/18/wb-prefetch.html&quot;&gt;prefetch&lt;/a&gt;,
the contract is fairly simple: the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/dblfetch.v&quot;&gt;prefetch
module&lt;/a&gt;
needs to return to the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
the memory it read from the address the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
requested.  It’s that simple.&lt;/p&gt;

&lt;p&gt;To make matters even easier,
&lt;a href=&quot;http://www.clifford.at/yosys&quot;&gt;yosys&lt;/a&gt;
offers two expressions that can help:
&lt;code class=&quot;highlighter-rouge&quot;&gt;$anyseq&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;$anyconst&lt;/code&gt;.  These describe “free variables.”  They are so
valuable, that I’d like to take a moment longer to discuss these terms.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;$anyseq&lt;/code&gt; defines an arbitrary value that can change on every clock cycle.
You might find it within a section of Verilog code that looks something like:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;wire	[N-1:0]	some_value;
assign	some_value = $anyseq;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;It’s equivalent to having an unconstrained input (i.e. a “free variable”) to
your module, but doesn’t require you to actually create such an input.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;$anyconst&lt;/code&gt; is similar, only the value of &lt;code class=&quot;highlighter-rouge&quot;&gt;$anyconst&lt;/code&gt; will never change within
a run.  Indeed, not only is it similar, but you’d write it out in the exact
same way.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;wire	[N-1:0]	some_constant;
assign	some_constant = $anyconst;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;With a just one simple assumption, &lt;code class=&quot;highlighter-rouge&quot;&gt;$anyseq&lt;/code&gt; can be turned into an &lt;code class=&quot;highlighter-rouge&quot;&gt;$anyconst&lt;/code&gt;,
as in:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;wire	[N-1:0]	some_constant;
assign	some_constant = $anyseq;
always @($global_clock)
	assume(some_valid == $past(some_value));&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;However, this is only for illustration purposes.  &lt;code class=&quot;highlighter-rouge&quot;&gt;$anyconst&lt;/code&gt; will work
for us today rather than &lt;code class=&quot;highlighter-rouge&quot;&gt;$anyseq&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Specifically, we can use &lt;code class=&quot;highlighter-rouge&quot;&gt;$anyconst&lt;/code&gt; to describe the formal contract between the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt; and
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/dblfetch.v&quot;&gt;this prefetch&lt;/a&gt;
module.  Using &lt;code class=&quot;highlighter-rouge&quot;&gt;$anyconst&lt;/code&gt;, we can describe both an arbitrary address in memory,
as well as an arbitrary value (the instruction) that will be at this address.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;wire	[AW-1:0]	f_const_addr;
wire	[DW-1:0]	f_const_insn;

assign	f_const_addr = $anyconst;
assign	f_const_insn = $anyconst;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Then the basic contract is that any time the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/dblfetch.v&quot;&gt;prefetch&lt;/a&gt;
tells the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
that it has a valid instruction, i.e. &lt;code class=&quot;highlighter-rouge&quot;&gt;o_valid&lt;/code&gt; is true, &lt;em&gt;and&lt;/em&gt; that this
instruction comes from the address listed above, &lt;code class=&quot;highlighter-rouge&quot;&gt;f_const_addr&lt;/code&gt;, &lt;em&gt;then&lt;/em&gt; the
instruction must also match the value listed above as well, &lt;code class=&quot;highlighter-rouge&quot;&gt;f_const_insn&lt;/code&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(*)
if ((o_valid)&amp;amp;&amp;amp;(o_pc == f_const_addr))
	assert(o_insn == f_const_insn);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Well, this is close but it isn’t quite right yet.  This doesn’t handle the
case where an attempt to read from this instruction address results in a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_(computing)&quot;&gt;bus&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_error&quot;&gt;error&lt;/a&gt;.
To handle that case, we’ll need an additional flag to determine
if our arbitrary example address references a legal location on the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_(computing)&quot;&gt;bus&lt;/a&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;wire	f_const_illegal;

assign	f_const_illegal = $anyconst;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Using this new flag, the contract then becomes,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(*)
if ((o_valid)&amp;amp;&amp;amp;(o_pc == f_const_addr))
begin
	assert(o_illegal == f_const_illegal);
	if (!o_illegal)
		assert(o_insn == f_const_insn);
end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Well, even that’s not quite right.  I like using the &lt;code class=&quot;highlighter-rouge&quot;&gt;o_illegal&lt;/code&gt; bit as a
sticky bit.  Once it becomes true, it should stay true until the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt; and
issues an &lt;code class=&quot;highlighter-rouge&quot;&gt;i_new_pc&lt;/code&gt; flag and new &lt;code class=&quot;highlighter-rouge&quot;&gt;i_pc&lt;/code&gt;.  Alternatively, we can clear it on the
rarer &lt;code class=&quot;highlighter-rouge&quot;&gt;i_reset&lt;/code&gt; or &lt;code class=&quot;highlighter-rouge&quot;&gt;i_clear_cache&lt;/code&gt; flags.  This means that our contract is
instead going to be,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(*)
if ((o_valid)&amp;amp;&amp;amp;(o_pc == f_const_addr))
begin
	if (f_const_illegal)
		assert(o_illegal)
	if (!o_illegal)
		assert(o_insn == f_const_insn);
end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;We’ll also have to add some assumptions to our algorithm in order to meet
this contract.  Specifically, we’ll need to assume that any time we read
from the &lt;code class=&quot;highlighter-rouge&quot;&gt;f_const_addr&lt;/code&gt; address
that the result returned will be an acknowledgment (not an error) carrying
&lt;code class=&quot;highlighter-rouge&quot;&gt;f_const_insn&lt;/code&gt; in &lt;code class=&quot;highlighter-rouge&quot;&gt;i_wb_data&lt;/code&gt; if &lt;code class=&quot;highlighter-rouge&quot;&gt;f_const_illegal&lt;/code&gt; is false, or a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_(computing)&quot;&gt;bus&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_error&quot;&gt;error&lt;/a&gt;
if &lt;code class=&quot;highlighter-rouge&quot;&gt;f_const_illegal&lt;/code&gt; is true, but that part will be prefetch specific
so we’ll hold off on that until we get to our actual properties.&lt;/p&gt;

&lt;h2 id=&quot;working-through-the-algorithm&quot;&gt;Working through the Algorithm&lt;/h2&gt;

&lt;p&gt;I normally work through an algorithm via pseudocode before presenting it
here.  Today, we’ll just walk through this by steps–since I’m not sure I
have a simple pseudocode to describe it.&lt;/p&gt;

&lt;p&gt;So, here’s how this algorithm will function:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;On any reset or request to clear the cache, wait for a new PC to be given&lt;/li&gt;
&lt;/ul&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 13. On Reset&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/dblfetch-reset.svg&quot; alt=&quot;&quot; width=&quot;320&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;We’ll assume &lt;code class=&quot;highlighter-rouge&quot;&gt;i_new_pc&lt;/code&gt; takes place on the clock after &lt;code class=&quot;highlighter-rouge&quot;&gt;i_reset&lt;/code&gt;.  That means
that on the clock following &lt;code class=&quot;highlighter-rouge&quot;&gt;i_new_pc&lt;/code&gt;, we want to initiate a bus request
with the address of the program counter just given within &lt;code class=&quot;highlighter-rouge&quot;&gt;i_pc&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;This logic is shown in Fig 13. on the right.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Likewise, on a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_(computing)&quot;&gt;bus&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_error&quot;&gt;error&lt;/a&gt;,
set the error flag and wait for a new
&lt;a href=&quot;https://en.wikipedia.org/wiki/Program_counter&quot;&gt;PC&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;You can see this in Fig 14. on the right.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 14. On a Bus Error&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/dblfetch-buserr.svg&quot; alt=&quot;&quot; width=&quot;280&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;In that figure, you can see that following a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_(computing)&quot;&gt;bus&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_error&quot;&gt;error&lt;/a&gt;:
the bus cycle ends and so &lt;code class=&quot;highlighter-rouge&quot;&gt;o_wb_cyc&lt;/code&gt; drops.  &lt;code class=&quot;highlighter-rouge&quot;&gt;o_valid&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;o_illegal&lt;/code&gt; are
then both set together.  &lt;code class=&quot;highlighter-rouge&quot;&gt;o_valid&lt;/code&gt; indicates that the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_(computing)&quot;&gt;bus&lt;/a&gt;
transaction is complete, &lt;code class=&quot;highlighter-rouge&quot;&gt;o_illegal&lt;/code&gt; that it ended with an invalid instruction.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;On any &lt;code class=&quot;highlighter-rouge&quot;&gt;i_new_pc&lt;/code&gt; request, start a new
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_(computing)&quot;&gt;bus&lt;/a&gt;
transaction.&lt;/li&gt;
&lt;/ul&gt;

&lt;table align=&quot;right&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 15. On a New PC mid-cycle&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/dblfetch-midcycle.svg&quot; alt=&quot;&quot; width=&quot;400&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;As shown in Fig 15 above, if a
  &lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_(computing)&quot;&gt;bus&lt;/a&gt;
  transaction is currently underway when the
  &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
  signals an &lt;code class=&quot;highlighter-rouge&quot;&gt;i_new_pc&lt;/code&gt;, then the
  &lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_(computing)&quot;&gt;bus&lt;/a&gt;
  request is aborted (&lt;code class=&quot;highlighter-rouge&quot;&gt;o_wb_cyc&lt;/code&gt; is dropped) and a new one is started on the
  clock following.  We’ll use the internal register
  &lt;code class=&quot;highlighter-rouge&quot;&gt;invalid_bus_cycle&lt;/code&gt;, as shown in Fig 15, to mark that a 
  &lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_(computing)&quot;&gt;bus&lt;/a&gt; transaction was aborted,
  and that a new
  &lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_(computing)&quot;&gt;bus&lt;/a&gt; transaction
  needs to be initiated on the next clock.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;When any
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_(computing)&quot;&gt;bus&lt;/a&gt;
transaction begins, immediately issue two requests.&lt;/p&gt;

    &lt;p&gt;This was what we showed above in Fig 3 when we started.  Everything starts
with two requests.  Then, if a response comes back before the second request
is issued an additional value will be requested from the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_(computing)&quot;&gt;bus&lt;/a&gt;.&lt;/p&gt;

    &lt;p&gt;Remember the rule: no request may be issued unless there is a place to put
the result–lest the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_(computing)&quot;&gt;bus&lt;/a&gt;
respond faster then we are expecting.  Hence, the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_(computing)&quot;&gt;bus&lt;/a&gt;
transaction starts out with our two instruction “cache” entries empty so we
can issue two requests.  If one value comes back and leaves our “cache” for
the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;,
then we can immediately issue a third request.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The initial address requested will be given by the value in &lt;code class=&quot;highlighter-rouge&quot;&gt;i_pc&lt;/code&gt;
whenever &lt;code class=&quot;highlighter-rouge&quot;&gt;i_new_pc&lt;/code&gt; is true.
Ever after, the request address should increment by one on each clock.&lt;/p&gt;

    &lt;p&gt;This goes for the output
&lt;a href=&quot;https://en.wikipedia.org/wiki/Program_counter&quot;&gt;PC&lt;/a&gt;
value, &lt;code class=&quot;highlighter-rouge&quot;&gt;o_pc&lt;/code&gt; as well.  It will also be set to &lt;code class=&quot;highlighter-rouge&quot;&gt;i_pc&lt;/code&gt;
any time &lt;code class=&quot;highlighter-rouge&quot;&gt;i_new_pc&lt;/code&gt; is true.  However, unlike the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_(computing)&quot;&gt;bus&lt;/a&gt;
addresses which increments on every new
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_(computing)&quot;&gt;bus&lt;/a&gt;
request that is made, this value will instead increment any time the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
accepts an instruction.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Responses to the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_(computing)&quot;&gt;bus&lt;/a&gt;
will be placed into the &lt;code class=&quot;highlighter-rouge&quot;&gt;o_insn&lt;/code&gt; register any time &lt;code class=&quot;highlighter-rouge&quot;&gt;o_valid&lt;/code&gt; is
false, or any time there’s nothing in the cache and &lt;code class=&quot;highlighter-rouge&quot;&gt;i_stall_n&lt;/code&gt; is true.&lt;/p&gt;

    &lt;p&gt;We’ll get deeper into these details in the next section.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;If an instruction is being held in &lt;code class=&quot;highlighter-rouge&quot;&gt;o_valid&lt;/code&gt;, the second return will be
placed into a &lt;code class=&quot;highlighter-rouge&quot;&gt;cache_word&lt;/code&gt;, and then
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_(computing)&quot;&gt;bus&lt;/a&gt;
transaction will stop and the
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;wishbone&lt;/a&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;CYC&lt;/code&gt; line will be lowered.&lt;/p&gt;

    &lt;p&gt;We’ve gone for too long without an image.  Here’s what I’m talking about
in Fig 16.&lt;/p&gt;

    &lt;p&gt;It is important that the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_(computing)&quot;&gt;bus&lt;/a&gt;
request end if the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
is stalled for too long (&lt;code class=&quot;highlighter-rouge&quot;&gt;i_stall_n&lt;/code&gt; is low), as the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
might be stalled at the internal &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/ex/wbdblpriarb.v&quot;&gt;memory vs prefetch
arbiter&lt;/a&gt;
while trying to access the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_(computing)&quot;&gt;bus&lt;/a&gt;.
By making sure that we never receive more than two instructions, and then
let the &lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_(computing)&quot;&gt;bus&lt;/a&gt;
return to idle, we keep the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
from entering into a deadlock state.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;All of this needs to be subject to the rule that the two element return
&lt;a href=&quot;https://en.wikipedia.org/wiki/FIFO_(computing_and_electronics)&quot;&gt;FIFO&lt;/a&gt;
cannot be allowed to ever overflow it’s two instruction depth.  We’ll use
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal properties&lt;/a&gt;
below to convince ourselves that such will never happen.&lt;/p&gt;

&lt;h2 id=&quot;the-code&quot;&gt;The Code&lt;/h2&gt;

&lt;p&gt;Now that you know the basic idea behind
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/dblfetch.v&quot;&gt;the code&lt;/a&gt;,
it’s time to examine it in detail.  Once we finish, we’ll get into the
formal properties necessary to verify that this works in the next section.&lt;/p&gt;

&lt;p&gt;We’ll start from the beginning: when shall a bus transaction begin and
end?  As you may recall from the &lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal
properties&lt;/a&gt; of the
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;wishbone bus&lt;/a&gt;,
&lt;code class=&quot;highlighter-rouge&quot;&gt;o_wb_cyc&lt;/code&gt; will capture anytime we in the middle of one (or more) transactions,
and &lt;code class=&quot;highlighter-rouge&quot;&gt;o_wb_stb&lt;/code&gt; will be true anytime we are making a request of the
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;.
You may also remember that &lt;code class=&quot;highlighter-rouge&quot;&gt;o_wb_stb&lt;/code&gt; can only ever be true during a
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;
cycle.  Hence, &lt;code class=&quot;highlighter-rouge&quot;&gt;o_wb_stb&lt;/code&gt; must imply that &lt;code class=&quot;highlighter-rouge&quot;&gt;o_wb_cyc&lt;/code&gt; is also true.&lt;/p&gt;

&lt;p&gt;The &lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;
initially starts out idle.  We’ll also return to an idle on any reset
or &lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_(computing)&quot;&gt;bus&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_error&quot;&gt;error&lt;/a&gt;.
This logic is similar to any &lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;Wishbone
bus&lt;/a&gt;
master.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	initial	o_wb_cyc = 1&#39;b0;
	initial	o_wb_stb = 1&#39;b0;
	always @(posedge i_clk)
		if ((i_reset)||((o_wb_cyc)&amp;amp;&amp;amp;(i_wb_err)))
		begin
			o_wb_cyc &amp;lt;= 1&#39;b0;
			o_wb_stb &amp;lt;= 1&#39;b0;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Next, during any
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;
transaction, we’ll keep issuing transactions
until a &lt;code class=&quot;highlighter-rouge&quot;&gt;last_stb&lt;/code&gt; flag becomes true.  We’re going to use this &lt;code class=&quot;highlighter-rouge&quot;&gt;last_stb&lt;/code&gt;
idea to keep this set of
&lt;a href=&quot;/blog/2017/06/12/minimizing-luts.html&quot;&gt;logic simpler&lt;/a&gt;,
since &lt;code class=&quot;highlighter-rouge&quot;&gt;last_stb&lt;/code&gt; can be calculated on the prior clock.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;		end else if (o_wb_cyc)
		begin
			if ((!o_wb_stb)||(!i_wb_stall))
				o_wb_stb &amp;lt;= (!last_stb);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Releasing the
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;
is a little more complicated.&lt;/p&gt;

&lt;p&gt;The first step is to count the number of items in flight at any given time.
We’ll place this count into &lt;code class=&quot;highlighter-rouge&quot;&gt;inflight&lt;/code&gt; and come back to the logic to do
this later.&lt;/p&gt;

&lt;p&gt;We’ll end the transaction on any last acknowledgment.
We’re also going to release the
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;
anytime we’ve made our last request,
and nothing is in flight.  Finally, anytime a new
&lt;a href=&quot;https://en.wikipedia.org/wiki/Program_counter&quot;&gt;program counter&lt;/a&gt;
is given to us, or any time we are asked to clear our cache, we’ll
also end this
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;
transaction.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;			if (((i_wb_ack)&amp;amp;&amp;amp;(!o_wb_stb)&amp;amp;&amp;amp;(inflight&amp;lt;=1))
				||((!o_wb_stb)&amp;amp;&amp;amp;(inflight == 0))
				// Or any new transaction request
				||((i_new_pc)||(i_clear_cache)))
			begin
				o_wb_cyc &amp;lt;= 1&#39;b0;
				o_wb_stb &amp;lt;= 1&#39;b0;
			end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;That’s how we’ll end a transaction, but when will one start?&lt;/p&gt;

&lt;p&gt;We’re going to need to start a transaction on a couple conditions.
First, if we are idle and the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
asks for a new
&lt;a href=&quot;https://en.wikipedia.org/wiki/Program_counter&quot;&gt;PC&lt;/a&gt;,
we’ll need to start
a transaction.  Likewise, if the last transaction was aborted because the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
requested a new
&lt;a href=&quot;https://en.wikipedia.org/wiki/Program_counter&quot;&gt;PC&lt;/a&gt;,
then &lt;code class=&quot;highlighter-rouge&quot;&gt;invalid_bus_cycle&lt;/code&gt; will be true and we need to start again.  Finally,
any time we’ve run our two instruction cache/FIFO
dry, then we’ll start a new
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;
cycle as well.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;		end else if ((i_new_pc)||(invalid_bus_cycle)
			||((o_valid)&amp;amp;&amp;amp;(i_stall_n)&amp;amp;&amp;amp;(!o_illegal)))
		begin
			// ...
			o_wb_cyc &amp;lt;= 1&#39;b1;
			o_wb_stb &amp;lt;= 1&#39;b1;
		end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Normally, when I build a multi-transaction
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;
master, I know ahead of time how many transaction requests to issue.  Examples
would be the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/pfcache.v&quot;&gt;prefetch plus
cache&lt;/a&gt;
bus master, which always fetches a complete cache line, and the &lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/rtl/wbuexec.v&quot;&gt;full-featured
debugging bus
master&lt;/a&gt;
I like to use.  In the case of the &lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/rtl/wbuexec.v&quot;&gt;debugging
bus&lt;/a&gt;,
the read
&lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/rtl/wbuexec.v&quot;&gt;bus&lt;/a&gt;,
request tells it how many transactions to request, although the write
&lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/rtl/wbuexec.v&quot;&gt;bus&lt;/a&gt;,
request just requests an additional transaction.&lt;/p&gt;

&lt;p&gt;This &lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;
master is different.&lt;/p&gt;

&lt;p&gt;In this case, we want to issue two requests, and then possibly more depending
on whether or not we have enough available spaces.  Doing this requires
counting the number of transactions in flight.  We’ll do this with the
register, &lt;code class=&quot;highlighter-rouge&quot;&gt;inflight&lt;/code&gt;.  Upon any successful
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;
request, we’ll increment this value and on
any acknowledgment we’ll decrement it to keep a count of what’s
in flight.  (We don’t need to adjust our count on
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_error&quot;&gt;error&lt;/a&gt;,
since the
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;
transaction will always be aborted on any
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_error&quot;&gt;error&lt;/a&gt;
anyway.)&lt;/p&gt;

&lt;p&gt;There are some key features of this logic.  Because an acknowledgment can come
back when the &lt;code class=&quot;highlighter-rouge&quot;&gt;o_wb_cyc&lt;/code&gt; line is low, such as immediately following an
aborted transaction, we’ll just set everything to zero if &lt;code class=&quot;highlighter-rouge&quot;&gt;o_wb_cyc&lt;/code&gt; is low.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	initial	inflight = 2&#39;b00;
	always @(posedge i_clk)
	if (!o_wb_cyc)
		inflight &amp;lt;= 2&#39;b00;
	else begin&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;After that, we increase the number of items in flight on any accepted
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;
request, and decrease the number on any acknowledgment.  If neither are true,
or if both are true, the count won’t change.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;		case({ ((o_wb_stb)&amp;amp;&amp;amp;(!i_wb_stall)), i_wb_ack })
		2&#39;b01:	inflight &amp;lt;= inflight - 1&#39;b1;
		2&#39;b10:	inflight &amp;lt;= inflight + 1&#39;b1;
		// If neither ack nor request, then no change.  Likewise
		// if we have both an ack and a request, there&#39;s no change
		// in the number of requests in flight.
		default: begin end
		endcase
	end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Just as an example of how
&lt;a href=&quot;/blog/2018/03/14/is-formal-hard.html&quot;&gt;easy formal can be&lt;/a&gt;,
I knew when I wrote these lines that &lt;code class=&quot;highlighter-rouge&quot;&gt;inflight&lt;/code&gt; could never be greater than
two.  Hence, I originally placed an assert statement here to that effect.
It has since been moved to our formal section and so we’ll discuss it
below when we get to it.  I only bring it up here to discuss an example
situation where it is useful to immediately write a formal property.&lt;/p&gt;

&lt;p&gt;Let’s move on to the &lt;code class=&quot;highlighter-rouge&quot;&gt;last_stb&lt;/code&gt; piece of logic.  You may recall from above
that we used a piece of logic to determine when the current request was the last
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;
request that needed to be issued.  Normally when I build a
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;
master, this is a registered value–set on the clock before the last strobe.
A good example of this would be the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/wbdmac.v&quot;&gt;DMA controller&lt;/a&gt; for the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;,
which separates the difficult logic of when to end a
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;
cycle from the already
&lt;a href=&quot;/blog/2017/06/12/minimizing-luts.html&quot;&gt;difficult logic&lt;/a&gt;,
describing the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/wbdmac.v&quot;&gt;DMA&lt;/a&gt;
state machine.&lt;/p&gt;

&lt;p&gt;This isn’t that either.&lt;/p&gt;

&lt;p&gt;This &lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;
master is different because I want to keep issuing requests anytime the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
accepts an instruction.  In this case, the second strobe will be the
last strobe–i.e. if the number in flight is more than one.  Likewise if
there’s a valid instruction waiting for the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
then this also needs to be the last
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;
request.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(*)
		last_stb = (inflight != 2&#39;b00)||((o_valid)&amp;amp;&amp;amp;(!i_stall_n));&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The next register, &lt;code class=&quot;highlighter-rouge&quot;&gt;invalid_bus_cycle&lt;/code&gt;, is one I’ve tried to get rid of many
times.  In many ways it feels redundant.  Timing, however, requires it.
Specifically, my problem is this: if &lt;code class=&quot;highlighter-rouge&quot;&gt;i_new_pc&lt;/code&gt; comes during the middle of a
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;
cycle, &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/dblfetch.v&quot;&gt;the
prefetch&lt;/a&gt;
immediately aborts that
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;
cycle.  The
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;
cycle needs to then be re-initiated on the next clock cycle, as shown in Fig 15
above.  That’s the purpose of &lt;code class=&quot;highlighter-rouge&quot;&gt;invalid_bus_cycle&lt;/code&gt;: to tell the design to start
up a new
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;
cycle after the last one was artificially ended by an &lt;code class=&quot;highlighter-rouge&quot;&gt;i_new_pc&lt;/code&gt; request.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	initial	invalid_bus_cycle = 1&#39;b0;
	always @(posedge i_clk)
		if (i_reset)
			invalid_bus_cycle &amp;lt;= 1&#39;b0;
		else if ((o_wb_cyc)&amp;amp;&amp;amp;(i_new_pc))
			invalid_bus_cycle &amp;lt;= 1&#39;b1;
		else if (!o_wb_cyc)
			invalid_bus_cycle &amp;lt;= 1&#39;b0;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;We discussed above how the
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;
request address, &lt;code class=&quot;highlighter-rouge&quot;&gt;o_wb_addr&lt;/code&gt;, will be set by
the address given on any &lt;code class=&quot;highlighter-rouge&quot;&gt;i_new_pc&lt;/code&gt; request.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	initial	o_wb_addr = {(AW){1&#39;b1}};
	always @(posedge i_clk)
		if (i_new_pc)
			o_wb_addr &amp;lt;= i_pc[AW+1:2];&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Other than on any &lt;code class=&quot;highlighter-rouge&quot;&gt;i_new_pc&lt;/code&gt; request, we’ll increment the
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;
address on every successful transaction request but leave it alone otherwise.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;		else if ((o_wb_stb)&amp;amp;&amp;amp;(!i_wb_stall))
			o_wb_addr &amp;lt;= o_wb_addr + 1&#39;b1;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;We can now look at the &lt;code class=&quot;highlighter-rouge&quot;&gt;o_valid&lt;/code&gt; signal.  As you may recall, this signal
needs to be true any time a valid instruction is being presented to the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;We’ll start on reset.  On any reset, any &lt;code class=&quot;highlighter-rouge&quot;&gt;i_new_pc&lt;/code&gt; request, or any request
to &lt;code class=&quot;highlighter-rouge&quot;&gt;i_clear_cache&lt;/code&gt;, we’ll clear this valid signal.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	initial	o_valid = 1&#39;b0;
	always @(posedge i_clk)
		if ((i_reset)||(i_new_pc)||(i_clear_cache))
			o_valid &amp;lt;= 1&#39;b0;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Further, on any valid return from the
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;,
whether an acknowledgment or an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_error&quot;&gt;error&lt;/a&gt;,
we’ll set the valid signal to true.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;		else if ((o_wb_cyc)&amp;amp;&amp;amp;((i_wb_ack)||(i_wb_err)))
			o_valid &amp;lt;= 1&#39;b1;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The final piece of logic references what to do if the
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;
isn’t providing an instruction, but the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
has just accepted the one we’ve presented to it within &lt;code class=&quot;highlighter-rouge&quot;&gt;o_insn&lt;/code&gt;.  In this case,
whether or not we are valid will be determined by whether or not the
second word in our FIFO or cache, &lt;code class=&quot;highlighter-rouge&quot;&gt;cache_word&lt;/code&gt;, has a valid value within it.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;		else if (i_stall_n)
			o_valid &amp;lt;= cache_valid;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;o_valid&lt;/code&gt; tells the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
when the instruction from the
&lt;a href=&quot;/zipcpu/2017/11/18/wb-prefetch.html&quot;&gt;prefetch&lt;/a&gt;
is a valid instruction.  The instruction itself is kept in the &lt;code class=&quot;highlighter-rouge&quot;&gt;o_insn&lt;/code&gt;
register, our next item to discuss.&lt;/p&gt;

&lt;p&gt;As you’ll recall from above, there are a couple cases to consider with &lt;code class=&quot;highlighter-rouge&quot;&gt;o_insn&lt;/code&gt;.
If &lt;code class=&quot;highlighter-rouge&quot;&gt;o_valid&lt;/code&gt; isn’t true, then &lt;code class=&quot;highlighter-rouge&quot;&gt;o_insn&lt;/code&gt; is a don’t care.  If &lt;code class=&quot;highlighter-rouge&quot;&gt;o_valid&lt;/code&gt;
is true, but &lt;code class=&quot;highlighter-rouge&quot;&gt;i_stall_n&lt;/code&gt; is false, then the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
is busy (stalled), and the
instruction must stay ready and unchanged until the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
is ready to accept it.&lt;/p&gt;

&lt;p&gt;Hence, any time &lt;code class=&quot;highlighter-rouge&quot;&gt;o_valid&lt;/code&gt; is false, or any time the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
is ready to accept an instruction, then we can update the instruction.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	initial	o_insn = {(32){1&#39;b1}};
	always @(posedge i_clk)
	if ((!o_valid)||(i_stall_n))
	begin&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;If the cache word is valid, then we want to present the cache word as the
next instruction word.  Otherwise, the next instruction word can only come from
the &lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;.
While it may not be on the
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;
on this cycle, it will eventually be on the
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;,
i.e. in &lt;code class=&quot;highlighter-rouge&quot;&gt;i_wb_data&lt;/code&gt;, and then &lt;code class=&quot;highlighter-rouge&quot;&gt;o_valid&lt;/code&gt; will be set on the
next clock–keeping us from changing again until the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
accepts the instruction.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;		if (cache_valid)
			o_insn &amp;lt;= cache_word;
		else
			o_insn &amp;lt;= i_wb_data;
	end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;As a side note, you may notice that the logic for this 32-bit word has
been kept very simple.  &lt;a href=&quot;/blog/2017/06/12/minimizing-luts.html&quot;&gt;This is
important&lt;/a&gt;.
Complex logic on a wide bus can suddenly and greatly &lt;a href=&quot;/blog/2017/06/12/minimizing-luts.html&quot;&gt;increase your logic
usage&lt;/a&gt;.
Instead, we are reserving the complex logic for the one or two wire
registers, such as &lt;code class=&quot;highlighter-rouge&quot;&gt;o_wb_cyc&lt;/code&gt; or &lt;code class=&quot;highlighter-rouge&quot;&gt;o_wb_stb&lt;/code&gt; above, while keeping the logic
for the larger registers, like &lt;code class=&quot;highlighter-rouge&quot;&gt;o_insn&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;o_wb_addr&lt;/code&gt;, or even &lt;code class=&quot;highlighter-rouge&quot;&gt;o_pc&lt;/code&gt; simple.&lt;/p&gt;

&lt;p&gt;Speaking of &lt;code class=&quot;highlighter-rouge&quot;&gt;o_pc&lt;/code&gt;, that’s our next register to examine.  The
&lt;code class=&quot;highlighter-rouge&quot;&gt;o_pc&lt;/code&gt; register is very similar to the &lt;code class=&quot;highlighter-rouge&quot;&gt;o_wb_addr&lt;/code&gt; register that we dealt with
above.  It needs to be set on any &lt;code class=&quot;highlighter-rouge&quot;&gt;i_new_pc&lt;/code&gt; event, and otherwise incremented
any time the output instruction is valid, &lt;code class=&quot;highlighter-rouge&quot;&gt;o_valid&lt;/code&gt;, and the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
accepts that instruction, &lt;code class=&quot;highlighter-rouge&quot;&gt;i_stall_n&lt;/code&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	initial	o_pc = 0;
	always @(posedge i_clk)
		if (i_new_pc)
			o_pc &amp;lt;= i_pc;
		else if ((o_valid)&amp;amp;&amp;amp;(i_stall_n))
			o_pc[AW+1:2] &amp;lt;= o_pc[AW+1:2] + 1&#39;b1;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;You’ll notice that we kept this logic
&lt;a href=&quot;/blog/2017/06/12/minimizing-luts.html&quot;&gt;simple&lt;/a&gt; as well,
since the number of LUTs required by
this logic will be required &lt;em&gt;for every bit&lt;/em&gt; of &lt;code class=&quot;highlighter-rouge&quot;&gt;o_pc&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Just to illustrate this point, the &lt;code class=&quot;highlighter-rouge&quot;&gt;o_pc&lt;/code&gt; logic alone uses 61 4-LUTs of the
total 246 LUTs used by the design as a whole on an iCE40.  That’s a whole 24%
of the total logic for this design–and it’s a very minimal piece of logic at
that.&lt;/p&gt;

&lt;p&gt;The final word used to interface with the rest of the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
is the &lt;code class=&quot;highlighter-rouge&quot;&gt;o_illegal&lt;/code&gt; register.  This is the flag used to tell the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
that the attempt to read from this address resulted in a
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_error&quot;&gt;error&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;We’ll clear this flag on any reset, or &lt;code class=&quot;highlighter-rouge&quot;&gt;i_new_pc&lt;/code&gt; request.  Likewise, we’ll
clear it on any request to clear the cache, &lt;code class=&quot;highlighter-rouge&quot;&gt;i_clear_cache&lt;/code&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	initial	o_illegal = 1&#39;b0;
	always @(posedge i_clk)
		if ((i_reset)||(i_new_pc)||(i_clear_cache))
			o_illegal &amp;lt;= 1&#39;b0;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;As with &lt;code class=&quot;highlighter-rouge&quot;&gt;o_insn&lt;/code&gt;, nothing is allowed to change if we have a valid
instruction that the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
hasn’t yet accepted the last instruction, or equivalently if
&lt;code class=&quot;highlighter-rouge&quot;&gt;(o_valid)&amp;amp;&amp;amp;(!i_stall_n)&lt;/code&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;		else if ((!o_valid)||(i_stall_n))
		begin&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;That brings us to how &lt;code class=&quot;highlighter-rouge&quot;&gt;o_illegal&lt;/code&gt; needs to be set.  If the &lt;code class=&quot;highlighter-rouge&quot;&gt;cache_word&lt;/code&gt; is
valid, then it moves into the &lt;code class=&quot;highlighter-rouge&quot;&gt;o_insn&lt;/code&gt; position.  At that same time,
if the &lt;code class=&quot;highlighter-rouge&quot;&gt;cache_illegal&lt;/code&gt; flag associated with that &lt;code class=&quot;highlighter-rouge&quot;&gt;cache_word&lt;/code&gt; is true,
that will indicate that a
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_error&quot;&gt;error&lt;/a&gt;
was returned while attempting to request the second word.  This illegal
flag will then also need to move into the &lt;code class=&quot;highlighter-rouge&quot;&gt;o_insn&lt;/code&gt; position and we’ll set
&lt;code class=&quot;highlighter-rouge&quot;&gt;o_illegal&lt;/code&gt; in that case.&lt;/p&gt;

&lt;p&gt;Otherwise, if the cached value isn’t valid, then there’s nothing in our
cache and we’ll need to set the &lt;code class=&quot;highlighter-rouge&quot;&gt;o_illegal&lt;/code&gt; flag immediately on a
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_error&quot;&gt;error&lt;/a&gt;,
since that’s the value directly going into the first output position,
&lt;code class=&quot;highlighter-rouge&quot;&gt;o_insn&lt;/code&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;			if (cache_valid)
				o_illegal &amp;lt;= (o_illegal)||(cache_illegal);
			else if ((o_wb_cyc)&amp;amp;&amp;amp;(i_wb_err))
				o_illegal &amp;lt;= 1&#39;b1;
		end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Ok, so we’ve now dealt with the output values to the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;:
&lt;code class=&quot;highlighter-rouge&quot;&gt;o_valid&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;o_insn&lt;/code&gt;, and &lt;code class=&quot;highlighter-rouge&quot;&gt;o_illegal&lt;/code&gt;.  These are the values associated
with the current item being sent to the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
from our two instruction FIFO.&lt;/p&gt;

&lt;p&gt;Let’s now turn our attention to that second response from the bus, the &lt;em&gt;other&lt;/em&gt;
element in our two instruction FIFO.  We’ll store this value in the word
&lt;code class=&quot;highlighter-rouge&quot;&gt;cache_word&lt;/code&gt;, and mark it as valid using &lt;code class=&quot;highlighter-rouge&quot;&gt;cache_valid&lt;/code&gt;.
Should this word be the result of a
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_error&quot;&gt;error&lt;/a&gt;,
we’ll then set the value &lt;code class=&quot;highlighter-rouge&quot;&gt;cache_illegal&lt;/code&gt; to reflect this.&lt;/p&gt;

&lt;p&gt;We’ll start here, though, with &lt;code class=&quot;highlighter-rouge&quot;&gt;cache_valid&lt;/code&gt;.  On any reset, any new
&lt;a href=&quot;https://en.wikipedia.org/wiki/Program_counter&quot;&gt;PC&lt;/a&gt;,
or any time we clear the cache, &lt;code class=&quot;highlighter-rouge&quot;&gt;cache_valid&lt;/code&gt; needs to be cleared.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	initial	cache_valid = 1&#39;b0;
	always @(posedge i_clk)
		if ((i_reset)||(i_new_pc)||(i_clear_cache))
			cache_valid &amp;lt;= 1&#39;b0;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Otherwise, we need to set it any time &lt;code class=&quot;highlighter-rouge&quot;&gt;o_valid&lt;/code&gt; is true, the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt; is
stalled &lt;code class=&quot;highlighter-rouge&quot;&gt;(!i_stall_n)&lt;/code&gt;, and a return comes in from the
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;.
In a similar fashion, we’ll need to clear this flag anytime the &lt;code class=&quot;highlighter-rouge&quot;&gt;cache_word&lt;/code&gt;
gets moved into the &lt;code class=&quot;highlighter-rouge&quot;&gt;o_insn&lt;/code&gt; position and presented to the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;.
 This will be when &lt;code class=&quot;highlighter-rouge&quot;&gt;i_stall_n&lt;/code&gt; is true, but not response is coming from the
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The only catch is when/if &lt;code class=&quot;highlighter-rouge&quot;&gt;cache_valid&lt;/code&gt; is already true and a new response
comes back from the
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;. (This should never
happen.) In this case, &lt;code class=&quot;highlighter-rouge&quot;&gt;cache_valid&lt;/code&gt; needs to be set as well.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;		else begin
			if ((o_valid)&amp;amp;&amp;amp;(o_wb_cyc)&amp;amp;&amp;amp;((i_wb_ack)||(i_wb_err)))
				cache_valid &amp;lt;= (!i_stall_n)||(cache_valid);
			else if (i_stall_n)
				cache_valid &amp;lt;= 1&#39;b0;
		end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This brings us to the cache word.  As you’ll recall from above, the
&lt;code class=&quot;highlighter-rouge&quot;&gt;cache_word&lt;/code&gt; register is the second word in the output FIFO after &lt;code class=&quot;highlighter-rouge&quot;&gt;o_insn&lt;/code&gt;.
This value is completely irrelevant, though, unless &lt;code class=&quot;highlighter-rouge&quot;&gt;cache_valid&lt;/code&gt; (above)
is also true.  Hence, we can set it to whatever returns from the
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt; in
&lt;code class=&quot;highlighter-rouge&quot;&gt;i_wb_data&lt;/code&gt; whenever it returns.  We’ll use other logic, above in &lt;code class=&quot;highlighter-rouge&quot;&gt;cache_valid&lt;/code&gt;,
to determine whether or not this value is relevant to us.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(posedge i_clk)
		if ((o_wb_cyc)&amp;amp;&amp;amp;(i_wb_ack))
			cache_word &amp;lt;= i_wb_data;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Obviously this will fail if an acknowledgment is returned while &lt;code class=&quot;highlighter-rouge&quot;&gt;cache_valid&lt;/code&gt;
is true.  We’ll need to make certain this never happens, and we’ll use the
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal methods&lt;/a&gt;
below to convince ourselves that this will never happen.&lt;/p&gt;

&lt;p&gt;The last value is the &lt;code class=&quot;highlighter-rouge&quot;&gt;cache_illegal&lt;/code&gt; value.  This flag is used to
indicate that the second response from the
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt; was a
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_error&quot;&gt;error&lt;/a&gt;,
&lt;code class=&quot;highlighter-rouge&quot;&gt;i_wb_err&lt;/code&gt;.  As before, this value is cleared on any &lt;code class=&quot;highlighter-rouge&quot;&gt;i_reset&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;i_new_pc&lt;/code&gt;,
or &lt;code class=&quot;highlighter-rouge&quot;&gt;i_clear_cache&lt;/code&gt;.  After that, it’s set on any &lt;code class=&quot;highlighter-rouge&quot;&gt;i_wb_err&lt;/code&gt; return where
the first
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;
return position in the FIFO is stuck waiting on the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;,
&lt;code class=&quot;highlighter-rouge&quot;&gt;(o_valid)&amp;amp;&amp;amp;(!i_stall_n)&lt;/code&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	initial	cache_illegal = 1&#39;b0;
	always @(posedge i_clk)
	if ((i_reset)||(i_clear_cache)||(i_new_pc))
		cache_illegal &amp;lt;= 1&#39;b0;
	else if ((o_wb_cyc)&amp;amp;&amp;amp;(i_wb_err)&amp;amp;&amp;amp;(o_valid)&amp;amp;&amp;amp;(!i_stall_n))
		cache_illegal &amp;lt;= 1&#39;b1;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Remember that the &lt;code class=&quot;highlighter-rouge&quot;&gt;i_wb_err&lt;/code&gt; flag needs to be cross-checked with the
&lt;code class=&quot;highlighter-rouge&quot;&gt;o_wb_cyc&lt;/code&gt; flag, since suddenly dropping &lt;code class=&quot;highlighter-rouge&quot;&gt;o_wb_cyc&lt;/code&gt; might still allow
&lt;code class=&quot;highlighter-rouge&quot;&gt;i_wb_err&lt;/code&gt; to return on the next cycle when &lt;code class=&quot;highlighter-rouge&quot;&gt;o_wb_cyc&lt;/code&gt; is low.&lt;/p&gt;

&lt;p&gt;That’s it!  At this point, we have a completed
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/dblfetch.v&quot;&gt;prefetch module&lt;/a&gt;
that will continue fetching instructions from memory until it’s two
instruction word FIFO is full and the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
remains stalled.&lt;/p&gt;

&lt;p&gt;But … does it work?  That’s the point of the
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal properties&lt;/a&gt;
presented in the next section.&lt;/p&gt;

&lt;h2 id=&quot;the-formal-properties&quot;&gt;The Formal Properties&lt;/h2&gt;

&lt;p&gt;A &lt;a href=&quot;/zipcpu/2017/11/18/wb-prefetch.html&quot;&gt;prefetch&lt;/a&gt;
has two basic interfaces it needs to maintain, as shown
above in Fig 12.  The first is formally characterized by the set of &lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;wishbone
properties&lt;/a&gt;.
The second interface is to the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;.
Therefore, we’ll spend some time putting together the assumptions and assertions
necessary for interacting with the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;.
Finally, we’ll present the logic necessary to formally verify that &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/dblfetch.v&quot;&gt;this
prefetch&lt;/a&gt;
formally maintains its &lt;em&gt;contract&lt;/em&gt; with the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt; as
we discussed above.&lt;/p&gt;

&lt;p&gt;We’ll start with the
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal properties&lt;/a&gt;
necessary for interacting with the
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;wishbone bus&lt;/a&gt;.
Aside from assuming that &lt;code class=&quot;highlighter-rouge&quot;&gt;i_reset&lt;/code&gt; is true on startup,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	initial	`ASSUME(i_reset);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;most of this is already done for us by the &lt;code class=&quot;highlighter-rouge&quot;&gt;fwb_master&lt;/code&gt; module.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	localparam	F_LGDEPTH=2;
	wire	[(F_LGDEPTH-1):0]	f_nreqs, f_nacks, f_outstanding;

	//
	// Add a bunch of wishbone-based asserts
	fwb_master #(.AW(AW), .DW(DW), .F_LGDEPTH(F_LGDEPTH),
				.F_MAX_STALL(2),
				.F_MAX_REQUESTS(0), .F_OPT_SOURCE(1),
				.F_OPT_CLK2FFLOGIC(F_OPT_CLK2FFLOGIC),
				.F_OPT_RMW_BUS_OPTION(1),
				.F_OPT_DISCONTINUOUS(0))
		f_wbm(i_clk, i_reset,
			o_wb_cyc, o_wb_stb, o_wb_we, o_wb_addr, o_wb_data, 4&#39;h0,
			i_wb_ack, i_wb_stall, i_wb_data, i_wb_err,
			f_nreqs, f_nacks, f_outstanding);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;You may remember how we built that
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;property list together&lt;/a&gt;
earlier, right?&lt;/p&gt;

&lt;p&gt;In this case, the important parts of this are the parameters being used
to set this up.  First, we’re only expecting a two items to ever be in
flight at a time, so we can set &lt;code class=&quot;highlighter-rouge&quot;&gt;F_LGDEPTH&lt;/code&gt; to two.  Second, just to keep
things moving, we’ll assume that the
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;
will never stall more than 2
clocks at a time, &lt;code class=&quot;highlighter-rouge&quot;&gt;F_MAX_STALL(2)&lt;/code&gt;.  We won’t set a maximum number of
requests, since our particular goal is to allow us to continually make
requests until our result buffer is full.  &lt;code class=&quot;highlighter-rouge&quot;&gt;F_OPT_SOURCE&lt;/code&gt; is set to
true, just to check that &lt;code class=&quot;highlighter-rouge&quot;&gt;o_wb_stb&lt;/code&gt; gets set to true any time
&lt;code class=&quot;highlighter-rouge&quot;&gt;o_wb_cyc&lt;/code&gt; rises.&lt;/p&gt;

&lt;p&gt;It’s really just about that simple, but there is one exception: we’ll
&lt;a href=&quot;/blog/2018/03/14/is-formal-hard.html&quot;&gt;need to tie our logic&lt;/a&gt;
to the &lt;code class=&quot;highlighter-rouge&quot;&gt;f_nreqs&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;f_nacks&lt;/code&gt;, and &lt;code class=&quot;highlighter-rouge&quot;&gt;f_outstanding&lt;/code&gt; signals, or we won’t pass the
&lt;a href=&quot;/blog/2018/03/10/induction-exercise.html&quot;&gt;formal induction&lt;/a&gt;
step.&lt;/p&gt;

&lt;p&gt;That logic is coming up in a bit.&lt;/p&gt;

&lt;p&gt;The next section discusses the assumptions associated with interacting with
the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;.
To make sure these statements hold properly, we’ll use a variety
of &lt;code class=&quot;highlighter-rouge&quot;&gt;f_past_*&lt;/code&gt; variables.  We’ll use these in place of the &lt;code class=&quot;highlighter-rouge&quot;&gt;$past()&lt;/code&gt; operator,
since
&lt;a href=&quot;/blog/2017/06/21/looking-at-verilator.html&quot;&gt;Verilator&lt;/a&gt;
doesn’t support it (yet).  This includes &lt;code class=&quot;highlighter-rouge&quot;&gt;f_past_reset&lt;/code&gt;,
&lt;code class=&quot;highlighter-rouge&quot;&gt;f_past_clear_cache&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;f_past_o_valid&lt;/code&gt;, and &lt;code class=&quot;highlighter-rouge&quot;&gt;f_past_stall_n&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The first assumption is that following any reset, the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
will provide a new
&lt;a href=&quot;https://en.wikipedia.org/wiki/Program_counter&quot;&gt;instruction address&lt;/a&gt;
on the next clock cycle.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(posedge i_clk)
		if ((f_past_valid)&amp;amp;&amp;amp;(f_past_reset))
			assume(i_new_pc);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;We’ll assume the same of an &lt;code class=&quot;highlighter-rouge&quot;&gt;i_clear_cache&lt;/code&gt; request, that the next clock
cycle will provide us with an new
&lt;a href=&quot;https://en.wikipedia.org/wiki/Program_counter&quot;&gt;PC&lt;/a&gt;
value.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(posedge i_clk)
		if ((f_past_valid)&amp;amp;&amp;amp;(f_past_clear_cache))
			assume(i_new_pc);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Further, we know from the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;’s code
that the &lt;code class=&quot;highlighter-rouge&quot;&gt;i_clear_cache&lt;/code&gt; request will never be held high for two clocks
in a row.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(posedge i_clk)
	if (f_past_clear_cache)
		assume(!i_clear_cache);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This brings us to a rather unusual assertion.&lt;/p&gt;

&lt;p&gt;Some time ago, I got frustrated trying to translate between word addresses
on the
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;
and the byte addresses the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
uses.  In a fit of frustration, I converted all of the versions of the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Program_counter&quot;&gt;program counter&lt;/a&gt;
maintained within the
design to byte addressing.  That means that the bottom two bits of 
&lt;code class=&quot;highlighter-rouge&quot;&gt;i_pc&lt;/code&gt; need to be zero.  It also means the bottom two bits of &lt;code class=&quot;highlighter-rouge&quot;&gt;o_pc&lt;/code&gt; will
need to be zero, but we’ll get to that one later.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(*)
		assume(i_pc[1:0] == 2&#39;b00);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The result of using byte addressing is that I can now correlate these
&lt;a href=&quot;https://en.wikipedia.org/wiki/Program_counter&quot;&gt;program counter&lt;/a&gt; values
with the byte addresses in a dump of any
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
executable.&lt;/p&gt;

&lt;p&gt;Now let’s talk about the &lt;code class=&quot;highlighter-rouge&quot;&gt;i_stall_n&lt;/code&gt; line.  Following any reset, the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
will be reset and there will be no reason to stall.  Hence, following any
reset &lt;code class=&quot;highlighter-rouge&quot;&gt;i_stall_n&lt;/code&gt; will be true indicating that the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
is &lt;em&gt;ready&lt;/em&gt; to accept an instruction.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	initial	assume(i_stall_n);
	always @(posedge i_clk)
		if ((f_past_valid)&amp;amp;&amp;amp;(f_past_reset))
			assume(i_stall_n);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;In a similar manner, the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
will never become busy and stall unless it has already accepted an instruction.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(posedge i_clk)
		if ((f_past_valid)&amp;amp;&amp;amp;(!f_past_o_valid)&amp;amp;&amp;amp;(f_past_stall_n))
			assume(i_stall_n);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Our last criteria regarding our interaction with the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
is the assumption that the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
will always accept an instruction within four clocks.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	localparam	F_CPU_DELAY = 4;
	reg	[4:0]	f_cpu_delay;

	// Now, let&#39;s look at the delay the CPU takes to accept an instruction.
	always @(posedge i_clk)
		// If no instruction is ready, then keep our counter at zero
		if ((!o_valid)||(i_stall_n))
			f_cpu_delay &amp;lt;= 0;
		else
			// Otherwise, count the clocks the CPU takes to respond
			f_cpu_delay &amp;lt;= f_cpu_delay + 1&#39;b1;

	always @(posedge i_clk)
		assume(f_cpu_delay &amp;lt; F_CPU_DELAY);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This isn’t necessarily true.  A divide instruction might cause the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
to stall for 30+ clocks.  However, it’s good enough to speed our way through
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal verification&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;We can now turn to some assertions about our outputs to the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;.
This isn’t (yet) the contract we discussed above, but we’ll get to that
in the next section.&lt;/p&gt;

&lt;p&gt;We’ll start with the assertion about the output
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;wishbone bus&lt;/a&gt;
address.
Anytime a new request is accepted by the
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;,
the &lt;code class=&quot;highlighter-rouge&quot;&gt;o_wb_pc&lt;/code&gt; should increment.  The only exception is following an
&lt;code class=&quot;highlighter-rouge&quot;&gt;i_new_pc&lt;/code&gt; signal–when it should be set by the new &lt;code class=&quot;highlighter-rouge&quot;&gt;i_pc&lt;/code&gt; value.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(posedge i_clk)
	if ((f_past_valid)&amp;amp;&amp;amp;($past(o_wb_stb))&amp;amp;&amp;amp;(!$past(i_wb_stall))
			&amp;amp;&amp;amp;(!$past(i_new_pc)))
		assert(o_wb_addr &amp;lt;= $past(o_wb_addr)+1&#39;b1);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;When it comes to the output values, the rule is that anytime the output
is valid and the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
is stalled, i.e. any time &lt;code class=&quot;highlighter-rouge&quot;&gt;(o_valid)&amp;amp;&amp;amp;(!i_stall_n)&lt;/code&gt;,
then the output values need to stay constant.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(posedge i_clk)
	if ((f_past_valid)&amp;amp;&amp;amp;(!$past(i_reset))
			&amp;amp;&amp;amp;(!$past(i_new_pc))&amp;amp;&amp;amp;(!$past(i_clear_cache))
			&amp;amp;&amp;amp;($past(o_valid))&amp;amp;&amp;amp;(!$past(i_stall_n)))
	begin
		assert($stable(o_pc));
		assert($stable(o_insn));
		assert($stable(o_valid));
		assert($stable(o_illegal));
	end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The same is true for that second cached word as well.  If that cache position
is valid, yet the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
is stalled, then it should never change.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(posedge i_clk)
	if ((f_past_valid)&amp;amp;&amp;amp;(!$past(i_reset))
			&amp;amp;&amp;amp;(!$past(i_new_pc))&amp;amp;&amp;amp;(!$past(i_clear_cache))
			&amp;amp;&amp;amp;($past(o_valid))&amp;amp;&amp;amp;(!$past(i_stall_n))
			&amp;amp;&amp;amp;($past(cache_valid)))
	begin
		assert($stable(cache_valid));
		assert($stable(cache_word));
		assert($stable(cache_illegal));
	end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;In a fashion similar to &lt;code class=&quot;highlighter-rouge&quot;&gt;o_wb_addr&lt;/code&gt; above, &lt;code class=&quot;highlighter-rouge&quot;&gt;o_pc&lt;/code&gt; should only ever increment,
and it should only do that if an instruction has been accepted–with the
exception of any time &lt;code class=&quot;highlighter-rouge&quot;&gt;i_new_pc&lt;/code&gt; is asserted.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(posedge i_clk)
	if ((f_past_valid)&amp;amp;&amp;amp;(!$past(i_new_pc))
			&amp;amp;&amp;amp;($past(o_valid))&amp;amp;&amp;amp;($past(i_stall_n)))
		assert(o_pc[AW+1:2] == $past(o_pc[AW+1:2])+1&#39;b1);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;As with &lt;code class=&quot;highlighter-rouge&quot;&gt;i_pc[1:0]&lt;/code&gt; and the frustration I described above, the bottom two
bits of the &lt;code class=&quot;highlighter-rouge&quot;&gt;o_pc&lt;/code&gt; address are unused.  Let’s assert here that they remain zero.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(*)
		assert(o_pc[1:0] == 2&#39;b00);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Upon any
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_error&quot;&gt;error&lt;/a&gt;
return, one of either &lt;code class=&quot;highlighter-rouge&quot;&gt;o_illegal&lt;/code&gt; or &lt;code class=&quot;highlighter-rouge&quot;&gt;cache_illegal&lt;/code&gt; should be
set.  Further, if &lt;code class=&quot;highlighter-rouge&quot;&gt;o_illegal&lt;/code&gt; is set, so too should be &lt;code class=&quot;highlighter-rouge&quot;&gt;o_valid&lt;/code&gt; to indicate
this is a valid return, and the same for &lt;code class=&quot;highlighter-rouge&quot;&gt;cache_valid&lt;/code&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(posedge i_clk)
	if ((f_past_valid)&amp;amp;&amp;amp;(!$past(i_reset))
			&amp;amp;&amp;amp;(!$past(i_new_pc))
			&amp;amp;&amp;amp;(!$past(i_clear_cache))
			&amp;amp;&amp;amp;($past(o_wb_cyc))&amp;amp;&amp;amp;($past(i_wb_err)))
		assert( ((o_valid)&amp;amp;&amp;amp;(o_illegal))
			||((cache_valid)&amp;amp;&amp;amp;(cache_illegal)) );&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Any time &lt;code class=&quot;highlighter-rouge&quot;&gt;o_illegal&lt;/code&gt; gets set, &lt;code class=&quot;highlighter-rouge&quot;&gt;o_valid&lt;/code&gt; should also be set at the same time.
&lt;code class=&quot;highlighter-rouge&quot;&gt;o_illegal&lt;/code&gt; will then stay true until cleared by a &lt;code class=&quot;highlighter-rouge&quot;&gt;i_reset&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;i_new_pc&lt;/code&gt;, etc,
so this is the most important part of the check.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(posedge i_clk)
	if ((f_past_valid)&amp;amp;&amp;amp;(!$past(o_illegal))&amp;amp;&amp;amp;(o_illegal))
		assert(o_valid);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;We’ll need to check for the same thing in the cache as well.  Hence, any
time the cached value was not illegal before, and the cache remains invalid
now, then the cache cannot have become illegal during this clock as well.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(posedge i_clk)
	if ((f_past_valid)&amp;amp;&amp;amp;(!$past(cache_illegal))&amp;amp;&amp;amp;(!cache_valid))
		assert(!cache_illegal);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Following any &lt;code class=&quot;highlighter-rouge&quot;&gt;i_new_pc&lt;/code&gt; request, &lt;code class=&quot;highlighter-rouge&quot;&gt;o_valid&lt;/code&gt; &lt;em&gt;must&lt;/em&gt; be low.  This assertion
comes from searching for a bug in the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/idecode.v&quot;&gt;instruction
decoder&lt;/a&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(posedge i_clk)
	if ((f_past_valid)&amp;amp;&amp;amp;($past(i_new_pc)))
		assert(!o_valid);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Finally, any time we transition from &lt;code class=&quot;highlighter-rouge&quot;&gt;o_valid&lt;/code&gt; to &lt;code class=&quot;highlighter-rouge&quot;&gt;!o_valid&lt;/code&gt;, we should also
be starting a
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;
cycle–lest we somehow get stuck.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(posedge i_clk)
	if ((f_past_valid)&amp;amp;&amp;amp;(!$past(i_reset))&amp;amp;&amp;amp;(!$past(i_clear_cache))
			&amp;amp;&amp;amp;($past(o_valid))&amp;amp;&amp;amp;(!o_valid)&amp;amp;&amp;amp;(!o_illegal))
		assert((o_wb_cyc)||(invalid_bus_cycle));&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Okay, that was a lot of properties!  Are you still with me?&lt;/p&gt;

&lt;p&gt;At this point, we are finally ready for the contract with the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;!
Remember how we discussed this above?  Let’s now take a look at how it’s done.&lt;/p&gt;

&lt;p&gt;We’ll start with three arbitrary values, an address, &lt;code class=&quot;highlighter-rouge&quot;&gt;f_const_addr&lt;/code&gt;, an
instruction, &lt;code class=&quot;highlighter-rouge&quot;&gt;f_const_insn&lt;/code&gt;, and whether or not that address will return a
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_error&quot;&gt;error&lt;/a&gt;,
&lt;code class=&quot;highlighter-rouge&quot;&gt;f_const_illegal&lt;/code&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	wire	[AW-1:0]	f_const_addr;
	wire	[DW-1:0]	f_const_insn;
	wire			f_const_illegal;

	// ...
	assign	f_const_addr    = $anyconst;
	assign	f_const_insn    = $anyconst;
	assign	f_const_illegal = $anyconst;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The next section is a bit verbose.  It probably doesn’t need to be.
But, just to tell the story …&lt;/p&gt;

&lt;p&gt;Over the course of time, while working with these values, I got somewhat
frustrated with the waveform viewing tool I was using.  One frustration was
my formal properties often contained something like &lt;code class=&quot;highlighter-rouge&quot;&gt;if ((A)&amp;amp;&amp;amp;(B)&amp;amp;&amp;amp;...)&lt;/code&gt; and
I could never tell when
something failed which of &lt;code class=&quot;highlighter-rouge&quot;&gt;A&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;B&lt;/code&gt;, or (other) wasn’t true.  To keep this
from happening, I assigned wires (below) to the various comparisons checks
I needed to do.  This way, I can examine these wires on any trace
failure and see why things failed.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	wire	f_this_addr, f_this_pc, f_this_req, f_this_data,
		f_this_insn;

	assign	f_this_addr = (o_wb_addr ==   f_const_addr);
	assign	f_this_pc   = (o_pc      == { f_const_addr, 2&#39;b00 });
	assign	f_this_req  = (i_pc      == { f_const_addr, 2&#39;b00 });
	assign	f_this_data = (i_wb_data ==   f_const_insn);
	assign	f_this_insn = (o_insn    ==   f_const_insn);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;That said, I’m undecided as to whether or not this frustration should lead me
to split out wires like this in the future.&lt;/p&gt;

&lt;p&gt;Ok, that’s the setup, here’s the contract: on any clock where the result
is valid, and where it’s our &lt;code class=&quot;highlighter-rouge&quot;&gt;f_const_addr&lt;/code&gt; address being returned, then
we need to be returning either this instruction, &lt;code class=&quot;highlighter-rouge&quot;&gt;f_const_insn&lt;/code&gt;, or
&lt;code class=&quot;highlighter-rouge&quot;&gt;o_illegal&lt;/code&gt; if this instruction returned a
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_error&quot;&gt;error&lt;/a&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(*)
	if ((o_valid)&amp;amp;&amp;amp;(f_this_pc))
	begin
		if (f_const_illegal)
			assert(o_illegal);
		if (!o_illegal)
			assert(f_this_insn);
	end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Of course, this will only work if the
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;
itself returns either this instruction or an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_error&quot;&gt;error&lt;/a&gt;
upon request.  Since this is an input of the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/dblfetch.v&quot;&gt;prefetch&lt;/a&gt;,
it needs to be assumed.&lt;/p&gt;

&lt;p&gt;The trick in making this assumption is that we need to know which return
of the many
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;
requests that we’ve made is the return value for this contract instruction.
Given that we increment &lt;code class=&quot;highlighter-rouge&quot;&gt;o_wb_addr&lt;/code&gt; any time we send a
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;
request in flight, and given that
&lt;code class=&quot;highlighter-rouge&quot;&gt;f_outstanding&lt;/code&gt; counts the number of items in flight, we can then know if this
return is our address by subtracting from &lt;code class=&quot;highlighter-rouge&quot;&gt;o_wb_addr&lt;/code&gt; the number of items
in flight.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	assign	f_this_return = (o_wb_addr - f_outstanding == f_const_addr);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Using this predicate, we can now say that if the next
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;
return will be for this request (i.e. &lt;code class=&quot;highlighter-rouge&quot;&gt;f_this_return&lt;/code&gt; is set), then if
we receive an acknowledgment from the
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;
the data should be &lt;code class=&quot;highlighter-rouge&quot;&gt;f_const_insn&lt;/code&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(*)
	if ((o_wb_cyc)&amp;amp;&amp;amp;(f_this_return))
	begin
		if (i_wb_ack)
			assume(i_wb_data == f_const_insn);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;To handle whether we get a
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_error&quot;&gt;error&lt;/a&gt;
or an acknowledgment, we’ll do it this way:  If &lt;code class=&quot;highlighter-rouge&quot;&gt;f_const_illegal&lt;/code&gt; is true, we
should &lt;em&gt;only&lt;/em&gt; get an &lt;code class=&quot;highlighter-rouge&quot;&gt;i_wb_err&lt;/code&gt; from the
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;
and never any valid acknowledgment.  Likewise the reverse: if &lt;code class=&quot;highlighter-rouge&quot;&gt;f_const_illegal&lt;/code&gt;
is false, we should &lt;em&gt;only&lt;/em&gt; ever get an acknowledgment from the
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;.
This particular way of describing this behavior allows the
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;.
to still take its own sweet time to return any values, but
yet still forces the
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_error&quot;&gt;error&lt;/a&gt;
when appropriate–i.e., when &lt;code class=&quot;highlighter-rouge&quot;&gt;f_const_illegal&lt;/code&gt; is set.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;		if (f_const_illegal)
			assume(!i_wb_ack);
		else
			assume(!i_wb_err);
	end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;There’s a corollary to our contract above.  This corollary has to do
with the cached value that hasn’t yet been given to the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;.
In this case, we still need to assert that this cached value holds to our
contract.  While this wouldn’t be necessary for a simple Bounded Model Check
(BMC), it is a &lt;a href=&quot;/blog/2018/03/10/induction-exercise.html&quot;&gt;necessary
requirement&lt;/a&gt;
in order to pass the formal
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Mathematical_induction&quot;&gt;induction step&lt;/a&gt;.
Hence, if the address within the cache, the next &lt;code class=&quot;highlighter-rouge&quot;&gt;o_pc&lt;/code&gt; address, &lt;code class=&quot;highlighter-rouge&quot;&gt;o_pc+4&lt;/code&gt;,
matches our arbitrary address, &lt;code class=&quot;highlighter-rouge&quot;&gt;f_const_addr&lt;/code&gt;, and if the cache has a valid
value within it, then these conditions apply: unless the cache value is
illegal, it should contain our arbitrary instruction word.  Likewise,
if the cache value is supposed to be illegal, then &lt;code class=&quot;highlighter-rouge&quot;&gt;cache_illegal&lt;/code&gt;
should be true as well.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(*)
	if ((o_pc[AW+1:2] + 1&#39;b1 == f_const_addr)&amp;amp;&amp;amp;(cache_valid))
	begin
		if (!cache_illegal)
			assert(cache_word == f_const_insn);

		if (f_const_illegal)
			assert(cache_illegal);
	end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;That’s our contract.  If we meet that contract, then we’ll know this
design works.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(posedge i_clk)
	if ((f_past_valid)&amp;amp;&amp;amp;(!$past(cache_illegal))&amp;amp;&amp;amp;(!cache_valid))
		assert(!cache_illegal);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;We’re not done yet, however.&lt;/p&gt;

&lt;p&gt;First, we want to make certain that our two instruction FIFO will never
overflow.  As we’ve written our design above, any overflow would be
catastrophic.  Hence, any time we request a new value, we must have a place
to put it.  In other words, either the cache value must be empty, or the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
must have just accepted a value.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(*)
	if (o_wb_stb)
		assert((!cache_valid)||(i_stall_n));&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;In a similar vein, any time both the output and the cache value are both
valid, then we need to guarantee that we aren’t requesting any more values,
and that nothing is in flight.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(*)
	if ((o_valid)&amp;amp;&amp;amp;(cache_valid))
		assert((f_outstanding == 0)&amp;amp;&amp;amp;(!o_wb_stb));&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;These should be sufficient to keep us from overflowing this two instruction
FIFO.&lt;/p&gt;

&lt;p&gt;However, the
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal properties&lt;/a&gt;
we’ve listed so far &lt;a href=&quot;/blog/2018/03/10/induction-exercise.html&quot;&gt;aren’t sufficient to
guarantee&lt;/a&gt;
that the design will pass the &lt;a href=&quot;https://en.wikipedia.org/wiki/Mathematical_induction&quot;&gt;induction
step&lt;/a&gt;.  In order to pass
&lt;a href=&quot;https://en.wikipedia.org/wiki/Mathematical_induction&quot;&gt;induction&lt;/a&gt;,
we need to restrict the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Mathematical_induction&quot;&gt;induction&lt;/a&gt;
engine so that it only considers reachable states.&lt;/p&gt;

&lt;p&gt;To make certain we don’t over-restrict our design, we’ll limit ourselves here
to only using assert statements.  As a result, the BMC and
&lt;a href=&quot;https://en.wikipedia.org/wiki/Mathematical_induction&quot;&gt;induction&lt;/a&gt;
stages will be able to catch anything that is over constrained–as long as the
number of stages examined in BMC is more than the stages examined during
&lt;a href=&quot;https://en.wikipedia.org/wiki/Mathematical_induction&quot;&gt;induction&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The first assertion is that any time we have at least one item in our FIFO,
that is any time &lt;code class=&quot;highlighter-rouge&quot;&gt;o_valid&lt;/code&gt; is true, and any time that item isn’t moving forward,
then there can only be one or zero
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;
requests outstanding.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(*)
	if ((o_valid)&amp;amp;&amp;amp;(!i_stall_n))
		assert(f_outstanding &amp;lt; 2);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The next assertion follows, but in this case any time the FIFO is completely
empty we allow ourselves to have up to two requests in flight.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(*)
	if ((!o_valid)||(i_stall_n))
		assert(f_outstanding &amp;lt;= 2);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Further, any time we are within a
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;
cycle, i.e. &lt;code class=&quot;highlighter-rouge&quot;&gt;o_wb_cyc&lt;/code&gt; is high, but yet we’ve stopped making
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;
requests, i.e. &lt;code class=&quot;highlighter-rouge&quot;&gt;o_wb_stb&lt;/code&gt; is low, then there should
be some number of requests in flight.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(posedge i_clk)
	if ((f_past_valid)&amp;amp;&amp;amp;($past(o_wb_cyc))&amp;amp;&amp;amp;(!$past(o_wb_stb))
			&amp;amp;&amp;amp;(o_wb_cyc))
		assert(inflight != 0);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Just to make sure we captured everything, let’s state this again: on any
return from the
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;,
there must be a place to put that return.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(*)
	if ((o_wb_cyc)&amp;amp;&amp;amp;(i_wb_ack))
		assert(!cache_valid);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Further, our design has two separate counters of how many items are within
flight.  One is from the &lt;code class=&quot;highlighter-rouge&quot;&gt;f_outstanding&lt;/code&gt; counter created within the
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;formal WB properties&lt;/a&gt;,
module, and the other our &lt;code class=&quot;highlighter-rouge&quot;&gt;inflight&lt;/code&gt; counter.&lt;/p&gt;

&lt;p&gt;These two counters need to be identical any time the
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;,
is in use.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(posedge i_clk)
	if (o_wb_cyc)
		assert(inflight == f_outstanding);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Now let’s look at the address of the request being made, vs the address
being given to the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;First, upon any return from the
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;,
that goes into &lt;code class=&quot;highlighter-rouge&quot;&gt;o_valid&lt;/code&gt;, the address
of the value returned needs to be equal to the value given to the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	assign	this_return_address = o_wb_addr - f_outstanding;
	assign	next_pc_address = o_pc[AW+1:2] + 1&#39;b1;

	always @(posedge i_clk)
	if ((f_past_valid)&amp;amp;&amp;amp;($past(o_wb_cyc))
			&amp;amp;&amp;amp;(!$past(i_reset))
			&amp;amp;&amp;amp;(!$past(i_new_pc))
			&amp;amp;&amp;amp;(!$past(i_clear_cache))
			&amp;amp;&amp;amp;(!$past(invalid_bus_cycle))
			&amp;amp;&amp;amp;(($past(i_wb_ack))||($past(i_wb_err)))
			&amp;amp;&amp;amp;((!$past(o_valid))||($past(i_stall_n)))
			&amp;amp;&amp;amp;(!$past(cache_valid)))
		assert(o_pc[AW+1:2] == $past(this_return_address));&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This isn’t enough, though, to constrain the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Mathematical_induction&quot;&gt;induction&lt;/a&gt;
engine.  I know, I tried.&lt;/p&gt;

&lt;p&gt;Getting
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/dblfetch.v&quot;&gt;this design&lt;/a&gt;
to pass the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Mathematical_induction&quot;&gt;induction&lt;/a&gt; step
required running the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Mathematical_induction&quot;&gt;induction&lt;/a&gt;
engine many times, then looking at the failures and trying to find out
which wires or values didn’t make sense.  When you find them, you look
at them and wonder, how on earth did that happen?  That doesn’t follow
my design principles!  Yes, but you
&lt;a href=&quot;/blog/2018/03/10/induction-exercise.html&quot;&gt;need to tell&lt;/a&gt;
the &lt;a href=&quot;https://en.wikipedia.org/wiki/Mathematical_induction&quot;&gt;induction&lt;/a&gt; step
engine that.&lt;/p&gt;

&lt;p&gt;So, let’s look at the case where &lt;code class=&quot;highlighter-rouge&quot;&gt;o_valid&lt;/code&gt; isn’t true, but yet we are within a
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;
cycle.  In this case, &lt;code class=&quot;highlighter-rouge&quot;&gt;o_pc&lt;/code&gt; must be the address of the next request
that will be returned from the
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(posedge i_clk)
	if ((f_past_valid)&amp;amp;&amp;amp;($past(o_wb_cyc))&amp;amp;&amp;amp;(!o_valid)&amp;amp;&amp;amp;(!$past(i_new_pc))
			&amp;amp;&amp;amp;(o_wb_cyc))
		assert(o_pc[AW+1:2] == this_return_address);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;We need to check the same thing with the cache word.  Any time the cache
becomes valid, the address coming back needs to be one past the &lt;code class=&quot;highlighter-rouge&quot;&gt;o_pc&lt;/code&gt;
address being presented to the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(posedge i_clk)
	if ((f_past_valid)&amp;amp;&amp;amp;($past(o_wb_cyc))
			&amp;amp;&amp;amp;(!$past(cache_valid))&amp;amp;&amp;amp;(cache_valid))
		assert(next_pc_address == $past(this_return_address));&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The final step looks at these relationships a bit more thoroughly.  We’ll
examine only those times, though, when the bus is active.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(posedge i_clk)
	if ((f_past_valid)&amp;amp;&amp;amp;($past(o_wb_cyc))&amp;amp;&amp;amp;(o_wb_cyc))
	begin&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;If there’s one active value in our FIFO, then anything returned from the
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;
should have an address given by our next
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;
address.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;		if ((o_valid)&amp;amp;&amp;amp;(!cache_valid))
			assert(this_return_address == next_pc_address);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Likewise anytime we have no valid instructions, the next value to be returned
by the
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;
must match the next
&lt;a href=&quot;https://en.wikipedia.org/wiki/Program_counter&quot;&gt;PC&lt;/a&gt;
value, &lt;code class=&quot;highlighter-rouge&quot;&gt;o_pc&lt;/code&gt;, to be sent to the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;		else if (!o_valid)
			assert(this_return_address == o_pc[AW+1:2]);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Finally, any time the
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;
is idle, and there’s only one word in our cache and it’s not illegal,
then the address remaining on the
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;
needs to be the next address to be requested.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	end else if ((f_past_valid)&amp;amp;&amp;amp;(!invalid_bus_cycle)
			&amp;amp;&amp;amp;(!o_wb_cyc)&amp;amp;&amp;amp;(o_valid)&amp;amp;&amp;amp;(!o_illegal)
			&amp;amp;&amp;amp;(!cache_valid))
		assert(o_wb_addr == next_pc_address);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This leaves us with only two more assertions.  These are sort of dogs and
cats assertions that don’t fit under any other category above.&lt;/p&gt;

&lt;p&gt;First, the &lt;code class=&quot;highlighter-rouge&quot;&gt;invalid_bus_cycle&lt;/code&gt; should only ever be true if we aren’t in a
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;
cycle.  This assertion was added to make certain I could simplify
some of the assertions above.  Since I know it is true, I could make the
other assertions simpler.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(*)
	if (invalid_bus_cycle)
		assert(!o_wb_cyc);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Finally, the &lt;code class=&quot;highlighter-rouge&quot;&gt;cache_valid&lt;/code&gt; signal should never be true unless &lt;code class=&quot;highlighter-rouge&quot;&gt;o_valid&lt;/code&gt; is
also true.  This lines up with the idea that &lt;code class=&quot;highlighter-rouge&quot;&gt;cache_valid&lt;/code&gt; is our signal that
the second item within our two-element FIFO is valid, so therefore the first
item in the FIFO must also be valid in these cases as well.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(*)
	if (cache_valid)
		assert(o_valid);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Wow!  That was a lot of work on those properties!  The cool thing about these,
though, is that now that I have these properties, I can then test simple logic
changes to my design, such as &lt;a href=&quot;/blog/2017/06/12/minimizing-luts.html&quot;&gt;trying to remove LUTs to make the design
simpler&lt;/a&gt;,
and see if those changes affect the functionality of this design.&lt;/p&gt;

&lt;h2 id=&quot;cover-properties&quot;&gt;Cover Properties&lt;/h2&gt;

&lt;p&gt;I haven’t presented &lt;code class=&quot;highlighter-rouge&quot;&gt;cover&lt;/code&gt; properties before, although they are a valuable
part of
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal methods&lt;/a&gt;.
The &lt;code class=&quot;highlighter-rouge&quot;&gt;cover&lt;/code&gt; property is very different from the &lt;code class=&quot;highlighter-rouge&quot;&gt;assume&lt;/code&gt; an &lt;code class=&quot;highlighter-rouge&quot;&gt;assert&lt;/code&gt; properties
above.  Indeed, &lt;code class=&quot;highlighter-rouge&quot;&gt;cover&lt;/code&gt; is called a “liveness” property, unlike
&lt;code class=&quot;highlighter-rouge&quot;&gt;assume&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;assert&lt;/code&gt; which are called “safety” properties.  The difference is
that &lt;code class=&quot;highlighter-rouge&quot;&gt;assume&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;assert&lt;/code&gt; properties must apply to all traces, whereas a
&lt;code class=&quot;highlighter-rouge&quot;&gt;cover&lt;/code&gt; property only needs to apply to a single trace to be true.&lt;/p&gt;

&lt;p&gt;A quick Google search suggests that there’s a bit of a disagreement as to
whether “liveness” properties are even needed, or whether “safety” properties
are sufficient.&lt;/p&gt;

&lt;p&gt;While I’m not going to enter into that debate today, I will note that
&lt;code class=&quot;highlighter-rouge&quot;&gt;cover&lt;/code&gt; statements can be used while you are building your design to
see if it is working.&lt;/p&gt;

&lt;p&gt;As an example, before I listed out all of the properties in the last
section, I wanted to know if this routine might ever get a third
acknowledgment from the same
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;
cycle.  If you’ll remember from Fig 11 above, this was part of the purpose
of
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/dblfetch.v&quot;&gt;this design&lt;/a&gt;
in the first place–to be able to continue the
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;
cycle as long as possible.  Therefore, I put the following &lt;code class=&quot;highlighter-rouge&quot;&gt;cover&lt;/code&gt;
statement into my design.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(posedge i_clk)
	cover((f_past_valid)&amp;amp;&amp;amp;($past(f_nacks)==3)
		&amp;amp;&amp;amp;($past(i_wb_ack))&amp;amp;&amp;amp;($past(o_wb_cyc)));&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;When this &lt;code class=&quot;highlighter-rouge&quot;&gt;cover&lt;/code&gt; statement failed at first, I knew I didn’t have my design
right yet.  Further, when I dug into the problem, I discovered that this
&lt;code class=&quot;highlighter-rouge&quot;&gt;cover&lt;/code&gt; statement was failing not due to my logic, but rather due to some
erroneous assumptions I had made.&lt;/p&gt;

&lt;p&gt;Erroneous assumptions can be particularly problematic in
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal methods&lt;/a&gt;,
especially if you are only using the “safety” properties, &lt;code class=&quot;highlighter-rouge&quot;&gt;assume&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;assert&lt;/code&gt;,
since an erroneous assumption will artificially limit your proof.  Worse yet,
you might not notice that your assumptions are creating this artificial
limit.  Such an assumption might then give you a false assurance that your
design works–even though it does not. (Yes, I’ve &lt;a href=&quot;/blog/2018/02/09/first-cyclonev.html&quot;&gt;been burned by
this&lt;/a&gt;
more than once.)&lt;/p&gt;

&lt;h2 id=&quot;logic-usage&quot;&gt;Logic Usage&lt;/h2&gt;

&lt;p&gt;If you’ll remember from when we started, the purpose of this particular
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/dblfetch.v&quot;&gt;prefetch
module&lt;/a&gt;
was to be a compromise–it was to have better performance than our &lt;a href=&quot;/zipcpu/2017/11/18/wb-prefetch.html&quot;&gt;one
instruction prefetch&lt;/a&gt;,
but not nearly as much as we might have with a proper &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/pfcache.v&quot;&gt;instruction
cache&lt;/a&gt;.
It’s also supposed to be a (fairly) low logic design.&lt;/p&gt;

&lt;p&gt;So, for a small design, how did we do?&lt;/p&gt;

&lt;p&gt;In particular, I’d like to place
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/dblfetch.v&quot;&gt;this prefetch&lt;/a&gt;
into both a
&lt;a href=&quot;https://tinyfpga.com&quot;&gt;TinyFPGA&lt;/a&gt;
and the &lt;a href=&quot;/blog/2017/12/16/max1k.html&quot;&gt;MAX1000 from Arrow&lt;/a&gt;.
Will it fit?&lt;/p&gt;

&lt;p&gt;The iCE40 &lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
within the &lt;a href=&quot;https://tinyfpga.com&quot;&gt;TinyFPGA&lt;/a&gt; board is perhaps the most
constrained of these two.  This
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
has just less than 8k 4-LUTs available to it.  With just a simple
&lt;a href=&quot;https://www.clifford.at/yosys&quot;&gt;yosys&lt;/a&gt;
script,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;read_verilog dblfetch.v
synth_ice40&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;we can easily measure this components usage on an iCE40–in only
a half-second no less (try doing that with a vendor tool!).  You can
see the LUT4 usage of these various components in the table below.&lt;/p&gt;

&lt;table class=&quot;bordered-table&quot;&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Prefetch&lt;/th&gt;
      &lt;th&gt;LUT4s&lt;/th&gt;
      &lt;th&gt;iCE40 Device usage&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;Single&lt;/td&gt;
      &lt;td&gt;74&lt;/td&gt;
      &lt;td&gt;1.0%&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Double&lt;/td&gt;
      &lt;td&gt;247&lt;/td&gt;
      &lt;td&gt;3.2%&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;(Before)&lt;/td&gt;
      &lt;td&gt;277&lt;/td&gt;
      &lt;td&gt;3.6%&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;w/ 4k Cache&lt;/td&gt;
      &lt;td&gt;621&lt;/td&gt;
      &lt;td&gt;8.0%&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;As you can see from the table, this module offers an area compromise between
the &lt;a href=&quot;/zipcpu/2017/11/18/wb-prefetch.html&quot;&gt;slowest prefetch
module&lt;/a&gt;
and the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/pfcache.v&quot;&gt;full prefetch and cache
module&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;running-the-zipcpu-with-this-prefetch&quot;&gt;Running the ZipCPU with this prefetch&lt;/h2&gt;

&lt;p&gt;If you want to try running the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
or even
&lt;a href=&quot;/zipcpu/2018/02/12/zbasic-intro.html&quot;&gt;ZBasic&lt;/a&gt; with this
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/dblfetch.v&quot;&gt;this prefetch&lt;/a&gt;
installed, all you need to do is to adjust the flags in
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/cpudefs.v&quot;&gt;cpudefs.v&lt;/a&gt;.
Specifically, you’ll want to make certain the &lt;code class=&quot;highlighter-rouge&quot;&gt;OPT_SINGLE_FETCH&lt;/code&gt; define is
commented,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;// `define	OPT_SINGLE_FETCH&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;and the &lt;code class=&quot;highlighter-rouge&quot;&gt;OPT_DOUBLE_FETCH&lt;/code&gt; line is not,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;`ifndef	OPT_SINGLE_FETCH
`define	OPT_DOUBLE_FETCH
`endif&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;You may recall discussing &lt;a href=&quot;/zipcpu/2018/01/31/cpu-build.html&quot;&gt;this comparison in a previous
article&lt;/a&gt;,
only now this &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/dblfetch.v&quot;&gt;compromise prefetch
module&lt;/a&gt;
has been updated for better performance and lower logic.  Hence, if you’ve
downloaded the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; before, you’ll
want to do a &lt;code class=&quot;highlighter-rouge&quot;&gt;git pull&lt;/code&gt; to get the latest version of
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/dblfetch.v&quot;&gt;this module&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;While it’s generally true that nothing comes for free, today’s post presents
a bit of an exception.  By redesigning &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/dblfetch.v&quot;&gt;my original dblfetch
module&lt;/a&gt;,
used by the &lt;a href=&quot;https://github.com/ZipCPU/s6soc&quot;&gt;S6SoC&lt;/a&gt;
and some other &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; low logic
implementations, we were able to get both better performance and
&lt;a href=&quot;/blog/2017/06/12/minimizing-luts.html&quot;&gt;fewer LUTs&lt;/a&gt;.
Hence, there are two conclusions we might draw:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;In general, the more LUTs you apply to a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Soft_microprocessor&quot;&gt;soft-core CPU&lt;/a&gt;,
the faster the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Soft_microprocessor&quot;&gt;CPU&lt;/a&gt; will be.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;There exist times when a better design can achieve more or better
performance.  Today’s post represents one of those times.  Such
performance increases, though, do tend to be asymptotic over time.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;What made the difference?  This new/updated
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/dblfetch.v&quot;&gt;prefetch&lt;/a&gt;
doesn’t use a two element memory array, nor the associated pair of valid
signals, to capture the two elements returned by the bus.&lt;/p&gt;

&lt;p&gt;How about the
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal methods&lt;/a&gt; we
used?  Did they help?  To this I’ll answer both yes and no.  The first time
I used this logic in a
&lt;a href=&quot;/blog/2017/06/21/looking-at-verilator.html&quot;&gt;simulated&lt;/a&gt;
&lt;a href=&quot;/blog/2017/12/16/max1k.html&quot;&gt;board&lt;/a&gt;, the
&lt;a href=&quot;/zipcpu/2018/02/12/zbasic-intro.html&quot;&gt;CPU test&lt;/a&gt;
failed.  That’s the “No” part of the answer.  However, the logic failed
within the early branch logic in the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/idecode.v&quot;&gt;instruction
decoder&lt;/a&gt;, not the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/dblfetch.v&quot;&gt;prefetch&lt;/a&gt;.
Indeed, this updated
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/dblfetch.v&quot;&gt;prefetch&lt;/a&gt;
has yet to have any failures since passing
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal verification&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Sadly, this wonderful anecdote of the performance of
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal methods&lt;/a&gt;
isn’t nearly as clear as I might like it to be.  The logic that failed within
the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/idecode.v&quot;&gt;instruction
decoder&lt;/a&gt;
had already been &lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formally
verified&lt;/a&gt;.
Apparently, that proof just wasn’t sufficient and I must still be only learning
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal methods&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The one question we haven’t answered is just how much faster is this
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/dblfetch.v&quot;&gt;prefetch&lt;/a&gt;?
That is, how does it’s &lt;em&gt;performance&lt;/em&gt; quantitatively compare to the other
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
&lt;a href=&quot;/zipcpu/2017/11/18/wb-prefetch.html&quot;&gt;prefetch&lt;/a&gt; modules?
I’m going to hold those questions off, though, for a future article on how
to measure your &lt;a href=&quot;https://en.wikipedia.org/wiki/Soft_microprocessor&quot;&gt;CPU&lt;/a&gt;’s
performance via a benchmark test–such as the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Dhrystone&quot;&gt;Dhrystone benchmark&lt;/a&gt;.  Such a
benchmark test will also bring us face to face with the fact that our
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;
speed measurements above weren’t accurate at all since they ignored the
(very significant) cost of
&lt;a href=&quot;https://en.wikipedia.org/wiki/Branch_(computer_science)&quot;&gt;branching&lt;/a&gt;.&lt;/p&gt;
&lt;hr /&gt;&lt;p&gt;&lt;em&gt;Many will say to me in that day, Lord, Lord, have we not prophesied in thy name? and in thy name have cast out devils? and in thy name done many wonderful works?  And then will I profess unto them, I never knew you: depart from me, ye that work iniquity.  (Matt 7:22-23)&lt;/em&gt;</description>
        <pubDate>Wed, 21 Mar 2018 00:00:00 -0400</pubDate>
        <link>http://zipcpu.com/zipcpu/2018/03/21/dblfetch.html</link>
        <guid isPermaLink="true">http://zipcpu.com/zipcpu/2018/03/21/dblfetch.html</guid>
        
        
        <category>zipcpu</category>
        
      </item>
    
      <item>
        <title>Is formal really all that hard?</title>
        <description>&lt;p&gt;I spent the first week of March, 2018, at
&lt;a href=&quot;https://dvcon.org&quot;&gt;DVCon&lt;/a&gt;
in San Francisco, talking to vendors and asking questions regarding
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;Formal Verification&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Many vendors offered Verification IP (VIP) modules that you could use in
&lt;a href=&quot;/blog/2017/06/21/looking-at-verilator.html&quot;&gt;simulation&lt;/a&gt;
to know that your interface matched the specification.  These models would
attach to your design, allowing you to then run tests on your design.  When/if
your design didn’t match what the protocol required, these commercial
VIP modules would issue an error.&lt;/p&gt;

&lt;p&gt;Indeed, it seems like the primary method of &lt;em&gt;proving&lt;/em&gt; that an
&lt;a href=&quot;/blog/2017/10/13/fpga-v-asic.html&quot;&gt;ASIC design&lt;/a&gt;
would work prior to tape out is to feed the simulated design with random data
and requests, over and over again, in order to get the design to fail.  Several
presentations discussed how to do this.  Hardware was advertised that could
help to make this happen.  While I’ll admit that the level of effort discussed
and presented goes well beyond my simple &lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;scripted test bench
failures&lt;/a&gt;,
it still only provides a small stochastic confidence that the design would work.&lt;/p&gt;

&lt;p&gt;What a difference from
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal&lt;/a&gt;!&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/v-method.svg&quot; alt=&quot;&quot; width=&quot;600&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;When using
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal methods&lt;/a&gt;,
&lt;em&gt;every&lt;/em&gt; path through the your logic is tested to determine if the design
works.  &lt;em&gt;Every path&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;This led me to wandering through the exhibit hall, asking vendor after vendor
if they had any &lt;em&gt;formal&lt;/em&gt; VIP.  Perhaps 5-10% of the VIP available was available
for proving something
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formally&lt;/a&gt;.
While the reasons were mixed, the general consensus was that
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal&lt;/a&gt;
was more difficult to use, and so there wasn’t the same market for it.  One
vendor even declared that his tools were faster, better, and cheaper than
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal&lt;/a&gt;,
although less than
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal&lt;/a&gt;
in capability.&lt;/p&gt;

&lt;p&gt;What??  Really?  Is
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal&lt;/a&gt;
really all that difficult to use?&lt;/p&gt;

&lt;p&gt;Let’s look at a simple example or two.  Then, we can discuss how I go about
getting started with
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal&lt;/a&gt; on any new
design, and what designs I apply
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal methods&lt;/a&gt; to.
Finally, we’ll attempt to address the question of whether
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal methods&lt;/a&gt;
really are all that hard.&lt;/p&gt;

&lt;h2 id=&quot;cover&quot;&gt;Cover&lt;/h2&gt;

&lt;p&gt;Just one simple &lt;code class=&quot;highlighter-rouge&quot;&gt;cover&lt;/code&gt; statement can have an amazing impact on a new design.
As an example, in a &lt;a href=&quot;https://github.com/ZipCPU/tinyzip&quot;&gt;recent design&lt;/a&gt;
I was working on for the
&lt;a href=&quot;https://tinyfpga.com&quot;&gt;TinyFPGA&lt;/a&gt;, a project I am calling
&lt;a href=&quot;https://github.com/ZipCPU/tinyzip&quot;&gt;TinyZip&lt;/a&gt;, I simply inserted&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	cover(o_wb_ack);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;into the &lt;a href=&quot;https://github.com/ZipCPU/tinyzip/blob/master/rtl/dualflexpress.v&quot;&gt;new/updated dual
I/O&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt;
controller.
(I was starting with
&lt;a href=&quot;https://github.com/ZipCPU/s6soc/blob/master/rtl/qflashxpress.v&quot;&gt;this QSPI&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt; controller.)
If you aren’t familiar with a &lt;code class=&quot;highlighter-rouge&quot;&gt;cover&lt;/code&gt; statement, you can consider
it a challenge to the
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal&lt;/a&gt;
&lt;a href=&quot;http://www.clifford.at/yosys&quot;&gt;tools&lt;/a&gt; to find some way to make the predicate
inside of the &lt;code class=&quot;highlighter-rouge&quot;&gt;cover&lt;/code&gt; statement–in this case &lt;code class=&quot;highlighter-rouge&quot;&gt;o_wb_ack&lt;/code&gt;–true.  To do this,
the &lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal&lt;/a&gt;
&lt;a href=&quot;http://www.clifford.at/yosys&quot;&gt;tools&lt;/a&gt; needed to trace &lt;a href=&quot;https://github.com/ZipCPU/tinyzip/blob/master/rtl/dualflexpress.v&quot;&gt;my
design&lt;/a&gt;
through the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt;
bring-up, the
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus request&lt;/a&gt;, the address
passing to the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt;,
and the return value.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;No extra logic was required!&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;I didn’t need to &lt;a href=&quot;/blog/2017/06/21/looking-at-verilator.html&quot;&gt;build a
simulation&lt;/a&gt;,
to tell the simulator to tick the clock,
tell it how many clocks to tick, feed it with just the right input along
the way–none of that.  With one line I had an example
trace through the important parts of my code.&lt;/p&gt;

&lt;p&gt;Was that all that hard?&lt;/p&gt;

&lt;p&gt;Ok, so it wasn’t perfect: the bus wires were being driven incoherently.
However, with some additional assumptions, such as those &lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;we discussed for the
Wishbone Bus&lt;/a&gt;, the traces
greatly improved.  (No, the
&lt;a href=&quot;https://github.com/ZipCPU/tinyzip/blob/master/rtl/dualflexpress.v&quot;&gt;controller&lt;/a&gt;
isn’t finished yet …)  Later, I added another cover statement to make
certain I could keep &lt;a href=&quot;https://github.com/ZipCPU/tinyzip/blob/master/rtl/dualflexpress.v&quot;&gt;the
design&lt;/a&gt;
loaded with one request after another.&lt;/p&gt;

&lt;h2 id=&quot;state-machines&quot;&gt;State Machines&lt;/h2&gt;

&lt;p&gt;Many of my designs use state machines that don’t completely cover
all of the states bits available.  For example, the “lite” versions of
&lt;a href=&quot;https://github.com/ZipCPU/wbuart32&quot;&gt;my serial port modules&lt;/a&gt;
only use states 0-8 and 15.  What if the design entered into any other
state?  Would such be possible?  With just a simple assertion,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	assert((state &amp;lt;= 8)||(state == 15));&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;I can then use
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal methods&lt;/a&gt;
to tell me if my state machine will ever get out of bounds.  Indeed, this
concept is so useful, it’s worth discussing further in the next section.&lt;/p&gt;

&lt;h2 id=&quot;dependent-logic&quot;&gt;Dependent logic&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;Formal methods&lt;/a&gt; are
also &lt;em&gt;very&lt;/em&gt; useful for making sure that dependencies between logic elements
are captured.  Hence, if you have two variables, &lt;code class=&quot;highlighter-rouge&quot;&gt;A&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;B&lt;/code&gt; that &lt;em&gt;must&lt;/em&gt;
have a dependent relationship,
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal methods&lt;/a&gt; are
very useful for making sure that dependent relationship is maintained.&lt;/p&gt;

&lt;p&gt;For example, many designs depend upon a state machine that transitions at a
speed much slower than the system clock.  My own &lt;a href=&quot;https://github.com/ZipCPU/wbuart32&quot;&gt;UART
implementation&lt;/a&gt; makes a great example
of this.  In this design, as with many similar ones, there is often a counter
used to determine &lt;em&gt;when&lt;/em&gt; the next state change will be.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
if (counter != 0)
	counter &amp;lt;= counter - 1&#39;b1;
else if (state_change) // &amp;amp;&amp;amp; counter == 0
	counter &amp;lt;= NEW_VALUE-1&#39;b1;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The problem with this approach is that within the state machine logic, I would
need to place tests for whether or not &lt;code class=&quot;highlighter-rouge&quot;&gt;counter == 0&lt;/code&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
if (i_reset)
	state  == reset_state;
else if (counter == 0)
begin
	case(state)
	STATE_ONE:
		// ...
	end case
end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This test for zero can make the &lt;a href=&quot;/blog/2017/06/12/minimizing-luts.html&quot;&gt;state transition logic unnecessarily
complex&lt;/a&gt;,
so I’ll often calculate it the clock prior with something like:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	zclk &amp;lt;= (counter == 1)||((counter == 0)&amp;amp;&amp;amp;(!state_change));&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;To determine if I got the logic right, I only need to
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formally verify&lt;/a&gt; that:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	assert(zclk == (counter == 0));&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;When the
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal&lt;/a&gt;
proof passes, I’ll know that these two dependent registers, &lt;code class=&quot;highlighter-rouge&quot;&gt;zclk&lt;/code&gt; and
&lt;code class=&quot;highlighter-rouge&quot;&gt;counter&lt;/code&gt;, are guaranteed to maintain their dependent relationship.
Hence, I can rely upon this dependency always being true within my
code–as I intended.&lt;/p&gt;

&lt;p&gt;Certainly other internal code dependencies can exist as well–often more
complex than this one.  For example, a packet index or address might need
to be zero any time the network is idle.  As I recognize that I have such
a dependency when writing my own code, I’ll often quickly write an
assertion to capture it.  Indeed, I do this so often that I’ll discuss
how to go about this in the next section.&lt;/p&gt;

&lt;h2 id=&quot;while-writing-code&quot;&gt;While writing code&lt;/h2&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/files-formal.svg&quot; alt=&quot;&quot; width=&quot;180&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Often, when I write RTL, I’ll come across a situation where I recognize some
dependency within my code that must be hold true.  Rather than write a fully
defensive piece of code that handles any potential internal failure, it
is often effective (and easier) to write a quick assertion to remind myself
to come back later and place this into the list of &lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal
properties&lt;/a&gt;
at the end of the module.&lt;/p&gt;

&lt;p&gt;Making sure I remember all of these dependencies later can be a hassle.&lt;/p&gt;

&lt;p&gt;Here’s a method I’ve found useful for that purpose.&lt;/p&gt;

&lt;p&gt;As I’m working on creating a module,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;//
// All files start with a (legalese) comment block
//
module name(/* portlist */);
	//
	// Module code is indented by one tab
	//&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;I’ll add any
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal properties&lt;/a&gt;
in line as I’m writing–but with the caveat that these ad-hoc properties
are not indented like the rest of the code.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;// Properties that need to be moved around later are not indented
// This helps me remember, when I see something that doesn&#39;t line
// up, that this property needs to be moved to another location.
always @(posedge i_clk)
	assume(!i_reset);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;My development will then continue, returning to my original indentation
scheme.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	//
	// Further module code (now indented again) may follow
	//&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Then, some time later, I’ll collect these ad-hoc &lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;assumtions and
assertions&lt;/a&gt;
into a section at the end of the module together with the rest of its
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal properties&lt;/a&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;`ifdef	FORMAL
	// Here&#39;s where the formal properties will eventually be placed:
	// between `ifdef FORMAL and it&#39;s associated `endif.
`endif&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;For example, a
&lt;a href=&quot;https://github.com/ZipCPU/wbuart32&quot;&gt;UART&lt;/a&gt; baud counter should never count
higher than one baud interval.  Hence, as I’m putting my
&lt;a href=&quot;https://github.com/ZipCPU/wbuart32&quot;&gt;UART&lt;/a&gt;
component design together, I’ll place an assertion to this effect into my code.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	assert(baud_counter &amp;lt; ONE_BAUD);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Some of my code, such as the &lt;a href=&quot;https://github.com/ZipCPU/tinyzip/blob/master/rtl/dualflexpress.v&quot;&gt;dual I/O flash
controller&lt;/a&gt;
I mentioned above, depends upon the ability to peek at a
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus request&lt;/a&gt;
at certain times before accepting it.  This requirement is easily captured by
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal properties&lt;/a&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
if ((f_past_valid)&amp;amp;&amp;amp;($past(request))&amp;amp;&amp;amp;(!$past(accepted)))
	assert(request_details == $past(request_details));&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Once I realize this, usually while building the code, I’ll just write it in
as I discussed above.  &lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;Asserts and
assumptions&lt;/a&gt;
like this alone have helped me flush out many
&lt;a href=&quot;/blog/2017/08/14/strategies-for-pipelining.html&quot;&gt;pipeline&lt;/a&gt;
bugs!&lt;/p&gt;

&lt;p&gt;Knowing that I intend to use
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal methods&lt;/a&gt;
to verify a design helps to encourage me to write properties within my
code as I write my code–even though I’ll place those at the end of the
file later.&lt;/p&gt;

&lt;h2 id=&quot;some-modules-are-just-too-critical-not-to-use-formal&quot;&gt;Some modules are just too critical not to use formal&lt;/h2&gt;

&lt;p&gt;Some interfaces I deal with are just &lt;em&gt;too critical&lt;/em&gt; not to use
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal methods&lt;/a&gt;
to prove a design component before introducing it to hardware.
For example, just one misbehaving &lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus
component&lt;/a&gt;
and the whole design will come crashing down.&lt;/p&gt;

&lt;p&gt;Remember how this happened to me in my first &lt;a href=&quot;/blog/2018/02/09/first-cyclonev.html&quot;&gt;Cyclone-V
project&lt;/a&gt;?  Before I
got the &lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal&lt;/a&gt;
properties of the &lt;a href=&quot;https://www.altera.com/literature/manual/mnl_avalon_spec.pdf&quot;&gt;Avalon
bus&lt;/a&gt;
just right, I had to deal with several cases of hardware lockup.
It would seem as though a
&lt;a href=&quot;/blog/2018/02/09/first-cyclonev.html&quot;&gt;Cyclone-V&lt;/a&gt;
can’t recover if my own logic fails to lower the wait request line, or
equivalently if it returns random bus responses that don’t follow requests).
In my case, only cycling power ever rescued my design, leaving me wondering
what had happened.&lt;/p&gt;

&lt;p&gt;If you’ve been reading this blog for a while, you may now recognize this
purpose in the &lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;formal WB properties
post&lt;/a&gt;.
Bus control logic is just &lt;em&gt;too sensitive&lt;/em&gt; to mess up.  All it takes
is one master missing a response to a request and your design may be locked
up until a hard reset.&lt;/p&gt;

&lt;p&gt;Cache controllers are another example, as they can be a &lt;em&gt;real pain&lt;/em&gt; to get
right.  Worse, all it takes is one &lt;a href=&quot;/zipcpu/2017/12/28/ugliest-bug.html&quot;&gt;ugly caching
error&lt;/a&gt; and you may be
&lt;a href=&quot;/blog/2017/05/19/fpga-hell.html&quot;&gt;spending days (or weeks)&lt;/a&gt;
looking in the wrong place to find the bug.&lt;/p&gt;

&lt;p&gt;My recommendation, therefore, would be that you consider this principle for
any portion of your design that, if it fails, will cause the whole design to
fail while leaving you in &lt;a href=&quot;/blog/2017/05/19/fpga-hell.html&quot;&gt;FPGA
Hell&lt;/a&gt;.
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;Formally verify&lt;/a&gt;
those components early in your design cycle, before ever placing them onto
real hardware.  Then verify them again any time you change them.&lt;/p&gt;

&lt;h2 id=&quot;some-simple-contracts&quot;&gt;Some simple contracts&lt;/h2&gt;

&lt;p&gt;I’ve recently started looking at the designs I’m building as providing a
service, and so when I start building the design I’ll often create a &lt;em&gt;contract&lt;/em&gt;
to describe the service that must be provided.  These &lt;em&gt;contracts&lt;/em&gt; are usually
just a couple of lines of &lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal
properties&lt;/a&gt;
that describe outputs in relationship to the designs inputs.
Such design contracts are often so fundamental that if the contract holds,
the design will be 80% verified (or better).&lt;/p&gt;

&lt;p&gt;Consider, for a moment, some simple peripherals from the standpoint of a
“contract”.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;Bus requests should always be followed by a bus
response&lt;/a&gt;.  There should be
no more responses than there are requests.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;A &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/dev/rtl/core/pfcache.v&quot;&gt;cache&lt;/a&gt;
should always return the value that would be found in memory at the
given address, whether it needs to read from memory to get it or instead if
it is already in the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/dev/rtl/core/pfcache.v&quot;&gt;cache&lt;/a&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Reads from a memory controller
(&lt;a href=&quot;https://github.com/ZipCPU/xulalx25soc/blob/master/rtl/wbsdram.v&quot;&gt;SDRAM&lt;/a&gt;,
&lt;a href=&quot;https://github.com/ZipCPU/tinyzip/blob/master/rtl/dualflexpress.v&quot;&gt;flash&lt;/a&gt;,
etc.) should always return the value that exists in the memory at that
location, and writes should change the memory.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;An &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/zipmmu.v&quot;&gt;MMU&lt;/a&gt;
should act as a bus bridge, between one set of addresses (the virtual ones)
and another (the physical ones), while creating page misses for anything
that doesn’t match.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The neat thing about these contracts is that they can help me prove that an
item works–to include passing the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Mathematical_induction&quot;&gt;induction&lt;/a&gt;
&lt;a href=&quot;/blog/2018/03/10/induction-exercise.html&quot;&gt;step&lt;/a&gt;.
Specifically, until the contract can be proven, the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Mathematical_induction&quot;&gt;induction&lt;/a&gt;
solver will keep presenting me with traces I need to examine.  This helps me
know how many properties I need to write.&lt;/p&gt;

&lt;p&gt;If the Lord wills, I’m hoping to blog about this concept soon with respect to a
second &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
&lt;a href=&quot;/zipcpu/2017/11/18/wb-prefetch.html&quot;&gt;prefetch module&lt;/a&gt;,
showing how a contract can be written using a couple free variables.&lt;/p&gt;

&lt;h2 id=&quot;why-do-people-think-formal-is-hard&quot;&gt;Why do people think formal is hard?&lt;/h2&gt;

&lt;p&gt;After hearing that 
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal&lt;/a&gt;
was too hard, I tried to gather all of the excuses I heard
to see if there might be some merit to any of them.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Mathematical_induction&quot;&gt;Induction&lt;/a&gt;
is harder than Bounded Model Checking (BMC)&lt;/p&gt;

    &lt;p&gt;Many of the simple examples I gave above would be perfect for bounded
proofs.  These proofs are only applicable for the first N steps (i.e
the bound) following a reset.  Bounded proofs are much easier than the
full proofs, simply because in the case of a full proof you need to
find &lt;em&gt;ALL&lt;/em&gt; the &lt;a href=&quot;/blog/2018/03/10/induction-exercise.html&quot;&gt;internal
dependencies&lt;/a&gt;.
within your design and make them known to the
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal&lt;/a&gt;
engine via additional properties–whether they be assumptions or assertions.
This can be a pain, and so I can understand that you might not wish to use
&lt;a href=&quot;https://en.wikipedia.org/wiki/Mathematical_induction&quot;&gt;induction&lt;/a&gt;
at first.  Even in this case, though, the bounded model check is still
valuable–just not nearly as valuable as the full proof with
&lt;a href=&quot;https://en.wikipedia.org/wiki/Mathematical_induction&quot;&gt;induction&lt;/a&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Some modules are just too complex to prove using
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal methods&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;This isn’t an excuse, nor should it be.  It is just a reality.&lt;/p&gt;

    &lt;p&gt;While I’ve been able to &lt;a href=&quot;/zipcpu/2018/01/22/formal-progress.html&quot;&gt;prove all of the leaf
modules&lt;/a&gt; of the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;,
the complexity of the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt; as a whole
has caused me to pause before diving into it.  While I think I &lt;em&gt;can&lt;/em&gt;
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formally prove&lt;/a&gt;
that it works, the sheer complexity has caused me to pause.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The full System Verilog Assertions syntax can be confusing&lt;/p&gt;

    &lt;p&gt;If you’ve looked at the articles I’ve written so far regarding
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal methods&lt;/a&gt;,
you may notice that I haven’t used the full System Verilog Assertion (SVA)
syntax.  This is for two reasons.&lt;/p&gt;

    &lt;p&gt;First, the open source
&lt;a href=&quot;http://www.clifford.at/yosys&quot;&gt;yosys&lt;/a&gt;
synthesis tool that I’m using to get access to
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal methods&lt;/a&gt;
without re-mortgaging my home doesn’t understand this syntax (yet).
Indeed, I’ve managed to &lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formally
verify&lt;/a&gt;
many designs with only the subset that
&lt;a href=&quot;http://www.clifford.at/yosys&quot;&gt;yosys&lt;/a&gt;
supports.  Since
&lt;a href=&quot;http://www.clifford.at/yosys&quot;&gt;yosys&lt;/a&gt;
is the tool I can afford, it’s the tool I’ve been using.&lt;/p&gt;

    &lt;p&gt;Second, I’m in the process of building a class in
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal methods&lt;/a&gt;.
This class includes a section on how to use the full SVA syntax: properties,
sequences, clocking blocks, bind statements, and more.  Since I’ve now
been introduced to the full SVA syntax, my initial impressions are that
it is very expressive, terse and compact, and as a result it is confusing
to those who are not familiar with them.  On the other hand, the
&lt;code class=&quot;highlighter-rouge&quot;&gt;assert&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;assume&lt;/code&gt; statements I’ve used within always or initial blocks
have been expressive enough for me, and simpler to understand.&lt;/p&gt;

    &lt;p&gt;It just happens that this simpler subset is also the set that
&lt;a href=&quot;http://www.clifford.at/yosys&quot;&gt;yosys&lt;/a&gt;
currently supports.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;It can be really difficult to sell
&lt;em&gt;&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal&lt;/a&gt;&lt;/em&gt;
Verification IP, simply because
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal&lt;/a&gt;
verification is a form of
&lt;a href=&quot;https://en.wikipedia.org/wiki/White_box_testing&quot;&gt;&lt;em&gt;white&lt;/em&gt; box testing&lt;/a&gt;&lt;/p&gt;

    &lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 3. Just attaching VIP to a formal design doesn&#39;t usually work&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/files-vip-unlinked.svg&quot; alt=&quot;&quot; width=&quot;360&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p style=&quot;list-style-type: none;&quot;&gt;What I mean by this is that attaching any vendor
   supplied Verification IP module to your design isn’t as simple as just
   instantiating the two components within the same design.  The
   &lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal methods&lt;/a&gt;,
   and &lt;a href=&quot;https://en.wikipedia.org/wiki/Mathematical_induction&quot;&gt;induction&lt;/a&gt;
   in particular, won’t work if you just plug and play related design pieces
   together such as Fig 3. attempts to show.  This makes it more difficult
   to sell, purchase, or use vendor provided Verification IP with
   &lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;In order to connect an external set of
   &lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal&lt;/a&gt; properties,
   such as those from a piece of vendor supplied Verification IP, to the
   &lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal&lt;/a&gt; properties
   within your own design–relevant portions of the design need to be
   constrained to be properly dependent with the VIP.
   Success in this fashion is far more intrusive, and not nearly as simple
   as just purchasing someone else’s IP.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 4. Passing Induction requires component state to interact&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/files-vip-linked.svg&quot; alt=&quot;&quot; width=&quot;360&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Perhaps a good example of this is my
   &lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;Wishbone&lt;/a&gt; &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/ex/wbpriarbiter.v&quot;&gt;bus
   arbiter&lt;/a&gt;.
   Internal to the &lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;Wishbone formal
   property&lt;/a&gt;
   &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/tree/master/rtl/ex&quot;&gt;IP modules&lt;/a&gt;
   are the counters necessary to insure that slaves will only respond
   to outstanding requests.  This
   requires counting the number of requests, the number of acknowledgments,
   and then making certain that there are never more acknowledgments than
   requests.  When I then try to use these properties within the bus
   &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/ex/wbpriarbiter.v&quot;&gt;arbiter&lt;/a&gt;
   to pass
   &lt;a href=&quot;https://en.wikipedia.org/wiki/Mathematical_induction&quot;&gt;induction&lt;/a&gt;,
   the
   &lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal&lt;/a&gt; engine
   may set these counters to &lt;a href=&quot;/blog/2018/03/10/induction-exercise.html&quot;&gt;any initial value it
   wants&lt;/a&gt;.  However,
   the arbiter
   is designed so that only one master can ever have access to the bus at a
   time.  This means that the counters for the two slave inputs and the master
   output must be kept in sync.  Doing this requires knowledge of the counters
   within the
   &lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;Wishbone&lt;/a&gt; propert
   &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/tree/master/rtl/ex&quot;&gt;module&lt;/a&gt;,
   enough so that I can assert that when one bus source has access to the bus,
   the other sources number of outstanding requests must remain at zero.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
if (r_a_owner)
begin
	// If A owns the bus

	// B must have no outstanding requests, nor may it
	// have received any acknowledgements
	assert(f_b_nreqs == 0);
	assert(f_b_nacks == 0);

	// The total number of outstanding requests must equal
	// the number of outstanding requests A is expecting
	assert(f_a_outsanding == f_outstanding);
end else begin
	// Else B must own the bus
	// Same properties as before, just reversed
	assert(f_a_nreqs == 0);
	assert(f_a_nacks == 0);
	assert(f_b_outsanding == f_outstanding);
end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig. Here&#39;s how I ended up attaching WB properties to a simple design&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/files-wb-properties.svg&quot; alt=&quot;&quot; width=&quot;480&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;If you fail to do this, your design &lt;a href=&quot;/blog/2018/03/10/induction-exercise.html&quot;&gt;won’t be able
   to pass&lt;/a&gt;
   &lt;a href=&quot;https://en.wikipedia.org/wiki/Mathematical_induction&quot;&gt;induction&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Even if your design doesn’t pass
   &lt;a href=&quot;https://en.wikipedia.org/wiki/Mathematical_induction&quot;&gt;induction&lt;/a&gt;,
   (most big chip maker designs don’t) your &lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal
   properties&lt;/a&gt;
   may still be good enough to accomplish some purposes, since you can still
   find lots of bugs via a simple Bounded Model Check.  You just can’t &lt;em&gt;prove&lt;/em&gt;
   that your design will maintain those properties for all time.&lt;/p&gt;

&lt;p&gt;Does it take a genius?  Not really.  Indeed, from my own experience,
it just takes someone smart enough to write Verilog RTL in the first place.&lt;/p&gt;

&lt;h2 id=&quot;formal-isnt-perfect&quot;&gt;Formal isn’t perfect&lt;/h2&gt;

&lt;p&gt;My thesis today is just that
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal&lt;/a&gt;
isn’t really any more difficult than normal RTL coding.  Not only that, it fits
nicely into the RTL coding process and even adds to it.  Now that I’ve used it
for a while, and now that I’ve found as many errors as I have using
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal&lt;/a&gt;,
I’m convinced from my own experience that it’s not really that hard.  Indeed,
if I had the choice today, I would find it difficult to start a project
&lt;em&gt;without&lt;/em&gt; the help
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal methods&lt;/a&gt;
provide.&lt;/p&gt;

&lt;p&gt;While I was at the
&lt;a href=&quot;https://dvcon.org&quot;&gt;DVCon&lt;/a&gt; conference, I heard two fascinating comments
regarding how valuable &lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal
methods&lt;/a&gt; are,
and many fascinating anecdotes.  The first comment I scribbled down was
that, “Without &lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal&lt;/a&gt;,
70% of the bugs in a design are found after the module is turned in.  With
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal&lt;/a&gt;,
80% of the bugs in a design are found before the module is turned in.”
No, I’m not sure any more where these numbers came from, so if I can find the
study I’d love to share it with you.  The
second comment was from one of the panelists who noted that a rough 80% of a
verification engineer’s time is spent fixing the &lt;em&gt;silly&lt;/em&gt; bugs.  The
implication in this statement was that, had only
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal methods&lt;/a&gt;
been used, the verification engineer wouldn’t need to be spending his time
fixing the stupid mistakes.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;Formal methods&lt;/a&gt;
aren’t perfect.  By that I mean that, in my own experience, I’ve still had
to chase down bugs that “passed” a formal proof.
These include problems with not constraining my design enough, with adding
careless assumptions, and even misunderstood requirements.&lt;/p&gt;

&lt;p&gt;However, I find 
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal methods&lt;/a&gt;
easier to use than the alternative, and I also feel like I am finding more
bugs by using them as part of my design process.  As a result, I now use
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal methods&lt;/a&gt;
first, and then continue with simulation when I’m done.&lt;/p&gt;

&lt;p&gt;So why do people think
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal&lt;/a&gt; is all that
difficult?  My best guess is that
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal methods&lt;/a&gt;
appear difficult to those who have not tried them, and additionally to those
selling Verification IP.&lt;/p&gt;
&lt;hr /&gt;&lt;p&gt;&lt;em&gt;Behold, I am the LORD, the God of all flesh: is there any thing too hard for me?  (Jeremiah 32:27)&lt;/em&gt;</description>
        <pubDate>Wed, 14 Mar 2018 00:00:00 -0400</pubDate>
        <link>http://zipcpu.com/blog/2018/03/14/is-formal-hard.html</link>
        <guid isPermaLink="true">http://zipcpu.com/blog/2018/03/14/is-formal-hard.html</guid>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>An Exercise in using Formal Induction</title>
        <description>&lt;p&gt;In many ways I’m still quite the beginner when it comes to proving designs
using &lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal methods&lt;/a&gt;:
I’ve only used
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal methods&lt;/a&gt;
for about about five months.  However, over those five months I’ve found
so many bugs in my “&lt;em&gt;working&lt;/em&gt;” code that I’ve started using
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal methods&lt;/a&gt;
for every new component and design I’ve built since.&lt;/p&gt;

&lt;p&gt;I’ve also found myself counseling others on the
&lt;a href=&quot;https://irclog.whitequark.org/yosys&quot;&gt;#yosys&lt;/a&gt;
&lt;a href=&quot;https://freenode.net&quot;&gt;IRC forum&lt;/a&gt;.  It’s been rather strange, though, since
I very much feel as though I myself am quite the beginner, and yet I’m
answering questions and explaining things as though I’d been doing this
for years.&lt;/p&gt;

&lt;p&gt;I haven’t.&lt;/p&gt;

&lt;p&gt;However, I’d like to share with you today an &lt;a href=&quot;/examples/kitest.v&quot;&gt;example
piece&lt;/a&gt; of code that really
taught me a lot about
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal methods&lt;/a&gt;,
and in particular about the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Mathematical_induction&quot;&gt;induction&lt;/a&gt; step.
It’s come up recently as I’ve tried to explain
&lt;a href=&quot;https://en.wikipedia.org/wiki/Mathematical_induction&quot;&gt;induction&lt;/a&gt;
to someone with even less experience than I have, and I’ve found that it
makes a good and simple example to learn from.&lt;/p&gt;

&lt;p&gt;I’ll be honest–my own mentors haven’t thought that much of the
&lt;a href=&quot;/examples/kitest.v&quot;&gt;example below&lt;/a&gt;.  Their response
has been something like, “Oh, yes, of course.” Yet to me, I’ve found
&lt;a href=&quot;/examples/kitest.v&quot;&gt;this example&lt;/a&gt;
to be &lt;em&gt;very&lt;/em&gt; instructive.&lt;/p&gt;

&lt;h2 id=&quot;the-example-code&quot;&gt;The Example Code&lt;/h2&gt;

&lt;p&gt;The &lt;a href=&quot;/examples/kitest.v&quot;&gt;basic example&lt;/a&gt;
consists of two shift registers, &lt;code class=&quot;highlighter-rouge&quot;&gt;sa&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;sb&lt;/code&gt;, although
the example would also work if you were comparing &lt;a href=&quot;/blog/2017/10/27/lfsr.html&quot;&gt;Fibonacci versus Galois
linear feedback shift registers
(LFSR)s&lt;/a&gt;–it just wouldn’t be
nearly as clear.  However, the example does require that the two
shift register outputs need to be identical.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 1. Two identical shift registers&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/kitest.svg&quot; alt=&quot;&quot; width=&quot;480&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;We’ll allow our two shift registers to have a parameterized
length, &lt;code class=&quot;highlighter-rouge&quot;&gt;LN&lt;/code&gt;, although for the purposes of today’s discussion we’ll only
set this length to a constant 16, &lt;code class=&quot;highlighter-rouge&quot;&gt;LN=16&lt;/code&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;module	kitest(i_clk, i_reset, i_ce, i_in, o_bit);
	parameter		LN=16;
	//
	input	wire		i_clk, i_reset, i_ce, i_in;
	output	wire		o_bit;

	reg	[(LN-1):0]	sa, sb;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;For this example to be instructive, both shift registers must have &lt;em&gt;identical&lt;/em&gt;
logic.  Therefore, we’ll initialize both registers to zero.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	initial	sa = 0;
	initial	sb = 0;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;We’ll clear both registers on any synchronous reset.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(posedge i_clk)
	if (i_reset)
	begin
		sa &amp;lt;= 0;
		sb &amp;lt;= 0;
	end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Finally, any time &lt;code class=&quot;highlighter-rouge&quot;&gt;i_ce&lt;/code&gt; is true, the input value will be placed into the
least significant bit (LSB) of each shift register, while we shift the rest
of the register to the left.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	else if (i_ce)
	begin
		sa &amp;lt;= { sa[(LN-2):0], i_in };
		sb &amp;lt;= { sb[(LN-2):0], i_in };
	end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;In all other clocks, &lt;code class=&quot;highlighter-rouge&quot;&gt;sa&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;sb&lt;/code&gt; will remain unchained.&lt;/p&gt;

&lt;p&gt;Our &lt;a href=&quot;/examples/kitest.v&quot;&gt;example&lt;/a&gt;
needs an output, so let’s set our output value to be the
exclusive OR of the most significant bits in each register.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	assign	o_bit = sa[LN-1] ^ sb[LN-1];&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;If these two shift registers are truly identical, then we should be able to
assert this fact to the
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal&lt;/a&gt;
solver, as in:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;`ifdef	FORMAL
	assert property(!o_bit);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;If you stop here and try to prove this one property,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;`endif
endmodule&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;it will pass a bounded model check, but not
&lt;a href=&quot;https://en.wikipedia.org/wiki/Mathematical_induction&quot;&gt;induction&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Once I understood why
&lt;a href=&quot;/examples/kitest.v&quot;&gt;this simple design&lt;/a&gt;
struggled with
&lt;a href=&quot;https://en.wikipedia.org/wiki/Mathematical_induction&quot;&gt;induction&lt;/a&gt;,
I was suddenly able to figure out why various designs were struggling with
&lt;a href=&quot;https://en.wikipedia.org/wiki/Mathematical_induction&quot;&gt;induction&lt;/a&gt;,
and I then understood how to deal with it.  Therefore, let’s
spend the rest of this article discussing the difficulty with
&lt;a href=&quot;/examples/kitest.v&quot;&gt;this design&lt;/a&gt;,
and also how we might go about solving it.&lt;/p&gt;

&lt;h2 id=&quot;running-symbiyosys&quot;&gt;Running SymbiYosys&lt;/h2&gt;

&lt;p&gt;If you have &lt;a href=&quot;https://symbiyosys.readthedocs.io/en/latest&quot;&gt;SymbiYosys&lt;/a&gt;
installed, then all it takes is a
&lt;a href=&quot;/examples/kitest.sby&quot;&gt;very simple script&lt;/a&gt; to run this test.
Since adjusting parameters is fairly easy with
&lt;a href=&quot;https://symbiyosys.readthedocs.io/en/latest&quot;&gt;SymbiYosys&lt;/a&gt;, we’ll use it for
our tests today.&lt;/p&gt;

&lt;p&gt;There are four basic parts to any
&lt;a href=&quot;https://symbiyosys.readthedocs.io/en/latest&quot;&gt;SymbiYosys&lt;/a&gt;
script: the options, the formal engine, the
&lt;a href=&quot;http://www.clifford.at/yosys&quot;&gt;yosys&lt;/a&gt;
script, and the list of component files involved.&lt;/p&gt;

&lt;p&gt;In our case, we’ll want to use the formal mode &lt;em&gt;prove&lt;/em&gt;.  This will run both
the bounded model checker (BMC), &lt;em&gt;and&lt;/em&gt; the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Mathematical_induction&quot;&gt;induction&lt;/a&gt; engine.
Other modes I’ve worked with include &lt;em&gt;bmc&lt;/em&gt;, which just runs the bounded
model checker, and &lt;em&gt;cover&lt;/em&gt;, which checks cover properties. 
&lt;a href=&quot;https://symbiyosys.readthedocs.io/en/latest&quot;&gt;SymbiYosys&lt;/a&gt;
also supports a mode for checking liveness, called mode &lt;em&gt;live&lt;/em&gt;, but I have
yet to try that mode.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;[options]
mode prove&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 2. Forall time proofs have two parts&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/formal-forall-time.svg&quot; alt=&quot;&quot; width=&quot;240&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;We’ll also be adjusting the depth of the proof.  This is the number of logic
steps the formal solver uses to test our design.  In &lt;em&gt;bmc&lt;/em&gt; mode, this will
be the number of clock cycles, measured from the beginning of time, that
are checked for any assertion failures.  For the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Mathematical_induction&quot;&gt;induction&lt;/a&gt; step, in
&lt;em&gt;prove&lt;/em&gt; mode, this will decide the number of clock cycles for both the &lt;em&gt;bmc&lt;/em&gt;
pass and the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Mathematical_induction&quot;&gt;induction&lt;/a&gt; pass.  For
the &lt;a href=&quot;https://en.wikipedia.org/wiki/Mathematical_induction&quot;&gt;induction&lt;/a&gt; pass,
all but the last cycle will assume your &lt;code class=&quot;highlighter-rouge&quot;&gt;assert&lt;/code&gt;’s are true.  On the last cycle,
however, the formal engine will try to find one example where it can show that
an assertion fails.&lt;/p&gt;

&lt;p&gt;In my initial
&lt;a href=&quot;https://symbiyosys.readthedocs.io/en/latest&quot;&gt;SymbiYosys&lt;/a&gt;
&lt;a href=&quot;/examples/kitest.sby&quot;&gt;script&lt;/a&gt;,
I’ll set this depth to 31.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;depth 31&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;As I mentioned, we’ll be adjusting this value during today’s
&lt;a href=&quot;/examples/kitest.v&quot;&gt;exercise&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;We’ll also need to specify which formal solving engine we want to use.  In
this case, the &lt;a href=&quot;http://yices.csl.sri.com&quot;&gt;yices&lt;/a&gt;
engine will work quite nicely.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;[engines]
smtbmc yices&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Other engines are available, and may produce different results.&lt;/p&gt;

&lt;p&gt;We’ll then provide
&lt;a href=&quot;https://symbiyosys.readthedocs.io/en/latest&quot;&gt;SymbiYosys&lt;/a&gt;
with a very simple set of
&lt;a href=&quot;http://www.clifford.at/yosys&quot;&gt;yosys&lt;/a&gt;
commands to build &lt;a href=&quot;/examples/kitest.v&quot;&gt;our test&lt;/a&gt;,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;[script]
read_verilog -formal kitest.v
prep -top kitest

[files]
kitest.v&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Be aware when you are working with
&lt;a href=&quot;https://symbiyosys.readthedocs.io/en/latest&quot;&gt;SymbiYosys&lt;/a&gt;
that the &lt;code class=&quot;highlighter-rouge&quot;&gt;[files]&lt;/code&gt; section
will specify where your source files are coming from.
&lt;a href=&quot;https://symbiyosys.readthedocs.io/en/latest&quot;&gt;SymbiYosys&lt;/a&gt; will then copy
these files to a working directory before running
&lt;a href=&quot;http://www.clifford.at/yosys&quot;&gt;yosys&lt;/a&gt;,
so the &lt;code class=&quot;highlighter-rouge&quot;&gt;read_verilog&lt;/code&gt; command within the
&lt;a href=&quot;http://www.clifford.at/yosys&quot;&gt;yosys&lt;/a&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;[script]&lt;/code&gt; section will reference all files
from within the current directory where
&lt;a href=&quot;https://symbiyosys.readthedocs.io/en/latest&quot;&gt;SymbiYosys&lt;/a&gt; placed them.&lt;/p&gt;

&lt;p&gt;Let’s save this script to a file,
&lt;a href=&quot;/examples/kitest.sby&quot;&gt;kitest.sby&lt;/a&gt;.
Put together, the whole
&lt;a href=&quot;https://symbiyosys.readthedocs.io/en/latest&quot;&gt;SymbiYosys&lt;/a&gt;
&lt;a href=&quot;/examples/kitest.sby&quot;&gt;script&lt;/a&gt;
will look like,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;[options]
mode prove
depth 31

[engines]
smtbmc yices

[script]
read_verilog -formal kitest.v
prep -top kitest

[files]
kitest.v&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Assuming you have
&lt;a href=&quot;https://symbiyosys.readthedocs.io/en/latest&quot;&gt;SymbiYosys&lt;/a&gt;,
&lt;a href=&quot;http://www.clifford.at/yosys&quot;&gt;yosys&lt;/a&gt;, and
&lt;a href=&quot;http://yices.csl.sri.com&quot;&gt;yices&lt;/a&gt;
installed, then all it then takes to run
&lt;a href=&quot;https://symbiyosys.readthedocs.io/en/latest&quot;&gt;SymbiYosys&lt;/a&gt;
is the command,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span class=&quot;gp&quot;&gt;% &lt;/span&gt;sby -f kitest.sby&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Pay attention to the last line returned by
&lt;a href=&quot;https://symbiyosys.readthedocs.io/en/latest&quot;&gt;SymbiYosys&lt;/a&gt;.  If all goes
well, you’ll get the line:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;SBY [kitest] DONE (PASS, rc=0)&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;However, if our design passes BMC (which it will) but
fails &lt;a href=&quot;https://en.wikipedia.org/wiki/Mathematical_induction&quot;&gt;induction&lt;/a&gt;, then
this last line will instead read,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;SBY [kitest] DONE (UNKNOWN, rc=4)&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;In the next section, we’ll look at what happens when we apply
&lt;a href=&quot;https://symbiyosys.readthedocs.io/en/latest&quot;&gt;SymbiYosys&lt;/a&gt;
to &lt;a href=&quot;/examples/kitest.v&quot;&gt;our example&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;exploring-what-happens&quot;&gt;Exploring what happens&lt;/h2&gt;

&lt;p&gt;Let’s spend some time exploring what happens within
&lt;a href=&quot;/examples/kitest.v&quot;&gt;this example design&lt;/a&gt;, and see what
it will take to get us to fully prove our property that the output bit will
always be zero.&lt;/p&gt;

&lt;p&gt;We’ll start out by describing a set of tests, each containing a different
approach to handling this problem.  We’ll use the local parameter
&lt;code class=&quot;highlighter-rouge&quot;&gt;FORMAL_TEST&lt;/code&gt; to select from among several possible options for proving
this.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	localparam [2:0]	FORMAL_TEST = 3&#39;b001;

	generate if (FORMAL_TEST == 3&#39;b000)
	begin

		always @(*)
			assume(i_ce);

	end else if (FORMAL_TEST == 3&#39;b001)
	begin

		// No extra logic

	end else if (FORMAL_TEST == 3&#39;b010)
	begin

		assert property(sa == sb);

	end else if (FORMAL_TEST == 3&#39;b011)
	begin

		always @(posedge i_clk)
		if (!$past(i_ce))
			assume(i_ce);

	end else if (FORMAL_TEST == 3&#39;b100)
	begin

		always @(posedge i_clk)
		if ((!$past(i_ce))&amp;amp;&amp;amp;(!$past(i_ce,2)))
			assume(i_ce);

	// else
	//	No formal logic
	end endgenerate&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Now, let’s work our way through these tests, shall we?&lt;/p&gt;

&lt;p&gt;When &lt;code class=&quot;highlighter-rouge&quot;&gt;FORMAL_TEST&lt;/code&gt; is zero, the test passes–much as we might expect.
Since it does pass, there’s no trace generated to examine and we can move
on.  We’ll come back to this, though, in a moment.&lt;/p&gt;

&lt;p&gt;When &lt;code class=&quot;highlighter-rouge&quot;&gt;FORMAL_TEST&lt;/code&gt; is set to &lt;code class=&quot;highlighter-rouge&quot;&gt;3&#39;b001&lt;/code&gt;, however, the test fails.  Why would
this be?  It doesn’t make sense, right?  I mean, if you look at the
&lt;a href=&quot;/examples/kitest.v&quot;&gt;code&lt;/a&gt;,
you can clearly (by examination) tell that &lt;code class=&quot;highlighter-rouge&quot;&gt;sa==sb&lt;/code&gt;, and so there must be
something wrong with the
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal methods&lt;/a&gt;,
therefore, if it can’t tell that these two are equal.&lt;/p&gt;

&lt;p&gt;Well, not quite.  Let’s dig a little deeper.&lt;/p&gt;

&lt;p&gt;In particular, let’s pull up the trace associated with this failure.  If
you look through the
&lt;a href=&quot;https://symbiyosys.readthedocs.io/en/latest&quot;&gt;SymbiYosys&lt;/a&gt;
output, you’ll find the line ending with&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;.... Writing trace to VCD file: engine_0/trace_induct.vcd&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;We can open &lt;code class=&quot;highlighter-rouge&quot;&gt;trace_induct.vcd&lt;/code&gt; in &lt;a href=&quot;http://gtkwave.sourceforge.net&quot;&gt;GTKWave&lt;/a&gt;
and look at what’s going on here.  You’ll find this file in the
&lt;code class=&quot;highlighter-rouge&quot;&gt;kitest/engine_0&lt;/code&gt; directory where
&lt;a href=&quot;https://symbiyosys.readthedocs.io/en/latest&quot;&gt;SymbiYosys&lt;/a&gt;
placed it.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 3. Induction fails&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/kitest-2.png&quot; alt=&quot;&quot; width=&quot;911&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;If you look through the trace, you’ll notice that &lt;code class=&quot;highlighter-rouge&quot;&gt;sa&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;sb&lt;/code&gt; are
indeed different.&lt;/p&gt;

&lt;p&gt;What?  How can this be?&lt;/p&gt;

&lt;p&gt;To understand this, you need to understand a bit about how formal
&lt;a href=&quot;https://en.wikipedia.org/wiki/Mathematical_induction&quot;&gt;induction&lt;/a&gt; works.
The &lt;a href=&quot;https://en.wikipedia.org/wiki/Mathematical_induction&quot;&gt;induction&lt;/a&gt; step
works by picking random initial values for every registered signal within
the design.  Well, okay, that’s not quite right.  The values aren’t truly
chosen &lt;em&gt;randomly&lt;/em&gt;, they are actually chosen &lt;em&gt;exhaustively&lt;/em&gt;.  Were they chosen
randomly, it might be possible to miss some choices that would cause the design
to fail.  The benefit of formal, however, is that it will try every possible
combination in order to find one that will cause  your design to fail.
To you as a developer looking at the traces through your code, it might feel
like these values are chosen &lt;em&gt;randomly&lt;/em&gt;, although there’s actually a method
to this madness.&lt;/p&gt;

&lt;p&gt;Either way, the engine knows nothing about whether or not the design could
ever achieve the initial values it chooses.  It only knows whether or not any
of these violate any assumptions or assertions.&lt;/p&gt;

&lt;p&gt;For the first 31 steps of this test, the only constraint upon &lt;code class=&quot;highlighter-rouge&quot;&gt;sa&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;sb&lt;/code&gt; is
that their most significant bits are equal.  The engine has kept this true for
us.  Nothing in &lt;a href=&quot;/examples/kitest.v&quot;&gt;our example&lt;/a&gt;
constrains the rest of the shift register, either &lt;code class=&quot;highlighter-rouge&quot;&gt;sa[LN-2:0]&lt;/code&gt; or &lt;code class=&quot;highlighter-rouge&quot;&gt;sb[LN-2:0]&lt;/code&gt;,
so those values can be anything.&lt;/p&gt;

&lt;p&gt;Then, in step 31, the engine chooses to set &lt;code class=&quot;highlighter-rouge&quot;&gt;i_ce&lt;/code&gt; high.  This forces a
comparison between &lt;code class=&quot;highlighter-rouge&quot;&gt;sa[LN-1]&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;sb[LN-1]&lt;/code&gt; on step 32, where the comparison
(which is formed by our assertion) fails.&lt;/p&gt;

&lt;p&gt;This is obviously not what we want, so
what can we do to fix this?  The most obvious answer is to
assert that &lt;code class=&quot;highlighter-rouge&quot;&gt;sa==sb&lt;/code&gt;.  This is &lt;code class=&quot;highlighter-rouge&quot;&gt;FORMAL_TEST&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;3&#39;b010&lt;/code&gt;.  This test passes
very quickly, with little fanfare.  This works.&lt;/p&gt;

&lt;p&gt;What else might we do?&lt;/p&gt;

&lt;p&gt;Suppose we went back and examined our first test again, with our depth
set to 15 instead of 31.  You’ll need to adjust the depth option within the
&lt;a href=&quot;https://symbiyosys.readthedocs.io/en/latest&quot;&gt;SymbiYosys&lt;/a&gt;
&lt;a href=&quot;/examples/kitest.sby&quot;&gt;configuration script&lt;/a&gt;
to do this.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;depth 15&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;As before, we can pull up the trace to see what happened.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 4. Induction fails, where it succeeded before&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/kitest-0.png&quot; alt=&quot;&quot; width=&quot;918&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;In this trace, &lt;code class=&quot;highlighter-rouge&quot;&gt;sa&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;sb&lt;/code&gt; are different again.  This time,
though, the difference starts out in bit zero on the first timestep (not shown).
On every clock following, this one differing bit moves one step closer to our
assertion that the most significant bits of &lt;code class=&quot;highlighter-rouge&quot;&gt;sa&lt;/code&gt; and&lt;code class=&quot;highlighter-rouge&quot;&gt;sb&lt;/code&gt; are identical.  As
this assertion is applied in the first 15 steps, it is applied as an
assumption–forcing the fifteen most significant bits of &lt;code class=&quot;highlighter-rouge&quot;&gt;sa&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;sb&lt;/code&gt; to be
identical.  However, on step 16, the assertion
is treated not as an assumption but rather as a full-blown assertion.
This time it fails, because we never told the formal engine that bits zero
in both shift registers were initially identical.&lt;/p&gt;

&lt;p&gt;This suggests that this test will pass for a depth of 16.  Feel free to try
that one on your own.&lt;/p&gt;

&lt;p&gt;Now let’s move on and try &lt;code class=&quot;highlighter-rouge&quot;&gt;FORMAL_TEST&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;3&#39;b011&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;In this test, &lt;code class=&quot;highlighter-rouge&quot;&gt;i_ce&lt;/code&gt; is never allowed to be zero for two clocks in a row.
It is allowed to be true on every clock, or to alternate between true and
false, or some combination between the two.&lt;/p&gt;

&lt;p&gt;Let’s make one more change as well.  We’ll set the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Mathematical_induction&quot;&gt;induction&lt;/a&gt;
depth to 30 steps in &lt;a href=&quot;/examples/kitest.sby&quot;&gt;kitest.sby&lt;/a&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;depth 30&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This test also fails.&lt;/p&gt;

&lt;p&gt;As before, we can pull up the trace to see what happened.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 5. Induction fails, i_ce is now true every other step&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/kitest-3.png&quot; alt=&quot;&quot; width=&quot;915&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;This looks very much like the last test that failed: both failed because the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Mathematical_induction&quot;&gt;induction&lt;/a&gt; engine
allowed &lt;code class=&quot;highlighter-rouge&quot;&gt;sa&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;sb&lt;/code&gt; to start out with different least significant bit.&lt;/p&gt;

&lt;p&gt;The only thing that’s different here is &lt;code class=&quot;highlighter-rouge&quot;&gt;i_ce&lt;/code&gt;.  In this case, the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Mathematical_induction&quot;&gt;induction&lt;/a&gt;
engine has chosen to alternate &lt;code class=&quot;highlighter-rouge&quot;&gt;i_ce&lt;/code&gt; with high and low.
Why?  Because the alternating &lt;code class=&quot;highlighter-rouge&quot;&gt;i_ce&lt;/code&gt; value pushes the assertion regarding
this bit far enough forward in formal steps that the proof now fails.&lt;/p&gt;

&lt;p&gt;However, it failed on the &lt;em&gt;last&lt;/em&gt; step.  I know,
&lt;a href=&quot;https://en.wikipedia.org/wiki/Mathematical_induction&quot;&gt;induction&lt;/a&gt;
always only ever fails on its last step.  That’s not what I mean.  What I mean
is that if we just extend the search depth by one clock,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;depth 31&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;then this test will pass.&lt;/p&gt;

&lt;p&gt;The last test, &lt;code class=&quot;highlighter-rouge&quot;&gt;FORMAL_TEST&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;3&#39;b100&lt;/code&gt;, is very similar to test &lt;code class=&quot;highlighter-rouge&quot;&gt;3b011&lt;/code&gt;.  I’ll
leave this one as homework for you.&lt;/p&gt;

&lt;p&gt;I’ll also leave as homework for you the task of insisting that &lt;code class=&quot;highlighter-rouge&quot;&gt;i_ce&lt;/code&gt; is
true at least one of every eight clocks cycles.  How many induction steps will
that take to succeed?&lt;/p&gt;

&lt;p&gt;I like this example, because it does a good job fleshing out how the
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Mathematical_induction&quot;&gt;induction&lt;/a&gt; proof
works.&lt;/p&gt;

&lt;p&gt;Reality turns out to be very similar to this example, although it never looks
as simple.  In most of the designs I’ve worked with, there’s always been some
amount of state that I can’t quite capture with a proper &lt;code class=&quot;highlighter-rouge&quot;&gt;assert&lt;/code&gt; statement.
By using a longer
&lt;a href=&quot;https://en.wikipedia.org/wiki/Mathematical_induction&quot;&gt;induction&lt;/a&gt;
length, though, I can often force the state within my designs to flush itself.&lt;/p&gt;

&lt;p&gt;Even this doesn’t always work.&lt;/p&gt;

&lt;p&gt;You may remember &lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;my discussion of the formal
properties&lt;/a&gt;
of a &lt;a href=&quot;/doc/wbspec_b4.pdf&quot;&gt;wishbone
bus&lt;/a&gt;.  Nothing within &lt;a href=&quot;/doc/wbspec_b4.pdf&quot;&gt;the
specification&lt;/a&gt;
forces a slave to drop its &lt;code class=&quot;highlighter-rouge&quot;&gt;STALL&lt;/code&gt; output to accept a new request within a
given number of cycles.  Likewise, nothing within the specification forces
a slave to respond to the request by raising the &lt;code class=&quot;highlighter-rouge&quot;&gt;ACK&lt;/code&gt; signal within a
given number of clock cycles.  This creates a possibility where there may
be some amount of hidden state.  In order to deal with that possibility,
just like we forced &lt;code class=&quot;highlighter-rouge&quot;&gt;i_ce&lt;/code&gt; to be high at least one in &lt;code class=&quot;highlighter-rouge&quot;&gt;N&lt;/code&gt; clock cycles, &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/ex/fwb_master.v&quot;&gt;I
would force&lt;/a&gt;
the stall line, &lt;code class=&quot;highlighter-rouge&quot;&gt;STALL&lt;/code&gt;, to be dropped if it was ever asserted for too long.
In a similar fashion, &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/ex/fwb_slave.v&quot;&gt;I would
prevent&lt;/a&gt;
the slave from waiting too many clock cycles before acknowledging a request.&lt;/p&gt;

&lt;h2 id=&quot;other-approaches&quot;&gt;Other Approaches&lt;/h2&gt;

&lt;p&gt;If you have a chance to try some other formal engines, you may find they
work better in this example.
For example, the pdr engine,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt; 
[engines]
abc pdr&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;a href=&quot;https://arieg.bitbucket.io/avy&quot;&gt;avy&lt;/a&gt;,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt; 
[engines]
aiger avy&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;and &lt;a href=&quot;https://bitbucket.org/sterin/super_prove_build&quot;&gt;suprove&lt;/a&gt;&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt; 
[engines]
aiger suprove&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;don’t seem to struggle with this problem.&lt;/p&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Mathematical_induction&quot;&gt;Induction&lt;/a&gt;
may be the more difficult step of using
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal methods&lt;/a&gt;.
It need not be, but you need to understand how it works in order to understand
the reasons while it might fail.  The
&lt;a href=&quot;/examples/kitest.v&quot;&gt;example above&lt;/a&gt; is, in my estimation,
simple enough to show the difficulties with
&lt;a href=&quot;https://en.wikipedia.org/wiki/Mathematical_induction&quot;&gt;induction&lt;/a&gt;.
If you understand the details of
&lt;a href=&quot;/examples/kitest.v&quot;&gt;this example&lt;/a&gt;,
this example, you should be ready to fully formally prove
your own designs.&lt;/p&gt;
&lt;hr /&gt;&lt;p&gt;&lt;em&gt;And thine house and thy kingdom shall be established for ever before thee: thy throne shall be established for ever. (2Sam 7:16)&lt;/em&gt;</description>
        <pubDate>Sat, 10 Mar 2018 00:00:00 -0500</pubDate>
        <link>http://zipcpu.com/blog/2018/03/10/induction-exercise.html</link>
        <guid isPermaLink="true">http://zipcpu.com/blog/2018/03/10/induction-exercise.html</guid>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>Want to use ZBasic?  Let&#39;s have some fun--no actual FPGA required!</title>
        <description>&lt;p&gt;Now that
&lt;a href=&quot;/zipcpu/2018/01/31/cpu-build.html&quot;&gt;you’ve seen&lt;/a&gt; the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; by itself, and now that &lt;a href=&quot;/zipcpu/2018/01/31/cpu-build.html&quot;&gt;you’ve
built its tool chain&lt;/a&gt;,
let’s look at together at what you can do with the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
as part of a larger design:
&lt;a href=&quot;https://github.com/ZipCPU/zbasic&quot;&gt;ZBasic&lt;/a&gt;.
Today, I’d like to show you how to run the
&lt;a href=&quot;https://github.com/ZipCPU/zbasic&quot;&gt;ZBasic&lt;/a&gt;
design within a
&lt;a href=&quot;https://www.veripool.org/wiki/verilator&quot;&gt;Verilator&lt;/a&gt;-based
simulation environment–one that simulates
a &lt;a href=&quot;https://www.opencores.org/project,wbqspiflash&quot;&gt;QSPI flash&lt;/a&gt;, a
&lt;a href=&quot;https://github.com/ZipCPU/wbuart32&quot;&gt;serial port&lt;/a&gt;, and even
(optionally) an
&lt;a href=&quot;https://github.com/ZipCPU/sdspi/blob/master/bench/cpp/sdspisim.cpp&quot;&gt;SD-Card&lt;/a&gt;.
If all goes well, we’ll run the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;’s
&lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/sw/board/cputest.c&quot;&gt;CPU-Test program&lt;/a&gt;,
and then even play
&lt;a href=&quot;https://github.com/ZipCPU/tttt&quot;&gt;4x4x4 Tic-tac-toe&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;But first, let’s start with a little history.&lt;/p&gt;

&lt;h2 id=&quot;why-zbasic&quot;&gt;Why ZBasic?&lt;/h2&gt;

&lt;p&gt;When I first started out with the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;,
my goal was to demonstrate it on a cheap hobbyist board.  After my first
development, on a &lt;a href=&quot;https://store.digilentinc.com&quot;&gt;Digilent&lt;/a&gt;
&lt;a href=&quot;https://store.digilentinc.com/basys-3-artix-7-fpga-trainer-board-recommended-for-introductory-users&quot;&gt;Basys-3&lt;/a&gt;,
I then built demonstrations for an
&lt;a href=&quot;http://www.xess.com&quot;&gt;Xess.com&lt;/a&gt;
&lt;a href=&quot;http://www.xess.com/shop/product/xula2-lx25&quot;&gt;XuLA2-LX25 board&lt;/a&gt;,
and then the
&lt;a href=&quot;https://store.digilentinc.com&quot;&gt;Digilent&lt;/a&gt;
&lt;a href=&quot;https://store.digilentinc.com/cmod-s6-breadboardable-spartan-6-fpga-module&quot;&gt;CMod S6&lt;/a&gt;, the
&lt;a href=&quot;https://store.digilentinc.com/arty-artix-7-fpga-development-board-for-makers-and-hobbyists&quot;&gt;Arty&lt;/a&gt;,
and most recently
&lt;a href=&quot;https://store.digilentinc.com/nexys-video-artix-7-fpga-trainer-board-for-multimedia-applications&quot;&gt;Nexys Video&lt;/a&gt;
boards.
You can still find most of these builds on-line in the
&lt;a href=&quot;https://github.com/ZipCPU/xulalx25soc&quot;&gt;XuLALX25SoC&lt;/a&gt;,
&lt;a href=&quot;https://github.com/ZipCPU/s6soc&quot;&gt;S6SoC&lt;/a&gt;,
&lt;a href=&quot;https://github.com/ZipCPU/openarty&quot;&gt;OpenArty&lt;/a&gt;, and
&lt;a href=&quot;https://github.com/ZipCPU/videozip&quot;&gt;VideoZip&lt;/a&gt; repositories.  Indeed, my
&lt;a href=&quot;https://github.com/ZipCPU&quot;&gt;main Github page&lt;/a&gt; still highlights the
&lt;a href=&quot;https://github.com/ZipCPU/openarty&quot;&gt;OpenArty&lt;/a&gt; project.
Many of these boards are peripheral rich, and even for those that aren’t I
purchased peripherals (mostly from
&lt;a href=&quot;https://store.digilentinc.com&quot;&gt;Digilent&lt;/a&gt;) to have something fun and new to
work with on each board.  I have found it to be a fun exercise to learn how
to build the RTL code to support a new peripheral and I would commend that
exercise to every RTL student.&lt;/p&gt;

&lt;p&gt;I then ran into the problem of supporting someone who didn’t have the
peripherals I had.  How could or should they use the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;,
if their hardware didn’t match the hardware of one of the demonstration designs?&lt;/p&gt;

&lt;p&gt;So, I backed up and took a look at all the designs I had.  Almost all of them
had some type of serial
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt;,
some amount of block RAM, and a serial port.
Why not then make a design that had &lt;em&gt;only&lt;/em&gt; these peripherals?&lt;/p&gt;

&lt;p&gt;That was, and still is, the purpose of the
&lt;a href=&quot;https://github.com/ZipCPU/zbasic&quot;&gt;ZBasic&lt;/a&gt;
design.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 1. ZBasic Components and Peripherals&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/zbasic-blok.svg&quot; alt=&quot;&quot; width=&quot;730&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Because &lt;a href=&quot;https://github.com/ZipCPU/zbasic&quot;&gt;the design&lt;/a&gt;
is intended to be generic, it has no
&lt;a href=&quot;https://en.wikipedia.org/wiki/Synchronous_dynamic_random-access_memory&quot;&gt;SDRAM&lt;/a&gt;,
nor any &lt;a href=&quot;https://en.wikipedia.org/wiki/DDR3_SDRAM&quot;&gt;DDR3 SDRAM&lt;/a&gt;,
nor any other type of external RAM chip.
These interfaces tend to be board specific, and I wanted
this distribution to be as basic and as simple as possible.  What that means,
though, is that the main
&lt;a href=&quot;https://github.com/ZipCPU/zbasic&quot;&gt;ZBasic&lt;/a&gt;
design requires 1MB of on-chip block RAM.  Well, “requires” is a harsh word,
what I mean to say is that the design as currently configured on
&lt;a href=&quot;https://github.com/ZipCPU/zbasic&quot;&gt;github&lt;/a&gt; will try to infer 1MB of block RAM.
While few chips have this much RAM, it allows the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;,
within the
&lt;a href=&quot;https://github.com/ZipCPU/zbasic&quot;&gt;ZBasic&lt;/a&gt;
design to have access to an abundance of RAM without worrying about the
interface to the RAM.  Even better, this amount of RAM can be easily
changed using
&lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt;,
by changing only one number in the
&lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt;,
&lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/auto-data/bkram.txt&quot;&gt;block RAM config
file&lt;/a&gt;
and then rebuilding the design (i.e. &lt;code class=&quot;highlighter-rouge&quot;&gt;make autodata&lt;/code&gt;).
If that’s not enough, by just adding your own user code and
&lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt;
configuration file, you can add whatever additional hardware to the
&lt;a href=&quot;https://github.com/ZipCPU/zbasic&quot;&gt;ZBasic&lt;/a&gt;
distribution you want–&lt;a href=&quot;https://en.wikipedia.org/wiki/Synchronous_dynamic_random-access_memory&quot;&gt;SDRAM&lt;/a&gt;s included.&lt;/p&gt;

&lt;p&gt;Okay, enough reminiscing, let’s discuss how to use the
&lt;a href=&quot;https://github.com/ZipCPU/zbasic&quot;&gt;ZBasic&lt;/a&gt;
design within a
&lt;a href=&quot;https://www.veripool.org/wiki/verilator&quot;&gt;Verilator&lt;/a&gt;-based
simulation.&lt;/p&gt;

&lt;h2 id=&quot;building-zbasic&quot;&gt;Building ZBasic&lt;/h2&gt;

&lt;p&gt;Your first task in using the
&lt;a href=&quot;https://github.com/ZipCPU/zbasic&quot;&gt;ZBasic&lt;/a&gt;
design will be &lt;a href=&quot;/zipcpu/2018/01/31/cpu-build.html&quot;&gt;building the
toolchain&lt;/a&gt;
for the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;:
&lt;a href=&quot;https://www.gnu.org/software/binutils&quot;&gt;binutils&lt;/a&gt;
&lt;a href=&quot;https://www.gcc.org&quot;&gt;GCC&lt;/a&gt;
and &lt;a href=&quot;https://sourceware.org/newlib&quot;&gt;newlib&lt;/a&gt;.
I’ll assume you’ve already done that, if not you’ll need to
&lt;a href=&quot;/zipcpu/2018/01/31/cpu-build.html&quot;&gt;back up a step&lt;/a&gt;.
I’m also going to assume that the toolchain is in your path, as we discussed
&lt;a href=&quot;/zipcpu/2018/01/31/cpu-build.html&quot;&gt;when building it&lt;/a&gt;.
The next step is to clone the
&lt;a href=&quot;https://github.com/ZipCPU/zbasic&quot;&gt;ZBasic&lt;/a&gt;
repository and build it.  Since this repository doesn’t include a copy of
&lt;a href=&quot;https://www.gcc.org&quot;&gt;GCC&lt;/a&gt;,
it’s fairly light and a straightforward clone will work.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;git clone https://github.com/ZipCPU/zbasic
&lt;span class=&quot;nb&quot;&gt;cd &lt;/span&gt;zbasic
make&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Voila!  You have a ready built
&lt;a href=&quot;https://www.veripool.org/wiki/verilator&quot;&gt;Verilator&lt;/a&gt;-based
project ready to run!  (Please create an issue on
&lt;a href=&quot;https://github.com/ZipCPU/zbasic&quot;&gt;Github&lt;/a&gt;
if you have problems, and this doesn’t work.)&lt;/p&gt;

&lt;p&gt;Shall we run our first test?  This test will require two windows, and a little
bit of timing to do right.  In your first window, go ahead an type the
following–but don’t hit return on that last line yet or you might miss some
of the simulation output.  This will run the main simulation “test-bench”
wrapper, and apply it to my (&lt;a href=&quot;/zipcpu/2018/01/31/cpu-build.html&quot;&gt;more
modern&lt;/a&gt;) &lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/sw/board/cputest.c&quot;&gt;CPU test
software&lt;/a&gt;–once
you hit return (don’t do it yet).&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span class=&quot;nb&quot;&gt;cd &lt;/span&gt;sim/verilated
./main_tb ../../sw/board/cputest&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;In your second window, type the following–but don’t hit return.  When you do
(eventually) hit return, this will connect you to the running
&lt;a href=&quot;https://github.com/ZipCPU/zbasic&quot;&gt;ZBasic&lt;/a&gt;
simulation.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;telnet localhost 8846&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Ok, now you can hit return in the first window and then the second.  You
should see the results of the &lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/sw/board/cputest.c&quot;&gt;CPU
test&lt;/a&gt;,
such as Fig 2 illustrates.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 2. ZBasic CPU Test Results&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/zbasic-cpu-test.png&quot; alt=&quot;&quot; width=&quot;563&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;If you had wanted, you could also turn on
&lt;a href=&quot;/blog/2017/07/31/vcd.html&quot;&gt;VCD file&lt;/a&gt;
&lt;a href=&quot;/blog/2017/06/21/looking-at-verilator.html&quot;&gt;generation&lt;/a&gt;
by using the &lt;code class=&quot;highlighter-rouge&quot;&gt;-d&lt;/code&gt; flag, and so trace every wire throughout the whole design as
it moves through this
&lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/sw/board/cputest.c&quot;&gt;CPU test&lt;/a&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;./main_tb -d ../../sw/board/cputest&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Be aware, however, there’s a reason this option is turned off by default: your
&lt;a href=&quot;/blog/2017/07/31/vcd.html&quot;&gt;VCD file&lt;/a&gt; could easily top 11GB.&lt;/p&gt;

&lt;p&gt;Alternatively, you could have just started the design on its own without
giving a program to the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;.
As the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
is configured within the
&lt;a href=&quot;https://github.com/ZipCPU/zbasic&quot;&gt;ZBasic&lt;/a&gt;
design, it starts up in a halted configuration.  (This is optional–it can be
configured to start immediately on power up–see the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/raw/master/doc/spec.pdf&quot;&gt;spec&lt;/a&gt;
for more details.)  If you give a program name as an argument, the
&lt;a href=&quot;/blog/2017/06/21/looking-at-verilator.html&quot;&gt;simulation wrapper&lt;/a&gt;
will load the program into memory and then clear the &lt;a href=&quot;/zipcpu/2017/08/25/hw-debugging.html&quot;&gt;halt bit from the
debugging interface&lt;/a&gt;.
On the other hand, if you give the simulation driver no program name,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;./main_tb&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;then you’ll need to load the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;’s
program into memory–just as you would need to do on actual
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
hardware.  This is done with the
&lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/sw/host/zipload.cpp&quot;&gt;zipload&lt;/a&gt;
program found in the
&lt;a href=&quot;https://github.com/ZipCPU/zbasic/tree/master/sw/board/&quot;&gt;sw/board&lt;/a&gt;
subdirectory.  We’ll also give this program the ‘-r’ switch, to indicate that
the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
should be started once the program is loaded into memory.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span class=&quot;nb&quot;&gt;cd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;path-to-zbasic]/sw/host
./zipload -r ../sw/board/cputest&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This does take a while, though, since we are first programming the &lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/sim/verilated/qspiflashsim.cpp&quot;&gt;simulated
flash&lt;/a&gt;
on board, and only then starting the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt;.  The
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt;
will then copy its machine code from
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt;,
to RAM, and run.&lt;/p&gt;

&lt;p&gt;There you have it!  You’ve just run your first
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
program in a (nearly)
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
representative environment.&lt;/p&gt;

&lt;h2 id=&quot;playing-tic-tac-toe&quot;&gt;Playing Tic-Tac-Toe&lt;/h2&gt;

&lt;p&gt;Ok, so you’ve run a
&lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/sw/board/cputest.c&quot;&gt;CPU test&lt;/a&gt;.
I know, &lt;strong&gt;BORING&lt;/strong&gt;!  So let’s try and have a little more fun.  Let’s now
play &lt;a href=&quot;https://github.com/ZipCPU/tttt&quot;&gt;4x4x4 tic-tac-toe&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Unlike the
&lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/sw/board/cputest.c&quot;&gt;CPU test&lt;/a&gt;,
which &lt;em&gt;only&lt;/em&gt; tests the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt; itself,
&lt;a href=&quot;https://github.com/ZipCPU/tttt&quot;&gt;4x4x4 tic-tac-toe&lt;/a&gt;
uses the
&lt;a href=&quot;https://en.wikipedia.org/wiki/C_standard_library&quot;&gt;C-library&lt;/a&gt;
as well, with such typical library system calls as &lt;code class=&quot;highlighter-rouge&quot;&gt;printf&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;fgets&lt;/code&gt;.
These calls get routed, via a &lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/sw/zlib/syscalls.c&quot;&gt;board specific glue
file&lt;/a&gt;
to the
&lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/sim/verilated/dbluartsim.cpp&quot;&gt;simulated serial port&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;To try this out, change directory into the &lt;code class=&quot;highlighter-rouge&quot;&gt;sw/board&lt;/code&gt; directory, and build
&lt;code class=&quot;highlighter-rouge&quot;&gt;tttt&lt;/code&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span class=&quot;nb&quot;&gt;cd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;path-to-zbasic]/sw/board
make tttt&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;If you get errors, relax.  The “make” command won’t build
&lt;a href=&quot;https://github.com/ZipCPU/tttt&quot;&gt;tttt (4x4x4 tic-tac-toe)&lt;/a&gt;
successfully yet, but it should clone
&lt;a href=&quot;https://github.com/ZipCPU/tttt&quot;&gt;tttt&lt;/a&gt; as a submodule into a subdirectory of the
&lt;a href=&quot;https://github.com/ZipCPU/zbasic/tree/master/sw/board&quot;&gt;sw/board&lt;/a&gt;
directory.&lt;/p&gt;

&lt;p&gt;If it doesn’t clone
&lt;a href=&quot;https://github.com/ZipCPU/tttt&quot;&gt;tttt&lt;/a&gt; (I’ve had mixed success with git
submodules so far–all probably due to a problem lying somewhere between my
keyboard and my chair …), feel free to clone
&lt;a href=&quot;https://github.com/ZipCPU/tttt&quot;&gt;tttt&lt;/a&gt;
right there in that directory.&lt;/p&gt;

&lt;p&gt;Once you have it cloned, you’ll need to adjust a couple of lines within the
&lt;a href=&quot;https://github.com/ZipCPU/tttt/blob/master/src/Makefile&quot;&gt;sw/board/tttt/src/Makefile&lt;/a&gt;
to tell
&lt;a href=&quot;https://github.com/ZipCPU/tttt&quot;&gt;tttt&lt;/a&gt; where the
&lt;a href=&quot;https://en.wikipedia.org/wiki/C_standard_library&quot;&gt;C-library&lt;/a&gt;
is.  Therefore, open the
&lt;a href=&quot;https://github.com/ZipCPU/tttt/blob/master/src/Makefile&quot;&gt;Makefile&lt;/a&gt;
in your favorite editor and replace the lines,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-make&quot; data-lang=&quot;make&quot;&gt;&lt;span class=&quot;err&quot;&gt;ifeq&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;($(ARCH),&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;zip)&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;XLIBD&lt;/span&gt;    &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; ../../branch8b/sw/zlib
&lt;span class=&quot;nv&quot;&gt;XLIBS&lt;/span&gt;    &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; -L&lt;span class=&quot;nv&quot;&gt;$(XLIBD)&lt;/span&gt; -Wl,--start-group -Wl,--Map&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;zip-tttt.map -larty
&lt;span class=&quot;nv&quot;&gt;LDSCRIPT&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$(XLIBD)&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;/../board/arty.ld&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;with these lines,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-make&quot; data-lang=&quot;make&quot;&gt;&lt;span class=&quot;err&quot;&gt;ifeq&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;($(ARCH),&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;zip)&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;XLIBD&lt;/span&gt;    &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; ../../../zlib
&lt;span class=&quot;nv&quot;&gt;XLIBS&lt;/span&gt;    &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; -L&lt;span class=&quot;nv&quot;&gt;$(XLIBD)&lt;/span&gt; -Wl,--start-group -Wl,--Map&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;zip-tttt.map -lzbasic -lc
&lt;span class=&quot;nv&quot;&gt;LDSCRIPT&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$(XLIBD)&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;/../board/board.ld&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;At this point, you should just be able to build
&lt;a href=&quot;https://github.com/ZipCPU/tttt&quot;&gt;tttt&lt;/a&gt;
without further ado.  To do this, stay in the
&lt;a href=&quot;https://github.com/ZipCPU/zbasic/tree/master/sw/board&quot;&gt;sw/board&lt;/a&gt; directory
of the &lt;a href=&quot;https://github.com/ZipCPU/zbasic&quot;&gt;ZBasic&lt;/a&gt; project and type:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;make tttt&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This will make certain the cross-compiler environment variables are properly
set to build
&lt;a href=&quot;https://github.com/ZipCPU/tttt&quot;&gt;tttt&lt;/a&gt;
for the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;.
(If you had instead cd’d into &lt;code class=&quot;highlighter-rouge&quot;&gt;tttt&lt;/code&gt; and issued a &lt;code class=&quot;highlighter-rouge&quot;&gt;make&lt;/code&gt; command, it would
build &lt;code class=&quot;highlighter-rouge&quot;&gt;tttt&lt;/code&gt; for your local/host architecture.)&lt;/p&gt;

&lt;p&gt;Now we can play.  Ready?&lt;/p&gt;

&lt;p&gt;As before, we’ll type in the command to start the simulator in one window,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span class=&quot;nb&quot;&gt;cd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;path-to-zbasic]/sim/verilated
./main_tb ../../sw/board/tttt/src/zip-tttt&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;and connect to the simulated serial port from another window,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;telnet localhost 8846&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;When you hit return on the two (in sequence), the &lt;code class=&quot;highlighter-rouge&quot;&gt;telnet&lt;/code&gt; window will show
the following:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;Trying 127.0.0.1...
Connected to localhost.
Escape character is &#39;^]&#39;.

Welcome to 4x4x4 Tic-Tac-Toe

The goal of this game is to get 4 pieces in a row.  The board is three
dimensional, even though it will be displayed on a terminal screen.  Imagine
instead of seeing four 4x4 boards side by side, that these boards are
actually standing on top of each other.  A winning four in a row can exist
on any of the 4x4 levels.  A winning four in a row can also cross through
all levels.  Diagonals are valid, as are diagonal diagonals.

To specify your move, type in a string of three numbers each in the range of
1-4.  The first two numbers describe where you wish to move within one 4x4
board, where the first number is the position counting left to right and the
second number is the position counting from top down.  The last number is
which 4x4 board you wish to move to, counting from the 4x4 on the left to
the right

Current Board: (Empty)
----  ----  ----  ----  
----  ----  ----  ----  
----  ----  ----  ----  
----  ----  ----  ----  

Your move : &lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;You should be able to just type your move in as a series of three numbers,
each 1-4, as in &lt;code class=&quot;highlighter-rouge&quot;&gt;1 1 1&lt;/code&gt;.  Have fun!&lt;/p&gt;

&lt;p&gt;Be careful, although the computer isn’t unbeatable, he does play a pretty
mean game!&lt;/p&gt;

&lt;h2 id=&quot;homework&quot;&gt;Homework&lt;/h2&gt;

&lt;p&gt;Care for some
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;
homework?  Here’s a fascinating test you can try with the
&lt;a href=&quot;https://github.com/ZipCPU/zbasic&quot;&gt;ZBasic&lt;/a&gt;
distribution, one that will help to illustrate how important having a
hardware memory copy capability is.&lt;/p&gt;

&lt;p&gt;The glue logic supporting the
&lt;a href=&quot;https://en.wikipedia.org/wiki/C_standard_library&quot;&gt;C-library&lt;/a&gt;
includes a file called
&lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/sw/zlib/crt0.c&quot;&gt;crt0.c&lt;/a&gt;.
For most
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;’s this is an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Assembly_language&quot;&gt;assembly language&lt;/a&gt;
file called crt0.s.  Not for the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;.  For the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;,
this file is written in C.  It contains two routines: &lt;code class=&quot;highlighter-rouge&quot;&gt;_start&lt;/code&gt; and
&lt;code class=&quot;highlighter-rouge&quot;&gt;_bootloader&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The first routine, &lt;code class=&quot;highlighter-rouge&quot;&gt;_start&lt;/code&gt; starts the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
by setting the stack pointer to the end of memory, and then jumping to a
function called &lt;code class=&quot;highlighter-rouge&quot;&gt;_bootloader&lt;/code&gt;.  This is really an
&lt;a href=&quot;/zipcpu/2018/01/01/zipcpu-isa.html&quot;&gt;assembly language&lt;/a&gt;
routine with a thin veneer of a C wrapper, but it’s placed within the
&lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/sw/zlib/crt0.c&quot;&gt;crt0.c&lt;/a&gt;
file anyway.  When you strip away the cruft, it basicaly reads as,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-asm&quot; data-lang=&quot;asm&quot;&gt;_start:		; Here&#39;s the global ZipCPU entry point upon reset/reboot
	LDI	_top_of_stack,SP	; Set up our supervisor stack ptr
	MOV	_kernel_is_dead(PC),uPC	; Set user PC pointer to somewhere valid
	JSR	_bootloader	; JSR to the bootloader routine
	OR	0x4000,CC	; Clear the data cache
        //
	CLR	R1		; argc = 0
	MOV	_argv(PC),R2	; argv = &amp;amp;0
	LDI	__env,R3	; env = NULL
	JSR	main		; Call the user main() function
        //
_graceful_kernel_exit:		; Halt on any return from main--gracefully
	JSR	exit		; Call the _exit as part of exiting
_hw_shutdown:
	NEXIT	R1		; If in simulation, call an exit function
_kernel_is_dead:		; Halt the CPU\n&quot;
	HALT			;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The second routine within
&lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/sw/zlib/crt0.c&quot;&gt;this file&lt;/a&gt;
is the &lt;code class=&quot;highlighter-rouge&quot;&gt;_bootloader&lt;/code&gt; routine that is called from the &lt;code class=&quot;highlighter-rouge&quot;&gt;_start&lt;/code&gt; function above.
This is the routine I’d like to demonstrate for this homework lesson.&lt;/p&gt;

&lt;p&gt;The &lt;code class=&quot;highlighter-rouge&quot;&gt;_bootloader&lt;/code&gt; function itself is really nothing more than a series of
memory copy routines.  These are based around a couple of assumptions.  First,
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt;
is non-volatile (i.e. like a ROM) and so upon startup instructions can
be found there.  The second assumption is that the block RAM is faster than
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt;.
Hence, we want to move our instructions (and data) from
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt;
into block RAM before starting any program.&lt;/p&gt;

&lt;p&gt;First, the &lt;code class=&quot;highlighter-rouge&quot;&gt;_bootloader&lt;/code&gt; copies memory from the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt;
into block RAM.  This section is framed by an
&lt;code class=&quot;highlighter-rouge&quot;&gt;#ifdef _BOARD_HAS_KERNEL_SPACE&lt;/code&gt;,  so that any
high priority (kernel) functions would be or could be placed into block RAM.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;	&lt;span class=&quot;nf&quot;&gt;_booloader&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;// ...
&lt;/span&gt;
&lt;span class=&quot;cp&quot;&gt;#ifdef  _BOARD_HAS_KERNEL_SPACE
&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;rdp&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_kernel_image_start&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;wrp&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_bkram&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_kernel_image_end&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_kernel_image_start&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;do&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
			&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;wrp&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rdp&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;wrp&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_kernel_image_end&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_kernel_image_end&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_sdram&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;wrp&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_sdram&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;cp&quot;&gt;#else
&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;rdp&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_ram_image_start&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;wrp&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_ram&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;cp&quot;&gt;#endif&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Second, the bootloader copies from
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Synchronous_dynamic_random-access_memory&quot;&gt;SDRAM&lt;/a&gt;
into any
&lt;a href=&quot;https://en.wikipedia.org/wiki/Synchronous_dynamic_random-access_memory&quot;&gt;SDRAM&lt;/a&gt;
the board might have,
as defined by the &lt;code class=&quot;highlighter-rouge&quot;&gt;_sdram&lt;/code&gt; pointer.  Since
&lt;a href=&quot;https://github.com/ZipCPU/zbasic&quot;&gt;ZBasic&lt;/a&gt;
doesn’t have any
&lt;a href=&quot;https://en.wikipedia.org/wiki/Synchronous_dynamic_random-access_memory&quot;&gt;SDRAM&lt;/a&gt;,
this second memory copy ends up continuing the write into block RAM
instead.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;        &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;wrp&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_ram_image_end&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
		&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;wrp&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rdp&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The third section of memory is the BSS section.  This is a memory section
whose initial contents are all zeros.  The &lt;code class=&quot;highlighter-rouge&quot;&gt;_bootloader&lt;/code&gt; fulfills this
commitment by writing zeros to all of the memory location within this
section.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;	&lt;span class=&quot;c1&quot;&gt;// ...
&lt;/span&gt;	&lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;wrp&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_bss_image_end&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
		&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;wrp&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;However, if you look inside the
&lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/sw/zlib/crt0.c&quot;&gt;crt0.c&lt;/a&gt;
file, you’ll actually see two choices
for how to handle these memory copies.  The first choice is applied if
&lt;code class=&quot;highlighter-rouge&quot;&gt;USE_DMA&lt;/code&gt; is defined.  This is set earlier in the file to be true only if
&lt;code class=&quot;highlighter-rouge&quot;&gt;_HAVE_ZIPSYS_DMA&lt;/code&gt; is defined–something that comes from the
&lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/rtl/cpu/cpudefs.v&quot;&gt;cpudefs.v&lt;/a&gt;
configuration file.&lt;/p&gt;

&lt;p&gt;For this homework assignment, turn on tracing with the &lt;code class=&quot;highlighter-rouge&quot;&gt;-d&lt;/code&gt; flag (you do have
a rough 4GB available, right?) and run the
&lt;a href=&quot;https://github.com/ZipCPU/tttt&quot;&gt;4x4x4 tic-tac-toe program (tttt)&lt;/a&gt;
again.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span class=&quot;nb&quot;&gt;cd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;path-to-zbasic]/sim/verilated
./main_tb -d ../../sw/board/tttt/src/zip-tttt&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;To keep it from taking up too much room on your
hard-drive, kill it as soon as the game instructions start coming up (i.e.
type Ctrl-C on the screen where you typed &lt;code class=&quot;highlighter-rouge&quot;&gt;main_tb -d ...&lt;/code&gt;).
Copy the &lt;a href=&quot;/blog/2017/07/31/vcd.html&quot;&gt;trace file&lt;/a&gt;
from &lt;code class=&quot;highlighter-rouge&quot;&gt;trace.vcd&lt;/code&gt; to &lt;code class=&quot;highlighter-rouge&quot;&gt;with-dma.vcd&lt;/code&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;mv trace.vcd with-dma.vcd&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Then comment the &lt;code class=&quot;highlighter-rouge&quot;&gt;USE_DMA&lt;/code&gt; define in
&lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/sw/zlib/crt0.c&quot;&gt;crt0.c&lt;/a&gt; by
placing two &lt;code class=&quot;highlighter-rouge&quot;&gt;//&lt;/code&gt;s at the beginning of the line,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span class=&quot;o&quot;&gt;//&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;define&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;USE_DMA&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;You can then rebuild in
&lt;a href=&quot;https://github.com/ZipCPU/zbasic/tree/master/sw/zlib/&quot;&gt;sw/zlib&lt;/a&gt; by typing
&lt;code class=&quot;highlighter-rouge&quot;&gt;make&lt;/code&gt; in that directory, but you’ll need to do a &lt;code class=&quot;highlighter-rouge&quot;&gt;make clean&lt;/code&gt; in
&lt;a href=&quot;https://github.com/ZipCPU/zbasic/tree/master/sw/board/&quot;&gt;sw/board&lt;/a&gt;
before you can re-issue &lt;code class=&quot;highlighter-rouge&quot;&gt;make&lt;/code&gt; again there.  Once done, you can issue a
&lt;code class=&quot;highlighter-rouge&quot;&gt;make&lt;/code&gt; in
&lt;a href=&quot;https://github.com/ZipCPU/zbasic/tree/master/sw/board/&quot;&gt;sw/board&lt;/a&gt;
and then &lt;code class=&quot;highlighter-rouge&quot;&gt;make tttt&lt;/code&gt;.  This will propagate this change throughout the
&lt;a href=&quot;https://en.wikipedia.org/wiki/C_standard_library&quot;&gt;C-library&lt;/a&gt;
and into the application software.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span class=&quot;nb&quot;&gt;cd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;path-to-zbasic]/sw/zlib
make
&lt;span class=&quot;nb&quot;&gt;cd&lt;/span&gt; ../sw/board
make clean
make
make tttt&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Now run the simulator again, still with the -d option.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span class=&quot;nb&quot;&gt;cd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;path-to-zbasic]/sim/verilated
main_tb -d ../../sw/board/tttt/src/zip-tttt&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Kill it (Ctrl-C) as before when the characters start getting printed to the
terminal.  Then rename the &lt;code class=&quot;highlighter-rouge&quot;&gt;trace.vcd&lt;/code&gt; file to be &lt;code class=&quot;highlighter-rouge&quot;&gt;without-dma.vcd&lt;/code&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;mv trace.vcd without-dma.vcd&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Now that you have two comparison files, pull them both up in
&lt;a href=&quot;https://gtkwave.sourceforge.net&quot;&gt;GtkWave&lt;/a&gt;.
Let’s look specifically at the
serial output line &lt;code class=&quot;highlighter-rouge&quot;&gt;o_wbu_uart_tx&lt;/code&gt; from the top level, and then from
within the top level, the
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;wishbone strobe
line &lt;code class=&quot;highlighter-rouge&quot;&gt;wb_stb&lt;/code&gt;&lt;/a&gt;, the
&lt;code class=&quot;highlighter-rouge&quot;&gt;flash_sel&lt;/code&gt; (&lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt;
select) line, and then &lt;code class=&quot;highlighter-rouge&quot;&gt;bkram_sel&lt;/code&gt; (block RAM select)
lines.  As you may recall, &lt;code class=&quot;highlighter-rouge&quot;&gt;wb_stb&lt;/code&gt; will be true anytime a request is being
made across the bus.  The other two lines indicate when the address
associated with this request is either referencing the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt;
or the block RAM.&lt;/p&gt;

&lt;p&gt;See a difference?&lt;/p&gt;

&lt;p&gt;Here’s my figure for running without the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/wbdmac.v&quot;&gt;DMA&lt;/a&gt;,&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 3. ZBasic Bootloader without DMA&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/zbasic-wodma.png&quot; alt=&quot;&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;and again for running with the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/wbdmac.v&quot;&gt;DMA&lt;/a&gt;
controller,&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 4. ZBasic Components and Peripherals&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/zbasic-wdma.png&quot; alt=&quot;&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;If you look at the far right, when &lt;code class=&quot;highlighter-rouge&quot;&gt;o_wbu_uart_tx&lt;/code&gt; starts toggling that’s when
the first characters of the game are being sent to the serial port.  This
doesn’t happen until the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;_bootloader&lt;/code&gt; has finished.  Here, you can see that it takes about nine
seconds to copy everything from
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt;
when using the &lt;code class=&quot;highlighter-rouge&quot;&gt;_bootloader&lt;/code&gt;, whereas it
takes over twenty seconds without!  You can also see a big difference in the
&lt;code class=&quot;highlighter-rouge&quot;&gt;flash_sel&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;bkram_sel&lt;/code&gt; lines.  What’s going on there?&lt;/p&gt;

&lt;p&gt;Let’s drill one level deeper and look at what’s going on by zooming in.
Let’s also add the &lt;code class=&quot;highlighter-rouge&quot;&gt;flash_ack&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;bkram_ack&lt;/code&gt; lines–there are the
wishbone acknowledgement
lines from these two peripherals, and indicate when a request has been
fulfilled.&lt;/p&gt;

&lt;p&gt;You can see the
&lt;a href=&quot;/blog/2017/07/31/vcd.html&quot;&gt;trace&lt;/a&gt;
without
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/wbdmac.v&quot;&gt;DMA&lt;/a&gt;,
in Fig 5, below.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 5. Zooming in on the ZBasic Bootloader without DMA&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/zbasic-wodma-zoom.png&quot; alt=&quot;&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;What’s not as readily apparent in this
&lt;a href=&quot;/blog/2017/07/31/vcd.html&quot;&gt;trace&lt;/a&gt;
is the context–it begins in the middle of a transaction.  A value has
already been requested from the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt;
controller by the time my screen capture starts.  Once the
&lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/rtl/wbqspiflash.v&quot;&gt;flash controller&lt;/a&gt;
acknowledges the transaction, that is when &lt;code class=&quot;highlighter-rouge&quot;&gt;flash_ack&lt;/code&gt; goes high, the data
becomes available to the &lt;code class=&quot;highlighter-rouge&quot;&gt;_bootloader&lt;/code&gt;,
and it immediately turns around and writes to the block RAM.  Since the
block RAM is quite fast, it acknowledges its transaction almost immediately.
(Remember, transaction requests only take place when &lt;code class=&quot;highlighter-rouge&quot;&gt;wb_stb&lt;/code&gt; is high, and
so Fig 6 only shows two transaction requests.)  The
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
then issues a read request of the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt;
and … everything stalls again waiting for the &lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/rtl/wbqspiflash.v&quot;&gt;flash
controller&lt;/a&gt;’s
acknowledgement.&lt;/p&gt;

&lt;p&gt;This is &lt;em&gt;very&lt;/em&gt; different from what happens when the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/wbdmac.v&quot;&gt;DMA&lt;/a&gt;,
is turned on.  For that case, you can see what happens when
in Fig 6 below.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 6. Zooming in on the ZBasic Bootloader, with the DMA in use&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/zbasic-wdma-zoom.png&quot; alt=&quot;&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;In this case, the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/wbdmac.v&quot;&gt;DMA&lt;/a&gt;
reads multiple items from the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt;
in a back to back
fashion–you can see all of the acknowledgement’s in the &lt;code class=&quot;highlighter-rouge&quot;&gt;flash_ack&lt;/code&gt; line
in Fig 6.  During this time, the block RAM is idle.  Once the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/wbdmac.v&quot;&gt;DMA&lt;/a&gt;
has finished
reading a rough 1k words from the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt;,
it then bursts these to the block
RAM.  Look at the &lt;code class=&quot;highlighter-rouge&quot;&gt;wb_stb&lt;/code&gt; line to see this–it’s nearly a constant &lt;code class=&quot;highlighter-rouge&quot;&gt;ON&lt;/code&gt;
signal, indicating that one request after another is being made.  In a
similar fashion, but unlike the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/rtl/wbqspiflash.v&quot;&gt;controller&lt;/a&gt;’s
response, the block RAM’s acknowledgment signal is also a constant high–since
the block RAM can respond to one request per clock.
As a result, this portion of the copy goes by very quickly.&lt;/p&gt;

&lt;p&gt;Given this information, would you rather copy your data using the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/wbdmac.v&quot;&gt;DMA&lt;/a&gt;,
or a tight loop within the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;?&lt;/p&gt;

&lt;h2 id=&quot;how-do-i-change-the-amount-of-block-ram&quot;&gt;How do I change the amount of block RAM?&lt;/h2&gt;

&lt;p&gt;Since I know this is going to come up, let me show you how easy it is to
change the amount of block RAM in this device.&lt;/p&gt;

&lt;p&gt;First, look in the
&lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt; &lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/auto-data/bkram.txt&quot;&gt;block ram configuration
file&lt;/a&gt;.
Within that file, find the line,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;@$LGMEMSZ=20&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This line defines a tag, &lt;code class=&quot;highlighter-rouge&quot;&gt;@LGMEMSZ&lt;/code&gt;, specifies that it is a numerical
tag with the &lt;code class=&quot;highlighter-rouge&quot;&gt;@$&lt;/code&gt; prefix, and then gives it the value of &lt;code class=&quot;highlighter-rouge&quot;&gt;20&lt;/code&gt;.
This tag is used to specify that the log, based two, of the block RAM
memory size is twenty–meaning it should have 1MB, or &lt;code class=&quot;highlighter-rouge&quot;&gt;2^20&lt;/code&gt; bytes, of
block RAM.  The key itself is unique to this
&lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/auto-data/bkram.txt&quot;&gt;block ram configuration
file&lt;/a&gt;,
so you aren’t likely to find it elsewhere.  It basically defines a local
variable within an &lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt; context.
However, with a bit of math and some substitution (remember, 
&lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt; is primarily a
copy/paste utility with a calculator and address assignment built
in), this number becomes the amount of block RAM called for in the
system design.&lt;/p&gt;

&lt;p&gt;You can change this one number, and then run &lt;code class=&quot;highlighter-rouge&quot;&gt;make autodata&lt;/code&gt; from the main
directory (assuming you have
&lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt; installed and in your path),
and the design will immediately be reconfigured for the new memory size.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span class=&quot;nb&quot;&gt;cd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;path-to-zbasic]/
make autodata&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Yes, you’ll still need to run &lt;code class=&quot;highlighter-rouge&quot;&gt;make&lt;/code&gt; from the main directory again once
you’ve done this,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;make&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;so that this newly configured design has a chance to build.&lt;/p&gt;

&lt;p&gt;What changes?&lt;/p&gt;

&lt;p&gt;Well, first, the &lt;code class=&quot;highlighter-rouge&quot;&gt;@MAIN.INSERT&lt;/code&gt; tag that same
&lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/auto-data/bkram.txt&quot;&gt;bkram.txt&lt;/a&gt;
file is used to tell
&lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt; what to place into your
&lt;a href=&quot;/blog/2017/10/05/autofpga-intro.html&quot;&gt;main.v&lt;/a&gt;
file.  In this case, it’s a reference to a
&lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/rtl/memdev.v&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;memdev&lt;/code&gt;&lt;/a&gt;
module which implements a block RAM device that is parameterized by its size.
&lt;code class=&quot;highlighter-rouge&quot;&gt;@THIS.LGMEMSZ&lt;/code&gt; is used to control this parameter.  It’s also used to
connect that design parameter to the number of address lines fed to this
component, and changing this size may cause the other peripherals on the bus
to be shuffled around to minimize the required bus logic.&lt;/p&gt;

&lt;p&gt;Second, all of the addresses will (may) be re-assigned as I just mentioned.
This includes more than just the block RAM.  These new addresses can be found
listed in the
&lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/sw/host/regdefs.h&quot;&gt;regdefs.h&lt;/a&gt;
and
&lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/sw/board/board.h&quot;&gt;board.h&lt;/a&gt;
files based upon the &lt;code class=&quot;highlighter-rouge&quot;&gt;@REGS.*&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;@BDEF.OSVAL&lt;/code&gt; tags.&lt;/p&gt;

&lt;p&gt;Third, the &lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/sw/board/board.ld&quot;&gt;linker definition
script&lt;/a&gt;
will have changed, which will adjust the
&lt;code class=&quot;highlighter-rouge&quot;&gt;_bkram&lt;/code&gt; pointer used by the &lt;code class=&quot;highlighter-rouge&quot;&gt;_bootloader&lt;/code&gt; we discussed above.&lt;/p&gt;

&lt;p&gt;Fourth, the &lt;code class=&quot;highlighter-rouge&quot;&gt;@SIM.LOAD&lt;/code&gt; tag defines the software necessary to load a program
into this memory, given the new location and length found in the updated
&lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/sw/host/regdefs.h&quot;&gt;regdefs.h&lt;/a&gt;
file.&lt;/p&gt;

&lt;p&gt;The result of all of this is that, following an
&lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt;
based reconfigure, all that is required is to rebuild the project and
we have a new amount of memory at a (potentially) different location.&lt;/p&gt;

&lt;h2 id=&quot;next-steps&quot;&gt;Next Steps&lt;/h2&gt;

&lt;p&gt;Now that you know how to run the
&lt;a href=&quot;https://github.com/ZipCPU/zbasic&quot;&gt;ZBasic&lt;/a&gt;
demonstration, the next step
will be to show how simple and easy it is to add a
&lt;a href=&quot;https://github.com/ZipCPU/wbpmic&quot;&gt;new component&lt;/a&gt;
using
&lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt;,
and then to demonstrate how we can integrate this component into our
&lt;a href=&quot;/blog/2017/06/21/looking-at-verilator.html&quot;&gt;simulation&lt;/a&gt;
and ultimately the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
design as a whole.&lt;/p&gt;

&lt;p&gt;My current plan is to do this with the
&lt;a href=&quot;https://github.com/ZipCPU/wbpmic&quot;&gt;WBPMIC&lt;/a&gt;
component.  This particular controller is designed to control a &lt;a href=&quot;http://store.digilentinc.com/pmod-mic3-mems-microphone-with-adjustable-gain&quot;&gt;MEMs audio
microphone&lt;/a&gt;
and &lt;a href=&quot;https://en.wikipedia.org/wiki/Analog-to-digital_converter&quot;&gt;A/D&lt;/a&gt;
sold by &lt;a href=&quot;https://store.digilentinc.com&quot;&gt;Digilent&lt;/a&gt;–their
“&lt;a href=&quot;http://store.digilentinc.com/pmod-mic3-mems-microphone-with-adjustable-gain&quot;&gt;PMod MIC3&lt;/a&gt;”.&lt;/p&gt;

&lt;p&gt;That will be our next step in this series, although there’s really a lot
of information we can come back to–such as how the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/wbdmac.v&quot;&gt;DMA controller&lt;/a&gt;
works in the first place.&lt;/p&gt;
&lt;hr /&gt;&lt;p&gt;&lt;em&gt;Wilt thou play with him as with a bird? or wilt thou bind him for thy maidens? (Job 41:5)&lt;/em&gt;</description>
        <pubDate>Mon, 12 Feb 2018 00:00:00 -0500</pubDate>
        <link>http://zipcpu.com/zipcpu/2018/02/12/zbasic-intro.html</link>
        <guid isPermaLink="true">http://zipcpu.com/zipcpu/2018/02/12/zbasic-intro.html</guid>
        
        
        <category>zipcpu</category>
        
      </item>
    
      <item>
        <title>Debugging a Cyclone-V</title>
        <description>&lt;p&gt;If you’ve read the description of &lt;a href=&quot;/about/gisselquist-technology.html&quot;&gt;Gisselquist
Technology&lt;/a&gt;,
you’ll remember that &lt;a href=&quot;/about/gisselquist-technology.html&quot;&gt;Gisselquist
Technology&lt;/a&gt;
is a services business.  I use
&lt;a href=&quot;http://zipcpu.com/&quot;&gt;this blog&lt;/a&gt;
and my
&lt;a href=&quot;https://github.com/ZipCPU&quot;&gt;demonstration IP cores&lt;/a&gt;
to help attract customers.  It also means that I don’t necessarily advertise
all of the IP I’ve built on my
&lt;a href=&quot;/projects.html&quot;&gt;projects page&lt;/a&gt;–since
I’m not selling IP but rather my time and abilities.  I prefer not to comment
about the customers I work with, or what their various requirements
are–that’s their business.  I just provide them with a service.&lt;/p&gt;

&lt;p&gt;However, a recent project I’ve been working on is worth commenting on from
the standpoint of how to avoid
&lt;a href=&quot;/blog/2017/05/19/fpga-hell.html&quot;&gt;FPGA Hell&lt;/a&gt;
in a somewhat unique environment: the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
+ &lt;a href=&quot;https://en.wikipedia.org/wiki/ARM_architecture&quot;&gt;ARM&lt;/a&gt;
environment.  This is probably all the more appropriate, as these
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
+ &lt;a href=&quot;https://en.wikipedia.org/wiki/ARM_architecture&quot;&gt;ARM&lt;/a&gt;
chips are becoming more and more popular.&lt;/p&gt;

&lt;p&gt;The project in question was a basic data acquisition system: control &lt;em&gt;N&lt;/em&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Analog-to-digital_converter&quot;&gt;A/D&lt;/a&gt;s
running at over a MHz in speed, and spit the results out over Ethernet.
To make this project work, we chose to use the
&lt;a href=&quot;http://www.terasic.com/cgi-bin/page/archive.pl?Language=English&amp;amp;No=1046&quot;&gt;DE10-Nano&lt;/a&gt;
as our processing device, shown below.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 1. A DE10-Nano board, shown without the A/Ds attached&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/de10-deskpic.jpg&quot; alt=&quot;Picture of a DE10-Nano FPGA board from Terasic&quot; width=&quot;768&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;This also marks my first experience with an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
+ &lt;a href=&quot;https://en.wikipedia.org/wiki/ARM_architecture&quot;&gt;ARM&lt;/a&gt;
type device, and what it takes to interface logic with an on-board
&lt;a href=&quot;https://en.wikipedia.org/wiki/ARM_architecture&quot;&gt;hard processor&lt;/a&gt;, and I
thought I might share with you some of my experiences and the
lessons I learned.&lt;/p&gt;

&lt;h2 id=&quot;general-project-structure&quot;&gt;General Project Structure&lt;/h2&gt;

&lt;p&gt;You can see the general structure of the project in Fig 2 below.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 2. Design Structure&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/de10-design.svg&quot; alt=&quot;&quot; width=&quot;400&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;In brief, the
&lt;a href=&quot;https://en.wikipedia.org/wiki/ARM_architecture&quot;&gt;ARM processor&lt;/a&gt;
has a number of buses available to it, within the chip, to communicate
over.  I chose the light-weight bus from the
&lt;a href=&quot;https://en.wikipedia.org/wiki/ARM_architecture&quot;&gt;ARM&lt;/a&gt;
to the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
for its simplicity–although I may revisit this decision later.  I then used
&lt;a href=&quot;https://www.altera.com/products/design-software/fpga-design/quartus-prime/features/qts-platform-designer.html&quot;&gt;Qsys&lt;/a&gt;
(now called the “&lt;a href=&quot;https://www.altera.com/products/design-software/fpga-design/quartus-prime/features/qts-platform-designer.html&quot;&gt;Platform Designer&lt;/a&gt;”
, although few tutorials have been updated since the name change) to
connect my application specific design component(s) to an
&lt;a href=&quot;https://www.altera.com/content/dam/altera-www/global/en_US/pdfs/literature/manual/mnl_avalon_spec.pdf&quot;&gt;Avalon&lt;/a&gt;
memory-mapped I/O bus.&lt;/p&gt;

&lt;p&gt;This brings me to my own part of the design.  For this application specific
portion, I bridged from the
&lt;a href=&quot;https://www.altera.com/content/dam/altera-www/global/en_US/pdfs/literature/manual/mnl_avalon_spec.pdf&quot;&gt;Avalon bus&lt;/a&gt;
to a
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;Wishbone (WB) bus&lt;/a&gt;
(all my legacy code was written for
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;WB&lt;/a&gt;),
and used &lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt;
to assemble my
design components together–assigning addresses and handling the bus
interconnect within my own portion of the design.&lt;/p&gt;

&lt;p&gt;This became my
“&lt;a href=&quot;/blog/2017/06/16/dbg-bus-forest.html&quot;&gt;debugging bus&lt;/a&gt;”
as well for finding bugs within my design.&lt;/p&gt;

&lt;p&gt;Further, the
&lt;a href=&quot;https://www.altera.com/products/design-software/fpga-design/quartus-prime/features/qts-platform-designer.html&quot;&gt;Platform Designer&lt;/a&gt;
output is a big black box that I needed to create a wrapper for, connecting
the
&lt;a href=&quot;https://en.wikipedia.org/wiki/ARM_architecture&quot;&gt;ARM processor&lt;/a&gt;
to the external system components–&lt;a href=&quot;https://en.wikipedia.org/wiki/DDR3_SDRAM&quot;&gt;DDR3
SDRAM&lt;/a&gt;,
&lt;a href=&quot;https://en.wikipedia.org/wiki/Gigabit_Ethernet&quot;&gt;GigE&lt;/a&gt;
network, etc.&lt;/p&gt;

&lt;h2 id=&quot;so-what-was-the-process-for-finding-bugs&quot;&gt;So what was the process for finding bugs?&lt;/h2&gt;

&lt;p&gt;My bug finding approach follows directly from &lt;a href=&quot;/blog/2017/06/23/my-dbg-philosophy.html&quot;&gt;my basic debugging
philosophy&lt;/a&gt;.
However, the
&lt;a href=&quot;/blog/2017/06/23/my-dbg-philosophy.html&quot;&gt;basic philosophy&lt;/a&gt;
really needs to be slightly updated, since I’ve started using
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal methods&lt;/a&gt;.
Basically, I followed the following steps:&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 3. Design Process&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/cyclonev-design.svg&quot; alt=&quot;Steps in design with Cyclone-V&quot; width=&quot;180&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;I wrote my design components and immediately “tested” them using the
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal methods&lt;/a&gt;
provided by
&lt;a href=&quot;http://www.clifford.at/yosys&quot;&gt;yosys-smtbmc&lt;/a&gt;
and the lint capabilities of
&lt;a href=&quot;https://veripool.org/wiki/verilator&quot;&gt;Verilator&lt;/a&gt;.
If any component didn’t pass muster from both of these tools, I
didn’t even try it on the board.&lt;/p&gt;

    &lt;p&gt;This worked well for the bottom or “leaf” nodes of my design tree.&lt;/p&gt;

    &lt;p&gt;I also applied this method to a single non-leaf node, one that included my
&lt;a href=&quot;/dsp/2017/11/10/delayw.html&quot;&gt;delay element&lt;/a&gt;
as a sub-component.
The purpose of this module was to segment the data into blocks, and to
calculate the best exponent that could be applied to all of the samples
in a given block.  The timing of this module was critical, but it wasn’t
simple to desk check–so the proof was important.  Indeed, the success
of the entire design depended upon this being done “right”.
However, after cutting the proof down as much as possible, it still
took a rough day of solid CPU computation to finish.  This was rare
among my proofs, as most completed within 5-20 minutes.  Still, I
needed the confidence of that formal verification proof and so I
“paid” that price.&lt;/p&gt;

    &lt;p&gt;Neither did I apply
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal methods&lt;/a&gt;
to all of the design components.  For example, one component contained
three parallel
&lt;a href=&quot;/blog/2017/07/29/fifo.html&quot;&gt;FIFO&lt;/a&gt;s closely
integrated together.  Another component contained the
entire signal processing chain (including the parallel
&lt;a href=&quot;/blog/2017/07/29/fifo.html&quot;&gt;FIFO&lt;/a&gt;s 
module).  Neither of these components were
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formally verified&lt;/a&gt;,
although I would’ve loved doing so–I just wasn’t certain I could manage
the complexity required to do so.  Hence these components were
desk-checked,
&lt;a href=&quot;/blog/2017/06/21/looking-at-verilator.html&quot;&gt;simulated&lt;/a&gt;,
and tested on the hardware itself but never
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formally verified&lt;/a&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;If the component passed
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal verification&lt;/a&gt;
and
&lt;a href=&quot;https://veripool.org/wiki/verilator&quot;&gt;Verilator&lt;/a&gt; linting, I’d
synthesize it and try it on the board.  If it failed on the board, I’d
add a
&lt;a href=&quot;/blog/2017/07/08/getting-started-with-wbscope.html&quot;&gt;wishbone scope&lt;/a&gt;
to see what was going on.  Since this was an
&lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt; based design, adding or
removing a &lt;a href=&quot;/blog/2017/07/08/getting-started-with-wbscope.html&quot;&gt;wishbone
scope&lt;/a&gt;
was &lt;em&gt;really&lt;/em&gt; easy to do.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;This left me stuck in
&lt;a href=&quot;/blog/2017/05/19/fpga-hell.html&quot;&gt;FPGA Hell&lt;/a&gt;
only twice, and never for very long.  First, I was stuck in
&lt;a href=&quot;/blog/2017/05/19/fpga-hell.html&quot;&gt;FPGA Hell&lt;/a&gt;
before I learned how to use the golden reference design
properly.  In these cases, the
&lt;a href=&quot;https://www.yoctoproject.org/product/angstrom-distribution&quot;&gt;Angstrom&lt;/a&gt;
Linux distribution I was using
would never get past the boot-loader.  Second, I would get stuck in
&lt;a href=&quot;/blog/2017/05/19/fpga-hell.html&quot;&gt;FPGA Hell&lt;/a&gt;
any time the system didn’t interact with the
&lt;a href=&quot;https://www.altera.com/content/dam/altera-www/global/en_US/pdfs/literature/manual/mnl_avalon_spec.pdf&quot;&gt;Avalon bus&lt;/a&gt;
properly.&lt;/p&gt;

    &lt;p&gt;In the second case, my
&lt;a href=&quot;https://veripool.org/wiki/verilator&quot;&gt;Verilator&lt;/a&gt;-based
&lt;a href=&quot;/blog/2017/06/21/looking-at-verilator.html&quot;&gt;simulation&lt;/a&gt;
rescued me nicely every time.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;No,  &lt;a href=&quot;/blog/2017/06/02/design-process.html&quot;&gt;I did not use any Verilog based test-benches&lt;/a&gt;.&lt;/p&gt;

    &lt;p&gt;After having gotten a taste of
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal methods&lt;/a&gt;,
I’m not sure I’d go back to any
&lt;a href=&quot;/blog/2017/06/02/design-process.html&quot;&gt;other approaches&lt;/a&gt;
if I didn’t need to.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;the-crazy-bug&quot;&gt;The Crazy Bug&lt;/h2&gt;

&lt;p&gt;Ok, so … I did come across a rather “Crazy Bug”.  You know, the kind that
goes down in your memory banks as one that &lt;em&gt;really&lt;/em&gt; stands out?  The one bug
in any project that takes you so long to find that you had to take notice
of it?  In my case, this bug took place across the interaction between the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
and the &lt;a href=&quot;https://en.wikipedia.org/wiki/ARM_architecture&quot;&gt;ARM&lt;/a&gt;
processor.&lt;/p&gt;

&lt;p&gt;For your sake, I’ll share what happened here, lest you get caught in
the same bug yourself.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig. 4. Basic Processing Steps&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/adc-copy-loop.svg&quot; alt=&quot;S/w outline&quot; width=&quot;180&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;After collecting samples from the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Analog-to-digital_converter&quot;&gt;A/D&lt;/a&gt;s,
those samples went through an initial signal processing chain.
Once that signal processing chain had finished working on the incoming
samples, those samples were placed into a
&lt;a href=&quot;/blog/2017/07/29/fifo.html&quot;&gt;FIFO&lt;/a&gt;.
When the software running on the
&lt;a href=&quot;https://en.wikipedia.org/wiki/ARM_architecture&quot;&gt;ARM&lt;/a&gt;
was ready, it would call the
&lt;a href=&quot;http://www.cplusplus.com/reference/cstring/memcpy/&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;memcpy()&lt;/code&gt;&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/C_standard_library&quot;&gt;C-library&lt;/a&gt; routine
to copy samples from the
&lt;a href=&quot;/blog/2017/07/29/fifo.html&quot;&gt;FIFO&lt;/a&gt;
to the user’s memory space.  These processed samples were then sent
to a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Network_socket&quot;&gt;socket&lt;/a&gt;
to be sent over
&lt;a href=&quot;https://en.wikipedia.org/wiki/Gigabit_Ethernet&quot;&gt;GigE&lt;/a&gt;
to a part of the system I had no control of.  To make this happen, the
&lt;a href=&quot;/blog/2017/07/29/fifo.html&quot;&gt;FIFO&lt;/a&gt;
was given the largest memory space I could afford, so that a vendor
optimized piece of code (i.e. the
&lt;a href=&quot;http://www.cplusplus.com/reference/cstring/memcpy/&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;memcpy()&lt;/code&gt;&lt;/a&gt;)
could just copy the memory from the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
to &lt;a href=&quot;https://en.wikipedia.org/wiki/Random-access_memory&quot;&gt;RAM&lt;/a&gt;.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig. 5. Memory Copy from FIFO to RAM&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/adc-memcpy.svg&quot; alt=&quot;MemCPY&quot; width=&quot;400&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;I’m sure the actual
&lt;a href=&quot;https://en.wikipedia.org/wiki/ARM_architecture&quot;&gt;ARM&lt;/a&gt;
&lt;a href=&quot;http://www.cplusplus.com/reference/cstring/memcpy/&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;memcpy()&lt;/code&gt;&lt;/a&gt;)
is a bit more complicated than the logic below, but the following is a basic
pseudocode outline of what the routine does:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;c1&quot;&gt;// Example memcpy
&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;	&lt;span class=&quot;nf&quot;&gt;memcpy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;size_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ln&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ln&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;ln&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Only … that’s not I the behavior I observed.&lt;/p&gt;

&lt;p&gt;Initially, all I knew was that the data coming out of the device was all
jumbled, and I couldn’t tell why.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig. 6. Counter Injection&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/counter-inject.svg&quot; alt=&quot;Injecting a counter following the A/Ds&quot; width=&quot;240&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;If you’ve never had to deal with a data acquisition process like this,
there’s one trick you need to have as part of your bag-of-tricks
to find stream-based processing bugs–the counter.  As shown in Fig 6 on the
right, the counter runs
along side the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Analog-to-digital_converter&quot;&gt;A/D&lt;/a&gt;
controller.  It increments with every sample.  A
user-configurable “switch” then selects whether the counter or the data is
sent down-stream.  If done right, you can then check the data values at
the end of your processing stream, and you can tell whether samples
were lost, corrupted, or worse–just by checking whether the ultimate
sample values still had the one-up relationship present with a counter.&lt;/p&gt;

&lt;p&gt;It was because this counter was not incrementing by one on every sample
that I knew I had a problem.&lt;/p&gt;

&lt;p&gt;So … I applied my
&lt;a href=&quot;/blog/2017/07/08/getting-started-with-wbscope.html&quot;&gt;scope&lt;/a&gt;
to the bus transaction.  My first thought was that I was somehow double
or triple stepping my
&lt;a href=&quot;/blog/2017/07/29/fifo.html&quot;&gt;FIFO&lt;/a&gt; on semi-random reads,
so I wanted to see what happened on a read from my
&lt;a href=&quot;/blog/2017/07/29/fifo.html&quot;&gt;FIFO&lt;/a&gt;.  Using this
&lt;a href=&quot;/blog/2017/07/08/getting-started-with-wbscope.html&quot;&gt;scope&lt;/a&gt;,
I discovered the &lt;a href=&quot;/blog/2017/07/29/fifo.html&quot;&gt;FIFO&lt;/a&gt;
was acting within normal limits.  However, the values
being read didn’t match the values in my code.&lt;/p&gt;

&lt;p&gt;Ok, so I adjusted the
&lt;a href=&quot;/blog/2017/07/08/getting-started-with-wbscope.html&quot;&gt;scope&lt;/a&gt;
and traced the problem up stream.  Things looked good there.&lt;/p&gt;

&lt;p&gt;So I adjusted my &lt;a href=&quot;/blog/2017/07/29/fifo.html&quot;&gt;FIFO&lt;/a&gt;
so that it would return the address pointer instead of
the data.  In this case, the
&lt;a href=&quot;http://www.cplusplus.com/reference/cstring/memcpy/&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;memcpy()&lt;/code&gt;&lt;/a&gt;)’d
buffer came back finally in order with no problems, but the
&lt;a href=&quot;/blog/2017/07/08/getting-started-with-wbscope.html&quot;&gt;scope&lt;/a&gt;
finally showed the problem.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/OUT-OF-ORDER.svg&quot; alt=&quot;&quot; width=&quot;480&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Instead of reading sample values 0, 1, 2, 3, 4, …, the
&lt;a href=&quot;https://en.wikipedia.org/wiki/ARM_architecture&quot;&gt;ARM&lt;/a&gt;
was reading sample values 0, 8, 16, 24, 1, 2, 3, 4, … and then quietly
reordering the samples back into what it thought was the “correct” order.
However, since the
&lt;a href=&quot;/blog/2017/07/29/fifo.html&quot;&gt;FIFO&lt;/a&gt;
based device was producing values in order in spite of the
out of order addresses, when the
&lt;a href=&quot;https://en.wikipedia.org/wiki/ARM_architecture&quot;&gt;ARM&lt;/a&gt;
rearranged the reads back in order–the result was the values in the buffer
were now &lt;em&gt;out of order&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Since knowing is half the battle, I now had two choices: I could fix the
&lt;a href=&quot;http://www.cplusplus.com/reference/cstring/memcpy/&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;memcpy()&lt;/code&gt;&lt;/a&gt;)
routine by writing one of my own that didn’t read out of order, or
I could shuffle the memory back into order.  I chose the former and wrote
my own
&lt;a href=&quot;http://www.cplusplus.com/reference/cstring/memcpy/&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;memcpy()&lt;/code&gt;&lt;/a&gt;), one where
I could &lt;em&gt;guarantee&lt;/em&gt; that the reads would be issued &lt;em&gt;in order&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;This new version of code &lt;em&gt;still&lt;/em&gt; read from my
&lt;a href=&quot;/blog/2017/07/29/fifo.html&quot;&gt;FIFO&lt;/a&gt;
out of order.&lt;/p&gt;

&lt;p&gt;As it turns out, it was the
&lt;a href=&quot;https://en.wikipedia.org/wiki/ARM_architecture&quot;&gt;ARM CPU&lt;/a&gt;
itself that caused the reads to be
issued out of order, and then quietly placed the memory back in order
on the other end.
However, if I rearranged my own memory copy to never
increment the “fake” address into the
&lt;a href=&quot;/blog/2017/07/29/fifo.html&quot;&gt;FIFO&lt;/a&gt;,
then it finally read it in order.&lt;/p&gt;

&lt;p&gt;I’ll say this much: I would’ve never figured this out without my &lt;a href=&quot;/blog/2017/07/08/getting-started-with-wbscope.html&quot;&gt;Wishbone
Scope&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;immediate-lessons-learned&quot;&gt;Immediate Lesson’s Learned&lt;/h2&gt;

&lt;p&gt;As with any attempt to use a new piece of technology you aren’t familiar with,
there will be hiccups.  The
&lt;a href=&quot;https://www.altera.com/products/fpga/cyclone-series/cyclone-v/overview.html&quot;&gt;Cyclone-V&lt;/a&gt;
on the
&lt;a href=&quot;http://www.terasic.com/cgi-bin/page/archive.pl?Language=English&amp;amp;No=1046&quot;&gt;DE10-Nano&lt;/a&gt;
was no exception.
Indeed, it took me almost a month of grumbling and confusion to get off the
ground before I discovered that, yes, the
&lt;a href=&quot;https://www.terasic.com.tw&quot;&gt;Terasic&lt;/a&gt;
&lt;a href=&quot;http://www.terasic.com.tw/cgi-bin/page/archive.pl?Language=English&amp;amp;CategoryNo=205&amp;amp;No=1046&amp;amp;PartNo=4&quot;&gt;documentation&lt;/a&gt;
&lt;em&gt;did&lt;/em&gt; show me how to interact with this device.  Here are some other
frustrations I came across:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;My first big frustration was &lt;a href=&quot;https://software.intel.com/en-us/articles/de10-nano-board-schematic&quot;&gt;the schematic&lt;/a&gt; I found online.  It took me some
time to realize that someone had posted a
&lt;a href=&quot;http://www.terasic.com/cgi-bin/page/archive.pl?Language=English&amp;amp;No=593&quot;&gt;DE0-Nano&lt;/a&gt;
schematic on an &lt;a href=&quot;https://software.intel.com/en-us/articles/de10-nano-board-schematic&quot;&gt;Intel
DE10-Nano support&lt;/a&gt; web-page.&lt;/p&gt;

    &lt;p&gt;Sadly, despite posting a comment to this effect, &lt;a href=&quot;https://software.intel.com/en-us/articles/de10-nano-board-schematic&quot;&gt;this official
Intel support page&lt;/a&gt; &lt;em&gt;still&lt;/em&gt; contains a link to the wrong schematic.&lt;/p&gt;

    &lt;p&gt;In the end, I needed to destroy and then recreate my project in
&lt;a href=&quot;https://www.altera.com/products/design-software/fpga-design/quartus-prime/download.html&quot;&gt;Quartus&lt;/a&gt;
just to convince myself that I had gotten rid of all of the references
to the wrong part.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;My next frustration was that I couldn’t find an
&lt;a href=&quot;https://www.altera.com&quot;&gt;Altera&lt;/a&gt; “Libraries” reference.&lt;/p&gt;

    &lt;p&gt;Perhaps I’m spoiled: &lt;a href=&quot;https://www.xilinx.com&quot;&gt;Xilinx&lt;/a&gt; offers a &lt;a href=&quot;https://www.xilinx.com/support/documentation/sw_manuals/xilinx14_7/7series_hdl.pdf&quot;&gt;libraries
guide&lt;/a&gt;
that gives you instructions for how to interface with any of the
hard components on the chip.  Hence, if I need a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Phase-locked_loop&quot;&gt;PLL&lt;/a&gt;,
I just put a reference to their
&lt;a href=&quot;https://en.wikipedia.org/wiki/Phase-locked_loop&quot;&gt;PLL&lt;/a&gt;
within my own code and off I go.&lt;/p&gt;

    &lt;p&gt;I couldn’t find a similar libraries guide for
&lt;a href=&quot;https://www.altera.com&quot;&gt;Altera&lt;/a&gt;.  Indeed, I probably
spent much too much time looking for it.&lt;/p&gt;

    &lt;p&gt;In the end, I just swallowed my aversion to working with GUI’s and built the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Phase-locked_loop&quot;&gt;PLL&lt;/a&gt;
I needed using &lt;a href=&quot;https://www.altera.com/products/design-software/fpga-design/quartus-prime/features/qts-platform-designer.html&quot;&gt;Platform
Designer&lt;/a&gt;.
Since resigning to use &lt;a href=&quot;https://www.altera.com/products/design-software/fpga-design/quartus-prime/features/qts-platform-designer.html&quot;&gt;Platform
Designer&lt;/a&gt;,
it has handled all of my needs to date–I just hate using GUI’s: they are
slow, and they can hide details where I’m not looking for them, etc.
Although, looking over the &lt;a href=&quot;https://www.altera.com/products/design-software/fpga-design/quartus-prime/features/qts-platform-designer.html&quot;&gt;Platform
Designer&lt;/a&gt;
generated data file in the end, it’s &lt;em&gt;just an XML file&lt;/em&gt;–one that submits
nicely to “diff”, and thus one I can use with
&lt;a href=&quot;https://git-scm.com&quot;&gt;git&lt;/a&gt;
quite nicely.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;My second problem had to deal with the “Golden H/W design”
&lt;a href=&quot;http://www.terasic.com.tw/cgi-bin/page/archive.pl?Language=English&amp;amp;CategoryNo=205&amp;amp;No=1046&amp;amp;PartNo=4&quot;&gt;provided by&lt;/a&gt;
&lt;a href=&quot;https://www.terasic.com.tw&quot;&gt;Terasic&lt;/a&gt; for the board.&lt;/p&gt;

    &lt;p&gt;Looking through this design with Altera’s &lt;a href=&quot;https://www.altera.com/products/design-software/fpga-design/quartus-prime/features/qts-platform-designer.html&quot;&gt;Platform
Designer&lt;/a&gt;,
I could easily identify a variety of things I didn’t need.  I dumped these
out of my project, and then cleaned up the result so that there were
only the components I needed, and then built the project.&lt;/p&gt;

    &lt;p&gt;It didn’t work.  The board would load and run the bootloader just fine.
The bootloader would load my
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
design, but would then fail to start Linux.  Not knowing how to debug Linux
loading to know what device was failing, how, or why, I just couldn’t
tell why not.&lt;/p&gt;

    &lt;p&gt;In the end, I went back and rebuilt the Golden Design
&lt;a href=&quot;http://www.terasic.com.tw/cgi-bin/page/archive.pl?Language=English&amp;amp;CategoryNo=205&amp;amp;No=1046&amp;amp;PartNo=4&quot;&gt;as provided&lt;/a&gt;,
and then only modified it for my application.  This worked.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;I really dislike vendor code that doesn’t match my own high quality coding
standards.&lt;/p&gt;

    &lt;p&gt;By this I mean two things.  First, I use &lt;code class=&quot;highlighter-rouge&quot;&gt;default_nettype none&lt;/code&gt; in all of
my designs.  It helps me avoid a whole variety of painful Verilog bugs.
However, a bug in the &lt;a href=&quot;https://www.altera.com&quot;&gt;Altera&lt;/a&gt;’s
&lt;a href=&quot;https://www.altera.com/products/fpga/cyclone-series/cyclone-v/overview.html&quot;&gt;Cyclone-V&lt;/a&gt;
IP would cause my design to fail if I tried to use this across my design.&lt;/p&gt;

    &lt;p&gt;With a little bit of help from an &lt;a href=&quot;http://www.clifford.at&quot;&gt;amazing mentor&lt;/a&gt;,
I managed to use &lt;code class=&quot;highlighter-rouge&quot;&gt;default_nettype none&lt;/code&gt; at the top of my files, and
&lt;code class=&quot;highlighter-rouge&quot;&gt;default_nettype wire&lt;/code&gt; at the bottom and
&lt;a href=&quot;https://www.altera.com&quot;&gt;Altera&lt;/a&gt;’s
broken code would still synthesize.&lt;/p&gt;

    &lt;p&gt;I then got all kinds of warnings from their “working” IP.  I mean, really
guys, can’t you clean up &lt;em&gt;your own&lt;/em&gt; IP?  How can I tell if my
implementation of your IP has problems if your IP fills the logs with
warnings–&lt;em&gt;when it works&lt;/em&gt;!?  (Incidentally,
&lt;a href=&quot;https://www.xilinx.com&quot;&gt;Xilinx&lt;/a&gt;’s code isn’t any
better, and &lt;a href=&quot;https://www.xilinx.com&quot;&gt;Xilinx&lt;/a&gt;’s MIG-generated
&lt;a href=&quot;https://en.wikipedia.org/wiki/DDR3_SDRAM&quot;&gt;DDR3 SDRAM&lt;/a&gt;
controller is a particular offender …)&lt;/p&gt;

    &lt;p&gt;The worst of these warnings said that I hadn’t mapped several pins
properly, and yet the pin mapping tool wouldn’t let me do anything with
these hardware-assigned yet somehow mis-mapped pins.  As with the
other warnings, these could be ignored, but how was I to know that when
things weren’t working?&lt;/p&gt;

    &lt;p&gt;Again, building the &lt;a href=&quot;http://www.terasic.com.tw/cgi-bin/page/archive.pl?Language=English&amp;amp;CategoryNo=205&amp;amp;No=1046&amp;amp;PartNo=4&quot;&gt;Golden H/W Reference Design&lt;/a&gt;
gave me some
confidence, as I could then see that I still got the same warnings
and yet for some outrageous reason, the
&lt;a href=&quot;http://www.terasic.com.tw/cgi-bin/page/archive.pl?Language=English&amp;amp;CategoryNo=205&amp;amp;No=1046&amp;amp;PartNo=4&quot;&gt;Golden Design&lt;/a&gt;
worked in spite of the warnings.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;This blog is about debugging
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;s,
though, so what did I learn from that standpoint?&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;One mistake in the
&lt;a href=&quot;https://www.altera.com/content/dam/altera-www/global/en_US/pdfs/literature/manual/mnl_avalon_spec.pdf&quot;&gt;Avalon bus&lt;/a&gt;
controller would lock up the device &lt;em&gt;HARD&lt;/em&gt;.&lt;/p&gt;

    &lt;p&gt;If this happened, the only solution appeared to be pulling power.&lt;/p&gt;

    &lt;p&gt;The &lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal&lt;/a&gt; proof
of the
&lt;a href=&quot;https://www.altera.com/content/dam/altera-www/global/en_US/pdfs/literature/manual/mnl_avalon_spec.pdf&quot;&gt;Avalon&lt;/a&gt;
to &lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;WB&lt;/a&gt;
converter created a bit of a false confidence for me: my design
still locked up at times.&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;
        &lt;p&gt;The first problem I had with my
&lt;a href=&quot;https://www.altera.com/content/dam/altera-www/global/en_US/pdfs/literature/manual/mnl_avalon_spec.pdf&quot;&gt;Avalon&lt;/a&gt;
bus interface
was that I somehow managed to &lt;em&gt;assume&lt;/em&gt; within my
proof that all transactions would be read transactions.  The assumption
wasn’t simple, and it wasn’t obvious, so I never realized what happened
from a simple desk check.&lt;/p&gt;

        &lt;p&gt;In the end, I figured out what was going on via
&lt;a href=&quot;/blog/2017/06/21/looking-at-verilator.html&quot;&gt;simulation&lt;/a&gt;.&lt;/p&gt;

        &lt;p&gt;When I went back to the
formal properties, I realized I hadn’t created
any “cover” properties, and that a simple “cover” property or two
would’ve revealed this problem.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;My next problem was when I mis-wired a bus component in
&lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt;.&lt;/p&gt;

        &lt;p&gt;For a given peripheral, the
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;WB strobe&lt;/a&gt;
value is given by the overall
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;wishbone strobe (a
transaction request)&lt;/a&gt;
&lt;a href=&quot;/blog/2017/06/22/simple-wb-interconnect.html&quot;&gt;logically &lt;code class=&quot;highlighter-rouge&quot;&gt;AND&lt;/code&gt;ed
with the peripheral’s address select line&lt;/a&gt;.  I had forgotten this
address select line logical &lt;code class=&quot;highlighter-rouge&quot;&gt;AND&lt;/code&gt; on one component, and so that
component was responding to &lt;em&gt;EVERY&lt;/em&gt; transaction across the bus–with
pretty catastrophic results.&lt;/p&gt;

        &lt;p&gt;As with the prior problem, I found this pretty quickly … once I fired
up the &lt;a href=&quot;/blog/2017/06/21/looking-at-verilator.html&quot;&gt;simulator&lt;/a&gt;.&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;/blog/2017/06/21/looking-at-verilator.html&quot;&gt;Simulator&lt;/a&gt;?
How …?&lt;/p&gt;

    &lt;p&gt;Yes.  Exactly.  I couldn’t simulate the
&lt;a href=&quot;https://en.wikipedia.org/wiki/ARM_architecture&quot;&gt;ARM&lt;/a&gt; processor, the
&lt;a href=&quot;https://en.wikipedia.org/wiki/DDR3_SDRAM&quot;&gt;DDR3 SDRAM&lt;/a&gt;,
the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Gigabit_Ethernet&quot;&gt;GigE&lt;/a&gt;
network, the lightweight
&lt;a href=&quot;http://www.gstitt.ece.ufl.edu/courses/fall15/eel4720_5721/labs/refs/AXI4_specification.pdf&quot;&gt;AXI&lt;/a&gt; bridge,
or the
&lt;a href=&quot;http://www.gstitt.ece.ufl.edu/courses/fall15/eel4720_5721/labs/refs/AXI4_specification.pdf&quot;&gt;AXI&lt;/a&gt; to
&lt;a href=&quot;https://www.altera.com/content/dam/altera-www/global/en_US/pdfs/literature/manual/mnl_avalon_spec.pdf&quot;&gt;Avalon&lt;/a&gt;
memory-mapped I/O bridge, but I could create a
&lt;a href=&quot;https://veripool.org/wiki/verilator&quot;&gt;Verilator&lt;/a&gt;-based
&lt;a href=&quot;/blog/2017/06/21/looking-at-verilator.html&quot;&gt;simulation&lt;/a&gt;
of the
&lt;a href=&quot;https://www.altera.com/content/dam/altera-www/global/en_US/pdfs/literature/manual/mnl_avalon_spec.pdf&quot;&gt;Avalon&lt;/a&gt;
bus interface on down–to include simulating
the &lt;a href=&quot;https://en.wikipedia.org/wiki/Analog-to-digital_converter&quot;&gt;A/D&lt;/a&gt;s.
That portion of the design was a fairly straight-forward
&lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt;
based implementation, and even though it wasn’t a full-design
&lt;a href=&quot;/blog/2017/06/21/looking-at-verilator.html&quot;&gt;simulation&lt;/a&gt;,
it was enough to
&lt;a href=&quot;/blog/2017/06/21/looking-at-verilator.html&quot;&gt;simulate&lt;/a&gt;
enough of the design to find many problems.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Given my experiences with an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
+ &lt;a href=&quot;https://en.wikipedia.org/wiki/ARM_architecture&quot;&gt;ARM&lt;/a&gt;
architecture, would I recommend it for others?  As with any engineering
decision, your choice will depend upon the requirements of your problem.
However, I would have &lt;em&gt;really&lt;/em&gt; struggled if this had been my first-ever
design.  Hence, I’d recommend beginners start with something simpler–such
as a plain
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
with an on-board (debuggable)
&lt;a href=&quot;https://en.wikipedia.org/wiki/Soft_microprocessor&quot;&gt;soft-core CPU&lt;/a&gt;,
before adding the &lt;a href=&quot;https://en.wikipedia.org/wiki/ARM_architecture&quot;&gt;ARM&lt;/a&gt;
to the mix.&lt;/p&gt;

&lt;h2 id=&quot;conclusions&quot;&gt;Conclusions&lt;/h2&gt;

&lt;p&gt;There’s more I could say, but this post is long enough as is.  I’d like to be
able to blog some more about the
&lt;a href=&quot;https://www.altera.com/content/dam/altera-www/global/en_US/pdfs/literature/manual/mnl_avalon_spec.pdf&quot;&gt;Avalon&lt;/a&gt;
to &lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;WB&lt;/a&gt;
bridge and how I managed to formally verify it,
how easy it is to suddenly add a
&lt;a href=&quot;/blog/2017/07/08/getting-started-with-wbscope.html&quot;&gt;scope&lt;/a&gt;
to a design using
&lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt;,
or indeed how powerful
&lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt;
is in general.&lt;/p&gt;

&lt;p&gt;These discussions will sadly need to wait for a later day.&lt;/p&gt;

&lt;hr /&gt;&lt;p&gt;&lt;em&gt;If we say that we have not sinned, we make him a liar, and his word is not in us. (1John 1:9)&lt;/em&gt;</description>
        <pubDate>Fri, 09 Feb 2018 00:00:00 -0500</pubDate>
        <link>http://zipcpu.com/blog/2018/02/09/first-cyclonev.html</link>
        <guid isPermaLink="true">http://zipcpu.com/blog/2018/02/09/first-cyclonev.html</guid>
        
        
        <category>blog</category>
        
      </item>
    
  </channel>
</rss>
