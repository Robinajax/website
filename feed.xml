<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>The ZipCPU by Gisselquist Technology</title>
    <description>The ZipCPU blog, featuring how to discussions of FPGA and soft-core CPU design.  This site will be focused on Verilog solutions, using exclusively OpenSource IP products for FPGA design.  Particular focus areas include topics often left out of more mainstream FPGA design courses such as how to debug an FPGA design.
</description>
    <link>https://zipcpu.com/</link>
    <atom:link href="https://zipcpu.com/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Sun, 06 Oct 2019 21:31:08 -0400</pubDate>
    <lastBuildDate>Sun, 06 Oct 2019 21:31:08 -0400</lastBuildDate>
    <generator>Jekyll v3.0.1</generator>
    <image>
      <url>https://zipcpu.com/img/gt-rss.png</url>
      <title></title>
      <link></link>
    </image>
    
      <item>
        <title>Is formal verfication enough, or is simulation required?</title>
        <description>&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/enough/orconf.png&quot; alt=&quot;&quot; width=&quot;161&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;While at &lt;a href=&quot;https://orconf.org&quot;&gt;ORCONF&lt;/a&gt; this past weekend, several folks asked
me to what extent I used
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal methods&lt;/a&gt;.
Since I found myself answering this question with some stories from my own
experiences that I had yet to blog about, I thought I’d write
them down and share them here.&lt;/p&gt;

&lt;p&gt;Unlike many of my articles, this one will avoid deep dives into code.  We’ll
have plenty of opportunities to do that another time.&lt;/p&gt;

&lt;p&gt;That said, I’d like to discuss four design examples: an &lt;a href=&quot;https://github.com/ZipCPU/blob/master/rtl/core/pfcache.v&quot;&gt;instruction
cache&lt;/a&gt; that wasn’t
formally verified, chasing down
a &lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash memory&lt;/a&gt; verification error,
a &lt;a href=&quot;https://github.com/ZipCPU/blob/master/rtl/core/dcache.v&quot;&gt;data cache&lt;/a&gt; built
with formal from the beginning, and a recent speed upgrade I worked on for an
external &lt;a href=&quot;https://github.com/cliffordwolf/picorv32&quot;&gt;PicoRV32&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_(computing)&quot;&gt;Bus&lt;/a&gt; interface.&lt;/p&gt;

&lt;h2 id=&quot;the-instruction-cache&quot;&gt;The Instruction Cache&lt;/h2&gt;

&lt;p&gt;The &lt;a href=&quot;https://github.com/ZipCPU/blob/master/rtl/core/pfcache.v&quot;&gt;instruction
cache&lt;/a&gt;
story is &lt;a href=&quot;/zipcpu/2017/12/28/ugliest-bug.html&quot;&gt;one I’ve told
before&lt;/a&gt;.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: left; padding: 15px&quot;&gt;&lt;caption&gt;Fig 1. The ZipCPU Instruction Cache&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/enough/zipcpu-prefetch.svg&quot; alt=&quot;&quot; width=&quot;240&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;The &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;’s &lt;a href=&quot;https://github.com/ZipCPU/blob/master/rtl/core/pfcache.v&quot;&gt;instruction
cache&lt;/a&gt;
is actually one of several possible instruction fetch modules it can be
configured with.  We’ve already discussed the &lt;a href=&quot;/zipcpu/2017/11/18/wb-prefetch.html&quot;&gt;basic
prefetch&lt;/a&gt;, and a more
&lt;a href=&quot;/zipcpu/2018/03/21/dblfetch.html&quot;&gt;pipelined prefetch&lt;/a&gt;
implementation.  The 
&lt;a href=&quot;https://github.com/ZipCPU/blob/master/rtl/core/pfcache.v&quot;&gt;cache&lt;/a&gt; is a
drop-in replacement for either.  Then, within the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;, the
&lt;a href=&quot;/zipcpu/2017/11/18/wb-prefetch.html&quot;&gt;prefetch&lt;/a&gt;
and the load-store unit (also a plug-in with several options) are arbitrated
between to determine which gets access to the
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;Wishbone bus&lt;/a&gt;
at any given time, as shown in Fig. 2 on the left.&lt;/p&gt;

&lt;p&gt;This is just basic CPU design and background.&lt;/p&gt;

&lt;p&gt;Now, imagine if you had a program running on a CPU, and the program wasn’t
working.  Whenever you called the first function after a reset, it would fail
with a &lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_error&quot;&gt;bus error&lt;/a&gt; after writing
beyond the end of memory.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/zipcpu/2019/02/04/debugging-that-cpu.html&quot;&gt;How might you find this
bug&lt;/a&gt;?&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Desk checking&lt;/p&gt;

    &lt;p&gt;A desk check of the failing software clearly indicated that the software
shouldn’t cause a bus error.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;When I added an instruction to trigger an
&lt;a href=&quot;/blog/2017/06/08/simple-scope.html&quot;&gt;internal scope&lt;/a&gt; and
so to get a &lt;a href=&quot;/blog/2017/07/31/vcd.html&quot;&gt;trace&lt;/a&gt;, the failure
vanished.&lt;/p&gt;

    &lt;p&gt;This made me wonder, did I have a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Heisenbug&quot;&gt;Heisenbug&lt;/a&gt;?&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;If I then re-ran the broken program, it no longer failed at this same step
but instead later on.&lt;/p&gt;

    &lt;p&gt;&lt;a href=&quot;/zipcpu/2017/07/14/cpu-debugging-needs.html&quot;&gt;Restarting&lt;/a&gt;
the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; a second time brought
the bug back.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;If I stepped through the code, there was no bug.&lt;/p&gt;

    &lt;p&gt;I think this definitely meets the criteria for a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Heisenbug&quot;&gt;Heisenbug&lt;/a&gt;.&lt;/p&gt;

    &lt;p&gt;It’s also a bug you can’t let go of to come back to on another day, since it
isn’t clear that you’d be able to reproduce it some other time.  I now had
to find it while it was hot.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;/blog/2018/08/22/what-is-simulation.html&quot;&gt;Simulation&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;Okay, I gave up.  Maybe
&lt;a href=&quot;/blog/2018/08/22/what-is-simulation.html&quot;&gt;simulation&lt;/a&gt;
would help?&lt;/p&gt;

    &lt;p&gt;In this case, the design failed in
&lt;a href=&quot;/blog/2018/08/22/what-is-simulation.html&quot;&gt;Simulation&lt;/a&gt;
as well as in hardware, and with the same symptoms even.  I was on the way
to a solution!&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;You can &lt;a href=&quot;/zipcpu/2017/12/28/ugliest-bug.html&quot;&gt;read more about the story here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The bottom line was that this bug took me way too long to find, and cost me way
more project time than I wanted to devote to it.&lt;/p&gt;

&lt;p&gt;By using
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal methods&lt;/a&gt;, I have
kept this &lt;a href=&quot;https://github.com/ZipCPU/blob/master/rtl/core/pfcache.v&quot;&gt;instruction cache design
unit&lt;/a&gt; from failing
since.  Indeed, I’m now convinced that if I had used &lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal
methods&lt;/a&gt; from the get-go,
I would’ve never had this bug in the first place.&lt;/p&gt;

&lt;p&gt;In a moment, we’ll come back and test that assumption–since I’ve since built
a &lt;a href=&quot;https://github.com/ZipCPU/blob/master/rtl/core/dcache.v&quot;&gt;data cache&lt;/a&gt;
using &lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal methods&lt;/a&gt;
from the very beginning and there’s a story to share there.  First, though, I
want to share the story of a design that got missed during my switch to
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal methods&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;flash-memory-verification-error&quot;&gt;Flash Memory Verification Error&lt;/h2&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 2. A Serial port to Wishbone converter&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/wb-uart-ovw.svg&quot; alt=&quot;&quot; width=&quot;240&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;One of my recent projects involved building an FFT accelerator that
used the &lt;a href=&quot;https://riscv.org&quot;&gt;RISC-V&lt;/a&gt;
&lt;a href=&quot;https://github.com/cliffordwolf/picorv32&quot;&gt;PicoRV32&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;.
In this project, like so many others, I needed to write the
&lt;a href=&quot;https://github.com/cliffordwolf/picorv32&quot;&gt;PicoRV32&lt;/a&gt;
software to &lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt;
and then have an embedded
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;
(i.e. the &lt;a href=&quot;https://github.com/cliffordwolf/picorv32&quot;&gt;PicoRV32&lt;/a&gt; in this case)
run that program.  The first step in this process is to &lt;a href=&quot;https://github.com/ZipCPU/zipversa/blob/3a99a61b0ed531338ec745c74758f3ca5729ee4c/sw/host/flashdrvr.cpp#L413-L438&quot;&gt;read what’s currently
in the flash, and then to compare it to
what I want to be in the flash&lt;/a&gt;.  Depending
on the result of that comparison, the flash sector needs to be either erased
(bits turn to ones) and then programmed (specific bits turned to zeros), or
just programmed.  Ideally, if the design already exists in the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt; then nothing more needs
to be done.&lt;/p&gt;

&lt;p&gt;In testing, however, when I tried to load the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt;
a second time with a particular program, the comparison would fail and the
loader would say that the design needed to be loaded again, as shown
in Fig. 3 on the left.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: left; padding: 15px&quot;&gt;&lt;caption&gt;Fig 3. Comparing just-written flash memory failed&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/enough/flash-comparison.svg&quot; alt=&quot;&quot; width=&quot;240&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;This was an indication that the first effort to program the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt;
had either failed for some reason, or there was a wild pointer error writing
strange things to the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt;.
Either way, it wasn’t how things were supposed to work.&lt;/p&gt;

&lt;p&gt;My first thought was that my &lt;a href=&quot;/blog/2019/03/27/qflexpress.html&quot;&gt;updated flash
controller&lt;/a&gt; had a bug in it,
or that maybe the current
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash memory&lt;/a&gt;
I was working with had a unique feature that I wasn’t prepared for.
Much to my surprise, when I tried to reproduce the bug in
&lt;a href=&quot;/blog/2018/08/22/what-is-simulation.html&quot;&gt;simulation&lt;/a&gt;,
it failed in the exact same place with the exact same symptoms–even though I
was using an &lt;a href=&quot;https://github.com/ZipCPU/zipversa/blob/master/sim/verilator/flashsim.cpp&quot;&gt;emulated flash device&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;So I turned on the “debug by printf” feature of the &lt;a href=&quot;https://github.com/ZipCPU/zipversa/blob/master/sim/verilator/flashsim.cpp&quot;&gt;emulated flash
device&lt;/a&gt;,
and created a test: I would load the correct design into this &lt;a href=&quot;https://github.com/ZipCPU/zipversa/blob/master/sim/verilator/flashsim.cpp&quot;&gt;emulated
flash&lt;/a&gt;,
and then attempt to load my program into the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt;
a second time.  As before, the second load attempt detected a difference between
the original image and the new image, indicating that what was in the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash memory&lt;/a&gt;
didn’t match–when it was supposed to.  However, the debugging statements
indicated that the &lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash memory&lt;/a&gt;
was never changed from its initial load.&lt;/p&gt;

&lt;p&gt;Something else was wrong, and it wasn’t the &lt;a href=&quot;/blog/2019/03/27/qflexpress.html&quot;&gt;flash
controller&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;I restarted the
&lt;a href=&quot;/blog/2018/08/22/what-is-simulation.html&quot;&gt;simulation&lt;/a&gt;, this
time with &lt;a href=&quot;/blog/2017/07/31/vcd.html&quot;&gt;tracing&lt;/a&gt; enabled.
Many minutes later (it might’ve even been an hour or two …) I had a 22GB
file I could work with.&lt;/p&gt;

&lt;p&gt;I shouldn’t need to mention that 22GB is not a
&lt;a href=&quot;/blog/2017/07/31/vcd.html&quot;&gt;trace file&lt;/a&gt; size I like to
work with.  It takes forever to generate/write, and slows down my CPU user
experience.  (I’ve often noticed my favorite music stuttering during this time.)
Further, anything over about 200MB will cause
&lt;a href=&quot;http://gtkwave.sourceforge.net&quot;&gt;GTKWave&lt;/a&gt; to complain.  It also tends to lock
up my local WiFi network anytime I try to debugging on my laptop, when the
&lt;a href=&quot;/blog/2017/07/31/vcd.html&quot;&gt;trace&lt;/a&gt;
is kept on my desktop.&lt;/p&gt;

&lt;p&gt;I suppose I should point out that I tried using the
&lt;a href=&quot;/blog/2017/06/21/looking-at-verilator.html&quot;&gt;Verilator&lt;/a&gt;
FST option to generate a compressed trace.  While the result was a shorter
&lt;a href=&quot;/blog/2017/07/31/vcd.html&quot;&gt;trace&lt;/a&gt;, it took even
longer to generate.  That I even have this memory tells you that just running
the &lt;a href=&quot;/blog/2018/08/22/what-is-simulation.html&quot;&gt;simulation&lt;/a&gt;
once wasn’t enough.  It rarely is.&lt;/p&gt;

&lt;p&gt;The other problem is that it’s really hard to discover where the bug is in a
large &lt;a href=&quot;/blog/2017/07/31/vcd.html&quot;&gt;trace&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Still, I managed to find the
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;Wishbone request&lt;/a&gt;
that read from the address that was causing the fault.  (It was always the
same address, and within this section of the design the address only ever
incremented.)  Much to my surprise, the
&lt;a href=&quot;/blog/2018/08/22/what-is-simulation.html&quot;&gt;simulation&lt;/a&gt;
read the correct value from the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Then why did my load software
&lt;a href=&quot;https://github.com/ZipCPU/zipversa/blob/3a99a61b0ed531338ec745c74758f3ca5729ee4c/sw/host/flashdrvr.cpp#L429-L430&quot;&gt;report&lt;/a&gt;
that the &lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt;
didn’t match the software image, when in fact it actually did?&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 4. The bus to PC processing chain&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/enough/return-path.svg&quot; alt=&quot;&quot; width=&quot;240&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;I needed to trace this result through the design–from where I had found it
reading the correct value from the &lt;a href=&quot;https://github.com/ZipCPU/zipversa/blob/master/sim/verilator/flashsim.cpp&quot;&gt;emulated flash
device&lt;/a&gt;
all the way to the PC host software that was receiving the wrong value, as shown
in Fig. 4 on the right.&lt;/p&gt;

&lt;p&gt;Not all of the trace points were easy to work through.  The first trace point
was a
&lt;a href=&quot;https://github.com/ZipCPU/zipversa/blob/master/rtl/wbubus/wbufifo.v&quot;&gt;FIFO&lt;/a&gt;.  I
watched the correct data word go into the
&lt;a href=&quot;https://github.com/ZipCPU/zipversa/blob/master/rtl/wbubus/wbufifo.v&quot;&gt;FIFO&lt;/a&gt;.
I looked up the address it was written to, and then watched the correct word
come out of the
&lt;a href=&quot;https://github.com/ZipCPU/zipversa/blob/master/rtl/wbubus/wbufifo.v&quot;&gt;FIFO&lt;/a&gt;
a significant time later.  No errors yet.&lt;/p&gt;

&lt;p&gt;The word then went through another processing stage with no change, just
a delay.  No error there.&lt;/p&gt;

&lt;p&gt;Then it went into the &lt;a href=&quot;https://github.com/ZipCPU/zipversa/blob/master/rtl/wbubus/wbucompress.v&quot;&gt;compression algorithm&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Ouch.  Did I really need to dig into the &lt;a href=&quot;https://github.com/ZipCPU/zipversa/blob/master/rtl/wbubus/wbucompress.v&quot;&gt;compression algorithm&lt;/a&gt;?
Unlike the prior steps, it would not be easy to “see” the correct word work
its way back.  Compression could fundamentally change the word into something
else.&lt;/p&gt;

&lt;p&gt;Like any good engineer, I did what I could to avoid digging into the 
&lt;a href=&quot;https://github.com/ZipCPU/zipversa/blob/master/rtl/wbubus/wbucompress.v&quot;&gt;compression algorithm&lt;/a&gt;:
I looked at the metadata.  I watched the &lt;code class=&quot;highlighter-rouge&quot;&gt;stb&lt;/code&gt; (valid) and ready (&lt;code class=&quot;highlighter-rouge&quot;&gt;!stall&lt;/code&gt;)
signals.  I quickly noticed data changing when the downstream interface was
still stalled.  Perhaps there was a
&lt;a href=&quot;/blog/2017/08/14/strategies-for-pipelining.html&quot;&gt;pipeline&lt;/a&gt;
bug in the
&lt;a href=&quot;https://github.com/ZipCPU/zipversa/blob/master/rtl/wbubus/wbucompress.v&quot;&gt;compression algorithm&lt;/a&gt;?&lt;/p&gt;

&lt;p&gt;As it turned out, this data change was “normal”–it had just been too long
since I’d written and examined &lt;a href=&quot;https://github.com/ZipCPU/zipversa/blob/master/rtl/wbubus/wbucompress.v&quot;&gt;the
code&lt;/a&gt;,
and so I wasn’t remembering well what it was supposed to do.&lt;/p&gt;

&lt;p&gt;Nevertheless, I stepped into and through all of the steps in the
&lt;a href=&quot;https://github.com/ZipCPU/zipversa/blob/master/rtl/wbubus/wbucompress.v&quot;&gt;compression algorithm&lt;/a&gt;.  I had to.&lt;/p&gt;

&lt;p&gt;Before continuing, let me tell you a bit about this compression scheme.&lt;/p&gt;

&lt;p&gt;First, it’s part of my debugging bus protocol.  If you’ve read the &lt;a href=&quot;//blog/2017/06/05/wb-bridge-overview.html&quot;&gt;introductory
post&lt;/a&gt; in my &lt;a href=&quot;https://github.com/ZipCPU/dbgbus/tree/master/hexbus&quot;&gt;series
on building a debugging
bus&lt;/a&gt;, you’ll know that
I have two versions I use.  One is a simplified version that we built together
on the blog.  I call that one the &lt;code class=&quot;highlighter-rouge&quot;&gt;hexbus&lt;/code&gt;, since it is built around
transmitting hexadecimal numbers.  The other is my workhorse debugging bus
implementation, outlined in Fig. 2 above.  This workhorse design includes &lt;a href=&quot;https://github.com/ZipCPU/zipversa/blob/master/rtl/wbubus/wbucompress.v&quot;&gt;this
compression
module&lt;/a&gt;
within in it.  The compressor
is designed to compress 36-bit codewords, where the first 4-bits contain
meta-information, such as whether the word contains an address update, write
acknowledgment, read-return, etc., and the last 32-bits may contain encoded
data.  After the compression, the 36-bit words are broken into one or more
6-bit words followed a synchronization/end-of-word character, and these are
then mapped into printable, human-readable characters.&lt;/p&gt;

&lt;p&gt;The compression itself is based upon one of three schemes.  The first scheme
encodes the last data value into a new codeword that can be sent using a single
byte.  The second scheme encodes any one of the next eight values into what will
become a single byte again.  The third scheme encodes any of the next 512
values into what will become a two byte sequence.&lt;/p&gt;

&lt;p&gt;Sadly, this requires a compression table of 521 elements in length.  Since
FPGAs don’t offer block RAM lengths of 521 elements, I use a 1024 element
table to record the last data words I’d sent.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 5. Serial port compression algorithm&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/enough/basic-compression.svg&quot; alt=&quot;&quot; width=&quot;560&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;How does the compression work?&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Any time the host (PC) processor sets the address of a bus request, the
new address acknowledgment going back to the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;
is used as a signal to reset the compression table to zero length.  This
synchronizes any external program to the compression algorithm, especially
since multiple independent programs may want to interact with the FPGA
design over time.  (Only one will ever interact with the FPGA at any given
time.)&lt;/p&gt;

    &lt;p&gt;This is a key point.  Because I was reading from the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt;
over a long period of sequential addresses, the PC didn’t need to send new
address/synchronization requests.  This also allowed the table to fill up,
like it was supposed to, but perhaps more than it did for me normally.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Then, once a 32-bit value is read from the internal
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;Wishbone bus&lt;/a&gt;, it is
(eventually) sent to the &lt;a href=&quot;https://github.com/ZipCPU/zipversa/blob/master/rtl/wbubus/wbucompress.v&quot;&gt;compression algorithm&lt;/a&gt;
as a 36-bit data word.&lt;/p&gt;

    &lt;p&gt;This was where I was at, while following the logic through the
&lt;a href=&quot;/blog/2017/07/31/vcd.html&quot;&gt;trace&lt;/a&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The compressor immediately places this 36-bit data word onto the output.&lt;/p&gt;

    &lt;p&gt;This looked good–the 36-bit word I had been following was now on the output.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;However, since the serial port interface tends to be slow, it may take many,
many clocks for this output to be accepted.  During this time, the compressor
goes back through its past memory to see if any of the values it has sent
in the past 521 (uncompressed) samples matches this current one.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;On a match, the compression algorithm recodes the outgoing data word to
indicate a compressed codeword, and the search stops.&lt;/p&gt;

    &lt;p&gt;This was the reason I had initially thought there was a fault in the
&lt;a href=&quot;https://github.com/ZipCPU/zipversa/blob/master/rtl/wbubus/wbucompress.v&quot;&gt;compression algorithm&lt;/a&gt;–the
output was changing even though the output was stalled.  In this case, it
was the &lt;em&gt;expected&lt;/em&gt; behavior.&lt;/p&gt;

    &lt;p&gt;It’s amazing what you forget about your code between the time you write it
and the time years later you have to go back and look at it again to
understand what it’s doing when something goes wrong.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;If no matching code word is found by the time the outgoing word is ready to
be accepted, then the &lt;a href=&quot;https://github.com/ZipCPU/zipversa/blob/master/rtl/wbubus/wbucompress.v&quot;&gt;compression
algorithm&lt;/a&gt;
then writes this word to the table and knocks the last word out of the table.
All indices then advance.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;On a new word, the process starts over from step 2.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;This is sort of the background of how this algorithm is supposed to work.&lt;/p&gt;

&lt;p&gt;To find my bug, I walked through every step of this algorithm from within
the trace file.  I had to walk through each of the steps above, through the
algorithm, checking the work at every step.  I then got to the point where the
algorithm found a match from the table at 522 words ago.  (It was easy to
find–since that’s where the module output codeword changed.)  Since the number
of possible compressions is only 521 words ago, a distance further than that
should’ve been dismissed.&lt;/p&gt;

&lt;p&gt;It wasn’t.&lt;/p&gt;

&lt;p&gt;This was a serious bug.  It took a long time to find it.  The fix, once found
was easy, but finding it?&lt;/p&gt;

&lt;p&gt;So, why hadn’t I found it earlier?&lt;/p&gt;

&lt;p&gt;Let’s look a little bit deeper, and see the real story.&lt;/p&gt;

&lt;p&gt;First, understand that this algorithm was built for &lt;a href=&quot;/blog/2017/06/05/wb-bridge-overview.html&quot;&gt;one of my very first
digital designs&lt;/a&gt;–long
before I started posting all of my designs on
&lt;a href=&quot;https://github.com/ZipCPU&quot;&gt;GitHub&lt;/a&gt;, and even before I was posting them on
&lt;a href=&quot;https://opencores.org&quot;&gt;OpenCores&lt;/a&gt;.   For that early design, I verified this
&lt;a href=&quot;https://github.com/ZipCPU/zipversa/blob/master/rtl/wbubus/wbucompress.v&quot;&gt;compression algorithm&lt;/a&gt;
as part of verifying a larger project in
&lt;a href=&quot;/blog/2018/08/22/what-is-simulation.html&quot;&gt;simulation&lt;/a&gt;.
Once that larger project worked, I figured this algorithm worked as well.&lt;/p&gt;

&lt;p&gt;After being used very successfully on that first project, this design was
lifted from that project to be used on a next one.  It was then lifted from that
one to be used on another, and another, and so on.  Today, I count its use in
twelve separate designs.  Indeed, over the years that I have used this module
it has become well-honed and well trusted.&lt;/p&gt;

&lt;p&gt;Not once during this time did the design ever accumulate any automated tests,
to verify if any changes updating the design maintained the designs
functionality.&lt;/p&gt;

&lt;p&gt;This was probably my key mistake.&lt;/p&gt;

&lt;p&gt;Sometime later, after I had been using this compression design for some time,
I noticed the design was creating a synthesis warning.  For some reason, the
synthesizer was &lt;a href=&quot;https://github.com/ZipCPU/openarty/blob/69b666b68eb49b22f7d32c9501e5ae2e5618f18f/rtl/wbucompress.v#L251&quot;&gt;complaining about comparing the found code-word index against
&lt;code class=&quot;highlighter-rouge&quot;&gt;521&lt;/code&gt;&lt;/a&gt;–the
maximum table offset I had an encoding for.  The warning said there were too
many bits in the comparison.  This didn’t make sense to me.  It should
be a 10-bit comparison, but … perhaps I wasn’t seeing the problem the
synthesis tool was seeing.  So I &lt;a href=&quot;https://github.com/ZipCPU/zipversa/blob/977eca075829ec10716fb95086c7e3b65009d67a/rtl/wbubus/wbucompress.v#L251-L252&quot;&gt;removed the comparison to make the warning
go away&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Knowing I needed to test the design, I left it in my master debugging bus
repository and forgot about it.  My intent was to “verify it” when it was later
incorporated into another project.&lt;/p&gt;

&lt;p&gt;So, here I was, with a broken design and cursing my broken design process.&lt;/p&gt;

&lt;p&gt;After way too long staring at this code, I discovered the real bug: I was
&lt;a href=&quot;https://github.com/ZipCPU/openarty/blob/69b666b68eb49b22f7d32c9501e5ae2e5618f18f/rtl/wbucompress.v#L251&quot;&gt;originally comparing against&lt;/a&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;10&#39;h521&lt;/code&gt; rather than &lt;code class=&quot;highlighter-rouge&quot;&gt;10&#39;d521&lt;/code&gt;.  Look carefully.  Do you see the difference?
This bug could happen to anyone.  Had I properly created a unit verification
process for this core, I might have caught the bug long ago–or not.  I’m
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;not sure I would’ve been rigorous enough to build a test that would’ve loaded
the FPGA with this
many values&lt;/a&gt;
just to test index overflow.
That’s something only the formal solver would be annoying enough to try.&lt;/p&gt;

&lt;p&gt;There’s a lesson I learned from jumping out of airplanes that applies well
here: Back in my days as a cadet in the US Air Force Academy, I had the
opportunity to jump out of perfectly good airplanes.  It was a lot of fun.
While we all enjoyed arguing over whether this was a smart or stupid thing to
do, no one argued about whether the reserve parachute was a smart or stupid
thing to have.  Instead, we were all taught that our reserve chute was our
last chance at life–our last chance to live.  We were to protect that reserve
chute with everything we had.&lt;/p&gt;

&lt;p&gt;In many ways, the &lt;a href=&quot;/blog/2017/06/02/design-process.html&quot;&gt;debugging
bus&lt;/a&gt; has somewhat of
the same purpose–although certainly not quite as dramatic.  This, plus the
&lt;a href=&quot;/blog/2017/07/08/getting-started-with-wbscope.html&quot;&gt;scope&lt;/a&gt;
and the &lt;a href=&quot;/blog/2018/08/22/what-is-simulation.html&quot;&gt;simulator&lt;/a&gt;,
are my last lines of defense against
&lt;a href=&quot;/blog/2017/05/19/fpga-hell.html&quot;&gt;FPGA Hell&lt;/a&gt;.  If any of my
designs should’ve been &lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formally
verified&lt;/a&gt;,
it would be these ones.&lt;/p&gt;

&lt;p&gt;As an aside, I recently had the opportunity to formally verify the &lt;a href=&quot;https://github.com/ZipCPU/wbscope/blob/master/rtl/axilscope.v&quot;&gt;AXI
version&lt;/a&gt; of my 
&lt;a href=&quot;/blog/2017/07/08/getting-started-with-wbscope.html&quot;&gt;scope&lt;/a&gt;.
Much to my surprise, I also found a subtle bug that had been hiding in the
&lt;a href=&quot;/blog/2017/10/20/cdc.html&quot;&gt;clock domain crossing&lt;/a&gt;
logic of the reset signal in the &lt;a href=&quot;https://github.com/ZipCPU/wbscope/blob/master/rtl/wbscope.v&quot;&gt;Wishbone
version&lt;/a&gt;
I’d been using as well.&lt;/p&gt;

&lt;p&gt;My point?  Verify any debugging logic you use.  Getting out of
&lt;a href=&quot;/blog/2017/05/19/fpga-hell.html&quot;&gt;FPGA Hell&lt;/a&gt;
depends upon it.&lt;/p&gt;

&lt;p&gt;It’s designs like these, and hard-earned lessons like this one, that continue
to convince me that I need to use &lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal
methods&lt;/a&gt;.
Why?  Because I tend spend the longest amount of  time chasing bugs in prior
designs that were never properly verified in the first place.&lt;/p&gt;

&lt;h2 id=&quot;the-data-cache&quot;&gt;The Data Cache&lt;/h2&gt;

&lt;table align=&quot;center&quot; style=&quot;float: left&quot;&gt;&lt;caption&gt;Fig 6. The ZipCPU Data Cache&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/enough/zipcpu-lsu.svg&quot; alt=&quot;&quot; width=&quot;240&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;The third story centers around building a &lt;a href=&quot;https://github.com/ZipCPU/blob/master/rtl/core/dcache.v&quot;&gt;data
cache&lt;/a&gt; for the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Indeed, it wasn’t long after building the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
that I decided I wanted to build a
&lt;a href=&quot;https://github.com/ZipCPU/blob/master/rtl/core/dcache.v&quot;&gt;data cache&lt;/a&gt;.
Even as far back as when I first presented the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
at &lt;a href=&quot;https://orconf.org/2016/&quot;&gt;ORCONF&lt;/a&gt;, I
was using my spare time to scribble out how this
&lt;a href=&quot;https://github.com/ZipCPU/blob/master/rtl/core/dcache.v&quot;&gt;data cache&lt;/a&gt;
would work.  I then scribbled that out and started over and over again and
again.  (It didn’t help that my scribbles were being done in pen, or that
I kept finding so many bugs in the scribbles ….)  I just struggled to get
a grasp on the whole algorithm and, as I’m sure you know, details matter.&lt;/p&gt;

&lt;p&gt;That was in 2016.&lt;/p&gt;

&lt;p&gt;It wasn’t until later, in 2018, when I was preparing to &lt;a href=&quot;/tutorial/#training&quot;&gt;teach my first course
in formal methods&lt;/a&gt;
that I actually managed to get the time and focus to build it from top to
bottom.  At that time, I was experimenting with the &lt;code class=&quot;highlighter-rouge&quot;&gt;cover()&lt;/code&gt; statement, and
getting excited that I could just &lt;code class=&quot;highlighter-rouge&quot;&gt;cover()&lt;/code&gt; the data returned from the
&lt;a href=&quot;https://github.com/ZipCPU/blob/master/rtl/core/dcache.v&quot;&gt;cache&lt;/a&gt;
to get almost all the information I needed.&lt;/p&gt;

&lt;p&gt;You can see an example of what this trace might have looked like in Fig. 7,
below.  This particular trace is drawn, however, from the &lt;a href=&quot;https://github.com/ZipCPU/blob/master/rtl/core/dcache.v&quot;&gt;current
implementation&lt;/a&gt;,
rather than the original one we are discussing.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 7. Data Cache Cover Trace&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/enough/dcache8.svg&quot; alt=&quot;&quot; width=&quot;720&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Notice that in order to &lt;code class=&quot;highlighter-rouge&quot;&gt;cover()&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;o_valid&lt;/code&gt;, the formal tool needed
to generate a trace that showed:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;The &lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt; requesting to read data
from the &lt;a href=&quot;https://github.com/ZipCPU/blob/master/rtl/core/dcache.v&quot;&gt;cache&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;You can see this in Fig. 7 where &lt;code class=&quot;highlighter-rouge&quot;&gt;i_request&lt;/code&gt; goes high.  (Inside the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;, the wire name used is
&lt;code class=&quot;highlighter-rouge&quot;&gt;i_pipe_stb&lt;/code&gt;–but we’re trying to make things readable here.)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;That data had to be determined to be in a cachable address&lt;/p&gt;

    &lt;p&gt;You might notice that it takes two clocks before &lt;code class=&quot;highlighter-rouge&quot;&gt;o_wb_cyc&lt;/code&gt; goes high.
One clock is required to read from the table of
&lt;a href=&quot;https://en.wikipedia.org/wiki/Cache_(computing)&quot;&gt;cache&lt;/a&gt; tags, the second
to compare the current request against the result.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The &lt;a href=&quot;https://en.wikipedia.org/wiki/Cache_(computing)&quot;&gt;cache&lt;/a&gt;.
would’ve been empty at the time, since it was fresh from a restart.  Hence,
the requested address isn’t found in the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Cache_(computing)&quot;&gt;cache&lt;/a&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The &lt;a href=&quot;https://github.com/ZipCPU/blob/master/rtl/core/dcache.v&quot;&gt;cache logic&lt;/a&gt;
would then go out to the
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;Wishbone bus&lt;/a&gt;
and read a &lt;a href=&quot;https://en.wikipedia.org/wiki/Cache_(computing)&quot;&gt;cache line&lt;/a&gt;.
into memory.  (As shown above in Fig. 7)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Once the &lt;a href=&quot;https://en.wikipedia.org/wiki/Cache_(computing)&quot;&gt;cache line&lt;/a&gt;
was in memory, the &lt;a href=&quot;https://github.com/ZipCPU/blob/master/rtl/core/dcache.v&quot;&gt;data
cache&lt;/a&gt; would then
return the value to the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt;.&lt;/p&gt;

    &lt;p&gt;This again requires several clocks, since it costs at least one clock to
write to the cache memory, another one to check that it’s in memory, and
another one to select between several possible cache results, etc.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;I could examine all of this logic from one simple &lt;code class=&quot;highlighter-rouge&quot;&gt;cover()&lt;/code&gt; generated
&lt;a href=&quot;/blog/2017/07/31/vcd.html&quot;&gt;trace&lt;/a&gt;!&lt;/p&gt;

&lt;p&gt;Even better, were either the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt;’s or the
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;Wishbone bus protocol&lt;/a&gt;
ever violated, the &lt;code class=&quot;highlighter-rouge&quot;&gt;cover()&lt;/code&gt; request would fail and I’d get a trace showing
where the failure took place.&lt;/p&gt;

&lt;p&gt;Not only that, the proof that I was using verified that the &lt;a href=&quot;/zipcpu/2018/07/13/memories.html&quot;&gt;“right” value
would always be returned&lt;/a&gt;
by the &lt;a href=&quot;https://github.com/ZipCPU/blob/master/rtl/core/dcache.v&quot;&gt;cache&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;I had similar &lt;code class=&quot;highlighter-rouge&quot;&gt;cover()&lt;/code&gt; statements in the &lt;a href=&quot;https://github.com/ZipCPU/blob/master/rtl/core/dcache.v&quot;&gt;data cache
logic&lt;/a&gt;
to verify:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Words written to memory would go right through the
&lt;a href=&quot;https://github.com/ZipCPU/blob/master/rtl/core/dcache.v&quot;&gt;cache&lt;/a&gt;
to the bus, since I had chosen a &lt;a href=&quot;https://en.wikipedia.org/wiki/Cache_(computing)&quot;&gt;“write-through” cache
implementation&lt;/a&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Words read or written from &lt;a href=&quot;https://en.wikipedia.org/wiki/Memory-mapped_I/O&quot;&gt;non-cachable
memory&lt;/a&gt; would also go
straight to the bus&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;With no properties violated, &lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus protocols
maintained&lt;/a&gt;, and a series
of &lt;code class=&quot;highlighter-rouge&quot;&gt;cover()&lt;/code&gt; statements in hand, I was really excited to go and run
&lt;a href=&quot;https://en.wikipedia.org/wiki/Dhrystone&quot;&gt;Dhrystone&lt;/a&gt; to see how
my performance might have improved.&lt;/p&gt;

&lt;p&gt;Any guesses as to what happened?&lt;/p&gt;

&lt;p&gt;Much to my shock and surprise, the CPU with its brand &lt;a href=&quot;https://github.com/ZipCPU/blob/master/rtl/core/dcache.v&quot;&gt;new data
cache&lt;/a&gt;
installed froze when I ran it in
&lt;a href=&quot;/blog/2018/08/22/what-is-simulation.html&quot;&gt;simulation&lt;/a&gt;.
Right out of the gate.  After staring at the screen in complete puzzlement,
I restarted the
&lt;a href=&quot;/blog/2018/08/22/what-is-simulation.html&quot;&gt;simulation&lt;/a&gt;.
with &lt;a href=&quot;/blog/2017/06/21/looking-at-verilator.html&quot;&gt;tracing enabled&lt;/a&gt;, killed it, and then pulled the
&lt;a href=&quot;/blog/2017/07/31/vcd.html&quot;&gt;trace&lt;/a&gt;
up into &lt;a href=&quot;http://gtkwave.sourceforge.net&quot;&gt;GTKWave&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;It didn’t take much work to find when the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt; froze.&lt;/p&gt;

&lt;p&gt;As it turns out, I had verified every part of the &lt;a href=&quot;https://github.com/ZipCPU/blob/master/rtl/core/dcache.v&quot;&gt;data
cache&lt;/a&gt;’s operation
except one:  I never verified that the busy line would clear after
returning its result to the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Ever since, I no longer &lt;code class=&quot;highlighter-rouge&quot;&gt;cover()&lt;/code&gt; a core just returning the “right-answer” any
more.  Instead, I will always create a
&lt;a href=&quot;/blog/2017/07/31/vcd.html&quot;&gt;trace&lt;/a&gt;
showing the core returning to idle after the “right-answer” has been found.
Even better, my current &lt;code class=&quot;highlighter-rouge&quot;&gt;cover()&lt;/code&gt; checks will look into a minimum of two
requests going through the core, so I can examine what sort of overall
throughput I might expect.&lt;/p&gt;

&lt;p&gt;When trying to answer the question of whether or not formal is enough on its
own, this was a valuable lesson learned.  Since this time, however, I haven’t
found any further bugs in this core–in spite of updating it several times.
Indeed, looking back over the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blame/master/rtl/core/dcache.v&quot;&gt;commit
log&lt;/a&gt;, it looks
like all of the subsequent commits had to deal with tool issues–rather than
any more functional issues.&lt;/p&gt;

&lt;h2 id=&quot;the-new-picorv32-front-end&quot;&gt;The New PicoRV32 Front End&lt;/h2&gt;

&lt;table align=&quot;center&quot; style=&quot;float: left&quot;&gt;&lt;caption&gt;Fig 8. A basic PicoRV32-based Accelerator&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/enough/zipversa.svg&quot; alt=&quot;&quot; width=&quot;480&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;The last story focuses on the
&lt;a href=&quot;https://github.com/cliffordwolf/picorv32&quot;&gt;PicoRV32&lt;/a&gt; CPU.  In this case, a
customer had asked me to create a basic FPGA accelerator design, such as the
one shown in Fig. 8 on the right.  I chose to demonstrate this using an FFT
accelerator.  As built, the board was to receive data from GbE network, and
then the &lt;a href=&quot;https://riscv.org&quot;&gt;RISC-V&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;
within the design would then push that data through the on-chip accelerator.&lt;/p&gt;

&lt;p&gt;Of course, in the end, nothing works as desired.  The first problem I had was
the DDR3 SDRAM.  Since the goal of the project was to use entirely open source
tools, logic, and software, I needed an &lt;a href=&quot;https://github.com/ZipCPU/zipversa/blob/master/rtl/wbddrsdram.v&quot;&gt;open source DDR3
controller&lt;/a&gt;
for an ECP5.  Since this wasn’t initially available, the team chose to skip the
DDR3 SDRAM.  (There’s now a &lt;a href=&quot;https://github.com/enjoy-digital/litedram&quot;&gt;litedram
controller&lt;/a&gt; that &lt;a href=&quot;https://github.com/enjoy-digital/litedram/blob/master/litedram/phy/ecp5ddrphy.py&quot;&gt;works with the
ECP5&lt;/a&gt;.)&lt;/p&gt;

&lt;p&gt;Sadly, this had consequences.&lt;/p&gt;

&lt;p&gt;The first consequence was that the &lt;a href=&quot;https://sourceware.org/newlib/&quot;&gt;newlib
C-library&lt;/a&gt; didn’t fit into my 64kB of
block RAM.  That meant that the CPU’s instructions would need to be placed into
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash memory&lt;/a&gt;.
As you may recall from our discussions about building a &lt;a href=&quot;/blog/2019/03/27/qflexpress.html&quot;&gt;flash
controller&lt;/a&gt;,
a QSPI flash memory requires 8 serial port clocks (6 for address, and then
2 dummy clocks) just to start a transaction.  Another 8 clocks are needed
to read any 32-bit instruction word.&lt;/p&gt;

&lt;p&gt;Making matters worse, the ECP5 chip the project ran on didn’t provide first
class access to the flash clock pin.  I needed to go through a logic block
to get access to it, and that block didn’t offer access to the DDR I/O
primitives &lt;a href=&quot;/blog/2019/03/27/qflexpress.html&quot;&gt;my controller&lt;/a&gt;
needed for high speed access.  In other words, I’d need to suffer a minimum of
32 clocks per instruction access, since each SPI clock would cost two system
clocks.  When all was said and done, interfaces written, bus delays added up,
the cost ended up being closer to 38 clocks per instruction access.&lt;/p&gt;

&lt;p&gt;The next piece of this problem surrounded the
&lt;a href=&quot;https://github.com/cliffordwolf/picorv32&quot;&gt;PicoRV32&lt;/a&gt;’s interfaces.  Unlike the
&lt;a href=&quot;/zipcpu/2017/11/18/wb-prefetch.html&quot;&gt;instruction
pre-fetch interface&lt;/a&gt; I
used for the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;, the
&lt;a href=&quot;https://github.com/cliffordwolf/picorv32&quot;&gt;PicoRV32&lt;/a&gt;’s bus interface involves
setting a valid line and an address line.  The environment is then expected to
go look up what ever is at that address, and then to return it to the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;.
Further, the only difference between reading and writing is that the
&lt;a href=&quot;https://github.com/cliffordwolf/picorv32&quot;&gt;PicoRV32&lt;/a&gt; sets the write select
bits when writing–so the wrapper needs to check these as well.  Finally, the
&lt;a href=&quot;https://github.com/cliffordwolf/picorv32&quot;&gt;PicoRV32&lt;/a&gt; also includes a flag to
indicate an instruction read request rather than a memory request.&lt;/p&gt;

&lt;p&gt;While I had a &lt;a href=&quot;/zipcpu/2018/07/13/memories.html&quot;&gt;block RAM
controller&lt;/a&gt; and a &lt;a href=&quot;/blog/2019/03/27/qflexpress.html&quot;&gt;flash
controller&lt;/a&gt;
sitting on a shelf, I didn’t have a
&lt;a href=&quot;https://github.com/cliffordwolf/picorv32&quot;&gt;PicoRV32&lt;/a&gt; &lt;a href=&quot;https://github.com/ZipCPU/zipversa/blob/master/rtl/picorv/wb_picorv32.v&quot;&gt;bus control
wrapper&lt;/a&gt;
that worked with &lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;AutoFPGA’s version of
Wishbone&lt;/a&gt;.
Building this was one of the project deliverables.&lt;/p&gt;

&lt;p&gt;You can see my &lt;a href=&quot;https://github.com/ZipCPU/zipversa/blob/master/rtl/picorv/wb_picorv32.v&quot;&gt;first draft of this wrapper
here&lt;/a&gt;. 
On any new bus request, the design sends the request to the
&lt;a href=&quot;/zipcpu/2017/10/05/autofpga-intro.html&quot;&gt;AutoFPGA&lt;/a&gt; generated
bus interconnect, and then returns the result to the
&lt;a href=&quot;https://github.com/cliffordwolf/picorv32&quot;&gt;CPU&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The problem with this design is that every instruction fetch is a separate
and independent bus transaction.  As a result, when the &lt;a href=&quot;/blog/2019/03/27/qflexpress.html&quot;&gt;flash
controller&lt;/a&gt;
sees that there are no further fetches coming, it ends the burst read.
Subsequent reads will require sending the address and mode bits again.  That’s
12 clocks for the address bits, and 4 more clocks for the mode bits, for a
total of 16 extra clocks per instruction that wouldn’t be needed were
multiple requests made one after another.&lt;/p&gt;

&lt;p&gt;Therefore, once I had completed the requirements of the contract, I took a
moment to see if I might build a better
&lt;a href=&quot;https://github.com/cliffordwolf/picorv32&quot;&gt;PicoRV32&lt;/a&gt; interface.&lt;/p&gt;

&lt;p&gt;The new design &lt;a href=&quot;/zipcpu/2018/03/21/dblfetch.html&quot;&gt;followed the techniques I discussed
here&lt;/a&gt;, with just a
couple of differences.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;First, I required an extra clock to know if the requested address was
the result of a &lt;a href=&quot;https://en.wikipedia.org/wiki/Branch_(computer_science)&quot;&gt;branch
instruction&lt;/a&gt;.
In &lt;a href=&quot;/zipcpu/2017/11/18/wb-prefetch.html&quot;&gt;my own pre-fetch interface
design&lt;/a&gt; the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt; exports a wire indicating any
time the &lt;a href=&quot;https://en.wikipedia.org/wiki/Program_counter&quot;&gt;program counter&lt;/a&gt;
has changed as a result of a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Branch_(computer_science)&quot;&gt;branch&lt;/a&gt;.  Not so
with the &lt;a href=&quot;https://github.com/cliffordwolf/picorv32&quot;&gt;PicoRV32&lt;/a&gt;.  I needed
to detect this in my bus wrapper.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;I also built a deeper lookup.  Instead of looking up only two instruction
words, and then looking up the next word anytime one of those two were
accepted, I chose to lookup up four words regardless of how fast the
&lt;a href=&quot;https://github.com/cliffordwolf/picorv32&quot;&gt;PicoRV32&lt;/a&gt; consumed them.&lt;/p&gt;

    &lt;p&gt;This was a draft design after all, to see if this might help, not something
final that was going to be part of this contract.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Finally, the &lt;a href=&quot;https://github.com/cliffordwolf/picorv32&quot;&gt;PicoRV32&lt;/a&gt;
muxes both instruction and data requests together across the same external
&lt;a href=&quot;https://github.com/cliffordwolf/picorv32&quot;&gt;CPU&lt;/a&gt;
interface.  My updated &lt;a href=&quot;https://en.wikipedia.org/wiki/Prefetching&quot;&gt;prefetch&lt;/a&gt;
routine needed to handle both types of requests.  Only the instruction
stream, where I could predict the next instruction address with some
certainty, would be partially
&lt;a href=&quot;https://en.wikipedia.org/wiki/Cache_(computing)&quot;&gt;cached&lt;/a&gt;.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;a href=&quot;/formal/2018/07/14/dev-cycle.html&quot;&gt;As with any formal proof&lt;/a&gt;,
I started with the &lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus
properties&lt;/a&gt;.  I then
added further properties to include properties I felt necessary for
&lt;a href=&quot;/blog/2018/03/10/induction-exercise.html&quot;&gt;induction&lt;/a&gt;,
and also created properties to describe the CPU side of the interface.&lt;/p&gt;

&lt;p&gt;When I was confident the design worked using
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal methods&lt;/a&gt;,
I switched to simulation and immediately my “working” programs (i.e. &lt;a href=&quot;https://en.wikipedia.org/wiki/%22Hello,_World!%22_program&quot;&gt;Hello
World&lt;/a&gt;) stopped
working.&lt;/p&gt;

&lt;p&gt;What happened?&lt;/p&gt;

&lt;p&gt;In this case, the software called for a data load during one of my set of four
instruction fetches.  Instead of waiting for the series of four instruction
fetches to finish and then initiating a request for the data, the core
returned the value from the ongoing instruction fetch to the data port.&lt;/p&gt;

&lt;p&gt;Why?  Because I returned a data value on any bus acknowledgment … a simple
oversight.&lt;/p&gt;

&lt;p&gt;Couldn’t formal methods have caught this?&lt;/p&gt;

&lt;p&gt;Yes, they could’ve and they should’ve.  Why didn’t they?  Because I got sloppy.
I was trying to do something quick, and I had tried to short-circuit the
&lt;a href=&quot;/zipcpu/2018/07/13/memories.html&quot;&gt;memory property check&lt;/a&gt;
on the data bus in order to build this design on the quick.&lt;/p&gt;

&lt;p&gt;Lesson learned.&lt;/p&gt;

&lt;h2 id=&quot;the-project-with-no-bugs&quot;&gt;The Project with no bugs&lt;/h2&gt;

&lt;p&gt;The past four project stories have all involved finding ugly bugs in them.&lt;/p&gt;

&lt;p&gt;I should mention before going on that I’ve also had the experience where a
formally verified
project has no logic bugs in it.&lt;/p&gt;

&lt;p&gt;Tool issues?  Yes.  What works with the Yosys parser doesn’t necessarily work
with the Verific parser, and even that doesn’t necessarily work with Vivado or
Quartus.  What about language “standards”?  Yeah.  However, I should point out
that those who have tried my &lt;a href=&quot;/formal/2018/12/28/axilite.html&quot;&gt;formally
verified&lt;/a&gt;
&lt;a href=&quot;/blog/2019/05/29/demoaxi.html&quot;&gt;AXI&lt;/a&gt; or
&lt;a href=&quot;/blog/2019/01/12/demoaxilite.html&quot;&gt;AXI-lite slaves&lt;/a&gt;
have often commented that they’ve worked the first time.&lt;/p&gt;

&lt;p&gt;The key takeaway here is that it is possible to fully verify something using
formal methods alone.  I just need to learn how to reproduce this success in
all of my designs.&lt;/p&gt;

&lt;h2 id=&quot;lessons-learned&quot;&gt;Lessons Learned&lt;/h2&gt;

&lt;p&gt;Every year that I’ve gone to &lt;a href=&quot;https://dvcon.org&quot;&gt;DVCON&lt;/a&gt;, there’s been a
contractor or two selling “formal &lt;a href=&quot;https://en.wikipedia.org/wiki/Signoff_(electronic_design_automation)&quot;&gt;sign-off&lt;/a&gt;”
services.  I understand this to mean that by using their services, they will use
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal methods&lt;/a&gt;
to verify your design to the point where it can be trusted enough for an
&lt;a href=&quot;/blog/2017/10/13/fpga-v-asic.html&quot;&gt;ASIC&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Tape-out&quot;&gt;tape-out&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;That’s awesome.  I’ll be honest, I look up to anyone who can stand by such a
claim and ability.&lt;/p&gt;

&lt;p&gt;However, as illustrated from the examples above, this has not been my
experience in general.  While it has always been my goal, and while I’ve
had a success or two doing this, I haven’t yet been able to fully eliminate
&lt;a href=&quot;/blog/2018/08/22/what-is-simulation.html&quot;&gt;simulation&lt;/a&gt;
simulation from my personal design process.&lt;/p&gt;

&lt;p&gt;That said, these four examples above do illustrate some important takeaways:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;There’s always a need for
&lt;a href=&quot;/blog/2018/08/22/what-is-simulation.html&quot;&gt;simulation&lt;/a&gt;
in &lt;a href=&quot;https://en.wikipedia.org/wiki/Integration_testing&quot;&gt;&lt;em&gt;integration&lt;/em&gt; testing&lt;/a&gt;.&lt;/p&gt;

    &lt;p&gt;To date, I’ve only ever formally verified design &lt;em&gt;components&lt;/em&gt;, never
entire designs.  The larger the component has been, the more difficult the
formal proof becomes.  As a result, I’ve always had a need to use
&lt;a href=&quot;/blog/2018/08/22/what-is-simulation.html&quot;&gt;simulation&lt;/a&gt;
to test an entire design.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Most of my simulation testing I’ve done has tended to be rather ad-hoc.
My tests tend to be designed towards only ever demonstrate a single working
path through my design.  Indeed, simulations in general &lt;em&gt;never verify every
working path&lt;/em&gt; within a design.  Only formal does that.&lt;/p&gt;

    &lt;p&gt;The best evidence for this is the fact that I never sufficiently tested
whether element 521 could be properly returned by the compression algorithm,
but that element 522 would be properly rejected.&lt;/p&gt;

    &lt;p&gt;I am looking forward to fixing some of my personal test-script issues by
using &lt;a href=&quot;https://github.com/YosysHQ/mcy&quot;&gt;Symbiotic EDA’s new
mutation engine&lt;/a&gt;–but we’ll save the
discussion on how to use that engine for a later date.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Don’t forget to &lt;code class=&quot;highlighter-rouge&quot;&gt;cover()&lt;/code&gt; the design returning to idle.&lt;/p&gt;

    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;cover()&lt;/code&gt; is great for proving that an operation can complete, or that you
haven’t assumed away the answer.  However, just verifying that a design will
return the correct answer upon request isn’t enough–you have to &lt;code class=&quot;highlighter-rouge&quot;&gt;cover()&lt;/code&gt;
the return to the beginning or idle state.&lt;/p&gt;

    &lt;p&gt;As I mentioned above, I also like checking 2-3 transactions via a &lt;code class=&quot;highlighter-rouge&quot;&gt;cover()&lt;/code&gt;
statement, so that I can measure best-case throughput as well.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Even though the two formally verified designs above still needed to be
&lt;a href=&quot;/blog/2018/08/22/what-is-simulation.html&quot;&gt;simulated&lt;/a&gt;,
and even though new bugs were caught in that
&lt;a href=&quot;/blog/2018/08/22/what-is-simulation.html&quot;&gt;simulation&lt;/a&gt;
check, I never found more than one bug in each.&lt;/p&gt;

    &lt;p&gt;The &lt;a href=&quot;https://github.com/ZipCPU/blob/master/rtl/core/dcache.v&quot;&gt;data cache&lt;/a&gt;
has now worked for me for over a year without further logic problems.  (There
were some &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blame/master/rtl/core/dcache.v&quot;&gt;tool
incompatibilities&lt;/a&gt;
…) The &lt;a href=&quot;https://github.com/ZipCPU/blob/master/rtl/core/pfcache.v&quot;&gt;instruction
cache&lt;/a&gt;
has likewise been formally verified, and it has worked for much longer
without problems.  Indeed, it’s undergone several revisions without
suffering from any more bugs caught during
&lt;a href=&quot;/blog/2018/08/22/what-is-simulation.html&quot;&gt;simulation&lt;/a&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Individual design components need their own verification infrastructure.&lt;/p&gt;

    &lt;p&gt;This was one of the painful lessons I learned from the bus return
&lt;a href=&quot;https://github.com/ZipCPU/zipversa/blob/master/rtl/wbubus/wbucompress.v&quot;&gt;compression algorithm&lt;/a&gt;.
In this case, I had tested it as part of a larger design and missed the
difference between &lt;code class=&quot;highlighter-rouge&quot;&gt;10&#39;h521&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;10&#39;d521&lt;/code&gt;.  I then copied it from one
design to the next, to the next, to the next, and then needed to make a
change to it.  Having no method of testing the component, I instead queued
a minor disaster up for myself some time later.&lt;/p&gt;

    &lt;p&gt;Now, sadly, I’ve learned that I need to go back through this entire
debugging bus implementation in order to add in proper verification
logic–logic that should’ve been created when the design was
initially created years ago.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;There’s not a single bug listed above that could not have been caught using
either &lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal methods&lt;/a&gt;
&lt;em&gt;or&lt;/em&gt; an appropriate
&lt;a href=&quot;/blog/2018/08/22/what-is-simulation.html&quot;&gt;simulation&lt;/a&gt;.&lt;/p&gt;

    &lt;p&gt;This goes both ways.  Any bug caught via
&lt;a href=&quot;/blog/2018/08/22/what-is-simulation.html&quot;&gt;simulation&lt;/a&gt;,
but not &lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal&lt;/a&gt;, can
be turned into a formal property to be subsequently checked.  Any bug caught
via &lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal methods&lt;/a&gt;
but not
&lt;a href=&quot;/blog/2018/08/22/what-is-simulation.html&quot;&gt;simulation&lt;/a&gt;,
can be used to generate a better test script.&lt;/p&gt;

    &lt;p&gt;Indeed, my guess is that &lt;a href=&quot;/formal/2019/09/06/axi-story.html&quot;&gt;now that I’ve found bugs that weren’t caught by
Xilinx’s AXI VIP&lt;/a&gt;,
they’ll quickly adjust their product.  I certainly would if I were them.
I also expect that once these updates go through, that things that pass
their AXI VIP will look like they work again, the demonstration designs
will get fixed … and all will be look good again on the surface.  However,
the moment you make one change to those designs, everything will be up in the
air again.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Just because something “works” in practice, doesn’t truly mean it “works”&lt;/p&gt;

    &lt;p&gt;The reference to &lt;code class=&quot;highlighter-rouge&quot;&gt;10&#39;h521&lt;/code&gt; rather than &lt;code class=&quot;highlighter-rouge&quot;&gt;10&#39;d521&lt;/code&gt; existed in the compression
scheme since it was written.  It was there for many years, waiting until
just the right sequence triggered it.&lt;/p&gt;

    &lt;p&gt;Although I hadn’t noticed this bug earlier, the design never truly worked
earlier either.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The really ugly lessons learned come only after working with a design for
some period of time.&lt;/p&gt;

    &lt;p&gt;This is a sad reality of IP core development.  Just because a given IP core
works in some designs, just because it passes the threshold for the
instructor to grant an &lt;code class=&quot;highlighter-rouge&quot;&gt;A&lt;/code&gt;, or for the customer to accept the design work,
doesn’t mean it will work in all designs.  This is fundamentally the problem
with
&lt;a href=&quot;/blog/2018/08/22/what-is-simulation.html&quot;&gt;simulation&lt;/a&gt;–you
can’t test everything.&lt;/p&gt;

    &lt;p&gt;The good news is that the longer you use a given core, then (hopefully) the
closer it gets to perfection.  That is, at least until you need to rewrite
it.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Let me share one final thought:  If you choose to cut corners in verification,
like I did to test the updated
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;Wishbone&lt;/a&gt; wrapper
for the &lt;a href=&quot;https://github.com/cliffordwolf/picorv32&quot;&gt;PicoRV32&lt;/a&gt;, then it doesn’t
matter whether when using
&lt;a href=&quot;/blog/2018/08/22/what-is-simulation.html&quot;&gt;simulation&lt;/a&gt;
techniques or &lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal
methods&lt;/a&gt;.  Either way,
you are setting yourself up for getting burned later on.&lt;/p&gt;

&lt;p&gt;The good news, though, is that by using the updated wrapper I could speed up
the &lt;a href=&quot;https://github.com/cliffordwolf/picorv32&quot;&gt;PicoRV32&lt;/a&gt; by a factor of 2x.&lt;/p&gt;

&lt;p&gt;We’ll leave that thought, though, to be the topic of another article.&lt;/p&gt;
&lt;hr /&gt;&lt;p&gt;&lt;em&gt;And he began to speak unto them by parables. A certain man planted a vineyard, and set an hedge about it, and digged a place for the winefat, and built a tower, and let it out to husbandmen, and went into a far country. (Mark 12:1)&lt;/em&gt;</description>
        <pubDate>Sat, 05 Oct 2019 00:00:00 -0400</pubDate>
        <link>https://zipcpu.com/formal/2019/10/05/formal-enough.html</link>
        <guid isPermaLink="true">https://zipcpu.com/formal/2019/10/05/formal-enough.html</guid>
        
        
        <category>formal</category>
        
      </item>
    
      <item>
        <title>Quiz #6: Synchronous logic in Asynchronous contexts</title>
        <description>&lt;p&gt;This quiz is really intended for the open version of SymbiYosys.  The
open Yosys doesn’t quite implement &lt;code class=&quot;highlighter-rouge&quot;&gt;$global_clock&lt;/code&gt; properly.  According to
the SystemVerilog standard, &lt;code class=&quot;highlighter-rouge&quot;&gt;$global_clock&lt;/code&gt; is supposed to be a clock
chosen by the designer to be the default clock thoughout the design any
time a default clock is necessary throughout an entire design, rather than
(as used here) one that is set by the tools to be a formal time step.&lt;/p&gt;

&lt;p&gt;As a result, the reference to &lt;code class=&quot;highlighter-rouge&quot;&gt;$global_clock&lt;/code&gt; as used above has been
deprecated.  I also expect this non-standard usage to be removed soon enough.&lt;/p&gt;

&lt;p&gt;To fix this issue, Yosys now supports the attribute &lt;code class=&quot;highlighter-rouge&quot;&gt;(* gclk *)&lt;/code&gt; to define
a wire or register that will contain the formal timestep.  You can then use
edges of such a register, rather than &lt;code class=&quot;highlighter-rouge&quot;&gt;$global_clock&lt;/code&gt;, to specify the
formal timestep.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;gclk&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;reg&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;gbl_clk&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;always&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;posedge&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;gbl_clk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;assert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Were you using concurrent assertions, the design should read:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;gclk&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;reg&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;gbl_clk&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;assert&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;property&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;posedge&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;gbl_clk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;fell&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i_clk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|-&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;stable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;signal&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
	
&lt;span class=&quot;k&quot;&gt;assert&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;property&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;posedge&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;gbl_clk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;rose&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i_clk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|-&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;stable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;signal&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
	
&lt;span class=&quot;k&quot;&gt;assert&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;property&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;posedge&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;gbl_clk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;past&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i_clk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|-&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;stable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;signal&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;That said, only one of these captures the logic check desired.  Can you tell
which one?&lt;/p&gt;
</description>
        <pubDate>Fri, 06 Sep 2019 00:00:00 -0400</pubDate>
        <link>https://zipcpu.com/quiz/2019/09/06/quiz06.html</link>
        <guid isPermaLink="true">https://zipcpu.com/quiz/2019/09/06/quiz06.html</guid>
        
        
        <category>quiz</category>
        
      </item>
    
      <item>
        <title>AXI Verification, the story so far</title>
        <description>&lt;p&gt;&lt;a href=&quot;https://orconf.org&quot;&gt;ORCONF 2019&lt;/a&gt; is coming up, and I’m planning on presenting
slides on the topic of &lt;a href=&quot;/formal/2018/12/28/axilite.html&quot;&gt;formally verifying AXI
interfaces&lt;/a&gt;.  My intent was
just to share some of the bugs I’ve found and so to encourage folks to use
formal verification tools, such as the
&lt;a href=&quot;https://symbiyosys.readthedocs.io/en/latest&quot;&gt;SymbiYosys&lt;/a&gt; tool that I’ve been
using.  However, as I started to put the story together, I also started to
realize just how important this topic is.&lt;/p&gt;

&lt;p&gt;Here’s the bottom line: AXI is very difficult to verify using traditional
simulation based methods.  How difficult is it?  So difficult that many of the
major vendors out there have gotten it wrong.&lt;/p&gt;

&lt;p&gt;Let me back up, though, and walk you through some of the details.&lt;/p&gt;

&lt;h2 id=&quot;axi-whats-that&quot;&gt;AXI, what’s that?&lt;/h2&gt;

&lt;p&gt;It begins with the chip manufacturing industry.  There are a lot of companies
out there building their own special and secret sauce into digital electronics.
The reality, though, is that many of the tasks these chips are responsible
for performing are challenging to do in raw digital hardware.  It’s not that
they cannot be done, but rather that it’s a lot easier to do them in software.
That means that if you want to build a custom silicon widget, you are likely
to want to include a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;
into your custom widget as well.&lt;/p&gt;

&lt;p&gt;While building a basic
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;
may be a college student’s class project, building and maintaining the
assembler, linker, compiler, debugger, and indeed the whole tool chain is a
task few design houses want to take on for themselves.  It’s just easier to
purchase someone else’s
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;,
rather than to handle all of this work yourself.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 1. A basic AXI bus structure&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/axi-story/axi-in-everything.svg&quot; alt=&quot;&quot; width=&quot;360&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;One of the most popular
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;s
in the embedded sub-chip IP market is the
&lt;a href=&quot;https://en.wikipedia.org/wiki/ARM_architecture&quot;&gt;ARM&lt;/a&gt;.  While
&lt;a href=&quot;https://riscv.org&quot;&gt;RISC-V&lt;/a&gt; may well give
&lt;a href=&quot;https://en.wikipedia.org/wiki/ARM_architecture&quot;&gt;ARM&lt;/a&gt;
a run for their money, much of the industry has already standardized
around a set of &lt;a href=&quot;https://en.wikipedia.org/wiki/ARM_architecture&quot;&gt;ARM&lt;/a&gt; bus
protocol standards drawn from the &lt;a href=&quot;https://en.wikipedia.org/wiki/Advanced_Microcontroller_Bus_Architecture&quot;&gt;AMBA bus protocol
set&lt;/a&gt;.
Of these, the high bandwidth standard is clearly
&lt;a href=&quot;/blog/2019/05/29/demoaxi.html&quot;&gt;AXI&lt;/a&gt;.  As a result, if you
want to connect your secret sauce to a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt; hidden inside
your proprietary integrated circuit technology, you are likely going to be
using an &lt;a href=&quot;/blog/2019/05/29/demoaxi.html&quot;&gt;AXI bus&lt;/a&gt; to connect
the pieces together.&lt;/p&gt;

&lt;p&gt;Recognizing this reality, and the fact that
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGAs&lt;/a&gt; are
often used to test the logic within integrated circuits before &lt;a href=&quot;/blog/2017/10/13/fpga-v-asic.html&quot;&gt;burning
them into actual hardware&lt;/a&gt;,
the two major
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt; vendors
have been offering &lt;a href=&quot;/blog/2019/05/29/demoaxi.html&quot;&gt;AXI&lt;/a&gt;
based tooling for some time.  This includes not only the
&lt;a href=&quot;/blog/2019/07/17/crossbar.html&quot;&gt;AXI bus fabric&lt;/a&gt; that connects
everything together, but also several basic design components like &lt;a href=&quot;https://en.wikipedia.org/wiki/Synchronous_dynamic_random-access_memory&quot;&gt;SDRAM
controllers&lt;/a&gt;, memory movers,
&lt;a href=&quot;https://en.wikipedia.org/wiki/Direct_memory_access&quot;&gt;DMA&lt;/a&gt;
engines, &lt;a href=&quot;/blog/2018/11/29/llvga.html&quot;&gt;video controllers&lt;/a&gt;,
&lt;a href=&quot;/blog/2019/03/27/qflexpress.html&quot;&gt;flash controllers&lt;/a&gt;, as well
as example designs so that their users can get more value from their hardware.
These basic &lt;a href=&quot;/formal/2019/05/13/axifull.html&quot;&gt;AXI&lt;/a&gt;
designs are offered for free to anyone who uses their tools.  As a result, the
example designs in particular have become rather ubiquitous–so much so that
any error in one or the other tends to show up over and over again in the
code of anyone who used that example as a foundation for their own work.  Again,
this shouldn’t be surprising to anyone.&lt;/p&gt;

&lt;h2 id=&quot;formal-methods&quot;&gt;Formal methods&lt;/h2&gt;

&lt;p&gt;This was where I entered the picture.  In October, 2017, &lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;I tried out formal
methods&lt;/a&gt; for the
first time on what I thought was a fairly basic and simple design.  My plan
was just to write a review about some new “formal verification” fad and then
to go back to &lt;a href=&quot;/blog/2017/06/02/design-process.html&quot;&gt;digital design the way I had been doing
it&lt;/a&gt;.  My plan changed
when the tool found bugs in my design.  So I then tried applying the tool to
another one of my “working” designs.  The same thing happened, the tool found
bugs in it.  Valid bugs.  &lt;a href=&quot;/blog/2018/01/22/formal-progress.html&quot;&gt;Over and over I applied the formal
tools&lt;/a&gt;
to my designs and found more and more bugs.&lt;/p&gt;

&lt;p&gt;To understand how significant these bugs were, consider these: an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Synchronous_dynamic_random-access_memory&quot;&gt;SDRAM&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/xulalx25soc/blob/master/rtl/wbsdram.v&quot;&gt;controller&lt;/a&gt;
that might fetch the wrong memory address, a
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt; &lt;a href=&quot;https://en.wikipedia.org/wiki/Cache_(computing)&quot;&gt;instruction
cache&lt;/a&gt; that &lt;a href=&quot;/zipcpu/2017/12/28/ugliest-bug.html&quot;&gt;returned the
wrong instruction&lt;/a&gt;,
or even an &lt;a href=&quot;/dsp/2018/10/02/fft.html&quot;&gt;FFT&lt;/a&gt; that worked for one
set of sizes and bit widths but not for others.  The list goes on.&lt;/p&gt;

&lt;p&gt;Eventually, I stopped verifying my designs after the fact and &lt;a href=&quot;/formal/2018/07/14/dev-cycle.html&quot;&gt;started going
straight to formal verification tools before ever picking up a
simulator&lt;/a&gt;.  Design has
never been &lt;a href=&quot;/formal/2019/08/03/proof-duration.html&quot;&gt;so fast&lt;/a&gt;
or so easy as a result.  Indeed, the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/dcache.v&quot;&gt;data
cache&lt;/a&gt; that I
had wanted to build for years suddenly came together inside of two weeks.&lt;/p&gt;

&lt;p&gt;By the end of 2018, I’d also struggled many times to build my own AXI
interface components.  In &lt;a href=&quot;/blog/2019/04/27/axi-addr.html&quot;&gt;one particularly painful
example&lt;/a&gt;, I was forced
to deliver a design to a customer that didn’t live up to the promises I had
made to him.  Even now, most of my work has been done using
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;Wishbone&lt;/a&gt;–it’s much
&lt;a href=&quot;/zipcpu/2017/05/29/simple-wishbone.html&quot;&gt;simpler to use&lt;/a&gt;.
Sadly, though, if you want to interact with the modern
&lt;a href=&quot;https://en.wikipedia.org/wiki/ARM_architecture&quot;&gt;ARM&lt;/a&gt;+&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
SOC chips like either Xilinx’s Zynq or one of &lt;a href=&quot;/blog/2018/02/09/first-cyclonev.html&quot;&gt;Intel’s
SOC&lt;/a&gt;s, you will
(eventually) &lt;a href=&quot;/blog/2019/04/27/axi-addr.html&quot;&gt;need to learn to speak
AXI&lt;/a&gt;.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: left; padding: 15px&quot;&gt;&lt;caption&gt;Fig 2. Verification using a formal property file(s)&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/axi-story/fp-file.svg&quot; alt=&quot;&quot; width=&quot;320&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;As I mentioned above, my first attempts at building AXI components dismal
failures.  My second set of attempts weren’t much better.  Finally, somewhere
around last Christmas time, I started picking up AXI and formal verification
together.  I first &lt;a href=&quot;/formal/2018/12/28/axilite.html&quot;&gt;built a set of formal properties for
AXI-lite&lt;/a&gt;, and then again
later for &lt;a href=&quot;/formal/2019/05/13/axifull.html&quot;&gt;AXI&lt;/a&gt;.  These
properties make it easy to verify &lt;a href=&quot;/blog/2019/05/29/demoaxi.html&quot;&gt;AXI
bus&lt;/a&gt; components–much easier
than &lt;a href=&quot;/blog/2018/08/22/what-is-simulation.html&quot;&gt;simulation&lt;/a&gt;
alone.  The neat thing about this approach is that the property files can then
be reused from one AXI design to another with only minimal configuration
and set up.  Hence, once I built one design, getting the next one right became
easier.&lt;/p&gt;

&lt;p&gt;Not knowing whether or not I understood the bus standard well enough, my first
&lt;a href=&quot;/formal/2018/12/28/axilite.html&quot;&gt;AXI-lite&lt;/a&gt; and
&lt;a href=&quot;/formal/2019/05/13/axifull.html&quot;&gt;AXI&lt;/a&gt; verification
projects were to verify any publicly available code I could get my hands on.  I
started with Xilinx’s example code, and then moved on to verifying several
projects on Github, and finally looked into Intel’s example AXI code.
I was expecting to find examples that met the &lt;a href=&quot;/doc/axi-spec.pdf&quot;&gt;AXI
standard&lt;/a&gt; that I could then learn from.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 3. Most example designs have two parts&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/axi-story/ex-design.svg&quot; alt=&quot;&quot; width=&quot;320&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Let me pause at this point to describe what I mean by an “example” design,
or even a “demonstration” design.  These are vendor provided example logic
designs, such as the one illustrated in Fig. 3 on the right and typically
written in Verilog, VHDL, or both, that show the proper
interaction between a bus component and the bus.  Typically, they are written
in a fashion so that you can adjust a user logic section however
you might like, while another portion of the design provided by the vendor
handles all of the more difficult AXI bus interaction logic.&lt;/p&gt;

&lt;p&gt;Much to my surprise, most of the cores I examined had bugs in them.
I’ve &lt;a href=&quot;https://twitter.com/ZipCPU&quot;&gt;tweeted&lt;/a&gt; about many of these, and so now
I’m collecting these examples into some slides that I can present at
&lt;a href=&quot;https://orconf.org&quot;&gt;ORCONF&lt;/a&gt; in just a couple of weeks.&lt;/p&gt;

&lt;h2 id=&quot;its-worse-than-a-software-bug&quot;&gt;It’s worse than a software bug&lt;/h2&gt;

&lt;p&gt;One of the jokes in the flying world is that pilots need to maintain “the
ratio”: one safe landing for every take off.  AXI bus interactions are
in many ways no different, there needs to be one response for every request.
Further, just as most airplanes don’t offer ejection seats or parachutes,
AXI doesn’t offer a “bus abort” capability.  As a result, if you fail to
keep the “ratio” then really “bad” things will happen.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: left; padding: 15px&quot;&gt;&lt;caption&gt;Fig 4. Every request must get a response&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/axi-story/request-response.svg&quot; alt=&quot;&quot; width=&quot;320&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;What kind of “bad” things are we talking about?  In the case of a bus,
a bus master makes a request–whether or read or write–and the slave responds.
In the case of AXI, the fact that it has no abort capability means that a master
must wait for a response until it arrives.  The standard doesn’t allowed it to
time out and give up after waiting a second, minute, hour, or year.  Even
if the response gets dropped or otherwise becomes missing, the master must
still wait for a response.&lt;/p&gt;

&lt;p&gt;Sadly, I discovered the problem with this in my first &lt;a href=&quot;/blog/2018/02/09/first-cyclonev.html&quot;&gt;Cyclone-V
SOC&lt;/a&gt;
design.  At one point when I had a mistake within my own logic so that the
design didn’t respond to the bus like it was supposed to, the bus and the
&lt;a href=&quot;https://en.wikipedia.org/wiki/ARM_architecture&quot;&gt;ARM&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;
driving the bus, locked up hard.  Only a reset, forcing a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;
reboot, fixed the bug.&lt;/p&gt;

&lt;p&gt;In my example, I was lucky.  Knowing that there was a bug in my design, I was
able to then turn around and &lt;a href=&quot;/blog/2017/06/21/looking-at-verilator.html&quot;&gt;simulate my
design&lt;/a&gt; and
find the bug.  I haven’t always been this lucky, and things could’ve been much
worse.  Had I not been able to reproduce the bug in
&lt;a href=&quot;/blog/2018/08/22/what-is-simulation.html&quot;&gt;simulation&lt;/a&gt;,
I might have ended up stuck in &lt;a href=&quot;/blog/2017/05/19/fpga-hell.html&quot;&gt;FPGA
Hell&lt;/a&gt; myself, staring
at a flawed design with no idea how to fix it.&lt;/p&gt;

&lt;p&gt;Others haven’t been so lucky.&lt;/p&gt;

&lt;p&gt;Even among those who ask for help there are a lot of problems that can’t be
solved by a disinterested stranger looking over unfamiliar logic.  It’s only
gets worse when you have no clue where to start looking, as might happen
with a design that suddenly locks up the whole system.&lt;/p&gt;

&lt;p&gt;You need to understand, this isn’t a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Kernel_panic&quot;&gt;kernel panic&lt;/a&gt;
type of bug.  We’re not talking about the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Blue_Screen_of_Death&quot;&gt;blue sceen of death&lt;/a&gt;
here either.  Nor are we talking
about bugs where your &lt;a href=&quot;https://en.wikipedia.org/wiki/Segmentation_fault&quot;&gt;application just
failed&lt;/a&gt;.  No, we are
talking about something even more severe.  A fault in the
&lt;a href=&quot;/formal/2019/05/13/axifull.html&quot;&gt;AXI bus&lt;/a&gt; structure
whereby a component fails to respond properly is catastrophic.  The result
will be a whole system crash so hard that only a power cycle can fix it.&lt;/p&gt;

&lt;p&gt;Given that &lt;a href=&quot;/blog/2017/07/08/getting-started-with-wbscope.html&quot;&gt;I use the bus for
debugging&lt;/a&gt;,
such a crash leaves me blind to the cause.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 5. Two types of catastrophic bugs&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/axi-story/catastrophic-two-types.svg&quot; alt=&quot;There are two types of catastrophic bugs: those that return too few responses, and those that return too many&quot; width=&quot;320&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;So what kind of bugs did I find?  I found both types of catastrophic bugs.  Not
only did I find peripherals that didn’t produce as many responses as requests
they had received, but I also found bus masters that would drop requests before
the bus had accepted them.&lt;/p&gt;

&lt;p&gt;In one &lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt; I examined
from a major vendor, two load or two store instructions, back to back, would
cause a transaction to be dropped if the interconnect wasn’t immediately ready
to receive to the request.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: left; padding: 15px&quot;&gt;&lt;caption&gt;Fig 6. An interconnect bug&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/axi-story/buggy-interconnect.svg&quot; alt=&quot;Interconnect routes a slaves response to the wrong master&quot; width=&quot;480&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Worse, I even found an
&lt;a href=&quot;/blog/2019/07/17/crossbar.html&quot;&gt;interconnect&lt;/a&gt;,
something that connects multiple masters to multiple peripherals such as the
one shown in Fig. 6, where a request from one master would get sent to the
correct slave, but then the response from the slave would be returned back
to a different master.&lt;/p&gt;

&lt;p&gt;It wasn’t pretty.&lt;/p&gt;

&lt;p&gt;Indeed, I found bugs in a very large percentage of the cores I examined.&lt;/p&gt;

&lt;p&gt;It didn’t help that many demonstration cores, and how-to blog articles
I found had bugs in their example cores that were then copied into various
user designs.  Neither did it help that the example designs from &lt;em&gt;both&lt;/em&gt; major
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
vendors had catastrophic bugs within them.&lt;/p&gt;

&lt;p&gt;As you might imagine, I was rather perplexed by this.  In many ways, none of
this made any sense.  If these problems were really so bad, how was it that
no one had noticed them?&lt;/p&gt;

&lt;p&gt;One possibility was that each vendor only checked their cores in their own
environment, and somehow the environment was masking the bugs.  As an example,
some of the bugs I found would be only triggered if the bus was ever used in
a particular configuration.  I also found that one vendor had crippled
the throughput of their interconnect–perhaps because no one really knew who or
what was responsible for the user bugs.
[&lt;a href=&quot;/zipcpu/2019/02/09/cpu-blinky.html&quot;&gt;1&lt;/a&gt;] [&lt;a href=&quot;/blog/2019/05/29/demoaxi.html&quot;&gt;2&lt;/a&gt;]&lt;/p&gt;

&lt;p&gt;So I started browsing and participating in various forums.&lt;/p&gt;

&lt;h2 id=&quot;working-the-forums-for-answers&quot;&gt;Working the forums for answers&lt;/h2&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 7. Digilent&#39;s Popular Contributors&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/axi-story/leader-board.png&quot; alt=&quot;&quot; width=&quot;296&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Back in the beginning, when I first started to try to sell my services as an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
design engineer, I worked &lt;a href=&quot;/digilent/2017/05/18/most-common-digilent-support-requests.html&quot;&gt;Digilent’s
forums&lt;/a&gt;
fairly hard in the hopes that I might gain some free publicity and perhaps
even a contract.
Even to this date I’m one of their leading all time contributors, even though
I’ve stopped working the forum as hard and the forum moderator’s have since
caught up and one has passed me.
Since I had just left the military service, I was hoping this might be a way
to find some commercial work.  The technique worked well, since I found
two contracts, several long-term business relationships, and even some free
hardware as a result of it–such as a &lt;a href=&quot;https://store.digilentinc.com/nexys-video-artix-7-fpga-trainer-board-for-multimedia-applications&quot;&gt;Nexys Video
board&lt;/a&gt;
and even a &lt;a href=&quot;/blog/2017/09/14/even-i-get-stuck.html&quot;&gt;Digital
Discovery&lt;/a&gt;.
This time, however, I worked up the chain on the major vendor’s forums, rather
than those of their outlets.  Specifically, I was looking for examples of the
bugs listed above, or if not then I was hoping to discover why they weren’t
being triggered.  I was also looking for example designs to check my formal
property files against.&lt;/p&gt;

&lt;p&gt;While much of what I found was fairly benign, such as brand-new students
struggling to figure out their engineering design homework, there were
also many professional design engineers participating in these forums and
asking for help regarding the problems they had come across.&lt;/p&gt;

&lt;p&gt;In one conversation, I came across a user asking for help whose AXI slave
design wasn’t working.  When I asked if he would try my own &lt;a href=&quot;/formal/2019/01/12/demoaxilite.html&quot;&gt;formally verified
design&lt;/a&gt;,
he tried it and the bugs went away.  Sadly, we never found or identified the
bug(s) in his own (VHDL) code–perhaps because he never shared enough of his
design.  Incidentally, when I offered him &lt;a href=&quot;/formal/2019/01/12/demoaxilite.html&quot;&gt;my own design to
try&lt;/a&gt;,
I never told him that this was the first time the core had been tried in either
hardware or simulation.  It “just worked” the first time.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: left; padding: 15px&quot;&gt;&lt;caption&gt;Fig 8. Updating software breaks the hardware design&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/axi-story/new-software.svg&quot; alt=&quot;&quot; width=&quot;240&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;In another conversation, an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
design engineer had built a design and delivered it to his product team in
a “working” condition for the software programmer to take over.  The design
contained a &lt;a href=&quot;https://en.wikipedia.org/wiki/MicroBlaze&quot;&gt;MicroBlaze&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt; and whatever
application sauce they were putting into it, such as is shown in Fig. 8.  This
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
design engineer then left the company.  Some time later, the software
engineer made some changes to his
&lt;a href=&quot;https://en.wikipedia.org/wiki/MicroBlaze&quot;&gt;MicroBlaze&lt;/a&gt; software–not the
hardware design, but the software for the
&lt;a href=&quot;https://en.wikipedia.org/wiki/MicroBlaze&quot;&gt;MicroBlaze&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;
within it.  The result was that the design locked up following two adjacent
store instructions and no one could understand why.  This pattern also matched
the bugs that I had found.&lt;/p&gt;

&lt;p&gt;Someone else posted on a &lt;a href=&quot;https://reddit.com/r/FPGA&quot;&gt;Reddit forum&lt;/a&gt; that their
design wasn’t working, curious if anyone had seen similar problems before.  I
asked if he had formally verified his design.  Instead of responding to
me, he turned around and posted on the vendor’s forum no longer asking but
now declaring that their
interconnect was broken.  Again, I asked if he had formally verified his
design or, if not, if he’d release his source code and I’d check it for him.  He
then proceeded to ignored me for a second time and instead posted a trace that
was supposed to show the bug.  When you looked closer at the trace, however,
you found a bug within his core and not the interconnect: one request was
creating two responses.  His design wasn’t keeping up the “ratio”.  Formal
methods would’ve caught that.&lt;/p&gt;

&lt;p&gt;Another engineer posted, wondering what was wrong with the vendor tools.
When I asked if he could or would share his source, he refused.  Sadly, this
is a rather common though unfortunate answer.  Digital logic is designed and
sold, and protecting the market tends to keep corporations tight-lipped about
their secret algorithms–since it represents real money to them.  Instead,
this engineer offered a “sanitized” version of what he was doing.  With the
&lt;a href=&quot;/formal/2019/04/16/axi-mistakes.html&quot;&gt;experience I had gained from formal
methods&lt;/a&gt;, I could
clearly see the bug in even his sanitized design–although I have to believe
it must’ve passed his test bench for him to even open up like that.&lt;/p&gt;

&lt;p&gt;When I dug further into the forums, I found several examples of folks who had
written in, not knowing why their design was failing, but for whom no one had
responded.&lt;/p&gt;

&lt;p&gt;I also looked into any example code I could find.  I noticed that most of the
examples I found followed the vendor’s examples.  This made it fairly easy
to verify, since once I had verified one example any others that looked like
it tended to have the same bugs.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 9. Vendor interconnect logic, with multiple internal implementations&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/axi-story/vendor-interconnect.svg&quot; alt=&quot;&quot; width=&quot;320&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;At one point, I even looked into a major vendor’s interconnect structure.  I
was hoping I might be able to apply the formal tools to it, having &lt;a href=&quot;/blog/2019/07/17/crossbar.html&quot;&gt;verified
my own interconnect&lt;/a&gt; and
also since I had found some severe bugs in an academic’s interconnect–as
mentioned above.  As I worked through this design to determine if it would
even be possible to set up the tools (it wasn’t–not all of the code was
available as shown in Fig. 9), I noticed an
optional “feature”: The default setting of their interconnect
would allocate a channel from the master to the slave and at the same time from
the slave to the master.  This channel would then remain allocated until all
transactions had completed–much like my own
&lt;a href=&quot;/blog/2019/07/17/crossbar.html&quot;&gt;crossbar design&lt;/a&gt;.
An optional setting would activate a different implementation, one that would
route transaction requests in packets to the slaves,
and then route them back to the masters in a way that required bus arbitration
in both directions.  As a result of the second “return” arbitration, the slave
would experience “&lt;a href=&quot;https://en.wikipedia.org/wiki/Back_pressure&quot;&gt;back
pressure&lt;/a&gt;”–a necessary trigger
condition for some (but not all) of the bugs I had found.  This second
implementation would’ve clearly triggered the bugs that I had found, whereas
the first might not have.  Given the code I examined, it is quite possible that
a failure to test all configurations of this vendor’s design might’ve
contributed to the problem manifesting in some designs and not others.&lt;/p&gt;

&lt;p&gt;In another example from the same interconnect logic, I noticed that the
vendor crippled both read and write channels in their AXI-lite to AXI bridge.
This surprised me.  Bridging from &lt;a href=&quot;https://github.com/ZipCPU/wb2axip/blob/master/rtl/axilite2axi.v&quot;&gt;AXI-lite to
AXI&lt;/a&gt; is really
easy to do, requiring almost no logic.  Then I realized, their crippled design
probably kept some of these &lt;a href=&quot;/formal/2018/12/28/axilite.html&quot;&gt;AXI-lite
bugs&lt;/a&gt;
from triggering.  This appeared to be either a consequence of an engineer
trying to fix an ill-defined logic bug, or perhaps it was legacy code
remaining from a protocol version (AXI3) that had since fallen out of favor.&lt;/p&gt;

&lt;p&gt;I also discovered a more shocking reason why many of these bugs may have stayed
hidden, while examining some
&lt;a href=&quot;https://en.wikipedia.org/wiki/Direct_memory_access&quot;&gt;DMA&lt;/a&gt; reset questions.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 10. DMA&#39;s are used for automatic data copying&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/axi-story/dma-copy.svg&quot; alt=&quot;&quot; width=&quot;560&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;For those who are not familiar with a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Direct_memory_access&quot;&gt;DMA&lt;/a&gt;, it’s basically
a hardware component that copies data from one bus slave to another.  My own
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/wbdmac.v&quot;&gt;WB DMA&lt;/a&gt;,
works by first copying the data to an internal memory, and only then writes
it back to the bus.  It will do this several times if necessary.  If it
ever encounters a bus error,
such as I sometimes generate from a slave failing to respond,
it issues a bus abort, ends the transaction, and reports an error.&lt;/p&gt;

&lt;p&gt;This is not as easy to do with AXI.&lt;/p&gt;

&lt;p&gt;In this case, several customers had posted to the forum over a couple of days
asking asking whether or not it was possible to interrupt an ongoing
&lt;a href=&quot;https://en.wikipedia.org/wiki/Direct_memory_access&quot;&gt;DMA&lt;/a&gt;
transaction.  Apparently, these customers were trying to copy data between a
user logic core and memory and the bus was locking up mid-transaction.  They
wanted to find out how to abort the transaction.  I replied to these
individuals that there is no such thing as a bus abort in AXI: every
transaction request must receive a response.  There’s no way to timeout
a transaction.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: left; padding: 15px&quot;&gt;&lt;caption&gt;Fig 11. Using an AXI Fault Isolator&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/axi-story/axi-fault-isolator.svg&quot; alt=&quot;&quot; width=&quot;320&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Well, not quite.  There is one way to timeout a transaction.  You can use a
“firewall” of some type, such as this &lt;a href=&quot;https://github.com/ZipCPU/wb2axip/blob/master/rtl/axisafety.v&quot;&gt;bus
fault isolator&lt;/a&gt;,
to catch bugs in a faulty AXI slave.  If placed between the slave and the rest
of the bus logic, as shown in Fig. 11, it will catch faults and then isolate
the downstream slave from the rest of the system–keeping those faults from
propagating upstream and becoming catastrophic.  Of course, once the fault
is detected, you still don’t know if a subsequent response was for the
missing earlier response or not.  As a result, you can even configure 
&lt;a href=&quot;https://github.com/ZipCPU/wb2axip/blob/master/rtl/axisafety.v&quot;&gt;the core&lt;/a&gt;
to then reset the downstream slave as well.&lt;/p&gt;

&lt;p&gt;Unfortunately, this approach is not a cure-all.  Placing the &lt;a href=&quot;https://github.com/ZipCPU/wb2axip/blob/master/rtl/axisafety.v&quot;&gt;bus fault
isolator&lt;/a&gt;
between the interconnect and user logic will slow the user logic transactions
down to one at a time.  As a result, just placing
&lt;a href=&quot;https://github.com/ZipCPU/wb2axip/blob/master/rtl/axisafety.v&quot;&gt;this core&lt;/a&gt;
between the interconnect and user logic may resolve the problem just by
itself–even if it never detects a fault.&lt;/p&gt;

&lt;p&gt;Still, I shared this possibility on several of these forum threads.  If nothing
else, it would’ve helped isolate the cause of the problem.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 12. Unflattering posts were deleted&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/axi-story/deleted-post.svg&quot; alt=&quot;&quot; width=&quot;320&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;What surprised me the most about this these
&lt;a href=&quot;https://en.wikipedia.org/wiki/Direct_memory_access&quot;&gt;DMA&lt;/a&gt;
reset inquiries was that the &lt;em&gt;vendor then deleted all but one of the three
threads&lt;/em&gt; when it became apparent that it wasn’t going to be flattering to their
product line or to the bus structure they had chosen.  This left me wondering,
&lt;em&gt;how many other forum posts regarding these bugs have been deleted?&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Yes, this problem runs deep.  It also appears to be hard to find.&lt;/p&gt;

&lt;h2 id=&quot;why-havent-these-bugs-been-caught&quot;&gt;Why haven’t these bugs been caught?&lt;/h2&gt;

&lt;p&gt;Digital design has been around for a while, so why haven’t these problems been
caught before?  Why do they remain so hard to find?&lt;/p&gt;

&lt;p&gt;I think the answer to this question comes down to how digital designs are
tested and verified in the first place.  The standard test methodology
requires you to write a &lt;a href=&quot;https://www.xilinx.com/support/documentation/sw_manuals/xilinx10/isehelp/ise_c_simulation_test_bench.htm&quot;&gt;test bench&lt;/a&gt;
that exercises your design.  Much as I discovered with &lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;my first experience
with formal methods&lt;/a&gt;,
such test benches tend to only examine a “normal” design path.  In my case,
my own FIFO test bench didn’t check all combinations of reading and writing to
either full or empty FIFOs.&lt;/p&gt;

&lt;p&gt;My best guess is that the same thing is going on here.&lt;/p&gt;

&lt;p&gt;I know one individual who wrote in to Xilinx’s forums proudly proclaimed
that his core had passed Xilinx’s (AXI VIP/simulation based) verification
and so any problem he was having must be Xilinx’s fault.  Sadly, their
verification step left him believing that his user core worked, even
though it still suffered from the &lt;a href=&quot;/formal/2018/12/28/axilite.html&quot;&gt;same AXI-lite
bugs&lt;/a&gt; I had already found.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: left; padding: 15px&quot;&gt;&lt;caption&gt;Fig 13. Simulation scripts rarely test everything&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/axi-story/sim-script.svg&quot; alt=&quot;&quot; width=&quot;320&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;The basic problem is that if
you only ever test your AXI user component against one transaction at a time,
you’ll miss most of these bugs: You’ll start your simulation with a bus
master initiating a transaction while the slave is already waiting for it.
The simulated slave will then respond to the waiting master and voila you’ll
convince yourself that your design works even when you haven’t checked all
conditions.  What then happens if the interconnect sends another request
before the first one has returned?  It wasn’t tested.  What happens if either
the interconnect or bus the master aren’t yet ready to receive the bus slave’s
response?  Not tested.  Might the slave
ever lock up, due to conditions that aren’t simulated, to where it stops
processing the bus request?  These aren’t things that are normally tested in
&lt;a href=&quot;/blog/2018/08/22/what-is-simulation.html&quot;&gt;simulation&lt;/a&gt;,
but they do happen in real life.&lt;/p&gt;

&lt;p&gt;Consider the &lt;a href=&quot;https://en.wikipedia.org/wiki/Direct_memory_access&quot;&gt;DMA&lt;/a&gt;
discussion above.  A good
&lt;a href=&quot;https://en.wikipedia.org/wiki/Direct_memory_access&quot;&gt;DMA&lt;/a&gt;
will push as much data into and through a core as fast as the bus will allow,
yet the simulation approach we just discussed above will never test for this.&lt;/p&gt;

&lt;p&gt;Consider the example of the vendor’s interconnect as well, shown in Fig. 9
above.  If the interconnect has to arbitrate response packets back to the
master that sent them, then it may not be ready to receive a particular
response if another slave has the return grant to that master.  This
didn’t get tested either.&lt;/p&gt;

&lt;p&gt;What about the crippled channels?  If you had enabled them to be full speed,
by packing request after request, many of these example designs would break.
Again, this is something you won’t test if you just tested one transaction
at a time in a simulation.&lt;/p&gt;

&lt;p&gt;Some weeks ago an engineer wrote to me and asked if I had a test bench for &lt;a href=&quot;/formal/2019/01/12/demoaxilite.html&quot;&gt;one
of my cores&lt;/a&gt;.  You
know, he said, something where he might write:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;&lt;span class=&quot;n&quot;&gt;read_transaction&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;address&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;write_transaction&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;address&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;I was floored.  Indeed, I didn’t even know where to start.  Any test bench
that only checked one transaction at a time, or waited for the read transaction
to finish before starting a write transaction would mask many if not all of
the bugs I had found.&lt;/p&gt;

&lt;p&gt;On the other hand, this is &lt;a href=&quot;/blog/2017/09/18/clocks-for-sw-engineers.html&quot;&gt;how &lt;em&gt;software&lt;/em&gt; engineers
think&lt;/a&gt;,
since &lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;s
can only ever do one thing at a time: test this, then test that.  It’s how
software works, but it’s not how hardware works.&lt;/p&gt;

&lt;p&gt;This is why digital designers need
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal methods&lt;/a&gt;
now more than ever–because they actually check the cases you weren’t
anticipating.&lt;/p&gt;

&lt;p&gt;If you’ve never tried
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal methods&lt;/a&gt;
before, then understand that they are very different from
&lt;a href=&quot;/blog/2018/08/22/what-is-simulation.html&quot;&gt;simulation&lt;/a&gt;.
Instead of trying one test after another in a long chain or sequence of logic,
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal methods&lt;/a&gt;
check all logic paths at once.  Yes, “all”, in what typically is a breadth
first search.  This is both their greatest benefit, since they catch things
no one imagines, as well as their greatest curse, since the computation
required does not grow with &lt;a href=&quot;https://en.wikipedia.org/wiki/Time_complexity#Polynomial_time&quot;&gt;polynomial
time&lt;/a&gt;.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 14. Should vs should not&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/axi-story/should-not.svg&quot; alt=&quot;&quot; width=&quot;320&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Another thing that makes
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal methods&lt;/a&gt;
different is that you don’t specify how the external environment &lt;em&gt;should&lt;/em&gt;
interact with your core.  Instead, you specify how the external environment
&lt;em&gt;shouldn’t&lt;/em&gt; interact with your core.  The subtle difference in logic means
that, unless you tell the tool not to, it will try all kinds of crazy logic
inputs that you might never expect.&lt;/p&gt;

&lt;p&gt;One of the common misperceptions about formal verification techniques is that
they are only useful or cost-effective for “mission critical”
applications–things like aircraft, rockets, and satellites.  Were I to
buy into this misconception, I wouldn’t touch formal methods at all–since
my own little “sandbox” is hardly anything anyone cares about.&lt;/p&gt;

&lt;p&gt;That view might have even described me before I tried it for the first time.
After using these tools, I’d never go back to the way I was doing
digital design before starting with formal methods.  For me, formal methods
are a big time saver.  One of the things I really dislike is trying to sort
through a 15GB+ simulation trace file looking for a bug.  It takes too long,
and wears thin on my patience.  Not so with formal methods.  Indeed, most of
the formal designs I do require less than 20 time steps to find a bug.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: left; padding: 15px&quot;&gt;&lt;caption&gt;Fig 15. Reasons why I still use formal methods&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/axi-story/why-formal.svg&quot; alt=&quot;&quot; width=&quot;320&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Posting to a forum?  Personally, I’d never write into a vendor forum asking
for help unless I was not only stuck in &lt;a href=&quot;/blog/2017/05/19/fpga-hell.html&quot;&gt;FPGA
Hell&lt;/a&gt;, but I had tried
every option I knew of to get out and still ended up stuck.  I like the
ability to do my own work and to call it my own, and so I’m the type of person
who will wait until I had tried fixing my own design every way I knew how
before ever breaking down and asking for help.  Perhaps its a character flaw.
However it’s this particular bias of mine, and I don’t think it’s all that
uncommon, that makes me believe that those who had posted requesting help,
and especially the professionals among them, must have been stuck in
&lt;a href=&quot;/blog/2017/05/19/fpga-hell.html&quot;&gt;FPGA Hell&lt;/a&gt;
for a while before they risked their pride and profit to ask on a public forum.
Now imagine if you could find a logic problem quickly, perhaps even in less
time than it took to synthesize your design or even write your post for help,
and do it all at your desk.&lt;/p&gt;

&lt;p&gt;“Mission critical” or not, formal methods have saved me and my little
sandbox of the world &lt;a href=&quot;/zipcpu/2017/12/28/ugliest-bug.html&quot;&gt;a lot of
frustration&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;So &lt;a href=&quot;/formal/2019/08/03/proof-duration.html&quot;&gt;how long does it
take&lt;/a&gt;?  Well, to
give you an example, I just built my own &lt;a href=&quot;https://github.com/ZipCPU/wb2axip//blob/master/rtl/axis2mm.v&quot;&gt;AXI stream to
memory&lt;/a&gt;
converter.  After writing this core, I included the
formal bus properties into the core and started running the tools.  This
was before simulation–since I haven’t (yet) run the core through a simulation.
At first, &lt;a href=&quot;https://symbiyosys.readthedocs.io/en/latest&quot;&gt;SymbiYosys&lt;/a&gt;
founds bugs in seconds.  Those first bugs tended to be focused on initial
values and reset processing.  Once fixed, the tool then took a bit longer
and found several bugs in my AXI-lite control logic.  Once I cleared
those two hurdles, I was then stuck again between about 10-15 time steps for
a while.  During this time, the tools only required two minutes of processing
to find a bug.  At this point the bugs found included things like reading
from an empty FIFO, initiating a bus burst requests before there was enough
data in the FIFO, changing a bus request while it was waiting to be accepted,
crossing memory pages within a single request and so forth.  Now that I’ve
worked with the core for a while, it only takes 56 seconds to know if any
changes I’ve made have broken the core.&lt;/p&gt;

&lt;p&gt;Think about that for a moment.  It takes 56 seconds to know if any simple logic
change has placed a bug in the core or not.  Not only that, but by means of
&lt;a href=&quot;/blog/2018/03/10/induction-exercise.html&quot;&gt;k-induction&lt;/a&gt;,
those 56 seconds evaluate not only the first 15-timesteps, but &lt;em&gt;every set of
15-timesteps from the beginning of time through all eternity&lt;/em&gt;–or at least
until the hardware starts failing.&lt;/p&gt;

&lt;p&gt;Good luck trying to get your simulation either to run that fast or to be
that complete.&lt;/p&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;Most of the bugs I’ve found have now been posted, either in a blog article
on this site, in Xilinx’s forums, or directly to the authors of any github
cores either by filing an issue or sending an e-mail.  Many of them have not
yet been fixed as of this writing.  For example, as of Vivado 2019.1, Xilinx’s
bugs remain including one dating back as far as 2016.1.  The good news is that
their engineers are now not only aware of these bugs, but they’ve also promised
to fix them.  This is not yet true of the bugs I found in Intel’s design.
Sorry, I’ve dropped the ball there.  Other than
&lt;a href=&quot;https://twitter.com/ZipCPU&quot;&gt;tweeting&lt;/a&gt; about Intel’s bugs, I have
yet to formally post or write about my findings.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 16. It&#39;s not just for safety critical applications&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/axi-story/bubble.svg&quot; alt=&quot;&quot; width=&quot;320&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;What I will say is that I remember, years ago and before I ever started
diving deeply into FPGA technology myself,
sitting down with a co-worker to integrate their data collection logic into
my mission requirements.  Our goal was to demonstrate that we had a useful
product to the boss.  Instead, I remember this coworker struggling and
struggling with the design, hitting the reset key over and over and over
again, frustrated and confused at why the design wasn’t starting up like
it was supposed to or like it “usually” did.  No, I’m not going to repeat
his language here, but let’s just say that over the course of time while
he was hitting that reset button it became more and more colorful.&lt;/p&gt;

&lt;p&gt;Now consider that the training material I’ve found has been broken.  Indeed,
any one of the AXI bugs I’ve found in these public source vendor training
materials might’ve caused this same frustration.  These include not only the
bugs found in the training material for the vendor’s tools that I’ve already
blogged about, but also the training material for the other major vendors on the
market.&lt;/p&gt;

&lt;p&gt;Now, as I’m slowly picking up my jaw off the floor, I’m starting to get the
full impact of what’s been going on.&lt;/p&gt;

&lt;p&gt;These bugs can be found and fixed–using formal methods.&lt;/p&gt;

&lt;p&gt;If you are interested in repeating any of my work, I’ve done all of my work
using &lt;a href=&quot;https://symbiyosys.readthedocs.io/en/latest&quot;&gt;SymbiYosys&lt;/a&gt;–either the
open source or the commercial version.  I’ve also posted copies of the
Xilinx designs I’ve tested.  If you’ve never formal methods, the open
source version is capable of processing any Verilog (2005) code you might have
with a limited number of SystemVerilog extensions.  Feel free to download it
and give it a try.  You can also find my &lt;a href=&quot;/formal/2018/12/28/axilite.html&quot;&gt;AXI-lite
properties&lt;/a&gt; and &lt;a href=&quot;https://github.com/ZipCPU/wb2axip&quot;&gt;several
example designs on line&lt;/a&gt; as well.&lt;/p&gt;

&lt;p&gt;You can also start with my &lt;a href=&quot;/tutorial&quot;&gt;beginner’s design
tutorial&lt;/a&gt;.  It’s free.  Enjoy it.  Even though
&lt;a href=&quot;/blog/2019/08/20/lego-design.html&quot;&gt;Xilinx deleted my response recommending this tutorial to new
engineers&lt;/a&gt;, you are
welcome to it.  I also teach a course on how to do formal verification.
You can find &lt;a href=&quot;/tutorial#training&quot;&gt;those slides here&lt;/a&gt;,
and contact me if you are interested in taking the course either on-line or
in person on your site.  Feel free to check those out too.&lt;/p&gt;

&lt;p&gt;Finally, I look forward to meeting many of my readers at
&lt;a href=&quot;https://orconf.org&quot;&gt;ORCONF 2019&lt;/a&gt;!  Feel free to stop me and say hello.&lt;/p&gt;

&lt;!-- Counter argument: If Xilinx is having these issues, and it&#39;s not breaking their neck, it can&#39;t be such a big deal.  Other comment: IP Vendors need to adapt formal methods before their customers do, because as soon as their customers have the formal methods, they&#39;ll immediate know where to put the blame. --&gt;
&lt;hr /&gt;&lt;p&gt;&lt;em&gt;Buy the truth, and sell it not; also wisdom, and instruction, and understanding. (Prov 23:23)&lt;/em&gt;</description>
        <pubDate>Fri, 06 Sep 2019 00:00:00 -0400</pubDate>
        <link>https://zipcpu.com/formal/2019/09/06/axi-story.html</link>
        <guid isPermaLink="true">https://zipcpu.com/formal/2019/09/06/axi-story.html</guid>
        
        
        <category>formal</category>
        
      </item>
    
      <item>
        <title>Understanding AutoFPGA&#39;s address assignment algorithm</title>
        <description>&lt;p&gt;Some time ago, I figured out a basic address assignment algorithm for use in
&lt;a href=&quot;/zipcpu/2017/10/05/autofpga-intro.html&quot;&gt;AutoFPGA&lt;/a&gt;.
At the encouragement of &lt;a href=&quot;https://twitter.com/ZipCPU&quot;&gt;my twitter&lt;/a&gt; followers, I
thought it might be valuable to share this algorithm here.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/zipcpu/2017/10/05/autofpga-intro.html&quot;&gt;AutoFPGA&lt;/a&gt;,
as you may recall, connects peripherals (&lt;a href=&quot;https://github.com/ZipCPU/autofpga/tree/dev&quot;&gt;and now multiple masters
in the dev branch&lt;/a&gt;) to any
respective buses you might wish to assign them to.  While
&lt;a href=&quot;/zipcpu/2017/10/05/autofpga-intro.html&quot;&gt;AutoFPGA&lt;/a&gt;
is primarily a copy-paste design facility with some calculation mixed in,
address assignment is one of several exceptions to this rule.&lt;/p&gt;

&lt;p&gt;Consider as an example the bus structure shown in Fig. 1.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 1. Example multi-level bus structure&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/address-assignment/generic-bus-diagram.svg&quot; alt=&quot;&quot; width=&quot;720&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;In this structure, you can see three bus masters, together with four basic
slaves, four &lt;code class=&quot;highlighter-rouge&quot;&gt;DOUBLE&lt;/code&gt;-type slaves, and four &lt;code class=&quot;highlighter-rouge&quot;&gt;SINGLE&lt;/code&gt;-type slaves.  Slave one
in particular provides access to a second bus having two slaves on it.&lt;/p&gt;

&lt;p&gt;To assign addresses to all of these peripherals,
&lt;a href=&quot;/zipcpu/2017/10/05/autofpga-intro.html&quot;&gt;AutoFPGA&lt;/a&gt;
generates and maintains a list of buses found within the design.  Each bus
is composed of a number of peripherals (the PLIST), and one or more masters
(the MLIST).  Certain special “subbus” or “arbiter” masters are able to cross
from one bus to another, making it possible to have hierarchical bus structures,
such as Fig. 1 shows above.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 2. Example multi-level bus structure&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/address-assignment/bus-lists.svg&quot; alt=&quot;&quot; width=&quot;420&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;&lt;a href=&quot;/zipcpu/2017/10/05/autofpga-intro.html&quot;&gt;AutoFPGA&lt;/a&gt;s
first task is to &lt;a href=&quot;/zipcpu/2019/08/30/subbus.html&quot;&gt;split each bus into three
parts&lt;/a&gt;: The first is for
peripherals of type &lt;code class=&quot;highlighter-rouge&quot;&gt;SINGLE&lt;/code&gt;.  These are single register peripherals whose
register is immediately available for reading or writing, and who don’t stall
the bus.  The second set of peripherals, those of type &lt;code class=&quot;highlighter-rouge&quot;&gt;DOUBLE&lt;/code&gt;, can have
more registers internal to them.  This set requires a single clock period to
return a value from a bus request.  As with the &lt;code class=&quot;highlighter-rouge&quot;&gt;SINGLE&lt;/code&gt; list, this set is
not allowed to stall the bus either.  The last set of peripherals contains all
other types of peripherals.&lt;/p&gt;

&lt;p&gt;For &lt;a href=&quot;/zipcpu/2017/05/29/simple-wishbone.html&quot;&gt;WB peripherals&lt;/a&gt;,
the entire &lt;code class=&quot;highlighter-rouge&quot;&gt;SINGLE&lt;/code&gt; peripheral set is turned into a &lt;code class=&quot;highlighter-rouge&quot;&gt;DOUBLE&lt;/code&gt; peripheral, and
then that peripheral is turned into a regular peripheral of the normal variety.
While this is captured in Figs. 1 and 2 above, I haven’t yet decided if I will
do the same thing for the
&lt;a href=&quot;/formal/2018/12/28/axilite.html&quot;&gt;AXI-lite&lt;/a&gt; interface or not.&lt;/p&gt;

&lt;p&gt;Address assignment then starts at the lowest level of the bus structure, and
then works its way up to the top.  Within any given level, the &lt;code class=&quot;highlighter-rouge&quot;&gt;SINGLE&lt;/code&gt; set is
assigned first and formed into its own peripheral, then the &lt;code class=&quot;highlighter-rouge&quot;&gt;DOUBLE&lt;/code&gt; set,
and then peripheral assignment is done on the rest of the bus.&lt;/p&gt;

&lt;p&gt;Let’s look at an example from one of my more recent projects.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 3. Abbreviated bus design from a recent project&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/address-assignment/sonar-design.svg&quot; alt=&quot;&quot; width=&quot;720&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;In this project there’s your basic
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;, and then
&lt;a href=&quot;/blog/2019/03/27/qflexpress.html&quot;&gt;flash&lt;/a&gt;,
SDRAM, network, and &lt;a href=&quot;https://github.com/ZipCPU/sdspi&quot;&gt;SD-Card&lt;/a&gt;
peripherals.  Indeed, this much of the design is based upon my
&lt;a href=&quot;https://github.com/ZipCPU/videozip&quot;&gt;VideoZip design&lt;/a&gt;.  Now, using
&lt;a href=&quot;/zipcpu/2017/10/05/autofpga-intro.html&quot;&gt;AutoFPGA&lt;/a&gt;,
I can add a basic SONAR transmit controller and a boot ROM section so my
customer doesn’t need to load code into the design himself.  (The boot ROM
slave isn’t shown in Fig. 3 above.)  Finally, there’s a data recorder shown
above as the “DMA” in the picture.  If you look carefully, you’ll notice this
same slave exists on the bus in two places: once where for the control port
where it receives its commands, and again for the memory access portion
where it masters the bus.  Xilinx users might be familiar with the similar
&lt;a href=&quot;https://www.xilinx.com/support/documentation/ip_documentation/axi_datamover/v5_1/pg022_axi_datamover.pdf&quot;&gt;AXIS2MM data mover
peripheral&lt;/a&gt;,
but this particular one is my own WB creation and no real relation to theirs.&lt;/p&gt;

&lt;p&gt;Let’s spend a moment to see how
&lt;a href=&quot;/zipcpu/2017/10/05/autofpga-intro.html&quot;&gt;AutoFPGA&lt;/a&gt;
handles this address assignment problem.&lt;/p&gt;

&lt;h2 id=&quot;address-decoding&quot;&gt;Address Decoding&lt;/h2&gt;

&lt;p&gt;The first step to understanding how address assignment works is to understand
how addresses are decoded.  &lt;a href=&quot;/blog/2019/07/17/crossbar.html&quot;&gt;As we’ve discussed
before&lt;/a&gt;, address decoding is
done with two values: an address and a mask assigned on a per-slave basis.  A
particular peripheral is selected if the requested address matches the slave’s
address everywhere a mask bit is set.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;&lt;span class=&quot;n&quot;&gt;request&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;peripheral&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;valid_request&lt;/span&gt;
		&lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;requested_address&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SLAVE_MASK&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SLAVE_ADDR&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;You might also equivalently write,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;&lt;span class=&quot;n&quot;&gt;request&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;peripheral&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;valid_request&lt;/span&gt;
		&lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;requested_address&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;^&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SLAVE_ADDR&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SLAVE_MASK&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Both should generate the same logic.&lt;/p&gt;

&lt;p&gt;In general, the goal of address assignment is to both minimize the number of
mask bits and the number of address bits at the same time.&lt;/p&gt;

&lt;p&gt;Sound simple?  Let’s find out how this works.&lt;/p&gt;

&lt;h2 id=&quot;easy-address-assignment&quot;&gt;Easy Address Assignment&lt;/h2&gt;

&lt;p&gt;Just to illustrate the issue of address assignment, let’s start out with a
basic set of peripherals and assign an address to each of them.  I’ve chosen
a set of 12-peripherals for this purpose, shown in Fig. 4 on the right.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 4. Example slave peripherals&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/address-assignment/sample-plist.png&quot; alt=&quot;&quot; width=&quot;296&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;The first “peripheral” is the null space.&lt;/p&gt;

    &lt;p&gt;My initial designs didn’t include this null space.  Shall we say I got
burned and then painfully learned the wisdom of my ways?&lt;/p&gt;

    &lt;p&gt;The story dates back to before I implemented illegal instruction detection
in the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;,
feeling at the time that it was “optional”.  (I don’t feel this way any
more.)  Then one day something went wrong.  Somewhere, a pointer got set
to address zero.  Worse, all of my peripheral addresses were packed near
zero at the time.  The result was that the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt; started
wildly writing errant data to the peripheral address space.&lt;/p&gt;

    &lt;p&gt;By the time I had realized what was happening, the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt;
had written to the flash configuration control register and switched
some of the one-time programmable configuration bits.  My
&lt;a href=&quot;https://store.digilentinc.com/arty-a7-artix-7-fpga-development-board-for-makers-and-hobbyists&quot;&gt;Arty&lt;/a&gt;,
while usable, has never been the same since.&lt;/p&gt;

    &lt;p&gt;I’ve also learned to add illegal instruction detection and bus error
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_(computing)&quot;&gt;bus&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_error&quot;&gt;error&lt;/a&gt; detection to the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt;,
and similarly a null space to my address assignments.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The next couple of peripherals in this example set are &lt;a href=&quot;/blog/2017/07/08/getting-started-with-wbscope.html&quot;&gt;Wishbone
Scopes&lt;/a&gt;.
These require only two addresses, 4-bytes each, one for control and one
for data.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;I also have a &lt;a href=&quot;https://github.com/ZipCPU/wbpmic&quot;&gt;microphone peripheral&lt;/a&gt;
with a similar addressing scheme–one address for control and one for data.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The next peripheral is my &lt;a href=&quot;https://github.com/ZipCPU/wbuart32&quot;&gt;WBUART
peripheral&lt;/a&gt;.  This has transmit and
receive registers, as well as protocol control and FIFO status registers.
&lt;a href=&quot;https://github.com/ZipCPU/wbuart32/blob/master/rtl/wbuart.v&quot;&gt;This
peripheral&lt;/a&gt;
therefore requires address space for four 32-bit registers.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;My &lt;a href=&quot;https://github.com/ZipCPU/videozip/tree/enet/rtl/ethernet&quot;&gt;RGMII&lt;/a&gt; and
&lt;a href=&quot;https://github.com/ZipCPU/openarty/tree/autoarty/rtl/enetpackets.v&quot;&gt;RMII&lt;/a&gt;
controllers need two address regions–one for packet
memory and another for the controller.  The
&lt;a href=&quot;https://github.com/ZipCPU/videozip/tree/enet/rtl/ethernet/enetpackets.v&quot;&gt;controller&lt;/a&gt;
itself requires eight 32-bit registers to control the transmitter, the
receiver, the MAC address,
and to some feedback counters to capture the number of aborted packets.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;These are followed by the &lt;a href=&quot;https://github.com/ZipCPU/videozip/blob/master/rtl/enetctrl.v&quot;&gt;network management data port&lt;/a&gt;.  My network
management controller provides a separate address for everything in
the &lt;a href=&quot;https://en.wikipedia.org/wiki/Management_Data_Input/Output&quot;&gt;MDIO&lt;/a&gt;
address space, so it requires 128 bytes of address space.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The network packet memory needs to be sufficiently large to hold both a
received packet as well as the packet to be transmitted next.  Let’s pick
a memory area 32,768 bytes wide (two 16kB packets) knowing that we can
adjust this for other architectures.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;While I don’t typically use a first-stage boot-loader, one of the projects
I’m working on requires it.  That project requires a boot-ROM so we’ll throw
it in here.  A block-ROM of 256kB is more than sufficient to read a
program from an SD-card and copy it to RAM.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;We’ll then scrap together whatever’s left of our FPGA block RAM components
in order to create a &lt;a href=&quot;/zipcpu/2018/07/13/memories.html&quot;&gt;1MB block RAM
peripheral&lt;/a&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;We also have a &lt;a href=&quot;/blog/2019/03/27/qflexpress.html&quot;&gt;flash
   peripheral&lt;/a&gt; in this
   sample list.  It seems there’s a large set of
   &lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt;
   peripherals stuck at 24-bit addressing, so this will give us a
   &lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt;
   size of 16MB.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Our final peripheral is a &lt;a href=&quot;https://en.wikipedia.org/wiki/DDR3_SDRAM&quot;&gt;DDR3
   SDRAM&lt;/a&gt; having 512MB of memory.
   My current approach to this is to use the basic MIG controller, coupled
   with a &lt;a href=&quot;https://github.com/ZipCPU/wb2axisp/blob/master/rtl/wbm2axisp.v&quot;&gt;Wishbone to AXI
   bridge&lt;/a&gt;.
   As you’ll see in a moment, the sheer size of this particular peripheral will
   dominate much of how our address assignment algorithm will work.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Now, let me ask, how would you assign addresses to these peripherals?&lt;/p&gt;

&lt;p&gt;Ideally, what we might want would be a one-hot addressing scheme where
you could tell which peripheral was addressed by a single bit in the
address space.  While this sounds like an awesome idea, it fails in
practice any time an errant program accesses an address with more than one
of these otherwise one-hot bits set.  If both peripherals respond,
… “bad” things will happen.  The bus, for example, might lock up until
the next power cycle.  This is usually quite “bad”.&lt;/p&gt;

&lt;p&gt;This would also break the &lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;fundamental rule of all bus
work&lt;/a&gt;: for every request,
there is one and only one response.&lt;/p&gt;

&lt;p&gt;No, we want to make certain instead that our address assignment method works
in such a way that only one slave will ever be addressed at a time.  It doesn’t
matter if “non-allocated” addresses select that slave, but it does matter if any
addresses select more than one slave at a time.&lt;/p&gt;

&lt;p&gt;Perhaps the easiest way to do address assignment might be to first find
the slave with the biggest address width, and then assign an address space
that big to every slave.  Since the
&lt;a href=&quot;https://en.wikipedia.org/wiki/DDR3_SDRAM&quot;&gt;SDRAM&lt;/a&gt;
requires an address space of
&lt;code class=&quot;highlighter-rouge&quot;&gt;0x2000_0000&lt;/code&gt; bytes, we’ll assign every peripheral that many bytes and just
count up.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: left; padding: 15px&quot;&gt;&lt;caption&gt;Fig 5. Example slave peripherals&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/address-assignment/simple-assignment.png&quot; alt=&quot;&quot; width=&quot;643&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;As you can see from Fig. 5 on the left, we overran our 32-bit address
space and now need a 33-bit address space.
You can also see that our 8-byte peripherals were assigned 512 MBs of
address space each.  This would sort of be like running a parcel shipping
business and only supporting one size container–train box cars.&lt;/p&gt;

&lt;p&gt;Practically, this will never work.&lt;/p&gt;

&lt;p&gt;The &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
only supports a 32-bit address space (i.e. 30-bit word address space), and
of that address space there’s a reserved portion at the end from
&lt;code class=&quot;highlighter-rouge&quot;&gt;0xff00_0000&lt;/code&gt; to &lt;code class=&quot;highlighter-rouge&quot;&gt;0xffff_ffff&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Before we abandon this approach though, let’s see what else we might learn
from it.  For example, the address decoder could decode all of these separate
peripheral address ranges with a simple 4-bit lookup table, checking only
address bits 33-29 as indicated by the mask, &lt;code class=&quot;highlighter-rouge&quot;&gt;0x1_e000_0000&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;While this is a low-logic decoder, it does have a consequence.  Low-logic
means that peripherals with a small address range may exist at multiple
locations in the address map.  To continue our parcel shipping analogy, many
loaves of bread might find in a package big enough to hold a sofa–why
only pack one peripheral in such a large address space?&lt;/p&gt;

&lt;p&gt;Further, consider how the &lt;a href=&quot;https://github.com/ZipCPU/wbuart32&quot;&gt;UART
peripheral&lt;/a&gt; exists from &lt;code class=&quot;highlighter-rouge&quot;&gt;0x8000_000f&lt;/code&gt; to
&lt;code class=&quot;highlighter-rouge&quot;&gt;0x9fff_ffff&lt;/code&gt; even though it only uses four registers within that range.
What happens, then, is that all of the addresses within this range will
alias into the same four peripheral registers, allowing the
&lt;a href=&quot;https://github.com/ZipCPU/wbuart32&quot;&gt;UART&lt;/a&gt;
to be addressed anywhere in that address region.  We’ll touch more on this
in the next section.&lt;/p&gt;

&lt;p&gt;For now, we can summarize our success, or lack thereof, by two metrics–the
address width required to access all of these peripherals (33 bits–too many),
and the number of mask bits necessary to select between them, 4-bits.&lt;/p&gt;

&lt;p&gt;Can we do better?&lt;/p&gt;

&lt;h2 id=&quot;tightly-packing-addresses&quot;&gt;Tightly packing addresses&lt;/h2&gt;

&lt;p&gt;When I first started trying to handle address assignment, I would pack as many
peripherals as I could into a given address area.  Here’s how that algorithm
worked:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;I’d first sort all the peripherals, leaving the null space at zero of course.&lt;/p&gt;

    &lt;p&gt;Perhaps you’ve noticed that I’ve already sorted the peripherals listed
in Fig. 4 above.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;I’d initialize my work by setting a &lt;code class=&quot;highlighter-rouge&quot;&gt;start_address&lt;/code&gt; either to 0.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;For each peripheral, starting with the “empty” null-space and working down
the list, I’d add to the &lt;code class=&quot;highlighter-rouge&quot;&gt;start_address&lt;/code&gt; the size of the peripheral, minus
one byte.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;	&lt;span class=&quot;n&quot;&gt;pa&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;peripheral&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;address_width&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;periphera&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;base_address&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;start_address&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pa&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;ol start=&quot;4&quot;&gt;
  &lt;li&gt;
    &lt;p&gt;This would be guaranteed to overflow if there weren’t enough bits to
support my requested address range.  For example, suppose the start address
was &lt;code class=&quot;highlighter-rouge&quot;&gt;0x40&lt;/code&gt; and I wanted to allocate space for the &lt;a href=&quot;https://github.com/ZipCPU/videozip/blob/master/rtl/enetctrl.v&quot;&gt;MDIO 
peripheral&lt;/a&gt;–requiring
a register space of &lt;code class=&quot;highlighter-rouge&quot;&gt;0x80&lt;/code&gt; octets.  If you add these two together, you’d
get &lt;code class=&quot;highlighter-rouge&quot;&gt;0x40 + 0x80 = 0xc0&lt;/code&gt;.  Subtracting one brings you to &lt;code class=&quot;highlighter-rouge&quot;&gt;0xbf&lt;/code&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Now I can trim off the bottom bits, to guarantee the peripheral can use
an address mask.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;	&lt;span class=&quot;n&quot;&gt;pa&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;peripheral&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;address_width&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;periphera&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;base_address&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1l&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pa&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;ol start=&quot;6&quot;&gt;
  &lt;li&gt;
    &lt;p&gt;To follow our example from above, this would force the &lt;a href=&quot;https://github.com/ZipCPU/videozip/blob/master/rtl/enetctrl.v&quot;&gt;MDIO
peripheral&lt;/a&gt;
needing &lt;code class=&quot;highlighter-rouge&quot;&gt;0x80&lt;/code&gt; bytes of address space to have a start address equal to
&lt;code class=&quot;highlighter-rouge&quot;&gt;0x80&lt;/code&gt;–plenty of room, and with a guaranteed 7-bits to reference values
within the peripheral.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;We can then increment our start address to be ready for the next peripheral.
The new start address must be just following our assigned address space.
So, for our&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;	&lt;span class=&quot;n&quot;&gt;start_address&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;peripheral&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;base_address&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1ul&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pa&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;ol start=&quot;8&quot;&gt;
  &lt;li&gt;Then, as a first pass to knowing what mask bits we require, we set our
mask bits to be the next address bit over.&lt;/li&gt;
&lt;/ol&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;	&lt;span class=&quot;n&quot;&gt;periheral&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mask_bits&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1l&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pa&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;ol start=&quot;9&quot;&gt;
  &lt;li&gt;Finally, go back and repeat for all peripherals.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;This sounds confusing.  Perhaps a picture or two might help.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 6. Address assignment: three scopes and a serial port&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/address-assignment/uart-plus-scopes.svg&quot; alt=&quot;&quot; width=&quot;280&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;The two &lt;a href=&quot;/blog/2017/07/08/getting-started-with-wbscope.html&quot;&gt;scopes&lt;/a&gt;
and the &lt;a href=&quot;https://github.com/ZipCPU/wbpmic&quot;&gt;microphone&lt;/a&gt; all use two words of
address space.  We can therefore pack them tightly together.  However, when
we get to the &lt;a href=&quot;https://github.com/ZipCPU/wbuart32&quot;&gt;UART&lt;/a&gt;,
we need an address that’s aligned with four bus words.  Rounding up to the
nearest address that’s aligned with four bus words is going to require
stuffing two words of unused space into our address space as shown in Fig.
6 on the right.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: left; padding: 15px&quot;&gt;&lt;caption&gt;Fig 7. Adding the network control port&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/address-assignment/network-plus-uart.svg&quot; alt=&quot;&quot; width=&quot;420&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Once we’ve assigned the
&lt;a href=&quot;/blog/2017/07/08/getting-started-with-wbscope.html&quot;&gt;scopes&lt;/a&gt;
and the &lt;a href=&quot;https://github.com/ZipCPU/wbuart32&quot;&gt;UART&lt;/a&gt;, it’s now time to assign an
address to the &lt;a href=&quot;https://github.com/ZipCPU/openarty/tree/autoarty/rtl/enetpackets.v&quot;&gt;network control
port&lt;/a&gt;.
This peripheral needs an address aligned to eight 32-bit words.  However,
if you shuffle everything to an eight word width, you’ll find that the network
control addresses don’t fit unless you skip some more space.&lt;/p&gt;

&lt;p&gt;As you can see, we’re working from the smaller peripheral to the larger
ones.  At each level, the peripheral needs to be assigned to an address
aligned to the size of the peripheral.&lt;/p&gt;

&lt;p&gt;That’s what the algorithm above does.&lt;/p&gt;

&lt;p&gt;As a last step, we’ll measure the total number of bits required to do this
address decoding (30 bits), and then trim any mask bits to just that many bits.
The result would be a set of base addresses and masks describing a “full
address decoder”.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 8. Full address decoding&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/address-assignment/full-address-decoding.png&quot; alt=&quot;&quot; width=&quot;589&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;This time, you’ll notice from Fig. 8 above that we’ve done much better at
minimizing the number of address bits than we did in our first attempt shown
in Fig. 5 above.  But 27 mask bits?  Not so much.&lt;/p&gt;

&lt;p&gt;If low logic were important to us, and it has always been to me since more
logic costs more money, we might choose to just check the minimum mask bits
necessary to separate peripherals.  This would be a “partial address decoding”,
since it would leave holes in the address space.  You can see how this might
work in Fig. 9 below.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: left; padding: 15px&quot;&gt;&lt;caption&gt;Fig 9. First cut at partial address decoding&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/address-assignment/first-pass-partial.png&quot; alt=&quot;&quot; width=&quot;589&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;If you count number of bits used in the masks of Fig. 9, you’ll get eleven
non-zero bits.  Eleven mask bits would mean that decoding a peripheral’s
address would require a comparator with a length somewhere between one
bit (the &lt;a href=&quot;https://en.wikipedia.org/wiki/DDR3_SDRAM&quot;&gt;SDRAM&lt;/a&gt;)
and 11-bits (the &lt;a href=&quot;/blog/2017/07/08/getting-started-with-wbscope.html&quot;&gt;WB
Scopes&lt;/a&gt;).
Decoding addresses using an 11-bit mask would &lt;a href=&quot;/blog/2017/06/12/minimizing-luts.html&quot;&gt;require between two and three
LUTs per slave&lt;/a&gt;
depending on your architecture.&lt;/p&gt;

&lt;p&gt;While this kind of “partial address decoding” is both common and cost
effective, it’s been known to surprise those who aren’t familiar with it.
Consider as an example address &lt;code class=&quot;highlighter-rouge&quot;&gt;0x210_0000&lt;/code&gt;.  Since the
block RAM’s mask only checks bits &lt;code class=&quot;highlighter-rouge&quot;&gt;0x2110_0000&lt;/code&gt;, our address decoding
algorithm above will map this address to the block RAM–even though the
block RAM’s official address space only exists between &lt;code class=&quot;highlighter-rouge&quot;&gt;0x10_0000&lt;/code&gt; and
&lt;code class=&quot;highlighter-rouge&quot;&gt;0x1f_ffff&lt;/code&gt;.  On the other hand, &lt;code class=&quot;highlighter-rouge&quot;&gt;0x20c_0000&lt;/code&gt; would map to our block &lt;code class=&quot;highlighter-rouge&quot;&gt;ROM&lt;/code&gt;,
&lt;code class=&quot;highlighter-rouge&quot;&gt;0x30c_0000&lt;/code&gt; would map to our &lt;a href=&quot;/blog/2019/03/27/qflexpress.html&quot;&gt;Flash
peripheral&lt;/a&gt;,
and &lt;code class=&quot;highlighter-rouge&quot;&gt;0x4003_0000&lt;/code&gt; would map to our first &lt;a href=&quot;/blog/2017/07/08/getting-started-with-wbscope.html&quot;&gt;WB
Scope&lt;/a&gt;).
This isn’t a bug, but it can be a rather surprising consequence
the address decoding algorithm.&lt;/p&gt;

&lt;p&gt;So, all in all, we did okay here with our second attempt at address assignment.
&lt;a href=&quot;/zipcpu/2017/10/05/autofpga-intro.html&quot;&gt;AutoFPGA&lt;/a&gt;, however,
has a better approach to generating a “partial address decoding” mask, which
we’ll discuss in the next section.&lt;/p&gt;

&lt;h2 id=&quot;autofpgas-address-assignment-algorithm&quot;&gt;AutoFPGAs Address Assignment Algorithm&lt;/h2&gt;

&lt;p&gt;What we’ve done above nearly describes
&lt;a href=&quot;/zipcpu/2017/10/05/autofpga-intro.html&quot;&gt;AutoFPGA&lt;/a&gt;’s
address assignment algorithm.  There’s only one piece missing: minimizing
the required size of the mask.&lt;/p&gt;

&lt;p&gt;To handle this,
&lt;a href=&quot;/zipcpu/2017/10/05/autofpga-intro.html&quot;&gt;AutoFPGA&lt;/a&gt;
takes a first pass through the peripheral list to
calculate the minimum total address size.  It then increases the minimum
peripheral address size as long as the total address width remains less
than the minimum address width, and as long as the number of mask
bits goes down.&lt;/p&gt;

&lt;p&gt;How shall the minimum total address size be calculated?  Just the way we did
it in our last section: add peripherals to a bus and calculate the address
width.  The number of relevant bits is then given by the difference between
the full address size and the bloated minimum size given to every slave.&lt;/p&gt;

&lt;p&gt;For example, if we look through our example slave set, you’ll see that the
maximum slave size that doesn’t increase increase the address width is 25 bits.
Once chosen, each slave is checked for its address size.  If the slaves
address size is less than 25 bits, it is replaced by 25 bits in the
algorithm above.  The algorithm then continues as before.&lt;/p&gt;

&lt;p&gt;For the slave set example we’ve been working with today, the result then
looks like Fig. 10 below.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 10. Minimizing mask size for a given address width&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/address-assignment/final-assignment.png&quot; alt=&quot;&quot; width=&quot;589&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;You might notice that the base address just increments from one peripheral
to the next–that’s the minimum address size amount.  Further, the peripheral’s
are just one step away from each other up until the last peripheral–the
&lt;a href=&quot;https://en.wikipedia.org/wiki/DDR3_SDRAM&quot;&gt;SDRAM&lt;/a&gt; again.&lt;/p&gt;

&lt;p&gt;Looking at Fig. 10 again, you’ll notice that the total address width is just
one more than the &lt;a href=&quot;https://en.wikipedia.org/wiki/DDR3_SDRAM&quot;&gt;SDRAM&lt;/a&gt;’s
address width.  This is the minimum possible address width we could’ve
achieved.  Similarly, you’ll also notice that the address calculation now
fits in a 5-bit mask.  Since Xilinx chips allow packing two 5-LUTs into a
single 6-LUT as long as the wires are the same, that means we can do our
address decoding with only six pairs of 5-LUTs.&lt;/p&gt;

&lt;h2 id=&quot;bus-hierarchies&quot;&gt;Bus Hierarchies&lt;/h2&gt;

&lt;p&gt;This same basic approach maps quite nicely to bus hierarchies as well,
where one bus master is a slave to another bus above it.
&lt;a href=&quot;/zipcpu/2017/10/05/autofpga-intro.html&quot;&gt;AutoFPGA&lt;/a&gt;
handles bus hierarchies by simply walking the bus tree from the bottom on
up.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Start at the lowest bus in the hierarchy.  Assign addresses to it.
Once accomplished, you’ll then know the address width of this sub-bus
within the hierarchy.&lt;/p&gt;

    &lt;p&gt;This width is used to fill key tags within an bus-translator or arbiter
components, allowing them to be adjusted for the width of the bus
they are working with.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Once you then move up in the hierarchy, you can treat each bus beneath
as a self-contained slave.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Where this starts to get interesting is if you have multiple tops to the
bus tree, and those tops each have a different perspective of the
address map.  I’ve already had this problem once with both the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; and the
debugging bus
occupying the top of the tree.  My solution was rather hackish to force
a specific arrangment of the two buses, but I’m likely going to need to
revisit it in the future.&lt;/p&gt;

&lt;p&gt;Since I’m only just now starting to handle multipl-masters with
&lt;a href=&quot;/zipcpu/2017/10/05/autofpga-intro.html&quot;&gt;AutoFPGA&lt;/a&gt;, rather
than using an
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/ex/wbarbiter.v&quot;&gt;arbiter&lt;/a&gt;
to neck down every bus to a single master, I’m not quite sure how this
is going to impact things … yet.&lt;/p&gt;

&lt;h2 id=&quot;conclusions&quot;&gt;Conclusions&lt;/h2&gt;

&lt;p&gt;I’m sure there are more complicated address assignment algorithms out there,
but this one has worked rather nicely for me for some time.&lt;/p&gt;

&lt;p&gt;It’s not perfect.  One of the particular limitations of this algorithm
as written is that it doesn’t (yet) handle the case where some peripherals
have pre-assigned addresses and others need to be assigned around those.
This means that every time your run
&lt;a href=&quot;/zipcpu/2017/10/05/autofpga-intro.html&quot;&gt;AutoFPGA&lt;/a&gt;
the address structure might change.  That’s not necessarily a good thing
when you’ve already delivered a product to your client and you just want
to add a new piece of hardware to the address decoder without obsoleting
all of the software you’ve already written.  In other words, allowing
the address space to be fixed is something I am very interested in
addressing in the future.&lt;/p&gt;

&lt;p&gt;On the other hand, if you have control over all of the parts of a project and
have no problems rebuilding all of your software on every reconfiguration, then
&lt;a href=&quot;/zipcpu/2017/10/05/autofpga-intro.html&quot;&gt;AutoFPGA&lt;/a&gt;
might be the solution you need.  Not only does it move things around, but it
then updates a series of header and data files that you can then use to keep
running the same software once recompiled.  As a result, if I simply run&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;make autodata
&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;make&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;all of the addresses may get reassigned, but all of the software will rebuilt
at the same time to support the new address space.  On the other hand,
address reassignment isn’t automatic–if I don’t run &lt;code class=&quot;highlighter-rouge&quot;&gt;make autodata&lt;/code&gt; then
the design should work as is with the current address assignments.&lt;/p&gt;

&lt;p&gt;What do you think?  Feel free to drop me a line or re-post this article
if you felt this material was valuable.&lt;/p&gt;
&lt;hr /&gt;&lt;p&gt;&lt;em&gt;But he said unto them, Give ye them to eat. And they said, We have no more but five loaves and two fishes; except we should go and buy meat for all this people.  For they were about five thousand men. And he said to his disciples, Make them sit down by fifties in a company.  (Luke 9:13-14)&lt;/em&gt;</description>
        <pubDate>Tue, 03 Sep 2019 00:00:00 -0400</pubDate>
        <link>https://zipcpu.com/zipcpu/2019/09/03/address-assignment.html</link>
        <guid isPermaLink="true">https://zipcpu.com/zipcpu/2019/09/03/address-assignment.html</guid>
        
        
        <category>zipcpu</category>
        
      </item>
    
      <item>
        <title>Quiz #5: Immediate vs Concurrent Assertions</title>
        <description>
</description>
        <pubDate>Sat, 31 Aug 2019 00:00:00 -0400</pubDate>
        <link>https://zipcpu.com/quiz/2019/08/31/quiz05.html</link>
        <guid isPermaLink="true">https://zipcpu.com/quiz/2019/08/31/quiz05.html</guid>
        
        
        <category>quiz</category>
        
      </item>
    
      <item>
        <title>Connecting lots of slaves to a bus without using a lot of logic</title>
        <description>&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 1. A Minimal Bus Implementation&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/bus-doubles/minimal-crossbar.svg&quot; alt=&quot;&quot; width=&quot;360&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;I’m not quite sure why, but most of the time when I examine a design on-line
that someone has posted to a forum, there are very few bus components.  There’s
typically a CPU (Microblaze, Nios2, or ARM), some kind of SDRAM memory, perhaps
a flash device, and then one or two other peripherals.  Perhaps these would be
an SD-card controller and an ethernet controller, as shown in Fig. 1.&lt;/p&gt;

&lt;p&gt;I’ve never quite understood this.  Many of my own designs will have those same
peripherals, but then perhaps another 25 more.  Why not create more peripherals
than just a few?&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 2. Adding more peripherals&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/bus-doubles/massive-crossbar.svg&quot; alt=&quot;&quot; width=&quot;720&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Perhaps I’m adding in the kitchen sink at this point, but why not?  If you can,
and if you have the peripheral and the space, why not add it into your design?
Maybe I’m just becoming a logic hoarder–I’ll add logic from every peripheral
I’ve ever worked on into a design and then more.  I’ll then even add lots
of &lt;a href=&quot;/blog/2017/06/08/simple-scope.html&quot;&gt;wishbone scopes&lt;/a&gt;
just to debug the whole.&lt;/p&gt;

&lt;p&gt;Large numbers of items on the bus has yet to become a crippling problem for
anything I’ve wanted to do.&lt;/p&gt;

&lt;p&gt;So why don’t I see block designs with even half as many components when browsing
&lt;a href=&quot;https://forums.xilinx.com&quot;&gt;Xilinx’s forums&lt;/a&gt;?&lt;/p&gt;

&lt;p&gt;My guess is that it costs most folks too much logic.&lt;/p&gt;

&lt;p&gt;To understand the issue, let’s just say that we want to connect four masters
(CPU instructions, CPU data, DMA, and &lt;a href=&quot;/blog/2017/06/16/dbg-bus-forest.html&quot;&gt;debugging
bus&lt;/a&gt;) to a bus
with 32 slave peripherals on it.  Just the
&lt;a href=&quot;/blog/2019/07/17/crossbar.html&quot;&gt;crossbar interconnect&lt;/a&gt;
alone, before adding any peripherals, would require 5,571 LUTs for a &lt;a href=&quot;https://github.com/ZipCPU/wb2axip/blob/master/rtl/wbxbar.v&quot;&gt;WB
interconnect&lt;/a&gt;,
and (gasp!) 10,341 LUTs for an &lt;a href=&quot;https://github.com/ZipCPU/wb2axip/blob/master/rtl/axixbar.v&quot;&gt;AXI
interconnect&lt;/a&gt;!
It doesn’t help that the size of the
&lt;a href=&quot;/blog/2019/07/17/crossbar.html&quot;&gt;crossbar&lt;/a&gt; goes up at a rate
faster than the product of the number of masters times the number of slaves.
Worse, these numbers say nothing of the difficulty associated with getting
such a massive design to pass timing for all the paths within such an behemoth
of a &lt;a href=&quot;/blog/2019/07/17/crossbar.html&quot;&gt;crossbar interconnect&lt;/a&gt;
either.&lt;/p&gt;

&lt;p&gt;Perhaps this is why I’ve never seen more than a couple of slaves in any
particular design: the
&lt;a href=&quot;/blog/2019/07/17/crossbar.html&quot;&gt;interconnect&lt;/a&gt;
alone might take nearly half the part, if not more!  (Depending upon your
FPGA size, of course.)&lt;/p&gt;

&lt;p&gt;This of course leads to the interesting question, how is it that I haven’t
suffered from this problem when adding 20+ peripherals to a design?&lt;/p&gt;

&lt;h2 id=&quot;the-two-simple-slaves&quot;&gt;The Two Simple Slaves&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;/zipcpu/2017/10/05/autofpga-intro.html&quot;&gt;AutoFPGA&lt;/a&gt;
simplifies this complex bus interconnect logic via the creation of two simpler
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;Wishbone&lt;/a&gt;
&lt;a href=&quot;/zipcpu/2017/05/29/simple-wishbone.html&quot;&gt;slave protocols&lt;/a&gt;.
I’ll call these sub-protocols, since for each of the simpler protocols the
&lt;a href=&quot;/zipcpu/2017/05/29/simple-wishbone.html&quot;&gt;slave&lt;/a&gt;
can still be &lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;Wishbone&lt;/a&gt;
compliant, it just has a couple of extra features.
The first sub-protocol is appropriate for a
&lt;a href=&quot;/zipcpu/2017/05/29/simple-wishbone.html&quot;&gt;slave&lt;/a&gt;
that consists of just a single register.  This register may always be read
immediately.  The second peripheral class takes a single clock cycle to return
the data of interest.
&lt;a href=&quot;/zipcpu/2017/10/05/autofpga-intro.html&quot;&gt;AutoFPGA&lt;/a&gt;
uses a slave type tag to describe these two sub-protocol classes.  The first
class would have a &lt;code class=&quot;highlighter-rouge&quot;&gt;@SLAVE.TYPE=SINGLE&lt;/code&gt; tag, and the second would be
&lt;code class=&quot;highlighter-rouge&quot;&gt;@SLAVE.TYPE=DOUBLE&lt;/code&gt;.
&lt;a href=&quot;/zipcpu/2017/10/05/autofpga-intro.html&quot;&gt;AutoFPGA&lt;/a&gt; would
then use this information to simplify how such a
&lt;a href=&quot;/zipcpu/2017/05/29/simple-wishbone.html&quot;&gt;slave&lt;/a&gt;
might connect to the &lt;a href=&quot;/blog/2017/06/22/simple-wb-interconnect.html&quot;&gt;automatically generated bus
structure&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Let’s take a look at each of these simplified protocol classes from a
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;Wishbone&lt;/a&gt;
standpoint, and then see how we might use this in an
&lt;a href=&quot;/blog/2019/01/12/demoaxilite.html&quot;&gt;AXI-lite&lt;/a&gt; or even from an
&lt;a href=&quot;/blog/2019/05/29/demoaxi.html&quot;&gt;AXI&lt;/a&gt; (full) standpoint.&lt;/p&gt;

&lt;p&gt;In &lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;Wishbone&lt;/a&gt;,
the &lt;code class=&quot;highlighter-rouge&quot;&gt;SINGLE&lt;/code&gt;
&lt;a href=&quot;/zipcpu/2017/05/29/simple-wishbone.html&quot;&gt;slave&lt;/a&gt;
type must have only a single register assigned to it.  It must never stall the
bus, and the register must always be available to be read.  It’s as though all
the internal logic were summarized as,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;&lt;span class=&quot;k&quot;&gt;always&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;begin&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;o_wb_ack&lt;/span&gt;   &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i_wb_stb&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;o_wb_stall&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mb&quot;&gt;1&#39;b0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;o_wb_data&lt;/span&gt;  &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;internal_register&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;o_wb_err&lt;/span&gt;   &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mb&quot;&gt;1&#39;b0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;always&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;posedge&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i_clk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i_wb_stb&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i_wb_we&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;begin&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i_wb_sel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;internal_register&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;31&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;24&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i_wb_data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;31&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;24&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i_wb_sel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;internal_register&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;23&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;16&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i_wb_data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;23&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;16&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i_wb_sel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;internal_register&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;15&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;8&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i_wb_data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;15&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;8&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i_wb_sel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;internal_register&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;7&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i_wb_data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;7&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;It’s really simple.  Now, what if the
&lt;a href=&quot;/blog/2019/07/17/crossbar.html&quot;&gt;interconnect&lt;/a&gt;
could just ignore &lt;code class=&quot;highlighter-rouge&quot;&gt;o_wb_stall&lt;/code&gt; (always zero), and &lt;code class=&quot;highlighter-rouge&quot;&gt;o_wb_ack&lt;/code&gt; (always
&lt;code class=&quot;highlighter-rouge&quot;&gt;i_wb_stb&lt;/code&gt;), set the &lt;code class=&quot;highlighter-rouge&quot;&gt;STB&lt;/code&gt; line (&lt;code class=&quot;highlighter-rouge&quot;&gt;i_wb_stb&lt;/code&gt;) dependent upon which
&lt;a href=&quot;/zipcpu/2017/05/29/simple-wishbone.html&quot;&gt;slave&lt;/a&gt;
it was talking to, and then use a big case statement based
upon the current address to determine the return value?&lt;/p&gt;

&lt;p&gt;The &lt;code class=&quot;highlighter-rouge&quot;&gt;DOUBLE&lt;/code&gt; type is very similar.  In this case, though, the &lt;code class=&quot;highlighter-rouge&quot;&gt;ACK&lt;/code&gt; line takes
another cycle to return.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;&lt;span class=&quot;c1&quot;&gt;// Delay the acknowledgement by one cycle, so we can accomplish our logic
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;initial&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;o_wb_ack&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mb&quot;&gt;1&#39;b0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;always&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;posedge&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i_clk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;o_wb_ack&lt;/span&gt;   &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i_wb_stb&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This extra cycle makes it possible to for the
&lt;a href=&quot;/zipcpu/2017/05/29/simple-wishbone.html&quot;&gt;slave&lt;/a&gt;
to select from among several possible internal registers you might wish
to return before returning the result.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;&lt;span class=&quot;k&quot;&gt;always&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;posedge&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i_clk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;case&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i_wb_addr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;o_wb_data&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;internal_register&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;31&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;o_wb_data&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;internal_register&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;31&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;o_wb_data&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;internal_register&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;31&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;o_wb_data&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;internal_register&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;31&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// ...
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;endcase&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This would again simplify the
&lt;a href=&quot;/blog/2019/07/17/crossbar.html&quot;&gt;interconnect&lt;/a&gt;,
since it would no longer need to wait for &lt;code class=&quot;highlighter-rouge&quot;&gt;!STALL&lt;/code&gt;, nor would it need
to check &lt;code class=&quot;highlighter-rouge&quot;&gt;ACK&lt;/code&gt; to know if the resulting data was valid.&lt;/p&gt;

&lt;p&gt;Because the logic for both &lt;code class=&quot;highlighter-rouge&quot;&gt;SINGLE&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;DOUBLE&lt;/code&gt;
&lt;a href=&quot;/zipcpu/2017/05/29/simple-wishbone.html&quot;&gt;slaves&lt;/a&gt;
is a &lt;em&gt;subset&lt;/em&gt; of the
full &lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;Wishbone&lt;/a&gt;
protocol, the
&lt;a href=&quot;/zipcpu/2017/05/29/simple-wishbone.html&quot;&gt;slave&lt;/a&gt;
can still be a valid
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;Wishbone&lt;/a&gt;
&lt;a href=&quot;/zipcpu/2017/05/29/simple-wishbone.html&quot;&gt;slave&lt;/a&gt;
in its own right, while also allowing for the
&lt;a href=&quot;/blog/2019/07/17/crossbar.html&quot;&gt;interconnect&lt;/a&gt;
to optimize its bus access.  This means that the
&lt;a href=&quot;/zipcpu/2017/05/29/simple-wishbone.html&quot;&gt;slave&lt;/a&gt;
should still work in a non-optimized
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;Wishbone&lt;/a&gt;
context as well as the optimized one, so you lose nothing there.&lt;/p&gt;

&lt;p&gt;I’ve now used this approach within
&lt;a href=&quot;/zipcpu/2017/10/05/autofpga-intro.html&quot;&gt;AutoFPGA&lt;/a&gt;
for some time with great success–but only for
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;Wishbone&lt;/a&gt; peripherals
so far, and only with a &lt;a href=&quot;/blog/2017/06/22/simple-wb-interconnect.html&quot;&gt;very simplified interconnect
structure&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The reason this has come to light is that I’m now
in the process of &lt;a href=&quot;/zipcpu/2019/08/22/tech-debt.html&quot;&gt;upgrading
AutoFPGA&lt;/a&gt;
to use a full
&lt;a href=&quot;/blog/2019/07/17/crossbar.html&quot;&gt;crossbar interconnect&lt;/a&gt;.
As part of this upgrade, I came across this little optimization and wondered if
I should keep it or throw it out.  I almost threw it out, but then got to
thinking some more about it.&lt;/p&gt;

&lt;p&gt;To see the impact, consider the design shown above in Fig. 2.  Had I collected
&lt;code class=&quot;highlighter-rouge&quot;&gt;SINGLE&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;DOUBLE&lt;/code&gt; slaves together for interconnect purposes, the design
might’ve been simplified to the one in Fig. 3 below.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 3. Creating slave groups by type, SINGLE and DOUBLE&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/bus-doubles/divided.svg&quot; alt=&quot;&quot; width=&quot;720&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;My current thought is, can or should this be done with
&lt;a href=&quot;/blog/2019/05/29/demoaxi.html&quot;&gt;AXI peripherals&lt;/a&gt;,
and if so how?&lt;/p&gt;

&lt;h2 id=&quot;simplifying-axi&quot;&gt;Simplifying AXI&lt;/h2&gt;

&lt;p&gt;So, if we were to totally simplify
&lt;a href=&quot;/blog/2019/05/29/demoaxi.html&quot;&gt;AXI&lt;/a&gt;
to create simpler slaves and to gather eliminate any common bus logic between
them together, how would we do it?&lt;/p&gt;

&lt;p&gt;Here’s my current working proposal:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;The interconnect guarantees that the core receives no back-pressure, leaving
&lt;code class=&quot;highlighter-rouge&quot;&gt;BREADY&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;RREADY&lt;/code&gt; both high.&lt;/p&gt;

    &lt;p&gt;This may require one (or more) &lt;a href=&quot;/blog/2019/05/22/skidbuffer.html&quot;&gt;skid
buffers&lt;/a&gt;, or perhaps
even small FIFOs within the interconnect, but this should still be quite
doable.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The slave can then guarantee that it will keep all of the slave generated
&lt;code class=&quot;highlighter-rouge&quot;&gt;*READY&lt;/code&gt; signals high as well: &lt;code class=&quot;highlighter-rouge&quot;&gt;AWREADY&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;WREADY&lt;/code&gt;, and &lt;code class=&quot;highlighter-rouge&quot;&gt;ARREADY&lt;/code&gt;.&lt;/p&gt;

    &lt;p&gt;Sorry, but this property will keep you from using many of &lt;a href=&quot;/formal/2019/05/13/axifull.html&quot;&gt;Xilinx’s
peripherals&lt;/a&gt;, since
they tend to idle with their &lt;code class=&quot;highlighter-rouge&quot;&gt;*READY&lt;/code&gt; signals low.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The interconnect guarantees that &lt;code class=&quot;highlighter-rouge&quot;&gt;AWVALID == WVALID&lt;/code&gt;.  This will save
the slave from the hassle of needing to implement incoming
&lt;a href=&quot;/blog/2019/05/22/skidbuffer.html&quot;&gt;skid buffers&lt;/a&gt;
just to synchronize these two signals.&lt;/p&gt;

    &lt;p&gt;Even better, if the slave logic is done right, the synthesis tool should
be able to remove the &lt;a href=&quot;/blog/2019/05/22/skidbuffer.html&quot;&gt;skid
buffer&lt;/a&gt; logic from an
otherwise fully &lt;a href=&quot;/blog/2019/05/29/demoaxi.html&quot;&gt;AXI&lt;/a&gt;
compliant core.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The slave can then guarantee that &lt;code class=&quot;highlighter-rouge&quot;&gt;BVALID == $past(AWVALID)&lt;/code&gt; and
&lt;code class=&quot;highlighter-rouge&quot;&gt;RVALID == $past(ARVALID)&lt;/code&gt; for &lt;code class=&quot;highlighter-rouge&quot;&gt;SINGLE&lt;/code&gt; peripherals.  For &lt;code class=&quot;highlighter-rouge&quot;&gt;DOUBLE&lt;/code&gt;
peripherals, the slave would guarantees that &lt;code class=&quot;highlighter-rouge&quot;&gt;BVALID == $past(AWVALID,2)&lt;/code&gt;
and &lt;code class=&quot;highlighter-rouge&quot;&gt;RVALID == $past(ARVALID,2)&lt;/code&gt;.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The neat thing about all of this is that these rules would work for
&lt;a href=&quot;/blog/2019/01/12/demoaxilite.html&quot;&gt;AXI-lite&lt;/a&gt; as well as for
&lt;a href=&quot;/blog/2019/05/29/demoaxi.html&quot;&gt;AXI&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;With just a little more work, we could guarantee the ability to connect
an &lt;a href=&quot;/blog/2019/01/12/demoaxilite.html&quot;&gt;AXI-lite&lt;/a&gt; slave to a
simplified &lt;a href=&quot;/blog/2019/05/29/demoaxi.html&quot;&gt;AXI&lt;/a&gt; interconnect
without the need for any further simplification logic.&lt;/p&gt;

&lt;p&gt;To do this using a fully
&lt;a href=&quot;/blog/2019/05/29/demoaxi.html&quot;&gt;AXI&lt;/a&gt;
capable slave, we’d need a couple other bus simplifying rules as well.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;The interconnect must guarantee that &lt;code class=&quot;highlighter-rouge&quot;&gt;AxLEN == 0&lt;/code&gt; any time &lt;code class=&quot;highlighter-rouge&quot;&gt;AxVALID&lt;/code&gt; is
true for both channels.&lt;/p&gt;

    &lt;p&gt;This means that the interconnect will need to break apart any bursts into
individual beats before they ever reach the slave.&lt;/p&gt;

    &lt;p&gt;This doesn’t mean that the interconnect will no longer support bursting
at a rate of one beat of the transfer per clock cycle, but rather that each
individual beat will be given its own address from the interconnect.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The interconnect would also then guarantees that &lt;code class=&quot;highlighter-rouge&quot;&gt;WLAST == 1&lt;/code&gt; any time
&lt;code class=&quot;highlighter-rouge&quot;&gt;WVALID&lt;/code&gt; is true.&lt;/p&gt;

    &lt;p&gt;This just follows from guaranteeing that &lt;code class=&quot;highlighter-rouge&quot;&gt;AxLEN == 0&lt;/code&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The interconnect guarantees that &lt;code class=&quot;highlighter-rouge&quot;&gt;AxID = 0&lt;/code&gt;, and then ignores &lt;code class=&quot;highlighter-rouge&quot;&gt;xID&lt;/code&gt; on the
return channel.&lt;/p&gt;

    &lt;p&gt;Yes, I understand that there are reasons for using the ID field–just not
in this simplified version of
&lt;a href=&quot;/blog/2019/05/29/demoaxi.html&quot;&gt;AXI&lt;/a&gt;.&lt;/p&gt;

    &lt;p&gt;Also, having a known response time from the slave makes the conversion
from &lt;a href=&quot;/blog/2019/05/29/demoaxi.html&quot;&gt;AXI&lt;/a&gt; to
&lt;a href=&quot;/blog/2019/01/12/demoaxilite.html&quot;&gt;AXI-lite&lt;/a&gt;
a lot easier–without requiring any loss in burst speed.  To see how
difficult the conversion can be, consider &lt;a href=&quot;https://github.com/ZipCPU/wb2axip/blob/master/rtl/axi2axilite.v&quot;&gt;this full speed
bridge&lt;/a&gt;
and notice the challenge of matching up the return ID with the requested
burst, as well generating &lt;code class=&quot;highlighter-rouge&quot;&gt;BVALID&lt;/code&gt; or even &lt;code class=&quot;highlighter-rouge&quot;&gt;RVALID &amp;amp; RLAST&lt;/code&gt; signals with
the end of the burst.  It wasn’t easy to do, certainly not while &lt;a href=&quot;/img/tweets/axi2axil-write-burst.svg&quot;&gt;maintaining
a high throughput&lt;/a&gt;,
and it was even harder to verify.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The interconnect guarantees that &lt;code class=&quot;highlighter-rouge&quot;&gt;AxSIZE = $clog(C_AXI_DATA_WIDTH)-3&lt;/code&gt;, and
then leaves it constant.&lt;/p&gt;

    &lt;p&gt;This also follows from setting &lt;code class=&quot;highlighter-rouge&quot;&gt;AxLEN == 0&lt;/code&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The slave ignores &lt;code class=&quot;highlighter-rouge&quot;&gt;AxBURST&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;AxCACHE&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;AxPROT&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;AxQOS&lt;/code&gt;, and
so on.  (The master guarantees these values are zero, in case the slave
doesn’t quite want to ignore them.)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The slave might still support &lt;code class=&quot;highlighter-rouge&quot;&gt;AxLOCK&lt;/code&gt; if desired, or ignore it if not.  I
haven’t decided if that would be useful or not.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Finally, if the interconnect does its job right, you wouldn’t lose any burst
support, but still be able to retire beats at a rate of one per clock.&lt;/p&gt;

&lt;p&gt;Indeed, the &lt;a href=&quot;/blog/2019/05/29/demoaxi.html&quot;&gt;AXI&lt;/a&gt;
slave logic might easily be simplified to something like the following for
the &lt;code class=&quot;highlighter-rouge&quot;&gt;SINGLE&lt;/code&gt; type peripheral:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;&lt;span class=&quot;c1&quot;&gt;//
// Simplified AXI (SINGLE) write logic
//
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;always&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;posedge&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;S_AXI_ACLK&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;S_AXI_AWVALID&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;begin&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;S_AXI_WSTRB&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;internal_register&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;31&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;24&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;S_AXI_WDATA&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;31&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;24&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;S_AXI_WSTRB&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;internal_register&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;23&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;16&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;S_AXI_WDATA&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;23&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;16&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;S_AXI_WSTRB&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;internal_register&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;15&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;8&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;S_AXI_WDATA&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;15&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;8&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;S_AXI_WSTRB&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;internal_register&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;7&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;S_AXI_WDATA&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;7&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;always&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;S_AXI_BRESP&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mb&quot;&gt;2&#39;b00&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;//
// Simplified AXI (SINGLE) read logic
//
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;always&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;S_AXI_RDATA&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;internal_register&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;always&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;S_AXI_RRESP&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mb&quot;&gt;2&#39;b00&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The &lt;code class=&quot;highlighter-rouge&quot;&gt;DOUBLE&lt;/code&gt; type peripheral logic would also be similarly simplified.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;&lt;span class=&quot;c1&quot;&gt;//
// Simplified AXI (DOUBLE) write logic
//
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;assign&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;wreg&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;S_AXI_AWADDR&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;C_AXI_ADDR_WIDTH&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;clog2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;C_AXI_DATA_WIDTH&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;always&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;posedge&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;S_AXI_ACLK&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;S_AXI_AWVALID&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;begin&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;S_AXI_WSTRB&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;internal_register&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;wreg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;31&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;24&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;S_AXI_WDATA&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;31&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;24&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;S_AXI_WSTRB&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;internal_register&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;wreg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;23&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;16&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;S_AXI_WDATA&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;23&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;16&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;S_AXI_WSTRB&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;internal_register&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;wreg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;15&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;8&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;S_AXI_WDATA&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;15&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;8&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;S_AXI_WSTRB&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;internal_register&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;wreg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;7&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;S_AXI_WDATA&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;7&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;//
// Simplified AXI (DOUBLE) read logic
//
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;assign&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;rreg&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;S_AXI_ARADDR&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;C_AXI_ADDR_WIDTH&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;clog2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;C_AXI_DATA_WIDTH&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;always&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;posedge&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;S_AXI_ACLK&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;case&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rreg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;o_wb_data&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;internal_register&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;31&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;o_wb_data&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;internal_register&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;31&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;o_wb_data&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;internal_register&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;31&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;o_wb_data&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;internal_register&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;31&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;//&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Yes, this eliminates a lot of the logic necessary to deal with the
&lt;a href=&quot;/blog/2019/05/29/demoaxi.html&quot;&gt;AXI&lt;/a&gt;
protocol.  All of that ugly logic would be aggregated into one &lt;code class=&quot;highlighter-rouge&quot;&gt;axisingle&lt;/code&gt;
or one &lt;code class=&quot;highlighter-rouge&quot;&gt;axidouble&lt;/code&gt; module that would then handle all of the full
&lt;a href=&quot;/blog/2019/05/29/demoaxi.html&quot;&gt;AXI&lt;/a&gt;
protocol interaction in order to create this simplified protocol.  You can see
an example of such an
&lt;a href=&quot;/blog/2019/01/12/demoaxilite.html&quot;&gt;AXI-lite&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/wb2axip/blob/master/rtl/axilsingle.v&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;axilsingle&lt;/code&gt; peripheral on
github&lt;/a&gt;,
should you be interested in how this might work.&lt;/p&gt;

&lt;p&gt;This approach allows the bus interconnect to simplify its logic drastically.
Instead of a 10k LUT
&lt;a href=&quot;/blog/2019/07/17/crossbar.html&quot;&gt;crossbar&lt;/a&gt;,
it should now be possible to connect the design together using a 3.4k LUT
&lt;a href=&quot;/blog/2019/07/17/crossbar.html&quot;&gt;crossbar&lt;/a&gt;,
Such a &lt;a href=&quot;/blog/2019/07/17/crossbar.html&quot;&gt;crossbar&lt;/a&gt;
might support 4 masters and 8 slaves, where one of those slaves controls
the &lt;code class=&quot;highlighter-rouge&quot;&gt;SINGLE&lt;/code&gt; peripherals and one controls the &lt;code class=&quot;highlighter-rouge&quot;&gt;DOUBLE&lt;/code&gt; peripherals.  The
logic in the slaves might even be as low as 600 LUTs (based upon a &lt;a href=&quot;https://github.com/ZipCPU/wb2axip/blob/master/rtl/axilsingle.v&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;SINGLE&lt;/code&gt;
peripheral drawn from an AXI-lite
example&lt;/a&gt;).&lt;/p&gt;

&lt;p&gt;Yes, there would be some distinct differences in this approach.  For
example, only one master could ever command a read (or write) port of a
&lt;code class=&quot;highlighter-rouge&quot;&gt;SINGLE&lt;/code&gt; or &lt;code class=&quot;highlighter-rouge&quot;&gt;DOUBLE&lt;/code&gt; peripheral at a time–rather than allowing a separate
master to connect to every simplified peripheral.  This isn’t really that
much of a problem, since if you anticipated contention, you might split the
&lt;code class=&quot;highlighter-rouge&quot;&gt;SINGLE&lt;/code&gt; (or &lt;code class=&quot;highlighter-rouge&quot;&gt;DOUBLE&lt;/code&gt;) peripherals into two groups–and so avoid
the contention.  You might also place any high demand peripherals into
their own peripheral slot in the interconnect and just ignore the potential
optimizations–indeed, how you group slaves into &lt;code class=&quot;highlighter-rouge&quot;&gt;SINGLE&lt;/code&gt; or
&lt;code class=&quot;highlighter-rouge&quot;&gt;DOUBLE&lt;/code&gt; peripheral locations is completely application dependent.&lt;/p&gt;

&lt;p&gt;This is also a very different approach from the more common approach of using
an AHB slave as a “lite” slave.  First, AHB has no support for simultaneous
reads and writes.  That would force the read and write channels to be
synchronous prior to handling an AHB slave.  Second, because AHB permits
arbitrary stall amounts, the master/interconnect can’t simplify the returns
among a group of peripherals, but instead is required to check for the return
from each individual peripheral.  Similarly, while it is possible to generate
an AHB interconnect, and so group peripheral returns, such groups of multiple
slaves under the same AHB port would just slow everything down–since AHB is
primarily a combinatorial logic bus.&lt;/p&gt;

&lt;p&gt;Unlike that AHB approach, this approach maintains the high clock speed and
multiple inflight transactions that
&lt;a href=&quot;/blog/2019/05/29/demoaxi.html&quot;&gt;AXI&lt;/a&gt; is known for already.
It also maintains the separate read and write channels, as well as full/burst
speed–unlike many of the &lt;a href=&quot;/formal/2018/12/28/axilite.html&quot;&gt;AXI-lite
implementations&lt;/a&gt; I’ve seen.&lt;/p&gt;

&lt;h2 id=&quot;conclusions&quot;&gt;Conclusions&lt;/h2&gt;

&lt;p&gt;As you may remember, &lt;a href=&quot;/zipcpu/2019/08/22/tech-debt.html&quot;&gt;I’m in the process of upgrading
AutoFPGA&lt;/a&gt; so that it can
handle multiple bus types.  My current upgrade plans include both full
&lt;a href=&quot;https://github.com/ZipCPU/autofpga/blob/master/sw/bus/wb.cpp&quot;&gt;WB&lt;/a&gt; support as
well as
&lt;a href=&quot;https://github.com/ZipCPU/autofpga/blob/master/sw/bus/axil.cpp&quot;&gt;AXI-lite&lt;/a&gt;
support, although once I get that far
AXI
shouldn’t be much harder.  Indeed, most of the
AXI
work has already been done in either the &lt;a href=&quot;https://github.com/ZipCPU/autofpga/blob/master/sw/bus/axil.cpp&quot;&gt;AXI-lite bus logic
generator&lt;/a&gt;,
or the &lt;a href=&quot;/blog/2019/07/17/crossbar.html&quot;&gt;AXI crossbar&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Of course, &lt;a href=&quot;https://github.com/ZipCPU/autofpga/tree/dev&quot;&gt;my current work to this end is still quite
preliminary&lt;/a&gt;, but this at least
outlines how I intend to get the bus to be able to handle large numbers of
slaves without breaking the piggy bank to get there.  My goal is also to make
the generated logic usable for all, rather than encumbered by copyrights,
so that I could then use it in a vendor-independent basis for an &lt;a href=&quot;/blog/2019/08/16/intermediate.html&quot;&gt;intermediate
digital design tutorial&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.blueletterbible.org/kjv/heb/6/3&quot;&gt;If the Lord wills&lt;/a&gt;,
I’d love to have the opportunity to come back and blog about the success
of this work.  We’ll see what future the
&lt;a href=&quot;https://www.blueletterbible.org/kjv/heb/6/3&quot;&gt;Lord brings&lt;/a&gt;.&lt;/p&gt;

&lt;hr /&gt;&lt;p&gt;&lt;em&gt;And whosoever shall fall on this stone shall be broken: but on whomsoever it shall fall, it will grind him to powder. (Matt 21:44)&lt;/em&gt;</description>
        <pubDate>Fri, 30 Aug 2019 00:00:00 -0400</pubDate>
        <link>https://zipcpu.com/zipcpu/2019/08/30/subbus.html</link>
        <guid isPermaLink="true">https://zipcpu.com/zipcpu/2019/08/30/subbus.html</guid>
        
        
        <category>zipcpu</category>
        
      </item>
    
      <item>
        <title>Quiz #4: If this counter is never triggered, can we prove it&#39;ll never leave zero?</title>
        <description>&lt;p&gt;Let’s come back to our simple counter example again (no pun intended at first,
enjoyed ever since), and let’s build a quiz from it again.&lt;/p&gt;

&lt;p&gt;This time we’ve &lt;a href=&quot;/quiz/2019/08/08/quiz02.html&quot;&gt;fixed the issue with the initial
value&lt;/a&gt;,
we’ve chosen to ignore the ASIC designers who will insist our counter
requires an initial reset signal (it wouldn’t fit on the slide with a reset,
but you can add one if to the puzzle above if it makes you feel better),
and we’ve &lt;a href=&quot;/quiz/2019/08/19/quiz03.html&quot;&gt;asserted that our counter will never meet or exceed
&lt;code class=&quot;highlighter-rouge&quot;&gt;24&lt;/code&gt;&lt;/a&gt;.  (You may assume the
counter has enough of a bit width to reach &lt;code class=&quot;highlighter-rouge&quot;&gt;24&lt;/code&gt; …)  We’ve also brought back
the &lt;code class=&quot;highlighter-rouge&quot;&gt;i_start_signal&lt;/code&gt;, which will trigger our counter.&lt;/p&gt;

&lt;p&gt;Today, though, we want to assume that the start signal is never raised,
and having assumed that we want to prove that the counter will remain
zero.&lt;/p&gt;

&lt;p&gt;Will the assertion below prove that?&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;&lt;span class=&quot;k&quot;&gt;always&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;posedge&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i_clk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;assert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;($&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;past&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;counter&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

</description>
        <pubDate>Sat, 24 Aug 2019 00:00:00 -0400</pubDate>
        <link>https://zipcpu.com/quiz/2019/08/24/quiz04.html</link>
        <guid isPermaLink="true">https://zipcpu.com/quiz/2019/08/24/quiz04.html</guid>
        
        
        <category>quiz</category>
        
      </item>
    
  </channel>
</rss>
