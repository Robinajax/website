<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>The ZipCPU by Gisselquist Technology</title>
    <description>The ZipCPU blog, featuring how to discussions of FPGA and CPU design. This site will be focused on Verilog solutions, using exclusively OpenSource IP products for FPGA design.
</description>
    <link>http://zipcpu.com/</link>
    <atom:link href="http://zipcpu.com/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Thu, 15 Jun 2017 17:58:57 -0400</pubDate>
    <lastBuildDate>Thu, 15 Jun 2017 17:58:57 -0400</lastBuildDate>
    <generator>Jekyll v3.0.1</generator>
    
      <item>
        <title>How to send our bus results back out the serial port</title>
        <description>&lt;p&gt;This post starts to complete the design of a very elementary debug port that
can be used to command an internal, on-board, wishbone bus.  Other posts in
this series include:&lt;/p&gt;

&lt;table style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 1: DBG Port Overview&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/wb-uart-smpl.svg&quot; alt=&quot;Block Diagram of a Simpler Wishbone to UART converter&quot; width=&quot;360&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;/blog/2017/06/05/wb-bridge-overview.html&quot;&gt;An overview of a UART to wishbone
bridge&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;How to build a &lt;a href=&quot;/blog/2017/06/08/simple-wb-master.html&quot;&gt;Simple Wishbone Master&lt;/a&gt;, and&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;How to &lt;a href=&quot;/blog/2017/06/14/creating-words-from-bytes.html&quot;&gt;create bus command words from a 7-bit data stream&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;We’ve slowly been building up to the implementation of a WB-UART component,
such as that in Fig 1.&lt;/p&gt;

&lt;p&gt;A this point, we’ve now described how to get a serial port up and running,
how to &lt;a href=&quot;/blog/2017/06/14/creating-words-from-bytes.html&quot;&gt;create words from the serial
stream&lt;/a&gt;, and
&lt;a href=&quot;/blog/2017/06/08/simple-wb-master.html&quot;&gt;how to control a simple wishbone bus
master&lt;/a&gt;
from the command words running through this stream.  We are very close to having
a working debug bus–since we can add the FIFOs and interrupts in later if
we have to.&lt;/p&gt;

&lt;p&gt;This lesson is about what it takes to turn the response words from the bus
master into a characters that will be sent out the output transport.  The
output transport, as you will recall, has a functionality similar to a
serial port.  Indeed, it might be a serial port, although it doesn’t need
to be.&lt;/p&gt;

&lt;h2 id=&quot;stream-timing&quot;&gt;Stream timing&lt;/h2&gt;

&lt;p&gt;Before we start, though, let’s examine how to handle stream timing.  Our
problem is that we will be generating words to be sent out of our serial
port at a rate that is much faster than the port can handle.  We’re going to
want to make certain that these response words are not lost–in spite of the
speed differential.&lt;/p&gt;

&lt;p&gt;Earlier, we described &lt;a href=&quot;2017/06/02/generating-timing.html&quot;&gt;how to build a strobe type of
signal&lt;/a&gt;.  For our purposes here, the
strobe signal was one that was valid for a single clock only.  Here, we are
also going to use a busy signal.  The two signals will work together in the
following way: the strobe will indicate a desire to send a word downstream,
while the busy response from the next component will be used to indicate that
the downstream component is not ready to receive.  To deal with this, once we
set our strobe we will continue to hold it high (request data be sent)
until the downstream components busy but is cleared.&lt;/p&gt;

&lt;p&gt;Conditions for moving forward will therefore look something like …&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;if ((i_stb)&amp;amp;&amp;amp;(!o_dw_busy))
	....&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This condition will be true any time we accept a request to send a word.&lt;/p&gt;

&lt;p&gt;Likewise, there is a similar condition on the downstream side of any stream
component:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;if ((o_dw_stb)&amp;amp;&amp;amp;(!i_tx_busy))
	....&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Prefixes will change depending upon which side of the link we are on, or
which components we are using, but the logic is going to be the same every
time.&lt;/p&gt;

&lt;p&gt;Now, with that out of the way, we can disassemble our words into a serial
port output channel.&lt;/p&gt;

&lt;h2 id=&quot;breaking-words-into-nibbles&quot;&gt;Breaking Words into nibbles&lt;/h2&gt;

&lt;p&gt;The trick to making any stream processing work is to only do a little bit of
processing at each step.  Hence for our first step, we turn our response
word into bytes.&lt;/p&gt;

&lt;p&gt;There are a couple primary variables to make this work.  The first one is
the word buffer, &lt;strong&gt;r_word&lt;/strong&gt;.  This buffer holds what is left of our response
word that has not yet been sent.  The next variable is the &lt;strong&gt;r_len&lt;/strong&gt; word
that holds how many valid nibbles remain in our &lt;strong&gt;r_word&lt;/strong&gt; register.&lt;/p&gt;

&lt;p&gt;Hence, on any new incoming word, as long as we are not busy, we send
a nibble noting the top two bits (Read data, write acknowledgement, etc.), and
we note that the register now has eight
nibbles within it.  In the case of any special words, we instead send the top
five bits of the command word and nothing more.  Other protocols would work
as well, this is just what we are going to choose.&lt;/p&gt;

&lt;p&gt;Here’s the big always blog for what we want to do.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	if (i_reset)
	begin
		// On reset, clear our variables
		r_word &amp;lt;= 0;
		r_len  &amp;lt;= 0;
		o_dw_stb  &amp;lt;= 1&#39;b0;
		o_dw_bits &amp;lt;= 5&#39;h0;
	end else if ((i_stb)&amp;amp;&amp;amp;(!o_dw_busy))
	begin			
		// If we are not busy, then load a new command
		// into our buffer to be sent
		r_word &amp;lt;= i_word[31:0];
		r_len  &amp;lt;= 4&#39;h8;

		o_dw_stb &amp;lt;= 1&#39;b1;
		o_dw_bits &amp;lt;= { 3&#39;b100, i_word[33:32] };
		if (i_word[33:32]==2&#39;b11)
		begin
			// If this is a special command,
			// grab all top 5-bits to output
			// them
			o_dw_bits &amp;lt;= i_word[33:29];
			r_len &amp;lt;= 4&#39;h0;
		end else if (i_word[33:32] == 2&#39;b01)
		begin // On an ACK, print only the &#39;K&#39;
			// and nothing more
			r_len &amp;lt;= 4&#39;h0;
		end
	end else if ((o_dw_stb)&amp;amp;&amp;amp;(!i_tx_busy))
	begin
		// Our last byte was accepted, move to the next one
		if (r_len != 4&#39;h0)
		begin
			o_dw_stb  &amp;lt;= 1&#39;b1;
			o_dw_bits &amp;lt;= { 1&#39;b0, r_word[31:28] };
			r_word &amp;lt;= { r_word[27:0], 4&#39;h0 };
			r_len  &amp;lt;= r_len - 1&#39;b1;
		end else
			o_dw_stb  &amp;lt;= 1&#39;b0;
	end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;We’ll simplify this giant always block by first removing the reset logic
from it.  Indeed, the only things that need reset logic are the &lt;strong&gt;r_len&lt;/strong&gt;
and &lt;strong&gt;o_dw_stb&lt;/strong&gt; registers.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
if (i_reset)
begin
	r_len &amp;lt;= 0;
	o_dw_stb &amp;lt;= 0;
end else if ((i_stb)&amp;amp;&amp;amp;(!o_dw_busy))
begin
	o_dw_stb &amp;lt;= 1&#39;b1;
	if (i_word[33:32]==2&#39;b11)
		r_len &amp;lt;= 4&#39;h0;
	else
		r_len &amp;lt;= 4&#39;h8;
end else if (!i_tx_busy)
begin
	o_dw_stb &amp;lt;= (r_len != 4&#39;h0);
	if (r_len != 4&#39;h0)
		r_len &amp;lt;= r_len - 1&#39;b1;
end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;You should find this logic identical to the big always block above.&lt;/p&gt;

&lt;p&gt;The rest of our logic, to include all the various wires associated with
the word register &lt;strong&gt;r_word&lt;/strong&gt; can then be drastically simplified.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
// No reset logic needed
if ((i_stb)&amp;amp;&amp;amp;(!o_dw_busy))
begin
	// On any new word, set the result
	r_word &amp;lt;= i_word;
end else if (!i_tx_busy)
	// Whenever we aren&#39;t busy, a new nibble is accepted
	// and the word shifts.  If we never set our output
	// strobe, this will never become busy, but if the
	// register isn&#39;t in use, there&#39;s no penalty to clearing
	// it repeatedly.
	r_word &amp;lt;= { r_word[27:0], 4&#39;h0 };&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Even the outputs may be set quite simply.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
if ((i_stb)&amp;amp;&amp;amp;(!o_dw_busy))
begin
	if (i_word[33:32] == 2&#39;b11)
		o_dw_bits &amp;lt;= i_word[33:29];
	else
		o_dw_bits &amp;lt;= { 3&#39;b100, i_word[33:32] };
end else if (i_tx_busy)
	o_dw_bits &amp;lt;= { 1&#39;b0, r_word[31:28] };&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;If you look over the difference between what we started with and where we
ended up, there’s a lot of differences.  All of these differences translate
into fewer resources in our output.  They can basically be summarized by this:
if you don’t care the what the value of a register is under certain conditions,
then don’t make that register depend upon those conditions.  Remember, the
resources used by a piece of logic can be (roughly) calculated by the number
of inputs that piece of logic requires.&lt;/p&gt;

&lt;h2 id=&quot;turning-nibbles-into-characters&quot;&gt;Turning nibbles into characters&lt;/h2&gt;

&lt;p&gt;The next step on the output process is to turn this stream of nibbles into
output characters.  This is almost a pure lookup table, but the stream
logic keeps it from being quite that.&lt;/p&gt;

&lt;p&gt;The stream logic consists of paying attention to the busy and strobe flags
to determine when we have an output to send.  In particular, if we are not
busy and a request is made of us, we’ll forward it down the line.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	if ((i_stb)&amp;amp;&amp;amp;(!o_gx_busy))
		// On a new request, send it forward
		o_gx_stb &amp;lt;= 1&#39;b1;
	else if (!i_busy)
		o_gx_stb &amp;lt;= 1&#39;b0;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Since we don’t have more than a single clock’s worth of processing to do here,
we can just set the busy bit to be the same as our output strobe bit.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;assign	o_gx_busy = o_gx_stb;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The real work is in the lookup table.  When given a value between 5’h0 and
5’hf, we just send the hexadecimal output.  Values with the 5’h10 bit set
indicate we need to send a special character.  You can see the special
characters we support below.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	if ((i_stb)&amp;amp;&amp;amp;(!o_gx_busy))
	begin
		case(i_bits)
		5&#39;h00: o_gx_char &amp;lt;= &quot;0&quot;;
		5&#39;h01: o_gx_char &amp;lt;= &quot;1&quot;;
		5&#39;h02: o_gx_char &amp;lt;= &quot;2&quot;;
		5&#39;h03: o_gx_char &amp;lt;= &quot;3&quot;;
		5&#39;h04: o_gx_char &amp;lt;= &quot;4&quot;;
		5&#39;h05: o_gx_char &amp;lt;= &quot;5&quot;;
		5&#39;h06: o_gx_char &amp;lt;= &quot;6&quot;;
		5&#39;h07: o_gx_char &amp;lt;= &quot;7&quot;;
		5&#39;h08: o_gx_char &amp;lt;= &quot;8&quot;;
		5&#39;h09: o_gx_char &amp;lt;= &quot;9&quot;;
		5&#39;h0a: o_gx_char &amp;lt;= &quot;a&quot;;
		5&#39;h0b: o_gx_char &amp;lt;= &quot;b&quot;;
		5&#39;h0c: o_gx_char &amp;lt;= &quot;c&quot;;
		5&#39;h0d: o_gx_char &amp;lt;= &quot;d&quot;;
		5&#39;h0e: o_gx_char &amp;lt;= &quot;e&quot;;
		5&#39;h0f: o_gx_char &amp;lt;= &quot;f&quot;;
		//
		5&#39;h10: o_gx_char &amp;lt;= &quot;R&quot;;	// Read response w/data
		5&#39;h11: o_gx_char &amp;lt;= &quot;K&quot;;	// Write ACK
		5&#39;h12: o_gx_char &amp;lt;= &quot;A&quot;;	// Address was set
		5&#39;h13: o_gx_char &amp;lt;= &quot;S&quot;;	// Special
		//
		5&#39;h18: o_gx_char &amp;lt;= &quot;T&quot;;	// reseT
		5&#39;h19: o_gx_char &amp;lt;= &quot;E&quot;;	// BUS Error
		5&#39;h1a: o_gx_char &amp;lt;= &quot;I&quot;;	// Interrupt
		5&#39;h1b: o_gx_char &amp;lt;= &quot;Z&quot;;	// I&#39;m here, but slping
		default: o_gx_char &amp;lt;= 8&#39;hd;	// Carriage return
		endcase
	end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Unknown characters just get quietly turned into carriage returns, which
the next module turns into carriage return and newline pairs (CR/NL).&lt;/p&gt;

&lt;h2 id=&quot;adding-carriage-returns-and-newlines-to-the-stream&quot;&gt;Adding Carriage Returns and Newlines to the Stream&lt;/h2&gt;

&lt;p&gt;The final step is to add a carriage return/newline pair to our output stream
any time it becomes idle.  This will assist any buffered software following
that might depend upon the end of a line before forwarding the data received.&lt;/p&gt;

&lt;p&gt;To do this, we’ll create a new stream component in our processing chain.
Any characters given to this stream will just send their characters back
out the port.  But, if the port is idle we’ll insert a carriage return into
the stream.  Then, any time a carriage return is sent out, we’ll set a register
&lt;strong&gt;last_cr&lt;/strong&gt; to indicate that we’ve sent one carriage return, and don’t need
to send it again.  This value will clear upon any new and valid data from
the port.&lt;/p&gt;

&lt;p&gt;The next state variable we’ll use is &lt;strong&gt;cr_state&lt;/strong&gt;.  This variable will be
set at anytime &lt;strong&gt;last_cr&lt;/strong&gt; is set, and we’ll clear it upon sending a newline.&lt;/p&gt;

&lt;p&gt;Put together, any time we enter our newline state, we’ll set &lt;strong&gt;last_cr&lt;/strong&gt; and
set &lt;strong&gt;cr_state&lt;/strong&gt;.  After the carriage return is sent, we’ll send a newline
and clear &lt;strong&gt;cr_state&lt;/strong&gt;.  We’ll then stay in that state until anything
else is sent through the port.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	if (i_reset)
	begin
		// On reset, act as though we&#39;ve already sent
		// a CR/NL pair
		cr_state &amp;lt;= 1&#39;b0;
		last_cr  &amp;lt;= 1&#39;b0;
		o_nl_stb &amp;lt;= 1&#39;b0;
	end else if ((i_stb)&amp;amp;&amp;amp;(!o_nl_busy))
	begin
		// On any input, set the last_cr bit if it was
		// a carriage return, and clear it otherwise. 
		// Clear the cr_state bit either way.
		o_nl_stb  &amp;lt;= i_stb;
		o_nl_byte &amp;lt;= i_byte;
		cr_state &amp;lt;= 1&#39;b0;
		last_cr &amp;lt;= (i_byte[7:0] == 8&#39;hd);
	end else if ((o_nl_busy)&amp;amp;&amp;amp;(!i_busy))
	begin
		// If we&#39;ve just sent something, let&#39;s check
		// if we need to send a cr/newline pair
		if (!last_cr)
		begin
			// We haven&#39;t sent a carriage
			// return.  So, send it if the
			// input is idle.
			cr_state  &amp;lt;= (!i_stb);
			o_nl_byte &amp;lt;= 8&#39;hd;
			last_cr   &amp;lt;= (!i_stb);
			o_nl_stb  &amp;lt;= (!i_stb);
		end else if (cr_state)
		begin
			// We&#39;ve sent the carriage
			// return, but not the newline.
			// Send the newline now.
			cr_state  &amp;lt;= 1&#39;b0;
			o_nl_byte &amp;lt;= 8&#39;ha;
			o_nl_stb  &amp;lt;= 1&#39;b1;
		end else
			// Idle the channel
			o_nl_stb  &amp;lt;= 1&#39;b0;
	end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h2 id=&quot;future-posts&quot;&gt;Future Posts&lt;/h2&gt;

&lt;p&gt;There, that’s all there is to it!  You now know how to take a response word
from the wishbone bus master, and how to send that result back out a serial
port.&lt;/p&gt;

&lt;p&gt;While we’ve just about presented all of the components, and while you almost
have a usable bus at this point, we’re not there yet.  Some particular
functionality remains missing.  This includes:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Adding interrupt notifications to the response stream&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Adding idle notifications to let you know you are connected to the right
stream&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Creating a simple wishbone interconnect&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Creating a hand-controlled test bench to prove this works&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Creating a software bus controller&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Now that our controller is nearly complete, though, these will be much simpler
topics.  We’ll come back to them in future posts.&lt;/p&gt;
</description>
        <pubDate>Thu, 15 Jun 2017 00:00:00 -0400</pubDate>
        <link>http://zipcpu.com/blog/2017/06/15/words-back-to-bytes.html</link>
        <guid isPermaLink="true">http://zipcpu.com/blog/2017/06/15/words-back-to-bytes.html</guid>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>No PI for you</title>
        <description>&lt;p&gt;FPGA’s can handle simple things well, and they handle simple things fast.
Other things like &lt;a href=&quot;https://en.wikipedia.org/wiki/Pi&quot;&gt;PI&lt;/a&gt;
(&lt;a href=&quot;https://www.angio.net/pi/digits/100000.txt&quot;&gt;3.141592653…&lt;/a&gt;) are harder to
deal with.  How then shall phase be dealt with within an FPGA, and in what
units?&lt;/p&gt;

&lt;p&gt;The mathematicians will define phase in units of
&lt;a href=&quot;https://en.wikipedia.org/wiki/Radian&quot;&gt;Radians&lt;/a&gt;, with values ranging
between zero and 2PI.  Further, the units are periodic, so anything outside
of the range between zero and 2PI may be brought into the range by adding
as many 2PI values as necessary.&lt;/p&gt;

&lt;p&gt;Others will define phase as a number between 0 and
360 degrees.&lt;/p&gt;

&lt;p&gt;Both refer to the same thing–the measure of time within a
periodic waveform from the beginning of the period.&lt;/p&gt;

&lt;p&gt;While Radians may be the natural units of phase (angles), they are not the
first choice of the FPGA designer.  Why not?&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;FPGA’s need to have a known number of bits to represent something.  If you
allocate enough bits to handle 0 to 8 (containing 0 to 2PI, or 6.28..),
you’ll have a difficult time dealing with 16PI.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Radian&quot;&gt;Radians&lt;/a&gt; have
roll over problems.  While both PI and 3PI/2 are valid angles
between 0 and 2PI, their sum is outside of the
range between 0 and 2PI.  Before you can use this out-of-range value,
and before you can add any more phase increments to it, the number must be
normalized by subtracting 2PI from it to get it back into the range of
0 to 2PI.&lt;/p&gt;

    &lt;p&gt;This will cost you a clock, and slow any algorithm you are building down by
a factor of two.&lt;/p&gt;

    &lt;p&gt;It will also only work if your wander into the range between 2PI and
4PI, but not between 50PI and 52PI.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;FPGA’s can’t really handle numbers between 0 and 1.&lt;/p&gt;

    &lt;p&gt;This problem is so common and the solution so well known that aspiring FPGA
DSP engineers might just multiply the values from 0 to PI by 2^N and consider
that the solution without ever thinking twice.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;While these might seem like viable solutions, a better approach
to dealing with angles exists.&lt;/p&gt;

&lt;h2 id=&quot;a-better-unit-for-angles&quot;&gt;A Better Unit for Angles&lt;/h2&gt;

&lt;p&gt;A simpler and better angular unit choice is simply to map the range from 0
to 2PI onto the integer interval from 0 to 2^N-1.  This can then be represented
with an N-bit number.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;fpga_val = floor( theta * 2^N / (2PI) + 0.5)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;What’s neat about this approach to angles within an FPGA is that rollover
is handled naturally, with no other logic required.&lt;/p&gt;

&lt;p&gt;Consider how one might add PI to 3PI/2.  We’ll use N=8, and so we’ll be
representing angles with to within a degree or two.  Hence,
our expression becomes 8’h80 plus 8’hc0.  If you add these two values together,
and throw out any rollover, you get the value 8’h40.&lt;/p&gt;

&lt;p&gt;Notice from this example how we didn’t need to waste a clock to bring our
results back within limits.  Neither were we restricted to only integer
Radian values, even though we did our calculation with integers.&lt;/p&gt;

&lt;p&gt;Even better, FPGA’s are often optimized for integer arithmetic.  Hence,
angular adjustments made in this fashion become easy and simple.&lt;/p&gt;

&lt;h2 id=&quot;generating-sine-or-cosine&quot;&gt;Generating Sine or Cosine&lt;/h2&gt;

&lt;p&gt;Depending upon your needs, you can easily convert this angle to a sine and
cosine value.&lt;/p&gt;

&lt;p&gt;For example, you could use the top bit as your sine wave value, and get a
square wave out with no more work.  This was the approach used by the &lt;a href=&quot;https://github.com/ZipCPU/wbfmtx&quot;&gt;wishbone
controlled FM transmitter hack&lt;/a&gt; in order
to transmit an FM signal from an FPGA.&lt;/p&gt;

&lt;p&gt;You could also use the top several bits as an index into a table, and so build
a direct digital synthesizer.&lt;/p&gt;

&lt;p&gt;Even slicker is to use your angle as an input to a &lt;a href=&quot;http://www.andraka.com/files/crdcsrvy.pdf&quot;&gt;CORDIC
algorithm&lt;/a&gt;.  In that
case, you can use this angle as an input to generate a sine wave or cosine
wave.  You can also use the &lt;a href=&quot;http://www.andraka.com/files/crdcsrvy.pdf&quot;&gt;CORDIC
algorithm&lt;/a&gt;
to multiply by sine and cosine (at the same time), or take arc-tangents.
If you like this idea, you ought to know that the &lt;a href=&quot;http://www.andraka.com/files/crdcsrvy.pdf&quot;&gt;CORDIC
algorithm&lt;/a&gt; can be pipelined so
as to operate at one input/output per clock–with no throughput loss, such as
you would’ve had were you using either
&lt;a href=&quot;https://en.wikipedia.org/wiki/Radian&quot;&gt;Radians&lt;/a&gt; or
&lt;a href=&quot;https://en.wikipedia.org/wiki/Degree_(angle)&quot;&gt;degrees&lt;/a&gt; as your angular units.&lt;/p&gt;

&lt;p&gt;Gosh, the &lt;a href=&quot;http://www.andraka.com/files/crdcsrvy.pdf&quot;&gt;CORDIC algorithm&lt;/a&gt; is just
&lt;em&gt;so&lt;/em&gt; useful, we might need to write a post on it by itself.&lt;/p&gt;

&lt;p&gt;Coming back to our topic, though, all of these approaches to generating sine
waves work nicely … but only if you use the right angular units.&lt;/p&gt;
</description>
        <pubDate>Thu, 15 Jun 2017 00:00:00 -0400</pubDate>
        <link>http://zipcpu.com/dsp/2017/06/15/no-pi-for-you.html</link>
        <guid isPermaLink="true">http://zipcpu.com/dsp/2017/06/15/no-pi-for-you.html</guid>
        
        
        <category>dsp</category>
        
      </item>
    
      <item>
        <title>How to create bus command words, from a 7-bit data stream</title>
        <description>&lt;p&gt;This is our next post in how to build a
&lt;a href=&quot;http://opencores.org/opencores,wishbone&quot;&gt;wishbone&lt;/a&gt; controlled debugging port
into your design.  Other posts on this topic include:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;/blog/2017/06/05/wb-bridge-overview.html&quot;&gt;An overview of a UART to wishbone
bridge&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;Don’t let the title fool you.  The &lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/rtl/wbubus.v&quot;&gt;UART to wishbone
bridge&lt;/a&gt; was my
first debugging bus.  It was so versatile, that I’ve rebuilt it for many other
platforms–not all of them using a &lt;a href=&quot;https://github.com/ZipCPU/wbuart32&quot;&gt;UART (serial)&lt;/a&gt; port.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;How to build a &lt;a href=&quot;/blog/2017/06/08/simple-wb-master.html&quot;&gt;Simple Wishbone Master&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;table style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 1: WB-UART Overview&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/wb-uart-smpl.svg&quot; alt=&quot;Block Diagram of a Simpler Wishbone to UART converter&quot; width=&quot;360&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;These two articles have presented the overview shown in Fig. 1 as a simple
bus overview that we might use.  Using this overview as a guide, we’ve discussed
how to build the
&lt;a href=&quot;/blog/2017/06/08/simple-wb-master.html&quot;&gt;bus master&lt;/a&gt;.
We’ve said nothing (yet) about FIFO’s, resets, interrupts, or converting
response words back to bytes.  Today, though, we’re going to discuss how to
create the command words from the incoming interface.  We’ll also use this
incoming port to generate a reset for the rest of the port.&lt;/p&gt;

&lt;p&gt;We’ll do this in two parts.  The &lt;a href=&quot;https://github.com/ZipCPU/dbgbus/blob/master/rtl/hexbus/wbdechex.v&quot;&gt;first
part&lt;/a&gt; will
turn our 7-bit incoming printable ASCII bytes into a shorter, simpler, 5’bit
values formatted to be used by the next component.  The &lt;a href=&quot;https://github.com/ZipCPU/dbgbus/blob/master/rtl/hexbus/wbpack.v&quot;&gt;second
part&lt;/a&gt; will
actually pack these bits into words and send them to our 
&lt;a href=&quot;https://github.com/ZipCPU/dbgbus/blob/master/rtl/hexbus/wbexec.v&quot;&gt;bus master&lt;/a&gt;
(since we have no FIFO yet …).&lt;/p&gt;

&lt;h2 id=&quot;design-outline&quot;&gt;Design Outline&lt;/h2&gt;

&lt;p&gt;We’d like to turn printable ASCII into command words.  We’re going to
design this ASCII in such a fashion that every command word will begin with
a capitol letter identifying the command, and end with 0-8 nibbles of
hexadecimal characters.  So, let’s look at what that requires:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Addresses will begin with an “A” character.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Read requests will consist of an “R” character alone.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Write requests will consist of an “W” character.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Reset requests consist of a “T” character.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Write requests and address values will be followed by 0-8 nibbles of value.
This value will encode either the value to be written, or the new address
to be set.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Unspecified command word bits will be set to zero, allowing unsigned
extensions of words.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Addresses will end in multiples of four.  If the 2 bit is set on an address,
the value will be added to the last address register.  If the 1 bit is clear,
the address will be incremented (by 4) on every read or write.  Hence,
“A2040RRRR” should read four consecutive values from the 0x02040 address.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Some examples of this coding would be:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Read from address 0x2040.&lt;/li&gt;
&lt;/ul&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;A2040R&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;ul&gt;
  &lt;li&gt;Write 0xdeadbeef to the address 0x2044&lt;/li&gt;
&lt;/ul&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;A2044Wdeadbeef&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;ul&gt;
  &lt;li&gt;Write a 1 to the next four consecutive addresses&lt;/li&gt;
&lt;/ul&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;W1W1W1W1&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Our encoding will need to turn these sorts of commands into 34-bit command
words suitable for the
&lt;a href=&quot;https://github.com/ZipCPU/dbgbus/blob/master/rtl/hexbus/wbexec.v&quot;&gt;bus master&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;transforming-printable-ascii-to-binary-nibbles&quot;&gt;Transforming Printable ASCII to Binary Nibbles&lt;/h2&gt;

&lt;p&gt;As outlined above, we’re going to focus on a hexadecimal encoding format. 
This is simply for the purpose of keeping the encoding simple enough so that
you can either type the value in via a keyboard, or perhaps read and comprehend
it when two pieces of software are talking to each other.  In both cases, you
want the command channel to be comprehensible.&lt;/p&gt;

&lt;p&gt;For this purpose, the values ‘0’-‘9’, and ‘a’-‘f’ will be transformed into
bit values 5’h0 to 5’hf.  Yes, that is a &lt;em&gt;five&lt;/em&gt; bit encoding we’re going to
use to go to the next step.&lt;/p&gt;

&lt;p&gt;Why?  If we are using a hexadecimal encoding, why do we need five bits?&lt;/p&gt;

&lt;p&gt;We’ll use the fifth bit to tell us some extra information: is this a read
request, a write command, a new address or a reset command?  These extra
options will use that extra bit, and we’ll generate it from specific
letters that aren’t part of the hexadecimal encoding.&lt;/p&gt;

&lt;p&gt;For example, if the user types a “T”, we’ll use that as an indication that
we want to reset our entire debugging bus component.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	o_reset &amp;lt;= (i_stb)&amp;amp;&amp;amp;(i_byte[6:0] == 7&#39;h54);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Otherwise, if we receive anything other than an incoming nothing character
7’h7f, we’ll be producing an output.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	o_stb   &amp;lt;= (i_stb)&amp;amp;&amp;amp;(i_byte[6:0] != 7&#39;h7f);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;All that’s left here is to decide what that output value will be.&lt;/p&gt;

&lt;p&gt;We’ll handle that with a giant case statement.  Although this may look complex,
once it gets turned into FPGA logic, this is nothing more than a 7-bit lookup
table per output bit, or about 20 LUTs.  (Remember &lt;a href=&quot;/blog/2017/06/12/minimizing-luts.html&quot;&gt;how to count
LUTs&lt;/a&gt;?)&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
begin
	case(i_byte[6:0])
	// Transform hexadecimal characters &#39;0&#39; to &#39;9&#39; to their
	// binary equivalents, with the out of band flag cleared
	7&#39;h30: o_bits &amp;lt;= 5&#39;h00;
	7&#39;h31: o_bits &amp;lt;= 5&#39;h01;
	7&#39;h32: o_bits &amp;lt;= 5&#39;h02;
	7&#39;h33: o_bits &amp;lt;= 5&#39;h03;
	7&#39;h34: o_bits &amp;lt;= 5&#39;h04;
	7&#39;h35: o_bits &amp;lt;= 5&#39;h05;
	7&#39;h36: o_bits &amp;lt;= 5&#39;h06;
	7&#39;h37: o_bits &amp;lt;= 5&#39;h07;
	7&#39;h38: o_bits &amp;lt;= 5&#39;h08;
	7&#39;h39: o_bits &amp;lt;= 5&#39;h09;
	//
	// Hexadecimal characters &#39;a&#39; through &#39;f&#39;
	//	(Note that &#39;A&#39; is used for &#39;Address&#39; and hence we don&#39;t
	//	support upper case hexadecimal letters here)
	7&#39;h61: o_bits &amp;lt;= 5&#39;h0a;
	7&#39;h62: o_bits &amp;lt;= 5&#39;h0b;
	7&#39;h63: o_bits &amp;lt;= 5&#39;h0c;
	7&#39;h64: o_bits &amp;lt;= 5&#39;h0d;
	7&#39;h65: o_bits &amp;lt;= 5&#39;h0e;
	7&#39;h66: o_bits &amp;lt;= 5&#39;h0f;
	//
	// Other characters set out of band information (o_bits[4])
	// These are primarily the bus command bits
	7&#39;h52: o_bits &amp;lt;= 5&#39;h10;	// &#39;R&#39;, or read command
	7&#39;h57: o_bits &amp;lt;= 5&#39;h11;	// &#39;W&#39;, or write command
	7&#39;h41: o_bits &amp;lt;= 5&#39;h12;	// &#39;A&#39;, set address
	7&#39;h53: o_bits &amp;lt;= 5&#39;h13;	// &#39;S&#39;, &quot;special&quot; ... reserved for later
	7&#39;h54: o_bits &amp;lt;= 5&#39;h16;	// &#39;T&#39; --set for form only
	default: // an &quot;other&quot; character, to be subsequently ignored.
		// Also used as an end of word character, if received
		o_bits &amp;lt;= 5&#39;h1f;
	endcase
end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;But what will we do with this five-bit value result?  That’s the next stage.&lt;/p&gt;

&lt;h2 id=&quot;transforming-binary-nibbles-to-words&quot;&gt;Transforming Binary Nibbles to Words&lt;/h2&gt;

&lt;p&gt;To pack four bits at a time into a 34-bit value is going to take several
steps.&lt;/p&gt;

&lt;p&gt;The first step deals with the upper two bits of the output command word.
These are given by the lower two bits in our five bit word, but only when
the upper bit is set.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;initial	o_word[33:32] = 2&#39;b11;
always @(posedge i_clk)
	if ((i_stb)&amp;amp;&amp;amp;(i_bits[4:2] == 3&#39;b100)) // new command
		o_word[33:32] &amp;lt;= i_bits[1:0];&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;We may wish to add other “special” command words into our dictionary in the
future.  Checking for 3’b100 checks that the high bit is set, but also leaves
room for us to check for other command words later.&lt;/p&gt;

&lt;p&gt;Now, any time we are told what command we are about to do, we’re going to need
to keep track of whether or not our register has a command loaded within it.
We’ll build our command word up from the first letter indicating what command
we are issuing (‘A’, ‘R’, or ‘W’).  On any non-hexadecimal character, we’ll
flush the command through the system.  We’re also going to clear any partial
command on any reset request.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;initial	cmd_loaded = 1&#39;b0;
always @(posedge i_clk)
	if (i_reset)
		cmd_loaded &amp;lt;= 1&#39;b0;
	else if ((i_stb)&amp;amp;&amp;amp;(i_bits[4:2] == 3&#39;b100))
		cmd_loaded &amp;lt;= 1&#39;b1;
	else if ((i_stb)&amp;amp;&amp;amp;(i_bits[4]))
		cmd_loaded &amp;lt;= 1&#39;b0;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Any thing else, any other special command, will just drop on the flow and
the command will go from loaded to unloaded.&lt;/p&gt;

&lt;p&gt;The last piece of logic before we build our word itself is the one to determine
when to send our word to the next stage.  We’ll do that any time we have a
command loaded and a new character comes in with that extra high-bit set.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;initial	o_stb = 1&#39;b0;
always @(posedge i_clk)
	o_stb &amp;lt;= (!i_reset)&amp;amp;&amp;amp;((i_stb)&amp;amp;&amp;amp;(cmd_loaded)&amp;amp;&amp;amp;(i_bits[4]));&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Now, finally, we can build the word that we will output.  At this point,
building this word in a register is quite easy.
On any new value, we just shift the new value into our word and move everything
over by four bits.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;initial	o_word[31:0] = 0;
always @(posedge i_clk)
	if (i_reset)
		r_word[31:0] &amp;lt;= 0;
	else if (i_stb)
	begin
		if (i_bits[4])
		begin
			// Record the command into our buffer
			r_word[33:32] &amp;lt;= i_bits[1:0];
			// Clear our buffer on any new command
			r_word[31:0] &amp;lt;= 0;
		end else
			// Other wise, new hex digits just get
			// placed in the bottom of our shift register,
			// and everything quietly moves over by one
			r_word[31:0] &amp;lt;= { r_word[27:0], i_bits[3:0] };
	end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Sure, we’ll clear our buffer on any new reset command and any time we get a
command word as opposed to a hex digit.  That way, if we want to send any short
unsigned numbers, we have only to give those unsigned digits.  For example,
W5W6\n will write the value five to the bus, and then the value 6.  With this
approach, we don’t need to send all 8-nibbles defining our 32-bit word if we
don’t have to.&lt;/p&gt;

&lt;p&gt;Finally, for timing purposes, we wait for an incoming value before setting
our output word.  Why timing?  Well, because our output strobe is only true
for the immediate clock following the incoming strobe.  &lt;strong&gt;r_word&lt;/strong&gt; has also
changed by then.  Hence, we’ll grab a copy before then of what we wish to
send out.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(posedge i_clk)
		if (i_reset)
			o_word &amp;lt;= 0;
		else if (i_stb)
			o_word &amp;lt;= r_word;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h2 id=&quot;thats-it&quot;&gt;That’s it!&lt;/h2&gt;

&lt;p&gt;That’s all there is to it.  You’ve now seen how simple it can be to compose
an output word from several input bytes.&lt;/p&gt;

&lt;p&gt;Sure, this protocol is simple.  It takes us up to 9-bytes to send a 32-bit
address, and another 9-bytes any time we wish to write a 32-bit value.
In other words, we are sending 72-bits any time we wish to use 34-bits worth
of information.&lt;/p&gt;

&lt;p&gt;Can this be improved upon?  Definitely.  But first, let’s just work through
what it takes to build our entire interface before we try to improve upon it.&lt;/p&gt;

</description>
        <pubDate>Wed, 14 Jun 2017 00:00:00 -0400</pubDate>
        <link>http://zipcpu.com/blog/2017/06/14/creating-words-from-bytes.html</link>
        <guid isPermaLink="true">http://zipcpu.com/blog/2017/06/14/creating-words-from-bytes.html</guid>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>Minimizing FPGA Resource Utilization</title>
        <description>&lt;p&gt;There have now been several projects I’ve worked on where I’ve butted up
against the maximum resource utilization of an FPGA chip.  If you ask a
manager how to deal with this problem, they will think you need a bigger FPGA.
This answer is problematic, though, for two primary reasons:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;If you already have your board designed, built, and tested–perhaps even in
production, and you wish to add features to the board, you will be stuck
with the FPGA resources that you already have.  Building or even just
assembling a new board with a bigger FPGA can be an expensive proposition.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;I’m a hobbyist.  I typically can’t afford a bigger FPGA&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;At times like these, a thorough code scrubbing can often help you squeak that
last Lookup-Table (LUT) out of your FPGA.  To do that, I’ve come up with
several strategies for reducing my LUT count on an FPGA.&lt;/p&gt;

&lt;h2 id=&quot;what-is-a-lut&quot;&gt;What is a LUT?&lt;/h2&gt;

&lt;p&gt;A LUT is a Look-Up Table.  Modern FPGA’s are built out of
large arrays of these lookup tables.  Using a lookup table, you can build
any logic you want–so long as you don’t exceed the number of elements in the
lookup table.&lt;/p&gt;

&lt;p&gt;As an example, the &lt;a href=&quot;https://www.xilinx.com/support/documentation/user_guides/ug474_7Series_CLB.pdf&quot;&gt;7-series Xilinx FPGAs&lt;/a&gt; are composed of
“configurable logic blocks”, each of which contain two “slices”, of
which each of those “slices” contain four 6-input LUTs.  Each of these
LUT’s can handle either one six input lookup, or two five input lookups–as
long as the two share the same inputs.&lt;/p&gt;

&lt;p&gt;The &lt;a href=&quot;https://www.altera.com/content/dam/altera-www/global/en_US/pdfs/literature/hb/cyclone-iv/cyciv-51002.pdf&quot;&gt;Altera Cyclone IV&lt;/a&gt;,
on the other hand, has only 4-input LUTs.&lt;/p&gt;

&lt;p&gt;The point being that every FPGA implements your logic via a combination of
LUTs.&lt;/p&gt;

&lt;p&gt;Chips differ by the capability of their LUTs, as well as by the number of LUTs
on board.  In general, the more LUTs you have, the more logic your chip can do,
but also the more your FPGA chip is going to cost.  It’s all a tradeoff.&lt;/p&gt;

&lt;p&gt;To get the most logic for a given price, the FPGA design engineer needs to be
able to code efficiently, and pack their code into the fewest LUTs possible.&lt;/p&gt;

&lt;h2 id=&quot;the-zipcpu-and-the-s6soc&quot;&gt;The ZipCPU and the S6SoC&lt;/h2&gt;

&lt;p&gt;When the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt; was first built, it only
supported 32-bit
&lt;a href=&quot;https://en.wikipedia.org/wiki/Byte&quot;&gt;bytes&lt;/a&gt;.  This meant that the smallest
unit of individually addressable memory was the full bus size: 32-bits. 
This has all kinds of consequences when you wish to operate on 8-bit values,
or when computer code depends upon 4*sizeof(char)==sizeof(int).&lt;/p&gt;

&lt;p&gt;In my case, the light dawned when I realized that I would need to rewrite the 
entire &lt;a href=&quot;http://sourceware.org/newlib&quot;&gt;C-library&lt;/a&gt; to support 32-bit bytes, that
the &lt;a href=&quot;https://en.wikipedia.org/wiki/Dhrystone&quot;&gt;Dhrystone benchmark&lt;/a&gt; depended upon
8-bit bytes (&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/doc/orconf.pdf&quot;&gt;Ref&lt;/a&gt;),
that &lt;a href=&quot;https://en.wikipedia.org/wiki/Coremark&quot;&gt;Coremark&lt;/a&gt; also depended upon
8-bit bytes.  Figuring that this was only the tip of the iceberg regarding the
problems I was going to have, I then decided to &lt;em&gt;byte&lt;/em&gt; the bullet and add
byte-wise addressing instructions to the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The problem with this was that the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;
already worked and worked well on some very small FPGA’s, and the
Spartan 6/LX4 on the
&lt;a href=&quot;http://store.digilentinc.com/cmod-s6-breadboardable-spartan-6-fpga-module&quot;&gt;CMod S6&lt;/a&gt; was
&lt;a href=&quot;https://github.com/ZipCPU/s6soc&quot;&gt;one of them&lt;/a&gt;.
With only 2400 six-input LUTs to work with in total, and only about 50 to
spare, could
the additional logic necessary to fit the new instructions fit onto the
&lt;a href=&quot;http://store.digilentinc.com/cmod-s6-breadboardable-spartan-6-fpga-module&quot;&gt;S6&lt;/a&gt;?&lt;/p&gt;

&lt;p&gt;I actually set my goals higher.  Not only did I want the new instructions to
fit, but I wanted to make some other upgrades as well.  Most of these other
upgrades surrounded the slow flash speed.  Because the S6/LX4 has hardly
any RAM, almost all of the instructions had to fit within the flash.  Flash
access, however, is &lt;em&gt;slow&lt;/em&gt;.  Hence, when I started my upgrades, the ZipCPU
took 52 clocks per instruction when running from the flash.  Ouch!  Could
something be done about this as well?&lt;/p&gt;

&lt;p&gt;So these were my goals:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;The obvious: I wanted to be able to support the extra 8-bit byte instructions:
LH (load halfword), SH (store halfword), LB (load byte), and SB (store byte).&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;I also wanted to upgrade the &lt;a href=&quot;https://github.com/ZipCPU/s6soc&quot;&gt;S6SoC&lt;/a&gt;
to be able to use the compressed instruction
set extension of the ZipCPU.  Using that extension, the assembler can
(sometimes) pack two instructions into one instruction word.  If the
&lt;a href=&quot;https://github.com/ZipCPU/s6soc&quot;&gt;S6SoC&lt;/a&gt; could be made to handle these
instructions, then I wouldn’t need to compile two versions of the C-library:
one using and one without using these instructions.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;I wanted to upgrade the fetch routine, so that it could handle fetching two
words at a time.&lt;/p&gt;

    &lt;p&gt;Because of the way the QSPI flash is set up, the first word you fetch from
flash
will always cost 22 flash clocks.  The first six of those are for the address,
the next 8 to allow the flash to look up your address, and then another
eight to read the data back out.  Since I was generating a clock signal from
logic, the flash actually ran at half that speed, costing me 
44 clocks every time I wished to fetch an instruction.  At the time, the
&lt;a href=&quot;https://github.com/ZipCPU/s6soc&quot;&gt;S6SoC&lt;/a&gt; had absolutely no pipelining,
so it was always fetching a new instruction after executing every instruction.&lt;/p&gt;

    &lt;p&gt;If I could fetch two instructions at a time, that would
cost only 60 clocks, and yet provide me with two instruction words.
This should raise the instruction speed from one instruction every 52 clocks
to one instruction every 38 clocks or so.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;I wanted to update the flash controller so that it would work off of a
80MHz flash clock instead of a 40MHz flash clock.  Basically, I wanted to
run the flash at the speed of the rest of the FPGA.  Since the flash was
rated for 100MHz, this shouldn’t be a problem, right?&lt;/p&gt;

    &lt;p&gt;This should reduce the number of clocks necessary to load two instructions
from 60 clocks to 30, speeding the instruction issue rate up to about one
instruction every 2 clocks.&lt;/p&gt;

    &lt;p&gt;In the end, supporting the compressed instructions got me down to one
instruction every 18 clocks, but I’m getting ahead of myself.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;As the update went along, things went so well I started to get greedy.  So, I
added more goals to my upgrade:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Now, I wanted to add the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/div.v&quot;&gt;divide
unit&lt;/a&gt; into the
design&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;I wanted a &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/cpuops.v&quot;&gt;full
multiply&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;I also wanted to partially pipeline &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;the CPU
itself&lt;/a&gt;.  I
still wanted to avoid the
expensive collision detection logic, but partially pipelining the CPU would
speed the CPU up another 60% (5 clocks per ALU instruction down to 3)&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;In the end, I got everything I wanted save the LOCK instruction.  (The LOCK
instruction holds the bus cycle line high while reading a value, running one
ALU operation on it, and then writing the value back.  It’s also useful
for atomically reading 64-bit values.)&lt;/p&gt;

&lt;h2 id=&quot;strategies-to-reduce-logic-usage&quot;&gt;Strategies to Reduce Logic Usage&lt;/h2&gt;

&lt;p&gt;Here’s how I managed to fit so many upgrades into 2400 LUTs, given that I was
already using 2345 of them.  (Yes, that’s right, on a device with 2400 LUTs,
I managed to use &lt;em&gt;all&lt;/em&gt; of them.)&lt;/p&gt;

&lt;p&gt;Here are some of the strategies I’ve used over time to keep my LUT usage
down:&lt;/p&gt;

&lt;h3 id=&quot;start-by-counting-your-logic&quot;&gt;Start by counting your logic.&lt;/h3&gt;

&lt;p&gt;Your design tools should be able to tell you how many LUTs you are using.
Some tools will even break this out nicely between design modules, helping
you to focus on the part that needs work.&lt;/p&gt;

&lt;p&gt;Find out how to do this, and then track your work throughout your design.&lt;/p&gt;

&lt;p&gt;While one strategy is to set your sites on the biggest components, I also
got a lot of savings by looking at how many LUTs were consumed by the smaller
components as well.  When you are starting out at 2345 LUTs out of 2400,
&lt;em&gt;every LUT matters&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Now, understand that the synthesizer is going to try to map all of your logic
into LUTs.  Every LUT can handle some number of inputs.  Look up what your
hardware’s definition of a LUT is, and then &lt;em&gt;count&lt;/em&gt; the number of
inputs to every flip-flop in your design.  Count the number of wires to
each flip-flop enable, and the number of alternatives within every block. 
Work to bring that number down to eight or less if possible, and you’ll be
amazed at how well your design will handle both fitting onto your device,
as well as the speed of the logic you can achieve using your logic.&lt;/p&gt;

&lt;p&gt;So, for some simple numbers to think about with respect to &lt;a href=&quot;https://www.xilinx.com/support/documentation/user_guides/ug474_7Series_CLB.pdf&quot;&gt;Xilinx’s CLB
structure&lt;/a&gt;:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;5 inputs: If you can get your logic down to five inputs or less, you might
be able to share a LUT with wires within a group&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;6 inputs: Anything that requires six inputs will require one LUT.  Be aware
of busses of logic all requiring 6-inputs … you are likely to need one
LUT for every input in that bus.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;7 inputs: Requires two LUTs and a 7-Mux.  This still fits within one slice,
so it doesn’t impact your timing (much) yet.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;8 inputs: Requires four LUTs and n 8-input mux.  This still fits within 
one slice&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;9 inputs and more: These don’t fit nicely into a LUT, nor do they fit nicely
into a set of four LUTs, and so the synthesis
tool is going to have to try to figure out how to string LUTs together to
accomplish your logic.  If your logic isn’t an add, subtract, or compare
that can use the carry chain, you may wish to do your best to avoid this
amount of logic.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;As you go through your logic: &lt;em&gt;force every LUT to justify its existence&lt;/em&gt;.&lt;/p&gt;

&lt;h3 id=&quot;use-block-ram-anywhere-you-can&quot;&gt;Use block RAM anywhere you can.&lt;/h3&gt;

&lt;p&gt;Look for memories that are implemented in LUTs, and turn them into block RAMs.
Anywhere you can do this will yield an &lt;em&gt;amazing&lt;/em&gt; savings.
Indeed, switching from LUTs to block RAM has often been the difference between
failure and success in my designs.&lt;/p&gt;

&lt;p&gt;For example, the following logic isn’t likely to make it into block RAM:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	if (A)
		mem[addrA] &amp;lt;= valA;
	else if (B)
		mem[addrB] &amp;lt;= valB;
	else if (C)
		mem[addrC] &amp;lt;= valC;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;However, with a couple simple manipulations, you can often trade a clock of
delay for the capability you need.  The following, for example, will fit in
Block RAM:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;// Capture the logic we need ...
always @(posedge i_clk)
	wr &amp;lt;= ((A)||(B)||(C));
always @(posedge i_clk)
	if (A)
	begin
		wAddr &amp;lt;= addrA;
		wData &amp;lt;= valA;
	end else if (B)
	begin
		wAddr &amp;lt;= addrB;
		wData &amp;lt;= valB;
	end else if (C)
	begin
		wAddr &amp;lt;= addrC;
		wData &amp;lt;= valC;
	end

// So we can implement it with simplicity on the next clock,
// using block RAM.
always @(posedge i_clk)
	if (wr)
		mem[wAddr] &amp;lt;= wData;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This was an important part of getting my
&lt;a href=&quot;https://github.com/ZipCPU/sdspi&quot;&gt;SD-SPI&lt;/a&gt; and
&lt;a href=&quot;https://github.com/ZipCPU/openarty/blob/master/enetpackets.v&quot;&gt;RMII ethernet&lt;/a&gt;
modules to work, although it didn’t help the
&lt;a href=&quot;https://github.com/ZipCPU/s6soc&quot;&gt;S6SoC&lt;/a&gt; in particular.  Still, it allowed
me to run the SD-SPI controller with a 200MHz clock – so lowering your LUT
usage is likely to increase your maximum speed as well.&lt;/p&gt;

&lt;h3 id=&quot;be-very-aware-of-nested-ifs&quot;&gt;Be very aware of nested if’s&lt;/h3&gt;

&lt;p&gt;My first attempt at any design tends to look like a giant if-then-else logic
block handling states and state transitions.  They’re just too easy to
understand and follow.  As an example, the &lt;a href=&quot;/blog/2017/06/08/simple-wb-master.html&quot;&gt;simple wishbone
master&lt;/a&gt;
controller we built the other day started
with a giant always block with several conditions.&lt;/p&gt;

&lt;p&gt;The problem with these large logic blocks is that there are often states where
you don’t care what certain values are for some variables.  In these cases,
you can simplify the logic for those states.&lt;/p&gt;

&lt;p&gt;For example, imagine something like ….&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
if (RESET)
begin
	valid &amp;lt;= 1&#39;b0;
	B &amp;lt;= 0; /// Really a don&#39;t care
end else if (CE)
begin
	valid &amp;lt;= (input is valid);
	B &amp;lt;= (... something of value);
end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Let’s count this logic:  Each of the bits in valid and B depend upon both RESET
and CE, hence a minimum of one LUT each.  Further, the flip-flop clock enable
line also requires a LUT for each flip flop.  So, we’re talking about 2 LUTs
for the valid signal, and another 2 LUTs &lt;em&gt;for every bit in B&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;If the only value that really depends upon the RESET is the valid signal,
which indicates whether or not B contains a valid value, why must B be set
on reset?  In this case, you want to separate your logic into multiple logic
blocks, often one block per variable.  You can then end up with something
like …&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
if (RESET)
	valid &amp;lt;= 1&#39;b0;
else if (CE)
	valid &amp;lt;= (input is valid);

always @(posedge i_clk)
if (CE)
	B &amp;lt;= (... something of value);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;If CE is a simple wire by itself, and not composed of more logic resources,
than it won’t cost any LUTs to calculate.  Likewise if the value you wish to
store in B comes from already calculated logic on your board, then you have
just spared yourself one LUT for every wire in B.  Even if there are several
inputs to the wires in B, if you just managed to drop from 6-inputs to five
for each wire, then you may have dropped the number of LUTs used to calculate
B in half.&lt;/p&gt;

&lt;p&gt;The impact of this can be significant.&lt;/p&gt;

&lt;p&gt;Two examples of updated and simplified logic would be my &lt;a href=&quot;https://github.com/ZipCPU/s6soc/qflashxpress.v&quot;&gt;simplified QSPI
flash controller&lt;/a&gt; when
compared with the giant always block in &lt;a href=&quot;https://github.com/ZipCPU/s6soc/blob/master/rtl/wbqspiflash.v&quot;&gt;basic flash
controller&lt;/a&gt;.
Even though the simplified controller can only handle read requests,
its amazingly light on the logic.&lt;/p&gt;

&lt;p&gt;Likewise, my recent rewrite of my 
&lt;a href=&quot;https://github.com/ZipCPU/wbuart32&quot;&gt;UART&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/wbuart32/blob/master/rtl/txuart.v&quot;&gt;transmitter&lt;/a&gt;
and
&lt;a href=&quot;https://github.com/ZipCPU/wbuart32/blob/master/rtl/rxuart.v&quot;&gt;receiver&lt;/a&gt;
saved me many LUTs by breaking up the logic in that big always block.
Perhaps you might enjoy looking through the
GIT history of this &lt;a href=&quot;https://github.com/ZipCPU/wbuart32&quot;&gt;UART controller&lt;/a&gt;,
to see how easy they were to read &lt;a href=&quot;https://github.com/ZipCPU/wbuart32/commit/e157c6e110e84f418514c7617db80519f5bba6ca&quot;&gt;back when they used a massive state
transition block&lt;/a&gt;, and then to compare that with what they look like today.&lt;/p&gt;

&lt;h3 id=&quot;reduce-your-requirements-if-you-can&quot;&gt;Reduce your requirements if you can&lt;/h3&gt;

&lt;p&gt;Very few UART controllers truly need to handle 5, 6, and 7-bit words, parity,
break setting and detection, parity error and frame error detection, hardware
flow control, and so forth.  If you know your application well, and
you have code in your application that is designed to handle things that will
never happen, then &lt;em&gt;remove that code&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;In my case, the 
&lt;a href=&quot;https://github.com/ZipCPU/wbuart32&quot;&gt;UART&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/wbuart32/blob/master/rtl/txuart.v&quot;&gt;transmitter&lt;/a&gt;
and
&lt;a href=&quot;https://github.com/ZipCPU/wbuart32/blob/master/rtl/rxuart.v&quot;&gt;receiver&lt;/a&gt;
had way more functionality than I needed.  So, I built a lighter UART
&lt;a href=&quot;https://github.com/ZipCPU/wbuart32/blob/master/rtl/txuartlite.v&quot;&gt;transmitter&lt;/a&gt;
and
&lt;a href=&quot;https://github.com/ZipCPU/wbuart32/blob/master/rtl/rxuartlite.v&quot;&gt;receiver&lt;/a&gt;
with only the capabilities I would ever use.
Since I had long since removed the UART
&lt;a href=&quot;https://github.com/ZipCPU/wbuart32/blob/master/rtl/ufifo.v&quot;&gt;FIFO&lt;/a&gt;,
there wasn’t much more I could after that.&lt;/p&gt;

&lt;p&gt;The point being, if you’ve over designed your product–remove the
all that extra, unused, logic when you get tight on resources.&lt;/p&gt;

&lt;h3 id=&quot;avoid-bit-selects-if-you-can&quot;&gt;Avoid bit selects if you can&lt;/h3&gt;

&lt;p&gt;I made a lot of adjustments to the
&lt;a href=&quot;https://github.com/ZipCPU/s6soc/blob/master/rtl/cpu/div.v&quot;&gt;divide unit&lt;/a&gt;
to get it to fit.  Most of these adjustments followed the advice above,
but one very powerful adjustment was also to get rid of a statement like …&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;if (lots_of_conditions)
	o_quotient[current_bit] &amp;lt;= (logic to calculate a bit);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;and, with some understanding that every bit needed to be set anyway, I was
able to rearrange that statement into,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;if (lots of conditions)
	o_quotient &amp;lt;= { o_quotient[30:0], (logic to calculate a bit) };&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Think about the LUT usage required to implement this statement.  The first
statement requires
many LUTs &lt;em&gt;per bit&lt;/em&gt; to determine not only whether that bit is going to be set,
but also what the bit will be set to.  The second example still requires some
LUTs to determine whether or not &lt;em&gt;a&lt;/em&gt; bit is going to be set, but those LUTs
can be shared across all bits.  Further, only the bottom bit has to have the
special set of LUTs to determine what the bit needs to be set to.&lt;/p&gt;

&lt;p&gt;That one optimization by itself saved me many, many LUTs.  In the end, I think
I saved about 100 LUTs out of a 300 LUT component, but you can look at the
&lt;a href=&quot;https://github.com/ZipCPU/s6soc/commits/master/rtl/cpu/div.v&quot;&gt;git log&lt;/a&gt; to see
the details of the other changes that were made along the way.&lt;/p&gt;

&lt;h3 id=&quot;manage-your-reset-logic&quot;&gt;Manage your Reset Logic&lt;/h3&gt;

&lt;p&gt;If you follow &lt;a href=&quot;https://www.xilinx.com/support/documentation/white_papers/wp272.pdf&quot;&gt;Xilinx’s
 guidance&lt;/a&gt;,
they would highly recommend against having
a global reset.  They explain pretty clearly how it impedes all of the logic
within your design.&lt;/p&gt;

&lt;p&gt;In my own implementations, such as within the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;ZipCPU&lt;/a&gt;, I
tend to create _valid lines stating whether or not a group of logic lines
is actually valid.  These lines then get the reset signal, while all the other
logic ignores it.  Indeed, many of my
&lt;a href=&quot;/projects.html&quot;&gt;ZipCPU implementations &lt;/a&gt;
don’t use a global (or even a local) reset at all.  Sure, the CPU has
a reset line … but I usually leave it unconnected, and instead command the
reset from some amount of local logic.  For example, both the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/wbwatchdog.v&quot;&gt;watchdog timer&lt;/a&gt;
and the debug port can command a reset.  Further, on a really small design
with no debug port (i.e., the &lt;a href=&quot;https://github.com/ZipCPU/s6soc&quot;&gt;S6SoC again&lt;/a&gt;),
I used a button for that purpose.&lt;/p&gt;

&lt;h3 id=&quot;application-specific-optimizations&quot;&gt;Application Specific Optimizations&lt;/h3&gt;

&lt;p&gt;Some optimizations, though, are by nature application specific.  A good
example of this is a &lt;a href=&quot;https://en.wikipedia.org/wiki/Finite_impulse_response&quot;&gt;FIR
filter&lt;/a&gt;
I built some time ago in support of my
&lt;a href=&quot;/projects.html&quot;&gt;universal resampling project&lt;/a&gt;.  (Any
rate in, to any lower rate out, out of band rejection greater than 70 dB, etc.)
When building &lt;a href=&quot;https://en.wikipedia.org/wiki/Finite_impulse_response&quot;&gt;the FIR&lt;/a&gt;,
I couldn’t afford to use block RAM’s to hold the coefficients—cause there was
no time for a RAM lookup: every coefficient needed to be used on every clock. 
The entire design, though, needed to run at the full clock rate.&lt;/p&gt;

&lt;p&gt;So, I made each tap settable from a single address that would push
them all through memory–like a giant shift register.  Still, this was too
much logic.&lt;/p&gt;

&lt;p&gt;In the end, even that wasn’t enough: I had to go farther so as to fix the
FIR taps with constant values within the filter.  Because of the nature
and structure of the resampling problem, this approach worked.&lt;/p&gt;

&lt;p&gt;I then managed to reduce the logic required even further by forcing the filter
to be symmetric.  Indeed, the &lt;a href=&quot;https://en.wikipedia.org/wiki/Parks-McClellan_filter_design_algorithm&quot;&gt;Parks-McClellan filter design
algorithm&lt;/a&gt;,
used for designing my lowpass anti-aliasing filters, &lt;em&gt;only&lt;/em&gt; designs
such &lt;a href=&quot;https://en.wikipedia.org/wiki/Linear_phase&quot;&gt;linear phase&lt;/a&gt; (i.e. symmetric)
filters anyway.  Thus, with this trick, I was able to use half as many
hardware multiplies.&lt;/p&gt;

&lt;p&gt;Looking over my taps, I then realized I could do more since some of the taps
were zero, some had only only one bit set in their coefficient, and since the
mid-point was already scaled to (2^N-1) so as to be able to use a subtract
instead of a multiply.&lt;/p&gt;

&lt;p&gt;If DSP usage is an issue, you might wish to consider this approach.&lt;/p&gt;

&lt;h3 id=&quot;keep-large-comparisons-out-of-state-transition-logic&quot;&gt;Keep large comparisons out of state transition logic&lt;/h3&gt;

&lt;p&gt;Don’t place large comparisons in your state transition diagrams if you
don’t need to.&lt;/p&gt;

&lt;p&gt;As an example, the logic below compares A against a 32-bit value, &lt;em&gt;and&lt;/em&gt;
C against a 24-bit value.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	A &amp;lt;= A + 1&#39;b1;
always @(posedge i_clk)
	C &amp;lt;= C + 7;

always @(posedge i_clk)
if (A == 32&#39;h00)
	B &amp;lt;= iB;
else if (C == 24&#39;h084)
	B &amp;lt;= ~B;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;If we are smart about things, we can move the comparison one clock earlier
and calculate intermediate values.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	zA &amp;lt;= &amp;amp;A;
always @(posedge i_clk)
	mC &amp;lt;= (C == 24&#39;h081);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;These two intermediate values then relieve the stress on the set for the
value of B,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
if (zA)
	B &amp;lt;= iB;
else if (mC)
	B &amp;lt;= ~B;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This was another technique that I used when simplifying the onboard
&lt;a href=&quot;https://github.com/ZipCPU/wbuart32&quot;&gt;UART&lt;/a&gt;.
To see how it works, look at the baud counter logic within the
&lt;a href=&quot;https://github.com/ZipCPU/wbuart32/blob/master/rtl/rxuartlite.v&quot;&gt;receiver&lt;/a&gt;,
and pay attention to the &lt;strong&gt;zero_baud_counter&lt;/strong&gt; logic.  At one time, the
state diagram had depended upon tests for whether or not
&lt;strong&gt;baud_counter&lt;/strong&gt; was zero.  You can see from the 
&lt;a href=&quot;https://github.com/ZipCPU/wbuart32/blob/master/rtl/rxuartlite.v&quot;&gt;receiver&lt;/a&gt;
source how not only was the &lt;strong&gt;baud_counter&lt;/strong&gt; logic removed from the main
always loop, but the &lt;strong&gt;zero_baud_counter&lt;/strong&gt; logic was removed as well.
Now, the main loop only references the &lt;strong&gt;zero_baud_counter&lt;/strong&gt; logic
strobe to know when to step the logic forward by one.&lt;/p&gt;

&lt;h3 id=&quot;if-all-else-fails-ask-for-help&quot;&gt;If all else fails, ask for help&lt;/h3&gt;

&lt;p&gt;Finally, if all else fails, ask  someone with more experience to look over
your code.  Perhaps they might see something you are missing?&lt;/p&gt;

&lt;p&gt;On second thought … maybe not.  They might tell me that the way I format my
code is all wrong.&lt;/p&gt;

&lt;h2 id=&quot;testing-the-changes&quot;&gt;Testing the changes&lt;/h2&gt;

&lt;p&gt;Since one focus of this blog is on testing and debugging, how did I manage to
prove that these new changes worked?&lt;/p&gt;

&lt;p&gt;First, all of these changes were tested initially within a simulation. 
My favorite simulation test was to see if I could get the
&lt;a href=&quot;https://github.com/ZipCPU/s6soc&quot;&gt;S6SoC&lt;/a&gt; to
run all the way from boot up to sending &lt;a href=&quot;https://github.com/ZipCPU/s6soc/blob/master/sw/wlibc/hello.c&quot;&gt;Hello
World&lt;/a&gt;
out the serial port.&lt;/p&gt;

&lt;p&gt;Second, the new instruction set also included special NOOP encodings.  These
allow me to place NOOPs into the code that will then cause the simulator
to print to the screen, whether it be characters, strings, register values,
or a full register dump.  The same code, when run within the hardware, would
just ignore these NOOP instructions.  These allowed me, when using the
simulator, to “debug by printf” all over the place.&lt;/p&gt;

&lt;p&gt;Third, the
&lt;a href=&quot;https://github.com/ZipCPU/s6soc/blob/master/sim/verilator/zip_sim.cpp&quot;&gt;simulator&lt;/a&gt;
also printed out a lot of trace information.  This was useful for tracing back
memory values that hadn’t been set appropriately all the way back to when they
were set.  Further, by matching the trace timing with
&lt;a href=&quot;http://gtkwave.sourceforge.net&quot;&gt;GTKwave&lt;/a&gt;’s timing, I was able to look up,
using &lt;a href=&quot;http://gtkwave.sourceforge.net&quot;&gt;GTKwave&lt;/a&gt;,
any values that weren’t printed in the trace to find the problem.&lt;/p&gt;

&lt;p&gt;Finally, for the bugs the first two items didn’t catch, I did have a
&lt;a href=&quot;https://github.com/ZipCPU/wbscope&quot;&gt;wishbone scope&lt;/a&gt; on board.  Since I didn’t
have room on board for my favorite debug interface, I set the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;CPU&lt;/a&gt; up so that
on any reset (button press) it would &lt;a href=&quot;https://github.com/ZipCPU/s6soc/blob/master/sw/dev/resetdump.s&quot;&gt;dump the
values&lt;/a&gt; of the
scope and the register values on startup (these weren’t cleared on reset). 
While the result is that the
&lt;a href=&quot;https://github.com/ZipCPU/s6soc/blob/master/sw/wlibc/hello.c&quot;&gt;Hello World&lt;/a&gt;
program’s output doesn’t start
out looking pretty, I can also use that startup output to find whatever caused
the CPU to halt and need to be restarted manually.&lt;/p&gt;

&lt;p&gt;So, it was all doable and straight forward.  Indeed, even today, if you don’t
have the
&lt;a href=&quot;http://store.digilentinc.com/cmod-s6-breadboardable-spartan-6-fpga-module&quot;&gt;CMod S6&lt;/a&gt;,
you can still test how the &lt;a href=&quot;https://github.com/ZipCPU/s6soc&quot;&gt;S6SoC&lt;/a&gt; would run
on that
&lt;a href=&quot;http://store.digilentinc.com/cmod-s6-breadboardable-spartan-6-fpga-module&quot;&gt;CMod S6&lt;/a&gt;
by using &lt;a href=&quot;https://github.com/ZipCPU/s6soc/trunk/blob/master/sim/verilator/zip_sim.cpp&quot;&gt;the simulator&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;how-did-it-work&quot;&gt;How did it work?&lt;/h2&gt;

&lt;p&gt;The changes outlined above were the difference between success and failure,
between getting the updated &lt;a href=&quot;https://github.com/ZipCPU/s6soc&quot;&gt;S6SoC&lt;/a&gt;
working with the new instruction set
&lt;em&gt;and the compressed instruction extension&lt;/em&gt;, or being able to abandon that
hardware (and my bragging rights) entirely.  Had I not made the optimizations
above, I might never have gotten the CPU to work with 8-bit bytes, and hence
I might’ve never had C-library support.  Now, however, not only does the CPU
run with 8-bit byte support, but it also has a &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/core/div.v&quot;&gt;divide
unit&lt;/a&gt;, and runs 3x
faster than it ever did before.&lt;/p&gt;

&lt;p&gt;What does all this mean?  If I disable illegal instruction detection for the
LOCK instruction, then I can play &lt;a href=&quot;https://github.com/ZipCPU/tttt&quot;&gt;4x4x4 Tic-Tac-Toe&lt;/a&gt; on my &lt;a href=&quot;http://store.digilentinc.com/cmod-s6-breadboardable-spartan-6-fpga-module&quot;&gt;CMod
S6&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;So is minimizing LUT usage important?&lt;/p&gt;

&lt;p&gt;Tell me your experiences!&lt;/p&gt;
</description>
        <pubDate>Mon, 12 Jun 2017 00:00:00 -0400</pubDate>
        <link>http://zipcpu.com/blog/2017/06/12/minimizing-luts.html</link>
        <guid isPermaLink="true">http://zipcpu.com/blog/2017/06/12/minimizing-luts.html</guid>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>A College Student&#39;s Response to the FPGA Design Process</title>
        <description>&lt;p&gt;I recently had the opportunity to help a college student on his end of term
project.  The student’s project sounded like a lot of fun to me, but in the
typical end of term, typical college fashion, I’m not sure it was nearly as
much fun for him or his teammate.&lt;/p&gt;

&lt;p&gt;When the term was over, I shared with him my &lt;a href=&quot;/blog/2017/06/02/design-process.html&quot;&gt;blog
post&lt;/a&gt;,
describing the difference
between the student’s design process, the expert’s design process, and the
actual expert’s design process, and then offered him a chance to respond now
that his term is over.&lt;/p&gt;

&lt;p&gt;What follows is that he had to say, and then my own thoughts on his
comments.&lt;/p&gt;

&lt;h2 id=&quot;a-college-students-perspective&quot;&gt;A College Student’s Perspective&lt;/h2&gt;

&lt;p&gt;I really liked &lt;a href=&quot;/blog/2017/06/02/design-process.html&quot;&gt;your blog
post&lt;/a&gt;, and I’d like to
respond to it with my own experience.&lt;/p&gt;

&lt;p&gt;I’ve now finally finished the project, and handed in my final report.&lt;/p&gt;

&lt;p&gt;It is not
as professionally done as I might like, and it is likely that it may be
missing some desired info.  However, the main key point I want to bring out
is that &lt;em&gt;we should have spent more time
testbenching via simulation on Vivado and creating accurate testbenches, with
wait times and hold times similar to realistic button presses as well as
accounting for delay times between components in the FPGA, the
&lt;a href=&quot;http://store.digilentinc.com/pmod-kypd-16-button-keypad/&quot;&gt;keypad&lt;/a&gt;,
and the
&lt;a href=&quot;http://store.digilentinc.com/pmodclp-character-lcd-with-parallel-interface/&quot;&gt;LCD&lt;/a&gt;&lt;/em&gt;.
All of our testbenches were made very simply with a few hundred
nanosecond wait times at most and hold times of 25-50 ns. This is obviously
not very realistic in terms of how long a button stays pressed or how long
it might take for our &lt;a href=&quot;https://en.wikipedia.org/wiki/Double_dabble&quot;&gt;double dabble
algorithm&lt;/a&gt; to work. In simulation,
a &lt;a href=&quot;https://en.wikipedia.org/wiki/Double_dabble&quot;&gt;double dabble&lt;/a&gt;
will occur virtually instantly, but realistically has a much higher latency
when implemented into the board.&lt;/p&gt;

&lt;p&gt;This was not accounted for in our testbenching nor during the design process,
which is something that I feel wasn’t pushed hard enough by the curriculum,
but also might have just been common sense and didn’t hit me until now. However,
judging by what you wrote in &lt;a href=&quot;/blog/2017/06/02/design-process.html&quot;&gt;your blog
post&lt;/a&gt;, it seems
that creating proper
testbenches for each and every module doesn’t happen often amongst students,
and I feel that &lt;em&gt;we are a good example of that, unfortunately&lt;/em&gt;. This just goes
to show that if I had spent more time creating testbenches for the interfaces
and tried to figure out ways for the FPGA to tell me what’s going on in all
that hardware, we might have had more success by the end of the project period.&lt;/p&gt;

&lt;p&gt;It is interesting how you mention getting diagnostics from the FPGA because
no one ever provided details or instructions on how we should do so or what
are good methods on communicating with the FPGA and how to know what parts of
the FPGA we could use to figure out if intermediate steps are working as we
want.&lt;/p&gt;

&lt;p&gt;I do feel a little scammed knowing that there were techniques out there that,
with just a couple minutes of explanation, might have saved me hours of
debugging. 
This makes me somewhat sad because I feel like I didn’t get
the experience and fulfillment from the class that I wanted/needed just
because someone was too tired or didn’t care to explain something to me.
This is what made me relate to &lt;a href=&quot;/blog/2017/06/02/design-process.html&quot;&gt;your blog post
post&lt;/a&gt;
where you mention in the beginning that the design
process for a student and a professional are almost two different worlds.&lt;/p&gt;

&lt;p&gt;Of course, my instructor would emphasize making a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Block_diagram&quot;&gt;block diagram&lt;/a&gt;, then going
into a &lt;a href=&quot;httpw://en.wikipedia.org/wiki/Finite-state_machine&quot;&gt;state machine&lt;/a&gt; and
&lt;a href=&quot;https://en.wikipedia.org/wiki/Datapath&quot;&gt;datapath&lt;/a&gt; drawing,
then designing the VHDL code,
&lt;a href=&quot;https://en.wikipedia.org/Test_bench&quot;&gt;testbenching&lt;/a&gt;, etc.
However, I feel like during homeworks, lectures, labs, and
the project period, the aid was almost a bit too lax and every time
I asked for help on why this warning is popping up or why the output
wouldn’t be showing on the
&lt;a href=&quot;http://store.digilentinc.com/pmodclp-character-lcd-with-parallel-interface/&quot;&gt;LCD&lt;/a&gt;,
I would get: “hmmm … I’m not too sure.  I haven’t really dived
into how the
&lt;a href=&quot;http://store.digilentinc.com/pmodclp-character-lcd-with-parallel-interface/&quot;&gt;LCD&lt;/a&gt;
works” or “have you tried testbenching it” or “try telling the
FPGA to give you some info back so you know what’s happening inside.”
There was never any in-depth discussion or a 
fulfilling moment where I felt “wow!  Now, I know how to prevent/fix this
warning or error” or perhaps “Okay, I understand that I may have to adjust my
design in this way and keep this in mind for the future”. Honestly, I felt
that I was winging it
the whole time.  It was frustrating.  Still, for some reason, I feel
like I still had fun with it. I had fun because it was challenging, it was not
easy, and every time I made a little bit of noticeable progress I felt like I
conquered the world. I just wish I didn’t have to conquer the world by myself.&lt;/p&gt;

&lt;p&gt;Enough of the slightly depressing monologue, the key lessons I learned were
these:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Make accurate testbenches for &lt;em&gt;everything&lt;/em&gt; even the really simple and
intuitive modules like
&lt;a href=&quot;https://en.wikipedia.org/wiki/Binary-coded_decimal&quot;&gt;BCD&lt;/a&gt;
to binary &lt;a href=&quot;https://en.wikipedia.org/wiki/Double_dabble&quot;&gt;converters&lt;/a&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Account for timing delays in the board that pretty much never happen
in the simulation&lt;/p&gt;

    &lt;p&gt;[Editor’s note: &lt;em&gt;You should test bench your entire design as well, not just
the components.  This also would’ve helped find out what was going as
the various components within the design interacted with each other.&lt;/em&gt;]&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The main issue I think we had was that we were sending the outputs from the
&lt;a href=&quot;http://store.digilentinc.com/pmod-kypd-16-button-keypad/&quot;&gt;keypad&lt;/a&gt;
to each module simultaneously, and it is likely that the later modules
were trying to perform calculations or send outputs to the
&lt;a href=&quot;http://store.digilentinc.com/pmodclp-character-lcd-with-parallel-interface/&quot;&gt;LCD&lt;/a&gt;
before data values were even finished
&lt;a href=&quot;https://en.wikipedia.org/wiki/Double_dabble&quot;&gt;converting&lt;/a&gt;
from
&lt;a href=&quot;https://en.wikipedia.org/wiki/Binary-coded_decimal&quot;&gt;BCD&lt;/a&gt;
to binary in the very first
module. Of course, it seems like this problem would fix itself after a few
cycles, but it was probably not smart to literally not account for timing in
the physical board.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Always ask for help from a close professional, professor, instructor, or
even the &lt;a href=&quot;https://forum.digilentinc.com&quot;&gt;friendly Digilent community&lt;/a&gt;. It is
so hard to do complex projects on
your own, especially when you have no or extremely minimal programming/coding
experience (that’s me).
Even if the instructor didn’t seem interested, I feel
like I should’ve sucked it up and just asked for help more often.
My instructor was smart as hell and I still had
tons of things I definitely did not know how to do without some help.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;A big thing in the &lt;a href=&quot;/blog/2017/06/02/design-process.html&quot;&gt;blog
post&lt;/a&gt;
is getting diagnostics and always retracing
steps. Sometimes the testbench isn’t the problem, it’s the design. For example,
&lt;a href=&quot;https://forums.xilinx.com/t5/Implementation/why-latches-are-considered-bad/td-p/200291&quot;&gt;latches&lt;/a&gt;,
time loops, etc. can all be affected my design in ways that I don’t
understand but are still making it not work the way I want. Pay attention to
warnings and don’t dismiss anything until you get confirmation or find online
that the warning doesn’t mean much.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;my-own-thoughts&quot;&gt;My Own Thoughts&lt;/h2&gt;

&lt;p&gt;Perhaps I might pull out of his response some key points worth taking away
from it.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;… it also might’ve been just common sense and didn’t hit me until now.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;This is half of the point of any education: to get the student to learn how
to think about a task in such a way as to make the task simple.
I’m not talking about the mechanics of the task necessarily, but rather
how to wrap your mind around the task, so that your mind thinks in the
language of the task.  The means of achieving this enlightenment is usually
 to give the student one task after another until the student finally learn’s
how to school his own mind.&lt;/p&gt;

&lt;p&gt;This is also why an employer would be excited to see a large portfolio of
complex projects you have designed.  It means you understand how to &lt;em&gt;think&lt;/em&gt;
like a digital designer.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;This makes me somewhat sad because I feel like I didn’t get
the experience and fulfillment from the class that I wanted/needed just
because …&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;I think you’ve now learned the lesson the class was trying to teach.  Next
time, let’s see if we can’t get that lesson across with a little less pain,
and a better grade.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Every time I asked for help on why this warning is popping up or why the
output wouldn’t be showing on the
&lt;a href=&quot;http://store.digilentinc.com/pmodclp-character-lcd-with-parallel-interface/&quot;&gt;LCD&lt;/a&gt;,
I would get:
&lt;em&gt;“hmmm … I’m not too sure. I haven’t really dived into how the
&lt;a href=&quot;http://store.digilentinc.com/pmodclp-character-lcd-with-parallel-interface/&quot;&gt;LCD&lt;/a&gt;
works”&lt;/em&gt;
or
&lt;em&gt;“have you tried testbenching it”&lt;/em&gt;
or
&lt;em&gt;“try telling the FPGA to give you some info back so you know what’s
happening inside.”&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;If I were your instructor, these might be my responses as well.  If you write
into the &lt;a href=&quot;https://forums.xilinx.com&quot;&gt;Xilinx forums&lt;/a&gt;, you are also likely to
get similar responses.&lt;/p&gt;

&lt;p&gt;To understand why, think about it from the other side: I’ve now been a mentor
for many students.  I’ve looked over many pieces of code trying to find their
bugs.  While I find it a fun challenge, it’s not easy.&lt;/p&gt;

&lt;p&gt;Indeed, finding bugs in my own code is hard enough, finding bugs in someone
else’s code is a lot harder.
It can take me between minutes and hours to find the mistake in someone else’s
code, depending upon the complexity of the code.  (Debouncing
&lt;a href=&quot;http://store.digilentinc.com/pmod-kypd-16-button-keypad/&quot;&gt;keypad&lt;/a&gt;’s is
usually quick, debugging &lt;a href=&quot;https://github.com/ZipCPU/dblclockfft&quot;&gt;FFT&lt;/a&gt;’s is
hard.)&lt;/p&gt;

&lt;p&gt;To make getting help easier, you must first find out what the issue is.
The instructor is right in this case, you need to tell “the FPGA to give you
some info back so you know what’s happening inside.”&lt;/p&gt;

&lt;p&gt;That in itself is one of the ongoing topics of this blog.&lt;/p&gt;

&lt;p&gt;Although it’s a touch off topic: when I studied for my Ph.D., my advisor had
no background in my field (Digital signal processing as applied to digital
communications).  He couldn’t help me with any of the details of how to do the
mechanics of my problem.  Originally, I would’ve thought that this would’ve
disqualified him from advising me.  In hindsight, I think it worked out to
everyone’s advantage–because it forced me to finally learn how to
learn a topic for myself.  At some point, there’s only so much an instructor
can do.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;There was never any in-depth discussion or a fulfilling moment where I felt
“wow!  Now, I know how to prevent/fix this warning or error”
or perhaps
“Okay, I understand that I may have to adjust my design in this way
and keep this in mind for the future”.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;I think our student has now just had his aha moment–only he may not realize
it yet.&lt;/p&gt;

&lt;p&gt;Stick around.  This is what we are going to try to do here on this blog:
explain what it takes to keep you from getting stuck in the future!&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;It was frustrating.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;a href=&quot;/fpga-hell.html&quot;&gt;FPGA Hell&lt;/a&gt; is &lt;em&gt;always&lt;/em&gt; frustrating.  Let’s
get you out of &lt;a href=&quot;/fpga-hell.html&quot;&gt;FPGA Hell&lt;/a&gt;, so that you can
enjoy winging it like the rest of us.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;I had fun because it was challenging, it was not easy, and every time
I made a little bit of noticeable progress I felt like I conquered the world.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;This is one of my own personal reasons for doing digital design.&lt;/p&gt;

&lt;p&gt;Can I share a secret with you all?  I keep a copy of the
&lt;a href=&quot;https://www.youtube.com/watch?v=78N2SP6JFaI&quot;&gt;theme from Superman&lt;/a&gt; lying around,
just to be able to share the excitement of success with the others in the
office.  I’ve even bought copies of the theme from &lt;a href=&quot;https://www.youtube.com/watch?v=IgncJgSbbck&quot;&gt;Indiana
Jones&lt;/a&gt;, from &lt;a href=&quot;https://www.youtube.com/watch?v=4rQSJDLM8ZE&quot;&gt;Star
Wars&lt;/a&gt;, and … I’d better
just stop there.&lt;/p&gt;

</description>
        <pubDate>Sat, 10 Jun 2017 00:00:00 -0400</pubDate>
        <link>http://zipcpu.com/blog/2017/06/10/lost-college-student.html</link>
        <guid isPermaLink="true">http://zipcpu.com/blog/2017/06/10/lost-college-student.html</guid>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>Building a Simple Wishbone Master</title>
        <description>&lt;p&gt;Explaining how to build a good &lt;a href=&quot;/blog/2017/06/05/wb-bridge-overview.html&quot;&gt;wishbone controlled debug
port&lt;/a&gt;
may take a couple of posts to do right.  Worse, it may take us a couple of
rounds just to get the logic right, but let’s try anyway.&lt;/p&gt;

&lt;table style=&quot;float: left&quot;&gt;&lt;caption&gt;Fig 1: WB-UART Overview&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/wb-uart-smpl.svg&quot; alt=&quot;Block Diagram of a Simpler Wishbone to UART converter&quot; width=&quot;360&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;For this post, we’re going to concentrate on the wishbone bus master found
at the bottom of the simplified UART to wishbone converter, as outlind in
Fig 1.&lt;/p&gt;

&lt;p&gt;Hence, if the whole capability will eventually look like Fig 1, we’re only
looking at the component at the very bottom within this post, and even then
we’re only going to examine a simplified version of it.  We’ll leave the
implementation of multiple transactions at once for a later date.&lt;/p&gt;

&lt;p&gt;My strategy for this blog post will be to come back and update it later
with any updates or fixes, so (hopefully) any mistakes will get fixed over
time.&lt;/p&gt;

&lt;p&gt;We are going to try to take this opportunity to build a simple wishbone bus
master.  Before starting, you may wish to grab a copy of the
&lt;a href=&quot;http://opencores.org/opencores,wishbone&quot;&gt;wishbone bus specification&lt;/a&gt; and
follow along in the
&lt;a href=&quot;http://opencores.org/cdn/downloads/wbspec_b4.pdf&quot;&gt;B4 version&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;You can find definitions for the various wishbone interface
wires in chapter two.  We’re going to continue following our practice of
prepending input wires with &lt;strong&gt;i_…&lt;/strong&gt; and output wires with &lt;strong&gt;o_..&lt;/strong&gt;, even
though the specification appends similar notes.  We’re also going to add
the &lt;strong&gt;_wb_&lt;/strong&gt; designator to all of the inputs associated with the wishbone
bus.  Hence, &lt;strong&gt;i_wb_ack&lt;/strong&gt; will reference the return acknowledgement from
the slave.&lt;/p&gt;

&lt;p&gt;Chapter three of the 
&lt;a href=&quot;http://opencores.org/cdn/downloads/wbspec_b4.pdf&quot;&gt;spec&lt;/a&gt; describes how the
various wishbone wires compose a bus cycle.
We’ll specifically be implementing the &lt;em&gt;pipelined bus cycle&lt;/em&gt; (not the classic
bus cycle), and we’re eventually going to build our implementation so that
it can issue requests across the bus in a pipelined fashion as fast as the
slave will allow it.&lt;/p&gt;

&lt;p&gt;If you are a visual learner, check out figures 3-6, and 3-8 from
&lt;a href=&quot;http://opencores.org/cdn/downloads/wbspec_b4.pdf&quot;&gt;the specification&lt;/a&gt;.
I find these to be the most useful, as I’m explaining how the bus works.
We’ll reserve the capability shown in Figures 3-11 and 3-13 for a later post.&lt;/p&gt;

&lt;p&gt;For today’s post, we’ll handle a single bus interaction per bus cycle, so
the CYC line will be lowered between requests.  We’ll revisit this decision
in a later post so that we can issue multiple requests of the bus at
one request per clock, but that will be a later discussion.&lt;/p&gt;

&lt;p&gt;Further, you can see the code as we’re building it in the &lt;a href=&quot;https://github.com/ZipCPU/icozip&quot;&gt;ICO Zip
repository&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/icozip/blob/master/rtl/exbus/exsimple.v&quot;&gt;here&lt;/a&gt;.
Since the &lt;a href=&quot;https://github.com/ZipCPU/icozip&quot;&gt;ICO Zip project&lt;/a&gt; isn’t fully
functional (yet), we’ll be building on the master branch.  That will also help
to make sure our link references stay valid over time–even if we need to
modify our files later.&lt;/p&gt;

&lt;h2 id=&quot;the-control-interface&quot;&gt;The Control Interface&lt;/h2&gt;

&lt;p&gt;The bus master interface we are building will ultimately be commanded from an
external interface.  We’ve
&lt;a href=&quot;/blog/2017/06/05/wb-bridge-overview.html&quot;&gt;already discussed&lt;/a&gt;
how that one might wish to do this over &lt;a href=&quot;http://icoboard.org&quot;&gt;ICO board&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/icozip/blob/master/rtl/pptest&quot;&gt;parallel port&lt;/a&gt;,
&lt;a href=&quot;https://github.com/ZipCPU/wbuart32&quot;&gt;UART&lt;/a&gt;, SPI, or
&lt;a href=&quot;https://github.com/ZipCPU/xulalx25soc/blob/master/rtl/jtagser.v&quot;&gt;JTAG&lt;/a&gt;. 
Exactly which is used will be external to our bus master implementation.&lt;/p&gt;

&lt;p&gt;We’ll have to build up the functionality in our control interface 
as we build up the whole interface.  The two sort of go together.&lt;/p&gt;

&lt;p&gt;For now, let’s handle all of our communication using 34-bit words.  We’ll use
the top 2-bits of these 34-bit words for signaling, and then the bottom 32 for
any values we wish to pass.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;input		i_reset;
input		i_cmd_stb;
input	[33:0]	i_cmd_word;
output	reg	o_cmd_busy;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Our input data word will be valid any time &lt;strong&gt;i_cmd_stb&lt;/strong&gt; is valid, but it will only
be accepted whenever &lt;strong&gt;o_cmd_busy&lt;/strong&gt; is false.  Hence, when you read the code, you
may find (&lt;strong&gt;i_stb&lt;/strong&gt;)&amp;amp;&amp;amp;(!&lt;strong&gt;o_cmd_busy&lt;/strong&gt;).  This will be the indication a
request has been accepted.&lt;/p&gt;

&lt;p&gt;For now, we’ll just set &lt;strong&gt;o_cmd_busy&lt;/strong&gt; to be true any time the bus is active.
Eventually, we’ll want to take a peek at the next bus request, and drop 
&lt;strong&gt;o_cmd_busy&lt;/strong&gt; if the next request is one we are interested in.  For example,
if we are busy doing something and the user requests a bus reset, we’ll
need to drop the busy line and accept that request.&lt;/p&gt;

&lt;p&gt;For our command words, we’ll use the following definition to define how the
34-bit control words will be interpreted:&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;33&lt;/th&gt;
      &lt;th&gt;32&lt;/th&gt;
      &lt;th&gt;31 - 0&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;Read request, ignore the rest of the 32-bits, ACK on output&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;Write request, the 32-bit data contains the word to be written&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;Set an address.  If bit 31 is set, we’ll add this value to the current bus address.  If bit 30 is set, the address will be incremented upon each bus access&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;4’h0, 28’hxx, Bus Reset&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;Our signaling scheme will allow us to issue a bus reset command, which will
abruptly cause us to abandon any bus cycle we may be in the middle of.  To
make this work, the bus reset request will need to override the busy flag.&lt;/p&gt;

&lt;p&gt;This is not the most efficient scheme.  For example, why send 34-bits when
you are only going to pay attention to two of them (i.e. the read)?  Wouldn’t
it make more sense to send a smaller number of bits for the read, together with
the number of items you intend to read?  Yes, it would.  Optimizing this command
word will be the subject of another post.&lt;/p&gt;

&lt;p&gt;The output of our bus will use (almost) the exact same approach.  We’ll create
a &lt;strong&gt;o_rsp_stb&lt;/strong&gt; signal that will be true any time the output references a
valid codeword.  Unlike the input, though, we’ll ignore any flow control on the 
output.  We can add some amount of flow control back in later with
&lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/rtl/wbufifo.v&quot;&gt;a FIFO&lt;/a&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;input		o_rsp_stb;
input		o_rsp_word;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;We’ll also borrow from the input codeword encoding for the return trip encoding,
as shown below:&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;33&lt;/th&gt;
      &lt;th&gt;32&lt;/th&gt;
      &lt;th&gt;31 - 0&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;Acknowledge a write.  The 32-bit value contains number of writes to acknowledge&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;Read response, the 32 data bits are the word that was read&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;Acknowledge an address that has been set, with two zero bits and 30 address bits&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;3’h0, 29’hxx, Bus Reset acknowledgement&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;3’h1, 29’hxx, Bus Error&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;decoding-the-control-interface&quot;&gt;Decoding the Control Interface&lt;/h2&gt;

&lt;p&gt;We have only four different types of command words in our code book.
In the first section of our simple bus master, we’ll create
flags to indicate which request is currently being made.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;assign	i_cmd_rd   = (i_cmd_stb)&amp;amp;&amp;amp;(i_cmd_word[33:32] == 2&#39;b00);
assign	i_cmd_wr   = (i_cmd_stb)&amp;amp;&amp;amp;(i_cmd_word[33:32] == 2&#39;b01);
// We&#39;ll use i_cmd_bus to capture whether we have a read or write request
assign	i_cmd_bus  = (i_cmd_stb)&amp;amp;&amp;amp;(i_cmd_word[33]    == 1&#39;b0);
//
assign	i_cmd_addr = (i_cmd_stb)&amp;amp;&amp;amp;(i_cmd_word[33:32] == 2&#39;b10);
assign	i_cmd_special = (i_cmd_stb)&amp;amp;&amp;amp;(i_cmd_word[33:32] == 2&#39;b11);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;You may notice that I have violated my naming convention with these wires:
I have named locally generated wires with an &lt;strong&gt;i_…&lt;/strong&gt; prefix when they are
not actual inputs to our bus master module, but rather the results of
combinatorial logic applied to inputs.  In this case, it tends to work
out, but it’s not something I’m regularly going to do.&lt;/p&gt;

&lt;h2 id=&quot;the-wishbone-master-interface&quot;&gt;The Wishbone Master Interface&lt;/h2&gt;

&lt;p&gt;This bus controller will have three basic states, as shown in Fig 2.&lt;/p&gt;

&lt;table syle=&quot;float: none; align: center&quot;&gt;&lt;caption&gt;Wishbone Master State Transition Diagram&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/wb-simple-master.svg&quot; alt=&quot;Simple Bus Master state transition diagram&quot; width=&quot;700&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Here’s a quick description of each of those states:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;em&gt;IDLE&lt;/em&gt;: When we are doing nothing, both CYC and STB must be low.  In this
state, we’ll need to be responsive to incoming requests from the bus.
Upon a request, we’ll need to set the request direction (&lt;strong&gt;o_wb_we&lt;/strong&gt;),
the data lines (&lt;strong&gt;o_wb_data&lt;/strong&gt;) and then CYC and STB.&lt;/p&gt;

    &lt;p&gt;We’ll also set our address lines in this state, but without adjusting
CYC or STB.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;em&gt;BUS REQUEST&lt;/em&gt;: When CYC and STB are both high, a bus request is taking
place.  This request phase lasts until &lt;strong&gt;i_wb_stall&lt;/strong&gt; goes low, at
which point our request has been accepted.&lt;/p&gt;

    &lt;p&gt;When we come back to this code later and transition it to handling multiple
requests, we will transition from one request
to the next any time &lt;strong&gt;o_wb_stb&lt;/strong&gt; is true and &lt;strong&gt;i_wb_stall&lt;/strong&gt; is false.&lt;/p&gt;

    &lt;p&gt;It is also possible that the acknowledgement might be received on the same
clock the transaction was requested.  We’ll need to make certain we deal
with this case.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;em&gt;BUS RESPONSE&lt;/em&gt;: After making a request of the bus, we need to wait until
the slave acknowledges it.  Every acknowledgement will lead us to sending
another response across our command interface back up our command stream.
More importantly, every read response will also need to carry the value
read from the &lt;strong&gt;i_wb_data&lt;/strong&gt; data lines in its payload.  We’ll need to
make certain we return those back to the user.&lt;/p&gt;

    &lt;p&gt;Once the last acknowledgement is received, we can transition back to the
idle state.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;There are a couple of exceptions to this model: if a bus error occurs, we’ll
simply abandon the current transaction.  This approach has the inherent
problem in it that acknowledgements may come back later and get mixed with
another bus request.  For now, we’ll accept that risk and do it anyway,
since it may be the only way to recover the bus if a peripheral is
non-responsive.&lt;/p&gt;

&lt;h3 id=&quot;simplified-overview&quot;&gt;Simplified Overview&lt;/h3&gt;

&lt;p&gt;If you’re still somewhat new to digital design and coming from the
software world, your first approach to building a Wishbone Bus Master might
look something like the following:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;initial	o_wb_cyc = 1&#39;b0;
initial	o_wb_stb = 1&#39;b0;
initial	newaddr  = 1&#39;b0;
initial	o_rsp_stb= 1&#39;b0;
always @(posedge i_clk)
if ((i_reset)||(i_wb_err))
begin
	o_wb_cyc &amp;lt;= 1&#39;b0;
	o_wb_stb &amp;lt;= 1&#39;b0;
	o_cmd_busy   &amp;lt;= 1&#39;b0;
	o_rsp_stb    &amp;lt;= 1&#39;b1;
	newaddr &amp;lt;= 0;

	// Return over the command interface that we just had an error,
	// or a bus reset
	if (i_wb_reset)
		o_rsp_word &amp;lt;= `RSP_RESET;
	else
		o_rsp_word &amp;lt;= `RSP_BUS_ERROR;
end else if ((i_cmd_stb)&amp;amp;&amp;amp;(!o_cmd_busy))
begin
	//
	// In the idle state
	//
	newaddr &amp;lt;= 0;
	if (i_cmd_addr)
	begin
		if (!i_cmd_word[1])
			o_wb_addr &amp;lt;= i_cmd_word[29:0];
		else
			o_wb_addr &amp;lt;= i_cmd_word[29:0] + o_wb_addr;

		inc &amp;lt;= !i_cmd_word[0];

		// Acknowledge the new address -- on the next clock
		// (after the add has completed)
		newaddr &amp;lt;= 1&#39;b1;
	end

	if (newaddr)
	begin
		o_rsp_stb &amp;lt;= 1&#39;b1;
		o_rsp_word &amp;lt;= { `RSP_SUB_ADDR, o_wb_addr, 1&#39;b0, !inc };
	end

	o_wb_we &amp;lt;= (i_cmd_wr);

	// On a read or write request, activate the bus and go to the bus
	// request state
	if (i_cmd_bus)
	begin
		o_wb_cyc &amp;lt;= 1&#39;b1;
		o_wb_stb &amp;lt;= 1&#39;b1;
		o_cmd_busy   &amp;lt;= 1&#39;b1;
	end

	if (i_cmd_wr)
		o_wb_data &amp;lt;= i_cmd_word[31:0];
end else if (o_wb_stb)
begin
	newaddr &amp;lt;= 1&#39;b0;
	//
	// BUS REQUEST state
	//
	// In the state where we are commanding the bus, and waiting for
	// the bus request to be accepted
	//
	// o_wb_cyc will also be true here, since we cannot allow
	// o_wb_stb to be true if o_wb_cyc is not true.  (Too many
	// peripherals depend upon this bus simplification ...)
	//
	if (!i_wb_stall)
	begin
		// The request has been accepted, don&#39;t request again.
		o_wb_stb  &amp;lt;= 1&#39;b0;
		o_wb_addr &amp;lt;= o_wb_addr + inc;

		// If we get an ack on the same cycle as the request,
		// quietly transition back to idle.
		if (i_wb_ack)
		begin
			o_wb_cyc &amp;lt;= 1&#39;b0;
			o_rsp_stb &amp;lt;= 1&#39;b1;
			if (o_wb_we)
				o_rsp_word &amp;lt;= `RSP_WRITE_ACKNOWLEDGEMENT;
			else
				o_rsp_word &amp;lt;= { `RSP_SUB_DATA, i_wb_data };
		end
	end
end else if (o_wb_cyc)
begin
	newaddr &amp;lt;= 1&#39;b0;
	if (i_wb_ack)
	begin
		o_wb_cyc &amp;lt;= 1&#39;b0;
		o_cmd_busy &amp;lt;= 1&#39;b0;
		o_rsp_stb &amp;lt;= 1&#39;b1;
		if (o_wb_we)
			o_rsp_word &amp;lt;= `RSP_WRITE_ACKNOWLEDGEMENT;
		else
			o_rsp_word &amp;lt;= { `RSP_SUB_DATA, i_wb_data };
	end
end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;From this view, the three states of the controller should be readily
apparent.  The controller starts out idle, CYC=STB=0. 
Once the controller receives a command, it
moves to a bus request state to issue the command, CYC=STB=1.  Once the
command has been issued, but before any response, it is in a bus wait state
with CYC=1, STB=0.  When the final ACK comes back, we’ll go back to idle,
CYC=STB=0.&lt;/p&gt;

&lt;p&gt;That’s how a wishbone master works.&lt;/p&gt;

&lt;p&gt;When I first sketch out a design, it often looks very similar to this giant
always block above.  Perhaps it’s my software background.  I like to build
one big always block with all the parts and pieces within it.  Indeed, my
&lt;a href=&quot;http://opencores.org/project,qspiflash&quot;&gt;flash controller&lt;/a&gt; is still built in
this fashion, with one giant always block.&lt;/p&gt;

&lt;p&gt;Now that I’ve been doing this for a while, I’ve learned that breaking the
big always block up into little blocks is easier on the FPGA.  For example,
in this case, why should the address lines only get set when the new address
command shows up &lt;em&gt;and&lt;/em&gt; the reset is clear?&lt;/p&gt;

&lt;p&gt;For this reason, we’ll split up the always block into parts and pieces.&lt;/p&gt;

&lt;h3 id=&quot;the-cyc-and-stb-lines&quot;&gt;The CYC and STB Lines&lt;/h3&gt;

&lt;p&gt;The wishbone CYC and STB lines are so integrally connected, they
tend to remain together no matter how the interface gets broken up.  Indeed,
these two wires alone define which state we are in within our state space.
Further, in the big always block above, few lines actually depend upon
the reset line.  Hence, we’ll build their state diagram like this:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;initial	o_wb_cyc = 1&#39;b0;
initial	o_wb_stb = 1&#39;b0;
always @(posedge i_clk)
	if ((i_reset)||((i_wb_err)&amp;amp;&amp;amp;(o_wb_cyc)))
	begin
		// On any error or reset, then clear the bus.
		o_wb_cyc &amp;lt;= 1&#39;b0;
		o_wb_stb &amp;lt;= 1&#39;b0;
	end else if (o_wb_stb)
	begin
		//
		// BUS REQUEST state
		//
		if (!i_wb_stall)
			// If we are only going to do one transaction,
			// then as soon as the stall line is lowered, we are
			// done.
			o_wb_stb &amp;lt;= 1&#39;b0;

		// While not likely, it is possible that a slave might ACK
		// our request on the same clock it is received.  In that
		// case, drop the CYC line.
		//
		// We gate this with the stall line in case we receive an
		// ACK while our request has yet to go out.  This may make
		// more sense later, when we are sending multiple back to back
		// requests across the bus, but we&#39;ll leave this gate here
		// as a placeholder until then.
		if ((!i_wb_stall)&amp;amp;&amp;amp;(i_wb_ack))
			o_wb_cyc &amp;lt;= 1&#39;b0;
	end else if (o_wb_cyc)
	begin
		//
		// BUS WAIT
		//
		if (i_wb_ack)
			// Once the slave acknowledges our request, we are done.
			o_wb_cyc &amp;lt;= 1&#39;b0;
	end else begin
		//
		// IDLE state
		//
		if (i_cmd_bus)
		begin
			// We&#39;ve been asked to start a bus cycle from our
			// command word, either RD or WR
			o_wb_cyc &amp;lt;= 1&#39;b1;
			o_wb_stb &amp;lt;= 1&#39;b1;
		end
	end

	// For now, we&#39;ll use the bus cycle line as an indication of whether
	// or not we are too busy to accept anything else from the command
	// port.  This will change if we want to accept multiple write
	// commands per bus cycle, but that will be a bus master that&#39;s
	// not nearly so simple.
	assign	o_cmd_busy = o_wb_cyc;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h3 id=&quot;the-write-line&quot;&gt;The write line&lt;/h3&gt;
&lt;p&gt;We can significantly simplify the output bus write enable line.  Since we only
accept commands when we are in the idle state, and we only transition to
the bus request state on a read (or write) command, we can just simply leave
this as:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(posedge i_clk)
		if (!o_wb_cyc)
			o_wb_we &amp;lt;= (i_cmd_wr);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Notice how much we just simplified this.&lt;/p&gt;

&lt;p&gt;The consequence of this simplification (and the many others like it) is that
our code will be harder to read.
The positive: because this line now uses fewer FPGA resources, there will
be less logic between clocks, allowing you to (possibly) run your clock a 
touch faster, and there will be fewer LUTs used to generate this line, allowing
you to place more of what you care about onto your FPGA.&lt;/p&gt;

&lt;h3 id=&quot;the-address-lines&quot;&gt;The Address Lines&lt;/h3&gt;

&lt;p&gt;We remove the address lines from the big block simply because there’s no reason
why the address line logic needs to depend upon the reset line.  On reset, we
can allow the address (and the increment) to both come up undefined.  We’ll
also keep our own internal new address variable in this block as well.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	//
	// The bus ADDRESS lines
	//
	initial	newaddr = 1&#39;b0;
	always @(posedge i_clk)
	begin
		if ((i_cmd_addr)&amp;amp;&amp;amp;(!o_cmd_busy))
		begin
			// If we are in the idle state, we accept address
			// setting commands.  Specifically, we&#39;ll allow the
			// user to either set the address, or add a difference
			// to our address.  The difference may not make sense
			// now, but if we ever wish to compress our command bus,
			// sending an address difference can drastically cut
			// down the number of bits required in a set address
			// request.
			if (!i_cmd_word[1])
				o_wb_addr &amp;lt;= i_cmd_word[31:2];
			else
				o_wb_addr &amp;lt;= i_cmd_word[31:2] + o_wb_addr;

			//
			// We&#39;ll allow that bus requests can either increment
			// the address, or leave it the same.  One bit in the
			// command word will tell us which, and we&#39;ll set this
			// bit on any set address command.
			inc &amp;lt;= !i_cmd_word[0];
		end else if ((o_wb_stb)&amp;amp;&amp;amp;(!i_wb_stall))
			// The address lines are used while the bus is active,
			// and referenced any time STB &amp;amp;&amp;amp; !STALL are true.
			//
			// However, once STB and !STALL are both true, then the
			// bus is ready to move to the next request.  Hence,
			// we add our increment (one or zero) here.
			o_wb_addr &amp;lt;= o_wb_addr + , inc};


		// We&#39;d like to respond to the bus with any address we just
		// set.  The goal here is that, upon any read from the bus,
		// we should be able to know what address the bus was set to.
		// For this reason, we want to return the bus address up the
		// command stream.
		//
		// The problem is that the add (above) when setting the address
		// takes a clock to do.  Hence, we&#39;ll use &quot;newaddr&quot; as a flag
		// that o_wb_addr has a new value in it that needs to be
		// returned via the command link.
		newaddr &amp;lt;= ((i_cmd_addr)&amp;amp;&amp;amp;(!o_cmd_busy));
	end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h3 id=&quot;the-output-data-lines&quot;&gt;The output data lines&lt;/h3&gt;

&lt;p&gt;Those output data lines can be set just like the write enable line.  Only,
this time, we don’t care what the lines are set to when we are reading.
Hence, we’ll set them upon any request.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(posedge i_clk)
	begin
		// This may look a touch confusing ... what&#39;s important is that:
		//
		// 1. No one cares what the bus data lines are, unless we are
		//	in the middle of a write cycle.
		// 2. Even during a write cycle, these lines are don&#39;t cares
		//	if the STB line is low, indicating no more requests
		// 3. When a request is received to write, and so we transition
		//	to a bus write cycle, that request will come with data.
		// 4. Hence, we set the data words in the IDLE state on the
		//	same clock we go to BUS REQUEST.  While in BUS REQUEST,
		//	these lines cannot change until the slave has accepted
		//	our inputs.
		//
		// Thus we force these lines to be constant any time STB and
		// STALL are both true, but set them otherwise.
		//
		if ((!o_wb_stb)||(!i_wb_stall))
			o_wb_data &amp;lt;= i_cmd_word[31:0];
	end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Since we are setting 32 outputs, the logic savings is much greater than the
savings from simplifying just the one &lt;strong&gt;o_wb_we&lt;/strong&gt; line.&lt;/p&gt;

&lt;h3 id=&quot;the-output-result&quot;&gt;The output result&lt;/h3&gt;

&lt;p&gt;We also need to return a result back up the command chain.  This result will
be dependent upon what has taken place.  It could be:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;An acknowledgement of a bus reset request&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;A notification of a bus error&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;An acknowledgement of a new address, or a value that has been written&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Or (finally) the result of any data  read from the bus.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Because of all of these possibilities, it takes a bit of logic to set this
right.  Remember, &lt;strong&gt;o_rsp_stb&lt;/strong&gt; will be true any time &lt;strong&gt;o_rsp_word&lt;/strong&gt; has valid
information, and that the &lt;strong&gt;o_rsp_word&lt;/strong&gt; wires are don’t cares any time
&lt;strong&gt;o_rsp_stb&lt;/strong&gt; is low.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	if (i_reset)
	begin
		o_rsp_stb &amp;lt;= 1&#39;b1;
		o_rsp_word &amp;lt;= `RSP_RESET;
	end else if (i_wb_err)
	begin
		o_rsp_stb &amp;lt;= 1&#39;b1;
		o_rsp_word &amp;lt;= `RSP_BUS_ERROR;
	end else if (o_wb_cyc) begin
		//
		// We&#39;re either in the BUS REQUEST or BUS WAIT states
		//
		// Either way, we want to return a response on our command
		// channel if anything gets ack&#39;d
		o_rsp_stb &amp;lt;= (i_wb_ack);
		//
		//
		if (o_wb_we)
			o_rsp_word &amp;lt;= `RSP_WRITE_ACKNOWLEDGEMENT;
		else
			o_rsp_word &amp;lt;= { `RSP_SUB_DATA, i_wb_data };
	end else begin
		//
		// We are in the IDLE state.
		//
		// Echo any new addresses back up the command chain
		//
		o_rsp_stb  &amp;lt;= newaddr;
		o_rsp_word &amp;lt;= { `RSP_SUB_ADDR, o_wb_addr, 1&#39;b0, !inc };
	end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h2 id=&quot;a-not-so-simplified-wishbone-master&quot;&gt;A Not-So Simplified Wishbone Master&lt;/h2&gt;

&lt;p&gt;If you’ve along so far, you may notice we’ve left a lot of capabilities
we want in our bus master on the floor:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;There’s no means for sending multiple write commands without dropping CYC
between them.  This will break our flash controller, so we’ll have to come
back and fix this.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;There’s no means for reading from (or writing to) multiple consecutive
addresses in one
transaction.  That’s really useful for getting us on and off the bus
quickly.  We’ll need to come back to this later.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;There are a lot of times when the bits in our 34-bit codeword are going
unused.  For example, why transmit 34-bits to our device just to send
a reset, when only six of those 34 bits are ever used to decode a reset?
Why send a 30’bit address offset, when you are just adding it to the current
address?&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;If we want a really good wishbone master interface that’s fully featured,
we’ll need to come back and fix these things.  For now, let’s move on to the
next piece in our command wishbone bridge.&lt;/p&gt;

&lt;h2 id=&quot;examples&quot;&gt;Examples&lt;/h2&gt;

&lt;p&gt;Now that you know the basic pieces of any wishbone bus master, here’s a list
of some example wishbone bus master’s that I’ve built that you might find
worth referencing:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Instruction fetch: &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/prefetch.v&quot;&gt;one word at a
time&lt;/a&gt;,
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/dblfetch.v&quot;&gt;two at a
time&lt;/a&gt;, and
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/pfcache.v&quot;&gt;using a
cache&lt;/a&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;CPU memory stage: &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/memops.v&quot;&gt;one word at a time
time&lt;/a&gt;, and
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/pipemem.v&quot;&gt;pipelined&lt;/a&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;A &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/wbdmac.v&quot;&gt;direct memory access (DMA)
controller&lt;/a&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;A [similar UART-WB bridge](
(https://github.com/ZipCPU/zbasic/blob/master/rtl/wbuexec.v).&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;next-steps&quot;&gt;Next Steps&lt;/h2&gt;

&lt;p&gt;You can find prior posts in this series on the &lt;a href=&quot;/topics.html&quot;&gt;site
topics&lt;/a&gt; page.  You can also see from 
&lt;a href=&quot;/topics.html&quot;&gt;that page&lt;/a&gt; where I’m hoping to go next.&lt;/p&gt;

</description>
        <pubDate>Thu, 08 Jun 2017 00:00:00 -0400</pubDate>
        <link>http://zipcpu.com/blog/2017/06/08/simple-wb-master.html</link>
        <guid isPermaLink="true">http://zipcpu.com/blog/2017/06/08/simple-wb-master.html</guid>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>Building A Simple In-Circuit Logic Analyzer</title>
        <description>&lt;p&gt;If you’ve never built your own &lt;a href=&quot;https://en.wikipedia.org/wiki/Logic_analyzer&quot;&gt;logic
scope&lt;/a&gt; to “see” what’s going
on within an FPGA, it’s not really that hard to do.  There are a couple of
steps required to do it, but not really all that more.&lt;/p&gt;

&lt;p&gt;Over time, I’ve built several logic scopes–each for a different environment
that I’ve been running in.  Somewhere around rebuilding the wheel for the
third time, and for a different customer each time, I decided to build
my own–so that I could have a scope that I legally owned and controlled,
and that I could bring with me to any new FPGA job.&lt;/p&gt;

&lt;p&gt;Here in this post, we’ll walk through all the steps of building a basic
&lt;a href=&quot;https://en.wikipedia.org/wiki/Logic_analyzer&quot;&gt;logic scope&lt;/a&gt;.  We’ll reserve
until later how to go about turning this scope’s results into a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Value_change_dump&quot;&gt;VCD file&lt;/a&gt;
for &lt;a href=&quot;http://gtkwave.sourceforge.net&quot;&gt;GTKWave&lt;/a&gt; viewing–but only because I was
using the scope successfully for many years before I ever even discovered
&lt;a href=&quot;http://gtkwave.sourceforge.net&quot;&gt;GTKWave&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;how-it-works&quot;&gt;How it works&lt;/h2&gt;

&lt;p&gt;Before we get into the Verilog code necessary to build one of these things,
let’s discuss what we want it to do.&lt;/p&gt;

&lt;p&gt;We’d like three capabilities from our scope.  First, whenever something goes
wrong within our design, we’d like to be able to look back into the past and see
what happened, as in Fig. 1.&lt;/p&gt;

&lt;table align=&quot;center&quot;&gt;&lt;caption&gt;Fig. 1: Looking back into the past&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/scope-past.svg&quot; alt=&quot;A scope that looks back in time&quot; width=&quot;400&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Of course, this ability to look back in time will be limited by the size of our
scope’s memory.&lt;/p&gt;

&lt;p&gt;We’d also like the ability to debug an interaction that we are in the
process of designing.  For example, if you want to read from &lt;a href=&quot;http://opencores.org/project,qspiflash&quot;&gt;flash
memory&lt;/a&gt;,
it might be valid to look at the flash data lines together with some of your
internal &lt;a href=&quot;http://opencores.org/project,qspiflash&quot;&gt;flash control&lt;/a&gt; state.  In
this case, you would want to start capturing at the time of your read request. 
This capability would look something like Fig 2.&lt;/p&gt;

&lt;table align=&quot;center&quot;&gt;&lt;caption&gt;Fig. 2: After the trigger&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/scope-now.svg&quot; alt=&quot;Using a scope to see what&#39;s happening now&quot; width=&quot;400&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Continuing the our &lt;a href=&quot;http://opencores.org/project,qspiflash&quot;&gt;flash controller&lt;/a&gt;
example, what if you wanted to know what happened
when the flash finished its program or erase cycle?  You’d then want to know
what was happening some distance from your trigger, often a known amount of
time later in relation to the trigger.  In that case, what you want will look
something like Fig 3.&lt;/p&gt;

&lt;table align=&quot;center&quot;&gt;&lt;caption&gt;Fig. 3: A future event&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/scope-future.svg&quot; alt=&quot;Examining logic lines some time in the future&quot; width=&quot;400&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;We can handle all three of these needs by counting a programmable number
of clock cycles from the scope’s trigger until we stop recording (Fig 4.)&lt;/p&gt;

&lt;table align=&quot;center&quot;&gt;&lt;caption&gt;Fig. 4: Trigger Logic&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/scope-trigger.svg&quot; alt=&quot;How the holdoff works&quot; width=&quot;400&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;There remains one other feature we are going to need and that is that we will
need to ensure our memory is initialized before we ever stop recording.
In particular, you really don’t want to find yourself chasing some “bug” in
your design, something that doesn’t make any sense, only to find out later
that the data you were reading from the scope wasn’t valid.  For this
reason, we need make sure all of the scope’s memory is initialized before it can
be triggered.&lt;/p&gt;

&lt;p&gt;This leads to the rough timing diagram shown in Fig 5.&lt;/p&gt;

&lt;table&gt;&lt;caption&gt;Fig. 5: Scope timing&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/simple-scope.svg&quot; alt=&quot;The stages of a scope&#39;s capture&quot; width=&quot;800&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;In particular, following any scope reset, we’ll insist on setting all of the
values in memory before permitting the scope to be triggered.&lt;/p&gt;

&lt;p&gt;Okay, now that we know what we want to do, let’s look into how to do it.&lt;/p&gt;

&lt;h2 id=&quot;filling-the-scope&quot;&gt;Filling the scope&lt;/h2&gt;

&lt;p&gt;The first step to building a scope is to load your data into the scope.  There
are two parts to this.  The first is keeping track of the address you are
writing within your block RAM, and the second part is actually writing to that
memory.  Both parts are quite simple.&lt;/p&gt;

&lt;p&gt;We’ll use a register, &lt;strong&gt;waddr&lt;/strong&gt; to contain the address we wish to write to.
We’ll insist that this address start at zero only so we can tell if the
scope’s memory was ever fully initialized.  This address will quietly wrap
around the limits of the memory, whatever those limits might be, as we write.
We’ll also increment this address every time we receive a valid data sample
until the scope stops.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	if (i_reset)
		waddr &amp;lt;= 0;
	else if ((i_ce)&amp;amp;&amp;amp;(!stopped))
		waddr &amp;lt;= waddr + 1&#39;b1;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Writing to memory is even simpler: On any clock when we’ve got valid data,
we write to the scope’s memory–up until the point where we stop the scope.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	if ((i_ce)&amp;amp;&amp;amp;(!stopped))
		mem[waddr] &amp;lt;= i_data;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;If you’ve never used block RAM within an FPGA before, the various synthesis
tools can be finicky.  In general, if you have too much logic within the same
always block as the memory write, they won’t recognize the block RAM.  That’s
why we keep our memory write logic &lt;em&gt;simple&lt;/em&gt;.  (Ref
&lt;a href=&quot;https://www.xilinx.com/support/documentation/white_papers/wp231.pdf&quot;&gt;[1]&lt;/a&gt;)&lt;/p&gt;

&lt;p&gt;We also write to our memory on every clock up until we are stopped.  This is
how we guarantee that, when we get a trigger, we can have a valid capture of
whatever it was that lead up to the trigger.&lt;/p&gt;

&lt;p&gt;The final piece to our scope’s write logic is the detection of when the scope
was filled.  Since we started the write address at zero, we’ll know we have
filled the scope on the same clock that we both write to it, and write to it
with the address equal to all ones.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	if (i_reset)
		primed &amp;lt;= 1&#39;b0;
	else if ((i_ce)&amp;amp;&amp;amp;(!primed))
		primed &amp;lt;= &amp;amp;waddr;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;With this simple logic, you’ve now created your first
&lt;a href=&quot;https://en.wikipedia.org/wiki/Logic_analyzer&quot;&gt;scope&lt;/a&gt;.  Now let’s look
at how to stop it, and then how to get the results out of it.&lt;/p&gt;

&lt;h2 id=&quot;triggering-the-scope&quot;&gt;Triggering the scope&lt;/h2&gt;

&lt;p&gt;A quick examination of Fig. 4 above should make plain what we wish to do.&lt;/p&gt;

&lt;p&gt;First, from reset until we’ve been triggered, the scope runs and records
normally.  Once we receive a trigger, and only then, do we move on to the
next step.  Hence, we need to know when we’ve been triggered.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	if (i_reset)
		triggered &amp;lt;= 1&#39;b0;
	else if ((i_trigger)&amp;amp;&amp;amp;(primed))
		triggered &amp;lt;= 1&#39;b0;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;You might notice that this trigger doesn’t depend upon &lt;strong&gt;i_ce&lt;/strong&gt;, even though
all of the data reads and writes do.  This was done on purpose so that
any trigger that takes place between &lt;strong&gt;i_ce&lt;/strong&gt;’s will still get noticed by
the scope.&lt;/p&gt;

&lt;p&gt;The next step is to count some programmable number of clocks from the trigger
until we stop.  We’ll call this counter the &lt;strong&gt;holdoff_counter&lt;/strong&gt;, and
we’ll start it counting as soon as we are triggered.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_ck)
	if ((i_reset)||(!triggered))
		holdoff_counter &amp;lt;= 0;
	else if (i_ce)
		holdoff_counter &amp;lt;= holdoff_counter + 1&#39;b1;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Once the holdoff counter reaches the user holdoff, we then set a flag to
indicate we have stopped.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_ck)
	if ((i_reset)||(!triggered))
		stopped &amp;lt;= 0;
	else if ((i_ce)&amp;amp;&amp;amp;(!stopped))
		stopped &amp;lt;= (holdoff_counter &amp;gt;= user_holdoff);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The only tricky part about all of these controls is lining them all up so that
the last data sample is the sample that produced the trigger.  For now, we’ll
leave as an exercise for the student.&lt;/p&gt;

&lt;p&gt;The last step will be to read the results out of your local
&lt;a href=&quot;http://opencores.org/opencores,wishbone&quot;&gt;wishbone bus&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;reading-the-results&quot;&gt;Reading the results&lt;/h2&gt;

&lt;p&gt;When it comes to reading results, there are just a couple of tricks required. 
Most of these are involved with unwrapping the RAM memory, and the rest of
what is required is straight forward.&lt;/p&gt;

&lt;p&gt;Remember how we just wrote to successive memory locations until we stopped?
We’re going to need to unwrap all of that.&lt;/p&gt;

&lt;p&gt;The first step is to calculate the offset we need into the memory array.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	if (i_reset)
		raddr &amp;lt;= 0;
	else if ((i_wb_stb)&amp;amp;&amp;amp;(!i_wb_we)&amp;amp;&amp;amp;(i_wb_addr))
		raddr &amp;lt;= raddr + 1&#39;b1;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;We’ll then add this offset to the write address to get the address we need from
the scope’s memory.  The trick is that this operation has now taken an
extra clock.  If we want to support a throughput of one read per bus clock,
we’re going to need to add one extra unit to keep up with the bus clock.
In other words, we’ll pre-compute the next read address if we are in the middle
of a read, but otherwise have only the offset plus the last write address.&lt;/p&gt;

&lt;p&gt;Will this address calculation wrap around the end of the memory back to the
beginning?  Most definitely.  We are counting upon that.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	if ((i_wb_stb)&amp;amp;&amp;amp;(!i_wb_we)&amp;amp;&amp;amp;(i_wb_addr))
		this_addr &amp;lt;= raddr + waddr + 1&#39;b1;
	else
		this_addr &amp;lt;= raddr + waddr;
end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Now that we have our read address, referenced from the beginning of memory
rather than from the beginning of of the capture we are reporting, we can
now read from the scope’s memory.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	data &amp;lt;= mem[this_addr];&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;As you examine this, remember that block RAM logic is special, whether read or
write–it must
fit the form of what the synthesizer is expecting, or the memory will be
implemented in logic instead of RAM.  It is for that reason that we keep our
memory read as simple as possible and don’t try to merge it with the
output case statement below.&lt;/p&gt;

&lt;p&gt;The final step is to place this value onto the bus.  We hold onto our address
for one clock, so that we can align our data read with the bus request, and
make certain that we are always returning the right value on the right clock.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	last_bus_addr &amp;lt;= i_wb_addr;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;We do the same thing for our acknowledgement line, delaying it for one clock,
to give us time to actually read from the bus.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	pre_ack &amp;lt;= i_wb_stb;
always @(posedge i_clk)
	o_wb_ack &amp;lt;= pre_ack;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Otherwise reading from this scope is just as simple as reading from any
address from any other simple peripheral.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	case(last_bus_addr)
	1&#39;b0: o_wb_data &amp;lt;= { 1&#39;b0, stopped, triggered, 1&#39;b0,
			3&#39;h0, LGMEMLEN, user_holdoff };

	1&#39;b1: o_wb_data &amp;lt;= data;
	endcase&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;That’s it!  There’s not all that much to it.  A scope requires writing to
memory, stopping based upon some trigger, and then reading the data back
out later.  You’ve now seen all of these pieces.&lt;/p&gt;

&lt;h2 id=&quot;zipcpus-wishbone-scope&quot;&gt;ZipCPU’s Wishbone Scope&lt;/h2&gt;

&lt;p&gt;Now that you know how one of these scopes works, and even better how to build
your own, you might wish to check out my own version of a &lt;a href=&quot;https://github.com/ZipCPU/wbscope&quot;&gt;wishbone
scope&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;There are a couple of differences between that my own &lt;a href=&quot;https://github.com/ZipCPU/wbscope&quot;&gt;wishbone
scope&lt;/a&gt;, name wbscope and found on GitHub,
and the scope we’ve just outlined above, although not that many.  Here’s a
quick list of differences:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/ZipCPU/wbscope&quot;&gt;wbscope&lt;/a&gt; allows you to use two
asynchronous clocks, if you need them: one for the data and another
for the bus.&lt;/p&gt;

    &lt;p&gt;I needed this capability when testing the &lt;a href=&quot;https://github.com/ZipCPU/openarty/blob/master/rtl/enetpackets.v&quot;&gt;RMII ethernet
controller&lt;/a&gt;
within the &lt;a href=&quot;https://github.com/ZipCPU/openarty&quot;&gt;OpenArty project&lt;/a&gt; for the
&lt;a href=&quot;http://store.digilentinc.com/arty-artix-7-fpga-development-board-for-makers-and-hobbyists&quot;&gt;Arty board&lt;/a&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Data capture within our &lt;a href=&quot;https://github.com/ZipCPU/wbscope&quot;&gt;wishbone scope&lt;/a&gt;
has been carefully calibrated so that a hold off of zero will place the
trigger in exactly the last location in memory.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The &lt;a href=&quot;https://github.com/ZipCPU/wbscope&quot;&gt;wishbone scope&lt;/a&gt; in the repo adds
a couple extra bus directed capabilities.  These include&lt;/p&gt;

    &lt;p&gt;o an interrupt output for an on-board CPU,&lt;/p&gt;

    &lt;p&gt;o the ability to manually disable the scope’s trigger, or even&lt;/p&gt;

    &lt;p&gt;o the ability to manually trigger the scope from the bus independent of the
  trigger wired into the scope.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;I’ve also built a &lt;a href=&quot;https://github.com/ZipCPU/wbscope/blob/master/rtl/wbscopc.v&quot;&gt;compressed version of the
scope&lt;/a&gt; that
applies
&lt;a href=&quot;https://en.wikipedia.org/wiki/Run-length_encoding&quot;&gt;run length encoding&lt;/a&gt;
to the data, to allow recording events over a long period of time.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Further, there’s even a &lt;a href=&quot;https://github.com/ZipCPU/wbscope/blob/master/rtl/axi4lscope.v&quot;&gt;AXI-lite version of the
scope&lt;/a&gt;, although
since I don’t use the AXI bus, that version has not been tested very much–so
I can’t assure you that it works.&lt;/p&gt;

&lt;h2 id=&quot;next-steps&quot;&gt;Next Steps&lt;/h2&gt;

&lt;p&gt;We’ll still queue up for later how to actually create a
&lt;a href=&quot;http://opencores.org/opencores,wishbone&quot;&gt;wishbone bus master&lt;/a&gt; that can
be commanded from from a local host PC, as well as instructions for how to
turn these results into a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Value_change_dump&quot;&gt;VCD file&lt;/a&gt;
that you can view with &lt;a href=&quot;http://gtkwave.sourceforge.net&quot;&gt;GTKWave&lt;/a&gt;.&lt;/p&gt;

</description>
        <pubDate>Thu, 08 Jun 2017 00:00:00 -0400</pubDate>
        <link>http://zipcpu.com/blog/2017/06/08/simple-scope.html</link>
        <guid isPermaLink="true">http://zipcpu.com/blog/2017/06/08/simple-scope.html</guid>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>Nearest Neighbor Interpolation</title>
        <description>&lt;p&gt;One of the most common things any DSP implementation needs to do is
interpolation.  Here, let’s just discuss how to handle nearest neighbour
interpolation.&lt;/p&gt;

&lt;p&gt;Among all interpolants, the nearest neighbour interpolator is probably the
worst one you could use with respect to signal quality.  Better interpolators
exist: linear interpolation, quadratic interpolation, etc.  These all require
multiplies, careful attention to detail to avoid overflow, and more.  If you
want to build an interpolator, though, the nearest neighbour interpolator
is the place to start learning.&lt;/p&gt;

&lt;p&gt;As you read below, you’ll see why a nearest neighbour interpolator is the
simplest interpolator you could build.&lt;/p&gt;

&lt;h2 id=&quot;problem-setup&quot;&gt;Problem Setup&lt;/h2&gt;

&lt;p&gt;The first step to interpolation is to set up the problem properly.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Your input is an &lt;strong&gt;i_data&lt;/strong&gt; bus which will be valid any time &lt;strong&gt;i_stb&lt;/strong&gt;
is true.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Your output is an &lt;strong&gt;o_data&lt;/strong&gt; bus, together with an &lt;strong&gt;o_stb&lt;/strong&gt; qualifier.
Whenever the &lt;strong&gt;o_stb&lt;/strong&gt; line is true, the &lt;strong&gt;o_data&lt;/strong&gt; bus will have valid
data within it.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;generating-the-output-clock&quot;&gt;Generating the Output Clock&lt;/h2&gt;

&lt;p&gt;The next step is to handle your clock.  Here, you have two options.  You
can generate a &lt;a href=&quot;/blog/2017/06/02/generating-timing.html&quot;&gt;fractional
clock&lt;/a&gt; based upon
your system clock, or you could do the same based upon the input sampling clock.
The two options will look nearly identical.&lt;/p&gt;

&lt;p&gt;Here’s how you would generate your output timing based upon the system clock:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	{ o_stb, counter } &amp;lt;= counter + fractional_system_clock_divider;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;In this case, the &lt;strong&gt;fractional_system_clock_divider&lt;/strong&gt; is given by
two raised to the clock width, times the output clock rate you would like,
divided by the system clock rate.  The units of the two clock rates don’t
matter, just as long as they are consistent.&lt;/p&gt;

&lt;p&gt;And here’s how you would generate the output clock based upon the incoming
sample clock:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	if (i_stb)
		{ o_stb, counter } &amp;lt;= counter + fractional_sample_clock_divider;
	else
		o_stb &amp;lt;= 1&#39;b0;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;In this case, the clock is set nearly identically, but the fractional divider
is instead calculated with respect to the input clock rate, rather than the
output clock rate.&lt;/p&gt;

&lt;h2 id=&quot;handling-the-data-signals&quot;&gt;Handling the Data Signals&lt;/h2&gt;

&lt;p&gt;On every input clock, we create a copy of the data.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	if (i_stb)
		neighbour &amp;lt;= i_data;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;On every output clock, we copy that data to the output.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	if (o_stb)
		o_data &amp;lt;= neighbour;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Might the incoming data change multiple times between the incoming sample and
the outgoing sample?  Yes.  Won’t this cause a problem?  Yes it will.  The
problem this would create is called
&lt;a href=&quot;https://en.wikipedia.org/wiki/Aliasing&quot;&gt;aliasing&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;You can solve the aliasing problem by filtering your input signal before
it comes into the resampler.&lt;/p&gt;

&lt;h2 id=&quot;does-anyone-really-use-this&quot;&gt;Does anyone really use this?&lt;/h2&gt;

&lt;p&gt;Nearest neighbour interpolators have a lot of problems.  It’s not hard to
find or see these problems.  If they are so poor, are they ever used?&lt;/p&gt;

&lt;p&gt;Yes.&lt;/p&gt;

&lt;p&gt;Have I ever used one?&lt;/p&gt;

&lt;p&gt;Yes.&lt;/p&gt;

&lt;p&gt;I used a nearest neighbour interpolator once when I needed to resample a signal
with an 1024/1023 resampler.  To make it work, though, I first insisted that the
signal was oversampled (8x in my case) at the output of the anti-aliasing
filter.  When I later compared the result with a linear interpolator,
the nearest neighbour interpolator worked “good enough” for my application, and
so I dropped the linear interpolator alternative for this simpler one.&lt;/p&gt;

&lt;p&gt;The other place you may see this getting used is in a waveform transmitter
when the input clock is just slower than the output clock.  In this case,
if a new sample isn’t presented to the transmitter by the next sample clock,
the last sample can be repeated.  You can see this approach used in both the
&lt;a href=&quot;https://github.com/ZipCPU/wbpwmaudio/blob/master/rtl/wbpwmaudio.v&quot;&gt;PWM audio&lt;/a&gt;,
and the &lt;a href=&quot;https://github.com/ZipCPU/wbfmtx/blob/master/rtl/wbfmtxhack.v&quot;&gt;FM transmitter
(hack)&lt;/a&gt;
controllers I’ve put together.&lt;/p&gt;

&lt;h2 id=&quot;for-further-study&quot;&gt;For Further Study&lt;/h2&gt;

&lt;p&gt;If you are interested in knowing more about interpolation, you can find a
document describing how to do arbitrary digital interpolation
&lt;a href=&quot;https://github.com/ZipCPU/interpolation/blob/master/interpolation.pdf&quot;&gt;here&lt;/a&gt;.
In this blog, we’ll focus not on the generics of interpolation, but rather on
how to build an interpolator.&lt;/p&gt;

</description>
        <pubDate>Tue, 06 Jun 2017 00:00:00 -0400</pubDate>
        <link>http://zipcpu.com/dsp/2017/06/06/simple-interpolator.html</link>
        <guid isPermaLink="true">http://zipcpu.com/dsp/2017/06/06/simple-interpolator.html</guid>
        
        
        <category>dsp</category>
        
      </item>
    
      <item>
        <title>An Overview of a Wishbone-UART Bridge</title>
        <description>&lt;p&gt;I’ve now tried to write about how to convert a UART stream to a wishbone master
several times over, and … each time the result has been too complex to
explain within a simple blog post.&lt;/p&gt;

&lt;p&gt;So, in good engineering fashion, let’s decompose the problem.  Instead of
presenting an entire wishbone controller, let me instead present you with an
overview of the RTL side of a &lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/rtl/wbubus.v&quot;&gt;working UART to wishbone
bridge&lt;/a&gt; that I’ve
now used for many of my projects.  When we build a new/simpler on this blog,
we’ll need to include many of these design elements, so it’s worth taking a
look at.&lt;/p&gt;

&lt;p&gt;You can see an outline overview of the parts and pieces I’ve used before
in Fig. 1.&lt;/p&gt;

&lt;table style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 1: WB-UART Overview&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/wb-uart-ovw.svg&quot; alt=&quot;Block Diagram of a Working Wishbone to UART converter&quot; width=&quot;240&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;h2 id=&quot;the-transport-end&quot;&gt;The Transport End&lt;/h2&gt;

&lt;p&gt;At the top of this figure are the receiver and transmitter. In this design, the
transport layer is a generic 8-bit interface.&lt;/p&gt;

&lt;p&gt;Because the transport layer is so generic, it can be provided by either a
&lt;a href=&quot;https://github.com/ZipCPU/openarty/blob/master/rtl/toplevel.v&quot;&gt;serial port&lt;/a&gt;,
&lt;a href=&quot;https://github.com/ZipCPU/xulalx25soc/blob/master/rtl/jtagser.v&quot;&gt;JTAG port&lt;/a&gt;,
or even a &lt;a href=&quot;https://store.digilentinc.com&quot;&gt;Digilent&lt;/a&gt; DEPP channel, such as the
&lt;a href=&quot;https://github.com/ZipCPU/s6soc/blob/master/rtl/deppbyte.v&quot;&gt;S6SoC&lt;/a&gt; uses.
Indeed, even my work on the &lt;a href=&quot;https://github.com/ZipCPU/icozip/blob/master/rtl/pptest/pport.v&quot;&gt;ICO
board&lt;/a&gt; will
use a fairly generic 8-bit parallel port interface.&lt;/p&gt;

&lt;p&gt;There’s one additional requirement to this interface, necessary when the
interface runs over something similar to a SPI port: there must be an idle
character.  That way when a character &lt;em&gt;must&lt;/em&gt; be sent, such as when the SPI port
must transmit in order to receive, the idle character can be sent.  To date,
I’ve used an 8’hff for this purpose–but only if I’ve needed it.  That
character can be generated by the transmitter, or quietly dropped in the
receiver.&lt;/p&gt;

&lt;h2 id=&quot;the-bus-master-end&quot;&gt;The Bus Master End&lt;/h2&gt;

&lt;p&gt;On the other end of the UART to wishbone bridge is the &lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/rtl/wbuexec.v&quot;&gt;wishbone bus
master&lt;/a&gt; that
commands the entire bus interface to the chip.  Any peripheral can be hung off
of such a bus:
&lt;a href=&quot;http://opencores.org/project,qspiflash&quot;&gt;flash&lt;/a&gt;,
&lt;a href=&quot;https://github.com/ZipCPU/xulalx25soc/blob/master/rtl/wbsdram.v&quot;&gt;SDRAM&lt;/a&gt;,
&lt;a href=&quot;https://github.com/ZipCPU/wb2axip&quot;&gt;an AXI bus&lt;/a&gt;,
&lt;a href=&quot;https://github.com/ZipCPU/openarty/blob/master/rtl/enetpackets.v&quot;&gt;network interface&lt;/a&gt;,
an LED/switch/button interface,
&lt;a href=&quot;https://github.com/ZipCPU/rtcclock&quot;&gt;real–time clock&lt;/a&gt;,
GPIO,
&lt;a href=&quot;https://github.com/ZipCPU/openarty/blob/master/rtl/wboled.v&quot;&gt;OLEDRgb controller&lt;/a&gt;,
&lt;a href=&quot;https://github.com/ZipCPU/wbuart32/blob/master/rtl/wbuart.v&quot;&gt;UART controller&lt;/a&gt;,
PS/2 mouse controller, and more.&lt;/p&gt;

&lt;p&gt;In this case, the bus master accepts commands in the form of 36-bit words. 
These 36-bit words specify to the bus:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;What address to use (one word),&lt;/li&gt;
  &lt;li&gt;Whether to write one word,&lt;/li&gt;
  &lt;li&gt;Whether to stop writing, or&lt;/li&gt;
  &lt;li&gt;Whether to read multiple words.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The read/write commands also include a bit indicating whether the address
should increment between bus accesses, or whether all of the accesses will
be to the same bus address.&lt;/p&gt;

&lt;p&gt;Three specific capabilities of that can be hung off of this bus are worth
mentioning.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;The first is the &lt;a href=&quot;http://opencores.org/project,qspiflash&quot;&gt;flash controller&lt;/a&gt;.
Because I can control the flash over
a &lt;a href=&quot;https://github.com/ZipCPU/wbuart32&quot;&gt;UART port&lt;/a&gt;, I can read, erase, and
program the flash.  That means that I can reconfigure the entire FPGA over
&lt;a href=&quot;https://github.com/ZipCPU/wbuart32&quot;&gt;UART&lt;/a&gt;.  Even better, if you connect
one of &lt;a href=&quot;https://github.com/ZipCPU/wbicapetwo&quot;&gt;Xilinx’s ICAPE2 interfaces to the
bus&lt;/a&gt;,
you can then load and reload the FPGA’s configuration–without JTAG access.&lt;/p&gt;

    &lt;p&gt;The flash interface itself creates a unique requirement of this bus:  When
writing to the flash, the flash controller uses the end of the wishbone
cycle (CYC line goes low) as the signal to start programming the flash.  For
this reason, when writing a series of values, we cannot drop the wishbone
cycle line (CYC) until the last value is written.  Dropping the CYC line is
then the indication to the flash chip that it can start programming.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Since I’ve spent much of my time building a
   &lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;CPU&lt;/a&gt;, I’m particularly interested in
   being able to start, step, halt, and reboot the
   &lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;CPU&lt;/a&gt; from a debug port controlled by
   this interface.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Finally, for the purposes of this blog, this wishbone interface is useful
because you can now control a 
&lt;a href=&quot;https://github.com/ZipCPU/wbscope&quot;&gt;Wishbone Scope&lt;/a&gt;, whether it be a
&lt;a href=&quot;https://github.com/ZipCPU/wbscope/blob/master/rtl/wbscope.v&quot;&gt;traditional
scope&lt;/a&gt; or an
&lt;a href=&quot;https://github.com/ZipCPU/wbscope/blob/master/rtl/wbscopc.v&quot;&gt;RLE compressed
scope&lt;/a&gt; which
you can then use to debug any other part of your design.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;That’s how powerful the wishbone bus master is.&lt;/p&gt;

&lt;h2 id=&quot;characters-to-bits&quot;&gt;Characters to Bits&lt;/h2&gt;

&lt;p&gt;Since this was my first interface (although now in its 3rd generation), I
needed to be able to read what was going
on.  To accomplish this, I insisted that the interface run over printable
ASCII characters: 0-9, A-Z, a-z, @ and %.  The result is that, if necessary,
I can read the interface by eye and understand what is being sent–although
it does require a (not so secret) decoder ring to do it.&lt;/p&gt;

&lt;p&gt;Newlines are treated as out of band characters, and used to end writes that may
currently be in progress.  This keeps us from using a 6-bit interface.&lt;/p&gt;

&lt;p&gt;Hence, the first level beneath the transport layer
&lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/rtl/wbutohex.v&quot;&gt;converts printable ASCII into 6-bit
words&lt;/a&gt;
and &lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/rtl/wbusixchar.v&quot;&gt;back again&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;This also slows down the speed of the transport, since the transport
layer can handle 8-bit bytes and we’re only using six of those 8-bit bytes.&lt;/p&gt;

&lt;p&gt;Perhaps we can build a better one on this blog as time progresses?&lt;/p&gt;

&lt;h2 id=&quot;assembling-into-lines&quot;&gt;Assembling into lines&lt;/h2&gt;

&lt;p&gt;While perhaps not required, the interface does &lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/rtl/wbucompactlines.v&quot;&gt;assemble responses into
lines&lt;/a&gt;.
To do this, it inserts line breaks at the end of any response, or any time the
line would otherwise overflow.&lt;/p&gt;

&lt;p&gt;From a user’s standpoint, this makes it a lot easier to synchronize your eyes
to the beginning of commands and responses–especially when/if you need to
debug this interface.&lt;/p&gt;

&lt;h2 id=&quot;packing-bytes-into-words&quot;&gt;Packing Bytes into Words&lt;/h2&gt;

&lt;p&gt;Any wishbone bus command requires first knowing whether you wish to read or
write, a bus address, and possible a 32-bit data word.&lt;/p&gt;

&lt;p&gt;To do all of these things, you need to be able to assemble 8-bit bytes into
words that are at least 32-bits in length.  That length is the minimum to hold
a 32-bit data word that you wish to write, but by itself it’s not enough.  The
interface must also be able to indicate the type of transaction that is being
requested.&lt;/p&gt;

&lt;p&gt;In the example we’ve been following, we &lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/rtl/wbureadcw.v&quot;&gt;convert six 6-bit characters into a
36-bit word&lt;/a&gt; and
&lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/rtl/wbudeword.v&quot;&gt;back again&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;While 36-bits works, it may be overkill for what we need.  Perhaps we can
drop this down to a 35-bit word?&lt;/p&gt;

&lt;h2 id=&quot;compression&quot;&gt;Compression&lt;/h2&gt;

&lt;p&gt;UARTs are slow.  Reading an FPGA’s configuration from a flash, so you know
whether or not it needs to be reflashed, over a slow UART link can be &lt;em&gt;painful&lt;/em&gt;.
To speed things up, I added compression to this example bridge.
For reading and writing, we use a simple compression scheme based upon a
table of the most recently sent values.  Addresses get compressed based
upon either the difference between them and the last address, or perhaps just
the low order bits of the address might be sent.&lt;/p&gt;

&lt;p&gt;You can see the table look up and address decoding logic within the
&lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/wbudecompress.v&quot;&gt;decompression
module&lt;/a&gt;, or the
logic to see if a codeword to be sent can be found within
a table lookup
&lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/wbucompress.v&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;resets-and-interrupts&quot;&gt;Resets and Interrupts&lt;/h2&gt;

&lt;p&gt;As a final step, the bus interface needs to handle a couple extra pieces:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;When the bus is idle, the interface should send something periodically so that  you know the FPGA is active on the other end.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;If ever an interrupt occurs, you want that information inserted into the
data stream&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;This logic is captured in the &lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/wbuidleint.v&quot;&gt;idle-int
module&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Finally, you need some form of fault tolerance, so that if a peripheral
doesn’t respond to the bus, the bus can detect that fact, reset the bus,
and return an error across the channel.  We use the same error code for a bus
time out as any generic bus error coming from the bus itself, although
we can usually tell the difference between them.&lt;/p&gt;

&lt;p&gt;This watchdog capability is handled in the &lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/wbubus.v&quot;&gt;top
level&lt;/a&gt; of the UART
to wishbone bridge.&lt;/p&gt;

&lt;h2 id=&quot;performance&quot;&gt;Performance&lt;/h2&gt;

&lt;p&gt;Since this bus communicates reads and writes of 32–bit words packed into
six 8-bit bytes and transmitted over an 8-bit channel, it takes 60 UART baud
cycles (8N1 encoding) to write one word across the bus (ignoring compression).&lt;/p&gt;

&lt;p&gt;If you switch to 7N1 encoding, you can increase your speed by about 10%,
since we were only ever using 7-bits of an 8-bit interface.&lt;/p&gt;

&lt;p&gt;Stick with us and we’ll try to beat this number.  Specifically, if we abandon a
6-bits within 8-bit interface and switch to a full 8-bit interface, we should
be able to get down to about 46 baud per word–a 30% speed increase.&lt;/p&gt;

&lt;p&gt;On the other hand, if we wish to multiplex a console port onto the channel,
we may need to stick with a 7-bit interface.  In that case, perhaps we can
use all seven bits, instead of only 65 of the 128 values?&lt;/p&gt;

&lt;h2 id=&quot;not-shown&quot;&gt;Not Shown&lt;/h2&gt;

&lt;p&gt;What isn’t shown in this diagram is the structure of the &lt;a href=&quot;https://github.com/ZipCPU/openarty/blob/master/sw/host/ttybus.cpp&quot;&gt;C++
software&lt;/a&gt;
necessary to encode and decode words to send across this bus.&lt;/p&gt;

&lt;p&gt;Still, if we can keep the interface to any redesigned bus as simple as the
&lt;a href=&quot;https://github.com/ZipCPU/openarty/blob/master/sw/host/devbus.h&quot;&gt;devbus
interface&lt;/a&gt;
that all of our interface software uses, then any software we’ve already
written to use that interface will need to be relinked with the new interface
library, but no other changes will be required.&lt;/p&gt;

&lt;h2 id=&quot;a-minimal-interface&quot;&gt;A minimal interface&lt;/h2&gt;

&lt;p&gt;On this blog, we’re going to rebuild this interface.  Our goal will be to
design it in a manner so simple that any college student can build one.
This may mean that we throw out any unused or unnecessary parts and pieces.
We’ll also see if we can’t get our newer, better interface to run faster
than this current one.&lt;/p&gt;

&lt;p&gt;The result should be a simpler WB to UART bridge, such as the one shown in
Fig 2.&lt;/p&gt;

&lt;table style=&quot;float: left&quot;&gt;&lt;caption&gt;Fig 2: WB-UART Simplified&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/wb-uart-smpl.svg&quot; alt=&quot;Block Diagram of a Simpler Wishbone to UART converter&quot; width=&quot;360&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Before we can build one of these, though, we’re going to need to spend some
time learning how to build a wishbone bus master — similar to the &lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/rtl/wbuexec.v&quot;&gt;last
one&lt;/a&gt;,
but simpler.  Simple enough that it can be understood by the student,
and simple enough that it requires very few hardware resources.  That lesson
will then inform the rest our work redesigning the interface itself.&lt;/p&gt;
</description>
        <pubDate>Mon, 05 Jun 2017 00:00:00 -0400</pubDate>
        <link>http://zipcpu.com/blog/2017/06/05/wb-bridge-overview.html</link>
        <guid isPermaLink="true">http://zipcpu.com/blog/2017/06/05/wb-bridge-overview.html</guid>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>Campus Sidewalks and FPGA Design</title>
        <description>&lt;p&gt;I once heard a fascinating answer to the question of where to place sidewalks
on campus after building a new building: Wait a year first.  After a year of
using the new building, the students and faculty will have created paths
to and from your new building.  These dirt paths then tell you where to
build your official sidewalks.&lt;/p&gt;

&lt;p&gt;This has been my experience with the &lt;a href=&quot;https://github.com/ZipCPU/wbscope/blob/master/rtl/wbscopc.v&quot;&gt;compressed wishbone
scope&lt;/a&gt; I built
years ago.&lt;/p&gt;

&lt;p&gt;The &lt;a href=&quot;https://github.com/ZipCPU/wbscope/blob/master/rtl/wbscopc.v&quot;&gt;compressed 
scope&lt;/a&gt;
wasn’t my first bus scope.  The &lt;a href=&quot;https://github.com/ZipCPU/wbscope/blob/master/rtl/wbscope.v&quot;&gt;first
scope&lt;/a&gt; was more of
a traditional scope that captured every sample based upon a trigger.  It’s
designed to be a slave on a &lt;a href=&quot;http://opencores.org/opencores,wishbone&quot;&gt;wishbone
bus&lt;/a&gt;, and so it fits nicely as a
component of a design.&lt;/p&gt;

&lt;p&gt;With just a touch of logic, it wasn’t very hard to add a &lt;a href=&quot;https://en.wikipedia.org/wiki/Run-length_encoding&quot;&gt;run-length
compression&lt;/a&gt;
feature to the front end of the &lt;a href=&quot;https://github.com/ZipCPU/wbscope/blob/master/rtl/wbscope.v&quot;&gt;traditional
scope&lt;/a&gt;.
Although this worked okay, it didn’t handle the trigger properly.  I
ignored this problem, and used the compressed scope anyway.&lt;/p&gt;

&lt;p&gt;I used it to debug a &lt;a href=&quot;http://store.digilentinc.com/pmod-gps-gps-receiver/&quot;&gt;GPS
interface&lt;/a&gt;, looking
for where the PPS signal took place with respect to the UART NMEA stream.&lt;/p&gt;

&lt;p&gt;I used it to debug a &lt;a href=&quot;http://opencores.org/opencores,wishbone&quot;&gt;wishbone bus&lt;/a&gt;,
so I could skip the idle times or even times when the slave I was debugging
wasn’t selected.&lt;/p&gt;

&lt;p&gt;More recently, I used it to debug the &lt;a href=&quot;https://github.com/ZipCPU/wbi2c&quot;&gt;I2C
portion&lt;/a&gt; of an HDMI interface.&lt;/p&gt;

&lt;p&gt;In all of these, the
&lt;a href=&quot;https://github.com/ZipCPU/wbscope/blob/master/rtl/wbscopc.v&quot;&gt;compressed scope&lt;/a&gt;
proved its worth particularly for slow
interfaces where the scope would allow longer snapshots than could fit in block
memory.  Indeed, I’m not sure I could have debugged these interfaces without a
&lt;a href=&quot;https://github.com/ZipCPU/wbscope/blob/master/rtl/wbscopc.v&quot;&gt;compressed scope&lt;/a&gt;.
But, now that I’ve done so, I’ve learned enough to go
back and add in some necessary features.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;The &lt;a href=&quot;https://github.com/ZipCPU/wbscope/blob/master/rtl/wbscopc.v&quot;&gt;scope&lt;/a&gt;
needs to have a known trigger point.  Given the output stream,
and the holdoff you configured the scope with, you should be able to know
exactly where the trigger will be in that output stream.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;If nothing is changing, the
&lt;a href=&quot;https://github.com/ZipCPU/wbscope/blob/master/rtl/wbscopc.v&quot;&gt;scope&lt;/a&gt;
should have a maximum run length, so that
it doesn’t lock up and give you no information.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The last piece of memory within the
&lt;a href=&quot;https://github.com/ZipCPU/wbscope/blob/master/rtl/wbscopc.v&quot;&gt;scope&lt;/a&gt;’s
buffer must be a data point, even if it was part of a run.  It cannot be
left as part of a run.  This is a necessary part of knowing exactly where,
within the buffer, the trigger took place.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;As with the
&lt;a href=&quot;https://github.com/ZipCPU/wbscope/blob/master/rtl/wbscope.v&quot;&gt;regular scope&lt;/a&gt;,
the
&lt;a href=&quot;https://github.com/ZipCPU/wbscope/blob/master/rtl/wbscopc.v&quot;&gt;compressed scope&lt;/a&gt;
should have the option for working off of both a data clock and a bus clock.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Timing is important.  Working at high speed is valuable.  The debugger
(i.e. scope) must be able to keep up with your logic when your logic is at
high speed.  This means that all debug/scope logic should be broken up into
pieces small enough to run at the highest speed necessary.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Hence, I just laid my metaphorical sidewalks, and rebuilt the 
&lt;a href=&quot;https://github.com/ZipCPU/wbscope/blob/master/rtl/wbscopc.v&quot;&gt;compressed scope&lt;/a&gt;
according to my needs–now that I knew what they were.&lt;/p&gt;

&lt;p&gt;If you have a &lt;a href=&quot;http://opencores.org/opencores,wishbone&quot;&gt;wishbone bus&lt;/a&gt; within
your design, then feel free to try it out and let me know how (or if) it works
for you.&lt;/p&gt;

&lt;p&gt;If you don’t have a wishbone bus within your design, then &lt;a href=&quot;/topics.html&quot;&gt;stick
around&lt;/a&gt; and we’ll discuss how to build one.&lt;/p&gt;

</description>
        <pubDate>Sat, 03 Jun 2017 00:00:00 -0400</pubDate>
        <link>http://zipcpu.com/blog/2017/06/03/building-sidewalks.html</link>
        <guid isPermaLink="true">http://zipcpu.com/blog/2017/06/03/building-sidewalks.html</guid>
        
        
        <category>blog</category>
        
      </item>
    
  </channel>
</rss>
