<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>The ZipCPU by Gisselquist Technology</title>
    <description>The ZipCPU blog, featuring how to discussions of FPGA and soft-core CPU design.  This site will be focused on Verilog solutions, using exclusively OpenSource IP products for FPGA design.  Particular focus areas include topics often left out of more mainstream FPGA design courses such as how to debug an FPGA design.
</description>
    <link>https://zipcpu.com/</link>
    <atom:link href="https://zipcpu.com/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Tue, 03 Sep 2019 11:59:40 -0400</pubDate>
    <lastBuildDate>Tue, 03 Sep 2019 11:59:40 -0400</lastBuildDate>
    <generator>Jekyll v3.0.1</generator>
    <image>
      <url>https://zipcpu.com/img/gt-rss.png</url>
      <title></title>
      <link></link>
    </image>
    
      <item>
        <title>Quiz #5: Immediate vs Concurrent Assertions</title>
        <description>
</description>
        <pubDate>Sat, 31 Aug 2019 00:00:00 -0400</pubDate>
        <link>https://zipcpu.com/quiz/2019/08/31/quiz05.html</link>
        <guid isPermaLink="true">https://zipcpu.com/quiz/2019/08/31/quiz05.html</guid>
        
        
        <category>quiz</category>
        
      </item>
    
      <item>
        <title>Connecting lots of slaves to a bus without using a lot of logic</title>
        <description>&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 1. A Minimal Bus Implementation&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/bus-doubles/minimal-crossbar.svg&quot; alt=&quot;&quot; width=&quot;360&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;I’m not quite sure why, but most of the time when I examine a design on-line
that someone has posted to a forum, there are very few bus components.  There’s
typically a CPU (Microblaze, Nios2, or ARM), some kind of SDRAM memory, perhaps
a flash device, and then one or two other peripherals.  Perhaps these would be
an SD-card controller and an ethernet controller, as shown in Fig. 1.&lt;/p&gt;

&lt;p&gt;I’ve never quite understood this.  Many of my own designs will have those same
peripherals, but then perhaps another 25 more.  Why not create more peripherals
than just a few?&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 2. Adding more peripherals&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/bus-doubles/massive-crossbar.svg&quot; alt=&quot;&quot; width=&quot;720&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Perhaps I’m adding in the kitchen sink at this point, but why not?  If you can,
and if you have the peripheral and the space, why not add it into your design?
Maybe I’m just becoming a logic hoarder–I’ll add logic from every peripheral
I’ve ever worked on into a design and then more.  I’ll then even add lots
of &lt;a href=&quot;/blog/2017/06/08/simple-scope.html&quot;&gt;wishbone scopes&lt;/a&gt;
just to debug the whole.&lt;/p&gt;

&lt;p&gt;Large numbers of items on the bus has yet to become a crippling problem for
anything I’ve wanted to do.&lt;/p&gt;

&lt;p&gt;So why don’t I see block designs with even half as many components when browsing
&lt;a href=&quot;https://forums.xilinx.com&quot;&gt;Xilinx’s forums&lt;/a&gt;?&lt;/p&gt;

&lt;p&gt;My guess is that it costs most folks too much logic.&lt;/p&gt;

&lt;p&gt;To understand the issue, let’s just say that we want to connect four masters
(CPU instructions, CPU data, DMA, and &lt;a href=&quot;/blog/2017/06/16/dbg-bus-forest.html&quot;&gt;debugging
bus&lt;/a&gt;) to a bus
with 32 slave peripherals on it.  Just the
&lt;a href=&quot;/blog/2019/07/17/crossbar.html&quot;&gt;crossbar interconnect&lt;/a&gt;
alone, before adding any peripherals, would require 5,571 LUTs for a &lt;a href=&quot;https://github.com/ZipCPU/wb2axip/blob/master/rtl/wbxbar.v&quot;&gt;WB
interconnect&lt;/a&gt;,
and (gasp!) 10,341 LUTs for an &lt;a href=&quot;https://github.com/ZipCPU/wb2axip/blob/master/rtl/axixbar.v&quot;&gt;AXI
interconnect&lt;/a&gt;!
It doesn’t help that the size of the
&lt;a href=&quot;/blog/2019/07/17/crossbar.html&quot;&gt;crossbar&lt;/a&gt; goes up at a rate
faster than the product of the number of masters times the number of slaves.
Worse, these numbers say nothing of the difficulty associated with getting
such a massive design to pass timing for all the paths within such an behemoth
of a &lt;a href=&quot;/blog/2019/07/17/crossbar.html&quot;&gt;crossbar interconnect&lt;/a&gt;
either.&lt;/p&gt;

&lt;p&gt;Perhaps this is why I’ve never seen more than a couple of slaves in any
particular design: the
&lt;a href=&quot;/blog/2019/07/17/crossbar.html&quot;&gt;interconnect&lt;/a&gt;
alone might take nearly half the part, if not more!  (Depending upon your
FPGA size, of course.)&lt;/p&gt;

&lt;p&gt;This of course leads to the interesting question, how is it that I haven’t
suffered from this problem when adding 20+ peripherals to a design?&lt;/p&gt;

&lt;h2 id=&quot;the-two-simple-slaves&quot;&gt;The Two Simple Slaves&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;/zipcpu/2017/10/05/autofpga-intro.html&quot;&gt;AutoFPGA&lt;/a&gt;
simplifies this complex bus interconnect logic via the creation of two simpler
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;Wishbone&lt;/a&gt;
&lt;a href=&quot;/zipcpu/2017/05/29/simple-wishbone.html&quot;&gt;slave protocols&lt;/a&gt;.
I’ll call these sub-protocols, since for each of the simpler protocols the
&lt;a href=&quot;/zipcpu/2017/05/29/simple-wishbone.html&quot;&gt;slave&lt;/a&gt;
can still be &lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;Wishbone&lt;/a&gt;
compliant, it just has a couple of extra features.
The first sub-protocol is appropriate for a
&lt;a href=&quot;/zipcpu/2017/05/29/simple-wishbone.html&quot;&gt;slave&lt;/a&gt;
that consists of just a single register.  This register may always be read
immediately.  The second peripheral class takes a single clock cycle to return
the data of interest.
&lt;a href=&quot;/zipcpu/2017/10/05/autofpga-intro.html&quot;&gt;AutoFPGA&lt;/a&gt;
uses a slave type tag to describe these two sub-protocol classes.  The first
class would have a &lt;code class=&quot;highlighter-rouge&quot;&gt;@SLAVE.TYPE=SINGLE&lt;/code&gt; tag, and the second would be
&lt;code class=&quot;highlighter-rouge&quot;&gt;@SLAVE.TYPE=DOUBLE&lt;/code&gt;.
&lt;a href=&quot;/zipcpu/2017/10/05/autofpga-intro.html&quot;&gt;AutoFPGA&lt;/a&gt; would
then use this information to simplify how such a
&lt;a href=&quot;/zipcpu/2017/05/29/simple-wishbone.html&quot;&gt;slave&lt;/a&gt;
might connect to the &lt;a href=&quot;/blog/2017/06/22/simple-wb-interconnect.html&quot;&gt;automatically generated bus
structure&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Let’s take a look at each of these simplified protocol classes from a
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;Wishbone&lt;/a&gt;
standpoint, and then see how we might use this in an
&lt;a href=&quot;/blog/2019/01/12/demoaxilite.html&quot;&gt;AXI-lite&lt;/a&gt; or even from an
&lt;a href=&quot;/blog/2019/05/29/demoaxi.html&quot;&gt;AXI&lt;/a&gt; (full) standpoint.&lt;/p&gt;

&lt;p&gt;In &lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;Wishbone&lt;/a&gt;,
the &lt;code class=&quot;highlighter-rouge&quot;&gt;SINGLE&lt;/code&gt;
&lt;a href=&quot;/zipcpu/2017/05/29/simple-wishbone.html&quot;&gt;slave&lt;/a&gt;
type must have only a single register assigned to it.  It must never stall the
bus, and the register must always be available to be read.  It’s as though all
the internal logic were summarized as,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;&lt;span class=&quot;k&quot;&gt;always&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;begin&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;o_wb_ack&lt;/span&gt;   &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i_wb_stb&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;o_wb_stall&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mb&quot;&gt;1&#39;b0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;o_wb_data&lt;/span&gt;  &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;internal_register&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;o_wb_err&lt;/span&gt;   &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mb&quot;&gt;1&#39;b0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;always&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;posedge&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i_clk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i_wb_stb&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i_wb_we&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;begin&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i_wb_sel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;internal_register&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;31&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;24&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i_wb_data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;31&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;24&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i_wb_sel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;internal_register&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;23&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;16&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i_wb_data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;23&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;16&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i_wb_sel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;internal_register&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;15&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;8&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i_wb_data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;15&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;8&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i_wb_sel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;internal_register&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;7&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i_wb_data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;7&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;It’s really simple.  Now, what if the
&lt;a href=&quot;/blog/2019/07/17/crossbar.html&quot;&gt;interconnect&lt;/a&gt;
could just ignore &lt;code class=&quot;highlighter-rouge&quot;&gt;o_wb_stall&lt;/code&gt; (always zero), and &lt;code class=&quot;highlighter-rouge&quot;&gt;o_wb_ack&lt;/code&gt; (always
&lt;code class=&quot;highlighter-rouge&quot;&gt;i_wb_stb&lt;/code&gt;), set the &lt;code class=&quot;highlighter-rouge&quot;&gt;STB&lt;/code&gt; line (&lt;code class=&quot;highlighter-rouge&quot;&gt;i_wb_stb&lt;/code&gt;) dependent upon which
&lt;a href=&quot;/zipcpu/2017/05/29/simple-wishbone.html&quot;&gt;slave&lt;/a&gt;
it was talking to, and then use a big case statement based
upon the current address to determine the return value?&lt;/p&gt;

&lt;p&gt;The &lt;code class=&quot;highlighter-rouge&quot;&gt;DOUBLE&lt;/code&gt; type is very similar.  In this case, though, the &lt;code class=&quot;highlighter-rouge&quot;&gt;ACK&lt;/code&gt; line takes
another cycle to return.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;&lt;span class=&quot;c1&quot;&gt;// Delay the acknowledgement by one cycle, so we can accomplish our logic
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;initial&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;o_wb_ack&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mb&quot;&gt;1&#39;b0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;always&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;posedge&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i_clk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;o_wb_ack&lt;/span&gt;   &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i_wb_stb&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This extra cycle makes it possible to for the
&lt;a href=&quot;/zipcpu/2017/05/29/simple-wishbone.html&quot;&gt;slave&lt;/a&gt;
to select from among several possible internal registers you might wish
to return before returning the result.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;&lt;span class=&quot;k&quot;&gt;always&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;posedge&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i_clk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;case&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i_wb_addr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;o_wb_data&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;internal_register&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;31&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;o_wb_data&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;internal_register&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;31&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;o_wb_data&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;internal_register&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;31&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;o_wb_data&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;internal_register&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;31&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// ...
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;endcase&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This would again simplify the
&lt;a href=&quot;/blog/2019/07/17/crossbar.html&quot;&gt;interconnect&lt;/a&gt;,
since it would no longer need to wait for &lt;code class=&quot;highlighter-rouge&quot;&gt;!STALL&lt;/code&gt;, nor would it need
to check &lt;code class=&quot;highlighter-rouge&quot;&gt;ACK&lt;/code&gt; to know if the resulting data was valid.&lt;/p&gt;

&lt;p&gt;Because the logic for both &lt;code class=&quot;highlighter-rouge&quot;&gt;SINGLE&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;DOUBLE&lt;/code&gt;
&lt;a href=&quot;/zipcpu/2017/05/29/simple-wishbone.html&quot;&gt;slaves&lt;/a&gt;
is a &lt;em&gt;subset&lt;/em&gt; of the
full &lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;Wishbone&lt;/a&gt;
protocol, the
&lt;a href=&quot;/zipcpu/2017/05/29/simple-wishbone.html&quot;&gt;slave&lt;/a&gt;
can still be a valid
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;Wishbone&lt;/a&gt;
&lt;a href=&quot;/zipcpu/2017/05/29/simple-wishbone.html&quot;&gt;slave&lt;/a&gt;
in its own right, while also allowing for the
&lt;a href=&quot;/blog/2019/07/17/crossbar.html&quot;&gt;interconnect&lt;/a&gt;
to optimize its bus access.  This means that the
&lt;a href=&quot;/zipcpu/2017/05/29/simple-wishbone.html&quot;&gt;slave&lt;/a&gt;
should still work in a non-optimized
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;Wishbone&lt;/a&gt;
context as well as the optimized one, so you lose nothing there.&lt;/p&gt;

&lt;p&gt;I’ve now used this approach within
&lt;a href=&quot;/zipcpu/2017/10/05/autofpga-intro.html&quot;&gt;AutoFPGA&lt;/a&gt;
for some time with great success–but only for
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;Wishbone&lt;/a&gt; peripherals
so far, and only with a &lt;a href=&quot;/blog/2017/06/22/simple-wb-interconnect.html&quot;&gt;very simplified interconnect
structure&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The reason this has come to light is that I’m now
in the process of &lt;a href=&quot;/zipcpu/2019/08/22/tech-debt.html&quot;&gt;upgrading
AutoFPGA&lt;/a&gt;
to use a full
&lt;a href=&quot;/blog/2019/07/17/crossbar.html&quot;&gt;crossbar interconnect&lt;/a&gt;.
As part of this upgrade, I came across this little optimization and wondered if
I should keep it or throw it out.  I almost threw it out, but then got to
thinking some more about it.&lt;/p&gt;

&lt;p&gt;To see the impact, consider the design shown above in Fig. 2.  Had I collected
&lt;code class=&quot;highlighter-rouge&quot;&gt;SINGLE&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;DOUBLE&lt;/code&gt; slaves together for interconnect purposes, the design
might’ve been simplified to the one in Fig. 3 below.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 3. Creating slave groups by type, SINGLE and DOUBLE&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/bus-doubles/divided.svg&quot; alt=&quot;&quot; width=&quot;720&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;My current thought is, can or should this be done with
&lt;a href=&quot;/blog/2019/05/29/demoaxi.html&quot;&gt;AXI peripherals&lt;/a&gt;,
and if so how?&lt;/p&gt;

&lt;h2 id=&quot;simplifying-axi&quot;&gt;Simplifying AXI&lt;/h2&gt;

&lt;p&gt;So, if we were to totally simplify
&lt;a href=&quot;/blog/2019/05/29/demoaxi.html&quot;&gt;AXI&lt;/a&gt;
to create simpler slaves and to gather eliminate any common bus logic between
them together, how would we do it?&lt;/p&gt;

&lt;p&gt;Here’s my current working proposal:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;The interconnect guarantees that the core receives no back-pressure, leaving
&lt;code class=&quot;highlighter-rouge&quot;&gt;BREADY&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;RREADY&lt;/code&gt; both high.&lt;/p&gt;

    &lt;p&gt;This may require one (or more) &lt;a href=&quot;/blog/2019/05/22/skidbuffer.html&quot;&gt;skid
buffers&lt;/a&gt;, or perhaps
even small FIFOs within the interconnect, but this should still be quite
doable.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The slave can then guarantee that it will keep all of the slave generated
&lt;code class=&quot;highlighter-rouge&quot;&gt;*READY&lt;/code&gt; signals high as well: &lt;code class=&quot;highlighter-rouge&quot;&gt;AWREADY&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;WREADY&lt;/code&gt;, and &lt;code class=&quot;highlighter-rouge&quot;&gt;ARREADY&lt;/code&gt;.&lt;/p&gt;

    &lt;p&gt;Sorry, but this property will keep you from using many of &lt;a href=&quot;/formal/2019/05/13/axifull.html&quot;&gt;Xilinx’s
peripherals&lt;/a&gt;, since
they tend to idle with their &lt;code class=&quot;highlighter-rouge&quot;&gt;*READY&lt;/code&gt; signals low.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The interconnect guarantees that &lt;code class=&quot;highlighter-rouge&quot;&gt;AWVALID == WVALID&lt;/code&gt;.  This will save
the slave from the hassle of needing to implement incoming
&lt;a href=&quot;/blog/2019/05/22/skidbuffer.html&quot;&gt;skid buffers&lt;/a&gt;
just to synchronize these two signals.&lt;/p&gt;

    &lt;p&gt;Even better, if the slave logic is done right, the synthesis tool should
be able to remove the &lt;a href=&quot;/blog/2019/05/22/skidbuffer.html&quot;&gt;skid
buffer&lt;/a&gt; logic from an
otherwise fully &lt;a href=&quot;/blog/2019/05/29/demoaxi.html&quot;&gt;AXI&lt;/a&gt;
compliant core.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The slave can then guarantee that &lt;code class=&quot;highlighter-rouge&quot;&gt;BVALID == $past(AWVALID)&lt;/code&gt; and
&lt;code class=&quot;highlighter-rouge&quot;&gt;RVALID == $past(ARVALID)&lt;/code&gt; for &lt;code class=&quot;highlighter-rouge&quot;&gt;SINGLE&lt;/code&gt; peripherals.  For &lt;code class=&quot;highlighter-rouge&quot;&gt;DOUBLE&lt;/code&gt;
peripherals, the slave would guarantees that &lt;code class=&quot;highlighter-rouge&quot;&gt;BVALID == $past(AWVALID,2)&lt;/code&gt;
and &lt;code class=&quot;highlighter-rouge&quot;&gt;RVALID == $past(ARVALID,2)&lt;/code&gt;.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The neat thing about all of this is that these rules would work for
&lt;a href=&quot;/blog/2019/01/12/demoaxilite.html&quot;&gt;AXI-lite&lt;/a&gt; as well as for
&lt;a href=&quot;/blog/2019/05/29/demoaxi.html&quot;&gt;AXI&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;With just a little more work, we could guarantee the ability to connect
an &lt;a href=&quot;/blog/2019/01/12/demoaxilite.html&quot;&gt;AXI-lite&lt;/a&gt; slave to a
simplified &lt;a href=&quot;/blog/2019/05/29/demoaxi.html&quot;&gt;AXI&lt;/a&gt; interconnect
without the need for any further simplification logic.&lt;/p&gt;

&lt;p&gt;To do this using a fully
&lt;a href=&quot;/blog/2019/05/29/demoaxi.html&quot;&gt;AXI&lt;/a&gt;
capable slave, we’d need a couple other bus simplifying rules as well.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;The interconnect must guarantee that &lt;code class=&quot;highlighter-rouge&quot;&gt;AxLEN == 0&lt;/code&gt; any time &lt;code class=&quot;highlighter-rouge&quot;&gt;AxVALID&lt;/code&gt; is
true for both channels.&lt;/p&gt;

    &lt;p&gt;This means that the interconnect will need to break apart any bursts into
individual beats before they ever reach the slave.&lt;/p&gt;

    &lt;p&gt;This doesn’t mean that the interconnect will no longer support bursting
at a rate of one beat of the transfer per clock cycle, but rather that each
individual beat will be given its own address from the interconnect.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The interconnect would also then guarantees that &lt;code class=&quot;highlighter-rouge&quot;&gt;WLAST == 1&lt;/code&gt; any time
&lt;code class=&quot;highlighter-rouge&quot;&gt;WVALID&lt;/code&gt; is true.&lt;/p&gt;

    &lt;p&gt;This just follows from guaranteeing that &lt;code class=&quot;highlighter-rouge&quot;&gt;AxLEN == 0&lt;/code&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The interconnect guarantees that &lt;code class=&quot;highlighter-rouge&quot;&gt;AxID = 0&lt;/code&gt;, and then ignores &lt;code class=&quot;highlighter-rouge&quot;&gt;xID&lt;/code&gt; on the
return channel.&lt;/p&gt;

    &lt;p&gt;Yes, I understand that there are reasons for using the ID field–just not
in this simplified version of
&lt;a href=&quot;/blog/2019/05/29/demoaxi.html&quot;&gt;AXI&lt;/a&gt;.&lt;/p&gt;

    &lt;p&gt;Also, having a known response time from the slave makes the conversion
from &lt;a href=&quot;/blog/2019/05/29/demoaxi.html&quot;&gt;AXI&lt;/a&gt; to
&lt;a href=&quot;/blog/2019/01/12/demoaxilite.html&quot;&gt;AXI-lite&lt;/a&gt;
a lot easier–without requiring any loss in burst speed.  To see how
difficult the conversion can be, consider &lt;a href=&quot;https://github.com/ZipCPU/wb2axip/blob/master/rtl/axi2axilite.v&quot;&gt;this full speed
bridge&lt;/a&gt;
and notice the challenge of matching up the return ID with the requested
burst, as well generating &lt;code class=&quot;highlighter-rouge&quot;&gt;BVALID&lt;/code&gt; or even &lt;code class=&quot;highlighter-rouge&quot;&gt;RVALID &amp;amp; RLAST&lt;/code&gt; signals with
the end of the burst.  It wasn’t easy to do, certainly not while &lt;a href=&quot;/img/tweets/axi2axil-write-burst.svg&quot;&gt;maintaining
a high throughput&lt;/a&gt;,
and it was even harder to verify.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The interconnect guarantees that &lt;code class=&quot;highlighter-rouge&quot;&gt;AxSIZE = $clog(C_AXI_DATA_WIDTH)-3&lt;/code&gt;, and
then leaves it constant.&lt;/p&gt;

    &lt;p&gt;This also follows from setting &lt;code class=&quot;highlighter-rouge&quot;&gt;AxLEN == 0&lt;/code&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The slave ignores &lt;code class=&quot;highlighter-rouge&quot;&gt;AxBURST&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;AxCACHE&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;AxPROT&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;AxQOS&lt;/code&gt;, and
so on.  (The master guarantees these values are zero, in case the slave
doesn’t quite want to ignore them.)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The slave might still support &lt;code class=&quot;highlighter-rouge&quot;&gt;AxLOCK&lt;/code&gt; if desired, or ignore it if not.  I
haven’t decided if that would be useful or not.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Finally, if the interconnect does its job right, you wouldn’t lose any burst
support, but still be able to retire beats at a rate of one per clock.&lt;/p&gt;

&lt;p&gt;Indeed, the &lt;a href=&quot;/blog/2019/05/29/demoaxi.html&quot;&gt;AXI&lt;/a&gt;
slave logic might easily be simplified to something like the following for
the &lt;code class=&quot;highlighter-rouge&quot;&gt;SINGLE&lt;/code&gt; type peripheral:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;&lt;span class=&quot;c1&quot;&gt;//
// Simplified AXI (SINGLE) write logic
//
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;always&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;posedge&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;S_AXI_ACLK&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;S_AXI_AWVALID&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;begin&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;S_AXI_WSTRB&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;internal_register&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;31&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;24&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;S_AXI_WDATA&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;31&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;24&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;S_AXI_WSTRB&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;internal_register&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;23&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;16&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;S_AXI_WDATA&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;23&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;16&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;S_AXI_WSTRB&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;internal_register&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;15&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;8&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;S_AXI_WDATA&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;15&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;8&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;S_AXI_WSTRB&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;internal_register&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;7&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;S_AXI_WDATA&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;7&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;always&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;S_AXI_BRESP&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mb&quot;&gt;2&#39;b00&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;//
// Simplified AXI (SINGLE) read logic
//
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;always&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;S_AXI_RDATA&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;internal_register&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;always&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;S_AXI_RRESP&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mb&quot;&gt;2&#39;b00&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The &lt;code class=&quot;highlighter-rouge&quot;&gt;DOUBLE&lt;/code&gt; type peripheral logic would also be similarly simplified.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;&lt;span class=&quot;c1&quot;&gt;//
// Simplified AXI (DOUBLE) write logic
//
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;assign&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;wreg&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;S_AXI_AWADDR&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;C_AXI_ADDR_WIDTH&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;clog2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;C_AXI_DATA_WIDTH&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;always&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;posedge&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;S_AXI_ACLK&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;S_AXI_AWVALID&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;begin&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;S_AXI_WSTRB&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;internal_register&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;wreg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;31&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;24&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;S_AXI_WDATA&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;31&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;24&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;S_AXI_WSTRB&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;internal_register&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;wreg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;23&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;16&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;S_AXI_WDATA&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;23&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;16&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;S_AXI_WSTRB&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;internal_register&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;wreg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;15&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;8&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;S_AXI_WDATA&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;15&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;8&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;S_AXI_WSTRB&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;internal_register&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;wreg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;7&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;S_AXI_WDATA&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;7&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;//
// Simplified AXI (DOUBLE) read logic
//
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;assign&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;rreg&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;S_AXI_ARADDR&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;C_AXI_ADDR_WIDTH&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;clog2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;C_AXI_DATA_WIDTH&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;always&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;posedge&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;S_AXI_ACLK&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;case&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rreg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;o_wb_data&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;internal_register&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;31&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;o_wb_data&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;internal_register&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;31&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;o_wb_data&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;internal_register&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;31&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;o_wb_data&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;internal_register&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;31&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;//&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Yes, this eliminates a lot of the logic necessary to deal with the
&lt;a href=&quot;/blog/2019/05/29/demoaxi.html&quot;&gt;AXI&lt;/a&gt;
protocol.  All of that ugly logic would be aggregated into one &lt;code class=&quot;highlighter-rouge&quot;&gt;axisingle&lt;/code&gt;
or one &lt;code class=&quot;highlighter-rouge&quot;&gt;axidouble&lt;/code&gt; module that would then handle all of the full
&lt;a href=&quot;/blog/2019/05/29/demoaxi.html&quot;&gt;AXI&lt;/a&gt;
protocol interaction in order to create this simplified protocol.  You can see
an example of such an
&lt;a href=&quot;/blog/2019/01/12/demoaxilite.html&quot;&gt;AXI-lite&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/wb2axip/blob/master/rtl/axilsingle.v&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;axilsingle&lt;/code&gt; peripheral on
github&lt;/a&gt;,
should you be interested in how this might work.&lt;/p&gt;

&lt;p&gt;This approach allows the bus interconnect to simplify its logic drastically.
Instead of a 10k LUT
&lt;a href=&quot;/blog/2019/07/17/crossbar.html&quot;&gt;crossbar&lt;/a&gt;,
it should now be possible to connect the design together using a 3.4k LUT
&lt;a href=&quot;/blog/2019/07/17/crossbar.html&quot;&gt;crossbar&lt;/a&gt;,
Such a &lt;a href=&quot;/blog/2019/07/17/crossbar.html&quot;&gt;crossbar&lt;/a&gt;
might support 4 masters and 8 slaves, where one of those slaves controls
the &lt;code class=&quot;highlighter-rouge&quot;&gt;SINGLE&lt;/code&gt; peripherals and one controls the &lt;code class=&quot;highlighter-rouge&quot;&gt;DOUBLE&lt;/code&gt; peripherals.  The
logic in the slaves might even be as low as 600 LUTs (based upon a &lt;a href=&quot;https://github.com/ZipCPU/wb2axip/blob/master/rtl/axilsingle.v&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;SINGLE&lt;/code&gt;
peripheral drawn from an AXI-lite
example&lt;/a&gt;).&lt;/p&gt;

&lt;p&gt;Yes, there would be some distinct differences in this approach.  For
example, only one master could ever command a read (or write) port of a
&lt;code class=&quot;highlighter-rouge&quot;&gt;SINGLE&lt;/code&gt; or &lt;code class=&quot;highlighter-rouge&quot;&gt;DOUBLE&lt;/code&gt; peripheral at a time–rather than allowing a separate
master to connect to every simplified peripheral.  This isn’t really that
much of a problem, since if you anticipated contention, you might split the
&lt;code class=&quot;highlighter-rouge&quot;&gt;SINGLE&lt;/code&gt; (or &lt;code class=&quot;highlighter-rouge&quot;&gt;DOUBLE&lt;/code&gt;) peripherals into two groups–and so avoid
the contention.  You might also place any high demand peripherals into
their own peripheral slot in the interconnect and just ignore the potential
optimizations–indeed, how you group slaves into &lt;code class=&quot;highlighter-rouge&quot;&gt;SINGLE&lt;/code&gt; or
&lt;code class=&quot;highlighter-rouge&quot;&gt;DOUBLE&lt;/code&gt; peripheral locations is completely application dependent.&lt;/p&gt;

&lt;p&gt;This is also a very different approach from the more common approach of using
an AHB slave as a “lite” slave.  First, AHB has no support for simultaneous
reads and writes.  That would force the read and write channels to be
synchronous prior to handling an AHB slave.  Second, because AHB permits
arbitrary stall amounts, the master/interconnect can’t simplify the returns
among a group of peripherals, but instead is required to check for the return
from each individual peripheral.  Similarly, while it is possible to generate
an AHB interconnect, and so group peripheral returns, such groups of multiple
slaves under the same AHB port would just slow everything down–since AHB is
primarily a combinatorial logic bus.&lt;/p&gt;

&lt;p&gt;Unlike that AHB approach, this approach maintains the high clock speed and
multiple inflight transactions that
&lt;a href=&quot;/blog/2019/05/29/demoaxi.html&quot;&gt;AXI&lt;/a&gt; is known for already.
It also maintains the separate read and write channels, as well as full/burst
speed–unlike many of the &lt;a href=&quot;/formal/2018/12/28/axilite.html&quot;&gt;AXI-lite
implementations&lt;/a&gt; I’ve seen.&lt;/p&gt;

&lt;h2 id=&quot;conclusions&quot;&gt;Conclusions&lt;/h2&gt;

&lt;p&gt;As you may remember, &lt;a href=&quot;/zipcpu/2019/08/22/tech-debt.html&quot;&gt;I’m in the process of upgrading
AutoFPGA&lt;/a&gt; so that it can
handle multiple bus types.  My current upgrade plans include both full
&lt;a href=&quot;https://github.com/ZipCPU/autofpga/blob/master/sw/bus/wb.cpp&quot;&gt;WB&lt;/a&gt; support as
well as
&lt;a href=&quot;https://github.com/ZipCPU/autofpga/blob/master/sw/bus/axil.cpp&quot;&gt;AXI-lite&lt;/a&gt;
support, although once I get that far
AXI
shouldn’t be much harder.  Indeed, most of the
AXI
work has already been done in either the &lt;a href=&quot;https://github.com/ZipCPU/autofpga/blob/master/sw/bus/axil.cpp&quot;&gt;AXI-lite bus logic
generator&lt;/a&gt;,
or the &lt;a href=&quot;/blog/2019/07/17/crossbar.html&quot;&gt;AXI crossbar&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Of course, &lt;a href=&quot;https://github.com/ZipCPU/autofpga/tree/dev&quot;&gt;my current work to this end is still quite
preliminary&lt;/a&gt;, but this at least
outlines how I intend to get the bus to be able to handle large numbers of
slaves without breaking the piggy bank to get there.  My goal is also to make
the generated logic usable for all, rather than encumbered by copyrights,
so that I could then use it in a vendor-independent basis for an &lt;a href=&quot;/blog/2019/08/16/intermediate.html&quot;&gt;intermediate
digital design tutorial&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.blueletterbible.org/kjv/heb/6/3&quot;&gt;If the Lord wills&lt;/a&gt;,
I’d love to have the opportunity to come back and blog about the success
of this work.  We’ll see what future the
&lt;a href=&quot;https://www.blueletterbible.org/kjv/heb/6/3&quot;&gt;Lord brings&lt;/a&gt;.&lt;/p&gt;

&lt;hr /&gt;&lt;p&gt;&lt;em&gt;And whosoever shall fall on this stone shall be broken: but on whomsoever it shall fall, it will grind him to powder. (Matt 21:44)&lt;/em&gt;</description>
        <pubDate>Fri, 30 Aug 2019 00:00:00 -0400</pubDate>
        <link>https://zipcpu.com/zipcpu/2019/08/30/subbus.html</link>
        <guid isPermaLink="true">https://zipcpu.com/zipcpu/2019/08/30/subbus.html</guid>
        
        
        <category>zipcpu</category>
        
      </item>
    
      <item>
        <title>Quiz #4: If this counter is never triggered, can we prove it&#39;ll never leave zero?</title>
        <description>&lt;p&gt;Let’s come back to our simple counter example again (no pun intended at first,
enjoyed ever since), and let’s build a quiz from it again.&lt;/p&gt;

&lt;p&gt;This time we’ve &lt;a href=&quot;/quiz/2019/08/08/quiz02.html&quot;&gt;fixed the issue with the initial
value&lt;/a&gt;,
we’ve chosen to ignore the ASIC designers who will insist our counter
requires an initial reset signal (it wouldn’t fit on the slide with a reset,
but you can add one if to the puzzle above if it makes you feel better),
and we’ve &lt;a href=&quot;/quiz/2019/08/19/quiz03.html&quot;&gt;asserted that our counter will never meet or exceed
&lt;code class=&quot;highlighter-rouge&quot;&gt;24&lt;/code&gt;&lt;/a&gt;.  (You may assume the
counter has enough of a bit width to reach &lt;code class=&quot;highlighter-rouge&quot;&gt;24&lt;/code&gt; …)  We’ve also brought back
the &lt;code class=&quot;highlighter-rouge&quot;&gt;i_start_signal&lt;/code&gt;, which will trigger our counter.&lt;/p&gt;

&lt;p&gt;Today, though, we want to assume that the start signal is never raised,
and having assumed that we want to prove that the counter will remain
zero.&lt;/p&gt;

&lt;p&gt;Will the assertion below prove that?&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;&lt;span class=&quot;k&quot;&gt;always&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;posedge&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i_clk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;assert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;($&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;past&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;counter&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

</description>
        <pubDate>Sat, 24 Aug 2019 00:00:00 -0400</pubDate>
        <link>https://zipcpu.com/quiz/2019/08/24/quiz04.html</link>
        <guid isPermaLink="true">https://zipcpu.com/quiz/2019/08/24/quiz04.html</guid>
        
        
        <category>quiz</category>
        
      </item>
    
      <item>
        <title>Technology Debt and AutoFPGA, the bill just came due</title>
        <description>&lt;p&gt;I’m currently working on a fun SONAR project where I need a data collector.
The project involves transmitting SONAR data through the thick hull of a deeply
submerged underwater object, without drilling holes in the hull to do it.&lt;/p&gt;

&lt;p&gt;Understanding the transmission path through the hull will be a challenge,
so it becomes important to store the incoming signal to memory, download
it to &lt;a href=&quot;https://www.gnu.org/software/octave&quot;&gt;Octave&lt;/a&gt;, and study it there
before building the downstream processing logic.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 1. Sonar Signal Processing Chain&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;a href=&quot;/img/signalpath.svg&quot;&gt;&lt;img src=&quot;/img/autofpga/signalpath.svg&quot; alt=&quot;Sonar signal path: transmitter, hull, copy to memory, to SD card, then analyzed in Octave&quot; width=&quot;720&quot; /&gt;&lt;/a&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;My plan is to collect this information at high speed (800Msps),
to dump it to memory, and then to an &lt;a href=&quot;https://github.com/ZipCPU/sdspi&quot;&gt;SD-Card&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;If you’ve used Xilinx cores before, you may remember that they offer
an &lt;a href=&quot;https://www.xilinx.com/support/documentation/ip_documentation/axi_datamover/v5_1/pg022_axi_datamover.pdf&quot;&gt;AXI Stream to Memory Mapped DataMover
core&lt;/a&gt;
to handle this sort of data to memory processing, but I’ve always liked the
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;Wishbone bus&lt;/a&gt; and
&lt;a href=&quot;/blog/2017/06/21/looking-at-verilator.html&quot;&gt;Verilator&lt;/a&gt;–the
&lt;a href=&quot;https://www.youtube.com/watch?v=en8JMz7v3LU&quot;&gt;fastest simulator on the market&lt;/a&gt;,
and one that’s easy to integrate an &lt;a href=&quot;https://github.com/ZipCPU/sdspi/blob/master/bench/cpp/sdsdpisim.cpp&quot;&gt;SD-Card simulator
into&lt;/a&gt;.
Creating a similar
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;Wishbone&lt;/a&gt;
core took me only a couple hours one morning to both build and verify.  Having
the &lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;formal properties for the Wishbone
bus&lt;/a&gt; on hand
definitely helped.&lt;/p&gt;

&lt;p&gt;That was the easy part.  Indeed, I’d like blog about this new core soon as well
(once I decide where to put it).&lt;/p&gt;

&lt;p&gt;The harder part was integrating this new core with
&lt;a href=&quot;/zipcpu/2017/10/05/autofpga-intro.html&quot;&gt;AutoFPGA&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The problem is simple and basic:
&lt;a href=&quot;/zipcpu/2017/10/05/autofpga-intro.html&quot;&gt;AutoFPGA&lt;/a&gt;.
as currently designed can handle the logic necessary to connect a
&lt;em&gt;single Wishbone&lt;/em&gt; master to all of the slaves within a design.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;This approach is light on logic, as desired.  The &lt;a href=&quot;/blog/2017/06/22/simple-wb-interconnect.html&quot;&gt;necessary interconnect
logic is cheap and easy to
build&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 2. ZipCPU and AutoFPGA bus structure&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/autofpga/zipbus.svg&quot; alt=&quot;Four bus masters, three bus arbiters&quot; width=&quot;480&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;For the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;, this logic
represents a bit of a &lt;a href=&quot;/zipcpu/2019/02/09/cpu-blinky.html&quot;&gt;speed
bump&lt;/a&gt;.  Internally, the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
has two memory ports, one for instructions and one for data, and after
generating them I &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/ex/wbdblpriarb.v&quot;&gt;arbitrate them together&lt;/a&gt; into a single bus interface.  While
this slows down the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt;,
I’ve accepted the consequences of this to date because it helps simplify the
rest of the design.  Sadly, the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
gets slowed down again when its bus control signals have to be arbitrated
against the DMA peripheral, and then again when they are arbitrated against
the debugging bus.&lt;/p&gt;

    &lt;p&gt;All of this costs time and capability.  Indeed, in order to meet timing each
of the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/ex/wbarbiter.v&quot;&gt;bus
arbiters&lt;/a&gt;
has required &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/ex/busdelay.v&quot;&gt;delaying bus accesses by a
cycle&lt;/a&gt;.&lt;/p&gt;

    &lt;p&gt;I’ve dreamed of rewriting the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt;
so that it has two independent bus ports, removing the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/wbdmac.v&quot;&gt;DMA&lt;/a&gt;
from the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt;
to the main design, and then allowing all four bus masters
(&lt;a href=&quot;/zipcpu/2018/03/21/dblfetch.html&quot;&gt;CPU instructions&lt;/a&gt;,
CPU data,
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/wbdmac.v&quot;&gt;DMA&lt;/a&gt;
and &lt;a href=&quot;/zipcpu/2017/05/20/which-came-first.html&quot;&gt;debugging interface&lt;/a&gt;)
to interact with the bus at the same time through a
&lt;a href=&quot;/blog/2019/07/17/crossbar.html&quot;&gt;crossbar&lt;/a&gt;.
&lt;a href=&quot;/zipcpu/2017/10/05/autofpga-intro.html&quot;&gt;AutoFPGA&lt;/a&gt;
can’t handle this (yet).  We’ll discuss this more in a moment.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 3. A better bus design, this time using a crossbar interconnect&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/autofpga/crossbarbus.svg&quot; alt=&quot;All bus masters are now equals entering  the bus, all delays are internal to the crossbar&quot; width=&quot;720&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;This also has consequences for anyone who would like to use
&lt;a href=&quot;/zipcpu/2017/10/05/autofpga-intro.html&quot;&gt;AutoFPGA&lt;/a&gt;.  For
example, I’d like it to be able to handle interconnecting
&lt;a href=&quot;/blog/2019/05/29/demoaxi.html&quot;&gt;AXI&lt;/a&gt;,
&lt;a href=&quot;/blog/2019/01/12/demoaxilite.html&quot;&gt;AXI-lite&lt;/a&gt;,
and even &lt;a href=&quot;/doc/wbspec_b4.pdf&quot;&gt;Wishbone classic&lt;/a&gt; signals.
However, as built today,
&lt;a href=&quot;/zipcpu/2017/10/05/autofpga-intro.html&quot;&gt;AutoFPGA&lt;/a&gt;
can only ever create the logic for
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;Wishbone pipeline&lt;/a&gt;
signaling.&lt;/p&gt;

    &lt;p&gt;To solve this, I’ve recently created a series of
&lt;a href=&quot;/blog/2019/07/17/crossbar.html&quot;&gt;crossbar&lt;/a&gt; bus
arbiters–&lt;a href=&quot;https://github.com/ZipCPU/wb2axip/blob/master/rtl/axixbar.v&quot;&gt;AXI&lt;/a&gt;,
&lt;a href=&quot;https://github.com/ZipCPU/wb2axip/blob/master/rtl/axilxbar.v&quot;&gt;AXI-lite&lt;/a&gt;, and
&lt;a href=&quot;https://github.com/ZipCPU/wb2axip/blob/master/rtl/wbxbar.v&quot;&gt;Wishbone (pipeline)&lt;/a&gt;,
with the goal and intent that
&lt;a href=&quot;/zipcpu/2017/10/05/autofpga-intro.html&quot;&gt;AutoFPGA&lt;/a&gt;
should just be able to reference such an arbiter and not need
to know much more about the bus.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;… and now I want to add a &lt;a href=&quot;/blog/2017/06/08/simple-wb-master.html&quot;&gt;new bus
master&lt;/a&gt;, a
&lt;a href=&quot;/blog/2017/08/14/strategies-for-pipelining.html&quot;&gt;stream&lt;/a&gt;
to &lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;Wishbone&lt;/a&gt;
bus master.&lt;/p&gt;

&lt;p&gt;It’s not quite that simple either.  A second SONAR project I’m working on will
require a transmit controller that will want to read instructions from the bus.
Indeed, this is why I like and use
&lt;a href=&quot;/zipcpu/2017/10/05/autofpga-intro.html&quot;&gt;AutoFPGA&lt;/a&gt;.  It
allows me to easily and rapidly reconfigure a master base design, &lt;a href=&quot;https://github.com/ZipCPU/videozip&quot;&gt;such as this
one&lt;/a&gt; for the &lt;a href=&quot;https://store.digilentinc.com/nexys-video-artix-7-fpga-trainer-board-for-multimedia-applications&quot;&gt;Nexys Video
board&lt;/a&gt;,
from one configuration and application to another.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 4. Two different AutoFPGA Configurations, built from the same base design&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/autofpga/dualconfig.svg&quot; alt=&quot;Two design shown, one with recording components and one with transmitter components&quot; width=&quot;720&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;While the new SONAR transmit controller component is not a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;, I found the idea
of re-using &lt;a href=&quot;/zipcpu/2018/03/21/dblfetch.html&quot;&gt;my instruction fetch
code&lt;/a&gt; just too tempting.
Indeed, should the &lt;a href=&quot;https://www.blueletterbible.org/kjv/jas/4/15&quot;&gt;Lord be
willing&lt;/a&gt;, I’m hoping to discuss
how to build something like this in my (to be written) &lt;a href=&quot;/blog/2019/08/16/intermediate.html&quot;&gt;intermediate
tutorial&lt;/a&gt;, with a music
box as an application, but we’ll have to come back to that on another day.&lt;/p&gt;

&lt;p&gt;What I’d like to do today is to use the same &lt;a href=&quot;https://github.com/ZipCPU/videozip&quot;&gt;basic FPGA
design&lt;/a&gt; for both applications, as shown
in Fig. 4 above: the stream to memory controller, as well as the scripted
SONAR transmit controller.  Ideally, I’d just make a small change or two
and the design would suddenly go from working on one project to working
on a second project.&lt;/p&gt;

&lt;p&gt;Again, that’s the purpose of
&lt;a href=&quot;/zipcpu/2017/10/05/autofpga-intro.html&quot;&gt;AutoFPGA&lt;/a&gt;
in the first place.&lt;/p&gt;

&lt;p&gt;Sadly, this leaves me with a choice: I can either upgrade my &lt;a href=&quot;/blog/2017/06/22/simple-wb-interconnect.html&quot;&gt;interconnect
logic&lt;/a&gt; generator
within &lt;a href=&quot;/zipcpu/2017/10/05/autofpga-intro.html&quot;&gt;AutoFPGA&lt;/a&gt;
to handle multiple bus masters, or I can slow the bus down (again) by
manually adding in one more arbiter to transform the problem back to a
known solution–the single bus master.&lt;/p&gt;

&lt;p&gt;This time (yes, there were others), I chose to update
&lt;a href=&quot;/zipcpu/2017/10/05/autofpga-intro.html&quot;&gt;AutoFPGA&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;updates-in-progress&quot;&gt;Updates in Progress&lt;/h2&gt;

&lt;p&gt;The updates to
&lt;a href=&quot;/zipcpu/2017/10/05/autofpga-intro.html&quot;&gt;AutoFPGA&lt;/a&gt;
are still a work in progress, or I’d share them on
&lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;github&lt;/a&gt;.  (No one really wants to try
to build code that will just
&lt;a href=&quot;https://en.wikipedia.org/wiki/Segmentation_fault&quot;&gt;segfault&lt;/a&gt;, and that’s
where I spent most of my day yesterday.)  Here’s some of what’s coming, though:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;First and foremost, my immediate goal is to create multiple bus master
support, through a
&lt;a href=&quot;/blog/2019/07/17/crossbar.html&quot;&gt;crossbar interconnect&lt;/a&gt;,
so that adding (or removing) a
&lt;a href=&quot;/blog/2017/06/08/simple-wb-master.html&quot;&gt;bus master&lt;/a&gt;
is as easy as adjusting the line in the Makefile identifying
which masters are to be included in the design.&lt;/li&gt;
&lt;/ol&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 5. A Crossbar can support multiple masters&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/autofpga/multimaster.svg&quot; alt=&quot;Block logic for 3 master connected to a crossbar driving 6 slaves&quot; width=&quot;720&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;One of the advantages of using
&lt;a href=&quot;/zipcpu/2017/10/05/autofpga-intro.html&quot;&gt;AutoFPGA&lt;/a&gt;
over a proprietary solution like
&lt;a href=&quot;https://www.xilinx.com/products/design-tools/vivado.html&quot;&gt;Vivado&lt;/a&gt;
or &lt;a href=&quot;https://www.intel.com/content/www/us/en/programmable/products/design-software/fpga-design/quartus-prime/features/qts-platform-designer.html&quot;&gt;Quartus&lt;/a&gt;
is that all of the project files are user-supplied text files, and so they
can easily be examined and fixed (if necessary).  Even better, you’ll never
need to “rebuild” your project from the ground up after updating your vendor
tool set, although you might need to make some adjustments when updating
&lt;a href=&quot;/zipcpu/2017/10/05/autofpga-intro.html&quot;&gt;AutoFPGA&lt;/a&gt;.
I’ll discuss why below.&lt;/p&gt;

&lt;ol start=&quot;2&quot;&gt;
  &lt;li&gt;
    &lt;p&gt;The &lt;a href=&quot;/blog/2019/07/17/crossbar.html&quot;&gt;crossbar
interconnect&lt;/a&gt;
logic is not currently a part of
&lt;a href=&quot;/zipcpu/2017/10/05/autofpga-intro.html&quot;&gt;AutoFPGA&lt;/a&gt;.
This creates both opportunities and problems.&lt;/p&gt;

    &lt;p&gt;&lt;em&gt;The opportunity:&lt;/em&gt; You can easily replace
&lt;a href=&quot;/blog/2019/07/17/crossbar.html&quot;&gt;my arbiter logic&lt;/a&gt;
with yours by just matching the interface and then swapping the
arbiter logic.&lt;/p&gt;

    &lt;p&gt;The problem comes from licensing.  While
&lt;a href=&quot;/zipcpu/2017/10/05/autofpga-intro.html&quot;&gt;AutoFPGA&lt;/a&gt;
is licensed under &lt;a href=&quot;https://www.gnu.org/licenses/gpl.html&quot;&gt;GPL&lt;/a&gt;, it asserts
no license over the code it creates.  I treat it sort of like a
&lt;a href=&quot;https://www.gnu.org/software/gcc&quot;&gt;GCC&lt;/a&gt;: the code
&lt;a href=&quot;https://www.gnu.org/software/gcc&quot;&gt;GCC&lt;/a&gt;
produces remains under the license it started with.  I’ve done this to try
to make &lt;a href=&quot;/zipcpu/2017/10/05/autofpga-intro.html&quot;&gt;AutoFPGA&lt;/a&gt;
usable by all in any context.&lt;/p&gt;

    &lt;p&gt;If I want to keep
&lt;a href=&quot;/zipcpu/2017/10/05/autofpga-intro.html&quot;&gt;AutoFPGA&lt;/a&gt;
usable in this new context, I may need to release any bus-logic sub-cores
under a very permissive license.  Given the amount of time that went into
creating them, I am reluctant to do so, but needs may require this.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;As mentioned above, this new
&lt;a href=&quot;/zipcpu/2017/10/05/autofpga-intro.html&quot;&gt;AutoFPGA&lt;/a&gt;
upgrade has multiple bus protocol
support.  This currently includes
&lt;a href=&quot;/blog/2019/01/12/demoaxilite.html&quot;&gt;AXI-lite&lt;/a&gt;
support as well as
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;Wishbone&lt;/a&gt;
support.  Even better, the
&lt;a href=&quot;/blog/2019/01/12/demoaxilite.html&quot;&gt;AXI-lite&lt;/a&gt;
will be high speed straight from the
&lt;a href=&quot;https://github.com/ZipCPU/wb2axip/blob/master/rtl/axilxbar.v&quot;&gt;arbiter&lt;/a&gt;
arbiter–rather than &lt;a href=&quot;/formal/2018/12/28/axilite.html&quot;&gt;crippled like Xilinx’s
support&lt;/a&gt; was.&lt;/p&gt;

    &lt;p&gt;My eventual goal will be to automatically insert crossbars and bus protocol
(and clock) bridges as needed by the design.  While other tools already exist
to do this, not all of them are open–making it difficult to use the &lt;a href=&quot;https://www.youtube.com/watch?v=en8JMz7v3LU&quot;&gt;fastest
simulator on the market&lt;/a&gt;.  My
current goal is just to be able to handle different bus protocols–bus
bridges and clock crossings can be added manually for the time being.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;I’ve also been burned by the previous
&lt;a href=&quot;/zipcpu/2017/10/05/autofpga-intro.html&quot;&gt;AutoFPGA&lt;/a&gt;
approach to integrating bus components into a design.  Specifically, in
order to integrate a bus component before,
&lt;a href=&quot;/zipcpu/2017/10/05/autofpga-intro.html&quot;&gt;AutoFPGA&lt;/a&gt;
would create wires based upon the bus name (not type):
&lt;code class=&quot;highlighter-rouge&quot;&gt;wb_cyc&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;wb_stb&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;wb_we&lt;/code&gt; and so on.  To connect a slave, you’d need to
create a &lt;code class=&quot;highlighter-rouge&quot;&gt;@MAIN.INSERT&lt;/code&gt; tag to outline code that would be simply inserted
into the main project design.  This code would then pass &lt;code class=&quot;highlighter-rouge&quot;&gt;wb_cyc&lt;/code&gt;,
and &lt;code class=&quot;highlighter-rouge&quot;&gt;wb_we&lt;/code&gt; directly to the peripheral design, and the design would return
something like &lt;code class=&quot;highlighter-rouge&quot;&gt;flash_ack&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;flash_stall&lt;/code&gt;, and &lt;code class=&quot;highlighter-rouge&quot;&gt;flash_data&lt;/code&gt; (assuming it
was a &lt;a href=&quot;/2019/03/27/qflexpress.html&quot;&gt;flash controller&lt;/a&gt;.
Further, rather than passing &lt;code class=&quot;highlighter-rouge&quot;&gt;wb_stb&lt;/code&gt; to the slave, the design would &lt;a href=&quot;/blog/2017/06/22/simple-wb-interconnect.html&quot;&gt;decode
addresses&lt;/a&gt;
to determine which slave was being addressed, and so you’d then pass
&lt;code class=&quot;highlighter-rouge&quot;&gt;wb_stb &amp;amp; flash_sel&lt;/code&gt;.  That is, you’d pass the
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;Wishbone&lt;/a&gt;
strobe (i.e.  transaction request) ANDed with the slave selection drawn
from the bus address.&lt;/p&gt;

    &lt;p&gt;While I like this design approach in general, since it allows you to connect
to the bus any way you want, there’s been more than one time I’ve 
connected a &lt;a href=&quot;/zipcpu/2018/01/22/formal-progress.html&quot;&gt;formally
verified&lt;/a&gt;
core to the bus and gotten this logic wrong.&lt;/p&gt;

    &lt;p&gt;As an example, I once got careless and just passed &lt;code class=&quot;highlighter-rouge&quot;&gt;wb_stb&lt;/code&gt; directly to
the core rather than &lt;code class=&quot;highlighter-rouge&quot;&gt;wb_stb &amp;amp; slave_sel&lt;/code&gt;.  The result wasn’t pretty,
but caused multiple returns from the bus (I wasn’t filtering returns based
upon the active slave) and so &lt;a href=&quot;/blog/2018/02/09/first-cyclonev.html&quot;&gt;crashed Intel’s AXI interface (it had gone
through an AXI to Avalon bridge …)&lt;/a&gt;.&lt;/p&gt;

    &lt;p&gt;Worse, when you try to integrate with something like
&lt;a href=&quot;/blog/2019/05/29/demoaxi.html&quot;&gt;AXI&lt;/a&gt;,
you end up needing to mention and connect &lt;em&gt;every single I/O wire&lt;/em&gt; just to
get it right.&lt;/p&gt;

    &lt;p&gt;The easy answer would be to define a tag in
&lt;a href=&quot;/zipcpu/2017/10/05/autofpga-intro.html&quot;&gt;AutoFPGA&lt;/a&gt;,
we’ll call it &lt;code class=&quot;highlighter-rouge&quot;&gt;@SLAVE.PORTLIST&lt;/code&gt;, which would contain a string containing
all the logic (i.e. a list of I/O ports) that can be used to connect your
slave to the bus.  A similar tag, &lt;code class=&quot;highlighter-rouge&quot;&gt;@SLAVE.ANSIPORTLIST&lt;/code&gt;, would reference
a string containing all the logic necessary to connect a peripheral to a
bus using ANSI notation.  Similar tags, &lt;code class=&quot;highlighter-rouge&quot;&gt;@MASTER.PORTLIST&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;@MASTER.ANSIPORTLIST&lt;/code&gt;, would define this
logic for bus masters.  (There are already other &lt;code class=&quot;highlighter-rouge&quot;&gt;@*PORTLIST&lt;/code&gt; tags used
to define external I/O connections, the &lt;code class=&quot;highlighter-rouge&quot;&gt;SLAVE&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;MASTER&lt;/code&gt; prefix would
designate these port lists specific to the bus at hand.)&lt;/p&gt;

    &lt;p&gt;Creating these strings will simplify my design efforts, and help to
standardize things as well.&lt;/p&gt;

    &lt;p&gt;One unintended consequence of this adjusting a core from one interface
type to another would only require adjusting the &lt;code class=&quot;highlighter-rouge&quot;&gt;@SLAVE.BUS.TYPE&lt;/code&gt;
tag–of course, you’ll still need to adjust the core.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Peripheral classes&lt;/p&gt;

    &lt;p&gt;To keep the logic light, I’ve defined two subsets of the
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;Wishbone&lt;/a&gt;
protocol, subsets I call &lt;code class=&quot;highlighter-rouge&quot;&gt;SINGLE&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;DOUBLE&lt;/code&gt;.  I created them when I
noticed that I had a lot of peripherals with nearly the same logic, and
it just made sense to aggregate the control logic together across peripherals.&lt;/p&gt;

    &lt;p&gt;Neither of these two sub-classes, &lt;code class=&quot;highlighter-rouge&quot;&gt;SINGLE&lt;/code&gt; nor &lt;code class=&quot;highlighter-rouge&quot;&gt;DOUBLE&lt;/code&gt;, are allowed to
stall the bus, neither are they allowed to return
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_(computing)&quot;&gt;bus&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_error&quot;&gt;errors&lt;/a&gt;.
&lt;code class=&quot;highlighter-rouge&quot;&gt;SINGLE&lt;/code&gt; peripherals create their acknowledgments on the same clock cycle
they are accessed, and &lt;code class=&quot;highlighter-rouge&quot;&gt;DOUBLE&lt;/code&gt; peripherals create their acknowledgments
one cycle later.&lt;/p&gt;

    &lt;p&gt;– A &lt;code class=&quot;highlighter-rouge&quot;&gt;SINGLE&lt;/code&gt; peripheral is one that contains a single register only,
   and it’s useful for your basic control register.&lt;/p&gt;

    &lt;p&gt;– A &lt;code class=&quot;highlighter-rouge&quot;&gt;DOUBLE&lt;/code&gt; peripheral is one that contains multiple registers.  It uses
   one clock in a case statement to select among multiple values to return.&lt;/p&gt;

    &lt;p&gt;I’ve found these bus classes to be quite common across many design elements.
Because their logic is simple, I’ve had no problem creating designs with
30+ peripherals and then adding or removing those peripherals via
&lt;a href=&quot;/zipcpu/2017/10/05/autofpga-intro.html&quot;&gt;AutoFPGA&lt;/a&gt;
as projects have required.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 6. Special slave classes: SINGLE and DOUBLE&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/autofpga/sdiobus.svg&quot; alt=&quot;SINGLE slaves and DOUBLE slaves each form a class of I/O where the control logic is shared between them&quot; width=&quot;560&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Here’s the good news: When I started creating the
&lt;a href=&quot;/formal/2018/12/28/axilite.html&quot;&gt;AXI-lite&lt;/a&gt; support, I
realized that I needed to continue to support these two subclasses.  The
need for them wasn’t specific to
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;Wishbone&lt;/a&gt; peripherals.
Therefore, the
&lt;a href=&quot;/formal/2018/12/28/axilite.html&quot;&gt;AXI-lite&lt;/a&gt; support
will support these two subclasses.  To give you an idea how these might
work, here are the assumptions required for these simplified peripherals.&lt;/p&gt;

    &lt;p&gt;– &lt;code class=&quot;highlighter-rouge&quot;&gt;SINGLE&lt;/code&gt; requires that &lt;code class=&quot;highlighter-rouge&quot;&gt;C_S_AXI_ADDR_WIDTH == 0&lt;/code&gt;, or a slave having one
   address only.  That allows the address lines to be dropped.  The
   &lt;code class=&quot;highlighter-rouge&quot;&gt;DOUBLE&lt;/code&gt; class will allow a peripheral to support multiple addresses, and
   so different address widths as well.&lt;/p&gt;

    &lt;p&gt;– Write interface&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;
        &lt;p&gt;The slave must guarantee that &lt;code class=&quot;highlighter-rouge&quot;&gt;AWREADY = WREADY = 1&lt;/code&gt;.&lt;/p&gt;

        &lt;p&gt;This will allow the interconnect to ignore these inputs.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;The slave must also guarantee that &lt;code class=&quot;highlighter-rouge&quot;&gt;BVALID == $past(AWVALID)&lt;/code&gt; for
&lt;code class=&quot;highlighter-rouge&quot;&gt;SINGLE&lt;/code&gt; peripherals, and that &lt;code class=&quot;highlighter-rouge&quot;&gt;BVALID == $past(AWVALID,2)&lt;/code&gt; for
&lt;code class=&quot;highlighter-rouge&quot;&gt;DOUBLE&lt;/code&gt; peripherals.&lt;/p&gt;

        &lt;p&gt;This will allow the interconnect to automatically generate a common
&lt;code class=&quot;highlighter-rouge&quot;&gt;BVALID&lt;/code&gt; for all of the peripherals in the set without needing the
logic to check every peripheral for this condition individually.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;The controller (i.e interconnect) will guarantee that
&lt;code class=&quot;highlighter-rouge&quot;&gt;AWVALID == WVALID&lt;/code&gt;.&lt;/p&gt;

        &lt;p&gt;This means that you can connect &lt;code class=&quot;highlighter-rouge&quot;&gt;AWVALID&lt;/code&gt; to &lt;code class=&quot;highlighter-rouge&quot;&gt;WVALID&lt;/code&gt; when connecting
your core, and also that you don’t need to handle synchronizing these
two channels together within your core.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;The controller will also guarantee that &lt;code class=&quot;highlighter-rouge&quot;&gt;BREADY == 1&lt;/code&gt;.&lt;/p&gt;

        &lt;p&gt;That is also required for the interconnect to ignore &lt;code class=&quot;highlighter-rouge&quot;&gt;BVALID&lt;/code&gt;.&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ol&gt;

    &lt;p&gt;– Read interface&lt;/p&gt;

    &lt;p&gt;These rules pretty much follow the write interface above.&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;The slave must guarantee that &lt;code class=&quot;highlighter-rouge&quot;&gt;ARREADY == 1&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;The slave must also guarantee that &lt;code class=&quot;highlighter-rouge&quot;&gt;RVALID == $past(ARVALID)&lt;/code&gt; for
&lt;code class=&quot;highlighter-rouge&quot;&gt;SINGLE&lt;/code&gt; peripherals, or equivalently that &lt;code class=&quot;highlighter-rouge&quot;&gt;RVALID == $past(ARVALID,2)&lt;/code&gt;
for &lt;code class=&quot;highlighter-rouge&quot;&gt;DOUBLE&lt;/code&gt; peripherals.&lt;/li&gt;
      &lt;li&gt;The controller will guarantee that &lt;code class=&quot;highlighter-rouge&quot;&gt;RREADY == 1&lt;/code&gt;.&lt;/li&gt;
    &lt;/ol&gt;

    &lt;p&gt;Together, these assumptions will greatly simplify creating
&lt;a href=&quot;/formal/2018/12/28/axilite.html&quot;&gt;AXI-lite&lt;/a&gt; slaves.
The control logic to support this is pretty easy to build and verify
as well, so it’s likely I’ll do something similar when I get to building
the full &lt;a href=&quot;/blog/2019/05/29/demoaxi.html&quot;&gt;AXI&lt;/a&gt; support.&lt;/p&gt;

    &lt;p&gt;I’m sure we’ll discuss more about this on the blog as time goes along.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;All of these are wonderful, great, and (insert your favorite superlative
here) ideas.&lt;/p&gt;

&lt;p&gt;There’s one problem I discovered when integrating these changes into my design:
I had used the knowledge of how the interconnect worked when building some of
my cores.  This is now causing these otherwise “working” cores to break.&lt;/p&gt;

&lt;h2 id=&quot;technology-debt-the-bill-comes-due&quot;&gt;Technology Debt: The bill comes due&lt;/h2&gt;

&lt;p&gt;Wikipedia (today) defines &lt;a href=&quot;https://en.wikipedia.org/wiki/Technical_debt&quot;&gt;technology
debt&lt;/a&gt; as,&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Technical debt is a concept in software development that reflects
the implied cost of additional rework caused by choosing an easy or
limited solution now instead of using a better approach that would take
longer.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Two of my cores that are now suffering from this debt are my RMII/RGMII
network cores, and my wonderful new &lt;a href=&quot;/2019/03/27/qflexpress.html&quot;&gt;“Universal” QSPI flash
controller&lt;/a&gt;.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: left&quot;&gt;&lt;caption&gt;Fig 7. Abusing the bus protocol&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/autofpga/qspiports.svg&quot; alt=&quot;Shared signals: CYC, WE, ADDR, bus separate STB signals.  Bus returns share ACK, STALL, and DATA signals.  The result is not protocol compliant.&quot; width=&quot;420&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Both of these cores have both a memory interface and a control interface,
as shown in Fig. 7 on the left.  For the network core, the memory interface is
to either the to-be-transmitted or the already-received packet memory
contained within the core.  For the
&lt;a href=&quot;/2019/03/27/qflexpress.html&quot;&gt;flash controller&lt;/a&gt;,
the interface is between the &lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash
memory&lt;/a&gt; and the control register.&lt;/p&gt;

&lt;p&gt;In both cases, I abused the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_(computing)&quot;&gt;bus&lt;/a&gt; protocol knowing how the
&lt;a href=&quot;/blog/2017/06/22/simple-wb-interconnect.html&quot;&gt;interconnect&lt;/a&gt;
would handle things.&lt;/p&gt;

&lt;p&gt;You can see how this affects the port list for the
flash controller
below,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;&lt;span class=&quot;k&quot;&gt;module&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;qflexpress&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i_clk&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i_reset&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;i_wb_cyc&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i_wb_stb&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i_cfg_stb&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i_wb_we&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i_wb_addr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i_wb_data&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;o_wb_ack&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;o_wb_stall&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;o_wb_data&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;o_qspi_sck&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;o_qspi_cs_n&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;o_qspi_mod&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;o_qspi_dat&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i_qspi_dat&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Rather than defining two (properly separate) interfaces, I just created a
single interface with two strobe signals: &lt;code class=&quot;highlighter-rouge&quot;&gt;i_wb_stb&lt;/code&gt; for reading from memory,
and &lt;code class=&quot;highlighter-rouge&quot;&gt;i_cfg_stb&lt;/code&gt; for reading from the control port.  Results were returned
through a common return port of &lt;code class=&quot;highlighter-rouge&quot;&gt;o_wb_ack, o_wb_stall,&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;o_wb_data&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;If first hit a problem with this interface when I tried to handle
acknowledgments.  Since the simple
&lt;a href=&quot;/blog/2017/06/22/simple-wb-interconnect.html&quot;&gt;interconnect&lt;/a&gt;
I was using just OR’d all of the acknowledgment signals together in order to
generate an ACK signal to return to the
&lt;a href=&quot;/blog/2017/06/08/simple-wb-master.html&quot;&gt;bus master&lt;/a&gt;,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;&lt;span class=&quot;k&quot;&gt;always&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;posedge&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i_clk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;wb_ack&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;flash_memory_ack&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;memory_ack&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;etc_ack&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;};&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;there was never any problem with OR’ing two acknowledgment signals together
within the slave.  Indeed, it spared bus logic in the return.  Similarly, since
the &lt;a href=&quot;/blog/2017/06/22/simple-wb-interconnect.html&quot;&gt;interconnect&lt;/a&gt;
selected the data to be returned based upon which slave set its
acknowledgment signal,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;&lt;span class=&quot;k&quot;&gt;always&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;posedge&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i_clk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;case&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;flash_memory_ack&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;memory_ack&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;other_ack&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;etc_ack&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;// No line to accept flash_config_data
&lt;/span&gt;&lt;span class=&quot;mb&quot;&gt;4&#39;b1???&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;wb_data&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;flash_memory_data&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;mb&quot;&gt;4&#39;b01??&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;memory_ack&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;//&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;etc&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;a slave interface that hadn’t been referenced could validly set it’s
acknowledgment signal and then return data via the other slave interface port.&lt;/p&gt;

&lt;p&gt;Both of these are an abuse of
the &lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;Wishbone&lt;/a&gt;
protocol.&lt;/p&gt;

&lt;p&gt;As you might expect, I then ran into problems when I wanted to update my
interconnect to drop the &lt;a href=&quot;/zipcpu/2019/03/28/return-decoding.html&quot;&gt;poorly designed return
logic&lt;/a&gt;, since I
wanted to now create an index register for a multiplexer that would identify
which core should receive the returned data.
(If that’s confusing, I explain
the concept &lt;a href=&quot;/zipcpu/2019/03/28/return-decoding.html&quot;&gt;here&lt;/a&gt;.)&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;&lt;span class=&quot;k&quot;&gt;always&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;posedge&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i_clk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;wb_stb&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;wb_index&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;wb_addr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;LOW_BITS&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;always&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;posedge&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i_clk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;case&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;wb_index&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;wb_data&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;flash_memory_data&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// This port will never return valid data, since there was no defined
// flash configuration port defining a flash_config_data value
&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;wb_data&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;flash_config_data&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;wb_data&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;memory_data&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;//&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;etc&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Once the selected channel stopped returning the correct value under
this new logic implementation, I then started to learn the error of my ways.&lt;/p&gt;

&lt;p&gt;Note the key word “started”.  Rather than fixing the problem properly by
creating two separate bus interfaces, I cheated.  I returned the same data
on both channels.  This would work because the returned acknowledgment was
still the OR of all the acknowledgments.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;&lt;span class=&quot;k&quot;&gt;assign&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;flash_config_data&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;flash_memory_data&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Now the bill is coming due again, since in order to support multiple masters
it is now possible that two masters will each try to access the two peripheral
interfaces, both at the same time, and so combining values in the return port
is no longer possible under any stretch.&lt;/p&gt;

&lt;p&gt;That means I’ll need to change the &lt;a href=&quot;/2019/03/27/qflexpress.html&quot;&gt;“Universal” QSPI flash
controller&lt;/a&gt; port list to be
something closer to,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;&lt;span class=&quot;k&quot;&gt;module&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;qflexpress&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i_clk&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i_reset&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;i_wb_cyc&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i_wb_stb&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i_wb_we&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i_wb_addr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i_wb_data&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;o_wb_ack&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;o_wb_stall&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;o_wb_data&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;i_cfg_cyc&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i_cfg_stb&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i_cfg_we&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i_cfg_addr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i_cfg_data&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;o_cfg_ack&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;o_cfg_stall&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;o_cfg_data&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;o_qspi_sck&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;o_qspi_cs_n&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;o_qspi_mod&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;o_qspi_dat&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i_qspi_dat&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;like it probably should’ve been in the beginning.&lt;/p&gt;

&lt;p&gt;There’s another problem that I’m likely to struggle from as well: all of the
bus wire names are changing.  Creating a bus structure where every wire is
prefixed by &lt;code class=&quot;highlighter-rouge&quot;&gt;wb_&lt;/code&gt;, as in &lt;code class=&quot;highlighter-rouge&quot;&gt;wb_cyc&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;wb_stb&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;wb_we&lt;/code&gt;, etc., is great when only
one master will ever control this bus.  Creating multi-master support is going
to require changing all of these wire names so that each peripheral can be
interacted with separately.  This will result in an annoying
incompatibility between
&lt;a href=&quot;/zipcpu/2017/10/05/autofpga-intro.html&quot;&gt;AutoFPGA&lt;/a&gt;
versions.  While I think the benefit outweighs the problems, it will take
some time to upgrade all of my separate projects to get things to work again
with the new version.&lt;/p&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;My conclusion from this whole affair is that I’m learning some hard lessons
about design.  In particular, be careful not to use the knowledge of how the
other end of an interface is working to violate the rules of that interface.
Sure, the result might work for your first project, but by doing so you are
incurring a debt–one that will need to be paid eventually when you use the
core later in a different environment.&lt;/p&gt;

&lt;p&gt;Some time ago, I remember consulting with a particular technology company
about this issue.  They shared with me their own struggles, sounding very
similar to this one, where they had all kinds of cores written in house but
each of which had abused the bus protocol in some fashion or other.
The result was that drawing a core out from their library to use in a new
project incurred an update cost any time the new environment was different.
Worse, because of the tyranny of the urgent, the didn’t fix the issue properly.
Instead, they had chosen the quick and easy solution of modifying the library
core to fit the new need.  As a result, their core IP library was filled with
many similar cores–but all having subtly different (abused) interfaces.&lt;/p&gt;

&lt;p&gt;It’s fun for me to consult and discuss the “way out” of a problem like that.
I’m sure you, like me, enjoy telling other people how to live their lives.
It becomes quite a different matter when you find yourself stuck in the same
mire.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Behold, thou … makest the boast of God, And knowest his will, and
approvest the things that are more excellent, being instructed out of
the law; And art confident that thou thyself art a guide of the blind,
a light of them which are in darkness, An instructor of the foolish, a
teacher of babes, which hast the form of knowledge and of the truth in
the law.  &lt;strong&gt;Thou therefore which teachest another, teachest thou not
thyself?&lt;/strong&gt; thou that preachest a man should not steal, dost thou steal?
(From &lt;a href=&quot;https://www.blueletterbible.org/kjv/rom/2/17-21&quot;&gt;Romans 2:17-21&lt;/a&gt;)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Ouch.  That hurts.  So true though.&lt;/p&gt;

&lt;p&gt;So I’m going to try to start paying off this debt today, together with whatever
interest may have accrued.  I’d still like to come back later,
&lt;a href=&quot;https://www.blueletterbible.org/kjv/jas/4/15&quot;&gt;Lord willing&lt;/a&gt;,
and discuss that stream to Wishbone converter–but that’ll have to wait for
another day.&lt;/p&gt;
&lt;hr /&gt;&lt;p&gt;&lt;em&gt;The rich ruleth over the poor, and the borrower is servant to the lender. (Prov 22:7)&lt;/em&gt;</description>
        <pubDate>Thu, 22 Aug 2019 00:00:00 -0400</pubDate>
        <link>https://zipcpu.com/zipcpu/2019/08/22/tech-debt.html</link>
        <guid isPermaLink="true">https://zipcpu.com/zipcpu/2019/08/22/tech-debt.html</guid>
        
        
        <category>zipcpu</category>
        
      </item>
    
      <item>
        <title>Xilinx deleted this post</title>
        <description>&lt;p&gt;I was originally going to title this article, &lt;em&gt;“Digital design is not Lego
design”&lt;/em&gt;, but then Xilinx deleted the &lt;a href=&quot;https://forums.xilinx.com&quot;&gt;forum&lt;/a&gt; post
it was based upon, so I’ve since changed the title.  Here’s the story:&lt;/p&gt;

&lt;p&gt;Recently, someone posted some fairly benign recommendations for beginners on
Xilinx’s forums.  I’d point you to the forum post so you could read these in
context, but like I mentioned above–Xilinx was apparently so upset by my
comments (copied below) that they deleted the whole discussion.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 1. Deleted!&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;a href=&quot;/img/tweets/xilinx-msg-not-found.png&quot;&gt;&lt;img src=&quot;/img/tweets/xilinx-msg-not-found.png&quot; alt=&quot;&quot; width=&quot;720&quot; /&gt;&lt;/a&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Maybe I should start recording all of my discussions from now on …&lt;/p&gt;

&lt;p&gt;The first individual to comment (sorry, his username has now been lost in the
web somewhere), shared his recommendations for a beginning designer.  In
particular, he was noting how much time you’d need to speed using the
simulator for a project, and if that was the case, why not spend your time
&lt;a href=&quot;/blog/2018/08/22/what-is-simulation.html&quot;&gt;learning to use the simulator
well&lt;/a&gt; before
purchasing a dev board?&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;For a real project, you will have no choice but to simulate the $@ out of
it because it won’t work and your physical debugging will be meaningless.  So
why not focus on that?  The HDL and simulation environment are already a lot
to learn.  Then when you literally can’t do any more without hardware, you
will be in a better position to buy a board.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;In many ways, I agree with the sentiment–but with a few caveats that I’ll share
in a moment.&lt;/p&gt;

&lt;p&gt;A well known and often very helpful user,
&lt;a href=&quot;https://forums.xilinx.com/t5/user/viewprofilepage/user-id/74556&quot;&gt;u4223374&lt;/a&gt;,
responded with his own perspective, recommending a design approach I’ll call
“Lego design”.  He writes,&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Increasingly these days an FPGA designer can get away without any hardware
knowledge.  With Xilinx (and others) providing IP cores for most of the
common interfaces, the unique processing hardware doesn’t tend to need any
external-to-the-FPGA communications at all – it just talks to the I/O IP
cores&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;… &lt;em&gt;without any hardware knowledge&lt;/em&gt;?  Incredible.  Let’s just say I disagree.&lt;/p&gt;

&lt;p&gt;After I responded, Xilinx then deleted the whole post.  The next section 
contains my response, which is what I will assume offended them.  I didn’t
copy and paste it, though, but rather fat-fingered typing it in so you might
find subtle spelling differences.  I’ve also added hyperlinks links to the
discussion for anyone wanting background information, since I’ve been scolded
by a Xilinx forum moderator for offering too many links to my blog and &lt;a href=&quot;/projects.html&quot;&gt;my
github IP&lt;/a&gt;.  Specifically, I’ve been told me
to keep the hyper-links in my forum replies at two or less.  The reply quoted
below originally had only the one link within it.&lt;/p&gt;

&lt;h2 id=&quot;my-response&quot;&gt;My Response&lt;/h2&gt;

&lt;p&gt;If you read through the forums, you’ll see that this [&lt;a href=&quot;https://forums.xilinx.com/t5/user/viewprofilepage/user-id/74556&quot;&gt;u4223374&lt;/a&gt;’s]
view doesn’t hold water.&lt;/p&gt;

&lt;p&gt;A very common question is, “Why doesn’t my design work?”  This question is
asked over and over, from those who have tried this approach, understand none
of what’s going on under the hood, and then &lt;a href=&quot;/blog/2017/05/19/fpga-hell.html&quot;&gt;can’t figure out what’s wrong with
their design&lt;/a&gt; when it doesn’t
work.  They are forever posting here [on &lt;a href=&quot;https://forums.xilinx.com&quot;&gt;Xilinx’s
forums&lt;/a&gt;] needing to be rescued, unable to &lt;a href=&quot;/digilent/2017/05/29/fft-debugging.html&quot;&gt;narrow
down the problem to the component at fault&lt;/a&gt;,
and so they tend to blame Xilinx’s cores of not working when it is their
own code at fault.&lt;/p&gt;

&lt;p&gt;While not always the case, it doesn’t help when the code block they are using
&lt;a href=&quot;//formal/2018/12/28/axilite.html&quot;&gt;actually has bugs in it already&lt;/a&gt;.  Worse, because the beginner is never taught
the fundamentals, but rather the idea that digital design is just like
connecting Legos, they have &lt;a href=&quot;/blog/2017/05/19/fpga-hell.html&quot;&gt;no idea where to even
start&lt;/a&gt; when trying to find
the problem.&lt;/p&gt;

&lt;p&gt;The problem gets worse for the designer who wants to make use of older hardware,
hardware that might no longer be supported by Xilinx.  Equivalenty, FPGA design
is often seen as a gateway to ASIC design.  If all you learn is how to connect
pre-built Lego blocks, you’re not likely to get a job where you actually need
to build something to sell.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/High-level_synthesis&quot;&gt;HLS&lt;/a&gt; was designed to make
HDL even easier.  From what I’ve seen, it only makes HDL design easier &lt;em&gt;for
the individual who already understands HDL design&lt;/em&gt; in the first place.  Many
students I know who’ve tried it
[&lt;a href=&quot;https://en.wikipedia.org/wiki/High-level_synthesis&quot;&gt;HLS&lt;/a&gt;]
have noted that small, subtle, and seemingly insignificant code changes will
take a “working” design and render it non-synthesizable.&lt;/p&gt;

&lt;p&gt;As to the recommendation from the original author,&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;I would suggest if you have no hands on experience and aren’t really itching
to see sometimes [sic] happen in a circuit that you can focus on learning
your HDL of choice and learn to write test benches to validate your designs.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;I would agree somewhat, but with caveats based upon the mistakes I’ve seen
students make who have followed this recommendation.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;I’ve seen students confuse test-bench only code, code that cannot be
synthesized, with synthesizable code.  Often students don’t even know the
difference after starting from this standpoint.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;I’ve also seen &lt;a href=&quot;/zipcpu/2017/12/28/ugliest-bug.html&quot;&gt;way too many bugs pass bench tests, only to fail in real
hardware&lt;/a&gt;.   (This
includes first and foremost my own bugs …)&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;This leaves me with two additional recommendations:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;A beginner needs to learn how to &lt;a href=&quot;/blog/2017/06/02/design-process.html&quot;&gt;debug their design in
hardware&lt;/a&gt; as well as
with the test bench–especially if his design hits hardware after only ever
seeing a testbench.  (Yes, there is a &lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;better
way&lt;/a&gt;.)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;I recommend using the synthesizer along the way.  Even if the student doesn’t
have any real hardware, it is possible to use a synthesizer to 1) recognize
unsynthesizable code, and 2) discover what kinds of code can be synthesized
within any particular clock speed and what kinds cannot.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Even better, a beginner should learn to use &lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal
methods&lt;/a&gt;.&lt;/p&gt;

    &lt;p&gt;Why?&lt;/p&gt;

    &lt;p&gt;Because &lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal
methods&lt;/a&gt; do a better
job of finding bugs than test benches alone&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Since I believe so firmly in this approach, I’ve put together a &lt;a href=&quot;/tutorial&quot;&gt;tutorial for
beginners&lt;/a&gt;.  It’s a hardware agnostic tutorial,
so you should be able to learn regardless of what hardware you have as long
as 1) You have a serial port, 2) a button, and 3) A couple of LEDs.&lt;/p&gt;

&lt;h2 id=&quot;why-would-xilinx-delete-this-comment&quot;&gt;Why would Xilinx delete this comment?&lt;/h2&gt;

&lt;p&gt;I think Xilinx is working very hard to sell the idea that hardware design is
as simple as playing with Legos: Connect this block to that block and Voila!
Magically a working design appears.  While (I hope) that this is often the
case for those who use this approach, I have a different perspective: I tend
to read the forum posts that were written by those for whom this simplified
design methodology doesn’t work.  (You might argue that my
sampling &lt;a href=&quot;https://en.wikipedia.org/wiki/Universe_(mathematics)&quot;&gt;Universe&lt;/a&gt;
is skewed as a result.)&lt;/p&gt;

&lt;p&gt;I also tend to be rather hard on Xilinx for the bugs in their example AXI
designs–those that they recommend beginners start from.
[&lt;a href=&quot;//formal/2018/12/28/axilite.html&quot;&gt;1&lt;/a&gt;]
[&lt;a href=&quot;/formal/2019/05/13/axifull.html&quot;&gt;2&lt;/a&gt;]  Sadly, these faulty
designs have caused a lot of problems for Xilinx’s users:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;One software engineer picked up from where the hardware engineer left
off–after the hardware engineer “finished” the project, delivered a
“working” design, and left the company …  This software engineer made
a very minor adjustment to his MicroBlaze code and the FPGA portion of his
design stopped working.  A key feature of his new design was a pair of
adjacent store instructions just before the design failed.  This could’ve
been caused by either of the bugs I had found in their training material
(cited above).&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Several other users have been frustrated that Xilinx’s AXI DMA core has
“caused” their design to hang.  They’ve asked how to “reset” the core, so
they can go on.&lt;/p&gt;

    &lt;p&gt;The problem here is important: AXI, by design, cannot recover from dropped
transactions.  If the master is no longer interested in the bus response,
it has no way to drop the response without resetting the entire bus or just
ignoring the response.&lt;/p&gt;

    &lt;p&gt;In the bugs I demonstrated above, transaction responses would get dropped
in their demo code.  This will cause the design (and the attached bus) to
hang–unable to be reset until a power cycle.&lt;/p&gt;

    &lt;p&gt;One solution to this problem is to use a wrapper core with some kind of
safety feature: Xilinx offers what they call an “AXI firewall” IP to check
for AXI failures and set a flag that the ILA might notice.  Of course, that
IP would be forever broken until the next reset (i.e. power cycle).  An
alternative approach is to use my own &lt;a href=&quot;https://github.com/ZipCPU/wb2axip/blob/master/rtl/axisafety.v&quot;&gt;bus fault
isolator&lt;/a&gt;,
and to configure it to reset the downstream peripheral once any error is
detected.  Sadly, while these two approaches will allow you to recover from
a fault, it may well be that a faulty core doesn’t trigger either of the
tests within these cores.  I know from my own experience, that &lt;a href=&quot;https://github.com/ZipCPU/wb2axip/blob/master/rtl/axisafety.v&quot;&gt;the logic
within my own core&lt;/a&gt;,
simplifies (and slows down) the AXI transaction, and so there’s a non-zero
likelihood that this might prevent a design from failing downstream of
this fault isolator.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;It’s not that uncommon for an engineer to post to the forum, declare
Xilinx’s code is broken, but then refuse to share his own code.&lt;/p&gt;

    &lt;p&gt;In many of these examples, I’ve asked if users will post their code so that
I can test my formal properties on their core.  While some have taken me
up on the offer, there haven’t been that many takers.  Of those who have
taken me up on the offer, verifying the code is often quite easy: since most
Xilinx users copy from Xilinx’s demo designs.  As a result, the proof is
usually as simple as one of the ones I’ve done before.  Of those who haven’t
posted their code, some have at least posted traces showing &lt;a href=&quot;/formal/2019/04/16/axi-mistakes.html&quot;&gt;dropped
acknowledgements&lt;/a&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;There are “right” and “wrong” answers to this kind of criticism.  The
&lt;a href=&quot;https://www.blueletterbible.org/kjv/jhn/3/21&quot;&gt;“right” response&lt;/a&gt; is to
1) acknowledge the problem (Yes, it’s broken), 2) identify
the problem (it does this when it should do that, it’s been broken since
2016 or whenever), 3) promise a fix, and then 4) announce when the
demonstration code works again again.  Finally, they should 5) point out to
users who might not know of the problem, that a fix has been issued.&lt;/p&gt;

    &lt;p&gt;Were they to do this, I’d either get quiet or repeat the corporate message.
Up until now, Xilinx’s has been (nearly) silent on this topic.&lt;/p&gt;

    &lt;p&gt;Not commenting is one thing, but … deleting posts?&lt;/p&gt;

    &lt;p&gt;Sadly, getting rid of the messenger doesn’t change the truth of the message.
It also leaves those who desire to build reliable designs in a lurch, since
they still don’t know why their designs are failing.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;At a glance, the problem is simply this: When a newcomer comes to the Xilinx
forums to ask &lt;a href=&quot;/blog/2019/05/29/demoaxi.html&quot;&gt;how to build an AXI
design&lt;/a&gt;, the official answer
is to point him to the demo designs.  Sadly, when I pointed one such user to
the bugs in Xilinx’s demonstration designs, they were quite disheartened.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Thank you, Dan, but I need something easier. …&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;My response below helps to highlight the core issue:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;In many ways, it’s a shame Xilinx chose AXI as their protocol for connecting
everything together.  AXI is a very complicated protocol, and a hard one to
get right.  I like to use
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;Wishbone&lt;/a&gt;, and find it
much easier to work with.  There’s also an AHB protocol that’s easier to work
with than &lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;Wishbone&lt;/a&gt;.&lt;/p&gt;

  &lt;p&gt;That said, I really don’t know any way to make this “easy” as you would like.
The complexity comes with the territory.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Sorry, folks, but we’re not building Legos here.  If you want things to work,
and to reliably work well, then you need to learn the fundamentals.  Second,
if you want to build &lt;a href=&quot;/blog/2019/05/29/demoaxi.html&quot;&gt;AXI interfaces with
confidence&lt;/a&gt;, you need &lt;a href=&quot;//formal/2018/12/28/axilite.html&quot;&gt;formal
methods&lt;/a&gt;.
Neither Xilinx’s test benches, nor their Verification IP, found the bugs
I’ve blogged about that many users have been struggling with and from.&lt;/p&gt;
&lt;hr /&gt;&lt;p&gt;&lt;em&gt;What I tell you in darkness, that speak ye in light: and what ye hear in the ear, that preach ye upon the housetops.  (Matt 10:27)&lt;/em&gt;</description>
        <pubDate>Tue, 20 Aug 2019 00:00:00 -0400</pubDate>
        <link>https://zipcpu.com/blog/2019/08/20/lego-design.html</link>
        <guid isPermaLink="true">https://zipcpu.com/blog/2019/08/20/lego-design.html</guid>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>Quiz #3: Will formal verification prove this counter keeps its bounds?</title>
        <description>
</description>
        <pubDate>Mon, 19 Aug 2019 00:00:00 -0400</pubDate>
        <link>https://zipcpu.com/quiz/2019/08/19/quiz03.html</link>
        <guid isPermaLink="true">https://zipcpu.com/quiz/2019/08/19/quiz03.html</guid>
        
        
        <category>quiz</category>
        
      </item>
    
      <item>
        <title>Planning an Intermediate Design Tutorial</title>
        <description>&lt;p&gt;I’ve been known for wandering through &lt;a href=&quot;/digilent/2017/05/18/most-common-digilent-support-requests.html&quot;&gt;an FPGA forum or two, and I’ve see some
common and reocurring
themes&lt;/a&gt;.
One of them is, “My design isn’t working and I don’t know why
not.”  It’s the reason I dedicated this blog to keeping individuals out of
“&lt;a href=&quot;/blog/2017/05/19/fpga-hell.html&quot;&gt;FPGA Hell&lt;/a&gt;” as I called it.&lt;/p&gt;

&lt;p&gt;Indeed, I saw such a post again just this morning.  Someone had a MicroBlaze
design that wasn’t starting.  It worked on an older board, but not the newer
revision of the board.  What might be wrong?&lt;/p&gt;

&lt;p&gt;If all you know is that, “My design doesn’t start,” you don’t have much to
debug from.&lt;/p&gt;

&lt;p&gt;This was one of the reasons why one of my first blog topics was how to build
a &lt;a href=&quot;/blog/2017/06/16/dbg-bus-forest.html&quot;&gt;debugging bus&lt;/a&gt;
followed by the &lt;a href=&quot;/blog/2017/07/08/getting-started-with-wbscope.html&quot;&gt;wishbone
scope&lt;/a&gt;.
Why?  Because this is how I debug problems like that.  Using the two of those,
I can typically trace anything going wrong down to a trace between two
interfaces.  At that point, you can then visually “see” what’s going on.&lt;/p&gt;

&lt;p&gt;Sadly, if all you have are the vendor tools, it’s very hard to “see” what’s
going on.  Worse, I find myself quick to blame someone else’s code when I
don’t see a problem in my own–even if I can’t figure out what the problem is.&lt;/p&gt;

&lt;p&gt;It was for this reason that I &lt;a href=&quot;/fpga-hell.html&quot;&gt;dedicated the blog&lt;/a&gt; to keeping individuals out of
“&lt;a href=&quot;/blog/2017/05/19/fpga-hell.html&quot;&gt;FPGA Hell&lt;/a&gt;”.
One of the problems associated with blogging, however, is that my articles
1) tend not to be arranged in any particular order, and 2) tend not to get
updated over time.&lt;/p&gt;

&lt;p&gt;This was my first reason for writing a &lt;a href=&quot;/tutorial&quot;&gt;beginner’s
tutorial&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The second reason for writing a &lt;a href=&quot;/tutorial/&quot;&gt;beginner’s
tutorial&lt;/a&gt; was in response to problems
I’ve seen with the more traditional instruction.  For example, I’ve seen
students confuse “testbench” constructs with “synthesizable” constructs and
then wonder why their design doesn’t work.  I’ve seen students create bench
tests that provide less test coverage of their code than “modern” swimwear.&lt;/p&gt;

&lt;p&gt;Indeed, I &lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;once had the same problem in my own
designs&lt;/a&gt;: My own test
coverage left me
&lt;a href=&quot;/zipcpu/2017/12/28/ugliest-bug.html&quot;&gt;chasing bugs in my designs over late nights, and GB traces containing the
bug&lt;/a&gt;
… somewhere … within them.  It was specifically for this reason that I
&lt;a href=&quot;/blog/2018/01/22/formal-progress.html&quot;&gt;fell in love with formal
verification&lt;/a&gt; so
quickly–it finds the bugs within your design that my own testbenches were
always missing.&lt;/p&gt;

&lt;p&gt;When no one listened to me hollering about the way I felt things “should” be
done, I decided to try writing a &lt;a href=&quot;/tutorial&quot;&gt;tutorial&lt;/a&gt;
myself to help teach what’s missing.&lt;/p&gt;

&lt;p&gt;So far, that
&lt;a href=&quot;/tutorial&quot;&gt;tutorial&lt;/a&gt;
has been well received.  Sure, I’ve had some welcome but less than flattering
comments.  Perhaps the biggest one regards
&lt;a href=&quot;/blog/2017/06/21/looking-at-verilator.html&quot;&gt;Verilator&lt;/a&gt;
and the C++ nature of the &lt;a href=&quot;/tutorial&quot;&gt;tutorial&lt;/a&gt;.
Why should C++ be required when your goal is to learn Verilog and FPGA design.
I get it.  A similar comment regards “make” files we used.  However, you can’t
do things like &lt;a href=&quot;/blog/2018/11/29/llvga.html&quot;&gt;this VGA
simulator&lt;/a&gt; without some basic
software background, and a lot of folks are coming into the FPGA community
with that background–much like me.  For them, at least, it makes sense.&lt;/p&gt;

&lt;p&gt;That said, there’s a strong need in the community for teaching materials that
will teach “From blinky to AXI,” and while &lt;a href=&quot;/tutorial&quot;&gt;my own
tutorial&lt;/a&gt; gets past blinky, it doesn’t make it
anywhere near &lt;a href=&quot;/2019/05/29/demoaxi.html&quot;&gt;AXI&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;So let me present some of my thoughts today regarding how this might be fixed.&lt;/p&gt;

&lt;h2 id=&quot;the-problem-with-the-intermediate-tutorial&quot;&gt;The problem with the intermediate tutorial&lt;/h2&gt;

&lt;p&gt;There’s a couple of reasons why I have yet to start on an intermediate FPGA
tutorial.  One is that I sell my services and … things have been quite busy
as of late.  (Sorry, but this blog is a &lt;em&gt;hobby&lt;/em&gt; of mine rather than something
that puts food on the table for my family.)  The second reason is that the
next step really requires a lot of design-ware that few students would like
to build.&lt;/p&gt;

&lt;p&gt;Allow me to explain.&lt;/p&gt;

&lt;p&gt;Many of the FPGA designs I’ve worked with involve some kind of bus master
together with several bus slaves.  The common task, then, for the FPGA designer
is to build a new bus slave.  A classic example of this might be to create a
new piece of hardware to add to a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;’s
capabilities, such as is shown in Fig. 1 below.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 1. A typical CPU based design&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/im-tutorial/tut-im-cpu.svg&quot; alt=&quot;&quot; width=&quot;480&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;The task of the student is then to build this new slave.  Perhaps he has several
such slaves he’d like to build.&lt;/p&gt;

&lt;p&gt;Were I to build this the way my mathematical background requires, I’d want
to teach everything from the bus master, to the S(D)RAM memory controller,
to the &lt;a href=&quot;/blog/2017/06/22/simple-wb-interconnect.html&quot;&gt;bus interconnect&lt;/a&gt; before the student gets to their first bus slave.
You know, learn multiplication before square roots.  In this case, that’d be …&lt;/p&gt;

&lt;p&gt;&lt;em&gt;BORING!&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;I mean, seriously, would you want to know how to build a
&lt;a href=&quot;https://www.teachengineering.org/lessons/view/cub_dams_lesson03&quot;&gt;lock and dam&lt;/a&gt;
just to go canoing on the river?&lt;/p&gt;

&lt;p&gt;Here’s another example design that’s common among FPGAs: you want to process
data, say an image perhaps.  That means you want to read the image from memory
(there’s not enough room in block RAM to store most images), process it however,
and then store it back into memory again.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 2. A basic processing pipeline&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/im-tutorial/tut-im-procbare.svg&quot; alt=&quot;&quot; width=&quot;480&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;While this might be a typical signal or image processing application, there’s
a missing piece to it: the design usually begins and ends with Matlab or, in
my case, &lt;a href=&quot;https://www.gnu.org/software/octave&quot;&gt;Octave&lt;/a&gt;.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;First, you build your design in
  &lt;a href=&quot;https://www.gnu.org/software/octave&quot;&gt;Octave&lt;/a&gt; and prove that your algorithm
  works&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Along the way, you discover how to measure the performance of your
  algorithm, and you learn how to communicate (i.e. plot) that performance.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Now you want to put it on an FPGA.  So, you build your data processing
  algorithm to put it on the FPGA.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;It’s now the big moment: As you are synthesizing your brand-new algorithm
in order to place it into an FPGA design, you suddenly realize that you
have no way of getting your data set into or out of memory.  Worse, even
if you do realize that, you have no easy way to get it in or out of
&lt;a href=&quot;https://www.gnu.org/software/octave&quot;&gt;Octave&lt;/a&gt; from your design, even if you
were to get it into memory.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;You can see the problem illustrated below in Fig. 3,&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 3. A traditional data streaming problem&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/im-tutorial/tut-im-procpipe.svg&quot; alt=&quot;&quot; width=&quot;480&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Of course, what I haven’t mentioned is that the end goal of this sort of stream
processing task is typically not to process the data within memory, but rather
to receive the data on some signal or video feed, process it, and then to
forward the output back to a similar feed.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 4. From input to output&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/im-tutorial/tut-im-procpipeio.svg&quot; alt=&quot;&quot; width=&quot;480&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Where’s the tutorial to teach that?&lt;/p&gt;

&lt;p&gt;There isn’t one (that I know of).  (I don’t really know of that many.)&lt;/p&gt;

&lt;p&gt;Hence, the reality is that a lot of individuals end up using the vendor tools
and vendor design components and have no idea what’s going wrong when they
don’t work.&lt;/p&gt;

&lt;p&gt;As an example, a recent Xilinx user wrote that he’d written a lot of data into
his Xilinx stream processor and no data ever came out.  Why not?  Eventually,
after some back and forth, he realized he’d never marked the &lt;em&gt;end&lt;/em&gt; of the
data packet.  Now, without using your own code, or at least something that’s
open source, how would you ever find a bug like that?&lt;/p&gt;

&lt;p&gt;My point in all of this is simply that, when your goal is data processing,
you don’t really want to build all of that miracle glueware shown in Fig. 3
above–just like you didn’t want to build the interconnect and the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;
shown in the example before that, in Fig. 1.&lt;/p&gt;

&lt;p&gt;Yes, I understand that most FPGA vendors provide cores and logic that can
handle all of this middle ware.  Personally, I have a couple of problems
with using these cores.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;First, and perhaps most important, if you ever need to switch hardware
  vendors, you’ll have to tear apart your design and rebuild it for the new
  cores using their new interfaces.&lt;/p&gt;

    &lt;p&gt;This includes switching design flows, even for the same hardware.  For
example, if there were an open source tool chain, would you be able to get
by without the vendor supplied cores?  How about if you wanted to use
an open source simulator, like
&lt;a href=&quot;/blog/2017/06/21/looking-at-verilator.html&quot;&gt;Verilator&lt;/a&gt;?
Know of any good &lt;a href=&quot;/2019/07/17/crossbar.html&quot;&gt;open source
interconnects&lt;/a&gt;?  Or tools to
connect your components to said open source interconnects?&lt;/p&gt;

    &lt;p&gt;Or have you not noticed that I have
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; based designs for
&lt;a href=&quot;https://github.com/ZipCPU/icozip&quot;&gt;iCE40&lt;/a&gt;,
&lt;a href=&quot;https://github.com/ZipCPU/zipversa&quot;&gt;ECP5&lt;/a&gt;,
&lt;a href=&quot;https://github.com/ZipCPU/openarty/tree/autoarty&quot;&gt;Xilinx&lt;/a&gt;, &lt;em&gt;and&lt;/em&gt;
&lt;a href=&quot;/zipcpu/2019/03/12/arrowzip.html&quot;&gt;Intel&lt;/a&gt;?  Yes, it
is doable.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Second, the purpose of the intermediate tutorial we are discussing would be
for learning.  It’s one thing to use a vendor’s core when you have a product
that’s due on a tight schedule.  Sure, I get it, go for it.  I’m not knocking
that at all.  On the other hand, if you want to learn design, then doesn’t
it make sense to spend your time learning how to build your own versions
of the basic building blocks before you turn around and use those from a
vendor?&lt;/p&gt;

    &lt;p&gt;Worse, wouldn’t it be a shame if you learned how to design using vendor
based building blocks but then … had to switch tools and discovered that
you no longer knew anything because you could no longer use the cores and
tools you were familiar with?  For example, have you ever tried simulating
Xilinx’s AXI interconnect using &lt;a href=&quot;https://www.youtube.com/watch?v=en8JMz7v3LU&quot;&gt;the fastest
simulator&lt;/a&gt;
out there?  (Hint: it’s not Vivado.)&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;My point here is simply this: there’s a need for instruction material that
goes past basic serial port I/O in a vendor independent fashion.&lt;/p&gt;

&lt;h2 id=&quot;tutorial-goals&quot;&gt;Tutorial Goals&lt;/h2&gt;

&lt;p&gt;As always, one of the goals of the tutorial is to have the widest applicability
possible.  That means it needs to share FPGA design concepts and strategies
in a vendor independent fashion.  That means I can’t really use vendor code in
my tutorial.  That includes all the vendor glueware, bus interconnects, etc.&lt;/p&gt;

&lt;p&gt;My apologies to all of you big-named vendors out there.  On the other hand,
after trying to answer questions from clueless forum posters, wouldn’t you
rather have customer’s who knew how to debug their own designs?&lt;/p&gt;

&lt;p&gt;So, here was my thought: Using entirely open source tools, so that the design
components could be verified with
&lt;a href=&quot;https://symbiyosys.readthedocs.io/en/latest&quot;&gt;SymbiYosys&lt;/a&gt; and then simulated
using &lt;a href=&quot;/blog/2017/06/21/looking-at-verilator.html&quot;&gt;Verilator&lt;/a&gt;,
create a set of lessons similar to those shown
in Fig. 5 below.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 5. Proposed intermediate tutorial structure&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/im-tutorial/tut-intermediate.svg&quot; alt=&quot;&quot; width=&quot;720&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;The lessons would use
&lt;a href=&quot;/zipcpu/2017/10/05/autofpga-intro.html&quot;&gt;AutoFPGA&lt;/a&gt;
to connect all of the parts and pieces together.  In every lesson, the goal
would be to be able to formally verify any new components, then to run the
design in a
&lt;a href=&quot;/blog/2017/06/21/looking-at-verilator.html&quot;&gt;Verilator&lt;/a&gt;
based simulation, and then in actual hardware.&lt;/p&gt;

&lt;p&gt;The lesson sequence would start out by discussing some of your basic slave
design components.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;The first lesson would start out by creating a &lt;a href=&quot;/zipcpu/2019/02/09/cpu-blinky.html&quot;&gt;very simple “blinky”
design&lt;/a&gt;,
but this time using the
&lt;a href=&quot;/zipcpu/2017/10/05/autofpga-intro.html&quot;&gt;AutoFPGA&lt;/a&gt;
generated &lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;Wishbone
bus&lt;/a&gt;.  Commands sent
from the host over the &lt;a href=&quot;/blog/2017/06/16/dbg-bus-forest.html&quot;&gt;debugging
bus&lt;/a&gt; would be used
to turn LEDs on and off.&lt;/p&gt;

    &lt;p&gt;For those who don’t recall the &lt;a href=&quot;https://github.com/ZipCPU/dbgbus/blob/master/hexbus/README.md&quot;&gt;debugging bus
articles&lt;/a&gt;, a
“&lt;a href=&quot;/blog/2017/06/16/dbg-bus-forest.html&quot;&gt;debugging bus&lt;/a&gt;” is
my term for a bus, internal to an FPGA, that can be accessed and commanded
from host (PC) software.  Even better, I like to run my &lt;a href=&quot;/blog/2017/06/16/dbg-bus-forest.html&quot;&gt;debugging
bus&lt;/a&gt; software &lt;a href=&quot;/blog/2017/06/17/why-network-debugging.html&quot;&gt;over
a network&lt;/a&gt;,
allowing me to interact with either my design or its simulation from
anywhere on my local network.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The second lesson would involve simply &lt;a href=&quot;/dsp/2017/07/11/simplest-sinewave-generator.html&quot;&gt;creating an audio
tone&lt;/a&gt;.
This would be very similar to the first lesson, but might involve a couple
of bus addresses, to allow the developer to control amplitude and frequency
from their external computer as one example.  The tone itself could be
played using a basic &lt;a href=&quot;{ site.baseurl }}/dsp/2017/09/04/pwm-reinvention.html&quot;&gt;PWM
controller&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The third lesson would be quick, just showing how to connect a &lt;a href=&quot;/zipcpu/2018/07/13/memories.html&quot;&gt;block
RAM&lt;/a&gt; to the bus as
well as how to verify RAM based slaves.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;We’d then discuss building a “&lt;a href=&quot;/blog/2017/06/08/simple-scope.html&quot;&gt;bus
scope&lt;/a&gt;”.  If you’ve
read my blog much, you’ll know that I use what I call a “&lt;a href=&quot;/blog/2017/07/08/getting-started-with-wbscope.html&quot;&gt;wishbone
scope&lt;/a&gt;”.
You’d be amazed at the &lt;a href=&quot;/2017/09/14/even-i-get-stuck.html&quot;&gt;bugs you can find and
diagnose&lt;/a&gt; using
something like this.&lt;/p&gt;

    &lt;p&gt;This is somewhat different from using vendor tools (chipscope, ILA, etc),
simply because it is bus based.  This will allow you greater control of the
scope, eventually allowing you to control it from your embedded
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;–but
we’re not there yet.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The final slave in this section of the course would be your &lt;a href=&quot;/blog/2018/08/16/spiflash.html&quot;&gt;basic xSPI
flash memory controller&lt;/a&gt;.
This could be done either with SPI or
&lt;a href=&quot;/blog/2019/03/27/qflexpress.html&quot;&gt;QSPI&lt;/a&gt;.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Voila, the first section of an intermediate Verilog tutorial.&lt;/p&gt;

&lt;p&gt;The second section of the tutorial would focus on bus masters, rather than bus
slaves.&lt;/p&gt;

&lt;ol start=&quot;6&quot;&gt;
  &lt;li&gt;It would begin with a set of lessons on creating a video output.&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;(6) The first might discuss &lt;a href=&quot;/blog/2018/11/29/llvga.html&quot;&gt;outputting a fixed test
 pattern&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;(7) That lesson would be followed with a stream processing lesson where
a “sprite” of some type would be added to the video stream.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;(8) The next lesson would be (generic) on &lt;a href=&quot;/blog/2018/07/06/afifo.html&quot;&gt;asynchronous
FIFOs&lt;/a&gt;.  Although this
is really a video independent topic, it’s really a necessary background
for the next lesson&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;(9) The final video lesson would be on how to &lt;a href=&quot;https://github.com/ZipCPU/vgasim/blob/master/rtl/wbvgaframe.v&quot;&gt;stream pixels from a (fixed)
memory location&lt;/a&gt;
to the video controller and hence to the VGA screen.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;All of this would be simulatable using
  &lt;a href=&quot;/blog/2017/06/21/looking-at-verilator.html&quot;&gt;Verilator&lt;/a&gt;.
  Perhaps painfully simulatable, but simulatable none the less.&lt;/p&gt;

&lt;ol start=&quot;10&quot;&gt;
  &lt;li&gt;
    &lt;p&gt;We’ll then move back to a quick bus slave, to learn how to &lt;a href=&quot;https://github.com/ZipCPU/wbpmic&quot;&gt;control a basic
SPI A/D controller&lt;/a&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Once we have a way to ingest samples, the next lesson would discuss how
to record samples from something like an A/D controller to memory, in order
to later be read out using the debugging bus.&lt;/p&gt;

    &lt;p&gt;At this point, you should be able to ingest your pipeline processing
algorithm into a design.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Finally, before getting into
  &lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;
  design, we’d work our way through a basic
  hardware controller–something that could read “instructions” from a memory,
  and then use them to control a hardware output.  In this case, it should be
  possible to build a basic music box–perhaps something that could play
  “&lt;a href=&quot;https://www.youtube.com/watch?v=Qwa0c8VO71s&quot;&gt;Music Box Dancer&lt;/a&gt;”?&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;That would end the basic set of lessons on building bus masters.&lt;/p&gt;

&lt;p&gt;The next group of lessons would focus on building a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;.  This would not
be about &lt;a href=&quot;https://www.amazon.com/Computer-Architecture-Quantitative-John-Hennessy/dp/012383872X&quot;&gt;ISA design&lt;/a&gt; (Sorry, I know my limits), but rather on
implementing some increasingly complex
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;s.&lt;/p&gt;

&lt;ol start=&quot;13&quot;&gt;
  &lt;li&gt;
    &lt;p&gt;The first lesson would discuss just a simple, very basic, microcontroller.
  I haven’t yet decided what ISA I’d use, or if there’s one available that has
  a nice tool suite with it, but you get the idea.&lt;/p&gt;

    &lt;p&gt;In this lesson, the student would implement such a simple
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;A &lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;
really &lt;a href=&quot;//zipcpu/2017/07/14/cpu-debugging-needs.html&quot;&gt;needs a debugging
interface&lt;/a&gt;, so
we’d add one.  This would allow us to start and stop our
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;,
using the same debugging bus that’s supported us so far, and perhaps even
read registers and state from it.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;That would lead us right into building an &lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/sw/host/zipload.cpp&quot;&gt;ELF program
loader&lt;/a&gt;.
This could be just something basic that can read a compiled file and load
it into either flash or (block) RAM.  Of course, this would also require
an ELF-based tool chain, and so likely a proper
&lt;a href=&quot;https://en.wikipedia.org/wiki/Instruction_set_architecture&quot;&gt;ISA&lt;/a&gt;
as well.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;We can then move to a lesson on &lt;a href=&quot;/zipcpu/2017/08/23/cpu-pipeline.html&quot;&gt;pipelined
CPUs&lt;/a&gt;.&lt;/p&gt;

    &lt;p&gt;This one I haven’t quite figured out yet, but I’d like to offer something
more complex than the basic state-machine based microcontroller.&lt;/p&gt;

    &lt;p&gt;While one option might be to use the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; here,
I want an option that presents some amount of learning to the
student–rather than just following a script.&lt;/p&gt;

    &lt;p&gt;Perhaps one option might be adding a special instruction (or two, or four)
to the &lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;.
Another option might be to restructure the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt; for some
purpose (such as MMU integration as an example).  We’ll see.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;How fast your CPU works is really dependent upon where it’s memory is found,
and linker scripts provide the means of adjusting where your memory is found
within your design.  We’ll discuss how to read, write, and adjust linker
scripts so you have an idea of what’s going on within your design.&lt;/p&gt;

    &lt;p&gt;The student should be able to load a CPU (either theirs or mine) so that it
runs from &lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;Flash&lt;/a&gt;, block RAM,
block ROM, or … wherever.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;This really then feeds nicely into understanding &lt;a href=&quot;/zipcpu/2018/02/12/zbasic-intro.html&quot;&gt;how a bootloader
works&lt;/a&gt;.
Once you know how to place program instructions (wherever), it’s important
to be able to copy them to where you need them.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The next lesson would focus on how to build a &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/pfcache.v&quot;&gt;cache
controller&lt;/a&gt;.
I’d provide the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; to any one
who wished to use it at this point, although I could understand why a
student might rather wish to use their own.  I’m not (yet) set on this
course of action.&lt;/p&gt;

    &lt;p&gt;Of course, as with all of these designs, part of the lesson would discuss
how to go about formally verifying the design.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Finally, we’d discuss the &lt;a href=&quot;https://en.wikipedia.org/wiki/Design_of_the_FAT_file_system&quot;&gt;FAT
filesystem&lt;/a&gt;,
so that the CPU could access files on an external &lt;a href=&quot;https://en.wikipedia.org/wiki/SD_Card&quot;&gt;SD Card&lt;/a&gt;.&lt;/p&gt;

    &lt;p&gt;Yes, the course will show how this can be done from simulation too.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;I think this progression builds nicely, one lesson upon the next, with the
bus components being built growing every more capable.  Further, while
I like this progression of lessons, I’ve noted that with all of my
tutorials students have found it valuable to pick up in the middle
as their interest and needs dictate.&lt;/p&gt;

&lt;h2 id=&quot;hardware-required&quot;&gt;Hardware required&lt;/h2&gt;

&lt;p&gt;Unlike the &lt;a href=&quot;/tutorial&quot;&gt;beginner’s tutorial&lt;/a&gt;, once we get
past lesson one, special hardware will be required for the following lessons.
Well, either that or the student might choose (instead) to build the design
in the simulator alone and just go on.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 6. Proposed hardware requirements&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/im-tutorial/generic-hw.svg&quot; alt=&quot;&quot; width=&quot;360&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Judging from the hardware we’ve discussed above, to complete all of the lessons
you’d need:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;A &lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;Flash memory&lt;/a&gt;
controller (most FPGAs have this)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;A VGA port.&lt;/p&gt;

    &lt;p&gt;While I’d love to do &lt;a href=&quot;https://en.wikipedia.org/wiki/HDMI&quot;&gt;HDMI&lt;/a&gt;,
and while HDMI isn’t really all that much more
difficult, the I/O’s required for HDMI are a touch more challenging
to do in a &lt;em&gt;generic hardware&lt;/em&gt; fashion.&lt;/p&gt;

    &lt;p&gt;Perhaps this &lt;a href=&quot;https://store.digilentinc.com/pmod-vga-video-graphics-array&quot;&gt;dual Pmod VGA
peripheral&lt;/a&gt;
would serve our purpose well here.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;While I’d like to avoid any external RAM controllers, the Video lesson
really requires a significant amount of RAM (typically external) in order
to handle streaming from a memory buffer.&lt;/p&gt;

    &lt;p&gt;This may require an AXI lesson mid-tutorial.&lt;/p&gt;

    &lt;p&gt;Perhaps the best way to handle this in an intermediate course would be to
offer vendors an opportunity to post and share how to interact with their
xDDR SDRAM controllers.  I know I have several SDRAM controllers available
to work from, and even an &lt;a href=&quot;https://github.com/ZipCPU/icozip/blob/master/rtl/icozip/sramdev.v&quot;&gt;SRAM controller&lt;/a&gt;.  I would also expect that the
&lt;a href=&quot;https://github.com/enjoy-digital/litedram&quot;&gt;litedram&lt;/a&gt; authors might be
willing to support this project as well.  (Maybe I should ask them?)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;A simple PWM based audio controller, such as might be used with &lt;a href=&quot;https://store.digilentinc.com/pmod-amp2-audio-amplifier&quot;&gt;this
  PMod audio device&lt;/a&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;A SPI based A/D.  For this, I was thinking of something similar to
  &lt;a href=&quot;http://store.digilentinc.com/pmod-mic3-mems-microphone-with-adjustable-gain&quot;&gt;Digilent’s audio
  PMod&lt;/a&gt;,
  for which I already have both &lt;a href=&quot;https://github.com/ZipCPU/wbpmic/blob/master/rtl/smpladc.v&quot;&gt;(verified) example
code&lt;/a&gt; as well
as a decent &lt;a href=&quot;https://github.com/ZipCPU/wbpmic/blob/master/bench/cpp/micnco.cpp&quot;&gt;emulator&lt;/a&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Finally, in order to use the &lt;a href=&quot;https://en.wikipedia.org/wiki/SD_Card&quot;&gt;SD
Card&lt;/a&gt;.  and read and parse a &lt;a href=&quot;https://en.wikipedia.org/wiki/Design_of_the_FAT_file_system&quot;&gt;FAT file
filesystem&lt;/a&gt;,
you’d need a design with an SD card reader on it.  My current &lt;a href=&quot;https://github.com/ZipCPU/sdspi&quot;&gt;SD card
controller&lt;/a&gt; is SPI based, so I might
start there.  On the other hand, one of my current projects is to upgrade
that controller to be fully SDIO compliant, so we might do even better.&lt;/p&gt;

    &lt;p&gt;For those that do not have an SD card on their board, there does exist
a &lt;a href=&quot;https://store.digilentinc.com/pmod-sd-full-sized-sd-card-slot&quot;&gt;PMod SD&lt;/a&gt;
which might work nicely for this purpose as well.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Sadly, not all entry level development boards have all of this hardware,
so whether or not this list is too aggressive or not is an important question.&lt;/p&gt;

&lt;h2 id=&quot;from-blinky-to-axi--wheres-the-axi&quot;&gt;“From Blinky to AXI” … where’s the AXI?&lt;/h2&gt;

&lt;p&gt;So I started by saying that a tutorial “From Blinky to AXI” would be a valuable
contribution.  Sadly, the proposed tutorial above doesn’t (yet) discuss
&lt;a href=&quot;/blog/2019/05/29/demoaxi.html&quot;&gt;AXI&lt;/a&gt;.
I haven’t quite decided on how to handle that.&lt;/p&gt;

&lt;p&gt;I could leave the AXI work for a future “AXI only” tutorial, or I might work
it into this tutorial, or I might just leave it within the
&lt;a href=&quot;/blog/2019/05/29/demoaxi.html&quot;&gt;blog&lt;/a&gt;.
Another approach might be to provide the bus with a &lt;a href=&quot;https://github.com/ZipCPU/wb2axip/blob/master/rtl/wb2axilite.v&quot;&gt;WB to AXI-lite
bridge&lt;/a&gt;, and
then to make all of the devices using
&lt;a href=&quot;/blog/2019/01/12/demoaxilite.html&quot;&gt;AXI-lite&lt;/a&gt;.
I’m not quite certain right now.&lt;/p&gt;

&lt;p&gt;I am open to ideas, if you’d like to share them.&lt;/p&gt;

&lt;h2 id=&quot;conclusions&quot;&gt;Conclusions&lt;/h2&gt;

&lt;p&gt;Whew!  While I like this overview of what would be next, I’m not certain any
(potential) students would be interested in something quite this intensive.&lt;/p&gt;

&lt;p&gt;I’d love to hear your thoughts.  I intend to create a &lt;a href=&quot;https://www.reddit.com/r/ZipCPU/comments/crbyrw/planning_an_intermediate_design_tutorial/&quot;&gt;Reddit post&lt;/a&gt;
with this article, and hear any comments that might be shared.  Feel free to
join in the discussion.&lt;/p&gt;

&lt;p&gt;My own first thought is to note that, while
&lt;a href=&quot;/zipcpu/2017/10/05/autofpga-intro.html&quot;&gt;AutoFPGA&lt;/a&gt;
handles multiple slave integration easily, it doesn’t (yet) handle multiple
masters.  The good news is that I’m going to have to fix that already for
a contract I’m working on, so that’s likely to get fixed quickly.&lt;/p&gt;

&lt;p&gt;Of course, all of this would only be if the &lt;a href=&quot;https://www.blueletterbible.org/kjv/jas/4/15&quot;&gt;Lord
wills&lt;/a&gt;–so we’ll have to see
if any of this ever gets off of the ground in the first place, but your
thoughts would be welcome either way.&lt;/p&gt;
&lt;hr /&gt;&lt;p&gt;&lt;em&gt;And whatsoever ye do in word or deed, do all in the name of the Lord Jesus, giving thanks to God and the Father by him. (Col 3:17)&lt;/em&gt;</description>
        <pubDate>Fri, 16 Aug 2019 00:00:00 -0400</pubDate>
        <link>https://zipcpu.com/blog/2019/08/16/intermediate.html</link>
        <guid isPermaLink="true">https://zipcpu.com/blog/2019/08/16/intermediate.html</guid>
        
        
        <category>blog</category>
        
      </item>
    
  </channel>
</rss>
