<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>The ZipCPU by Gisselquist Technology</title>
    <description>The ZipCPU blog, featuring how to discussions of FPGA and soft-core CPU design.  This site will be focused on Verilog solutions, using exclusively OpenSource IP products for FPGA design.  Particular focus areas include topics often left out of more mainstreeam FPGA design courses such as how to debug an FPGA design.
</description>
    <link>http://zipcpu.com/</link>
    <atom:link href="http://zipcpu.com/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Sun, 11 Mar 2018 21:29:36 -0400</pubDate>
    <lastBuildDate>Sun, 11 Mar 2018 21:29:36 -0400</lastBuildDate>
    <generator>Jekyll v3.0.1</generator>
    <image>
      <url>http://zipcpu.com/img/gt-rss.png</url>
      <title></title>
      <link></link>
    </image>
    
      <item>
        <title>An Exercise in using Formal Induction</title>
        <description>&lt;p&gt;In many ways I’m still quite the beginner when it comes to proving designs
using &lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal methods&lt;/a&gt;:
I’ve only used
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal methods&lt;/a&gt;
for about about five months.  However, over those five months I’ve found
so many bugs in my “&lt;em&gt;working&lt;/em&gt;” code that I’ve started using
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal methods&lt;/a&gt;
for every new component and design I’ve built since.&lt;/p&gt;

&lt;p&gt;I’ve also found myself counseling others on the
&lt;a href=&quot;https://irclog.whitequark.org/yosys&quot;&gt;#yosys&lt;/a&gt;
&lt;a href=&quot;https://freenode.net&quot;&gt;IRC forum&lt;/a&gt;.  It’s been rather strange, though, since
I very much feel as though I myself am quite the beginner, and yet I’m
answering questions and explaining things as though I’d been doing this
for years.&lt;/p&gt;

&lt;p&gt;I haven’t.&lt;/p&gt;

&lt;p&gt;However, I’d like to share with you today an &lt;a href=&quot;/examples/kitest.v&quot;&gt;example
piece&lt;/a&gt; of code that really
taught me a lot about
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal methods&lt;/a&gt;,
and in particular about the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Mathematical_induction&quot;&gt;induction&lt;/a&gt; step.
It’s come up recently as I’ve tried to explain
&lt;a href=&quot;https://en.wikipedia.org/wiki/Mathematical_induction&quot;&gt;induction&lt;/a&gt;
to someone with even less experience than I have, and I’ve found that it
makes a good and simple example to learn from.&lt;/p&gt;

&lt;p&gt;I’ll be honest–my own mentors haven’t thought that much of the
&lt;a href=&quot;/examples/kitest.v&quot;&gt;example below&lt;/a&gt;.  Their response
has been something like, “Oh, yes, of course.” Yet to me, I’ve found
&lt;a href=&quot;/examples/kitest.v&quot;&gt;this example&lt;/a&gt;
to be &lt;em&gt;very&lt;/em&gt; instructive.&lt;/p&gt;

&lt;h2 id=&quot;the-example-code&quot;&gt;The Example Code&lt;/h2&gt;

&lt;p&gt;The &lt;a href=&quot;/examples/kitest.v&quot;&gt;basic example&lt;/a&gt;
consists of two shift registers, &lt;code class=&quot;highlighter-rouge&quot;&gt;sa&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;sb&lt;/code&gt;, although
the example would also work if you were comparing &lt;a href=&quot;/blog/2017/10/27/lfsr.html&quot;&gt;Fibonacci versus Galois
linear feedback shift registers
(LFSR)s&lt;/a&gt;–it just wouldn’t be
nearly as clear.  However, the example does require that the two
shift register outputs need to be identical.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 1. Two identical shift registers&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/kitest.svg&quot; alt=&quot;&quot; width=&quot;480&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;We’ll allow our two shift registers to have a parameterized
length, &lt;code class=&quot;highlighter-rouge&quot;&gt;LN&lt;/code&gt;, although for the purposes of today’s discussion we’ll only
set this length to a constant 16, &lt;code class=&quot;highlighter-rouge&quot;&gt;LN=16&lt;/code&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;module	kitest(i_clk, i_reset, i_ce, i_in, o_bit);
	parameter		LN=16;
	//
	input	wire		i_clk, i_reset, i_ce, i_in;
	output	wire		o_bit;

	reg	[(LN-1):0]	sa, sb;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;For this example to be instructive, both shift registers must have &lt;em&gt;identical&lt;/em&gt;
logic.  Therefore, we’ll initialize both registers to zero.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	initial	sa = 0;
	initial	sb = 0;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;We’ll clear both registers on any synchronous reset.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(posedge i_clk)
	if (i_reset)
	begin
		sa &amp;lt;= 0;
		sb &amp;lt;= 0;
	end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Finally, any time &lt;code class=&quot;highlighter-rouge&quot;&gt;i_ce&lt;/code&gt; is true, the input value will be placed into the
least significant bit (LSB) of each shift register, while we shift the rest
of the register to the left.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	else if (i_ce)
	begin
		sa &amp;lt;= { sa[(LN-2):0], i_in };
		sb &amp;lt;= { sb[(LN-2):0], i_in };
	end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;In all other clocks, &lt;code class=&quot;highlighter-rouge&quot;&gt;sa&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;sb&lt;/code&gt; will remain unchained.&lt;/p&gt;

&lt;p&gt;Our &lt;a href=&quot;/examples/kitest.v&quot;&gt;example&lt;/a&gt;
needs an output, so let’s set our output value to be the
exclusive OR of the most significant bits in each register.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	assign	o_bit = sa[LN-1] ^ sb[LN-1];&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;If these two shift registers are truly identical, then we should be able to
assert this fact to the
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal&lt;/a&gt;
solver, as in:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;`ifdef	FORMAL
	assert property(!o_bit);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;If you stop here and try to prove this one property,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;`endif
endmodule&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;it will pass a bounded model check, but not
&lt;a href=&quot;https://en.wikipedia.org/wiki/Mathematical_induction&quot;&gt;induction&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Once I understood why
&lt;a href=&quot;/examples/kitest.v&quot;&gt;this simple design&lt;/a&gt;
struggled with
&lt;a href=&quot;https://en.wikipedia.org/wiki/Mathematical_induction&quot;&gt;induction&lt;/a&gt;,
I was suddenly able to figure out why various designs were struggling with
&lt;a href=&quot;https://en.wikipedia.org/wiki/Mathematical_induction&quot;&gt;induction&lt;/a&gt;,
and I then understood how to deal with it.  Therefore, let’s
spend the rest of this article discussing the difficulty with
&lt;a href=&quot;/examples/kitest.v&quot;&gt;this design&lt;/a&gt;,
and also how we might go about solving it.&lt;/p&gt;

&lt;h2 id=&quot;running-symbiyosys&quot;&gt;Running SymbiYosys&lt;/h2&gt;

&lt;p&gt;If you have &lt;a href=&quot;https://symbiyosys.readthedocs.io/en/latest&quot;&gt;SymbiYosys&lt;/a&gt;
installed, then all it takes is a
&lt;a href=&quot;/examples/kitest.sby&quot;&gt;very simple script&lt;/a&gt; to run this test.
Since adjusting parameters is fairly easy with
&lt;a href=&quot;https://symbiyosys.readthedocs.io/en/latest&quot;&gt;SymbiYosys&lt;/a&gt;, we’ll use it for
our tests today.&lt;/p&gt;

&lt;p&gt;There are four basic parts to any
&lt;a href=&quot;https://symbiyosys.readthedocs.io/en/latest&quot;&gt;SymbiYosys&lt;/a&gt;
script: the options, the formal engine, the
&lt;a href=&quot;http://www.clifford.at/yosys&quot;&gt;yosys&lt;/a&gt;
script, and the list of component files involved.&lt;/p&gt;

&lt;p&gt;In our case, we’ll want to use the formal mode &lt;em&gt;prove&lt;/em&gt;.  This will run both
the bounded model checker (BMC), &lt;em&gt;and&lt;/em&gt; the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Mathematical_induction&quot;&gt;induction&lt;/a&gt; engine.
Other modes I’ve worked with include &lt;em&gt;bmc&lt;/em&gt;, which just runs the bounded
model checker, and &lt;em&gt;cover&lt;/em&gt;, which checks cover properties. 
&lt;a href=&quot;https://symbiyosys.readthedocs.io/en/latest&quot;&gt;SymbiYosys&lt;/a&gt;
also supports a mode for checking liveness, called mode &lt;em&gt;live&lt;/em&gt;, but I have
yet to try that mode.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;[options]
mode prove&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 2. Forall time proofs have two parts&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/formal-forall-time.svg&quot; alt=&quot;&quot; width=&quot;240&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;We’ll also be adjusting the depth of the proof.  This is the number of logic
steps the formal solver uses to test our design.  In &lt;em&gt;bmc&lt;/em&gt; mode, this will
be the number of clock cycles, measured from the beginning of time, that
are checked for any assertion failures.  For the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Mathematical_induction&quot;&gt;induction&lt;/a&gt; step, in
&lt;em&gt;prove&lt;/em&gt; mode, this will decide the number of clock cycles for both the &lt;em&gt;bmc&lt;/em&gt;
pass and the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Mathematical_induction&quot;&gt;induction&lt;/a&gt; pass.  For
the &lt;a href=&quot;https://en.wikipedia.org/wiki/Mathematical_induction&quot;&gt;induction&lt;/a&gt; pass,
all but the last cycle will assume your &lt;code class=&quot;highlighter-rouge&quot;&gt;assert&lt;/code&gt;’s are true.  On the last cycle,
however, the formal engine will try to find one example where it can show that
an assertion fails.&lt;/p&gt;

&lt;p&gt;In my initial
&lt;a href=&quot;https://symbiyosys.readthedocs.io/en/latest&quot;&gt;SymbiYosys&lt;/a&gt;
&lt;a href=&quot;/examples/kitest.sby&quot;&gt;script&lt;/a&gt;,
I’ll set this depth to 31.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;depth 31&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;As I mentioned, we’ll be adjusting this value during today’s
&lt;a href=&quot;/examples/kitest.v&quot;&gt;exercise&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;We’ll also need to specify which formal solving engine we want to use.  In
this case, the &lt;a href=&quot;http://yices.csl.sri.com&quot;&gt;yices&lt;/a&gt;
engine will work quite nicely.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;[engines]
smtbmc yices&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Other engines are available, and may produce different results.&lt;/p&gt;

&lt;p&gt;We’ll then provide
&lt;a href=&quot;https://symbiyosys.readthedocs.io/en/latest&quot;&gt;SymbiYosys&lt;/a&gt;
with a very simple set of
&lt;a href=&quot;http://www.clifford.at/yosys&quot;&gt;yosys&lt;/a&gt;
commands to build &lt;a href=&quot;/examples/kitest.v&quot;&gt;our test&lt;/a&gt;,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;[script]
read_verilog -formal kitest.v
prep -top kitest

[files]
kitest.v&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Be aware when you are working with
&lt;a href=&quot;https://symbiyosys.readthedocs.io/en/latest&quot;&gt;SymbiYosys&lt;/a&gt;
that the &lt;code class=&quot;highlighter-rouge&quot;&gt;[files]&lt;/code&gt; section
will specify where your source files are coming from.
&lt;a href=&quot;https://symbiyosys.readthedocs.io/en/latest&quot;&gt;SymbiYosys&lt;/a&gt; will then copy
these files to a working directory before running
&lt;a href=&quot;http://www.clifford.at/yosys&quot;&gt;yosys&lt;/a&gt;,
so the &lt;code class=&quot;highlighter-rouge&quot;&gt;read_verilog&lt;/code&gt; command within the
&lt;a href=&quot;http://www.clifford.at/yosys&quot;&gt;yosys&lt;/a&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;[script]&lt;/code&gt; section will reference all files
from within the current directory where
&lt;a href=&quot;https://symbiyosys.readthedocs.io/en/latest&quot;&gt;SymbiYosys&lt;/a&gt; placed them.&lt;/p&gt;

&lt;p&gt;Let’s save this script to a file,
&lt;a href=&quot;/examples/kitest.sby&quot;&gt;kitest.sby&lt;/a&gt;.
Put together, the whole
&lt;a href=&quot;https://symbiyosys.readthedocs.io/en/latest&quot;&gt;SymbiYosys&lt;/a&gt;
&lt;a href=&quot;/examples/kitest.sby&quot;&gt;script&lt;/a&gt;
will look like,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;[options]
mode prove
depth 31

[engines]
smtbmc yices

[script]
read_verilog -formal kitest.v
prep -top kitest

[files]
kitest.v&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Assuming you have
&lt;a href=&quot;https://symbiyosys.readthedocs.io/en/latest&quot;&gt;SymbiYosys&lt;/a&gt;,
&lt;a href=&quot;http://www.clifford.at/yosys&quot;&gt;yosys&lt;/a&gt;, and
&lt;a href=&quot;http://yices.csl.sri.com&quot;&gt;yices&lt;/a&gt;
installed, then all it then takes to run
&lt;a href=&quot;https://symbiyosys.readthedocs.io/en/latest&quot;&gt;SymbiYosys&lt;/a&gt;
is the command,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span class=&quot;gp&quot;&gt;% &lt;/span&gt;sby -f kitest.sby&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Pay attention to the last line returned by
&lt;a href=&quot;https://symbiyosys.readthedocs.io/en/latest&quot;&gt;SymbiYosys&lt;/a&gt;.  If all goes
well, you’ll get the line:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;SBY [kitest] DONE (PASS, rc=0)&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;However, if our design passes BMC (which it will) but
fails &lt;a href=&quot;https://en.wikipedia.org/wiki/Mathematical_induction&quot;&gt;induction&lt;/a&gt;, then
this last line will instead read,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;SBY [kitest] DONE (UNKNOWN, rc=4)&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;In the next section, we’ll look at what happens when we apply
&lt;a href=&quot;https://symbiyosys.readthedocs.io/en/latest&quot;&gt;SymbiYosys&lt;/a&gt;
to &lt;a href=&quot;/examples/kitest.v&quot;&gt;our example&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;exploring-what-happens&quot;&gt;Exploring what happens&lt;/h2&gt;

&lt;p&gt;Let’s spend some time exploring what happens within
&lt;a href=&quot;/examples/kitest.v&quot;&gt;this example design&lt;/a&gt;, and see what
it will take to get us to fully prove our property that the output bit will
always be zero.&lt;/p&gt;

&lt;p&gt;We’ll start out by describing a set of tests, each containing a different
approach to handling this problem.  We’ll use the local parameter
&lt;code class=&quot;highlighter-rouge&quot;&gt;FORMAL_TEST&lt;/code&gt; to select from among several possible options for proving
this.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	localparam [2:0]	FORMAL_TEST = 3&#39;b001;

	generate if (FORMAL_TEST == 3&#39;b000)
	begin

		always @(*)
			assume(i_ce);

	end else if (FORMAL_TEST == 3&#39;b001)
	begin

		// No extra logic

	end else if (FORMAL_TEST == 3&#39;b010)
	begin

		assert property(sa == sb);

	end else if (FORMAL_TEST == 3&#39;b011)
	begin

		always @(posedge i_clk)
		if (!$past(i_ce))
			assume(i_ce);

	end else if (FORMAL_TEST == 3&#39;b100)
	begin

		always @(posedge i_clk)
		if ((!$past(i_ce))&amp;amp;&amp;amp;(!$past(i_ce,2)))
			assume(i_ce);

	// else
	//	No formal logic
	end endgenerate&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Now, let’s work our way through these tests, shall we?&lt;/p&gt;

&lt;p&gt;When &lt;code class=&quot;highlighter-rouge&quot;&gt;FORMAL_TEST&lt;/code&gt; is zero, the test passes–much as we might expect.
Since it does pass, there’s no trace generated to examine and we can move
on.  We’ll come back to this, though, in a moment.&lt;/p&gt;

&lt;p&gt;When &lt;code class=&quot;highlighter-rouge&quot;&gt;FORMAL_TEST&lt;/code&gt; is set to &lt;code class=&quot;highlighter-rouge&quot;&gt;3&#39;b001&lt;/code&gt;, however, the test fails.  Why would
this be?  It doesn’t make sense, right?  I mean, if you look at the
&lt;a href=&quot;/examples/kitest.v&quot;&gt;code&lt;/a&gt;,
you can clearly (by examination) tell that &lt;code class=&quot;highlighter-rouge&quot;&gt;sa==sb&lt;/code&gt;, and so there must be
something wrong with the
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal methods&lt;/a&gt;,
therefore, if it can’t tell that these two are equal.&lt;/p&gt;

&lt;p&gt;Well, not quite.  Let’s dig a little deeper.&lt;/p&gt;

&lt;p&gt;In particular, let’s pull up the trace associated with this failure.  If
you look through the
&lt;a href=&quot;https://symbiyosys.readthedocs.io/en/latest&quot;&gt;SymbiYosys&lt;/a&gt;
output, you’ll find the line ending with&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;.... Writing trace to VCD file: engine_0/trace_induct.vcd&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;We can open &lt;code class=&quot;highlighter-rouge&quot;&gt;trace_induct.vcd&lt;/code&gt; in &lt;a href=&quot;http://gtkwave.sourceforge.net&quot;&gt;GTKWave&lt;/a&gt;
and look at what’s going on here.  You’ll find this file in the
&lt;code class=&quot;highlighter-rouge&quot;&gt;kitest/engine_0&lt;/code&gt; directory where
&lt;a href=&quot;https://symbiyosys.readthedocs.io/en/latest&quot;&gt;SymbiYosys&lt;/a&gt;
placed it.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 3. Induction fails&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/kitest-2.png&quot; alt=&quot;&quot; width=&quot;911&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;If you look through the trace, you’ll notice that &lt;code class=&quot;highlighter-rouge&quot;&gt;sa&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;sb&lt;/code&gt; are
indeed different.&lt;/p&gt;

&lt;p&gt;What?  How can this be?&lt;/p&gt;

&lt;p&gt;To understand this, you need to understand a bit about how formal
&lt;a href=&quot;https://en.wikipedia.org/wiki/Mathematical_induction&quot;&gt;induction&lt;/a&gt; works.
The &lt;a href=&quot;https://en.wikipedia.org/wiki/Mathematical_induction&quot;&gt;induction&lt;/a&gt; step
works by picking random initial values for every registered signal within
the design.  Well, okay, that’s not quite right.  The values aren’t truly
chosen &lt;em&gt;randomly&lt;/em&gt;, they are actually chosen &lt;em&gt;exhaustively&lt;/em&gt;.  Were they chosen
randomly, it might be possible to miss some choices that would cause the design
to fail.  The benefit of formal, however, is that it will try every possible
combination in order to find one that will cause  your design to fail.
To you as a developer looking at the traces through your code, it might feel
like these values are chosen &lt;em&gt;randomly&lt;/em&gt;, although there’s actually a method
to this madness.&lt;/p&gt;

&lt;p&gt;Either way, the engine knows nothing about whether or not the design could
ever achieve the initial values it chooses.  It only knows whether or not any
of these violate any assumptions or assertions.&lt;/p&gt;

&lt;p&gt;For the first 31 steps of this test, the only constraint upon &lt;code class=&quot;highlighter-rouge&quot;&gt;sa&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;sb&lt;/code&gt; is
that their most significant bits are equal.  The engine has kept this true for
us.  Nothing in &lt;a href=&quot;/examples/kitest.v&quot;&gt;our example&lt;/a&gt;
constrains the rest of the shift register, either &lt;code class=&quot;highlighter-rouge&quot;&gt;sa[LN-2:0]&lt;/code&gt; or &lt;code class=&quot;highlighter-rouge&quot;&gt;sb[LN-2:0]&lt;/code&gt;,
so those values can be anything.&lt;/p&gt;

&lt;p&gt;Then, in step 31, the engine chooses to set &lt;code class=&quot;highlighter-rouge&quot;&gt;i_ce&lt;/code&gt; high.  This forces a
comparison between &lt;code class=&quot;highlighter-rouge&quot;&gt;sa[LN-1]&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;sb[LN-1]&lt;/code&gt; on step 32, where the comparison
(which is formed by our assertion) fails.&lt;/p&gt;

&lt;p&gt;This is obviously not what we want, so
what can we do to fix this?  The most obvious answer is to
assert that &lt;code class=&quot;highlighter-rouge&quot;&gt;sa==sb&lt;/code&gt;.  This is &lt;code class=&quot;highlighter-rouge&quot;&gt;FORMAL_TEST&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;3&#39;b010&lt;/code&gt;.  This test passes
very quickly, with little fanfare.  This works.&lt;/p&gt;

&lt;p&gt;What else might we do?&lt;/p&gt;

&lt;p&gt;Suppose we went back and examined our first test again, with our depth
set to 15 instead of 31.  You’ll need to adjust the depth option within the
&lt;a href=&quot;https://symbiyosys.readthedocs.io/en/latest&quot;&gt;SymbiYosys&lt;/a&gt;
&lt;a href=&quot;/examples/kitest.sby&quot;&gt;configuration script&lt;/a&gt;
to do this.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;depth 15&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;As before, we can pull up the trace to see what happened.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 4. Induction fails, where it succeeded before&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/kitest-0.png&quot; alt=&quot;&quot; width=&quot;918&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;In this trace, &lt;code class=&quot;highlighter-rouge&quot;&gt;sa&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;sb&lt;/code&gt; are different again.  This time,
though, the difference starts out in bit zero on the first timestep (not shown).
On every clock following, this one differing bit moves one step closer to our
assertion that the most significant bits of &lt;code class=&quot;highlighter-rouge&quot;&gt;sa&lt;/code&gt; and&lt;code class=&quot;highlighter-rouge&quot;&gt;sb&lt;/code&gt; are identical.  As
this assertion is applied in the first 15 steps, it is applied as an
assumption–forcing the fifteen most significant bits of &lt;code class=&quot;highlighter-rouge&quot;&gt;sa&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;sb&lt;/code&gt; to be
identical.  However, on step 16, the assertion
is treated not as an assumption but rather as a full-blown assertion.
This time it fails, because we never told the formal engine that bits zero
in both shift registers were initially identical.&lt;/p&gt;

&lt;p&gt;This suggests that this test will pass for a depth of 16.  Feel free to try
that one on your own.&lt;/p&gt;

&lt;p&gt;Now let’s move on and try &lt;code class=&quot;highlighter-rouge&quot;&gt;FORMAL_TEST&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;3&#39;b011&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;In this test, &lt;code class=&quot;highlighter-rouge&quot;&gt;i_ce&lt;/code&gt; is never allowed to be zero for two clocks in a row.
It is allowed to be true on every clock, or to alternate between true and
false, or some combination between the two.&lt;/p&gt;

&lt;p&gt;Let’s make one more change as well.  We’ll set the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Mathematical_induction&quot;&gt;induction&lt;/a&gt;
depth to 30 steps in &lt;a href=&quot;/examples/kitest.sby&quot;&gt;kitest.sby&lt;/a&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;depth 30&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This test also fails.&lt;/p&gt;

&lt;p&gt;As before, we can pull up the trace to see what happened.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 5. Induction fails, i_ce is now true every other step&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/kitest-3.png&quot; alt=&quot;&quot; width=&quot;915&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;This looks very much like the last test that failed: both failed because the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Mathematical_induction&quot;&gt;induction&lt;/a&gt; engine
allowed &lt;code class=&quot;highlighter-rouge&quot;&gt;sa&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;sb&lt;/code&gt; to start out with different least significant bit.&lt;/p&gt;

&lt;p&gt;The only thing that’s different here is &lt;code class=&quot;highlighter-rouge&quot;&gt;i_ce&lt;/code&gt;.  In this case, the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Mathematical_induction&quot;&gt;induction&lt;/a&gt;
engine has chosen to alternate &lt;code class=&quot;highlighter-rouge&quot;&gt;i_ce&lt;/code&gt; with high and low.
Why?  Because the alternating &lt;code class=&quot;highlighter-rouge&quot;&gt;i_ce&lt;/code&gt; value pushes the assertion regarding
this bit far enough forward in formal steps that the proof now fails.&lt;/p&gt;

&lt;p&gt;However, it failed on the &lt;em&gt;last&lt;/em&gt; step.  I know,
&lt;a href=&quot;https://en.wikipedia.org/wiki/Mathematical_induction&quot;&gt;induction&lt;/a&gt;
always only ever fails on its last step.  That’s not what I mean.  What I mean
is that if we just extend the search depth by one clock,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;depth 31&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;then this test will pass.&lt;/p&gt;

&lt;p&gt;The last test, &lt;code class=&quot;highlighter-rouge&quot;&gt;FORMAL_TEST&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;3&#39;b100&lt;/code&gt;, is very similar to test &lt;code class=&quot;highlighter-rouge&quot;&gt;3b011&lt;/code&gt;.  I’ll
leave this one as homework for you.&lt;/p&gt;

&lt;p&gt;I’ll also leave as homework for you the task of insisting that &lt;code class=&quot;highlighter-rouge&quot;&gt;i_ce&lt;/code&gt; is
true at least one of every eight clocks cycles.  How many induction steps will
that take to succeed?&lt;/p&gt;

&lt;p&gt;I like this example, because it does a good job fleshing out how the
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Mathematical_induction&quot;&gt;induction&lt;/a&gt; proof
works.&lt;/p&gt;

&lt;p&gt;Reality turns out to be very similar to this example, although it never looks
as simple.  In most of the designs I’ve worked with, there’s always been some
amount of state that I can’t quite capture with a proper &lt;code class=&quot;highlighter-rouge&quot;&gt;assert&lt;/code&gt; statement.
By using a longer
&lt;a href=&quot;https://en.wikipedia.org/wiki/Mathematical_induction&quot;&gt;induction&lt;/a&gt;
length, though, I can often force the state within my designs to flush itself.&lt;/p&gt;

&lt;p&gt;Even this doesn’t always work.&lt;/p&gt;

&lt;p&gt;You may remember &lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;my discussion of the formal
properties&lt;/a&gt;
of a &lt;a href=&quot;/doc/wbspec_b4.pdf&quot;&gt;wishbone
bus&lt;/a&gt;.  Nothing within &lt;a href=&quot;/doc/wbspec_b4.pdf&quot;&gt;the
specification&lt;/a&gt;
forces a slave to drop its &lt;code class=&quot;highlighter-rouge&quot;&gt;STALL&lt;/code&gt; output to accept a new request within a
given number of cycles.  Likewise, nothing within the specification forces
a slave to respond to the request by raising the &lt;code class=&quot;highlighter-rouge&quot;&gt;ACK&lt;/code&gt; signal within a
given number of clock cycles.  This creates a possibility where there may
be some amount of hidden state.  In order to deal with that possibility,
just like we forced &lt;code class=&quot;highlighter-rouge&quot;&gt;i_ce&lt;/code&gt; to be high at least one in &lt;code class=&quot;highlighter-rouge&quot;&gt;N&lt;/code&gt; clock cycles, &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/ex/fwb_master.v&quot;&gt;I
would force&lt;/a&gt;
the stall line, &lt;code class=&quot;highlighter-rouge&quot;&gt;STALL&lt;/code&gt;, to be dropped if it was ever asserted for too long.
In a similar fashion, &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/ex/fwb_slave.v&quot;&gt;I would
prevent&lt;/a&gt;
the slave from waiting too many clock cycles before acknowledging a request.&lt;/p&gt;

&lt;h2 id=&quot;other-approaches&quot;&gt;Other Approaches&lt;/h2&gt;

&lt;p&gt;If you have a chance to try some other formal engines, you may find they
work better in this example.
For example, the pdr engine,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt; 
[engines]
abc pdr&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;a href=&quot;https://arieg.bitbucket.io/avy&quot;&gt;avy&lt;/a&gt;,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt; 
[engines]
aiger avy&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;and &lt;a href=&quot;https://bitbucket.org/sterin/super_prove_build&quot;&gt;suprove&lt;/a&gt;&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt; 
[engines]
aiger suprove&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;don’t seem to struggle with this problem.&lt;/p&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Mathematical_induction&quot;&gt;Induction&lt;/a&gt;
may be the more difficult step of using
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal methods&lt;/a&gt;.
It need not be, but you need to understand how it works in order to understand
the reasons while it might fail.  The
&lt;a href=&quot;/examples/kitest.v&quot;&gt;example above&lt;/a&gt; is, in my estimation,
simple enough to show the difficulties with
&lt;a href=&quot;https://en.wikipedia.org/wiki/Mathematical_induction&quot;&gt;induction&lt;/a&gt;.
If you understand the details of
&lt;a href=&quot;/examples/kitest.v&quot;&gt;this example&lt;/a&gt;,
this example, you should be ready to fully formally prove
your own designs.&lt;/p&gt;
&lt;hr /&gt;&lt;p&gt;&lt;em&gt;And thine house and thy kingdom shall be established for ever before thee: thy throne shall be established for ever. (2Sam 7:16)&lt;/em&gt;</description>
        <pubDate>Sat, 10 Mar 2018 00:00:00 -0500</pubDate>
        <link>http://zipcpu.com/blog/2018/03/10/induction-exercise.html</link>
        <guid isPermaLink="true">http://zipcpu.com/blog/2018/03/10/induction-exercise.html</guid>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>Want to use ZBasic?  Let&#39;s have some fun--no actual FPGA required!</title>
        <description>&lt;p&gt;Now that
&lt;a href=&quot;/zipcpu/2018/01/31/cpu-build.html&quot;&gt;you’ve seen&lt;/a&gt; the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; by itself, and now that &lt;a href=&quot;/zipcpu/2018/01/31/cpu-build.html&quot;&gt;you’ve
built its tool chain&lt;/a&gt;,
let’s look at together at what you can do with the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
as part of a larger design:
&lt;a href=&quot;https://github.com/ZipCPU/zbasic&quot;&gt;ZBasic&lt;/a&gt;.
Today, I’d like to show you how to run the
&lt;a href=&quot;https://github.com/ZipCPU/zbasic&quot;&gt;ZBasic&lt;/a&gt;
design within a
&lt;a href=&quot;https://www.veripool.org/wiki/verilator&quot;&gt;Verilator&lt;/a&gt;-based
simulation environment–one that simulates
a &lt;a href=&quot;https://www.opencores.org/project,wbqspiflash&quot;&gt;QSPI flash&lt;/a&gt;, a
&lt;a href=&quot;https://github.com/ZipCPU/wbuart32&quot;&gt;serial port&lt;/a&gt;, and even
(optionally) an
&lt;a href=&quot;https://github.com/ZipCPU/sdspi/blob/master/bench/cpp/sdspisim.cpp&quot;&gt;SD-Card&lt;/a&gt;.
If all goes well, we’ll run the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;’s
&lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/sw/board/cputest.c&quot;&gt;CPU-Test program&lt;/a&gt;,
and then even play
&lt;a href=&quot;https://github.com/ZipCPU/tttt&quot;&gt;4x4x4 Tic-tac-toe&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;But first, let’s start with a little history.&lt;/p&gt;

&lt;h2 id=&quot;why-zbasic&quot;&gt;Why ZBasic?&lt;/h2&gt;

&lt;p&gt;When I first started out with the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;,
my goal was to demonstrate it on a cheap hobbyist board.  After my first
development, on a &lt;a href=&quot;https://store.digilentinc.com&quot;&gt;Digilent&lt;/a&gt;
&lt;a href=&quot;https://store.digilentinc.com/basys-3-artix-7-fpga-trainer-board-recommended-for-introductory-users&quot;&gt;Basys-3&lt;/a&gt;,
I then built demonstrations for an
&lt;a href=&quot;http://www.xess.com&quot;&gt;Xess.com&lt;/a&gt;
&lt;a href=&quot;http://www.xess.com/shop/product/xula2-lx25&quot;&gt;XuLA2-LX25 board&lt;/a&gt;,
and then the
&lt;a href=&quot;https://store.digilentinc.com&quot;&gt;Digilent&lt;/a&gt;
&lt;a href=&quot;https://store.digilentinc.com/cmod-s6-breadboardable-spartan-6-fpga-module&quot;&gt;CMod S6&lt;/a&gt;, the
&lt;a href=&quot;https://store.digilentinc.com/arty-artix-7-fpga-development-board-for-makers-and-hobbyists&quot;&gt;Arty&lt;/a&gt;,
and most recently
&lt;a href=&quot;https://store.digilentinc.com/nexys-video-artix-7-fpga-trainer-board-for-multimedia-applications&quot;&gt;Nexys Video&lt;/a&gt;
boards.
You can still find most of these builds on-line in the
&lt;a href=&quot;https://github.com/ZipCPU/xulalx25soc&quot;&gt;XuLALX25SoC&lt;/a&gt;,
&lt;a href=&quot;https://github.com/ZipCPU/s6soc&quot;&gt;S6SoC&lt;/a&gt;,
&lt;a href=&quot;https://github.com/ZipCPU/openarty&quot;&gt;OpenArty&lt;/a&gt;, and
&lt;a href=&quot;https://github.com/ZipCPU/videozip&quot;&gt;VideoZip&lt;/a&gt; repositories.  Indeed, my
&lt;a href=&quot;https://github.com/ZipCPU&quot;&gt;main Github page&lt;/a&gt; still highlights the
&lt;a href=&quot;https://github.com/ZipCPU/openarty&quot;&gt;OpenArty&lt;/a&gt; project.
Many of these boards are peripheral rich, and even for those that aren’t I
purchased peripherals (mostly from
&lt;a href=&quot;https://store.digilentinc.com&quot;&gt;Digilent&lt;/a&gt;) to have something fun and new to
work with on each board.  I have found it to be a fun exercise to learn how
to build the RTL code to support a new peripheral and I would commend that
exercise to every RTL student.&lt;/p&gt;

&lt;p&gt;I then ran into the problem of supporting someone who didn’t have the
peripherals I had.  How could or should they use the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;,
if their hardware didn’t match the hardware of one of the demonstration designs?&lt;/p&gt;

&lt;p&gt;So, I backed up and took a look at all the designs I had.  Almost all of them
had some type of serial
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt;,
some amount of block RAM, and a serial port.
Why not then make a design that had &lt;em&gt;only&lt;/em&gt; these peripherals?&lt;/p&gt;

&lt;p&gt;That was, and still is, the purpose of the
&lt;a href=&quot;https://github.com/ZipCPU/zbasic&quot;&gt;ZBasic&lt;/a&gt;
design.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 1. ZBasic Components and Peripherals&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/zbasic-blok.svg&quot; alt=&quot;&quot; width=&quot;730&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Because &lt;a href=&quot;https://github.com/ZipCPU/zbasic&quot;&gt;the design&lt;/a&gt;
is intended to be generic, it has no
&lt;a href=&quot;https://en.wikipedia.org/wiki/Synchronous_dynamic_random-access_memory&quot;&gt;SDRAM&lt;/a&gt;,
nor any &lt;a href=&quot;https://en.wikipedia.org/wiki/DDR3_SDRAM&quot;&gt;DDR3 SDRAM&lt;/a&gt;,
nor any other type of external RAM chip.
These interfaces tend to be board specific, and I wanted
this distribution to be as basic and as simple as possible.  What that means,
though, is that the main
&lt;a href=&quot;https://github.com/ZipCPU/zbasic&quot;&gt;ZBasic&lt;/a&gt;
design requires 1MB of on-chip block RAM.  Well, “requires” is a harsh word,
what I mean to say is that the design as currently configured on
&lt;a href=&quot;https://github.com/ZipCPU/zbasic&quot;&gt;github&lt;/a&gt; will try to infer 1MB of block RAM.
While few chips have this much RAM, it allows the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;,
within the
&lt;a href=&quot;https://github.com/ZipCPU/zbasic&quot;&gt;ZBasic&lt;/a&gt;
design to have access to an abundance of RAM without worrying about the
interface to the RAM.  Even better, this amount of RAM can be easily
changed using
&lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt;,
by changing only one number in the
&lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt;,
&lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/auto-data/bkram.txt&quot;&gt;block RAM config
file&lt;/a&gt;
and then rebuilding the design (i.e. &lt;code class=&quot;highlighter-rouge&quot;&gt;make autodata&lt;/code&gt;).
If that’s not enough, by just adding your own user code and
&lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt;
configuration file, you can add whatever additional hardware to the
&lt;a href=&quot;https://github.com/ZipCPU/zbasic&quot;&gt;ZBasic&lt;/a&gt;
distribution you want–&lt;a href=&quot;https://en.wikipedia.org/wiki/Synchronous_dynamic_random-access_memory&quot;&gt;SDRAM&lt;/a&gt;s included.&lt;/p&gt;

&lt;p&gt;Okay, enough reminiscing, let’s discuss how to use the
&lt;a href=&quot;https://github.com/ZipCPU/zbasic&quot;&gt;ZBasic&lt;/a&gt;
design within a
&lt;a href=&quot;https://www.veripool.org/wiki/verilator&quot;&gt;Verilator&lt;/a&gt;-based
simulation.&lt;/p&gt;

&lt;h2 id=&quot;building-zbasic&quot;&gt;Building ZBasic&lt;/h2&gt;

&lt;p&gt;Your first task in using the
&lt;a href=&quot;https://github.com/ZipCPU/zbasic&quot;&gt;ZBasic&lt;/a&gt;
design will be &lt;a href=&quot;/zipcpu/2018/01/31/cpu-build.html&quot;&gt;building the
toolchain&lt;/a&gt;
for the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;:
&lt;a href=&quot;https://www.gnu.org/software/binutils&quot;&gt;binutils&lt;/a&gt;
&lt;a href=&quot;https://www.gcc.org&quot;&gt;GCC&lt;/a&gt;
and &lt;a href=&quot;https://sourceware.org/newlib&quot;&gt;newlib&lt;/a&gt;.
I’ll assume you’ve already done that, if not you’ll need to
&lt;a href=&quot;/zipcpu/2018/01/31/cpu-build.html&quot;&gt;back up a step&lt;/a&gt;.
I’m also going to assume that the toolchain is in your path, as we discussed
&lt;a href=&quot;/zipcpu/2018/01/31/cpu-build.html&quot;&gt;when building it&lt;/a&gt;.
The next step is to clone the
&lt;a href=&quot;https://github.com/ZipCPU/zbasic&quot;&gt;ZBasic&lt;/a&gt;
repository and build it.  Since this repository doesn’t include a copy of
&lt;a href=&quot;https://www.gcc.org&quot;&gt;GCC&lt;/a&gt;,
it’s fairly light and a straightforward clone will work.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;git clone https://github.com/ZipCPU/zbasic
&lt;span class=&quot;nb&quot;&gt;cd &lt;/span&gt;zbasic
make&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Voila!  You have a ready built
&lt;a href=&quot;https://www.veripool.org/wiki/verilator&quot;&gt;Verilator&lt;/a&gt;-based
project ready to run!  (Please create an issue on
&lt;a href=&quot;https://github.com/ZipCPU/zbasic&quot;&gt;Github&lt;/a&gt;
if you have problems, and this doesn’t work.)&lt;/p&gt;

&lt;p&gt;Shall we run our first test?  This test will require two windows, and a little
bit of timing to do right.  In your first window, go ahead an type the
following–but don’t hit return on that last line yet or you might miss some
of the simulation output.  This will run the main simulation “test-bench”
wrapper, and apply it to my (&lt;a href=&quot;/zipcpu/2018/01/31/cpu-build.html&quot;&gt;more
modern&lt;/a&gt;) &lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/sw/board/cputest.c&quot;&gt;CPU test
software&lt;/a&gt;–once
you hit return (don’t do it yet).&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span class=&quot;nb&quot;&gt;cd &lt;/span&gt;sim/verilated
./main_tb ../../sw/board/cputest&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;In your second window, type the following–but don’t hit return.  When you do
(eventually) hit return, this will connect you to the running
&lt;a href=&quot;https://github.com/ZipCPU/zbasic&quot;&gt;ZBasic&lt;/a&gt;
simulation.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;telnet localhost 8846&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Ok, now you can hit return in the first window and then the second.  You
should see the results of the &lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/sw/board/cputest.c&quot;&gt;CPU
test&lt;/a&gt;,
such as Fig 2 illustrates.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 2. ZBasic CPU Test Results&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/zbasic-cpu-test.png&quot; alt=&quot;&quot; width=&quot;563&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;If you had wanted, you could also turn on
&lt;a href=&quot;/blog/2017/07/31/vcd.html&quot;&gt;VCD file&lt;/a&gt;
&lt;a href=&quot;/blog/2017/06/21/looking-at-verilator.html&quot;&gt;generation&lt;/a&gt;
by using the &lt;code class=&quot;highlighter-rouge&quot;&gt;-d&lt;/code&gt; flag, and so trace every wire throughout the whole design as
it moves through this
&lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/sw/board/cputest.c&quot;&gt;CPU test&lt;/a&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;./main_tb -d ../../sw/board/cputest&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Be aware, however, there’s a reason this option is turned off by default: your
&lt;a href=&quot;/blog/2017/07/31/vcd.html&quot;&gt;VCD file&lt;/a&gt; could easily top 11GB.&lt;/p&gt;

&lt;p&gt;Alternatively, you could have just started the design on its own without
giving a program to the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;.
As the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
is configured within the
&lt;a href=&quot;https://github.com/ZipCPU/zbasic&quot;&gt;ZBasic&lt;/a&gt;
design, it starts up in a halted configuration.  (This is optional–it can be
configured to start immediately on power up–see the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/raw/master/doc/spec.pdf&quot;&gt;spec&lt;/a&gt;
for more details.)  If you give a program name as an argument, the
&lt;a href=&quot;/blog/2017/06/21/looking-at-verilator.html&quot;&gt;simulation wrapper&lt;/a&gt;
will load the program into memory and then clear the &lt;a href=&quot;/zipcpu/2017/08/25/hw-debugging.html&quot;&gt;halt bit from the
debugging interface&lt;/a&gt;.
On the other hand, if you give the simulation driver no program name,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;./main_tb&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;then you’ll need to load the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;’s
program into memory–just as you would need to do on actual
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
hardware.  This is done with the
&lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/sw/host/zipload.cpp&quot;&gt;zipload&lt;/a&gt;
program found in the
&lt;a href=&quot;https://github.com/ZipCPU/zbasic/tree/master/sw/board/&quot;&gt;sw/board&lt;/a&gt;
subdirectory.  We’ll also give this program the ‘-r’ switch, to indicate that
the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
should be started once the program is loaded into memory.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span class=&quot;nb&quot;&gt;cd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;path-to-zbasic]/sw/host
./zipload -r ../sw/board/cputest&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This does take a while, though, since we are first programming the &lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/sim/verilated/qspiflashsim.cpp&quot;&gt;simulated
flash&lt;/a&gt;
on board, and only then starting the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt;.  The
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt;
will then copy its machine code from
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt;,
to RAM, and run.&lt;/p&gt;

&lt;p&gt;There you have it!  You’ve just run your first
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
program in a (nearly)
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
representative environment.&lt;/p&gt;

&lt;h2 id=&quot;playing-tic-tac-toe&quot;&gt;Playing Tic-Tac-Toe&lt;/h2&gt;

&lt;p&gt;Ok, so you’ve run a
&lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/sw/board/cputest.c&quot;&gt;CPU test&lt;/a&gt;.
I know, &lt;strong&gt;BORING&lt;/strong&gt;!  So let’s try and have a little more fun.  Let’s now
play &lt;a href=&quot;https://github.com/ZipCPU/tttt&quot;&gt;4x4x4 tic-tac-toe&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Unlike the
&lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/sw/board/cputest.c&quot;&gt;CPU test&lt;/a&gt;,
which &lt;em&gt;only&lt;/em&gt; tests the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt; itself,
&lt;a href=&quot;https://github.com/ZipCPU/tttt&quot;&gt;4x4x4 tic-tac-toe&lt;/a&gt;
uses the
&lt;a href=&quot;https://en.wikipedia.org/wiki/C_standard_library&quot;&gt;C-library&lt;/a&gt;
as well, with such typical library system calls as &lt;code class=&quot;highlighter-rouge&quot;&gt;printf&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;fgets&lt;/code&gt;.
These calls get routed, via a &lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/sw/zlib/syscalls.c&quot;&gt;board specific glue
file&lt;/a&gt;
to the
&lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/sim/verilated/dbluartsim.cpp&quot;&gt;simulated serial port&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;To try this out, change directory into the &lt;code class=&quot;highlighter-rouge&quot;&gt;sw/board&lt;/code&gt; directory, and build
&lt;code class=&quot;highlighter-rouge&quot;&gt;tttt&lt;/code&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span class=&quot;nb&quot;&gt;cd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;path-to-zbasic]/sw/board
make tttt&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;If you get errors, relax.  The “make” command won’t build
&lt;a href=&quot;https://github.com/ZipCPU/tttt&quot;&gt;tttt (4x4x4 tic-tac-toe)&lt;/a&gt;
successfully yet, but it should clone
&lt;a href=&quot;https://github.com/ZipCPU/tttt&quot;&gt;tttt&lt;/a&gt; as a submodule into a subdirectory of the
&lt;a href=&quot;https://github.com/ZipCPU/zbasic/tree/master/sw/board&quot;&gt;sw/board&lt;/a&gt;
directory.&lt;/p&gt;

&lt;p&gt;If it doesn’t clone
&lt;a href=&quot;https://github.com/ZipCPU/tttt&quot;&gt;tttt&lt;/a&gt; (I’ve had mixed success with git
submodules so far–all probably due to a problem lying somewhere between my
keyboard and my chair …), feel free to clone
&lt;a href=&quot;https://github.com/ZipCPU/tttt&quot;&gt;tttt&lt;/a&gt;
right there in that directory.&lt;/p&gt;

&lt;p&gt;Once you have it cloned, you’ll need to adjust a couple of lines within the
&lt;a href=&quot;https://github.com/ZipCPU/tttt/blob/master/src/Makefile&quot;&gt;sw/board/tttt/src/Makefile&lt;/a&gt;
to tell
&lt;a href=&quot;https://github.com/ZipCPU/tttt&quot;&gt;tttt&lt;/a&gt; where the
&lt;a href=&quot;https://en.wikipedia.org/wiki/C_standard_library&quot;&gt;C-library&lt;/a&gt;
is.  Therefore, open the
&lt;a href=&quot;https://github.com/ZipCPU/tttt/blob/master/src/Makefile&quot;&gt;Makefile&lt;/a&gt;
in your favorite editor and replace the lines,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-make&quot; data-lang=&quot;make&quot;&gt;&lt;span class=&quot;err&quot;&gt;ifeq&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;($(ARCH),&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;zip)&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;XLIBD&lt;/span&gt;    &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; ../../branch8b/sw/zlib
&lt;span class=&quot;nv&quot;&gt;XLIBS&lt;/span&gt;    &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; -L&lt;span class=&quot;nv&quot;&gt;$(XLIBD)&lt;/span&gt; -Wl,--start-group -Wl,--Map&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;zip-tttt.map -larty
&lt;span class=&quot;nv&quot;&gt;LDSCRIPT&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$(XLIBD)&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;/../board/arty.ld&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;with these lines,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-make&quot; data-lang=&quot;make&quot;&gt;&lt;span class=&quot;err&quot;&gt;ifeq&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;($(ARCH),&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;zip)&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;XLIBD&lt;/span&gt;    &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; ../../../zlib
&lt;span class=&quot;nv&quot;&gt;XLIBS&lt;/span&gt;    &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; -L&lt;span class=&quot;nv&quot;&gt;$(XLIBD)&lt;/span&gt; -Wl,--start-group -Wl,--Map&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;zip-tttt.map -lzbasic -lc
&lt;span class=&quot;nv&quot;&gt;LDSCRIPT&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$(XLIBD)&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;/../board/board.ld&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;At this point, you should just be able to build
&lt;a href=&quot;https://github.com/ZipCPU/tttt&quot;&gt;tttt&lt;/a&gt;
without further ado.  To do this, stay in the
&lt;a href=&quot;http://github.com/ZipCPU/zbasic/tree/master/sw/board&quot;&gt;sw/board&lt;/a&gt; directory
of the &lt;a href=&quot;http://github.com/ZipCPU/zbasic&quot;&gt;ZBasic&lt;/a&gt; project and type:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;make tttt&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This will make certain the cross-compiler environment variables are properly
set to build
&lt;a href=&quot;https://github.com/ZipCPU/tttt&quot;&gt;tttt&lt;/a&gt;
for the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;.
(If you had instead cd’d into &lt;code class=&quot;highlighter-rouge&quot;&gt;tttt&lt;/code&gt; and issued a &lt;code class=&quot;highlighter-rouge&quot;&gt;make&lt;/code&gt; command, it would
build &lt;code class=&quot;highlighter-rouge&quot;&gt;tttt&lt;/code&gt; for your local/host architecture.)&lt;/p&gt;

&lt;p&gt;Now we can play.  Ready?&lt;/p&gt;

&lt;p&gt;As before, we’ll type in the command to start the simulator in one window,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span class=&quot;nb&quot;&gt;cd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;path-to-zbasic]/sim/verilated
./main_tb ../../sw/board/tttt/src/zip-tttt&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;and connect to the simulated serial port from another window,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;telnet localhost 8846&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;When you hit return on the two (in sequence), the &lt;code class=&quot;highlighter-rouge&quot;&gt;telnet&lt;/code&gt; window will show
the following:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;Trying 127.0.0.1...
Connected to localhost.
Escape character is &#39;^]&#39;.

Welcome to 4x4x4 Tic-Tac-Toe

The goal of this game is to get 4 pieces in a row.  The board is three
dimensional, even though it will be displayed on a terminal screen.  Imagine
instead of seeing four 4x4 boards side by side, that these boards are
actually standing on top of each other.  A winning four in a row can exist
on any of the 4x4 levels.  A winning four in a row can also cross through
all levels.  Diagonals are valid, as are diagonal diagonals.

To specify your move, type in a string of three numbers each in the range of
1-4.  The first two numbers describe where you wish to move within one 4x4
board, where the first number is the position counting left to right and the
second number is the position counting from top down.  The last number is
which 4x4 board you wish to move to, counting from the 4x4 on the left to
the right

Current Board: (Empty)
----  ----  ----  ----  
----  ----  ----  ----  
----  ----  ----  ----  
----  ----  ----  ----  

Your move : &lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;You should be able to just type your move in as a series of three numbers,
each 1-4, as in &lt;code class=&quot;highlighter-rouge&quot;&gt;1 1 1&lt;/code&gt;.  Have fun!&lt;/p&gt;

&lt;p&gt;Be careful, although the computer isn’t unbeatable, he does play a pretty
mean game!&lt;/p&gt;

&lt;h2 id=&quot;homework&quot;&gt;Homework&lt;/h2&gt;

&lt;p&gt;Care for some
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;
homework?  Here’s a fascinating test you can try with the
&lt;a href=&quot;http://github.com/ZipCPU/zbasic&quot;&gt;ZBasic&lt;/a&gt;
distribution, one that will help to illustrate how important having a
hardware memory copy capability is.&lt;/p&gt;

&lt;p&gt;The glue logic supporting the
&lt;a href=&quot;https://en.wikipedia.org/wiki/C_standard_library&quot;&gt;C-library&lt;/a&gt;
includes a file called
&lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/sw/zlib/crt0.c&quot;&gt;crt0.c&lt;/a&gt;.
For most
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;’s this is an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Assembly_language&quot;&gt;assembly language&lt;/a&gt;
file called crt0.s.  Not for the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;.  For the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;,
this file is written in C.  It contains two routines: &lt;code class=&quot;highlighter-rouge&quot;&gt;_start&lt;/code&gt; and
&lt;code class=&quot;highlighter-rouge&quot;&gt;_bootloader&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The first routine, &lt;code class=&quot;highlighter-rouge&quot;&gt;_start&lt;/code&gt; starts the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
by setting the stack pointer to the end of memory, and then jumping to a
function called &lt;code class=&quot;highlighter-rouge&quot;&gt;_bootloader&lt;/code&gt;.  This is really an
&lt;a href=&quot;/zipcpu/2018/01/01/zipcpu-isa.html&quot;&gt;assembly language&lt;/a&gt;
routine with a thin veneer of a C wrapper, but it’s placed within the
&lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/sw/zlib/crt0.c&quot;&gt;crt0.c&lt;/a&gt;
file anyway.  When you strip away the cruft, it basicaly reads as,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-asm&quot; data-lang=&quot;asm&quot;&gt;_start:		; Here&#39;s the global ZipCPU entry point upon reset/reboot
	LDI	_top_of_stack,SP	; Set up our supervisor stack ptr
	MOV	_kernel_is_dead(PC),uPC	; Set user PC pointer to somewhere valid
	JSR	_bootloader	; JSR to the bootloader routine
	OR	0x4000,CC	; Clear the data cache
        //
	CLR	R1		; argc = 0
	MOV	_argv(PC),R2	; argv = &amp;amp;0
	LDI	__env,R3	; env = NULL
	JSR	main		; Call the user main() function
        //
_graceful_kernel_exit:		; Halt on any return from main--gracefully
	JSR	exit		; Call the _exit as part of exiting
_hw_shutdown:
	NEXIT	R1		; If in simulation, call an exit function
_kernel_is_dead:		; Halt the CPU\n&quot;
	HALT			;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The second routine within
&lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/sw/zlib/crt0.c&quot;&gt;this file&lt;/a&gt;
is the &lt;code class=&quot;highlighter-rouge&quot;&gt;_bootloader&lt;/code&gt; routine that is called from the &lt;code class=&quot;highlighter-rouge&quot;&gt;_start&lt;/code&gt; function above.
This is the routine I’d like to demonstrate for this homework lesson.&lt;/p&gt;

&lt;p&gt;The &lt;code class=&quot;highlighter-rouge&quot;&gt;_bootloader&lt;/code&gt; function itself is really nothing more than a series of
memory copy routines.  These are based around a couple of assumptions.  First,
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt;
is non-volatile (i.e. like a ROM) and so upon startup instructions can
be found there.  The second assumption is that the block RAM is faster than
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt;.
Hence, we want to move our instructions (and data) from
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt;
into block RAM before starting any program.&lt;/p&gt;

&lt;p&gt;First, the &lt;code class=&quot;highlighter-rouge&quot;&gt;_bootloader&lt;/code&gt; copies memory from the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt;
into block RAM.  This section is framed by an
&lt;code class=&quot;highlighter-rouge&quot;&gt;#ifdef _BOARD_HAS_KERNEL_SPACE&lt;/code&gt;,  so that any
high priority (kernel) functions would be or could be placed into block RAM.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;	&lt;span class=&quot;nf&quot;&gt;_booloader&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;// ...
&lt;/span&gt;
&lt;span class=&quot;cp&quot;&gt;#ifdef  _BOARD_HAS_KERNEL_SPACE
&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;rdp&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_kernel_image_start&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;wrp&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_bkram&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_kernel_image_end&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_kernel_image_start&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;do&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
			&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;wrp&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rdp&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;wrp&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_kernel_image_end&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_kernel_image_end&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_sdram&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;wrp&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_sdram&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;cp&quot;&gt;#else
&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;rdp&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_ram_image_start&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;wrp&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_ram&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;cp&quot;&gt;#endif&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Second, the bootloader copies from
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Synchronous_dynamic_random-access_memory&quot;&gt;SDRAM&lt;/a&gt;
into any
&lt;a href=&quot;https://en.wikipedia.org/wiki/Synchronous_dynamic_random-access_memory&quot;&gt;SDRAM&lt;/a&gt;
the board might have,
as defined by the &lt;code class=&quot;highlighter-rouge&quot;&gt;_sdram&lt;/code&gt; pointer.  Since
&lt;a href=&quot;https://github.com/ZipCPU/zbasic&quot;&gt;ZBasic&lt;/a&gt;
doesn’t have any
&lt;a href=&quot;https://en.wikipedia.org/wiki/Synchronous_dynamic_random-access_memory&quot;&gt;SDRAM&lt;/a&gt;,
this second memory copy ends up continuing the write into block RAM
instead.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;        &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;wrp&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_ram_image_end&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
		&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;wrp&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rdp&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The third section of memory is the BSS section.  This is a memory section
whose initial contents are all zeros.  The &lt;code class=&quot;highlighter-rouge&quot;&gt;_bootloader&lt;/code&gt; fulfills this
commitment by writing zeros to all of the memory location within this
section.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;	&lt;span class=&quot;c1&quot;&gt;// ...
&lt;/span&gt;	&lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;wrp&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_bss_image_end&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
		&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;wrp&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;However, if you look inside the
&lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/sw/zlib/crt0.c&quot;&gt;crt0.c&lt;/a&gt;
file, you’ll actually see two choices
for how to handle these memory copies.  The first choice is applied if
&lt;code class=&quot;highlighter-rouge&quot;&gt;USE_DMA&lt;/code&gt; is defined.  This is set earlier in the file to be true only if
&lt;code class=&quot;highlighter-rouge&quot;&gt;_HAVE_ZIPSYS_DMA&lt;/code&gt; is defined–something that comes from the
&lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/rtl/cpu/cpudefs.v&quot;&gt;cpudefs.v&lt;/a&gt;
configuration file.&lt;/p&gt;

&lt;p&gt;For this homework assignment, turn on tracing with the &lt;code class=&quot;highlighter-rouge&quot;&gt;-d&lt;/code&gt; flag (you do have
a rough 4GB available, right?) and run the
&lt;a href=&quot;https://github.com/ZipCPU/tttt&quot;&gt;4x4x4 tic-tac-toe program (tttt)&lt;/a&gt;
again.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span class=&quot;nb&quot;&gt;cd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;path-to-zbasic]/sim/verilated
./main_tb -d ../../sw/board/tttt/src/zip-tttt&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;To keep it from taking up too much room on your
hard-drive, kill it as soon as the game instructions start coming up (i.e.
type Ctrl-C on the screen where you typed &lt;code class=&quot;highlighter-rouge&quot;&gt;main_tb -d ...&lt;/code&gt;).
Copy the &lt;a href=&quot;/blog/2017/07/31/vcd.html&quot;&gt;trace file&lt;/a&gt;
from &lt;code class=&quot;highlighter-rouge&quot;&gt;trace.vcd&lt;/code&gt; to &lt;code class=&quot;highlighter-rouge&quot;&gt;with-dma.vcd&lt;/code&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;mv trace.vcd with-dma.vcd&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Then comment the &lt;code class=&quot;highlighter-rouge&quot;&gt;USE_DMA&lt;/code&gt; define in
&lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/sw/zlib/crt0.c&quot;&gt;crt0.c&lt;/a&gt; by
placing two &lt;code class=&quot;highlighter-rouge&quot;&gt;//&lt;/code&gt;s at the beginning of the line,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span class=&quot;o&quot;&gt;//&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;define&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;USE_DMA&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;You can then rebuild in
&lt;a href=&quot;https://github.com/ZipCPU/zbasic/tree/master/sw/zlib/&quot;&gt;sw/zlib&lt;/a&gt; by typing
&lt;code class=&quot;highlighter-rouge&quot;&gt;make&lt;/code&gt; in that directory, but you’ll need to do a &lt;code class=&quot;highlighter-rouge&quot;&gt;make clean&lt;/code&gt; in
&lt;a href=&quot;https://github.com/ZipCPU/zbasic/tree/master/sw/board/&quot;&gt;sw/board&lt;/a&gt;
before you can re-issue &lt;code class=&quot;highlighter-rouge&quot;&gt;make&lt;/code&gt; again there.  Once done, you can issue a
&lt;code class=&quot;highlighter-rouge&quot;&gt;make&lt;/code&gt; in
&lt;a href=&quot;https://github.com/ZipCPU/zbasic/tree/master/sw/board/&quot;&gt;sw/board&lt;/a&gt;
and then &lt;code class=&quot;highlighter-rouge&quot;&gt;make tttt&lt;/code&gt;.  This will propagate this change throughout the
&lt;a href=&quot;https://en.wikipedia.org/wiki/C_standard_library&quot;&gt;C-library&lt;/a&gt;
and into the application software.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span class=&quot;nb&quot;&gt;cd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;path-to-zbasic]/sw/zlib
make
&lt;span class=&quot;nb&quot;&gt;cd&lt;/span&gt; ../sw/board
make clean
make
make tttt&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Now run the simulator again, still with the -d option.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span class=&quot;nb&quot;&gt;cd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;path-to-zbasic]/sim/verilated
main_tb -d ../../sw/board/tttt/src/zip-tttt&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Kill it (Ctrl-C) as before when the characters start getting printed to the
terminal.  Then rename the &lt;code class=&quot;highlighter-rouge&quot;&gt;trace.vcd&lt;/code&gt; file to be &lt;code class=&quot;highlighter-rouge&quot;&gt;without-dma.vcd&lt;/code&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;mv trace.vcd without-dma.vcd&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Now that you have two comparison files, pull them both up in
&lt;a href=&quot;https://gtkwave.sourceforge.net&quot;&gt;GtkWave&lt;/a&gt;.
Let’s look specifically at the
serial output line &lt;code class=&quot;highlighter-rouge&quot;&gt;o_wbu_uart_tx&lt;/code&gt; from the top level, and then from
within the top level, the
&lt;a href=&quot;/blog/2017/11/07/wb-formal.html&quot;&gt;wishbone strobe
line &lt;code class=&quot;highlighter-rouge&quot;&gt;wb_stb&lt;/code&gt;&lt;/a&gt;, the
&lt;code class=&quot;highlighter-rouge&quot;&gt;flash_sel&lt;/code&gt; (&lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt;
select) line, and then &lt;code class=&quot;highlighter-rouge&quot;&gt;bkram_sel&lt;/code&gt; (block RAM select)
lines.  As you may recall, &lt;code class=&quot;highlighter-rouge&quot;&gt;wb_stb&lt;/code&gt; will be true anytime a request is being
made across the bus.  The other two lines indicate when the address
associated with this request is either referencing the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt;
or the block RAM.&lt;/p&gt;

&lt;p&gt;See a difference?&lt;/p&gt;

&lt;p&gt;Here’s my figure for running without the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/wbdmac.v&quot;&gt;DMA&lt;/a&gt;,&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 3. ZBasic Bootloader without DMA&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/zbasic-wodma.png&quot; alt=&quot;&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;and again for running with the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/wbdmac.v&quot;&gt;DMA&lt;/a&gt;
controller,&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 4. ZBasic Components and Peripherals&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/zbasic-wdma.png&quot; alt=&quot;&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;If you look at the far right, when &lt;code class=&quot;highlighter-rouge&quot;&gt;o_wbu_uart_tx&lt;/code&gt; starts toggling that’s when
the first characters of the game are being sent to the serial port.  This
doesn’t happen until the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;_bootloader&lt;/code&gt; has finished.  Here, you can see that it takes about nine
seconds to copy everything from
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt;
when using the &lt;code class=&quot;highlighter-rouge&quot;&gt;_bootloader&lt;/code&gt;, whereas it
takes over twenty seconds without!  You can also see a big difference in the
&lt;code class=&quot;highlighter-rouge&quot;&gt;flash_sel&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;bkram_sel&lt;/code&gt; lines.  What’s going on there?&lt;/p&gt;

&lt;p&gt;Let’s drill one level deeper and look at what’s going on by zooming in.
Let’s also add the &lt;code class=&quot;highlighter-rouge&quot;&gt;flash_ack&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;bkram_ack&lt;/code&gt; lines–there are the
wishbone acknowledgement
lines from these two peripherals, and indicate when a request has been
fulfilled.&lt;/p&gt;

&lt;p&gt;You can see the
&lt;a href=&quot;/blog/2017/07/31/vcd.html&quot;&gt;trace&lt;/a&gt;
without
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/wbdmac.v&quot;&gt;DMA&lt;/a&gt;,
in Fig 5, below.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 5. Zooming in on the ZBasic Bootloader without DMA&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/zbasic-wodma-zoom.png&quot; alt=&quot;&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;What’s not as readily apparent in this
&lt;a href=&quot;/blog/2017/07/31/vcd.html&quot;&gt;trace&lt;/a&gt;
is the context–it begins in the middle of a transaction.  A value has
already been requested from the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt;
controller by the time my screen capture starts.  Once the
&lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/rtl/wbqspiflash.v&quot;&gt;flash controller&lt;/a&gt;
acknowledges the transaction, that is when &lt;code class=&quot;highlighter-rouge&quot;&gt;flash_ack&lt;/code&gt; goes high, the data
becomes available to the &lt;code class=&quot;highlighter-rouge&quot;&gt;_bootloader&lt;/code&gt;,
and it immediately turns around and writes to the block RAM.  Since the
block RAM is quite fast, it acknowledges its transaction almost immediately.
(Remember, transaction requests only take place when &lt;code class=&quot;highlighter-rouge&quot;&gt;wb_stb&lt;/code&gt; is high, and
so Fig 6 only shows two transaction requests.)  The
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
then issues a read request of the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt;
and … everything stalls again waiting for the &lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/rtl/wbqspiflash.v&quot;&gt;flash
controller&lt;/a&gt;’s
acknowledgement.&lt;/p&gt;

&lt;p&gt;This is &lt;em&gt;very&lt;/em&gt; different from what happens when the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/wbdmac.v&quot;&gt;DMA&lt;/a&gt;,
is turned on.  For that case, you can see what happens when
in Fig 6 below.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 6. Zooming in on the ZBasic Bootloader, with the DMA in use&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/zbasic-wdma-zoom.png&quot; alt=&quot;&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;In this case, the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/wbdmac.v&quot;&gt;DMA&lt;/a&gt;
reads multiple items from the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt;
in a back to back
fashion–you can see all of the acknowledgement’s in the &lt;code class=&quot;highlighter-rouge&quot;&gt;flash_ack&lt;/code&gt; line
in Fig 6.  During this time, the block RAM is idle.  Once the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/wbdmac.v&quot;&gt;DMA&lt;/a&gt;
has finished
reading a rough 1k words from the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt;,
it then bursts these to the block
RAM.  Look at the &lt;code class=&quot;highlighter-rouge&quot;&gt;wb_stb&lt;/code&gt; line to see this–it’s nearly a constant &lt;code class=&quot;highlighter-rouge&quot;&gt;ON&lt;/code&gt;
signal, indicating that one request after another is being made.  In a
similar fashion, but unlike the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/rtl/wbqspiflash.v&quot;&gt;controller&lt;/a&gt;’s
response, the block RAM’s acknowledgment signal is also a constant high–since
the block RAM can respond to one request per clock.
As a result, this portion of the copy goes by very quickly.&lt;/p&gt;

&lt;p&gt;Given this information, would you rather copy your data using the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/wbdmac.v&quot;&gt;DMA&lt;/a&gt;,
or a tight loop within the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;?&lt;/p&gt;

&lt;h2 id=&quot;how-do-i-change-the-amount-of-block-ram&quot;&gt;How do I change the amount of block RAM?&lt;/h2&gt;

&lt;p&gt;Since I know this is going to come up, let me show you how easy it is to
change the amount of block RAM in this device.&lt;/p&gt;

&lt;p&gt;First, look in the
&lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt; &lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/auto-data/bkram.txt&quot;&gt;block ram configuration
file&lt;/a&gt;.
Within that file, find the line,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;@$LGMEMSZ=20&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This line defines a tag, &lt;code class=&quot;highlighter-rouge&quot;&gt;@LGMEMSZ&lt;/code&gt;, specifies that it is a numerical
tag with the &lt;code class=&quot;highlighter-rouge&quot;&gt;@$&lt;/code&gt; prefix, and then gives it the value of &lt;code class=&quot;highlighter-rouge&quot;&gt;20&lt;/code&gt;.
This tag is used to specify that the log, based two, of the block RAM
memory size is twenty–meaning it should have 1MB, or &lt;code class=&quot;highlighter-rouge&quot;&gt;2^20&lt;/code&gt; bytes, of
block RAM.  The key itself is unique to this
&lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/auto-data/bkram.txt&quot;&gt;block ram configuration
file&lt;/a&gt;,
so you aren’t likely to find it elsewhere.  It basically defines a local
variable within an &lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt; context.
However, with a bit of math and some substitution (remember, 
&lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt; is primarily a
copy/paste utility with a calculator and address assignment built
in), this number becomes the amount of block RAM called for in the
system design.&lt;/p&gt;

&lt;p&gt;You can change this one number, and then run &lt;code class=&quot;highlighter-rouge&quot;&gt;make autodata&lt;/code&gt; from the main
directory (assuming you have
&lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt; installed and in your path),
and the design will immediately be reconfigured for the new memory size.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span class=&quot;nb&quot;&gt;cd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;path-to-zbasic]/
make autodata&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Yes, you’ll still need to run &lt;code class=&quot;highlighter-rouge&quot;&gt;make&lt;/code&gt; from the main directory again once
you’ve done this,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;make&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;so that this newly configured design has a chance to build.&lt;/p&gt;

&lt;p&gt;What changes?&lt;/p&gt;

&lt;p&gt;Well, first, the &lt;code class=&quot;highlighter-rouge&quot;&gt;@MAIN.INSERT&lt;/code&gt; tag that same
&lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/auto-data/bkram.txt&quot;&gt;bkram.txt&lt;/a&gt;
file is used to tell
&lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt; what to place into your
&lt;a href=&quot;/blog/2017/10/05/autofpga-intro.html&quot;&gt;main.v&lt;/a&gt;
file.  In this case, it’s a reference to a
&lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/rtl/memdev.v&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;memdev&lt;/code&gt;&lt;/a&gt;
module which implements a block RAM device that is parameterized by its size.
&lt;code class=&quot;highlighter-rouge&quot;&gt;@THIS.LGMEMSZ&lt;/code&gt; is used to control this parameter.  It’s also used to
connect that design parameter to the number of address lines fed to this
component, and changing this size may cause the other peripherals on the bus
to be shuffled around to minimize the required bus logic.&lt;/p&gt;

&lt;p&gt;Second, all of the addresses will (may) be re-assigned as I just mentioned.
This includes more than just the block RAM.  These new addresses can be found
listed in the
&lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/sw/host/regdefs.h&quot;&gt;regdefs.h&lt;/a&gt;
and
&lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/sw/board/board.h&quot;&gt;board.h&lt;/a&gt;
files based upon the &lt;code class=&quot;highlighter-rouge&quot;&gt;@REGS.*&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;@BDEF.OSVAL&lt;/code&gt; tags.&lt;/p&gt;

&lt;p&gt;Third, the &lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/sw/board/board.ld&quot;&gt;linker definition
script&lt;/a&gt;
will have changed, which will adjust the
&lt;code class=&quot;highlighter-rouge&quot;&gt;_bkram&lt;/code&gt; pointer used by the &lt;code class=&quot;highlighter-rouge&quot;&gt;_bootloader&lt;/code&gt; we discussed above.&lt;/p&gt;

&lt;p&gt;Fourth, the &lt;code class=&quot;highlighter-rouge&quot;&gt;@SIM.LOAD&lt;/code&gt; tag defines the software necessary to load a program
into this memory, given the new location and length found in the updated
&lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/sw/host/regdefs.h&quot;&gt;regdefs.h&lt;/a&gt;
file.&lt;/p&gt;

&lt;p&gt;The result of all of this is that, following an
&lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt;
based reconfigure, all that is required is to rebuild the project and
we have a new amount of memory at a (potentially) different location.&lt;/p&gt;

&lt;h2 id=&quot;next-steps&quot;&gt;Next Steps&lt;/h2&gt;

&lt;p&gt;Now that you know how to run the
&lt;a href=&quot;https://github.com/ZipCPU/zbasic&quot;&gt;ZBasic&lt;/a&gt;
demonstration, the next step
will be to show how simple and easy it is to add a
&lt;a href=&quot;https://github.com/ZipCPU/wbpmic&quot;&gt;new component&lt;/a&gt;
using
&lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt;,
and then to demonstrate how we can integrate this component into our
&lt;a href=&quot;/blog/2017/06/21/looking-at-verilator.html&quot;&gt;simulation&lt;/a&gt;
and ultimately the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
design as a whole.&lt;/p&gt;

&lt;p&gt;My current plan is to do this with the
&lt;a href=&quot;https://github.com/ZipCPU/wbpmic&quot;&gt;WBPMIC&lt;/a&gt;
component.  This particular controller is designed to control a &lt;a href=&quot;http://store.digilentinc.com/pmod-mic3-mems-microphone-with-adjustable-gain&quot;&gt;MEMs audio
microphone&lt;/a&gt;
and &lt;a href=&quot;https://en.wikipedia.org/wiki/Analog-to-digital_converter&quot;&gt;A/D&lt;/a&gt;
sold by &lt;a href=&quot;https://store.digilentinc.com&quot;&gt;Digilent&lt;/a&gt;–their
“&lt;a href=&quot;http://store.digilentinc.com/pmod-mic3-mems-microphone-with-adjustable-gain&quot;&gt;PMod MIC3&lt;/a&gt;”.&lt;/p&gt;

&lt;p&gt;That will be our next step in this series, although there’s really a lot
of information we can come back to–such as how the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/wbdmac.v&quot;&gt;DMA controller&lt;/a&gt;
works in the first place.&lt;/p&gt;
&lt;hr /&gt;&lt;p&gt;&lt;em&gt;Wilt thou play with him as with a bird? or wilt thou bind him for thy maidens? (Job 41:5)&lt;/em&gt;</description>
        <pubDate>Mon, 12 Feb 2018 00:00:00 -0500</pubDate>
        <link>http://zipcpu.com/zipcpu/2018/02/12/zbasic-intro.html</link>
        <guid isPermaLink="true">http://zipcpu.com/zipcpu/2018/02/12/zbasic-intro.html</guid>
        
        
        <category>zipcpu</category>
        
      </item>
    
      <item>
        <title>Debugging a Cyclone-V</title>
        <description>&lt;p&gt;If you’ve read the description of &lt;a href=&quot;/about/gisselquist-technology.html&quot;&gt;Gisselquist
Technology&lt;/a&gt;,
you’ll remember that &lt;a href=&quot;/about/gisselquist-technology.html&quot;&gt;Gisselquist
Technology&lt;/a&gt;
is a services business.  I use
&lt;a href=&quot;http://zipcpu.com/&quot;&gt;this blog&lt;/a&gt;
and my
&lt;a href=&quot;https://github.com/ZipCPU&quot;&gt;demonstration IP cores&lt;/a&gt;
to help attract customers.  It also means that I don’t necessarily advertise
all of the IP I’ve built on my
&lt;a href=&quot;/projects.html&quot;&gt;projects page&lt;/a&gt;–since
I’m not selling IP but rather my time and abilities.  I prefer not to comment
about the customers I work with, or what their various requirements
are–that’s their business.  I just provide them with a service.&lt;/p&gt;

&lt;p&gt;However, a recent project I’ve been working on is worth commenting on from
the standpoint of how to avoid
&lt;a href=&quot;/blog/2017/05/19/fpga-hell.html&quot;&gt;FPGA Hell&lt;/a&gt;
in a somewhat unique environment: the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
+ &lt;a href=&quot;https://en.wikipedia.org/wiki/ARM_architecture&quot;&gt;ARM&lt;/a&gt;
environment.  This is probably all the more appropriate, as these
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
+ &lt;a href=&quot;https://en.wikipedia.org/wiki/ARM_architecture&quot;&gt;ARM&lt;/a&gt;
chips are becoming more and more popular.&lt;/p&gt;

&lt;p&gt;The project in question was a basic data acquisition system: control &lt;em&gt;N&lt;/em&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Analog-to-digital_converter&quot;&gt;A/D&lt;/a&gt;s
running at over a MHz in speed, and spit the results out over Ethernet.
To make this project work, we chose to use the
&lt;a href=&quot;http://www.terasic.com/cgi-bin/page/archive.pl?Language=English&amp;amp;No=1046&quot;&gt;DE10-Nano&lt;/a&gt;
as our processing device, shown below.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 1. A DE10-Nano board, shown without the A/Ds attached&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/de10-deskpic.jpg&quot; alt=&quot;Picture of a DE10-Nano FPGA board from Terasic&quot; width=&quot;768&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;This also marks my first experience with an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
+ &lt;a href=&quot;https://en.wikipedia.org/wiki/ARM_architecture&quot;&gt;ARM&lt;/a&gt;
type device, and what it takes to interface logic with an on-board
&lt;a href=&quot;https://en.wikipedia.org/wiki/ARM_architecture&quot;&gt;hard processor&lt;/a&gt;, and I
thought I might share with you some of my experiences and the
lessons I learned.&lt;/p&gt;

&lt;h2 id=&quot;general-project-structure&quot;&gt;General Project Structure&lt;/h2&gt;

&lt;p&gt;You can see the general structure of the project in Fig 2 below.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 2. Design Structure&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/de10-design.svg&quot; alt=&quot;&quot; width=&quot;400&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;In brief, the
&lt;a href=&quot;https://en.wikipedia.org/wiki/ARM_architecture&quot;&gt;ARM processor&lt;/a&gt;
has a number of buses available to it, within the chip, to communicate
over.  I chose the light-weight bus from the
&lt;a href=&quot;https://en.wikipedia.org/wiki/ARM_architecture&quot;&gt;ARM&lt;/a&gt;
to the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
for its simplicity–although I may revisit this decision later.  I then used
&lt;a href=&quot;https://www.altera.com/products/design-software/fpga-design/quartus-prime/features/qts-platform-designer.html&quot;&gt;Qsys&lt;/a&gt;
(now called the “&lt;a href=&quot;https://www.altera.com/products/design-software/fpga-design/quartus-prime/features/qts-platform-designer.html&quot;&gt;Platform Designer&lt;/a&gt;”
, although few tutorials have been updated since the name change) to
connect my application specific design component(s) to an
&lt;a href=&quot;https://www.altera.com/content/dam/altera-www/global/en_US/pdfs/literature/manual/mnl_avalon_spec.pdf&quot;&gt;Avalon&lt;/a&gt;
memory-mapped I/O bus.&lt;/p&gt;

&lt;p&gt;This brings me to my own part of the design.  For this application specific
portion, I bridged from the
&lt;a href=&quot;https://www.altera.com/content/dam/altera-www/global/en_US/pdfs/literature/manual/mnl_avalon_spec.pdf&quot;&gt;Avalon bus&lt;/a&gt;
to a
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;Wishbone (WB) bus&lt;/a&gt;
(all my legacy code was written for
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;WB&lt;/a&gt;),
and used &lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt;
to assemble my
design components together–assigning addresses and handling the bus
interconnect within my own portion of the design.&lt;/p&gt;

&lt;p&gt;This became my
“&lt;a href=&quot;/blog/2017/06/16/dbg-bus-forest.html&quot;&gt;debugging bus&lt;/a&gt;”
as well for finding bugs within my design.&lt;/p&gt;

&lt;p&gt;Further, the
&lt;a href=&quot;https://www.altera.com/products/design-software/fpga-design/quartus-prime/features/qts-platform-designer.html&quot;&gt;Platform Designer&lt;/a&gt;
output is a big black box that I needed to create a wrapper for, connecting
the
&lt;a href=&quot;https://en.wikipedia.org/wiki/ARM_architecture&quot;&gt;ARM processor&lt;/a&gt;
to the external system components–&lt;a href=&quot;https://en.wikipedia.org/wiki/DDR3_SDRAM&quot;&gt;DDR3
SDRAM&lt;/a&gt;,
&lt;a href=&quot;https://en.wikipedia.org/wiki/Gigabit_Ethernet&quot;&gt;GigE&lt;/a&gt;
network, etc.&lt;/p&gt;

&lt;h2 id=&quot;so-what-was-the-process-for-finding-bugs&quot;&gt;So what was the process for finding bugs?&lt;/h2&gt;

&lt;p&gt;My bug finding approach follows directly from &lt;a href=&quot;/blog/2017/06/23/my-dbg-philosophy.html&quot;&gt;my basic debugging
philosophy&lt;/a&gt;.
However, the
&lt;a href=&quot;/blog/2017/06/23/my-dbg-philosophy.html&quot;&gt;basic philosophy&lt;/a&gt;
really needs to be slightly updated, since I’ve started using
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal methods&lt;/a&gt;.
Basically, I followed the following steps:&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 3. Design Process&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/cyclonev-design.svg&quot; alt=&quot;Steps in design with Cyclone-V&quot; width=&quot;180&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;I wrote my design components and immediately “tested” them using the
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal methods&lt;/a&gt;
provided by
&lt;a href=&quot;http://www.clifford.at/yosys&quot;&gt;yosys-smtbmc&lt;/a&gt;
and the lint capabilities of
&lt;a href=&quot;https://veripool.org/wiki/verilator&quot;&gt;Verilator&lt;/a&gt;.
If any component didn’t pass muster from both of these tools, I
didn’t even try it on the board.&lt;/p&gt;

    &lt;p&gt;This worked well for the bottom or “leaf” nodes of my design tree.&lt;/p&gt;

    &lt;p&gt;I also applied this method to a single non-leaf node, one that included my
&lt;a href=&quot;/dsp/2017/11/10/delayw.html&quot;&gt;delay element&lt;/a&gt;
as a sub-component.
The purpose of this module was to segment the data into blocks, and to
calculate the best exponent that could be applied to all of the samples
in a given block.  The timing of this module was critical, but it wasn’t
simple to desk check–so the proof was important.  Indeed, the success
of the entire design depended upon this being done “right”.
However, after cutting the proof down as much as possible, it still
took a rough day of solid CPU computation to finish.  This was rare
among my proofs, as most completed within 5-20 minutes.  Still, I
needed the confidence of that formal verification proof and so I
“paid” that price.&lt;/p&gt;

    &lt;p&gt;Neither did I apply
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal methods&lt;/a&gt;
to all of the design components.  For example, one component contained
three parallel
&lt;a href=&quot;/blog/2017/07/29/fifo.html&quot;&gt;FIFO&lt;/a&gt;s closely
integrated together.  Another component contained the
entire signal processing chain (including the parallel
&lt;a href=&quot;/blog/2017/07/29/fifo.html&quot;&gt;FIFO&lt;/a&gt;s 
module).  Neither of these components were
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formally verified&lt;/a&gt;,
although I would’ve loved doing so–I just wasn’t certain I could manage
the complexity required to do so.  Hence these components were
desk-checked,
&lt;a href=&quot;/blog/2017/06/21/looking-at-verilator.html&quot;&gt;simulated&lt;/a&gt;,
and tested on the hardware itself but never
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formally verified&lt;/a&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;If the component passed
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal verification&lt;/a&gt;
and
&lt;a href=&quot;https://veripool.org/wiki/verilator&quot;&gt;Verilator&lt;/a&gt; linting, I’d
synthesize it and try it on the board.  If it failed on the board, I’d
add a
&lt;a href=&quot;/blog/2017/07/08/getting-started-with-wbscope.html&quot;&gt;wishbone scope&lt;/a&gt;
to see what was going on.  Since this was an
&lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt; based design, adding or
removing a &lt;a href=&quot;/blog/2017/07/08/getting-started-with-wbscope.html&quot;&gt;wishbone
scope&lt;/a&gt;
was &lt;em&gt;really&lt;/em&gt; easy to do.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;This left me stuck in
&lt;a href=&quot;/blog/2017/05/19/fpga-hell.html&quot;&gt;FPGA Hell&lt;/a&gt;
only twice, and never for very long.  First, I was stuck in
&lt;a href=&quot;/blog/2017/05/19/fpga-hell.html&quot;&gt;FPGA Hell&lt;/a&gt;
before I learned how to use the golden reference design
properly.  In these cases, the
&lt;a href=&quot;https://www.yoctoproject.org/product/angstrom-distribution&quot;&gt;Angstrom&lt;/a&gt;
Linux distribution I was using
would never get past the boot-loader.  Second, I would get stuck in
&lt;a href=&quot;/blog/2017/05/19/fpga-hell.html&quot;&gt;FPGA Hell&lt;/a&gt;
any time the system didn’t interact with the
&lt;a href=&quot;https://www.altera.com/content/dam/altera-www/global/en_US/pdfs/literature/manual/mnl_avalon_spec.pdf&quot;&gt;Avalon bus&lt;/a&gt;
properly.&lt;/p&gt;

    &lt;p&gt;In the second case, my
&lt;a href=&quot;https://veripool.org/wiki/verilator&quot;&gt;Verilator&lt;/a&gt;-based
&lt;a href=&quot;/blog/2017/06/21/looking-at-verilator.html&quot;&gt;simulation&lt;/a&gt;
rescued me nicely every time.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;No,  &lt;a href=&quot;/blog/2017/06/02/design-process.html&quot;&gt;I did not use any Verilog based test-benches&lt;/a&gt;.&lt;/p&gt;

    &lt;p&gt;After having gotten a taste of
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal methods&lt;/a&gt;,
I’m not sure I’d go back to any
&lt;a href=&quot;/blog/2017/06/02/design-process.html&quot;&gt;other approaches&lt;/a&gt;
if I didn’t need to.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;the-crazy-bug&quot;&gt;The Crazy Bug&lt;/h2&gt;

&lt;p&gt;Ok, so … I did come across a rather “Crazy Bug”.  You know, the kind that
goes down in your memory banks as one that &lt;em&gt;really&lt;/em&gt; stands out?  The one bug
in any project that takes you so long to find that you had to take notice
of it?  In my case, this bug took place across the interaction between the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
and the &lt;a href=&quot;https://en.wikipedia.org/wiki/ARM_architecture&quot;&gt;ARM&lt;/a&gt;
processor.&lt;/p&gt;

&lt;p&gt;For your sake, I’ll share what happened here, lest you get caught in
the same bug yourself.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig. 4. Basic Processing Steps&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/adc-copy-loop.svg&quot; alt=&quot;S/w outline&quot; width=&quot;180&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;After collecting samples from the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Analog-to-digital_converter&quot;&gt;A/D&lt;/a&gt;s,
those samples went through an initial signal processing chain.
Once that signal processing chain had finished working on the incoming
samples, those samples were placed into a
&lt;a href=&quot;/blog/2017/07/29/fifo.html&quot;&gt;FIFO&lt;/a&gt;.
When the software running on the
&lt;a href=&quot;https://en.wikipedia.org/wiki/ARM_architecture&quot;&gt;ARM&lt;/a&gt;
was ready, it would call the
&lt;a href=&quot;http://www.cplusplus.com/reference/cstring/memcpy/&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;memcpy()&lt;/code&gt;&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/C_standard_library&quot;&gt;C-library&lt;/a&gt; routine
to copy samples from the
&lt;a href=&quot;/blog/2017/07/29/fifo.html&quot;&gt;FIFO&lt;/a&gt;
to the user’s memory space.  These processed samples were then sent
to a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Network_socket&quot;&gt;socket&lt;/a&gt;
to be sent over
&lt;a href=&quot;https://en.wikipedia.org/wiki/Gigabit_Ethernet&quot;&gt;GigE&lt;/a&gt;
to a part of the system I had no control of.  To make this happen, the
&lt;a href=&quot;/blog/2017/07/29/fifo.html&quot;&gt;FIFO&lt;/a&gt;
was given the largest memory space I could afford, so that a vendor
optimized piece of code (i.e. the
&lt;a href=&quot;http://www.cplusplus.com/reference/cstring/memcpy/&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;memcpy()&lt;/code&gt;&lt;/a&gt;)
could just copy the memory from the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
to &lt;a href=&quot;https://en.wikipedia.org/wiki/Random-access_memory&quot;&gt;RAM&lt;/a&gt;.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig. 5. Memory Copy from FIFO to RAM&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/adc-memcpy.svg&quot; alt=&quot;MemCPY&quot; width=&quot;400&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;I’m sure the actual
&lt;a href=&quot;https://en.wikipedia.org/wiki/ARM_architecture&quot;&gt;ARM&lt;/a&gt;
&lt;a href=&quot;http://www.cplusplus.com/reference/cstring/memcpy/&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;memcpy()&lt;/code&gt;&lt;/a&gt;)
is a bit more complicated than the logic below, but the following is a basic
pseudocode outline of what the routine does:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;c1&quot;&gt;// Example memcpy
&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;	&lt;span class=&quot;nf&quot;&gt;memcpy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;size_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ln&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ln&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;ln&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Only … that’s not I the behavior I observed.&lt;/p&gt;

&lt;p&gt;Initially, all I knew was that the data coming out of the device was all
jumbled, and I couldn’t tell why.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig. 6. Counter Injection&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/counter-inject.svg&quot; alt=&quot;Injecting a counter following the A/Ds&quot; width=&quot;240&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;If you’ve never had to deal with a data acquisition process like this,
there’s one trick you need to have as part of your bag-of-tricks
to find stream-based processing bugs–the counter.  As shown in Fig 6 on the
right, the counter runs
along side the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Analog-to-digital_converter&quot;&gt;A/D&lt;/a&gt;
controller.  It increments with every sample.  A
user-configurable “switch” then selects whether the counter or the data is
sent down-stream.  If done right, you can then check the data values at
the end of your processing stream, and you can tell whether samples
were lost, corrupted, or worse–just by checking whether the ultimate
sample values still had the one-up relationship present with a counter.&lt;/p&gt;

&lt;p&gt;It was because this counter was not incrementing by one on every sample
that I knew I had a problem.&lt;/p&gt;

&lt;p&gt;So … I applied my
&lt;a href=&quot;/blog/2017/07/08/getting-started-with-wbscope.html&quot;&gt;scope&lt;/a&gt;
to the bus transaction.  My first thought was that I was somehow double
or triple stepping my
&lt;a href=&quot;/blog/2017/07/29/fifo.html&quot;&gt;FIFO&lt;/a&gt; on semi-random reads,
so I wanted to see what happened on a read from my
&lt;a href=&quot;/blog/2017/07/29/fifo.html&quot;&gt;FIFO&lt;/a&gt;.  Using this
&lt;a href=&quot;/blog/2017/07/08/getting-started-with-wbscope.html&quot;&gt;scope&lt;/a&gt;,
I discovered the &lt;a href=&quot;/blog/2017/07/29/fifo.html&quot;&gt;FIFO&lt;/a&gt;
was acting within normal limits.  However, the values
being read didn’t match the values in my code.&lt;/p&gt;

&lt;p&gt;Ok, so I adjusted the
&lt;a href=&quot;/blog/2017/07/08/getting-started-with-wbscope.html&quot;&gt;scope&lt;/a&gt;
and traced the problem up stream.  Things looked good there.&lt;/p&gt;

&lt;p&gt;So I adjusted my &lt;a href=&quot;/blog/2017/07/29/fifo.html&quot;&gt;FIFO&lt;/a&gt;
so that it would return the address pointer instead of
the data.  In this case, the
&lt;a href=&quot;http://www.cplusplus.com/reference/cstring/memcpy/&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;memcpy()&lt;/code&gt;&lt;/a&gt;)’d
buffer came back finally in order with no problems, but the
&lt;a href=&quot;/blog/2017/07/08/getting-started-with-wbscope.html&quot;&gt;scope&lt;/a&gt;
finally showed the problem.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/OUT-OF-ORDER.svg&quot; alt=&quot;&quot; width=&quot;480&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Instead of reading sample values 0, 1, 2, 3, 4, …, the
&lt;a href=&quot;https://en.wikipedia.org/wiki/ARM_architecture&quot;&gt;ARM&lt;/a&gt;
was reading sample values 0, 8, 16, 24, 1, 2, 3, 4, … and then quietly
reordering the samples back into what it thought was the “correct” order.
However, since the
&lt;a href=&quot;/blog/2017/07/29/fifo.html&quot;&gt;FIFO&lt;/a&gt;
based device was producing values in order in spite of the
out of order addresses, when the
&lt;a href=&quot;https://en.wikipedia.org/wiki/ARM_architecture&quot;&gt;ARM&lt;/a&gt;
rearranged the reads back in order–the result was the values in the buffer
were now &lt;em&gt;out of order&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Since knowing is half the battle, I now had two choices: I could fix the
&lt;a href=&quot;http://www.cplusplus.com/reference/cstring/memcpy/&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;memcpy()&lt;/code&gt;&lt;/a&gt;)
routine by writing one of my own that didn’t read out of order, or
I could shuffle the memory back into order.  I chose the former and wrote
my own
&lt;a href=&quot;http://www.cplusplus.com/reference/cstring/memcpy/&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;memcpy()&lt;/code&gt;&lt;/a&gt;), one where
I could &lt;em&gt;guarantee&lt;/em&gt; that the reads would be issued &lt;em&gt;in order&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;This new version of code &lt;em&gt;still&lt;/em&gt; read from my
&lt;a href=&quot;/blog/2017/07/29/fifo.html&quot;&gt;FIFO&lt;/a&gt;
out of order.&lt;/p&gt;

&lt;p&gt;As it turns out, it was the
&lt;a href=&quot;https://en.wikipedia.org/wiki/ARM_architecture&quot;&gt;ARM CPU&lt;/a&gt;
itself that caused the reads to be
issued out of order, and then quietly placed the memory back in order
on the other end.
However, if I rearranged my own memory copy to never
increment the “fake” address into the
&lt;a href=&quot;/blog/2017/07/29/fifo.html&quot;&gt;FIFO&lt;/a&gt;,
then it finally read it in order.&lt;/p&gt;

&lt;p&gt;I’ll say this much: I would’ve never figured this out without my &lt;a href=&quot;/blog/2017/07/08/getting-started-with-wbscope.html&quot;&gt;Wishbone
Scope&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;immediate-lessons-learned&quot;&gt;Immediate Lesson’s Learned&lt;/h2&gt;

&lt;p&gt;As with any attempt to use a new piece of technology you aren’t familiar with,
there will be hiccups.  The
&lt;a href=&quot;https://www.altera.com/products/fpga/cyclone-series/cyclone-v/overview.html&quot;&gt;Cyclone-V&lt;/a&gt;
on the
&lt;a href=&quot;http://www.terasic.com/cgi-bin/page/archive.pl?Language=English&amp;amp;No=1046&quot;&gt;DE10-Nano&lt;/a&gt;
was no exception.
Indeed, it took me almost a month of grumbling and confusion to get off the
ground before I discovered that, yes, the
&lt;a href=&quot;https://www.terasic.com.tw&quot;&gt;Terasic&lt;/a&gt;
&lt;a href=&quot;http://www.terasic.com.tw/cgi-bin/page/archive.pl?Language=English&amp;amp;CategoryNo=205&amp;amp;No=1046&amp;amp;PartNo=4&quot;&gt;documentation&lt;/a&gt;
&lt;em&gt;did&lt;/em&gt; show me how to interact with this device.  Here are some other
frustrations I came across:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;My first big frustration was &lt;a href=&quot;https://software.intel.com/en-us/articles/de10-nano-board-schematic&quot;&gt;the schematic&lt;/a&gt; I found online.  It took me some
time to realize that someone had posted a
&lt;a href=&quot;http://www.terasic.com/cgi-bin/page/archive.pl?Language=English&amp;amp;No=593&quot;&gt;DE0-Nano&lt;/a&gt;
schematic on an &lt;a href=&quot;https://software.intel.com/en-us/articles/de10-nano-board-schematic&quot;&gt;Intel
DE10-Nano support&lt;/a&gt; web-page.&lt;/p&gt;

    &lt;p&gt;Sadly, despite posting a comment to this effect, &lt;a href=&quot;https://software.intel.com/en-us/articles/de10-nano-board-schematic&quot;&gt;this official
Intel support page&lt;/a&gt; &lt;em&gt;still&lt;/em&gt; contains a link to the wrong schematic.&lt;/p&gt;

    &lt;p&gt;In the end, I needed to destroy and then recreate my project in
&lt;a href=&quot;https://www.altera.com/products/design-software/fpga-design/quartus-prime/download.html&quot;&gt;Quartus&lt;/a&gt;
just to convince myself that I had gotten rid of all of the references
to the wrong part.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;My next frustration was that I couldn’t find an
&lt;a href=&quot;https://www.altera.com&quot;&gt;Altera&lt;/a&gt; “Libraries” reference.&lt;/p&gt;

    &lt;p&gt;Perhaps I’m spoiled: &lt;a href=&quot;https://www.xilinx.com&quot;&gt;Xilinx&lt;/a&gt; offers a &lt;a href=&quot;https://www.xilinx.com/support/documentation/sw_manuals/xilinx14_7/7series_hdl.pdf&quot;&gt;libraries
guide&lt;/a&gt;
that gives you instructions for how to interface with any of the
hard components on the chip.  Hence, if I need a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Phase-locked_loop&quot;&gt;PLL&lt;/a&gt;,
I just put a reference to their
&lt;a href=&quot;https://en.wikipedia.org/wiki/Phase-locked_loop&quot;&gt;PLL&lt;/a&gt;
within my own code and off I go.&lt;/p&gt;

    &lt;p&gt;I couldn’t find a similar libraries guide for
&lt;a href=&quot;https://www.altera.com&quot;&gt;Altera&lt;/a&gt;.  Indeed, I probably
spent much too much time looking for it.&lt;/p&gt;

    &lt;p&gt;In the end, I just swallowed my aversion to working with GUI’s and built the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Phase-locked_loop&quot;&gt;PLL&lt;/a&gt;
I needed using &lt;a href=&quot;https://www.altera.com/products/design-software/fpga-design/quartus-prime/features/qts-platform-designer.html&quot;&gt;Platform
Designer&lt;/a&gt;.
Since resigning to use &lt;a href=&quot;https://www.altera.com/products/design-software/fpga-design/quartus-prime/features/qts-platform-designer.html&quot;&gt;Platform
Designer&lt;/a&gt;,
it has handled all of my needs to date–I just hate using GUI’s: they are
slow, and they can hide details where I’m not looking for them, etc.
Although, looking over the &lt;a href=&quot;https://www.altera.com/products/design-software/fpga-design/quartus-prime/features/qts-platform-designer.html&quot;&gt;Platform
Designer&lt;/a&gt;
generated data file in the end, it’s &lt;em&gt;just an XML file&lt;/em&gt;–one that submits
nicely to “diff”, and thus one I can use with
&lt;a href=&quot;https://git-scm.com&quot;&gt;git&lt;/a&gt;
quite nicely.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;My second problem had to deal with the “Golden H/W design”
&lt;a href=&quot;http://www.terasic.com.tw/cgi-bin/page/archive.pl?Language=English&amp;amp;CategoryNo=205&amp;amp;No=1046&amp;amp;PartNo=4&quot;&gt;provided by&lt;/a&gt;
&lt;a href=&quot;https://www.terasic.com.tw&quot;&gt;Terasic&lt;/a&gt; for the board.&lt;/p&gt;

    &lt;p&gt;Looking through this design with Altera’s &lt;a href=&quot;https://www.altera.com/products/design-software/fpga-design/quartus-prime/features/qts-platform-designer.html&quot;&gt;Platform
Designer&lt;/a&gt;,
I could easily identify a variety of things I didn’t need.  I dumped these
out of my project, and then cleaned up the result so that there were
only the components I needed, and then built the project.&lt;/p&gt;

    &lt;p&gt;It didn’t work.  The board would load and run the bootloader just fine.
The bootloader would load my
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
design, but would then fail to start Linux.  Not knowing how to debug Linux
loading to know what device was failing, how, or why, I just couldn’t
tell why not.&lt;/p&gt;

    &lt;p&gt;In the end, I went back and rebuilt the Golden Design
&lt;a href=&quot;http://www.terasic.com.tw/cgi-bin/page/archive.pl?Language=English&amp;amp;CategoryNo=205&amp;amp;No=1046&amp;amp;PartNo=4&quot;&gt;as provided&lt;/a&gt;,
and then only modified it for my application.  This worked.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;I really dislike vendor code that doesn’t match my own high quality coding
standards.&lt;/p&gt;

    &lt;p&gt;By this I mean two things.  First, I use &lt;code class=&quot;highlighter-rouge&quot;&gt;default_nettype none&lt;/code&gt; in all of
my designs.  It helps me avoid a whole variety of painful Verilog bugs.
However, a bug in the &lt;a href=&quot;https://www.altera.com&quot;&gt;Altera&lt;/a&gt;’s
&lt;a href=&quot;https://www.altera.com/products/fpga/cyclone-series/cyclone-v/overview.html&quot;&gt;Cyclone-V&lt;/a&gt;
IP would cause my design to fail if I tried to use this across my design.&lt;/p&gt;

    &lt;p&gt;With a little bit of help from an &lt;a href=&quot;http://www.clifford.at&quot;&gt;amazing mentor&lt;/a&gt;,
I managed to use &lt;code class=&quot;highlighter-rouge&quot;&gt;default_nettype none&lt;/code&gt; at the top of my files, and
&lt;code class=&quot;highlighter-rouge&quot;&gt;default_nettype wire&lt;/code&gt; at the bottom and
&lt;a href=&quot;https://www.altera.com&quot;&gt;Altera&lt;/a&gt;’s
broken code would still synthesize.&lt;/p&gt;

    &lt;p&gt;I then got all kinds of warnings from their “working” IP.  I mean, really
guys, can’t you clean up &lt;em&gt;your own&lt;/em&gt; IP?  How can I tell if my
implementation of your IP has problems if your IP fills the logs with
warnings–&lt;em&gt;when it works&lt;/em&gt;!?  (Incidentally,
&lt;a href=&quot;https://www.xilinx.com&quot;&gt;Xilinx&lt;/a&gt;’s code isn’t any
better, and &lt;a href=&quot;https://www.xilinx.com&quot;&gt;Xilinx&lt;/a&gt;’s MIG-generated
&lt;a href=&quot;https://en.wikipedia.org/wiki/DDR3_SDRAM&quot;&gt;DDR3 SDRAM&lt;/a&gt;
controller is a particular offender …)&lt;/p&gt;

    &lt;p&gt;The worst of these warnings said that I hadn’t mapped several pins
properly, and yet the pin mapping tool wouldn’t let me do anything with
these hardware-assigned yet somehow mis-mapped pins.  As with the
other warnings, these could be ignored, but how was I to know that when
things weren’t working?&lt;/p&gt;

    &lt;p&gt;Again, building the &lt;a href=&quot;http://www.terasic.com.tw/cgi-bin/page/archive.pl?Language=English&amp;amp;CategoryNo=205&amp;amp;No=1046&amp;amp;PartNo=4&quot;&gt;Golden H/W Reference Design&lt;/a&gt;
gave me some
confidence, as I could then see that I still got the same warnings
and yet for some outrageous reason, the
&lt;a href=&quot;http://www.terasic.com.tw/cgi-bin/page/archive.pl?Language=English&amp;amp;CategoryNo=205&amp;amp;No=1046&amp;amp;PartNo=4&quot;&gt;Golden Design&lt;/a&gt;
worked in spite of the warnings.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;This blog is about debugging
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;s,
though, so what did I learn from that standpoint?&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;One mistake in the
&lt;a href=&quot;https://www.altera.com/content/dam/altera-www/global/en_US/pdfs/literature/manual/mnl_avalon_spec.pdf&quot;&gt;Avalon bus&lt;/a&gt;
controller would lock up the device &lt;em&gt;HARD&lt;/em&gt;.&lt;/p&gt;

    &lt;p&gt;If this happened, the only solution appeared to be pulling power.&lt;/p&gt;

    &lt;p&gt;The &lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal&lt;/a&gt; proof
of the
&lt;a href=&quot;https://www.altera.com/content/dam/altera-www/global/en_US/pdfs/literature/manual/mnl_avalon_spec.pdf&quot;&gt;Avalon&lt;/a&gt;
to &lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;WB&lt;/a&gt;
converter created a bit of a false confidence for me: my design
still locked up at times.&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;
        &lt;p&gt;The first problem I had with my
&lt;a href=&quot;https://www.altera.com/content/dam/altera-www/global/en_US/pdfs/literature/manual/mnl_avalon_spec.pdf&quot;&gt;Avalon&lt;/a&gt;
bus interface
was that I somehow managed to &lt;em&gt;assume&lt;/em&gt; within my
proof that all transactions would be read transactions.  The assumption
wasn’t simple, and it wasn’t obvious, so I never realized what happened
from a simple desk check.&lt;/p&gt;

        &lt;p&gt;In the end, I figured out what was going on via
&lt;a href=&quot;/blog/2017/06/21/looking-at-verilator.html&quot;&gt;simulation&lt;/a&gt;.&lt;/p&gt;

        &lt;p&gt;When I went back to the
formal properties, I realized I hadn’t created
any “cover” properties, and that a simple “cover” property or two
would’ve revealed this problem.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;My next problem was when I mis-wired a bus component in
&lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt;.&lt;/p&gt;

        &lt;p&gt;For a given peripheral, the
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;WB strobe&lt;/a&gt;
value is given by the overall
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;wishbone strobe (a
transaction request)&lt;/a&gt;
&lt;a href=&quot;/blog/2017/06/22/simple-wb-interconnect.html&quot;&gt;logically &lt;code class=&quot;highlighter-rouge&quot;&gt;AND&lt;/code&gt;ed
with the peripheral’s address select line&lt;/a&gt;.  I had forgotten this
address select line logical &lt;code class=&quot;highlighter-rouge&quot;&gt;AND&lt;/code&gt; on one component, and so that
component was responding to &lt;em&gt;EVERY&lt;/em&gt; transaction across the bus–with
pretty catastrophic results.&lt;/p&gt;

        &lt;p&gt;As with the prior problem, I found this pretty quickly … once I fired
up the &lt;a href=&quot;/blog/2017/06/21/looking-at-verilator.html&quot;&gt;simulator&lt;/a&gt;.&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;/blog/2017/06/21/looking-at-verilator.html&quot;&gt;Simulator&lt;/a&gt;?
How …?&lt;/p&gt;

    &lt;p&gt;Yes.  Exactly.  I couldn’t simulate the
&lt;a href=&quot;https://en.wikipedia.org/wiki/ARM_architecture&quot;&gt;ARM&lt;/a&gt; processor, the
&lt;a href=&quot;https://en.wikipedia.org/wiki/DDR3_SDRAM&quot;&gt;DDR3 SDRAM&lt;/a&gt;,
the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Gigabit_Ethernet&quot;&gt;GigE&lt;/a&gt;
network, the lightweight
&lt;a href=&quot;http://www.gstitt.ece.ufl.edu/courses/fall15/eel4720_5721/labs/refs/AXI4_specification.pdf&quot;&gt;AXI&lt;/a&gt; bridge,
or the
&lt;a href=&quot;http://www.gstitt.ece.ufl.edu/courses/fall15/eel4720_5721/labs/refs/AXI4_specification.pdf&quot;&gt;AXI&lt;/a&gt; to
&lt;a href=&quot;https://www.altera.com/content/dam/altera-www/global/en_US/pdfs/literature/manual/mnl_avalon_spec.pdf&quot;&gt;Avalon&lt;/a&gt;
memory-mapped I/O bridge, but I could create a
&lt;a href=&quot;https://veripool.org/wiki/verilator&quot;&gt;Verilator&lt;/a&gt;-based
&lt;a href=&quot;/blog/2017/06/21/looking-at-verilator.html&quot;&gt;simulation&lt;/a&gt;
of the
&lt;a href=&quot;https://www.altera.com/content/dam/altera-www/global/en_US/pdfs/literature/manual/mnl_avalon_spec.pdf&quot;&gt;Avalon&lt;/a&gt;
bus interface on down–to include simulating
the &lt;a href=&quot;https://en.wikipedia.org/wiki/Analog-to-digital_converter&quot;&gt;A/D&lt;/a&gt;s.
That portion of the design was a fairly straight-forward
&lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt;
based implementation, and even though it wasn’t a full-design
&lt;a href=&quot;/blog/2017/06/21/looking-at-verilator.html&quot;&gt;simulation&lt;/a&gt;,
it was enough to
&lt;a href=&quot;/blog/2017/06/21/looking-at-verilator.html&quot;&gt;simulate&lt;/a&gt;
enough of the design to find many problems.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Given my experiences with an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
+ &lt;a href=&quot;https://en.wikipedia.org/wiki/ARM_architecture&quot;&gt;ARM&lt;/a&gt;
architecture, would I recommend it for others?  As with any engineering
decision, your choice will depend upon the requirements of your problem.
However, I would have &lt;em&gt;really&lt;/em&gt; struggled if this had been my first-ever
design.  Hence, I’d recommend beginners start with something simpler–such
as a plain
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
with an on-board (debuggable)
&lt;a href=&quot;https://en.wikipedia.org/wiki/Soft_microprocessor&quot;&gt;soft-core CPU&lt;/a&gt;,
before adding the &lt;a href=&quot;https://en.wikipedia.org/wiki/ARM_architecture&quot;&gt;ARM&lt;/a&gt;
to the mix.&lt;/p&gt;

&lt;h2 id=&quot;conclusions&quot;&gt;Conclusions&lt;/h2&gt;

&lt;p&gt;There’s more I could say, but this post is long enough as is.  I’d like to be
able to blog some more about the
&lt;a href=&quot;https://www.altera.com/content/dam/altera-www/global/en_US/pdfs/literature/manual/mnl_avalon_spec.pdf&quot;&gt;Avalon&lt;/a&gt;
to &lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;WB&lt;/a&gt;
bridge and how I managed to formally verify it,
how easy it is to suddenly add a
&lt;a href=&quot;/blog/2017/07/08/getting-started-with-wbscope.html&quot;&gt;scope&lt;/a&gt;
to a design using
&lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt;,
or indeed how powerful
&lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt;
is in general.&lt;/p&gt;

&lt;p&gt;These discussions will sadly need to wait for a later day.&lt;/p&gt;

&lt;hr /&gt;&lt;p&gt;&lt;em&gt;If we say that we have not sinned, we make him a liar, and his word is not in us. (1John 1:9)&lt;/em&gt;</description>
        <pubDate>Fri, 09 Feb 2018 00:00:00 -0500</pubDate>
        <link>http://zipcpu.com/blog/2018/02/09/first-cyclonev.html</link>
        <guid isPermaLink="true">http://zipcpu.com/blog/2018/02/09/first-cyclonev.html</guid>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>ZipCPU toolchain and initial test</title>
        <description>&lt;p&gt;Please accept my apologies for taking so long to put this article together.
I’ve made a lot of changes to the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
in order to &lt;a href=&quot;/zipcpu/2018/01/22/formal-progress.html&quot;&gt;formally
prove&lt;/a&gt;
the components.  I’ve also cleaned out all of the issues in the issue-tracker
on &lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;Github&lt;/a&gt;.  These changes have now been
integrated into &lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;the baseline&lt;/a&gt;.
They have been confirmed to build within
&lt;a href=&quot;http://www.clifford.at/yosys/&quot;&gt;yosys&lt;/a&gt;,
&lt;a href=&quot;https://www.xilinx.com/products/design-tools/ise-design-suite.html&quot;&gt;ISE&lt;/a&gt;,
&lt;a href=&quot;https://www.xilinx.com/products/design-tools/vivado.html&quot;&gt;Vivado&lt;/a&gt;,
and
&lt;a href=&quot;https://veripool.org/wiki/verilator&quot;&gt;Verilator&lt;/a&gt;.
Further, the new changes have been proven on the
&lt;a href=&quot;https://github.com/ZipCPU/zbasic&quot;&gt;ZBasic&lt;/a&gt; distribution–just not within an
actual &lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
(yet).  Further, when measuring the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Logic_block&quot;&gt;LUT&lt;/a&gt;
usage impact of the changes that
have been made, they appear to require no more than four extra
&lt;a href=&quot;https://en.wikipedia.org/wiki/Logic_block&quot;&gt;LUT&lt;/a&gt;s–suggesting the 
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
remains on target to be a low-logic
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Integration with
&lt;a href=&quot;https://github.com/olofk/fusesoc&quot;&gt;FuseSoC&lt;/a&gt;
is still now, perhaps more firmly than ever, on my to-do list.&lt;/p&gt;

&lt;p&gt;With that aside, let’s look into how you might get started.&lt;/p&gt;

&lt;h2 id=&quot;introduction&quot;&gt;Introduction&lt;/h2&gt;

&lt;p&gt;Let’s spend a couple of posts discussing how to fire up the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
and run it.  Our goal will be to show how the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
can be used to control a signal processing application.  That, however,
will take a couple of posts to get to.  For this first post, let’s
just discuss how to get the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
tool chain up and running, and then how to test and know that the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt;
itself works.&lt;/p&gt;

&lt;p&gt;If you look at the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;’s
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/README.md&quot;&gt;README file&lt;/a&gt;, you’ll
read that the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
is only one component of a (potentially) much larger system.  For example,
consider the
&lt;a href=&quot;https://github.com/ZipCPU/zbasic&quot;&gt;ZBasic&lt;/a&gt;
system in the figure below.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 1. ZBasic Components and Peripherals&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/zbasic-blok.svg&quot; alt=&quot;&quot; width=&quot;730&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/ZipCPU/zbasic&quot;&gt;This system&lt;/a&gt;
was designed to be a generic system that could demonstrate the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;’s
capabilities.  If you notice, the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
is only a small part of this full system.  Likewise, the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/zipsystem.v&quot;&gt;ZipSystem&lt;/a&gt;,
a container for the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
with some peripherals connected close to the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt;,
is still only a small portion of any full design.  To make a full design from
just a &lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt;, the
&lt;a href=&quot;https://github.com/ZipCPU/zbasic&quot;&gt;ZBasic&lt;/a&gt;
project also contains a
&lt;a href=&quot;https://github.com/ZipCPU/wbuart32&quot;&gt;serial port&lt;/a&gt;, a &lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/rtl/memdev.v&quot;&gt;block
RAM&lt;/a&gt;, a &lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/rtl/wbqspiflash.v&quot;&gt;flash (ROM)
controller&lt;/a&gt;,
an (optional)
&lt;a href=&quot;https://github.com/ZipCPU/sdspi&quot;&gt;SPI-mode SD-Card controller&lt;/a&gt;, and
(currently) a
&lt;a href=&quot;https://github.com/ZipCPU/wbscope&quot;&gt;scope&lt;/a&gt; for the
&lt;a href=&quot;https://github.com/ZipCPU/sdspi&quot;&gt;SD-card controller&lt;/a&gt;
as well.  There are also some smaller components, such as a
&lt;a href=&quot;https://github.com/ZipCPU/rtcclock&quot;&gt;real-time clock&lt;/a&gt;, a
&lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/auto-data/pwrcount.txt&quot;&gt;counter-since-power
up&lt;/a&gt;,
a second &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/icontrol.v&quot;&gt;interrupt
controller&lt;/a&gt;,
the &lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/auto-data/version.txt&quot;&gt;date of the last time the system was
built&lt;/a&gt;
 and so forth.&lt;/p&gt;

&lt;p&gt;As with all of my designs, the &lt;a href=&quot;https://github.com/ZipCPU/zbasic&quot;&gt;ZBasic design&lt;/a&gt;
also has a &lt;a href=&quot;/blog/2017/06/05/wb-bridge-overview.html&quot;&gt;debugging bus
controller&lt;/a&gt;
that can be used to control the bus within the core from an external
&lt;a href=&quot;https://github.com/ZipCPU/wbuart32&quot;&gt;serial port&lt;/a&gt;.  This version of the
debugging bus controller, however, multiplexes two 7-bit
channels onto an 8-bit serial port channel–unlike the &lt;a href=&quot;/blog/2017/06/05/wb-bridge-overview.html&quot;&gt;one we discussed
earlier&lt;/a&gt;.
This creates a
&lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/rtl/wbconsole.v&quot;&gt;console port&lt;/a&gt;
for the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt;, in addition to the
&lt;a href=&quot;/blog/2017/06/05/wb-bridge-overview.html&quot;&gt;debugging bus controller&lt;/a&gt;.
This makes it possible to experiment with the
&lt;a href=&quot;https://github.com/ZipCPU/zbasic&quot;&gt;ZBasic&lt;/a&gt;
module on any
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
board having only a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Serial_Peripheral_Interface_Bus&quot;&gt;QSPI&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt; and a
&lt;a href=&quot;https://github.com/ZipCPU/wbuart32&quot;&gt;serial port&lt;/a&gt;.  The
&lt;a href=&quot;https://github.com/ZipCPU/sdspi&quot;&gt;SDCard&lt;/a&gt; port is optional, and by using
&lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt;, the block RAM can easily be
resized.&lt;/p&gt;

&lt;p&gt;Our eventual goal in this series of articles will be to show how to run
this &lt;a href=&quot;https://github.com/ZipCPU/zbasic&quot;&gt;ZBasic design&lt;/a&gt;,
while simulating all of the components, from within
&lt;a href=&quot;/blog/2017/06/21/looking-at-verilator.html&quot;&gt;Verilator&lt;/a&gt;.  As
part of this goal, we’ll also add a
&lt;a href=&quot;https://github.com/ZipCPU/wbpmic&quot;&gt;MEMs based audio A/D&lt;/a&gt;
and may possibly even add an &lt;a href=&quot;https://github.com/ZipCPU/xulalx25soc/blob/master/rtl/wbsdram.v&quot;&gt;SDRAM
controller&lt;/a&gt;.
We’ll even use the &lt;a href=&quot;https://sourceware.org/newlib&quot;&gt;C-library&lt;/a&gt; to demonstrate a
&lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/sw/board/hello.c&quot;&gt;Hello World
example&lt;/a&gt;,
and possibly even to play &lt;a href=&quot;https://github.com/ZipCPU/tttt&quot;&gt;4x4x4 Tic-Tac-Toe&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;That will be the goal of this series.&lt;/p&gt;

&lt;p&gt;Today’s goal, however, will just be to examine the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
by itself.  To do so, we’ll trace a piece
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; history,
and run the very first piece of software ever written for the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;the-initial-zipcpu-test-software&quot;&gt;The Initial ZipCPU Test Software&lt;/h2&gt;

&lt;p&gt;The very first  piece of software I wrote for the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
just demonstrated each of the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt;’s
instructions, and its ability to execute them.&lt;/p&gt;

&lt;p&gt;The initial version of this test was created by a test generator piece of
software that at one time wrote a couple of machine code instructions
into a binary file which would then describe the block RAM memory image
for the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt;.
I was so excited to get this simple code to work!  Little did I know how
much more work would be involved in finding all the corner cases within any
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;.
This piece of code, however, is now only relic-ware.  Indeed, it is not only
a couple of &lt;a href=&quot;/zipcpu/2018/01/01/zipcpu-isa.html&quot;&gt;instruction set
architecture&lt;/a&gt;
versions out of date, but since it was causing build errors for users it has
since been removed from the repository entirely.&lt;/p&gt;

&lt;p&gt;With the introduction of the first
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/tree/master/sw/zasm&quot;&gt;assembler&lt;/a&gt;,
the program that generated machine code was replaced with an &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/bench/asm/simtest.s&quot;&gt;assembly
file&lt;/a&gt;.
Even though that
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/tree/master/sw/zasm&quot;&gt;initial assembler&lt;/a&gt;
has now also become relic-ware, the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/bench/asm/simtest.s&quot;&gt;assembly
file&lt;/a&gt;
test has been maintained to the point that it can still
be assembled using the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/sw/gas-zippatch.patch&quot;&gt;version of
binutils&lt;/a&gt;.
Unlike the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/tree/master/sw/zasm&quot;&gt;original assembler&lt;/a&gt;,
&lt;a href=&quot;https://www.gnu.org/software/binutils&quot;&gt;binutils&lt;/a&gt;
provides several valuable capabilities–such as the ability to link multiple
files together, the ability to follow a script describing where memory and/or
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt;
are located, the ability to place an initial RAM image in
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt;,
and even the ability to integrate with &lt;a href=&quot;https://gcc.gnu.org&quot;&gt;GCC&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;This &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/bench/asm/simtest.s&quot;&gt;remaining piece of
software/testware&lt;/a&gt;
starts with a branch-always followed by break test–just to make certain the
&lt;a href=&quot;/zipcpu/2017/08/23/cpu-pipeline.html&quot;&gt;pipeline&lt;/a&gt;
works.  It then continues by testing some basic register setting commands.
It was meant to be run within a &lt;a href=&quot;/zipcpu/2017/07/26/cpu-sim-debugger.html&quot;&gt;monitor
program&lt;/a&gt;.
Using this program, you can step through this software one clock cycle at a
time–just like &lt;a href=&quot;/zipcpu/2017/07/26/cpu-sim-debugger.html&quot;&gt;we discussed
earlier&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Let’s build and run
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/bench/asm/simtest.s&quot;&gt;this program&lt;/a&gt;
today, to give us some confidence that the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt;
itself continues to work.&lt;/p&gt;

&lt;h2 id=&quot;building-the-tools&quot;&gt;Building the tools&lt;/h2&gt;

&lt;p&gt;The first step in converting any
&lt;a href=&quot;https://en.wikipedia.org/wiki/Assembly_language&quot;&gt;assembly file&lt;/a&gt; into &lt;a href=&quot;https://en.wikipedia.org/wiki/Machine_code&quot;&gt;machine
code&lt;/a&gt;
is to acquire (or build) an &lt;a href=&quot;https://www.gnu.org/software/binutils&quot;&gt;assembler and
linker&lt;/a&gt;.  The
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
has backend support for &lt;a href=&quot;https://www.gnu.org/software/binutils&quot;&gt;binutils (assembler and
linker)&lt;/a&gt;, the
&lt;a href=&quot;https://gcc.gnu.org&quot;&gt;GCC C-compiler&lt;/a&gt;, and
&lt;a href=&quot;https://sourcewaire.org/newlib&quot;&gt;newlib&lt;/a&gt;.  Although only
&lt;a href=&quot;https://www.gnu.org/software/binutils&quot;&gt;binutils&lt;/a&gt;
is required for this &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/bench/asm/simtest.s&quot;&gt;testing
program&lt;/a&gt;,
all of the tools are built from the same command, so let’s build them together.&lt;/p&gt;

&lt;p&gt;To build the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
tool-suite, first make sure you have the prerequisites
for &lt;a href=&quot;https://gcc.gnu.org&quot;&gt;GCC&lt;/a&gt;.  For debian based systems, this will look like:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;sudo apt install flex bison libbison-dev libgmp-dev libmpfr-dev libmpc-dev bc&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;You’ll notice several &lt;code class=&quot;highlighter-rouge&quot;&gt;*-dev&lt;/code&gt; components.  These are different from their non
&lt;code class=&quot;highlighter-rouge&quot;&gt;-dev&lt;/code&gt; counterparts, in that they allow you to build components using these
libraries rather than just using binary components already built.  In other
words, installing &lt;code class=&quot;highlighter-rouge&quot;&gt;gmp&lt;/code&gt; isn’t good enough, you’ll need to install &lt;code class=&quot;highlighter-rouge&quot;&gt;libgmp-dev&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;You are also going to need &lt;a href=&quot;https://www.veripool.org/wiki/verilator&quot;&gt;Verilator&lt;/a&gt;
to translate
the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;’s Verilog source code into
the C++ necessary to simulate it,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;sudo apt install verilator&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The &lt;a href=&quot;/zipcpu/2017/07/26/cpu-sim-debugger.html&quot;&gt;simulation&lt;/a&gt;
driver needs
&lt;a href=&quot;http://www.mr511.de/software/english.html&quot;&gt;libelf&lt;/a&gt; in order to know
where to load programs and program components into memory,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;sudo apt install libelf-dev&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Please note that, as with the earlier components, this package is the
development version of
&lt;a href=&quot;http://www.mr511.de/software/english.html&quot;&gt;libelf&lt;/a&gt;.  We’ll need that version
to build a program that uses it that can read and process an ELF file.&lt;/p&gt;

&lt;p&gt;Many of my distributions depend upon &lt;a href=&quot;http://ctags.sourceforge.net&quot;&gt;ctags&lt;/a&gt;,
and the &lt;a href=&quot;/zipcpu/2017/07/26/cpu-sim-debugger.html&quot;&gt;simulation control
program&lt;/a&gt;
is written using
&lt;a href=&quot;https://www.gnu.org/software/ncurses&quot;&gt;ncurses&lt;/a&gt;, so let’s get those as well:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;sudo apt install ncurses-dev ctags&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;If you are using Windows,
&lt;a href=&quot;/blog/2017/07/28/cygwin-fpga.html&quot;&gt;these instructions&lt;/a&gt;
should get you started using these tools via &lt;a href=&quot;https://cygwin.com&quot;&gt;cygwin&lt;/a&gt;.
Since I’m not using Windows regularly, please let me know if you have any
problems building with &lt;a href=&quot;https://cygwin.com&quot;&gt;cygwin&lt;/a&gt;–I’ll probably never notice
the problem otherwise.&lt;/p&gt;

&lt;p&gt;One you have these prerequisites, it is now time to actually clone
the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
repository,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;git clone --depth 1 https://github.com/ZipCPU/zipcpu
&lt;span class=&quot;nb&quot;&gt;cd &lt;/span&gt;zipcpu&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;While you may have cloned repositories without the &lt;code class=&quot;highlighter-rouge&quot;&gt;depth&lt;/code&gt; command, doing so
with the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;repository&lt;/a&gt; will also download a history
containing several versions of &lt;a href=&quot;https://gcc.gnu.org&quot;&gt;GCC&lt;/a&gt;.  In other words,
you’ll be spending a lot of bandwidth downloading more of the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;repository&lt;/a&gt; than you need.&lt;/p&gt;

&lt;p&gt;At this point, you &lt;em&gt;should&lt;/em&gt; be able to just type “make”.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;make&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This will orchestrate a
&lt;a href=&quot;https://www.veripool.org/wiki/verilator&quot;&gt;Verilator&lt;/a&gt;-based
make of the “&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/tree/master/rtl&quot;&gt;rtl/&lt;/a&gt;”
directory, and a build of the simulation
directory, “&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/tree/master/sim/verilator&quot;&gt;sim/verilator&lt;/a&gt;”.  It will also trigger a build of the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
tool-suite that we’ll need to turn the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/bench/asm/simtest.s&quot;&gt;simulation test
file&lt;/a&gt;
from &lt;a href=&quot;/zipcpu/2018/01/01/zipcpu-isa.html&quot;&gt;assembly&lt;/a&gt; into
&lt;a href=&quot;https://en.wikipedia.org/wiki/Machine_code&quot;&gt;object code&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The current version of the tools will be built and placed into a “sw/install”
directory within the cloned repository of the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;.
Before going further, you will need to make certain that this directory
is a part of your path.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span class=&quot;nb&quot;&gt;export &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;PATH&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$PATH&lt;/span&gt;:&amp;lt;your-path-to-zipcpu&amp;gt;/sw/install/cross-tools/bin&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;I am very interested in any struggles you may have during this process.
Please create an issue on
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;GitHub&lt;/a&gt; if you have any errors up to this
point.&lt;/p&gt;

&lt;h2 id=&quot;running-the-test-file&quot;&gt;Running the test file&lt;/h2&gt;

&lt;p&gt;Now that you have the tool suite, and now that your &lt;code class=&quot;highlighter-rouge&quot;&gt;PATH&lt;/code&gt; environment
variable has been modified so that &lt;code class=&quot;highlighter-rouge&quot;&gt;zip-as&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;zip-cpp&lt;/code&gt; are in
your path, then it is now time to build the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/bench/asm/simtest.s&quot;&gt;simulation test
file&lt;/a&gt;.
For this, we’ll change into the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/bench/asm&quot;&gt;bench/asm&lt;/a&gt;,
and run &lt;code class=&quot;highlighter-rouge&quot;&gt;make simtest&lt;/code&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span class=&quot;nb&quot;&gt;cd &lt;/span&gt;bench/asm
make simtest&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;You can also build a disassembly file of the result, in case you are ever
interested in what the original instructions actually build into, by&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;make simtest.txt&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Once built, we can change into the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/tree/master/sim/verilator/&quot;&gt;Verilator based simulation
directory&lt;/a&gt;,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span class=&quot;nb&quot;&gt;cd&lt;/span&gt; ../..
&lt;span class=&quot;nb&quot;&gt;cd &lt;/span&gt;sim/verilator&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;From here, you can run the automated tests.  There are two such tests,
both based off of the same &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/bench/asm/simtest.s&quot;&gt;simulated test&lt;/a&gt; instructions.&lt;/p&gt;

&lt;p&gt;The first automated test just runs the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/bench/asm/simtest.s&quot;&gt;test&lt;/a&gt;
file, using the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;’s
&lt;a href=&quot;/zipcpu/2017/85/25/hw-debugging.html&quot;&gt;debug interface&lt;/a&gt;
and particularly the &lt;em&gt;step&lt;/em&gt; instruction provided by that interface–the
same &lt;em&gt;step&lt;/em&gt; control that the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt;
would use were it placed on actual hardware.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;./zipsys_tb -s ../../bench/asm/simtest&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;To know when the test is complete, the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/bench/asm/simtest.s&quot;&gt;test file&lt;/a&gt;
has been designed to “end” in one of two states.  It will either end with
1) a halt instruction (successful exit), or 2) a BUSY instruction (error exit).
The &lt;a href=&quot;/zipcpu/2017/07/26/cpu-sim-debugger.html&quot;&gt;simulator&lt;/a&gt;
will detect this interface, and return an appropriate value to the shell.&lt;/p&gt;

&lt;p&gt;The second automated test simulates how the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt; would run if it were actually
running on the device without the
&lt;a href=&quot;/zipcpu/2017/85/25/hw-debugging.html&quot;&gt;debugging interface&lt;/a&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;./zipsys_tb -a ../../bench/asm/simtest&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;These two tests are so valuable to me, that I have a make target set up
just to run both of them,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;make &lt;span class=&quot;nb&quot;&gt;test&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;There’s a third way to run the test as well–the interactive test.  Although
starting the run is just as simple,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;make itest&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;there are more details involved in commanding it, which we’ll get into in the
next section.&lt;/p&gt;

&lt;p&gt;Further, no matter how you run this
&lt;a href=&quot;/zipcpu/2017/07/26/cpu-sim-debugger.html&quot;&gt;simulator&lt;/a&gt;,
it will (currently) always create a
&lt;a href=&quot;/blog/2017/07/31/vcd.html&quot;&gt;VCD trace file&lt;/a&gt;.  You are
welcome to open this file in a waveform viewer to see the internal signals
within the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; if you would like.
This isn’t true of the 
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
&lt;a href=&quot;/zipcpu/2017/07/26/cpu-sim-debugger.html&quot;&gt;simulator&lt;/a&gt;
within the
&lt;a href=&quot;https://github.com/ZipCPU/zbasic&quot;&gt;ZBasic&lt;/a&gt; repository–since the trace files
for &lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/sim/verilated/automaster_tb.cpp&quot;&gt;that simulator&lt;/a&gt;
can easily grow to many Gigabytes in length, that one is turned off by default.
In this case, though, the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/bench/asm/simtest.s&quot;&gt;simtest
file&lt;/a&gt;
is short enough that the
&lt;a href=&quot;/blog/2017/07/31/vcd.html&quot;&gt;VCD trace file&lt;/a&gt;
should remain within a reasonable size.&lt;/p&gt;

&lt;h2 id=&quot;interactive-commands&quot;&gt;Interactive Commands&lt;/h2&gt;

&lt;p&gt;Now that you know how to start the &lt;a href=&quot;/zipcpu/2017/07/26/cpu-sim-debugger.html&quot;&gt;simulation based
debugger&lt;/a&gt;
let’s spend some time describing how to work operate it.  As you’ll recall
from the last section, starting the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
&lt;a href=&quot;/zipcpu/2017/07/26/cpu-sim-debugger.html&quot;&gt;simulation based
debugger&lt;/a&gt; is easy.
Just run&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;make itest&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;from the “&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/tree/master/sim/verilated&quot;&gt;sim/verilated&lt;/a&gt;”
subdirectory.&lt;/p&gt;

&lt;p&gt;This will apply the
&lt;a href=&quot;/zipcpu/2017/07/26/cpu-sim-debugger.html&quot;&gt;simulation&lt;/a&gt;
to the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/bench/asm/simtest.s&quot;&gt;simtest
file&lt;/a&gt;.
To start it with another file you can run,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;./zipsys_tb &amp;lt;your-executable-file&amp;gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Knowing what to do next isn’t quite as simple.  Sure, either hitting the
escape key or ‘q’ will exit, but you can do a lot more.  Here’s a cheat sheet
so you’ll know what to do.  Specifically, the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
&lt;a href=&quot;/zipcpu/2017/07/26/cpu-sim-debugger.html&quot;&gt;simulator&lt;/a&gt;
understands the following command keys:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;‘h’ Halts the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;‘g’ tells the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt;
to &lt;em&gt;go&lt;/em&gt; until given another command.&lt;/li&gt;
  &lt;li&gt;‘G’ does the same thing, but only updates the screen any time a user types
a character.  It’s useful for moving quickly through a long simulation if
necessary.&lt;/li&gt;
  &lt;li&gt;‘r’ gives the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt; the reset command,
sending it back to supervisor mode and the reset address&lt;/li&gt;
  &lt;li&gt;’s’ &lt;em&gt;steps&lt;/em&gt; the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt; using the
&lt;a href=&quot;/zipcpu/2017/08/25/hw-debugging.html&quot;&gt;debugging interface&lt;/a&gt;
that will exist within the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
implementation&lt;/li&gt;
  &lt;li&gt;‘t’ &lt;em&gt;ticks&lt;/em&gt; the clock.  It steps the
&lt;a href=&quot;/blog/2017/06/21/looking-at-verilator.html&quot;&gt;Verilator&lt;/a&gt;
&lt;a href=&quot;/zipcpu/2017/07/26/cpu-sim-debugger.html&quot;&gt;simulation&lt;/a&gt;
by one clock tick, but done in such a fashion that the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt;’s
Verilog logic doesn’t know it’s being stepped.&lt;/li&gt;
  &lt;li&gt;‘T’ releases the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt;
from the &lt;a href=&quot;/zipcpu/2017/08/25/hw-debugging.html&quot;&gt;hardware debugging
mode&lt;/a&gt;.  This is
useful if you’ve been giving it the &lt;em&gt;step&lt;/em&gt; command (separate from ticking
the clock), and you want the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt; to continue without being given
explicit &lt;em&gt;step&lt;/em&gt; instructions.&lt;/li&gt;
  &lt;li&gt;‘q’ quits the simulation&lt;/li&gt;
  &lt;li&gt;Ctrl-L redraws the screen.  This used to be really important when running
a &lt;a href=&quot;https://www.gnu.org/software/ncurses&quot;&gt;curses&lt;/a&gt;
program over a modem connection–any time someone else in the house
would pick up the phone, you’d get a bunch of garbage on the screen and your
computer would need to re-sync.  While it’s not as necessary today, I did
find it necessary to add this capability in–specifically for the case
where I have
&lt;a href=&quot;https://gtkwave.sourceforge.net&quot;&gt;GTKWave&lt;/a&gt;
running in the background spewing warnings over my screen anytime I
update the display.&lt;/li&gt;
  &lt;li&gt;‘u’ switches the performance times to show user mode performance&lt;/li&gt;
  &lt;li&gt;‘m’ switches the performance times to show global machine performance&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;If this is your first experience with the
&lt;a href=&quot;/zipcpu/2017/07/26/cpu-sim-debugger.html&quot;&gt;simulator&lt;/a&gt;,
just remember three
characters: ‘t’ steps it forward, ‘r’ restarts it, and ‘q’ exits.  You might
just wish to press ‘t’ several times and watch what happens.  If that gets
boring, try typing ‘g’–you can stop the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
anytime by typing ‘t’ later to return to single-clock-tick mode.&lt;/p&gt;

&lt;p&gt;The &lt;a href=&quot;/zipcpu/2017/07/26/cpu-sim-debugger.html&quot;&gt;simulator&lt;/a&gt;
also has the ability to adjust and change registers.  You
can move around the display using the arrow keys.  When you get to a register
you wish to adjust, press the enter key, type the new number, and then press
enter (to set the value) or escape (to leave the mode).&lt;/p&gt;

&lt;h2 id=&quot;understanding-the-interactive-display&quot;&gt;Understanding the Interactive Display&lt;/h2&gt;

&lt;p&gt;So let’s look at what this interface tells us.&lt;/p&gt;

&lt;p&gt;When you initially start the
&lt;a href=&quot;/zipcpu/2017/07/26/cpu-sim-debugger.html&quot;&gt;simulator&lt;/a&gt;,
you’ll see a screen looking like Fig 2 below.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 2, Initial Simulator Screen&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/zipsim-initial.png&quot; alt=&quot;&quot; width=&quot;562&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Let’s break down the components of this view, so that you can understand what’s
going on.  Fig 3. therefore shows the basic sections of the
&lt;a href=&quot;/zipcpu/2017/07/26/cpu-sim-debugger.html&quot;&gt;simulation&lt;/a&gt;
screen.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 3. Components of the simulation screen&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/zipsim-overview.svg&quot; alt=&quot;&quot; width=&quot;562&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Starting at the top are two lines describing the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/zipsystem.v&quot;&gt;ZipSystem&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/tree/master/peripherals&quot;&gt;peripherals&lt;/a&gt;.  These
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/tree/master/peripherals&quot;&gt;peripherals&lt;/a&gt;
are shown in the blue box of Fig 1 above, they consist of an &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/icontrol.v&quot;&gt;interrupt
controller (PIC)&lt;/a&gt;, a
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/ziptimer.v&quot;&gt;watchdog timer (WDT)&lt;/a&gt;, a
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/wbwatchdog.v&quot;&gt;bus watchdog (WBUS)&lt;/a&gt;, and the second
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/icontrol.v&quot;&gt;interrupt control register (PIC2)&lt;/a&gt;.  Judging from these
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/tree/master/peripherals&quot;&gt;peripherals&lt;/a&gt;,
you can tell if (for example) interrupts are enabled, or an interrupt is
pending.  On the next line are the three
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/ziptimer.v&quot;&gt;count-down timers (TMRA-TMRC)&lt;/a&gt;, and
a &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/zipjiffies.v&quot;&gt;Jiffies&lt;/a&gt;
peripheral for controlling absolute rather than relative programmable
interrupt timing.  (This would be useful for real-time task scheduling.)&lt;/p&gt;

&lt;p&gt;The next line, starting with &lt;code class=&quot;highlighter-rouge&quot;&gt;MTSK&lt;/code&gt;, shows the values of four
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/peripherals/zipcounter.v&quot;&gt;performance counters&lt;/a&gt;.  The first counts the number clock ticks, and the last counts
the number of instructions retired.  The two in the middle count how often the
operands stage of the
&lt;a href=&quot;/zipcpu/2017/08/23/cpu-pipeline.html&quot;&gt;pipeline&lt;/a&gt; is stalled,
and how often the
&lt;a href=&quot;/zipcpu/2017/11/18/wb-prefetch.html&quot;&gt;prefetch&lt;/a&gt;
is stalled.  These are global counters.  They count whether the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt;
is in &lt;a href=&quot;/zipcpu/2018/01/01/zipcpu-isa.html&quot;&gt;supervisor mode or user
mode&lt;/a&gt;.  There’s a
second set of identical
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/peripherals/zipcounter.v&quot;&gt;counters&lt;/a&gt;,
revealed by typing &lt;code class=&quot;highlighter-rouge&quot;&gt;u&lt;/code&gt; within the
&lt;a href=&quot;/zipcpu/2017/07/26/cpu-sim-debugger.html&quot;&gt;simulation&lt;/a&gt;,
showing the same basic values–but this second set only increments
while in user mode.  This makes it possible to measure per user-task statistics.&lt;/p&gt;

&lt;p&gt;Further information regarding these
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/tree/master/peripherals&quot;&gt;peripherals&lt;/a&gt;,
and the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/peripherals/zipcounter.v&quot;&gt;performance
counters&lt;/a&gt;
may be found within the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/raw/master/doc/spec.pdf&quot;&gt;reference manual&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The third section of the display in Fig 3 is the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt;
register section.  As you may
&lt;a href=&quot;/zipcpu/2018/01/01/zipcpu-isa.html&quot;&gt;recall&lt;/a&gt;, the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
has two sets of sixteen 32-bit registers.  These are shown in this section.
The registers range from R0 to R12, and then the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Stack_register&quot;&gt;stack pointer (SP)&lt;/a&gt;,
&lt;a href=&quot;https://en.wikipedia.org/wiki/Status_register&quot;&gt;condition codes register (CC)&lt;/a&gt;,
and &lt;a href=&quot;https://en.wikipedia.org/wiki/Program_counter&quot;&gt;program counter (PC)&lt;/a&gt;.
The supervisor set is shown on top, the user set underneath.  The set that
is highlighted indicates which mode the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt;
is currently in–in this case, the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt;
is in supervisor mode.&lt;/p&gt;

&lt;p&gt;The fourth section, coming down from the top, tells you about the bus.
The &lt;code class=&quot;highlighter-rouge&quot;&gt;PF BUS&lt;/code&gt; line gives you information about the
&lt;a href=&quot;/zipcpu/2017/11/18/wb-prefetch.html&quot;&gt;prefetch&lt;/a&gt;
unit, and the &lt;code class=&quot;highlighter-rouge&quot;&gt;MEMBUS&lt;/code&gt; line tells you about the memory module.  The third line
shows the result of the output of the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/ex/wbdblpriarb.v&quot;&gt;arbiter&lt;/a&gt;,
and which of these units actually has access to the bus.&lt;/p&gt;

&lt;p&gt;The final section shows the &lt;a href=&quot;/zipcpu/2017/08/23/cpu-pipeline.html&quot;&gt;instruction
pipeline&lt;/a&gt;.  As you may
&lt;a href=&quot;/zipcpu/2017/08/23/cpu-pipeline.html&quot;&gt;remember&lt;/a&gt;, the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
has a basic five stage &lt;a href=&quot;/zipcpu/2017/08/23/cpu-pipeline.html&quot;&gt;pipeline&lt;/a&gt;.  The bottom of the display shows only four
lines.  These are the output of the
&lt;a href=&quot;/zipcpu/2017/11/18/wb-prefetch.html&quot;&gt;prefetch&lt;/a&gt; (&lt;code class=&quot;highlighter-rouge&quot;&gt;I&lt;/code&gt;), the
output of the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/idecode.v&quot;&gt;instruction
decoder&lt;/a&gt;
(&lt;code class=&quot;highlighter-rouge&quot;&gt;Dc)&lt;/code&gt;, the output of the read operands section (&lt;code class=&quot;highlighter-rouge&quot;&gt;Op&lt;/code&gt;) and the result of the
&lt;a href=&quot;/zipcpu/2017/08/11/simple-alu.html&quot;&gt;ALU&lt;/a&gt; (&lt;code class=&quot;highlighter-rouge&quot;&gt;Al&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;Indeed, this section is &lt;em&gt;so&lt;/em&gt; important for understanding how the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt; works, that we should take a deeper
look at it.  If you hold and press the ‘t’ key for a while, you’ll come across
the state shown in Fig 4 below.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 4, Instruction Pipeline&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/zipsim-insns.png&quot; alt=&quot;&quot; width=&quot;662&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;The first two columns on the left will show &lt;code class=&quot;highlighter-rouge&quot;&gt;Ck&lt;/code&gt; to indicate that the &lt;a href=&quot;/zipcpu/2017/08/23/cpu-pipeline.html&quot;&gt;pipeline&lt;/a&gt;
stage’s &lt;code class=&quot;highlighter-rouge&quot;&gt;CE&lt;/code&gt; line is high, or &lt;code class=&quot;highlighter-rouge&quot;&gt;Stl&lt;/code&gt;, to show that the particular stage is
&lt;em&gt;stalled&lt;/em&gt;.  Most instructions will be followed by a &lt;code class=&quot;highlighter-rouge&quot;&gt;:&lt;/code&gt;, although the first
half of any compressed instruction will be followed by a &lt;code class=&quot;highlighter-rouge&quot;&gt;/&lt;/code&gt;.  Following
the decode stage, either an &lt;code class=&quot;highlighter-rouge&quot;&gt;A&lt;/code&gt; (ALU), &lt;code class=&quot;highlighter-rouge&quot;&gt;M&lt;/code&gt; (memory), or &lt;code class=&quot;highlighter-rouge&quot;&gt;I&lt;/code&gt; (illegal)
character may follow the &lt;code class=&quot;highlighter-rouge&quot;&gt;;&lt;/code&gt; (or &lt;code class=&quot;highlighter-rouge&quot;&gt;/&lt;/code&gt;).  Immediately after this (optional)
character, is the address the instruction was read from.&lt;br /&gt;
If an instruction follows, as with all of the stages in Fig 4
above, then the particular
&lt;a href=&quot;/zipcpu/2017/08/23/cpu-pipeline.html&quot;&gt;pipeline&lt;/a&gt;
stage has valid values within it.
If the instruction is highlighted, its being run in supervisor mode.
These instructions, therefore, are being run from user mode.&lt;/p&gt;

&lt;p&gt;Is this making any sense?  Perhaps you might then be interested in the homework
section that follows.&lt;/p&gt;

&lt;h2 id=&quot;interactive-homework&quot;&gt;Interactive Homework&lt;/h2&gt;

&lt;p&gt;One of the really fun parts of
&lt;a href=&quot;/zipcpu/2017/07/26/cpu-sim-debugger.html&quot;&gt;this simulation&lt;/a&gt;.
is watching how the performance
of the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt;
is impacted by how well the
&lt;a href=&quot;/zipcpu/2017/11/18/wb-prefetch.html&quot;&gt;prefetch&lt;/a&gt;
mechanism works.  This is primarily controlled by some &lt;code class=&quot;highlighter-rouge&quot;&gt;define&lt;/code&gt;s within the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/cpudefs.v&quot;&gt;cpudefs.v&lt;/a&gt; file.&lt;/p&gt;

&lt;p&gt;Since you’ve already looked at how the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt;
operates in its default configuration with a
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/pfcache.v&quot;&gt;prefetch and cache&lt;/a&gt;
enabled,
let’s see how it does with some other
&lt;a href=&quot;/zipcpu/2017/11/18/wb-prefetch.html&quot;&gt;prefetch&lt;/a&gt;
module’s enabled.  Hence, for a second test, let’s uncomment the
&lt;code class=&quot;highlighter-rouge&quot;&gt;OPT_DOUBLE_FETCH&lt;/code&gt; define within
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/cpudefs.v&quot;&gt;cpudefs.v&lt;/a&gt;,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilator&quot; data-lang=&quot;verilator&quot;&gt;define OPT_DOUBLE_FETCH&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;You will then need to re-run make in the
“&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/tree/master/rtl&quot;&gt;rtl/&lt;/a&gt;” directory,
as well as the
“&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/tree/master/sim/verilated&quot;&gt;sim/verilated&lt;/a&gt;”
directory.&lt;/p&gt;

&lt;p&gt;This will switch the CPU from using the
&lt;a href=&quot;/zipcpu/2017/11/18/wb-prefetch.html&quot;&gt;prefetch&lt;/a&gt; and
&lt;a href=&quot;https://en.wikipedia.org/wiki/CPU_cache&quot;&gt;I-cache&lt;/a&gt;
of the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/pfcache.v&quot;&gt;pfcache&lt;/a&gt;
module, to using a module that fetches two instructions at a time:
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/dblfetch.v&quot;&gt;dblfetch&lt;/a&gt;.
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/dblfetch.v&quot;&gt;dblfetch&lt;/a&gt;
was designed to be a simpler
&lt;a href=&quot;/zipcpu/2017/11/18/wb-prefetch.html&quot;&gt;prefetch&lt;/a&gt;
than the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/pfcache.v&quot;&gt;pfcache&lt;/a&gt;
module, but also to have better performance than the single instruction at a
time &lt;a href=&quot;/zipcpu/2017/11/18/wb-prefetch.html&quot;&gt;prefetch&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/prefetch.v&quot;&gt;module&lt;/a&gt;–especially
when reading instructions from
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Speaking of the
&lt;a href=&quot;/zipcpu/2017/11/18/wb-prefetch.html&quot;&gt;single prefetch&lt;/a&gt;
module, why don’t we give that one a try?
To see how the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt;
performs with a
&lt;a href=&quot;/zipcpu/2017/11/18/wb-prefetch.html&quot;&gt;prefetch&lt;/a&gt;
module that only retrieves one instruction at a time, go ahead and uncomment
the &lt;code class=&quot;highlighter-rouge&quot;&gt;OPT_SINGLE_FETCH&lt;/code&gt; line from within
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/cpudefs.v&quot;&gt;cpudefs.v&lt;/a&gt;,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilator&quot; data-lang=&quot;verilator&quot;&gt;define OPT_SINGLE_FETCH&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;and then rerun make in the
“&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/tree/master/rtl&quot;&gt;rtl/&lt;/a&gt;” directory,
and
“&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/tree/master/sim/verilated&quot;&gt;sim/verilated&lt;/a&gt;”
directories again.&lt;/p&gt;

&lt;p&gt;See the difference?&lt;/p&gt;

&lt;p&gt;With the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/pfcache.v&quot;&gt;prefetch + cache&lt;/a&gt;, the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt;
has to pause any time the
&lt;a href=&quot;https://en.wikipedia.org/wiki/CPU_cache&quot;&gt;cache&lt;/a&gt;
line needs to be re-filled.  This is particularly pronounced at the beginning
of the
&lt;a href=&quot;/zipcpu/2017/07/26/cpu-sim-debugger.html&quot;&gt;simulation&lt;/a&gt;
where you have to wait many clocks for the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt;
to fill the
&lt;a href=&quot;https://en.wikipedia.org/wiki/CPU_cache&quot;&gt;cache&lt;/a&gt;.
You may also notice the effects of
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/pfcache.v&quot;&gt;this prefetch&lt;/a&gt;
any time the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt;
hits a
branch instruction, whether a
&lt;a href=&quot;/zipcpu/2018/01/01/zipcpu-isa.html&quot;&gt;branch always &lt;code class=&quot;highlighter-rouge&quot;&gt;BRA&lt;/code&gt;&lt;/a&gt;
or a conditional branch
(&lt;a href=&quot;/zipcpu/2018/01/01/zipcpu-isa.html&quot;&gt;nominally a conditional ADD
instruction&lt;/a&gt;)–the
two will have different effects within the
&lt;a href=&quot;/zipcpu/2017/07/26/cpu-sim-debugger.html&quot;&gt;simulator&lt;/a&gt;.
The
&lt;a href=&quot;/zipcpu/2018/01/01/zipcpu-isa.html&quot;&gt;branch always&lt;/a&gt;
instruction will suffer a single stall, and then (appear to) replace the
branch instruction moving through the
&lt;a href=&quot;/zipcpu/2017/08/23/cpu-pipeline.html&quot;&gt;pipeline&lt;/a&gt; with the
instruction prior to the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Branch_(computer_science)&quot;&gt;branch&lt;/a&gt;
target.  This is primarily an effect within the
&lt;a href=&quot;/zipcpu/2017/07/26/cpu-sim-debugger.html&quot;&gt;simulator viewer&lt;/a&gt;,
the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt;
doesn’t actually execute this other instruction, but it does send the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Branch_(computer_science)&quot;&gt;branch&lt;/a&gt;’s
target address through the
&lt;a href=&quot;/zipcpu/2017/08/23/cpu-pipeline.html&quot;&gt;pipeline&lt;/a&gt;–leading to
the misleading view.  The
&lt;a href=&quot;/zipcpu/2018/01/01/zipcpu-isa.html&quot;&gt;conditional branch&lt;/a&gt;,
on the other hand, will clear the
&lt;a href=&quot;/zipcpu/2017/08/23/cpu-pipeline.html&quot;&gt;pipeline&lt;/a&gt;
anytime it is taken.  If the result is in the
&lt;a href=&quot;https://en.wikipedia.org/wiki/CPU_cache&quot;&gt;cache&lt;/a&gt;,
then the new instructions will start filling the (now empty)
&lt;a href=&quot;/zipcpu/2017/08/23/cpu-pipeline.html&quot;&gt;pipeline&lt;/a&gt;
following the branch.&lt;/p&gt;

&lt;p&gt;On the other hand, with the
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;single prefetch&lt;/a&gt;
module, the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt;
is unable to fill its
&lt;a href=&quot;/zipcpu/2017/08/23/cpu-pipeline.html&quot;&gt;pipeline&lt;/a&gt;.
It seems to be forever fetching the next instruction, while spending
very little time actually executing instructions.&lt;/p&gt;

&lt;p&gt;When I first saw this difference, I suddenly learned a lot about how
important the
&lt;a href=&quot;https://en.wikipedia.org/wiki/CPU_cache&quot;&gt;cache&lt;/a&gt;
is to
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;
performance.  It was for this purpose that I wanted to share
this demonstration with you–I just found it very valuable.&lt;/p&gt;

&lt;h2 id=&quot;next-time&quot;&gt;Next Time&lt;/h2&gt;

&lt;p&gt;Our next step, now that you’ve built the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
toolchain, will be to run the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/sw/board/cputest.c&quot;&gt;test program&lt;/a&gt;
program from within the
&lt;a href=&quot;https://github.com/ZipCPU/zbasic&quot;&gt;ZBasic&lt;/a&gt;
repository.  This goes beyond testing just the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt;–it involves testing a
&lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/sw/verilated/qspiflashsim.cpp&quot;&gt;simulated flash&lt;/a&gt;
and a &lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/sw/verilated/dbluartsim.cpp&quot;&gt;simulated serial
port&lt;/a&gt;–together
with their controllers.  If time permits, I’ll even add the instructions
to play &lt;a href=&quot;https://github.com/ZipCPU/tttt&quot;&gt;4x4x4 tic-tac-toe&lt;/a&gt;
within that demonstration–it’s a fun game and a nice way to relieve the
stress of getting something new working.&lt;/p&gt;

&lt;p&gt;Beyond that, I’ve still got a couple of blogging articles planned along
this line.  The next article I have planned will show how to add a
&lt;a href=&quot;https://github.com/ZipCPU/wbpmic&quot;&gt;microphone controller&lt;/a&gt;
component to
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;wishbone bus&lt;/a&gt;
within the
&lt;a href=&quot;https://github.com/ZipCPU/zbasic&quot;&gt;ZBasic&lt;/a&gt;
implementation using
&lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt;.  I’d also like to show
how you can profile a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;
running
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;Dhrystone&lt;/a&gt;
within a
&lt;a href=&quot;/zipcpu/2017/07/26/cpu-sim-debugger.html&quot;&gt;simulator&lt;/a&gt;,
using a capability similar to the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;’s
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/sim/verilated/pdump.cpp&quot;&gt;pdump&lt;/a&gt;
program.  This was also very instructive to me, since it helped me
understand where and when the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt;
ended up stalling, and what it would stall for under a reasonable load.&lt;/p&gt;

&lt;p&gt;So, stick around, there’s more coming!&lt;/p&gt;
&lt;hr /&gt;&lt;p&gt;&lt;em&gt;Shall the axe boast itself against him that heweth therewith? or shall the saw magnify itself against him that shaketh it? as if the rod should shake itself against them that lift it up, or as if the staff should lift up itself, as if it were no wood. (Isaiah 10:15)&lt;/em&gt;</description>
        <pubDate>Wed, 31 Jan 2018 00:00:00 -0500</pubDate>
        <link>http://zipcpu.com/zipcpu/2018/01/31/cpu-build.html</link>
        <guid isPermaLink="true">http://zipcpu.com/zipcpu/2018/01/31/cpu-build.html</guid>
        
        
        <category>zipcpu</category>
        
      </item>
    
      <item>
        <title>Updating ZipCPU files</title>
        <description>&lt;p&gt;Several of you have asked me, following the
&lt;a href=&quot;/zipcpu/2018/01/01/zipcpu-isa.html&quot;&gt;ZipCPU ISA introduction&lt;/a&gt;
article,
to present instructions for building and trying out the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; for yourselves. 
I would like to do that.  Indeed, I’m planning on it.  If the Lord is willing,
this will be my next article.  If I get stuck along the way and it takes too
long to get there, then I might just pause and describe a &lt;a href=&quot;https://github.com/ZipCPU/interpolation/blob/master/rtl/quadratic/quadinterp.v&quot;&gt;quadratic
interpolator&lt;/a&gt;
first, but if the Lord remains willing we’ll still get there.&lt;/p&gt;

&lt;p&gt;This week, however, I’ve gotten stuck into the “just-one-more” (fill in the
blank) change loop.  Most of these changes have centered around
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal verifying&lt;/a&gt;
that the various components of the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
works as designed.&lt;/p&gt;

&lt;p&gt;At first the task was easy–I just started building
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal verification&lt;/a&gt;
proofs for the little components within the 
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;–you know, the peripherals that
just &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/zipcounter.v&quot;&gt;count
instructions&lt;/a&gt;,
or the one that justs &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/zipcounter.v&quot;&gt;counts down to zero and then creates an
interrupt&lt;/a&gt;.
In each case, I’ve gotten to the point where I think I’m ready to post the
“here’s how to get started article”, and I think to myself, “Just one more
proof.”
I mean, how hard can a &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/ziptimer.v&quot;&gt;simple
timer&lt;/a&gt;
be, for example?&lt;/p&gt;

&lt;p&gt;Well, that &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/ziptimer.v&quot;&gt;simple timer&lt;/a&gt;
was harder to
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formally verify&lt;/a&gt;
than I expected.&lt;/p&gt;

&lt;p&gt;Then, after I wrote up the chart below, things started to become a challenge.
Surely I could
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formally verify&lt;/a&gt; the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/wbdmac.v&quot;&gt;DMA controller&lt;/a&gt;, right?
I wouldn’t want to present the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; to others if there was a subtle
bug within the 
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/wbdmac.v&quot;&gt;DMA
controller&lt;/a&gt; that 
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal methods&lt;/a&gt;
could find, right?
The &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/wbdmac.v&quot;&gt;DMA
controller&lt;/a&gt;,
I told myself, should be easy: I’ve already put together the set of &lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;formal
Wishbone properties&lt;/a&gt;
necessary to make certain it works, the hard work has been done, right?&lt;/p&gt;

&lt;p&gt;One day later, I have a &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/wbdmac.v&quot;&gt;wonderful
proof&lt;/a&gt;
that my &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/wbdmac.v&quot;&gt;DMA
controller&lt;/a&gt;
works, but I’m no closer to writing the getting started article.
Of course, it didn’t help that I adjusted how I expressed the
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;wishbone properties&lt;/a&gt;,
and so other components–notably the (yet to be integrated)
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/zipmmu.v&quot;&gt;MMU&lt;/a&gt;
had to be adjusted to work with this new property description as well …&lt;/p&gt;

&lt;p&gt;However, with everyone of these projects, I’m getting closer and closer to
being able to &lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formally
verify&lt;/a&gt;
the &lt;em&gt;entire &lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt;&lt;/em&gt;.  Even further, I
intended to do a full proof, including not only bounded model checking but
induction as well.&lt;/p&gt;

&lt;p&gt;Just so you see how far I’ve gotten, here’s a list of the RTL components
in the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt; project,
together with whether or not I’ve managed to finish
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formally verifying&lt;/a&gt;
the component or not.&lt;/p&gt;

&lt;table class=&quot;bordered-table&quot;&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Project&lt;/th&gt;
      &lt;th&gt;Component&lt;/th&gt;
      &lt;th&gt;Purpose&lt;/th&gt;
      &lt;th&gt;Status&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/prefetch.v&quot;&gt;prefetch&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;Single Insn Prefetch&lt;/td&gt;
      &lt;td&gt;&lt;em&gt;Proven&lt;/em&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/dblfetch.v&quot;&gt;dblfetch&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;Two Insn Pipelind Prefetch&lt;/td&gt;
      &lt;td&gt;&lt;em&gt;Proven&lt;/em&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/pfcache.v&quot;&gt;pfcache&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;Prefetch and integrated instruction cache&lt;/td&gt;
      &lt;td&gt;&lt;em&gt;Proven&lt;/em&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/idecode.v&quot;&gt;idecode&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;Instruction decoder&lt;/td&gt;
      &lt;td&gt;&lt;em&gt;Proven&lt;/em&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/div.v&quot;&gt;div&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;Divide module&lt;/td&gt;
      &lt;td&gt;&lt;em&gt;Proven&lt;/em&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/memops.v&quot;&gt;memops&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;Memory Interface Module&lt;/td&gt;
      &lt;td&gt;&lt;em&gt;Proven&lt;/em&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/pipemem.v&quot;&gt;pipemem&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;Memory Module, supporting pipelind mem access&lt;/td&gt;
      &lt;td&gt;&lt;em&gt;Proven&lt;/em&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/icontrol.v&quot;&gt;icontrol&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;Interrupt controller&lt;/td&gt;
      &lt;td&gt;&lt;em&gt;Proven&lt;/em&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/zipjiffies.v&quot;&gt;zipjiffies&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;I/O Scheduling peripheral&lt;/td&gt;
      &lt;td&gt;&lt;em&gt;Proven&lt;/em&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/zipcounter.v&quot;&gt;zipcounter&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;Performance counter&lt;/td&gt;
      &lt;td&gt;&lt;em&gt;Proven&lt;/em&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/ziptimer.v&quot;&gt;ziptimer&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;Count-down timer&lt;/td&gt;
      &lt;td&gt;&lt;em&gt;Proven&lt;/em&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/wbdmac.v&quot;&gt;wbdmac&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;CPU DMA Controller&lt;/td&gt;
      &lt;td&gt;&lt;em&gt;Proven&lt;/em&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/zipmmu.v&quot;&gt;zipmmu&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;External MMU peripheral&lt;/td&gt;
      &lt;td&gt;&lt;em&gt;Proven&lt;/em&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/ex/busdelay.v&quot;&gt;busdelay&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;A timing saving bus delay&lt;/td&gt;
      &lt;td&gt;&lt;em&gt;Proven&lt;/em&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/ex/wbpriarbiter.v&quot;&gt;wbpriarbiter&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;A wishbone priority arbiter&lt;/td&gt;
      &lt;td&gt;&lt;em&gt;Proven&lt;/em&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/ex/wbdblpriarb.v&quot;&gt;wbdblpriarb&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;A priority arbiter for a pair of shared wishbone interfaces&lt;/td&gt;
      &lt;td&gt;&lt;em&gt;Proven&lt;/em&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/cpuops.v&quot;&gt;cpuops&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;ALU component&lt;/td&gt;
      &lt;td&gt;(Not started)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;zipcpu&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;Master CPU controller&lt;/td&gt;
      &lt;td&gt;(Not started)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/zipbones.v&quot;&gt;zipbones&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;CPU Container&lt;/td&gt;
      &lt;td&gt;(Not started)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/zipsystem.v&quot;&gt;zipsystem&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;CPU Container with Peripherals&lt;/td&gt;
      &lt;td&gt;(Not started)&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 1. Components of a ZipSystem&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/zipsystem.svg&quot; alt=&quot;&quot; width=&quot;420&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;Pictorially, you can see most of these components in the diagram of the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/zipsystem.v&quot;&gt;ZipSystem&lt;/a&gt;
shown to the right in Fig 1.  I’ve proven all of the
peripheral components shown in boxes on the right, as well as all of the
sub-components within the CPU in the yellow box on the left.  (The
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
still doesn’t have an FPU component, and the
&lt;a href=&quot;/zipcpu/2017/08/11/simple-alu.html&quot;&gt;ALU&lt;/a&gt; was forgotten
when I initially built the table above.) The large yellow box on the left
that is the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
within the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/zipsystem.v&quot;&gt;ZipSystem&lt;/a&gt;
still remains to be proven, as does the area with
the blue background known as the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/zipsystem.v&quot;&gt;ZipSystem&lt;/a&gt;.
However, I’m getting a lot closer–having now proved all but one of the
components within these two aggregate components.&lt;/p&gt;

&lt;p&gt;Indeed, if you just judge from the table (and figure) above, I’ve got the
entire
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt; periphery proven, just not the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;core module&lt;/a&gt;
itself or the two container modules–the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipsystem.v&quot;&gt;zipsystem&lt;/a&gt;,
or the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipbones.v&quot;&gt;zipbones&lt;/a&gt;.
As for the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;main CPU
component&lt;/a&gt;,
I’ve started working on it–but haven’t tried it to see how far I could
get.  My biggest fear there is that there’s some pipeline bug still lying
dormant within the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
that I will only discover via
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal verification&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;I’ve certainly found several subtle bugs along the way.  For example, just
the right sequence of commands and the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/wbdmac.v&quot;&gt;DMA
controller&lt;/a&gt;
would try to initiate a bus transaction of zero length–violating a primary
assertion.  As another example, that &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/ziptimer.v&quot;&gt;simple count-down
timer&lt;/a&gt;
would “break” if just the right series of commands were given to it.  Or worse,
the (soon to be integrated)
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/zipmmu.v&quot;&gt;MMU&lt;/a&gt;
component would sometimes place the last physical page address on the bus
instead of the one appropriate for the current bus request.&lt;/p&gt;

&lt;p&gt;I’m hoping to present these proven components here on
&lt;a href=&quot;http://zipcpu.com/&quot;&gt;this blog&lt;/a&gt; in time.  If
you are interested in the proofs before then, you should be able to find some
of those proofs in the development branch of the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/tree/dev&quot;&gt;ZipCPU repository&lt;/a&gt;, otherwise feel
free to write if you don’t find what you are looking for.  It will take
me some time to integrate these components and then to write the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
getting started “how-to” instructions, since I want to make certain that
the test benches within the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/tree/dev&quot;&gt;ZipCPU
repository&lt;/a&gt;
still work (I think I broke one or two), that the &lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/sw/board/cputest.c&quot;&gt;CPU
test&lt;/a&gt;
within the &lt;a href=&quot;https://github.com/ZipCPU/zbasic&quot;&gt;ZBasic repository&lt;/a&gt;
continues to work, as well as making certain that the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt;
still builds within both &lt;a href=&quot;https://www.xilinx.com&quot;&gt;Xilinx&lt;/a&gt;’s
&lt;a href=&quot;https://www.xilinx.com/products/design-tools/ise-design-suite.html&quot;&gt;ISE&lt;/a&gt;
(i.e. the &lt;a href=&quot;https://github.com/ZipCPU/xulalx25soc&quot;&gt;XuLA2-LX25 SoC repository&lt;/a&gt;)
and &lt;a href=&quot;https://www.xilinx.com/products/design-tools/vivado.html&quot;&gt;Vivado&lt;/a&gt;
(i.e. either the &lt;a href=&quot;https://github.com/ZipCPU/videozip&quot;&gt;VideoZip&lt;/a&gt;
or the &lt;a href=&quot;https://github.com/ZipCPU/openarty&quot;&gt;OpenArty&lt;/a&gt; repository).&lt;/p&gt;

&lt;p&gt;Getting these components to build for five separate synthesis engines,
&lt;a href=&quot;https://veripool.org/wiki/verilator&quot;&gt;Verilator&lt;/a&gt;,
&lt;a href=&quot;http://www.clifford.at/yosys/&quot;&gt;yosys&lt;/a&gt;,
&lt;a href=&quot;https://www.xilinx.com/products/design-tools/ise-design-suite.html&quot;&gt;ISE&lt;/a&gt;,
&lt;a href=&quot;https://www.xilinx.com/products/design-tools/vivado.html&quot;&gt;Vivado&lt;/a&gt;, and (now
hopefully)
&lt;a href=&quot;https://www.altera.com/products/design-software/fpga-design/quartus-prime/overview.html&quot;&gt;Quartus&lt;/a&gt;,
has become such a hassle, that I’ve asked among my friends in the
&lt;a href=&quot;https://openrisc.io&quot;&gt;OpenRISC&lt;/a&gt;
world for some ideas to help, and I’ve been told that
&lt;a href=&quot;https://github.com/olofk/fusesoc&quot;&gt;FuseSoC&lt;/a&gt;
can handle testing builds for all of these different synthesis tools
with one configuration.  I think I’m going to need to try that.&lt;/p&gt;

&lt;h2 id=&quot;other-components&quot;&gt;Other Components&lt;/h2&gt;

&lt;p&gt;I’ve also slowly been
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formally verifying&lt;/a&gt;
many of the peripherals I’ve been working with.  Below, therefore, are some
other important components that I’ve managed to
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formally verify&lt;/a&gt; as
well:&lt;/p&gt;

&lt;table class=&quot;bordered-table&quot;&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Project&lt;/th&gt;
      &lt;th&gt;Component&lt;/th&gt;
      &lt;th&gt;Purpose&lt;/th&gt;
      &lt;th&gt;Status&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;a href=&quot;https://github.com/ZipCPU/xulalx25soc&quot;&gt;XuLA2-LX25&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;https://github.com/ZipCPU/xulalx25soc/blob/master/rtl/wbsdram.v&quot;&gt;wbsdram&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;SDRAM controller&lt;/td&gt;
      &lt;td&gt;&lt;em&gt;Proven&lt;/em&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;a href=&quot;https://github.com/ZipCPU/wb2axip&quot;&gt;wb2axip&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;https://github.com/ZipCPU/wb2axip/blob/master/rtl/wbm2axisp.v&quot;&gt;wbm2axip&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;Pipelined WB to AXI converter&lt;/td&gt;
      &lt;td&gt;&lt;em&gt;Proven&lt;/em&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;a href=&quot;https://github.com/ZipCPU/vgasim&quot;&gt;vgasim&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;https://github.com/ZipCPU/vgasim/blob/master/rtl/llvga.v&quot;&gt;llvga&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;Low-level VGA Controller&lt;/td&gt;
      &lt;td&gt;&lt;em&gt;Proven&lt;/em&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;a href=&quot;https://github.com/ZipCPU/wbpmic&quot;&gt;wbpmic&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;https://github.com/ZipCPU/wbpmic/blob/master/rtl/wbsmpladc.v&quot;&gt;wbsmpladc&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;Simple WB A/D Controller&lt;/td&gt;
      &lt;td&gt;&lt;em&gt;Proven&lt;/em&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;https://github.com/ZipCPU/wbpmic/blob/master/rtl/smplfifo.v&quot;&gt;smplfifo&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;A/D Converter’s FIFO&lt;/td&gt;
      &lt;td&gt;&lt;em&gt;Proven&lt;/em&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;https://github.com/ZipCPU/wbpmic/blob/master/rtl/smpladc.v&quot;&gt;smpladc&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;SPI based A/D Converter&lt;/td&gt;
      &lt;td&gt;&lt;em&gt;Proven&lt;/em&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;a href=&quot;https://github.com/ZipCPU/wbuart32&quot;&gt;wbuart&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;https://github.com/ZipCPU/wbuart32/blob/master/rtl/ufifo.v&quot;&gt;ufifo&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;Generic FIFO for serial ports&lt;/td&gt;
      &lt;td&gt;&lt;em&gt;Proven&lt;/em&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;a href=&quot;https://github.com/ZipCPU/wbuart32&quot;&gt;wbuart&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;https://github.com/ZipCPU/wbuart32/blob/master/rtl/txuartlite.v&quot;&gt;txuartlite&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;Bare bones serial port transmitter&lt;/td&gt;
      &lt;td&gt;&lt;em&gt;Proven&lt;/em&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;a href=&quot;https://github.com/ZipCPU/dspfilters&quot;&gt;dspfilters&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/lfsr.v&quot;&gt;lfsr&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;Generic LFSR&lt;/td&gt;
      &lt;td&gt;&lt;em&gt;Proven&lt;/em&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;a href=&quot;https://github.com/ZipCPU/dspfilters&quot;&gt;dspfilters&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/delayw.v&quot;&gt;delayw&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;Signal delay module&lt;/td&gt;
      &lt;td&gt;&lt;em&gt;Proven&lt;/em&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;a href=&quot;http://opencores.org/project,qspiflash&quot;&gt;qspiflash&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;https://opencores.org/websvn,filedetails?repname=qspiflash&amp;amp;path=%2Fqspiflash%2Ftrunk%2Frtl%2Fllqspi.v&quot;&gt;llqspi&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;Low level QSPI flash driver&lt;/td&gt;
      &lt;td&gt;&lt;em&gt;Proven&lt;/em&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;Each of these components has a story to tell.  For example, I found the subtlest
of bugs in the &lt;a href=&quot;https://github.com/ZipCPU/xulalx25soc/blob/master/rtl/wbsdram.v&quot;&gt;SDRAM memory
controller&lt;/a&gt;,
a bug that in rare cases would have caused the &lt;a href=&quot;https://github.com/ZipCPU/xulalx25soc/blob/master/rtl/wbsdram.v&quot;&gt;memory
controller&lt;/a&gt;
to read or write the wrong memory address (i.e., the right column but the
wrong row).  I’ll admit, I was a bit surprised to find this, as I’ve now been
using this
&lt;a href=&quot;https://github.com/ZipCPU/xulalx25soc/blob/master/rtl/wbsdram.v&quot;&gt;memory controller&lt;/a&gt;
for years now and haven’t hit that bug.  (Not all of these proofs have been
pushed to their respective repositories yet …)&lt;/p&gt;

&lt;p&gt;All of the items listed above are candidates for future blog articles–both
the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; and its components as well
as the peripherals listed above.  Not only do I think they might be of interest
to some, but blogging about them will also give me the opportunity to clean up
the code a bit following this last mad dash to prove the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Oh, by the way, if you want to get started with the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; before I write my getting
started article, you can find some &lt;a href=&quot;/zipcpu/2017/08/23/cpu-pipeline.html&quot;&gt;simple getting-started instructions
here&lt;/a&gt;–just to get you
going until I write up something prettier.&lt;/p&gt;
&lt;hr /&gt;&lt;p&gt;&lt;em&gt;So likewise ye, when ye shall have done all those things which are commanded you, say, We are unprofitable servants: we have done that which was our duty to do.  (Luke 17:10)&lt;/em&gt;</description>
        <pubDate>Mon, 22 Jan 2018 00:00:00 -0500</pubDate>
        <link>http://zipcpu.com/blog/2018/01/22/formal-progress.html</link>
        <guid isPermaLink="true">http://zipcpu.com/blog/2018/01/22/formal-progress.html</guid>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>Interpolation is just a special type of convolution</title>
        <description>&lt;p&gt;The most profound lessons I’ve learned regarding
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolation&lt;/a&gt;
were that first,
&lt;a href=&quot;https://en.wikipedia.org/wiki/Shift-invariant_system&quot;&gt;shift invariant&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolators&lt;/a&gt;
existed, and second that the effects of a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Shift-invariant_system&quot;&gt;shift invariant&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;
can be described in the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency_domain&quot;&gt;frequency domain&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;But let’s back up a step to tell this story from the beginning.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;Interpolation&lt;/a&gt;
refers to a class of methods or algorithms for reconstructing a waveform’s
value &lt;em&gt;between&lt;/em&gt; given sample points.
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;Interpolation&lt;/a&gt; is
an important part of any sample rate conversion algorithm.
As a result, it is studied as part of both
&lt;a href=&quot;https://en.wikipedia.org/wiki/Numerical_analysis&quot;&gt;numerical analysis&lt;/a&gt; is
as well as &lt;a href=&quot;https://en.wikipedia.org/wiki/Sample-rate_conversion&quot;&gt;mutirate digital signal
processing&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;As part of &lt;a href=&quot;http://zipcpu.com/&quot;&gt;this blog&lt;/a&gt;,
we’ve already discussed &lt;a href=&quot;/dsp/2017/06/06/simple-interpolator.html&quot;&gt;nearest-neighbour
interpolation&lt;/a&gt; and
&lt;a href=&quot;/dsp/2017/07/29/series-linear-interpolation.html&quot;&gt;linear interpolation&lt;/a&gt;.  Going further, though, requires a bit of a background
understanding.  Since the necessary background wasn’t something I learned
when I last studied
&lt;a href=&quot;https://en.wikipedia.org/wiki/Numerical_analysis&quot;&gt;numerical analysis&lt;/a&gt;,
I figured you might be interested as well.&lt;/p&gt;

&lt;p&gt;Today, therefore, let’s look beyond &lt;a href=&quot;/dsp/2017/07/29/series-linear-interpolation.html&quot;&gt;linear
interpolation&lt;/a&gt;
and lay the ground work for better
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
based &lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial&quot;&gt;polynomial&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolation&lt;/a&gt; algorithms.&lt;/p&gt;

&lt;h2 id=&quot;my-own-history-with-interpolation&quot;&gt;My own history with interpolation&lt;/h2&gt;

&lt;p&gt;I first became seriously interested in
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolation&lt;/a&gt;
when I tried to follow and recreate &lt;a href=&quot;https://ieeexplore.ieee.org/document/134480/&quot;&gt;William Gardner’s cyclostationary
signal processing results&lt;/a&gt;
as part of my &lt;a href=&quot;http://www.dtic.mil/dtic/tr/fulltext/u2/a423141.pdf&quot;&gt;Ph.D.
Research&lt;/a&gt;.
Gardner &lt;a href=&quot;https://ieeexplore.ieee.org/document/134480/&quot;&gt;had stated&lt;/a&gt; that by using
&lt;a href=&quot;https://en.wikipedia.org/wiki/Cyclostationary_process&quot;&gt;cyclostationary&lt;/a&gt;
methods, his &lt;a href=&quot;https://en.wikipedia.org/wiki/Multilateration&quot;&gt;time difference of arrival
(TDOA)&lt;/a&gt; algorithm could
outperform all others.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;These new algorithms are tolerant to both interfering signals and noise,
and they can outperform conventional algorithms that achieve the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Cramer-Rao_bound&quot;&gt;Cramer-Rao&lt;/a&gt;
lower bound on variance for stationary signals because the signals considered
here are nonstationary
(&lt;a href=&quot;https://en.wikipedia.org/wiki/Cyclostationary_process&quot;&gt;cyclostationary&lt;/a&gt;)
and the algorithms expoit the nonstationarity to discriminate against noise
and interference.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;A &lt;a href=&quot;https://en.wikipedia.org/wiki/Multilateration&quot;&gt;TDOA&lt;/a&gt; estimator,
for those not familiar with the algorithm, takes two input signals, where one
is nominally the other delayed by some amount of time, runs a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Cross-correlation&quot;&gt;cross-correlation&lt;/a&gt;
between them, and then finds the location of the maximum value that results.
[&lt;a href=&quot;http://theduchy.ualr.edu/wordpress/wp-content/uploads/2017/06/scan0007.pdf&quot;&gt;Ref&lt;/a&gt;]&lt;/p&gt;

&lt;p&gt;Gardner, however, had insisted in his problem setup that the two simulated
signals were to be delayed with respect to
each other by an &lt;em&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Integer&quot;&gt;integer&lt;/a&gt;
number of samples&lt;/em&gt;, and then &lt;em&gt;assumed the peak
would lie on a sample point&lt;/em&gt;.  This process skipped the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;
that would be necessary for any real life application, and so his
estimation errors suddenly (and artificially) dropped to zero.  This erroneous
result then overinflated the performance of his algorithm.&lt;/p&gt;

&lt;p&gt;This lead me to study the question of which
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;
is better when peak finding?&lt;/p&gt;

&lt;p&gt;Peak finding in &lt;a href=&quot;https://en.wikipedia.org/wiki/Multilateration&quot;&gt;TDOA&lt;/a&gt;
estimation, however, is only one purpose of an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;.
Other purposes for
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolation&lt;/a&gt;
aren’t hard to come by:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;Interpolators&lt;/a&gt;
are commonly needed to process audio signals.  They are used to &lt;a href=&quot;https://en.wikipedia.org/wiki/Sample-rate_conversion&quot;&gt;change
sampling rates&lt;/a&gt;, such
as from an 8kHz sample rate to a 44.1kHz sample rate, or from a 44.1kHz
sample rate to a 48kHz sample rate.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;Interpolators&lt;/a&gt; are used within
video display devices having a fixed resolution, to allow them to
display other resolutions.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;When I was working with
&lt;a href=&quot;https://en.wikipedia.org/wiki/Global_Positioning_System&quot;&gt;GPS&lt;/a&gt;
signals years ago, the digitizer would sample some
&lt;a href=&quot;https://en.wikipedia.org/wiki/Integer&quot;&gt;integer&lt;/a&gt;
number of samples per chip.  However, in order to use
&lt;a href=&quot;https://en.wikipedia.org/wiki/Fast_Fourier_transform&quot;&gt;Fast Fourier transform&lt;/a&gt;
signal processing methods, the data needs to be resampled from the 1023N
samples per block that came from the digitizer to &lt;code class=&quot;highlighter-rouge&quot;&gt;1024*2^M&lt;/code&gt;
samples per block–a power of two.  This requires an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Upsampling&quot;&gt;upsampling&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolation&lt;/a&gt;
rate of 1024/1023—a difficult ratio to achieve using
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sample-rate_conversion&quot;&gt;rational resampling&lt;/a&gt;
methods.  (In the end, we actually downsampled the signal by 8192/1023 …)&lt;/p&gt;

    &lt;p&gt;Indeed, &lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolation&lt;/a&gt; in a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Global_Positioning_System&quot;&gt;GPS&lt;/a&gt;
processing system isn’t limited to the front end (re)sampler.  It’s also
an important part of picking the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Cross-correlation&quot;&gt;correlation&lt;/a&gt;
peak that is part of the measurement used to determine your location as well.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Many &lt;a href=&quot;https://en.wikipedia.org/wiki/Sine_wave&quot;&gt;sine wave&lt;/a&gt;
implementations are based around a &lt;a href=&quot;/dsp/2017/07/11/simplest-sinewave-generator.html&quot;&gt;table
lookup&lt;/a&gt;.
If you want to control the distortion in the resulting
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sine_wave&quot;&gt;sine wave&lt;/a&gt;, knowing how the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt; responds is
important to evaluating how good your &lt;a href=&quot;/dsp/2017/07/11/simplest-sinewave-generator.html&quot;&gt;table
lookup&lt;/a&gt;
method is.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Most satellite &lt;a href=&quot;https://en.wikipedia.org/wiki/Orbit&quot;&gt;orbits&lt;/a&gt;
are communicated with sampled positions from a special
&lt;a href=&quot;https://en.wikipedia.org/wiki/Orbit&quot;&gt;orbital&lt;/a&gt;
propagator.  However,
&lt;a href=&quot;https://en.wikipedia.org/wiki/Satellite_navigation&quot;&gt;satellite navigation&lt;/a&gt;
work, such as
&lt;a href=&quot;https://en.wikipedia.org/wiki/Global_Positioning_System&quot;&gt;GPS&lt;/a&gt;, requires
knowing the satellite’s position often on nanosecond level timesteps.
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;Interpolation&lt;/a&gt; is used to
address the problem of determining what happens between the points.&lt;/p&gt;

    &lt;p&gt;Even better, as we’ll touch on below, if you can quantify the error in your
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;, such as by
using &lt;a href=&quot;https://en.wikipedia.org/wiki/Fourier_analysis&quot;&gt;Fourier analysis&lt;/a&gt;,
you can also quantify the error in your navigation system.  You might even
be able to relax the requirements of your numerical satellite propagation
engine with a sufficiently powerful
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;When I built a suite of tools for &lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_signal_processing&quot;&gt;digital signal
processing&lt;/a&gt;
and display years ago, I used an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt; as part of the
GUI to allow the user to zoom in on any signal by an arbitrary amount.  Even
better, by using a quadratic
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;,
the signal lost most of the obvious evidences of being sampled in the first
place.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;When presenting the &lt;a href=&quot;/dsp/2017/09/16/pwm-demo.html&quot;&gt;demonstration of the improved
PWM&lt;/a&gt; signal, we only used a
&lt;a href=&quot;/dsp/2017/06/06/simple-interpolator.html&quot;&gt;nearest-neighbour&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt; to go from the
audio sample rate to output samples.  Because we didn’t use a good
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;,
our test waveform had many &lt;a href=&quot;https://en.wikipedia.org/wiki/Aliasing&quot;&gt;aliasing&lt;/a&gt;
artifacts in addition to the artifacts due to the
&lt;a href=&quot;/dsp/2017/09/04/pwm-reinvention&quot;&gt;PWM&lt;/a&gt;
modulation.&lt;/p&gt;

    &lt;p&gt;Replacing the
&lt;a href=&quot;/dsp/2017/06/06/simple-interpolator.html&quot;&gt;nearest-neighbour&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;
with either a
&lt;a href=&quot;/dsp/2017/07/29/series-linear-interpolation.html&quot;&gt;linear&lt;/a&gt;
or quadratic
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;
would’ve removed most of those extra artifacts.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;While the description above highlights my own personal background and reasons
for studying
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolation&lt;/a&gt; theory after
my graduate studies, these few examples can hardly do justice to the number
of times and places where a good
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt; is required.
Hence, when it comes time for you to choose a good 
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;, you’ll want to
remember the lessons we are about to discuss.&lt;/p&gt;

&lt;h2 id=&quot;key-assumptions&quot;&gt;Key Assumptions&lt;/h2&gt;

&lt;p&gt;The field of &lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolation&lt;/a&gt;
is fairly well established with lots of approaches and “solutions”.  To limit
our discussion, therefore, we’ll need to make some assumptions about what
types of &lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolators&lt;/a&gt;
are appropriate for
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_signal_processing&quot;&gt;signal processing&lt;/a&gt;
on an &lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;.
You may wish to read this section carefully, though, because the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolation&lt;/a&gt; theory and
conclusions I’ll present later will be driven by these assumptions.&lt;/p&gt;

&lt;p&gt;The first couple of assumptions are quite basic to &lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_signal_processing&quot;&gt;digital signal
processing&lt;/a&gt; in general:
the input is assumed to be a
&lt;em&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;sampled&lt;/a&gt;
data stream&lt;/em&gt; that is formed from
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;sampling&lt;/a&gt;:
an &lt;em&gt;infinite signal source&lt;/em&gt; (in time) at &lt;em&gt;equidistant samples&lt;/em&gt;.
An example of such a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;sampled&lt;/a&gt;
signal is shown below in Fig 1.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 1. Sampled data, the beginning of any interpolation problem&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/sampled-data.png&quot; alt=&quot;This figure shows a picture of a swept frequency sine wave, that has been sampled.  The samples are represented by impulses, the original sinewave by a dotted curve&quot; width=&quot;595&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;In the figure above, you can see the sampled points represented by green
circles, and the original waveform in dotted gray.  The purpose of the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;
is to estimate or recover the signal between the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;sample&lt;/a&gt;
points.&lt;/p&gt;

&lt;p&gt;The waveform shown in Fig 1 above also makes a wonderful example waveform:
it is a swept frequency tone.  Hence, the frequency of the tone on the
left is lower than that on the right.  As a result, and as we’ll discuss,
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolating&lt;/a&gt;
the signal on the left side is easy, but it gets harder on the right.  Indeed,
you might notice within the figure
how &lt;a href=&quot;https://en.wikipedia.org/wiki/Aliasing&quot;&gt;aliasing&lt;/a&gt;
starts to dominate on the far right.  Indeed, this figure works as such a good
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolation&lt;/a&gt;
test, that I used it throughout the
&lt;a href=&quot;https://github.com/ZipCPU/interpolation/raw/master/tutorial.pdf&quot;&gt;tutorial slides&lt;/a&gt;
I built to discuss this the topic.  We can return to this later.&lt;/p&gt;

&lt;p&gt;For now, let’s introduce two further key assumptions.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;The first of these key assumptions is that we are looking for a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Linear_map&quot;&gt;linear operator&lt;/a&gt;.
Adding two
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;sample&lt;/a&gt;
streams together before applying the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;
should therefore produce an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolation&lt;/a&gt;
of their sum signal.  Multiplying the incoming signal by a constant (scalar)
should produce a scaled output signal.&lt;/p&gt;

    &lt;p&gt;While
&lt;a href=&quot;/dsp/2017/09/27/quantization.html&quot;&gt;quantization&lt;/a&gt;
will have an effect on these two properties of
&lt;a href=&quot;https://en.wikipedia.org/wiki/Linear_map&quot;&gt;linearity&lt;/a&gt;, let’s ignore it
for now and just focus on
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolating&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Real_number&quot;&gt;real&lt;/a&gt; signals.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The second and final key assumption is that that the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolation&lt;/a&gt;
approach we are interested in today is
&lt;em&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Shift-invariant_system&quot;&gt;shift invariant&lt;/a&gt;&lt;/em&gt;.
&lt;a href=&quot;https://en.wikipedia.org/wiki/Shift-invariant_system&quot;&gt;Shift invariance&lt;/a&gt;
in this case is a subtly different from the classic definition simply
because the input is a
&lt;em&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;sampled&lt;/a&gt;&lt;/em&gt;
data stream, defined over the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Domain_of_a_function&quot;&gt;domain&lt;/a&gt;
of all &lt;a href=&quot;https://en.wikipedia.org/wiki/Integer&quot;&gt;integers&lt;/a&gt;,
and the output is a signal defined over the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Domain_of_a_function&quot;&gt;domain&lt;/a&gt;
of &lt;a href=&quot;https://en.wikipedia.org/wiki/Real_number&quot;&gt;real numbers&lt;/a&gt;.  Therefore,
by shift invariant I mean that if you shift the incoming
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;sample&lt;/a&gt; stream
left or right by some &lt;a href=&quot;https://en.wikipedia.org/wiki/Integer&quot;&gt;integer&lt;/a&gt;
number of samples, &lt;code class=&quot;highlighter-rouge&quot;&gt;k&lt;/code&gt;, then the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolated&lt;/a&gt;
output stream (defined over the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Domain_of_a_function&quot;&gt;domain&lt;/a&gt;
of &lt;a href=&quot;https://en.wikipedia.org/wiki/Real_number&quot;&gt;real numbers&lt;/a&gt;) will
also shift by the same &lt;a href=&quot;https://en.wikipedia.org/wiki/Integer&quot;&gt;integer&lt;/a&gt;
amount.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;That’s not so hard, is it?&lt;/p&gt;

&lt;p&gt;The goal of any
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolation algorithm&lt;/a&gt;
is to estimate or recover the signal between the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;sample&lt;/a&gt;
points.  If you think about
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolation&lt;/a&gt;
in terms of Fig 1 above, the goal is to recover the gray dotted
line given only the green points.&lt;/p&gt;

&lt;p&gt;The above assumptions also drive the form of the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolation&lt;/a&gt;
solution.&lt;/p&gt;

&lt;p&gt;To see how this is the case, let’s start with a mathematical representation of
our &lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;sampled&lt;/a&gt;
signal, &lt;code class=&quot;highlighter-rouge&quot;&gt;x[n]&lt;/code&gt;, re-expressed as a series of
&lt;a href=&quot;https://en.wikipedia.org/wiki/Direc_delta_function&quot;&gt;Dirac delta functions&lt;/a&gt;
over the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Domain_of_a_function&quot;&gt;domain&lt;/a&gt;
of &lt;a href=&quot;https://en.wikipedia.org/wiki/Real_number&quot;&gt;real numbers&lt;/a&gt;.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/interp-x-made-continuous.png&quot; alt=&quot;x(t)=SUM x[n]d(t-n)&quot; width=&quot;277&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;In this representation, the function &lt;code class=&quot;highlighter-rouge&quot;&gt;x(t)&lt;/code&gt; is created from the discrete-time
input sequence &lt;code class=&quot;highlighter-rouge&quot;&gt;x[n]&lt;/code&gt; by a sum of scaled and offset
&lt;a href=&quot;https://en.wikipedia.org/wiki/Direc_delta_function&quot;&gt;Dirac delta functions&lt;/a&gt;.
Indeed, this was the meaning of the red impulses shown in Fig 1 above.  Each
&lt;a href=&quot;https://en.wikipedia.org/wiki/Direc_delta_function&quot;&gt;impulse&lt;/a&gt;
represents a scaled
&lt;a href=&quot;https://en.wikipedia.org/wiki/Direc_delta_function&quot;&gt;Dirac delta function&lt;/a&gt;,
at the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;sample&lt;/a&gt;
height, &lt;code class=&quot;highlighter-rouge&quot;&gt;x[n]&lt;/code&gt;, and location, &lt;code class=&quot;highlighter-rouge&quot;&gt;n&lt;/code&gt;, just as this equation describes.  These
&lt;a href=&quot;https://en.wikipedia.org/wiki/Direc_delta_function&quot;&gt;Dirac delta functions&lt;/a&gt;
are used to bridge the difference between the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;sampled&lt;/a&gt;
representation of a signal, &lt;code class=&quot;highlighter-rouge&quot;&gt;x[n]&lt;/code&gt;, and its continuous time equivalent,
&lt;code class=&quot;highlighter-rouge&quot;&gt;x(t)&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;We also know that every
&lt;a href=&quot;https://en.wikipedia.org/wiki/Linear_map&quot;&gt;linear&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Time-invariant_system&quot;&gt;time-invariant system&lt;/a&gt;
producing an output &lt;code class=&quot;highlighter-rouge&quot;&gt;y(t)&lt;/code&gt; from its input &lt;code class=&quot;highlighter-rouge&quot;&gt;x(t)&lt;/code&gt; can be represented by a
continuous-time
&lt;a href=&quot;https://en.wikipedia.org/wiki/Convolution&quot;&gt;convolution&lt;/a&gt;, such as the one
shown below.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/continuous-convolution.png&quot; alt=&quot;y(t)=INT h(tau)x(t-tau)&quot; width=&quot;300&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;At this point in our discussion, the form of the &lt;code class=&quot;highlighter-rouge&quot;&gt;h(t)&lt;/code&gt; that describes this
system is completely arbitrary.  It’s just a function of the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Real_number&quot;&gt;real numbers&lt;/a&gt;, producing a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Real_number&quot;&gt;real numbered&lt;/a&gt; output.  We’ll
come back later and pick a particular form to work with, but for now consider
&lt;code class=&quot;highlighter-rouge&quot;&gt;h(t)&lt;/code&gt; to be an arbitrary
&lt;a href=&quot;https://en.wikipedia.org/wiki/Real_number&quot;&gt;real&lt;/a&gt;
valued function.&lt;/p&gt;

&lt;p&gt;Since we’ve represented our original
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;sampled&lt;/a&gt;
signal, &lt;code class=&quot;highlighter-rouge&quot;&gt;x[n]&lt;/code&gt;, with a representation, &lt;code class=&quot;highlighter-rouge&quot;&gt;x(t)&lt;/code&gt;, composed of a set of scaled and
offset
&lt;a href=&quot;https://en.wikipedia.org/wiki/Direc_delta_function&quot;&gt;Dirac delta functions&lt;/a&gt;,
we can then substitute &lt;code class=&quot;highlighter-rouge&quot;&gt;x(t)&lt;/code&gt;
into this formula,&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/interp-xn-convolved.png&quot; alt=&quot;y(t)=INT h(tau) SUM x[n] d(t-tau-n)&quot; width=&quot;464&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;and then pull the summation out front,&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/interp-xn-convolved-2.png&quot; alt=&quot;y(t)=SUM x[n] INT h(tau) d(t-tau-n)&quot; width=&quot;440&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;The result is a 
&lt;a href=&quot;https://en.wikipedia.org/wiki/Convolution&quot;&gt;convolution&lt;/a&gt;
that we can evaluate.  Given the properties of the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Direc_delta_function&quot;&gt;Dirac delta functions&lt;/a&gt;,
any product of a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Direc_delta_function&quot;&gt;Dirac delta functions&lt;/a&gt;
and a function that is continuous near the region where the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Direc_delta_function&quot;&gt;Dirac delta functions&lt;/a&gt;
is non-zero, yet integrated over the point where the argument of the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Direc_delta_function&quot;&gt;Dirac delta functions&lt;/a&gt;
is goes through zero will simply yield the value of that other function at
that point.  In other words,&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/interp-is-convolution.png&quot; alt=&quot;y(t)=SUM x[n] INT h(tau) d(t-tau-n)&quot; width=&quot;278&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;and we’ve just proved that, under the assumptions we listed above,
&lt;em&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolation&lt;/a&gt;
is just another form of a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Convolution&quot;&gt;convolution&lt;/a&gt;.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;To see what I mean by this, consider Fig 2 below.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 2. Interpolation by Superposition&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/interpolation-superposition.png&quot; alt=&quot;&quot; width=&quot;810&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;In this figure, you can see the operation of the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Convolution&quot;&gt;convolution&lt;/a&gt;
taking place.  The figure shows the incoming
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;samples&lt;/a&gt;,
as green dots.  For each incoming
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;sample&lt;/a&gt;,
there is a scaled and weighted &lt;code class=&quot;highlighter-rouge&quot;&gt;h(t)&lt;/code&gt; function shown in gray.  Note how
this &lt;code class=&quot;highlighter-rouge&quot;&gt;h(t)&lt;/code&gt; function was designed so that the each gray line touches one
green circle, and yet goes through zero for the other circles.  Then, when
you sum all of these weighted and shifted &lt;code class=&quot;highlighter-rouge&quot;&gt;h(t)&lt;/code&gt; functions together, you get
the &lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolation&lt;/a&gt;
result shown in red.&lt;/p&gt;

&lt;p&gt;This conclusion has some major consequences for
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_signal_processing&quot;&gt;signal processing&lt;/a&gt;.
Among other things, it means we can use
&lt;a href=&quot;https://en.wikipedia.org/wiki/Fourier_analysis&quot;&gt;Fourier analysis&lt;/a&gt;
techniques to evaluate
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolators&lt;/a&gt;–just as we use
&lt;a href=&quot;https://en.wikipedia.org/wiki/Fourier_analysis&quot;&gt;Fourier analysis&lt;/a&gt; to evaluate
any other &lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filtering&lt;/a&gt;
operation.&lt;/p&gt;

&lt;p&gt;In particular, we can treat an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt; as nothing
more than an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Upsampling&quot;&gt;upsampling&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;.
Everything you’ve learned about
&lt;a href=&quot;https://en.wikipedia.org/wiki/Aliasing&quot;&gt;aliasing&lt;/a&gt; and
&lt;a href=&quot;https://en.wikipedia.org/wiki/Nyquist_rate&quot;&gt;Nyquist&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;sampling&lt;/a&gt;
applies now as it would with any other
&lt;a href=&quot;https://en.wikipedia.org/wiki/Upsampling&quot;&gt;upsampling&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Sadly, apart from the modern development of
&lt;a href=&quot;http://ieeexplore.ieee.org/document/15483/&quot;&gt;Farrow filters&lt;/a&gt;,
it seems that only a few
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolation&lt;/a&gt;
developments start from these assumptions.  We’ll discuss the consequences
of other choices quickly in the next section.&lt;/p&gt;

&lt;p&gt;Without loss of (too much) generality, we can use a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Piecewise&quot;&gt;piecewise&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial&quot;&gt;polynomial&lt;/a&gt;
to represent the &lt;code class=&quot;highlighter-rouge&quot;&gt;h(t)&lt;/code&gt; function above.  Doing so allows us to turn our
incoming
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;sampled&lt;/a&gt;
signal, &lt;code class=&quot;highlighter-rouge&quot;&gt;x[n]&lt;/code&gt;, into a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Piecewise&quot;&gt;piecewise&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial&quot;&gt;polynomial&lt;/a&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;y(t)&lt;/code&gt;, meaning
that what happens between
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;samples&lt;/a&gt;, i.e. the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;
result, can now be represented as a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Piecewise&quot;&gt;piecewise&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial&quot;&gt;polynomial&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Two &lt;a href=&quot;https://en.wikipedia.org/wiki/Piecewise&quot;&gt;piecewise&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial&quot;&gt;polynomial&lt;/a&gt;
forms are convenient for this purpose: those centered around the points
where the signal is defined, &lt;code class=&quot;highlighter-rouge&quot;&gt;[k-0.5,k+0.5)&lt;/code&gt; for
&lt;a href=&quot;https://en.wikipedia.org/wiki/Integer&quot;&gt;integers&lt;/a&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;k&lt;/code&gt;, and those defined between points
in a signal, such as &lt;code class=&quot;highlighter-rouge&quot;&gt;[k, k+1)&lt;/code&gt;.  We’ll come back to this more in a moment.&lt;/p&gt;

&lt;p&gt;So, to summarize, here were our assumptions:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;The incoming signal was
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;sampled&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;This will be the case with almost all
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_signal_processing&quot;&gt;DSP&lt;/a&gt;
applications.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The incoming signal is infinite in length.&lt;/p&gt;

    &lt;p&gt;While one might argue that this is never quite true, it is true that for most
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_signal_processing&quot;&gt;signal processing&lt;/a&gt;
applications there is often more data available than can be operated on at
any point in time.  For these applications, the difference between a signal
of truly infinite length and the perspective of the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_signal_processing&quot;&gt;signal processing&lt;/a&gt;
engine applied to a signal of finite length is quite irrelevant.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;All &lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;sample&lt;/a&gt;
times are equidistant&lt;/p&gt;

    &lt;p&gt;This is also true for most, although not all,
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_signal_processing&quot;&gt;DSP&lt;/a&gt;
applications.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The &lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;
must be
&lt;a href=&quot;https://en.wikipedia.org/wiki/Linear_map&quot;&gt;linear&lt;/a&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The resulting
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;
must also be shift invariant&lt;/p&gt;

    &lt;p&gt;This may be the &lt;em&gt;most significant assumption&lt;/em&gt; we’ve made along the way.
Indeed, it is this assumption that renders most of the other
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolation&lt;/a&gt;
developments inappropriate going forward–since they don’t preserve this
property.&lt;/p&gt;

    &lt;p&gt;It is also this assumption that makes
&lt;a href=&quot;https://en.wikipedia.org/wiki/Fourier_analysis&quot;&gt;Fourier analysis&lt;/a&gt; of
the &lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt; possible.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The &lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;’s
interpolation function, &lt;code class=&quot;highlighter-rouge&quot;&gt;h(t)&lt;/code&gt;, is formed from a set of
&lt;a href=&quot;https://en.wikipedia.org/wiki/Piecewise&quot;&gt;piecewise&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial&quot;&gt;polynomial&lt;/a&gt;s.&lt;/p&gt;

    &lt;p&gt;I’m sure there must be other useful
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolation&lt;/a&gt;
functions that are not formed from
&lt;a href=&quot;https://en.wikipedia.org/wiki/Piecewise&quot;&gt;piecewise&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial&quot;&gt;polynomial&lt;/a&gt;s.  However,
&lt;a href=&quot;https://en.wikipedia.org/wiki/Piecewise&quot;&gt;piecewise&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial&quot;&gt;polynomial&lt;/a&gt;s form a nice, easy
set to work with when implementing
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolators&lt;/a&gt; within
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;s–or
even &lt;a href=&quot;https://en.wikipedia.org/wiki/Embedded_system&quot;&gt;embedded&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;s for that
matter.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;For the most part, these are all quite common &lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_signal_processing&quot;&gt;digital signal
processing&lt;/a&gt;
assumptions, so I wouldn’t expect anyone to be surprised or shocked
at any of them.  What has surprised me was how rare these assumptions
are in the &lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolation&lt;/a&gt;
developments I’ve studied in the past.&lt;/p&gt;

&lt;h2 id=&quot;many-other-approaches-are-not-shift-invariant&quot;&gt;Many other approaches are not shift invariant&lt;/h2&gt;

&lt;p&gt;Since the assumptions above are not common
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolation&lt;/a&gt;
assumptions, let’s take a moment and investigate the significance of some
of them.&lt;/p&gt;

&lt;p&gt;Traditional &lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolation&lt;/a&gt;
approaches are commonly applied to only a &lt;em&gt;finite&lt;/em&gt; set of
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;sample&lt;/a&gt;
points found within a single, fixed, finite window of time.  This includes
most &lt;a href=&quot;https://en.wikipedia.org/wiki/Spline_interpolation&quot;&gt;spline interpolation&lt;/a&gt;
developments (these were always my favorites), &lt;a href=&quot;https://en.wikipedia.org/wiki/Chebyshev_polynomials&quot;&gt;Chebyshev polynomial
interpolation&lt;/a&gt;,
&lt;a href=&quot;https://en.wikipedia.org/wiki/Lagrange_polynomial&quot;&gt;Lagrange interpolation&lt;/a&gt;,
&lt;a href=&quot;https://en.wikipedia.org/wiki/Legendre_polynomials&quot;&gt;Legendre polynomial
interpolation&lt;/a&gt;
and more.&lt;/p&gt;

&lt;p&gt;These approaches, however, become less than ideal when applied to a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;sample&lt;/a&gt;
stream that is much longer than their finite time window.  Therefore, to make
these approaches viable, the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;sample&lt;/a&gt;
data stream is split into windows in time and the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;
is applied to each window.&lt;/p&gt;

&lt;p&gt;The problem with this sliding window approach revolves around what happens
at the edges where the algorithm transitions from one window to the next.
Because these
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolation&lt;/a&gt;
routines do nothing to guarantee that the result has controlled properties
between one window and the next, the transition region often suffers
from distortions not present in the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;’s
development.&lt;/p&gt;

&lt;p&gt;Nowhere is this more apparent than when combining a series of
&lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial_regression&quot;&gt;quadratic fit&lt;/a&gt;s
between
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;sample&lt;/a&gt;
points together to create a new
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolated&lt;/a&gt;
signal, such as is shown in Fig 3.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 3. The result of applying a series of sliding quadratic fits as an interpolation method&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/interpolation-discontinuous-quadratic.png&quot; alt=&quot;&quot; width=&quot;603&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;In this figure, every set of three adjacent sample points was used to create a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial_regression&quot;&gt;quadratic&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolation&lt;/a&gt;
function surrounding the middle sample.  The
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolation&lt;/a&gt;
function is only valid for plus or minus a half sample surrounding the
middle of those three points.  Outside of that region, a new
set of three samples is used to generate the next
&lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial_regression&quot;&gt;quadratic fit&lt;/a&gt;.
The resulting signal, shown in Fig 3 above, contains many unwanted
discontinuities that result from this sliding fit-window approach.&lt;/p&gt;

&lt;p&gt;Further, our desire to create an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolation&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;
that can be implemented within an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
will tend to push us away from other common
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt; structures,
such as &lt;a href=&quot;https://en.wikipedia.org/wiki/Trigonometric_interpolation&quot;&gt;trigonometric
interpolation&lt;/a&gt;,
or even &lt;a href=&quot;https://en.wikipedia.org/wiki/Rational_function&quot;&gt;rational function&lt;/a&gt;
evaluation, since these
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolators&lt;/a&gt;
depend upon functions that are more difficult to calculate within
&lt;a href=&quot;https://en.wikipedia.org/wiki/Hardware_deescription_language&quot;&gt;RTL logic&lt;/a&gt;.
That leaves us stuck with
&lt;a href=&quot;https://en.wikipedia.org/wiki/Piecewise&quot;&gt;piecewise&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial&quot;&gt;polynomial&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolation&lt;/a&gt;
functions.&lt;/p&gt;

&lt;p&gt;Not all of the other approaches avoid
&lt;a href=&quot;https://en.wikipedia.org/wiki/Shift-invariant_system&quot;&gt;shift invariance&lt;/a&gt;.
For example, the &lt;a href=&quot;https://en.wikipedia.org/wiki/Whittaker-Shannon_interpolation_formula&quot;&gt;Whittaker-Shannon&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolation&lt;/a&gt;
approach creates a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Shift-invariant_system&quot;&gt;shift invariant&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;
that can be applied to the infinite sample sets discussed above.  However, the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sinc_function&quot;&gt;sinc functions&lt;/a&gt;
it is based upon render &lt;code class=&quot;highlighter-rouge&quot;&gt;h(t)&lt;/code&gt; infinite in length, making this approach
difficult to implement.&lt;/p&gt;

&lt;p&gt;As a result, this leaves us with only one practical
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt; choice,
which we shall discuss in the next section.&lt;/p&gt;

&lt;h2 id=&quot;farrow-filters&quot;&gt;Farrow Filters&lt;/h2&gt;

&lt;p&gt;The only viable
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolation&lt;/a&gt;
alternative remaining within this set of assumptions is a
&lt;a href=&quot;http://ieeexplore.ieee.org/document/15483/&quot;&gt;Farrow filter&lt;/a&gt;.  Indeed, the
assumptions we’ve arrived at so far force us towards a
&lt;a href=&quot;http://ieeexplore.ieee.org/document/15483/&quot;&gt;Farrow filter&lt;/a&gt;, leaving us no
other alternative.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 4. A Piecewise Polynomial interpolation filter&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/interpolation-piecewise-poly.png&quot; alt=&quot;&quot; width=&quot;431&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;When using the &lt;a href=&quot;http://ieeexplore.ieee.org/document/15483/&quot;&gt;Farrow filter&lt;/a&gt;
approach, the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolation&lt;/a&gt;
function, &lt;code class=&quot;highlighter-rouge&quot;&gt;h(t)&lt;/code&gt;, is formed from a set of
&lt;a href=&quot;https://en.wikipedia.org/wiki/Piecewise&quot;&gt;piecewise&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial&quot;&gt;polynomials&lt;/a&gt;.  An example of one
such filter composed of
&lt;a href=&quot;https://en.wikipedia.org/wiki/Piecewise&quot;&gt;piecewise&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial&quot;&gt;quadratics&lt;/a&gt;
is shown in Fig 4 on the right.&lt;/p&gt;

&lt;p&gt;According to
&lt;a href=&quot;http://ieeexplore.ieee.org/document/15483/&quot;&gt;Farrow’s paper&lt;/a&gt;, the actual
“amount of delay”, i.e. the &lt;code class=&quot;highlighter-rouge&quot;&gt;t&lt;/code&gt; value when calculating the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolation&lt;/a&gt;
result, need not be calculated until it is needed.  This
is perfect for what we might wish to accomplish within an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The only question remaining is, what
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolation&lt;/a&gt;
function, &lt;code class=&quot;highlighter-rouge&quot;&gt;h(t)&lt;/code&gt;, shall we use?&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://ieeexplore.ieee.org/document/00679201/&quot;&gt;Fred Harris&lt;/a&gt; presents a
solution to
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolation&lt;/a&gt;
function generation based upon first designing a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;discrete-time filter&lt;/a&gt;
of many taps, and then approximating that function with a higher order
&lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial&quot;&gt;polynomial&lt;/a&gt;.
You may find this approach a valid solution to your
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolation&lt;/a&gt;
needs.  It is actually commonly used.&lt;/p&gt;

&lt;p&gt;I just haven’t found &lt;a href=&quot;http://ieeexplore.ieee.org/document/00679201/&quot;&gt;Harris’s ad-hoc filter derivation
method&lt;/a&gt;
personally very satisfying.  Ever since finding
&lt;a href=&quot;http://ieeexplore.ieee.org/document/00679201/&quot;&gt;Harris&lt;/a&gt;’s work, I’ve wanted
to know if there were a more rigorous and less ad-hoc approach to generating
these coefficients.  Is there some way, therefore, that an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;
can be developed using this technique and yet still meeting some
optimality properties?&lt;/p&gt;

&lt;p&gt;The answer is, yes there is, but also that we won’t get that far today. 
Instead, we’ll just lay the ground work for understanding and analyzing
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filters&lt;/a&gt;
of &lt;a href=&quot;http://ieeexplore.ieee.org/document/15483/&quot;&gt;this type&lt;/a&gt;.
Then, later, we’ll use this approach in order to develop &lt;em&gt;optimal&lt;/em&gt;
(in some sense)
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolation&lt;/a&gt; functions and their
&lt;a href=&quot;https://en.wikipedia.org/wiki/Piecewise&quot;&gt;piecewise&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial&quot;&gt;polynomial&lt;/a&gt;
coefficients.&lt;/p&gt;

&lt;h2 id=&quot;some-example-filters&quot;&gt;Some example filters&lt;/h2&gt;

&lt;p&gt;For now, let’s demonstrate some example
&lt;a href=&quot;http://ieeexplore.ieee.org/document/15483/&quot;&gt;Farrow filters&lt;/a&gt;.
Our examples will have a much lower order than those either
&lt;a href=&quot;http://ieeexplore.ieee.org/document/15483/&quot;&gt;Farrow&lt;/a&gt;
or &lt;a href=&quot;http://ieeexplore.ieee.org/document/00679201/&quot;&gt;Harris&lt;/a&gt; used, but the lower
order might help to make
&lt;a href=&quot;http://ieeexplore.ieee.org/document/15483/&quot;&gt;these filters&lt;/a&gt;
more understandable.&lt;/p&gt;

&lt;h3 id=&quot;sample-and-hold&quot;&gt;Sample and hold&lt;/h3&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 5. Sample and Hold&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/interpolation-fig-shold.png&quot; alt=&quot;&quot; width=&quot;325&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;The first &lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;
we discussed on
&lt;a href=&quot;http://zipcpu.com/&quot;&gt;this blog&lt;/a&gt;
was a sample and hold function.  While this may not seem like much of an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;,
it can be shown to have the form shown in Fig 5 on the right, and in
the equation below:&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/interpolation-eqn-shold.png&quot; alt=&quot;h(t) = 1, for 0&amp;lt;t&amp;lt;1, 0 ow&quot; width=&quot;250&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;This is actually a common
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolation&lt;/a&gt;
function in many mixed signal components, so it is worth recognizing.&lt;/p&gt;

&lt;p&gt;While this a common
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolation&lt;/a&gt;
function in many practical mixed signal
components, I’d like to do better.  Let’s keep looking, therefore.&lt;/p&gt;

&lt;h3 id=&quot;nearest-neighbour&quot;&gt;Nearest Neighbour&lt;/h3&gt;

&lt;p&gt;A similar &lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolation&lt;/a&gt;
function is the
&lt;a href=&quot;/dsp/2017/06/06/simple-interpolator.html&quot;&gt;nearest neighbor&lt;/a&gt;
function.  This has
an almost identical form for &lt;code class=&quot;highlighter-rouge&quot;&gt;h(t)&lt;/code&gt; as the sample-and-hold function above,
save that this time &lt;code class=&quot;highlighter-rouge&quot;&gt;h(t)&lt;/code&gt; is centered about the y-axis.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/interpolation-eqn-nnbor.png&quot; alt=&quot;h(t) = 1, for |t|&amp;lt;1/2, 0 ow&quot; width=&quot;252&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;It isn’t all that difficult to prove that the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Fourier_transform&quot;&gt;Fourier&lt;/a&gt;
transform of this function is a familiar
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sinc_funtion&quot;&gt;sinc function&lt;/a&gt;, which decays
out of band at a rate of &lt;code class=&quot;highlighter-rouge&quot;&gt;1/f&lt;/code&gt;.  Fig 6 below shows both this &lt;code class=&quot;highlighter-rouge&quot;&gt;h(t)&lt;/code&gt; function,
on the left, as well as its
&lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency_response&quot;&gt;frequency response&lt;/a&gt;
on the right.  Also shown on the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency_response&quot;&gt;frequency response&lt;/a&gt;
chart is a &lt;code class=&quot;highlighter-rouge&quot;&gt;1/f&lt;/code&gt; asymptote.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 6. Nearest Neighbor interpolation function and frequency response&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/interpolation-fig-nnbor.png&quot; alt=&quot;&quot; width=&quot;730&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;The asymptotic performance can be controlled in
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;
design to achieve specific performance measures, if desired.  You’ll be able
to see this as we continue.&lt;/p&gt;

&lt;h3 id=&quot;linear-interpolation&quot;&gt;Linear interpolation&lt;/h3&gt;

&lt;p&gt;If you &lt;a href=&quot;https://en.wikipedia.org/wiki/Convolution&quot;&gt;convolve&lt;/a&gt;
the &lt;a href=&quot;https://en.wikipedia.org/wiki/Rectangular_function&quot;&gt;rectangle function&lt;/a&gt;
that is the
&lt;a href=&quot;/dsp/2017/06/06/simple-interpolator.html&quot;&gt;nearest neighbor&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;
with itself, you will get a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Triangle_function&quot;&gt;triangle functions&lt;/a&gt;,&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/interpolation-eqn-linear.png&quot; alt=&quot;h(t) = 1-|t|^2, for |t|&amp;lt;1/2&quot; width=&quot;297&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Since
&lt;a href=&quot;https://en.wikipedia.org/wiki/Convolution&quot;&gt;convolution&lt;/a&gt;
in time is multiplication in frequency, the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Fourier_transform&quot;&gt;Fourier&lt;/a&gt;
transform of this function is simply a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sinc_funtion&quot;&gt;sinc function&lt;/a&gt; squared.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 7. Linear interpolation function and frequency response&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/interpolation-fig-linear.png&quot; alt=&quot;&quot; width=&quot;730&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;This creates a &lt;code class=&quot;highlighter-rouge&quot;&gt;1/f^2&lt;/code&gt; asymptote, shown above.  As a result, any out of band
&lt;a href=&quot;https://en.wikipedia.org/wiki/Aliasing&quot;&gt;aliasing&lt;/a&gt;
artifacts are further attenuated by this filter.&lt;/p&gt;

&lt;h3 id=&quot;quadratic-fit&quot;&gt;Quadratic Fit&lt;/h3&gt;

&lt;p&gt;With a little bit of work, the typical quadratic fit function, the one
producing the result in Fig 3 above, can also be
represented in this form.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/interpolation-eqn-qfit.png&quot; alt=&quot;Quadratic fit eqn&quot; width=&quot;396&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 8. Quadratic fit function&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/interpolation-fig-qfit.png&quot; alt=&quot;&quot; width=&quot;325&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;This function, however, isn’t continuous at all.  Indeed, when you plot it
out, as in Fig 8 to the right, you’ll get a feel for why the quadratic fit
in Fig 3 above looked as horrible as it did.&lt;/p&gt;

&lt;p&gt;But, what happened?  Why does this look nothing like a quadratic fit?&lt;/p&gt;

&lt;p&gt;Well, actually, it does.  If you extend the middle section on both sides,
you can see that it comes down and hits the axis at &lt;code class=&quot;highlighter-rouge&quot;&gt;x=-1&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;x=1&lt;/code&gt;.  In
a similar fashion, if you extend either of the wings out, you’ll see they
hit &lt;code class=&quot;highlighter-rouge&quot;&gt;y(0)=1&lt;/code&gt; and either &lt;code class=&quot;highlighter-rouge&quot;&gt;y(-2)=0&lt;/code&gt; or &lt;code class=&quot;highlighter-rouge&quot;&gt;y(2)=0&lt;/code&gt; respectively.  We created
exactly what we tried to create, but by moving from one fitting window
to the next we also created the discontinuous artifacts shown in Fig 8.&lt;/p&gt;

&lt;p&gt;This really shouldn’t be surprising.  When we created our quadratic fit,
we did nothing to control the transitions from one fitting region to another.
Fig 8 just shows the effects of such a choice on the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;
that results.&lt;/p&gt;

&lt;h3 id=&quot;smoothed-quadratic&quot;&gt;Smoothed quadratic&lt;/h3&gt;

&lt;p&gt;If &lt;a href=&quot;https://en.wikipedia.org/wiki/Convolution&quot;&gt;convolving&lt;/a&gt;
a &lt;a href=&quot;https://en.wikipedia.org/wiki/Rectangular_function&quot;&gt;rectangle&lt;/a&gt;
with itself generated a nice &lt;a href=&quot;/dsp/2017/07/29/series-linear-interpolation.html&quot;&gt;linear
interpolation&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Triangle_function&quot;&gt;triangle function&lt;/a&gt;,
what do you think you would you get from
&lt;a href=&quot;https://en.wikipedia.org/wiki/Convolution&quot;&gt;convolving&lt;/a&gt; a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Triangle_function&quot;&gt;triangle function&lt;/a&gt;
with that same
&lt;a href=&quot;https://en.wikipedia.org/wiki/Rectangular_function&quot;&gt;rectangle&lt;/a&gt;?  You will
get a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Piecewise&quot;&gt;piecewise&lt;/a&gt;
quadratic
&lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial&quot;&gt;polynomial&lt;/a&gt;
function whose
&lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency_response&quot;&gt;frequency response&lt;/a&gt;
decays at &lt;code class=&quot;highlighter-rouge&quot;&gt;1/f^3&lt;/code&gt;–as fast or faster than any other
&lt;a href=&quot;https://en.wikipedia.org/wiki/Piecewise&quot;&gt;piecewise&lt;/a&gt;
quadratic
&lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial&quot;&gt;polynomial&lt;/a&gt;
function.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/interpolation-eqn-rectcubed.png&quot; alt=&quot;Quadratic eqn for the quadratic created by convolving a rectangle with itself three times&quot; width=&quot;402&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;The only problem with this function is that it is no longer a true
&lt;a href=&quot;/dsp/2017/07/29/series-linear-interpolation.html&quot;&gt;interpolator&lt;/a&gt;.
By that I mean that if you were to
&lt;a href=&quot;https://en.wikipedia.org/wiki/Convolution&quot;&gt;convolve&lt;/a&gt;
your sampled data, &lt;code class=&quot;highlighter-rouge&quot;&gt;x[n]&lt;/code&gt;, with this function, then the continuous output
function, &lt;code class=&quot;highlighter-rouge&quot;&gt;y(t)&lt;/code&gt;, that would result would no longer necessarily match
&lt;code class=&quot;highlighter-rouge&quot;&gt;x[n]&lt;/code&gt; whenever &lt;code class=&quot;highlighter-rouge&quot;&gt;t=n&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;This is a result of the fact that &lt;code class=&quot;highlighter-rouge&quot;&gt;h(n)&lt;/code&gt; doesn’t equal zero for all
&lt;a href=&quot;https://en.wikipedia.org/wiki/Integer&quot;&gt;integers&lt;/a&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;n&lt;/code&gt;, where &lt;code class=&quot;highlighter-rouge&quot;&gt;n != 0&lt;/code&gt;.
You can see from Fig 9 below that this
function certainly doesn’t go through zero at &lt;code class=&quot;highlighter-rouge&quot;&gt;t=1&lt;/code&gt; as just one example.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 9. Smoother Quadratic function and frequency response&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/interpolation-fig-rcubd.png&quot; alt=&quot;&quot; width=&quot;730&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;The good news, though, is that the &lt;code class=&quot;highlighter-rouge&quot;&gt;1/f^3&lt;/code&gt; falloff was one of the best we’ve
seen yet–as shown by the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency_response&quot;&gt;frequency response&lt;/a&gt;
function on the right of Fig 9 above.&lt;/p&gt;

&lt;p&gt;Since we are trying to create
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolators&lt;/a&gt;,
a function that isn’t an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;
isn’t very acceptable.  Therefore let’s remember this function
while looking for an better alternative.&lt;/p&gt;

&lt;h3 id=&quot;ideal-interpolator&quot;&gt;Ideal Interpolator&lt;/h3&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 10. Ideal interpolator&#39;s frequency response&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/interpolation-fig-ideal.png&quot; alt=&quot;&quot; width=&quot;370&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Much as it is possible with traditional
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filtering&lt;/a&gt;
methods to specify an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sinc_filter&quot;&gt;ideal filter&lt;/a&gt;,
the same can be done with
&lt;a href=&quot;http://ieeexplore.ieee.org/document/15483/&quot;&gt;interpolation filters&lt;/a&gt;
as well.&lt;/p&gt;

&lt;p&gt;Shown in Fig 10 at the right is the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency_response&quot;&gt;frequency response&lt;/a&gt;
of an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sinc_filter&quot;&gt;ideal&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolation&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;.
As you might expect, this function passes all frequencies below the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Nyquist_rate&quot;&gt;Nyquist&lt;/a&gt;
frequency, and stops all frequencies above that.&lt;/p&gt;

&lt;p&gt;However, as with the development of more traditional
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filters&lt;/a&gt;,
this
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;
is also infinite in length, doesn’t fit nicely into a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Piecewise&quot;&gt;piecewise&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial&quot;&gt;polynomial&lt;/a&gt;
representation, and thus isn’t very suitable for practical work.&lt;/p&gt;

&lt;p&gt;It is suitable, however, for discussing the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sinc_filter&quot;&gt;ideal&lt;/a&gt;
that we would like our practical
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filters&lt;/a&gt;
to approach in terms of performance.  Therefore, we shall judge that the
closer an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolation&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter’s&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency_response&quot;&gt;frequency response&lt;/a&gt;
approximates this
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sinc_filter&quot;&gt;ideal&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;,
the better the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolation&lt;/a&gt;
will be.&lt;/p&gt;

&lt;h3 id=&quot;better-quadratic&quot;&gt;Better Quadratic&lt;/h3&gt;

&lt;p&gt;With a bit more work, we can come up with a better quadratic
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolation&lt;/a&gt;
function.  This function, shown in Fig 11 below, has a much wider
“&lt;a href=&quot;https://en.wikipedia.org/wiki/Passband&quot;&gt;passband&lt;/a&gt;”,
while still maintaining the &lt;code class=&quot;highlighter-rouge&quot;&gt;1/f^2&lt;/code&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Stopband&quot;&gt;stopband&lt;/a&gt;
fall off that the &lt;a href=&quot;/dsp/2017/07/29/series-linear-interpolation.html&quot;&gt;linear
interpolator&lt;/a&gt; had.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 11. A better quadratic interpolator function and frequency response&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/interpolation-fig-betterq.png&quot; alt=&quot;&quot; width=&quot;730&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Not only that, but this
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;
comes closer to the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sinc_filter&quot;&gt;ideal&lt;/a&gt;
in both
&lt;a href=&quot;https://en.wikipedia.org/wiki/Passband&quot;&gt;passband&lt;/a&gt; and
&lt;a href=&quot;https://en.wikipedia.org/wiki/Stopband&quot;&gt;stopband&lt;/a&gt;
then our last attempt did.  Hence, while maintaining the asymptotic
performance of a
&lt;a href=&quot;/dsp/2017/07/29/series-linear-interpolation.html&quot;&gt;linear interpolator&lt;/a&gt;,
we’ve achieved better performance at lower frequencies.  Further, the nulls
are deeper and wider than the
&lt;a href=&quot;/dsp/2017/07/29/series-linear-interpolation.html&quot;&gt;linear interpolator&lt;/a&gt; shown in Fig 7 above.&lt;/p&gt;

&lt;p&gt;For these reasons, this will be the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;
we’ll implement and demonstrate when we come back and look at quadratic
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolation&lt;/a&gt;
performance in a later post.&lt;/p&gt;

&lt;h3 id=&quot;can-we-do-better&quot;&gt;Can we do better?&lt;/h3&gt;

&lt;p&gt;I think the answer to this question is, yes, we can do even better than this.
However, I have yet to see the formal theory behind optimally generating
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolation&lt;/a&gt;
functions such as these.&lt;/p&gt;

&lt;p&gt;For now, consider this question: can the ad-hoc
&lt;a href=&quot;http://ieeexplore.ieee.org/document/15483/&quot;&gt;Farrow&lt;/a&gt; filter functions that
&lt;a href=&quot;http://ieeexplore.ieee.org/document/00679201/&quot;&gt;Harris&lt;/a&gt; espouses be
rewritten as discrete
&lt;a href=&quot;https://en.wikipedia.org/wiki/Convolution&quot;&gt;convolutions&lt;/a&gt;
of functions which are formed by
&lt;a href=&quot;https://en.wikipedia.org/wiki/Convolution&quot;&gt;convolving&lt;/a&gt; a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Rectangular_function&quot;&gt;rectangle&lt;/a&gt;
rectangle with itself many times?  If so, you could choose the rate at
which the stop band falls off, whether &lt;code class=&quot;highlighter-rouge&quot;&gt;1/f&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;1/f^2&lt;/code&gt;, etc, by choosing
which subset of these functions you wish to use when generating your
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolation&lt;/a&gt;
function.&lt;/p&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;Selecting a “good”
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolation&lt;/a&gt;
method for your signal processing application
starts with the right set of assumptions.  Indeed, the single most critical
assumption required for good
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;
development is that the resulting
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolation&lt;/a&gt;
method must be shift invariant.
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;Interpolation&lt;/a&gt;
routines chosen without this property are likely to suffer uncontrolled
effects as the interval defining the function changes with time.&lt;/p&gt;

&lt;p&gt;This, however, is only the beginning of the study of
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolation&lt;/a&gt;
for
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_signal_processing&quot;&gt;DSP&lt;/a&gt;
applications within
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;s.
While it opens up the topic by providing the necessary background, more
remains to be covered.  For example:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;It is possible, although perhaps not all that practical, to create a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Spline_interpolation&quot;&gt;spline&lt;/a&gt;
development under these assumptions.  Although the typical
&lt;a href=&quot;https://en.wikipedia.org/wiki/Spline_interpolation&quot;&gt;spline&lt;/a&gt;
development depends upon a difficult matrix inversion, an alternative
&lt;a href=&quot;https://en.wikipedia.org/wiki/Spline_interpolation&quot;&gt;spline&lt;/a&gt;
development exists which doesn’t depend upon any real-time matrix inversion.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Using this approach, we can now build some very useful and generic
quadratic
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolators&lt;/a&gt;.
Two in particular will be worth discussing: a quadratic
&lt;a href=&quot;https://en.wikipedia.org/wiki/Upsampling&quot;&gt;upsampling&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;
which may be used for
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sample-rate_conversion&quot;&gt;resampling&lt;/a&gt;
or tracking applications, and an improved
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sine_wave&quot;&gt;sine wave&lt;/a&gt; &lt;a href=&quot;/dsp/2017/07/11/simplest-sinewave-generator.html&quot;&gt;table
lookup&lt;/a&gt;
method.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Finally, it might be fun to see if it is possible to generate an &lt;em&gt;optimum&lt;/em&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;
by some measure of optimality.&lt;/p&gt;

&lt;p&gt;While I intend to come back to this topic, if you are
interested in more information about the types of
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolators&lt;/a&gt;
discussed above before that time, feel free to check out my &lt;a href=&quot;https://github.com/ZipCPU/interpolation/raw/master/tutorial.pdf&quot;&gt;tutorial
slides&lt;/a&gt;
on the topic.&lt;/p&gt;
&lt;hr /&gt;&lt;p&gt;&lt;em&gt;Is it fit to say to a king, Thou art wicked? and to princes, Ye are ungodly?  (Job 34:18)&lt;/em&gt;</description>
        <pubDate>Tue, 16 Jan 2018 00:00:00 -0500</pubDate>
        <link>http://zipcpu.com/dsp/2018/01/16/interpolation-is-convolution.html</link>
        <guid isPermaLink="true">http://zipcpu.com/dsp/2018/01/16/interpolation-is-convolution.html</guid>
        
        
        <category>dsp</category>
        
      </item>
    
      <item>
        <title>A Quick Introduction to the ZipCPU Instruction Set</title>
        <description>&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 1: The ZipCPU&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/zipcpu.png&quot; alt=&quot;&quot; width=&quot;360&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;If you aren’t familiar with the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;, then you should know that it
is my attempt at improving the publicly available
&lt;a href=&quot;https://en.wikipedia.org/wiki/Soft_microprocessor&quot;&gt;softcore CPU&lt;/a&gt;
architectures.  It has been designed from the ground up to be a truly
&lt;a href=&quot;https://en.wikipedia.org/wiki/Reduced_instruction_set_computer&quot;&gt;&lt;em&gt;Reduced&lt;/em&gt; instruction set computer, or
RISC&lt;/a&gt;
machine, to have
a simple
&lt;a href=&quot;https://en.wikipedia.org/wiki/Instruction_pipelining&quot;&gt;pipeline&lt;/a&gt;
implementation, and yet to be able to run a multi-tasking
&lt;a href=&quot;https://en.wikipedia.org/wiki/Operating_System&quot;&gt;operating system&lt;/a&gt;
if desired.  Unlike many of the other more common
&lt;a href=&quot;https://en.wikipedia.org/wiki/Soft_microprocessor&quot;&gt;soft-core CPU&lt;/a&gt;s,
such as
&lt;a href=&quot;https://www.xilinx.com/support/documentation/sw_manuals/mb_ref_guide.pdf&quot;&gt;MicroBlaze&lt;/a&gt;
or the &lt;a href=&quot;https://www.altera.com/literature/hb/nios2/n2cpu_nii5v1.pdf&quot;&gt;NiosII&lt;/a&gt;,
the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; has been created in a
completely open source fashion.&lt;/p&gt;

&lt;p&gt;The &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; was also designed to
run on the cheaper, more commodity,
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
hardware platforms.
Indeed, in many ways this has always been the philosophy behind the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;: be small and simple, yet
fully and completely functional.  I judged, as I built it this way, that not
only would it be easier to build and debug a simpler
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;,
but also that it would be easier to add to an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
project as an afterthought if it was small.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: left&quot;&gt;&lt;caption&gt;Fig 2: A Cheaper CPU: Teensy LC&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;a href=&quot;https://www.pjrc.com/teensy/&quot;&gt;&lt;img src=&quot;/img/teensy.jpg&quot; alt=&quot;A Picture of the Teensy CPU&quot; width=&quot;120&quot; /&gt;&lt;/a&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;Consider, for a moment: if you bought an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;,
you did so for a purpose.  If you wanted a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;
instead then there are many other
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;’s
that you could have bought that would have run faster, and cost less, than
the &lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
you purchased.  As an example, Fig 2 shows a picture of the &lt;a href=&quot;https://www.pjrc.com/teensy&quot;&gt;TeensyLC&lt;/a&gt;–a small
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;
that sells for only $15USD.  Since you didn’t purchase a
&lt;a href=&quot;https://www.pjrc.com/teensy&quot;&gt;TeensyLC&lt;/a&gt;, you must have purchased that
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
for a reason–to perform a task that you couldn’t do with an off-the-shelf
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;.
Indeed, I would imagine you want as much of your
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
available to complete that task as possible.
If, in the process, you find yourself needing a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt; on the same
chip as your
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;–then
you want that
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;
to stay out of the way, and to consume as few resources as possible.&lt;/p&gt;

&lt;p&gt;This is, and was, the purpose of the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;We’ve already discussed several of the parts and pieces of the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; across many articles over
the last year.  For example, we discussed the divide unit when we discussed
&lt;a href=&quot;/blog/2017/06/12/minimizing-luts.html&quot;&gt;minimizing FPGA resource
allocation&lt;/a&gt;.
We discussed the
&lt;a href=&quot;/zipcpu/2017/08/11/simple-alu.html&quot;&gt;ALU&lt;/a&gt;
unit when describing how a &lt;a href=&quot;/zipcpu/2017/08/11/simple-alu.html&quot;&gt;simple ALU might be
structured&lt;/a&gt;.
We discussed the &lt;a href=&quot;/zipcpu/2017/07/14/cpu-debugging-needs.html&quot;&gt;debugging needs of a
CPU&lt;/a&gt; in general,
as well as how to meet those needs in both
&lt;a href=&quot;/zipcpu/2017/07/26/cpu-sim-debugger.html&quot;&gt;simulation&lt;/a&gt; and
in the &lt;a href=&quot;/zipcpu/2017/08/25/hw-debugging.html&quot;&gt;hardware&lt;/a&gt;.  More
recently, we &lt;a href=&quot;/zipcpu/2017/11/18/wb-prefetch.html&quot;&gt;presented and formally verified a simple prefetch
engine&lt;/a&gt; for the
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;wishbone bus&lt;/a&gt;.  Indeed,
my recent post about the &lt;a href=&quot;/zipcpu/2017/12/28/ugliest-bug.html&quot;&gt;ugliest
bug&lt;/a&gt;
I’ve ever encountered was also based upon my experiences with the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Today, let’s take a look at how the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/raw/master/spec.pdf&quot;&gt;instruction set&lt;/a&gt; is
laid out, and discuss a few of the ways it is different from some of the
other, more common,
&lt;a href=&quot;https://en.wikipedia.org/wiki/Soft_microprocessor&quot;&gt;soft-core CPU&lt;/a&gt;s
of today.  Our intention will by no means be to present a complete description
of the &lt;a href=&quot;https://en.wikipedia.org/wiki/Instruction_set_architecture&quot;&gt;ISA&lt;/a&gt;,
but rather an overview.  The
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/raw/master/doc/spec.pdf&quot;&gt;ZipCPU specification&lt;/a&gt;should provide any missing details–if not, please let me know if you find
something missing and I can add it in.&lt;/p&gt;

&lt;h2 id=&quot;the-basic-operations&quot;&gt;The Basic Operations&lt;/h2&gt;

&lt;p&gt;The &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; was designed around a set
of instructions all having the very simple form,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-asm&quot; data-lang=&quot;asm&quot;&gt;	OP.X #+Rb,Ra&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 3: Generic ZipCPU Instruction Operation&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/zipcpu-op-logic.svg&quot; alt=&quot;Ra &amp;lt;= (if X) Ra (op) #+Rb&quot; width=&quot;480&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;You can read this generic instruction as: if &lt;code class=&quot;highlighter-rouge&quot;&gt;X&lt;/code&gt; is true, then &lt;code class=&quot;highlighter-rouge&quot;&gt;OP&lt;/code&gt; is applied
to the number &lt;code class=&quot;highlighter-rouge&quot;&gt;#&lt;/code&gt; plus the value of register &lt;code class=&quot;highlighter-rouge&quot;&gt;Rb&lt;/code&gt;, and the register &lt;code class=&quot;highlighter-rouge&quot;&gt;Ra&lt;/code&gt;,
and the result is placed into &lt;code class=&quot;highlighter-rouge&quot;&gt;Ra&lt;/code&gt;.  Here I’m using &lt;code class=&quot;highlighter-rouge&quot;&gt;#&lt;/code&gt; to refer to an
immediate value–a fixed number encoded within the instruction stream.&lt;/p&gt;

&lt;p&gt;Fig 3 attempts to show this operation graphically.  Two registers are read
from the register file, noted here as &lt;code class=&quot;highlighter-rouge&quot;&gt;Ra&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;Rb&lt;/code&gt;.  An immediate is added
to register &lt;code class=&quot;highlighter-rouge&quot;&gt;Rb&lt;/code&gt;, or alternatively the immediate replaces &lt;code class=&quot;highlighter-rouge&quot;&gt;Rb&lt;/code&gt; entirely,
and the result joins &lt;code class=&quot;highlighter-rouge&quot;&gt;Ra&lt;/code&gt; to be operated upon.&lt;/p&gt;

&lt;p&gt;For &lt;a href=&quot;/zipcpu/2017/08/11/simple-alu.html&quot;&gt;ALU&lt;/a&gt;
instructions, the result is only written back if the condition is
true.&lt;/p&gt;

&lt;p&gt;Memory instructions are just a touch different.  In the case of a memory
instruction, the &lt;code class=&quot;highlighter-rouge&quot;&gt;#+Rb&lt;/code&gt; value (immediate number plus the value of register
&lt;code class=&quot;highlighter-rouge&quot;&gt;Rb&lt;/code&gt;) is used as the address for the memory operation.  Further, the
operation only begins if the condition is true.  &lt;code class=&quot;highlighter-rouge&quot;&gt;Ra&lt;/code&gt; is used as the
data source for a store operation, or the data result of a load operation.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 4: ZipCPU Instruction Format(s)&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/zipcpu-insn-form.png&quot; alt=&quot;1&#39;b0, 4&#39;b Ra, 5&#39;b Op, etc.&quot; width=&quot;633&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;The encoding for this and other &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; instructions are shown
in Fig 4 on the right.  Four bits are used to encode the destination register,
&lt;code class=&quot;highlighter-rouge&quot;&gt;Ra&lt;/code&gt;, five bits are used to encode the opcode, &lt;code class=&quot;highlighter-rouge&quot;&gt;OP&lt;/code&gt;, three bits are used to
encode the condition, &lt;code class=&quot;highlighter-rouge&quot;&gt;X&lt;/code&gt;, and the remaining bits are used to encode whether
or not &lt;code class=&quot;highlighter-rouge&quot;&gt;Rb&lt;/code&gt; is used and what immediate offset is used by the instruction.&lt;/p&gt;

&lt;p&gt;Two instructions have special formats: the &lt;code class=&quot;highlighter-rouge&quot;&gt;MOV&lt;/code&gt; (move) and &lt;code class=&quot;highlighter-rouge&quot;&gt;LDI&lt;/code&gt; (load
immediate) instructions, we’ll come back to these further on.&lt;/p&gt;

&lt;p&gt;The &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; can also support
compressed instructions, with their format shown at the bottom of Fig 4.
While we’ll only touch on the &lt;em&gt;Compressed Instruction Set&lt;/em&gt;
today, you can read all about these two-for-one instructions in the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/raw/master/doc/spec.pdf&quot;&gt;specification&lt;/a&gt; if you are
interested.&lt;/p&gt;

&lt;p&gt;Indeed, the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; &lt;a href=&quot;https://en.wikipedia.org/wiki/Instruction_set_architecture&quot;&gt;instruction set
architecture&lt;/a&gt;
 is just about that simple.  Still, let’s dig into some more details.&lt;/p&gt;

&lt;h2 id=&quot;the-basic-operations-in-more-detail&quot;&gt;The Basic Operations, in more detail&lt;/h2&gt;

&lt;p&gt;Most &lt;a href=&quot;https://en.wikipedia.org/wiki/Reduced_instruction_set_computer&quot;&gt;RISC&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;s
today tend to support a six bit opcode or larger.  This allows
these machines to support up to 64 basic instructions–or even more.
Not the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; was designed to be a truly
&lt;a href=&quot;https://en.wikipedia.org/wiki/Reduced_instruction_set_computer&quot;&gt;&lt;em&gt;Reduced&lt;/em&gt; instruction set
computer&lt;/a&gt;.
As a result, it doesn’t have nearly as many instructions as its competitors:
the &lt;a href=&quot;http://www.latticesemi.com/~/media/LatticeSemi/Documents/UserManuals/JL/LatticeMico32ProcessorReferenceManual37.pdf&quot;&gt;lm32 processor&lt;/a&gt;,
&lt;a href=&quot;https://raw.githubusercontent.com/openrisc/doc/master/archive/openrisc_arch.pdf&quot;&gt;OpenRISC&lt;/a&gt;,
&lt;a href=&quot;https://riscv.org&quot;&gt;RISC-V&lt;/a&gt;,
&lt;a href=&quot;https://www.altera.com/literature/hb/nios2/n2cpu_nii5v1.pdf&quot;&gt;NiosII&lt;/a&gt;,
and &lt;a href=&quot;https://www.xilinx.com/support/documentation/sw_manuals/mb_ref_guide.pdf&quot;&gt;MicroBlaze&lt;/a&gt;.  We can go over some of these differences later.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 5: ZipCPU Instructions&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/zipcpu-insns.png&quot; alt=&quot;(A chart of the [ZipCPU](/about/zipcpu.html) instructions)&quot; width=&quot;378&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;For now, let’s take a quick look at the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; instruction cheat sheet, shown
in Fig 5.  From here, you can see that the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; supports 25 basic
instructions.
It has four special instructions, &lt;code class=&quot;highlighter-rouge&quot;&gt;BREAK&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;LOCK&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;NOOP&lt;/code&gt;, and &lt;code class=&quot;highlighter-rouge&quot;&gt;SIM&lt;/code&gt;,
and another six instructions reserved for a floating point co-processor–these
are the &lt;code class=&quot;highlighter-rouge&quot;&gt;FP&lt;/code&gt; instructions.  Further, eight instructions have been chosen to
also have a compressed representation.&lt;/p&gt;

&lt;p&gt;That’s it.  There are no more or hidden instructions, although a lot of
the instructions within this list have some special functionality.&lt;/p&gt;

&lt;p&gt;Shall we walk through these instructions, and discuss what each does in turn?&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;SUB&lt;/strong&gt;tract, subtracts &lt;code class=&quot;highlighter-rouge&quot;&gt;#+Rb&lt;/code&gt; from the value in &lt;code class=&quot;highlighter-rouge&quot;&gt;Ra&lt;/code&gt;, leaving the result in
&lt;code class=&quot;highlighter-rouge&quot;&gt;Ra&lt;/code&gt;.&lt;/p&gt;

    &lt;p&gt;I’ll write this as &lt;code class=&quot;highlighter-rouge&quot;&gt;Ra &amp;lt;= Ra - (#+Rb)&lt;/code&gt; to facilitate a simpler notation,
since just about all of the instructions will have this form.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;AND&lt;/strong&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;Ra &amp;lt;= Ra &amp;amp; (#+Rb)&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;ADD&lt;/strong&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;Ra &amp;lt;= Ra + (#+Rb)&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;OR&lt;/strong&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;Ra &amp;lt;= Ra | (#+Rb)&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;XOR&lt;/strong&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;Ra &amp;lt;= Ra ^ (#+Rb)&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;LSR&lt;/strong&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;Ra &amp;lt;= Ra &amp;gt;&amp;gt; (#+Rb)&lt;/code&gt; (assumes Ra is unsigned)&lt;/p&gt;

    &lt;p&gt;In all of the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;’s
shift instructions, the last bit shifted out of &lt;code class=&quot;highlighter-rouge&quot;&gt;Ra&lt;/code&gt; is placed into the
Carry flag.&lt;/p&gt;

    &lt;p&gt;Further, these shift instructions accept requests for shifts outside of the
reasonable bounds &lt;code class=&quot;highlighter-rouge&quot;&gt;0--31&lt;/code&gt;, permitting instead any shift amount between
&lt;code class=&quot;highlighter-rouge&quot;&gt;0&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;2^31&lt;/code&gt;–not that you’d need these extra amounts.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;LSL&lt;/strong&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;Ra &amp;lt;= Ra &amp;lt;&amp;lt; (#+Rb)&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;ASR&lt;/strong&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;Ra &amp;lt;= Ra &amp;gt;&amp;gt; (#+Rb)&lt;/code&gt;&lt;/p&gt;

    &lt;p&gt;This instruction implements an &lt;a href=&quot;https://en.wikipedia.org/wiki/Arithmetic_shift&quot;&gt;Arithmetic right
shift&lt;/a&gt;.  This is
done by first assuming that &lt;code class=&quot;highlighter-rouge&quot;&gt;Ra&lt;/code&gt; is
signed, and then propagating the sign bit from the MSB down.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;BREV&lt;/strong&gt;, This is the “bit-reverse” instruction.  For this instruction,
&lt;code class=&quot;highlighter-rouge&quot;&gt;Ra&lt;/code&gt; is assigned the value of &lt;code class=&quot;highlighter-rouge&quot;&gt;(#+Rb)&lt;/code&gt; but not until &lt;code class=&quot;highlighter-rouge&quot;&gt;(#+Rb)&lt;/code&gt; has been
“bit-reversed”.  That is, bit 0 of &lt;code class=&quot;highlighter-rouge&quot;&gt;(#+Rb)&lt;/code&gt; becomes bit 31 of &lt;code class=&quot;highlighter-rouge&quot;&gt;Ra&lt;/code&gt;,
bit 1 becomes bit 30, etc.&lt;/p&gt;

    &lt;p&gt;This instruction is very unique to the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;, and yet it is also very
fundamental to how the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; operates.  By using a &lt;strong&gt;BREV&lt;/strong&gt; instruction,
the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; can load any
18-bit value into the upper bits of a register.  If it is then followed by
a &lt;strong&gt;LDILO&lt;/strong&gt;, the pair of instructions can then load any 32-bit value into
a register.&lt;/p&gt;

    &lt;p&gt;The &lt;strong&gt;BREV&lt;/strong&gt; instruction is also very useful for bit-reversed addressing and
bit-manipulation functions–such as counting trailing zeros in a number.
It’s also used for the &lt;strong&gt;CLR&lt;/strong&gt; (clear register) derived instruction.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;LDILO&lt;/strong&gt;, or Load Immediate Lo, assigns the lower 16 bits of &lt;code class=&quot;highlighter-rouge&quot;&gt;Ra&lt;/code&gt; to the
lower 16 bits of &lt;code class=&quot;highlighter-rouge&quot;&gt;(#+Rb)&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;MPYUHI&lt;/strong&gt;, or multiply unsigned values and return the upper 32-bits, sets
&lt;code class=&quot;highlighter-rouge&quot;&gt;Ra&lt;/code&gt; to &lt;code class=&quot;highlighter-rouge&quot;&gt;(Ra*(#+Rb)) &amp;gt;&amp;gt;32&lt;/code&gt;.  The multiplication involved assumes both
&lt;code class=&quot;highlighter-rouge&quot;&gt;Ra&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;(#+Rb)&lt;/code&gt; are unsigned numbers.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;MPYSHI&lt;/strong&gt;, or multiply signed values and return the upper 32-bits, is
identical to &lt;code class=&quot;highlighter-rouge&quot;&gt;MPYUHI&lt;/code&gt;, with the exception that the multiplication is done
assuming both &lt;code class=&quot;highlighter-rouge&quot;&gt;Ra&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;(#+Rb)&lt;/code&gt; are signed numbers.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;MPY&lt;/strong&gt;, a 32x32-bit multiply which returns the lower bits of the result.
Basically, this is given by &lt;code class=&quot;highlighter-rouge&quot;&gt;Ra &amp;lt;= Ra * (#+Rb)&lt;/code&gt;, with the exception that
&lt;code class=&quot;highlighter-rouge&quot;&gt;Ra&lt;/code&gt; is set to the lower 32-bits of the product.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;DIVU&lt;/strong&gt;, a 32x32-bit unsigned divide.  &lt;code class=&quot;highlighter-rouge&quot;&gt;Ra &amp;lt;= Ra / (#+Rb)&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;DIVS&lt;/strong&gt;, a 32x32-bit signed divide. &lt;code class=&quot;highlighter-rouge&quot;&gt;Ra &amp;lt;= Ra / (#+Rb)&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;CMP&lt;/strong&gt;, Compare.  Sets the flags according to &lt;code class=&quot;highlighter-rouge&quot;&gt;Ra - (#+Rb)&lt;/code&gt;.  This
instruction is implemented identically to the &lt;strong&gt;SUB&lt;/strong&gt; instruction above,
save that &lt;em&gt;only&lt;/em&gt; the flags are affected by a &lt;strong&gt;CMP&lt;/strong&gt; instruction.  &lt;code class=&quot;highlighter-rouge&quot;&gt;Ra&lt;/code&gt;
is not written back to the register file.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;TEST&lt;/strong&gt;, is identical to the &lt;strong&gt;AND&lt;/strong&gt; instruction, save that like the &lt;strong&gt;CMP&lt;/strong&gt;
instruction, &lt;strong&gt;TEST&lt;/strong&gt; only sets the flags register and leaves &lt;code class=&quot;highlighter-rouge&quot;&gt;Ra&lt;/code&gt; untouched.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Two more basic instructions have subtly different forms.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;MOV&lt;/strong&gt;, a move instruction, &lt;code class=&quot;highlighter-rouge&quot;&gt;Ra &amp;lt;= (#+Rb)&lt;/code&gt;.  In this case, the move
instruction always has an &lt;code class=&quot;highlighter-rouge&quot;&gt;Rb&lt;/code&gt; register.  If you want to move just the
constant into a register, then use the &lt;strong&gt;LDI&lt;/strong&gt; instruction instead.&lt;/p&gt;

    &lt;p&gt;The &lt;strong&gt;MOV&lt;/strong&gt; instruction has the additional capability of moving values
between register sets–something we’ll need to get to later.  As a result,
the range of the immediate values supported by the move instruction (13-bits)
is not quite as many as those supported by the rest of the instructions
above (either 14-bits or 18-bits).&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;LDI&lt;/strong&gt;, or load immediate, has a little bit of a different form.  The
&lt;strong&gt;LDI&lt;/strong&gt; instruction has no &lt;code class=&quot;highlighter-rouge&quot;&gt;Rb&lt;/code&gt; register option.  It is used for loading
arbitrary values into &lt;code class=&quot;highlighter-rouge&quot;&gt;Ra&lt;/code&gt;, and written as &lt;code class=&quot;highlighter-rouge&quot;&gt;Ra &amp;lt;= #&lt;/code&gt;.&lt;/p&gt;

    &lt;p&gt;This instruction has
also been stripped to its bare essentials to be able to load the largest
value into a register as possible.  As a result, it can load any 23-bit
signed value into a register.  Anything more requires a combination of a
&lt;code class=&quot;highlighter-rouge&quot;&gt;BREV&lt;/code&gt; instruction and an &lt;code class=&quot;highlighter-rouge&quot;&gt;LDILO&lt;/code&gt; instruction.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The next six instructions are memory instructions.  These are written a little
differently, but they still read from left to right.  For example,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-asm&quot; data-lang=&quot;asm&quot;&gt;	SW.X Ra,#(Rb)&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;stores the value of &lt;code class=&quot;highlighter-rouge&quot;&gt;Ra&lt;/code&gt; into the address given by &lt;code class=&quot;highlighter-rouge&quot;&gt;#&lt;/code&gt; plus the &lt;code class=&quot;highlighter-rouge&quot;&gt;Rb&lt;/code&gt; register,
while&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-asm&quot; data-lang=&quot;asm&quot;&gt;	LW.X #(Rb),Ra&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;loads the value of &lt;code class=&quot;highlighter-rouge&quot;&gt;Ra&lt;/code&gt; based upon the contents of memory given by the address
in &lt;code class=&quot;highlighter-rouge&quot;&gt;Rb&lt;/code&gt; plus the offset, &lt;code class=&quot;highlighter-rouge&quot;&gt;#&lt;/code&gt;.  Both of these can be executed conditionally,
if the condition &lt;code class=&quot;highlighter-rouge&quot;&gt;X&lt;/code&gt; is true.  (More on that later.)&lt;/p&gt;

&lt;p&gt;Both of these instructions operate on a word, hence their mnemonic is
&lt;em&gt;store word&lt;/em&gt; or &lt;em&gt;load word&lt;/em&gt; respectively.  The &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; supports four other
memory instructions:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;LH&lt;/strong&gt; or load halfword.  This instruction loads a 16-bit value from memory
into &lt;code class=&quot;highlighter-rouge&quot;&gt;Ra&lt;/code&gt; and then clears the upper 16-bits to get the result to fit
into 32-bits.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;SH&lt;/strong&gt; or store halfword.  This instruction stores the bottom 16-bits of a
register into memory.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;LB&lt;/strong&gt; or load byte.  The upper 24-bits are cleared.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;SB&lt;/strong&gt; or store byte&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;These are all of the basic &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; instructions.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: left&quot;&gt;&lt;caption&gt;Fig 6: ZipCPU Instructions&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/zipcpu-insns-derived.png&quot; alt=&quot;(A chart of several of the ZipCPU&#39;s derived instructions)&quot; width=&quot;454&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;See anything missing?  If you are familiar with other
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;s,
you may notice &lt;em&gt;a lot&lt;/em&gt; of missing instructions.  None of these,
however, are truly required as combinations of the instructions
above can be used to implement almost any
instruction you might need.  For example, Fig 6 shows several examples of
instructions the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Assembly_language#Assembler&quot;&gt;assembler&lt;/a&gt;
understands, yet whose implementation is derived from the instructions above.&lt;/p&gt;

&lt;p&gt;Let’s back up a bit, though, and discuss the registers on the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;the-basic-zipcpu-register-set&quot;&gt;The Basic ZipCPU Register Set&lt;/h2&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 7: ZipCPU Register Set&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/zipcpu-registers.png&quot; alt=&quot;[ZipCPU](/about/zipcpu.html) registers: R0 (or LR), R1-R11, R12 (or FP), SP, CC, and PC.  There are two sets of these, one prefixed with u for user, the other prefixed with s for supervisor&quot; width=&quot;360&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;The &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; supports sixteen 32-bit registers in two sets, but
we’ll come back to issue of the different register sets later.  For now,
each set of sixteen registers is organized into registers &lt;code class=&quot;highlighter-rouge&quot;&gt;R0&lt;/code&gt;-&lt;code class=&quot;highlighter-rouge&quot;&gt;R15&lt;/code&gt;.  From
the hardware standpoint, all but the last two are general purpose, whereas
the compiler treats all but four of these registers as general purpose
registers.&lt;/p&gt;

&lt;p&gt;Of these sixteen registers, the hardware treats the last two as special purpose
registers.  &lt;code class=&quot;highlighter-rouge&quot;&gt;R15&lt;/code&gt; is the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Program_counter&quot;&gt;program counter&lt;/a&gt;,
or &lt;code class=&quot;highlighter-rouge&quot;&gt;PC&lt;/code&gt;.  This register maintains
the address of the next instruction the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; will execute within it.
&lt;code class=&quot;highlighter-rouge&quot;&gt;R14&lt;/code&gt; also has a special purpose–it is the &lt;a href=&quot;https://en.wikipedia.org/wiki/Status_register&quot;&gt;condition code and
status register&lt;/a&gt;,
or &lt;code class=&quot;highlighter-rouge&quot;&gt;CC&lt;/code&gt;.  Flags, such as whether or not the result of the last
operation was zero or not, are stored in the bottom four bits of the &lt;code class=&quot;highlighter-rouge&quot;&gt;CC&lt;/code&gt;
register.&lt;/p&gt;

&lt;p&gt;While the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; instruction set
doesn’t have any
&lt;a href=&quot;https://en.wikipedia.org/wiki/Branch_(computer_science)&quot;&gt;branch&lt;/a&gt;
instructions per se, three of the basic instructions above can be
applied to the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Program_counter&quot;&gt;program counter&lt;/a&gt;
in order to create
&lt;a href=&quot;https://en.wikipedia.org/wiki/Branch_(computer_science)&quot;&gt;branch&lt;/a&gt;
instructions.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;LDI #,PC&lt;/code&gt; loads a 23’bit signed immediate value into the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Program_counter&quot;&gt;program counter&lt;/a&gt;,
&lt;code class=&quot;highlighter-rouge&quot;&gt;PC&lt;/code&gt;.  It can be used any time the absolute address of the destination
is known by the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Assembly_language#Assembler&quot;&gt;assembler&lt;/a&gt;
before linking–which isn’t very often.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ADD #,PC&lt;/code&gt; adds an amount to the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Program_counter&quot;&gt;program counter&lt;/a&gt;,
&lt;code class=&quot;highlighter-rouge&quot;&gt;PC&lt;/code&gt;.  This will execute
a local &lt;a href=&quot;https://en.wikipedia.org/wiki/Branch_(computer_science)&quot;&gt;branch&lt;/a&gt;,
causing the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt;
to read its next instruction &lt;code class=&quot;highlighter-rouge&quot;&gt;#&lt;/code&gt; words
earlier or later depending on the sign of &lt;code class=&quot;highlighter-rouge&quot;&gt;#&lt;/code&gt;.  Since this is such a common
instruction, this is often abbreviated with by a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Branch_(computer_science)&quot;&gt;branch&lt;/a&gt;
always instruction, &lt;code class=&quot;highlighter-rouge&quot;&gt;BRA &amp;lt;address label&amp;gt;&lt;/code&gt;.&lt;/p&gt;

    &lt;p&gt;The &lt;code class=&quot;highlighter-rouge&quot;&gt;BRA&lt;/code&gt; instruction is often used for jumping between locations within a
given function–such as when executing a loop or an if.  It is used anytime
the &lt;a href=&quot;https://en.wikipedia.org/wiki/Assembly_language#Assembler&quot;&gt;assembler&lt;/a&gt;
can tell that the distance to the target will fit within 18-bits.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;LW (PC),PC&lt;/code&gt; followed by a new address, reads a new value of the program
counter from the next
word in instruction memory.  This instruction is used heavily by the linker,
since the next address in memory can later be simply set to any value once
that value is known.  This is also known as a &lt;em&gt;long jump&lt;/em&gt; instruction,
and so the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Assembly_language#Assembler&quot;&gt;assembler&lt;/a&gt;
understands the &lt;code class=&quot;highlighter-rouge&quot;&gt;LJMP &amp;lt;address label&amp;gt;&lt;/code&gt; mnemonic,
where &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;address label&amp;gt;&lt;/code&gt; is an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Assembly_language#Assembler&quot;&gt;assembly&lt;/a&gt;
label of where you wish to jump to.&lt;/p&gt;

    &lt;p&gt;When the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; is built with the
early &lt;a href=&quot;https://en.wikipedia.org/wiki/Branch_(computer_science)&quot;&gt;branching&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/cpudefs.v&quot;&gt;option&lt;/a&gt;, for
a cost of about 80 LUTs, and the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/pfcache.v&quot;&gt;prefetch with instruction
cache&lt;/a&gt;,
this instruction only costs three clock cycles.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/sw/gcc-zippatch.patch&quot;&gt;port&lt;/a&gt;
of &lt;a href=&quot;https://www.gcc.org&quot;&gt;GCC&lt;/a&gt;
treats &lt;code class=&quot;highlighter-rouge&quot;&gt;R0&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;R14&lt;/code&gt;, and (sometimes) &lt;code class=&quot;highlighter-rouge&quot;&gt;R13&lt;/code&gt; as special registers.
&lt;code class=&quot;highlighter-rouge&quot;&gt;R0&lt;/code&gt; is known as the link register, &lt;code class=&quot;highlighter-rouge&quot;&gt;LR&lt;/code&gt;, where the return address to a
subroutine is kept.  This leads to two other instructions:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;MOV 8(PC),R0&lt;/code&gt; followed by &lt;code class=&quot;highlighter-rouge&quot;&gt;LJMP &amp;lt;function&amp;gt;&lt;/code&gt; is how the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; implements
a long jump to subroutine command, &lt;strong&gt;LJSR&lt;/strong&gt;–a shorter jump can be
implemented with the &lt;code class=&quot;highlighter-rouge&quot;&gt;BRA&lt;/code&gt; instruction–but only if the destination is
known at
&lt;a href=&quot;https://en.wikipedia.org/wiki/Assembly_language#Assembler&quot;&gt;assembly&lt;/a&gt;
time to be in range.  The
&lt;a href=&quot;https://en.wikipedia.org/wiki/Assembly_language#Assembler&quot;&gt;assembler&lt;/a&gt;
handles all of the constants, and selects between the instruction forms
for you, so you may find these instruction pairs written in
&lt;a href=&quot;https://en.wikipedia.org/wiki/Assembly_language&quot;&gt;assembly&lt;/a&gt;
as either &lt;code class=&quot;highlighter-rouge&quot;&gt;JSR &amp;lt;function&amp;gt;&lt;/code&gt; or &lt;code class=&quot;highlighter-rouge&quot;&gt;LJSR &amp;lt;function&amp;gt;&lt;/code&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;MOV R0,PC&lt;/code&gt; loads the link register back into the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Program_counter&quot;&gt;program counter&lt;/a&gt;.  This
is often the last instruction in any function.  Indeed, it is so common
that the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Assembly_language#Assembler&quot;&gt;assembler&lt;/a&gt;
will also accept the &lt;strong&gt;RETN&lt;/strong&gt; mnemonic for this instruction.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The &lt;a href=&quot;https://www.gcc.org&quot;&gt;GCC&lt;/a&gt; &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/sw/gcc-zippatch.patch&quot;&gt;back
end&lt;/a&gt;
uses &lt;code class=&quot;highlighter-rouge&quot;&gt;R14&lt;/code&gt; as the &lt;a href=&quot;https://en.wikipedia.org/wiki/Stack_register&quot;&gt;stack
pointer&lt;/a&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;SP&lt;/code&gt;.  Hence, you
might see &lt;code class=&quot;highlighter-rouge&quot;&gt;SW R0,(SP)&lt;/code&gt; which will store &lt;code class=&quot;highlighter-rouge&quot;&gt;R0&lt;/code&gt; onto the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Call_stack&quot;&gt;stack&lt;/a&gt;.
If you choose not to optimize your code, and sometimes even if you do,
the compiler will use &lt;code class=&quot;highlighter-rouge&quot;&gt;R13&lt;/code&gt; as a frame pointer, &lt;code class=&quot;highlighter-rouge&quot;&gt;FP&lt;/code&gt;.  This register is
similar to the &lt;a href=&quot;https://en.wikipedia.org/wiki/Stack_register&quot;&gt;stack pointer&lt;/a&gt;,
and used to reference local variables within a function.  In
general, I’ve tried to keep the compiler from using &lt;code class=&quot;highlighter-rouge&quot;&gt;R13&lt;/code&gt; as a frame
pointer though–since it further limits the 14 general purpose registers.&lt;/p&gt;

&lt;p&gt;It’s for these reasons that, at the beginning of any function, you’ll often
see code looking like:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-asm&quot; data-lang=&quot;asm&quot;&gt;function_name:
	SUB 12,SP
	SW  R0,(SP)
	SW  R1,4(SP)
	; etc&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This allocates three words on the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Call_stack&quot;&gt;stack&lt;/a&gt;.
of four bytes each, and then uses the first two of them
to store &lt;code class=&quot;highlighter-rouge&quot;&gt;R0&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;R1&lt;/code&gt; respectively–presumably because the compiled routine
is going to clobber those registers and wants to use their values or restore
them later.&lt;/p&gt;

&lt;p&gt;You may then find, at the end that function, code that looks like,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-asm&quot; data-lang=&quot;asm&quot;&gt;	LW  (SP),R0
	LW  4(SP),R1
	ADD 12,SP
	RETN	; Implemented as MOV R0,PC&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This code loads the original values of &lt;code class=&quot;highlighter-rouge&quot;&gt;R0&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;R1&lt;/code&gt; back from the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Call_stack&quot;&gt;stack&lt;/a&gt;,
restores the &lt;a href=&quot;https://en.wikipedia.org/wiki/Stack_register&quot;&gt;stack pointer&lt;/a&gt;,
to its original value, and then finally returns
to the place where it was called from.&lt;/p&gt;

&lt;h2 id=&quot;conditions&quot;&gt;Conditions&lt;/h2&gt;

&lt;p&gt;When I introduced the form of the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; instructions above, I mentioned
that almost all instructions had the form &lt;code class=&quot;highlighter-rouge&quot;&gt;OP.X #+Rb,Ra&lt;/code&gt;.  We’ve examined
the various operations, &lt;code class=&quot;highlighter-rouge&quot;&gt;OP&lt;/code&gt;, and the various registers that &lt;code class=&quot;highlighter-rouge&quot;&gt;Ra&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;Rb&lt;/code&gt;
can take on, but we haven’t discussed the conditions, &lt;code class=&quot;highlighter-rouge&quot;&gt;X&lt;/code&gt;.
It is the condition &lt;code class=&quot;highlighter-rouge&quot;&gt;X&lt;/code&gt; that allows almost every
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
instruction to be executed &lt;em&gt;conditionally&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;The &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; supports 8 conditions,
or possibly values for the &lt;code class=&quot;highlighter-rouge&quot;&gt;X&lt;/code&gt;, as shown in Fig 8.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 8: ZipCPU Conditions&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/zipcpu-conditions.png&quot; alt=&quot;[ZipCPU](/about/zipcpu.html) supports eight conditions: (none), if zero, if less than, if greater than or equal, if overflow, and negations of these for all but overflow&quot; width=&quot;360&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;If no condition is specified with the instruction, then the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; will always perform the
indicated instruction.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Z&lt;/code&gt;, or the zero condition, will cause an instruction to only execute if
the &lt;code class=&quot;highlighter-rouge&quot;&gt;Z&lt;/code&gt; flag in the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Status_register&quot;&gt;condition codes&lt;/a&gt; is set.&lt;/p&gt;

    &lt;p&gt;If you are not familiar with
&lt;a href=&quot;https://en.wikipedia.org/wiki/Status_register&quot;&gt;condition codes&lt;/a&gt;,
the basic idea is that if the
result of the last instruction was a &lt;code class=&quot;highlighter-rouge&quot;&gt;Z&lt;/code&gt;ero, then the &lt;code class=&quot;highlighter-rouge&quot;&gt;Z&lt;/code&gt; bit will be set.
Hence, if you compare (i.e. subtract) two registers and the result is zero,
then you know the registers are equal and you can use the &lt;code class=&quot;highlighter-rouge&quot;&gt;Z&lt;/code&gt; bit to
do logic assuming the registers were equal.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;LT&lt;/code&gt;, the less than condition, will cause an instruction to execute &lt;em&gt;only&lt;/em&gt;
if the result of the last instruction was less than zero.  This is a
signed comparison result, focusing on the &lt;code class=&quot;highlighter-rouge&quot;&gt;N&lt;/code&gt;egative bit in the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Status_register&quot;&gt;condition codes&lt;/a&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;C&lt;/code&gt;, will cause an instruction to execute only if the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Status_register&quot;&gt;carry bit&lt;/a&gt;
is set.&lt;/p&gt;

    &lt;p&gt;This is also how the &lt;a href=&quot;https://www.gcc.org&quot;&gt;compiler&lt;/a&gt;
implements an &lt;em&gt;unsigned less than&lt;/em&gt; condition.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;V&lt;/code&gt;, will cause an instruction to execute only if the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Status_register&quot;&gt;o&lt;code class=&quot;highlighter-rouge&quot;&gt;V&lt;/code&gt;erflow bit&lt;/a&gt;
is set.  The &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/sw/gcc-zippatch.patch&quot;&gt;port&lt;/a&gt;
of &lt;a href=&quot;https://www.gcc.org&quot;&gt;GCC&lt;/a&gt; doesn’t yet use this
&lt;a href=&quot;https://en.wikipedia.org/wiki/Status_register&quot;&gt;flag&lt;/a&gt;,
but it may do so in the future.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The last three
&lt;a href=&quot;https://en.wikipedia.org/wiki/Status_register&quot;&gt;flags&lt;/a&gt;
are just negations of the earlier
&lt;a href=&quot;https://en.wikipedia.org/wiki/Status_register&quot;&gt;flags&lt;/a&gt;.
There’s &lt;code class=&quot;highlighter-rouge&quot;&gt;NZ&lt;/code&gt;, or not zero, &lt;code class=&quot;highlighter-rouge&quot;&gt;GE&lt;/code&gt;, or greater than or equal to, and there’s
&lt;code class=&quot;highlighter-rouge&quot;&gt;NC&lt;/code&gt; to test if the carry bit is not set (i.e., unsigned greater than or
equal to).&lt;/p&gt;

&lt;p&gt;The most common use of these conditions is in
&lt;a href=&quot;https://en.wikipedia.org/wiki/Branch_(computer_science)&quot;&gt;branching&lt;/a&gt;
operators.  For
example, &lt;code class=&quot;highlighter-rouge&quot;&gt;ADD.Z #,PC&lt;/code&gt; will cause the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt;
to jump &lt;em&gt;only&lt;/em&gt; if the &lt;code class=&quot;highlighter-rouge&quot;&gt;Z&lt;/code&gt;ero bit is set.  Since this is also a
very common operation, the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Assembly_language#Assembler&quot;&gt;assembler&lt;/a&gt;
understands seven
&lt;a href=&quot;https://en.wikipedia.org/wiki/Branch_(computer_science)&quot;&gt;branch&lt;/a&gt;
instruction implementing &lt;code class=&quot;highlighter-rouge&quot;&gt;ADD.X&lt;/code&gt;: &lt;code class=&quot;highlighter-rouge&quot;&gt;BZ&lt;/code&gt;
(&lt;a href=&quot;https://en.wikipedia.org/wiki/Branch_(computer_science)&quot;&gt;branch&lt;/a&gt;
if zero), &lt;code class=&quot;highlighter-rouge&quot;&gt;BNZ&lt;/code&gt;
(&lt;a href=&quot;https://en.wikipedia.org/wiki/Branch_(computer_science)&quot;&gt;branch&lt;/a&gt;
if not zero), &lt;code class=&quot;highlighter-rouge&quot;&gt;BLT&lt;/code&gt;
(&lt;a href=&quot;https://en.wikipedia.org/wiki/Branch_(computer_science)&quot;&gt;branch&lt;/a&gt;
if less than), &lt;code class=&quot;highlighter-rouge&quot;&gt;BGE&lt;/code&gt;
(&lt;a href=&quot;https://en.wikipedia.org/wiki/Branch_(computer_science)&quot;&gt;branch&lt;/a&gt;
if greater than or equal), &lt;code class=&quot;highlighter-rouge&quot;&gt;BC&lt;/code&gt;
(&lt;a href=&quot;https://en.wikipedia.org/wiki/Branch_(computer_science)&quot;&gt;branch&lt;/a&gt;
if carry is set), &lt;code class=&quot;highlighter-rouge&quot;&gt;BNC&lt;/code&gt;
(&lt;a href=&quot;https://en.wikipedia.org/wiki/Branch_(computer_science)&quot;&gt;branch&lt;/a&gt;
if carry is not set), and finally &lt;code class=&quot;highlighter-rouge&quot;&gt;BV&lt;/code&gt;
(&lt;a href=&quot;https://en.wikipedia.org/wiki/Branch_(computer_science)&quot;&gt;branch&lt;/a&gt;
on overflow).&lt;/p&gt;

&lt;p&gt;You can also use these conditions to test multiple things at once.  For
example, suppose you wanted to know if registers &lt;code class=&quot;highlighter-rouge&quot;&gt;R0&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;R1&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;R2&lt;/code&gt;, &lt;em&gt;and&lt;/em&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;R3&lt;/code&gt; were all zero, and you wish to
&lt;a href=&quot;https://en.wikipedia.org/wiki/Branch_(computer_science)&quot;&gt;branch&lt;/a&gt;
to some target if they are all zero.  In this case, you might write:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-asm&quot; data-lang=&quot;asm&quot;&gt;	CMP 0,R0
	CMP.Z 0,R1
	CMP.Z 0,R2
	CMP.Z 0,R3
	BZ all_zero&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;You could also do a test of whether or not just one of them was zero,
such as:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-asm&quot; data-lang=&quot;asm&quot;&gt;	CMP 0,R0
	CMP.NZ 0,R1
	CMP.NZ 0,R2
	CMP.NZ 0,R3
	BNZ one_of_these_is_nonzero&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;These work because the &lt;code class=&quot;highlighter-rouge&quot;&gt;CMP&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;TST&lt;/code&gt; instructions &lt;em&gt;always&lt;/em&gt; set the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Status_register&quot;&gt;condition codes&lt;/a&gt;–even
when executed conditionally.  Other instructions,
when executed conditionally, don’t affect the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Status_register&quot;&gt;condition codes&lt;/a&gt;–allowing
strings of conditional instructions to all depend upon the same condition.&lt;/p&gt;

&lt;p&gt;A good example of multiple instructions depending upon a single condition
would be an integer absolute value calculation.
Suppose you wanted to calculate the absolute value of &lt;code class=&quot;highlighter-rouge&quot;&gt;R0&lt;/code&gt; and leave the
result in &lt;code class=&quot;highlighter-rouge&quot;&gt;R0&lt;/code&gt;.  You might then write,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-asm&quot; data-lang=&quot;asm&quot;&gt;	TEST R0
	XOR.LT -1,R0
	ADD.LT 1,R0&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The first instruction &lt;code class=&quot;highlighter-rouge&quot;&gt;AND&lt;/code&gt;’s &lt;code class=&quot;highlighter-rouge&quot;&gt;R0&lt;/code&gt; with &lt;code class=&quot;highlighter-rouge&quot;&gt;-1&lt;/code&gt;–the default value if no other
value is given to &lt;code class=&quot;highlighter-rouge&quot;&gt;TEST&lt;/code&gt;.  Since this is a &lt;code class=&quot;highlighter-rouge&quot;&gt;TEST&lt;/code&gt; instruction, &lt;code class=&quot;highlighter-rouge&quot;&gt;R0&lt;/code&gt; is
left unchanged and only the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Status_register&quot;&gt;flags&lt;/a&gt; are affected.
In this case, the &lt;code class=&quot;highlighter-rouge&quot;&gt;N&lt;/code&gt; flag will be set if &lt;code class=&quot;highlighter-rouge&quot;&gt;R0&lt;/code&gt; is negative.  We can then
complement every bit and add one to &lt;code class=&quot;highlighter-rouge&quot;&gt;R0&lt;/code&gt; to negate it.
Notice how, in this process, the &lt;code class=&quot;highlighter-rouge&quot;&gt;XOR&lt;/code&gt; instruction didn’t affect the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Status_register&quot;&gt;flags&lt;/a&gt;, making it possible
to string the &lt;code class=&quot;highlighter-rouge&quot;&gt;ADD&lt;/code&gt; function to this chain as well–all operating only if
&lt;code class=&quot;highlighter-rouge&quot;&gt;R0&lt;/code&gt; was negative.&lt;/p&gt;

&lt;p&gt;Why are conditional instructions a good thing?  There is a real method and
purpose to this madness.  Conditional
&lt;a href=&quot;https://en.wikipedia.org/wiki/Branch_(computer_science)&quot;&gt;branches&lt;/a&gt;
on the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
cost about 5-clocks, whereas conditionally executed
&lt;a href=&quot;/zipcpu/2017/08/11/simple-alu.html&quot;&gt;ALU&lt;/a&gt;
instructions still cost only one clock.  Hence, the absolute value calculation
above costs 3-clocks (ignoring
&lt;a href=&quot;/zipcpu/2017/11/18/wb-prefetch.html&quot;&gt;prefetch&lt;/a&gt;
stalls), whereas the alternative&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;	&lt;span class=&quot;n&quot;&gt;TEST&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;R0&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;BGE&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;dont_negate&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;XOR&lt;/span&gt;	&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;R0&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;ADD&lt;/span&gt;	&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;R0&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;dont_negate&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;would cost four clocks if &lt;code class=&quot;highlighter-rouge&quot;&gt;R0&lt;/code&gt; needed to be negated, and six clocks if it
didn’t.  This is in comparison to the three clocks for both conditions
presented above.&lt;/p&gt;

&lt;p&gt;You may notice that for all of the extra functionality in this section and
the last, the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; still only offers the same basic 25-instructions.
&lt;a href=&quot;https://en.wikipedia.org/wiki/Branch_(computer_science)&quot;&gt;Branches&lt;/a&gt;,
jumps, and subroutine calls are just special cases of these same
instructions.&lt;/p&gt;

&lt;p&gt;There are also some subtle details here as well.  For example, some
instructions aren’t allowed to set the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Status_register&quot;&gt;condition codes&lt;/a&gt;.
These include &lt;code class=&quot;highlighter-rouge&quot;&gt;MOV&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;BREV&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;LDILO&lt;/code&gt; instructions and anything that
writes to the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Program_counter&quot;&gt;program counter&lt;/a&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;PC&lt;/code&gt; or the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Status_register&quot;&gt;condition code register&lt;/a&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;CC&lt;/code&gt;.
In a similar fashion, any conditionally executed instruction, with the
exception of &lt;code class=&quot;highlighter-rouge&quot;&gt;CMP&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;TEST&lt;/code&gt;, will not affect thew
&lt;a href=&quot;https://en.wikipedia.org/wiki/Status_register&quot;&gt;condition codes&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Well, not quite.  The &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; does
have four more &lt;em&gt;special&lt;/em&gt; instructions that we need to discuss in the next
section.&lt;/p&gt;

&lt;h2 id=&quot;special-instructions&quot;&gt;Special Instructions&lt;/h2&gt;

&lt;p&gt;The &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; also supports four special
instructions: &lt;code class=&quot;highlighter-rouge&quot;&gt;BREAK&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;LOCK&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;SIM&lt;/code&gt;, and &lt;code class=&quot;highlighter-rouge&quot;&gt;NOOP&lt;/code&gt;.&lt;br /&gt;
Other special instructions, such as &lt;code class=&quot;highlighter-rouge&quot;&gt;RTU&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;STEP&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;WAIT&lt;/code&gt;, or &lt;code class=&quot;highlighter-rouge&quot;&gt;HALT&lt;/code&gt;, are
derived instructions from the basic instructions listed above.  We’ll
come back to the &lt;code class=&quot;highlighter-rouge&quot;&gt;RTU&lt;/code&gt; instruction in the next section when we discuss
the purpose for the two separate register sets.&lt;/p&gt;

&lt;p&gt;The &lt;code class=&quot;highlighter-rouge&quot;&gt;BREAK&lt;/code&gt; instruction was built for the
&lt;a href=&quot;/zipcpu/2017/08/25/hw-debugging.html&quot;&gt;debugger&lt;/a&gt;.
By replacing any instruction with a &lt;code class=&quot;highlighter-rouge&quot;&gt;BREAK&lt;/code&gt; instruction, the currently
running code will halt at that instruction–without executing it.  This will
leave the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt;
in a state where the debugger can then examine what’s going on within it,
single step over the break, and then continue until the next break.&lt;/p&gt;

&lt;p&gt;The &lt;code class=&quot;highlighter-rouge&quot;&gt;LOCK&lt;/code&gt; instruction is used to support
&lt;a href=&quot;https://en.wikipedia.org/wiki/Linearizability&quot;&gt;atomic&lt;/a&gt; accesses.
&lt;a href=&quot;https://en.wikipedia.org/wiki/Linearizability&quot;&gt;Atomic&lt;/a&gt;
instructions are ones where you want to read something from the bus, operate
upon it, and then return the modified value.  For example, an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Linearizability&quot;&gt;atomic&lt;/a&gt;
increment might look like,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-asm&quot; data-lang=&quot;asm&quot;&gt;	LOCK
	LW	(R0),R1
	ADD	1,R1
	SW	R1,(R0)&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The &lt;code class=&quot;highlighter-rouge&quot;&gt;LOCK&lt;/code&gt; function works by disabling
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interrupt&quot;&gt;interrupts&lt;/a&gt;
and then making sure that
the &lt;a href=&quot;/doc/wbspec_b4.pdf&quot;&gt;wishbone&lt;/a&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;CYC&lt;/code&gt; line is not
lowered between the &lt;code class=&quot;highlighter-rouge&quot;&gt;LW&lt;/code&gt; (load word) and &lt;code class=&quot;highlighter-rouge&quot;&gt;SW&lt;/code&gt; (store word) instructions.
After three instructions, the number shown above, the lock is released.&lt;/p&gt;

&lt;p&gt;The &lt;code class=&quot;highlighter-rouge&quot;&gt;NOOP&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;SIM&lt;/code&gt; instructions are very similar, although they look
different on the surface.  &lt;code class=&quot;highlighter-rouge&quot;&gt;NOOP&lt;/code&gt; is a simple
no-operation instruction–an instruction that doesn’t do anything.  When the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; encounters a &lt;code class=&quot;highlighter-rouge&quot;&gt;NOOP&lt;/code&gt; instruction,
it does nothing.  When the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
encounters a &lt;code class=&quot;highlighter-rouge&quot;&gt;SIM&lt;/code&gt; instruction, while running in hardware, the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; halts with an illegal
instruction exception.&lt;/p&gt;

&lt;p&gt;These two instructions have some other capabilities when used within the
simulator: they can be used to send values to the simulation terminal via
either &lt;code class=&quot;highlighter-rouge&quot;&gt;SOUT&lt;/code&gt; (a SIM) or &lt;code class=&quot;highlighter-rouge&quot;&gt;NOUT&lt;/code&gt; (a NOOP).
For example, you can print either a single character to the terminal,
&lt;code class=&quot;highlighter-rouge&quot;&gt;NOUT &#39;c&#39;&lt;/code&gt;, a register’s value, &lt;code class=&quot;highlighter-rouge&quot;&gt;NDUMP R0&lt;/code&gt;, or even the full register bank to
the terminal, &lt;code class=&quot;highlighter-rouge&quot;&gt;NDUMP&lt;/code&gt;, using the
lower bits of these commands.  The
&lt;a href=&quot;https://en.wikipedia.org/wiki/Assembly_language#Assembler&quot;&gt;assembler&lt;/a&gt;
also understands mnemonics allowing you to string together multiple
characters into a single
&lt;a href=&quot;https://en.wikipedia.org/wiki/Assembly_language&quot;&gt;assembly&lt;/a&gt;
command, either &lt;code class=&quot;highlighter-rouge&quot;&gt;NSTR&lt;/code&gt; or &lt;code class=&quot;highlighter-rouge&quot;&gt;SSTR&lt;/code&gt;, to print to the terminal.&lt;/p&gt;

&lt;p&gt;In the case of the &lt;code class=&quot;highlighter-rouge&quot;&gt;NOOP&lt;/code&gt; instructions, once placed onto the actual hardware
these simulation only capabilities will be quietly ignored.&lt;/p&gt;

&lt;h2 id=&quot;interrupts&quot;&gt;Interrupts&lt;/h2&gt;

&lt;p&gt;Let’s now come back to those two register sets, since they are used to
help the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; handle
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interrupt&quot;&gt;interrupts&lt;/a&gt;.
Indeed, the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; has a fairly
unique &lt;a href=&quot;https://en.wikipedia.org/wiki/Interrupt&quot;&gt;interrupt&lt;/a&gt;
architecture.  For example, the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
only recognizes one type of
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interrupt&quot;&gt;interrupt&lt;/a&gt;.
When the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
recognizes an &lt;a href=&quot;https://en.wikipedia.org/wiki/Interrupt&quot;&gt;interrupt&lt;/a&gt;,
the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; just switches from user
to supervisor register sets.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 9: ZipCPU Operating Modes&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/zipcpu-modes.svg&quot; alt=&quot;Reset -&amp;gt; [ supervisor -&amp;gt; user ]*&quot; width=&quot;360&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Basically, it works like this: upon any reboot, the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; boots into
&lt;em&gt;supervisor&lt;/em&gt; mode.  This mode uses one set of sixteen registers—the
supervisor set.  When the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
is ready to enable &lt;a href=&quot;https://en.wikipedia.org/wiki/Interrupt&quot;&gt;interrupt&lt;/a&gt;s,
it switches to &lt;em&gt;user&lt;/em&gt; mode where the other set of registers are used—the
user set.  Then, on any
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interrupt&quot;&gt;interrupt&lt;/a&gt;, user trap,
or &lt;a href=&quot;https://en.wikipedia.org/wiki/Trap_(computing)&quot;&gt;processing exception&lt;/a&gt;,
the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
returns to supervisor mode.&lt;/p&gt;

&lt;p&gt;To make this possible, the &lt;code class=&quot;highlighter-rouge&quot;&gt;MOV&lt;/code&gt; instruction has been given a special
capability.  It can be used to &lt;code class=&quot;highlighter-rouge&quot;&gt;MOV&lt;/code&gt; registers between the two register
sets–but only when the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
is in supervisor mode.&lt;/p&gt;

&lt;p&gt;This means that
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interrupt&quot;&gt;interrupts&lt;/a&gt;
for the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; are handled
differently from other processors as well, and so programming the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
is a little different for that reason as well.&lt;/p&gt;

&lt;p&gt;For example, on most processors, an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interrupt&quot;&gt;interrupt&lt;/a&gt;
will:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Automatically place a couple of user registers
(the &lt;a href=&quot;https://en.wikipedia.org/wiki/Program_counter&quot;&gt;program counter&lt;/a&gt;,
&lt;a href=&quot;https://en.wikipedia.org/wiki/Stack_register&quot;&gt;stack pointer&lt;/a&gt;,
etc.) into a special place.  This may either be onto the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Call_stack&quot;&gt;stack&lt;/a&gt;,
in older &lt;a href=&quot;https://en.wikipedia.org/wiki/Instruction_set_architecture&quot;&gt;ISA&lt;/a&gt;s,
or in a couple of special purpose registers–as on more recent
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;s.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The address of an &lt;a href=&quot;https://en.wikipedia.org/wiki/Interrupt_handler&quot;&gt;interrupt service routine
(ISR)&lt;/a&gt;
is then loaded from an &lt;a href=&quot;https://en.wikipedia.org/wiki/Interrupt_vector_table&quot;&gt;interrupt
table&lt;/a&gt;, and the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;
jumps to this address.&lt;/p&gt;

    &lt;p&gt;This &lt;a href=&quot;https://en.wikipedia.org/wiki/Interrupt_vector_table&quot;&gt;table&lt;/a&gt;
needs to be carefully set by a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Microcontroller&quot;&gt;microcontroller&lt;/a&gt;,
often in a special memory location or special purpose register.  Any
mistake in this process and the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;
will try to execute instructions from a non-existent memory address.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;An &lt;a href=&quot;https://en.wikipedia.org/wiki/Interrupt_handler&quot;&gt;interrupt service
routine&lt;/a&gt; then runs to
“handle” the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interrupt&quot;&gt;interrupt&lt;/a&gt;.&lt;/p&gt;

    &lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Interrupt_handler&quot;&gt;These routines&lt;/a&gt;
are often built with very special rules.  This often
forces these routines to be built in
&lt;a href=&quot;https://en.wikipedia.org/wiki/Assembly_language&quot;&gt;assembly&lt;/a&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;A special instruction such as an IRET instruction (interrupt return) is
issued at the end of the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interrupt_handler&quot;&gt;ISR&lt;/a&gt;
to return to the previously running program.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;This is not how
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interrupt&quot;&gt;interrupts&lt;/a&gt;
work on the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;, nor does it
reflect how the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; is programmed.&lt;/p&gt;

&lt;p&gt;As shown above in Fig 9, the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
starts its processing in supervisor mode.  Before the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt;
can switch to user mode, it creates a set of registers for
user mode.  These are either loaded via
the &lt;a href=&quot;https://en.wikipedia.org/wiki/Assembly_language&quot;&gt;assembly&lt;/a&gt;.
&lt;code class=&quot;highlighter-rouge&quot;&gt;MOV&lt;/code&gt; instructions, or by the &lt;code class=&quot;highlighter-rouge&quot;&gt;zip_restore_context(int *)&lt;/code&gt; C-language
built-in.  This latter function call loads and sets all of the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; registers from a memory array.
It can then switch to user mode via an &lt;code class=&quot;highlighter-rouge&quot;&gt;RTU&lt;/code&gt; instruction.  The &lt;code class=&quot;highlighter-rouge&quot;&gt;RTU&lt;/code&gt;
instruction itself is implemented by an &lt;code class=&quot;highlighter-rouge&quot;&gt;OR&lt;/code&gt; instruction that just sets the
global &lt;a href=&quot;https://en.wikipedia.org/wiki/Interrupt&quot;&gt;interrupt&lt;/a&gt;
enable (&lt;code class=&quot;highlighter-rouge&quot;&gt;GIE&lt;/code&gt;) bit in the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Status_register&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;CC&lt;/code&gt; register&lt;/a&gt;.
A C-language built-in, &lt;code class=&quot;highlighter-rouge&quot;&gt;zip_rtu()&lt;/code&gt;, can also be used to execute this jump
from C.&lt;/p&gt;

&lt;p&gt;Once the &lt;code class=&quot;highlighter-rouge&quot;&gt;RTU&lt;/code&gt; instruction is issued, the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; starts executing instructions
using the user register set.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;If an &lt;a href=&quot;https://en.wikipedia.org/wiki/Interrupt&quot;&gt;interrupt&lt;/a&gt;
takes place while the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; is
in user mode, it will automatically switch back to supervisor mode.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;If an &lt;a href=&quot;https://en.wikipedia.org/wiki/Interrupt&quot;&gt;interrupt&lt;/a&gt;
is pending in supervisor mode, the &lt;code class=&quot;highlighter-rouge&quot;&gt;RTU&lt;/code&gt; instruction will have no effect
and will leave the 
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
in supervisor mode.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;If the user program needs to return to supervisor mode, it can can clear
the &lt;code class=&quot;highlighter-rouge&quot;&gt;GIE&lt;/code&gt; bit with either an &lt;code class=&quot;highlighter-rouge&quot;&gt;AND&lt;/code&gt; or an &lt;code class=&quot;highlighter-rouge&quot;&gt;LDI&lt;/code&gt; instruction.  This will send
the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; back into supervisor mode
as well.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Other program errors, such as
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_error&quot;&gt;bus errors&lt;/a&gt;, illegal
instructions, division by zero exceptions, etc.,  encountered in user
mode will also return the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
to supervisor mode.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The special &lt;code class=&quot;highlighter-rouge&quot;&gt;WAIT&lt;/code&gt; instruction will cause the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
to enter into user mode (if it isn’t in user mode already), but then
sleep until the next interrupt.  This instruction is also implemented
via a basic &lt;code class=&quot;highlighter-rouge&quot;&gt;OR&lt;/code&gt; instruction.  The &lt;code class=&quot;highlighter-rouge&quot;&gt;HALT&lt;/code&gt; instruction acts in an identical
fashion when executed in user mode.  When executed in supervisor mode it
will actually &lt;code class=&quot;highlighter-rouge&quot;&gt;HALT&lt;/code&gt; the CPU.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Once the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
returns from user mode, it will return to the supervisor
code where it left off.  You can see this in the multi-tasking code
found in the &lt;a href=&quot;https://github.com/ZipCPU/s6soc&quot;&gt;S6Soc&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/s6soc/blob/master/sw/zipos/kernel.c&quot;&gt;kernel&lt;/a&gt;
software.  From a high level, that code looks like:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;kernel_entry&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;// ...
&lt;/span&gt;	&lt;span class=&quot;c1&quot;&gt;// Set up a series of user tasks, and initialize their registers.
&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;tasklist&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ksetup&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;

	&lt;span class=&quot;c1&quot;&gt;// Pick a current task, and load its registers into the user
&lt;/span&gt;	&lt;span class=&quot;c1&quot;&gt;// register set
&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;current&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tasklist&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;restore_context&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;current&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

	&lt;span class=&quot;c1&quot;&gt;// Enable interrupts ...
&lt;/span&gt;	&lt;span class=&quot;c1&quot;&gt;// ...
&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;do&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;c1&quot;&gt;// ....
&lt;/span&gt;		&lt;span class=&quot;n&quot;&gt;SET_WATCHDOG&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;zip_rtu&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;

		&lt;span class=&quot;c1&quot;&gt;// Get interrupt information
&lt;/span&gt;		&lt;span class=&quot;n&quot;&gt;pic&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_sys&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;io_pic&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pix&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x8000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
			&lt;span class=&quot;c1&quot;&gt;// We came here because of an interrupt
&lt;/span&gt;			&lt;span class=&quot;c1&quot;&gt;// ...
&lt;/span&gt;			&lt;span class=&quot;c1&quot;&gt;// Handle any interrupts
&lt;/span&gt;			&lt;span class=&quot;c1&quot;&gt;// ...
&lt;/span&gt;		&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

		&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;zip_ucc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CC_TRAPBIT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
			&lt;span class=&quot;c1&quot;&gt;// The user program has made a system call
&lt;/span&gt;			&lt;span class=&quot;c1&quot;&gt;// ...
&lt;/span&gt;			&lt;span class=&quot;c1&quot;&gt;// Handle any system calls
&lt;/span&gt;			&lt;span class=&quot;c1&quot;&gt;// ...
&lt;/span&gt;		&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;zip_ucc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CC_EXCEPTION&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
			&lt;span class=&quot;c1&quot;&gt;// The user task encountered an exception
&lt;/span&gt;			&lt;span class=&quot;c1&quot;&gt;// ...
&lt;/span&gt;			&lt;span class=&quot;c1&quot;&gt;// Deal with any user exceptions
&lt;/span&gt;			&lt;span class=&quot;c1&quot;&gt;// ...
&lt;/span&gt;		&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

		&lt;span class=&quot;c1&quot;&gt;// Check if we need to switch tasks
&lt;/span&gt;		&lt;span class=&quot;c1&quot;&gt;// ...
&lt;/span&gt;		&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;current&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;context&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;last_context&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
			&lt;span class=&quot;c1&quot;&gt;// If so, swap contexts
&lt;/span&gt;			&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;context_has_been_saved&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
				&lt;span class=&quot;n&quot;&gt;save_context&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;last_context&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;restore_context&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;current&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
		&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Wow!  Did you catch that?  That’s the core code of a multi-tasking
&lt;a href=&quot;https://en.wikipedia.org/wiki/Operating_System&quot;&gt;operating system&lt;/a&gt;!
Not only that, it was all written in C–no
&lt;a href=&quot;https://en.wikipedia.org/wiki/Assembly_language&quot;&gt;assembly&lt;/a&gt;
instructions were required in the task swapping code above.&lt;/p&gt;

&lt;p&gt;Did you notice where the return to userspace &lt;code class=&quot;highlighter-rouge&quot;&gt;RTU&lt;/code&gt; instruction was?  That
was the &lt;code class=&quot;highlighter-rouge&quot;&gt;zip_rtu()&lt;/code&gt; instruction.  Between when this instruction is issued
and when it returns, any user space program might run.&lt;/p&gt;

&lt;p&gt;How about &lt;a href=&quot;https://en.wikipedia.org/wiki/Interrupt&quot;&gt;interrupts&lt;/a&gt;?
Did you notice where the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interrupt&quot;&gt;interrupts&lt;/a&gt;
were handled?
&lt;code class=&quot;highlighter-rouge&quot;&gt;pic = _sys-&amp;gt;io_pic&lt;/code&gt; grabbed the current state of the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/icontrol.v&quot;&gt;interrupt controller&lt;/a&gt;
(an external module), which could then be queried to see if the reason for
&lt;code class=&quot;highlighter-rouge&quot;&gt;zip_rtu()&lt;/code&gt; returning was because of an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interrupt&quot;&gt;interrupt&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Indeed, once I realized how easy it was to swap between different tasks
in a multi-task concept, I found myself personally rather excited by the
possibilities that the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
offered for studying
&lt;a href=&quot;https://en.wikipedia.org/wiki/Operating_System&quot;&gt;Operating System&lt;/a&gt;
fundamentals from C.&lt;/p&gt;

&lt;p&gt;Now, if I could just get enough time to finish integrating the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/zipmmu.v&quot;&gt;MMU&lt;/a&gt;,
I might manage to even run a full
&lt;a href=&quot;https://en.wikipedia.org/wiki/Operating_System&quot;&gt;O/S&lt;/a&gt;
on the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;.
&lt;a href=&quot;https://en.wikipedia.org/wiki/Linux&quot;&gt;Linux&lt;/a&gt;
anyone?&lt;/p&gt;

&lt;h2 id=&quot;differences-between-other-cpus&quot;&gt;Differences between other CPU’s&lt;/h2&gt;

&lt;p&gt;Okay, so that’s what the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; instruction set looks like.  But how does
it compare to other
&lt;a href=&quot;https://en.wikipedia.org/wiki/Soft_microprocessor&quot;&gt;soft processors&lt;/a&gt;?
In particular, the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
instruction set could easily be compared to many other
&lt;a href=&quot;https://en.wikipedia.org/wiki/Soft_microprocessor&quot;&gt;soft-core CPU&lt;/a&gt;s,
such as the &lt;a href=&quot;http://www.latticesemi.com/~/media/LatticeSemi/Documents/UserManuals/JL/LatticeMico32ProcessorReferenceManual37.pdf&quot;&gt;lm32 processor&lt;/a&gt;,
&lt;a href=&quot;https://raw.githubusercontent.com/openrisc/doc/master/archive/openrisc_arch.pdf&quot;&gt;OpenRISC&lt;/a&gt;,
&lt;a href=&quot;https://www.altera.com/literature/hb/nios2/n2cpu_nii5v1.pdf&quot;&gt;NiosII&lt;/a&gt;,
and &lt;a href=&quot;https://www.xilinx.com/support/documentation/sw_manuals/mb_ref_guide.pdf&quot;&gt;MicroBlaze&lt;/a&gt;.
Let’s take a look at some of the key differences between the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
and some of these other processors.&lt;/p&gt;

&lt;p&gt;The first big difference is that the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; does not support three operand
instructions.  An example of such an instruction might be to set register
&lt;code class=&quot;highlighter-rouge&quot;&gt;Rd&lt;/code&gt; to the sum of &lt;code class=&quot;highlighter-rouge&quot;&gt;Ra&lt;/code&gt; plus &lt;code class=&quot;highlighter-rouge&quot;&gt;Rb&lt;/code&gt;, or &lt;code class=&quot;highlighter-rouge&quot;&gt;ADD Rd,Ra,Rb&lt;/code&gt;.  Did you notice how
this instruction read right to left?  This is common with other instruction
sets as well.&lt;/p&gt;

&lt;p&gt;Why doesn’t the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; offer three operand instructions?  Simply because
it would complicate the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/idecode.v&quot;&gt;instruction
decode&lt;/a&gt;
logic.
In particular, you’d need to decode more than just the four basic instruction
formats above.  Most of these processors, for example, have instructions that
take zero operands, instructions that take one operand and an immediate
(&lt;code class=&quot;highlighter-rouge&quot;&gt;LDI&lt;/code&gt;), instructions that take two registers and an immediate, and
instructions that take three registers and then have barely any room
for any immediate values (11’bits).&lt;/p&gt;

&lt;p&gt;The next thing you’ll notice is that the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; has a 5-bit opcode
to select among the various instructions.  These other processors use a
6-bit opcode, and when that isn’t enough they steal bits (as in the case
of the &lt;a href=&quot;https://www.xilinx.com/support/documentation/sw_manuals/mb_ref_guide.pdf&quot;&gt;MicroBlaze&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;)
from their immediate space.  The resulting reality is that
the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; actually has a more
&lt;a href=&quot;https://en.wikipedia.org/wiki/Reduced_instruction_set_computer&quot;&gt;&lt;em&gt;Reduced&lt;/em&gt; instruction set&lt;/a&gt;
than these other processors.&lt;/p&gt;

&lt;p&gt;When it comes to special registers, the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; is actually very unique.
In contrast to
&lt;a href=&quot;https://www.xilinx.com/support/documentation/sw_manuals/mb_ref_guide.pdf&quot;&gt;MicroBlaze&lt;/a&gt;’s
25 special registers, or the 65+ special registers of either
&lt;a href=&quot;https://openrisc.io&quot;&gt;OpenRISC&lt;/a&gt; or
&lt;a href=&quot;https://riscv.org&quot;&gt;RISC-V&lt;/a&gt;,
the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; has only two special
hardware registers–the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Program_counter&quot;&gt;program counter&lt;/a&gt;
and the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Status_register&quot;&gt;condition codes register&lt;/a&gt;.
Other functionality, such as the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/icontrol.v&quot;&gt;interrupt controller&lt;/a&gt;,
or even the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/wbdmac.v&quot;&gt;direct memory access (DMA) engine&lt;/a&gt;’s
control registers, are placed on an &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/zipsystem.v&quot;&gt;external bus
near&lt;/a&gt;
the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;,
so that these pieces may be added (or removed) according to the
needs (and logic scarcity) of your particular environment and application.&lt;/p&gt;

&lt;p&gt;A fifth way the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; is unique is in the number of registers.  The &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
offers 14 general purpose registers to user space.  Most of these other
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;s
offer 32 registers–but only with a lot of caveats.
For example, you can’t use &lt;code class=&quot;highlighter-rouge&quot;&gt;R0&lt;/code&gt; since the compiler
depends upon it to be equal to zero.  Another register may be used to form
constants in the assembler, and so its off limits to the compiler.  By the
time you drill down further, you’ll discover that perhaps only 24 registers
are available.  Of these 24, a rough half of them are assumed to be clobbered
on any function call and need to be saved on the stack anyway.  Further,
saving registers to the stack is really the limiting factor in any choice of
register size.  As a result, the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;’s
14 general purpose registers really don’t limit the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;’s performance significantly
in comparison to these other
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;s.&lt;/p&gt;

&lt;p&gt;When you start looking at actual instructions, the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; might initially appear
less capable.  For example, 
the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; 
has no &lt;code class=&quot;highlighter-rouge&quot;&gt;ADDC&lt;/code&gt; or &lt;code class=&quot;highlighter-rouge&quot;&gt;SUBC&lt;/code&gt; instructions (add or
subtract with carry), neither does the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; offer any &lt;code class=&quot;highlighter-rouge&quot;&gt;RSUB&lt;/code&gt; reverse
subtract instruction, &lt;code class=&quot;highlighter-rouge&quot;&gt;SEXT&lt;/code&gt; sign extension instructions, &lt;code class=&quot;highlighter-rouge&quot;&gt;CLZ&lt;/code&gt; count leading
(or trailing) zero instructions, &lt;code class=&quot;highlighter-rouge&quot;&gt;ROL&lt;/code&gt; rotate
left (or right) instructions and more.  However, these are all fairly rare
instructions and workarounds are easy to come by.  Indeed, the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
once had a rotate left instruction.  That instruction was later removed
because 1) the compiler never used it, 2) very simple alternative
instruction combinations were already available, and
the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; needed to support
8-bit bytes in order to be POSIX compliant.&lt;/p&gt;

&lt;p&gt;Of course, the next place the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; shines is with
its simplified bus architecture.  I’m not sure if you saw
&lt;a href=&quot;https://forum.digilentinc.com/topic/4930-arty-microblaze-speed-question&quot;&gt;this thread&lt;/a&gt;
or not, but it shows that the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;–even without a data cache,
can still outperform a
&lt;a href=&quot;https://www.xilinx.com/support/documentation/sw_manuals/mb_ref_guide.pdf&quot;&gt;MicroBlaze&lt;/a&gt;
simply due to (what I believe is) its simplified bus architecture.&lt;/p&gt;

&lt;h2 id=&quot;next-lesson&quot;&gt;Next Lesson&lt;/h2&gt;

&lt;p&gt;There are actually many other features contained with the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;, and even
other differences between it and other
&lt;a href=&quot;https://en.wikipedia.org/wiki/Soft_microprocessor&quot;&gt;softcore CPU&lt;/a&gt;s,
then this simple post could discuss.  For example, the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; can
&lt;a href=&quot;/zipcpu/2017/08/25/hw-debugging.html&quot;&gt;single step code&lt;/a&gt;
from either supervisor or user mode and more.&lt;/p&gt;

&lt;p&gt;Further, time wouldn’t permit discussing the various I/O peripherals that
can be optionally added to the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;–peripherals such as an
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/icontrol.v&quot;&gt;interrupt controller&lt;/a&gt;,
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/zipcounter.v&quot;&gt;performance counters&lt;/a&gt;, a
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/wbdmac.v&quot;&gt;DMA controller&lt;/a&gt;,
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/ziptimer.v&quot;&gt;simplified timers&lt;/a&gt;,
and more.  At least, time today won’t permit it.  These components are all
fair game for future blog posts.&lt;/p&gt;

&lt;p&gt;Some parts of the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;,
however, remain a work in progress.  For example, while an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Memory_management_unit&quot;&gt;MMU&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/zipmmu.v&quot;&gt;exists&lt;/a&gt;,
I have yet to integrate it into the rest of the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;.
In particular, the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/pfcache.v&quot;&gt;prefetch cache&lt;/a&gt;
will need to know when to invalidate cache lines due to writes, something
I haven’t gotten to yet.  Likewise, while a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Cache_(computing)&quot;&gt;data cache&lt;/a&gt; &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/dcache.v&quot;&gt;implementation
exists&lt;/a&gt;, it
also has yet to be integrated and has since become a touch out of date.  Once
those two are integrated, my next plan is to host
&lt;a href=&quot;https://en.wikipedia.org/wiki/Linux&quot;&gt;Linux&lt;/a&gt;
from the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;–I just haven’t
gotten that far yet.  Perhaps the reason is … I haven’t needed to.&lt;/p&gt;

&lt;p&gt;The &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; “as is” is already a
very capable &lt;a href=&quot;https://en.wikipedia.org/wiki/Microcontroller&quot;&gt;microcontroller&lt;/a&gt;,
just as it was designed to be.&lt;/p&gt;
&lt;hr /&gt;&lt;p&gt;&lt;em&gt;Know ye not, that to whom ye yield yourselves servants to obey, his servants ye are to whom ye obey; whether of sin unto death, or of obedience unto righteousness? (Rom 6:16)&lt;/em&gt;</description>
        <pubDate>Mon, 01 Jan 2018 00:00:00 -0500</pubDate>
        <link>http://zipcpu.com/zipcpu/2018/01/01/zipcpu-isa.html</link>
        <guid isPermaLink="true">http://zipcpu.com/zipcpu/2018/01/01/zipcpu-isa.html</guid>
        
        
        <category>zipcpu</category>
        
      </item>
    
      <item>
        <title>Top 10 ZipCPU blog posts for 2017</title>
        <description>&lt;p&gt;Happy New Year everyone!&lt;/p&gt;

&lt;p&gt;It’s now 2018.  Shall we take a quick look at the
top 10 posts from 2017?  In case you missed them, here’s a recap:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;/blog/2017/08/04/debouncing.html&quot;&gt;How to eliminate button bounces with digital logic&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;This page, showing how to handle debouncing buttons, received &lt;strong&gt;1,178&lt;/strong&gt;
hits in 2017.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;/dsp/2017/09/15/fastfir.html&quot;&gt;Building a high speed Finite Impulse Response Digital Filter&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;This page may have been the first real introduction to FIR filtering on
&lt;a href=&quot;http://zipcpu.com/&quot;&gt;ZipCPU.com&lt;/a&gt;, offering more details
than the &lt;a href=&quot;/dsp/2017/08/19/simple-filter.html&quot;&gt;initial, two-simple
filters&lt;/a&gt;
article presented.  It described how to build a generic FIR filter within an
FPGA.&lt;/p&gt;

    &lt;p&gt;Although the blog has since moved on to discuss &lt;a href=&quot;/dsp.html&quot;&gt;many other filtering
implementations&lt;/a&gt;, this basic article was a
winner that received &lt;strong&gt;1,284&lt;/strong&gt; page views in 2017.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;/dsp/2017/08/30/cordic.html&quot;&gt;Using a CORDIC to calculate sines and cosines in an FPGA&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;Although the CORDIC algorithm really isn’t anything new, this was still
a winning article as it helped to explain to many how a CORDIC operates.
As a result, this article received &lt;strong&gt;1,347&lt;/strong&gt; page views in 2017.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;/blog/2017/05/19/fpga-hell.html&quot;&gt;FPGA Hell&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;This simple and short essay describes the reality that many FPGA developers
have found themselves within: the code builds, it synthesizes, it can be
placed onto an FPGA, but once there it doesn’t work.  It also offers some
approaches for getting out of FPGA Hell as well.  This well loved
article received &lt;strong&gt;1,375&lt;/strong&gt; page views in 2017.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;/blog/2017/10/13/fpga-v-asic.html&quot;&gt;FPGAs vs ASICs&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;Thanks to a conversation with a friend at
&lt;a href=&quot;https://orconf.org&quot;&gt;ORCONF&lt;/a&gt;
this year, I learned that ASIC development is very different from FPGA
development.  Sure, they both share Verilog or VHDL as a base language,
and they
both use digital logic, but they are also &lt;em&gt;very different&lt;/em&gt; disciplines.
This article focuses on and describes those differences.  It received
&lt;strong&gt;1,427&lt;/strong&gt; page views in 2017.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;/zipcpu/2017/11/18/wb-prefetch.html&quot;&gt;Building a prefetch module for the ZipCPU&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;I guess I wasn’t expecting this article to end up on the top-ten list this
year when I wrote it.  It only describes a very simple prefetch module
for the ZipCPU, not the fastest or the best prefetch module.  Perhaps it
was because it showed how a prefetch module could interact with a CPU,
or perhaps it was because it showed how a prefetch module could be
formally verified.  Either way, this article ends up at number 6, with
&lt;strong&gt;2,003&lt;/strong&gt; page views during 2017.&lt;/p&gt;

    &lt;p&gt;Indeed, since this topic was so well received, I am looking forward to
posting about the ZipCPU’s &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/pfcache.v&quot;&gt;prefetch and cache
module&lt;/a&gt;,
and how that module may also be formally proven, in 2018.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;/blog/2017/10/20/cdc.html&quot;&gt;Some Simple Clock-Domain Crossing Solutions&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;This post discusses several different approaches to simple clock domain
crossings.  It discusses what clock domain crossings is, and when you need
a clock domain crossing solution in the first place.  This article received
&lt;strong&gt;2,152&lt;/strong&gt; page views.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;My first experience with Formal Methods&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;This post discusses my first experiences with using formal methods via the
open source &lt;a href=&quot;http://www.clifford.at/yosys&quot;&gt;yosys&lt;/a&gt; program and the
associated yosys-smtbmc program.  I applied these methods to a FIFO.  Much
to my surprise, the formal methods found bugs in my “working” FIFO
implementation that I had never found using a traditional test bench
methodology.&lt;/p&gt;

    &lt;p&gt;This post received &lt;strong&gt;5,936&lt;/strong&gt; page views in 2017.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;/blog/2017/08/21/rules-for-newbies.html&quot;&gt;Rules for new FPGA designers&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;At the beginning of the fall 2017 semester, I put together a list of
“rules” and pieces of advice for new FPGA designers.  While these rules
were hotly debated on the Hacker News website, they will still help to
keep new FPGA designers out of a lot of debugging troubles.&lt;/p&gt;

    &lt;p&gt;This post received &lt;strong&gt;11,530&lt;/strong&gt; page views.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;/blog/2017/09/18/clocks-for-sw-engineers.html&quot;&gt;Clocks for Software Engineers&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;The one post that received more page views than any other was the &lt;a href=&quot;/blog/2017/09/18/clocks-for-sw-engineers.html&quot;&gt;Clocks for
Software Engineers&lt;/a&gt;
post.  This post examines many of the common problems that software
engineers have when trying to “program” in Verilog or VHDL.  It discusses
the impact of for loops, and why the clock is so important.&lt;/p&gt;

    &lt;p&gt;In general, I make it a point not to post any of my articles to any news
aggregators.  This is based upon the Bible verse:&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;Let another man praise thee, and not thine own mouth; a stranger, and
not thine own lips. (&lt;a href=&quot;https://www.blueletterbible.org/kjv/pro/27/2&quot;&gt;Prov 27:2&lt;/a&gt;)&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;p&gt;Doing this also allows me to evaluate how well a particular article was, or
was not received.  If someone feels that the article was well written enough
to post to an aggregator, then that tells me something about my audience.&lt;/p&gt;

    &lt;p&gt;It may have been about four days after I posted this article when someone
read it and posted it on Hacker News.  I was sitting at my desk at the time
watching Google Analytics while doing other work when suddenly the number
of page views spiked from 0-3 at a time to upwards of 700 views at once.
(It’s probably more accurately a block average over a minute or two, but it
shows on the screen as though they were all at once.)  I then looked to find
the article on Hacker News: it was &lt;em&gt;the top article&lt;/em&gt; for several hours that
night.  Since then, it has often remained the top article people have read
on a week by week basis.&lt;/p&gt;

    &lt;p&gt;This article tops the zipcpu.com charts at &lt;strong&gt;57,033&lt;/strong&gt; page views in 2017.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;If you find you’ve missed any of these articles, feel free to go back and read
what others have enjoyed so much this year.&lt;/p&gt;

&lt;p&gt;From my standpoint, I find these top ten articles, together with any
e-mails from my &lt;a href=&quot;https://patreon.com/ZipCPU&quot;&gt;Patreon supporters&lt;/a&gt;, are a guide
to what topics might interest FPGA developers in the future.
For example, based upon this list I’ll probably discuss some other
(better?) approaches to sine-wave generation in this new year, how to build
(and verify) a prefetch with an integrated cache, an asynchronous FIFO
implementation, how to &lt;a href=&quot;https://github.com/ZipCPU/vgasim&quot;&gt;simulate a display&lt;/a&gt;
using Verilator, and much more–but only if the
&lt;a href=&quot;https://www.blueletterbible.org/kjv/jas/4/15&quot;&gt;Lord is willing&lt;/a&gt;.&lt;/p&gt;
&lt;hr /&gt;&lt;p&gt;&lt;em&gt;Say not thou, What is the cause that the former days were better than these? for thou dost not enquire wisely concerning this. (Eccl 7:10)&lt;/em&gt;</description>
        <pubDate>Mon, 01 Jan 2018 00:00:00 -0500</pubDate>
        <link>http://zipcpu.com/blog/2018/01/01/top-ten.html</link>
        <guid isPermaLink="true">http://zipcpu.com/blog/2018/01/01/top-ten.html</guid>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>A better filter implementation for slower signals</title>
        <description>&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 1. A Generic filter implementation&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/fir-form.svg&quot; alt=&quot;&quot; width=&quot;480&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;We’ve slowly been working through several
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_signal_processing&quot;&gt;DSP&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/tree/master/rtl&quot;&gt;implementations&lt;/a&gt; on
&lt;a href=&quot;http://zipcpu.com/&quot;&gt;this blog&lt;/a&gt;.  Each of these
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/tree/master/rtl&quot;&gt;implementations&lt;/a&gt;
includes the logic necessary to evaluate a typical
&lt;a href=&quot;https://en.wikipedia.org/wiki/Convolution&quot;&gt;convolution&lt;/a&gt;,
such as the one shown in Fig 1 on the right.&lt;/p&gt;

&lt;p&gt;We’ve presented both a
&lt;a href=&quot;/dsp/2017/09/15/fastfir.html&quot;&gt;fairly generic FIR filter implementation&lt;/a&gt;
for high rate data signals, as well as a
&lt;a href=&quot;/dsp/2017/09/29/cheaper-fast-fir.html&quot;&gt;simple modification to that implementation&lt;/a&gt;
that uses fewer resources but has a higher fanout.  We’ve also discussed a
&lt;a href=&quot;/dsp/2017/11/04/genfil-tb.html&quot;&gt;generic test harness&lt;/a&gt;
that can be used to test and prove some of
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters&quot;&gt;these filters&lt;/a&gt;,
and even showed &lt;a href=&quot;/dsp/2017/12/06/fastfir-tb.html&quot;&gt;how that harness might be
applied&lt;/a&gt;.
Further, we’ve discussed the usefulness of a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;’s
&lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency_response&quot;&gt;frequency response&lt;/a&gt;,
as well as
&lt;a href=&quot;/dsp/2017/11/22/fltr-response.html&quot;&gt;how to measure it&lt;/a&gt;
using the
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/bench/cpp/filtertb.cpp&quot;&gt;same test harness&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;However, if you want to try any of these initial filter implementations
on signals with a slower sample rate, such as audio signals, you’ll
quickly find these &lt;em&gt;faster&lt;/em&gt; filtering implementations to be very resource
intensive.&lt;/p&gt;

&lt;p&gt;For example, if you want to apply a 2047 tap filter to a 48kHz audio
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;,
while running your
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
at a 100MHz system clock, then the
&lt;a href=&quot;/dsp/2017/09/15/fastfir.html&quot;&gt;generic filter implementation&lt;/a&gt;
will cost you 2047 hardware multiplies.  This will force you to the most
expensive and feature rich Virtex-7 FPGA, the
&lt;a href=&quot;https://www.digikey.com/product-detail/en/xilinx-inc/XC7VH870T-1FLG1932C/XC7VH870T-1FLG1932C-ND/5247347&quot;&gt;XC7VH870T&lt;/a&gt;–a chip that will cost
you a minimum of $18k USD today on
&lt;a href=&quot;https://www.digikey.com&quot;&gt;Digikey&lt;/a&gt;.  On the other hand, if you used the
implementation presented below, you might still be able to use an
&lt;a href=&quot;https://www.digikey.com/product-detail/en/xilinx-inc/XC7A15T-1FTG256C/122-1930-ND/5248117&quot;&gt;Artix-7 priced at less than $26&lt;/a&gt; on
&lt;a href=&quot;https://www.digikey.com&quot;&gt;Digikey&lt;/a&gt;, and available as part of many hobby
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
boards for fairly reasonable prices (about $100USD).
&lt;a href=&quot;https://store.digilentinc.com/basys-3-artix-7-fpga-trainer-board-recommended-for-introductory-users/&quot;&gt;[1]&lt;/a&gt;
&lt;a href=&quot;https://store.digilentinc.com/arty-artix-7-fpga-development-board-for-makers-and-hobbyists/&quot;&gt;[2]&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;For all of these reasons, it’s important to know how to build a
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/slowfil.v&quot;&gt;filter&lt;/a&gt;
that re-uses its hardware multiplies to the maximum extent possible.  The
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/slowfil.v&quot;&gt;filter&lt;/a&gt;
that we’ll present below, for example, uses only one hardware
multiply–although that will limit the number of coefficients this
&lt;a href=&quot;https://en.wikipedia.org/wiki/Finite_impulse_response&quot;&gt;FIR&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/slowfil.v&quot;&gt;implementation&lt;/a&gt;
can handle.&lt;/p&gt;

&lt;p&gt;Let’s take a look at what how this
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;
will need to operate, and then look at how to
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/slowfil.v&quot;&gt;implement&lt;/a&gt;
it.  Once implemented, we’ll show how easy it is
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/bench/cpp/slowfil_tb.cpp&quot;&gt;to test&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/slowfil.v&quot;&gt;this filter&lt;/a&gt;
using the
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/bench/cpp/filtertb.cpp&quot;&gt;test harness&lt;/a&gt;
we built some time ago.&lt;/p&gt;

&lt;h2 id=&quot;the-operation&quot;&gt;The Operation&lt;/h2&gt;

&lt;p&gt;If you’ve gone through the posts above, then you are already aware that a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;digital filter&lt;/a&gt;
evaluates a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Convolution&quot;&gt;convolution&lt;/a&gt;.
For example, if &lt;code class=&quot;highlighter-rouge&quot;&gt;x[n]&lt;/code&gt; were our input, &lt;code class=&quot;highlighter-rouge&quot;&gt;y[n]&lt;/code&gt; our output, and &lt;code class=&quot;highlighter-rouge&quot;&gt;h[n]&lt;/code&gt; a
series of coefficients, then we might write that,&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/fir-convolution.png&quot; alt=&quot;&quot; width=&quot;255&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Pictorially, this equation describes the operation shown in Fig 1 above.&lt;/p&gt;

&lt;p&gt;Today’s &lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/slowfil.v&quot;&gt;filter
implementation&lt;/a&gt;
will follow directly from a straight-forward evaluation of the summation
in the equation above.  In other words, we’ll start by setting an
accumulator to the first value,&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/fir-slowfil-acc-zero.png&quot; alt=&quot;&quot; width=&quot;205&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Then, on each subsequent clock we’ll add the next value to it,&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/fir-slowfil-acc-step.png&quot; alt=&quot;&quot; width=&quot;409&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 2. A Time Multiplexed filter implementation&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/fir-slow-form.svg&quot; alt=&quot;&quot; width=&quot;480&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Fig 2 on the right shows a diagram of how this approach might look.
Basically, at every step we’ll read both an &lt;code class=&quot;highlighter-rouge&quot;&gt;h[k]&lt;/code&gt; value and an &lt;code class=&quot;highlighter-rouge&quot;&gt;x[n-k]&lt;/code&gt;
value from separate memories, multiply the two together, and add the product
together with the value from an accumulator.  Once all the values have
been added together, we’ll use this accumulated result as our output.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/fir-slowfil-acc-done.png&quot; alt=&quot;&quot; width=&quot;204&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;In Verilog, this might look something like the following.  On the first
clock, we’d read one tap from the tap (coefficient) memory, and multiply
it by our incoming data sample, &lt;code class=&quot;highlighter-rouge&quot;&gt;i_sample&lt;/code&gt;.  The result of that product
could then be used to initialize an accumulator, &lt;code class=&quot;highlighter-rouge&quot;&gt;r_acc&lt;/code&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
if (i_ce)
begin
	// first clock
	tap &amp;lt;= tapmem[0];

	// second clock
	product &amp;lt;= tap * i_sample;

	// third clock
	r_acc &amp;lt;= product;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Sounds simple so far, right?  Okay, so we’ve ignored any pipeline scheduling
(&lt;code class=&quot;highlighter-rouge&quot;&gt;i_ce&lt;/code&gt; will only be true for one clock in &lt;code class=&quot;highlighter-rouge&quot;&gt;N&lt;/code&gt;), but let’s come back to that
in a moment.&lt;/p&gt;

&lt;p&gt;Further, we’re going to need to read from block RAM memory on every clock
following.  This means we’ll need to place this new sample value into
memory, and then increment the write pointer.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	// Write the new data to memory, then increment the memory pointer
	dmem[dwidx] &amp;lt;= i_sample;
	dwidx &amp;lt;= dwidx + 1&#39;b1;	// increment the memory write pointer&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;We’re also going to want to be able to read the coefficient index pointer
and the data index pointer on the next clock, so let’s set these as part
of the same clock that the new data shows in on.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	// Still on i_ce
	tidx &amp;lt;= 1;
	didx &amp;lt;= dwidx;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;After the accumulator has been given an initial value, we’ll then need to read
both the coefficient values and the data values from an on-chip block RAM
memory.  Placing
the data into a data memory to make this happen will require a memory write
and some memory address manipulation.  That means that the second part of
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/slowfil.v&quot;&gt;this algorithm&lt;/a&gt;
might look like:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;end else if (!done)
begin
	// Now, between clocks, we&#39;ll need to read the data and the coefficient
	data &amp;lt;= dmem[didx];	// Read data from the sample memory, x[n-k]
	tap &amp;lt;= tapmem[tidx];	// Read from the coefficient memory, h[k]

	// Update the pointers to each.  Notice that the coefficient index,
	// tidx increases while the data index decreases--just as we have
	// above.
	didx &amp;lt;= didx - 1&#39;b1;
	tidx &amp;lt;= tidx + 1&#39;b1;

	// and calculate the product
	product &amp;lt;= tap * data;

	// Use the product to update the accumulator
	r_acc &amp;lt;= r_acc + product&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Once we are done with all of the above, we’ll set the &lt;a href=&quot;/blog/2017/08/14/strategies-for-pipelining.html&quot;&gt;traveling
CE&lt;/a&gt;
values associated with the output, &lt;code class=&quot;highlighter-rouge&quot;&gt;o_ce&lt;/code&gt;, and set the output 
value according to the last &lt;code class=&quot;highlighter-rouge&quot;&gt;r_acc&lt;/code&gt; value.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;end else // if (done)
begin
	o_ce &amp;lt;= 1&#39;b1;
	o_result &amp;lt;= r_acc;
end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;That’s the general gist of what we need to do.  Sadly, however, the code above
has multiple timing errors and pipeline scheduling conflicts within it.
For example, there should
be a clock delay between reading from memory and using the result, and another
clock delay between multiplying two numbers together and using that result.
As a result, the logic above will never work, but as a simple first draft
it should be able to convey (roughly) what it is we hope to do.&lt;/p&gt;

&lt;h2 id=&quot;the-basic-filter-written-in-c&quot;&gt;The basic filter, written in C++&lt;/h2&gt;

&lt;p&gt;Perhaps if you have a software background, you might appreciate seeing this
code written out in C++.  The following is an excerpt from an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Finite_impulse_response&quot;&gt;FIR&lt;/a&gt;
implementation found in my own personal signal processing library.  The code
uses double’s instead of fixed point, but it’s still basically the same thing.&lt;/p&gt;

&lt;p&gt;This C++ algorithm depends upon an array of &lt;code class=&quot;highlighter-rouge&quot;&gt;m_len&lt;/code&gt; coefficients, &lt;code class=&quot;highlighter-rouge&quot;&gt;m_coeff&lt;/code&gt;.
This array will be initialized with the coefficients associated with the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;
before starting.&lt;/p&gt;

&lt;p&gt;It also needs an array of data, &lt;code class=&quot;highlighter-rouge&quot;&gt;m_data&lt;/code&gt;, of the same length.  Rather than
moving all the data through the array at every point in time, we’ll just
keep track of the address of the last data element in the tapped delay line,
&lt;code class=&quot;highlighter-rouge&quot;&gt;m_loc&lt;/code&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt;	&lt;span class=&quot;nc&quot;&gt;FIR&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;m_len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;	&lt;span class=&quot;c1&quot;&gt;// Number of taps in the filter
&lt;/span&gt;	&lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt;	&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_coeff&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

	&lt;span class=&quot;c1&quot;&gt;// ...
&lt;/span&gt;	&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;m_loc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;		&lt;span class=&quot;c1&quot;&gt;// Location of the last sample in the buffer
&lt;/span&gt;	&lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt;	&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;	&lt;span class=&quot;c1&quot;&gt;// Data buffer, double[m_len]
&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;// ...
&lt;/span&gt;	&lt;span class=&quot;c1&quot;&gt;// Declare our operator
&lt;/span&gt;	&lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;apply&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i_sample&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Were this written in Verilog, such as we will do in the next section, these two
arrays would be captured in block RAMs.&lt;/p&gt;

&lt;p&gt;To evaluate the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Convolution&quot;&gt;convolution&lt;/a&gt; via the
equation above, we’ll run the following code when given a new sample,
&lt;code class=&quot;highlighter-rouge&quot;&gt;i_sample&lt;/code&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;FIR&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;apply&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i_sample&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;             &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ln&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;acc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Our first step will be to record the new sample into the data memory.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;	&lt;span class=&quot;n&quot;&gt;m_data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_loc&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dat&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_loc&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m_len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;m_loc&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;After this point, we’ll enter a loop whereby we grab one sample from
data memory and one coefficient from the coefficient memory, multiply the
two together, and accumulate the result into an accumulator, &lt;code class=&quot;highlighter-rouge&quot;&gt;acc&lt;/code&gt;.  We’ll
start the accumulator at zero.  Further, after each sample,
we’ll increase the address in coefficient memory, and decrease the address
in data memory–just as the formula above indicated.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;	&lt;span class=&quot;n&quot;&gt;acc&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;d&lt;/span&gt;   &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_loc&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;   &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_coeff&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;ln&lt;/span&gt;  &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m_loc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ln&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;acc&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The fact that the data memory isn’t centered makes this a touch more
complicated.  What that means is that if you start reading backwards
from the middle of memory (where the most recent sample was), you
will eventually run off the beginning of the memory.  Fig 3 shows this below.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 3. Data memory contains both old and new data&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/fir-slow-memory.svg&quot; alt=&quot;&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;In this figure, you can see the location &lt;code class=&quot;highlighter-rouge&quot;&gt;m_loc&lt;/code&gt; (just right of the center
of the figure) which is one past where
the new data, &lt;code class=&quot;highlighter-rouge&quot;&gt;i_sample&lt;/code&gt;, has just been written.  You can also see how
the &lt;code class=&quot;highlighter-rouge&quot;&gt;x[n-k]&lt;/code&gt; sequence extends to the left of this location.  Once this
data sequence runs off the end of memory to the left, a second pass is
required to get the rest of the data coming from the far end on the right.
This second pass continues back to where we started, making sure every data
sample in memory, and every coefficient value, is used exactly once.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;	&lt;span class=&quot;n&quot;&gt;d&lt;/span&gt;   &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m_data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_len&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;ln&lt;/span&gt;  &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ln&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_loc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ln&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;acc&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Once all of the multiplies have been completed, the result is returned.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;	&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;acc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This is the basic algorithm we will write in Verilog below.  There will be
some differences though.  The first and most obvious difference is the fact
that several parts of this algorithm will run in parallel–this is &lt;a href=&quot;/blog/2017/09/18/clocks-for-sw-engineers.html&quot;&gt;running in
hardware&lt;/a&gt;
after all.  The next, not
quite so obvious difference, is that if the memory address is limited to
some finite number of bits, then we won’t need to pay any attention to the
memory break shown above in Fig 3.  Finally, the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;
algorithm &lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/slowfil.v&quot;&gt;implemented in
Verilog&lt;/a&gt;
will be written using fixed point numbers instead of the &lt;code class=&quot;highlighter-rouge&quot;&gt;double&lt;/code&gt;-precision
floating point numbers that are so easy to use in the C++ above.&lt;/p&gt;

&lt;p&gt;Before moving on, I should make one point about the code above.  This C/C++
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;
implementation is only practical for
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;s
with &lt;a href=&quot;https://en.wikipedia.org/wiki/Impulse_response&quot;&gt;impulse responses&lt;/a&gt;
shorter than about 64 samples.  Anything more than 64 samples and you’ll
want to use an &lt;a href=&quot;https://en.wikipedia.org/wiki/Fast_Fourier_transform&quot;&gt;FFT&lt;/a&gt;
based
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filtering&lt;/a&gt;
approach.  The differences between the two approaches will become
particularly stark after double the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;
length only a few times.&lt;/p&gt;

&lt;h2 id=&quot;verilog&quot;&gt;Verilog&lt;/h2&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 4. Test Harness Filter Interface&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/fir-ports.svg&quot; alt=&quot;&quot; width=&quot;240&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;You may remember from our
&lt;a href=&quot;/dsp/2017/11/04/genfil-tb.html&quot;&gt;test harness discussion&lt;/a&gt;
that as long as a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;
implementation has the ports we discussed then, and shown again here in
Fig 4 at the right, that we can continue using our &lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/bench/cpp/filtertb.cpp&quot;&gt;generic filtering test
harness&lt;/a&gt;.
While we’ll be able to
&lt;a href=&quot;https://en.wikipedia.org/wiki/Inheritance_(object-oriented_programming)&quot;&gt;inherit&lt;/a&gt;
and modify
the &lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/bench/cpp/filtertb.cpp&quot;&gt;test harness&lt;/a&gt;
with additional functionality in the next section, we’ll 
need to start out this section by remembering that our
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;
implementation will need to have a reset, and the ability to load
taps, in addition to samples coming in and going out.&lt;/p&gt;

&lt;p&gt;We’ll start with the ability to set our
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;
coefficients.  As with many of our
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/tree/master/rtl&quot;&gt;other filters&lt;/a&gt;,
we’ll allow a parameter &lt;code class=&quot;highlighter-rouge&quot;&gt;FIXED_TAPS&lt;/code&gt; to express whether or not this
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;
has a tap-update capability at all.  If the coefficients are fixed, then
we’ll &lt;code class=&quot;highlighter-rouge&quot;&gt;$readmemh&lt;/code&gt; them from a &lt;code class=&quot;highlighter-rouge&quot;&gt;.hex&lt;/code&gt; file whose name is given in
&lt;code class=&quot;highlighter-rouge&quot;&gt;INITIAL_COEFFS&lt;/code&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	generate if (FIXED_TAPS)
	begin
		initial $readmemh(INITIAL_COEFFS, tapmem);
		// ...
	end else begin&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;On the other hand, if our
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;
coefficients are not fixed, &lt;code class=&quot;highlighter-rouge&quot;&gt;FIXED_TAPS&lt;/code&gt; will be false, and we’ll need
to load our coefficients into memory.  To do this, we’ll start with a
memory index, &lt;code class=&quot;highlighter-rouge&quot;&gt;tapwidx&lt;/code&gt;, or tap writing index.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;		reg	[(LGNTAPS-1):0]	tapwidx;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;We’ll set this index to zero initially, and to return to zero upon any reset.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;		initial	tapwidx = 0;
		always @(posedge i_clk)
			if(i_reset)
				tapwidx &amp;lt;= 0;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Otherwise, anytime the &lt;code class=&quot;highlighter-rouge&quot;&gt;i_tap_wr&lt;/code&gt; signal is high, a new coefficient is present
in &lt;code class=&quot;highlighter-rouge&quot;&gt;i_tap&lt;/code&gt; which we’ll write to coefficient memory.  We’ll also need to
increment this index.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;			else if (i_tap_wr)
				tapwidx &amp;lt;= tapwidx + 1&#39;b1;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Here’s where we actually use the tap (coefficient) writing index, &lt;code class=&quot;highlighter-rouge&quot;&gt;tapwidx&lt;/code&gt;
to write into the coefficient memory, &lt;code class=&quot;highlighter-rouge&quot;&gt;tapmem&lt;/code&gt;.  This is also the section
of the code to specify any memory initialization, so we’ll initialize the
memory if the &lt;code class=&quot;highlighter-rouge&quot;&gt;INITIAL_COEFFS&lt;/code&gt; file name is empty.  Note that the &lt;code class=&quot;highlighter-rouge&quot;&gt;if&lt;/code&gt;
statement is &lt;em&gt;outside&lt;/em&gt; of the &lt;code class=&quot;highlighter-rouge&quot;&gt;initial&lt;/code&gt; block.  That will keep the
synthesizer from looking for this file if the name hasn’t been given.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;		if (INITIAL_COEFFS != 0)
			initial $readmemh(INITIAL_COEFFS, tapmem);
		always @(posedge i_clk)
			if (i_tap_wr)
				tapmem[tapwidx] &amp;lt;= i_tap;
	end endgenerate&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;That’s all that’s required for dynamically setting or adjusting coefficient
memory.  We started with an &lt;code class=&quot;highlighter-rouge&quot;&gt;i_reset&lt;/code&gt; signal to clear the index, and then
wrote one coefficient and stepped the index on any clock where &lt;code class=&quot;highlighter-rouge&quot;&gt;i_tap_wr&lt;/code&gt; was
true.&lt;/p&gt;

&lt;p&gt;So let’s now turn our attention to the &lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/slowfil.v&quot;&gt;filter
implementation&lt;/a&gt;
itself.&lt;/p&gt;

&lt;p&gt;We’ll start with updating the data memory, herein called &lt;code class=&quot;highlighter-rouge&quot;&gt;dmem&lt;/code&gt;.  We’ll
use a data memory write index, &lt;code class=&quot;highlighter-rouge&quot;&gt;dwidx&lt;/code&gt; to do this.  Hence, on every &lt;code class=&quot;highlighter-rouge&quot;&gt;i_ce&lt;/code&gt;
value, we’ll increment the data memory write index,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	initial	dwidx = 0;
	always @(posedge i_clk)
		if (i_ce)
			dwidx &amp;lt;= dwidx + 1&#39;b1;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;and write the new sample into the data memory.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(posedge i_clk)
		if (i_ce)
			dmem[dwidx] &amp;lt;= i_sample;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;That may be about as simple as any logic could get!&lt;/p&gt;

&lt;p&gt;That said, there is a subtlety associated with this approach.
Notice in this process how the data memory update process is &lt;em&gt;independent&lt;/em&gt;
of the &lt;code class=&quot;highlighter-rouge&quot;&gt;i_reset&lt;/code&gt; signal.  It is dependent upon new sample data
only.  Further, this will allow the
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/slowfil.v&quot;&gt;filter&lt;/a&gt;
to immediately start with valid data following any reset.&lt;/p&gt;

&lt;p&gt;This &lt;em&gt;feature&lt;/em&gt;, however, will become a thorn in our side when we build our
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/bench/cpp/slowfil_tb.cpp&quot;&gt;test bench&lt;/a&gt;.
The basic problem is that we’ll want to apply test vectors to the
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/slowfil.v&quot;&gt;filter&lt;/a&gt;
that assume the memory is clear (all zeros).  While the preferred solution
might be to clear all memory elements any time &lt;code class=&quot;highlighter-rouge&quot;&gt;i_reset&lt;/code&gt; is asserted, this
isn’t how most memories are built.  That means that, when we wish to clear
this memory later, we’ll need to write as many zeros to it as are necessary
to fill it with zeros.&lt;/p&gt;

&lt;p&gt;Those two parts, loading tap coefficients and incoming data, are the easy
parts of the algorithm, though.  The next step is to calculate
the indices to be used for both reading from coefficient and data memories.
Since this gets into scheduling, let’s take a moment to start scribbling
a draft pipeline schedule.&lt;/p&gt;

&lt;p&gt;Usually, when I build a pipeline schedule, I start by writing out my code and
marking each line with the appropriate clock.  Doing this might result in
pseudocode looking something like the following.&lt;/p&gt;

&lt;p&gt;The first clock would set the memory reading indexes.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	// Clock 1 -- i_ce and i_sample are true, tidx and didx are set
	if (i_ce)
	begin
		tidx &amp;lt;= 0;
		didx &amp;lt;= dwidx;
	end else begin
		tidx &amp;lt;= tidx + 1&#39;b1;
		didx &amp;lt;= didx - 1&#39;b1;
	end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Notice how we are using the &lt;code class=&quot;highlighter-rouge&quot;&gt;i_ce&lt;/code&gt; signal as an indication of when to reset
the indices for the data and coefficient memories, &lt;code class=&quot;highlighter-rouge&quot;&gt;didx&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;tidx&lt;/code&gt;,
to the beginning of our run.  At the same time, we’ll write the new data
sample into memory–we discussed that above.  That’s the first clock.&lt;/p&gt;

&lt;p&gt;The second clock would read from memory,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	// Clock 2.
	tap &amp;lt;= tapmem[tidx];
	data &amp;lt;= dmem[didx];&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This will give us the information we need to calculate &lt;code class=&quot;highlighter-rouge&quot;&gt;h[k][x[n-k]&lt;/code&gt;, hence
we can multiply these two values together on the third clock cycle,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	// Clock 3.
	product &amp;lt;= tap * data;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Once the product is available, we’d add it to our accumulator.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	// Clock 4.
	if (new_product_data)
		acc &amp;lt;= product;
	else if (subsequent_product_data)
		acc &amp;lt;= acc + product;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The final step would be to create our output.  This will need to take place
some time into the future–at a time we’ll need to come back to and determine
later.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	// Clock ... some distance into the future
	if (new_product_data)
	begin
		o_ce &amp;lt;= 1&#39;b1;
		o_result &amp;lt;= acc;
	end else
		o_ce &amp;lt;= 1&#39;b0;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Before moving on, I tried to draw this basic pipeline schedule out in Fig 5
below for reference.  You should know, though, that whenever
I build an algorithm like this I usually just start by writing
the clock numbers in my code as we just did above.  I find these diagrams,
like Fig 5 below, are most useful to me when telling someone else about one
of my designs, such as I am doing now, then they are when I write them.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 5. Initial draft pipeline schedule&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/fir-slow-schedule-one.svg&quot; alt=&quot;&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;If you aren’t familiar with this sort of table, I use it to communicate
when variables are &lt;em&gt;valid&lt;/em&gt; within a design.  In this case, on the clock that
any new data is present, i.e.  &lt;a href=&quot;/blog/2017/08/14/strategies-for-pipelining.html&quot;&gt;the clock where &lt;code class=&quot;highlighter-rouge&quot;&gt;i_ce&lt;/code&gt; is
high&lt;/a&gt;,
the write
index for the data memory will also be valid.  These clock numbers are off by
one from the ones above, simply because variables set on one clock (as shown
in the code above) will be valid on the next clock–as shown in Fig 5.&lt;/p&gt;

&lt;p&gt;So, that’s generally what we wish to do.  To make this happen, though, let’s
add some
&lt;a href=&quot;/blog/2017/08/14/strategies-for-pipelining.html&quot;&gt;traveling valid flags&lt;/a&gt;
to this pipeline.  Specifically, we are going to want to know when to reset
the accumulator with a new product, and when to add other products into the
accumulator.  We’re also going to need to know when to set &lt;code class=&quot;highlighter-rouge&quot;&gt;o_ce&lt;/code&gt; and
&lt;code class=&quot;highlighter-rouge&quot;&gt;o_result.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;The first &lt;a href=&quot;/blog/2017/08/14/strategies-for-pipelining.html&quot;&gt;traveling valid
flag&lt;/a&gt;
we’ll call &lt;code class=&quot;highlighter-rouge&quot;&gt;pre_acc_ce&lt;/code&gt;–or the pre clock
enable for the accumulator.  We’ll use a shift register for this purpose.
Hence, on the first clock we’ll set &lt;code class=&quot;highlighter-rouge&quot;&gt;pre_acc_ce[0]&lt;/code&gt; to let us know that the
indices will be valid on the next clock.  On that next clock, we’ll set
&lt;code class=&quot;highlighter-rouge&quot;&gt;pre_acc_ce[1]&lt;/code&gt; to indicate that the memory reads are valid.  Finally, we’ll
set &lt;code class=&quot;highlighter-rouge&quot;&gt;pre_acc_ce[2]&lt;/code&gt; to indicate that the product is valid.  Further, we’ll
clear &lt;code class=&quot;highlighter-rouge&quot;&gt;pre_acc_ce[0]&lt;/code&gt; as soon as the last tap has been read.  This will then
be the indicator needed to know when to stop accumulating values.&lt;/p&gt;

&lt;p&gt;The only real trick in this logic chain is knowing when to shut &lt;code class=&quot;highlighter-rouge&quot;&gt;pre_acc_ce[0]&lt;/code&gt;
off.  In particular, it needs to be shut off once we have exhausted all of the
coefficients in the
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/slowfil.v&quot;&gt;filter&lt;/a&gt;.
We’ll come back to this in a moment, but for now
we are talking about a simple piece of scheduling logic such as,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	wire	last_tap_index;
	// ...
	reg	[2:0]	pre_acc_ce;
	initial	pre_acc_ce = 3&#39;h0;
	always @(posedge i_clk)
		if (i_reset)
			pre_acc_ce[0] &amp;lt;= 1&#39;b0;
		else if (i_ce)
			pre_acc_ce[0] &amp;lt;= 1&#39;b1;
		else if ((pre_acc_ce[0])&amp;amp;&amp;amp;(last_tap_index))
			pre_acc_ce[0] &amp;lt;= 1&#39;b1;
		else
			pre_acc_ce[0] &amp;lt;= 1&#39;b0;
	// ...

	always @(posedge i_clk)
		if (i_reset)
			pre_acc_ce[2:1] &amp;lt;= 2&#39;b0;
		else
			pre_acc_ce[2:1] &amp;lt;= pre_acc_ce[1:0];&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Once &lt;code class=&quot;highlighter-rouge&quot;&gt;i_ce&lt;/code&gt; is valid, the memory index will be valid on the next clock–so
we’ll set &lt;code class=&quot;highlighter-rouge&quot;&gt;pre_ce_acc[0]&lt;/code&gt; to true.  We’ll leave it true until we get to the
last tap index.  Likewise the values will flow through this structure just
like a shift register.&lt;/p&gt;

&lt;p&gt;But when shall we cut it off?  It needs to be cut off such that, when
the coefficient index, &lt;code class=&quot;highlighter-rouge&quot;&gt;tidx&lt;/code&gt;, is referencing the last coefficient,
&lt;code class=&quot;highlighter-rouge&quot;&gt;pre_acc_ce[0]&lt;/code&gt; will be false on the next clock.  Since our coefficient index
is counting from &lt;code class=&quot;highlighter-rouge&quot;&gt;0&lt;/code&gt; to &lt;code class=&quot;highlighter-rouge&quot;&gt;NTAPS-1&lt;/code&gt;, this can be expressed as,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	assign	last_tap_index = (NTAPS[LGNTAPS-1:0]-tidx &amp;lt;= 1);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The neat thing about this piece of logic, as you’ll see as we move forward,
is that it keeps the
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/slowfil.v&quot;&gt;filter&lt;/a&gt;
from outputting an invalid answer any time
too many clocks are given between &lt;code class=&quot;highlighter-rouge&quot;&gt;i_ce&lt;/code&gt; values.  Hence, if you have a
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/slowfil.v&quot;&gt;filter&lt;/a&gt;
with &lt;code class=&quot;highlighter-rouge&quot;&gt;NTAPS&lt;/code&gt; coefficients, yet there are more than &lt;code class=&quot;highlighter-rouge&quot;&gt;NTAPS&lt;/code&gt; clocks between
samples, then the accumulator will only pay attention to the first
&lt;code class=&quot;highlighter-rouge&quot;&gt;NTAPS&lt;/code&gt; products.&lt;/p&gt;

&lt;p&gt;This brings us to our next step: the block RAM read indices.  Upon any new
value, the
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/slowfil.v&quot;&gt;filter&lt;/a&gt;
starts accumulating from the product of coefficient zero
and the most recent data sample.  Coefficients then work forwards in their
array, while the data indexes work backwards–just like they did in the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Convolution&quot;&gt;convolution&lt;/a&gt;
formula we started with.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	initial	didx = 0;
	initial	tidx = 0;
	always @(posedge i_clk)
		if (i_ce)
		begin
			didx &amp;lt;= dwidx;
			tidx &amp;lt;= 0;
		end else begin
			didx &amp;lt;= didx - 1&#39;b1;
			tidx &amp;lt;= tidx + 1&#39;b1;
		end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Indeed, this logic is essentially identical to our last draft.&lt;/p&gt;

&lt;p&gt;We’ll also follow the clocks through the pipeline with a second
&lt;a href=&quot;/blog/2017/08/14/strategies-for-pipelining.html&quot;&gt;traveling CE&lt;/a&gt;
approach that will use a &lt;a href=&quot;/blog/2017/08/14/strategies-for-pipelining.html&quot;&gt;couple of other CE
signals&lt;/a&gt;.
The first of these, &lt;code class=&quot;highlighter-rouge&quot;&gt;m_ce&lt;/code&gt; is memory
index valid signal,
indicating that the first indices is valid.  As you follow through the code,
you’ll see other similar CE signals, such as the &lt;code class=&quot;highlighter-rouge&quot;&gt;d_ce&lt;/code&gt; signal to indicate
the first set of data and coefficient values are valid and &lt;code class=&quot;highlighter-rouge&quot;&gt;p_ce&lt;/code&gt; to indicate
the first product is valid.  We’ll use these in a moment to determine when to
load the accumulator vs adding a new value to it.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	// m_ce is valid when the first index is valid
	initial	m_ce = 1&#39;b0;
	always @(posedge i_clk)
		m_ce &amp;lt;= (i_ce)&amp;amp;&amp;amp;(!i_reset);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;On every clock cycle, we’ll read two values from block RAM–a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Impulse_response&quot;&gt;coefficient value&lt;/a&gt;
and a data value.  Note how the block RAM reading code below is explicitly
kept very simple.  This is to make certain that the tools recognize these as
reads from block RAM’s, rather than more complex logic such as one would need
to implement via a
&lt;a href=&quot;/blog/2017/06/12/minimizing-luts.html&quot;&gt;look-up-tables&lt;/a&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	initial	tap = 0;
	always @(posedge i_clk)
		tap &amp;lt;= tapmem[tidx[(LGNTAPS-1):0]];

	initial	data = 0;
	always @(posedge i_clk)
		data &amp;lt;= dmem[didx];&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Once read, we’ll set a data CE, or &lt;code class=&quot;highlighter-rouge&quot;&gt;d_ce&lt;/code&gt;, to indicate that the first data
value is now valid.  This will follow the first memory indices are valid
CE, &lt;code class=&quot;highlighter-rouge&quot;&gt;m_ce&lt;/code&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	initial	d_ce = 0;
	always @(posedge i_clk)
		d_ce &amp;lt;= (m_ce)&amp;amp;&amp;amp;(!i_reset);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;After all this work, we
can now calculate the product of &lt;code class=&quot;highlighter-rouge&quot;&gt;h[k]x[n-k]&lt;/code&gt;, herein referenced as just
&lt;code class=&quot;highlighter-rouge&quot;&gt;tap * data&lt;/code&gt;.  Another &lt;a href=&quot;/blog/2017/08/14/strategies-for-pipelining.html&quot;&gt;traveling CE
value&lt;/a&gt;,
this time &lt;code class=&quot;highlighter-rouge&quot;&gt;p_ce&lt;/code&gt;, denotes when this first product is valid.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	initial	p_ce = 1&#39;b0;
	always @(posedge i_clk)
		p_ce &amp;lt;= (d_ce)&amp;amp;&amp;amp;(!i_reset);

	initial	product = 0;
	always @(posedge i_clk)
		product &amp;lt;= tap * data;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Only now can we can finally get to the accumulator at the penultimate
stage of this chain.  On the first value given to it, that is
any time &lt;code class=&quot;highlighter-rouge&quot;&gt;p_ce&lt;/code&gt; is true–which will be true with the first product value,
&lt;code class=&quot;highlighter-rouge&quot;&gt;h[0]x[n]&lt;/code&gt;, the accumulator is set to the result of that first product.
Otherwise, any time a subsequent product is valid–as noted by
&lt;code class=&quot;highlighter-rouge&quot;&gt;pre_acc_ce[2]&lt;/code&gt; being high, the accumulator value is increased
by that clock’s &lt;code class=&quot;highlighter-rouge&quot;&gt;h[k]x[n-k]&lt;/code&gt; value.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	initial	r_acc = 0;
	always @(posedge i_clk)
		if (p_ce)
			r_acc &amp;lt;={ {(OW-(IW+TW)){product[(IW+TW-1)]}}, product };
		else if (pre_acc_ce[2])
			r_acc &amp;lt;= r_acc + { {(OW-(IW+TW)){product[(IW+TW-1)]}},
						product };&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This almost looks like the draft code we created to work out pipeline
scheduling.  The biggest difference is that we’ve done some sign extension
work above to make sure this works across multiple synthesis tools and
lint checkers.&lt;/p&gt;

&lt;p&gt;On the same clock we place a new value into the accumulator, we can also read
the last value out.  Hence we set &lt;code class=&quot;highlighter-rouge&quot;&gt;o_result&lt;/code&gt; to the output of the accumulator
on that same clock, and &lt;code class=&quot;highlighter-rouge&quot;&gt;o_ce&lt;/code&gt; to indicate this result is valid.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	initial	o_result = 0;
	always @(posedge i_clk)
		if (p_ce)
			o_result &amp;lt;= r_acc;

	initial	o_ce = 1&#39;b0;
	always @(posedge i_clk)
		o_ce &amp;lt;= (p_ce)&amp;amp;&amp;amp;(!i_reset);
endmodule&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Note that, as a consequence of this approach, &lt;code class=&quot;highlighter-rouge&quot;&gt;o_ce&lt;/code&gt; will always be true a
fixed number of clock ticks from &lt;code class=&quot;highlighter-rouge&quot;&gt;i_ce&lt;/code&gt;.  Hence, if the data stops coming, the
last accumulator value will not be read out.  Likewise, if the &lt;code class=&quot;highlighter-rouge&quot;&gt;i_ce&lt;/code&gt; values
come with fewer than &lt;code class=&quot;highlighter-rouge&quot;&gt;NTAPS&lt;/code&gt; steps between them, then the &lt;code class=&quot;highlighter-rouge&quot;&gt;o_ce&lt;/code&gt; values will
only report partial
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;
products.  There is no error detection or correction here–but you can feel
free to add it if you would like.&lt;/p&gt;

&lt;p&gt;Still, that’s what it takes to generate a
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/slowfil.v&quot;&gt;slow&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Finite_impulse_response&quot;&gt;FIR&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;
in Verilog for an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;.  Sadly,
though, the code is complex enough that we are going to lean heavily on our
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/bench/cpp/slowfil_tb.cpp&quot;&gt;test bench&lt;/a&gt;
code to know if it works or not.&lt;/p&gt;

&lt;h2 id=&quot;test-bench&quot;&gt;Test bench&lt;/h2&gt;

&lt;p&gt;When it comes time to building a
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/bench/cpp/slowfil_tb.cpp&quot;&gt;test bench&lt;/a&gt; for
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/slowfil.v&quot;&gt;this filter&lt;/a&gt;,
we’ve really already done most of the work in the &lt;a href=&quot;/dsp/2017/11/04/genfil-tb.html&quot;&gt;generic filtering
test harness&lt;/a&gt;
we built for the
&lt;a href=&quot;/dsp/2017/09/15/fastfir.html&quot;&gt;generic filter&lt;/a&gt;’s
&lt;a href=&quot;/dsp/2017/12/06/fastfir-tb.html&quot;&gt;test bench&lt;/a&gt;.
As a result, testing
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/slowfil.v&quot;&gt;this filter&lt;/a&gt;
only requires making a couple of small changes.  Indeed, if you run a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Diff_utility&quot;&gt;diff&lt;/a&gt;
between the original
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/bench/cpp/genericfir_tb.cpp&quot;&gt;test bench for a generic filter&lt;/a&gt;
and the
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/bench/cpp/slowfil_tb.cpp&quot;&gt;test bench&lt;/a&gt; for
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/slowfil.v&quot;&gt;this filter&lt;/a&gt;,
you’ll see the changes we are about to discuss below.  You might even be
surprised at how much code is in common between the two.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/slowfil.v&quot;&gt;This&lt;/a&gt;
will, however, be the first
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;
that will test the fixed number of clocks
per input clock enable, &lt;code class=&quot;highlighter-rouge&quot;&gt;i_ce&lt;/code&gt;  associated with the sample value.  As it
turns out, we did a good job
&lt;a href=&quot;/dsp/2017/11/04/genfil-tb.html&quot;&gt;building the initial&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/bench/cpp/filtertb.cpp&quot;&gt;test harness&lt;/a&gt;,
so there’s not much that needs to be changed there.&lt;/p&gt;

&lt;p&gt;Second, unlike the
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/bench/cpp/genfil_tb.cpp&quot;&gt;prior filter&lt;/a&gt;, resetting this one so that all the memory is
zero requires more work than just setting the reset flag.  In particular,
the way block RAM’s are built, they cannot be cleared in a single clock.
As a result, we’ll need to write a routine to explicitly write zero samples to
the filter’s internal memory so that any test vector generator can start
from a known state.&lt;/p&gt;

&lt;p&gt;With those two caveats aside, let’s start looking at the code.&lt;/p&gt;

&lt;p&gt;As with any code using our &lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/bench/cpp/filtertb.cpp&quot;&gt;basic filtering test
bench&lt;/a&gt;,
it starts out be declaring constants shared between the
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/bench/cpp/filtertb.cpp&quot;&gt;test bench code&lt;/a&gt;
and the
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/slowfil.v&quot;&gt;filter&lt;/a&gt;
itself.  These include the number of bits in the input, the
coefficients, the output, the number of coefficients, the delay between
input and the first output resulting from that input, and the number of
clocks per input sample.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt;	&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;IW&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;16&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;TW&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;16&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;OW&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;IW&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;TW&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;7&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;NTAPS&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;110&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;DELAY&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;CKPCE&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NTAPS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;These values are not only declared as constants at the beginning of the
test bench, but they are also used to when initializing our test bench
class.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt;	&lt;span class=&quot;nc&quot;&gt;SLOWFIL&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_TB&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;FILTERTB&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Vslowfil&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;bool&lt;/span&gt;		&lt;span class=&quot;n&quot;&gt;m_done&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

	&lt;span class=&quot;n&quot;&gt;SLOWFIL_TB&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;IW&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;IW&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;TW&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;TW&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;OW&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;OW&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;NTAPS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NTAPS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;DELAY&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;DELAY&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;CKPCE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CKPCE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This is just normal setup though.  Now we need to get into the actual
details of the test bench changes.&lt;/p&gt;

&lt;p&gt;The first change that needs to be made is to the &lt;code class=&quot;highlighter-rouge&quot;&gt;test()&lt;/code&gt; routine.  This
routine, as you &lt;a href=&quot;/dsp/2017/11/04/genfil-tb.html&quot;&gt;may
remember&lt;/a&gt;,
takes an input data stream, applies the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;,
and returns the result.  It also depends upon the filter having a zero
internal state.  Since clearing the state in this
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/bench/cpp/filtertb.cpp&quot;&gt;test bench&lt;/a&gt;
is a little more awkward, we’ll make certain to call a function to make
certain the state is cleared before calling the &lt;code class=&quot;highlighter-rouge&quot;&gt;test()&lt;/code&gt; function in the
&lt;a href=&quot;/dsp/2017/11/04/genfil-tb.html&quot;&gt;test harness&lt;/a&gt;
itself.  The neat part of this change, though, is that by
&lt;a href=&quot;https://en.wikipedia.org/wiki/Method_overriding&quot;&gt;overloading&lt;/a&gt;,
this &lt;code class=&quot;highlighter-rouge&quot;&gt;test()&lt;/code&gt; operator and using
&lt;a href=&quot;https://en.wikipedia.org/wiki/Inheritance_(object-oriented_programming)&quot;&gt;inheritance&lt;/a&gt;,
this change only requires the following four lines of code.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;	&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;	&lt;span class=&quot;nf&quot;&gt;test&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nlen&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;clear_filter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;FILTERTB&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Vslowfil&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;test&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nlen&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Unlike the
&lt;a href=&quot;/dsp/2017/12/06/fastfir-tb.html&quot;&gt;other filters&lt;/a&gt;
we’ve tested, this one requires a reset prior to loading any
new &lt;a href=&quot;https://en.wikipedia.org/wiki/Impulse_response&quot;&gt;coefficients&lt;/a&gt;.  As
you may recall from above, resetting
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/slowfil.v&quot;&gt;this filter&lt;/a&gt;
sets the index into the coefficient memory back to zero, so it is an
important part of loading a new set of
&lt;a href=&quot;https://en.wikipedia.org/wiki/Impulse_response&quot;&gt;coefficients&lt;/a&gt;.  Just a
slight modification to the
&lt;a href=&quot;/dsp/2017/11/04/genfil-tb.html&quot;&gt;test bench&lt;/a&gt;,
and this change has now been made as well.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;	&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;	&lt;span class=&quot;nf&quot;&gt;load&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nlen&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;reset&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;FILTERTB&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Vslowfil&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;load&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nlen&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Perhaps the most important change, though, is the function that we need to
write to clear the data memory within
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/slowfil.v&quot;&gt;this filter&lt;/a&gt;.
We’ll call this function &lt;code class=&quot;highlighter-rouge&quot;&gt;clear_filter()&lt;/code&gt;.  It will work by
providing one clock with &lt;code class=&quot;highlighter-rouge&quot;&gt;i_ce&lt;/code&gt; high and &lt;code class=&quot;highlighter-rouge&quot;&gt;i_sample&lt;/code&gt; set to zero per element
in the memory array.  Since the array will always be a length given by a power
of two, the internal memory may also be longer than the number of
taps, &lt;code class=&quot;highlighter-rouge&quot;&gt;NTAPS()&lt;/code&gt; in
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/slowfil.v&quot;&gt;this filter&lt;/a&gt;.
For this reason, we’ll round up to the next power of two using &lt;code class=&quot;highlighter-rouge&quot;&gt;nextlg()&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;What may surprise you, though, is that we are going to hit
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/slowfil.v&quot;&gt;this filter&lt;/a&gt;
with one new sample per clock, while ignoring the output.  The result of this
will be that the output of this run will be invalid, although the new data will
loaded into he memory as desired.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;	&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;	&lt;span class=&quot;nf&quot;&gt;clear_filter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;m_core&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i_tap_wr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

		&lt;span class=&quot;c1&quot;&gt;// ..
&lt;/span&gt;		&lt;span class=&quot;n&quot;&gt;m_core&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i_ce&lt;/span&gt;     &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;m_core&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i_sample&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nextlg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NTAPS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;());&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;tick&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;As one final step, once the memory has been loaded, we’ll let the last sample
propagate through
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/slowfil.v&quot;&gt;the filter&lt;/a&gt;,
so as to make certain
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/slowfil.v&quot;&gt;the filter&lt;/a&gt;
is in a usable state when we apply our test vectors.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;		&lt;span class=&quot;n&quot;&gt;m_core&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i_ce&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CKPCE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;tick&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;At this point, all we need to do is switch our main program to running the
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/bench/cpp/slowfil_tb.cpp&quot;&gt;test bench&lt;/a&gt;
created for this new code, and everything is roughly the same as before.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;n&quot;&gt;SLOWFIL_TB&lt;/span&gt;	&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tb&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;	&lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;argc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;**&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;argv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;Verilated&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;commandArgs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;argc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;argv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;tb&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SLOWFIL_TB&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;How’s that for fairly simple?  Indeed, implementing the
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/slowfil.v&quot;&gt;filter itself&lt;/a&gt;
was harder than this
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/bench/cpp/slowfil_tb.cpp&quot;&gt;test bench&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Of course, it’s only that simple because of the work we’ve already done,
but that just underscores the power of
&lt;a href=&quot;https://en.wikipedia.org/wiki/Object-oriented_programming&quot;&gt;Object Oriented Programming (OOP)&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;example-traces&quot;&gt;Example Traces&lt;/h2&gt;

&lt;p&gt;If you’d like to see a trace of how this all works, there’s a commented line
in the
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/bench/cpp/slowfil_tb.cpp&quot;&gt;test bench&lt;/a&gt;,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;	&lt;span class=&quot;o&quot;&gt;//&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tb&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;opentrace&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;trace.vcd&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;which, if uncommented, will create a
&lt;a href=&quot;/blog/2017/07/31/vcd.html&quot;&gt;VCD file&lt;/a&gt;
containing a trace of what
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/slowfil.v&quot;&gt;this filter&lt;/a&gt;
does in response to the
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/bench/cpp/slowfil_tb.cpp&quot;&gt;test bench&lt;/a&gt;’s
stimulus.  Be careful–the trace can quickly
become hundreds of megabytes, if not several gigabytes, in length.&lt;/p&gt;

&lt;p&gt;Still, let’s turn that on to see if we can get a feel for how
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/slowfil.v&quot;&gt;this filter&lt;/a&gt;
works.  We’ll stop the
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/bench/cpp/slowfil_tb.cpp&quot;&gt;test bench&lt;/a&gt;
after the
&lt;a href=&quot;/blog/2017/07/31/vcd.html&quot;&gt;trace file&lt;/a&gt;
gets to about 28MB–which is still more than we need for this demo.  We
can then use
&lt;a href=&quot;https://gtkwave.sourceforge.net&quot;&gt;GTKwave&lt;/a&gt;
to display the results.  You can see a screen capture of the result
in Fig 6 below.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 6. Trace of the First Impulse Test&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/fir-slowfil-trace.png&quot; alt=&quot;&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;The figure shows several key steps in the
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/bench/cpp/slowfil_tb.cpp&quot;&gt;test bench&lt;/a&gt;.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;First, at the far left, &lt;code class=&quot;highlighter-rouge&quot;&gt;i_tap_wr&lt;/code&gt; is high for many clocks as the
coefficients (&lt;code class=&quot;highlighter-rouge&quot;&gt;i_tap&lt;/code&gt;) are loaded into the
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/slowfil.v&quot;&gt;filter&lt;/a&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The &lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/slowfil.v&quot;&gt;filter&lt;/a&gt;
is then &lt;em&gt;cleared&lt;/em&gt; by writing a series of (roughly) &lt;code class=&quot;highlighter-rouge&quot;&gt;NTAPS()&lt;/code&gt;
zeros into the memory.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The &lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/bench/cpp/slowfil_tb.cpp&quot;&gt;test bench&lt;/a&gt;
then applies an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Kronecker_delta&quot;&gt;impulse&lt;/a&gt; to the
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/slowfil.v&quot;&gt;filter&lt;/a&gt;,
to verify the &lt;a href=&quot;https://en.wikipedia.org/wiki/Impulse_response&quot;&gt;response&lt;/a&gt;.
Both &lt;a href=&quot;https://en.wikipedia.org/wiki/Kronecker_delta&quot;&gt;impulse&lt;/a&gt;
and coefficient value are negative maximums, to see if the
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/slowfil.v&quot;&gt;filter&lt;/a&gt;
will overflow as a result.  What that means, though, is that the
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/slowfil.v&quot;&gt;filter&lt;/a&gt;’s
output given these coefficients and this input will be a
single positive
&lt;a href=&quot;https://en.wikipedia.org/wiki/Kronecker_delta&quot;&gt;impulse&lt;/a&gt;,
as shown in the figure above.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Suppose we zoomed in some more on how
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/slowfil.v&quot;&gt;this filter&lt;/a&gt;
operated?  In this case, see Fig 7 below.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 7. Zooming in on the first test vector&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/fir-slowfil-trace-zoom.png&quot; alt=&quot;&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;At this zoom level, you can see how the various &lt;code class=&quot;highlighter-rouge&quot;&gt;CE&lt;/code&gt;s (really misnamed
valid signals) make their way through the system until the final &lt;code class=&quot;highlighter-rouge&quot;&gt;o_ce&lt;/code&gt; and
&lt;code class=&quot;highlighter-rouge&quot;&gt;o_result&lt;/code&gt; are valid.  You can also see the &lt;code class=&quot;highlighter-rouge&quot;&gt;pre_acc_ce[2:0]&lt;/code&gt; shift register
note when the tap index and data index became valid, &lt;code class=&quot;highlighter-rouge&quot;&gt;m_ce&lt;/code&gt;, when the memory
reads were valid, &lt;code class=&quot;highlighter-rouge&quot;&gt;d_ce&lt;/code&gt;, and when the products became valid, &lt;code class=&quot;highlighter-rouge&quot;&gt;p_ce&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The point here is, even if you are struggling to understand the code itself
above, sometimes a trace becomes easier to make sense of.&lt;/p&gt;

&lt;h2 id=&quot;conclusions&quot;&gt;Conclusions&lt;/h2&gt;

&lt;p&gt;This filtering approach is really quite powerful.  Not only were we able
to reduce the number of multiplies required in order to implement
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/slowfil.v&quot;&gt;this filter&lt;/a&gt;,
but we were also able to prove it using little more than the &lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/bench/cpp/filtertb.cpp&quot;&gt;test harness
code&lt;/a&gt;
we’ve already built.&lt;/p&gt;

&lt;p&gt;Remember the discussion we started out with regarding a 2047 tap
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;?
Such a &lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;
would be sufficient to generate a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Low-pass_filter&quot;&gt;lowpass&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;
with a 480Hz
&lt;a href=&quot;https://en.wikipedia.org/wiki/Passband&quot;&gt;passband&lt;/a&gt;,
a 176Hz transition band, and a 70dB stop band.  That’s probably
good enough for any audio work you might wish to do.&lt;/p&gt;

&lt;p&gt;That doesn’t mean
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/slowfil.v&quot;&gt;this&lt;/a&gt;
is the best (or worst)
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;
out there, just one to place into your tool box.  It has a purpose, and it
works well in its own niche.&lt;/p&gt;

&lt;p&gt;What other approaches might we have tried?&lt;/p&gt;

&lt;p&gt;I’ve mentioned for some time that I’d like to build and demonstrate a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Linear_phase&quot;&gt;symmetrical filter&lt;/a&gt;.
At high speed, that filter is now built and just waiting
for a good blog post.  Similarly, a fun challenge might be to modify
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/slowfil.v&quot;&gt;this filter&lt;/a&gt;
to handle
&lt;a href=&quot;https://en.wikipedia.org/wiki/Linear_phase&quot;&gt;symmetric coefficients&lt;/a&gt;,
something that would allow it to run twice as many coefficients at once.&lt;/p&gt;

&lt;p&gt;Another future
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;
that will be fun to present is what I’m going to call
a cascaded
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;.
By cascaded
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;, I mean one that
is basically identical to
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/slowfil.v&quot;&gt;this filter&lt;/a&gt;,
except that it allows multiple
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;s
of this type to be cascaded together in order to effectively create a &lt;em&gt;much&lt;/em&gt;
longer &lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;.
In many ways, this may seem like the holy grail of generic
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;
implementation–a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;
that can be adjusted to use only as many hardware multiplies
as it is required to use given the incoming data rate.&lt;/p&gt;

&lt;p&gt;Perhaps the ultimate
&lt;a href=&quot;https://en.wikipedia.org/wiki/Low-pass_filter&quot;&gt;lowpass&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;,
however, is the multirate implementation of a 
&lt;a href=&quot;https://en.wikipedia.org/wiki/Low-pass_filter&quot;&gt;lowpass&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;.
Using multirate techniques, it should be possible to apply a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Low-pass_filter&quot;&gt;lowpass&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt; of
any bandwidth to full speed data for a cost of only 10-12 multiplies.&lt;/p&gt;

&lt;p&gt;But these are all topics for another day.&lt;/p&gt;
&lt;hr /&gt;&lt;p&gt;&lt;em&gt;Then took Mary a pound of ointment of spikenard, very costly, and anointed the feet of Jesus, and wiped his feet with her hair: and the house was filled with the odour of the ointment. (John 12:3)&lt;/em&gt;</description>
        <pubDate>Sat, 30 Dec 2017 00:00:00 -0500</pubDate>
        <link>http://zipcpu.com/dsp/2017/12/30/slowfil.html</link>
        <guid isPermaLink="true">http://zipcpu.com/dsp/2017/12/30/slowfil.html</guid>
        
        
        <category>dsp</category>
        
      </item>
    
      <item>
        <title>Mystery post: The ugliest bug I&#39;ve ever encountered</title>
        <description>&lt;p&gt;I’ve been working with software most of my life–since long before I ever
went to &lt;a href=&quot;https://wp.stolaf.edu&quot;&gt;college&lt;/a&gt;.  Now, after several decades of
working with software, I’d like to think I may have learned something about
fixing bugs in software.&lt;/p&gt;

&lt;p&gt;I’ve learned to debug bugs by their patterns, and the more often I see the
same error lead to the same bug the more these patters are enforced in my mind.
Hence, any time the symptoms of a bug match a pattern I’ve seen before, I know
exactly where to look for the bug.  When younger programmers ask me why
their code isn’t working, I just match what’s going on to a pattern I’ve seen
in the past, and I can usually find any problem they might have quite quickly.&lt;/p&gt;

&lt;p&gt;I’ve got to believe I’m not alone in this approach, and that others have also
used this approach to debugging software as well.&lt;/p&gt;

&lt;p&gt;While this approach has served me well over time, there was one bug I
encountered recently that didn’t match &lt;em&gt;any&lt;/em&gt; of the patterns I’ve learned over
my many decades.&lt;/p&gt;

&lt;h2 id=&quot;the-symptoms&quot;&gt;The Symptoms&lt;/h2&gt;

&lt;p&gt;Are you ready to see if you can recognize this bug?  Think you can do it?
Here’s what I was looking at.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 1. Writing past the end of memory&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/past-end-of-memory.svg&quot; alt=&quot;&quot; width=&quot;320&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;The code crashed with a
  &lt;em&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_error&quot;&gt;bus error&lt;/a&gt;&lt;/em&gt;,
created by trying to access a non-existent memory address using the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Stack_register&quot;&gt;stack pointer&lt;/a&gt;.&lt;/p&gt;

    &lt;p&gt;This isn’t the first time I’ve ever had a computer program do the wrong
thing.  As a result, I design my
&lt;a href=&quot;/blog/2017/06/22/simple-wb-interconnect.html&quot;&gt;wishbone interconnects&lt;/a&gt;
to both return an &lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_error&quot;&gt;error&lt;/a&gt;
upon any attempt to read from a non-existent address, as well as to
record the address created the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_error&quot;&gt;error&lt;/a&gt;.
For this reason, I knew the address the
&lt;a href=&quot;/blog/2017/06/22/simple-wb-interconnect.html&quot;&gt;interconnect&lt;/a&gt;
was seeing–and it was indeed beyond the end of memory.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;If you looked through and followed the code, there should never have been a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_error&quot;&gt;bus error&lt;/a&gt;.
&lt;a href=&quot;http://www.gcc.org&quot;&gt;GCC&lt;/a&gt; had put the proper logic into the
code to calculate the correct address.  For some reason, the correct
address wasn’t getting calculated.  Indeed, if you examined the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt; state following the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_error&quot;&gt;bus error&lt;/a&gt;, the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Stack_register&quot;&gt;stack pointer&lt;/a&gt; wasn’t
pointing to the right value.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;If I used the
&lt;a href=&quot;/zipcpu/2017/08/25/hw-debugging.html&quot;&gt;debugger&lt;/a&gt;
to step through the code, there would be no error.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Any attempt to add a debugging statement prior to the bug would keep the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt; from getting a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_error&quot;&gt;bus error&lt;/a&gt; at that instruction.&lt;/p&gt;

    &lt;p&gt;This includes both the &lt;code class=&quot;highlighter-rouge&quot;&gt;BREAK&lt;/code&gt; instruction as well any instructions which
might have been used to trigger the
&lt;a href=&quot;https://github.com/ZipCPU/wbscope&quot;&gt;wishbone scope&lt;/a&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;In my frustration at one point while I was trying to figure out what the
problem was, I decided to try Voodoo computing.&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;Defn: Voodoo computing, verb: The process of fixing what isn’t broken in 
an attempt to fix what is.  It is similar to &lt;a href=&quot;https://en.wikipedia.org/wiki/Cargo_cult&quot;&gt;Cargo
Cult&lt;/a&gt; programming.&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;p&gt;So I restarted the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; from
the beginning of the program.  (This was a warm reboot, not a cold one from
no power.)  On this second program start, the code executed as designed and
the program failed elsewhere.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Confused yet?  I certainly was.  Let me show you what the code looked like.&lt;/p&gt;

&lt;h2 id=&quot;the-software-in-question&quot;&gt;The Software in Question&lt;/h2&gt;

&lt;p&gt;The code that failed was the very first function call following a reboot.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 2. Initial stack pointer&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/initial-stack-pointer.svg&quot; alt=&quot;&quot; width=&quot;240&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;The &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; would start
at the reset address and it would load the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Stack_register&quot;&gt;stack pointer&lt;/a&gt;
with a reference to the end of memory.  While both of these are configurable
addresses within the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; infrastructure, inspecting
the code confirmed that the &lt;a href=&quot;http://www.gnu.org/software/binutils/&quot;&gt;assembler and
linker&lt;/a&gt; had done their jobs correctly.
After a couple of other instructions upon
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt; startup, the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt; would then jump to this
&lt;code class=&quot;highlighter-rouge&quot;&gt;first_subroutine&lt;/code&gt; and quickly fail.&lt;/p&gt;

&lt;p&gt;Here’s what those first few instructions looked like,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-assembly&quot; data-lang=&quot;assembly&quot;&gt;reset_address:
	; Load the stack pointer with the address of the very last location
	; in memory.  (LDI = load immediate, SP = stack pointer)
	LDI	#end_of_memory,SP
	; ... some other setup lines
	JSR	first_subroutine
	; ... code continues&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The &lt;code class=&quot;highlighter-rouge&quot;&gt;LDI&lt;/code&gt; instruction within the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
can load an arbitrary value into any register over the course of up to two
instructions.  Specifically, it takes one instruction for anything up to
23-bits, and two instructions for anything longer.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 3. The first Stack Frame&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/initial-stack-frame.svg&quot; alt=&quot;&quot; width=&quot;240&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;The program then jumped to a subroutine.  This involves copying the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Program_counter&quot;&gt;program counter&lt;/a&gt;,
&lt;code class=&quot;highlighter-rouge&quot;&gt;PC&lt;/code&gt;, into the &lt;code class=&quot;highlighter-rouge&quot;&gt;R0&lt;/code&gt; general purpose register, and then jumping to the address
given–in this case the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt;
jumped to &lt;code class=&quot;highlighter-rouge&quot;&gt;first_subroutine&lt;/code&gt;.  (I’ve since forgotten the subroutine’s actual
name.)&lt;/p&gt;

&lt;p&gt;The first several instructions in the &lt;code class=&quot;highlighter-rouge&quot;&gt;first_subroutine&lt;/code&gt; were much like any
other subroutine.  They created a stack frame by subtracting a value from the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Stack_register&quot;&gt;stack pointer&lt;/a&gt;–adjusting
it to point earlier in memory.  This creates an area in memory where the
program can hold local variables, commonly called
a &lt;a href=&quot;https://en.wikipedia.org/wiki/Call_stack&quot;&gt;stack frame&lt;/a&gt;.  The program
then attempted to save some registers to this new
&lt;a href=&quot;https://en.wikipedia.org/wiki/Call_stack&quot;&gt;stack frame&lt;/a&gt;.
In assembly, this looked like,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;first_subroutine:
	SUB	16,SP	; Create a stack fromm, subtracting 16 from SP
	SW	R0,(SP)	; Store R0 into the first position in the stack frame
	SW	R1,4(SP); BUS ERROR HERE!!!!&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;If you’ve never seen
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
assembly before, it reads from left to right, with the destination of the
instruction on the right.  Hence &lt;code class=&quot;highlighter-rouge&quot;&gt;SUB 16,SP&lt;/code&gt; subtracts sixteen from the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Stack_register&quot;&gt;stack pointer&lt;/a&gt;
and places the result back into the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Stack_register&quot;&gt;stack pointer&lt;/a&gt;.
Likewise &lt;code class=&quot;highlighter-rouge&quot;&gt;SW R0,(SP)&lt;/code&gt; stores the value of &lt;code class=&quot;highlighter-rouge&quot;&gt;R0&lt;/code&gt; into the address given by the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Stack_register&quot;&gt;stack pointer&lt;/a&gt;,
and &lt;code class=&quot;highlighter-rouge&quot;&gt;SW R1,4(SP)&lt;/code&gt; does roughly the same thing, with the
exception that &lt;code class=&quot;highlighter-rouge&quot;&gt;R1&lt;/code&gt; is saved into the location four bytes later.  Of these
three instructions, only the &lt;code class=&quot;highlighter-rouge&quot;&gt;SUB&lt;/code&gt;tract instruction modifies the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Stack_register&quot;&gt;stack pointer&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;If I pulled the code up in a
&lt;a href=&quot;/zipcpu/2017/08/25/hw-debugging.html&quot;&gt;debugger&lt;/a&gt; following
this &lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_error&quot;&gt;bus error&lt;/a&gt;,
the &lt;a href=&quot;https://en.wikipedia.org/wiki/Stack_register&quot;&gt;stack pointer&lt;/a&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;SP&lt;/code&gt;
would have the value given by the &lt;code class=&quot;highlighter-rouge&quot;&gt;end_of_memory&lt;/code&gt; value it was initially
loaded with.  It was as though the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Call_stack&quot;&gt;stack frame&lt;/a&gt;
was never created, despite the &lt;code class=&quot;highlighter-rouge&quot;&gt;SUB 16,SP&lt;/code&gt; instruction.&lt;/p&gt;

&lt;p&gt;When the 
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; then tried to write into this
&lt;a href=&quot;https://en.wikipedia.org/wiki/Call_stack&quot;&gt;stack frame&lt;/a&gt;,
it would write past the end of memory.
Depending on whether &lt;code class=&quot;highlighter-rouge&quot;&gt;end_of_memory&lt;/code&gt; pointed to the last address
in memory (where I commonly set it), or just past the end of memory would
then determine whether storing &lt;code class=&quot;highlighter-rouge&quot;&gt;R0&lt;/code&gt; to the location in the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Stack_register&quot;&gt;stack pointer&lt;/a&gt;
caused the &lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_error&quot;&gt;bus error&lt;/a&gt;
or whether it was storing &lt;code class=&quot;highlighter-rouge&quot;&gt;R1&lt;/code&gt; to the location 4 bytes later
that caused the &lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_error&quot;&gt;bus error&lt;/a&gt;.
Either way, the code caused a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_error&quot;&gt;bus error&lt;/a&gt;
and none of it made any sense to me.&lt;/p&gt;

&lt;p&gt;Before reading any further, think about the description above, and then ask
yourself: does this match any bug pattern you’ve ever seen before?  The program
fails the first time it is tried, but not the second–but then it would fail
on the third time.  Any attempt to add debugging code kept this error from
happening.&lt;/p&gt;

&lt;p&gt;Oh, and let me give you a hint: I was running my own code, on my own
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;, within an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Any ideas?&lt;/p&gt;

&lt;h2 id=&quot;what-was-it&quot;&gt;What was it?&lt;/h2&gt;

&lt;p&gt;In many ways, I was at a loss to figure out the problem until I started
up the program in a &lt;a href=&quot;https://www.veripool.org/wiki/verilator&quot;&gt;Verilator&lt;/a&gt;
&lt;a href=&quot;/blog/2017/06/21/looking-at-verilator.html&quot;&gt;based&lt;/a&gt;
&lt;a href=&quot;/zipcpu/2017/07/26/cpu-sim-debugger.html&quot;&gt;simulation&lt;/a&gt;.
(Yes, I know, I was running code that I hadn’t &lt;a href=&quot;/blog/2017/06/23/my-dbg-philosophy.html&quot;&gt;simulated first&lt;/a&gt;–&lt;a href=&quot;/blog/2017/06/02/design-process.html&quot;&gt;shame
on me&lt;/a&gt;.)  Once
I saw the bug take place within the
&lt;a href=&quot;/zipcpu/2017/07/26/cpu-sim-debugger.html&quot;&gt;simulator&lt;/a&gt;,
I knew I could find it quickly.&lt;/p&gt;

&lt;p&gt;As it turned out, the problem lied in the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/pfcache.v&quot;&gt;prefetch and instruction cache
module&lt;/a&gt;.  This
module was declaring that an
&lt;a href=&quot;/zipcpu/2017/11/18/wb-prefetch.html&quot;&gt;instruction was valid&lt;/a&gt;
one clock cycle before the cache logic had finished writing that instruction
into the cache.  In this case, there was often a &lt;code class=&quot;highlighter-rouge&quot;&gt;NOOP&lt;/code&gt; in the cache
instead of the &lt;code class=&quot;highlighter-rouge&quot;&gt;SUB 16,SP&lt;/code&gt; instruction.  Hence, when the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt; was erroneously given the
&lt;code class=&quot;highlighter-rouge&quot;&gt;NOOP&lt;/code&gt; instruction, the &lt;a href=&quot;https://en.wikipedia.org/wiki/Stack_register&quot;&gt;stack
pointer&lt;/a&gt;,
&lt;code class=&quot;highlighter-rouge&quot;&gt;SP&lt;/code&gt;, remained where it was–pointing to the end of memory.  The subsequent
&lt;code class=&quot;highlighter-rouge&quot;&gt;SW&lt;/code&gt; (store word) instruction then wrote past the end of memory, which then
triggered the &lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_error&quot;&gt;bus error&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;I’ve tried to draw this in Fig 4 below.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 4. Reading from the cache one clock too early&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/ugliest-bug.svg&quot; alt=&quot;&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;The figure shows a single
&lt;a href=&quot;https://en.wikipedia.org/wiki/CPU_cache#CACHE-LINES&quot;&gt;cache line&lt;/a&gt;.  The
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/pfcache.v&quot;&gt;prefetch/i-cache&lt;/a&gt;
module was filling that cache line with valid instructions.  It had filled
all but the last instruction, when it then declared the instruction was
valid.  Then, as it filled that last instruction with &lt;code class=&quot;highlighter-rouge&quot;&gt;SUB 16,SP&lt;/code&gt;, the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt;
read the &lt;code class=&quot;highlighter-rouge&quot;&gt;NOOP&lt;/code&gt; instruction that had been there one clock earlier, hence
leading to the bug.&lt;/p&gt;

&lt;p&gt;Had the subroutine’s first instruction landed anywhere else in the cache line,
being one clock early wouldn’t have mattered–since those locations would’ve
already been filled by the cache logic at that point.  This particular location
in the cache line made this appear to be one of those “phantom” bugs–bugs
that manifest at some times but not at others.  It also made it harder to
discover–as discussed above.&lt;/p&gt;

&lt;p&gt;So let’s go back through those symptoms and explain what happened, shall we?&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;We just explained why the 
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_error&quot;&gt;bus error&lt;/a&gt; took place–the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Stack_register&quot;&gt;stack pointer&lt;/a&gt; never
got updated, and so the program tried to write off the end of memory.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Although the &lt;code class=&quot;highlighter-rouge&quot;&gt;SUB 16,SP&lt;/code&gt; instruction was present in the code, the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/pfcache.v&quot;&gt;prefetch&lt;/a&gt;
returned a no operation instruction (&lt;code class=&quot;highlighter-rouge&quot;&gt;NOOP&lt;/code&gt;) to the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt;,
so this subtract was never executed–leaving the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Stack_register&quot;&gt;stack pointer&lt;/a&gt; pointing
to the end of memory.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The &lt;a href=&quot;/zipcpu/2017/08/25/hw-debugging.html&quot;&gt;debugger&lt;/a&gt; never
had a problem because it it operated at a much slower speed than the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt; was capable of operating.  This
gave the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt; in single stepping
mode enough time to load the cache before trying to read from the last
address in the
&lt;a href=&quot;https://en.wikipedia.org/wiki/CPU_cache#CACHE-LINES&quot;&gt;cache line&lt;/a&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;If I placed another instruction anywhere before the subtract in the
program’s instruction stream, then the &lt;code class=&quot;highlighter-rouge&quot;&gt;SUB 16,SP&lt;/code&gt; instruction would no
longer be the last element in a
&lt;a href=&quot;https://en.wikipedia.org/wiki/CPU_cache#CACHE-LINES&quot;&gt;cache line&lt;/a&gt;,
and there wouldn’t be any timing error.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;If I restarted the computer after this failure, the &lt;code class=&quot;highlighter-rouge&quot;&gt;SUB 16,SP&lt;/code&gt; instruction
would already be in the cache.  Hence, when the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/pfcache.v&quot;&gt;prefetch&lt;/a&gt;
declared the instruction to be valid one clock too early, it would still
read what was in the cache from the last time, i.e. the &lt;code class=&quot;highlighter-rouge&quot;&gt;SUB 16,SP&lt;/code&gt;
instruction.&lt;/p&gt;

    &lt;p&gt;That the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt; then failed somewhere
else should come as no surprise, when there is a bug of this type within
its code.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;This bug was so strange, and so different, that I though it would be fun to
share here.  I hope you enjoyed it.&lt;/p&gt;

&lt;h2 id=&quot;lessons-learned&quot;&gt;Lessons Learned&lt;/h2&gt;

&lt;p&gt;So what are some of the lessons I learned from this bug?&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;I learned the value of the
&lt;a href=&quot;/zipcpu/2017/07/26/cpu-sim-debugger.html&quot;&gt;simulator&lt;/a&gt;.
&lt;a href=&quot;/blog/2017/07/08/getting-started-with-wbscope.html&quot;&gt;Traces&lt;/a&gt;
taken using the
&lt;a href=&quot;https://github.com/ZipCPU/wbscope&quot;&gt;wishbone scope&lt;/a&gt;
just didn’t have enough information within them to permit me to recognize
the bug quickly.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;I (re)learned the fact that &lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;not all test benches will
catch all bugs&lt;/a&gt;..
This bug was not caught by my &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/sim/verilator/pfcache_tb.cpp&quot;&gt;prefetch testbench&lt;/a&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;I learned to place several cache testing pieces of code into my
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt; &lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/sw/board/cputest.c&quot;&gt;testing
program&lt;/a&gt;.
As a result, were this bug ever to show again, I’d detect it early on.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Even after all of this, I never quite trusted my &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/pfcache.v&quot;&gt;prefetch and cache
code&lt;/a&gt;
until some time later when I formally proved that it worked.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Perhaps you’d like to see that formal proof?  I’d love to share it!  However,
that will have to wait for another day and another post.&lt;/p&gt;
&lt;hr /&gt;&lt;p&gt;&lt;em&gt;Be thou diligent to know the state of thy flocks, and look well to thy herds.  (Prov 27:23)&lt;/em&gt;</description>
        <pubDate>Thu, 28 Dec 2017 00:00:00 -0500</pubDate>
        <link>http://zipcpu.com/zipcpu/2017/12/28/ugliest-bug.html</link>
        <guid isPermaLink="true">http://zipcpu.com/zipcpu/2017/12/28/ugliest-bug.html</guid>
        
        
        <category>zipcpu</category>
        
      </item>
    
  </channel>
</rss>
