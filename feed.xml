<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>The ZipCPU by Gisselquist Technology</title>
    <description>The ZipCPU blog, featuring how to discussions of FPGA and soft-core CPU design.  This site will be focused on Verilog solutions, using exclusively OpenSource IP products for FPGA design.  Particular focus areas include topics often left out of more mainstreeam FPGA design courses such as how to debug an FPGA design.
</description>
    <link>https://zipcpu.com/</link>
    <atom:link href="https://zipcpu.com/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Mon, 04 Jun 2018 16:48:31 -0400</pubDate>
    <lastBuildDate>Mon, 04 Jun 2018 16:48:31 -0400</lastBuildDate>
    <generator>Jekyll v3.0.1</generator>
    <image>
      <url>https://zipcpu.com/img/gt-rss.png</url>
      <title></title>
      <link></link>
    </image>
    
      <item>
        <title>Formally Verifying Asynchronous Components</title>
        <description>&lt;p&gt;To date, our formal verification efforts have primarily centered around
&lt;em&gt;synchronous&lt;/em&gt; designs using
&lt;a href=&quot;https://www.clifford.at/yosys&quot;&gt;yosys&lt;/a&gt;,
that is those designs where all logic transitions on the same clock edge,
rather than looking at
&lt;em&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Asynchronous_circuit&quot;&gt;asynchronous&lt;/a&gt;&lt;/em&gt;
designs.
The one exception so far has been the description of how to get an
&lt;a href=&quot;/formal/2018/04/12/areset.html&quot;&gt;asynchronous reset&lt;/a&gt;
to pass induction.  I’d like to move beyond this simple example towards
verifying a full &lt;a href=&quot;http://www.sunburst-design.com/papers/CummingsSNUG2002SJ_FIFO1.pdf&quot;&gt;asynchronous FIFO
design&lt;/a&gt;,
but that’s going to require a bit more background in how to
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formally verify&lt;/a&gt; an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Asynchronous_circuit&quot;&gt;asynchronous&lt;/a&gt;
design in general.  Today, therefore, let’s examine how to
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formally verify&lt;/a&gt; an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Asynchronous_circuit&quot;&gt;asynchronous&lt;/a&gt;
component that
&lt;a href=&quot;/blog/2017/10/20/cdc.html&quot;&gt;crosses between clock domains&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;If you aren’t familiar with
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal verification&lt;/a&gt;,
you might wish to go back and review our
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;introductory article&lt;/a&gt;
on the topic.  You might also find the
&lt;a href=&quot;/blog/2018/03/10/induction-exercise.html&quot;&gt;induction exercise&lt;/a&gt;
to be valuable as well.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 1. A Clock Switch Component&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/ckswitch-blkdiag.svg&quot; alt=&quot;&quot; width=&quot;360&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Today, let’s demonstrate how these same
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal verification&lt;/a&gt;
concepts apply an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Asynchronous_circuit&quot;&gt;asynchronous&lt;/a&gt;
design with two clocks within it.  In this
case, we’ll examine a clock switch.  Such a switch takes two clock inputs
and one line to select between them.  In our case, the two separate clocks
makes a perfect example of how
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal methods&lt;/a&gt;
can be applied to an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Asynchronous_circuit&quot;&gt;asynchronous&lt;/a&gt;
design.&lt;/p&gt;

&lt;h1 id=&quot;two-clocks&quot;&gt;Two Clocks&lt;/h1&gt;

&lt;p&gt;The first and most important step is to somehow describe both clocks via
formal properties to the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Satisfiability_modulo_theories&quot;&gt;SMT solver&lt;/a&gt;.
This step is really independent
of anything you might wish to verify, and it applies to any
&lt;a href=&quot;https://en.wikipedia.org/wiki/Asynchronous_circuit&quot;&gt;asynchronous&lt;/a&gt;
design.  Once you learn the simple trick involved, you’ll then notice that
other &lt;a href=&quot;https://en.wikipedia.org/wiki/Asynchronous_circuit&quot;&gt;asynchronous&lt;/a&gt;
verification proofs follow the exact same approach.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: left&quot;&gt;&lt;caption&gt;Fig 2. The Master rule of Formal Verification&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/fv-master-rule.svg&quot; alt=&quot;&quot; width=&quot;240&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;Specifically, we need to provide some assumptions to describe the two clocks
which will be the inputs to our clock switch design.  Why assumptions?
Because these clocks will be inputs, and the basic rule is that you should
always make assumptions about your inputs, and assertions about your local
state and any outputs.&lt;/p&gt;

&lt;p&gt;Perhaps you may remember our earlier discussion of how to create a &lt;a href=&quot;/blog/2017/06/02/generating-timing.html&quot;&gt;fractional
clock divider&lt;/a&gt;?
In &lt;a href=&quot;/blog/2017/06/02/generating-timing.html&quot;&gt;that article&lt;/a&gt;,
we used the top bit of a counter as a divided clock.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(posedge i_clk)
		counter &amp;lt;= counter + increment;

	assign divided_clock = counter[MSB];&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Clocks like this one that are generated from logic are often called
&lt;em&gt;logic&lt;/em&gt; &lt;em&gt;clocks&lt;/em&gt;.  Logic clocks are distinguished from regular clocks in that
are generated from logic within the design, rather than external hardware or
internal
&lt;a href=&quot;https://en.wikipedia.org/wiki/Phase-locked_loop&quot;&gt;PLL&lt;/a&gt;s,
and are then distributed across the design and used
like a clock.  In general, you don’t want to transition on the positive or
negative edge of any logic clock.  Doing so will make it
harder to achieve timing closure, and it will add additional
&lt;a href=&quot;/blog/2017/10/20/cdc.html&quot;&gt;clock domain crossing&lt;/a&gt;
requirements to your design.
Further, if this divided clock isn’t placed on the clock network, then
it might be seen to rise (or fall) at inconsistent times across the design.&lt;/p&gt;

&lt;p&gt;All of these are “bad” hardware consequences.&lt;/p&gt;

&lt;p&gt;None of these problems, however, will keep us from using the transitions of
this divided clock as a &lt;em&gt;&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal
constraint&lt;/a&gt;&lt;/em&gt;
on our clock input, so that’s exactly what we are about to do.&lt;/p&gt;

&lt;p&gt;We’ll start out by creating counters, &lt;code class=&quot;highlighter-rouge&quot;&gt;f_*_count&lt;/code&gt;, and increments,
&lt;code class=&quot;highlighter-rouge&quot;&gt;f_*_step&lt;/code&gt;, for each input clock.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	wire	[F_CKSTEP-1:0]	f_a_step,  f_b_step;
	reg	[F_CKSTEP-1:0]	f_a_count, f_b_count;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;In order to handle properties associated with any particular speed, we’ll allow
these increments to be completely arbitrary.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	assign	f_a_step = $anyconst;
	assign	f_b_step = $anyconst;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The &lt;code class=&quot;highlighter-rouge&quot;&gt;$anyconst&lt;/code&gt; description is specific to
&lt;a href=&quot;https://www.clifford.at/yosys&quot;&gt;yosys&lt;/a&gt;.
It means that these values will have a constant value given to
them–any value.  It’s roughly the same as having an extra unconstrained
input to the design and then forcing it to be &lt;code class=&quot;highlighter-rouge&quot;&gt;$stable&lt;/code&gt;.  Alternatively,
you can think of it as a register with no initial statement that doesn’t
produce a
&lt;a href=&quot;https://www.clifford.at/yosys&quot;&gt;yosys&lt;/a&gt;
warning on synthesis.&lt;/p&gt;

&lt;p&gt;However, these arbitrary constant values aren’t quite what we want yet.
For example, any increment having a zero value would indicate a clock
that doesn’t tick. 
This is bad, so we’ll force the increments to be greater than zero.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(*)
		assume(f_a_step &amp;gt; 0);

	always @(*)
		assume(f_b_step &amp;gt; 0);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;In a similar fashion, we can also constrain the clocks so that the fastest
one, whichever that one might be, takes four simulation time steps per cycle.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(*)
		assume((f_a_step[F_CKSTEP-1:F_CKSTEP-2] == 2&#39;b01)
			||(f_b_step[F_CKSTEP-1:F_CKSTEP-2] == 2&#39;b01));&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This will help make certain that there is always a positive edge to the clock
at least once per cycle.&lt;/p&gt;

&lt;p&gt;Now that we have an increment, we just add this increment to our counters on
every formal step–one counter per incoming clock.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @($global_clock)
	begin
		f_a_count &amp;lt;= f_a_count + f_a_step;
		f_b_count &amp;lt;= f_b_count + f_b_step;
	end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Let me draw your attention to the &lt;code class=&quot;highlighter-rouge&quot;&gt;$global_clock&lt;/code&gt; statement within the always
header.  In
&lt;a href=&quot;https://en.wikipedia.org/wiki/SystemVerilog&quot;&gt;SystemVerilog&lt;/a&gt;,
this value needs to be declared earlier in the file
as a positive or negative edge trigger based upon some pre-existing clock.
&lt;a href=&quot;https://www.clifford.at/yosys&quot;&gt;Yosys&lt;/a&gt;,
however, extends this behavior by making &lt;code class=&quot;highlighter-rouge&quot;&gt;$global_clock&lt;/code&gt; the
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal verification&lt;/a&gt;
time step.  Every time step is now examined by the formal engine,
not just those times described by an edge of a clock but intermediate times
as well.  It’s for this reason that we can use &lt;code class=&quot;highlighter-rouge&quot;&gt;$global_clock&lt;/code&gt; in this
circumstance.  Indeed, &lt;code class=&quot;highlighter-rouge&quot;&gt;$global_clock&lt;/code&gt; is one of the keys to this whole
operation.&lt;/p&gt;

&lt;p&gt;Our last formal property will be to assume that our incoming clock signals
are identical to the most significant bits of our counters.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(*)
		assume(i_clk_a = f_a_count[F_CKSTEP-1]);

	always @(*)
		assume(i_clk_b = f_b_count[F_CKSTEP-1]);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Simple enough?  We’ve just assumed the presence of two dissimilar clocks
coming into our design.  We’ve also allowed them to have arbitrary phases
and frequencies with respect to each other.&lt;/p&gt;

&lt;p&gt;There is one more required piece of
&lt;a href=&quot;https://www.clifford.at/yosys&quot;&gt;yosys&lt;/a&gt;,
magic, you’ll need to add &lt;code class=&quot;highlighter-rouge&quot;&gt;clk2fflogic&lt;/code&gt; to your
&lt;a href=&quot;https://www.clifford.at/yosys&quot;&gt;yosys&lt;/a&gt;
script file.  Alternatively, if you are using
&lt;a href=&quot;https://symbiyosys.readthedocs.io/en/latest&quot;&gt;SymbiYosys&lt;/a&gt;,
you can instead add &lt;code class=&quot;highlighter-rouge&quot;&gt;multiclock on&lt;/code&gt; to the options section.  You can
see an example of this
&lt;a href=&quot;https://symbiyosys.readthedocs.io/en/latest&quot;&gt;SymbiYosys&lt;/a&gt; &lt;a href=&quot;https://github.com/ZipCPU/website/blob/master/examples/clkswitch.sby&quot;&gt;script
here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;No more setup work is required–we’ve just formally assumed the existence of
two separate and dissimilar clock inputs.  In the next section, we’ll examine a
&lt;a href=&quot;https://github.com/ZipCPU/website/blob/master/examples/clkswitch.v&quot;&gt;clock switch
design&lt;/a&gt;
and discuss how we might
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formally verify&lt;/a&gt;
that it is glitch free.&lt;/p&gt;

&lt;h1 id=&quot;a-clock-switch&quot;&gt;A Clock Switch&lt;/h1&gt;

&lt;p&gt;At this point in our article, I usually present a working design that would
use the principle under discussion and
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal verify&lt;/a&gt; it.
Sadly, I only have a couple of
&lt;a href=&quot;https://en.wikipedia.org/wiki/Asynchronous_circuit&quot;&gt;asynchronous&lt;/a&gt;
designs to share.  I just haven’t had the need to build
that many.  That said, neither my formal proof of
&lt;a href=&quot;http://www.sunburst-design.com/papers/CummingsSNUG2002SJ_FIFO1.pdf&quot;&gt;Cliff Cumming’s asynchronous
FIFO&lt;/a&gt;
design, nor the &lt;a href=&quot;https://github.com/ZipCPU/wbuart32/blob/dev/rtl/rxuartlite.v&quot;&gt;proof of my
UART receiver&lt;/a&gt;
would be appropriate for a beginning blog post on
&lt;a href=&quot;https://en.wikipedia.org/wiki/Asynchronous_circuit&quot;&gt;asynchronous&lt;/a&gt;
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal verification&lt;/a&gt;
despite the fact that both proofs use the techniques discussed here.&lt;/p&gt;

&lt;p&gt;So let’s try something simpler.  Let’s instead examine a &lt;a href=&quot;https://github.com/ZipCPU/website/blob/master/examples/clkswitch.v&quot;&gt;clock
switch&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;A &lt;a href=&quot;https://github.com/ZipCPU/website/blob/master/examples/clkswitch.v&quot;&gt;clock
switch&lt;/a&gt;
is a design component that takes two clock inputs and a switch
input, and produces one of the two clocks as its output dependent upon how
the switch is set.
It’s not something an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
designer normally needs to build, since most
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
vendor libraries provide similar components which will be known
to work on their parts.  As an example, Xilinx offers a 
&lt;a href=&quot;https://www.xilinx.com/support/documentation/user_guides/ug472_7Series_Clocking.pdf&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;BUFGMUX&lt;/code&gt; design element&lt;/a&gt;
with similar capabilities.  However, for today’s purpose, 
a &lt;a href=&quot;https://github.com/ZipCPU/website/blob/master/examples/clkswitch.v&quot;&gt;clock
switch&lt;/a&gt;
design makes a perfect example of an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Asynchronous_circuit&quot;&gt;asynchronous&lt;/a&gt;
design which can be
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formally verified&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/ZipCPU/website/blob/master/examples/clkswitch.v&quot;&gt;Clock
switches&lt;/a&gt;
are very important parts of a failsafe designs.  A failsafe
design can start with one clock and then switch to the second clock once it
stabilizes.  In a similar fashion, if the second clock becomes unstable or
otherwise unusable, then the
&lt;a href=&quot;https://github.com/ZipCPU/website/blob/master/examples/clkswitch.v&quot;&gt;clock
switch&lt;/a&gt;
should return the design to the original clock.  A third use for a &lt;a href=&quot;https://github.com/ZipCPU/website/blob/master/examples/clkswitch.v&quot;&gt;clock
switch&lt;/a&gt;
would be in a
power sensitive design.  In such a power sensitive design, the clock
might be switched between a fast and a slow clock in order to control how
much power the design is using at any given time.&lt;/p&gt;

&lt;p&gt;So, how would you build a
&lt;a href=&quot;https://github.com/ZipCPU/website/blob/master/examples/clkswitch.v&quot;&gt;clock
switch&lt;/a&gt;?&lt;/p&gt;

&lt;p&gt;A straight forward &lt;a href=&quot;https://github.com/ZipCPU/website/blob/master/examples/clkswitch.v&quot;&gt;clock
switch&lt;/a&gt;
design might look like,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(*)
	if (i_sel)
		o_clk = i_clk_a;
	else
		o_clk = i_clk_b;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Sadly, this doesn’t work.  The problem is that the switch input &lt;code class=&quot;highlighter-rouge&quot;&gt;i_sel&lt;/code&gt;
is &lt;a href=&quot;https://en.wikipedia.org/wiki/Asynchronous_circuit&quot;&gt;asynchronous&lt;/a&gt;
to at least one of the two clock domains if not both.
The output clock period might therefore be something other than the
period of either clock if &lt;code class=&quot;highlighter-rouge&quot;&gt;i_sel&lt;/code&gt; changes mid clock.  Worse, the period
could easily be shorter then the minimum pulse width of this design.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 3. A Clock switching circuit&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/clock-switch.svg&quot; alt=&quot;&quot; width=&quot;560&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;A little googling turns up
&lt;a href=&quot;https://www.eetimes.com/document.asp?doc_id=1202359&quot;&gt;a fascinating article&lt;/a&gt;
on &lt;a href=&quot;https://www.eetimes.com&quot;&gt;EE Times&lt;/a&gt; discussing, “&lt;a href=&quot;https://www.eetimes.com/document.asp?doc_id=1202359&quot;&gt;Techniques to make clock
switching glitch free&lt;/a&gt;.”
In &lt;a href=&quot;https://www.eetimes.com/document.asp?doc_id=1202359&quot;&gt;the article&lt;/a&gt;,
Mahmud provides just the logic we need.&lt;/p&gt;

&lt;p&gt;According to
&lt;a href=&quot;https://www.eetimes.com/document.asp?doc_id=1202359&quot;&gt;the article&lt;/a&gt;,
the key piece we are missing is a pair of
&lt;a href=&quot;/blog/2017/10/20/cdc.html&quot;&gt;synchronizers&lt;/a&gt;.
Since the clock select input isn’t guaranteed to be synchronous to
either clock, it must be &lt;a href=&quot;/blog/2017/10/20/cdc.html&quot;&gt;synchronized into each
clock’s domain&lt;/a&gt;.  Once the
clock select line has been split and synchronized into each respective
clock domain, the output clock can then be synthesized by &lt;code class=&quot;highlighter-rouge&quot;&gt;and&lt;/code&gt;ing each
leg of the clock domain with its respective enable, and &lt;code class=&quot;highlighter-rouge&quot;&gt;or&lt;/code&gt;ing the
result together.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;assign	o_clk = ((a_sel)&amp;amp;&amp;amp;(i_clk_a))
		||((b_sel)&amp;amp;&amp;amp;(i_clk_b));&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This sounds simple enough.  Indeed, the article and the picture are so clear
that writing out the design is quite straightforward.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;module clkswitch(i_clk_a, i_clk_b, i_areset_n, i_sel, o_clk);
	input	wire	i_clk_a, i_clk_b;
	input	wire	i_areset_n;
	input	wire	i_sel;
	output	wire	o_clk;

	reg		aff, bff, a_sel, b_sel;

	// First half of the synchronizer for A
	//
	// Set aff on the positive edge of clock A
	initial aff = 0;
	always @(posedge i_clk_a, negedge i_areset_n)
	if (!i_areset_n)
		aff = 1;
	else
		aff &amp;lt;= (i_sel)&amp;amp;&amp;amp;(!b_sel);

	// Second half of the synchronizer for A
	//
	// Set a_sel based upon the negative edge of clock A
	//
	initial a_sel = 0;
	always @(negedge i_clk_a, negedge i_areset_n)
	if (!i_areset_n)
		a_sel = 1;
	else
		a_sel &amp;lt;= aff;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Notice that this synchronizer uses both edges of the clock to synchronize
on.  This would be a bad idea in an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;,
since you have no control over how far apart the design elements are.
However, this isn’t quite the same problem on an
&lt;a href=&quot;/blog/2017/10/13/fpga-v-asic.html&quot;&gt;ASIC&lt;/a&gt;,
as this design could be delivered as an internally
routed black box.&lt;/p&gt;

&lt;p&gt;The logic for B’s side is identical, save that it is based
upon the negation of our select signal.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	initial bff = 0;
	always @(posedge i_clk_b, negedge i_areset_n)
	if (!i_areset_n)
		bff &amp;lt;= 0;
	else
		bff &amp;lt;= (!i_sel)&amp;amp;&amp;amp;(!a_sel);

	initial b_sel = 0;
	always @(negedge i_clk_b, negedge i_areset_n)
	if (!i_areset_n)
		b_sel &amp;lt;= 0;
	else
		b_sel &amp;lt;= bff;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;As the final step, the output clock is determined by clock &lt;code class=&quot;highlighter-rouge&quot;&gt;A&lt;/code&gt; if
&lt;code class=&quot;highlighter-rouge&quot;&gt;a_sel&lt;/code&gt; is ever true, and by clock &lt;code class=&quot;highlighter-rouge&quot;&gt;B&lt;/code&gt; if &lt;code class=&quot;highlighter-rouge&quot;&gt;b_sel&lt;/code&gt; is true.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	assign	o_clk = ((a_sel)&amp;amp;&amp;amp;(i_clk_a))
			||((b_sel)&amp;amp;&amp;amp;(i_clk_b));
endmodule&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This design would be bad practice within an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;.
Besides transitioning on both positive and negative edges of a
clock, we are also sourcing a clock from combinational logic.
Both of these are big no-no’s in any
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;.
design.  If you want a &lt;a href=&quot;https://github.com/ZipCPU/website/blob/master/examples/clkswitch.v&quot;&gt;clock
switch&lt;/a&gt;
within your
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;.
design logic, use the vendor supplied black box that implements
something approximating (or better than) the above logic.&lt;/p&gt;

&lt;p&gt;Shall we see if we can
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formally verify&lt;/a&gt;
whether this circuit truly works?&lt;/p&gt;

&lt;h1 id=&quot;formally-verifying-the-clock-switch&quot;&gt;Formally Verifying the clock switch&lt;/h1&gt;

&lt;p&gt;Our first
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal verification&lt;/a&gt;
step is to determine what the “contract” is that
this design needs to meet.  Specifically, we want to make certain that&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;The outgoing clock should only transition when one of the incoming clocks
transitions.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The output clock’s high or low pulse width is no less than the width of the
fastest clock&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;We can switch from one clock to another&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Let’s work through these one by one.  The first criteria is easy: if neither
input clock rises, then we’ll assert that the output doesn’t rise either.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @($global_clock)
	if ((f_past_valid)&amp;amp;&amp;amp;(i_areset_n)&amp;amp;&amp;amp;(!$rose(i_clk_a))&amp;amp;&amp;amp;(!$rose(i_clk_b)))
		assert(!$rose(o_clk));&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Notice how I needed to add an exception for the
&lt;a href=&quot;/formal/2018/04/12/areset.html&quot;&gt;asynchronous reset&lt;/a&gt;.  Hence
this property will only hold as long as the reset line remains inactive (high).&lt;/p&gt;

&lt;p&gt;Likewise, if neither input falls, then the output shouldn’t fall either.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @($global_clock)
	if ((f_past_valid)&amp;amp;&amp;amp;(i_areset_n)&amp;amp;&amp;amp;(!$fell(i_clk_a))&amp;amp;&amp;amp;(!$fell(i_clk_b)))
		assert(!$fell(o_clk));&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;If you don’t recognize the &lt;code class=&quot;highlighter-rouge&quot;&gt;f_past_valid&lt;/code&gt; signal, we’ve discussed it many
times on this blog.  It is necessitated by the fact that on the initial time
step, &lt;code class=&quot;highlighter-rouge&quot;&gt;$rose()&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;$fell()&lt;/code&gt;, and &lt;code class=&quot;highlighter-rouge&quot;&gt;$past()&lt;/code&gt; are not well defined.  Instead,
we set the &lt;code class=&quot;highlighter-rouge&quot;&gt;f_past_valid&lt;/code&gt; just after that initial time step, and then start
checking on every step thereafter.&lt;/p&gt;

&lt;p&gt;The second criteria is a little harder to describe.  Indeed, our design choice
to use a fractional clock makes this more difficult.  Because we are
looking at the most significant bit of a counter, it’s not immediately
apparent how long each clock should be high.  Without a divide operator
to tell us how long we’d expect each clock leg to be high or low
we’re sort of stuck.&lt;/p&gt;

&lt;p&gt;We could switch from the &lt;a href=&quot;/blog/2017/06/02/generating-timing.html&quot;&gt;fractional
clock division&lt;/a&gt;
description above to an integer divide:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @($global_clock)
	if (f_a_count != 0)
		f_a_count &amp;lt;= f_a_count - 1&#39;b1;
	else
		f_a_count &amp;lt;= f_a_idiv-1;

	always @($global_clock)
	if (f_a_count == 0)
		assume(i_clk_a == !$past(i_clk_a));
	else
		assume($stable(i_clk_a);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This would offer some different properties to the clock, so I would
encourage anyone interested to try this approach.&lt;/p&gt;

&lt;p&gt;For this post, however, we’ll continue with the
&lt;a href=&quot;/blog/2017/06/02/generating-timing.html&quot;&gt;fractional divider&lt;/a&gt;
and see if we can’t find a simpler approach.&lt;/p&gt;

&lt;p&gt;If you examine the logic for the output clock, &lt;code class=&quot;highlighter-rouge&quot;&gt;o_clk&lt;/code&gt;, you’ll see that
the output clock is determined by either &lt;code class=&quot;highlighter-rouge&quot;&gt;a_sel&lt;/code&gt; or &lt;code class=&quot;highlighter-rouge&quot;&gt;b_sel&lt;/code&gt;.  If &lt;code class=&quot;highlighter-rouge&quot;&gt;a_sel&lt;/code&gt;
is true, clock &lt;code class=&quot;highlighter-rouge&quot;&gt;A&lt;/code&gt; is
produced.  Likewise if &lt;code class=&quot;highlighter-rouge&quot;&gt;b_sel&lt;/code&gt; is true, then clock B is produced.  If neither
is true, there should be no clock pulse out.  However, both should never be
true at the same time.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(*)
		assert(!a_sel || !b_sel);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;We might also choose to assert that &lt;code class=&quot;highlighter-rouge&quot;&gt;a_sel&lt;/code&gt; or &lt;code class=&quot;highlighter-rouge&quot;&gt;b_sel&lt;/code&gt; would only change
on a clock edge.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @($global_clock)
	if ((f_past_valid)&amp;amp;&amp;amp;(i_areset_n)&amp;amp;&amp;amp;(!$fell(i_clk_a)))
		assert($stable(a_sel));

	always @($global_clock)
	if ((f_past_valid)&amp;amp;&amp;amp;(i_areset_n)&amp;amp;&amp;amp;(!$fell(i_clk_b)))
		assert($stable(b_sel));&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;However, if you examine the design above you’ll see that this
is indeed the case by examination—with the exception of the
&lt;a href=&quot;/formal/2018/04/12/areset.html&quot;&gt;asynchronous reset&lt;/a&gt;
input.  This one piece of our logic might produce a clock glitch, but
we’ll assume that if you are using an
&lt;a href=&quot;/formal/2018/04/12/areset.html&quot;&gt;asynchronous reset&lt;/a&gt;
then you know what you are doing and you can handle such a glitch.&lt;/p&gt;

&lt;p&gt;For our final criteria, let’s count clock ticks in each clock domain.
We’ll start with the &lt;code class=&quot;highlighter-rouge&quot;&gt;A&lt;/code&gt; clock domain.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	reg	[2:0]	a_ticks, last_a_ticks;

	initial	a_ticks = 0;
	always @($global_clock)
		if (!i_areset_n)
			a_ticks &amp;lt;= 0;
		else if ($rose(i_clk_a)&amp;amp;&amp;amp;(a_sel)&amp;amp;&amp;amp;(! &amp;amp;a_ticks))
			a_ticks &amp;lt;= a_ticks + 1&#39;b1;
		else if (b_sel)
			a_ticks &amp;lt;= 0;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;We’ll do the same in a moment with the &lt;code class=&quot;highlighter-rouge&quot;&gt;B&lt;/code&gt; clock domain.  For now, let’s
keep track of the number of clock ticks we’ve had in the &lt;code class=&quot;highlighter-rouge&quot;&gt;A&lt;/code&gt; domain, and
remember this value even after we leave the &lt;code class=&quot;highlighter-rouge&quot;&gt;A&lt;/code&gt; domain.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	initial	last_a_ticks = 0;
	always @($global_clock)
	if (!i_areset_n)
		last_a_ticks &amp;lt;= 0;
	else if ((f_past_valid)&amp;amp;&amp;amp;($past(a_sel)))
		last_a_ticks &amp;lt;= a_ticks;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;We’ll then repeat this logic for the &lt;code class=&quot;highlighter-rouge&quot;&gt;B&lt;/code&gt; clock domain–both counting how
many ticks have taken place since changing, and keeping track of that count
once we switch back to &lt;code class=&quot;highlighter-rouge&quot;&gt;A&lt;/code&gt;s clock.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	reg	[2:0]	b_ticks, last_b_ticks;
	initial	b_ticks = 0;
	always @($global_clock)
		if (!i_areset_n)
			b_ticks &amp;lt;= 0;
		else if ($rose(i_clk_b)&amp;amp;&amp;amp;(b_sel)&amp;amp;&amp;amp;(! &amp;amp;b_ticks))
			b_ticks &amp;lt;= b_ticks + 1&#39;b1;
		else if (a_sel)
			b_ticks &amp;lt;= 0;

	initial	last_b_ticks = 0;
	always @($global_clock)
	if (!i_areset_n)
		last_b_ticks &amp;lt;= 0;
	else if ((f_past_valid)&amp;amp;&amp;amp;($past(b_sel)))
		last_b_ticks &amp;lt;= b_ticks;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;To make our traces look nice, we’ll assume that there must be at least
three clock ticks between switches.  Since this minimum duration properties
isn’t really a fundamental part of our proof, we’ll place it within an
parameterized option to the core.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	generate if (OPT_COVER)
	begin
		// Only one clock should ever be active at any time
		always @($global_clock)
		assert((a_ticks == 0)||(b_ticks == 0));

		always @($global_clock)
		if ((f_past_valid)&amp;amp;&amp;amp;($past(a_sel))&amp;amp;&amp;amp;(a_ticks == 0))
			assume(i_sel);

		always @($global_clock)
		if ((f_past_valid)&amp;amp;&amp;amp;($past(b_sel))&amp;amp;&amp;amp;(b_ticks == 0))
			assume(!i_sel);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Using these two measures of the number of times either &lt;code class=&quot;highlighter-rouge&quot;&gt;A&lt;/code&gt; or &lt;code class=&quot;highlighter-rouge&quot;&gt;B&lt;/code&gt; has
ticked between clock swaps, we can now ask the formal tools to &lt;code class=&quot;highlighter-rouge&quot;&gt;cover()&lt;/code&gt;
a clock transition from A to B where A is at least twice as fast as &lt;code class=&quot;highlighter-rouge&quot;&gt;B&lt;/code&gt;,
and again from &lt;code class=&quot;highlighter-rouge&quot;&gt;B&lt;/code&gt; to &lt;code class=&quot;highlighter-rouge&quot;&gt;A&lt;/code&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;		always @($global_clock)
		cover((f_past_valid)&amp;amp;&amp;amp;(&amp;amp;last_a_ticks)&amp;amp;&amp;amp;(&amp;amp;b_ticks)&amp;amp;&amp;amp;(b_sel)
			&amp;amp;&amp;amp;(f_a_step &amp;gt; (f_b_step&amp;lt;&amp;lt;1)));

		always @($global_clock)
		cover((f_past_valid)&amp;amp;&amp;amp;(&amp;amp;last_b_ticks)&amp;amp;&amp;amp;(&amp;amp;a_ticks)&amp;amp;&amp;amp;(a_sel)
			&amp;amp;&amp;amp;(f_a_step &amp;gt; (f_b_step&amp;lt;&amp;lt;1)));
	end endgenerate&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Now, if everything works, then when we run
&lt;a href=&quot;https://symbiyosys.readthedocs.io/en/latest&quot;&gt;SymbiYosys&lt;/a&gt;
with a &lt;code class=&quot;highlighter-rouge&quot;&gt;mode&lt;/code&gt; of &lt;code class=&quot;highlighter-rouge&quot;&gt;cover&lt;/code&gt;, and using the &lt;code class=&quot;highlighter-rouge&quot;&gt;cover&lt;/code&gt; task defined by the 
&lt;a href=&quot;https://symbiyosys.readthedocs.io/en/latest&quot;&gt;SymbiYosys&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/website/blob/master/examples/clkswitch.sby&quot;&gt;script&lt;/a&gt;,
we’ll get two traces of clock transitions.&lt;/p&gt;

&lt;p&gt;So we’ve now described two of the three properties above, and hand waved through
the third.  Will this work?&lt;/p&gt;

&lt;p&gt;Not quite.&lt;/p&gt;

&lt;p&gt;Should you test this core with only those properties above, you’ll discover
as I did that they aren’t sufficient to ensure that this &lt;a href=&quot;https://github.com/ZipCPU/website/blob/master/examples/clkswitch.v&quot;&gt;clock
switch&lt;/a&gt;
even worked.  You can see the output from
&lt;a href=&quot;https://symbiyosys.readthedocs.io/en/latest&quot;&gt;SymbiYosys&lt;/a&gt; below.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 4. SymbiYosys results from the first formal verification attempt&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/ckswitch-first-fail.png&quot; alt=&quot;Textual terminal output from SymbiYosys&quot; width=&quot;854&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;From this, we determine that our assertion from &lt;a href=&quot;https://github.com/ZipCPU/website/blob/master/examples/clkswitch.v#L184&quot;&gt;line
184&lt;/a&gt;
failed.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @($global_clock)
	assert((!a_sel)||(!b_sel));&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h2 id=&quot;what-happened&quot;&gt;What happened?&lt;/h2&gt;

&lt;p&gt;If you look near the bottom of the
&lt;a href=&quot;https://symbiyosys.readthedocs.io/en/latest&quot;&gt;SymbiYosys&lt;/a&gt;
output, you’ll see a line identifying a counterexample trace.  We can use this
trace to find out why our proof didn’t work.  This trace is shown in Fig 5
below.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 5. Trace file describing how the assertions might fail&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/ckswitch-first-trace.png&quot; alt=&quot;Failing trace, showing a_sel and b_sel both true at the same time&quot; width=&quot;827&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;If you look closely at the penultimate time step, between 70ns and 80ns,
you’ll notice that both
&lt;code class=&quot;highlighter-rouge&quot;&gt;a_sel&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;b_sel&lt;/code&gt; are true at the same time.  &lt;em&gt;This should never happen!&lt;/em&gt;
This violates all of the properties we are hoping to get from this clock
divider.&lt;/p&gt;

&lt;p&gt;Looking closer, you can see that &lt;code class=&quot;highlighter-rouge&quot;&gt;i_sel&lt;/code&gt; (shown in red) didn’t simply change
from selecting clock A to clock B.  Instead, it started out requesting clock
&lt;code class=&quot;highlighter-rouge&quot;&gt;B&lt;/code&gt;, suddenly switched to selecting clock &lt;code class=&quot;highlighter-rouge&quot;&gt;A&lt;/code&gt;, and then immediately
switched back before the synchronizers could settle.  Such a signal on
then &lt;code class=&quot;highlighter-rouge&quot;&gt;i_sel&lt;/code&gt; select line would defeat the purpose of our &lt;a href=&quot;https://github.com/ZipCPU/website/blob/master/examples/clkswitch.v&quot;&gt;clock
switch&lt;/a&gt;,
so it’s not really all that reasonable.&lt;/p&gt;

&lt;p&gt;On the other hand, if we assume that &lt;code class=&quot;highlighter-rouge&quot;&gt;i_sel&lt;/code&gt; won’t change until the clock
transition is complete, then we get a lot farther:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @($global_clock)
	if ((f_past_valid)&amp;amp;&amp;amp;($past(i_sel))&amp;amp;&amp;amp;(!a_sel))
		assume(i_sel);

	always @($global_clock)
	if ((f_past_valid)&amp;amp;&amp;amp;(!$past(i_sel))&amp;amp;&amp;amp;(!b_sel))
		assume(!i_sel);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;As another way we might express this, we might insist that anytime there is
a change propagating through the synchronizers then &lt;code class=&quot;highlighter-rouge&quot;&gt;i_sel&lt;/code&gt; will be
held constant.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @($global_clock)
	if ((a_sel != aff)||(b_sel != bff))
		assume($stable(i_sel));&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Getting this design to &lt;a href=&quot;/blog/2018/03/10/induction-exercise.html&quot;&gt;pass
induction&lt;/a&gt;
requires some additional properties.  For example, we can’t allow the
design to be transitioning in both rails at the same time.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(*)
	if (aff != a_sel)
		assert(bff == b_sel);

	always @(*)
	if (bff != b_sel)
		assert(aff == a_sel);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;With these changes the design passes, proving our first criteria–that the
outgoing clock only
ever changes on an input clock edge.  We also have a meager assurance that the
outgoing clock will not be faster than either incoming clock.  Perhaps
we should examine the third criteria, and see how this switch works when
swapping?&lt;/p&gt;

&lt;p&gt;As you may recall, our third criteria was whether or not we could
switch from one clock to the other or back again.
To see whether or not we met this criteria, we’ll need to run
&lt;a href=&quot;https://symbiyosys.readthedocs.io/en/latest&quot;&gt;SymbiYosys&lt;/a&gt;
in its cover mode.  Our
&lt;a href=&quot;https://github.com/ZipCPU/website/blob/master/examples/clkswitch.sby&quot;&gt;script&lt;/a&gt;
has a &lt;code class=&quot;highlighter-rouge&quot;&gt;cover&lt;/code&gt; task defined within it that does just that.  The result is two
generated clock traces that illustrate how clock transitions might happen.&lt;/p&gt;

&lt;p&gt;The first trace shows that a design can switch from a faster clock to a slower
clock.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 6. Cover result, switching from a faster clock to a slower clock&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/ckswitch-trace0.png&quot; alt=&quot;&quot; width=&quot;578&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;The second trace, on the other hand, shows the clock switching from a slower
clock to a faster clock.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 7. Cover result, switching from a slower clock to a faster clock&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/ckswitch-trace1.png&quot; alt=&quot;&quot; width=&quot;603&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;But what about the idea of a failsafe clock?  Didn’t we say that one reason
for using a &lt;a href=&quot;https://github.com/ZipCPU/website/blob/master/examples/clkswitch.v&quot;&gt;clock
switch&lt;/a&gt;
is to be able to have a failsafe clock, where if one
dies then the other one picks back up?&lt;/p&gt;

&lt;p&gt;This particular design doesn’t support a failsafe clock.
If &lt;code class=&quot;highlighter-rouge&quot;&gt;A&lt;/code&gt; is the failsafe clock, and &lt;code class=&quot;highlighter-rouge&quot;&gt;B&lt;/code&gt; stops transitioning, then you
can’t switch from &lt;code class=&quot;highlighter-rouge&quot;&gt;B&lt;/code&gt; back to &lt;code class=&quot;highlighter-rouge&quot;&gt;A&lt;/code&gt; using &lt;a href=&quot;https://github.com/ZipCPU/website/blob/master/examples/clkswitch.v&quot;&gt;this
design&lt;/a&gt;
since &lt;code class=&quot;highlighter-rouge&quot;&gt;b_sel&lt;/code&gt; depends upon both a positive and a negative transition from
clock &lt;code class=&quot;highlighter-rouge&quot;&gt;B&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Even though this clock switch design doesn’t offer a failsafe capability,
you should now understand the tools necessary to prove that your own design,
perhaps even one with a failsafe capability, would work—but only in an
&lt;a href=&quot;/blog/2017/10/13/fpga-v-asic.html&quot;&gt;ASIC&lt;/a&gt;
design of course!  (Remember, the clock switch is not appropriate for an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
design for the reasons given above.)&lt;/p&gt;

&lt;h2 id=&quot;next-steps&quot;&gt;Next Steps&lt;/h2&gt;

&lt;p&gt;Let’s think about what we just did.  We just verified that a design with
three &lt;a href=&quot;https://en.wikipedia.org/wiki/Asynchronous_circuit&quot;&gt;asynchronous&lt;/a&gt;
inputs “works”.  This involved formally describing two dissimilar clocks
with arbitrary phases and frequencies.  These techniques apply well beyond
this simple &lt;a href=&quot;https://github.com/ZipCPU/website/blob/master/examples/clkswitch.v&quot;&gt;clock
switch&lt;/a&gt;
design.  These techniques can be used in &lt;em&gt;any&lt;/em&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Asynchronous_circuit&quot;&gt;asynchronous&lt;/a&gt;
design component to verify that your logic is working as desired–in spite of
whatever clock phases or frequencies might be given to it.&lt;/p&gt;

&lt;p&gt;While working with
&lt;a href=&quot;https://en.wikipedia.org/wiki/Asynchronous_circuit&quot;&gt;asynchronous&lt;/a&gt;
inputs isn’t common, there are times and places for doing so.  I’ve already
mentioned some examples above: an
&lt;a href=&quot;/formal/2018/04/12/areset.html&quot;&gt;asynchronous reset&lt;/a&gt;,
a &lt;a href=&quot;https://github.com/ZipCPU/wbuart32/blob/dev/rtl/rxuartlite.v&quot;&gt;serial port
receiver&lt;/a&gt;,
or perhaps a circuit that must read memory at one clock rate and feed a video
stream at another rate.  In all of these cases, knowing how to
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formally verify&lt;/a&gt;
your component in spite of any
&lt;a href=&quot;/blog/2017/10/20/cdc.html&quot;&gt;multiple clock domains&lt;/a&gt;
will be a valuable tool.&lt;/p&gt;

&lt;p&gt;The next step in this short series on
&lt;a href=&quot;https://en.wikipedia.org/wiki/Asynchronous_circuit&quot;&gt;asynchronous&lt;/a&gt;
logic will be to take &lt;a href=&quot;http://www.sunburst-design.com/papers/CummingsSNUG2002SJ_FIFO1.pdf&quot;&gt;Cliff Cummings’ asynchronous FIFO
design&lt;/a&gt;,
and apply the same basic
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal verification&lt;/a&gt;
steps we just applied above.&lt;/p&gt;

&lt;p&gt;As an added bonus in this process, you should be able to then turn around and
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formally verify&lt;/a&gt;
any modifications you need to make to
&lt;a href=&quot;http://www.sunburst-design.com/papers/CummingsSNUG2002SJ_FIFO1.pdf&quot;&gt;his design&lt;/a&gt;
to meet your particular design requirements.&lt;/p&gt;
&lt;hr /&gt;&lt;p&gt;&lt;em&gt;And he said unto them, It is not for you to know the times or the seasons, which the Father hath put in His own power. (Acts 1:7)&lt;/em&gt;</description>
        <pubDate>Thu, 31 May 2018 00:00:00 -0400</pubDate>
        <link>https://zipcpu.com/formal/2018/05/31/clkswitch.html</link>
        <guid isPermaLink="true">https://zipcpu.com/formal/2018/05/31/clkswitch.html</guid>
        
        
        <category>formal</category>
        
      </item>
    
      <item>
        <title>A Slow but Symmetric FIR Filter Implementation</title>
        <description>&lt;p&gt;It’s been some time since we’ve discussed digital filtering on the
ZipCPU blog.
When we last left the topic, we had several filters left to present.  Today,
let’s pick up the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Linear_phase&quot;&gt;symmetric or linear phase&lt;/a&gt;
&lt;a href=&quot;/dsp/2017/09/15/fastfir.html&quot;&gt;filter&lt;/a&gt;,
and demonstrate a block RAM
based implementation of it.  I’ll call this a &lt;em&gt;slow filter&lt;/em&gt;, similar to our
last &lt;a href=&quot;/dsp/2017/12/30/slowfil.html&quot;&gt;slow filter&lt;/a&gt;,
simply because
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/slowsymf.v&quot;&gt;this filter&lt;/a&gt;
won’t be able to handle a new sample every clock
tick.  Instead, what makes
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/slowsymf.v&quot;&gt;this filter&lt;/a&gt;
special is that it only requires one dedicated hardware multiply.  Better
yet, as with the &lt;a href=&quot;/dsp/2017/12/30/slowfil.html&quot;&gt;last
slow filter&lt;/a&gt;
implementation, making
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/slowsymf.v&quot;&gt;this filter&lt;/a&gt;
adjustable won’t require a lot of resources.  Unlike the
&lt;a href=&quot;/dsp/2017/12/30/slowfil.html&quot;&gt;last filter&lt;/a&gt;,
though,
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/slowsymf.v&quot;&gt;this one&lt;/a&gt;
will offer nearly twice the performance for nearly the same amount of
resources.&lt;/p&gt;

&lt;p&gt;Interested yet?&lt;/p&gt;

&lt;p&gt;But we’ll come back to this in a moment.  In the meantime, let’s try to catch
up some of our readers who may be starting in the middle of this discussion.
Basically, we’ve been
slowly working through hardware implementations of all of the basic
&lt;a href=&quot;https://en.wikipedia.org/wiki/Finite_impulse_response&quot;&gt;FIR&lt;/a&gt;
filtering types.  We’ve already laid a lot of ground work, ground work you
might wish to review should you find yourself coming in the middle of this
discussion.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Our &lt;a href=&quot;/dsp/2017/09/15/fastfir.html&quot;&gt;first post&lt;/a&gt; on the
topic outlined what a digital filter was, and how a filter could be built that
operated at the full clock rate of an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;.
This initial post was quickly followed by an &lt;a href=&quot;/dsp/2017/09/29/cheaper-fast-fir.html&quot;&gt;updated
implementation&lt;/a&gt; that
used fewer
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flip-flop_(electronics)&quot;&gt;flip-flops&lt;/a&gt;
while achieving the same performance.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;This &lt;a href=&quot;/dsp/2017/09/15/fastfir.html&quot;&gt;initial filtering
article&lt;/a&gt;
was followed by a &lt;a href=&quot;/dsp/2017/11/04/genfil-tb.html&quot;&gt;proposed
abstraction&lt;/a&gt;
that could be applied to every
filtering implementation.
As long as any filter we built, therefore, had the I/O interface of this
&lt;a href=&quot;/dsp/2017/11/04/genfil-tb.html&quot;&gt;generic filter&lt;/a&gt;,
we could re-use a
&lt;a href=&quot;/dsp/2017/11/04/genfil-tb.html&quot;&gt;test harness&lt;/a&gt;,
to test multiple different filters.&lt;/p&gt;

    &lt;p&gt;A &lt;a href=&quot;/dsp/2017/11/22/fltr-response.html&quot;&gt;following article&lt;/a&gt;
discussed how we could use this &lt;a href=&quot;/dsp/2017/11/04/genfil-tb.html&quot;&gt;generic filter
testing&lt;/a&gt;
approach to verify that a given filter had the
&lt;a href=&quot;/dsp/2017/11/22/fltr-response.html&quot;&gt;frequency response&lt;/a&gt;
it was designed to have.&lt;/p&gt;

    &lt;p&gt;We then demonstrated how these methods could be applied to test our
&lt;a href=&quot;/dsp/2017/09/15/fastfir.html&quot;&gt;generic FIR filter&lt;/a&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Along the way, we’ve presented several different types of filters.  We
started by discussing &lt;a href=&quot;/dsp/2017/08/19/simple-filter.html&quot;&gt;two of the absolute simplest
filters&lt;/a&gt; I know of:
a pairwise averager and a &lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/iiravg.v&quot;&gt;recursive
averager&lt;/a&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;We then came back later to make the pairwise averager into a more generic
&lt;a href=&quot;/dsp/2017/10/16/boxcar.html&quot;&gt;moving (block) average
filter&lt;/a&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The last post on this topic broke the mold of a filter that accepted one
input and produced one output on every clock tick.  Instead, that &lt;a href=&quot;/dsp/2017/12/30/slowfil.html&quot;&gt;post
presented a filter&lt;/a&gt;
that would accept one input every &lt;code class=&quot;highlighter-rouge&quot;&gt;N&lt;/code&gt; clocks, allowing the
filter to accomplish all of its multiplies using a single hardware multiply
alone.&lt;/p&gt;

    &lt;p&gt;Further, since this &lt;a href=&quot;/dsp/2017/12/30/slowfil.html&quot;&gt;filtering
implementation&lt;/a&gt;
used block RAM to store and retrieve its coefficients, it cost much less to
reconfigure the filter than our prior &lt;a href=&quot;/dsp/2017/09/15/fastfir.html&quot;&gt;generic filtering
implementation&lt;/a&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Since this last post, I’ve focused on interpolation for a while, by first
proving that &lt;a href=&quot;/dsp/2018/01/16/interpolation-is-convolution.html&quot;&gt;interpolation &lt;em&gt;is&lt;/em&gt; a
convolution&lt;/a&gt;,
and then showing how that knowledge could be used to create a very useful
&lt;a href=&quot;/dsp/2018/03/30/quadratic.html&quot;&gt;quadratic interpolation&lt;/a&gt;
method with some amazing out-of-band performance.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;In other words, it’s been some time since we’ve discussed
filtering,
and there remain many types of
filters
and filtering implementations for us still to discuss.  For example, we
haven’t discussed
&lt;a href=&quot;https://en.wikipedia.org/wiki/Linear_phase&quot;&gt;symmetric&lt;/a&gt;
or &lt;a href=&quot;https://en.wikipedia.org/wiki/Half-band_filter&quot;&gt;half-band filters&lt;/a&gt;.
Neither have we discussed how to implement a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Hilbert_transform&quot;&gt;Hilbert transform&lt;/a&gt;.  Another
fun filtering topic we could discuss would be how to string multiple
filters
together to handle the case where there may be &lt;code class=&quot;highlighter-rouge&quot;&gt;N&lt;/code&gt; clocks between
samples, but the filter has more than &lt;code class=&quot;highlighter-rouge&quot;&gt;N&lt;/code&gt; coefficients.  There’s also the
ultimate
&lt;a href=&quot;https://en.wikipedia.org/wiki/Low-pass_filter&quot;&gt;lowpass filter&lt;/a&gt;:
the one that
filters
an incoming sample stream to
(just about) any arbitrary low-bandwidth for only about
&lt;code class=&quot;highlighter-rouge&quot;&gt;24&lt;/code&gt; taps–independent of the actual
&lt;a href=&quot;https://en.wikipedia.org/wiki/Low-pass_filter&quot;&gt;lowpass&lt;/a&gt;
bandwidth.
Then there’s the adaptive filters that are commonly used in the equalizers
within digital communications receivers.  Finally, there’s the grandaddy filter
of them all: the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Fast_Fourier_transform&quot;&gt;FFT&lt;/a&gt;
based
filter.
When implemented properly, an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Fast_Fourier_transform&quot;&gt;FFT&lt;/a&gt;
based filter is not only quite configurable, it’s also very easy to
reconfigure.&lt;/p&gt;

&lt;p&gt;Seems like I could keep discussing filtering for quite some time.&lt;/p&gt;

&lt;p&gt;All of these filtering topics would be fun to present here on
&lt;a href=&quot;https://zipcpu.com/&quot;&gt;this blog&lt;/a&gt;.
For today, though, let’s just examine how to build a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Linear_phase&quot;&gt;symmetric filter&lt;/a&gt;
implementation.&lt;/p&gt;

&lt;p&gt;To start off the discussion, consider that I recently counseled someone
who was studying aircraft engine noise and trying build a
filter
that would grab only 180Hz to 6300Hz of an audio signal sampled at 44.1kHz.
He was disappointed that his
&lt;a href=&quot;https://en.wikipedia.org/wiki/Butterfly_filter&quot;&gt;Butterworth filter&lt;/a&gt;
design wasn’t quite meeting his need.  Given that his design only had a 3dB
&lt;a href=&quot;https://en.wikipedia.org/wiki/Stopband&quot;&gt;stopband&lt;/a&gt;
rejection, I’m sure you can understand why not.  But let’s just consider
this specification for a moment.&lt;/p&gt;

&lt;p&gt;Suppose you wanted to design a 180Hz to 6300Hz bandpass filter.  How many
taps would you need?  Let’s say you wanted a 40Hz
&lt;a href=&quot;https://en.wikipedia.org/wiki/Transition_band&quot;&gt;transition band&lt;/a&gt;.
You would then need 4095 taps to achieve a 65dB
&lt;a href=&quot;https://en.wikipedia.org/wiki/Stopband&quot;&gt;stopband&lt;/a&gt;.
If you used the
&lt;a href=&quot;/dsp/2017/09/15/fastfir.html&quot;&gt;generic filtering&lt;/a&gt; approach,
you would need to find an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
with 4095 multiplies on board.  While I don’t know about
your budget, I certainly couldn’t afford an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
with that many multiplies.  On the other hand, if you used the
&lt;a href=&quot;/dsp/2017/12/30/slowfil.html&quot;&gt;slow filter&lt;/a&gt; from our
last discussion, you would only be able to implement a
filter
2267 taps long.  This would leave you with the choice of either loosening your
&lt;a href=&quot;https://en.wikipedia.org/wiki/Transition_band&quot;&gt;transition&lt;/a&gt;
bandwidth or your
&lt;a href=&quot;https://en.wikipedia.org/wiki/Stopband&quot;&gt;stopband&lt;/a&gt;
criteria.&lt;/p&gt;

&lt;p&gt;On the other hand, if you could exploit the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Linear_phase&quot;&gt;symmetry&lt;/a&gt;
inherent in
&lt;a href=&quot;https://en.wikipedia.org/wiki/Parks-McClellan_filter_design_algorithm&quot;&gt;most&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Finite_impulse_response&quot;&gt;FIR&lt;/a&gt;
filter designs, you’d have more than enough logic to implement your filter
design on a cheap
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
board using only one hardware multiply.&lt;/p&gt;

&lt;h2 id=&quot;background&quot;&gt;Background&lt;/h2&gt;

&lt;p&gt;So, what is this
&lt;a href=&quot;https://en.wikipedia.org/wiki/Linear_phase&quot;&gt;symmetry&lt;/a&gt;,
and how shall we exploit it?  To understand that, let’s go back to the
beginning and understand how
&lt;a href=&quot;/dsp/2017/09/15/fastfir.html&quot;&gt;digital filters&lt;/a&gt;,
are designed.&lt;/p&gt;

&lt;p&gt;To design a
filter,
the engineer must first determine a range of frequencies
he wants the filter to “pass” (i.e. the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Passband&quot;&gt;passband&lt;/a&gt;),
and another range of frequencies he wants the
filter
to “&lt;a href=&quot;https://en.wikipedia.org/wiki/Stopband&quot;&gt;stop&lt;/a&gt;”.
These two ranges tend to be disjoint, with a
“&lt;a href=&quot;https://en.wikipedia.org/wiki/Transition_band&quot;&gt;transition band&lt;/a&gt;”
between them.  Within the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Stopband&quot;&gt;stopband&lt;/a&gt;,
the engineer must determine the “depth”, also known as how much attenuation
the filter is to provide in this region.  This can also be used as a
criteria on how much (or little) distortion is allowed within the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Passband&quot;&gt;passband&lt;/a&gt;).&lt;/p&gt;

&lt;p&gt;All of these criteria are easily illustrated in Fig 1 below.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 1: FIR Filter Design Criteria&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/fir-lpf-design.png&quot; alt=&quot;Filter design regions: passband, transition band, and stop band&quot; width=&quot;776&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Given this criteria, the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Parks-McClellan_filter_design_algorithm&quot;&gt;Parks and McClellan algorithm&lt;/a&gt;
is well known for generating “optimal” filters.  &lt;a href=&quot;https://en.wikipedia.org/wiki/Parks-McClellan_filter_design_algorithm&quot;&gt;This filter design
method&lt;/a&gt;
produces filters that come closest to the filter design specification, as
measured by the maximum deviation from the specification.  There are two
other realities with using this method.  First, the filters designed by it all
have an odd number of coefficients.  Second, as designed they are all
&lt;a href=&quot;https://en.wikipedia.org/wiki/Linear_phase&quot;&gt;symmetric&lt;/a&gt; and
&lt;a href=&quot;https://en.wikipedia.org/wiki/Causal_filter&quot;&gt;non-causal&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;These two characteristics follow the fact that the
&lt;a href=&quot;/dsp/2017/09/15/fastfir.html&quot;&gt;filter&lt;/a&gt;
is specified with &lt;em&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Real_number&quot;&gt;real&lt;/a&gt;&lt;/em&gt;, as
opposed to
&lt;a href=&quot;https://en.wikipedia.org/wiki/Complex_number&quot;&gt;complex&lt;/a&gt; or
&lt;a href=&quot;https://en.wikipedia.org/wiki/Imaginary_number&quot;&gt;imaginary&lt;/a&gt;, criteria.  That
is, the desired &lt;a href=&quot;/dsp/2017/09/15/fastfir.html&quot;&gt;filter&lt;/a&gt;’s
&lt;a href=&quot;/dsp/2017/11/22/fltr-response.html&quot;&gt;frequency response&lt;/a&gt;
is expressed as a &lt;em&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Real_number&quot;&gt;real&lt;/a&gt;&lt;/em&gt;
function of frequency.&lt;/p&gt;

&lt;p&gt;Let’s think about this for a moment.  We already know that if you have a
sampled sequence, &lt;code class=&quot;highlighter-rouge&quot;&gt;x[n]&lt;/code&gt;, and apply a
&lt;a href=&quot;/dsp/2017/09/15/fastfir.html&quot;&gt;filter&lt;/a&gt;
with
&lt;a href=&quot;https://en.wikipedia.org/wiki/Impulse_response&quot;&gt;impulse response&lt;/a&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;h[k]&lt;/code&gt;,
then you will get the output &lt;code class=&quot;highlighter-rouge&quot;&gt;y[n]&lt;/code&gt;.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/eqn-convolution-raw.png&quot; alt=&quot;y[n]=SUM h[k] x[n-k]&quot; width=&quot;254&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 2: Convolution Operation&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/fir-form.svg&quot; alt=&quot;&quot; width=&quot;360&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;This operation is called a
discrete &lt;a href=&quot;https://en.wikipedia.org/wiki/Convolution&quot;&gt;convolution&lt;/a&gt;, and it
defines the operation of any
&lt;a href=&quot;/dsp/2017/09/15/fastfir.html&quot;&gt;discrete-time filter&lt;/a&gt;.
Fig 2 shows this operation pictorially, illustrating how the &lt;code class=&quot;highlighter-rouge&quot;&gt;x[n]&lt;/code&gt; elements
can be placed into a tapped delay line, multiplied by their respective &lt;code class=&quot;highlighter-rouge&quot;&gt;h[k]&lt;/code&gt;
coefficient, and then summed together to create the output &lt;code class=&quot;highlighter-rouge&quot;&gt;y[n]&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Further, if you apply this operation to a complex exponential,
such as when&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/eqn-symfil-input-sinusoid.png&quot; alt=&quot;x[n]=e^{j 2pi fn+jtheta}&quot; width=&quot;181&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;then the output of the
&lt;a href=&quot;/dsp/2017/09/15/fastfir.html&quot;&gt;filter&lt;/a&gt;
&lt;a href=&quot;/dsp/2017/11/22/fltr-response.html&quot;&gt;is the same exponential&lt;/a&gt;,
having only been multiplied by a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Complex_number&quot;&gt;complex&lt;/a&gt;
value that is independent of time,&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/eqn-symfil-output-sinusoid.png&quot; alt=&quot;y[n] = e^{jtheta}e^{j2pi fn} SUM h[k] e^{-j2pi fk}&quot; width=&quot;499&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;This complex multiplier is called the &lt;em&gt;&lt;a href=&quot;/dsp/2017/11/22/fltr-response.html&quot;&gt;frequency
response&lt;/a&gt;&lt;/em&gt;
of the filter.  It is defined by,&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/eqn-symfil-fltr-response.png&quot; alt=&quot;H(e^{j2pi f}) = SUM h[k] e^{-j2pi fk}&quot; width=&quot;301&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;This is also the function we were specifying earlier in Fig 1 above.
This should be familiar to you so far, as we have
already &lt;a href=&quot;/dsp/2017/11/22/fltr-response.html&quot;&gt;discussed the importance of a filter’s frequency
response&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Now consider what happens if we insist that this
&lt;a href=&quot;/dsp/2017/11/22/fltr-response.html&quot;&gt;frequency response&lt;/a&gt; is a
&lt;em&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Real_number&quot;&gt;real&lt;/a&gt;&lt;/em&gt;
function of frequency, just like we specified it above.  We’ll use &lt;code class=&quot;highlighter-rouge&quot;&gt;hs[k]&lt;/code&gt; and
&lt;code class=&quot;highlighter-rouge&quot;&gt;Hs&lt;/code&gt; to describe this constrained filter.  If this filter has a
&lt;em&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Real_number&quot;&gt;real&lt;/a&gt;&lt;/em&gt;
&lt;a href=&quot;/dsp/2017/11/22/fltr-response.html&quot;&gt;frequency response&lt;/a&gt;,
then the
&lt;a href=&quot;/dsp/2017/11/22/fltr-response.html&quot;&gt;frequency response&lt;/a&gt;
function must be equal to its conjugate.  We’ll start our proof there.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/eqn-symfil-real-H.png&quot; alt=&quot;H = H^&quot; width=&quot;319&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;We can then replace &lt;code class=&quot;highlighter-rouge&quot;&gt;Hs&lt;/code&gt; with its definition from above and shown in Fig 1,
and then work the conjugate through the summation.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/eqn-symfil-conjugate-sum.png&quot; alt=&quot;SUM h[k] e^{-j2pi fk} = SUM h[k] e^{j2pi fk}&quot; width=&quot;367&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Here, we note two things.  First, &lt;code class=&quot;highlighter-rouge&quot;&gt;hs[k]&lt;/code&gt; is real and so &lt;code class=&quot;highlighter-rouge&quot;&gt;hs[k]&lt;/code&gt; is also equal
to its own conjugate.  Second, if we reverse the summation on the right via a
variable substitution &lt;code class=&quot;highlighter-rouge&quot;&gt;p=-k&lt;/code&gt;, then we have&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/eqn-symfil-psum.png&quot; alt=&quot;SUM h[k] e^{-j2pi fk} = SUM h[-p] e^{-j2pi fp}&quot; width=&quot;396&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;We’ll switch back to a summation over &lt;code class=&quot;highlighter-rouge&quot;&gt;k&lt;/code&gt; for convenience of notation, although
this “new” &lt;code class=&quot;highlighter-rouge&quot;&gt;k&lt;/code&gt; value is just a dummy variable bearing no reference to the
&lt;code class=&quot;highlighter-rouge&quot;&gt;k&lt;/code&gt; three equations above.  (Yes, I did get marked off for doing this by
&lt;a href=&quot;https://www.afit.edu/BIOS/bio.cfm?facID=223&quot;&gt;my instructor&lt;/a&gt; years ago.)&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/eqn-symfil-ksum.png&quot; alt=&quot;SUM h[k] e^{-j2pi fk} = SUM h[-k] e^{-j2pi fk}&quot; width=&quot;388&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Now reflect on the fact that this relationship must be true for all
frequencies, &lt;code class=&quot;highlighter-rouge&quot;&gt;f&lt;/code&gt;.  That can only happen if&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/eqn-symfil-real-coeff.png&quot; alt=&quot;h[k] = h[-k]&quot; width=&quot;169&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;for all &lt;code class=&quot;highlighter-rouge&quot;&gt;k&lt;/code&gt;.  In other words, any filter with a
&lt;em&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Real_number&quot;&gt;real&lt;/a&gt;&lt;/em&gt;
&lt;a href=&quot;/dsp/2017/11/22/fltr-response.html&quot;&gt;frequency response&lt;/a&gt;,
such as those designed from a
&lt;em&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Real_number&quot;&gt;real&lt;/a&gt;&lt;/em&gt;
&lt;a href=&quot;/dsp/2017/11/22/fltr-response.html&quot;&gt;frequency response&lt;/a&gt;
criteria, will always be &lt;a href=&quot;https://en.wikipedia.org/wiki/Linear_phase&quot;&gt;symmetric&lt;/a&gt;
about the time axis, &lt;code class=&quot;highlighter-rouge&quot;&gt;k&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Of course, this isn’t very useful to us, since any
&lt;a href=&quot;/dsp/2017/09/15/fastfir.html&quot;&gt;filter&lt;/a&gt;
having non-zero values of &lt;code class=&quot;highlighter-rouge&quot;&gt;h[k]&lt;/code&gt; for &lt;code class=&quot;highlighter-rouge&quot;&gt;k&amp;lt;0&lt;/code&gt; is
&lt;a href=&quot;https://en.wikipedia.org/wiki/Causal_filter&quot;&gt;non-causal&lt;/a&gt; and as such
cannot be implemented: it depends upon the knowledge of &lt;em&gt;future&lt;/em&gt; values of
&lt;code class=&quot;highlighter-rouge&quot;&gt;x[n]&lt;/code&gt;.  The easy way to deal with this problem is to take the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Linear_phase&quot;&gt;symmetric&lt;/a&gt;
filter we just designed, and shift it so that it’s first non-zero coefficient
is &lt;code class=&quot;highlighter-rouge&quot;&gt;h[0]&lt;/code&gt;.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/eqn-symfil-shiftfil.png&quot; alt=&quot;h[k] = hs[k-(N-1)/2]&quot; width=&quot;204&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Hence, we now have a filter with &lt;code class=&quot;highlighter-rouge&quot;&gt;N&lt;/code&gt; non-zero coefficients, and where&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/eqn-symfil-new-symmetry.png&quot; alt=&quot;h[k] = h[N-1-k]&quot; width=&quot;219&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;This does nothing more than delay the operation of &lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/slowsymf.v&quot;&gt;our
filter&lt;/a&gt;
in time–something the designer may not care about.&lt;/p&gt;

&lt;p&gt;If you evaluate the
&lt;a href=&quot;/dsp/2017/11/22/fltr-response.html&quot;&gt;frequency response&lt;/a&gt;
of this adjusted
&lt;a href=&quot;/dsp/2017/09/15/fastfir.html&quot;&gt;filter&lt;/a&gt;,
you’ll find its
&lt;a href=&quot;/dsp/2017/11/22/fltr-response.html&quot;&gt;frequency response&lt;/a&gt;
to be related to our earlier
&lt;a href=&quot;/dsp/2017/11/22/fltr-response.html&quot;&gt;frequency response&lt;/a&gt;,
by a &lt;a href=&quot;https://en.wikipedia.org/wiki/Linear_phase&quot;&gt;linear phase&lt;/a&gt; term.&lt;/p&gt;

&lt;!-- H(e^{j2pi f}) = SUM h[k-N-1/2]e^{-j 2pi fk}
H(e^{j2pi f}) = SUM h[k]e^{-j 2pi f(k+(N-1)/2)} --&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/eqn-symfil-linear-phase.png&quot; alt=&quot;H(e^{j2pi f}) = e^{-j pi fN }SUM h[k]e^{-j 2pi fk}&quot; width=&quot;378&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;The difference between the
&lt;a href=&quot;/dsp/2017/11/22/fltr-response.html&quot;&gt;frequency response&lt;/a&gt;
of the two
&lt;a href=&quot;/dsp/2017/09/15/fastfir.html&quot;&gt;filters&lt;/a&gt;,
the one symmetric about zero and the
offset but now &lt;a href=&quot;https://en.wikipedia.org/wiki/Causal_filter&quot;&gt;causal&lt;/a&gt;
&lt;a href=&quot;/dsp/2017/09/15/fastfir.html&quot;&gt;filter&lt;/a&gt;,
is a phase term that is linear in frequency.  For this reason,
&lt;a href=&quot;/dsp/2017/09/15/fastfir.html&quot;&gt;filters&lt;/a&gt;
of this type are often called
&lt;em&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Linear_phase&quot;&gt;linear phase&lt;/a&gt;&lt;/em&gt;
&lt;a href=&quot;/dsp/2017/09/15/fastfir.html&quot;&gt;filters&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;But let’s go back a step, did you catch how this affects how we might
implement &lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/slowsymf.v&quot;&gt;this
filter&lt;/a&gt;?  If
the &lt;a href=&quot;/dsp/2017/09/15/fastfir.html&quot;&gt;filter&lt;/a&gt;
remains &lt;a href=&quot;https://en.wikipedia.org/wiki/Linear_phase&quot;&gt;symmetric&lt;/a&gt; such that,&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/eqn-symfil-new-symmetry.png&quot; alt=&quot;h[k] = h[N-1-k]&quot; width=&quot;219&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;then we can rewrite our &lt;a href=&quot;https://en.wikipedia.org/wiki/Convolution&quot;&gt;convolution&lt;/a&gt;
so it uses fewer multiplies.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/eqn-symfil-implementation.png&quot; alt=&quot;y[n] = SUM h[k] ( x[n-k] + x[n+k-(N-1)] ) + h[M]x[n-M]&quot; width=&quot;706&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 3: Convolution Operation Exploiting Coefficient Symmetry&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/fir-symfil-form.svg&quot; alt=&quot;&quot; width=&quot;360&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;This is a big deal!  It’s a big deal because we now have half as many
multiplies as we had before!  We can even scale &lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/slowsymf.v&quot;&gt;our
filter&lt;/a&gt;
such that the middle point of
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/slowsymf.v&quot;&gt;the filter&lt;/a&gt;,
&lt;code class=&quot;highlighter-rouge&quot;&gt;h[M]&lt;/code&gt;, has some sort of “simple”
value like &lt;code class=&quot;highlighter-rouge&quot;&gt;(2^(K-1))-1&lt;/code&gt; for a &lt;code class=&quot;highlighter-rouge&quot;&gt;K&lt;/code&gt; bit word size, for one fewer multiply.
Put together, we’ve just about doubled the capability of any
&lt;a href=&quot;/dsp/2017/09/15/fastfir.html&quot;&gt;filter&lt;/a&gt;
we might wish to implement for only a minimal cost in additional logic.&lt;/p&gt;

&lt;p&gt;You can see how this affects our operation in Fig 3.  Notice how the tapped
delay line containing the incoming signal is now folded in half.  Further,
before the multiply, there’s an addition where we add the pairs of signal data
points together before multiplying by the common filter coefficient.  You
might also notice the single value on the right.  This represents
the coefficient in the middle–the one we’ll multiply by a constant value.&lt;/p&gt;

&lt;p&gt;Now compare Fig 3 to Fig 2 and count the multiplies.  See the difference?
Instead of &lt;code class=&quot;highlighter-rouge&quot;&gt;N&lt;/code&gt; multiplies, there are now &lt;code class=&quot;highlighter-rouge&quot;&gt;(N-1)/2&lt;/code&gt;, or nearly half as many
as we had before.&lt;/p&gt;

&lt;p&gt;Now let’s take a look at how we might optimize our filter’s implementation
to take advantage of this property.&lt;/p&gt;

&lt;h2 id=&quot;c-implementation&quot;&gt;C++ Implementation&lt;/h2&gt;

&lt;p&gt;Although this is an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt; focused
blog, sometimes it helps to consider an algorithm in a higher level language
to understand it.  So let’s spend a moment and review the C++ code describing
our &lt;a href=&quot;/dsp/2017/12/30/slowfil.html&quot;&gt;last implementation&lt;/a&gt;, and
then show how this would change to exploit the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Linear_phase&quot;&gt;symmetry&lt;/a&gt;
inherent in most
&lt;a href=&quot;https://en.wikipedia.org/wiki/Finite_impulse_response&quot;&gt;FIR&lt;/a&gt;
filters.&lt;/p&gt;

&lt;p&gt;As we &lt;a href=&quot;/dsp/2017/12/30/slowfil.html&quot;&gt;presented it before&lt;/a&gt;,
the &lt;a href=&quot;/dsp/2017/12/30/slowfil.html&quot;&gt;slow filter&lt;/a&gt;
C++ code worked by first adding a new data sample to a circular buffer.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;&lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;FIR&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;apply&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dat&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;		&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ln&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;acc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

	&lt;span class=&quot;n&quot;&gt;m_data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_loc&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dat&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_loc&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m_len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;m_loc&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Then the filtering algorithm stepped through each
&lt;a href=&quot;/dsp/2017/09/15/fastfir.html&quot;&gt;filter&lt;/a&gt;
coefficient, multiplying it by a corresponding data sample.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;	&lt;span class=&quot;n&quot;&gt;acc&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;d&lt;/span&gt;   &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_loc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;   &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_taps&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_len&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;ln&lt;/span&gt;  &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m_len&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m_loc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ln&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;acc&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;--&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Notice that the two indices go in opposite directions.  This is an important
feature of any
&lt;a href=&quot;/dsp/2017/09/15/fastfir.html&quot;&gt;filtering&lt;/a&gt;,
implementation where the
&lt;a href=&quot;/dsp/2017/09/15/fastfir.html&quot;&gt;filter&lt;/a&gt;
might not be
&lt;a href=&quot;https://en.wikipedia.org/wiki/Linear_phase&quot;&gt;symmetric&lt;/a&gt;.
For &lt;a href=&quot;https://en.wikipedia.org/wiki/Linear_phase&quot;&gt;symmetric&lt;/a&gt;
&lt;a href=&quot;/dsp/2017/09/15/fastfir.html&quot;&gt;filters&lt;/a&gt;,
the direction the coefficients are read doesn’t really
matter all that much.&lt;/p&gt;

&lt;p&gt;The algorithm was made just a touch confusing by the fact that the data
is kept in a circular buffer.  As a result, the relevant data might cross
the boundary of the circular buffer, from the right half to the left.
If you split the loop into two parts, you can avoid checking for the
buffer split within the loop itself.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;	&lt;span class=&quot;n&quot;&gt;d&lt;/span&gt;   &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m_data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;ln&lt;/span&gt;  &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m_loc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ln&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;acc&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;--&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Finally, the algorithm ended by returning the accumulated sum of products.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;	&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;acc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;That’s the basic
&lt;a href=&quot;/dsp/2017/09/15/fastfir.html&quot;&gt;filtering&lt;/a&gt;
algorithm that you can apply to implement any
&lt;a href=&quot;https://en.wikipedia.org/wiki/Finite_impulse_response&quot;&gt;FIR&lt;/a&gt;
&lt;a href=&quot;/dsp/2017/09/15/fastfir.html&quot;&gt;filter&lt;/a&gt;.  (Remember, for
&lt;a href=&quot;https://en.wikipedia.org/wiki/Finite_impulse_response&quot;&gt;FIR&lt;/a&gt;
&lt;a href=&quot;/dsp/2017/09/15/fastfir.html&quot;&gt;filters&lt;/a&gt;
longer than about 64-taps or so,
&lt;a href=&quot;https://en.wikipedia.org/wiki/Fast_Fourier_transform&quot;&gt;FFT&lt;/a&gt;
methods are faster/better/cheaper in software than the direct form presented
above.)&lt;/p&gt;

&lt;p&gt;Now, how would we modify this algorithm to create an implementation that
would exploit the &lt;a href=&quot;https://en.wikipedia.org/wiki/Linear_phase&quot;&gt;symmetry&lt;/a&gt;
within our &lt;a href=&quot;https://en.wikipedia.org/wiki/Impulse_response&quot;&gt;impulse response&lt;/a&gt;
coefficients?&lt;/p&gt;

&lt;p&gt;We’d start out exactly as before, by adding the new data sample to our
input sample memory.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;&lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;SYMFIR&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;apply&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dat&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;		&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ln&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;acc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

	&lt;span class=&quot;n&quot;&gt;m_data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_loc&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dat&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_loc&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m_len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;m_loc&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;However, that’s about as far as we can go in common with the &lt;a href=&quot;/dsp/2017/12/30/slowfil.html&quot;&gt;previous
algorithm&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The next step is to calculate two pointers into the data–something we didn’t
need to do before.  The first, &lt;code class=&quot;highlighter-rouge&quot;&gt;dpnew&lt;/code&gt;,
will be a pointer to the most recent data that we just added into our buffer,
while the second, &lt;code class=&quot;highlighter-rouge&quot;&gt;dpold&lt;/code&gt;, will point to the oldest data in our buffer.  Since
the buffer has only as many samples within it as we have coefficients in our
&lt;a href=&quot;/dsp/2017/09/15/fastfir.html&quot;&gt;filter&lt;/a&gt;,
we only need to check for wrap around once.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;	&lt;span class=&quot;n&quot;&gt;dpnew&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_loc&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_loc&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;dpnew&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_len&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;dpold&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_loc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;We’ll also set a pointer to our coefficient memory.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;	&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m_taps&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;At each point through the summation, we’ll read two values from our
data memory, one older &lt;code class=&quot;highlighter-rouge&quot;&gt;*dpold&lt;/code&gt; and one newer &lt;code class=&quot;highlighter-rouge&quot;&gt;*dpnew&lt;/code&gt;.  We’ll then add these
two values together, and multiply the result by the
&lt;a href=&quot;/dsp/2017/09/15/fastfir.html&quot;&gt;filter&lt;/a&gt;
coefficient.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;	&lt;span class=&quot;k&quot;&gt;do&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;presum&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dpold&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dpnew&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;acc&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;presum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;So far this is all very straight forward.&lt;/p&gt;

&lt;p&gt;Where this C++ version gets difficult is when we try to handle pointer
wrapping in our circular buffer.  Unlike before, when we only had one pointer
to check, we now
have two pointers that might wrap as we work our way through memory.  Rather
than work through the math of separating this loop into three parts,
I’ll just add a wrap check inside the loop.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;		&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dpold&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_len&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;dpold&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dpnew&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;dpold&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_len&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dpold&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dpnew&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This loop will end before we get to the multiply in the middle of the
&lt;a href=&quot;/dsp/2017/09/15/fastfir.html&quot;&gt;filter&lt;/a&gt;.
So, let’s handle it now and then return our result.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;	&lt;span class=&quot;n&quot;&gt;acc&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dpold&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;acc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;For those who might ask, yes, I do like redundant parentheses.
That’s really beside the point, however.&lt;/p&gt;

&lt;p&gt;The point here is that for an &lt;code class=&quot;highlighter-rouge&quot;&gt;N&lt;/code&gt; point
&lt;a href=&quot;/dsp/2017/09/15/fastfir.html&quot;&gt;filter&lt;/a&gt;,
where &lt;code class=&quot;highlighter-rouge&quot;&gt;N&lt;/code&gt; is odd, we’ve just calculated the result using only
&lt;code class=&quot;highlighter-rouge&quot;&gt;1+(N-1)/2&lt;/code&gt; multiplies, instead of the &lt;code class=&quot;highlighter-rouge&quot;&gt;N&lt;/code&gt; multiplies it would have cost us
before.&lt;/p&gt;

&lt;p&gt;This is the basic algorithm we’ll code up in Verilog in the next section.
However, in Verilog we’ll use a memory in a circular addressing configuration.
That way we don’t have to worry (much) about wrapping the pointers around.
We will, however, need to worry about timing and pipeline scheduling.&lt;/p&gt;

&lt;h2 id=&quot;verilog-outline&quot;&gt;Verilog Outline&lt;/h2&gt;

&lt;p&gt;When we first built our
&lt;a href=&quot;/dsp/2017/12/30/slowfil.html&quot;&gt;slow filter implementation&lt;/a&gt;,
we used Fig 4 to illustrate how
&lt;a href=&quot;/dsp/2017/12/30/slowfil.html&quot;&gt;it&lt;/a&gt; worked.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 4. A Time Multiplexed filter implementation&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/fir-slow-form.svg&quot; alt=&quot;&quot; width=&quot;480&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;This diagram shows data coming in from the left, and going through two tapped
delay lines.  A selector then walks through each of the samples in the
tapped delay line picking a data value.  At the same time, a separate selector
picks a value from the
&lt;a href=&quot;/dsp/2017/12/30/slowfil.html&quot;&gt;filter&lt;/a&gt;’s
&lt;a href=&quot;https://en.wikipedia.org/wiki/Impulse_response&quot;&gt;impulse response&lt;/a&gt;
coefficients.  These two values are shown multiplied together, accumulated,
and then output.&lt;/p&gt;

&lt;p&gt;To build this
&lt;a href=&quot;https://en.wikipedia.org/wiki/Linear_phase&quot;&gt;symmetric filter&lt;/a&gt;,
we’re going to first break the tapped
delay line structure into three parts, as shown in Fig 3.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 5. Breaking the data tapped delay line into three pieces&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/slowsymf-data.svg&quot; alt=&quot;&quot; width=&quot;480&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;The parts on the left and right will be implemented by block RAMs, and
data will appear to “move” through the RAMs by just adjusting the indices
used.  The data point in the middle is point of symmetry for the filter.
This point will not reside within either of the block RAMs.  Instead, we’ll
make this the last item read from the left block RAM, and place this item
into the second block RAM on any new sample.&lt;/p&gt;

&lt;p&gt;When a sample is provided, all the data will shift right by one.  That will
be our first step.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(posedge i_clk)
	if (i_ce)
		dwidx &amp;lt;= dwidx + 1&#39;b1;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Using this index we’ll write the new sample to the left data memory.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(posedge i_clk)
	if (i_ce)
		dmem1[dwidx] &amp;lt;= i_sample;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;We’ll read the mid-point sample from the last value read from this memory.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(posedge i_clk)
	if (i_reset)
		mid_sample &amp;lt;= 0;
	else if (i_ce)
		mid_sample &amp;lt;= dleft;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Finally, we’ll write that mid-point sample to the right half of memory.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(posedge i_clk)
	if (i_ce)
		dmem2[dwidx] &amp;lt;= mid_sample;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Notice that we are using the same write index for both halves of memory.
We’ll have to deal with this a bit in our next step, since we are writing
to the newest memory on the left, and half way through the memory on the right.&lt;/p&gt;

&lt;p&gt;That will handle data movement, what about reading the data?&lt;/p&gt;

&lt;p&gt;To read the data, we’ll set two data pointers–one to each block RAM–when any
new sample comes in.  These will initially
point to the extreme locations in the memory, both the oldest and the most
recent.  These pointers will then walk, in unison, towards the center data
point, as shown in Fig 5 above.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(posedge i_clk)
	if (i_ce)
	begin
		lidx &amp;lt;= dwidx; // Newest value
		ridx &amp;lt;= dwidx-(HALFTAPS[LGNMEM-1:0])+1;
	end else if (not_done_yet)
	begin
		lidx &amp;lt;= lidx - 1&#39;b1;
		ridx &amp;lt;= ridx + 1&#39;b1;
	end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The next steps with the data are fairly straight forward.  There’s not much
magic in them.  First we’ll read the data,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
begin
	dleft  &amp;lt;= dmem1[lidx];	// Left memory
	dright &amp;lt;= dmem2[ridx];	// Right memory&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;then add the two values together,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	dsum &amp;lt;= dleft + dright;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;then multiply them by the filter coefficient,
&lt;a href=&quot;/dsp/2017/09/15/fastfir.html&quot;&gt;filter&lt;/a&gt;
coefficient,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	product &amp;lt;= dsum * tap;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;and add the result to an accumulator.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	acc &amp;lt;= acc + product;
end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;You may notice that we didn’t clear the accumulator, &lt;code class=&quot;highlighter-rouge&quot;&gt;acc&lt;/code&gt;.  We’ll have to
come back to that.  You may also notice we skipped some steps along the way,
although this is the basic algorithm.  So, let’s go back a bit.&lt;/p&gt;

&lt;p&gt;We’re going to need to read the
&lt;a href=&quot;/dsp/2017/09/15/fastfir.html&quot;&gt;filter&lt;/a&gt;
coefficient before we use it.  This will involve resetting the index
to the beginning of the coefficient memory,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
if (i_ce)
begin
	tidx &amp;lt;= 0;	// Filter coefficient index&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;and then reading the next
&lt;a href=&quot;/dsp/2017/09/15/fastfir.html&quot;&gt;filter&lt;/a&gt;
coefficient on every clock subsequent clock until we’re done.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;end else begin
	tidx &amp;lt;= tidx + 1&#39;b1;
	tap &amp;lt;= cmem[tidx];	// Filter coefficient index
end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;At this point, our algorithm roughly looks like Fig 6 below.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 6. The symmetric slow filter&#39;s block diagram&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/slowsymf-blockd.svg&quot; alt=&quot;&quot; width=&quot;480&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;We read from each data block in opposite directions and added the two
values together.  We also read from our coefficient memory, and then multiplied
the
&lt;a href=&quot;/dsp/2017/09/15/fastfir.html&quot;&gt;filter&lt;/a&gt;
coefficient by the data sum.  Finally, we accumulated the products
together to create an output.&lt;/p&gt;

&lt;p&gt;We’re still missing a couple items, though.  For example, we need to
multiply our mid-point by some value.  Let’s
fix that value to be &lt;code class=&quot;highlighter-rouge&quot;&gt;2^(M-1)-1&lt;/code&gt;, also known as the maximum positive integer
that can be represented in &lt;code class=&quot;highlighter-rouge&quot;&gt;M&lt;/code&gt; signed bits.  This works because this sample
value is usually (always?) the largest value in the
&lt;a href=&quot;/dsp/2017/09/15/fastfir.html&quot;&gt;filter&lt;/a&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
if (i_reset)
	midprod &amp;lt;= 0;
else if (m_ce)
	midprod &amp;lt;= (mid_sample &amp;lt;&amp;lt; (TW-1)) - mid_sample;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;At least, that’s the basic idea of how we &lt;em&gt;want&lt;/em&gt; the
&lt;a href=&quot;/dsp/2017/09/15/fastfir.html&quot;&gt;filter&lt;/a&gt; to work.
Sadly, this simplistic approach to the algorithm is going to give us some
headaches when we actually attempt to implement it in the next section.
Why?  Although we have a conceptual idea of what we wish to accomplish,
the devil in this case lies in the details of how we handle the
pipeline scheduling.&lt;/p&gt;

&lt;h2 id=&quot;verilog-implementation&quot;&gt;Verilog Implementation&lt;/h2&gt;

&lt;p&gt;When I first set out to implement
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/slowsymf.v&quot;&gt;this filter&lt;/a&gt;,
I thought I might just quickly modify the &lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/slowfil.v&quot;&gt;generic slow
filter&lt;/a&gt;
I had &lt;a href=&quot;/dsp/2017/12/30/slowfil.html&quot;&gt;presented earlier&lt;/a&gt;.
This is basically what I just presented above in the last section.
I’m mean, all that’s required is two memory reads, a sum and then
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/slowsymf.v&quot;&gt;the filter&lt;/a&gt;
is identical to what it was
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/slowfil.v&quot;&gt;before&lt;/a&gt;.
It’s that simple, right?&lt;/p&gt;

&lt;p&gt;No.  It isn’t.&lt;/p&gt;

&lt;p&gt;As a measure of difficulty, consider this:
I’ve gotten to the point where implementing a basic
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_signal_processing&quot;&gt;DSP&lt;/a&gt;
component like this has become fairly easy and routine.  I therefore gave
myself two days to do the task, and even then I didn’t work on it full time
for both days.  Much to my surprise, I almost didn’t finish the task within
the two days I’d given to myself.&lt;/p&gt;

&lt;p&gt;Why not?&lt;/p&gt;

&lt;p&gt;It wasn’t that the filter was really all that hard to implement,
but rather the problem was scheduling the pipeline.
To understand this, let’s work from the fixed points in the schedule.&lt;/p&gt;

&lt;p&gt;The first fixed points are the memory reads.  In order to make
certain the design tools place the data and
&lt;a href=&quot;/dsp/2017/09/15/fastfir.html&quot;&gt;filter&lt;/a&gt;
coefficients into block RAM,
they can only be accessed in the simplest of ways.  Specifically, each
RAM must takes one clock cycle to read where you do nothing else with the
value read.  Yet moving the time the data were valid from the clock in the
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/slowfil.v&quot;&gt;slow filter&lt;/a&gt;,
to the next (i.e. following the summation) made for all kinds of havoc within
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/slowsymf.v&quot;&gt;my design&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;In a humble admission, I’ll admit that I almost pulled out the
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal methods&lt;/a&gt;
to &lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formally verify&lt;/a&gt;
the design after I struggled so hard getting this to work within the
&lt;a href=&quot;/dsp/2017/11/04/genfil-tb.html&quot;&gt;test bench&lt;/a&gt;.  It seems
I’ve gotten hooked on how easy it is to get a design to work using
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal methods&lt;/a&gt;.
(Yes, it is possible to &lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formally
verify&lt;/a&gt;
a digital &lt;a href=&quot;/dsp/2017/09/15/fastfir.html&quot;&gt;filter&lt;/a&gt; using
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal methods&lt;/a&gt;.  The
problem is that the multiply makes the application of
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal methods&lt;/a&gt;
difficult.  I’ll leave this concept for another day, though, specifically
for some time after I discuss the concept of abstraction in
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal verification&lt;/a&gt;.)&lt;/p&gt;

&lt;p&gt;In the end, in order to get the &lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/slowsymf.v&quot;&gt;following
design&lt;/a&gt;
to work I had to work through the
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/slowsymf.v&quot;&gt;design&lt;/a&gt;
and its &lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/bench/cpp/slowsymf_tb.cpp&quot;&gt;test
bench&lt;/a&gt;
one clock at a time, verifying every value along the way until all of a
sudden
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/slowsymf.v&quot;&gt;the design&lt;/a&gt;
passed.  While I was successful, I do have to admit that my success took more
work than I expected.  Shall we just say my performance at the task just
wasn’t as graceful as I might have liked?&lt;/p&gt;

&lt;p&gt;The key to the success of
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/slowsymf.v&quot;&gt;this design&lt;/a&gt;
lies in the pipeline schedule.  So,
as I was building this algorithm, I scribbled out the pipeline schedule
diagram shown in Fig 7.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 7. Initial Pipeline Schedule&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/slowsymf-schedule.svg&quot; alt=&quot;&quot; width=&quot;720&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;If you remember from our prior discussions of these charts, values are
shown in the column in which they are valid.  Hence &lt;code class=&quot;highlighter-rouge&quot;&gt;i_ce&lt;/code&gt; is true on the
first clock of our cycle.  At that same time, the sample value, &lt;code class=&quot;highlighter-rouge&quot;&gt;i_sample&lt;/code&gt;,
the data write index (&lt;code class=&quot;highlighter-rouge&quot;&gt;dwidx&lt;/code&gt;), mid-point sample from the last time through
(&lt;code class=&quot;highlighter-rouge&quot;&gt;mid_sample&lt;/code&gt;), and the final data value from the left block RAM (&lt;code class=&quot;highlighter-rouge&quot;&gt;dleft&lt;/code&gt;)
are also valid.  On the next clock to the right, the data values may now
be read from memory, hence &lt;code class=&quot;highlighter-rouge&quot;&gt;dmem1[dwidx]&lt;/code&gt; is valid and so forth.  On this
clock also I’ll raise an &lt;code class=&quot;highlighter-rouge&quot;&gt;m_ce&lt;/code&gt; signaling flag so I know where I am in
this portion of the pipeline.&lt;/p&gt;

&lt;p&gt;I’ve taken the time to show particular anchor points to this diagram in
red.  These are the points we worked out above in the last section.  They are
immovable in the pipeline.  Hence, following the &lt;code class=&quot;highlighter-rouge&quot;&gt;m_ce&lt;/code&gt; (first memory read
valid) cycle there’s a first data valid cycle where &lt;code class=&quot;highlighter-rouge&quot;&gt;d_ce&lt;/code&gt; is high.  This
will be the first of many such cycles.  This is followed by a summation
cycle, &lt;code class=&quot;highlighter-rouge&quot;&gt;s_ce&lt;/code&gt;, when the first data sum is true.  This is then followed
by a product cycle, &lt;code class=&quot;highlighter-rouge&quot;&gt;p_ce&lt;/code&gt;, when the first data product is true and so on.&lt;/p&gt;

&lt;p&gt;The items in black are the ones I really struggled to get right.  In
particular, the
first &lt;a href=&quot;/dsp/2017/09/15/fastfir.html&quot;&gt;filter&lt;/a&gt; coefficient
value doesn’t have to be valid until &lt;code class=&quot;highlighter-rouge&quot;&gt;s_ce&lt;/code&gt; clock.
That means its index must be valid the clock prior and &lt;em&gt;not&lt;/em&gt; the clock
prior to that.  This one little difference marked the root of my problems.&lt;/p&gt;

&lt;p&gt;But let’s get to these difficulties in order.&lt;/p&gt;

&lt;p&gt;The first order of business is to allow the user to update the
&lt;a href=&quot;/dsp/2017/09/15/fastfir.html&quot;&gt;filter&lt;/a&gt;’s
coefficients.  This is almost the same exact code as we
&lt;a href=&quot;/dsp/2017/12/30/slowfil.html&quot;&gt;discussed earlier&lt;/a&gt;,
so it really doesn’t need much comment.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	generate if (FIXED_TAPS)
	begin : SET_FIXED_TAPS

		initial $readmemh(INITIAL_COEFFS, tapmem);

	end else begin : DYNAMIC_TAP_ADJUSTMENT
		// Coef memory write index
		reg	[(LGNMEM-1):0]	tapwidx;

		initial	tapwidx = 0;
		always @(posedge i_clk)
			if(i_reset)
				tapwidx &amp;lt;= 0;
			else if (i_tap_wr)
				tapwidx &amp;lt;= tapwidx + 1&#39;b1;

		if (INITIAL_COEFFS != 0)
			initial $readmemh(INITIAL_COEFFS, tapmem);
		always @(posedge i_clk)
			if (i_tap_wr)
				tapmem[tapwidx] &amp;lt;= i_tap;
	end endgenerate&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The next order of business is to move our data pipeline.  This happens any
time a new sample is sent to
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/slowsymf.v&quot;&gt;the filter&lt;/a&gt;,
as indicated by &lt;code class=&quot;highlighter-rouge&quot;&gt;i_ce&lt;/code&gt; being high.&lt;/p&gt;

&lt;p&gt;As you may recall, the &lt;a href=&quot;/blog/2017/08/14/strategies-for-pipelining.html&quot;&gt;global pipeline
strategy&lt;/a&gt;
works quite well for digital
&lt;a href=&quot;/dsp/2017/09/15/fastfir.html&quot;&gt;filter&lt;/a&gt;.
Within this design, however, we’ll be using a &lt;a href=&quot;/blog/2017/08/14/strategies-for-pipelining.html&quot;&gt;traveling
CE&lt;/a&gt;
approach as you saw in Fig 7 above.&lt;/p&gt;

&lt;p&gt;As part of this new sample routine, we’ll increment a data write index
on every new sample.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	initial	dwidx = 0;
	always @(posedge i_clk)
	if (i_ce)
		dwidx &amp;lt;= dwidx + 1&#39;b1;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;There is no reset on this index, despite the initial value.  This lack of a
reset allows
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/slowsymf.v&quot;&gt;the filter&lt;/a&gt;
to be cleared and flushed by holding the &lt;code class=&quot;highlighter-rouge&quot;&gt;i_reset&lt;/code&gt;
and &lt;code class=&quot;highlighter-rouge&quot;&gt;i_ce&lt;/code&gt; lines high, while also forcing &lt;code class=&quot;highlighter-rouge&quot;&gt;i_sample&lt;/code&gt; to be zero for as
many clock cycles as
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/slowsymf.v&quot;&gt;the filter&lt;/a&gt;
has taps.&lt;/p&gt;

&lt;p&gt;We’ll also write our new sample to the first memory bank,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(posedge i_clk)
	if (i_ce)
		dmem1[dwidx] &amp;lt;= i_sample;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;our midpoint sample to the second memory bank,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(posedge i_clk)
	if (i_ce)
		dmem2[dwidx] &amp;lt;= mid_sample;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;and we’ll set our midpoint sample to be the last sample read from the first
memory bank, or &lt;code class=&quot;highlighter-rouge&quot;&gt;dleft&lt;/code&gt; as I’m going to call it with reference to either
of Figs 5 or 6 above.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(posedge i_clk)
	if (i_reset)
		mid_sample &amp;lt;= 0;
	else if (i_ce)
		mid_sample &amp;lt;= dleft;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Since &lt;code class=&quot;highlighter-rouge&quot;&gt;mid_sample&lt;/code&gt; doesn’t need to be constrained to ultra-simple memory
logic, it can be sensitive to the reset.  This will halve the number of
clock cycles it will take to clear
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/slowsymf.v&quot;&gt;this filter&lt;/a&gt;
during a reset, since these zeros will then feed the second half of memory.&lt;/p&gt;

&lt;p&gt;The next signal, &lt;code class=&quot;highlighter-rouge&quot;&gt;pre_acc_ce&lt;/code&gt;, is the one we are going to use to control
whether or not to accumulate a new product into our accumulator.  This is
the control value that will also keep us from accumulating past the last
valid coefficient in
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/slowsymf.v&quot;&gt;our filter&lt;/a&gt;.
For this reason, we start out by counting how many coefficients are remaining.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	assign	taps_left = (NTAPS[LGNTAPS-1:1]-tidx);
	assign	last_tap_index = (taps_left &amp;lt;= 1);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;We’ll also calculate a flag to tell us whether or not we are at the last
data index.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	assign	last_data_index= (NTAPS[LGNTAPS-1:1]-tidx &amp;lt;= 2);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Both of these values are referenced to the pipeline cycle where the index
is valid.  What that means, though, is that this measurement needs to be
propagated to through the pipeline.  This is the purpose of &lt;code class=&quot;highlighter-rouge&quot;&gt;pre_acc_ce&lt;/code&gt;,
the “pre” calculation of whether the accumulator should be updated.
On any new data, &lt;code class=&quot;highlighter-rouge&quot;&gt;pre_acc_ce[0]&lt;/code&gt; gets set to &lt;code class=&quot;highlighter-rouge&quot;&gt;1&#39;b1&lt;/code&gt;.  This starts the beginning
of the accumulator pipeline.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	initial	pre_acc_ce = 4&#39;h0;
	always @(posedge i_clk)
	if (i_reset)
		pre_acc_ce[0] &amp;lt;= 1&#39;b0;
	else if (i_ce)
		pre_acc_ce[0] &amp;lt;= 1&#39;b1;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;It then stays at one until the index for the last coefficient.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	else if ((pre_acc_ce[0])&amp;amp;&amp;amp;(!last_tap_index))
		pre_acc_ce[0] &amp;lt;= 1&#39;b1;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Here we get to one of the surprises of the algorithm.  Because the coefficient
index and the data index are off by one cycle, this &lt;code class=&quot;highlighter-rouge&quot;&gt;last_tap_index&lt;/code&gt; value
isn’t a sufficient indicator of when to turn the &lt;code class=&quot;highlighter-rouge&quot;&gt;pre_acc_ce&lt;/code&gt; value off.
Instead, we’ll turn it off as long as we aren’t starting around again on
the next incoming sample.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	else if (!m_ce)
		pre_acc_ce[0] &amp;lt;= 1&#39;b0;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This &lt;code class=&quot;highlighter-rouge&quot;&gt;pre_acc_ce&lt;/code&gt; value now needs to be propagated through our pipeline.
We’ll use a simple shift register structure for this purpose.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(posedge i_clk)
	if (i_reset)
		pre_acc_ce[3:1] &amp;lt;= 3&#39;b0;
	else
		pre_acc_ce[3:1] &amp;lt;= { pre_acc_ce[2:1],
			((m_ce)||((pre_acc_ce[0])&amp;amp;&amp;amp;(!last_tap_index))) };
	// Where ...
	// pre_acc_ce[0] means the data index is valid
	// pre_acc_ce[1] means the data values are valid, tap index is valid
	// pre_acc_ce[2] means the data sum and tap value are valid
	// pre_acc_ce[3] means that the product is valid&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;We can now interpret &lt;code class=&quot;highlighter-rouge&quot;&gt;pre_acc_ce&lt;/code&gt; as follows.  If &lt;code class=&quot;highlighter-rouge&quot;&gt;pre_acc_ce[0]&lt;/code&gt; is true,
the data &lt;em&gt;index&lt;/em&gt; is valid.  If &lt;code class=&quot;highlighter-rouge&quot;&gt;pre_acc_ce[1]&lt;/code&gt; is true, the data &lt;em&gt;values&lt;/em&gt; are
valid.  If &lt;code class=&quot;highlighter-rouge&quot;&gt;pre_acc_ce[2]&lt;/code&gt; is true, the sum is valid and if &lt;code class=&quot;highlighter-rouge&quot;&gt;pre_acc_ce[3]&lt;/code&gt;
is true then the product is valid and may be accumulated.&lt;/p&gt;

&lt;p&gt;You’ll see how this works more in a moment.&lt;/p&gt;

&lt;p&gt;We’ll next focus on the data read indices.  These will continue to follow the
left and right convention from Figs 5 and 6 above.  Hence we’ll have a left
index, &lt;code class=&quot;highlighter-rouge&quot;&gt;lidx&lt;/code&gt;, and a right index &lt;code class=&quot;highlighter-rouge&quot;&gt;ridx&lt;/code&gt;.  On any reset, these are set to zero,
although this is really more for form than anything else.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	initial	lidx = 0;
	initial	ridx = 0;
	always @(posedge i_clk)
	if (i_reset)
	begin
		lidx &amp;lt;= 0;
		ridx &amp;lt;= 0;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Then, on any new sample, the left data index, &lt;code class=&quot;highlighter-rouge&quot;&gt;lidx&lt;/code&gt; is set to point to the
newest value just written to memory.  The right half data index is a touch
more complicated–and took me many trials to get right.  This index is
given by back tracking from the oldest value by half our
&lt;a href=&quot;/dsp/2017/09/15/fastfir.html&quot;&gt;filter&lt;/a&gt; length.  This
would’ve been the entire size of the second memory, save that we are forcing the
memory to have a power of two size, while the &lt;code class=&quot;highlighter-rouge&quot;&gt;NTAPS&lt;/code&gt; can be any arbitrary
odd number.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	end else if (i_ce)
	begin
		lidx &amp;lt;= dwidx; // Newest value
		ridx &amp;lt;= dwidx-(HALFTAPS[LGNMEM-1:0])+1;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;As a last step, we’ll step the indices as long as this isn’t the last
data index.  The left index steps backwards from the newest value to older
values, while the right index steps forwards from the oldest index to the
newer index.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	end else if ((m_ce)||(!last_data_index))
	begin
		lidx &amp;lt;= lidx - 1&#39;b1;
		ridx &amp;lt;= ridx + 1&#39;b1;
	end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Keep in mind, the &lt;code class=&quot;highlighter-rouge&quot;&gt;last_data_index&lt;/code&gt; criteria here is &lt;em&gt;key&lt;/em&gt;.  In particular,
we are about to read the left data value, &lt;code class=&quot;highlighter-rouge&quot;&gt;dleft&lt;/code&gt;, from the left memory
based upon this index.  This will turn into the mid point value on the
next sample.  For this reason, the indices cannot be allowed to just free
run.&lt;/p&gt;

&lt;p&gt;The second remarkable piece of this logic is the &lt;code class=&quot;highlighter-rouge&quot;&gt;m_ce&lt;/code&gt; criteria.  Our
&lt;code class=&quot;highlighter-rouge&quot;&gt;last_data_index&lt;/code&gt; flag depends upon the cofficient index, not the data index.
This coefficient index isn’t (yet) valid on the &lt;code class=&quot;highlighter-rouge&quot;&gt;m_ce&lt;/code&gt; cycle.  Hence, we need
to continue to walk the index forward even before the first tap index is
valid.  (Yes, this was another one of those details that surprised me as
I built this.)&lt;/p&gt;

&lt;p&gt;A very similar piece of logic is used to determine the
&lt;a href=&quot;/dsp/2017/09/15/fastfir.html&quot;&gt;filter&lt;/a&gt;
coefficient index.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	initial	tidx = 0;
	always @(posedge i_clk)
	if (i_reset)
		tidx &amp;lt;= 0;
	else if (m_ce)
		tidx &amp;lt;= 0;
	else if (!last_tap_index)
		tidx &amp;lt;= tidx + 1&#39;b1;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;While it might look like we might just let this value run as well, keep
in mind that we are using the
&lt;a href=&quot;/dsp/2017/09/15/fastfir.html&quot;&gt;filter&lt;/a&gt;
coefficient index as an indicator of when to stop accumulating.  For this
reason, this index also stops at the end of the coefficient memory.&lt;/p&gt;

&lt;p&gt;That’s the data and coefficient index calculation.  Let’s move on to the
memory read cycle(s).  We’ll mark this cycle with an &lt;code class=&quot;highlighter-rouge&quot;&gt;m_ce&lt;/code&gt; flag, as shown
in our pipeline schedule in Fig 7 above, indicating that this is the first
cycle the memory data is valid.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	initial	m_ce = 1&#39;b0;
	always @(posedge i_clk)
		m_ce &amp;lt;= (i_ce)&amp;amp;&amp;amp;(!i_reset);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;On this cycle we’ll read from the two block RAMs of data.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	initial	dleft  = 0;
	initial	dright = 0;
	always @(posedge i_clk)
	begin
		dleft  &amp;lt;= dmem1[lidx];
		dright &amp;lt;= dmem2[ridx];
	end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Following the outline in Fig 7, the next pipeline cycle and flag is the
data valid cycle, &lt;code class=&quot;highlighter-rouge&quot;&gt;d_ce&lt;/code&gt;.  This follows the &lt;code class=&quot;highlighter-rouge&quot;&gt;m_ce&lt;/code&gt;
flag, and like it this is only valid for one clock cycle.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	initial	d_ce = 0;
	always @(posedge i_clk)
		d_ce &amp;lt;= (m_ce)&amp;amp;&amp;amp;(!i_reset);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Now we can read the coefficient index,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	initial	tap = 0;
	always @(posedge i_clk)
		tap &amp;lt;= tapmem[tidx[(LGNTAPS-2):0]];&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;and add the data values together.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	initial	dsum = 0;
	always @(posedge i_clk)
	if (i_reset)
		dsum &amp;lt;= 0;
	else
		dsum   &amp;lt;= dleft + dright;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;We’ll use the &lt;code class=&quot;highlighter-rouge&quot;&gt;s_ce&lt;/code&gt; signal to mark that the first data summation is valid.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	initial	s_ce = 0;
	always @(posedge i_clk)
		s_ce &amp;lt;= (d_ce)&amp;amp;&amp;amp;(!i_reset);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The data sum times the
&lt;a href=&quot;/dsp/2017/09/15/fastfir.html&quot;&gt;filter&lt;/a&gt;
coefficient is our product value.  If this looks
familiar, it should–this matches the &lt;a href=&quot;/dsp/2017/12/30/slowfil.html&quot;&gt;slow
filter&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/slowfil.v&quot;&gt;code&lt;/a&gt;, and
was drawn from it.  This should also matches our discusion in the last section.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	initial	product = 0;
	always @(posedge i_clk)
		product &amp;lt;= tap * dsum;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The &lt;code class=&quot;highlighter-rouge&quot;&gt;midprod&lt;/code&gt; value is different.  &lt;code class=&quot;highlighter-rouge&quot;&gt;midprod&lt;/code&gt; is the product of the mid-point
sample, &lt;code class=&quot;highlighter-rouge&quot;&gt;mid_sample&lt;/code&gt; times the maximum positive integer value that fits
in &lt;code class=&quot;highlighter-rouge&quot;&gt;TW&lt;/code&gt; bits, or &lt;code class=&quot;highlighter-rouge&quot;&gt;2^(TW-1)-1&lt;/code&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	initial	midprod = 0;
	always @(posedge i_clk)
	if (i_reset)
		midprod &amp;lt;= 0;
	else if (m_ce)
		midprod &amp;lt;= { {(OW-IW-TW+1){mid_sample[IW-1]}},
					mid_sample, {(TW-1){1&#39;b0}}}
				-{ {(OW-IW){mid_sample[IW-1]} }, mid_sample};&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;That then leads us right into the accumulator.  There are three parts to
this.  First, we’ll set it to zero on any reset.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	initial	r_acc = 0;
	always @(posedge i_clk)
	if (i_reset)
		r_acc &amp;lt;= 0;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Second, on the &lt;code class=&quot;highlighter-rouge&quot;&gt;s_ce&lt;/code&gt; cycle (see Fig 7 above), we’ll initialize this
accumulator to be our midpoint product.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	else if (s_ce)
		r_acc &amp;lt;= midprod;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Third, on every subsequent sample with a valid product, we’ll add the
product to our accumulator.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	else if (pre_acc_ce[3])
		r_acc &amp;lt;= r_acc + { {(OW-(IW+TW)){product[(IW+TW-1)]}},
						product };&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Finally, on the same sample that we initialize our accumulator with the
mid-point product, we’ll
set our result to be the last value that had been in the accumulator.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	initial	o_result = 0;
	always @(posedge i_clk)
	if (s_ce)
		o_result &amp;lt;= r_acc;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;In a similar fashion, we’ll set our output clock enable strobe, so that
the rest of the signal processing pipeline can continue to follow the
&lt;a href=&quot;/blog/2017/08/14/strategies-for-pipelining.html&quot;&gt;global CE strategy&lt;/a&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	initial	o_ce = 1&#39;b0;
	always @(posedge i_clk)
		o_ce &amp;lt;= (s_ce)&amp;amp;&amp;amp;(!i_reset);

endmodule&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;That’s all it takes to build a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Linear_phase&quot;&gt;symmetric filter&lt;/a&gt;
running &lt;code class=&quot;highlighter-rouge&quot;&gt;N&lt;/code&gt; times slower than the system clock.&lt;/p&gt;

&lt;p&gt;Perhaps the biggest lesson learned to draw from this discussion is how
dependent I was on the
&lt;a href=&quot;/blog/2017/06/21/looking-at-verilator.html&quot;&gt;simulator&lt;/a&gt;
to get particular values right.
For example, did you notice the strange logic on &lt;code class=&quot;highlighter-rouge&quot;&gt;pre_acc_ce&lt;/code&gt;?  Or how about
the fact that the &lt;code class=&quot;highlighter-rouge&quot;&gt;last_data_index&lt;/code&gt; compared against two instead of zero or
one?  Or perhaps that the &lt;code class=&quot;highlighter-rouge&quot;&gt;taps_left&lt;/code&gt; calculation didn’t depend upon the
total number of taps, but rather &lt;code class=&quot;highlighter-rouge&quot;&gt;(N-1)/2&lt;/code&gt;?  (Remember, &lt;code class=&quot;highlighter-rouge&quot;&gt;N&lt;/code&gt;, the number of
coefficients, &lt;em&gt;must&lt;/em&gt; be an odd number.)  All of these values were determined
with the help of running many simulations.&lt;/p&gt;

&lt;h2 id=&quot;test-bench-performance&quot;&gt;Test Bench Performance&lt;/h2&gt;

&lt;p&gt;When it comes to building the &lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/bench/cpp/slowsymf_tb.cpp&quot;&gt;test bench for this
system&lt;/a&gt;,
there wasn’t a lot of work to be done–thanks to the work we did building
a generic filtering
&lt;a href=&quot;/dsp/2017/11/04/genfil-tb.html&quot;&gt;test bench&lt;/a&gt;
some time earlier.  Even better, if you
&lt;a href=&quot;http://meldmerge.org&quot;&gt;meld&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/bench/cpp/slowsymf_tb.cpp&quot;&gt;this test bench driver&lt;/a&gt;
against the
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/bench/cpp/slowfil_tb.cpp&quot;&gt;test bench driver&lt;/a&gt;
for the
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/slowfil.v&quot;&gt;slow filter&lt;/a&gt;,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;meld slowfil_tb.cpp slowsymf_tb.cpp&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;you’ll see only a very small, limited number of (key) differences.  While most
of these are concerned with adjusting
&lt;a href=&quot;/dsp/2017/09/15/fastfir.html&quot;&gt;filter&lt;/a&gt;
length related parameters, there is one particular difference worth commenting
on.  That difference is in the &lt;code class=&quot;highlighter-rouge&quot;&gt;testload()&lt;/code&gt; function.&lt;/p&gt;

&lt;p&gt;As you may recall from our discussion of the
&lt;a href=&quot;/dsp/2017/11/04/genfil-tb.html&quot;&gt;generic filtering test
harness&lt;/a&gt;, the &lt;code class=&quot;highlighter-rouge&quot;&gt;testload&lt;/code&gt;
method allows us to load coefficients into the
&lt;a href=&quot;/dsp/2017/09/15/fastfir.html&quot;&gt;filter&lt;/a&gt;,
and then test the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Impulse_response&quot;&gt;impulse response&lt;/a&gt;
of the filter to insure those coefficients were loaded correctly.  In our
case, this also gives us a chance to verify that the filter’s response is
&lt;a href=&quot;https://en.wikipedia.org/wiki/Linear_phase&quot;&gt;symmetric&lt;/a&gt;
as we had intended.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;        &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;    &lt;span class=&quot;nf&quot;&gt;testload&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nlen&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;c1&quot;&gt;// Load the given coefficients into the filter
&lt;/span&gt;		&lt;span class=&quot;n&quot;&gt;load&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nlen&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

		&lt;span class=&quot;c1&quot;&gt;// Loop through and test each coefficient
&lt;/span&gt;		&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NTAPS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
			&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;m&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;If the coefficient comes before the midpoint, it should match the data
given to this function and passed to &lt;code class=&quot;highlighter-rouge&quot;&gt;load&lt;/code&gt; above.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;			&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MIDP&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
				&lt;span class=&quot;n&quot;&gt;assert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Likewise if this is the midpoint, then the coefficient should be equal to
the fixed value, &lt;code class=&quot;highlighter-rouge&quot;&gt;(1&amp;lt;&amp;lt;(TW-1))-1&lt;/code&gt;, where &lt;code class=&quot;highlighter-rouge&quot;&gt;TW&lt;/code&gt; remains the maximum number of
bits in any coefficient.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;			&lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MIDP&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
				&lt;span class=&quot;n&quot;&gt;assert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;TW&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;On the other side of the midpoint, the coefficients should read back in
reverse order.  In other words, here is where we check the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Linear_phase&quot;&gt;symmetry&lt;/a&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;			&lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NTAPS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt;
				&lt;span class=&quot;n&quot;&gt;assert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NTAPS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Finally, anything beyond the number of taps in the filter should return zero.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;			&lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;
				&lt;span class=&quot;n&quot;&gt;assert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
		&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Once this is accomplished, we can now use our &lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/bench/cpp/slowsymf_tb.cpp&quot;&gt;test bench&lt;/a&gt;
&lt;a href=&quot;/dsp/2017/11/04/genfil-tb.html&quot;&gt;structure&lt;/a&gt;
to measure
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/slowsymf.v&quot;&gt;the filter&lt;/a&gt;’s
performance against the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Low-pass_filter&quot;&gt;lowpass filter&lt;/a&gt;
configuration we’ve been testing against.  The result is a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Stopband&quot;&gt;stopband&lt;/a&gt;
rejection roughly between -55 and -54 dB, which is just what we were expecting.&lt;/p&gt;

&lt;p&gt;That’s not that bad, especially if you consider that we only used half as many
clock cycles as the last &lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/slowfil.v&quot;&gt;slow filter
we studied&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/slowsymf.v&quot;&gt;This filter
implementation&lt;/a&gt;
marks one of those times where a little bit of
engineering up front will spare you a lot of design resources later.  That’s
why we added a touch more mathematics above to &lt;a href=&quot;/dsp/2017/09/15/fastfir.html&quot;&gt;what we had done
before&lt;/a&gt;.  Sure,
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/slowsymf.v&quot;&gt;our
implementation&lt;/a&gt;
is a touch more complicated than &lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/slowfil.v&quot;&gt;the last slow
filter&lt;/a&gt;.
But look at what we gained: twice the performance!  That’s what makes
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/slowsymf.v&quot;&gt;this filtering
implementation&lt;/a&gt;
valuable.  How applicable is it?  This approach applies to all filters
designed via the &lt;em&gt;optimal&lt;/em&gt; &lt;a href=&quot;https://en.wikipedia.org/wiki/Parks-McClellan_filter_design_algorithm&quot;&gt;Parks and McClellan filter design
algorithm&lt;/a&gt;.
In other words, this is almost a universally applicable optimization among
&lt;a href=&quot;https://en.wikipedia.org/wiki/Finite_impulse_response&quot;&gt;FIR&lt;/a&gt;
&lt;a href=&quot;/dsp/2017/09/15/fastfir.html&quot;&gt;filter&lt;/a&gt; implementations.&lt;/p&gt;

&lt;p&gt;As I mentioned above, we have yet to discuss many other types of
&lt;a href=&quot;/dsp/2017/09/15/fastfir.html&quot;&gt;filtering&lt;/a&gt;
implementations.  Perhaps this simplest
&lt;a href=&quot;/dsp/2017/09/15/fastfir.html&quot;&gt;filter&lt;/a&gt;
to build next would be a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Half-band_filter&quot;&gt;half band filter&lt;/a&gt;.  For
certain &lt;a href=&quot;/dsp/2017/09/15/fastfir.html&quot;&gt;filters&lt;/a&gt;, a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Half-band_filter&quot;&gt;half band filter&lt;/a&gt;
implementation can be built for half again as many resources as we just used.&lt;/p&gt;

&lt;p&gt;We’ll have to come back again on another day, though, in order to demonstrate
and discuss some of these other
&lt;a href=&quot;/dsp/2017/09/15/fastfir.html&quot;&gt;filters&lt;/a&gt;.&lt;/p&gt;
&lt;hr /&gt;&lt;p&gt;&lt;em&gt;There is one glory of the sun, and another glory of the moon, and another glory of the stars: for one star differeth from another star in glory.  (1Cor 15:41)&lt;/em&gt;</description>
        <pubDate>Thu, 17 May 2018 00:00:00 -0400</pubDate>
        <link>https://zipcpu.com/dsp/2018/05/17/slowsymf.html</link>
        <guid isPermaLink="true">https://zipcpu.com/dsp/2018/05/17/slowsymf.html</guid>
        
        
        <category>dsp</category>
        
      </item>
    
      <item>
        <title>Updated Projects List</title>
        <description>&lt;p&gt;If you haven’t noticed, there’s a
&lt;a href=&quot;/projects.html&quot;&gt;link&lt;/a&gt;
on the left of each page to the
&lt;a href=&quot;/projects.html&quot;&gt;projects&lt;/a&gt;
I’ve been working on.
&lt;a href=&quot;/projects.html&quot;&gt;That page&lt;/a&gt;
doesn’t get updated nearly as often as it should be.  However, I thought I’d
let you know that I updated it today.&lt;/p&gt;

&lt;p&gt;Perhaps the biggest new item is that I’m now teaching a two-day formal
verification course.  If you’d me to come and teach formal verification
at your workplace, please let me know.  I’m also prepared to offer individual
lessons via video teleconferencing.&lt;/p&gt;

&lt;p&gt;Other new projects listed include many of the projects you’ve seen presented
&lt;a href=&quot;https://zipcpu.com/&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Chief among these are the &lt;a href=&quot;/dsp/dsp.html&quot;&gt;DSP posts&lt;/a&gt;.
Hence, the page now lists the
&lt;a href=&quot;https://github.com/ZipCPU/cordic&quot;&gt;sine wave generators&lt;/a&gt; we’ve discussed
on the blog,
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters&quot;&gt;filters&lt;/a&gt;,
and
&lt;a href=&quot;https://github.com/ZipCPU/interpolation&quot;&gt;interpolators&lt;/a&gt;.  Further, the
&lt;a href=&quot;https://github.com/ZipCPU/dblclockfft&quot;&gt;FFT&lt;/a&gt;
is undergoing a
&lt;a href=&quot;https://github.com/ZipCPU/dblclockfft/tree/dev&quot;&gt;fascinating transformation&lt;/a&gt;
to make it more general purpose, but that’s far from complete.&lt;/p&gt;

&lt;p&gt;I also added a desscription to some of the items that had no description
before.  Perhaps the most interesting of these is the GPS schooled clock–a
basic project that can lock an internal FPGA counter to the PPS output of a
PMod GPS.&lt;/p&gt;

&lt;p&gt;Feel free to check out this new and updated project page, and by all means
please write if you find any broken links, have any questions, comments,
or suggestions!&lt;/p&gt;
&lt;hr /&gt;&lt;p&gt;&lt;em&gt;The preacher sought to find out acceptable words: and that which was written was upright, even words of truth. (Eccl 12:10)&lt;/em&gt;</description>
        <pubDate>Mon, 30 Apr 2018 00:00:00 -0400</pubDate>
        <link>https://zipcpu.com/blog/2018/04/30/updated-projects.html</link>
        <guid isPermaLink="true">https://zipcpu.com/blog/2018/04/30/updated-projects.html</guid>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>Aggregating verified modules together</title>
        <description>&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 1. The ZipCPU&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/zipcpu.svg&quot; alt=&quot;Block diagram of the ZipCPU, showing five pipeline stages&quot; width=&quot;360&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;If you’ve been following my work with the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;,
you’ll know that I have formally verified &lt;a href=&quot;/blog/2018/01/22/formal-progress.html&quot;&gt;all of the leaf
modules&lt;/a&gt;,
and that I am now working on verifying
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;the CPU&lt;/a&gt;
&lt;a href=&quot;/blog/2018/04/02/formal-cpu-bugs.html&quot;&gt;as a whole&lt;/a&gt;.
By “leaf module”, I mean a design component that references no other design
components.
You might also remember that &lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;I am rather new to formal
verification&lt;/a&gt;,
having only picked it up within this last year.  Verifying the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
may be the most complex design I’ve tried to verify yet.&lt;/p&gt;

&lt;p&gt;Prior to my attempts at formally verifying the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;,
the most difficult proof I had worked on was for a proprietary block
floating point module.  That module assigned a single exponent for all
of the values within a block of &lt;code class=&quot;highlighter-rouge&quot;&gt;2^N&lt;/code&gt; numbers, and then output the input
numbers sequentially together with their assigned floating point value.  Like
the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;,
it also involved proving a module with a leaf module underneath it.
The alignment was very difficult to get right in that implementation
and so I dependended heavily upon the &lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formally verified
properties&lt;/a&gt;
of those two modules in order to have the assurance that the component
even worked.&lt;/p&gt;

&lt;p&gt;Along the way, I’ve learned that there are some tricks to aggregating
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formally verified&lt;/a&gt;
submodules together in order to prove the whole.  I’ve now learned two
particular techniques, abstraction and invariants, to help
control the complexity of a formal proof.
Today’s discussion will focus on invariants.  If the
&lt;a href=&quot;https://www.blueletterbible.org/kjv/jas/4/15&quot;&gt;Lord is willing&lt;/a&gt;,
we’ll come back and discuss how to use abstraction, and present several
examples of it.&lt;/p&gt;

&lt;p&gt;I would love to declare, before starting out, that I am an expert on these
techniques.  I’m not.  Perhaps if I had found some article
or set of articles describing them I might be able to declare some amount
of expertise.  Sadly, while I found
a small number of articles describing invariants, I struggled to relate the
concepts presented within those articles to the
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal verification&lt;/a&gt;
problems
I was dealing with.  The one source I found to guide me along this road
was a presentation from &lt;a href=&quot;https://www.onespin.com&quot;&gt;OneSpin Solutions&lt;/a&gt; at
&lt;a href=&quot;https://dvcon.org&quot;&gt;DVCon&lt;/a&gt; 2018 in San Jose.&lt;/p&gt;

&lt;p&gt;So with credit to &lt;a href=&quot;https://www.onespin.com&quot;&gt;OneSpin Solutions&lt;/a&gt;, here’s
what I have learned about
invariants and how they apply to
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;Formal Verification&lt;/a&gt;.
More than that, I’ll
try to keep this presentation simple enough to be understandable, and
focused on how these topics apply to the
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal verification&lt;/a&gt;
of complex RTL modules.&lt;/p&gt;

&lt;h2 id=&quot;formal-property-review&quot;&gt;Formal Property Review&lt;/h2&gt;

&lt;p&gt;If you are coming in to the discussion late, then there are two concepts
you must understand in order to follow the discussion below.  These are
the &lt;code class=&quot;highlighter-rouge&quot;&gt;assume()&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;assert()&lt;/code&gt; System Verilog operators.  I like to explain
these with a set of diagrams describing the state of a design at any
given point in time.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 2. Formal regions of relevance&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/formal-bmc.svg&quot; alt=&quot;&quot; width=&quot;360&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;One such example state diagram is shown in Fig 2.  Consider every point in
this image as representing one state of all the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flip-flop_(electronics)&quot;&gt;flip-flops&lt;/a&gt;
in your design.  Any change to one of the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flip-flop_(electronics)&quot;&gt;flip-flops&lt;/a&gt;
in your design will move your system’s state to a new point on the diagram.&lt;/p&gt;

&lt;p&gt;Several parts of this diagram are worth noting.&lt;/p&gt;

&lt;p&gt;First, note that your design starts from an initial state, as defined by the
&lt;code class=&quot;highlighter-rouge&quot;&gt;initial&lt;/code&gt; statements within your design.  From this point, the inputs to your
design together with the logic within your design will cause the design
to move from one state to another.&lt;/p&gt;

&lt;p&gt;Second, note that there are three different types of states you can be in.
The first set of states are the set of “valid” states.  These are all of the
states that may be reached from your initial state without violating any
&lt;code class=&quot;highlighter-rouge&quot;&gt;assert&lt;/code&gt;ions within your design.  These are shown in green.&lt;/p&gt;

&lt;p&gt;The second set of states are those shown in red.  These are the “illegal” or
“invalid” states.  These are defined by all those states that violate an
&lt;code class=&quot;highlighter-rouge&quot;&gt;assert()&lt;/code&gt; statements within your design.
Your goal, using formal methods, will be to prove that you cannot cross from
a point in the set of valid states to one of the invalid states.&lt;/p&gt;

&lt;p&gt;There is a third set of states.  This set is shown by the largest region
containing all of the others.  This is the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Universe_(mathematics)&quot;&gt;universe&lt;/a&gt;
of all possible sets of
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flip-flop_(electronics)&quot;&gt;flip-flop&lt;/a&gt;
(register) combinations of values within your design.  Initially, this set is
defined by every
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flip-flop_(electronics)&quot;&gt;flip-flop&lt;/a&gt;
combination in your design.  Hence if you have &lt;code class=&quot;highlighter-rouge&quot;&gt;N&lt;/code&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flip-flop_(electronics)&quot;&gt;flip-flops&lt;/a&gt;
in your design, then without any further assumptions there are initially
&lt;code class=&quot;highlighter-rouge&quot;&gt;2^N&lt;/code&gt; states in this set.  Not all of these states will be &lt;em&gt;reachable&lt;/em&gt; from
your initial state.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: left&quot;&gt;&lt;caption&gt;Fig 3. The Effect of an Assumption&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/formal-bmc-assume.svg&quot; alt=&quot;&quot; width=&quot;360&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;Within your design, you have two sorts of statements you can make about the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flip-flop_(electronics)&quot;&gt;flip-flops&lt;/a&gt;
within your design.  The first is the &lt;code class=&quot;highlighter-rouge&quot;&gt;assume()&lt;/code&gt; statement.  This reduces the
size of the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Universe_(mathematics)&quot;&gt;universe&lt;/a&gt;
of values your
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flip-flop_(electronics)&quot;&gt;flip-flops&lt;/a&gt;
may be set to.&lt;/p&gt;

&lt;p&gt;To use the &lt;a href=&quot;/zipcpu/2018/04/17/ziptimer.html&quot;&gt;example of a
counter&lt;/a&gt;,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	if (i_reset)
		r_value &amp;lt;= 0;
	else if (i_start)
		r_value &amp;lt;= TIMEOUT;
	else if (r_value != 0)
		r_value &amp;lt;= r_value - 1&#39;b1;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;we might assume that the &lt;code class=&quot;highlighter-rouge&quot;&gt;i_reset&lt;/code&gt; signal is always zero.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(*)
	assume(!i_reset);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This will restrict the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Universe_(mathematics)&quot;&gt;universe&lt;/a&gt;
of possibilities to only those where &lt;code class=&quot;highlighter-rouge&quot;&gt;i_reset&lt;/code&gt; is
always zero.&lt;/p&gt;

&lt;p&gt;The goal of
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal methods&lt;/a&gt;
is to examine &lt;em&gt;every possible&lt;/em&gt; state your design can enter into in order
to prove that your design will never reach an &lt;em&gt;invalid&lt;/em&gt; state.
As I’m sure you can imagine, this task can be a challenge.  In general, this
challenge is &lt;code class=&quot;highlighter-rouge&quot;&gt;NP-hard&lt;/code&gt;–the computational complexity is roughly exponential
in the size of the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Universe_(mathematics)&quot;&gt;universe&lt;/a&gt;
within your design.  Hence, the smaller you can make the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Universe_(mathematics)&quot;&gt;universe&lt;/a&gt;
of possibilities the easier it will be to verify a design.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 4. The Effect of an Assertion&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/formal-bmc-assert.svg&quot; alt=&quot;&quot; width=&quot;360&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;The second basic formal statement is the &lt;code class=&quot;highlighter-rouge&quot;&gt;assert()&lt;/code&gt; statement.  Unlike the
&lt;code class=&quot;highlighter-rouge&quot;&gt;assume()&lt;/code&gt; statement which limits the size of the search space, the &lt;code class=&quot;highlighter-rouge&quot;&gt;assert()&lt;/code&gt;
statement declares particular states within that
&lt;a href=&quot;https://en.wikipedia.org/wiki/Universe_(mathematics)&quot;&gt;universe&lt;/a&gt;
are somehow “illegal” as shown in Fig 4.  When you use
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal methods&lt;/a&gt;,
your goal will be to guarantee your design remains in a legal state.&lt;/p&gt;

&lt;p&gt;If we return to the
&lt;a href=&quot;/zipcpu/2018/04/17/ziptimer.html&quot;&gt;timer example&lt;/a&gt;
above, we might assert that value of the counter is never one greater than
&lt;code class=&quot;highlighter-rouge&quot;&gt;TIMEOUT&lt;/code&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(*)
	assert(r_value != TIMEOUT+1);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;When applying
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal methods&lt;/a&gt;
to this example, the engine will quickly point out that
the initial state may lie within the red or illegal states–since we did nothing
to restrict &lt;code class=&quot;highlighter-rouge&quot;&gt;r_value&lt;/code&gt;s contents initially.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;initial r_value = 0;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;These two operators, &lt;code class=&quot;highlighter-rouge&quot;&gt;assume&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;assert&lt;/code&gt;, alone should be enough to get you
started with
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal methods&lt;/a&gt;,
and there’s a lot you can do with them.  However, if you want to &lt;em&gt;prove&lt;/em&gt; that
your design will work for all time rather than just the first &lt;code class=&quot;highlighter-rouge&quot;&gt;S&lt;/code&gt; time steps,
then you will need to apply the
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal method&lt;/a&gt;
called
&lt;a href=&quot;/blog/2018/03/10/induction-exercise.html&quot;&gt;induction&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/blog/2018/03/10/induction-exercise.html&quot;&gt;Induction&lt;/a&gt;
starts by assuming your design is somewhere among the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Universe_(mathematics)&quot;&gt;universe&lt;/a&gt;
of all possible states, and that the initial state the engine has chosen
is not illegal.  Its first
step is to create &lt;code class=&quot;highlighter-rouge&quot;&gt;S&lt;/code&gt; time steps where your design stays out of the
illegal set of states.  Then, on the &lt;code class=&quot;highlighter-rouge&quot;&gt;S+1&lt;/code&gt; time step, it tries to see if it
is possible to enter into the set of illegal states.&lt;/p&gt;

&lt;p&gt;The difficult part of this
&lt;a href=&quot;/blog/2018/03/10/induction-exercise.html&quot;&gt;inductive step&lt;/a&gt;
is that the formal engine cannot tell the difference between reachable states
and unreachable states.  This can be &lt;a href=&quot;/blog/2018/03/10/induction-exercise.html&quot;&gt;particularly
problematic&lt;/a&gt;
for the new user of
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal methods&lt;/a&gt;
to understand.
A common refrain is, “how did the formal engine put my design into this
state?  There’s no way it can get there!”&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: left&quot;&gt;&lt;caption&gt;Fig 5. The Lesson of Induction&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/formal-induction-soln.svg&quot; alt=&quot;&quot; width=&quot;360&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;Addressing this problem was the subject of a
&lt;a href=&quot;/blog/2018/03/10/induction-exercise.html&quot;&gt;prior article&lt;/a&gt;.
In that article, I explained that you must use either an &lt;code class=&quot;highlighter-rouge&quot;&gt;assume&lt;/code&gt; or an &lt;code class=&quot;highlighter-rouge&quot;&gt;assert&lt;/code&gt;
to keep the formal engine from reaching any unreachable states, or you will
never be able to fully &lt;em&gt;prove&lt;/em&gt; your design meets the properties you have
asserted for all time.&lt;/p&gt;

&lt;p&gt;Following our example of a timer, the formal engine might pick a value for
&lt;code class=&quot;highlighter-rouge&quot;&gt;r_value&lt;/code&gt; that was &lt;code class=&quot;highlighter-rouge&quot;&gt;TIMEOUT+S+2&lt;/code&gt;.  It would then follow &lt;code class=&quot;highlighter-rouge&quot;&gt;r_value&lt;/code&gt; for
&lt;code class=&quot;highlighter-rouge&quot;&gt;S&lt;/code&gt; steps until &lt;code class=&quot;highlighter-rouge&quot;&gt;r_value&lt;/code&gt; was &lt;code class=&quot;highlighter-rouge&quot;&gt;TIMEOUT+2&lt;/code&gt;.  On the next step, our property
that &lt;code class=&quot;highlighter-rouge&quot;&gt;(r_value != TIMEOUT+1)&lt;/code&gt; would be violated.&lt;/p&gt;

&lt;p&gt;To fix this, one would need to assert instead that &lt;code class=&quot;highlighter-rouge&quot;&gt;r_value &amp;lt;= TIMEOUT&lt;/code&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(*)
	assert(r_value &amp;lt;= TIMEOUT);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This makes the size of the “red” area large enough to include the whole
&lt;a href=&quot;https://en.wikipedia.org/wiki/Universe_(mathematics)&quot;&gt;universe&lt;/a&gt;, as shown
in Fig 5.  To follow the consequence of this in our example above,
&lt;code class=&quot;highlighter-rouge&quot;&gt;r_value&lt;/code&gt; would never be allowed to be &lt;code class=&quot;highlighter-rouge&quot;&gt;TIMEOUT+S+2&lt;/code&gt;.  It would only be allowed
to have a valid value.&lt;/p&gt;

&lt;p&gt;To know which of the two, &lt;code class=&quot;highlighter-rouge&quot;&gt;assert&lt;/code&gt; or &lt;code class=&quot;highlighter-rouge&quot;&gt;assume&lt;/code&gt;, is appropriate at any given
time, I’ve always used what I call the &lt;em&gt;master rule of Formal Verification&lt;/em&gt;
shown in Fig 6: &lt;em&gt;assume inputs&lt;/em&gt;, then &lt;em&gt;assert&lt;/em&gt; properties of both
&lt;em&gt;internal states and outputs&lt;/em&gt;.&lt;/p&gt;
&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 6. Master rule of Formal Verification&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/fv-master-rule.svg&quot; alt=&quot;&quot; width=&quot;280&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;This rule has served me well for all of my
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal verification&lt;/a&gt;
efforts to date.  Now that I’ve discovered I need to aggregate modules together,
I’ve had to learn some of the fine nuances of this rule.  These nuances
are the subject of the rest of this article.&lt;/p&gt;

&lt;h2 id=&quot;the-concept-of-an-invariant&quot;&gt;The Concept of an Invariant&lt;/h2&gt;

&lt;p&gt;What the master rule of
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal verification&lt;/a&gt;
doesn’t capture is how you deal
with things that have already been proven.  For example, let’s suppose &lt;code class=&quot;highlighter-rouge&quot;&gt;A&lt;/code&gt;
is a set of assumptions, and &lt;code class=&quot;highlighter-rouge&quot;&gt;B&lt;/code&gt; is a set of assertions.  Once you’ve proven
that &lt;code class=&quot;highlighter-rouge&quot;&gt;A&lt;/code&gt; implies &lt;code class=&quot;highlighter-rouge&quot;&gt;B&lt;/code&gt;, which I shall write as &lt;code class=&quot;highlighter-rouge&quot;&gt;A-&amp;gt;B&lt;/code&gt;, then you shouldn’t need
to prove it again.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: left&quot;&gt;&lt;caption&gt;Fig 7. (Some caption)&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/formal-invariants.svg&quot; alt=&quot;&quot; width=&quot;360&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;This is the concept of an Invariant.  Once you know that &lt;code class=&quot;highlighter-rouge&quot;&gt;A-&amp;gt;B&lt;/code&gt;, then &lt;code class=&quot;highlighter-rouge&quot;&gt;A-&amp;gt;B&lt;/code&gt;
becomes an invariant of your design.  Instead of reproving it, you may now treat
it as an assumption.  This becomes especially useful when trying to deal
with complex proofs. If you can reduce the complexity, you can then verify
larger and larger designs.&lt;/p&gt;

&lt;p&gt;There are two situations where I have found to apply this.  The first is
that of a parent module with a child (or leaf) module underneath it.  The
second place is when the proof of a design can be broken into separate sections.
I’ve encountered both while trying to verify the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;.  We’ll
examine each in turn.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 8. ZipCPU&#39;s module hierarchy&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/files-zipcpu-proved.svg&quot; alt=&quot;&quot; width=&quot;240&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;To explain the first situation, consider the module hierarchy (file structure)
of the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
shown in Fig 8.  The
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; consists of a
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/dev/rtl/core/zipcpu.v&quot;&gt;master CPU&lt;/a&gt;
file, an &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/dev/rtl/core/idecode.v&quot;&gt;instruction
decoder&lt;/a&gt;, an
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/dev/rtl/core/cpuops.v&quot;&gt;ALU&lt;/a&gt; with a
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/dev/rtl/core/mpyop.v&quot;&gt;multiply component&lt;/a&gt;
within it, a &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/dev/rtl/ex/wbdblpriarb.v&quot;&gt;twin bus
arbiter&lt;/a&gt;,
and one of two &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/dev/rtl/core/memops.v&quot;&gt;memory
controllers&lt;/a&gt;.
I use the red bar in Fig 8 to indicate the
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal properties&lt;/a&gt;
within the design.  Normally these properties are found at the end of the
source file.  You’d therefore normally expect this red bar to be at the bottom
of each file within the diagram.  However, since the concept of invariants
turns these properties on end, I show the red bar in this figure at the top
of the file–for illustration purposes.&lt;/p&gt;

&lt;p&gt;The other three components of the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; were abstracted.
These were the
&lt;a href=&quot;/zipcpu/2017/11/18/wb-prefetch.html&quot;&gt;prefetch&lt;/a&gt;,
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/div.v&quot;&gt;divide&lt;/a&gt;, and
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/mpyop.v&quot;&gt;multiply&lt;/a&gt;.
These are shown in Fig 8 as empty files with dotted lines around them,
indicating that due to the abstraction they have very little logic remaining
within them.  You can find their abstract representations in
my &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/dev/bench/formal&quot;&gt;bench/formal&lt;/a&gt;
directory.  These also made the proof easier, but for now we’ll leave the
mechanics of this for a topic for a future article.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: left&quot;&gt;&lt;caption&gt;Fig 9. Invariants applied to a parent/leaf module hierarchy&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/invariance-external.svg&quot; alt=&quot;&quot; width=&quot;480&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;To understand how I applied the principle of invariants to this design,
consider Fig 9.  This shows a parent module and a leaf or child module–both
with assertions and assumptions within them.&lt;/p&gt;

&lt;p&gt;In my first step, I verified that the leaf module works.  This is shown in the
left side of Fig 9.  During this step, I ignored the parent module, and only
proved that if the child’s assumptions held then the child would never enter
into an illegal state.&lt;/p&gt;

&lt;p&gt;Once the assumptions and module logic had been used to prove the assertions
within the module, I then switched my focus to the parent.  This is shown
on the right of Fig 9.  In this case, I no longer needed to prove the properties
of the child.  Instead, I needed to prove the properties of the parent.  To do
this, I asserted that the assumptions of the child held, and then assumed that
the assertions therefore held as well.&lt;/p&gt;

&lt;p&gt;Hmm, that statement was about as confusing as some of the mathematical articles
I’ve read on this topic.  Let me try explaining that again.&lt;/p&gt;

&lt;p&gt;Suppose we let &lt;code class=&quot;highlighter-rouge&quot;&gt;LA&lt;/code&gt; refer to the set of assumptions within the leaf module, and
&lt;code class=&quot;highlighter-rouge&quot;&gt;LB&lt;/code&gt; refer to the set of assertions within the leaf module.  By
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formally verifying&lt;/a&gt;
that module, I’ve now proved that &lt;code class=&quot;highlighter-rouge&quot;&gt;LA -&amp;gt; LB&lt;/code&gt;.
Unwrapping this a touch, this is equivalent to the
statement that either &lt;code class=&quot;highlighter-rouge&quot;&gt;LA&lt;/code&gt; is false, or &lt;code class=&quot;highlighter-rouge&quot;&gt;LB&lt;/code&gt; must be true: &lt;code class=&quot;highlighter-rouge&quot;&gt;(!LA)||(LB)&lt;/code&gt;.
Said another way, either one of the assumptions of this module must be false,
or all the assertions must be true.&lt;/p&gt;

&lt;p&gt;Now I want to move on to the parent module.  In this case, I have the additional
assumptions &lt;code class=&quot;highlighter-rouge&quot;&gt;PA&lt;/code&gt; and assertions &lt;code class=&quot;highlighter-rouge&quot;&gt;PB&lt;/code&gt; from the parent and I would like to prove
that &lt;code class=&quot;highlighter-rouge&quot;&gt;PA-&amp;gt;PB&lt;/code&gt;.
However, I also need to deal with the leaf module.  For the leaf module, I
know that &lt;code class=&quot;highlighter-rouge&quot;&gt;LA-&amp;gt;LB&lt;/code&gt;.  What I don’t know is whether or not &lt;code class=&quot;highlighter-rouge&quot;&gt;LA&lt;/code&gt; holds since
it consists of values provided by the parent module.  Unless and until I know
that &lt;code class=&quot;highlighter-rouge&quot;&gt;LA&lt;/code&gt; holds, I really know nothing about &lt;code class=&quot;highlighter-rouge&quot;&gt;LB&lt;/code&gt;.  Further, since the wires
composing &lt;code class=&quot;highlighter-rouge&quot;&gt;LA&lt;/code&gt; come from the parent, what I really need to do is to &lt;em&gt;assert&lt;/em&gt;
these properties hold in order to guarantee the proper functioning of the leaf.
Hence, I will now assert &lt;code class=&quot;highlighter-rouge&quot;&gt;LA&lt;/code&gt; and assume &lt;code class=&quot;highlighter-rouge&quot;&gt;LB&lt;/code&gt;.  This is backwards from how I
treated these components before.  As a result, I will assume &lt;code class=&quot;highlighter-rouge&quot;&gt;PA&amp;amp;LB&lt;/code&gt; and assert
&lt;code class=&quot;highlighter-rouge&quot;&gt;PB&amp;amp;LA&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The fascinating part of this is that the master rule of
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal verification&lt;/a&gt;
still applies.  We’re still &lt;em&gt;assuming&lt;/em&gt; the inputs to the parent module and
&lt;em&gt;asserting&lt;/em&gt; the properties of the internal state and any outputs.  How can this
be?  It works because the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flip-flop_(electronics)&quot;&gt;flip-flops&lt;/a&gt;
composing the internal state of the parent module are the input
connections to the child.  Hence the assumptions of the child’s inputs
are now outputs from the parent and so they may be asserted.  Likewise the
child’s outputs are now the parent’s inputs, and so it makes sense to make
assumptions about them.&lt;/p&gt;

&lt;p&gt;It this is still confusing, relax, I’ll show some code snippets
to illustrate how I applied this concept in the next section.&lt;/p&gt;

&lt;p&gt;The second way that invariants can be used within a design is within a given
design component (module).  In my case, it was within the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/dev/rtl/core/zipcpu.v&quot;&gt;ZipCPU core&lt;/a&gt;.
In this case, we’ll separate the assertions into groups of increasingly
complex logic, called stages in Fig 10 below.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 10. Invariants applied within a file&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/invariance-internal.svg&quot; alt=&quot;&quot; width=&quot;720&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Let’s call these sets of assertions &lt;code class=&quot;highlighter-rouge&quot;&gt;B0&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;B1&lt;/code&gt;, and &lt;code class=&quot;highlighter-rouge&quot;&gt;B2&lt;/code&gt;.  For the first
formal proof, we’ll prove that the assumptions together with the design
logic prove the &lt;code class=&quot;highlighter-rouge&quot;&gt;B0&lt;/code&gt; property, &lt;code class=&quot;highlighter-rouge&quot;&gt;A-&amp;gt;B0&lt;/code&gt;.  Within the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/dev/rtl/core/zipcpu.v&quot;&gt;ZipCPU core&lt;/a&gt;,
I call these &lt;code class=&quot;highlighter-rouge&quot;&gt;PHASE_ONE_ASSERT&lt;/code&gt;ions.  Once we know that &lt;code class=&quot;highlighter-rouge&quot;&gt;A-&amp;gt;B0&lt;/code&gt;,
we turn our attention to proving &lt;code class=&quot;highlighter-rouge&quot;&gt;B1&lt;/code&gt;.  In that case, we now know that
&lt;code class=&quot;highlighter-rouge&quot;&gt;A&lt;/code&gt; is true by assumption, but we also know that &lt;code class=&quot;highlighter-rouge&quot;&gt;B0&lt;/code&gt; is true by the implication
we just proved.  So for this second stage proof, we assume &lt;code class=&quot;highlighter-rouge&quot;&gt;A&lt;/code&gt; &lt;em&gt;and&lt;/em&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;B0&lt;/code&gt; and
attempt to prove &lt;code class=&quot;highlighter-rouge&quot;&gt;B1&lt;/code&gt;.  We can then repeat this again, assuming
&lt;code class=&quot;highlighter-rouge&quot;&gt;A&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;B0&lt;/code&gt;, and now &lt;code class=&quot;highlighter-rouge&quot;&gt;B1&lt;/code&gt; and proving &lt;code class=&quot;highlighter-rouge&quot;&gt;B2&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;If you’ve examined the (current)
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/dev/rtl/core/zipcpu.v&quot;&gt;formal proof&lt;/a&gt;
of the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; (it’s still a work in
progress), you may have noticed that I am using both of these methods.
First, I am verifying that the component pieces to the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
work as desired.  Then, I am aggregating those into the proof of the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; as a whole.  Second, within the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;, I’ve created two parts to the
proof: &lt;code class=&quot;highlighter-rouge&quot;&gt;B0&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;B1&lt;/code&gt;.  I’m expecting to create a third and possibly fourth
component later.  Currently, I can prove both &lt;code class=&quot;highlighter-rouge&quot;&gt;B0&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;B1&lt;/code&gt; using
&lt;a href=&quot;https://symbiyosys.readthedocs.io/en/latest&quot;&gt;SymbiYosys&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;According to &lt;a href=&quot;https://www.onespin.com&quot;&gt;OneSpin Solutions&lt;/a&gt;, this method can
increase the depth of the proof or rather the number of state transitions that
can be examined in a reasonable amount of time by perhaps a thousand fold.
These are their numbers, though.  In my own experience, I can only say that
formally verifying the second stage of the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; used to take longer than all
night.  (I’m not really sure how long–I never let it finish.)  It now takes
just over an hour.&lt;/p&gt;

&lt;h2 id=&quot;how-this-concept-appears-in-verilog&quot;&gt;How this concept appears in Verilog&lt;/h2&gt;

&lt;p&gt;The previous sections have discussed a lot about
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal verification&lt;/a&gt;
in the abstract.  They’ve
been so far from coded reality that I would imagine I’ve now left several
readers wondering what I’m talking about.  So let’s bring these abstract
concepts to reality, and discuss how they might look within a piece
of Verilog code.&lt;/p&gt;

&lt;p&gt;We’ll start with a fairly plain Verilog module.  Almost all of my modules have
the following rough format.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;// Copyright statement
`default_nettype	none
//
module thismodule( ...);
	// Core logic
`ifdef	FORMAL
	// Formal properties

	always @(*)
		assume(i_some_input);
	always @(*)
		assert(o_some_output);
`endif
endmodule&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;They start with a copyright statement, and then declare the &lt;code class=&quot;highlighter-rouge&quot;&gt;default_nettype&lt;/code&gt;
to be none instead of wire.  (This catches a &lt;em&gt;lot&lt;/em&gt; of bugs.)  The module
definition then follows with the core logic within it.  Following the module
logic, there’s an &lt;code class=&quot;highlighter-rouge&quot;&gt;ifdef FORMAL&lt;/code&gt; delimited section ending just before the
&lt;code class=&quot;highlighter-rouge&quot;&gt;endmodule&lt;/code&gt; on the last line of the file.  Inside that section I
place any assumptions or assertions regarding the logic above.  Indeed,
if you browse through any of the code I’ve formally verified, you’ll find
this to be the common form.&lt;/p&gt;

&lt;p&gt;If it is possible that this might be a leaf or child module to some other
module within a formal proof, then I’ll make some adjustments to the formal
section.  First, I’ll use a synthesis define to indicate &lt;code class=&quot;highlighter-rouge&quot;&gt;THISMODULE&lt;/code&gt; is
the module being verified.  Inside the module’s yosys script, I’ll also
modify the &lt;code class=&quot;highlighter-rouge&quot;&gt;read_verilog&lt;/code&gt; command to include a &lt;code class=&quot;highlighter-rouge&quot;&gt;-D THISMODULE&lt;/code&gt;.  So, for
example, within the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/dev/rtl/core/pipemem.v&quot;&gt;pipelined memory controller
module&lt;/a&gt;,
there’s a check for whether or not &lt;code class=&quot;highlighter-rouge&quot;&gt;PIPEMEM&lt;/code&gt; is defined.  Likewise, you
can see the definition within its &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/dev/bench/formal/pipemem.ys&quot;&gt;its yosys
script&lt;/a&gt;.
Second, I’ll define macros which I can then use to reference either the
&lt;code class=&quot;highlighter-rouge&quot;&gt;assume&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;assert&lt;/code&gt; statements.  If &lt;code class=&quot;highlighter-rouge&quot;&gt;THISMODULE&lt;/code&gt; is defined, these
will refer to &lt;code class=&quot;highlighter-rouge&quot;&gt;assume&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;assert&lt;/code&gt; as expected.  If not, they’ll be
swapped.  Then I rewrite the formal properties to use these macros.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;`ifdef	FORMAL
`ifdef	THISMODULE
`define	ASSUME	assume
`define	ASSERT	assert
`else
`define	ASSUME	assert
`define	ASSERT	assume
`endif
	// Formal properties
	always @(*)
		`ASSUME(i_some_input);
	always @(*)
		`ASSERT(o_some_output);
`endif&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This is how I handle creating the logic pictured in Fig 9 above within any
of the non-abstracted child modules.&lt;/p&gt;

&lt;p&gt;Perhaps the best example of how this might be useful is in the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;’s
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/dev/rtl/core/pipemem.v&quot;&gt;pipelined memory
controller&lt;/a&gt;.
The “contract” the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
has with the user is that it will not
&lt;a href=&quot;https://meltdownattack.com&quot;&gt;speculatively execute memory operations&lt;/a&gt;–since the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
places both memory and peripherals on the same bus.  Bus operations may be
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;pipelined&lt;/a&gt;,
meaning that multiple reads may be ongoing at any given time.  Now consider,
what would happen if one of those reads set the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Program_counter&quot;&gt;program counter&lt;/a&gt;?
There would be no way to undo any of the other reads that might be in
progress by this point.&lt;/p&gt;

&lt;p&gt;For example, consider the following string of loads.  In the
&lt;a href=&quot;/zipcpu/2018/01/01/zipcpu-isa.html&quot;&gt;ZipCPU ISA&lt;/a&gt;,
an &lt;code class=&quot;highlighter-rouge&quot;&gt;LW&lt;/code&gt; instruction loads a word of data from the bus into the register given
as the second argument.  (&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
instructions read left to right.)  The second to the last of these loads reads
a value into the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Program_counter&quot;&gt;program counter&lt;/a&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-asm&quot; data-lang=&quot;asm&quot;&gt;LW (R0),R1	; Load word from the address in R0 into the R1 register
LW 4(R0),R2	; R2 &amp;lt;- Mem[R0+4]
LW 8(R0),R3
LW 12(R0),R4
LW 16(R0),R5
LW 20(R0),PC	; PC &amp;lt;= Mem[R0+20]
LW 24(R0),R6	; Must not issue until the last load has completed&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Any time the &lt;a href=&quot;https://en.wikipedia.org/wiki/Program_counter&quot;&gt;program counter
(PC)&lt;/a&gt;
is set, the
CPU
jumps to a new instruction.  Hence, this memory read into the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Program_counter&quot;&gt;PC&lt;/a&gt;
is really a jump instruction.&lt;/p&gt;

&lt;p&gt;Should the CPU initiate the read into &lt;code class=&quot;highlighter-rouge&quot;&gt;R6&lt;/code&gt;?  No.  Not until the read into the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Program_counter&quot;&gt;PC&lt;/a&gt; completes.&lt;/p&gt;

&lt;p&gt;To check for this, the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/dev/rtl/core/pipemem.v&quot;&gt;memory
controller&lt;/a&gt;
assumes that any read into the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Program_counter&quot;&gt;program counter&lt;/a&gt;
must be the last read in a sequence.  To
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formally prove&lt;/a&gt;
this in an
&lt;a href=&quot;/blog/2018/03/10/induction-exercise.html&quot;&gt;inductive manner&lt;/a&gt;,
I need to check via assertions that the nothing in the
pipeline of ongoing reads contains a read into the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Program_counter&quot;&gt;program counter&lt;/a&gt;.
Once proven, the controller then asserts that if any output is to the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Program_counter&quot;&gt;program counter&lt;/a&gt;
then it must be the last return value in the sequence.  When this
component is aggregated, the “check every FIFO element” code is quietly
removed, being replaced only be the final assertion on the output.  This
final assertion, however, has been replaced by this process with an assumption
that no longer needs to be checked–simplifying the proof of the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
as a whole.&lt;/p&gt;

&lt;p&gt;The second method of applying invariants is the application within a given
file, as shown in Fig 10 above.  In this case, you want to prove several
sets of assertions.  Within the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/dev/rtl/core/zipcpu.v&quot;&gt;core&lt;/a&gt;,
I call these &lt;code class=&quot;highlighter-rouge&quot;&gt;PHASE_ONE&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;PHASE_TWO&lt;/code&gt;, and so on.
Associated with each phase is an assertion macro, &lt;code class=&quot;highlighter-rouge&quot;&gt;PHASE_ONE_ASSERT&lt;/code&gt;,
&lt;code class=&quot;highlighter-rouge&quot;&gt;PHASE_TWO_ASSERT&lt;/code&gt;, etc.  To then verify the component, you’d run it through
the formal engine twice: first as is, to test all of the phase one assertions,
and then again with &lt;code class=&quot;highlighter-rouge&quot;&gt;PHASE_TWO&lt;/code&gt; defined in order to test the phase two
assertions.  The second set of assertions are excluded from being evaluated
during the first set by a synthesis &lt;code class=&quot;highlighter-rouge&quot;&gt;ifdef&lt;/code&gt; directive.&lt;/p&gt;

&lt;p&gt;You can see the
&lt;a href=&quot;https://symbiyosys.readthedocs.io/en/latest&quot;&gt;SymbiYosys&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/dev/bench/formal/zipcpu.sby&quot;&gt;script for this here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The relevant code, shown below, was lifted from the beginning of the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;’s &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/dev/rtl/core/zipcpu.v&quot;&gt;formal properties
section&lt;/a&gt;.
It starts out with a commented list of all of the formal phases supported by
the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/dev/rtl/core/zipcpu.v&quot;&gt;module&lt;/a&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;`ifdef	FORMAL
//
// PHASE_X definitions control our assertion logic below.  They are to be
// defined by the synthesizer
//
// `define PHASE_TWO
// `define PHASE_THREE
// `define PHASE_FOUR
//&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;These aren’t strictly necessary, but they remind me which defines I am
supporting.&lt;/p&gt;

&lt;p&gt;Then each of the phases is given its own assertion macro.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;`define	PHASE_ONE_ASSERT	assert
`define	PHASE_TWO_ASSERT	assert
`define	PHASE_THR_ASSERT	assert
//&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;If &lt;code class=&quot;highlighter-rouge&quot;&gt;PHASE_TWO&lt;/code&gt; is defined, the &lt;code class=&quot;highlighter-rouge&quot;&gt;PHASE_ONE_ASSERT&lt;/code&gt; macro is then redefined as
an assumption.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;`ifdef	PHASE_TWO
`undef	PHASE_ONE_ASSERT
`define	PHASE_ONE_ASSERT	assume&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Likewise, if &lt;code class=&quot;highlighter-rouge&quot;&gt;PHASE_THREE&lt;/code&gt; is also defined then the &lt;code class=&quot;highlighter-rouge&quot;&gt;PHASE_TWO_ASSERT&lt;/code&gt;
is redefined to be an assumption.  This process then repeats for all of the
phases supported by the design.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;`ifdef	PHASE_THREE
`undef	PHASE_TWO_ASSERT
`define	PHASE_TWO_ASSERT	assume

`ifdef	PHASE_FOUR
`undef	PHASE_THR_ASSERT
`define	PHASE_THR_ASSERT	assume
`endif // PHASE_FOUR
`endif // PHASE_THREE
`endif // PHASE_TWO&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;At this point, the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/dev/rtl/core/zipcpu.v&quot;&gt;formal
properties&lt;/a&gt;
can proceed in sections.  The first section makes any input assumptions
necessary.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	// An example assumption
	always @(*)
		assume(i_some_input);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Then the first set of assertions follows these assumptions.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	// An example assertion
	always @(*)
		`PHASE_ONE_ASSERT(o_some_output);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This set of assertions is created
using the &lt;code class=&quot;highlighter-rouge&quot;&gt;PHASE_ONE_ASSERT&lt;/code&gt; macro.  That will allow us to replace these
assertions with assumptions in the next pass–once they’ve been proven
true in a first pass.&lt;/p&gt;

&lt;p&gt;Later, we can split into a second section of assertions–but only after
we’ve used the formal tools to verify the first set of assertions, and only
if &lt;code class=&quot;highlighter-rouge&quot;&gt;PHASE_TWO&lt;/code&gt; is defined.  In this latter section, assertions are created
using the &lt;code class=&quot;highlighter-rouge&quot;&gt;PHASE_TWO_ASSERT&lt;/code&gt; macro.  Further, in order to get into this
section the &lt;code class=&quot;highlighter-rouge&quot;&gt;PHASE_ONE_ASSERT&lt;/code&gt; macro used the previous section will have
been redefined to be an &lt;code class=&quot;highlighter-rouge&quot;&gt;assume&lt;/code&gt; statement instead of the original &lt;code class=&quot;highlighter-rouge&quot;&gt;assert&lt;/code&gt;
statement.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;`ifdef	PHASE_TWO
	always @(*)
		`PHASE_TWO_ASSERT(o_some_other_output);
`endif // PHASE_TWO
`endif // FORMAL&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;In the case of the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;,
the second phase of
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal verification&lt;/a&gt;
includes several free variables (&lt;a href=&quot;http://www.clifford.at/yosys/&quot;&gt;yosys&lt;/a&gt;’s
&lt;code class=&quot;highlighter-rouge&quot;&gt;$anyconst&lt;/code&gt;) used to track an arbitrary instruction from an arbitrary address
working its way through the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;’s
logic.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	assign	f_const_insn    = $anyconst;
	assign	f_const_addr    = $anyconst;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Using this method, I can reconstruct the operands for any operation
before that operation is issued, and verify that they have the right values.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(posedge i_clk)
	if // details
	begin
		if // more details ...
		begin
			// Check that the first operand matches
			if (fc_rA)
				`PHASE_TWO_ASSERT(f_Av == op_Av);
			// Now check the second operand
			`PHASE_TWO_ASSERT(f_Bv == op_Bv);
		end
	end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;If you’ll recall from the article describing the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;’s
&lt;a href=&quot;/zipcpu/2018/01/01/zipcpu-isa.html&quot;&gt;instruction set&lt;/a&gt;,
almost all
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
instructions have the basic form: &lt;code class=&quot;highlighter-rouge&quot;&gt;OP.C Ra,Rb+I&lt;/code&gt;, where &lt;code class=&quot;highlighter-rouge&quot;&gt;Ra&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;Rb&lt;/code&gt; are
arbitrary registers, and &lt;code class=&quot;highlighter-rouge&quot;&gt;I&lt;/code&gt; is some immediate constant.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 11. ZipCPU&#39;s ALU stage in context&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/cpu-bypass.svg&quot; alt=&quot;&quot; width=&quot;640&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Prior to entering the
&lt;a href=&quot;/zipcpu/2017/08/11/simple-alu.html&quot;&gt;ALU&lt;/a&gt;
stage, the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
adds the &lt;code class=&quot;highlighter-rouge&quot;&gt;Rb&lt;/code&gt; register value and &lt;code class=&quot;highlighter-rouge&quot;&gt;I&lt;/code&gt; together.  Then, while waiting for the
&lt;a href=&quot;/zipcpu/2017/08/11/simple-alu.html&quot;&gt;ALU&lt;/a&gt;
stage to become available, any write to either &lt;code class=&quot;highlighter-rouge&quot;&gt;Ra&lt;/code&gt; or &lt;code class=&quot;highlighter-rouge&quot;&gt;Rb&lt;/code&gt; adjusts these
values.&lt;/p&gt;

&lt;p&gt;What makes this difficult is that, in order to keep clock speed high, there’s
no opportunity to re-add the immediate constant &lt;code class=&quot;highlighter-rouge&quot;&gt;I&lt;/code&gt; to &lt;code class=&quot;highlighter-rouge&quot;&gt;Rb&lt;/code&gt;–that would take an
extra clock tick.  Dealing with this requires some careful pipeline stall
logic, and getting this logic right has been
tricky.  By allowing the formal engine to pick an arbitrary pipeline state
and then examine an arbitrary instruction going into the
&lt;a href=&quot;/zipcpu/2017/08/11/simple-alu.html&quot;&gt;ALU&lt;/a&gt;,
I can guarantee that the &lt;code class=&quot;highlighter-rouge&quot;&gt;Ra&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;Rb+I&lt;/code&gt; operands are valid no matter
which instruction precedes them.&lt;/p&gt;

&lt;p&gt;Searching through all of the possibilities of these free variables
can be expensive.  Indeed, this was the phase that was taking many hours
of processing as I was working on verifying
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;this core&lt;/a&gt;
module within the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;.  Now, using this method of
invariants, the entire formal verification of the (still not quite complete
properties of the)
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
takes less than two hours.&lt;/p&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;Invariants are only one method of handling formal complexity when aggregating
multiple modules together.  As I mentioned in the opening, I am by no means
an expert in
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal verification&lt;/a&gt;,
and so this is only my first application of
the principle of invariants to any project–in this case the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;.
However, even in the case of the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;,
the value of using invariants has saved many, many
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal verification&lt;/a&gt;
CPU cycles.&lt;/p&gt;

&lt;p&gt;We’ll have to return to this topic later in order to handle the concept of
abstraction in
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal methods&lt;/a&gt;.
Abstraction may be an even more powerful concept than invariants.
As you may remember from above, I’ve been using abstracted components to
represent the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/dev/bench/formal/abs_prefetch.v&quot;&gt;prefetch&lt;/a&gt;,
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/dev/bench/formal/abs_mpy.v&quot;&gt;multiply&lt;/a&gt;,
and
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/dev/bench/formal/abs_div.v&quot;&gt;divide&lt;/a&gt;
components.  As another illustration, consider this: when
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formally verifying&lt;/a&gt;
any container of the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;,
whether the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/zipsystem.v&quot;&gt;ZipSystem&lt;/a&gt;,
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/zipbones.v&quot;&gt;ZipBones&lt;/a&gt;,
or some yet to be determined container, I’m anticipating being able to
replace the entire complicated
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
core with an abstracted version of it, and then to be able to prove
the formal properties of the wrapper in question.&lt;/p&gt;

&lt;hr /&gt;&lt;p&gt;&lt;em&gt;And that ye study to be quiet, and to do your own business, and to work with your own hands, as we commanded you (1Thes 4:11)&lt;/em&gt;</description>
        <pubDate>Mon, 23 Apr 2018 00:00:00 -0400</pubDate>
        <link>https://zipcpu.com/formal/2018/04/23/invariant.html</link>
        <guid isPermaLink="true">https://zipcpu.com/formal/2018/04/23/invariant.html</guid>
        
        
        <category>formal</category>
        
      </item>
    
      <item>
        <title>ZipTimer: A simple countdown timer</title>
        <description>&lt;p&gt;If you are a beginning
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
designer, the first example you will be given to learn is that of a counter.
It’s sort of a tradition.  Class room exercises all illustrate concepts
with simple counters.  If you ask a question, the instructor will go to the
board and start his explanation with a counter.  At least, that’s what I would
do if I trying to teach an Verilog concept.&lt;/p&gt;

&lt;p&gt;But just how useful is a counter in the end anyway?&lt;/p&gt;

&lt;p&gt;Let’s try examining a
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/ziptimer.v&quot;&gt;counter&lt;/a&gt;
all the way from an irrelevant classroom
discussion to a vital system component.&lt;/p&gt;

&lt;p&gt;How can this be?  Well, one
peripheral necessary to any
&lt;a href=&quot;https://en.wikipedia.org/wiki/Computer_multitasking&quot;&gt;multitasking&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Operating_System&quot;&gt;operating system&lt;/a&gt;, whether
&lt;a href=&quot;http://www.unix.org/what_is_unix.html&quot;&gt;Unix&lt;/a&gt;,
&lt;a href=&quot;https://en.wikipedia.org/wiki/Linux&quot;&gt;Linux&lt;/a&gt;, Windows, or some other
&lt;a href=&quot;https://en.wikipedia.org/wiki/Operating_System&quot;&gt;O/S&lt;/a&gt;, is an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Programmable_interval_timer&quot;&gt;interval timer&lt;/a&gt;.
An &lt;a href=&quot;https://en.wikipedia.org/wiki/Programmable_interval_timer&quot;&gt;interval timer&lt;/a&gt;
is little more than a reconfigurable counter.  All it does is issue an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interrupt&quot;&gt;interrupt&lt;/a&gt;
to the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;
at a periodic interval.&lt;/p&gt;

&lt;p&gt;Embedded systems, such as those found within
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;’s,
have an additional timing
need.  These systems often need to insert known delays between different
operations.  Instead of an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Programmable_interval_timer&quot;&gt;interval timer&lt;/a&gt;,
these systems need what are known as
&lt;a href=&quot;https://en.wikipedia.org/wiki/Programmable_interval_timer&quot;&gt;“one-shot” timers&lt;/a&gt;.
Once programmed, they generate an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interrupt&quot;&gt;interrupt&lt;/a&gt;
after the programmed delay takes place and then they return to idle.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 1. The ZipSystem&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/zipsystem.svg&quot; alt=&quot;&quot; width=&quot;480&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;The
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; wrapper known as the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/zipsystem.v&quot;&gt;ZipSystem&lt;/a&gt;
has three such timers within it, shown in Fig 1 as “Generic Timers (x3)”.
I call these timers
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/ziptimer.v&quot;&gt;ZipTimers&lt;/a&gt;.
Each of these
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/ziptimer.v&quot;&gt;ZipTimers&lt;/a&gt;
supports generating either a regular
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interrupt&quot;&gt;interrupt&lt;/a&gt;
or a one-shot delay based
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interrupt&quot;&gt;interrupt&lt;/a&gt;.  These
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/ziptimer.v&quot;&gt;ZipTimers&lt;/a&gt;
have been a part of the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/zipsystem.v&quot;&gt;ZipSystem&lt;/a&gt;
since I started.  Their simplicity makes them perfect
candidates for beginner exercises, and even better candidates for learning
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal verification&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/ziptimer.v&quot;&gt;ZipTimer&lt;/a&gt;
has two capabilities beyond the traditional beginner’s counter
exercise.  These are first the ability to be programmed over a &lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;wishbone
bus&lt;/a&gt;,
and second the ability to
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interrupt&quot;&gt;interrupt&lt;/a&gt; the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Soft_microprocessor&quot;&gt;CPU&lt;/a&gt;
when the specified delay runs out.&lt;/p&gt;

&lt;p&gt;Therefore, let’s examine this &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/ziptimer.v&quot;&gt;timer
peripheral&lt;/a&gt;
as an exercise in learning Verilog,
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal verification&lt;/a&gt;,
and connecting a simple item to a bus using
&lt;a href=&quot;/zipcpu/2017/10/05/autofpga-intro.html&quot;&gt;AutoFPGA&lt;/a&gt;.
Along the way, I’ll do my best to avoid calling this a “counter example”.&lt;/p&gt;

&lt;h2 id=&quot;the-beginners-exercise&quot;&gt;The Beginner’s Exercise&lt;/h2&gt;

&lt;p&gt;Hopefully everyone reading this blog has at one time built a countdown timer
in Verilog.  Indeed, I use a basic countdown timer as one of the first examples
in the &lt;a href=&quot;/projects.html&quot;&gt;Formal Verification course&lt;/a&gt;
I now teach.  Below is the simple example timer that we’ll start
with today.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 2. A Countdown Timer&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/timer-oneshot.svg&quot; alt=&quot;&quot; width=&quot;248&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;initial	r_value = 0;
always @(posedge i_clk)
	if (i_start)
		r_value &amp;lt;= TIMEOUT;
	else if (r_value != 0)
		r_value &amp;lt;= r_value - 1&#39;b1;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This counter starts at zero.  Any time an &lt;code class=&quot;highlighter-rouge&quot;&gt;i_start&lt;/code&gt; signal takes place, the
counter is set to &lt;code class=&quot;highlighter-rouge&quot;&gt;TIMEOUT&lt;/code&gt; and then counts down to zero, as illustrated in
Fig 2.  Note that
setting this counter to &lt;code class=&quot;highlighter-rouge&quot;&gt;TIMEOUT&lt;/code&gt; doesn’t guarantee that it will take
&lt;code class=&quot;highlighter-rouge&quot;&gt;TIMEOUT&lt;/code&gt; clock ticks until it returns to zero–it is possible the &lt;code class=&quot;highlighter-rouge&quot;&gt;i_start&lt;/code&gt;
signal resets this counter back to &lt;code class=&quot;highlighter-rouge&quot;&gt;TIMEOUT&lt;/code&gt; before it hits zero.&lt;/p&gt;

&lt;p&gt;We’ll also create an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interrupt&quot;&gt;interrupt&lt;/a&gt;
signal that we will set anytime the counter becomes zero.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;initial	o_int &amp;lt;= 1&#39;b0;
always @(posedge i_clk)
	o_int &amp;lt;= (r_value == 1);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;That’s not all that hard, right?&lt;/p&gt;

&lt;p&gt;Did you notice the subtlety associated with checking &lt;code class=&quot;highlighter-rouge&quot;&gt;r_value==1&lt;/code&gt; here?
One of my readers pointed this out.  If &lt;code class=&quot;highlighter-rouge&quot;&gt;i_start&lt;/code&gt; happens to be true on the
same cycle that &lt;code class=&quot;highlighter-rouge&quot;&gt;r_value==1&lt;/code&gt;, then &lt;code class=&quot;highlighter-rouge&quot;&gt;o_int&lt;/code&gt; might be true on a clock cycle
when &lt;code class=&quot;highlighter-rouge&quot;&gt;r_value != 0&lt;/code&gt;.  Yes, this is a bug.  It’ll come back in the next section
as well.  However, I’m going to leave this bug in place because this was how I
originally designed the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/ziptimer.v&quot;&gt;ZipTimer&lt;/a&gt;–with
this bug within it.  (Oops!) It wasn’t until years later when I attempted to
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formally verify&lt;/a&gt; the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/ziptimer.v&quot;&gt;timer
code&lt;/a&gt;
presented below that I discovered this subtlety.&lt;/p&gt;

&lt;p&gt;For now, let’s just peel this onion back a bit further.&lt;/p&gt;

&lt;p&gt;The problem with the above implementation of a counter is that it isn’t very
reusable.  If you are going to generate a counter that will be
&lt;a href=&quot;https://en.wikipedia.org/wiki/Programmable_interval_timer&quot;&gt;programmable&lt;/a&gt;,
then you’ll want to add a
&lt;a href=&quot;/zipcpu/2017/05/29/simple-wishbone.html&quot;&gt;bus interface &lt;/a&gt;.
If we use the
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;wishbone bus&lt;/a&gt;,
then anytime &lt;code class=&quot;highlighter-rouge&quot;&gt;(i_wb_stb)&amp;amp;&amp;amp;(i_wb_we)&lt;/code&gt; is true, and the address reflects our
timer’s address, then we can reload our timer from &lt;code class=&quot;highlighter-rouge&quot;&gt;i_wb_data&lt;/code&gt;.
This would give us a more adaptable, configurable timer.  Such a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_(computing)&quot;&gt;bus&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Programmable_interval_timer&quot;&gt;controlled timer&lt;/a&gt;
could easily become a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Soft_microprocessor&quot;&gt;CPU&lt;/a&gt; peripheral.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;initial	r_value = 0;
always @(posedge i_clk)
	if ((i_wb_stb)&amp;amp;&amp;amp;(i_wb_we))
		r_value &amp;lt;= i_wb_data;
	else if (r_value != 0)
		r_value &amp;lt;= r_value - 1&#39;b1;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This works fine for
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
implementations, but what if you want this counter to run in a &lt;a href=&quot;/blog/2017/10/13/fpga-v-asic.html&quot;&gt;context
where &lt;code class=&quot;highlighter-rouge&quot;&gt;initial&lt;/code&gt; statements are
ignored&lt;/a&gt;?  In that case,
you need an &lt;code class=&quot;highlighter-rouge&quot;&gt;i_reset&lt;/code&gt; input.  On a reset, that is when &lt;code class=&quot;highlighter-rouge&quot;&gt;i_reset&lt;/code&gt; is high,
the counter should return to idle, &lt;code class=&quot;highlighter-rouge&quot;&gt;r_value == 0&lt;/code&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;initial	r_value = 0;
always @(posedge i_clk)
	if (i_reset)
		r_value &amp;lt;= 0;
	else if ((i_wb_stb)&amp;amp;&amp;amp;(i_wb_we))
		r_value &amp;lt;= i_wb_data;
	else if (r_value != 0)
		r_value &amp;lt;= r_value - 1&#39;b1;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;In a similar fashion, with only a tiny adjustment, we can use this module
to count events.  We’ll use an incoming &lt;code class=&quot;highlighter-rouge&quot;&gt;i_ce&lt;/code&gt; signal to denote when an event
has taken place.  Examples of such events include not only clock cycles
(&lt;code class=&quot;highlighter-rouge&quot;&gt;i_ce=1&lt;/code&gt;), but also incoming or outgoing samples in a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_signal_processing&quot;&gt;DSP&lt;/a&gt;
system, or lines or frames in a video system.  All of these options can
be created by appropriately setting an &lt;code class=&quot;highlighter-rouge&quot;&gt;i_ce&lt;/code&gt; input to one &lt;a href=&quot;/blog/2017/08/14/strategies-for-pipelining.html&quot;&gt;any time the
timer is to
step&lt;/a&gt;.
Put together, our original counter now becomes,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;initial	r_value = 0;
always @(posedge i_clk)
	if (i_reset)
		r_value &amp;lt;= 0;
	else if ((i_wb_stb)&amp;amp;&amp;amp;(i_wb_we))
		r_value &amp;lt;= i_wb_data;
	else if ((i_ce)&amp;amp;&amp;amp;(r_value != 0))
		r_value &amp;lt;= r_value - 1&#39;b1;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;That’s quite the configurable counter, no?&lt;/p&gt;

&lt;p&gt;Let’s now return to our
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus interface&lt;/a&gt;
and properly set the rest of the required
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;
&lt;a href=&quot;/zipcpu/2017/05/29/simple-wishbone.html&quot;&gt;control values&lt;/a&gt;.
Since we can respond on every clock cycle, there’s no reason to ever stall the
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;assign	o_wb_stall = 1&#39;b0;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;We’ll also need to create a response to the &lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;wishbone
bus&lt;/a&gt;.  Since
this operation takes only a single cycle, we’ll acknowledge the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_(computing)&quot;&gt;bus&lt;/a&gt;
any time we are selected.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;assign	o_wb_ack = (i_wb_stb);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;We can do this if the current counter state data is always valid on the
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;’s
&lt;code class=&quot;highlighter-rouge&quot;&gt;o_wb_data&lt;/code&gt; lines.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;assign	o_wb_data = r_value;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Voila!  A &lt;a href=&quot;/zipcpu/2017/05/29/simple-wishbone.html&quot;&gt;simple, wishbone bus
controlled&lt;/a&gt;
count-down timer!&lt;/p&gt;

&lt;h2 id=&quot;interval-timer&quot;&gt;Interval Timer&lt;/h2&gt;

&lt;p&gt;The former code works great for a one-shot timer.  However, if you want to
create a timer that
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interrupt&quot;&gt;interrupts&lt;/a&gt; the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt; every 10ms (as an example), only
to be reset by the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt; in an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interrupt_handler&quot;&gt;interrupt service routine&lt;/a&gt;,
then you will find that the interval pseudorandomly walks in phase.  The
intervals will all be longer then 10ms.  How can we fix this?&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 3. An Interval Timer&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/timer-interval.svg&quot; alt=&quot;&quot; width=&quot;248&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;One solution is to use an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Programmable_interval_timer&quot;&gt;interval timer&lt;/a&gt;.
Simply put, an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Programmable_interval_timer&quot;&gt;interval timer&lt;/a&gt;
is one that counts down to zero, and then resets itself to count down again.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;initial	r_value = 0;
always @(posedge i_clk)
	if (r_value != 0)
		r_value &amp;lt;= r_value - 1&#39;b1;
	else
		r_value &amp;lt;= interval_count;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;As before, we’ll generate an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interrupt&quot;&gt;interrupt&lt;/a&gt;
anytime this timer hits zero,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;initial	o_int &amp;lt;= 1&#39;b0;
always @(posedge i_clk)
	o_int &amp;lt;= (r_value == 1);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;But … what if we wanted to allow this reload value to be externally set?
To create this capability, we’ll attach this
&lt;a href=&quot;https://en.wikipedia.org/wiki/Programmable_interval_timer&quot;&gt;interval timer&lt;/a&gt;
to &lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;wishbone bus&lt;/a&gt;.
Perhaps we want something like,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;initial	r_value = 0;
always @(posedge i_clk)
	if ((i_wb_stb)&amp;amp;&amp;amp;(i_wb_we))
		r_interval_count &amp;lt;= i_wb_data;

always @(posedge i_clk)
	if (r_value != 0)
		r_value &amp;lt;= r_value - 1&#39;b1;
	else
		r_value &amp;lt;= r_interval_count;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This is almost identical to our original counter above, save that every time
it resets it goes back to &lt;code class=&quot;highlighter-rouge&quot;&gt;r_interval_count&lt;/code&gt; instead of the original &lt;code class=&quot;highlighter-rouge&quot;&gt;TIMEOUT&lt;/code&gt;
parameter.  Since &lt;code class=&quot;highlighter-rouge&quot;&gt;r_interval_count&lt;/code&gt; is programmable from the
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;,
we now have a &lt;a href=&quot;https://en.wikipedia.org/wiki/Programmable_interval_timer&quot;&gt;programmable interrupt
timer&lt;/a&gt;.
How hard can this be?&lt;/p&gt;

&lt;p&gt;In this case, the devil is in the details.&lt;/p&gt;

&lt;p&gt;Look closer.  Do you see any of the problems with this implementation?
For example, what happens if you want to switch from a 4-second intervals to
10ms intervals?  Just how many counts will that first 10ms interval contain?
Up to 4 seconds?&lt;/p&gt;

&lt;p&gt;If that’s not the response you want, then how should this timer respond?&lt;/p&gt;

&lt;p&gt;While we consider this, let’s also consider merging the countdown timer
together with the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Programmable_interval_timer&quot;&gt;interval timer&lt;/a&gt;
in a way that both respond to
&lt;a href=&quot;/zipcpu/2017/05/29/simple-wishbone.html&quot;&gt;bus requests&lt;/a&gt;.
Here’s the capability or requirement we’ll build to then:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;On any reset, the counter will set itself to zero and wait to be configured&lt;/p&gt;

    &lt;p&gt;This matches the count-down timer behavior we discussed above.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 4. The ZipTimer Register&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/timer-reg.png&quot; alt=&quot;&quot; width=&quot;557&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;On any write, the counter will assume the value written to it, as shown
in Fig 4 as the &lt;code class=&quot;highlighter-rouge&quot;&gt;New Counter&lt;/code&gt; bits, and will then start counting down.
If the number written was a zero, then the counter will stay at zero and stop.&lt;/p&gt;

    &lt;p&gt;Again, this matches the count-down timer behavior we originally discussed.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;If the high bit is set upon any write, shown as &lt;code class=&quot;highlighter-rouge&quot;&gt;R&lt;/code&gt; in Fig 4 above,
then the timer will enter into interval mode.  In all other cases, the timer
will be started as a one-shot countdown timer.&lt;/p&gt;

    &lt;p&gt;This is our first break from the original countdown timer’s functionality,
allowing us to run in an interval timer mode.&lt;/p&gt;

    &lt;p&gt;Further, if set to interval mode, then the value written to the timer will
become the interval definition.  Hence, when the timer finishes counting
down to zero, we’ll just automatically restart it again with the same
&lt;code class=&quot;highlighter-rouge&quot;&gt;New Counter&lt;/code&gt; value just written to it.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;On writing a zero to the counter, all ongoing counts will be ended and the
counter will return to idle.  Any interval capability will be turned off.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;We’ll also use a &lt;a href=&quot;/blog/2017/08/14/strategies-for-pipelining.html&quot;&gt;global CE
register&lt;/a&gt;,
&lt;code class=&quot;highlighter-rouge&quot;&gt;i_ce&lt;/code&gt;.  This will allow you to count down things other than clock cycles.
Perhaps you can count incoming samples on an interface.  Perhaps you
want to count video frames.  Perhaps you want to count finished instructions.
All of these can be implemented with an appropriate connection to this &lt;code class=&quot;highlighter-rouge&quot;&gt;i_ce&lt;/code&gt;
wire.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Simple enough?  Almost.&lt;/p&gt;

&lt;p&gt;If low logic is a priority, and it has always been a priority for me, then
you’ll also want to be able to configure this peripheral for just the amount
of logic necessary.  We’ll use the parameter &lt;code class=&quot;highlighter-rouge&quot;&gt;VW&lt;/code&gt; to control how many bits
are in our counter.  We’ll also use &lt;code class=&quot;highlighter-rouge&quot;&gt;BW&lt;/code&gt; to be the width of the data
bus–nominally 32 bits.  Finally we’ll use the one bit parameter,
&lt;code class=&quot;highlighter-rouge&quot;&gt;RELOADABLE&lt;/code&gt; to control whether or not this timer offers an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Programmable_interval_timer&quot;&gt;interval timer&lt;/a&gt;
mode or not.  For example, if you know you are only ever going to measure
20ms intervals from a 100MHz clock, then you won’t ever need any
more than &lt;code class=&quot;highlighter-rouge&quot;&gt;VW=21&lt;/code&gt; bits.&lt;/p&gt;

&lt;p&gt;Simple enough now?  I thought so.  Let’s dive into a walk through of the code.&lt;/p&gt;

&lt;h2 id=&quot;the-code&quot;&gt;The Code&lt;/h2&gt;

&lt;p&gt;We’ll walk through the code of the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/ziptimer.v&quot;&gt;ZipTimer&lt;/a&gt;
in two separate sections.  First, we’ll discuss the traditional Verilog code.
Then we’ll move from that to the
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal properties&lt;/a&gt;
section.  Once we’ve finished discussing the
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal properties&lt;/a&gt;
within the code, I show how to connect a peripheral like this to an
&lt;a href=&quot;/zipcpu/2017/10/05/autofpga-intro.html&quot;&gt;AutoFPGA&lt;/a&gt;
based design.&lt;/p&gt;

&lt;p&gt;Normally I skip the front matter of a Verilog file when blogging, so as to
only focus on the relevant portions.  In this case, I’ll show the three
parameters: &lt;code class=&quot;highlighter-rouge&quot;&gt;BW&lt;/code&gt;, containing the size of the bus, &lt;code class=&quot;highlighter-rouge&quot;&gt;VW&lt;/code&gt;, containing the
number of bits in our counter, and &lt;code class=&quot;highlighter-rouge&quot;&gt;RELOADABLE&lt;/code&gt;–set to one if we want
to support an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Programmable_interval_timer&quot;&gt;interval timer&lt;/a&gt;
capability in addition to the one-shot timer capability.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	parameter	BW = 32;
	parameter	VW = (BW-1);
	parameter [0:0]	RELOADABLE=1;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;I’ll also simplify the write command below to a &lt;code class=&quot;highlighter-rouge&quot;&gt;wb_write&lt;/code&gt; flag.  Since you’ll
see this often below, here’s the declaration.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	assign	wb_write = (i_wb_stb)&amp;amp;&amp;amp;(i_wb_we);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;As a result, any time you read &lt;code class=&quot;highlighter-rouge&quot;&gt;wb_write&lt;/code&gt; below you now know that it is
nothing more than a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Predicate_(mathematical_logic)&quot;&gt;predicate&lt;/a&gt;
that will be true any time the
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;
is writing to our only
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/ziptimer.v&quot;&gt;timer&lt;/a&gt;
register.&lt;/p&gt;

&lt;p&gt;We’ll also use a flag &lt;code class=&quot;highlighter-rouge&quot;&gt;r_running&lt;/code&gt; to keep track of whether or not the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/ziptimer.v&quot;&gt;timer&lt;/a&gt;
is &lt;em&gt;running&lt;/em&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	initial	r_running = 1&#39;b0;
	always @(posedge i_clk)
		if (i_reset)
			r_running &amp;lt;= 1&#39;b0;
		else if (wb_write)
			r_running &amp;lt;= (|i_wb_data[(VW-1):0]);
		else if ((r_zero)&amp;amp;&amp;amp;(!auto_reload))
			r_running &amp;lt;= 1&#39;b0;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Basically the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/ziptimer.v&quot;&gt;timer&lt;/a&gt;
is &lt;code class=&quot;highlighter-rouge&quot;&gt;r_running&lt;/code&gt; any time it is non-zero, or any time it is
zero and about to reload for the next interval.  If we wanted to, it would
&lt;a href=&quot;/blog/2018/03/14/is-formal-hard.html&quot;&gt;make sense to scribble in our
notes&lt;/a&gt;
at this point that,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(*)
if ((r_value != 0)||(auto_reload))
	assert(r_running);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The contrary case, where &lt;code class=&quot;highlighter-rouge&quot;&gt;r_running&lt;/code&gt; is not true, will be a little more
difficult to specify so we’ll save it until we have to think our way through it
in the next section.  Either way, when we get to building our
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal properties&lt;/a&gt;
section, we’ll then &lt;a href=&quot;/blog/2018/03/14/is-formal-hard.html&quot;&gt;copy our scribbled notes over
there&lt;/a&gt;
so we can place all of our
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal properties&lt;/a&gt;
in one place.&lt;/p&gt;

&lt;p&gt;Moving on, if you recall from above, we used a &lt;code class=&quot;highlighter-rouge&quot;&gt;RELOADABLE&lt;/code&gt; parameter
option to select whether or not this
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/ziptimer.v&quot;&gt;timer&lt;/a&gt;
included the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Programmable_interval_timer&quot;&gt;interval timer&lt;/a&gt;
ability, or just a one-shot capability.  Hence, if &lt;code class=&quot;highlighter-rouge&quot;&gt;RELOADABLE&lt;/code&gt; is true
then we’ll include this
&lt;a href=&quot;https://en.wikipedia.org/wiki/Programmable_interval_timer&quot;&gt;interval timer&lt;/a&gt;
capability.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	generate
	if (RELOADABLE != 0)
	begin&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The
&lt;a href=&quot;https://en.wikipedia.org/wiki/Programmable_interval_timer&quot;&gt;interval timer&lt;/a&gt;
capability itself centers around two registers.  The
first, &lt;code class=&quot;highlighter-rouge&quot;&gt;r_auto_reload&lt;/code&gt;, is a single bit flag telling us whether or not the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/ziptimer.v&quot;&gt;timer&lt;/a&gt;
needs to be restarted once it hits zero.  The second register will tell us
what our interval is should &lt;code class=&quot;highlighter-rouge&quot;&gt;r_auto_reload&lt;/code&gt; be set–but we’ll get to that
in a moment.&lt;/p&gt;

&lt;p&gt;Initially, I cleared this &lt;code class=&quot;highlighter-rouge&quot;&gt;r_auto_reload&lt;/code&gt; value upon any reset and set it
on any write where the most significant bit is set.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;		initial	r_auto_reload = 1&#39;b0;

		always @(posedge i_clk)
			if (i_reset)
				r_auto_reload &amp;lt;= 1&#39;b0;
			else if (wb_write)
				r_auto_reload &amp;lt;= (i_wb_data[(BW-1)]);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This approach failed when I tried to
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formally verify&lt;/a&gt;
the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/ziptimer.v&quot;&gt;ZipTimer&lt;/a&gt;.
When I dug a bit deeper, I realized that the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/ziptimer.v&quot;&gt;timer&lt;/a&gt;
interval could never be allowed to be zero.  Were it zero, this would
break the &lt;code class=&quot;highlighter-rouge&quot;&gt;r_running&lt;/code&gt; assertion we placed into our notes above.
Hence, I rewrote the &lt;code class=&quot;highlighter-rouge&quot;&gt;r_auto_reload&lt;/code&gt; logic above into,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;		initial	r_auto_reload = 1&#39;b0;

		always @(posedge i_clk)
			if (i_reset)
				r_auto_reload &amp;lt;= 1&#39;b0;
			else if (wb_write)
				r_auto_reload &amp;lt;= (i_wb_data[(BW-1)])
					&amp;amp;&amp;amp;(|i_wb_data[(VW-1):0]);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The big difference is that in order to create an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Programmable_interval_timer&quot;&gt;interval timer&lt;/a&gt;,
you need to not only set the high order bit but you must also provide a
non-zero interval length.&lt;/p&gt;

&lt;p&gt;The second item worth commenting on here is the assign statement.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;		assign	auto_reload = r_auto_reload;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;By assigning to a global &lt;code class=&quot;highlighter-rouge&quot;&gt;wire&lt;/code&gt; value within a &lt;code class=&quot;highlighter-rouge&quot;&gt;generate&lt;/code&gt; block, I
can then use this &lt;code class=&quot;highlighter-rouge&quot;&gt;wire&lt;/code&gt; value throughout the rest of my design without
needing to waste &lt;code class=&quot;highlighter-rouge&quot;&gt;reg&lt;/code&gt;s when &lt;code class=&quot;highlighter-rouge&quot;&gt;RELOADABLE&lt;/code&gt; is false and I don’t need them.
Optimizations within the synthesizer will then remove any extra logic dependent
upon these values.&lt;/p&gt;

&lt;p&gt;The next register associated with the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Programmable_interval_timer&quot;&gt;interval timer&lt;/a&gt;
capability is the &lt;code class=&quot;highlighter-rouge&quot;&gt;r_interval_count&lt;/code&gt; register–containing the the interval
length expressed as value to reset our register to after it reaches zero.
On any write, we’ll set this interval count to the information found on the
data &lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;
in &lt;code class=&quot;highlighter-rouge&quot;&gt;i_wb_data&lt;/code&gt;.  The &lt;code class=&quot;highlighter-rouge&quot;&gt;r_auto_reload&lt;/code&gt; we just dealt with
above will determine whether or not this &lt;code class=&quot;highlighter-rouge&quot;&gt;r_interval_count&lt;/code&gt; is relevant or not.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;		initial	r_interval_count = 0;
		always @(posedge i_clk)
			if (i_reset)
				r_interval_count &amp;lt;= 0;
			else if (wb_write)
				r_interval_count &amp;lt;= i_wb_data[(VW-1):0];
		assign	interval_count = r_interval_count;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Finally, if we are building without the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Programmable_interval_timer&quot;&gt;interval timer&lt;/a&gt;
capability, we’ll set both of these values, &lt;code class=&quot;highlighter-rouge&quot;&gt;auto_reload&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;interval_count&lt;/code&gt;,
to zero.  The synthesizer will then remove any of the relevant
&lt;a href=&quot;https://en.wikipedia.org/wiki/Programmable_interval_timer&quot;&gt;interval timer&lt;/a&gt;
logic below.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	end else begin
		assign	auto_reload = 1&#39;b0;
		assign	interval_count = 0;
	end endgenerate&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Let’s now dig into the core of this count-down timer: the counter’s value,
&lt;code class=&quot;highlighter-rouge&quot;&gt;r_value&lt;/code&gt;.  This follows primarily from the counter we started with, corrected
by our discussion above, but now with the changes necessary to handle both an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Programmable_interval_timer&quot;&gt;interval timer&lt;/a&gt;
capability as well as a &lt;a href=&quot;https://en.wikipedia.org/wiki/Programmable_interval_timer&quot;&gt;one-shot countdown
timer&lt;/a&gt;
capability.&lt;/p&gt;

&lt;p&gt;In both cases, the counter is initialized to zero, cleared on reset, and
set on any
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;
&lt;a href=&quot;/zipcpu/2017/05/29/simple-wishbone.html&quot;&gt;write&lt;/a&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	initial	r_value = 0;
	always @(posedge i_clk)
		if (i_reset)
			r_value &amp;lt;= 0;
		else if (wb_write)
			r_value &amp;lt;= i_wb_data[(VW-1):0];&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Otherwise, we’ll adjust the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/ziptimer.v&quot;&gt;timer&lt;/a&gt;
any time &lt;code class=&quot;highlighter-rouge&quot;&gt;i_ce&lt;/code&gt; is true and the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/ziptimer.v&quot;&gt;timer&lt;/a&gt;
is currently running.  As you may remember from above, the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/ziptimer.v&quot;&gt;timer&lt;/a&gt;
is &lt;code class=&quot;highlighter-rouge&quot;&gt;r_running&lt;/code&gt; any time &lt;code class=&quot;highlighter-rouge&quot;&gt;r_value&lt;/code&gt; it is nonzero, or we are in
&lt;a href=&quot;https://en.wikipedia.org/wiki/Programmable_interval_timer&quot;&gt;interval timer&lt;/a&gt;
mode (&lt;code class=&quot;highlighter-rouge&quot;&gt;r_auto_reload&lt;/code&gt; is true).&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;		else if ((i_ce)&amp;amp;&amp;amp;(r_running))
		begin&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;If the counter is not zero, we’ll count down.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;			if (!r_zero)
				r_value &amp;lt;= r_value - 1&#39;b1;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Once it reaches zero, we’ll restart it if we are in
&lt;a href=&quot;https://en.wikipedia.org/wiki/Programmable_interval_timer&quot;&gt;interval timer&lt;/a&gt;
mode.  In this mode, &lt;code class=&quot;highlighter-rouge&quot;&gt;auto_reload&lt;/code&gt; will be true.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;			else if (auto_reload)
				r_value &amp;lt;= interval_count;
		end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;If &lt;code class=&quot;highlighter-rouge&quot;&gt;auto_reload&lt;/code&gt; is not set then once the counter reaches zero, the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/ziptimer.v&quot;&gt;timer&lt;/a&gt;
will stop.&lt;/p&gt;

&lt;p&gt;The next register in our implementation is &lt;code class=&quot;highlighter-rouge&quot;&gt;r_zero&lt;/code&gt;.  &lt;code class=&quot;highlighter-rouge&quot;&gt;r_zero&lt;/code&gt; is a helper
register.  It needs to
be equivalent to &lt;code class=&quot;highlighter-rouge&quot;&gt;r_value == 0&lt;/code&gt;.  (We’ll prove that these two expressions
evaluate to the same value in a moment.)  By setting &lt;code class=&quot;highlighter-rouge&quot;&gt;r_zero&lt;/code&gt; on the clock
before &lt;code class=&quot;highlighter-rouge&quot;&gt;r_value&lt;/code&gt; reaches zero, we relieve some of the timing stress within
this module.  Hence, instead of an always block that depends upon whether
or not &lt;code class=&quot;highlighter-rouge&quot;&gt;r_value == 0&lt;/code&gt;, such as the original designs we started out with,
they can instead depend upon a single pre-calculated single-bit value &lt;code class=&quot;highlighter-rouge&quot;&gt;r_zero&lt;/code&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	reg	r_zero  = 1&#39;b1;
	always @(posedge i_clk)
		if (i_reset)
			r_zero &amp;lt;= 1&#39;b1;
		else if (wb_write)
			r_zero &amp;lt;= (i_wb_data[(VW-1):0] == 0);
		else if ((r_running)&amp;amp;&amp;amp;(i_ce))
		begin
			if (r_value == { {(VW-1){1&#39;b0}}, 1&#39;b1 })
				r_zero &amp;lt;= 1&#39;b1;
			else if ((r_zero)&amp;amp;&amp;amp;(auto_reload))
				r_zero &amp;lt;= 1&#39;b0;
		end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;a href=&quot;/blog/2018/03/14/is-formal-hard.html&quot;&gt;Were I writing this code from
scratch&lt;/a&gt;, I’d
scribble into the margin that I’ll want to come back and prove the
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal property&lt;/a&gt;
that&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(*) assert(r_zero == (r_value == 0));&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The final required piece of logic is the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interrupt&quot;&gt;interrupt&lt;/a&gt;
register, &lt;code class=&quot;highlighter-rouge&quot;&gt;o_int&lt;/code&gt;.  While we might consider setting the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interrupt&quot;&gt;interrupt&lt;/a&gt;
line to &lt;code class=&quot;highlighter-rouge&quot;&gt;r_zero&lt;/code&gt;, we’d then get lots of
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interrupt&quot;&gt;interrupt&lt;/a&gt;s
every time the counter was idle.  We’d also get lots of
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interrupt&quot;&gt;interrupt&lt;/a&gt;s
between any pair of &lt;code class=&quot;highlighter-rouge&quot;&gt;i_ce&lt;/code&gt; strobes while the counter was waiting to reload.
Hence, we’ll only set the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interrupt&quot;&gt;interrupt&lt;/a&gt;
any time &lt;code class=&quot;highlighter-rouge&quot;&gt;r_value&lt;/code&gt; transitions to zero, or more explicitly any time it is
equal to one and the &lt;code class=&quot;highlighter-rouge&quot;&gt;i_ce&lt;/code&gt; register is high.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	initial	o_int   = 1&#39;b0;
	always @(posedge i_clk)
		if ((i_reset)||(wb_write)||(!i_ce))
			o_int &amp;lt;= 1&#39;b0;
		else // if (i_ce)
			o_int &amp;lt;= (r_value == { {(VW-1){1&#39;b0}}, 1&#39;b1 });&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;As our last step, we’ll set the return data on the
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;
to be the indication of whether we are in
&lt;a href=&quot;https://en.wikipedia.org/wiki/Programmable_interval_timer&quot;&gt;interval timer&lt;/a&gt;
mode (&lt;code class=&quot;highlighter-rouge&quot;&gt;auto_reload&lt;/code&gt; is high), followed by the current
state of the counter.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	assign	o_wb_data = { auto_reload, r_value };&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Other
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;wishbone return&lt;/a&gt;
return values follow from our prior discussion:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	assign	o_wb_stall = 1&#39;b0;
	assign	o_wb_ack = (i_wb_stb);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;That’s all it takes to generate a timer peripheral for a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Soft_microprocessor&quot;&gt;CPU&lt;/a&gt;.  It’s a bit more
than the simple counter we started out with.
In the next section, we’ll discuss how we might go about &lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formally
verifying&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/ziptimer.v&quot;&gt;this timer&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;the-formal-proof&quot;&gt;The formal proof&lt;/h2&gt;

&lt;p&gt;If you are not familiar with using &lt;a href=&quot;http://www.clifford.at/yosys/&quot;&gt;yosys&lt;/a&gt;
for &lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal
verification&lt;/a&gt;,
then I’ll recommend you go back and read about my &lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;first experiences with
formal methods&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;If you just want a quick reminder, there are two basic operators we’ll be using
below.  The &lt;code class=&quot;highlighter-rouge&quot;&gt;assume()&lt;/code&gt; operator restricts the size of the possible state space
that the
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal methods&lt;/a&gt;
will examine.  The &lt;code class=&quot;highlighter-rouge&quot;&gt;assert()&lt;/code&gt; operator defines which states within
this group are illegal.  The formal engine will try all possible logic threads
to find one where the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Predicate_(mathematical_logic)&quot;&gt;predicate&lt;/a&gt;
expression inside the &lt;code class=&quot;highlighter-rouge&quot;&gt;assert()&lt;/code&gt; statement can be made to be false.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 5. The Golden Rule of Formal Verification&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/fv-master-rule.svg&quot; alt=&quot;&quot; width=&quot;360&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;To know which of &lt;code class=&quot;highlighter-rouge&quot;&gt;assume()&lt;/code&gt; or &lt;code class=&quot;highlighter-rouge&quot;&gt;assert()&lt;/code&gt; to use for any particular
property, I follow the rule shown in Fig 5.  Hence, we’ll &lt;code class=&quot;highlighter-rouge&quot;&gt;assume()&lt;/code&gt;
any properties about our inputs, and we’ll &lt;code class=&quot;highlighter-rouge&quot;&gt;assert()&lt;/code&gt; any properties
about our own internal state or any outputs we might produce.&lt;/p&gt;

&lt;p&gt;There is a third operator we’ll be using as well.  This is the &lt;code class=&quot;highlighter-rouge&quot;&gt;$past()&lt;/code&gt;
operator.  As we use it below, this operator returns the value of the
item within it one clock ago.  The problem with the &lt;code class=&quot;highlighter-rouge&quot;&gt;$past&lt;/code&gt; operator is that
it tends to misbehave prior to the beginning of time.  Hence, any time you
see me using this you’ll also see &lt;code class=&quot;highlighter-rouge&quot;&gt;f_past_valid&lt;/code&gt; in the condition list.&lt;/p&gt;

&lt;p&gt;As with most of my
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal property&lt;/a&gt;
sections, they start with the definition of the &lt;code class=&quot;highlighter-rouge&quot;&gt;f_past_valid&lt;/code&gt; variable
I just mentioned.  We discussed this above, and in more detail
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;before&lt;/a&gt;.
Basically, any assertion regarding something one clock in the &lt;code class=&quot;highlighter-rouge&quot;&gt;$past()&lt;/code&gt;,
before any &lt;code class=&quot;highlighter-rouge&quot;&gt;initial&lt;/code&gt; settings, will fail.
By checking for &lt;code class=&quot;highlighter-rouge&quot;&gt;f_past_valid&lt;/code&gt; being true as part of a formal logic
test, I can then use &lt;code class=&quot;highlighter-rouge&quot;&gt;$past()&lt;/code&gt; expressions in any &lt;code class=&quot;highlighter-rouge&quot;&gt;assert()&lt;/code&gt; statements below
without worrying about whether or not the logic being referenced occurred
before time began.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;`ifdef	FORMAL
	reg	f_past_valid;
	initial	f_past_valid = 1&#39;b0;
	always @(posedge i_clk)
		f_past_valid &amp;lt;= 1&#39;b1;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The next order of business is bounding the &lt;code class=&quot;highlighter-rouge&quot;&gt;i_reset&lt;/code&gt; signal.  This signal needs
to be true initially.  We’ll also insist that it’s true any time &lt;code class=&quot;highlighter-rouge&quot;&gt;f_past_valid&lt;/code&gt;
is false.  Aren’t these two the same condition?  Not quite. While they are
very similar, they are separate conditions.  This second
condition specifies that any time the induction engine tries to set
&lt;code class=&quot;highlighter-rouge&quot;&gt;f_past_valid&lt;/code&gt; to false, then the &lt;code class=&quot;highlighter-rouge&quot;&gt;i_reset&lt;/code&gt; line must also be true which will
then force the design into its initial state.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	initial	assume(i_reset);
	always @(*)
		if (!f_past_valid)
			assume(i_reset);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;If we do this properly, we can use &lt;code class=&quot;highlighter-rouge&quot;&gt;f_past_valid&lt;/code&gt; being false as an indication
that our design should be in its reset state.  In a similar fashion, on the
clock following any &lt;code class=&quot;highlighter-rouge&quot;&gt;i_reset&lt;/code&gt;, the design should also be in its reset state.&lt;/p&gt;

&lt;p&gt;We’ll pull any value from above that has an &lt;code class=&quot;highlighter-rouge&quot;&gt;initial&lt;/code&gt; statement or responds
to an &lt;code class=&quot;highlighter-rouge&quot;&gt;i_reset&lt;/code&gt; signal, and insist on either condition that the registers
have the same value.  We’ll also desk check our design to make certain that
registers set via an &lt;code class=&quot;highlighter-rouge&quot;&gt;initial&lt;/code&gt; statement are also responsive to an &lt;code class=&quot;highlighter-rouge&quot;&gt;i_reset&lt;/code&gt;
and vice-versa.  That is, an &lt;code class=&quot;highlighter-rouge&quot;&gt;initial&lt;/code&gt; statement should set the register
to the same value that an &lt;code class=&quot;highlighter-rouge&quot;&gt;i_reset&lt;/code&gt; would set them to.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(posedge i_clk)
	if ((!f_past_valid)||($past(i_reset)))
	begin
		assert(r_value     == 0);
		assert(r_running   == 0);
		assert(auto_reload == 0);
		assert(interval_count== 0);
		assert(r_zero      == 1&#39;b1);
	end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Let’s now move on to some internal consistency checks.  For example, we
stated above that we wanted &lt;code class=&quot;highlighter-rouge&quot;&gt;r_zero&lt;/code&gt; to be equivalent to &lt;code class=&quot;highlighter-rouge&quot;&gt;r_value==0&lt;/code&gt;.
Let’s now assert that this relationship holds.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(*)
		assert(r_zero == (r_value == 0));&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Likewise, anytime our value is non-zero the timer should be running.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(*)
		if (r_value != 0)
			assert(r_running);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;In a similar fashion, any time we are in interval mode we should be running.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(*)
		if (auto_reload)
			assert(r_running);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Perhaps you may recall these from our scribbled notes above as well?&lt;/p&gt;

&lt;p&gt;Further, if our parameter &lt;code class=&quot;highlighter-rouge&quot;&gt;RELOADABLE&lt;/code&gt; is false, then &lt;code class=&quot;highlighter-rouge&quot;&gt;auto_reload&lt;/code&gt; should
also be false.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(*)
		if (!RELOADABLE)
			assert(auto_reload == 0);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Finally, anytime &lt;code class=&quot;highlighter-rouge&quot;&gt;auto_reload&lt;/code&gt; is true, we should have a non-zero interval
time.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(*)
		if (auto_reload)
			assert(interval_count != 0);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Those are the simple properties.  The next several are more complex.&lt;/p&gt;

&lt;p&gt;Our next step will be to work through the properties associated with &lt;code class=&quot;highlighter-rouge&quot;&gt;r_value&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;For the first of these more complex properties, we’ll say that any
time &lt;code class=&quot;highlighter-rouge&quot;&gt;r_value==0&lt;/code&gt;, i.e. any time the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/ziptimer.v&quot;&gt;timer&lt;/a&gt;
has stopped counting down, then it should stay that way.  However, if you try
to express this simply,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(posedge i_clk)
	if ((f_past_valid)&amp;amp;&amp;amp;($past(r_value)==0))
		assert(r_value == 0);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;you might be surprised that your assertion doesn’t hold.  You’ll first find
that following a
&lt;a href=&quot;/zipcpu/2017/05/29/simple-wishbone.html&quot;&gt;wishbone write&lt;/a&gt;,
&lt;code class=&quot;highlighter-rouge&quot;&gt;r_value&lt;/code&gt; might be something other than zero.
You’ll then discover that, by design, following an automatic reload it won’t
be zero either.  Hence, the actual property is a touch more complex.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(posedge i_clk)
	if ((f_past_valid)&amp;amp;&amp;amp;($past(r_value)==0)
			&amp;amp;&amp;amp;(!$past(wb_write))&amp;amp;&amp;amp;(!$past(auto_reload)))
		assert(r_value == 0);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Next, let’s consider the case where &lt;code class=&quot;highlighter-rouge&quot;&gt;r_value&lt;/code&gt; was equal to zero on the last
clock, but isn’t equal to zero any more.  Specifically, we want to test
whether the interval
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/ziptimer.v&quot;&gt;timer&lt;/a&gt;
started over on a reload as desired.&lt;/p&gt;

&lt;p&gt;In this case, the simple property has several exceptions to it.  The counter
won’t move to its reload value following a reset, nor will it necessarily
move to its reload value following a
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;
&lt;a href=&quot;/zipcpu/2017/05/29/simple-wishbone.html&quot;&gt;write&lt;/a&gt;.
Finally, it should only restart if &lt;code class=&quot;highlighter-rouge&quot;&gt;i_ce&lt;/code&gt; is true, and in all other
cases remain where it was.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(posedge i_clk)
	if ((f_past_valid)&amp;amp;&amp;amp;(!$past(i_reset))&amp;amp;&amp;amp;(!$past(wb_write))
			&amp;amp;&amp;amp;($past(r_value)==0)&amp;amp;&amp;amp;($past(auto_reload)))
	begin
		if ($past(i_ce))
			assert(r_value == interval_count);
		else
			assert(r_value == $past(r_value));
	end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Now let’s consider the case where the &lt;code class=&quot;highlighter-rouge&quot;&gt;r_value&lt;/code&gt; is not equal to zero on
the last clock.  While I’d like to write the assertion that,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(posedge i_clk)
	if ((f_past_valid)&amp;amp;&amp;amp;($past(r_value)!=0))
		assert(r_value == $past(r_value)-1&#39;b1);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;the formal engine again corrects me with several traces showing why this
isn’t the case.  The first trace reminds me that, following a reset,
&lt;code class=&quot;highlighter-rouge&quot;&gt;r_value&lt;/code&gt; will be zero.  Once I fix that and try again, the second trace
reminds me that &lt;code class=&quot;highlighter-rouge&quot;&gt;r_value&lt;/code&gt; can be anything
following a
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;
&lt;a href=&quot;/zipcpu/2017/05/29/simple-wishbone.html&quot;&gt;write&lt;/a&gt;.
Rather than running the formal tools again, I go back and desk check this
time to discover that
if &lt;code class=&quot;highlighter-rouge&quot;&gt;i_ce&lt;/code&gt; isn’t true on the last clock then &lt;code class=&quot;highlighter-rouge&quot;&gt;r_value&lt;/code&gt; shouldn’t change.&lt;/p&gt;

&lt;p&gt;This brings us to the following property,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(posedge i_clk)
	if ((f_past_valid)&amp;amp;&amp;amp;(!$past(i_reset))
			&amp;amp;&amp;amp;(!$past(wb_write))&amp;amp;&amp;amp;($past(r_value)!=0))
	begin
		if ($past(i_ce))
			assert(r_value == $past(r_value)-1&#39;b1);
		else
			assert(r_value == $past(r_value));
	end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;How about a
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;
&lt;a href=&quot;/zipcpu/2017/05/29/simple-wishbone.html&quot;&gt;write&lt;/a&gt;?
Following a
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;
&lt;a href=&quot;/zipcpu/2017/05/29/simple-wishbone.html&quot;&gt;write&lt;/a&gt;,
we want our counter to have the data written to it in our value.
The exception is a reset.  If a
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;
&lt;a href=&quot;/zipcpu/2017/05/29/simple-wishbone.html&quot;&gt;write&lt;/a&gt;
and a reset occur on the same clock, we’d rather reset.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(posedge i_clk)
	if ((f_past_valid)&amp;amp;&amp;amp;(!$past(i_reset))&amp;amp;&amp;amp;($past(wb_write)))
		assert(r_value == $past(i_wb_data[(VW-1):0]));&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This also applies to the interval length.  Following a
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;
&lt;a href=&quot;/zipcpu/2017/05/29/simple-wishbone.html&quot;&gt;write&lt;/a&gt;,
if the value is non-zero, and if this module is built with the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Programmable_interval_timer&quot;&gt;interval timer&lt;/a&gt;
capability, then the high bit will determine whether or not we enter into
&lt;a href=&quot;https://en.wikipedia.org/wiki/Programmable_interval_timer&quot;&gt;interval timer&lt;/a&gt;
mode.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(posedge i_clk)
	if ((f_past_valid)&amp;amp;&amp;amp;(!$past(i_reset))&amp;amp;&amp;amp;($past(wb_write))
			&amp;amp;&amp;amp;(RELOADABLE)&amp;amp;&amp;amp;(|$past(i_wb_data[(VW-1):0])))
		assert(auto_reload == $past(i_wb_data[(BW-1)]));&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;We’re almost done.  Before leaving, we need to double check our output
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interrupt&quot;&gt;interrupt&lt;/a&gt;.
This wire, &lt;code class=&quot;highlighter-rouge&quot;&gt;o_int&lt;/code&gt;, should be set any time &lt;code class=&quot;highlighter-rouge&quot;&gt;r_value&lt;/code&gt; transitions from &lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt; to
&lt;code class=&quot;highlighter-rouge&quot;&gt;0&lt;/code&gt;.  Or, at least, that was my original thought.  Then as I worked through
this logic using &lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal
methods&lt;/a&gt;,
I realized there were some exceptions.&lt;/p&gt;

&lt;p&gt;If the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/ziptimer.v&quot;&gt;timer&lt;/a&gt;
is reset in the last cycle, then the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interrupt&quot;&gt;interrupt&lt;/a&gt;
should be inactive.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(posedge i_clk)
	if (!(f_past_valid)||($past(i_reset)))
		assert(!o_int);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Following a
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;
&lt;a href=&quot;/zipcpu/2017/05/29/simple-wishbone.html&quot;&gt;write&lt;/a&gt;, the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interrupt&quot;&gt;interrupt&lt;/a&gt;
wire should be zero as well.  This will allow us to turn the timer &lt;em&gt;off&lt;/em&gt; by
simply writing a zero to it.  Likewise, if
&lt;code class=&quot;highlighter-rouge&quot;&gt;i_ce&lt;/code&gt; wasn’t true on the last clock, then we didn’t just hit zero and the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interrupt&quot;&gt;interrupt&lt;/a&gt;
should be clear again.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	else if (($past(wb_write))||(!$past(i_ce)))
		assert(!o_int);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;So when should the output
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interrupt&quot;&gt;interrupt&lt;/a&gt;
be set?  Any time we transition to zero.
Hence, it should be set following the clock where &lt;code class=&quot;highlighter-rouge&quot;&gt;i_ce&lt;/code&gt; was high and
&lt;code class=&quot;highlighter-rouge&quot;&gt;r_value&lt;/code&gt; was a one.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	else
		assert(o_int == ((r_running)&amp;amp;&amp;amp;(r_value == 0)));&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Our last
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal properties&lt;/a&gt;
are associated with the
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;wishbone bus&lt;/a&gt;.
At first glance, these properties below may just appear like restatements
of the logic above.  In many ways they are.  However, by placing these here
I know I won’t carelessly adjust this interface logic while trying to optimize
things.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(*)
		assert(o_wb_ack == i_wb_stb);

	always @(*)
		assert(!o_wb_stall);
	always @(*)
		assert(o_wb_data[BW-1] == auto_reload);
	always @(*)
		assert(o_wb_data[VW-1:0] == r_value);
`endif
endmodule&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;That’s the last of our formal properties.  Did you notice along the way how
the formal engine helped us find the right properties for our code?  That it
found subtleties like the reset condition that needed to be checked for?
Not only that, did you notice how the formal engine helped us flesh out the
final details in our &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/ziptimer.v&quot;&gt;timer
implementation&lt;/a&gt;?&lt;/p&gt;

&lt;p&gt;These are all reasons why I have now started using
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal methods&lt;/a&gt;
before ever writing a test bench or running a simulation.  Using
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal methods&lt;/a&gt;
helps me discover details I might otherwise not think about.&lt;/p&gt;

&lt;h2 id=&quot;autofpga&quot;&gt;AutoFPGA&lt;/h2&gt;

&lt;p&gt;We have one more task before we are done: connecting &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/ziptimer.v&quot;&gt;this
timer&lt;/a&gt;
to the rest of our design.  If you are using
&lt;a href=&quot;/zipcpu/2017/10/05/autofpga-intro.html&quot;&gt;AutoFPGA&lt;/a&gt;,
that’s just as easy as adding the configuration file for this timer
to the &lt;a href=&quot;/zipcpu/2017/10/05/autofpga-intro.html&quot;&gt;AutoFPGA&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/tinyzip/blob/master/auto-data/Makefile&quot;&gt;command line&lt;/a&gt;.
Alternatively, we could &lt;a href=&quot;/blog/2017/06/22/simple-wb-interconnect.html&quot;&gt;connect this to the bus interconnect by
hand&lt;/a&gt;,
but I think you’ll find it simpler to use
&lt;a href=&quot;/zipcpu/2017/10/05/autofpga-intro.html&quot;&gt;AutoFPGA&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Normally this isn’t necessary with the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
since the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/ziptimer.v&quot;&gt;ZipTimer&lt;/a&gt;
is already connected manually within the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/zipsystem.v&quot;&gt;ZipSystem&lt;/a&gt;
module, shown above in Fig 1.
Two recent &lt;a href=&quot;/zipcpu/2017/10/05/autofpga-intro.html&quot;&gt;AutoFPGA&lt;/a&gt;
based designs, one for the
&lt;a href=&quot;https://github.com/ZipCPU/arrowzip/&quot;&gt;MAX-1000&lt;/a&gt;
and another for the
&lt;a href=&quot;https://github.com/ZipCPU/tinyzip&quot;&gt;TinyFPGA&lt;/a&gt; (neither quite complete),
however, don’t use the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/zipsystem.v&quot;&gt;ZipSystem&lt;/a&gt;
but rather the bare
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/zipbones.v&quot;&gt;ZipBones&lt;/a&gt;
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; wrapper, shown in Fig 6.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 6. The ZipBones&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/zipbones.svg&quot; alt=&quot;&quot; width=&quot;320&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;In each of these designs, you can find a
&lt;a href=&quot;/zipcpu/2017/10/05/autofpga-intro.html&quot;&gt;AutoFPGA&lt;/a&gt;
bustimer configuration within the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/zipbones.v&quot;&gt;ZipBones&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/tinyzip/blob/master/auto-data/zipbones.txt&quot;&gt;configuration&lt;/a&gt;
file, since having the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/ziptimer.v&quot;&gt;timer&lt;/a&gt;
is so useful to the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;–as
it would be to any
&lt;a href=&quot;https://en.wikipedia.org/wiki/Soft_microprocessor&quot;&gt;CPU&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;You may recall from the general format of an
&lt;a href=&quot;/zipcpu/2017/10/05/autofpga-intro.html&quot;&gt;AutoFPGA&lt;/a&gt;
configuration file that the entries consist of &lt;code class=&quot;highlighter-rouge&quot;&gt;@KEY=VALUE&lt;/code&gt; pairs.  They are
primarily used to tell
&lt;a href=&quot;/zipcpu/2017/10/05/autofpga-intro.html&quot;&gt;AutoFPGA&lt;/a&gt;
what text to copy and paste into a set of various project files.
If the &lt;code class=&quot;highlighter-rouge&quot;&gt;VALUE&lt;/code&gt; takes less than a line, the &lt;code class=&quot;highlighter-rouge&quot;&gt;@KEY=VALUE&lt;/code&gt; definition can be
placed on a single line.  Otherwise, all of the lines following &lt;code class=&quot;highlighter-rouge&quot;&gt;@KEY=&lt;/code&gt; will
consist of the &lt;code class=&quot;highlighter-rouge&quot;&gt;VALUE&lt;/code&gt; for that key.  Likewise, if the &lt;code class=&quot;highlighter-rouge&quot;&gt;VALUE&lt;/code&gt; is numeric,
you can have
&lt;a href=&quot;/zipcpu/2017/10/05/autofpga-intro.html&quot;&gt;AutoFPGA&lt;/a&gt;
calculate the value by placing a &lt;code class=&quot;highlighter-rouge&quot;&gt;$&lt;/code&gt; between the &lt;code class=&quot;highlighter-rouge&quot;&gt;@&lt;/code&gt; and the &lt;code class=&quot;highlighter-rouge&quot;&gt;KEY&lt;/code&gt; and so use
the &lt;code class=&quot;highlighter-rouge&quot;&gt;@$KEY=EXPRESSION&lt;/code&gt; form.  Finally, to reference
one value, &lt;code class=&quot;highlighter-rouge&quot;&gt;@KEYONE=VALONE&lt;/code&gt;, from within another, you would reference
it as &lt;code class=&quot;highlighter-rouge&quot;&gt;@$(KEYONE)&lt;/code&gt; within the value portion of the second
&lt;code class=&quot;highlighter-rouge&quot;&gt;@KEYTWO=VALTWO&lt;/code&gt; construct.&lt;/p&gt;

&lt;p&gt;Perhaps this would make more sense if we walked through an example.&lt;/p&gt;

&lt;p&gt;Every &lt;a href=&quot;/zipcpu/2017/10/05/autofpga-intro.html&quot;&gt;AutoFPGA&lt;/a&gt;
component description begins with a &lt;code class=&quot;highlighter-rouge&quot;&gt;@PREFIX&lt;/code&gt; tag.  This defines the beginning
of the component, as well as providing a name for the component.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;@PREFIX=bustimer&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;I chose to call this device a &lt;code class=&quot;highlighter-rouge&quot;&gt;bustimer&lt;/code&gt;.  Unlike other timers that might be
internal to other portions of the design, this one can be accessed from the
main &lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;wishbone bus&lt;/a&gt;–hence
the name.&lt;/p&gt;

&lt;p&gt;If you are following along from the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/zipbones.v&quot;&gt;ZipBones&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/tinyzip/blob/master/auto-data/zipbones.txt&quot;&gt;configuration&lt;/a&gt;
file, you can skip to the &lt;code class=&quot;highlighter-rouge&quot;&gt;@PREFIX=bustimer&lt;/code&gt; line.  The information prior
defines how to connect the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/zipbones.v&quot;&gt;ZipBones&lt;/a&gt;
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
wrapper to the bus.  A watchdog timer definition follows this one, all within
the same
&lt;a href=&quot;https://github.com/ZipCPU/tinyzip/blob/master/auto-data/zipbones.txt&quot;&gt;configuration&lt;/a&gt;
file.&lt;/p&gt;

&lt;p&gt;While &lt;a href=&quot;/zipcpu/2017/10/05/autofpga-intro.html&quot;&gt;AutoFPGA&lt;/a&gt;
doesn’t require it, I often define a &lt;code class=&quot;highlighter-rouge&quot;&gt;@DEVID&lt;/code&gt; tag.  I
primarily use this tag for contexts that don’t like lower case.
&lt;a href=&quot;/zipcpu/2017/10/05/autofpga-intro.html&quot;&gt;AutoFPGA&lt;/a&gt;
doesn’t do anything fancy with this tag, other then paste it into other
tags as I tell it to below.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;@DEVID=BUSTIMER&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The &lt;a href=&quot;https://github.com/ZipCPU/tinyzip/blob/master/rtl/main.v&quot;&gt;main.v&lt;/a&gt;
file of an
&lt;a href=&quot;/zipcpu/2017/10/05/autofpga-intro.html&quot;&gt;AutoFPGA&lt;/a&gt;
based project starts with a series of
&lt;code class=&quot;highlighter-rouge&quot;&gt;ifdef&lt;/code&gt;’s just before the &lt;code class=&quot;highlighter-rouge&quot;&gt;module&lt;/code&gt; declaration.  This allows a user to select
some items and not others, as well as capturing a set of dependencies of what
items depend upon others.  In this case, we have no dependencies, but we’ll
still create an &lt;code class=&quot;highlighter-rouge&quot;&gt;define&lt;/code&gt; line in case something else depends upon this
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_(computing)&quot;&gt;bus&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/ziptimer.v&quot;&gt;timer&lt;/a&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;@ACCESS=@$(DEVID)_ACCESS&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Now let’s connect our timer to a
&lt;a href=&quot;/zipcpu/2017/05/29/simple-wishbone.html&quot;&gt;wishbone bus&lt;/a&gt;.
Specifically, we want to connect this component to the system
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_(computing)&quot;&gt;bus&lt;/a&gt;,
by default named &lt;code class=&quot;highlighter-rouge&quot;&gt;wb&lt;/code&gt;.
We’ll also declare that this
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_(computing)&quot;&gt;bus&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/ziptimer.v&quot;&gt;timer&lt;/a&gt;
is a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_(computing)&quot;&gt;bus&lt;/a&gt;
slave whose result is always available and that never stalls,
&lt;code class=&quot;highlighter-rouge&quot;&gt;@SLAVE.TYPE=SINGLE&lt;/code&gt;, and one that has only a single address, &lt;code class=&quot;highlighter-rouge&quot;&gt;@NADDR=1&lt;/code&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;@SLAVE.BUS=wb
@SLAVE.TYPE=SINGLE
@NADDR=1&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Actually connecting this to a
&lt;a href=&quot;/zipcpu/2017/05/29/simple-wishbone.html&quot;&gt;bus&lt;/a&gt;
depends upon the code we want to place into our
&lt;a href=&quot;https://github.com/ZipCPU/tinyzip/blob/master/rtl/main.v&quot;&gt;main.v&lt;/a&gt;
file.  This is the purpose of the &lt;code class=&quot;highlighter-rouge&quot;&gt;@MAIN.INSERT&lt;/code&gt; tag.  Code within
this tag will get copied directly (after variable name substitution) into the
&lt;a href=&quot;https://github.com/ZipCPU/tinyzip/blob/master/rtl/main.v&quot;&gt;main.v&lt;/a&gt;
file.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;@MAIN.INSERT=
	ziptimer @$(PREFIX)i(i_clk, i_reset, 1&#39;b1,
			wb_cyc, (wb_stb)&amp;amp;&amp;amp;(@$(PREFIX)_sel), wb_we, wb_data,
				@$(PREFIX)_ack, @$(PREFIX)_stall,
				@$(PREFIX)_data, @$(PREFIX)_int);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;While you don’t need to reference the &lt;code class=&quot;highlighter-rouge&quot;&gt;@$(PREFIX)&lt;/code&gt; tag at all, I often use this
to help keep the names unique within any given design.  Once the pattern
matching takes place, these lines will just turn into:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;@MAIN.INSERT=
	ziptimer bustimeri(i_clk, i_reset, 1&#39;b1,
			wb_cyc, (wb_stb)&amp;amp;&amp;amp;(bustimer_sel), wb_we, wb_data,
				bustimer_ack, bustimer_stall,
				bustimer_data, bustimer_int);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;You don’t need to define the &lt;code class=&quot;highlighter-rouge&quot;&gt;bustimer_ack&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;bustimer_stall&lt;/code&gt;, or
&lt;code class=&quot;highlighter-rouge&quot;&gt;bustimer_data&lt;/code&gt; wires.
&lt;a href=&quot;/zipcpu/2017/10/05/autofpga-intro.html&quot;&gt;AutoFPGA&lt;/a&gt;
will define these for you once you tell it that this item is a
&lt;a href=&quot;/zipcpu/2017/05/29/simple-wishbone.html&quot;&gt;bus&lt;/a&gt; slave.
&lt;a href=&quot;/zipcpu/2017/10/05/autofpga-intro.html&quot;&gt;AutoFPGA&lt;/a&gt;
will also create a &lt;code class=&quot;highlighter-rouge&quot;&gt;bustimer_sel&lt;/code&gt; wire.  This wire will be true any time this
&lt;a href=&quot;/zipcpu/2017/05/29/simple-wishbone.html&quot;&gt;bus&lt;/a&gt;
component’s address is selected.  You do need to connect these wires to your
component, as we’ve done above.&lt;/p&gt;

&lt;p&gt;After running
&lt;a href=&quot;/zipcpu/2017/10/05/autofpga-intro.html&quot;&gt;AutoFPGA&lt;/a&gt;,
you should then be able to find this code snipped in the
&lt;a href=&quot;https://github.com/ZipCPU/tinyzip/blob/master/rtl/main.v&quot;&gt;main.v&lt;/a&gt;,
file.
&lt;a href=&quot;/zipcpu/2017/10/05/autofpga-intro.html&quot;&gt;AutoFPGA&lt;/a&gt;
will also declare the rest of the wires necessary to set this up as well.&lt;/p&gt;

&lt;p&gt;The last wire, &lt;code class=&quot;highlighter-rouge&quot;&gt;bustimer_int&lt;/code&gt;, is also defined automatically by
&lt;a href=&quot;/zipcpu/2017/10/05/autofpga-intro.html&quot;&gt;AutoFPGA&lt;/a&gt; as
part of generating and connecting up the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interrupt&quot;&gt;interrupt&lt;/a&gt;
wires.  In our case, we have a &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/icontrol.v&quot;&gt;programmable interrupt controller
(PIC)&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/tinyzip/blob/master/auto-data/pic.txt&quot;&gt;defined elsewhere in the
design&lt;/a&gt;
with the name of &lt;code class=&quot;highlighter-rouge&quot;&gt;buspic&lt;/code&gt;.  Hence, all we need to tell
&lt;a href=&quot;/zipcpu/2017/10/05/autofpga-intro.html&quot;&gt;AutoFPGA&lt;/a&gt;
is that we have an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interrupt&quot;&gt;interrupt&lt;/a&gt;
named &lt;code class=&quot;highlighter-rouge&quot;&gt;BUSTIMER&lt;/code&gt;, whose
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interrupt&quot;&gt;interrupt&lt;/a&gt;
wire is &lt;code class=&quot;highlighter-rouge&quot;&gt;bustimer_int&lt;/code&gt;, that needs to be connected to the
&lt;code class=&quot;highlighter-rouge&quot;&gt;buspic&lt;/code&gt;s inputs.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;@INT.BUSTIMER.WIRE= @$(PREFIX)_int
@INT.BUSTIMER.PIC= buspic&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This will add our &lt;code class=&quot;highlighter-rouge&quot;&gt;bustimer_int&lt;/code&gt; to the list of components within the
&lt;code class=&quot;highlighter-rouge&quot;&gt;bus_int_vector&lt;/code&gt;.  Hence, if you check the
&lt;a href=&quot;https://github.com/ZipCPU/tinyzip/blob/master/rtl/main.v&quot;&gt;main.v&lt;/a&gt;
file, you’ll see the &lt;code class=&quot;highlighter-rouge&quot;&gt;bustimer_int&lt;/code&gt; listed long with the other
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interrupt&quot;&gt;interrupt&lt;/a&gt;
lines.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;assign	bus_int_vector = {
	// ...
	bustimer_int,
	// ...
};&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Internal to the
&lt;a href=&quot;https://github.com/ZipCPU/tinyzip/blob/master/sw/zlib/board.h&quot;&gt;board.h&lt;/a&gt;
file that
&lt;a href=&quot;/zipcpu/2017/10/05/autofpga-intro.html&quot;&gt;AutoFPGA&lt;/a&gt;
creates for the internal processor that might use this design, this will
also create a line,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;cp&quot;&gt;#define	BUSPIC_BUSTIMER	BUSPIC(1)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;after assigning this peripheral to
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interrupt&quot;&gt;interrupt&lt;/a&gt;
control wire number one.&lt;/p&gt;

&lt;p&gt;The last two parts deal with non-Verilog parts of the design.  The first of
these deals with &lt;a href=&quot;/blog/2017/06/29/sw-dbg-interface.html&quot;&gt;connecting this device to the external debugging
interface&lt;/a&gt;.
Specifically, we’ll want to create a register, &lt;code class=&quot;highlighter-rouge&quot;&gt;R_BUSTIMER&lt;/code&gt;, with the human
name, &lt;code class=&quot;highlighter-rouge&quot;&gt;BUSTIMER&lt;/code&gt;.  These next three lines adjust the files
&lt;a href=&quot;https://github.com/ZipCPU/tinyzip/blob/master/sw/host/regdefs.h&quot;&gt;regdefs.h&lt;/a&gt;
and &lt;a href=&quot;https://github.com/ZipCPU/tinyzip/blob/master/sw/host/regdefs.cpp&quot;&gt;regdefs.cpp&lt;/a&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;@REGS.NOTE= // The bus timer
@REGS.N=1
@REGS.0= 0 R_@$(DEVID) @$(DEVID)&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;First, upon reading these lines,
&lt;a href=&quot;/zipcpu/2017/10/05/autofpga-intro.html&quot;&gt;AutoFPGA&lt;/a&gt;
will place a definition into the
&lt;a href=&quot;https://github.com/ZipCPU/tinyzip/blob/master/sw/host/regdefs.h&quot;&gt;regdefs.h&lt;/a&gt;
output file, defining an
&lt;code class=&quot;highlighter-rouge&quot;&gt;R_BUSTIMER&lt;/code&gt; identifier to be equivalent to the address of this
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/ziptimer.v&quot;&gt;timer&lt;/a&gt;
register.  This will tell external host components where in the memory
space to access this register when using &lt;code class=&quot;highlighter-rouge&quot;&gt;readio()&lt;/code&gt; or &lt;code class=&quot;highlighter-rouge&quot;&gt;writeio()&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/zipcpu/2017/10/05/autofpga-intro.html&quot;&gt;AutoFPGA&lt;/a&gt;
will also place references to this register into
&lt;a href=&quot;https://github.com/ZipCPU/tinyzip/blob/master/sw/host/regdefs.cpp&quot;&gt;regdefs.cpp&lt;/a&gt;.
&lt;a href=&quot;https://github.com/ZipCPU/tinyzip/blob/master/sw/host/regdefs.cpp&quot;&gt;This file&lt;/a&gt;
contains a mapping between the computer regiser name &lt;code class=&quot;highlighter-rouge&quot;&gt;R_BUSTIMER&lt;/code&gt;
and the user name for this register, &lt;code class=&quot;highlighter-rouge&quot;&gt;BUSTIMER&lt;/code&gt;.  As a result, you can then
use the &lt;code class=&quot;highlighter-rouge&quot;&gt;wbregs&lt;/code&gt; program, a variant of the old fashioned
&lt;a href=&quot;https://en.wikipedia.org/wiki/PEEK_and_POKE&quot;&gt;peek and poke hardware interface&lt;/a&gt;,
to read from the
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/ziptimer.v&quot;&gt;timer&lt;/a&gt;
with the command &lt;code class=&quot;highlighter-rouge&quot;&gt;wbregs bustimer&lt;/code&gt;, or to write to it via
&lt;a href=&quot;/blog/2017/06/29/sw-dbg-interface.html&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;wbregs bustimer newvalue&lt;/code&gt;&lt;/a&gt;.
(I have another version of this program called &lt;code class=&quot;highlighter-rouge&quot;&gt;avregs&lt;/code&gt; for use with the
&lt;a href=&quot;https://www.altera.com/literature/manual/mnl_avalon_spec.pdf&quot;&gt;Avalon bus&lt;/a&gt;
on a
&lt;a href=&quot;/blog/2018/02/09/first-cyclonev.html&quot;&gt;Cyclone-V&lt;/a&gt;
 …)&lt;/p&gt;

&lt;p&gt;The last item places a reference to this
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/ziptimer.v&quot;&gt;timer&lt;/a&gt;
into the
&lt;a href=&quot;https://github.com/ZipCPU/tinyzip/blob/master/sw/zlib/board.h&quot;&gt;board.h&lt;/a&gt;
file.  This file would be used by the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
to know if the
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/ziptimer.v&quot;&gt;timer&lt;/a&gt;
was built into the design and, if so, what address that
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/ziptimer.v&quot;&gt;timer&lt;/a&gt;
was placed into.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;@BDEF.IONAME=_bustimer
@BDEF.IOTYPE=unsigned
@BDEF.OSDEF=_BOARD_HAS_@$(DEVID)
@BDEF.OSVAL=static volatile @$BDEF.IOTYPE *const @$(BDEF.IONAME) = ((@$BDEF.IOTYPE *)@$[0x%08x](REGBASE));&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;a href=&quot;/zipcpu/2017/10/05/autofpga-intro.html&quot;&gt;AutoFPGA&lt;/a&gt;
will use this to create a line, similar to the following one, inside the
&lt;a href=&quot;https://github.com/ZipCPU/tinyzip/blob/master/sw/zlib/board.h&quot;&gt;board.h&lt;/a&gt;
file:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;cp&quot;&gt;#ifdef	BUSTIMER_ACCESS
#define	_BOARD_HAS_BUSTIMER
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;volatile&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_bustimer&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;mh&quot;&gt;0x00100000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;cp&quot;&gt;#endif	// BUSTIMER_ACCESS&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Remember, the goal of
&lt;a href=&quot;/zipcpu/2017/10/05/autofpga-intro.html&quot;&gt;AutoFPGA&lt;/a&gt;
is to make the inclusion of
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_(computing)&quot;&gt;bus&lt;/a&gt;
components into a design easier.  Hence, by placing these few lines into an
&lt;a href=&quot;/zipcpu/2017/10/05/autofpga-intro.html&quot;&gt;AutoFPGA&lt;/a&gt;
configuration file, this
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_(computing)&quot;&gt;bus&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/ziptimer.v&quot;&gt;timer&lt;/a&gt;
will be included into the design.  Removing these lines from the
&lt;a href=&quot;/zipcpu/2017/10/05/autofpga-intro.html&quot;&gt;AutoFPGA&lt;/a&gt;
configuration will seemlessly remove this
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_(computing)&quot;&gt;bus&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/ziptimer.v&quot;&gt;timer&lt;/a&gt;
from the design.&lt;/p&gt;

&lt;h2 id=&quot;conclusions&quot;&gt;Conclusions&lt;/h2&gt;

&lt;p&gt;We’ve now gone over everything it takes to create a useful countdown timer
within an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
design–whether a “one-shot” timer, or a fully programmable
interval timer.  Once put together, the final &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/ziptimer.v&quot;&gt;Verilog
code&lt;/a&gt;
isn’t all that much more difficult than
the original counter we started out from.  What may surprise you, though,
is how much work we went through to place such a &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/ziptimer.v&quot;&gt;simple
counter&lt;/a&gt;
into a design.  Not only did we
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formally&lt;/a&gt;
verify our
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/ziptimer.v&quot;&gt;timer&lt;/a&gt;,
but then we also had to connect it to the
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;wishbone bus&lt;/a&gt;
within the design.  We also dealt with several subtle issues associated with
making a
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/ziptimer.v&quot;&gt;timer&lt;/a&gt;
useful along the way.&lt;/p&gt;

&lt;p&gt;What can you use such a
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/ziptimer.v&quot;&gt;timer&lt;/a&gt;
for?&lt;/p&gt;

&lt;p&gt;We’ve already discussed how this can be the centerpiece of the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Computer_multitasking&quot;&gt;multitasking&lt;/a&gt;
implementation within an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Operating_System&quot;&gt;Operating System&lt;/a&gt;.
Upon any
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/ziptimer.v&quot;&gt;timer&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interrupt&quot;&gt;interrupt&lt;/a&gt;, the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Operating_System&quot;&gt;Operating System&lt;/a&gt;
can then swap user tasks or processes.
&lt;a href=&quot;https://www.blueletterbible.org/kjv/jas/4/15&quot;&gt;Should the Lord will&lt;/a&gt;, I’ll
come back and share how one
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/s6soc&quot;&gt;implementation&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/s6soc/blob/master/sw/zipos/kernel.c&quot;&gt;uses this&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interrupt&quot;&gt;interrupt&lt;/a&gt;
for exactly that purpose.&lt;/p&gt;

&lt;p&gt;There’s another valuable use of a
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/ziptimer.v&quot;&gt;timer&lt;/a&gt;
such as this–one which may not be
as obvious.  In the presentation above, we discussed wiring the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interrupt&quot;&gt;interrupt&lt;/a&gt;
wire to the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Soft_microprocessor&quot;&gt;CPU&lt;/a&gt;’s
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/icontrol.v&quot;&gt;interrupt controller&lt;/a&gt;.  If you instead connected the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interrupt&quot;&gt;interrupt&lt;/a&gt;
output to the reset wire for the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Soft_microprocessor&quot;&gt;CPU&lt;/a&gt;,
you would have created a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Watchdog_timer&quot;&gt;watchdog&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/ziptimer.v&quot;&gt;timer&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;So you see, a basic counter isn’t nearly as irrelevant as you might have
thought it would be, neither is it as simple.  It’s also provides a very
good example of the full
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
&lt;a href=&quot;/blog/2017/06/02/design-process.html&quot;&gt;design process&lt;/a&gt;.&lt;/p&gt;
&lt;hr /&gt;&lt;p&gt;&lt;em&gt;And He said unto them, It is not for you to know the times or the seasons, which the Father hath put in His own power. (Acts 1:7)&lt;/em&gt;</description>
        <pubDate>Tue, 17 Apr 2018 00:00:00 -0400</pubDate>
        <link>https://zipcpu.com/zipcpu/2018/04/17/ziptimer.html</link>
        <guid isPermaLink="true">https://zipcpu.com/zipcpu/2018/04/17/ziptimer.html</guid>
        
        
        <category>zipcpu</category>
        
      </item>
    
      <item>
        <title>Formally Verifying an Asynchronous Reset</title>
        <description>&lt;p&gt;&lt;a href=&quot;/blog/2017/10/20/cdc.html&quot;&gt;Clock Domain Crossings&lt;/a&gt;
can be difficult to get right.  This applies not only
to crossing data and logic from one clock domain to another, but also to
crossing resets from one clock domain to another.  The general rule is that all
logic &lt;a href=&quot;https://en.wikipedia.org/wiki/Flip-flop_(electronics)#Timing_considerations&quot;&gt;must have a guaranteed settling time before the next rising edge of
the next clock&lt;/a&gt;.
If this rule is violated then logic may enter a state that
is neither &lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt; nor &lt;code class=&quot;highlighter-rouge&quot;&gt;0&lt;/code&gt;, neither true nor false.&lt;/p&gt;

&lt;p&gt;This is
&lt;a href=&quot;https://en.wikipedia.org/wiki/Metastability_in_electronics&quot;&gt;metastability&lt;/a&gt;.
Avoid it at all costs.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 1. Synchronizing an Asynchronous Reset&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/areset-regions.svg&quot; width=&quot;360&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;In the case of an asynchronous reset, it usually doesn’t matter all that much
during which clock interval the design enters into the reset state.  As long
as the reset remains active long enough to fully propagate through the design,
everything will eventually enter into this state.  What matters is whether or
not the whole design leaves the reset state at the same time: on a clock edge.&lt;/p&gt;

&lt;p&gt;Fig 1. shows an example of such an asynchronous reset.  The negative logic
reset comes into the design with no guarantee of being synchronous with
the clock.
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flip-flop_(electronics)&quot;&gt;Flip-flops&lt;/a&gt;
dependent upon that reset may then enter into a metastable state, shown by
the pink background in the figure.  Logic within the design needs to
recognize this reset, and synchronize its release.  This is shown by the
green region, where the adjusted reset clears and returns to zero at
the sime time as the rising edge of the system clock.&lt;/p&gt;

&lt;p&gt;You may also notice from Fig 1 that the incoming asynchronous reset
signal is based upon negative logic.  In other words, to activate the reset
the logic needs to be pulled low.  This is a common practice in
&lt;a href=&quot;/blog/2017/10/13/fpga-v-asic.html&quot;&gt;ASIC designs&lt;/a&gt;,
since it allows a design to start entering into its reset state before
sufficient power is available to assert a positive going reset across the
entire design–although this isn’t usually required with FPGA designs.&lt;/p&gt;

&lt;p&gt;Since the logic necessary to do this is pretty simple, let’s take a look at it
in the next section.&lt;/p&gt;

&lt;h2 id=&quot;verilog&quot;&gt;Verilog&lt;/h2&gt;

&lt;p&gt;For our &lt;a href=&quot;/examples/areset.v&quot;&gt;simple Verilog example&lt;/a&gt;,
let’s create a synchronous positive logic
reset signal from a negative logic asynchronous reset.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: left&quot;&gt;&lt;caption&gt;Fig 2. Three Flip-flop Asynchronous Reset Synchronizer&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/areset-fifos.svg&quot; width=&quot;360&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;The &lt;a href=&quot;/examples/areset.v&quot;&gt;basic code&lt;/a&gt;
just sets the outgoing reset and the three
&lt;a href=&quot;/blog/2017/10/20/cdc.html&quot;&gt;flip-flop synchronizers&lt;/a&gt;
to &lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt; anytime the asynchronous reset is true, and then waits for three clock
edges to release.  You can see this basic logic pictorially in Fig 2 on the
left.&lt;/p&gt;

&lt;p&gt;Since &lt;a href=&quot;/examples/areset.v&quot;&gt;the code&lt;/a&gt;
itself is so short, I’ll spend a moment touching on some
details I usually avoid along the way.  For example, I (now) always start
any Verilog design by setting the &lt;code class=&quot;highlighter-rouge&quot;&gt;default_nettype&lt;/code&gt; to
&lt;code class=&quot;highlighter-rouge&quot;&gt;none&lt;/code&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;`default_nettype	none&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This one statement is really a blessing when it comes to finding
errors within your code.  Verilog specifies that the default synthesizer
behavior upon finding any undeclared identifier
is to assume that the identifier was supposed to reference a &lt;code class=&quot;highlighter-rouge&quot;&gt;wire&lt;/code&gt;, and so
the synthesizer will then quietly declare a &lt;code class=&quot;highlighter-rouge&quot;&gt;wire&lt;/code&gt; for you when you would have
rather had the synthesizer report an error due to your misspelling.  By
telling the synthesis tool not to do this, it becomes much easier to catch
errors you might have in your code.&lt;/p&gt;

&lt;p&gt;Our module will accept two inputs, and produce one output.  The two inputs will
be the clock, &lt;code class=&quot;highlighter-rouge&quot;&gt;i_clk&lt;/code&gt; and the negative going asynchronous reset, &lt;code class=&quot;highlighter-rouge&quot;&gt;i_areset_n&lt;/code&gt;.
The underscores here have specific meanings.  &lt;code class=&quot;highlighter-rouge&quot;&gt;i_&lt;/code&gt; references an input,
&lt;code class=&quot;highlighter-rouge&quot;&gt;o_&lt;/code&gt; in a moment will reference an output, and in the case of this reset the
&lt;code class=&quot;highlighter-rouge&quot;&gt;_n&lt;/code&gt; suffix references negative logic.  The last item in our portlist is
our synchronized output signal, &lt;code class=&quot;highlighter-rouge&quot;&gt;o_reset&lt;/code&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;module areset(i_clk, i_areset_n, o_reset);
	input	wire	i_clk, i_areset_n;
	output	reg	o_reset;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;To handle the synchronization, we’ll use a &lt;a href=&quot;/blog/2017/10/20/cdc.html&quot;&gt;three clock
synchronizer&lt;/a&gt;.  This requires
two internal state bits that we’ll call &lt;code class=&quot;highlighter-rouge&quot;&gt;sync_fifo&lt;/code&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	reg	[1:0]	sync_fifo;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;We’ll also assume the design begins in a reset state, and so initialize our
&lt;a href=&quot;/blog/2017/10/20/cdc.html&quot;&gt;synchronization FIFO&lt;/a&gt;
and our output to start in a reset condition.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	initial	sync_fifo = 2&#39;h3;
	initial	o_reset = 1&#39;b1;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Enough of the preliminaries.  What does it take to synchronize a reset?
Just the following four lines of code.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(posedge i_clk or negedge i_areset_n)
	if (!i_areset_n)
		{ o_reset, sync_fifo } &amp;lt;= 3&#39;h7;
	else
		{ o_reset, sync_fifo } &amp;lt;= { sync_fifo, 1&#39;b0 };&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;So how does this work?  As shown in Fig 1 above, anytime &lt;code class=&quot;highlighter-rouge&quot;&gt;i_areset_n&lt;/code&gt; goes low
(active), then we set the synchonizer and the output reset registers to all
ones.  Otherwise, if &lt;code class=&quot;highlighter-rouge&quot;&gt;i_areset_n&lt;/code&gt; is high (inactive), then on the positive
edge of the clock we’ll shift a zero into and through the the &lt;code class=&quot;highlighter-rouge&quot;&gt;sync_fifo&lt;/code&gt;
shift register until it clears the &lt;code class=&quot;highlighter-rouge&quot;&gt;o_reset&lt;/code&gt; output.&lt;/p&gt;

&lt;p&gt;That’s it.  There’s really not that much more to it.&lt;/p&gt;

&lt;p&gt;That is, there’s nothing more involved unless you want to
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formally verify&lt;/a&gt;
that this operation works as advertised.  Hence, let’s look at
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formally verifying&lt;/a&gt;
this reset logic in the next section.&lt;/p&gt;

&lt;h2 id=&quot;formal-properties&quot;&gt;Formal Properties&lt;/h2&gt;

&lt;p&gt;When it comes to
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal properties&lt;/a&gt;,
I’ve &lt;a href=&quot;/zipcpu/2018/03/21/dblfetch.html&quot;&gt;recently started including
“contracts”&lt;/a&gt; into the
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal properties&lt;/a&gt;
I write.  I’ve found it valuable to clearly indicate what the minimum
you want something to do is.  Let’s do that here.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;`ifdef	FORMAL
	////////////////////////////////////////////////////
	//
	// Our &quot;contract&quot;
	//
	////////////////////////////////////////////////////
	//&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;In this case, I can think of four basic properties that are relevant.&lt;/p&gt;

&lt;p&gt;The first is our one assumption that we always start in a reset state.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	initial	assume(!i_areset_n);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Our next property is that any time &lt;code class=&quot;highlighter-rouge&quot;&gt;i_areset_n&lt;/code&gt; is low (active) our outgoing
reset value &lt;code class=&quot;highlighter-rouge&quot;&gt;o_reset&lt;/code&gt; must be high (active).&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(*)
	if (!i_areset_n)
		assert(o_reset);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;At this point I can hear someone asking, doesn’t that make this an
asynchronous reset as well?&lt;/p&gt;

&lt;p&gt;Yes, technically it does.  However, &lt;code class=&quot;highlighter-rouge&quot;&gt;o_reset&lt;/code&gt; is guaranteed to also be high
for at least one clock before it is released, so we can (usually) just treat
it as a regular synchronous logic reset as well.  There is a risk
that this reset will send some
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flip-flop_(electronics)&quot;&gt;flip-flops&lt;/a&gt;
into a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Metastability_in_electronics&quot;&gt;metastable&lt;/a&gt; state
for one clock cycle.
While this is a possibility when using &lt;code class=&quot;highlighter-rouge&quot;&gt;o_reset&lt;/code&gt;, those
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flip-flop_(electronics)&quot;&gt;flip-flops&lt;/a&gt;
will be reset in the next clock interval.  If this is not acceptable
for your logic, then just treat &lt;code class=&quot;highlighter-rouge&quot;&gt;o_reset&lt;/code&gt; as an asynchronous reset.&lt;/p&gt;

&lt;p&gt;The third part of our contract is that we only ever leave the reset state
on the positive edge of any clock.  This property is a little less intuitive
to express as an &lt;code class=&quot;highlighter-rouge&quot;&gt;assert&lt;/code&gt;ion.  Specifically, we want to assert that any
time &lt;code class=&quot;highlighter-rouge&quot;&gt;o_reset&lt;/code&gt; transitions from &lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt; to &lt;code class=&quot;highlighter-rouge&quot;&gt;0&lt;/code&gt;, i.e. any time it &lt;em&gt;falls&lt;/em&gt;,
that the clock is also transitioning from &lt;code class=&quot;highlighter-rouge&quot;&gt;0&lt;/code&gt; to &lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt; (&lt;em&gt;rising&lt;/em&gt;).&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @($global_clock)
	if ($fell(o_reset))
		assert($rose(i_clk));&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;As one last part of our
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal proof&lt;/a&gt;,
let’s &lt;code class=&quot;highlighter-rouge&quot;&gt;cover()&lt;/code&gt; the release from reset to make certain this design will
release from reset like we expect it to.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(*)
		cover(!o_reset);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;At this point, if we only wanted to pass a bounded model check we’d be done.
If you instead want to &lt;em&gt;prove&lt;/em&gt; that this asynchronous reset works, then you’ll
&lt;a href=&quot;/blog/2018/03/10/induction-exercise.html&quot;&gt;need to create some more
formal properties&lt;/a&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	////////////////////////////////////////////////////
	//
	// Extras for passing induction
	//
	////////////////////////////////////////////////////&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;These extra properties are primarily used to make certain that the &lt;a href=&quot;/blog/2018/03/10/induction-exercise.html&quot;&gt;induction
engine doesn’t find the design in an unreachable
state&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;For the first of these properties, we’ll assert that any time the design
is not in a reset condition, then the &lt;code class=&quot;highlighter-rouge&quot;&gt;sync_fifo&lt;/code&gt; shift register bits should
be zero as well.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(*)
	if (!o_reset)
		assert(sync_fifo == 2&#39;b00);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;In a similar fashion, the &lt;code class=&quot;highlighter-rouge&quot;&gt;sync_fifo&lt;/code&gt; should &lt;em&gt;never&lt;/em&gt; be able to get into
a state where the bits are &lt;code class=&quot;highlighter-rouge&quot;&gt;2&#39;b01&lt;/code&gt;.  This property is necessary
to keep the &lt;a href=&quot;/blog/2018/03/10/induction-exercise.html&quot;&gt;induction stage from starting in this unreachable
state&lt;/a&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(*)
		assert(sync_fifo != 2&#39;b01);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Likewise, any time &lt;code class=&quot;highlighter-rouge&quot;&gt;sync_fifo[1]&lt;/code&gt; is &lt;em&gt;true&lt;/em&gt;, then &lt;code class=&quot;highlighter-rouge&quot;&gt;o_reset&lt;/code&gt; should be active.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(*)
	if (sync_fifo[1])
		assert(o_reset);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Finally, any time &lt;code class=&quot;highlighter-rouge&quot;&gt;i_areset_n&lt;/code&gt; is active (low), we’ll want to make certain
that &lt;code class=&quot;highlighter-rouge&quot;&gt;sync_fifo&lt;/code&gt; is in its full reset state as &lt;code class=&quot;highlighter-rouge&quot;&gt;2&#39;b11&lt;/code&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(*)
	if (!i_areset_n)
		assert(sync_fifo == 2&#39;b11);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;All four of these criteria are necessary to make certain that the design
passes induction.&lt;/p&gt;

&lt;p&gt;That also ends the
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal properties&lt;/a&gt;
of our asynchronous reset module.&lt;/p&gt;

&lt;h2 id=&quot;symbiyosys&quot;&gt;SymbiYosys&lt;/h2&gt;

&lt;p&gt;If you want to prove this design using
&lt;a href=&quot;https://symbiyosys.readthedocs.io/en/latest&quot;&gt;SymbiYosys&lt;/a&gt;,
you’ll need to put a
&lt;a href=&quot;https://symbiyosys.readthedocs.io/en/latest&quot;&gt;SymbiYosys&lt;/a&gt;
script together to do so.  Let’s take a quick moment to build this
&lt;a href=&quot;/examples/areset.sby&quot;&gt;script&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;We’ve discussed
&lt;a href=&quot;https://symbiyosys.readthedocs.io/en/latest&quot;&gt;SymbiYosys&lt;/a&gt;
scripts a little on the blog, although we haven’t discussed
&lt;a href=&quot;https://symbiyosys.readthedocs.io/en/latest&quot;&gt;SymbiYosys&lt;/a&gt;
&lt;em&gt;tasks&lt;/em&gt; much.  For this design, we’ll use a
&lt;a href=&quot;https://symbiyosys.readthedocs.io/en/latest&quot;&gt;SymbiYosys&lt;/a&gt;
task so that we can have
&lt;a href=&quot;https://symbiyosys.readthedocs.io/en/latest&quot;&gt;SymbiYosys&lt;/a&gt;
handle both &lt;em&gt;prove&lt;/em&gt;ing that our design works, as well as the &lt;em&gt;cover&lt;/em&gt; property
above.&lt;/p&gt;

&lt;p&gt;A &lt;a href=&quot;https://symbiyosys.readthedocs.io/en/latest&quot;&gt;SymbiYosys&lt;/a&gt;
&lt;a href=&quot;/examples/areset.sby&quot;&gt;script&lt;/a&gt;
with tasks in it starts with a &lt;code class=&quot;highlighter-rouge&quot;&gt;[tasks]&lt;/code&gt; section declaring the names
of the various tasks.  In our case, we’ll declare a &lt;code class=&quot;highlighter-rouge&quot;&gt;cover&lt;/code&gt; and a &lt;code class=&quot;highlighter-rouge&quot;&gt;prove&lt;/code&gt;
task.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;[tasks]
prove
cover&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The second section of the
&lt;a href=&quot;/examples/areset.sby&quot;&gt;SymbiYosys script&lt;/a&gt;
describes the options to be given to the formal solver.  The &lt;code class=&quot;highlighter-rouge&quot;&gt;mode&lt;/code&gt; option
selects what mode we wish to run the solvers in.  For the &lt;code class=&quot;highlighter-rouge&quot;&gt;prove&lt;/code&gt; task, we’ll
run in &lt;code class=&quot;highlighter-rouge&quot;&gt;prove&lt;/code&gt; mode.  This will apply both a bounded model check as well as
the &lt;em&gt;k&lt;/em&gt;-induction pass.  Passing this task will &lt;em&gt;prove&lt;/em&gt; that the safety
properties hold.  This applies to all of the &lt;code class=&quot;highlighter-rouge&quot;&gt;assume&lt;/code&gt;s and &lt;code class=&quot;highlighter-rouge&quot;&gt;assert&lt;/code&gt;s above.
The second mode, used by our
second task, is the &lt;code class=&quot;highlighter-rouge&quot;&gt;cover&lt;/code&gt; mode.  We’ll use this to make certain our
&lt;code class=&quot;highlighter-rouge&quot;&gt;cover&lt;/code&gt; statement is reached.  The final option, &lt;code class=&quot;highlighter-rouge&quot;&gt;multiclock on&lt;/code&gt;, applies
to both tasks.  This option tells
&lt;a href=&quot;https://symbiyosys.readthedocs.io/en/latest&quot;&gt;SymbiYosys&lt;/a&gt;
that we’ll be using the asynchronous or multiple clock capabilities of the
formal solvers.&lt;/p&gt;

&lt;p&gt;For those who have been following
&lt;a href=&quot;https://symbiyosys.readthedocs.io/en/latest&quot;&gt;SymbiYosys&lt;/a&gt;
development, this option replaces the &lt;code class=&quot;highlighter-rouge&quot;&gt;clk2fflogic&lt;/code&gt;
&lt;a href=&quot;http://www.clifford.at/yosys/&quot;&gt;yosys&lt;/a&gt;
option.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;[options]
prove: mode prove
cover: mode cover
multiclock on&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The third section is the &lt;code class=&quot;highlighter-rouge&quot;&gt;[engines]&lt;/code&gt; section.  This particular design doesn’t
really need any particular engine.  We’ll pick
&lt;a href=&quot;http://yices.csl.sri.com&quot;&gt;yices&lt;/a&gt;
therefore, since it is a good general purpose engine.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;[engines]
smtbmc yices&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Alternatively, we might have just stated &lt;code class=&quot;highlighter-rouge&quot;&gt;smtbmc&lt;/code&gt; without naming the
&lt;a href=&quot;http://yices.csl.sri.com&quot;&gt;yices&lt;/a&gt;
engine, since
&lt;a href=&quot;http://yices.csl.sri.com&quot;&gt;yices&lt;/a&gt; is the default engine anyway.&lt;/p&gt;

&lt;p&gt;That leaves two sections left.  The fourth section lists the commands that
&lt;a href=&quot;http://www.clifford.at/yosys/&quot;&gt;yosys&lt;/a&gt;
itself will use to prepare our design for the
&lt;a href=&quot;http://yices.csl.sri.com&quot;&gt;formal solver&lt;/a&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;[script]
read_verilog -formal areset.v
prep -top areset&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The final section lists all the files in our design–in this case, just
&lt;code class=&quot;highlighter-rouge&quot;&gt;areset.v&lt;/code&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;[files]
areset.v&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;We’re now ready to run
&lt;a href=&quot;https://symbiyosys.readthedocs.io/en/latest&quot;&gt;SymbiYosys&lt;/a&gt;!&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span class=&quot;gp&quot;&gt;&amp;gt; &lt;/span&gt;sby -f areset.sby&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;There’s really not much more to it.  That’s all that’s required to
formally verify
a simple
&lt;a href=&quot;/examples/areset.v&quot;&gt;asynchronous reset&lt;/a&gt;
design.&lt;/p&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;Proving that this &lt;a href=&quot;/examples/areset.v&quot;&gt;asynchronous reset to synchronous release
module&lt;/a&gt;
works may seem trivial, but it does demonstrate a lot of the capabilities of the
open source formal tools.  For example, did you notice that this proof applies
to &lt;em&gt;any&lt;/em&gt; clock structure?&lt;/p&gt;

&lt;p&gt;There are several other simple designs that can be proven just like this one.
Examples include a clock gate, clock switch, input or output DDR components
or even SERDES implementations.
I discuss each these projects in my Formal Verification course, before
offering them as student exercises.  &lt;a href=&quot;https://www.blueletterbible.org/kjv/jas/4/15&quot;&gt;If the Lord is
willing&lt;/a&gt;,
we’ll continue with these techniques to create and then &lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formally
verify&lt;/a&gt; an
&lt;a href=&quot;https://www.sunburst-design.com/papers/CummingsSNUG2002SJ_FIFO1.pdf&quot;&gt;asynchronous FIFO&lt;/a&gt;
as a future post.&lt;/p&gt;

&lt;hr /&gt;&lt;p&gt;&lt;em&gt;Come now, and let us reason together, saith the LORD: though your sins be as scarlet, they shall be as white as snow; though they be red like crimson, they shall be as wool.  (Is 1:18)&lt;/em&gt;</description>
        <pubDate>Thu, 12 Apr 2018 00:00:00 -0400</pubDate>
        <link>https://zipcpu.com/formal/2018/04/12/areset.html</link>
        <guid isPermaLink="true">https://zipcpu.com/formal/2018/04/12/areset.html</guid>
        
        
        <category>formal</category>
        
      </item>
    
      <item>
        <title>What would you like to see on the ZipCPU blog?</title>
        <description>&lt;p&gt;The &lt;a href=&quot;https://zipcpu.com/&quot;&gt;ZipCPU blog&lt;/a&gt; has recently picked
up a lot of readers in light of my
&lt;a href=&quot;/blog/2018/04/02/formal-cpu-bugs.html&quot;&gt;recent on-going work&lt;/a&gt;
to &lt;a href=&quot;/blog/2018/04/02/formal-cpu-bugs.html&quot;&gt;formally verify&lt;/a&gt;
the entire &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;To all of those new readers, &lt;em&gt;Welcome!&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;The &lt;a href=&quot;https://zipcpu.com/&quot;&gt;ZipCPU blog&lt;/a&gt; is dedicated to helping
FPGA designers avoid getting stuck in
&lt;a href=&quot;/blog/2017/05/19/fpga-hell.html&quot;&gt;FPGA Hell&lt;/a&gt;–a place where
&lt;a href=&quot;/blog/2017/09/14/even-i-get-stuck.html&quot;&gt;your design doesn’t work and you can’t figure out why
not&lt;/a&gt;.  To this end,
I’ve presented techniques for &lt;a href=&quot;/blog/2017/06/21/looking-at-verilator.html&quot;&gt;simulating your design using
Verilator&lt;/a&gt;,
&lt;a href=&quot;https://github.com/ZipCPU/dbgbus/blob/master/hexbus/README.md&quot;&gt;how to build a debugging
bus&lt;/a&gt; for
command, control, and internal register and state inspection, &lt;a href=&quot;/blog/2017/06/08/simple-scope.html&quot;&gt;how to build
your own internal logic
analyzer&lt;/a&gt;,
&lt;a href=&quot;/blog/2017/07/08/getting-started-with-wbscope.html&quot;&gt;how to use my own wishbone
scope&lt;/a&gt;,
&lt;a href=&quot;/blog/2017/07/31/vcd.html&quot;&gt;how the VCD file format expresses your logic
trace&lt;/a&gt;,
&lt;a href=&quot;/dsp/2017/07/24/dsp-debugging.html&quot;&gt;how to debug a DSP
algorithm&lt;/a&gt;,
&lt;a href=&quot;/blog/2017/06/17/why-network-debugging.html&quot;&gt;network debugging&lt;/a&gt;,
and more.&lt;/p&gt;

&lt;p&gt;Recently I’ve started learning about &lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal
verification&lt;/a&gt;,
and so I’ve added &lt;a href=&quot;/formal/formal.html&quot;&gt;that
topic&lt;/a&gt;
to my list as well.  As a result there have now been
&lt;a href=&quot;/formal/formal.html&quot;&gt;several articles&lt;/a&gt;
on how to &lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formally
verify&lt;/a&gt;
your logic as and after you have put it together, and &lt;a href=&quot;/blog/2018/03/14/is-formal-hard.html&quot;&gt;the value of formal
verification&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;What you as a reader need to know, however, is that these articles are
&lt;a href=&quot;https://www.patreon.com/ZipCPU&quot;&gt;sponsor supported&lt;/a&gt;.  If you find this blog
valuable, and would like to see it continue, then please consider becoming
one of my &lt;a href=&quot;https://www.patreon.com/ZipCPU&quot;&gt;Patreon Sponsors&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;One of the perks of being a
&lt;a href=&quot;https://www.patreon.com/ZipCPU&quot;&gt;sponsor&lt;/a&gt;
is that I am responsive to the topics my
&lt;a href=&quot;https://www.patreon.com/ZipCPU&quot;&gt;sponsors&lt;/a&gt;
are interested in.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.patreon.com/ZipCPU&quot;&gt;sponsors&lt;/a&gt;.
So, here’s a short list of some of the upcoming topics which I think would be
fun to post about.  If you are one of my
&lt;a href=&quot;https://www.patreon.com/ZipCPU&quot;&gt;sponsors&lt;/a&gt;,
then please consider yourself invited to contact me and let me know
which of these (or other) topics you might be interested in.  There
is also a more complete list of both past and upcoming topics in the site
&lt;a href=&quot;/topics.html&quot;&gt;topics&lt;/a&gt; list as well.&lt;/p&gt;

&lt;p&gt;So, without further delay, here are some of the topics I am considering
writing about in the near future, should &lt;a href=&quot;https://www.blueletterbible.org/kjv/jas/4/15&quot;&gt;the Lord be
willing&lt;/a&gt;:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;ZBasic ZipCPU Peripheral&lt;/strong&gt;: Some time ago, I promised I was going to
discuss how easy it was to add a peripheral to the
&lt;a href=&quot;https://github.com/ZipCPU/zbasic&quot;&gt;ZBasic&lt;/a&gt;
using &lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt;.
I am still fully intending to do this, although I am somewhat struggling to
decide what that example peripheral should be–there are just too many
&lt;a href=&quot;https://github.com/ZipCPU?tab=repositories&quot;&gt;possibilities&lt;/a&gt;.  Feel free
to make a suggestion if you would like.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Quadratic Sinewave generation&lt;/strong&gt;: &lt;a href=&quot;/dsp/2017/08/30/cordic.html&quot;&gt;CORDIC sinewave
generation&lt;/a&gt; is really cool,
but it can also be logically expensive within an FPGA.
A potentially cheaper algorithm, requiring only two multiplies, would be to
apply our &lt;a href=&quot;/dsp/2018/03/30/quadratic.html&quot;&gt;quadratic interpolation
techniques&lt;/a&gt;
to generating a cleaner sine wave.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Asynchronous FIFO&lt;/strong&gt;: I have a nice formal proof of &lt;a href=&quot;http://www.sunburst-design.com/papers/CummingsSNUG2002SJ_FIFO1.pdf&quot;&gt;Cliff Cummings’
asynchronous FIFO
design&lt;/a&gt;
that I think would be valuable to present as well.  Unlike many of &lt;a href=&quot;/formal/formal.html&quot;&gt;my other
formal articles&lt;/a&gt;, this one requires
a formal solution across more than one clock domain, and for arbitrary
clock speeds.  This will add to the interest and value of it.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Ethernet CRC&lt;/strong&gt;: When I recently built a Ethernet CRC module for the 1Gb
Ethernet port of the &lt;a href=&quot;https://store.digilentinc.com/nexys-video-artix-7-fpga-trainer-board-for-multimedia-applications&quot;&gt;Nexys Video
board&lt;/a&gt;,
I was surprised at how much formal methods could help simplify
the complicated math of a multi-stepping CRC generator.  This would
therefore be a fun topic to share, as there is a lot of practical
information within it.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Dual I/O SPI flash&lt;/strong&gt;: While I am personally quite biased towards a &lt;a href=&quot;http://opencores.org/project,qspiflash&quot;&gt;Quad
SPI flash implementation&lt;/a&gt;,
recent events have led me to need to build a
&lt;em&gt;Dual I/O SPI flash&lt;/em&gt; implementation for a couple of logic challenged
implementations.  This means that this controller should be simple enough to
both present and understand, and makes a nice blog topic&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;TinyFPGA&lt;/strong&gt;: I’m also building a &lt;a href=&quot;https://github.com/ZipCPU/tinyzip&quot;&gt;TinyFPGA BX
design&lt;/a&gt; using the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;, and would love to blog about
this design.  Yes, the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; does
fit nicely on that board with room to spare (when &lt;a href=&quot;https://github.com/ZipCPU/tinyzip/blob/master/rtl/cpu/cpudefs.v&quot;&gt;properly
trimmed&lt;/a&gt;),
however my &lt;a href=&quot;https://github.com/ZipCPU/s6soc/blob/master/rtl/qflashxpress.v&quot;&gt;minimal flash
controller&lt;/a&gt;
needed to be redesigned, and my C++ &lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/sim/verilated/qspiflashsim.cpp&quot;&gt;flash
simulator&lt;/a&gt;
needed to be adjusted to get this to work.  Once I’ve finished verifying
that I can program and run the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
on this board, then it would be fun to describe my experiences.  Because of
the dependence upon the flash controller, however, this post would follow the
discussion of the &lt;strong&gt;Dual I/O SPI flash&lt;/strong&gt; design.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Some Simple Formal Verification Proofs&lt;/strong&gt;: It might be nice to return to our
(event) &lt;a href=&quot;/blog/2017/06/02/generating-timing.html&quot;&gt;timing control solutions
post&lt;/a&gt;,
and take a new look at them in light of &lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal
verification&lt;/a&gt;.
For example, how would you verify that a timer provides you with the right
number of clock ticks, or how would you speed up an otherwise exceptionally
long proof.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Prefetch with Cache&lt;/strong&gt;: The
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; has a 1-way instruction
cache that would be fun to present, and would also conclude our discussion
of prefetch methods.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Data Movement&lt;/strong&gt;: One of the sad realities of FPGA work is that its not all
about data transformation.  There’s a lot to be done in data movement as well.&lt;/p&gt;

    &lt;p&gt;The &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZiPCPU&lt;/a&gt; contains a
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/wbdmac.v&quot;&gt;DMA controller&lt;/a&gt;
that can be set up to automatically move data from one place to another within
any &lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;wishbone based
design&lt;/a&gt;.  &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/wbdmac.v&quot;&gt;This
component&lt;/a&gt;,
and its formal properties would be useful to many of my readers.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Abstraction in Formal Verification&lt;/strong&gt;: The recent
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
&lt;a href=&quot;/blog/2018/04/02/formal-cpu-bugs.html&quot;&gt;verification work&lt;/a&gt;
depends heavily on formal verification concepts of abstraction and
invariance.  Both techniques are useful when trying to break a complicated
design, such as a full CPU, down into its subcomponents.&lt;/p&gt;

    &lt;p&gt;This article would present abstraction.  In short, abstraction is based upon
the statement that if &lt;code class=&quot;highlighter-rouge&quot;&gt;A&lt;/code&gt; implies &lt;code class=&quot;highlighter-rouge&quot;&gt;B&lt;/code&gt;, then &lt;code class=&quot;highlighter-rouge&quot;&gt;A&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;C&lt;/code&gt; must also imply
&lt;code class=&quot;highlighter-rouge&quot;&gt;B&lt;/code&gt;.  The figures and outline of this lesson would be taken from the
formal verification course I’ve put together for
&lt;a href=&quot;https://www.symbioticeda.com&quot;&gt;Symbiotic EDA&lt;/a&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Invariance in Formal Verification&lt;/strong&gt;: Invariance is a second very powerful
tool that can be used to simplify the formal prove of a component.  Put
simply, if you can prove the &lt;code class=&quot;highlighter-rouge&quot;&gt;A&lt;/code&gt; is true, you no longer need to prove &lt;code class=&quot;highlighter-rouge&quot;&gt;A&lt;/code&gt;
anymore.  The difference over what can, and cannot, be proven using this
technique can be drastic.&lt;/p&gt;

    &lt;p&gt;The figures and outline of this lesson would also be taken from the
formal verification course I’ve put together for
&lt;a href=&quot;https://www.symbioticeda.com&quot;&gt;Symbiotic EDA&lt;/a&gt;, as with the potential
abstraction course discussed above.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;More filtering&lt;/strong&gt;: We left our discussion of filtering incomplete, and
so I’d still like to come back to demonstrate both symmetric and halfband
filters.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Dhrystone&lt;/strong&gt;: Also on my list of items to discuss is Dhrystone, the
outdated-yet-still-useful CPU bench mark.  For all of you who are
interested in comparing your CPU’s performance against Dhrystone, this
article would take a quick look at how Dhrystone can be run within a
Verilator simulation, and how I’ve gone about interpreting the results.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Synchronization&lt;/strong&gt;: One common problem in &lt;a href=&quot;/dsp/dsp.html&quot;&gt;digital signal
processing&lt;/a&gt; is the
“two-clock” problem where data comes into the algorithm on one clock, and
yet needs to be output on the edges of an unrelated clock.  Now that we’ve
spent some time with
&lt;a href=&quot;/dsp/2018/03/30/quadratic.html&quot;&gt;interpolation&lt;/a&gt;, as well as
&lt;a href=&quot;/dsp/2017/12/14/logic-pll.html&quot;&gt;how to build a simple PLL
module&lt;/a&gt;, it only makes
sense that we would connect these two concepts to be able to synchronize
two data streams.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Generating an Arbitrary Clock Signal&lt;/strong&gt;: I also have a simple design
component that can be used to generate a clock signal at an arbitrary
frequency, without requiring any additional clock chips.  (The FPGA still
needs its input clock.)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Building a HyperRAM controller&lt;/strong&gt;:
&lt;a href=&quot;http://www.cypress.com/products/hyperram-memory&quot;&gt;HyperRAM&lt;/a&gt; is a powerful
RAM communication protocol.  Unlike
DDR3 SDRAM, building a controller for
&lt;a href=&quot;http://www.cypress.com/products/hyperram-memory&quot;&gt;HyperRAM&lt;/a&gt;
doesn’t require undocumented chip features.  This article would discuss
such a controller, both how to build it as well as how to formally verify
that it works.&lt;/p&gt;

    &lt;p&gt;If there’s enough demand, a separate article could discuss how to build a
simulation component for this device.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;If you’ve made it this far, let share this with you: I’m creating today
a &lt;a href=&quot;/formal/formal.html&quot;&gt;formal page&lt;/a&gt; which will capture
all of my formal verification posts.  This should make it easier for someone
who is only interested in &lt;a href=&quot;/formal/formal.html&quot;&gt;formal
verification&lt;/a&gt; to find articles that
discuss or provide examples of &lt;a href=&quot;/formal/formal.html&quot;&gt;formal
verification&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/formal/formal.html&quot;&gt;This new topical page&lt;/a&gt;
joins my prior &lt;a href=&quot;/dsp/dsp.html&quot;&gt;DSP topical page&lt;/a&gt;.  However,
&lt;em&gt;all&lt;/em&gt; articles will remain on the blog’s main page.&lt;/p&gt;

&lt;p&gt;Finally, if you are one of my
&lt;a href=&quot;https://www.patreon.com/ZipCPU&quot;&gt;Patreon sponsors&lt;/a&gt;,
please feel free to contact me at the e-mail address below and let me know
which, if any, of these topics you might be interested in.  Even better,
these are only suggestions.  If you are interested in a topic that isn’t
listed above, please feel free to share that topic with me as well.  Just please
be aware that topics not on this list, such as creating a GCC port, might
take a bit longer to work up to.&lt;/p&gt;

&lt;p&gt;If you are not one of my
&lt;a href=&quot;https://www.patreon.com/ZipCPU&quot;&gt;Patreon sponsors&lt;/a&gt;,
and yet you find this
&lt;a href=&quot;https://zipcpu.com/&quot;&gt;blog valuable&lt;/a&gt;, please consider joining
the team!  While I have no intention of restricting
&lt;a href=&quot;https://zipcpu.com/&quot;&gt;the blog&lt;/a&gt;’s content to subscribers only,
your support will help
&lt;a href=&quot;https://zipcpu.com/&quot;&gt;this blog&lt;/a&gt; continue into the future.&lt;/p&gt;
&lt;hr /&gt;&lt;p&gt;&lt;em&gt;The husbandman that laboureth must be first partaker of the fruits. (2Tim 2:6)&lt;/em&gt;</description>
        <pubDate>Thu, 05 Apr 2018 00:00:00 -0400</pubDate>
        <link>https://zipcpu.com/blog/2018/04/05/topatreon.html</link>
        <guid isPermaLink="true">https://zipcpu.com/blog/2018/04/05/topatreon.html</guid>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>Will formal methods ever find a bug in a working CPU?</title>
        <description>&lt;p&gt;Today, I’m starting what will likely be the slow process of
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formally verifying&lt;/a&gt;
the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;.  I’m going to use
&lt;a href=&quot;http://www.clifford.at/yosys&quot;&gt;yosys&lt;/a&gt; for this process initially, but given
&lt;a href=&quot;https://symbiyosys.readthedocs.io/en/latest&quot;&gt;SymbiYosys&lt;/a&gt;’s ability to
run multiple formal configurations as separate tasks, I will probably need to
switch after I get some distance along.&lt;/p&gt;

&lt;p&gt;At this point in the game, I’ve already &lt;a href=&quot;/blog/2018/01/22/formal-progress.html&quot;&gt;formally proven all of the
components&lt;/a&gt;
of the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;.
What remains is to prove the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU itself&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;So here’s my question: How many bugs would you expect to find in a “working”
soft-core CPU?  One?  Ten?  Twenty?  One hundred?  Shall we count?  I propose
keeping a running log of the bugs I find in the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; while using
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formally methods&lt;/a&gt;.
Perhaps this log will help to convince you the value of
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formally methods&lt;/a&gt;,
perhaps not.  Either way, I’ll keep it accurate to the information I discover.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;The memory manager refused to release the bus if the response came back
on the same cycle.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Certain errors should cause the CPU to halt–such as encountering a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_(computing)&quot;&gt;bus&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_error&quot;&gt;error&lt;/a&gt;
when reading from instruction memory.  Due to a (now locally fixed) bug
in the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;, these errors
would not cause the CPU to halt if they were one of the first couple
instructions.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; is designed so that
memory reads or writes &lt;em&gt;never&lt;/em&gt; need to be rolled back. This is to
facilitate using the memory bus for reading and
writing peripherals, such as the serial port.  Reads from such peripherals
have side effects that cannot be rolled back.  The formal methods however,
discovered an example where reading into the program counter, such as during
an indirect jump, my cause a following memory instruction to need to be
rolled back.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;’s current approach to
the compressed instruction set (CIS)
is to prevent the CPU from interrupting in the middle of a CIS instruction.
Formal methods, however, found an internal accounting bug which prevented
this logic from working properly.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Several bugs have been found in the debug infrastructure, allowing an
external debugger to change registers internal to the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;.&lt;/p&gt;

    &lt;p&gt;In one example, this was violating the rules the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; uses when issuing
pipelined memory instructions.&lt;/p&gt;

    &lt;p&gt;In another example, during a divide that was to write its results into &lt;code class=&quot;highlighter-rouge&quot;&gt;R0&lt;/code&gt;,
the external debug infrastructure was allowed to write to a register,
say &lt;code class=&quot;highlighter-rouge&quot;&gt;R1&lt;/code&gt;.  This would cause the divide to write its results into &lt;code class=&quot;highlighter-rouge&quot;&gt;R1&lt;/code&gt; upon
completion, rather than &lt;code class=&quot;highlighter-rouge&quot;&gt;R0&lt;/code&gt;.&lt;/p&gt;

    &lt;p&gt;The &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; has
therefore been adjusted so that the debug infrastructure
can only modify the value of a register if the CPU has been fully halted.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The flag indicating that the CPU is fully halted was not properly
implemented.  Specifically, the CPU might declare it was halted in the middle
of a CIS instruction when the second half of the instruction still needed
to be flushed through the pipeline.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;On a multi-cycle ALU operation (i.e. one of the multiplies), the flags
were being set before the operation was complete&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The clock-less version of the instruction decoder, used by the formal
properties alone to know what to expect from an instruction, didn’t match
the actual instruction decoder when it came to whether or not SIM
instructions should cause an illegal interrupt exception&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The divide wouldn’t wait for a multiply to complete before starting.  Such
a multiply might have provided the divide with its operand, but due to this
bug the divide input would’ve been the prior value of the register.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Under certain circumstances in the pipeline, the break instruction would
get bypassed.&lt;/p&gt;

    &lt;p&gt;I’m actually looking forward to simplifying this break logic by merging it
with the illegal instruction logic, since the two do the same thing in
different ways.  I’m holding off on this for now, however.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Writes to the user PC register, such as by the debug port or even the ALU,
   while in supervisor (not user) mode, would corrupt any logic depending
   upon the user PC register that was already in the pipeline.  Hence, the
   pipeline needs to be cleared following any such write.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;After making several fixes, the memory instruction following an illegal
instruction would be issued.  This error isn’t so much a bug in the working
CPU, but rather a bug in my pipeline logic rewrite.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Perhaps this would never happen.  However, the memory controller wouldn’t
stall when it ran out of internal memory to keep track of where the
write back results would be written to.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;On an early branch or an illegal instruction, the valid memory instruction
flag was still being set, eventually violating the contract with the memory
device.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The switch to interrupt flag wasn’t waiting for any ongoing memory
operations to complete first&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;On a divide error, the memory unit would still issue an instruction.
This creates a problem because a memory operation to a peripheral device
cannot be withdrawn, as the CPU tries to switch to its exception handling
code.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Under certain circumstances, the CPU would continue issuing instructions
following a bus error or division by zero error.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;At this point, I’m going to stop counting.  It’s not because there are so
many errors remaining, but rather because its no longer clear which of the
remaining errors were originally
in the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
and which ones were added while trying to fix the earlier bugs.&lt;/p&gt;

&lt;h2 id=&quot;bugs-in-the-formal-properties&quot;&gt;Bugs in the Formal Properties&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;The formal properties within the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;core&lt;/a&gt;,
as well as the abstracted components, are still quite immature.
Multiple bugs are still being found within them.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/ex/wbdblpriarb.v&quot;&gt;Wishbone
arbiter&lt;/a&gt;
had a careless assumption within it.  This prevented the arbiter from ever
being fully tested and verified.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
recognizes two memory regions: a local region for CPU-specific
peripherals from &lt;code class=&quot;highlighter-rouge&quot;&gt;0xff000000&lt;/code&gt; to &lt;code class=&quot;highlighter-rouge&quot;&gt;0xffffffff&lt;/code&gt; (used by the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/zipsystem.v&quot;&gt;ZipSystem&lt;/a&gt;,
and a more global memory
region (everything else).  Crossing regions within the same memory operation
is a fault that needs to be prevented in software, and the formal
properties for describing this fault were &lt;code class=&quot;highlighter-rouge&quot;&gt;assert()&lt;/code&gt; functions rather than
&lt;code class=&quot;highlighter-rouge&quot;&gt;restrict()&lt;/code&gt; functions.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;current-status&quot;&gt;Current status&lt;/h2&gt;

&lt;p&gt;I’m currently fully verifying the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;’s
capability using an &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/dev/bench/formal/abs_prefetch.v&quot;&gt;abstract
prefetch&lt;/a&gt;,
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/dev/bench/formal/abs_div.v&quot;&gt;abstract
divide&lt;/a&gt;,
and an &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/dev/bench/formal/abs_mpy.v&quot;&gt;abstract
multiply&lt;/a&gt;.
Thanks to SymbiYosys and “abc pdr”, the pipeline properties I’ve now verified
constitutes a full formal proof (BMC + induction) of the first set of
formal properties for the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;.
A second stage of properties have since been added, dependent upon the
synthesizer define &lt;code class=&quot;highlighter-rouge&quot;&gt;PHASE_ONE&lt;/code&gt;. The proof of this second set of properties
remains ongoing.&lt;/p&gt;

&lt;p&gt;First, the formal properties:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;I’ve proven that the assumptions within all of the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;’s
sub-modules hold.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;I’ve manage to verify that the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;’s
pipeline logic won’t accidentally “delete” an instruction in the pipeline.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;I’ve also added the properties that the operands given to the
ALU, memory, or divide unit, need to be valid.&lt;/p&gt;

    &lt;p&gt;This portion of the proof is ongoing.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Following any ALU or divide instruction, only the correct register will
ever be written if at all–I haven’t dealt with predicates yet.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;BREAK&lt;/code&gt; instructions never pass the OP stage as desired.  This makes certain
these instructions will not increment the PC when encountered.  This is
very similar to an illegal operand instruction, and the logic for these
may yet be merged.  For now, the &lt;code class=&quot;highlighter-rouge&quot;&gt;BREAK&lt;/code&gt; instruction bypasses the ALU
stage of the CPU as desired.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;I haven’t gotten to the cover properties yet, those are yet to come.  As a
result, I may have carelessly assumed away a portion of the proof and can’t
tell yet.&lt;/p&gt;

&lt;p&gt;Here’s how far I’ve gotten:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Without pipelining the memory bus, the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; made it for a full 40 clocks
in a bounded model check.  This was the extent of the test.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;With the pipelined memory bus, the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; has formally passed
&lt;em&gt;all of the formal properties&lt;/em&gt; now written for it&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The updated formal code is currently in a git repository branch that hasn’t
(yet) been pushed.  Upon request I have pushed components of this
proof into the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/tree/dev&quot;&gt;dev branc&lt;/a&gt;,
although I’d still be a bit embarrassed to present the (not quite working)
CPU yet.  This includes the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/dev/bench/formal/abs_mpy.v&quot;&gt;abstract
multiply&lt;/a&gt;
mentioned above, as well as the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/dev/rtl/core/mpyop.v&quot;&gt;multiply
module&lt;/a&gt; that it
replaces.&lt;/p&gt;

    &lt;p&gt;My apologies to all that have indicated an interest in seeing this code.
Thank you for your interest.  I guess it surprised me a bit.
I’m just not quite ready yet to post the code–mostly because things aren’t
fully working.  I do anticipate fully sharing this code in due time.  If
you are really interested in seeing this before it is complete, then
please send me an e-mail and I will consider placing it on
&lt;a href=&quot;https://gitlab.com&quot;&gt;gitlab&lt;/a&gt; where
&lt;a href=&quot;https://www.patreon.com/ZipCPU&quot;&gt;sponsors&lt;/a&gt; can have access to the current
work in progress.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;You can find my work in the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/tree/dev&quot;&gt;dev branch&lt;/a&gt;
of the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;github repository&lt;/a&gt;
for the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;.  Specifically,
you can find the properties that I’m working with at the bottom of the core
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/dev/rtl/core/zipcpu.v&quot;&gt;zipcpu.v&lt;/a&gt;
Verilog file.  I’m using a &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/dev/bench/formal/Makefile&quot;&gt;“make”
file&lt;/a&gt; within
the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/tree/dev/bench/formal&quot;&gt;bench/formal&lt;/a&gt;
directory to control the process.&lt;/p&gt;
&lt;hr /&gt;&lt;p&gt;&lt;em&gt;Again, when the wicked man turneth away from his wickedness that he hath committed, and doeth that which is lawful and right, he shall save his soul alive.  (Ezek 18:27)&lt;/em&gt;</description>
        <pubDate>Mon, 02 Apr 2018 00:00:00 -0400</pubDate>
        <link>https://zipcpu.com/blog/2018/04/02/formal-cpu-bugs.html</link>
        <guid isPermaLink="true">https://zipcpu.com/blog/2018/04/02/formal-cpu-bugs.html</guid>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>Resurrection Day!</title>
        <description>&lt;p&gt;Buddha &lt;a href=&quot;https://en.wikipedia.org/wiki/Gautama_Buddha#Relics&quot;&gt;is dead&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Mohammed &lt;a href=&quot;https://en.wikipedia.org/wiki/Muhammad#Death_and_tomb&quot;&gt;is dead&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.blueletterbible.org/kjv/deu/34/1&quot;&gt;Moses died&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.blueletterbible.org/kjv/mat/27/50&quot;&gt;Jesus died&lt;/a&gt; as well, but unlike
these others &lt;a href=&quot;https://www.blueletterbible.org/kjv/mat/28/7&quot;&gt;He is dead no more&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;This simple fact &lt;a href=&quot;https://www.blueletterbible.org/kjv/act/17/31&quot;&gt;makes Christianity
different&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Today, we celebrate this difference.&lt;/p&gt;

&lt;h2 id=&quot;what-makes-jesus-special&quot;&gt;What makes Jesus special?&lt;/h2&gt;

&lt;p&gt;Jesus knew He was going to die.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;And as Moses lifted up the serpent in the wilderness
[&lt;a href=&quot;https://www.blueletterbible.org/kjv/num/21/8&quot;&gt;Num 21:8&lt;/a&gt;],
even so must the Son of man be lifted up [i.e. crucified]: That whosoever
believeth in him should not perish, but have eternal life.
(&lt;a href=&quot;https://www.blueletterbible.org/kjv/jhn/3/14&quot;&gt;John 3:14-15&lt;/a&gt;)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;This was His purpose in coming to the earth.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Now is my soul troubled; and what shall I say?  Father, save me from this
hour: but for this cause came I unto this hour.  Father, glorify thy name.
Then came there a voice from heaven, saying, I have both glorified it, and
will glorify it again.
(&lt;a href=&quot;https://www.blueletterbible.org/kjv/jhn/12/27&quot;&gt;John 12:27-28&lt;/a&gt;)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Jesus also knew that He could raise Himself up from the grave long before
He was put to death.  This was a commandment given to Him by His Father,
the one we call God.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Therefore doth my Father love me, because I lay down my life, that I might
take it again.  No man taketh it from me, but I lay it down of myself.
I have the power to lay it down, and I have the power to take it again.
This command have I received of my Father.
(&lt;a href=&quot;https://www.blueletterbible.org/kjv/jhn/10/17&quot;&gt;John 10:17-18&lt;/a&gt;)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;The disciples were falsely accused of hiding His body.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Saying, Say ye, His disciples came by night, and stole him away while we
slept.
(&lt;a href=&quot;https://www.blueletterbible.org/kjv/mat/28/13&quot;&gt;Mat 28:13&lt;/a&gt;).&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;In spite of this lie, no one found the missing body because there was no
missing body.  Jesus is no longer dead, He is risen!&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;And as they were afraid, and bowed down their faces to the earth, they
said unto them, “Why seek ye the living among the dead?”
(&lt;a href=&quot;https://www.blueletterbible.org/kjv/luk/24/5&quot;&gt;Luke 24:5&lt;/a&gt;)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;em&gt;(By the way, I love the song by this same name which comes from the musical
&lt;a href=&quot;https://www.youtube.com/watch?v=roxCbUndmR0&quot;&gt;The Choice&lt;/a&gt; by Nate Copeland.
[&lt;a href=&quot;https://www.youtube.com/watch?v=6bM3S5fBYec&quot;&gt;1&lt;/a&gt;],
[&lt;a href=&quot;https://www.youtube.com/watch?v=wZ-qPvYQNr4&quot;&gt;2&lt;/a&gt;],
[&lt;a href=&quot;https://www.youtube.com/watch?v=c2fg_hhDN94&quot;&gt;3&lt;/a&gt;],
[&lt;a href=&quot;https://www.youtube.com/watch?v=Osbuen8WkRI&quot;&gt;4&lt;/a&gt;])&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;The resurrection, evidenced by the empty tomb, proves the validity
of the message.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Because he hath appointed a day, in the which He will judge the world in
righteousness by that Man whom he hath ordained; whereof He hath given
assurance unto all men, in that He hath raised Him from the dead.
(&lt;a href=&quot;https://www.blueletterbible.org/kjv/act/17/31&quot;&gt;Acts 17:31&lt;/a&gt;)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Without the resurrection, there is no point in Christianity.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;And if Christ be not risen, then is our preaching vain, and your faith is
vain [i.e. useless or pointless].  Yea, and we are found false witnesses of
God [i.e. liars]; because we have testified of God that He raised up Christ:
whom He raised not up, if so be that the dead rise not.&lt;/p&gt;

  &lt;p&gt;For if the dead rise not, then is Christ not raised: and if Christ be not
raised, your faith is vain; ye are yet in your sins.
Then they also which are fallen asleep in Christ are perished.&lt;/p&gt;

  &lt;p&gt;If in this life only we have hope in Christ, we are of all men most miserable.
(&lt;a href=&quot;https://www.blueletterbible.org/kjv/1co/15/14&quot;&gt;1Cor 15:14-19&lt;/a&gt;)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Indeed, were there no resurrection, then there would be no hope in living.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;If after the manner of men I have fought with beasts at Ephesus, what
advantageth it me, if the dead rise not?  Let us eat and drink; for
tomorrow we die.
(&lt;a href=&quot;https://www.blueletterbible.org/kjv/eph/15/32&quot;&gt;Eph 15:32&lt;/a&gt;)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;But there is a resurrection!  We know this from the testimony of those who
have seen him.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;This Jesus hath God raised up, whereof we all are witnesses.
(&lt;a href=&quot;https://www.blueletterbible.org/kjv/act/4/32&quot;&gt;Acts 4:32&lt;/a&gt;)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;or again,&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;For I delivered unto you first of all that which I also received, how that
Christ died for our sins according to the scriptures;
And that he was buried, and that he rose again the third day according to
the scriptures:
And that he was seen of Cephas, then of the twelve: After that, he was seen
of above five hundred brethren at once; of whom the greater part remain to
this present, but some are fallen asleep.
After that, he was seen of James; then of all the apostles.
And last of all he was seen of me also, as of one born out of due time.
(&lt;a href=&quot;https://www.blueletterbible.org/kjv/jhn/10/17&quot;&gt;1 Cor 15:3-8&lt;/a&gt;)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;We also know this by the empty tomb, proving to all that He is the Christ!&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Therefore let all the house of Israel know assuredly, that God hath made
the same Jesus, whom ye have crucified, both Lord and Christ.
(&lt;a href=&quot;https://www.blueletterbible.org/kjv/act/4/36&quot;&gt;Acts 4:36&lt;/a&gt;)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;i-serve-a-risen-savior&quot;&gt;I serve a risen Savior&lt;/h2&gt;

&lt;p&gt;Because He lives, I have been
&lt;a href=&quot;https://www.blueletterbible.org/kjv/rom/8/1&quot;&gt;freed from my own personal sins&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Because He lives, I no longer need to live a life
&lt;a href=&quot;https://www.blueletterbible.org/kjv/jhn/8/34&quot;&gt;controlled by my own wickedness&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Because He lives, &lt;a href=&quot;https://www.blueletterbible.org/kjv/jhn/10/28&quot;&gt;I have a
future&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Because He lives, &lt;a href=&quot;https://www.blueletterbible.org/kjv/col/3/23&quot;&gt;I blog&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Because He lives, &lt;a href=&quot;https://www.blueletterbible.org/kjv/jhn/6/37&quot;&gt;you may choose to have a future
  as well&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;If you know Christ, then
please join me today in celebrating the risen Savior, which is Christ the Lord.&lt;/p&gt;

&lt;p&gt;If you &lt;a href=&quot;https://www.blueletterbible.org/kjv/mat/7/23&quot;&gt;do not know Him&lt;/a&gt;,
or perhaps if you only know of or
&lt;a href=&quot;https://www.blueletterbible.org/kjv/jas/2/19&quot;&gt;about Him&lt;/a&gt;,
then please let me invite you discover Him through the letters His disciples
wrote describing their time with him:
&lt;a href=&quot;https://www.blueletterbible.org/kjv/mat/1&quot;&gt;Matthew&lt;/a&gt;,
&lt;a href=&quot;https://www.blueletterbible.org/kjv/mar/1&quot;&gt;Mark&lt;/a&gt;,
&lt;a href=&quot;https://www.blueletterbible.org/kjv/luk/1&quot;&gt;Luke&lt;/a&gt; and
&lt;a href=&quot;https://www.blueletterbible.org/kjv/jhn/1&quot;&gt;John&lt;/a&gt;.&lt;/p&gt;

&lt;hr /&gt;&lt;p&gt;&lt;em&gt;He is not here: for He is risen, as He said.  Come, see the place where the Lord lay. (Matthew 28:6)&lt;/em&gt;</description>
        <pubDate>Sun, 01 Apr 2018 00:00:00 -0400</pubDate>
        <link>https://zipcpu.com/blog/2018/04/01/resurrection-day.html</link>
        <guid isPermaLink="true">https://zipcpu.com/blog/2018/04/01/resurrection-day.html</guid>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>Quadratic fits are entirely inappropriate for DSP</title>
        <description>&lt;p&gt;Waveforms in nature have two characteristics that are difficult to handle in
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_signal_processing&quot;&gt;signal processing&lt;/a&gt;
applications: natural waveforms are
&lt;a href=&quot;https://en.wikipedia.org/wiki/Continuous_function&quot;&gt;continuous&lt;/a&gt;
and they are tend to last for a &lt;em&gt;long time&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;This is to be contrasted to the “signals” that &lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_signal_processing&quot;&gt;Digital Signal Processing
(DSP)&lt;/a&gt;
algorithms act upon.
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_signal_processing&quot;&gt;DSP&lt;/a&gt;
algorithms are applied to &lt;em&gt;finite&lt;/em&gt; sections of
(typically) longer waveforms that have been
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;sampled&lt;/a&gt;
at evenly spaced intervals.&lt;/p&gt;

&lt;p&gt;This leads to a fundamental problem: if you want to work on a waveform
as though it were
&lt;a href=&quot;https://en.wikipedia.org/wiki/Continuous_function&quot;&gt;continuous&lt;/a&gt;
instead of
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;sampled&lt;/a&gt;,
then you need to figure out how to reconstruct what the signal
&lt;em&gt;should be&lt;/em&gt; between the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;sample&lt;/a&gt;
points.  Perhaps you need to
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sample-rate_conversion&quot;&gt;resample&lt;/a&gt;
that signal at some new rate whose ratio is far from simple when compared
to the old rate.  Perhaps you need to
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sample-rate_conversion&quot;&gt;resample&lt;/a&gt;
your signal at locations driven by a tracking loop, such as a digital receiver
would need to do.  Perhaps you just want to zoom in on a screen plot of your
signal and &lt;a href=&quot;/dsp/2017/07/29/series-linear-interpolation.html&quot;&gt;linear
interpolation&lt;/a&gt;
leaves you with a signal that looks nothing like the original reality.  Either
way, if you want to
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;recover&lt;/a&gt;
what your signal does between
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;samples&lt;/a&gt;,
you’ll want to apply some form of
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolation&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;In the past, we’ve looked at both a &lt;a href=&quot;/dsp/2017/06/06/simple-interpolator.html&quot;&gt;sample-and-hold
“interpolator”&lt;/a&gt;
and a &lt;a href=&quot;/dsp/2017/07/29/series-linear-interpolation.html&quot;&gt;linear
interpolator&lt;/a&gt;
as possible subsample
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolation&lt;/a&gt; methods.
However, if &lt;a href=&quot;/dsp/2017/07/29/series-linear-interpolation.html&quot;&gt;linear
interpolation&lt;/a&gt;
isn’t good enough for your application, then the next best approach is some
form of &lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial_interpolation&quot;&gt;quadratic
interpolation&lt;/a&gt;.
Indeed, it’s not that hard to take three points and generate a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Quadratic_function&quot;&gt;quadratic&lt;/a&gt;
that will pass through all three of them.&lt;/p&gt;

&lt;p&gt;Stop.  Now.  Don’t do that.  Really.  Don’t.&lt;/p&gt;

&lt;p&gt;In a moment I’ll show you why not.  Then I’ll show you a better approach.
Further, when &lt;a href=&quot;https://github.com/ZipCPU/interpolation/blob/master/rtl/quadratic/quadinterp.v&quot;&gt;implemented in
logic&lt;/a&gt;,
this better approach will still use only the same two hardware multiplies that
a quadratic fit would’ve used.&lt;/p&gt;

&lt;h2 id=&quot;why-interpolation&quot;&gt;Why interpolation&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;Interpolation&lt;/a&gt; is the term used
to describe an algorithm that can be used to create (or estimate) data points
between
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;samples&lt;/a&gt;.
This is often called
&lt;a href=&quot;https://en.wikipedia.org/wiki/Upsamplers&quot;&gt;upsampling&lt;/a&gt; in a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_signal_processing&quot;&gt;Signal Processing&lt;/a&gt;
context, with the difference between
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolating&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Upsamplers&quot;&gt;upsamplers&lt;/a&gt;
and those that are not
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolating&lt;/a&gt;
is that the output of an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;
is guaranteed to go through the original
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;sample&lt;/a&gt;
points, whereas this is not necessarily the case of a more generic
&lt;a href=&quot;https://en.wikipedia.org/wiki/Upsamplers&quot;&gt;upsampler&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Today, we’ll be discussing
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolators&lt;/a&gt;
that are also infinite
&lt;a href=&quot;https://en.wikipedia.org/wiki/Upsamplers&quot;&gt;upsamplers&lt;/a&gt;, such as those &lt;a href=&quot;/dsp/2018/01/16/interpolation-is-convolution.html&quot;&gt;we
discussed earlier&lt;/a&gt;
when proving that all such
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolators&lt;/a&gt;
could be modeled as
&lt;a href=&quot;https://en.wikipedia.org/wiki/Convolution&quot;&gt;convolutions&lt;/a&gt;
of discrete-time signals with a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Continuous_function&quot;&gt;continuous&lt;/a&gt;
time filter.  Such
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolators&lt;/a&gt;
can form the basis of an &lt;em&gt;asynchronous &lt;a href=&quot;https://en.wikipedia.org/wiki/Sample-rate_conversion&quot;&gt;sample rate
converter&lt;/a&gt;&lt;/em&gt;.
For our purposes today, though, we will limit our discussion to
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolators&lt;/a&gt;
which are simply the result of a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Piecewise&quot;&gt;piecewise&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial&quot;&gt;polynomial&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Upsamplers&quot;&gt;upsamplers&lt;/a&gt;.  We’ll even limit the
discussion further to that subset of all
&lt;a href=&quot;https://en.wikipedia.org/wiki/Piecewise&quot;&gt;piecewise&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial&quot;&gt;polynomial&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Upsamplers&quot;&gt;upsamplers&lt;/a&gt;
that is formed from quadratic
&lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial&quot;&gt;polynomials&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;I first learned the idea of
&lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial&quot;&gt;polynomial&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Upsamplers&quot;&gt;upsampling&lt;/a&gt;
from &lt;a href=&quot;http://ieeexplore.ieee.org/document/679201&quot;&gt;Harris&lt;/a&gt;,
although it seems as though
&lt;a href=&quot;http://ieeexplore.ieee.org/document/15483/&quot;&gt;Farrow&lt;/a&gt;
was the actual originator of the idea.  Hence, you might recognize our
ultimate solution as a
&lt;a href=&quot;http://ieeexplore.ieee.org/document/15483/&quot;&gt;Farrow&lt;/a&gt;
filter, although it may not look like any
&lt;a href=&quot;http://ieeexplore.ieee.org/document/15483/&quot;&gt;Farrow&lt;/a&gt;
filter you’ve seen before.  Even better, it will have provably better
asymptotic out of band performance than any
&lt;a href=&quot;http://ieeexplore.ieee.org/document/15483/&quot;&gt;Farrow&lt;/a&gt;
filter or approach I’ve seen published to date.&lt;/p&gt;

&lt;h2 id=&quot;the-problem-with-quadratic-fitting&quot;&gt;The Problem with Quadratic Fitting&lt;/h2&gt;

&lt;p&gt;I started out this post by declaring that using a quadratic fit to
the nearest three points were a horrible means of
&lt;a href=&quot;https://en.wikipedia.org/wiki/Upsamplers&quot;&gt;upsampling&lt;/a&gt;.
Let’s take a moment before going
further to see why this is the case.  We’ll do this by first creating a fit
to the nearest three points of a signal, and then examining what happens when
you extend this fit beyond those three points into the points nearby.&lt;/p&gt;

&lt;p&gt;As with any
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolation&lt;/a&gt;
problem, we’ll start with a signal, &lt;code class=&quot;highlighter-rouge&quot;&gt;x[n]&lt;/code&gt;.  I’ll
use the square brackets, &lt;code class=&quot;highlighter-rouge&quot;&gt;[]&lt;/code&gt;, to emphasize that this is a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;sampled signal&lt;/a&gt;
and hence only integer indices are allowed.  From this
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;sampled signal&lt;/a&gt;,
our goal will be to create a new signal, &lt;code class=&quot;highlighter-rouge&quot;&gt;y(t)&lt;/code&gt;, with a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Continuous_function&quot;&gt;continuous&lt;/a&gt;
index, &lt;code class=&quot;highlighter-rouge&quot;&gt;t&lt;/code&gt;–herein noted by the parentheses, &lt;code class=&quot;highlighter-rouge&quot;&gt;()&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;To create a quadratic fit, well pick three points from this signal,
&lt;code class=&quot;highlighter-rouge&quot;&gt;x[n-1]&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;x[n]&lt;/code&gt;, and &lt;code class=&quot;highlighter-rouge&quot;&gt;x[n+1]&lt;/code&gt;, and then fit a quadratic function, &lt;code class=&quot;highlighter-rouge&quot;&gt;f_n(t)&lt;/code&gt;
to these three points so that:&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/quadeqn-fit-genquad.png&quot; alt=&quot;f_n(t-n) = a(t-n)^2 + b(t-n) + c&quot; width=&quot;599&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Further, if we assume that our
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;samples&lt;/a&gt;
are spaced one unit apart, then&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/quadeqn-fit-triplet.png&quot; alt=&quot;&quot; width=&quot;203&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;The constant term of this quadratic
&lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial&quot;&gt;polynomial&lt;/a&gt;
is very simple to solve.  If we examine &lt;code class=&quot;highlighter-rouge&quot;&gt;t=n&lt;/code&gt;, then,&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/quadeqn-fit-fzero.png&quot; alt=&quot;f_0(0) = a(0)+b(0)+c&quot; width=&quot;418&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;The linear term is just a bit harder, but it can be obtained by subtracting
&lt;code class=&quot;highlighter-rouge&quot;&gt;f_n(-1)&lt;/code&gt; from &lt;code class=&quot;highlighter-rouge&quot;&gt;f_n(1)&lt;/code&gt;,&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/quadeqn-fit-fsub.png&quot; alt=&quot;&quot; width=&quot;605&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;In other words,&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/quadeqn-fit-b.png&quot; alt=&quot;&quot; width=&quot;296&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Getting the last coefficient is just a little bit more work, but follows from
adding the two end point values, &lt;code class=&quot;highlighter-rouge&quot;&gt;f_n(1)&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;f_n(-1)&lt;/code&gt; together,&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/quadeqn-fit-fsum.png&quot; alt=&quot;&quot; width=&quot;531&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;This yields our quadratic coefficint,&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/quadeqn-fit-a.png&quot; alt=&quot;&quot; width=&quot;367&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Therefore, we can fit any three
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;sample&lt;/a&gt;
values to the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial&quot;&gt;polynomial&lt;/a&gt;,&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/quadeqn-fit-complete.png&quot; alt=&quot;&quot; width=&quot;632&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Fig 1 shows an example of one such fit.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 1. An example quadratic fit of three points&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/quadeqn-fit-result.png&quot; alt=&quot;&quot; width=&quot;410&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;At first glance, this looks pretty good.  We started with three data points,
and now we’ve created a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Continuous_function&quot;&gt;continuous&lt;/a&gt;
line that smoothly
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolates&lt;/a&gt;
between these three data points.  What could the problem be?&lt;/p&gt;

&lt;p&gt;The problem comes into play when you expand out from these three data points
and examine the infinite set of
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;samples&lt;/a&gt;
that are the incoming data.  In this case, the quadratic fit turns from a nice
&lt;a href=&quot;https://en.wikipedia.org/wiki/Continuous_function&quot;&gt;continuous&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;,
to discontinuous
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;,
where the discontinuity takes place halfway between any pair of
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;samples&lt;/a&gt;.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 2. Using a quadratic fit across multiple sample points create discontinuities&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/interpolation-discontinuous-quadratic.png&quot; alt=&quot;&quot; width=&quot;603&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;What happened?&lt;/p&gt;

&lt;p&gt;What happened was that we chose to only use &lt;code class=&quot;highlighter-rouge&quot;&gt;f_n&lt;/code&gt; between &lt;code class=&quot;highlighter-rouge&quot;&gt;n-1/2&lt;/code&gt; and
&lt;code class=&quot;highlighter-rouge&quot;&gt;n+1/2&lt;/code&gt;.  Once past &lt;code class=&quot;highlighter-rouge&quot;&gt;n+1/2&lt;/code&gt;, we switched to a new
&lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial&quot;&gt;polynomial&lt;/a&gt;,
&lt;code class=&quot;highlighter-rouge&quot;&gt;f_{n+1}&lt;/code&gt;.  Since we did nothing to constrain our
&lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial&quot;&gt;polynomial&lt;/a&gt;
solution so that it was
&lt;a href=&quot;https://en.wikipedia.org/wiki/Continuous_function&quot;&gt;continuous&lt;/a&gt;
between data sets, the result wasn’t
&lt;a href=&quot;https://en.wikipedia.org/wiki/Continuous_function&quot;&gt;continuous&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Before going further, let’s consider my previous statement that “&lt;a href=&quot;/dsp/2018/01/16/interpolation-is-convolution.html&quot;&gt;Interpolation
is just a special type of
convolution&lt;/a&gt;.”
Why?  Because if you can understand this quadratic
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt; as just a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Convolution&quot;&gt;convolution&lt;/a&gt;
of your data with a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Continuous_function&quot;&gt;continuous function&lt;/a&gt;,&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/interp-is-convolution.png&quot; alt=&quot;&quot; width=&quot;275&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;then we can plot the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency_response&quot;&gt;frequency response&lt;/a&gt;
of this
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;.
Knowing that
&lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency_response&quot;&gt;frequency response&lt;/a&gt;
will allow us, further on, to compare  this quadratic fit
with other alternative quadratic
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolators&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;To see how this fits into the form of a filter’s
&lt;a href=&quot;https://en.wikipedia.org/wiki/Impulse_response&quot;&gt;impulse response&lt;/a&gt;, let’s
examine what happens when this
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;
is applied to an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Kronecker_delta&quot;&gt;impulse&lt;/a&gt;.
If we allow &lt;code class=&quot;highlighter-rouge&quot;&gt;x[n]&lt;/code&gt; to be a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Kronecker_delta&quot;&gt;Kronecker delta function&lt;/a&gt;,
where &lt;code class=&quot;highlighter-rouge&quot;&gt;x[n]=0&lt;/code&gt; for all &lt;code class=&quot;highlighter-rouge&quot;&gt;n&lt;/code&gt; save for &lt;code class=&quot;highlighter-rouge&quot;&gt;x[0]=1&lt;/code&gt;, then the result of applying
this quadratic fit to this
&lt;a href=&quot;https://en.wikipedia.org/wiki/Kronecker_delta&quot;&gt;sequence&lt;/a&gt;
will be the &lt;a href=&quot;https://en.wikipedia.org/wiki/Impulse_response&quot;&gt;impulse
response&lt;/a&gt;
of this &lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;.  Let’s do
that now.&lt;/p&gt;

&lt;p&gt;First, &lt;code class=&quot;highlighter-rouge&quot;&gt;f_{-1}(t+1)&lt;/code&gt; will
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;sample&lt;/a&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;x[0]=1&lt;/code&gt; in it’s &lt;code class=&quot;highlighter-rouge&quot;&gt;n+1&lt;/code&gt; term, yielding the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial&quot;&gt;polynomial&lt;/a&gt;,&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/quadeqn-fit-impulse-neg.png&quot; alt=&quot;&quot; width=&quot;354&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Likewise, &lt;code class=&quot;highlighter-rouge&quot;&gt;f_{0}(t)&lt;/code&gt; will
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;sample&lt;/a&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;x[0]=1&lt;/code&gt; in it’s &lt;code class=&quot;highlighter-rouge&quot;&gt;n&lt;/code&gt; term, yielding,&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/quadeqn-fit-impulse-zero.png&quot; alt=&quot;&quot; width=&quot;175&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Next, the &lt;code class=&quot;highlighter-rouge&quot;&gt;f_{1}(t)&lt;/code&gt; term will
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;sample&lt;/a&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;x[0]=1&lt;/code&gt; in it’s &lt;code class=&quot;highlighter-rouge&quot;&gt;n-1&lt;/code&gt; term, giving us
our final &lt;a href=&quot;https://en.wikipedia.org/wiki/Piecewise&quot;&gt;piecewise&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial&quot;&gt;polynomial&lt;/a&gt; component,&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/quadeqn-fit-impulse-pos.png&quot; alt=&quot;&quot; width=&quot;341&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Put together, you can see this
&lt;a href=&quot;https://en.wikipedia.org/wiki/Piecewise&quot;&gt;piecewise&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial&quot;&gt;polynomial&lt;/a&gt;
plotted out in Fig 3.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 3. Impulse response of a Quadratic Fit Interpolator&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/interpolation-fig-qfit.png&quot; alt=&quot;&quot; width=&quot;325&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;See what happened?  This
&lt;a href=&quot;https://en.wikipedia.org/wiki/Impulse_response&quot;&gt;impulse response&lt;/a&gt; isn’t
&lt;a href=&quot;https://en.wikipedia.org/wiki/Continuous_function&quot;&gt;continuous&lt;/a&gt;
at all!  This is the reason why our
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolated&lt;/a&gt;
signal wasn’t &lt;a href=&quot;https://en.wikipedia.org/wiki/Continuous_function&quot;&gt;continuous&lt;/a&gt;
either.&lt;/p&gt;

&lt;p&gt;Further, it only takes some basic integral calculus to plot the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency_response&quot;&gt;frequency response&lt;/a&gt;
of this function in Fig 4.  (I’ll spare you the calculation–while basic,
it isn’t pretty.)&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 4. Fourier Transform of a Quadratic Fit&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/interpolation-fig-qfit-H.png&quot; alt=&quot;&quot; width=&quot;325&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;The gray line in Fig 4 is proportional to &lt;code class=&quot;highlighter-rouge&quot;&gt;1/f&lt;/code&gt;, showing how this
&lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency_response&quot;&gt;frequency response&lt;/a&gt;
only slowly converges towards zero as &lt;code class=&quot;highlighter-rouge&quot;&gt;f&lt;/code&gt; goes to infinity.  This is the
consequence of the discontinuities in the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Impulse_response&quot;&gt;impulse response&lt;/a&gt;
of this fit.&lt;/p&gt;

&lt;p&gt;Now that you see the problem with using a simple quadratic fit as an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;,
let’s see if we can do better.&lt;/p&gt;

&lt;h2 id=&quot;a-better-interpolator&quot;&gt;A Better Interpolator&lt;/h2&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 5. A Piecewise Polynomial&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/interpolation-piecewise-poly.png&quot; alt=&quot;&quot; width=&quot;278&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Now that we know what can go wrong with a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Piecewise&quot;&gt;piecewise&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial&quot;&gt;polynomial&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;,
it’s time to return to where we left off in our &lt;a href=&quot;/dsp/2018/01/16/interpolation-is-convolution.html&quot;&gt;prior
post&lt;/a&gt;
on this topic, and use the principles we developed there to develop
a better &lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;.
In that post, we showed that all
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolators&lt;/a&gt;
that met a minimum set of problem related assumptions have the form of a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Piecewise&quot;&gt;piecewise&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial&quot;&gt;polynomial&lt;/a&gt;,
such as is shown in Fig 5.&lt;/p&gt;

&lt;p&gt;Further, &lt;a href=&quot;/dsp/2018/01/16/interpolation-is-convolution.html&quot;&gt;we pointed
out&lt;/a&gt;
that an &lt;code class=&quot;highlighter-rouge&quot;&gt;h(t)&lt;/code&gt; function that is given by a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Piecewise&quot;&gt;piecewise&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial&quot;&gt;polynomial&lt;/a&gt;,
such as the one shown in Fig 5, can be a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Linear_system&quot;&gt;linear&lt;/a&gt;,
discrete shift invariant,
&lt;a href=&quot;https://en.wikipedia.org/wiki/Upsamplers&quot;&gt;upsampler&lt;/a&gt;.
In Fig 5, you can see separate regions of an example filter, &lt;code class=&quot;highlighter-rouge&quot;&gt;h(t)&lt;/code&gt;, shown
in separate colors.  Each colored region represents a separate quadratic
&lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial&quot;&gt;polynomial&lt;/a&gt;.  Our goal will be
to try to use some criteria to create a useful set of
&lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial&quot;&gt;polynomials&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;As a first step to building our own, let’s define our component
&lt;a href=&quot;https://en.wikipedia.org/wiki/Piecewise&quot;&gt;piecewise&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial&quot;&gt;polynomials&lt;/a&gt; as,&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/quadeqn-nfit-piecewise-eqn.png&quot; alt=&quot;&quot; width=&quot;818&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;That is to say, we’re going to look for a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Piecewise&quot;&gt;piecewise&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial&quot;&gt;polynomials&lt;/a&gt;
function, &lt;code class=&quot;highlighter-rouge&quot;&gt;h(t)&lt;/code&gt;, defined by the equations,&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/quadeqn-criteria-eqn-defns.png&quot; alt=&quot;&quot; width=&quot;666&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Why only five intervals?  This is an arbitrary choice.
There’s no hard and fast rule here.  More intervals or a higher
&lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial&quot;&gt;polynomial&lt;/a&gt;
degree might produce a better filter, but one that will cost more logic to
calculate.  Such longer filters can be the topic for another
discussion on another day.  I do know that this setup will yield a nicely
implementable solution ultimately requiring only two RTL multiplies.&lt;/p&gt;

&lt;p&gt;Two multiplies you ask?  What about all those arbitrary coefficients in &lt;code class=&quot;highlighter-rouge&quot;&gt;h(t)&lt;/code&gt;?
Hang on, we’ll get there.&lt;/p&gt;

&lt;p&gt;Why is there no &lt;code class=&quot;highlighter-rouge&quot;&gt;b&lt;/code&gt; coefficient for the middle interval?  Or, equivalently,
why are the &lt;code class=&quot;highlighter-rouge&quot;&gt;*_1&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;*_2&lt;/code&gt; coefficients repeated?  Because I have chosen a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Linear_phase&quot;&gt;symmetric&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolation&lt;/a&gt;
filter, in the hopes of achieving a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Linear_phase&quot;&gt;linear phase&lt;/a&gt;
result.  Further, I’ve started this derivation often enough without
pre-specifying these certain coefficients, and I end up specifying
them via equations anyway.  By doing it this way, it just reduces the
number of coefficients we’ll need to solve for from the beginning.&lt;/p&gt;

&lt;p&gt;To get to our result, all that remains is to determine the coefficients of the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Piecewise&quot;&gt;piecewise&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial&quot;&gt;polynomials&lt;/a&gt;
in our chosen filter.  To do this, we’ll use some (rather ad-hoc) criteria to
set up a system of linear equations to yield the as yet unknown coefficients.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;Interpolator&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Our first criteria for &lt;code class=&quot;highlighter-rouge&quot;&gt;h(t)&lt;/code&gt; is that the resulting waveform needs to
   &lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolate&lt;/a&gt;
   the incoming waveform.  In other words, whenever &lt;code class=&quot;highlighter-rouge&quot;&gt;t&lt;/code&gt; is
   an integer, the output value should equal the input.  That is, if &lt;code class=&quot;highlighter-rouge&quot;&gt;t=n&lt;/code&gt;
   then &lt;code class=&quot;highlighter-rouge&quot;&gt;y(n) = x[n]&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;If we work this from the equation standpoint,&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/interp-is-convolution.png&quot; alt=&quot;&quot; width=&quot;275&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p style=&quot;list-style-type: none;&quot;&gt;you can see that if &lt;code class=&quot;highlighter-rouge&quot;&gt;t=n&lt;/code&gt; then &lt;code class=&quot;highlighter-rouge&quot;&gt;y(n)&lt;/code&gt; is composed of a summation across
   several &lt;code class=&quot;highlighter-rouge&quot;&gt;h(t)&lt;/code&gt;
   values, each with the index &lt;code class=&quot;highlighter-rouge&quot;&gt;n-k&lt;/code&gt;.  Further, when &lt;code class=&quot;highlighter-rouge&quot;&gt;n=k&lt;/code&gt; we get the one
   component we want, and all of the other components will just pull us off in
   one direction or another.  Hence, we need to insist that,&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/quadeqn-criteria-interpolator.png&quot; alt=&quot;&quot; width=&quot;364&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 6. An interpolating filter must go through zero for all integers but zero&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/quadeqn-criteria-interpolator-dots.png&quot; alt=&quot;&quot; width=&quot;325&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;This means that every one of our
&lt;a href=&quot;https://en.wikipedia.org/wiki/Piecewise&quot;&gt;piecewise&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial&quot;&gt;polynomial&lt;/a&gt; component
functions, save the one in the center, will need to go through zero
near the integer within it, as shown in Fig 6.  The point in the center,
on the other hand, will need to pass through &lt;code class=&quot;highlighter-rouge&quot;&gt;y=1&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;It shouldn’t take too much work to see that our set of
&lt;a href=&quot;https://en.wikipedia.org/wiki/Piecewise&quot;&gt;piecewise&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial&quot;&gt;polynomial&lt;/a&gt; will
meet this criteria if we simply set &lt;code class=&quot;highlighter-rouge&quot;&gt;c_1&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;c_2&lt;/code&gt; to be zero.  Indeed,
this is the reason why it was constructed it based upon &lt;code class=&quot;highlighter-rouge&quot;&gt;t-n&lt;/code&gt; terms in the
first place.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;DSP Guru Meditation&lt;/strong&gt;: It can be shown that if &lt;code class=&quot;highlighter-rouge&quot;&gt;h(n)&lt;/code&gt; is a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Kronecker_delta&quot;&gt;Kronecker Delta function&lt;/a&gt;,
then it must also be true that,&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/quadeqn-criteria-interpolator-guru-1.png&quot; alt=&quot;&quot; width=&quot;213&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;or, equivalently,&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/quadeqn-criteria-interpolator-guru-2.png&quot; alt=&quot;&quot; width=&quot;330&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;This, plus the fact that &lt;code class=&quot;highlighter-rouge&quot;&gt;h(t)&lt;/code&gt; is real, forces the awkward reality
that &lt;code class=&quot;highlighter-rouge&quot;&gt;H(1/2)&lt;/code&gt; &lt;em&gt;must be&lt;/em&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;1/2&lt;/code&gt; as well for all practical
&lt;a href=&quot;https://en.wikipedia.org/wiki/Low-pass_filter&quot;&gt;low-pass&lt;/a&gt;
filters.  Hence, this criteria alone forces the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Passband&quot;&gt;passband&lt;/a&gt; and
&lt;a href=&quot;https://en.wikipedia.org/wiki/Stopband&quot;&gt;stopband&lt;/a&gt;
cutoff frequencies of any
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;
to be &lt;code class=&quot;highlighter-rouge&quot;&gt;f=1/2&lt;/code&gt;.  This is a somewhat unfortunate limitation on the
performance that might be achieved using this approach.&lt;/p&gt;

&lt;p&gt;This criteria is also a point of separation from
&lt;a href=&quot;http://ieeexplore.ieee.org/document/15483/&quot;&gt;Farrow&lt;/a&gt;’s work, since
&lt;a href=&quot;http://ieeexplore.ieee.org/document/15483/&quot;&gt;Farrow&lt;/a&gt; never insisted that the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sample-rate_conversion&quot;&gt;resamplers&lt;/a&gt;
he developed went through the original
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;sample&lt;/a&gt;
points.&lt;/p&gt;

&lt;ol start=&quot;2&quot;&gt;
  &lt;li&gt;&lt;strong&gt;Constant -&amp;gt; Constant&lt;/strong&gt;: &lt;code class=&quot;highlighter-rouge&quot;&gt;x[n]=c&lt;/code&gt; implies &lt;code class=&quot;highlighter-rouge&quot;&gt;y(t)=c&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;When I built my first
&lt;a href=&quot;http://ieeexplore.ieee.org/document/15483/&quot;&gt;Farrow&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolation&lt;/a&gt;
filter
from a quadratic
&lt;a href=&quot;https://en.wikipedia.org/wiki/Piecewise&quot;&gt;piecewise&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial&quot;&gt;polynomial&lt;/a&gt;,
I was surprised to discover that a constant input to my filter was producing
a non-constant output.  Instead, there was a small but repeating quadratic
component.  How could this to happen?!  How could I call this an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;, if the
resulting
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolated&lt;/a&gt; waveform
didn’t smoothly go through the given points?&lt;/p&gt;

&lt;p&gt;So I then went back to my equations for &lt;code class=&quot;highlighter-rouge&quot;&gt;h(t)&lt;/code&gt; and the coefficients of the
component &lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial&quot;&gt;polynomials&lt;/a&gt;,
and rebuilt them to insist that if &lt;code class=&quot;highlighter-rouge&quot;&gt;x[n]&lt;/code&gt; is the constant &lt;code class=&quot;highlighter-rouge&quot;&gt;c&lt;/code&gt;, then
&lt;code class=&quot;highlighter-rouge&quot;&gt;y(t)&lt;/code&gt; should equal that same constant &lt;code class=&quot;highlighter-rouge&quot;&gt;c&lt;/code&gt; as well.&lt;/p&gt;

&lt;p&gt;Let’s do that here.  With just a little manipulation, you’ll see that,&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/quadeqn-criteria-const-deriv.png&quot; alt=&quot;&quot; width=&quot;330&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Hence, we’ll want&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/quadeqn-criteria-const.png&quot; alt=&quot;&quot; width=&quot;375&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;for all possible values of &lt;code class=&quot;highlighter-rouge&quot;&gt;t&lt;/code&gt; between &lt;code class=&quot;highlighter-rouge&quot;&gt;-1/2&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;1/2&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;We can apply this criteria to our
&lt;a href=&quot;https://en.wikipedia.org/wiki/Piecewise&quot;&gt;piecewise&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial&quot;&gt;polynomial&lt;/a&gt;
filter without too much hassle.  I’ll spare you the gory details, although
you should know that the result is a set of equations further constraining our
&lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial&quot;&gt;polynomial&lt;/a&gt; coefficients.&lt;/p&gt;

&lt;p&gt;If we continue solving for our eight coefficients,
we’ll still need some more equations.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 7. The frequency response of a linear interpolator, showing a zero response for all integer frequencies but zero&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/quadeqn-criteria-const-H.png&quot; alt=&quot;&quot; width=&quot;378&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;&lt;strong&gt;DSP Guru Meditation&lt;/strong&gt;:
If you examine this property in
&lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency_response&quot;&gt;frequency&lt;/a&gt;,
it forces a unique and very desirable property upon the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolating&lt;/a&gt;
filter’s
&lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency_response&quot;&gt;frequency response&lt;/a&gt;.
In particular, the &lt;a href=&quot;https://en.wikipedia.org/wiki/Fourier_transform&quot;&gt;Fourier
transform&lt;/a&gt; of a constant
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;sampled&lt;/a&gt;
input has a component at &lt;code class=&quot;highlighter-rouge&quot;&gt;X(e^{j0})&lt;/code&gt; only, with &lt;code class=&quot;highlighter-rouge&quot;&gt;X(e^{j2pi f})=c delta(f)&lt;/code&gt;,
where &lt;code class=&quot;highlighter-rouge&quot;&gt;delta(f)&lt;/code&gt; is the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Dirac_delta_function&quot;&gt;Dirac delta function&lt;/a&gt;.
This would normally create aliasing components at frequencies &lt;code class=&quot;highlighter-rouge&quot;&gt;X(e^{j2pi m})&lt;/code&gt;
for all integers &lt;code class=&quot;highlighter-rouge&quot;&gt;m&lt;/code&gt; as well.  However, we just insisted that for a constant
input, the &lt;a href=&quot;https://en.wikipedia.org/wiki/Fourier_transform&quot;&gt;Fourier
transform&lt;/a&gt; of the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Continuous_function&quot;&gt;continuous&lt;/a&gt;
output function was to have a component at zero only.  Hence, we know that
&lt;code class=&quot;highlighter-rouge&quot;&gt;X(e^{j2pi f})H(f)&lt;/code&gt; must be nonzero for &lt;code class=&quot;highlighter-rouge&quot;&gt;f=0&lt;/code&gt;, and so we now know that
&lt;code class=&quot;highlighter-rouge&quot;&gt;H(0)=1&lt;/code&gt;.  We also know that &lt;code class=&quot;highlighter-rouge&quot;&gt;H(m)&lt;/code&gt; must be zero for all integers &lt;code class=&quot;highlighter-rouge&quot;&gt;m!=0&lt;/code&gt;,
&lt;code class=&quot;highlighter-rouge&quot;&gt;H(m)=0&lt;/code&gt;–just like a &lt;a href=&quot;https://en.wikipedia.org/wiki/Sinc_funtion&quot;&gt;sinc
function&lt;/a&gt; although other
functions can have this property as well.&lt;/p&gt;

&lt;p&gt;You can see this property shown in Fig 7 on the right.&lt;/p&gt;

&lt;ol start=&quot;3&quot;&gt;
  &lt;li&gt;&lt;strong&gt;Linear -&amp;gt; Linear&lt;/strong&gt;: &lt;code class=&quot;highlighter-rouge&quot;&gt;x[n] = n&lt;/code&gt; implies &lt;code class=&quot;highlighter-rouge&quot;&gt;y(t)=t&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Let’s follow that last criteria a bit further.  Instead of just insisting
that every constant produce a constant signal output, we can also insist
that every linear input produce a linear output.  Hence, if &lt;code class=&quot;highlighter-rouge&quot;&gt;x[n]=n&lt;/code&gt;,
then &lt;code class=&quot;highlighter-rouge&quot;&gt;y(t)&lt;/code&gt; should equal &lt;code class=&quot;highlighter-rouge&quot;&gt;t&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;As with our last criteria, we’ll apply our input, &lt;code class=&quot;highlighter-rouge&quot;&gt;x[n]=n&lt;/code&gt;, and then
insist that the result contains no &lt;code class=&quot;highlighter-rouge&quot;&gt;t^2&lt;/code&gt; terms.  (We already know it will
contain no constant terms.)&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 8. Constraining performance under linear inputs constrains the slope of the frequency response&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/quadeqn-criteria-const-Hdot.png&quot; alt=&quot;&quot; width=&quot;386&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;This will give us another linear constraint on our coefficients.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;DSP Guru Meditation&lt;/strong&gt;:
If you examine this criteria in
&lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency_response&quot;&gt;frequency&lt;/a&gt;, it basically
forces the slope of &lt;code class=&quot;highlighter-rouge&quot;&gt;H(m)&lt;/code&gt; to be zero for integers &lt;code class=&quot;highlighter-rouge&quot;&gt;m&lt;/code&gt;.  To be effective,
this criteria is dependent upon the constant criteria described above.&lt;/p&gt;

&lt;p&gt;This constraint therefore not only increases the width of our pass band,
but it also increases the depth of the nulls.&lt;/p&gt;

&lt;ol start=&quot;4&quot;&gt;
  &lt;li&gt;&lt;strong&gt;Quadratic -&amp;gt; Quadratic&lt;/strong&gt;: &lt;code class=&quot;highlighter-rouge&quot;&gt;x[n] = n^2&lt;/code&gt; implies &lt;code class=&quot;highlighter-rouge&quot;&gt;y(t)=t^2&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;For our fourth criteria, we’ll insist that if &lt;code class=&quot;highlighter-rouge&quot;&gt;x[n]=n^2&lt;/code&gt; then &lt;code class=&quot;highlighter-rouge&quot;&gt;y(t)&lt;/code&gt; should
equal &lt;code class=&quot;highlighter-rouge&quot;&gt;t^2&lt;/code&gt;.  In many ways this is similar to the linear criteria above.
As with the linear criteria, this also provides us with another equation
to add to the system of equations we are building to solve for &lt;code class=&quot;highlighter-rouge&quot;&gt;h(t)&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;DSP Guru Meditation&lt;/strong&gt;: This criteria constrains the second derivative of
the &lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency_response&quot;&gt;frequency response&lt;/a&gt;
near both &lt;code class=&quot;highlighter-rouge&quot;&gt;f=m&lt;/code&gt; for all integer frequencies &lt;code class=&quot;highlighter-rouge&quot;&gt;m&lt;/code&gt;, thus also widening our
passband, as well as the width of the nulls in the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency_response&quot;&gt;frequency response&lt;/a&gt;.
As a result, this criteria only intensifies our last constraint.&lt;/p&gt;

&lt;ol start=&quot;5&quot;&gt;
  &lt;li&gt;&lt;strong&gt;Continuous&lt;/strong&gt;: &lt;img src=&quot;/img/quadeqn-criteria-continuous.png&quot; width=&quot;233&quot; /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;As a final set of criteria, we’ll insist that our
&lt;a href=&quot;https://en.wikipedia.org/wiki/Piecewise&quot;&gt;piecewise&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial&quot;&gt;polynomial&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Impulse_response&quot;&gt;impulse response&lt;/a&gt; be
&lt;a href=&quot;https://en.wikipedia.org/wiki/Continuous_function&quot;&gt;continuous&lt;/a&gt;.
Hence, the &lt;code class=&quot;highlighter-rouge&quot;&gt;h(t)&lt;/code&gt; function must be
&lt;a href=&quot;https://en.wikipedia.org/wiki/Continuous_function&quot;&gt;continuous&lt;/a&gt;
at its seams: &lt;code class=&quot;highlighter-rouge&quot;&gt;t=-5/2&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;t=-3/2&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;t=-1/2&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;t=1/2&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;t=3/2&lt;/code&gt;, and &lt;code class=&quot;highlighter-rouge&quot;&gt;t=5/2&lt;/code&gt;.
However, since we constrained our
&lt;a href=&quot;https://en.wikipedia.org/wiki/Piecewise&quot;&gt;piecewise&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial&quot;&gt;polynomial&lt;/a&gt; to be
&lt;a href=&quot;https://en.wikipedia.org/wiki/Linear_phase&quot;&gt;symmetric&lt;/a&gt;
in time, we really only need to deal with half of those &lt;code class=&quot;highlighter-rouge&quot;&gt;t&lt;/code&gt; values.&lt;/p&gt;

&lt;p&gt;Because any linear combination of
&lt;a href=&quot;https://en.wikipedia.org/wiki/Continuous_function&quot;&gt;continuous functions&lt;/a&gt;
is also
&lt;a href=&quot;https://en.wikipedia.org/wiki/Continuous_function&quot;&gt;continuous&lt;/a&gt;,
&lt;code class=&quot;highlighter-rouge&quot;&gt;y(t)&lt;/code&gt; will be
&lt;a href=&quot;https://en.wikipedia.org/wiki/Continuous_function&quot;&gt;continuous&lt;/a&gt;
any time &lt;code class=&quot;highlighter-rouge&quot;&gt;h(t)&lt;/code&gt; is
&lt;a href=&quot;https://en.wikipedia.org/wiki/Continuous_function&quot;&gt;continuous&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;There’s an even more important consequence of this ad-hoc criteria: any
&lt;a href=&quot;https://en.wikipedia.org/wiki/Continuous_function&quot;&gt;continuous function&lt;/a&gt;
will have a &lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency_response&quot;&gt;frequency
response&lt;/a&gt;.
with an asymptotic decay proportional to &lt;code class=&quot;highlighter-rouge&quot;&gt;1/f^2&lt;/code&gt; or better.  This function
is no different.  Hence, when you put all of our constraints together, we’ve
now constrained the zero frequency, &lt;code class=&quot;highlighter-rouge&quot;&gt;f=0&lt;/code&gt;, and the first and second
derivatives of all integer frequencies.  By now insisting on a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Continuous_function&quot;&gt;continuous&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Impulse_response&quot;&gt;impulse response&lt;/a&gt;,
we’ve also constrained the asymptotic &lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency_response&quot;&gt;frequency
response&lt;/a&gt; of this
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolating&lt;/a&gt;
filter as well.&lt;/p&gt;

&lt;p&gt;In other words, we’ve just created an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolating&lt;/a&gt;
function with a very nice
&lt;a href=&quot;https://en.wikipedia.org/wiki/Low-pass_filter&quot;&gt;low-pass&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency_response&quot;&gt;frequency response&lt;/a&gt;–it
just doesn’t have a very narrow
&lt;a href=&quot;https://en.wikipedia.org/wiki/Transition_band&quot;&gt;transition band&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;DSP Guru Meditation&lt;/strong&gt;: I will contend, based more upon frustration then
proof, that it is actually impossible to create a finite quadratic
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolating&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial&quot;&gt;polynomial&lt;/a&gt; via this method that
will be &lt;a href=&quot;https://en.wikipedia.org/wiki/Continuous_function&quot;&gt;continuous&lt;/a&gt; in
its first derivative.  Before you jump to disprove me, remember my definition
of an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolating&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial&quot;&gt;polynomial&lt;/a&gt;, which requires that it
equal zero at all integer locations but zero.  Were we able to create such a
function, it would have an out of band asymptotic decay rate of &lt;code class=&quot;highlighter-rouge&quot;&gt;1/f^3&lt;/code&gt;–but
we’ll leave the discussion of such functions for a later discussion of either
higher order &lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolators&lt;/a&gt;,
or quadratic &lt;a href=&quot;https://en.wikipedia.org/wiki/Spline_interpolation&quot;&gt;splines&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;As an aside, it is possible to formulate the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Spline_interpolation&quot;&gt;splines&lt;/a&gt; problem in &lt;a href=&quot;/dsp/2018/01/16/interpolation-is-convolution.html&quot;&gt;this
fashion&lt;/a&gt;.
Doing so produces a solution that no longer requires solving for the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Piecewise&quot;&gt;piecewise&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial&quot;&gt;polynomial&lt;/a&gt; to be
coefficients at every step, while yielding a cleaner and (slightly) wider
&lt;a href=&quot;https://en.wikipedia.org/wiki/Passband&quot;&gt;passband&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;If you put all of the resulting equations together, for the constraints outlined
above, you will get an over-determined system.  This over determined system
will include several redundant equations which can be easily removed.  Once
the redundant equations are removed, you will then get the system
of linear equations below.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/quadeqn-criteria-eqns.png&quot; alt=&quot;&quot; width=&quot;441&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;In spite of starting with an over determined system in this process, we got
lucky: the system above has a unique solution given by,&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/quadeqn-criteria-soln.png&quot; alt=&quot;&quot; width=&quot;233&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Wow, that was a lot of work to just get a bunch of numbers.  So what,
right?  What’s the use of these five values?&lt;/p&gt;

&lt;p&gt;The value of this solution is seen in the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Impulse_response&quot;&gt;impulse response&lt;/a&gt; and
&lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency_response&quot;&gt;frequency response&lt;/a&gt;
shown in Fig 9.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 9. Impulse response (left) and Frequency Response (right) of this piecewise polynomial interpolator&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/interpolation-fig-betterq.png&quot; alt=&quot;&quot; width=&quot;728&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;As we required, the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Passband&quot;&gt;passband&lt;/a&gt; and
is “flat” near &lt;code class=&quot;highlighter-rouge&quot;&gt;f=0&lt;/code&gt;, and the nulls are deep.
Unlike both the &lt;a href=&quot;/dsp/2017/06/06/simple-interpolator.html&quot;&gt;nearest neighbor
interpolator&lt;/a&gt;
and the quadratic fit we
discussed above, the asymptotic fall off of this filter is proportional to
&lt;code class=&quot;highlighter-rouge&quot;&gt;1/f^2&lt;/code&gt;.  Further, unlike the &lt;a href=&quot;/dsp/2017/07/29/series-linear-interpolation.html&quot;&gt;linear interpolator we built
earlier&lt;/a&gt;
which also has an asymptotic fall off of &lt;code class=&quot;highlighter-rouge&quot;&gt;1/f^2&lt;/code&gt;, this
asymptotic fall off has a smaller proportionality coefficient of &lt;code class=&quot;highlighter-rouge&quot;&gt;1/f^2&lt;/code&gt;.
For comparison, consider Fix 7 above showing the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency_response&quot;&gt;frequency response&lt;/a&gt;
of the &lt;a href=&quot;/dsp/2017/07/29/series-linear-interpolation.html&quot;&gt;linear
interpolator&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;In other words, this quadratic
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt; forms a &lt;em&gt;nice&lt;/em&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Piecewise&quot;&gt;piecewise&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial&quot;&gt;polynomial&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolation&lt;/a&gt;
filter.&lt;/p&gt;

&lt;p&gt;Even better, with some careful coding (below) we can implement the coefficient
multiplication with only adds and subtracts.  This will mean that we can
evaluate this &lt;a href=&quot;https://github.com/ZipCPU/interpolation/blob/master/rtl/quadratic/quadinterp.v&quot;&gt;quadratic in
Verilog&lt;/a&gt;
using only two hardware multiplies–minimizing a precious resource found within
any digital logic component.&lt;/p&gt;

&lt;p&gt;Sadly, the development above is only an ad-hoc formulation.  While it
may be possible to truly generate &lt;em&gt;optimal&lt;/em&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolators&lt;/a&gt;
via this method, I have not yet pursued such a study in depth.&lt;/p&gt;

&lt;h2 id=&quot;three-interpolators-and-only-two-multiplies&quot;&gt;Three Interpolators and only Two Multiplies&lt;/h2&gt;

&lt;p&gt;In the next section, we’ll start discussing how to build the
&lt;a href=&quot;https://github.com/ZipCPU/interpolation/blob/master/rtl/quadratic/quadinterp.v&quot;&gt;Verilog code necessary to
implement&lt;/a&gt;
this &lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;.
Indeed, well even do one better than that: we’ll show
the Verilog code necessary to implement three separate quadratic
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolators&lt;/a&gt;–all with only
&lt;em&gt;two multiplies&lt;/em&gt;.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;The first &lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;
will be the one that results from the quadratic fit approach I was so
critical of above.  We’ll use this performance for reference below.  This
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;
is given by the equations we developed above:&lt;/li&gt;
&lt;/ol&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/quadeqn-fit-coeffs.png&quot; alt=&quot;&quot; width=&quot;367&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;As we discussed above, we can expect this
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;
to produce a discontinuous output waveform.&lt;/p&gt;

&lt;ol start=&quot;2&quot;&gt;
  &lt;li&gt;The second &lt;a href=&quot;https://en.wikipedia.org/wiki/Upsamplers&quot;&gt;upsampling&lt;/a&gt;
function may have the best &lt;a href=&quot;https://en.wikipedia.org/wiki/Stopband&quot;&gt;stopband&lt;/a&gt;
performance among all quadratic
&lt;a href=&quot;https://en.wikipedia.org/wiki/Upsamplers&quot;&gt;upsamplers&lt;/a&gt;, however it’s not a true
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;
since it doesn’t necessarily go through the original signal
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;sample&lt;/a&gt;
points.  We’ll call this the
non-&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;
for lack of a better term.  This
non-&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;
is a very valuable
&lt;a href=&quot;https://en.wikipedia.org/wiki/Upsamplers&quot;&gt;upsampling&lt;/a&gt;
function for the simple reason that its
&lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency_response&quot;&gt;frequency response&lt;/a&gt;
tail falls off faster (&lt;code class=&quot;highlighter-rouge&quot;&gt;1/f^3&lt;/code&gt;) than any other quadratic.  Indeed, it is
so valuable, that we may come back and use it to beat the performance of a
&lt;a href=&quot;/dsp/2017/08/30/cordic.html&quot;&gt;CORDIC&lt;/a&gt;–but
that will have to be the topic of a future article (it will still require
two multiples, something the
&lt;a href=&quot;/dsp/2017/08/30/cordic.html&quot;&gt;CORDIC&lt;/a&gt; doesn’t need).&lt;/li&gt;
&lt;/ol&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/quadeqn-cub-coeffs.png&quot; alt=&quot;&quot; width=&quot;383&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 11.  The impulse response of a rectangle convolved with itself three times&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/interpolation-fig-rcubd-impulse.png&quot; alt=&quot;&quot; width=&quot;325&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;This non-&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;
will not suffer from the discontinuities we discussed above.  Further, if you
are up to a calculus challenge, this function can be derived by
&lt;a href=&quot;https://en.wikipedia.org/wiki/Convolution&quot;&gt;convolving&lt;/a&gt; a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Rectangular_function&quot;&gt;rectangle function&lt;/a&gt;
with itself three separate times, hence its
&lt;a href=&quot;https://en.wikipedia.org/wiki/Impulse_response&quot;&gt;impulse response&lt;/a&gt;
is shown in Fig 11.&lt;/p&gt;

&lt;p&gt;One unique feature of this
&lt;a href=&quot;https://en.wikipedia.org/wiki/Upsamplers&quot;&gt;upsampler&lt;/a&gt;
is its properties when doing peak finding.  Indeed, peaks found following
this fit tend to be more accurately located than when using the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;
that is the topic of today’s development–but this again is a topic for
another day.&lt;/p&gt;

&lt;p&gt;Since the non-&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;’s
&lt;a href=&quot;https://en.wikipedia.org/wiki/Impulse_response&quot;&gt;impulse response&lt;/a&gt;
response is created by &lt;a href=&quot;https://en.wikipedia.org/wiki/Convolution&quot;&gt;convolving&lt;/a&gt; a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Rectangular_function&quot;&gt;rectangle function&lt;/a&gt;
with itself three separate times, its
&lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency_response&quot;&gt;frequency response&lt;/a&gt;
will be given by the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency_response&quot;&gt;frequency response&lt;/a&gt; of a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Rectangular_function&quot;&gt;rectangle function&lt;/a&gt;
cubed, or in other words by a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sinc_funtion&quot;&gt;sinc function&lt;/a&gt; cubed.&lt;/p&gt;

&lt;p&gt;Further, if you compare the coefficients of this
the non-&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;’s
&lt;a href=&quot;https://en.wikipedia.org/wiki/Impulse_response&quot;&gt;impulse response&lt;/a&gt;
with those of the quadratic fit (above), you’ll see that all but the
constant coefficients, &lt;code class=&quot;highlighter-rouge&quot;&gt;c_n&lt;/code&gt;, are identical.&lt;/p&gt;

&lt;p&gt;In &lt;a href=&quot;https://github.com/ZipCPU/interpolation/blob/master/rtl/quadratic/quadinterp.v&quot;&gt;our code&lt;/a&gt;
below, the parameter &lt;code class=&quot;highlighter-rouge&quot;&gt;OPT_IMPROVED_FIT&lt;/code&gt; will control whether or not this
non-&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolating&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Upsamplers&quot;&gt;upsampler&lt;/a&gt;
is generated or not.  If set, the traditional quadratic fit will be bypassed
for this alternative implementation.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;DSP Guru Meditation&lt;/strong&gt;: My statement above that the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency_response&quot;&gt;frequency response&lt;/a&gt;
tail of this filter asymptotically decays &lt;em&gt;faster than any other quadratic&lt;/em&gt;
isn’t quite true.  Quadratics filters composed of a linear combinations of
this filter function will also fall off at the &lt;code class=&quot;highlighter-rouge&quot;&gt;1/f^3&lt;/code&gt; rate … but we’ll
leave the further discussion of this approach to a future discussion of
quadratic (and/or cubic)
&lt;a href=&quot;https://en.wikipedia.org/wiki/Spline_interpolation&quot;&gt;splines&lt;/a&gt;, since that’s
where it is most relevant.&lt;/p&gt;

&lt;ol start=&quot;3&quot;&gt;
  &lt;li&gt;The third function we’ll implement is defined by the coefficient
equations we just developed in the last section above.&lt;/li&gt;
&lt;/ol&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/quadeqn-nfit-coeffs.png&quot; alt=&quot;&quot; width=&quot;675&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;This is the one we expect to see good results from–it is
&lt;a href=&quot;https://en.wikipedia.org/wiki/Continuous_function&quot;&gt;continuous&lt;/a&gt;,
and passes constants, lines, and quadratics without distortion.  Not
only that, the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;
generated by this function is guaranteed to go through the initial
&lt;code class=&quot;highlighter-rouge&quot;&gt;x[n]&lt;/code&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;sample&lt;/a&gt;
points given to it.&lt;/p&gt;

&lt;p&gt;The parameter &lt;code class=&quot;highlighter-rouge&quot;&gt;OPT_INTERPOLATOR&lt;/code&gt; in
&lt;a href=&quot;https://github.com/ZipCPU/interpolation/blob/master/rtl/quadratic/quadinterp.v&quot;&gt;our code below&lt;/a&gt;
will control whether or not this
implementation is used.  If set, &lt;code class=&quot;highlighter-rouge&quot;&gt;OPT_INTERPOLATOR&lt;/code&gt; will override the
&lt;code class=&quot;highlighter-rouge&quot;&gt;OPT_IMPROVED_FIT&lt;/code&gt; option parameter above, yielding an implementation of
this quadratic
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;We’ll use some careful coding techniques in the next section in order to
avoid using hardware multiplication elements when multiplying the quadratic
coefficients generated by the incoming data by these factors,
28, 16, 10, 3/4, etc.  The resulting algorithm will use only shifts and adds–up
until the final quadratic evaluation.  We will need to be careful
to make certain that we track the decimal point during this process though.&lt;/p&gt;

&lt;p&gt;When it comes to evaluating the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial&quot;&gt;polynomial&lt;/a&gt;
itself, if you’ve never implemented one numerically, then you should know
that there is a right and a wrong way to apply the multiply–a “trick” if you
will.  In particular, you don’t want to calculate your result by a
straight forward evaluation,&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/quadeqn-implementation-bad.png&quot; alt=&quot;&quot; width=&quot;243&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;This straight forward approach suffers from two problems.  The first problem is
that it costs three multiplies.  (Ouch!) The second problem is that this method
is susceptible to the loss of precision as the intermediate values are
truncated prior to their final addition.&lt;/p&gt;

&lt;p&gt;Instead, we’ll calculate this
&lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial&quot;&gt;polynomial&lt;/a&gt;’s
value based upon a different formulation:&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/quadeqn-implementation.png&quot; alt=&quot;&quot; width=&quot;217&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;This will solve both of these problems, yielding a nice solution suitable for
RTL implementation.&lt;/p&gt;

&lt;h2 id=&quot;fixed-point&quot;&gt;Fixed Point&lt;/h2&gt;

&lt;p&gt;Let’s pause for one more section before diving into
&lt;a href=&quot;https://github.com/ZipCPU/interpolation/blob/master/rtl/quadratic/quadinterp.v&quot;&gt;the code&lt;/a&gt;
below, to discuss how we are going to handle the evaluation of the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Piecewise&quot;&gt;piecewise&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial&quot;&gt;polynomial&lt;/a&gt;
function coefficients.&lt;/p&gt;

&lt;p&gt;Our first step will be to replace the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial&quot;&gt;polynomial&lt;/a&gt;,
coefficients with elements of a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;sample&lt;/a&gt;
based shift register.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
if (i_ce)
	{ x[3], x[2], x[1], x[0] } &amp;lt;= { x[2], x[1], x[0], in };&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This will eliminate the dependence of the algorithm on the integer &lt;code class=&quot;highlighter-rouge&quot;&gt;n&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;We’ll use the input data as the first element in this registers,
and use &lt;code class=&quot;highlighter-rouge&quot;&gt;x[0]&lt;/code&gt; to refer to the prior input, &lt;code class=&quot;highlighter-rouge&quot;&gt;x[1]&lt;/code&gt; to refer to the value
before that, etc.  Hence, we’ll map the following values:&lt;/p&gt;

&lt;table class=&quot;bordered-table&quot;&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Old name&lt;/th&gt;
      &lt;th&gt;New Name&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;x[n+2]&lt;/td&gt;
      &lt;td&gt;in&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;x[n+1]&lt;/td&gt;
      &lt;td&gt;x[0]&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;x[n+0]&lt;/td&gt;
      &lt;td&gt;x[1]&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;x[n-1]&lt;/td&gt;
      &lt;td&gt;x[2]&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;x[n-2]&lt;/td&gt;
      &lt;td&gt;x[3]&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;This allows us to re-express the above filter coefficient equations as,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;   16 av = 4(x[1]-8x[1])+16(x[0]+x[2])-2(in+x[3])
   16 bv = 2[(x[0]-x[2])+4(x[0]-x[2])]+(in-x[3])
   cv = x[1]&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;You may also notice that all of the multiplies necessary to calculate
the coefficients, &lt;code class=&quot;highlighter-rouge&quot;&gt;a_n&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;b_n&lt;/code&gt;, and &lt;code class=&quot;highlighter-rouge&quot;&gt;c_n&lt;/code&gt;,
have now been replaced with adds and shifts.  Instead of multiplying by &lt;code class=&quot;highlighter-rouge&quot;&gt;-28&lt;/code&gt;
for example, we can subtract &lt;code class=&quot;highlighter-rouge&quot;&gt;8x[1]&lt;/code&gt; from &lt;code class=&quot;highlighter-rouge&quot;&gt;x[1]&lt;/code&gt; and then shift the result left by two bits.  In a similar fashion, we can multiply &lt;code class=&quot;highlighter-rouge&quot;&gt;x[0]-x[2]&lt;/code&gt; by five
by adding &lt;code class=&quot;highlighter-rouge&quot;&gt;x[0]-x[2]&lt;/code&gt; to &lt;code class=&quot;highlighter-rouge&quot;&gt;4(x[0]-x[2])&lt;/code&gt;.  The final multiplication by
two, or rather left shift by one, just completes the desired multiply by ten.&lt;/p&gt;

&lt;p&gt;Even this is too hard, though, since it will take us a couple of clocks to
calculate these values.  Hence we’ll go about calculating our coefficients
in three steps each in a different clock cycle.&lt;/p&gt;

&lt;p&gt;We’ll start, therefore, by splitting this process into three sets of operations.
Eventually these will take place on separate clock cycles, but for now we can
draw them out as though they all happened at once.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;   pmidv = 8x[1] - x[1]; // = 7x[1]
   psumn =  x[0] + x[2];
   difn  =  x[0] - x[2];
   //
   diffn = difn + 4difn;	// = 5 * (x[0] - x[2])
   sumw  =   in  + x[3];
   diffw =   in  - x[3];
   midvpsumn = 4(psumn) - (pmidv); // = 4(x[0]+x[2])-7x[1]
   //
   16 av = 4(midvpsumn)-2(sumw)
   16 bv = 2(diffn)+(diffw)
   cv = x[1]&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This can then be rewritten into pseudo-RTL logic over the space of three clock
cycles.  Our notation for the shift register components from before, &lt;code class=&quot;highlighter-rouge&quot;&gt;in&lt;/code&gt;
through &lt;code class=&quot;highlighter-rouge&quot;&gt;x[3]&lt;/code&gt;, will be valid on the second clock cycle.  Hence, for the
first clock we’ll be referencing &lt;code class=&quot;highlighter-rouge&quot;&gt;in&lt;/code&gt; through &lt;code class=&quot;highlighter-rouge&quot;&gt;x[2]&lt;/code&gt; instead of &lt;code class=&quot;highlighter-rouge&quot;&gt;x[0]&lt;/code&gt;
through &lt;code class=&quot;highlighter-rouge&quot;&gt;x[3]&lt;/code&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
if (i_ce)
begin
   // First clock, pre-data
   pmidv &amp;lt;= 8x[0] - x[0]; // Was 8x[1] - x[1]
   psumn &amp;lt;=   in + x[1];  // Was x[0] + x[2]
   difn  &amp;lt;=   in - x[1];  // Was x[0] - x[2]&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This takes care of some of the inner operations from our equations above.
The next step handles some more of the “multiplies”.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;   // Second clock
   diffn &amp;lt;= difn + 4difn;	// = 5 * (x[0] - x[2])
   sumw  &amp;lt;=   in  + x[3];
   diffw &amp;lt;=   in  - x[3];
   midvpsumn &amp;lt;= 4(psumn) - (pmidv); // = 4(x[0]+x[2])-7x[1]&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;In the final clock cycle we’ll calculate the actual coefficients.  Because
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
math is primarily fixed point, we’ll leave the &lt;code class=&quot;highlighter-rouge&quot;&gt;16&lt;/code&gt; on the left–indicating
that we never divided by the necessary 16.  We’ll need to drop the extra four
bits later, but for now we’ll leave them in
place as long as possible to avoid loss of precision.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;   // Third clock, data delayed by one
   av &amp;lt;= 4(midvpsumn)-2(sumw); // * 2^4
   bv &amp;lt;= 2(diffn)+(diffw); // * 2^4
   cv &amp;lt;= x[2];
end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This gives us the coefficients of our
&lt;a href=&quot;https://en.wikipedia.org/wiki/Piecewise&quot;&gt;piecewise&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial&quot;&gt;polynomial&lt;/a&gt; for a given
set of five input samples.&lt;/p&gt;

&lt;p&gt;We still need to calculate the value of &lt;code class=&quot;highlighter-rouge&quot;&gt;t&lt;/code&gt; that needs to be used when
evaluating this &lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial&quot;&gt;polynomial&lt;/a&gt;.
This logic will follow directly from the &lt;a href=&quot;/dsp/2017/07/29/series-linear-interpolation.html&quot;&gt;linear interpolator
development&lt;/a&gt;,
and is even copied from that development.&lt;/p&gt;

&lt;p&gt;The only big difference between this and the &lt;a href=&quot;/dsp/2017/07/29/series-linear-interpolation.html&quot;&gt;linear
interpolator&lt;/a&gt;
development is that, unlike the
&lt;a href=&quot;/dsp/2017/07/29/series-linear-interpolation.html&quot;&gt;linear interpolator&lt;/a&gt;,
this &lt;a href=&quot;https://en.wikipedia.org/wiki/Piecewise&quot;&gt;piecewise&lt;/a&gt; quadratic
&lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial&quot;&gt;polynomial&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolates&lt;/a&gt;
from &lt;em&gt;around&lt;/em&gt; the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;sample&lt;/a&gt; points
(&lt;code class=&quot;highlighter-rouge&quot;&gt;|t|&amp;lt;1/2&lt;/code&gt;), rather than &lt;em&gt;between&lt;/em&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;sample&lt;/a&gt; points,
(&lt;code class=&quot;highlighter-rouge&quot;&gt;0&amp;lt;t&amp;lt;1&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;Perhaps this would make more sense with a figure.  Fig 12 therefore shows in
color how the quadratic
&lt;a href=&quot;https://en.wikipedia.org/wiki/Upsamplers&quot;&gt;upsampler&lt;/a&gt;
will interpolate from &lt;em&gt;around&lt;/em&gt; the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;sample&lt;/a&gt;
points on the left, rather than &lt;em&gt;between&lt;/em&gt; the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;sample&lt;/a&gt;
points as shown on the right.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 12. Piecewise quadratics interpolate around sample points (left), rather than between sample points (right)&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/quadeqn-intervals-compared.png&quot; alt=&quot;&quot; width=&quot;728&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;I’m not really sure why this is so, I just know that I haven’t managed to
build a symmetric quadratic
&lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial&quot;&gt;polynomial&lt;/a&gt;
&lt;em&gt;between&lt;/em&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;sample&lt;/a&gt; points
(right side of Fig. 12 above) that ended up being very useful.  To handle this
difference, we’ll keep track of the last coefficients.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
if (i_ce)
begin
	avold &amp;lt;= av;
	bvold &amp;lt;= bv;
	cvold &amp;lt;= cv;
end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Then, if our local &lt;code class=&quot;highlighter-rouge&quot;&gt;t&lt;/code&gt; value is less then zero (&lt;code class=&quot;highlighter-rouge&quot;&gt;MSB&lt;/code&gt; is set), we’ll
use the newer coefficients, &lt;code class=&quot;highlighter-rouge&quot;&gt;av&lt;/code&gt;-&lt;code class=&quot;highlighter-rouge&quot;&gt;cv&lt;/code&gt;, otherwise we’ll use the
older, delayed by one &lt;code class=&quot;highlighter-rouge&quot;&gt;avold&lt;/code&gt;-&lt;code class=&quot;highlighter-rouge&quot;&gt;cvold&lt;/code&gt; coefficients.&lt;/p&gt;

&lt;p&gt;We’d also like to add a half to &lt;code class=&quot;highlighter-rouge&quot;&gt;t&lt;/code&gt; at this point, so that it ranges between
&lt;code class=&quot;highlighter-rouge&quot;&gt;0&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt; instead of from &lt;code class=&quot;highlighter-rouge&quot;&gt;-0.5&lt;/code&gt; to &lt;code class=&quot;highlighter-rouge&quot;&gt;0.5&lt;/code&gt;.  It turns out that’s not needed.
&lt;code class=&quot;highlighter-rouge&quot;&gt;t&lt;/code&gt; naturally fits into place without change–all that’s required is to
re-interpret the signed &lt;code class=&quot;highlighter-rouge&quot;&gt;t&lt;/code&gt; value as an unsigned value and the conversion
is done.&lt;/p&gt;

&lt;p&gt;That gives us our three coefficients, &lt;code class=&quot;highlighter-rouge&quot;&gt;r_av&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;r_bv&lt;/code&gt;, and &lt;code class=&quot;highlighter-rouge&quot;&gt;r_cv&lt;/code&gt;,
together with our time offset, &lt;code class=&quot;highlighter-rouge&quot;&gt;r_offset&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Finally, as we go through the rest of the algorithm, we’ll use the prefixes
&lt;code class=&quot;highlighter-rouge&quot;&gt;r_&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;qp_&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;ls_&lt;/code&gt;, and &lt;code class=&quot;highlighter-rouge&quot;&gt;lp_&lt;/code&gt; to indicate which stage of the quadratic
algorithm we are in.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;The &lt;code class=&quot;highlighter-rouge&quot;&gt;r_&lt;/code&gt; prefix will hold the first copies of our variables in the “new”
sample rate domain.  This will include not only the quadratic coefficients,
&lt;code class=&quot;highlighter-rouge&quot;&gt;r_av&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;r_bv&lt;/code&gt;, and &lt;code class=&quot;highlighter-rouge&quot;&gt;r_cv&lt;/code&gt;, but also the value of &lt;code class=&quot;highlighter-rouge&quot;&gt;t&lt;/code&gt; associated with
these coefficients, held in &lt;code class=&quot;highlighter-rouge&quot;&gt;r_offset&lt;/code&gt;.  Finally, &lt;code class=&quot;highlighter-rouge&quot;&gt;r_ce&lt;/code&gt; will be true on
any clock where these values are valid.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The &lt;code class=&quot;highlighter-rouge&quot;&gt;qp_&lt;/code&gt; prefix will hold our variables immediately after taking
the &lt;em&gt;quadratic product&lt;/em&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;a*t&lt;/code&gt; or in terms of our registers,
&lt;code class=&quot;highlighter-rouge&quot;&gt;r_av * r_offset&lt;/code&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The &lt;code class=&quot;highlighter-rouge&quot;&gt;ls_&lt;/code&gt; prefix will refer to the variables associated with the
&lt;em&gt;linear sum&lt;/em&gt;, the result of adding &lt;code class=&quot;highlighter-rouge&quot;&gt;a*t+b&lt;/code&gt; or equivalently the output
of the quadratic product plus &lt;code class=&quot;highlighter-rouge&quot;&gt;r_bv&lt;/code&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The &lt;code class=&quot;highlighter-rouge&quot;&gt;lp_&lt;/code&gt; prefix will denote values associated with multiplying this
&lt;em&gt;last product&lt;/em&gt; and linear sum by our &lt;code class=&quot;highlighter-rouge&quot;&gt;t&lt;/code&gt; value one more time to get
&lt;code class=&quot;highlighter-rouge&quot;&gt;(at+b)*t&lt;/code&gt;.  As a result, when we add the constant to the result
of this last multiply, we’ll have our final value which we shall
call &lt;code class=&quot;highlighter-rouge&quot;&gt;r_done&lt;/code&gt;.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The algorithm below doesn’t do any rounding until the final step.  Instead,
it accumulates a lot of extra bits along the way, so that there’s not that
much precision lost along the way.&lt;/p&gt;

&lt;h2 id=&quot;the-code&quot;&gt;The Code&lt;/h2&gt;

&lt;p&gt;We’ve now made it far enough in our description that we can now walk through
the algorithm.  Feel free to skip this section if you would like and go
directly to the performance section below, and then return to this once you’ve
become convinced that you really are interested in the algorithmic details.
You can also just examine (or implement)
&lt;a href=&quot;https://github.com/ZipCPU/interpolation/blob/master/rtl/quadratic/quadinterp.v&quot;&gt;the code&lt;/a&gt;,
yourself to see what your thoughts are of it.&lt;/p&gt;

&lt;p&gt;The algorithm starts by defining some interface parameters.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	parameter	INW   = 25,	// Input width
			OWID  = INW,	// Output width
			MP    = 25,	// Multiply precision
			CTRBITS = 32;	// Bits in our counter&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;These are the input width, the output width, and the number of bits of our
time counter to use in the multiply.  The fourth value, &lt;code class=&quot;highlighter-rouge&quot;&gt;CTRBITS&lt;/code&gt;, controls
the total number of bits in the time counter.  In other words, how accurate
the fractional
&lt;a href=&quot;https://en.wikipedia.org/wiki/Upsamplers&quot;&gt;upsampling&lt;/a&gt;
ratio should be.  As with the &lt;a href=&quot;/dsp/2017/07/29/series-linear-interpolation.html&quot;&gt;linear
interpolator&lt;/a&gt;
development, this counter will step, on each input
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;sample&lt;/a&gt;,
by a step size given by the input &lt;code class=&quot;highlighter-rouge&quot;&gt;i_step&lt;/code&gt;,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;i_step = 2^(CTRBITS) (int)(old_sample_rate / new_sample_rate);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The number of bits in &lt;code class=&quot;highlighter-rouge&quot;&gt;CTRBITS&lt;/code&gt; will just control the accuracy and precision
of the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sample-rate_conversion&quot;&gt;resampling&lt;/a&gt;
function.&lt;/p&gt;

&lt;p&gt;The next two parameters, &lt;code class=&quot;highlighter-rouge&quot;&gt;OPT_INTERPOLATOR&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;OPT_IMPROVE_FIT&lt;/code&gt;, we
discussed earlier.  These control which quadratic
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sample-rate_conversion&quot;&gt;resampler&lt;/a&gt;
to implement among three defined in the code.  &lt;code class=&quot;highlighter-rouge&quot;&gt;OPT_INTERPOLATOR=1&lt;/code&gt; will
cause us to use the new
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;.
On the other hand, if &lt;code class=&quot;highlighter-rouge&quot;&gt;OPT_INTERPOLATOR=0&lt;/code&gt; but
&lt;code class=&quot;highlighter-rouge&quot;&gt;OPT_IMPROVED_FIT=1&lt;/code&gt;, then we’ll use the
non-&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;
output.  Finally, if both are zero the algorithm will calculate the
quadratic fit I’ve been so critical of.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	parameter  [0:0]	OPT_IMPROVED_FIT = 1&#39;b1;
	parameter  [0:0]	OPT_INTERPOLATOR = 1&#39;b1;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The last parameter, &lt;code class=&quot;highlighter-rouge&quot;&gt;GAIN_OFFSET&lt;/code&gt;, controls how far we shift the final result
to the right.  Ideally, this would be 4 if &lt;code class=&quot;highlighter-rouge&quot;&gt;OPT_INTERPOLATOR&lt;/code&gt; would be set in
order to divide by the factor of sixteen shown above.  Sadly, we can’t do that.
In particular, a set of constant maximum negative values surrounding a maximum
positive value, or vice versa, will yield filter results outside of that
incoming range.  Hence, to avoid overflow, we’ll only shift by three bits
(divide by eight), or two for the quadratic fit approaches.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	parameter		GAIN_OFFSET = (OPT_INTERPOLATOR)? 3:2;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The next step is to calculate the bit widths of various portions of this
algorithm.  These are held in local parameters, since they are calculated
from the main parameters above.  The first are the bit widths of the
coefficients,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;			// Bit-Width&#39;s of the quadratic, linear, and constant
			// coefficients
	localparam	AW = (OPT_INTERPOLATOR)?INW+6:INW+2,
			BW = (OPT_INTERPOLATOR)?INW+6:INW+1,
			CW = (OPT_INTERPOLATOR)?INW  :((OPT_IMPROVED_FIT)?(INW+3):INW),&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;followed by the number of bits we’ll have after the decimal place following each
computation,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;			ADEC=(OPT_INTERPOLATOR)? 4:1,
			BDEC=(OPT_INTERPOLATOR)? 4:1,
			CDEC=(OPT_INTERPOLATOR)? 0:((OPT_IMPROVED_FIT)? 3:0);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Remember, any time you want to multiply integers and fractions such as &lt;code class=&quot;highlighter-rouge&quot;&gt;A.B&lt;/code&gt;
times &lt;code class=&quot;highlighter-rouge&quot;&gt;X.Y&lt;/code&gt; (not the decimal place), you’ll need to first move the decimal
place to the far right so as to get &lt;code class=&quot;highlighter-rouge&quot;&gt;2^N(AB.)&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;2^M(XY.)&lt;/code&gt;.  Then, when
you multiply these numbers, you can shift them back to get the result you
were looking for back to where it belongs:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;A.B * X.Y = (AB. * XY.)*2^(-N-M)&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Of course, in practice this just means that we’ll track this resulting
decimal point, as you’ll see through &lt;a href=&quot;https://github.com/ZipCPU/interpolation/blob/master/rtl/quadratic/quadinterp.v&quot;&gt;the
code&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The final local parameter is the width of the internal calculations.
This is the number of bits that we will keep following each multiply.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	localparam	BMW = ((AW-ADEC&amp;gt;BW-BDEC) ? (AW-ADEC+BDEC) : BW);
	localparam	CMW = ((BMW+1-BDEC&amp;gt;CW-CDEC) ? (BMW+1-BDEC+CDEC) : CW);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;With these preliminaries aside, we can finally dig in to the
&lt;a href=&quot;https://github.com/ZipCPU/interpolation/blob/master/rtl/quadratic/quadinterp.v&quot;&gt;implementation&lt;/a&gt;
of our quadratic
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;,
beginning with how we generate the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial&quot;&gt;polynomial&lt;/a&gt;
coefficients themselves.  Since this will change depending upon our
choice of quadratic, we’ll use a generate block to select from among
several logic sets.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	generate if (OPT_INTERPOLATOR)
	begin&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;As our first step, we’ll calculate the shift register of data inputs
and a short history that we discussed above in the last section.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;		always @(posedge i_clk)
		if (i_ce)
			{ mem[3], mem[2], mem[1], mem[0] }
				&amp;lt;= { mem[2], mem[1], mem[0], i_data };&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Let’s take a moment here to discuss &lt;code class=&quot;highlighter-rouge&quot;&gt;i_ce&lt;/code&gt;.  This is the “global CE” signal
from our &lt;a href=&quot;/blog/2017/08/14/strategies-for-pipelining.html&quot;&gt;previous discussion on pipeline
strategies&lt;/a&gt;.
As you may recall from &lt;a href=&quot;/blog/2017/08/14/strategies-for-pipelining.html&quot;&gt;that
discussion&lt;/a&gt;,
the “global CE strategy” is very appropriate for
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_signal_processing&quot;&gt;signal processing&lt;/a&gt;
applications.  Further, you’ll want to remember the rules associated with the
“global CE” signal: &lt;em&gt;Nothing&lt;/em&gt; changes except on the clock that &lt;code class=&quot;highlighter-rouge&quot;&gt;i_ce&lt;/code&gt; is true.
Since this is a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sample-rate_conversion&quot;&gt;resampling&lt;/a&gt;
module, though, we’ll have to extend this rule.  Nothing on the incoming
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;sample&lt;/a&gt;,
rate side changes unless &lt;code class=&quot;highlighter-rouge&quot;&gt;i_ce&lt;/code&gt; is true.
We’ll use another CE signal, &lt;code class=&quot;highlighter-rouge&quot;&gt;r_ce&lt;/code&gt; for the output
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;sample&lt;/a&gt;
side in a moment.&lt;/p&gt;

&lt;p&gt;The next several calculations also follow directly from the last section
as well.  The only difference here is that this time we are applying the
necessary shifts to accomplish the needed “multiplies” from before.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;		always @(posedge i_clk)
		if (i_ce)
		begin
			pmidv &amp;lt;= { mem[0], 3&#39;b000 }
					- { {(3){mem[0][INW-1]}},mem[0]};// x7
			psumn &amp;lt;= { i_data[(INW-1)], i_data }
					+ { mem[1][(INW-1)], mem[1] };
			pdifn &amp;lt;= { i_data[(INW-1)], i_data }
					- { mem[1][(INW-1)], mem[1] };
			//
			sumw &amp;lt;= { mem[3][(INW-1)], mem[3] }
					+ { i_data[(INW-1)], i_data };
			// sumn &amp;lt;= psumn;
			diffn&amp;lt;= { pdifn[INW], pdifn, 2&#39;b00 }
					+ ,pdifn };// x5
			diffw&amp;lt;= { i_data[(INW-1)], i_data }
					- { mem[3][(INW-1)], mem[3] };
			// midv &amp;lt;= pmidv;
			midvpsumn &amp;lt;= -{ pmidv[(INW+2)],pmidv }
					+ { psumn[INW], psumn, 2&#39;h0 };//x7 + x4
		end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;That’s the first two clocks.  Then, on the third clock, we use these
intermediate expressions to generate the actual quadratic coefficients.
Remember, though, the &lt;code class=&quot;highlighter-rouge&quot;&gt;mem[x]&lt;/code&gt; values by this clock have shifted forward by
one extra
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;sample&lt;/a&gt;.
As a result, &lt;code class=&quot;highlighter-rouge&quot;&gt;cv&lt;/code&gt; is set to &lt;code class=&quot;highlighter-rouge&quot;&gt;mem[2]&lt;/code&gt; instead of &lt;code class=&quot;highlighter-rouge&quot;&gt;mem[1]&lt;/code&gt;.
Likewise, the &lt;code class=&quot;highlighter-rouge&quot;&gt;av&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;bv&lt;/code&gt; values here have been multiplied by sixteen
compared to the coefficients we want.  This factor of sixteen will ultimately,
and only partially, be corrected with the &lt;code class=&quot;highlighter-rouge&quot;&gt;GAIN_OFFSET&lt;/code&gt; when we are done.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;		initial	av = 0;
		initial	bv = 0;
		always @(posedge i_clk)
		if (i_ce)
		begin
			// av = x28 + x16 + x2
			// av = - { midv, 2&#39;b00 } + { sumn, 4&#39;h0 } - { sumw, 1&#39;b0 };
			av &amp;lt;= { midvpsumn, 2&#39;b00 }
					- { {(4){sumw[INW]}}, sumw, 1&#39;b0 };
			bv &amp;lt;= { diffn[INW+3],diffn, 1&#39;b0 }
				- { {(5){diffw[INW]}}, diffw };
			cv &amp;lt;= mem[2];
		end

	end else begin&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The next two sections in &lt;a href=&quot;https://github.com/ZipCPU/interpolation/blob/master/rtl/quadratic/quadinterp.v&quot;&gt;the
code&lt;/a&gt;
calculate the coefficients of the quadratic fit and
our non-&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolating&lt;/a&gt;
quadratic.  We’ll skip these here for simplicity, so that we can focus on
today’s quadratic &lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;,
however we’ll show the results of these
&lt;a href=&quot;https://en.wikipedia.org/wiki/Upsamplers&quot;&gt;upsampling&lt;/a&gt;
filters further down.&lt;/p&gt;

&lt;p&gt;At this point, then, we have our three quadratic coefficients, &lt;code class=&quot;highlighter-rouge&quot;&gt;av&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;bv&lt;/code&gt;,
and &lt;code class=&quot;highlighter-rouge&quot;&gt;cv&lt;/code&gt;–regardless of which algorithm generated them.&lt;/p&gt;

&lt;p&gt;We discussed in the last section the need for keeping the coefficients from
the last interval around, so we’ll copy them here.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(posedge i_clk)
	if (i_ce)
	begin
		avold &amp;lt;= av;
		bvold &amp;lt;= bv;
		cvold &amp;lt;= cv;
	end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;We’ll
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sample-rate_conversion&quot;&gt;resample&lt;/a&gt;
our data two clocks following any new incoming data, so let’s
capture that new value here.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(posedge i_clk)
		pre_ce &amp;lt;= i_ce;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;That brings us to calculating when to take our next
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;sample&lt;/a&gt;.
This code should be familiar, as it was lifted from our discussion on
&lt;a href=&quot;/dsp/2017/07/29/series-linear-interpolation.html&quot;&gt;linear interpolators&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;First, we calculate the when of the next
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;sample&lt;/a&gt;
point.  Our &lt;code class=&quot;highlighter-rouge&quot;&gt;t&lt;/code&gt; value is given by this counter.  When the counter overflows,
the next outgoing
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;sample&lt;/a&gt;
will require a new incoming
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;sample&lt;/a&gt;
so we’ll then stop moving forward and wait for that next
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;sample&lt;/a&gt;&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	// ...
	initial	r_ovfl  = 1&#39;b1;
	always @(posedge i_clk)
		if (i_ce)
			{ r_ovfl, r_counter } &amp;lt;= r_counter + i_step;
		else if (!r_ovfl)
			{ r_ovfl, r_counter } &amp;lt;= r_counter + i_step;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;In the end, the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;sample&lt;/a&gt;
indicator is a combination of either following a new
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;sample&lt;/a&gt;
value, or any other
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;sample&lt;/a&gt;
up until the counter overflows.  In this fashion, we’ll
&lt;a href=&quot;https://en.wikipedia.org/wiki/Upsamplers&quot;&gt;upsample&lt;/a&gt;
the incoming data.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	// ...
	initial	r_ce = 1&#39;b0;
	always @(posedge i_clk)
		r_ce &amp;lt;= ((pre_ce)||(!r_ovfl));&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Please feel free to refer back to the &lt;a href=&quot;/dsp/2017/07/29/series-linear-interpolation.html&quot;&gt;linear
interpolator&lt;/a&gt;
series if you find this logic difficult to understand.&lt;/p&gt;

&lt;p&gt;Two steps are left before evaluating the quadratic
&lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial&quot;&gt;polynomial&lt;/a&gt;: calculating &lt;code class=&quot;highlighter-rouge&quot;&gt;t&lt;/code&gt;,
and switching our coefficients so that the quadratic function we create
&lt;em&gt;surrounds&lt;/em&gt; our incoming data point. This accomplishes the transformation
illustrated in Fig 12 above.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(posedge i_clk)
	if (r_ce)
		pre_offset &amp;lt;= r_counter[(CTRBITS-1):(CTRBITS-MP)];

	// ...
	always @(posedge i_clk)
		if (r_ce)
		begin
			r_offset &amp;lt;= { pre_offset[MP-1], pre_offset[(MP-2):0] };
			if (pre_offset[(MP-1)])
			begin
				r_av &amp;lt;= av;
				r_bv &amp;lt;= bv;
				r_cv &amp;lt;= cv;
			end else begin
				r_av &amp;lt;= avold;
				r_bv &amp;lt;= bvold;
				r_cv &amp;lt;= cvold;
			end
		end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;At this point we now have our quadratic coefficients, &lt;code class=&quot;highlighter-rouge&quot;&gt;r_av&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;r_bv&lt;/code&gt;, and
&lt;code class=&quot;highlighter-rouge&quot;&gt;r_cv&lt;/code&gt;, together with our time offset, &lt;code class=&quot;highlighter-rouge&quot;&gt;r_offset&lt;/code&gt;.  These are the coefficients
of the quadratic we wish to evaluate.  Indeed, at this point all of the
difficult stuff is done.  All that remains is to handle the quadratic
evaluation itself.&lt;/p&gt;

&lt;p&gt;The first step is to multiply &lt;code class=&quot;highlighter-rouge&quot;&gt;a&lt;/code&gt; by &lt;code class=&quot;highlighter-rouge&quot;&gt;t&lt;/code&gt;.  To keep everything else aligned,
we’ll forward all of our other coefficients to the next clock.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(posedge i_clk)
	if (r_ce)
	begin
		qp_quad  &amp;lt;= r_av * r_offset;	// * 2^(-MP-ADEC)
		qp_bv    &amp;lt;= r_bv;		// * 2^(-BDEC)
		qp_cv    &amp;lt;= r_cv;		// * 2^(-CDEC)
		qp_offset&amp;lt;= r_offset;		// * 2^(-MP)
	end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Many FPGA’s have dedicated multiply accumulate capability in their
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_signal_processing&quot;&gt;DSP&lt;/a&gt;
hardware.  Such a capability would allow
us to calculate &lt;code class=&quot;highlighter-rouge&quot;&gt;r_av * r_offset + r_bv&lt;/code&gt;–with an appropriate bit select
along the way.  For right or wrong, this has never been my coding practice.
Perhaps I just want more control of the operation.  Either way, I will often
split these two calculations into two separate clocks.  That’s why we aren’t
adding the &lt;code class=&quot;highlighter-rouge&quot;&gt;bv&lt;/code&gt; coefficient to this multiplication result in this clock.&lt;/p&gt;

&lt;p&gt;Before the next step, let’s consider what we have.  We have three numbers,
with decimal points in varying locations.  &lt;code class=&quot;highlighter-rouge&quot;&gt;r_av&lt;/code&gt; for example has &lt;code class=&quot;highlighter-rouge&quot;&gt;ADEC&lt;/code&gt;
bits following the decimal point, and we just multiplied it by a value, &lt;code class=&quot;highlighter-rouge&quot;&gt;t&lt;/code&gt;,
all of whose bits were to the right of the decimal point.  Hence, we now
have &lt;code class=&quot;highlighter-rouge&quot;&gt;(MP+ADEC)&lt;/code&gt; bits following our decimal point in a number that is
&lt;code class=&quot;highlighter-rouge&quot;&gt;AW&lt;/code&gt; bits wide.  Let’s keep track of this decimal point as well as the
decimal point for &lt;code class=&quot;highlighter-rouge&quot;&gt;qb_bv&lt;/code&gt; in our notes.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	// qp_quad (AW-ADEC).(MP+ADEC)
	// qb_bv   (BW-BDEC).(BDEC)&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;We are now going to want to add the results of this multiply to our &lt;code class=&quot;highlighter-rouge&quot;&gt;b&lt;/code&gt;
coefficient in our next step.  To do this though, we’re going to first
need to normalize
both values so that they have the same number of decimal points.
In spite of the ugly looking code below, we’re just dropping the extra
bits off the bottom.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	// lw_quad (BW-BDEC).(BDEC)
	assign	lw_quad = { {(BMW-(AW+MP-(MP+ADEC-BDEC))){qp_quad[(AW+MP-1)]}},
				qp_quad[(AW+MP-1):(MP+ADEC-BDEC)] };&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Hence, we just shifted &lt;code class=&quot;highlighter-rouge&quot;&gt;qp_quad&lt;/code&gt; down by &lt;code class=&quot;highlighter-rouge&quot;&gt;(MP+ADEC-BDEC)&lt;/code&gt; binary decimal points,
so that it now has &lt;code class=&quot;highlighter-rouge&quot;&gt;BDEC&lt;/code&gt; bits following the decimal instead of &lt;code class=&quot;highlighter-rouge&quot;&gt;MP+ADEC&lt;/code&gt;.
The result, &lt;code class=&quot;highlighter-rouge&quot;&gt;lw_quad&lt;/code&gt;, now has the same number of decimal places as
&lt;code class=&quot;highlighter-rouge&quot;&gt;qp_bv&lt;/code&gt;, so we can now add these two numbers together.  As before, we’ll
forward the constants we haven’t yet used to the next clock cycle.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(posedge i_clk)
	if (r_ce)
	begin
		// ...
		ls_bv    &amp;lt;= { { (BMW+1-BW){qp_bv[BW-1] } }, qp_bv }
				+ { lw_quad[BMW-1], lw_quad };
		ls_cv    &amp;lt;= qp_cv;
		ls_offset&amp;lt;= qp_offset;
	end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;As a next step, we’ll calculate &lt;code class=&quot;highlighter-rouge&quot;&gt;(a*t+b)*t&lt;/code&gt; and place the result into &lt;code class=&quot;highlighter-rouge&quot;&gt;lp_bv&lt;/code&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(posedge i_clk)
	if (r_ce)
	begin
		lp_bv    &amp;lt;= ls_bv * ls_offset;	// * 2^(-MP-BDEC)
		lp_cv    &amp;lt;= ls_cv;		// * 2^(-   CDEC)
	end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;As before, we keep track of our decimal points at this step.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	// lp_bv (BMW+1-BDEC).(BDEC+MP)
	// lp_cv    (CW-CDEC).(CDEC)&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This helps us to know how much to shift &lt;code class=&quot;highlighter-rouge&quot;&gt;lp_bv&lt;/code&gt; by in order to align it with
&lt;code class=&quot;highlighter-rouge&quot;&gt;lp_cv&lt;/code&gt; so that the two can be added in the next step.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	wire	signed	[(CMW-1):0]	wp_bv;
	assign	wp_bv = { lp_bv[(BMW+MP):(MP+BDEC-CDEC)] };&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This brings us to the last part of calculating the quadratic, adding the
constant to the final result.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(posedge i_clk)
	if (r_ce)
		r_done &amp;lt;= { wp_bv[CMW-1], wp_bv }
				 + , lp_cv};&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;And we’re done!&lt;/p&gt;

&lt;p&gt;Okay, not quite.  We still need to drop a bunch of bits.
As &lt;a href=&quot;/dsp/2017/07/22/rounding.html&quot;&gt;we discussed earlier&lt;/a&gt;,
there’s a right and a wrong way to do drop bits in a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_signal_processing&quot;&gt;DSP&lt;/a&gt;
algorithm.  Hence, we’ll round towards the nearest even integer here
and then throw the rest of the bits away.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	generate if (CMW+1-GAIN_OFFSET &amp;gt; OWID)
	begin

		reg	[CMW-GAIN_OFFSET:0]	rounded;

		initial rounded = 0;
		always @(posedge i_clk)
		if (r_ce)
			rounded &amp;lt;= r_done[(CMW-GAIN_OFFSET):0]
				+ { {(OWID){1&#39;b0}},
					r_done[CMW-GAIN_OFFSET-OWID],
				{(CMW-OWID-GAIN_OFFSET-1)
					{!r_done[CMW-GAIN_OFFSET-OWID]}} };

		assign	o_data = rounded[(CMW-GAIN_OFFSET)
					:(CMW+1-GAIN_OFFSET-OWID)];&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The &lt;a href=&quot;https://github.com/ZipCPU/interpolation/blob/master/rtl/quadratic/quadinterp.v&quot;&gt;code&lt;/a&gt;
contains two other non-rounding choices, which we shall skip here
in our discussion.&lt;/p&gt;

&lt;p&gt;The final step is to note when this output is valid.  This involves
forwarding our new &lt;a href=&quot;/blog/2017/08/14/strategies-for-pipelining.html&quot;&gt;global CE pipeline control
signal&lt;/a&gt;
to the output.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	// ...
	end endgenerate

	assign	o_ce = r_ce;

	// ...
endmodule&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;At this, we are now done and our
&lt;a href=&quot;https://github.com/ZipCPU/interpolation/blob/master/rtl/quadratic/quadinterp.v&quot;&gt;code&lt;/a&gt;
is complete.  But does it work?  Let’s see in the next section.&lt;/p&gt;

&lt;h2 id=&quot;the-proof&quot;&gt;The Proof&lt;/h2&gt;

&lt;p&gt;I’ve always counseled individuals not to use a tool they aren’t familiar with.
Every tool in the shed has its purpose, its capabilities, and its limitations.
This &lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;
is no different from any other tool in that sense.  To see how well, or
poorly, this quadratic
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;
works, let’s test it.  In particular, we can sweep a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sine_wave&quot;&gt;sine wave&lt;/a&gt;
through the input and see what happens.  Further, let’s compare this
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;
with four different
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolation&lt;/a&gt;
methods:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Our first method will be the simple &lt;a href=&quot;/dsp/2017/06/06/simple-interpolator.html&quot;&gt;sample and hold
circuit&lt;/a&gt; we
presented earlier.  Since the code within this module doesn’t really handle
&lt;a href=&quot;https://en.wikipedia.org/wiki/Upsamplers&quot;&gt;upsampling&lt;/a&gt;, we’ll use the &lt;a href=&quot;/blog/2017/08/14/strategies-for-pipelining.html&quot;&gt;global
CE&lt;/a&gt;
from the other
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolators&lt;/a&gt;
to know when to capture this output.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The second method will be a straight-forward
&lt;a href=&quot;/dsp/2017/07/29/series-linear-interpolation.html&quot;&gt;linear interpolator&lt;/a&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Our third choice will be the quadratic fit we developed above, allowing
you to see just how good, or poor, this
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt; is in practice.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;We’ll then use the nice quadratic
&lt;a href=&quot;https://en.wikipedia.org/wiki/Upsamplers&quot;&gt;upsampler&lt;/a&gt; from above,
the one that we chose to call the
non-&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The final test algorithm is today’s quadratic
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt; algorithm.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;While I won’t walk you through the test code (today), I will post it with the
rest of the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;’s
&lt;a href=&quot;https://github.com/ZipCPU/interpolation/blob/master/rtl/quadratic/quadinterp.v&quot;&gt;code&lt;/a&gt;
in my &lt;a href=&quot;https://github.com/ZipCPU/interpolation&quot;&gt;interpolation repository&lt;/a&gt;.
If you are interested in this test code, check out the
&lt;a href=&quot;https://github.com/ZipCPU/interpolation/tree/master/bench&quot;&gt;bench&lt;/a&gt;
subdirectories.  There you will find a &lt;a href=&quot;https://github.com/ZipCPU/interpolation/blob/master/bench/rtl/icomparison.v&quot;&gt;master Verilog
module&lt;/a&gt;
that instantiates examples of all of the filters below, as well as a &lt;a href=&quot;https://github.com/ZipCPU/interpolation/blob/master/bench/cpp/icompare.cpp&quot;&gt;Verilator
based C++&lt;/a&gt;
program that will exercise these filters and write the outputs to a data file.
Finally, there’s a &lt;a href=&quot;https://github.com/ZipCPU/interpolation/blob/master/bench/cpp/plotem.m&quot;&gt;Octave
script&lt;/a&gt;
that can be used to plot these results.&lt;/p&gt;

&lt;p&gt;Sadly, the resulting data is too voluminous to plot in its entirety here,
so I’ll just pick some useful and revealing sections of this data for
discussion.&lt;/p&gt;

&lt;p&gt;For four first example, let’s compare how these
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolation&lt;/a&gt;
functions perform for a low frequency
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sine_wave&quot;&gt;sine wave&lt;/a&gt;.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 13. Low frequency interpolation&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/quadeqn-result-lo.png&quot; alt=&quot;&quot; width=&quot;581&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;By visual inspection alone, most of the quadratic
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolators&lt;/a&gt;
did pretty well.  Even the linear
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;
seems to be tracking the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sine_wave&quot;&gt;sine wave&lt;/a&gt;.
quite nicely.&lt;/p&gt;

&lt;p&gt;If you look even closer, though, you may notice some minor discontinuities
in the quadratic fit, or locations where the quadratic
non-&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;
doesn’t go through the given
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;sample&lt;/a&gt;
points.  These effects are minimal at this low frequency, but they are present.&lt;/p&gt;

&lt;p&gt;So, let’s increase the frequency.&lt;/p&gt;

&lt;p&gt;Fig 14 below shows the same
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sine_wave&quot;&gt;sine wave&lt;/a&gt;,
but this time with a frequency between &lt;code class=&quot;highlighter-rouge&quot;&gt;0.25&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;0.3&lt;/code&gt; cycles per sample.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 14. Higher frequency interpolation&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/quadeqn-result-hi.png&quot; alt=&quot;&quot; width=&quot;582&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Here the differences become very stark.  The quadratic fit’s discontinuities
are much larger, and the
non-&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;
is clearly missing the input
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;sample&lt;/a&gt;
points.&lt;/p&gt;

&lt;p&gt;If you look closer, you may even see some kinks in the quadratic
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt; we just built.
These are a result of the fact that, although this
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt; is
&lt;a href=&quot;https://en.wikipedia.org/wiki/Continuous_function&quot;&gt;continuous&lt;/a&gt;,
it is not
&lt;a href=&quot;https://en.wikipedia.org/wiki/Continuous_function&quot;&gt;continuous&lt;/a&gt;
in its first derivative.  Achieving that result will take more work–something
we’ll leave for another day.  Even still, though, this is probably good enough
for most purposes at this frequency.&lt;/p&gt;

&lt;p&gt;What about a higher frequency?  Why not push both of these
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolators&lt;/a&gt;
until they completely break down near the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Nyquist_frequency&quot;&gt;Nyquist frequency&lt;/a&gt;?&lt;/p&gt;

&lt;p&gt;That’s the purpose of the next figure, Fig 15.  In this figure, the incoming
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sine_wave&quot;&gt;sine wave&lt;/a&gt; is
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;sampled&lt;/a&gt;
right near the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Nyquist_frequency&quot;&gt;Nyquist cutoff frequency&lt;/a&gt;
of two samples per cycle.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 15. Interpolation near Nyquist&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/quadeqn-result-aliased.png&quot; alt=&quot;&quot; width=&quot;584&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Judging from the images above, it looks like the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolators&lt;/a&gt;
are tracking the outline of a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sine_wave&quot;&gt;sine wave&lt;/a&gt;
multiplied by some kind of envelope.  The
incoming signal, however, had no envelope function constraining it.  Indeed,
the incoming signal was nothing but a straight
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sine_wave&quot;&gt;sine wave&lt;/a&gt;.  Instead, this
apparent “envelope” is the result of undersampling a high frequency
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sine_wave&quot;&gt;sine wave&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Which &lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;
is better in this environment?  I might argue that none of them work well
this close to the &lt;a href=&quot;https://en.wikipedia.org/wiki/Nyquist_frequency&quot;&gt;Nyquist
frequency&lt;/a&gt;,
and that instead this final example frequency is really beyond their
capability.  This isn’t to say that better
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolators&lt;/a&gt;
do not exist, or that they cannot be developed.  Rather, it is simply a
statement of the reality that any
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;
will break down as it approaches the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Nyquist_frequency&quot;&gt;Nyquist frequency&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;For just the cost of a couple multiplies, several additions and bit selects,
and quite a few flip-flops, we’ve managed to implement a better
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;.
This &lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;
is better than a &lt;a href=&quot;/dsp/2017/06/06/simple-interpolator.html&quot;&gt;sample and
hold&lt;/a&gt;,
better than a
&lt;a href=&quot;/dsp/2017/07/29/series-linear-interpolation.html&quot;&gt;linear interpolator&lt;/a&gt;,
and even better than the straight forward quadratic fit we started with.
Further, unlike the more traditional
&lt;a href=&quot;http://ieeexplore.ieee.org/document/15483/&quot;&gt;Farrow&lt;/a&gt;
filter development, the output of the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sample-rate_conversion&quot;&gt;resampler&lt;/a&gt;
created by &lt;a href=&quot;https://github.com/ZipCPU/interpolation/blob/master/rtl/quadratic/quadinterp.v&quot;&gt;this interpolator&lt;/a&gt;
is actually constrained to go through the input samples.&lt;/p&gt;

&lt;p&gt;Does this mean that this is the best approach to
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolation&lt;/a&gt;?
By no means.  While &lt;a href=&quot;https://github.com/ZipCPU/interpolation/blob/master/rtl/quadratic/quadinterp.v&quot;&gt;this
solution&lt;/a&gt;
has some nice properties associated with it, it has no optimality properties.
In that sense, it’s just another ad-hoc development in a similar vein to
&lt;a href=&quot;http://ieeexplore.ieee.org/document/15483/&quot;&gt;Farrow&lt;/a&gt;’s.&lt;/p&gt;

&lt;p&gt;As with everything, though, you get want you pay for.  Better
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolators&lt;/a&gt; of this
variety exist, but they do cost more.  For example, there’s another filter like
this one documented in my &lt;a href=&quot;https://github.com/ZipCPU/interpolation/raw/master/tutorial.pdf&quot;&gt;interpolation
tutorial&lt;/a&gt;,
although the coefficient multiplies are too difficult to do with just adds
and subtracts.  Indeed, they require a divide by 80!  Another approach is to use
&lt;a href=&quot;https://en.wikipedia.org/wiki/Spline_interpolation&quot;&gt;spline&lt;/a&gt; interpolation.
You may remember my earlier suggestion that
&lt;a href=&quot;https://en.wikipedia.org/wiki/Spline_interpolation&quot;&gt;spline&lt;/a&gt; interpolation could
be done without calculating a new matrix solution for every data point.&lt;/p&gt;

&lt;!-- Mention: Asynchronous Sample Rate Conversion? --&gt;

&lt;p&gt;This, though, will need to be a discussion for another day.&lt;/p&gt;
&lt;hr /&gt;&lt;p&gt;&lt;em&gt;And he spake also a parable unto them; No man putteth a piece of a new garment upon an old; if otherwise, then both the new maketh a rent, and the piece that was taken out of the new agreeth not with the old. (Luke 5:36)&lt;/em&gt;</description>
        <pubDate>Fri, 30 Mar 2018 00:00:00 -0400</pubDate>
        <link>https://zipcpu.com/dsp/2018/03/30/quadratic.html</link>
        <guid isPermaLink="true">https://zipcpu.com/dsp/2018/03/30/quadratic.html</guid>
        
        
        <category>dsp</category>
        
      </item>
    
  </channel>
</rss>
