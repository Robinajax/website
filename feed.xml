<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>The ZipCPU by Gisselquist Technology</title>
    <description>The ZipCPU blog, featuring how to discussions of FPGA and soft-core CPU design.  This site will be focused on Verilog solutions, using exclusively OpenSource IP products for FPGA design.  Particular focus areas include topics often left out of more mainstream FPGA design courses such as how to debug an FPGA design.
</description>
    <link>https://zipcpu.com/</link>
    <atom:link href="https://zipcpu.com/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Tue, 18 Sep 2018 11:12:15 -0400</pubDate>
    <lastBuildDate>Tue, 18 Sep 2018 11:12:15 -0400</lastBuildDate>
    <generator>Jekyll v3.0.1</generator>
    <image>
      <url>https://zipcpu.com/img/gt-rss.png</url>
      <title></title>
      <link></link>
    </image>
    
      <item>
        <title>It&#39;s time for ORCONF 2018!</title>
        <description>&lt;p&gt;It’s time again for &lt;a href=&quot;https://orconf.org&quot;&gt;ORCONF&lt;/a&gt;!  For those who are not
familiar with &lt;a href=&quot;https://orconf.org&quot;&gt;ORCONF&lt;/a&gt;, I like to think of it as the
premier conference discussing &lt;a href=&quot;https://fossi-foundation.org&quot;&gt;Free and Open Source Silicon
(FOSSI)&lt;/a&gt;.  You can read more about the
&lt;a href=&quot;https://orconf.org&quot;&gt;conference here&lt;/a&gt;, or even read the &lt;a href=&quot;https://orconf.org/#presentations&quot;&gt;abstracts of the
presentations here&lt;/a&gt;,
although this latter link is likely to go stale before ORCONF-2019.
&lt;a href=&quot;https://orconf.org&quot;&gt;ORCONF&lt;/a&gt; tends to be a small conference, and nothing like
the giant IEEE conferences I’ve been to in the past.  I see this as a good
thing, because it means I will actually have a chance to meet and say hello
to everyone there.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/verilator_256_200_min.png&quot; alt=&quot;&quot; width=&quot;256&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;This year, among the many wonderful presentations that I lined up, I am
especially looking forward to &lt;a href=&quot;https://www.veripool.org/users/3&quot;&gt;Wilson
Snyder&lt;/a&gt;’s presentation on a multithreaded
version of &lt;a href=&quot;https://www.veripool.org/projects/verilator/wiki/Intro&quot;&gt;Verilator&lt;/a&gt;.
That could really transform my simulations!&lt;/p&gt;

&lt;p&gt;Here’s his abstract:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;a href=&quot;https://www.veripool.org/wiki/verilator&quot;&gt;Verilator&lt;/a&gt; 4.0 - Open Simulation Goes Multithreaded&lt;/p&gt;

  &lt;p&gt;The primary author of
&lt;a href=&quot;https://www.veripool.org/wiki/verilator&quot;&gt;Verilator&lt;/a&gt;, the open source
high-speed Verilog simulator, announces fresh for this meeting
&lt;a href=&quot;https://www.veripool.org/wiki/verilator&quot;&gt;Verilator&lt;/a&gt; 4.0 with
multithreading, and how you can get your designs the fast(est),
free simulation.&lt;/p&gt;

  &lt;p&gt;Presented by &lt;a href=&quot;https://www.veripool.org/users/3&quot;&gt;Wilson Snyder&lt;/a&gt;, one of the
primary authors of Verilator.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/orconf-2018-title.png&quot; alt=&quot;&quot; width=&quot;360&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;I will also be presenting this year, as I have the last two.  My title is:
Lessons learned while formally verifying the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;The &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; is a three-year old CPU
and &lt;a href=&quot;/zipcpu/2018/01/01/zipcpu-isa.html&quot;&gt;ISA&lt;/a&gt; designed for
low logic FPGA’s.  One of the challenges of any CPU design, to include the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;, is coming up with a
sufficiently robust test suite to exercise all of the possible logic flows
within &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.html&quot;&gt;the CPU&lt;/a&gt;.  While &lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal
methods&lt;/a&gt; can be used
for this task, they are traditionally viewed as too computationally
expensive to formally verify something as complex as a &lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;.&lt;/p&gt;

  &lt;p&gt;Contrary to this view, the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
has now been formally verified using
&lt;a href=&quot;https://symbiyosys.readthedocs.io/en/latest&quot;&gt;SymbiYosys&lt;/a&gt;.  As a result,
&lt;a href=&quot;/blog/2018/04/02/formal-cpu-bugs.html&quot;&gt;many bugs have been found and
fixed&lt;/a&gt;-bugs not
found previously using &lt;a href=&quot;/zipcpu/2018/02/12/zbasic-intro.html&quot;&gt;canned test
cases&lt;/a&gt;.  Not only
that, it has also &lt;a href=&quot;/formal/2018/07/21/zipcpu-icoboard.html&quot;&gt;become easier to
modify&lt;/a&gt; &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;the core
CPU&lt;/a&gt; as
necessary to achieve lower logic utilization, knowing that the solver will
find any bugs in the updated implementations.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;If you haven’t chosen to join us at &lt;a href=&quot;https://orconf.org&quot;&gt;ORCONF&lt;/a&gt;, then rest
assured the staff are really good at posting the various presentations later.
I will also post a copy of my slides on GitHub and link to them here, &lt;a href=&quot;/blog/2017/09/12/orconf-2017-return-home.html&quot;&gt;as I
did last year&lt;/a&gt;.
This is a small consolation, though, for missing the richness of actually
meeting and discussing digital design topics with the likes of those who
will be attending, or the opportunity to ask questions of the speakers.&lt;/p&gt;

&lt;p&gt;On the other hand, if you will be joining us, then please take a moment to
introduce yourself!  I’d love to have the opportunity to meet those who
have encouraged me over the last couple of years.&lt;/p&gt;
&lt;hr /&gt;&lt;p&gt;&lt;em&gt;Making request, if by any means now at length I might have a prosperous journey by the will of God to come unto you.  (Rom 1:10)&lt;/em&gt;</description>
        <pubDate>Tue, 18 Sep 2018 00:00:00 -0400</pubDate>
        <link>https://zipcpu.com/blog/2018/09/18/orconf-2018.html</link>
        <guid isPermaLink="true">https://zipcpu.com/blog/2018/09/18/orconf-2018.html</guid>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>My design works in simulation, but not in hardware.  Can formal methods help me?</title>
        <description>&lt;p&gt;It’s not uncommon in &lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
design to have a design that “works in simulation”, but fails the ultimate test
in hardware.  I might argue that within
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
designs, this is almost cliche.  While I’d like to blame the problem on
poor test design, it can also happen with &lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal
methods&lt;/a&gt; if you haven’t
fully verified your design.&lt;/p&gt;

&lt;p&gt;Since this happens more often that I’d like to admit, let’s ask the question
of whether or not &lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal
methods&lt;/a&gt; can help find a bug
within an &lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
design that is built, complete, loaded onto a piece of hardware, and yet
doesn’t work.&lt;/p&gt;

&lt;p&gt;The immediate answer shouldn’t surprise anyone: It depends.  Sometimes
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal methods&lt;/a&gt;
can help, sometimes they can’t.&lt;/p&gt;

&lt;p&gt;For example, if you look through my &lt;a href=&quot;/blog/2018/08/04/sim-mismatch.html&quot;&gt;list of reasons why a design might
pass simulation, but still fail in
hardware&lt;/a&gt;, you’ll
see several situations where &lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal
methods&lt;/a&gt; aren’t going to
help much.  A classic example would be “timing problems.”  While &lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal
methods&lt;/a&gt; can help
when you are crossing clock domains, they can’t do as much to help when logic
within your implemented design can’t make it from one
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flip-flop_(electronics)&quot;&gt;FF&lt;/a&gt; to the next
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flip-flop_(electronics)&quot;&gt;FF&lt;/a&gt;
within a single clock period.  In a similar manner, &lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal
methods&lt;/a&gt; aren’t going to help
when you haven’t handled your I/O timing well.&lt;/p&gt;

&lt;p&gt;Where &lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal methods&lt;/a&gt; &lt;em&gt;can&lt;/em&gt;
help is in eliminating possible causes of problems.&lt;/p&gt;

&lt;p&gt;For example, I recently tried to run my &lt;a href=&quot;https://github.com/ZipCPU/tttt&quot;&gt;4x4x4 Tic-Tac-Toe
game&lt;/a&gt; on the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
within an &lt;a href=&quot;http://www.icoboard.org&quot;&gt;ICO board&lt;/a&gt;.
Much to my dismay, &lt;a href=&quot;https://github.com/ZipCPU/icozip&quot;&gt;my design&lt;/a&gt; didn’t load
onto the board properly.  Digging deeper, I discovered that read and write
requests of the &lt;a href=&quot;https://github.com/ZipCPU/dbgbus/blob/master/hexbus/README.md&quot;&gt;debugging
bus&lt;/a&gt;
were missing their acknowledgments.  I struggled to figure out what was going
on.  Where should I even look for the problem?&lt;/p&gt;

&lt;p&gt;In this example, &lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal
methods&lt;/a&gt; were able to
help me.  Let me outline three ways in which &lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal
methods&lt;/a&gt; can help in such
a case, and then tell you what I found.  Using
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal methods&lt;/a&gt;, you can …&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Build a better test bench&lt;/p&gt;

    &lt;p&gt;One of the reasons why I got involved in &lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal
methods&lt;/a&gt; in the first
place was because my test bench authoring methods were just too poor to be
complete.  I’ve since replaced my individual test benches with proofs using
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal methods&lt;/a&gt;.  These
tend to be of a higher quality, and they tend to find more bugs.&lt;/p&gt;

    &lt;p&gt;While saying you should build a better bench test is sort of like saying
you should’ve built in right in the first place, it can help to go back
and thoroughly examine a component that you think might have faults within
it.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;“Cover” the problem&lt;/p&gt;

    &lt;p&gt;Once you see a problem in your logic within hardware, sometimes it helps
to &lt;code class=&quot;highlighter-rouge&quot;&gt;cover&lt;/code&gt; the situation.  In this case, you would pick a component, and
describe within that component a situation that you think is happening
in hardware.  If you then &lt;code class=&quot;highlighter-rouge&quot;&gt;cover()&lt;/code&gt; that situation, you can then get a trace
showing how your design might get into that situation.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Assert the problem will never happen&lt;/p&gt;

    &lt;p&gt;Alternatively, if the state the design gets into is an “illegal state”
that it should never get into, then it might help to &lt;code class=&quot;highlighter-rouge&quot;&gt;assert()&lt;/code&gt; that it
should never happen.  For example, if your design outputs values one and
three but skips the second value, then you can make an assertion that it
will never skip values and see if you can formally prove that assertion.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;In the case I outlined above, I had a two sides of an interface I was working
with.  To illustrate, consider Fig 1 below.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 1: ICO Board Parallel Port bug&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/ico-pport-bug.svg&quot; alt=&quot;&quot; width=&quot;640&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;One side of this interface had my
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
logic on it, and the other side contained
&lt;a href=&quot;https://github.com/ZipCPU/icozip/blob/master/sw/host/netpport.cpp&quot;&gt;software&lt;/a&gt;
on a &lt;a href=&quot;https://www.raspberrypi.org&quot;&gt;Raspberry Pi&lt;/a&gt;.  By inspection, I could see
that data was getting dropped in the interface.  But which side was at fault?&lt;/p&gt;

&lt;p&gt;Perhaps you might remember the module of interest on the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;: it was the
same &lt;a href=&quot;https://github.com/ZipCPU/dbgbus/blob/master/hexbus/README.md&quot;&gt;debugging bus
core&lt;/a&gt; we built here
on the blog before I discovered &lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal
methods&lt;/a&gt;.  Since
it had never been
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formally verified&lt;/a&gt;, I
&lt;em&gt;suspected&lt;/em&gt; a fault within it.&lt;/p&gt;

&lt;p&gt;If you remember the
&lt;a href=&quot;https://github.com/ZipCPU/dbgbus/blob/master/hexbus/README.md&quot;&gt;design&lt;/a&gt;
from when we built it, the return data path following the &lt;a href=&quot;https://github.com/ZipCPU/dbgbus/blob/master/hexbus/rtl/hbexec.v&quot;&gt;bus
request&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/dbgbus/blob/master/hexbus/rtl/hbbus.v&quot;&gt;consisted of a series of separate
stages&lt;/a&gt;, each
with back pressure.  In other words,
each stage was given a stall signal from the next stage, and generated a stall
signal for the prior stage.  Similarly, each stage created a data valid
signal I called a “strobe”.  Together with this data valid signal was data
that should be output from the stage.
I’ve written about this &lt;a href=&quot;/blog/2017/08/14/strategies-for-pipelining.html&quot;&gt;pipelining strategy
before&lt;/a&gt;,
calling it the &lt;a href=&quot;/blog/2017/08/14/strategies-for-pipelining.html&quot;&gt;“travelling CE”
strategy&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;This was one obvious place where data might be lost.&lt;/p&gt;

&lt;p&gt;I simply wanted to verify that no data would ever be lost in the pipeline.&lt;/p&gt;

&lt;p&gt;Therefore I went through all of the stages within the interface, and added
an assertion between the various stages: if the current stage was producing a
valid output but the next stage was busy, then the same data should still be
valid on the next clock.  No changes were allowed, and data was not allowed
to be dropped.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
if ((f_past_valid)&amp;amp;&amp;amp;($past(i_busy))&amp;amp;&amp;amp;($past(o_valid)))
begin
	assert(o_valid);
	assert($stable(o_data));
end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Of course, this assertion didn’t pass at first.  When I dug further, I found
some race conditions within my code.  I also found a couple of cases where a
value would be created by one of the stages, but yet it was designed to be
pre-empted should a newer value show up.  So I spent a bit of time to &lt;a href=&quot;https://github.com/ZipCPU/icozip/blob/master/rtl/hexbus/&quot;&gt;clean
up the code and my
properties&lt;/a&gt;,
and eventually it passed &lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;forma
 verification&lt;/a&gt; through
and through.&lt;/p&gt;

&lt;p&gt;The only problem was this interface still didn’t work, and hence I still
couldn’t play &lt;a href=&quot;https://github.com/ZipCPU/tttt&quot;&gt;4x4x4 tic-tac-toe&lt;/a&gt;
using the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; on the
&lt;a href=&quot;http://www.icoboard.org&quot;&gt;icoboard&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;This time, though, I now knew that my
&lt;a href=&quot;https://github.com/ZipCPU/dbgbus/blob/master/hexbus/README.md&quot;&gt;debugging bus&lt;/a&gt;
would &lt;em&gt;NEVER&lt;/em&gt; skip data words.&lt;/p&gt;

&lt;p&gt;That meant the problem had to lie within the
&lt;a href=&quot;https://www.raspberrypi.org&quot;&gt;Raspberry Pi&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/icozip/blob/master/sw/host/netpport.cpp&quot;&gt;code&lt;/a&gt;.
Sure enough, I found something similar to the following logic.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;n&quot;&gt;data_read&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;read_data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;number_requested&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;buffer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;iterations&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MAX_ITERATIONS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data_read&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;//
&lt;/span&gt;	&lt;span class=&quot;c1&quot;&gt;// Process the data
&lt;/span&gt;	&lt;span class=&quot;c1&quot;&gt;//
&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;// Read the next data
&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;data_read&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;read_data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;number_requested&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;buffer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This was supposed to read the data from my device and process it.  To keep the
routine from hanging, it would only repeat the loop &lt;code class=&quot;highlighter-rouge&quot;&gt;MAX_ITERATIONS&lt;/code&gt; times.&lt;/p&gt;

&lt;p&gt;See the bug?&lt;/p&gt;

&lt;p&gt;And to think, I was chasing this all over my
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
design wondering what was going wrong.  Once I
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formally verified&lt;/a&gt; through
the relevant portions of my
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt; code, I
was able to stop chasing phantoms and move quickly to the real problem.&lt;/p&gt;

&lt;p&gt;My point is here is simply this: &lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal
methods&lt;/a&gt; can still help–even
when the design is already implemented in (and failing in) hardware.&lt;/p&gt;

&lt;hr /&gt;&lt;p&gt;&lt;em&gt;Howbeit this kind goeth not out but by prayer and fasting. (Matt 17:21)&lt;/em&gt;</description>
        <pubDate>Sat, 08 Sep 2018 00:00:00 -0400</pubDate>
        <link>https://zipcpu.com/formal/2018/09/08/hw-failure.html</link>
        <guid isPermaLink="true">https://zipcpu.com/formal/2018/09/08/hw-failure.html</guid>
        
        
        <category>formal</category>
        
      </item>
    
      <item>
        <title>Handling multiple clocks with Verilator</title>
        <description>&lt;p&gt;For some reason, every time I’ve ever worked with video I’ve never managed to
be fortunate enough to have the same clock rate for both the pixel clock
and the memory.  The closest I came was using a 25MHz pixel clock on the
&lt;a href=&quot;https://store.digilentinc.com/basys-3-artix-7-fpga-trainer-board-recommended-for-introductory-users&quot;&gt;Basys3 board&lt;/a&gt;
which I could create by dividing a &lt;a href=&quot;https://reference.digilentinc.com/reference/programmable-logic/basys-3/reference-manual&quot;&gt;100MHz clock by
four&lt;/a&gt;
in logic.  While that probably wasn’t the best way to do it, I did manage to
successfully create a 640x480 image on my test display.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 1. A Nexys Video Board&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/nexys-video.png&quot; alt=&quot;&quot; width=&quot;473&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;When I moved on to the more serious pixel clock of 148.5 MHz in my
&lt;a href=&quot;https://github.com/ZipCPU/videozip&quot;&gt;VideoZip project&lt;/a&gt; using the
&lt;a href=&quot;https://store.digilentinc.com/nexys-video-artix-7-fpga-trainer-board-for-multimedia-applications&quot;&gt;Nexys Video board&lt;/a&gt;,
I could no longer manipulate my 100MHz system clock in logic to generate a
148.5MHz pixel clock.  &lt;a href=&quot;https://www.xilinx.com&quot;&gt;Xilinx&lt;/a&gt;’s DDR3 memory
controller insisted on a clock of 100MHz, so I was stuck needing to deal with
two dissimilar clocks.&lt;/p&gt;

&lt;p&gt;Up until &lt;a href=&quot;https://github.com/ZipCPU/videozip&quot;&gt;that project&lt;/a&gt;, I had never
used more than one clock with
&lt;a href=&quot;https://www.veripool.org/wiki/verilator&quot;&gt;Verilator&lt;/a&gt;.
Many of my designs were based upon just a single clock.  How was I going to
handle multiple clocks?  This turned into one of the biggest
challenges I had when developing &lt;a href=&quot;https://github.com/ZipCPU/videozip&quot;&gt;VideoZip&lt;/a&gt;.
(&lt;a href=&quot;https://github.com/ZipCPU/videozip&quot;&gt;VideoZip&lt;/a&gt; remains a work in progress.)&lt;/p&gt;

&lt;p&gt;The pixel clock on the &lt;a href=&quot;https://store.digilentinc.com/nexys-video-artix-7-fpga-trainer-board-for-multimedia-applications&quot;&gt;Nexys Video
board&lt;/a&gt;
isn’t the only problem for &lt;a href=&quot;https://github.com/ZipCPU/videozip&quot;&gt;VideoZip&lt;/a&gt;.
The Gb &lt;a href=&quot;https://en.wikipedia.org/wiki/Ethernet&quot;&gt;Ethernet&lt;/a&gt; port (&lt;a href=&quot;https://en.wikipedia.org/wiki/Media-independent_interface&quot;&gt;RGMII&lt;/a&gt;) wants to run at 125 MHz, reasoning about 8-bits at a time.  If this weren’t bad enough, the
&lt;a href=&quot;https://en.wikipedia.org/wiki/I2S&quot;&gt;I2S&lt;/a&gt;
audio interface wants an outgoing clock rate near 49.152 MHz.  While logical
and ugly kludges to this problem exist (which I may yet write about), the
appropriate way to deal with this is to use a PLL or digital clock manager to
generate these dissimilar clocks.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: left&quot;&gt;&lt;caption&gt;Fig 2: Multiple Clocking Needs&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/tbclock-nexys.svg&quot; alt=&quot;&quot; width=&quot;480&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;The unfortunate consequence was that I needed a multiple clock simulation
capability.  Ouch.&lt;/p&gt;

&lt;p&gt;The solution I eventually chose crosses multiple project boundaries,
but it is worthwhile enough that I’ll share it here.  It involves not only
modifying my prior &lt;a href=&quot;/blog/2017/06/21/looking-at-verilator.html&quot;&gt;Verilator test bench
wrapper&lt;/a&gt;,
but also a &lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/sim/verilator/tbclock.h&quot;&gt;test-bench clock helper
class&lt;/a&gt;.
While the updated test bench wrapper can be created manually, I’ll show you
in the end how to use
&lt;a href=&quot;/zipcpu/2017/10/05/autofpga-intro.html&quot;&gt;AutoFPGA&lt;/a&gt;
to tie each piece together into your design.&lt;/p&gt;

&lt;h2 id=&quot;reasoning-about-clocks&quot;&gt;Reasoning about clocks&lt;/h2&gt;

&lt;p&gt;If you remember
&lt;a href=&quot;/blog/2017/06/21/looking-at-verilator.html&quot;&gt;how I use&lt;/a&gt;
&lt;a href=&quot;https://www.veripool.org/wiki/verilator&quot;&gt;Verilator&lt;/a&gt;,
you’ll remember that I like to wrap a
&lt;a href=&quot;https://www.veripool.org/wiki/verilator&quot;&gt;Verilated&lt;/a&gt;
design in a test bench class I call
&lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/sim/verilated/testb.h&quot;&gt;TESTB&lt;/a&gt;.
Among other things, this &lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/sim/verilated/testb.h&quot;&gt;test bench
class&lt;/a&gt;
has an &lt;code class=&quot;highlighter-rouge&quot;&gt;tick()&lt;/code&gt; method that I
can call any time I want the clock within my design to tick once.
In my &lt;a href=&quot;/zipcpu/2017/10/05/autofpga-intro.html&quot;&gt;AutoFPGA&lt;/a&gt; enabled projects, this
&lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/sim/verilated/testb.h&quot;&gt;TESTB&lt;/a&gt;
class is created via &lt;a href=&quot;/zipcpu/2017/10/05/autofpga-intro.html&quot;&gt;AutoFPGA&lt;/a&gt;.  The class also
has some nice capabilities for opening and closing
&lt;a href=&quot;/blog/2017/07/31/vcd.html&quot;&gt;VCD trace files&lt;/a&gt;–but
those are not a part of today’s story.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;tick()&lt;/code&gt; works by:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Leaving the clock at zero and dumping the design state to a
&lt;a href=&quot;/blog/2017/07/31/vcd.html&quot;&gt;VCD file&lt;/a&gt; (if so enabled).&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Setting the clock to one, and dumping the design state to a
&lt;a href=&quot;/blog/2017/07/31/vcd.html&quot;&gt;VCD file&lt;/a&gt; again.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Setting the clock back to zero, and dumping the design state again.&lt;/p&gt;

    &lt;p&gt;This time, though, the
&lt;a href=&quot;/blog/2017/07/31/vcd.html&quot;&gt;VCD trace&lt;/a&gt;
is flushed to disk.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The module is then allowed to read any inputs that may have changed,
and adjust any outputs that may need to be changed.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Return to step one and repeat until the simulation is done.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;This works great for synchronous designs with only one clock.  Using this
method I can not only test my own design, but also incorporate
&lt;a href=&quot;https://en.wikipedia.org/wiki/Co-simulation&quot;&gt;co-simulation&lt;/a&gt;
tests: Serial port, I2C, video, you name it, all of that can fit in this
context.&lt;/p&gt;

&lt;p&gt;The problem is that this &lt;code class=&quot;highlighter-rouge&quot;&gt;tick()&lt;/code&gt; method works great for designs with only
one clock, but it is entirely insufficient when dealing with multiple clocks.
It’s not that &lt;a href=&quot;https://www.veripool.org/wiki/verilator&quot;&gt;Verilator&lt;/a&gt;
is somehow insufficient.  It’s not.
&lt;a href=&quot;https://www.veripool.org/wiki/verilator&quot;&gt;Verilator&lt;/a&gt; can handle multiple clocks
easily–as long as you can properly drive them.
&lt;a href=&quot;https://www.veripool.org/wiki/verilator&quot;&gt;Verilator&lt;/a&gt;’s
interface requires the caller to generate inputs at whatever rate they wish
to do so.  This was what I needed to do.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 3: TBCLOCK enabled Verilator simulation structure&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/tbclock-sim-structure.svg&quot; alt=&quot;&quot; width=&quot;640&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;My first step was to create a class to describe a clock to my test bench.
I call this class
&lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/sim/verilator/tbclock.h&quot;&gt;TBCLOCK&lt;/a&gt;,
or “test bench clock”.  Its purpose is primarily to help me reason about time,
and about one specific clock.  To understand the next step, let’s first take a
moment to understand &lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/sim/verilator/tbclock.h&quot;&gt;this
class&lt;/a&gt;
and its methods.  We can then look at how 
&lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/sim/verilator/tbclock.h&quot;&gt;TBCLOCK&lt;/a&gt;
can help us adjust our
&lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/sim/verilated/testb.h&quot;&gt;TESTB&lt;/a&gt;
with multi-clock aware information.&lt;/p&gt;

&lt;h2 id=&quot;tbclock&quot;&gt;TBCLOCK&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/sim/verilator/tbclock.h&quot;&gt;TBCLOCK&lt;/a&gt;
has four basic methods: &lt;code class=&quot;highlighter-rouge&quot;&gt;time_to_edge&lt;/code&gt;, returning the number of picoseconds to
the next clock edge, &lt;code class=&quot;highlighter-rouge&quot;&gt;advance&lt;/code&gt;, which advances the clock by some number of
picoseconds, and &lt;code class=&quot;highlighter-rouge&quot;&gt;rising_edge&lt;/code&gt; which can be used to tell if the clock is
currently on its rising edge.  The fourth method, &lt;code class=&quot;highlighter-rouge&quot;&gt;falling_edge&lt;/code&gt; is identical
to &lt;code class=&quot;highlighter-rouge&quot;&gt;rising_edge&lt;/code&gt;, but for falling edge clocks.&lt;/p&gt;

&lt;p&gt;Put together, these three methods work like this: the
&lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/sim/verilated/testb.h&quot;&gt;TESTB&lt;/a&gt;
object queries the
&lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/sim/verilator/tbclock.h&quot;&gt;TBCLOCK&lt;/a&gt;
objects to determine the amount of time to skip forward to get to the next
clock edge.  This looks sort of like
Fig 4 below.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 4: Time to next clock edge&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/tbclock-basic.svg&quot; alt=&quot;&quot; width=&quot;640&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/sim/verilator/tbclock.h&quot;&gt;TBCLOCK&lt;/a&gt;
compares the current time to when the next edge will take place, and returns
that amount of time in picoseconds.  (Why picoseconds?  It was an arbitrary
decision based upon the reality that nanoseconds wasn’t enough for the
application(s) shown above, and femptoseconds were overkill.)&lt;/p&gt;

&lt;p&gt;The &lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/sim/verilated/testb.h&quot;&gt;TESTB&lt;/a&gt;
enhanced logic then advances all of the
&lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/sim/verilator/tbclock.h&quot;&gt;TBCLOCK&lt;/a&gt;
objects to the time of this next edge, adjusts the clock input(s) and calls
&lt;a href=&quot;https://www.veripool.org/wiki/verilator&quot;&gt;Verilator&lt;/a&gt;’s
&lt;code class=&quot;highlighter-rouge&quot;&gt;eval()&lt;/code&gt; function to update any logic dependent upon that clock.&lt;/p&gt;

&lt;p&gt;When viewed across three separate clocks, the result might look like Fig 5.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 5: Multiple clocks&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/tbclock-advance.svg&quot; alt=&quot;&quot; width=&quot;640&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;You can see the resulting step sizes as events in the bottom trace in Fig 5.
As a result, &lt;a href=&quot;https://www.veripool.org/wiki/verilator&quot;&gt;Verilator&lt;/a&gt;
doesn’t step forward uniformly by the minimum common denominator of all clock
steps, but rather in a non-uniform fashion–so that it is only ever called to
evaluate logic following a clock edge.&lt;/p&gt;

&lt;p&gt;Creating a 
&lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/sim/verilator/tbclock.h&quot;&gt;TBCLOCK&lt;/a&gt;
is fairly straight forward.  Or, rather, it should be.  I got it wrong many
times over while just trying to get the basics below right.  To create an
object of this class, just declare one with the number of picoseconds
per clock tick.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt;	&lt;span class=&quot;nc&quot;&gt;TBCLOCK&lt;/span&gt;	&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;// ....
&lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;public:&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;TBCLOCK&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;increment_ps&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;c1&quot;&gt;// ....
&lt;/span&gt;	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The initialization routine uses &lt;code class=&quot;highlighter-rouge&quot;&gt;increment_ps&lt;/code&gt; to create an internal stepping
interval &lt;code class=&quot;highlighter-rouge&quot;&gt;m_increment_ps&lt;/code&gt; which is half of the original &lt;code class=&quot;highlighter-rouge&quot;&gt;increment_ps&lt;/code&gt;.  This
allows the &lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/sim/verilator/tbclock.h&quot;&gt;TBCLOCK&lt;/a&gt;
object to reason about both positive and negative edge going clocks.&lt;/p&gt;

&lt;p&gt;The next capability the &lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/sim/verilator/tbclock.h&quot;&gt;test bench
clock&lt;/a&gt;
offers is the ability to return the number of picoseconds until the next clock
tick.  This was what Fig 4 was showing above.  We’ll use this in the next
section in our inner clock loop.  The
next clock edge will come &lt;code class=&quot;highlighter-rouge&quot;&gt;m_increment_ps&lt;/code&gt; picoseconds after the last clock
edge.  If you subtract this future time from the current time, you’ll get a
value of how many picoseconds remain until the next clock edge.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;	&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt;	&lt;span class=&quot;nf&quot;&gt;time_to_edge&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_last_posedge_ps&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m_increment_ps&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m_now_ps&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
			&lt;span class=&quot;c1&quot;&gt;// Next edge is a negative edge
&lt;/span&gt;			&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m_last_posedge_ps&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m_increment_ps&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m_now_ps&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// if (m_last_posedge_ps + 2*m_increment_ps &amp;gt; m_now_ps)
&lt;/span&gt;			&lt;span class=&quot;c1&quot;&gt;// Next edge is a positive edge
&lt;/span&gt;			&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m_last_posedge_ps&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_increment_ps&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m_now_ps&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Once the clock generator has been queried for the time to the next edge, the
test-bench driver can then determine which clock edge comes next.
From here, each clock can be advanced until that next edge.  That’s the purpose
of the &lt;code class=&quot;highlighter-rouge&quot;&gt;advance()&lt;/code&gt; function: given a step size (in ps), advance the global
clock time maintained within this &lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/sim/verilator/tbclock.h&quot;&gt;test bench support
clock&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Well, not quite.  &lt;code class=&quot;highlighter-rouge&quot;&gt;advance()&lt;/code&gt; has one other purpose.  It also returns the value
of the clock, either &lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt; or &lt;code class=&quot;highlighter-rouge&quot;&gt;0&lt;/code&gt;, at this new time instant.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;	&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;	&lt;span class=&quot;nf&quot;&gt;advance&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;itime&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;

		&lt;span class=&quot;n&quot;&gt;m_now_ps&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;itime&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

		&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_now_ps&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m_last_posedge_ps&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_increment_ps&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
			&lt;span class=&quot;c1&quot;&gt;// Advance to the next positive edge, and return
&lt;/span&gt;			&lt;span class=&quot;c1&quot;&gt;// a positive valued clock
&lt;/span&gt;			&lt;span class=&quot;n&quot;&gt;m_last_posedge_ps&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_increment_ps&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;m_ticks&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
			&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_now_ps&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m_last_posedge_ps&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m_increment_ps&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
			&lt;span class=&quot;c1&quot;&gt;// Negative half of the clock&#39;s duty cycle
&lt;/span&gt;			&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;
			&lt;span class=&quot;c1&quot;&gt;// Positive half of the clock&#39;s duty cycle
&lt;/span&gt;			&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;In the next section, we’ll use the result of &lt;code class=&quot;highlighter-rouge&quot;&gt;advance()&lt;/code&gt; to set the
clock input value to the main Verilog &lt;a href=&quot;/blog/2017/06/21/looking-at-verilator.html&quot;&gt;test
bench function&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;There are two other helper functions to determine if the current time is a
rising or a falling edge, but that’s the basics of the first part.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;	&lt;span class=&quot;c1&quot;&gt;// Return true if this is a rising clock edge
&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;bool&lt;/span&gt;	&lt;span class=&quot;nf&quot;&gt;rising_edge&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_now_ps&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m_last_posedge_ps&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
			&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

	&lt;span class=&quot;c1&quot;&gt;// Return true if this is a falling clock edge
&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;bool&lt;/span&gt;	&lt;span class=&quot;nf&quot;&gt;falling_edge&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_now_ps&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m_last_posedge_ps&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m_increment_ps&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
			&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The primary work in this class is done within the &lt;code class=&quot;highlighter-rouge&quot;&gt;time_to_edge&lt;/code&gt; method.
We’ll see how this helps in the next section.&lt;/p&gt;

&lt;h2 id=&quot;updating-the-inner-testbench-class-testb&quot;&gt;Updating the inner testbench class, TESTB&lt;/h2&gt;

&lt;p&gt;The
&lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/sim/verilator/tbclock.h&quot;&gt;TBCLOCK&lt;/a&gt;
class we discussed above is only a &lt;em&gt;helper&lt;/em&gt; in the scheme of things.  Most of
the actual logic takes place within the updated &lt;code class=&quot;highlighter-rouge&quot;&gt;tick()&lt;/code&gt; function found within
the &lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/sim/verilated/testb.h&quot;&gt;test bench object,
TESTB&lt;/a&gt;,
used to drive the &lt;a href=&quot;https://www.veripool.org/wiki/verilator&quot;&gt;Verilator&lt;/a&gt; inputs.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/blog/2017/06/21/looking-at-verilator.html&quot;&gt;As you may
recall&lt;/a&gt;,
I started creating a &lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/sim/verilated/testb.h&quot;&gt;test bench class
wrapper&lt;/a&gt;
once I noticed that I kept using the same code for every
&lt;a href=&quot;https://www.veripool.org/wiki/verilator&quot;&gt;Verilator&lt;/a&gt;
based test bench.  The code to open a
&lt;a href=&quot;/blog/2017/07/31/vcd.html&quot;&gt;trace file&lt;/a&gt;
was the same.  The code to capture data to that
&lt;a href=&quot;/blog/2017/07/31/vcd.html&quot;&gt;trace file&lt;/a&gt;
was the same.  The &lt;a href=&quot;/blog/2017/06/21/looking-at-verilator.html&quot;&gt;code to toggle the
clock&lt;/a&gt;
was the same.  I found myself copying these pieces of code from one simulation
wrapper to another.  Rather than just duplicate the same code,
&lt;a href=&quot;/blog/2017/06/21/looking-at-verilator.html&quot;&gt;I created&lt;/a&gt; the
&lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/sim/verilated/testb.h&quot;&gt;test bench
wrapper&lt;/a&gt;
class,
&lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/sim/verilated/testb.h&quot;&gt;TESTB&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;One of the primary functions of the &lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/sim/verilated/testb.h&quot;&gt;test bench
wrapper&lt;/a&gt;
object is to advance the clock.
&lt;a href=&quot;https://www.veripool.org/wiki/verilator&quot;&gt;Verilator&lt;/a&gt;
requires that the clock toggle from low to high in order to call the
positive edge logic within your design.  The clock needs to then return low,
and all of these transitions require calls to the &lt;a href=&quot;/blog/2017/06/21/looking-at-verilator.html&quot;&gt;Verilator tracing
methods&lt;/a&gt; if you
want a &lt;a href=&quot;/blog/2017/07/31/vcd.html&quot;&gt;VCD file&lt;/a&gt; when you are
done.&lt;/p&gt;

&lt;p&gt;I found this cumbersome, so I wrapped all of that logic with a &lt;code class=&quot;highlighter-rouge&quot;&gt;tick()&lt;/code&gt; method.
This is the same &lt;code class=&quot;highlighter-rouge&quot;&gt;tick()&lt;/code&gt; method I discussed above.  The &lt;code class=&quot;highlighter-rouge&quot;&gt;tick()&lt;/code&gt; method of
&lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/sim/verilated/testb.h&quot;&gt;TESTB&lt;/a&gt;
would capture inputs to the core in a trace,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;	&lt;span class=&quot;k&quot;&gt;virtual&lt;/span&gt;	&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;	&lt;span class=&quot;nf&quot;&gt;tick&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;m_tickcount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

		&lt;span class=&quot;c1&quot;&gt;// Step one--don&#39;t skip this one!
&lt;/span&gt;		&lt;span class=&quot;c1&quot;&gt;// This step is necessary to make certain any combinatorial
&lt;/span&gt;		&lt;span class=&quot;c1&quot;&gt;// logic settles prior to the positive edge of the clock, and
&lt;/span&gt;		&lt;span class=&quot;c1&quot;&gt;// following any adjustments to design&#39;s inputs
&lt;/span&gt;		&lt;span class=&quot;c1&quot;&gt;//
&lt;/span&gt;		&lt;span class=&quot;c1&quot;&gt;// m_core-&amp;gt;i_clk = 0; // (This is implied)
&lt;/span&gt;		&lt;span class=&quot;n&quot;&gt;eval&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_trace&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;m_trace&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dump&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_tickcount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;toggle the clock high,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;		&lt;span class=&quot;c1&quot;&gt;// Step two
&lt;/span&gt;		&lt;span class=&quot;n&quot;&gt;m_core&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i_clk&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;eval&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;capture the results in a trace,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;		&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_trace&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;m_trace&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dump&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_tickcount&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;then toggle the clock low&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;		&lt;span class=&quot;c1&quot;&gt;// Step three
&lt;/span&gt;		&lt;span class=&quot;n&quot;&gt;m_core&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i_clk&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;eval&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;and capture the results in the trace again–this time flushing the trace file.
(Flushing is important–I’ve had too many designs fail some C-assertion in their
associated logic, and without the flush you may not get the state of your
variables at that last clock.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;		&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_trace&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;m_trace&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dump&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_tickcount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;m_trace&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;flush&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
		&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Before moving on, let me foot-stomp here that &lt;em&gt;all three calls to &lt;code class=&quot;highlighter-rouge&quot;&gt;eval()&lt;/code&gt;
are essential!&lt;/em&gt;.  While it may look like the last step and the first step
are identical since they both leave the clock at zero, they are not the same.
Between these two steps,
&lt;a href=&quot;https://en.wikipedia.org/wiki/Co-simulation&quot;&gt;co-simulation&lt;/a&gt;
logic might change inputs to the design.  Unless you call &lt;code class=&quot;highlighter-rouge&quot;&gt;eval()&lt;/code&gt; following
any &lt;a href=&quot;https://en.wikipedia.org/wiki/Co-simulation&quot;&gt;co-simulation&lt;/a&gt; updates to
design inputs, combinational logic depending upon these inputs may not
settle.  This is a painful bug to search for, so I recommend you learn the
lesson here.&lt;/p&gt;

&lt;p&gt;In this single clock paradigm outlined above, I could read any outputs and
adjust any inputs after calling this one &lt;code class=&quot;highlighter-rouge&quot;&gt;tick()&lt;/code&gt; method.  I could also call
the C &lt;code class=&quot;highlighter-rouge&quot;&gt;assert&lt;/code&gt; function if something had gone wrong–the &lt;code class=&quot;highlighter-rouge&quot;&gt;flush()&lt;/code&gt; command
above guaranteed that the relevant portion of the trace was in &lt;a href=&quot;/blog/2017/07/31/vcd.html&quot;&gt;the
file&lt;/a&gt;.  This approach was simple
enough, and I’ve used this pattern for many of my designs.  (You can read more
about it &lt;a href=&quot;/blog/2017/06/21/looking-at-verilator.html&quot;&gt;here&lt;/a&gt;.)&lt;/p&gt;

&lt;p&gt;Sadly, this initial approach didn’t work when dealing with multiple clocks.&lt;/p&gt;

&lt;p&gt;Instead, let’s walk through how this &lt;code class=&quot;highlighter-rouge&quot;&gt;tick()&lt;/code&gt; method can be updated to deal
with multiple clocks.  In the example below, drawn from the &lt;a href=&quot;https://github.com/ZipCPU/videozip&quot;&gt;VideoZip
project&lt;/a&gt;,
I have four clocks: &lt;code class=&quot;highlighter-rouge&quot;&gt;hdmi_out&lt;/code&gt;.  &lt;code class=&quot;highlighter-rouge&quot;&gt;hdmi_in&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;net_rx_clk&lt;/code&gt;, and my default &lt;code class=&quot;highlighter-rouge&quot;&gt;clk&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The first step when calling &lt;code class=&quot;highlighter-rouge&quot;&gt;tick()&lt;/code&gt; is to check the number of picoseconds
till the next clock edge.  This is the minimum time to the next edge among
all clocks.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;	&lt;span class=&quot;k&quot;&gt;virtual&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;	&lt;span class=&quot;nf&quot;&gt;tick&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;c1&quot;&gt;// m_clk describes the system clock
&lt;/span&gt;		&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;mintime&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m_clk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;time_to_edge&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;

		&lt;span class=&quot;c1&quot;&gt;// m_hdmi_out_clk describes the HDMI output clock
&lt;/span&gt;		&lt;span class=&quot;c1&quot;&gt;// This is at 148.5MHz for this design
&lt;/span&gt;		&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_hdmi_out_clk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;time_to_edge&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mintime&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;mintime&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m_hdmi_out_clk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;time_to_edge&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;

		&lt;span class=&quot;c1&quot;&gt;// m_hdmi_in_clk describes the HDMI input clock
&lt;/span&gt;		&lt;span class=&quot;c1&quot;&gt;// This is identical to the HDMI output clock in this design
&lt;/span&gt;		&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_hdmi_in_clk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;time_to_edge&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mintime&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;mintime&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m_hdmi_in_clk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;time_to_edge&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;

		&lt;span class=&quot;c1&quot;&gt;// m_net_rx_clk describes the 125MHz ethernet RGMII interface
&lt;/span&gt;		&lt;span class=&quot;c1&quot;&gt;// clock
&lt;/span&gt;		&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_net_rx_clk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;time_to_edge&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mintime&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;mintime&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m_net_rx_clk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;time_to_edge&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Once we know this amount of time, we’ll call &lt;code class=&quot;highlighter-rouge&quot;&gt;eval()&lt;/code&gt; once out of an abundance
of caution.  This makes sure, before any clock edges change, that all of the
combinational logic associated with any potentially changed input wires has
settled.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;		&lt;span class=&quot;n&quot;&gt;eval&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Once done, each of the various clock objects may be advanced by this amount
of time, and our global estimate of the current time can advance as well.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;		&lt;span class=&quot;n&quot;&gt;m_core&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i_hdmi_out_clk&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m_hdmi_out_clk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;advance&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mintime&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;m_core&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i_hdmi_in_clk&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m_hdmi_in_clk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;advance&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mintime&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;m_core&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i_clk&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m_clk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;advance&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mintime&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;m_core&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i_net_rx_clk&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m_net_rx_clk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;advance&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mintime&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

		&lt;span class=&quot;n&quot;&gt;m_time_ps&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mintime&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Finally, using these new clock values, we can call
&lt;a href=&quot;/blog/2017/06/21/looking-at-verilator.html&quot;&gt;Verilator&lt;/a&gt;
to evaluate our design in this new interval–adjusting any edge triggered
logic.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;		&lt;span class=&quot;n&quot;&gt;eval&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;If we are recording a trace at this time, we’ll then call
&lt;a href=&quot;/blog/2017/06/21/looking-at-verilator.html&quot;&gt;Verilator&lt;/a&gt;
to dump the current state of the design to a
&lt;a href=&quot;/blog/2017/07/31/vcd.html&quot;&gt;trace file&lt;/a&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;		&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_trace&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;m_trace&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dump&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_time_ps&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;m_trace&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;flush&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
		&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Don’t forget to flush it!  There’s been more than one time when I’ve checked
the outputs of a core after ticking the clock, decided their was a problem and
aborted, only to find the relevant signals hadn’t ended up in the
&lt;a href=&quot;/blog/2017/07/31/vcd.html&quot;&gt;trace file&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Finally, we’ll call any external simulation logic depending on clock edges.
In my single clock designs, I do this about mid-way through the low period of
the clock, so you can “see” the transformation.  I also did it between calls to
&lt;code class=&quot;highlighter-rouge&quot;&gt;tick()&lt;/code&gt;.  This doesn’t work with multiple-clocks, since peripherals are often
defined by the clock the logic is associated with.  For this reason,
we’ll have to call separate functions for each clock to allow these
&lt;a href=&quot;https://en.wikipedia.org/wiki/Co-simulation&quot;&gt;co-simulations&lt;/a&gt;
to update.  We’ll do this on
the falling edges of their respective clocks.  This includes possibly updating
the &lt;a href=&quot;https://github.com/ZipCPU/vgasim&quot;&gt;video simulation&lt;/a&gt;, checking for
simulated network packets, and more.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;		&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_hdmi_out_clk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;falling_edge&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;m_changed&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;sim_hdmi_out_clk_tick&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
		&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_hdmi_in_clk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;falling_edge&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;m_changed&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;sim_hdmi_in_clk_tick&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
		&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_net_rx_clk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;falling_edge&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;m_changed&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;sim_clk_tick&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
		&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_clk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;falling_edge&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;m_changed&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;sim_clk_tick&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
		&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;For example, in my &lt;a href=&quot;https://github.com/ZipCPU/fftdemo&quot;&gt;spectrogram demo
project&lt;/a&gt;, the &lt;code class=&quot;highlighter-rouge&quot;&gt;sim_clk_tick()&lt;/code&gt; function
advances the &lt;a href=&quot;https://github.com/ZipCPU/fftdemo/blob/master/bench/cpp/micnco.cpp&quot;&gt;A/D
simulation&lt;/a&gt;
and so updates &lt;code class=&quot;highlighter-rouge&quot;&gt;i_adc_miso&lt;/code&gt;, and the &lt;code class=&quot;highlighter-rouge&quot;&gt;sim_pixclk_tick()&lt;/code&gt; advances the
&lt;a href=&quot;https://github.com/ZipCPU/blob/master/bench/cpp/vgasim.cpp&quot;&gt;simulated video on the
screen&lt;/a&gt;
using the outgoing pixel, and the various outgoing synch signals.
(&lt;a href=&quot;https://github.com/ZipCPU/blob/master/bench/cpp/main_tb.cpp&quot;&gt;Ref&lt;/a&gt;)&lt;/p&gt;

&lt;p&gt;The conclusion here is that if you want to use this technique, you’ll want to
copy the
&lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/sim/verilator/tbclock.h&quot;&gt;TBCLOCK&lt;/a&gt;
class (or build your own), and then create a
&lt;a href=&quot;https://github.com/ZipCPU/videozip/blob/master/sim/verilated/testb.h&quot;&gt;test bench wrapper&lt;/a&gt;
that references your
&lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/sim/verilator/tbclock.h&quot;&gt;TBCLOCK&lt;/a&gt;
objects and gets all the pieces right.&lt;/p&gt;

&lt;p&gt;Alternatively, you could use &lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt;
to handle all of this busy work for you.&lt;/p&gt;

&lt;h2 id=&quot;using-autofpga-to-build-the-testbench&quot;&gt;Using AutoFPGA to build the testbench&lt;/h2&gt;

&lt;p&gt;If you are not familiar with &lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt;,
then in quick sum: it is Verilog-based code generator based upon a copy and
paste concept with minimal substitution capability.  You specify the code
snippets associated with each design component or peripheral in an
&lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt;
configuration file, and then when you call
&lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt; specifying that configuration
file (among many others),
&lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt;
will create your top level (device dependent) design, your main design
(device independent) file, and several other bus related files associated with
the peripherals you are making or using.&lt;/p&gt;

&lt;p&gt;If you are interested in this, consider reading about
&lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt;’s
&lt;a href=&quot;/zipcpu/2017/10/05/autofpga-intro.html&quot;&gt;design goal’s&lt;/a&gt;, 
or the primer on &lt;a href=&quot;/zipcpu/2017/10/06/autofpga-dataword.html&quot;&gt;how to connect simple register-based components to a
debugging bus&lt;/a&gt;
using &lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The neat thing about using &lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt;
for a purpose like this one, is that when you no longer need the extra
clock or the logic that uses it, you can just remove the reference to the
configuration file describing those components of your design from the
&lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt;
command line.  If you want to see how this works, consider examining a &lt;a href=&quot;https://github.com/ZipCPU/zbasic&quot;&gt;project
that uses&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt;, and then looking in the 
&lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/zbasic/tree/master/auto-data&quot;&gt;configuration file directory&lt;/a&gt;
for the &lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/auto-data/Makefile&quot;&gt;Makefile&lt;/a&gt;.  In there, you’ll find some lines similar to:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-makefile&quot; data-lang=&quot;makefile&quot;&gt;&lt;span class=&quot;nv&quot;&gt;DATA&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; global.txt bkram.txt buserr.txt clock.txt                       &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
	dlyarbiter.txt flash.txt rtclight.txt   rtcdate.txt             &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
	pic.txt pwrcount.txt                                            &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
	version.txt busconsole.txt zipmaster.txt sdspi.txt

&lt;span class=&quot;nv&quot;&gt;AUTOFPGA&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; ../../../autofpga/trunk/sw/autofpga

&lt;span class=&quot;nl&quot;&gt;.PHONY&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;data&lt;/span&gt;
&lt;span class=&quot;nl&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;$(AUTOFPGA) $(DATA)&lt;/span&gt;
	&lt;span class=&quot;nv&quot;&gt;$(AUTOFPGA)&lt;/span&gt; -o . &lt;span class=&quot;nv&quot;&gt;$(DATA)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This captures, in the &lt;code class=&quot;highlighter-rouge&quot;&gt;$(DATA)&lt;/code&gt; variable a list of configuration files that
are given to &lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Then in the main project
&lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/Makefile&quot;&gt;Makefile&lt;/a&gt; the created
code files will be copied to their various parts of the project tree if
running &lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt; had changed them–but
not otherwise.  As an
&lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/Makefile&quot;&gt;example&lt;/a&gt; from
&lt;a href=&quot;/zipcpu/2018/02/12/zbasic-intro.html&quot;&gt;Zbasic&lt;/a&gt;, these
&lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/Makefile&quot;&gt;Makefile&lt;/a&gt;
lines would look like:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-makefile&quot; data-lang=&quot;makefile&quot;&gt;&lt;span class=&quot;nl&quot;&gt;.PHONY&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;autodata&lt;/span&gt;
&lt;span class=&quot;nl&quot;&gt;autodata&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;check-autofpga&lt;/span&gt;
	&lt;span class=&quot;nv&quot;&gt;$(MAKE)&lt;/span&gt; --no-print-directory --directory&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;auto-data
	&lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;call copyif-changed,auto-data/toplevel.v,rtl/toplevel.v&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;call copyif-changed,auto-data/main.v,rtl/main.v&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;call copyif-changed,auto-data/regdefs.h,sw/host/regdefs.h&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;call copyif-changed,auto-data/regdefs.cpp,sw/host/regdefs.cpp&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;call copyif-changed,auto-data/board.h,sw/zlib/board.h&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;call copyif-changed,auto-data/board.ld,sw/board/board.ld&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;call copyif-changed,auto-data/rtl.make.inc,rtl/make.inc&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;call copyif-changed,auto-data/testb.h,sim/verilated/testb.h&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;call copyif-changed,auto-data/main_tb.cpp,sim/verilated/main_tb.cpp&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;and a little later, you’ll see the definition of this &lt;code class=&quot;highlighter-rouge&quot;&gt;copyif-changed&lt;/code&gt;
function.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-makefile&quot; data-lang=&quot;makefile&quot;&gt;&lt;span class=&quot;err&quot;&gt;define&lt;/span&gt;  &lt;span class=&quot;err&quot;&gt;copyif-changed&lt;/span&gt;
	&lt;span class=&quot;err&quot;&gt;@bash&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;-c&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&#39;cmp $(1) $(2); if [[ $$? != 0 ]]; then echo &quot;Copying $(1) to $(2)&quot;; cp $(1) $(2); fi&#39;&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;endef&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Basically, if files &lt;code class=&quot;highlighter-rouge&quot;&gt;$(1)&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;$(2)&lt;/code&gt; differ, then &lt;code class=&quot;highlighter-rouge&quot;&gt;$(1)&lt;/code&gt; is copied on top of
&lt;code class=&quot;highlighter-rouge&quot;&gt;$(2)&lt;/code&gt;.  This keeps &lt;a href=&quot;https://www.gnu.org/software/make&quot;&gt;make&lt;/a&gt; from rebuilding
things that depend upon files that haven’t changed.&lt;/p&gt;

&lt;p&gt;But that’s not my point here and now.&lt;/p&gt;

&lt;p&gt;What I want to share right now is how easy it is to teach
&lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt; about your multiple clocks.&lt;/p&gt;

&lt;p&gt;First, you’ll want to define each of your clocks.  A clock, in terms of
&lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt;, has three components:
a name, the name of the wire that contains this clock, and the frequency of
the clock in Hz.  For example, you might have a clock &lt;code class=&quot;highlighter-rouge&quot;&gt;clk&lt;/code&gt; contained in the
wire &lt;code class=&quot;highlighter-rouge&quot;&gt;i_clk&lt;/code&gt;, that runs at 100MHz.  You’d then define this as:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;CLOCK.NAME= clk
CLOCK.WIRE= i_clk
CLOCK.FREQUENCY= 100000000&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This alone is all that is needed to create the clock in the
&lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt; generated
&lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/sim/verilated/testb.h&quot;&gt;TESTB&lt;/a&gt;
file.&lt;/p&gt;

&lt;p&gt;What about simulating a component requiring this clock?&lt;/p&gt;

&lt;p&gt;Let’s consider simulating a video display.  You can find a video display
simulator &lt;a href=&quot;https://github.com/ZipCPU/vgasim&quot;&gt;here&lt;/a&gt;.  Let’s assume your
design has outputs &lt;code class=&quot;highlighter-rouge&quot;&gt;o_vga_vsync&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;o_vga_hsync&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;o_vga_red&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;o_vga_grn&lt;/code&gt;,
and &lt;code class=&quot;highlighter-rouge&quot;&gt;o_vga_blu&lt;/code&gt;–such as this one does.  Then, you’d want to declare a &lt;a href=&quot;https://github.com/ZipCPU/vgasim/blob/master/bench/cpp/vgasim.cpp&quot;&gt;VGA
simulator&lt;/a&gt;
VGA simulator in your Verilog design component,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;n&quot;&gt;SIM&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;DEFNS&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;VGASIM&lt;/span&gt;	&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_vga&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;You’d then want to initialize this component.  Here, we’ll set it up for an
800x600 display mode.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;n&quot;&gt;SIM&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;INIT&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;m_vga&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;VGASIM&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;800&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;600&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;We can then call this
&lt;a href=&quot;https://en.wikipedia.org/wiki/Co-simulation&quot;&gt;co-simulation&lt;/a&gt;
component on every clock tick, with,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;n&quot;&gt;SIM&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;TICK&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;
		&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_vga&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_core&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;o_vga_vsync&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m_core&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;o_vga_hsync&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;m_core&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;o_vga_red&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m_core&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;o_vga_grn&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;m_core&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;o_vga_blu&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Don’t forget to define the clock!  For an &lt;code class=&quot;highlighter-rouge&quot;&gt;800x600&lt;/code&gt; display mode, you’ll need
a &lt;code class=&quot;highlighter-rouge&quot;&gt;40MHz&lt;/code&gt; clock.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;CLOCK.NAME= pixclk
CLOCK.WIRE= i_pixclk
CLOCK.FREQUENCY= 40000000&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Ideally, you could just add this updated configuration file to your design
to add this component, or remove it from your design to remove the component.
At this point, this would work for a
&lt;a href=&quot;https://www.veripool.org/wiki/verilator&quot;&gt;Verilator&lt;/a&gt;
simulation.  If you wanted to go beyond simulation, you’d
need to actually add and configure the PLL in the toplevel design component.
You’d use the &lt;code class=&quot;highlighter-rouge&quot;&gt;TOP.INSERT&lt;/code&gt;
&lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt;
tag for that purpose.
&lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt;
would then copy the contents of that tag into your toplevel.v
design file.  No &lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt;
doesn’t configure the PLL itself (yet)–you still have to give it the code
for that (with the &lt;code class=&quot;highlighter-rouge&quot;&gt;TOP.INSERT&lt;/code&gt;).  Still,
&lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt;
will put that code in place for you, making reconfiguration simpler.&lt;/p&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;Perhaps that seems like a lot of work.  It’s not really.  We’re primarily
talking about 20-40 lines of code in total.  It’s just a different way of
thinking.  The only sad and complicated part is that all of these lines of
code take place over many design files.  Having
&lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt;
manage this for me has helped to keep all of the changes to support multiple
clocks within one or two files only.&lt;/p&gt;

&lt;p&gt;In the end, we now have a
&lt;a href=&quot;https://www.veripool.org/wiki/verilator&quot;&gt;Verilator&lt;/a&gt;,
based design that runs using multiple clocks.  Not only that, you can generate
a &lt;a href=&quot;/blog/2017/07/31/vcd.html&quot;&gt;VCD file&lt;/a&gt;
showing all of these various clocks and their respective traces.&lt;/p&gt;

&lt;p&gt;While this capability does not (yet) allow the generation of multiple clocks
with a known phase relationship, such as one might use with an ISERDES or an
OSERDES, upgrading the tools to do so would be fairly trivial.  I’m sure I’ll
get around to that when I have a need for it.&lt;/p&gt;

&lt;p&gt;Perhaps some of you are wondering to yourselves, “Verilog offers a capability
to generate multiple clocks already.  Why aren’t you using Verilog’s test bench
capability to do this?”&lt;/p&gt;

&lt;p&gt;My answer to that is simple: I know how to interface a C++ module with my
computer’s Windowing system using &lt;a href=&quot;https://www.gtkmm.org&quot;&gt;GTKMM&lt;/a&gt;.
I don’t know the Verilog system call to do that.&lt;/p&gt;

&lt;p&gt;What can you use this for?  I’ve already mentioned
&lt;a href=&quot;https://github.com/ZipCPU/vgasim&quot;&gt;video&lt;/a&gt;, &lt;a href=&quot;https://en.wikipedia.org/wiki/Ethernet&quot;&gt;Ethernet&lt;/a&gt;, and
audio applications.  There’s no reason why you can’t use this for custom
applications as well.  For example, I’m still looking forward to completing the
&lt;a href=&quot;https://forum.digilentinc.com/topic/2898-differential-pmod-challenge/&quot;&gt;differential pmod challenge&lt;/a&gt;
… but that’s really another topic for another day.&lt;/p&gt;
&lt;hr /&gt;&lt;p&gt;&lt;em&gt;And Jesus answered and said unto them, Elias truly shall first come, and restore all things. (Matt 17:11)&lt;/em&gt;</description>
        <pubDate>Thu, 06 Sep 2018 00:00:00 -0400</pubDate>
        <link>https://zipcpu.com/blog/2018/09/06/tbclock.html</link>
        <guid isPermaLink="true">https://zipcpu.com/blog/2018/09/06/tbclock.html</guid>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>RE: Building a simulation for my design?  What does that mean?</title>
        <description>&lt;p&gt;Recently, a student wrote to me:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Hello.  I am a student taking my first digital design course, and I stumbled
upon your website.  Specifically, &lt;a href=&quot;/blog/2017/06/02/design-process.html&quot;&gt;this
article&lt;/a&gt;.&lt;/p&gt;

  &lt;p&gt;What exactly is meant here when you talk about building a simulation for
your design?&lt;/p&gt;

  &lt;p&gt;(I’ll keep the student’s name anonymous.)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 1: Typical Student Design Process&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/student-design-process.svg&quot; alt=&quot;&quot; width=&quot;180&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;He’s specifically talking about
&lt;a href=&quot;/blog/2017/06/02/design-process.html&quot;&gt;an article&lt;/a&gt;
where I discuss the student design process, as shown in Fig 1. on the right.
If you haven’t read
&lt;a href=&quot;/blog/2017/06/02/design-process.html&quot;&gt;that article&lt;/a&gt;,
I would commend it to you.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/blog/2017/06/02/design-process.html&quot;&gt;The article&lt;/a&gt;
recommends having a valid/working &lt;a href=&quot;https://en.wikipedia.org/wiki/Simulation&quot;&gt;simulation&lt;/a&gt; before ever moving
to hardware.  It also recommends using some form of
&lt;a href=&quot;/blog/2017/06/16/dbg-bus-forest.html&quot;&gt;debugging bus&lt;/a&gt; and/or
&lt;a href=&quot;/blog/2017/06/08/simple-scope.html&quot;&gt;internal logic analyzer&lt;/a&gt;
for debugging designs that have moved to hardware.  About the time the article
was written, I was mentoring another college student who had been
struggling through to build a design of his own.  When he came across
&lt;a href=&quot;/blog/2017/06/02/design-process.html&quot;&gt;this article&lt;/a&gt;,
he was kind enough to respond with &lt;a href=&quot;/blog/2017/06/10/lost-college-student.html&quot;&gt;his own
experiences&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Sadly, &lt;a href=&quot;/blog/2017/06/10/lost-college-student.html&quot;&gt;this
experience&lt;/a&gt;
of frustration is common.  It is so common, that I coined the phrase
“&lt;a href=&quot;/blog/2017/05/19/fpga-hell.html&quot;&gt;FPGA Hell&lt;/a&gt;” to describe it,
and then &lt;a href=&quot;/fpga-hell.html&quot;&gt;dedicated my blog&lt;/a&gt; to keeping
students out of &lt;a href=&quot;/blog/2017/05/19/fpga-hell.html&quot;&gt;FPGA
Hell&lt;/a&gt;.  Much to
my surprise, I’ve since spoken with many professionals who have been
interested in these topics as well.  Apparently,
&lt;a href=&quot;/blog/2017/05/19/fpga-hell.html&quot;&gt;FPGA Hell&lt;/a&gt;
in the business (i.e.
&lt;a href=&quot;https://en.wikipedia.org/wiki/Application-specific_integrated_circuit&quot;&gt;ASIC&lt;/a&gt;)
world can easily translate into &lt;a href=&quot;/blog/2017/10/13/fpga-v-asic.html&quot;&gt;millions of lost
dollars&lt;/a&gt;–and often
lost jobs as well.&lt;/p&gt;

&lt;p&gt;But let me come back to the original question: what do I mean when I talk about
&lt;a href=&quot;/blog/2017/06/23/my-dbg-philosophy.html&quot;&gt;building a simulation for a
design&lt;/a&gt;?  There
are two types of &lt;a href=&quot;https://en.wikipedia.org/wiki/Simulation&quot;&gt;simulations&lt;/a&gt;
I have used in my designs.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Simulation&quot;&gt;Simulation&lt;/a&gt; in this context can
reference a quick bench test of a module, that attempts to verify the module
logic works.&lt;/p&gt;

    &lt;p&gt;I used to do this with my components a lot.  I don’t do this as much any
more.  Why not?  My own efforts just weren’t very effective at finding bugs.&lt;/p&gt;

    &lt;p&gt;That said, this remains my approach when &lt;a href=&quot;/dsp/2017/07/24/dsp-debugging.html&quot;&gt;debugging any DSP
design&lt;/a&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Simulation&quot;&gt;It&lt;/a&gt; can also refer to an
integrated test of the entire design and all of its pieces, together with
&lt;a href=&quot;https://en.wikipedia.org/wiki/Co-simulation&quot;&gt;co-simulations&lt;/a&gt; of all of the
attached pieces of hardware.  I do this before moving to actual hardware.&lt;/p&gt;

    &lt;p&gt;I continue this practice religiously, and every system level project I have
has a full simulation capability.  Depending on the project this simulation
can either be found in the &lt;code class=&quot;highlighter-rouge&quot;&gt;bench/cpp&lt;/code&gt; directory or a similar &lt;code class=&quot;highlighter-rouge&quot;&gt;sim/verilated&lt;/code&gt;
directory.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;I’ve discussed &lt;a href=&quot;https://en.wikipedia.org/wiki/Simulation&quot;&gt;simulation&lt;/a&gt; many
times over on &lt;a href=&quot;&quot;&gt;the blog&lt;/a&gt;, providing both
examples of &lt;a href=&quot;https://en.wikipedia.org/wiki/Simulation&quot;&gt;simulation&lt;/a&gt;, and
discussing how I put &lt;a href=&quot;https://en.wikipedia.org/wiki/Simulation&quot;&gt;simulations&lt;/a&gt;
together.  For example:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;I use &lt;a href=&quot;/blog/2017/06/21/looking-at-verilator.html&quot;&gt;Verilator&lt;/a&gt;
for all of my simulating needs.  We’ve discussed how to build a
&lt;a href=&quot;/blog/2017/06/21/looking-at-verilator.html&quot;&gt;verilator&lt;/a&gt;-based
bench test already on this blog.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;We’ve also discussed &lt;a href=&quot;/dsp/2017/11/04/genfil-tb.html&quot;&gt;how to test a DSP filter
design&lt;/a&gt; using
&lt;a href=&quot;/blog/2017/06/21/looking-at-verilator.html&quot;&gt;Verilator&lt;/a&gt;
as well.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The same applies to testing a
&lt;a href=&quot;/dsp/2017/10/02/cordic-tb.html&quot;&gt;CORDIC&lt;/a&gt;
algorithm that can evaluate sine and cosine functions.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Did I mention discussing how to build a simulation for a
&lt;a href=&quot;/dsp/2017/12/14/logic-pll.html&quot;&gt;logic PLL&lt;/a&gt;?&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;/blog/2017/06/21/looking-at-verilator.html&quot;&gt;Verilator&lt;/a&gt;
allows me to integrate C++ &lt;a href=&quot;https://en.wikipedia.org/wiki/Co-simulation&quot;&gt;co-simulation&lt;/a&gt;
code into my designs.  (&lt;a href=&quot;/blog/2017/06/21/looking-at-verilator.html&quot;&gt;Verilator&lt;/a&gt;
is not necessarily unique in this fashion, there are other approaches, however
&lt;a href=&quot;/blog/2017/06/21/looking-at-verilator.html&quot;&gt;Verilator&lt;/a&gt;
is most definitely my chosen approach.)  Examples include:&lt;/p&gt;

    &lt;p&gt;– A &lt;a href=&quot;https://github.com/ZipCPU/wbuart32&quot;&gt;serial port&lt;/a&gt; that you can connect
 to using &lt;a href=&quot;https://en.wikipedia.org/wiki/Transmission_Control_Protocol&quot;&gt;TCP/IP&lt;/a&gt;, such as &lt;code class=&quot;highlighter-rouge&quot;&gt;telnet localhost &amp;lt;port #&amp;gt;&lt;/code&gt;.  You can read about an example using this approach &lt;a href=&quot;/blog/2017/06/26/dbgbus-verilator.html&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;

    &lt;p&gt;– A &lt;a href=&quot;https://github.com/ZipCPU/icozip&quot;&gt;parallel port&lt;/a&gt; that takes the place
 of the serial port in my design for the &lt;a href=&quot;http://www.icoboard.org&quot;&gt;ICO Board&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;– A &lt;a href=&quot;https://github.com/ZipCPU/vgasim&quot;&gt;VGA simulator&lt;/a&gt;: includes both
 &lt;a href=&quot;https://github.com/ZipCPU/vgasim/blob/master/bench/cpp&quot;&gt;source&lt;/a&gt; (i.e. a camera)
 and &lt;a href=&quot;https://github.com/ZipCPU/vgasim/blob/master/bench/cpp&quot;&gt;sink&lt;/a&gt; (i.e. a window
 on your screen)
 &lt;a href=&quot;https://en.wikipedia.org/wiki/Co-simulation&quot;&gt;co-simulators&lt;/a&gt;.&lt;/p&gt;

    &lt;p&gt;– An &lt;a href=&quot;https://github.com/ZipCPU/wbpmic&quot;&gt;A/D simulator&lt;/a&gt; for &lt;a href=&quot;http://store.digilentinc.com/pmod-mic3-mems-microphone-with-adjustable-gain&quot;&gt;this
 microphone&lt;/a&gt; PMod.&lt;/p&gt;

    &lt;p&gt;– A &lt;a href=&quot;https://opencores.org/project/qspiflash&quot;&gt;flash simulator&lt;/a&gt;.  This has
 been so useful, I’ve reused it just about all of my
 &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; projects&lt;/p&gt;

    &lt;p&gt;– A &lt;a href=&quot;https://github.com/ZipCPU/sdspi&quot;&gt;SD-Card simulator (SPI mode only)&lt;/a&gt;.
 When I finally get to implementing Linux on the
 &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;, being able to simulate an
 SD card capability will be very important.&lt;/p&gt;

    &lt;p&gt;– An &lt;a href=&quot;https://github.com/ZipCPU/wbi2c&quot;&gt;I2C simulator&lt;/a&gt;.  This was a necessary
 part of my (still incomplete) &lt;a href=&quot;https://github.com/ZipCPU/videozip&quot;&gt;HDMI
 design&lt;/a&gt;, since modern monitors are
 supposed to respond to a query and reply with the video formats they support.
 (The I2C part of the design works.)&lt;/p&gt;

    &lt;p&gt;– &lt;a href=&quot;https://github.com/ZipCPU/openarty&quot;&gt;One of my designs&lt;/a&gt; even includes a
 &lt;a href=&quot;https://github.com/ZipCPU/openarty/blob/master/rtl/gpsclock_tb.v&quot;&gt;GPS PPS signal
 simulator&lt;/a&gt;,
 for testing my &lt;a href=&quot;https://github.com/ZipCPU/openarty/blob/master/rtl/gpsclock.v&quot;&gt;GPS time-tracking
 algorithm(s)&lt;/a&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;I am a firm believer in building a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Simulation&quot;&gt;simulation&lt;/a&gt; that you can interact
with using &lt;a href=&quot;/blog/2017/06/17/why-network-debugging.html&quot;&gt;a TCP/IP network
port&lt;/a&gt;.
This allows you to test/verify interacting with a design using your
production software.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;In &lt;a href=&quot;/zipcpu/2018/02/12/zbasic-intro.html&quot;&gt;one blog post&lt;/a&gt;
I discuss how to run the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
in an environment using a simulated serial port.&lt;/p&gt;

    &lt;p&gt;&lt;a href=&quot;/zipcpu/2018/02/12/zbasic-intro.html&quot;&gt;This blog post&lt;/a&gt;
also includes instructions for playing
&lt;a href=&quot;https://github.com/ZipCPU/tttt&quot;&gt;4x4x4 Tic-Tac-Toe&lt;/a&gt; on the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;–&lt;em&gt;running in simulation only&lt;/em&gt;.
If you’ve never tried &lt;a href=&quot;https://github.com/ZipCPU/tttt&quot;&gt;4x4x4 Tic-Tac-Toe&lt;/a&gt;, I
challenge you to try to beat the computer at the game.  It’s not unbeatable,
but the artificial intelligence used by that design is pretty good.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The &lt;a href=&quot;https://github.com/ZipCPU/vgasim&quot;&gt;VGA Simulation&lt;/a&gt; project contains
code for two &lt;a href=&quot;https://en.wikipedia.org/wiki/Simulation&quot;&gt;simulation&lt;/a&gt;
components within it.  (Both are
&lt;a href=&quot;/blog/2017/06/21/looking-at-verilator.html&quot;&gt;Verilator&lt;/a&gt;
based).&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 2: VGA Simulation, displays on a window of your screen&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/vgasim.png&quot; alt=&quot;&quot; width=&quot;360&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;ol&gt;
  &lt;li&gt;The &lt;a href=&quot;https://github.com/ZipCPU/vgasim/blob/master/bench/cpp/main_tb.cpp&quot;&gt;main_tb&lt;/a&gt;
  simulator simulates an &lt;a href=&quot;https://github.com/ZipCPU/vgasim/blob/master/rtl/wbvgaframe.v&quot;&gt;RTL
  design&lt;/a&gt;
  that &lt;a href=&quot;https://github.com/ZipCPU/vgasim/blob/master/rtl/imgfifo.v&quot;&gt;reads from a frame
  buffer&lt;/a&gt; in
  &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/bench/rtl/memdev.v&quot;&gt;memory&lt;/a&gt;
  and draws the contents of that frame buffer to the screen.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;You can see an example of the window this draws on my screen in Fig 2 on the
  right.&lt;/p&gt;

&lt;p&gt;The importance of having such a video &lt;a href=&quot;https://en.wikipedia.org/wiki/Simulation&quot;&gt;simulation&lt;/a&gt; capability can not be
  understated.  It is not that uncommon to have a bug in the graphics
  produced by a video-enabled design.  Just because you can see that bug on
  the screen doesn’t mean you can then find it within your design.&lt;/p&gt;

&lt;p&gt;By being able to run the design in a desktop application (i.e. in a
  &lt;a href=&quot;/blog/2017/06/21/looking-at-verilator.html&quot;&gt;Verilator&lt;/a&gt;
  &lt;a href=&quot;https://en.wikipedia.org/wiki/Simulation&quot;&gt;simulation&lt;/a&gt;)
  that recreates all of your logic, and saves every signal to a &lt;a href=&quot;/blog/2017/07/31/vcd.html&quot;&gt;trace
  file&lt;/a&gt;
  that can later be examined, finding and fixing bugs doesn’t become easy,
  &lt;em&gt;it becomes possible&lt;/em&gt;.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: left&quot;&gt;&lt;caption&gt;Fig 3: Creating a simulated video input&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/camsim.png&quot; alt=&quot;&quot; width=&quot;360&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;ol start=&quot;2&quot;&gt;
  &lt;li&gt;The other video &lt;a href=&quot;https://en.wikipedia.org/wiki/Simulation&quot;&gt;simulation&lt;/a&gt; is one I call
   &lt;a href=&quot;https://github.com/ZipCPU/vgasim/blob/master/bench/cpp/simcheck.cpp&quot;&gt;simcheck&lt;/a&gt;.
   This &lt;a href=&quot;https://en.wikipedia.org/wiki/Simulation&quot;&gt;simulation&lt;/a&gt; reads the 640x480 pixels at the top left of your screen,
   and creates Verilog signals from that portion of the screen that can then
   be ingested into your design.  (The frame size is configurable, as is the
   rest of the &lt;a href=&quot;https://en.wikipedia.org/wiki/XFree86_Modeline&quot;&gt;mode line&lt;/a&gt;.)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;If you just route these values into the other video
   &lt;a href=&quot;https://en.wikipedia.org/wiki/Co-simulation&quot;&gt;simulator&lt;/a&gt;,
   you can see the video output within a window on your desktop, as shown in
   Fig 3 on the left.  If you place that window near the same upper-left corner
   of your screen, you’ll get a cool recursive effect–also shown in Fig 3 on
   the left.&lt;/p&gt;

&lt;p&gt;Perhaps the best way I could describe all of this would be to point out a
&lt;a href=&quot;https://github.com/ZipCPU/fftdemo&quot;&gt;spectrogram&lt;/a&gt; design I recently built.
The &lt;a href=&quot;https://github.com/ZipCPU/fftdemo/blob/master/bench/cpp/main_tb.cpp&quot;&gt;simulation for this
demo&lt;/a&gt;
includes the &lt;a href=&quot;https://github.com/ZipCPU/wbpmic&quot;&gt;A/D simulator&lt;/a&gt; I mentioned
above, as well as the &lt;a href=&quot;https://github.com/ZipCPU/vgasim&quot;&gt;VGA output simulator&lt;/a&gt;.
Using this
&lt;a href=&quot;https://github.com/ZipCPU/fftdemo/blob/master/bench/cpp/main_tb.cpp&quot;&gt;simulation&lt;/a&gt;,
I can capture any
&lt;a href=&quot;/blog/2017/07/31/vcd.html&quot;&gt;trace&lt;/a&gt;,
and see every bit of logic flowing through my design
as it reads from a (simulated) A/D device, &lt;a href=&quot;https://github.com/ZipCPU/fftdemo/blob/master/rtl/subfildown.v&quot;&gt;filters and downsamples&lt;/a&gt; the signal,
takes a &lt;a href=&quot;https://github.com/ZipCPU/dblclockfft&quot;&gt;Fourier transform&lt;/a&gt;,
and then plots the result onto a window of my screen in a scrolling fashion.&lt;/p&gt;

&lt;p&gt;If I want, I can then even test other signal processing approaches, such as the
one shown below in Fig 4.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 4: High Resolution FFT Window Processing&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/tweets/fq-swepttone.png&quot; alt=&quot;&quot; width=&quot;640&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;This is what I mean by &lt;a href=&quot;https://en.wikipedia.org/wiki/Simulation&quot;&gt;simulation&lt;/a&gt;:
being able to repeat and test the entire design using software alone.&lt;/p&gt;

&lt;p&gt;Further, all of these &lt;a href=&quot;https://en.wikipedia.org/wiki/Simulation&quot;&gt;simulation&lt;/a&gt;
components are available for student use (and more):
they are (mostly) licensed under
&lt;a href=&quot;https://www.gnu.org/licenses/gpl-3.0.en.html&quot;&gt;GPLv3&lt;/a&gt;.
(Some are licensed under LGPLv3.)  If your instructor/advisor allows you to,
please feel free to try them and use them in one of your own projects.&lt;/p&gt;

&lt;h2 id=&quot;formal-verification&quot;&gt;Formal Verification&lt;/h2&gt;

&lt;p&gt;Since writing the original article on &lt;a href=&quot;/blog/2017/06/02/design-process.html&quot;&gt;The Actual Design
Process&lt;/a&gt;, I’ve come
across a new technique so powerful when it comes to finding bugs that my
own practices have since changed and changed significantly.  Instead of
&lt;a href=&quot;/blog/2017/06/23/my-dbg-philosophy.html&quot;&gt;first simulating any design
components&lt;/a&gt;, I now
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formally verify&lt;/a&gt;
every design component.  I use this new technique in place of bench testing:
it takes less work to do, finds bugs faster, and doesn’t require searching
through GB of
&lt;a href=&quot;/blog/2017/07/31/vcd.html&quot;&gt;traces&lt;/a&gt; to find any bugs.&lt;/p&gt;

&lt;p&gt;Why did I change?  I changed because none of my bench tests ever &lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;tested
enough of the design space&lt;/a&gt;.
This meant that I would then integrate design
components together that I &lt;em&gt;thought&lt;/em&gt; were working, only to &lt;a href=&quot;/zipcpu/2017/12/28/ugliest-bug.html&quot;&gt;later discover the
design as a whole wasn’t working&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Perhaps this would be during an integrated
&lt;a href=&quot;/blog/2017/06/21/looking-at-verilator.html&quot;&gt;Verilator&lt;/a&gt;-enabled
&lt;a href=&quot;https://en.wikipedia.org/wiki/Simulation&quot;&gt;simulation&lt;/a&gt;.  However, in that
environment, I’d find myself searching through 1-10GB
&lt;a href=&quot;/blog/2017/07/31/vcd.html&quot;&gt;trace&lt;/a&gt; files trying to find a
needle (the bug) in a haystack (the
&lt;a href=&quot;/blog/2017/07/31/vcd.html&quot;&gt;trace&lt;/a&gt;).
Worse, I might’ve tried to place the design onto an 
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
where I no longer have the same visibility into the design in order to
investigate any bugs.&lt;/p&gt;

&lt;p&gt;On the other hand, when using a
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal verification&lt;/a&gt;
approach, such as the one enabled by
&lt;a href=&quot;https://symbiyosys.readthedocs.io/en/latest&quot;&gt;SymbiYosys&lt;/a&gt;,
I’d find (and fix) many more bugs than I would’ve ever dreamed of testing while
trying to drive a simulation bench/test.  Even better, I can normally find
these bugs with between only 10-150 time-steps, and &lt;a href=&quot;/blog/2017/07/31/vcd.html&quot;&gt;trace
files&lt;/a&gt; less than 100kB in size.&lt;/p&gt;

&lt;p&gt;Having used
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal verification&lt;/a&gt;,
do I still use
&lt;a href=&quot;https://en.wikipedia.org/wiki/Simulation&quot;&gt;simulation&lt;/a&gt;?  Absolutely!
Although I’ve &lt;a href=&quot;/formal/2018/04/23/invariant.html&quot;&gt;discussed how to formally verify the aggregation of multiple
design components&lt;/a&gt;,
I have yet to learn how to do this reliably and in general with large
system level designs.&lt;/p&gt;

&lt;p&gt;That said, if you’ve never tried &lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal
methods&lt;/a&gt;,
then let me invite you to try out
&lt;a href=&quot;https://symbiyosys.readthedocs.io/en/latest&quot;&gt;SymbiYosys&lt;/a&gt;.
&lt;a href=&quot;https://symbiyosys.readthedocs.io/en/latest&quot;&gt;SymbiYosys&lt;/a&gt; is a free and
open-source program that can be used to formally verify a Verilog design.
Not only are there &lt;a href=&quot;https://github.com/YosysHQ/SymbiYosys/tree/master/docs/examples&quot;&gt;several example
designs&lt;/a&gt;,
in the &lt;a href=&quot;https://github.com/YosysHQ/SymbiYosys&quot;&gt;SymbiYosys repository&lt;/a&gt;,
but you can also find examples in many of &lt;a href=&quot;https://github.com/ZipCPU&quot;&gt;my own
repositories&lt;/a&gt;.  Look in the &lt;code class=&quot;highlighter-rouge&quot;&gt;bench/formal&lt;/code&gt;
subdirectory for any
&lt;a href=&quot;https://symbiyosys.readthedocs.io/en/latest&quot;&gt;SymbiYosys&lt;/a&gt;
scripts–those are the files that end in .sby.&lt;/p&gt;

&lt;p&gt;Thank you for that excellent question!&lt;/p&gt;
&lt;hr /&gt;&lt;p&gt;&lt;em&gt;Thou therefore which teachest another, teachest thou not thyself?  thou that preachest a man should not steal, dost thou steal? (Rom 2:21)&lt;/em&gt;</description>
        <pubDate>Wed, 22 Aug 2018 00:00:00 -0400</pubDate>
        <link>https://zipcpu.com/blog/2018/08/22/what-is-simulation.html</link>
        <guid isPermaLink="true">https://zipcpu.com/blog/2018/08/22/what-is-simulation.html</guid>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>How to build a SPI Flash Controller for an FPGA</title>
        <description>&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 1. The ICO board&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/icoBoard.Vorne.1.1.jpg&quot; alt=&quot;Picture of an ICO Board&quot; width=&quot;360&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Perhaps &lt;a href=&quot;/formal/2018/07/21/zipcpu-icoboard.html&quot;&gt;you may
remember&lt;/a&gt; that
I’ve been working to port the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
to an &lt;a href=&quot;http://www.latticesemi.com/Products/FPGAandCPLD/iCE40&quot;&gt;iCE40&lt;/a&gt; HX8k
platform: the &lt;a href=&quot;http://www.icoboard.org&quot;&gt;ICO board&lt;/a&gt;.  I like to boast that the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; was designed for low logic
applications, and the
&lt;a href=&quot;http://www.latticesemi.com/Products/FPGAandCPLD/iCE40&quot;&gt;iCE40&lt;/a&gt; is certainly a
low logic chip.  While the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
isn’t the &lt;em&gt;smallest&lt;/em&gt; processor out there, there are some forth processors
that are much smaller, it does fit nicely with room to spare on the
&lt;a href=&quot;http://www.latticesemi.com/Products/FPGAandCPLD/iCE40&quot;&gt;iCE40&lt;/a&gt; 8k.&lt;/p&gt;

&lt;p&gt;However, if you want a design that starts immediately upon power up, or if you
want more memory than is available in 8kB of block RAM or (in this case) even
in 128kB of &lt;a href=&quot;https://en.wikipedia.org/wiki/Static_random-access_memory&quot;&gt;SRAM&lt;/a&gt;,
then you need access to the &lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash
memory&lt;/a&gt;.
Why?  First, &lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash memory&lt;/a&gt; is
non-volatile, so anything that reads from it can do so immediately upon
power up.  Second, most
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;’s &lt;em&gt;need&lt;/em&gt; a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt; chip to store their design
within, so &lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt; chips are a
common addition on &lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt; boards.  Third,
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt;
is fairly cheap: a single 16MB
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt;
chip can sell for as little as $1 on
&lt;a href=&quot;https://www.digikey.com&quot;&gt;Digikey&lt;/a&gt;.  Given that my
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; design logic for the
&lt;a href=&quot;http://www.icoboard.org&quot;&gt;ICO board&lt;/a&gt; only requires about
132kB of memory, that leaves me with &lt;em&gt;lots&lt;/em&gt; of memory to play with … if I
just had a simple &lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt;
controller.&lt;/p&gt;

&lt;p&gt;I also had another reason for this project as well: I wanted to learn about
&lt;a href=&quot;http://www.asic-world.com/systemverilog/assertions4.html#Sequences&quot;&gt;System Verilog sequences&lt;/a&gt;,
and whether or not they could be used to &lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formally
verify&lt;/a&gt; a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/icozip/blob/master/rtl/icozip/spixpress.v&quot;&gt;controller&lt;/a&gt;.
Yes, I had access to the full commercial (&lt;a href=&quot;http://www.verific.com&quot;&gt;Verific&lt;/a&gt;
enabled) version of &lt;a href=&quot;http://www.clifford.at/yosys&quot;&gt;yosys&lt;/a&gt;
to do this.  But I wanted to see how useful this full version would be when
it came to designing a new/better &lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt; controller.&lt;/p&gt;

&lt;p&gt;So let’s see what it takes.&lt;/p&gt;

&lt;h2 id=&quot;lessons-learned-from-other-flash-controllers&quot;&gt;Lessons learned from other flash controllers&lt;/h2&gt;

&lt;p&gt;When I start any new design, my first step is to download the
&lt;a href=&quot;https://drive.google.com/file/d/0By-zY9AlHqXIcXZ6ZWdBR2dPXzg/view&quot;&gt;schematic&lt;/a&gt;
for the board that I have, and data sheets for all of the parts.  In this case, 
the &lt;a href=&quot;http://icoboard.org&quot;&gt;ICO board&lt;/a&gt; has a &lt;a href=&quot;http://www.cypress.com/file/177961/download&quot;&gt;Cypress S25FL127S 128 Mbit
(16MByte) chip&lt;/a&gt;
connected to the &lt;a href=&quot;http://www.latticesemi.com/Products/FPGAandCPLD/iCE40&quot;&gt;iCE40&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;.
I then spend some time reading the specifications and studying the
&lt;a href=&quot;https://drive.google.com/file/d/0By-zY9AlHqXIcXZ6ZWdBR2dPXzg/view&quot;&gt;schematic&lt;/a&gt;
before building anything.&lt;/p&gt;

&lt;p&gt;In this case, by the time I came to
&lt;a href=&quot;http://icoboard.org&quot;&gt;this board&lt;/a&gt;’s
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt;,
I had already built several
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt;
controllers before.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: left&quot;&gt;&lt;caption&gt;Fig 2. A Basys3 board&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/Basys3.png&quot; alt=&quot;Picture of an Basys3 Board&quot; width=&quot;360&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;The first &lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt; controller
I ever built was for the &lt;a href=&quot;https://store.digilentinc.com/basys-3-artix-7-fpga-trainer-board-recommended-for-introductory-users/&quot;&gt;Basys-3 board&lt;/a&gt;.
This board had a
&lt;a href=&quot;http://www.cypress.com/file/196861/download&quot;&gt;Spansion S25FL032P&lt;/a&gt; 4MB
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt;.
Since it was my first &lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt;
&lt;a href=&quot;https://opencores.org/project/qspiflash&quot;&gt;controller&lt;/a&gt; design, my goal was
to design something that could do everything:&lt;/p&gt;

    &lt;p&gt;– It could read the &lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt;
   at both high (QSPI) and low
   (&lt;a href=&quot;https://en.wikipedia.org/wiki/Serial_Peripheral_Interface&quot;&gt;SPI&lt;/a&gt;) speeds&lt;/p&gt;

    &lt;p&gt;– It could read the
   &lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt;’s internal
   configuration register in order to determine if the QSPI
   mode was even enabled&lt;/p&gt;

    &lt;p&gt;– It could both erase and program the
   &lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;– It could be used for reading the vendor identification words back from
   the &lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt;, and&lt;/p&gt;

    &lt;p&gt;– It could be used for reading the status register and/or writing the
   configuration register of the
   &lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt;.&lt;/p&gt;

    &lt;p&gt;&lt;a href=&quot;https://opencores.org/project/qspiflash&quot;&gt;This&lt;/a&gt; was a great general
purpose &lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt; controller,
and I’ve used it many times since.  However, all of this extra logic has
consequences when you want to place your design on a small board.  How bad?
&lt;a href=&quot;https://opencores.org/project/qspiflash&quot;&gt;It&lt;/a&gt; consumed about 1263
of the 7680 cells on an
&lt;a href=&quot;http://www.latticesemi.com/Products/FPGAandCPLD/iCE40&quot;&gt;iCE40&lt;/a&gt;,
or about 16% of the entire
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt; logic.&lt;/p&gt;

    &lt;p&gt;The other problem I had with this design was when I tried to place it onto
the Spartan 6/LX4 of the &lt;a href=&quot;https://store.digilentinc.com/cmod-s6-breadboardable-spartan-6-fpga-module&quot;&gt;CMod
S6&lt;/a&gt;.
Sure, there was plenty of room for the
&lt;a href=&quot;https://github.com/ZipCPU/s6soc/blob/master/rtl/wbqspiflash.v&quot;&gt;controller&lt;/a&gt;
and the &lt;a href=&quot;/blog/2017/06/05/wb-bridge-overview.html&quot;&gt;debugging
bus&lt;/a&gt;
I was using at the time–there just wasn’t much room for anything else.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 3. An Arty-A7 Board&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/arty-board.png&quot; alt=&quot;Picture of an Arty Board&quot; width=&quot;360&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;ol start=&quot;2&quot;&gt;
  &lt;li&gt;
    &lt;p&gt;Sometime later I decided I wanted to build a &lt;em&gt;high speed&lt;/em&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt; controller, so that I
could push &lt;a href=&quot;https://store.digilentinc.com/arty-a7-artix-7-fpga-development-board-for-makers-and-hobbyists&quot;&gt;Digilent’s Arty&lt;/a&gt;
up to a system clock rate of 200MHz.  Why 200MHz?
Because I had mistakenly thought this was the clock speed I’d need to use
to interact with the &lt;a href=&quot;https://en.wikipedia.org/wiki/DDR3_SDRAM&quot;&gt;DDR3 SDRAM&lt;/a&gt;
on board.  When I realized I &lt;a href=&quot;https://opencores.org/project/wbddr3&quot;&gt;couldn’t
interact&lt;/a&gt; with the
&lt;a href=&quot;https://en.wikipedia.org/wiki/DDR3_SDRAM&quot;&gt;SDRAM&lt;/a&gt;
any faster than about 82MHz, I abandoned &lt;a href=&quot;https://github.com/ZipCPU/openarty/blob/master/rtl/eqspiflash.v&quot;&gt;this
controller&lt;/a&gt;
and never used for any other projects.&lt;/p&gt;

    &lt;p&gt;Still, if the &lt;a href=&quot;http://opencores.org/project/qspiflash&quot;&gt;last controller&lt;/a&gt;
was full featured,
&lt;a href=&quot;https://github.com/ZipCPU/openarty/blob/master/rtl/eqspiflash.v&quot;&gt;this one&lt;/a&gt;
was even more so.
&lt;a href=&quot;https://github.com/ZipCPU/openarty/blob/master/rtl/eqspiflash.v&quot;&gt;It&lt;/a&gt;
not only allowed you to read and write any of several configuration
registers, it would also allow you to read and write the one-time
programmable (OTP) ROM.  Further, since I wanted this to run at 200MHz,
there was a lot of
&lt;a href=&quot;/blog/2017/08/14/strategies-for-pipelining.html&quot;&gt;pipelining&lt;/a&gt;
(and extra latency) to &lt;a href=&quot;https://github.com/ZipCPU/openarty/blob/master/rtl/eqspiflash.v&quot;&gt;this controller&lt;/a&gt;.&lt;/p&gt;

    &lt;p&gt;In hind sight, &lt;a href=&quot;https://github.com/ZipCPU/openarty/blob/master/rtl/eqspiflash.v&quot;&gt;this controller&lt;/a&gt;
was a boat anchor.  It’s bloated with features I never used and as a result
was way too big for the job.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;table align=&quot;center&quot; style=&quot;float: left&quot;&gt;&lt;caption&gt;Fig 4. A Cmod S6 board&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/cmods6.png&quot; alt=&quot;Picture of a CMod S6&quot; width=&quot;360&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;ol start=&quot;3&quot;&gt;
  &lt;li&gt;
    &lt;p&gt;However, when I needed to upgrade the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; in my
&lt;a href=&quot;https://github.com/ZipCPU/s6soc&quot;&gt;S6SoC design&lt;/a&gt; so that
it would support 8-bit bytes (the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; was originally a 32-bit byte
architecture), I needed to find &lt;a href=&quot;/blog/2017/06/12/minimizing-luts.html&quot;&gt;spare
LUTs&lt;/a&gt;
anywhere I could.  2,400 6-LUTs isn’t a lot of room for a multi-processing
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt;, and so I had to strip
everything out that I could.&lt;/p&gt;

    &lt;p&gt;The first thing to go was everything but the read capability from the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/s6soc/blob/master/rtl/wbsqspiflash.v&quot;&gt;controller&lt;/a&gt;.
That removed 30% of the logic in the controller.&lt;/p&gt;

    &lt;p&gt;It wasn’t enough.&lt;/p&gt;

    &lt;p&gt;Then I stepped back and realized that I would only ever run the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
from an already programmed
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt;, and that all I ever
&lt;em&gt;really&lt;/em&gt; needed from the &lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt;
was the ability to read from it.  I didn’t need to be able to read
the status register, the configuation register, the vendor’s ID, or anything
else: I just needed to read the &lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash
memory&lt;/a&gt;.&lt;/p&gt;

    &lt;p&gt;I also needed speed.&lt;/p&gt;

    &lt;p&gt;So I created a &lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash memory&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/s6soc/blob/master/rtl/qflashxpress.v&quot;&gt;controller&lt;/a&gt;
that used the Spartan 6’s DDR capability so that it could read
from the &lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt; at the system
clock speed.  This
provided a rough 2x improvement in speed.  Further, the rewrite to create
this capability, and this capability alone dropped the
&lt;a href=&quot;/blog/2017/06/12/minimizing-luts.html&quot;&gt;number of LUTs&lt;/a&gt;
used by the &lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt; from
(roughly) 569 down to about 100 or so.&lt;/p&gt;

    &lt;p&gt;(These numbers are approximate because
&lt;a href=&quot;http://www.clifford.at/yosys&quot;&gt;yosys&lt;/a&gt; doesn’t yet pack
&lt;a href=&quot;https://www.xilinx.com&quot;&gt;Xilinx&lt;/a&gt;
LUT’s together, but they do give an idea of usage.)&lt;/p&gt;

    &lt;p&gt;Since &lt;a href=&quot;https://github.com/ZipCPU/s6soc/blob/master/rtl/qflashxpress.v&quot;&gt;this
controller&lt;/a&gt;
offered only a read capability and nothing more, I
called it my &lt;a href=&quot;https://github.com/ZipCPU/s6soc/blob/master/rtl/qflashxpress.v&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;qflashxpress&lt;/code&gt;&lt;/a&gt; controller.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 5. A TinyFPGA Bx&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/TinyFPGA-BX.png&quot; alt=&quot;Picture of a TinyFPGA BX baord&quot; width=&quot;120&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;ol start=&quot;4&quot;&gt;
  &lt;li&gt;
    &lt;p&gt;I recently started working on a fourth
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/tinyzip/blob/master/rtl/dualflexpress.v&quot;&gt;controller&lt;/a&gt;
modeled after this last one, but using the Dual SPI read mode of the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt;.  &lt;a href=&quot;https://github.com/ZipCPU/tinyzip/blob/master/rtl/dualflexpress.v&quot;&gt;This
controller&lt;/a&gt;
is designed to support the
&lt;a href=&quot;http://www.latticesemi.com/Products/FPGAandCPLD/iCE40&quot;&gt;iCE40&lt;/a&gt;
on the &lt;a href=&quot;https://tinyfpga.com&quot;&gt;TinyFPGA BX&lt;/a&gt;.  However, on my pre-production
version of the &lt;a href=&quot;https://tinyfpga.com&quot;&gt;TinyFPGA BX&lt;/a&gt;, only the MISO and MOSI
lines are connected to the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt;, so the best/fastest I
could ever do is Dual SPI which would only allow me to read/write two
bits at a time.  (I have been assured that this has been fixed for the
production versions.)&lt;/p&gt;

    &lt;p&gt;Unlike the previous &lt;a href=&quot;https://github.com/ZipCPU/s6soc/blob/master/rtl/qflashxpress.v&quot;&gt;qflashxpress
controller&lt;/a&gt;,
I wanted the erase/program capability back.  Rather
then teach the HDL controller all of the necessary states associated with
erasing and reprogramming a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt;, I initially created
a bit banging port that could override the natural logic of the port.&lt;/p&gt;

    &lt;p&gt;The more I thought this through, though, the more I realized that bit banging
over the &lt;a href=&quot;https://github.com/ZipCPU/dbgbus/tree/master/hexbus&quot;&gt;debugging bus&lt;/a&gt;
would be horrendously inefficient.  Better yet, the
code already had the capability to send data to and receive data from the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt;, why not just
adjust the configuration access so that it can command an 8-bit transfer?&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;That leads me to the basic &lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/icozip/blob/master/rtl/icozip/spixpress.v&quot;&gt;controller&lt;/a&gt;
I want to discuss today.&lt;/p&gt;

&lt;p&gt;Why do I need a new &lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/icozip/blob/master/rtl/icozip/spixpress.v&quot;&gt;controller&lt;/a&gt;?
For a couple of reasons.  The first and perhaps more important is
the reality of how the &lt;a href=&quot;http://www.icoboard.org&quot;&gt;ICO board&lt;/a&gt; was wired.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 6. ICO Board hardware overview&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/ico-hwoverview.svg&quot; alt=&quot;Overview of the ICO board&#39;s hardware architecture&quot; width=&quot;640&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;In order to make certain that both the &lt;a href=&quot;https://www.raspberrypi.org&quot;&gt;Raspberry
Pi&lt;/a&gt; &lt;em&gt;and&lt;/em&gt; the
&lt;a href=&quot;http://www.latticesemi.com/Products/FPGAandCPLD/iCE40&quot;&gt;iCE40&lt;/a&gt; could
control the &lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt; memory, the
memory was routed through a
&lt;a href=&quot;https://www.latticesemi.com/Products/FPGAandCPLD/MachXO2&quot;&gt;MachXO2&lt;/a&gt; chip
as a traffic controller.  However, the
&lt;a href=&quot;https://www.latticesemi.com/Products/FPGAandCPLD/MachXO2&quot;&gt;MachXO2&lt;/a&gt; as wired
has no capability of dynamically controlling pin direction–the pins can only
ever go one way–either master in and slave out (MISO), or master out and
slave in (MOSI).  In other words,
any &lt;a href=&quot;https://github.com/ZipCPU/icozip/blob/master/rtl/icozip/spixpress.v&quot;&gt;flash controller&lt;/a&gt;
for the &lt;a href=&quot;http://www.icoboard.org&quot;&gt;ICO board&lt;/a&gt; can only ever use the traditional
&lt;a href=&quot;https://en.wikipedia.org/wiki/Serial_Peripheral_Interface&quot;&gt;SPI&lt;/a&gt; mode, and
thus any DSPI or QSPI enabled controller will only consume excess and unused
logic in an already tight space.&lt;/p&gt;

&lt;p&gt;All this is to say that this is my now a fifth generation
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/icozip/blob/master/rtl/icozip/spixpress.v&quot;&gt;controller&lt;/a&gt;
for me.  I’ve also learned along the way what’s important in a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/icozip/blob/master/rtl/icozip/spixpress.v&quot;&gt;controller&lt;/a&gt;:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;First and foremost, the
&lt;a href=&quot;https://github.com/ZipCPU/icozip/blob/master/rtl/icozip/spixpress.v&quot;&gt;controller&lt;/a&gt;:
must be able to read from the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt;.  It must do this
function well and fast, since this is its purpose for being.  As you’ll
see, with no other logic this will cost us 147 of the 7680 cells on the
&lt;a href=&quot;http://www.latticesemi.com/Products/FPGAandCPLD/iCE40&quot;&gt;iCE40&lt;/a&gt;.&lt;/p&gt;

    &lt;p&gt;If I wanted, I could stop here.  Nothing more is really required.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Second, as an optional performance improvement, it should be able to read
data from the &lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt; in
long strings of uninterrupted transactions.
Adding this logic to the controller will eventually cost us another 88
&lt;a href=&quot;http://www.latticesemi.com/Products/FPGAandCPLD/iCE40&quot;&gt;iCE40&lt;/a&gt; logic
cells.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Third, as a second optional enhancement, it needs to support a single
configuration register providing access to the rest of the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt;’s
capabilities without burdening the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/icozip/blob/master/rtl/icozip/spixpress.v&quot;&gt;controller&lt;/a&gt;
with unnecessary features.  This final feature will cost an additional
38 logic cells, bringing our entire total up to 273 logic cells out of
7680, or about 3% of the entire design.&lt;/p&gt;

    &lt;p&gt;This is a reasonable usage number for our purposes.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;That’s &lt;a href=&quot;https://github.com/ZipCPU/icozip/blob/master/rtl/icozip/spixpress.v&quot;&gt;the controller&lt;/a&gt;
we’ll examine today.&lt;/p&gt;

&lt;h2 id=&quot;basic-spi&quot;&gt;Basic SPI&lt;/h2&gt;

&lt;p&gt;If you are not familiar with the &lt;a href=&quot;https://en.wikipedia.org/wiki/Serial_Peripheral_Interface&quot;&gt;Serial Peripheral Interconnect
(SPI)&lt;/a&gt; means
of communicating between digital components, then let me recommend the
&lt;a href=&quot;https://www.fpga4fun.com/SPI.html&quot;&gt;SPI article on fpga4fun.com&lt;/a&gt;.  It’s short,
and it explains a lot of good details about the &lt;a href=&quot;https://en.wikipedia.org/wiki/Serial_Peripheral_Interface&quot;&gt;SPI
protocol&lt;/a&gt;
that you might find valuable.  In sum, it describes what can be a shared bus,
with typically a single master and many slaves, operating over a
synchronous (i.e. clocked) interface.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 7. A basic SPI transaction&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/spi-raw.svg&quot; alt=&quot;Wiring diagram showing a SPI transaction&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;The basic wires associated with this interface are:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;CS_n&lt;/code&gt;, a ‘negative logic’ chip select sometimes called &lt;code class=&quot;highlighter-rouge&quot;&gt;SS&lt;/code&gt; for the “slave
select” line.  This is the one line that is unique to each bus slave.
It is used to create a capability whereby multiple chips can have access to
the &lt;a href=&quot;https://en.wikipedia.org/wiki/Serial_Peripheral_Interface&quot;&gt;SPI&lt;/a&gt;
bus at the same time.  The “master” simply selects the one chip it is
interested in.  The other chips are then required to place their output
pin into a high impedance state and to ignore any transactions for which
they are not selected.&lt;/p&gt;

    &lt;p&gt;This means that anytime &lt;code class=&quot;highlighter-rouge&quot;&gt;CS_n&lt;/code&gt; is high, the chip of interest is not selected
and all of other wires are “don’t cares”.&lt;/p&gt;

    &lt;p&gt;The &lt;code class=&quot;highlighter-rouge&quot;&gt;CS_n&lt;/code&gt; signal is also be used for synchronization.  Pulling this wire
low (active) signals to the slave the beginning of a transaction, and
hence the slave knows which bit is the “first” bit of the transaction packet.&lt;/p&gt;

    &lt;p&gt;Today, we’ll be focusing on the interaction associated with a single chip.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;SCK&lt;/code&gt; is the serial clock.  Since this is a clocked interface, &lt;code class=&quot;highlighter-rouge&quot;&gt;SCK&lt;/code&gt; provides
that clock.  The
&lt;a href=&quot;https://en.wikipedia.org/wiki/Serial_Peripheral_Interface&quot;&gt;SPI&lt;/a&gt;
protocol allows for several definitions of how this clock needs to be
implemented, so check the chip you wish to interface with to double check
for example the polarity and phase of the clock signal that it is expecting.&lt;/p&gt;

    &lt;p&gt;For our implementation below, we’ll insist that &lt;code class=&quot;highlighter-rouge&quot;&gt;SCK&lt;/code&gt; be high any time
&lt;code class=&quot;highlighter-rouge&quot;&gt;CS_n&lt;/code&gt; is inactive, even though technically this is a “don’t care” signal
in such cases.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;MOSI&lt;/code&gt;.  I pronounce this wire as “MOH-see”, although it’s technically the
acronymn, “Master Out Slave In”.  Some chips will call this wire SDI for
Slave Data In or even just SI for Slave Input.  This is the one wire
running from the master to all of the
slaves containing information coming from the master.&lt;/p&gt;

    &lt;p&gt;As with the clock, pay attention to your chips specification of this signal.
We’ll treat this signal today as a signal that can only change on the
negative edge of &lt;code class=&quot;highlighter-rouge&quot;&gt;SCK&lt;/code&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;MISO&lt;/code&gt;, or “MEE-soh” as I like to pronounce it, is the “Master In, Slave Out”
wire–a single wire interface shared among all
&lt;a href=&quot;https://en.wikipedia.org/wiki/Serial_Peripheral_Interface&quot;&gt;SPI&lt;/a&gt;
slaves and containing the data being returned from the selected slave device.
Some chips will call this wire SDO for Slave Data Out, or even SO for Slave
Output.  All of these terms refer to the same basic wire.&lt;/p&gt;

    &lt;p&gt;Check the specification of the chip you are working with for details on this
signal, but from my experience this signal tends to change some number of &lt;code class=&quot;highlighter-rouge&quot;&gt;ns&lt;/code&gt;
following the last negative &lt;code class=&quot;highlighter-rouge&quot;&gt;SCK&lt;/code&gt; edge.  It should be stable whenever &lt;code class=&quot;highlighter-rouge&quot;&gt;SCK&lt;/code&gt;
is high, as long as you don’t make &lt;code class=&quot;highlighter-rouge&quot;&gt;SCK&lt;/code&gt; run too fast,
so you can read it any time &lt;code class=&quot;highlighter-rouge&quot;&gt;SCK&lt;/code&gt; is high.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;These are the basic signals we’ll be working with.&lt;/p&gt;

&lt;p&gt;A &lt;a href=&quot;https://en.wikipedia.org/wiki/Serial_Peripheral_Interface&quot;&gt;SPI&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt; doesn’t typically use the
full interface capabilities, however.  Instead, every
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Serial_Peripheral_Interface&quot;&gt;SPI&lt;/a&gt;
protocol I’ve read about has actually been a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Simplex_communication&quot;&gt;Simplex&lt;/a&gt;,
or one-way, protocol.  The basic
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt;
transaction involves sending an 8-bit command, followed by any command specific
arguments (if any–depends upon the command), after which the slave will
return some kind of response.  In no part of this process are both &lt;code class=&quot;highlighter-rouge&quot;&gt;MISO&lt;/code&gt; and
&lt;code class=&quot;highlighter-rouge&quot;&gt;MOSI&lt;/code&gt; lines containing valid data going in opposite directions at the same
time.
Either the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/icozip/blob/master/rtl/icozip/spixpress.v&quot;&gt;controller&lt;/a&gt;
is sending data to the &lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt; chip,
or the data is going in the reverse direction.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 8. SPI for Flash is a Simplex Protocol&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/spi-simplex.svg&quot; alt=&quot;Wiring diagram, showing a simplex SPI transaction--MISO is unsed during command, MOSI is unused during a response&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;If you examine the
&lt;a href=&quot;http://www.cypress.com/file/177961/download&quot;&gt;specification&lt;/a&gt;
for the &lt;a href=&quot;http://www.cypress.com/file/177961/download&quot;&gt;Cypress Flash&lt;/a&gt;
device on the
&lt;a href=&quot;http://www.icoboard.org&quot;&gt;ICO board&lt;/a&gt;, and look closely through it, you’ll
quickly discover that all transactions are composed of sequences of octets
(8-bits)–just like we discussed above.  This is common among
&lt;a href=&quot;https://en.wikipedia.org/wiki/Serial_Peripheral_Interface&quot;&gt;SPI&lt;/a&gt; based
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt; chips.&lt;/p&gt;

&lt;p&gt;Those first 8-bits of the transaction, though, are the important ones.  Hence
the &lt;a href=&quot;http://www.cypress.com/file/177961/download&quot;&gt;spec&lt;/a&gt;
outlines all the different commands that can be started from any 8-bit
value.  The command set is rather long, though, stretching across both
page 109 and 110–so I’ll only reference it here.  Further, there’s a whole
chapter devoted to walking through each of the commands in detail.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 9. Basic Flash I/O chip pins&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/spix-io-pins.svg&quot; alt=&quot;&quot; width=&quot;420&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;This &lt;a href=&quot;https://en.wikipedia.org/wiki/Simplex_communication&quot;&gt;simplex&lt;/a&gt;
command response protocol also allows particular bastardizations of the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Serial_Peripheral_Interface&quot;&gt;SPI&lt;/a&gt;
protocol whereby the &lt;code class=&quot;highlighter-rouge&quot;&gt;MISO&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;MOSI&lt;/code&gt; lines are re-purposed into bi-directional
wires: the master might send on both bits during the argument period of the
command, and then receive on both bits during the response period.  This is
called “Dual SPI” mode, or DSPI for short.  Many
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt;
chips (including &lt;a href=&quot;http://www.cypress.com/file/177961/download&quot;&gt;this one&lt;/a&gt;)
also have two other wires, a negative logic reset/hold pin and a negative logic
write protect pin.  These can also be re-purposed into further bidirectional
data wires, creating a four-wire bidirectional data bus for even faster
communication.  This four wire mode is often called “Quad SPI”, or QSPI
for short.&lt;/p&gt;

&lt;p&gt;Today, we’ll be looking at two basic capabilities, both within the basic
&lt;a href=&quot;https://en.wikipedia.org/wiki/Serial_Peripheral_Interface&quot;&gt;SPI&lt;/a&gt; protocol.
The first capability will send a &lt;em&gt;read&lt;/em&gt; command to the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt;,
and then read data back in the response.  This will be our basic read
capability.  The second will send an arbitrary 8-bit command to the flash,
and then maintain the &lt;code class=&quot;highlighter-rouge&quot;&gt;CS_n&lt;/code&gt; pin low and the &lt;code class=&quot;highlighter-rouge&quot;&gt;SCK&lt;/code&gt; pin stable (and high) until
either another command is received, or our
&lt;a href=&quot;https://github.com/ZipCPU/icozip/blob/master/rtl/icozip/spixpress.v&quot;&gt;controller&lt;/a&gt;
is explicitly told to adjust them again.&lt;/p&gt;

&lt;h3 id=&quot;read-only&quot;&gt;Read only&lt;/h3&gt;

&lt;p&gt;If you look through the command table on &lt;a href=&quot;http://www.cypress.com/file/177961/download&quot;&gt;page 109 of the specification for
this chip&lt;/a&gt;, you’ll notice several
commands that can be used to read from the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt;.  There’s the &lt;code class=&quot;highlighter-rouge&quot;&gt;READ&lt;/code&gt;
command which tops out at a maximum &lt;code class=&quot;highlighter-rouge&quot;&gt;SCK&lt;/code&gt; clock rate of &lt;code class=&quot;highlighter-rouge&quot;&gt;50MHz&lt;/code&gt;, the
&lt;code class=&quot;highlighter-rouge&quot;&gt;FAST_READ&lt;/code&gt;, topping out at 108MHz, the &lt;code class=&quot;highlighter-rouge&quot;&gt;DOR&lt;/code&gt; or dual read output, and the
&lt;code class=&quot;highlighter-rouge&quot;&gt;QOR&lt;/code&gt; or quad read output.  There are also some faster read commands, such as
the &lt;code class=&quot;highlighter-rouge&quot;&gt;DIOR&lt;/code&gt; or dual I/O read and the &lt;code class=&quot;highlighter-rouge&quot;&gt;QIOR&lt;/code&gt; or quad I/O read.  There are also
4-byte address commands, although they are not required on this &lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;From my own experience, I have found that the reads delivering 4-bits at a
time are the fastest, especially when you can start the transaction immediately
with the address in what is sometimes called
&lt;a href=&quot;https://en.wikipedia.org/wiki/Execute_in_place&quot;&gt;XIP&lt;/a&gt; mode–but we’ll have
to leave that discussion for another day, since the
&lt;a href=&quot;http://www.icoboard.org&quot;&gt;ICO board&lt;/a&gt; layout doesn’t support these
high speed access modes.&lt;/p&gt;

&lt;p&gt;So let’s return to the basic &lt;code class=&quot;highlighter-rouge&quot;&gt;READ&lt;/code&gt; command.  This command starts from
the device in its idle or default state, requires the controller to send an
8-bit &lt;code class=&quot;highlighter-rouge&quot;&gt;READ&lt;/code&gt; command to the device (&lt;code class=&quot;highlighter-rouge&quot;&gt;8&#39;h03&lt;/code&gt;), followed by a 3-byte (24-bit)
address.  Once done, the device will return bytes to us in sequence from the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt;, starting at the
address we give it and incrementing by one for each byte read.&lt;/p&gt;

&lt;p&gt;The &lt;a href=&quot;http://www.cypress.com/file/177961/download&quot;&gt;spec&lt;/a&gt; shows a picture of
this operation for us, which I’ve copied below into Fig 10.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 10. The basic command to read from flash&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/spi-spec.png&quot; alt=&quot;&quot; width=&quot;799&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Unlike many of the other things we’ve discussed, a &lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt; interaction is very
much an organized interaction over many clock cycles.
Let’s copy our interaction into
&lt;a href=&quot;https://www.wavedrom.com/editor.html&quot;&gt;wavedrom&lt;/a&gt; where we can edit it, and
then take another look again.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 11. Beginning our transaction design&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/spi-bare.svg&quot; alt=&quot;&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;This now becomes our goal–the specification our component must match.&lt;/p&gt;

&lt;p&gt;One key point in this picture is the clock rate.  The device will limit our
maximum &lt;code class=&quot;highlighter-rouge&quot;&gt;SCK&lt;/code&gt; rate to 50MHz when using the basic read command, &lt;code class=&quot;highlighter-rouge&quot;&gt;8&#39;h03&lt;/code&gt;.  Given that my goal system clock rate for &lt;a href=&quot;https://github.com/ZipCPU/icozip&quot;&gt;this
design&lt;/a&gt; is 50MHz as well, this will work well.&lt;/p&gt;

&lt;p&gt;But how to get an &lt;code class=&quot;highlighter-rouge&quot;&gt;SCK&lt;/code&gt;	of 50MHz from a 50MHz system clock?  To do this, &lt;a href=&quot;https://github.com/ZipCPU/icozip/blob/master/rtl/icozip/oclkddr.v&quot;&gt;we’ll
use&lt;/a&gt;
a &lt;code class=&quot;highlighter-rouge&quot;&gt;DDR&lt;/code&gt; output function of the &lt;code class=&quot;highlighter-rouge&quot;&gt;SB_IO&lt;/code&gt; primitive provided by the
&lt;a href=&quot;http://www.latticesemi.com/Products/FPGAandCPLD/iCE40&quot;&gt;iCE40&lt;/a&gt;.
That will allow us to run all of our logic at full speed,
even though this clock signal will toggle twice as fast as our logic.&lt;/p&gt;

&lt;p&gt;Before moving forward, let’s add one more design requirement to the
waveform file in Fig 11:  Our
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/icozip/blob/master/rtl/icozip/spixpress.v&quot;&gt;controller&lt;/a&gt;
must also interact with a &lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;Wishbone
bus&lt;/a&gt;.  Let’s think about
how we’ll do this for a moment.  Ideally, the
&lt;a href=&quot;https://github.com/ZipCPU/icozip/blob/master/rtl/icozip/spixpress.v&quot;&gt;controller&lt;/a&gt;
will need to accept a request from the bus, and then immediately
start the read transaction with the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt; chip.  Once done, the
&lt;a href=&quot;https://github.com/ZipCPU/icozip/blob/master/rtl/icozip/spixpress.v&quot;&gt;controller&lt;/a&gt;
will need to return a response, &lt;code class=&quot;highlighter-rouge&quot;&gt;o_wb_ack&lt;/code&gt; and
&lt;code class=&quot;highlighter-rouge&quot;&gt;o_wb_data&lt;/code&gt;, to the same bus.  All in all, this should look something like
Fig 12 below.  In between the request and the acknowledgment, the &lt;code class=&quot;highlighter-rouge&quot;&gt;o_wb_stall&lt;/code&gt;
signal should be high.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 12. Bus read transaction&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/spi-read.svg&quot; alt=&quot;&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Notice also that I added two other control wires to this picture: &lt;code class=&quot;highlighter-rouge&quot;&gt;ack_delay&lt;/code&gt;
is an internal counter, and &lt;code class=&quot;highlighter-rouge&quot;&gt;o_spi_sck&lt;/code&gt; is an output from our
&lt;a href=&quot;https://github.com/ZipCPU/icozip/blob/master/rtl/icozip/spixpress.v&quot;&gt;controller&lt;/a&gt;
to the &lt;a href=&quot;https://github.com/ZipCPU/icozip/blob/master/rtl/icozip/oclkddr.v&quot;&gt;DDR output
module&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The &lt;code class=&quot;highlighter-rouge&quot;&gt;ack_delay&lt;/code&gt; counter will be used to keep track of where
we are in the sequence.  This is shown at the bottom of Fig 12 above.  Once
&lt;code class=&quot;highlighter-rouge&quot;&gt;ack_delay&lt;/code&gt; hits zero, we should be done with our transaction.  If you look
in the sequence above, you’ll notice that the same clock &lt;code class=&quot;highlighter-rouge&quot;&gt;ack_delay&lt;/code&gt; hits
zero is also the clock &lt;code class=&quot;highlighter-rouge&quot;&gt;o_wb_ack&lt;/code&gt; is high, &lt;code class=&quot;highlighter-rouge&quot;&gt;o_wb_data&lt;/code&gt; is valid, &lt;code class=&quot;highlighter-rouge&quot;&gt;o_wb_stall&lt;/code&gt;
returns to zero, and &lt;code class=&quot;highlighter-rouge&quot;&gt;CS_n&lt;/code&gt; returns high.&lt;/p&gt;

&lt;p&gt;The &lt;code class=&quot;highlighter-rouge&quot;&gt;o_spi_sck&lt;/code&gt; signal also needs a bit more explanation.  This isn’t the
actual &lt;code class=&quot;highlighter-rouge&quot;&gt;SCK&lt;/code&gt; signal going to the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt; chip, but rather
a signal to the &lt;a href=&quot;https://github.com/ZipCPU/icozip/blob/master/rtl/icozip/oclkddr.v&quot;&gt;DDR output
module&lt;/a&gt;
telling it to toggle the clock.  You may notice that this signal is set
immediately after the
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;Wishbone&lt;/a&gt;
strobe (request) signal is accepted (i.e. strobe is high and stall is low).
However, the &lt;code class=&quot;highlighter-rouge&quot;&gt;SCK&lt;/code&gt; signal doesn’t start toggling for another clock period
after setting this &lt;code class=&quot;highlighter-rouge&quot;&gt;o_spi_sck&lt;/code&gt; signal high.  (This was unexpected, and so
we’ll discuss this again in our testing section below.  This one clock change
forced me to delay all of the other signals by one clock, as already shown in
Fig 12 above.&lt;/p&gt;

&lt;p&gt;For now, though, let’s return to that &lt;code class=&quot;highlighter-rouge&quot;&gt;ack_delay&lt;/code&gt; signal and just point out that
we’ll be using this signal internally to control a basic state machine.&lt;/p&gt;

&lt;p&gt;We’ll start our state machine with a “bus request”: a request to read from the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash memory&lt;/a&gt;.  That will look
something like:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;wire	bus_request;
assign	bus_request = (i_wb_stb)&amp;amp;&amp;amp;(!o_wb_stall)&amp;amp;&amp;amp;(!i_wb_we);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;We can then use this &lt;code class=&quot;highlighter-rouge&quot;&gt;bus_request&lt;/code&gt; signal to start our &lt;code class=&quot;highlighter-rouge&quot;&gt;ack_delay&lt;/code&gt; counter.
Once started, &lt;code class=&quot;highlighter-rouge&quot;&gt;ack_delay&lt;/code&gt; will just count down to zero, when we will
acknowledge the bus request.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;initial	ack_delay = 0;
always @(posedge i_clk)
if (bus_request)
	ack_delay &amp;lt;= 6&#39;d65;
else if (ack_delay &amp;gt; 0)
	ack_delay &amp;lt;= ack_delay - 1&#39;b0;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The second piece of circuitry we’ll want is a shift register controlling the
&lt;code class=&quot;highlighter-rouge&quot;&gt;MOSI&lt;/code&gt; values that we send to the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Serial_Peripheral_Interface&quot;&gt;SPI&lt;/a&gt;
interface.  This will include both our command, &lt;code class=&quot;highlighter-rouge&quot;&gt;8&#39;h03&lt;/code&gt;, and the address we
wish to read from, &lt;code class=&quot;highlighter-rouge&quot;&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;i_wb_address,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;2&#39;b0&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;.  (The last two bits are zero,
because the &lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;Wishbone&lt;/a&gt;
address is a word address, not a byte address.) Since we know the address at
time zero when the &lt;code class=&quot;highlighter-rouge&quot;&gt;bus_request&lt;/code&gt; is made, this can be as simple as,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
if (bus_request)
	// Here&#39;s the data stream we wish to send
	wdata_pipe   &amp;lt;= { 1&#39;b0, 8&#39;h03, i_wb_address };
else
	wdata_pipe &amp;lt;= { wdata_pipe[31:0], 1&#39;b0 };

assign	o_spi_mosi = wdata_pipe[32];&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Note the extra zero bit out front.  This is due to the extra clock it takes to
start the DDR &lt;a href=&quot;https://en.wikipedia.org/wiki/Serial_Peripheral_Interface&quot;&gt;SPI&lt;/a&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;SCK&lt;/code&gt; signal that we mentioned above, and diagrammed in Fig 12.&lt;/p&gt;

&lt;p&gt;All that remains is to set the rest of our signals based upon this counter,
using Fig. 12 above as a guide.  Remember, signals that are set on the
positive edge of a clock need to be set one clock before they are to be valid.
Hence, if you want to set the &lt;code class=&quot;highlighter-rouge&quot;&gt;CS_n&lt;/code&gt; signal high so that it is
high when &lt;code class=&quot;highlighter-rouge&quot;&gt;ack_delay&lt;/code&gt; returns to zero, you’ll want to set it that way when
&lt;code class=&quot;highlighter-rouge&quot;&gt;ack_delay&lt;/code&gt; is &lt;code class=&quot;highlighter-rouge&quot;&gt;7&#39;d1&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;First, upon a bus request, we would get things started.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
if (bus_request)
begin
	o_spi_cs_n &amp;lt;= 1&#39;b0;
	o_spi_sck  &amp;lt;= 1&#39;b1;

	o_wb_ack   &amp;lt;= 1&#39;b0;
	o_wb_stall &amp;lt;= 1&#39;b1;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Then, while things are running, we update any signals.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;end else if (ack_delay &amp;gt; 1)
begin
	o_spi_cs_n &amp;lt;= 1&#39;b0;
	o_spi_sck  &amp;lt;= (ack_delay &amp;gt; 2);

	o_wb_ack   &amp;lt;= 1&#39;b0;
	o_wb_stall &amp;lt;= 1&#39;b1;
	o_wb_data  &amp;lt;= { o_wb_data[30:0], i_spi_miso };&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Once we get to the end, we’ll need to shut down our interface and return
an acknowledgment and our data.  We can also turn the stall signal off
at this time.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;end else if (ack_delay == 1)
begin
	// Turn off the interface
	o_spi_cs_n &amp;lt;= 1&#39;b1;
	o_spi_sck  &amp;lt;= 1&#39;b0;

	o_wb_ack   &amp;lt;= 1&#39;b1;
	o_wb_stall &amp;lt;= 1&#39;b0;
	o_wb_data  &amp;lt;= { o_wb_data[30:0], i_spi_miso };&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Finally, if &lt;code class=&quot;highlighter-rouge&quot;&gt;ack_delay==0&lt;/code&gt; and there’s no &lt;code class=&quot;highlighter-rouge&quot;&gt;bus_request&lt;/code&gt;, then we just want
our interface to remain idle.  We’ll also quietly ignore any write requests
from the bus, acknowledging them immediately while we are idle.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;end else begin
	// Interface is idle
	o_spi_cs_n &amp;lt;= 1&#39;b1;
	o_spi_sck  &amp;lt;= 1&#39;b0;

	o_wb_ack   &amp;lt;= (i_wb_stb)&amp;amp;&amp;amp;(i_wb_we);
	o_wb_stall &amp;lt;= 1&#39;b0;
end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This is our primary capability.  We could ideally stop here if all you wanted
was a simple &lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/icozip/blob/master/rtl/icozip/spixpress.v&quot;&gt;controller&lt;/a&gt;
to only read from your &lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&quot;second-piped-reads-as-well&quot;&gt;Second: Piped reads as well&lt;/h3&gt;

&lt;p&gt;One problem with stopping here, though, is that this approach to reading from a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt; memory is &lt;em&gt;painfully&lt;/em&gt;
slow–especially for a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Soft_microprocessor&quot;&gt;soft-core CPU&lt;/a&gt;
when its speed is limited by the speed it can read instructions from the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt;.
If you just count clock cycles, then the
&lt;a href=&quot;https://github.com/ZipCPU/icozip/blob/master/rtl/icozip/spixpress.v&quot;&gt;controller&lt;/a&gt;
as is takes 66 cycles per
read.  This will limit any
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;’s speed to
66 &lt;a href=&quot;https://en.wikipedia.org/wiki/Cycles_per_instruction&quot;&gt;cycles per instruction
(CPI)&lt;/a&gt;.  While this
may be faster than your average snail, I’d like &lt;a href=&quot;/about/zipcpu.html&quot;&gt;my
CPU&lt;/a&gt; to run a bit faster.&lt;/p&gt;

&lt;p&gt;If you remember our &lt;a href=&quot;/zipcpu/2018/03/21/dblfetch.html&quot;&gt;discussion about pipelining a
prefetch&lt;/a&gt;, then
you’ll remember how I managed to keep a rolling
&lt;a href=&quot;/zipcpu/2017/11/18/wb-prefetch.html&quot;&gt;prefetch&lt;/a&gt;
going in the presence of a &lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt;
device.  That would increase the speed of a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt; bound
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;
from 66
&lt;a href=&quot;https://en.wikipedia.org/wiki/Cycles_per_instruction&quot;&gt;CPI&lt;/a&gt;
(minimum) up to 33 
&lt;a href=&quot;https://en.wikipedia.org/wiki/Cycles_per_instruction&quot;&gt;CPI&lt;/a&gt;.  It’s
still a snail’s pace, but a factor of two better is still a factor of two.&lt;/p&gt;

&lt;p&gt;How might we do this?&lt;/p&gt;

&lt;p&gt;The first step is to go back to the
&lt;a href=&quot;http://www.cypress.com/file/177961/download&quot;&gt;specfication&lt;/a&gt; for our
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt; chip, and then to
remember that once the read is started the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt; will just keep producing
subsequent bytes.  This is what we’d like to capitalize on.  We could do this
if we just kept the transaction going for another 32-bit word, but only
if there was a request for the next word from the bus.  We’ll have to test
for that in a moment.&lt;/p&gt;

&lt;p&gt;We’ll start this modified design by returning to our timing diagram.
Specifically, we’d like to be able to accept a request for the next
address just in time so that we don’t lose any clock cycles in our
&lt;a href=&quot;https://en.wikipedia.org/wiki/Serial_Peripheral_Interface&quot;&gt;SPI&lt;/a&gt;
transaction.  Hence, if we were just about at the end of one transaction,
then we should be able to extend it by one more transaction, as shown in Fig. 13
below.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 13. Pipelined read transaction&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/spi-pipe.svg&quot; alt=&quot;&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Notice a couple key points here.  First, the &lt;code class=&quot;highlighter-rouge&quot;&gt;ack_delay&lt;/code&gt; line never hits
zero–it just immediately goes into the next word.  The &lt;code class=&quot;highlighter-rouge&quot;&gt;o_wb_ack&lt;/code&gt; and
&lt;code class=&quot;highlighter-rouge&quot;&gt;o_wb_data&lt;/code&gt; lines maintain their requirement, they are to be valid one
clock after &lt;code class=&quot;highlighter-rouge&quot;&gt;ack_delay==1&lt;/code&gt;.  Indeed, in many
ways, this looks identical to what we had before with the exception that
following a &lt;code class=&quot;highlighter-rouge&quot;&gt;bus_request&lt;/code&gt; for the next word we go immediately into reading it
instead of sending a new address.&lt;/p&gt;

&lt;p&gt;Our first problem in this picture is the stall line–it needs to be low one
clock early, or when &lt;code class=&quot;highlighter-rouge&quot;&gt;ack_delay==1&lt;/code&gt;, and not when &lt;code class=&quot;highlighter-rouge&quot;&gt;ack_delay&lt;/code&gt; returns to zero.
The only thing is, we can’t do this at all times, but &lt;em&gt;only&lt;/em&gt; when
the address requested is for the next word, &lt;em&gt;only&lt;/em&gt; when this is a read request.&lt;/p&gt;

&lt;p&gt;That’s going to require some extra logic.&lt;/p&gt;

&lt;p&gt;It also requires a little bit of trickery that doesn’t quite follow the
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;Wishbone&lt;/a&gt;
&lt;a href=&quot;/doc/wbspec_b4.pdf&quot;&gt;specification&lt;/a&gt;:
we’ll take a peek at any pending transaction on one clock and set a flag
based upon it,
then we’ll check that flag and drop &lt;code class=&quot;highlighter-rouge&quot;&gt;o_wb_stall&lt;/code&gt; if necessary on the
following clock.  This new flag, &lt;code class=&quot;highlighter-rouge&quot;&gt;next_request&lt;/code&gt; is shown at the bottom of
Fig. 13 above.&lt;/p&gt;

&lt;p&gt;So here’s the extra logic.  First, we’ll capture the next address.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	reg	[21:0]	next_addr;

	always @(posedge i_clk)
	if ((i_wb_stb)&amp;amp;&amp;amp;(!o_wb_stall))
		next_addr &amp;lt;= i_wb_addr + 1&#39;b1;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Then, we’ll put our &lt;code class=&quot;highlighter-rouge&quot;&gt;next_request&lt;/code&gt; flag together.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	assign	next_request = (i_wb_stb)&amp;amp;&amp;amp;(!i_wb_we)&amp;amp;&amp;amp;(i_wb_addr == next_addr);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Now we can come back and review our basic signals from before.&lt;/p&gt;

&lt;p&gt;The &lt;code class=&quot;highlighter-rouge&quot;&gt;MOSI&lt;/code&gt; signal is a don’t care, so we can keep our &lt;code class=&quot;highlighter-rouge&quot;&gt;wdata_pipe&lt;/code&gt; logic
simple.&lt;/p&gt;

&lt;p&gt;The logic for &lt;code class=&quot;highlighter-rouge&quot;&gt;CS_n&lt;/code&gt; doesn’t change either–it’s set to zero on any bus
request, and this pipe request (once the stall is lowered) is just another
bus request.&lt;/p&gt;

&lt;p&gt;The &lt;code class=&quot;highlighter-rouge&quot;&gt;ack_delay&lt;/code&gt; logic does need to be adjusted, but this is minor.  Specifically, if there’s a &lt;code class=&quot;highlighter-rouge&quot;&gt;bus_request&lt;/code&gt; where &lt;code class=&quot;highlighter-rouge&quot;&gt;CS_n&lt;/code&gt; is already low, then only set
&lt;code class=&quot;highlighter-rouge&quot;&gt;ack_delay&lt;/code&gt; to 32 instead of &lt;code class=&quot;highlighter-rouge&quot;&gt;65&lt;/code&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	initial	ack_delay = 0;
	always @(posedge i_clk)
	if (bus_request)
		ack_delay &amp;lt;= (o_spi_cs_n) ? 7&#39;d65 : 7&#39;d32;
	else if (ack_delay != 0)
		ack_delay &amp;lt;= ack_delay - 1&#39;b1;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The &lt;code class=&quot;highlighter-rouge&quot;&gt;SCK&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;o_wb_stall&lt;/code&gt; signals are a touch more difficult.  First, the
&lt;code class=&quot;highlighter-rouge&quot;&gt;SCK&lt;/code&gt; signal needs to remain high one clock longer if &lt;code class=&quot;highlighter-rouge&quot;&gt;next_request&lt;/code&gt; is high.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	initial	o_spi_sck = 1&#39;b0;
	always @(posedge i_clk)
	if (i_reset)
		o_spi_sck &amp;lt;= 1&#39;b0;
	else if (bus_request)
		o_spi_sck &amp;lt;= 1&#39;b1;
	else if (ack_delay &amp;gt; 2)
		o_spi_sck &amp;lt;= 1&#39;b1;
	//
	// NEW LOGIC: keep the clock going if there&#39;s a second request
	// coming.
	else if ((next_request)&amp;amp;&amp;amp;(ack_delay == 2))
		o_spi_sck &amp;lt;= 1&#39;b1;
	else
		o_spi_sck &amp;lt;= 1&#39;b0;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Second, and really this is the key piece of logic on which all the others
depend, the stall line needs to be lowered
so the request can be accepted in time to start the new transaction without
any delayed cycles.  This pins the stall low clock period to be the same 
clock period where &lt;code class=&quot;highlighter-rouge&quot;&gt;ack_delay&lt;/code&gt; is one.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	initial	o_wb_stall = 1&#39;b0;
	always @(posedge i_clk)
	if (bus_request)
		o_wb_stall &amp;lt;= 1&#39;b1;
	//
	// NEW LOGIC: Drop the stall line if a request for the
	// next address is pending.  The stall line will be
	// low in this case when ack_delay == 1.
	//
	else if ((next_request)&amp;amp;&amp;amp;(ack_delay == 2))
		o_wb_stall &amp;lt;= 1&#39;b0;
	else
		o_wb_stall &amp;lt;= (ack_delay &amp;gt; 1);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Notice how these changes are fairly minor, but yet they can speed up a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;’s
&lt;a href=&quot;/zipcpu/2018/03/21/dblfetch.html&quot;&gt;instruction fetch by a factor of
two&lt;/a&gt; (… but only if the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;
doesn’t use the bus for data, doesn’t branch, doesn’t … etc).  There are
some &lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt; speed
details in there that I’m glossing over.  Still, we haven’t changed our
logic all that much to get this additional capability.&lt;/p&gt;

&lt;p&gt;At this point, we could stop again.  We’d now have a faster &lt;code class=&quot;highlighter-rouge&quot;&gt;ROM&lt;/code&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt; device.  The 
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt; would need to be written
using some other configuration, but we’d be able to read it in high speed.&lt;/p&gt;

&lt;p&gt;But, couldn’t we get the ability to read and write the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt; for just a little bit more
work?  That’s the purpose of the configuration port that we’ll discuss next.&lt;/p&gt;

&lt;h3 id=&quot;third-configuration-port&quot;&gt;Third: Configuration port&lt;/h3&gt;

&lt;p&gt;Can we add a configuration port capability to this 
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/icozip/blob/master/rtl/icozip/spixpress.v&quot;&gt;controller&lt;/a&gt;?
Specifically, it would be nice to have access to all of those other commands
outlined in the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt;
&lt;a href=&quot;http://www.cypress.com/file/177961/download&quot;&gt;specfication&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Let’s use a separate
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;Wishbone&lt;/a&gt;
port for this purpose.  By that I mean, let’s create a separate strobe signal,
&lt;code class=&quot;highlighter-rouge&quot;&gt;i_cfg_stb&lt;/code&gt;,
but otherwise share all of the signals between these two ports.  The &lt;a href=&quot;/blog/2017/06/22/simple-wb-interconnect.html&quot;&gt;bus
interconnect&lt;/a&gt;
can then set this new strobe signal, &lt;code class=&quot;highlighter-rouge&quot;&gt;i_cfg_stb&lt;/code&gt;, to indicate
a request on this new port.&lt;/p&gt;

&lt;p&gt;Unlike the primary &lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;Wishbone
bus&lt;/a&gt;,
we’ll make this one so that you can both write and then read
from this port.  Write’s will send 8-bits to the device over the &lt;code class=&quot;highlighter-rouge&quot;&gt;MOSI&lt;/code&gt; line,
and reads will read the 8-bits returned in the &lt;code class=&quot;highlighter-rouge&quot;&gt;MISO&lt;/code&gt; line.  In order to
allow longer interactions, extending beyond a single 8-bit transaction,
we’ll allocate bit &lt;code class=&quot;highlighter-rouge&quot;&gt;i_wb_data[8]&lt;/code&gt; and use it to control the &lt;code class=&quot;highlighter-rouge&quot;&gt;CS_n&lt;/code&gt; bit.&lt;/p&gt;

&lt;p&gt;Fig. 14 below shows this concept of this protocol.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 14. Configuration port transaction&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/spi-cmd.svg&quot; alt=&quot;A direct SPI command, bypassing the controller&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Writes with &lt;code class=&quot;highlighter-rouge&quot;&gt;i_wb_data[8]&lt;/code&gt; low will cause 8-bits to be sent, reads will
return the response.  Writes with &lt;code class=&quot;highlighter-rouge&quot;&gt;i_wb_data[8]&lt;/code&gt; set will return the
device to the mode where we can read data again.&lt;/p&gt;

&lt;p&gt;Were we building &lt;em&gt;only&lt;/em&gt; this interface, the logic would look &lt;em&gt;very&lt;/em&gt; similar to
just the logic necessary to implement Fig. 14 above.  We’d start with an
&lt;code class=&quot;highlighter-rouge&quot;&gt;user_request&lt;/code&gt; signal, capturing the write request on this configuration
channel.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	wire	user_request = (i_cfg_stb)&amp;amp;&amp;amp;(!o_wb_stall)&amp;amp;&amp;amp;(i_wb_we)
				&amp;amp;&amp;amp;(!i_wb_ata[8]);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Then we could just walk through our basic signals again.&lt;/p&gt;

&lt;p&gt;We’d start with the &lt;code class=&quot;highlighter-rouge&quot;&gt;MOSI&lt;/code&gt; signal.  This was based upon a &lt;code class=&quot;highlighter-rouge&quot;&gt;wdata_pipe&lt;/code&gt;
shift register before.  We can do this again now.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	initial	wdata_pipe = 0;
	always @(posedge i_clk)
	if (user_request)
		wdata_pipe &amp;lt;= { 1&#39;b0, i_wb_data[7:0], 24&#39;h0 };
	else
		wdata_pipe &amp;lt;= { wdata_pipe[31:0], 1&#39;b0 };

	assign	o_spi_mosi = wdata_pipe[32];&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;We can keep our &lt;code class=&quot;highlighter-rouge&quot;&gt;ack_delay&lt;/code&gt; state variable as well.  Only now, we’ll start it
from &lt;code class=&quot;highlighter-rouge&quot;&gt;7&#39;d9&lt;/code&gt; instead of &lt;code class=&quot;highlighter-rouge&quot;&gt;7&#39;d65&lt;/code&gt;, but the rest of the logic is nearly identical.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	initial	ack_delay = 0;
	always @(posedge i_clk)
	if (user_request)
		ack_delay &amp;lt;= 7&#39;d9;
	else if (ack_delay != 0)
		ack_delay &amp;lt;= ack_delay - 1&#39;b1;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Amazingly, the rest of the logic is the same as it was before, save for
some new checks for &lt;code class=&quot;highlighter-rouge&quot;&gt;(user_request)&lt;/code&gt; instead of &lt;code class=&quot;highlighter-rouge&quot;&gt;(bus_request)&lt;/code&gt; to know when
to start a transaction.&lt;/p&gt;

&lt;p&gt;This is why I like this particular approach over and above the bit-banging
approach I had tried on the fourth attempt I wrote about above–you can
share most of the configuration port logic with the regular read logic we
presented above.&lt;/p&gt;

&lt;h2 id=&quot;examining-the-controllers-verilog-code&quot;&gt;Examining the Controller’s Verilog Code&lt;/h2&gt;

&lt;p&gt;We’ve now walked through a description of how the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Serial_Peripheral_Interface&quot;&gt;SPI&lt;/a&gt;
interaction works, together with three separate interactions we want to
accomplish.  At this point, you know the basics, and you’ve seen some
useful code snippets.  The problem is we’ve ignored several key details
of this implementation along the way:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Resets&lt;/p&gt;

    &lt;p&gt;Our &lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;formal property list for the
Wishbone bus&lt;/a&gt;
requires the implementation of a reset signal.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Aborts&lt;/p&gt;

    &lt;p&gt;Similarly, the &lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;formal properties for the
Wishbone&lt;/a&gt;
bus require us to support the case where the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt; (or other bus
master) suddenly aborts the 
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;Wishbone&lt;/a&gt;
transaction.&lt;/p&gt;

    &lt;p&gt;I’ve come across two approaches to this requirement.  One is to continue the
transaction anyway, and just not to acknowledge the result at the end.
The second approach, which we’ll use here, is to actually terminate the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Serial_Peripheral_Interface&quot;&gt;SPI&lt;/a&gt;
transaction.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;All Acknowledgments&lt;/p&gt;

    &lt;p&gt;A third problem we have is that we’ve only discussed how to respond to three
of four possible requests.  We’ve discussed how to respond to a bus read,
and to reads from and writes to the configuration port.  What about
writes to the read port?  Or reads from the configuration port when
the port isn’t in the configuration mode?  (i.e. when &lt;code class=&quot;highlighter-rouge&quot;&gt;CS_n&lt;/code&gt; remains high)&lt;/p&gt;

    &lt;p&gt;Some controllers would issue
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_error&quot;&gt;bus errors&lt;/a&gt; for the unsupported
transactions shown in Fig. 15 below.  However, in my search for low logic
and simple controllers, I tend to &lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;return acknowledgments
instead&lt;/a&gt;–even when a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_error&quot;&gt;bus errors&lt;/a&gt; might make more sense.
We can argue over whether or not this is the best choice, but today’s
&lt;a href=&quot;https://github.com/ZipCPU/icozip/blob/master/rtl/icozip/spixpress.v&quot;&gt;controller&lt;/a&gt;
doesn’t issue any
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_error&quot;&gt;bus errors&lt;/a&gt;.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 15. Request Combinations&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/spix-ack.svg&quot; alt=&quot;Chart showing the different types of transactions&quot; width=&quot;480&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Actually, I’m personally kind of conflicted over whether or not this was the
  right implementation choice, so I’ll listen to anyone with an opinion on the
  issue.&lt;/p&gt;

&lt;p&gt;Specifically, we’ll simply acknowledge an illegal operation, even
  if it means returning potentially bad data.  In Fig. 15 above, I called
  these “Empty ACK”s.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Options&lt;/p&gt;

    &lt;p&gt;Because I know that different designs will have different needs, I’m also
going to implement our extensions as part of two options controlled by
one bit parameters: if &lt;code class=&quot;highlighter-rouge&quot;&gt;OPT_PIPE&lt;/code&gt; is set to &lt;code class=&quot;highlighter-rouge&quot;&gt;1&#39;b1&lt;/code&gt;, the core will support
pipelined reads.  Similarly, if the &lt;code class=&quot;highlighter-rouge&quot;&gt;OPT_CFG&lt;/code&gt; parameter is set to &lt;code class=&quot;highlighter-rouge&quot;&gt;1&#39;b1&lt;/code&gt;
the core will support the configuration port.&lt;/p&gt;

    &lt;p&gt;Perhaps I should also create an &lt;code class=&quot;highlighter-rouge&quot;&gt;OPT_ERROR&lt;/code&gt; that can be set if I want this
core to return a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_error&quot;&gt;bus errors&lt;/a&gt;
for the unsupported cases in Fig. 15.  That would certainly be an option.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;There’s one last difference you’ll see in the code below.  That is that I like
to split up my always blocks so that they only define the logic for one
register at a time.
This has two purposes.  First, it helps to minimize the gate count.  Wires
that don’t depend upon lots of nested if’s don’t need to have that nested
if logic required by other signals encumbering them.  Second, it keeps me
from the &lt;a href=&quot;http://www.clifford.at/papers/2017/togglemux/dac2017_paper.pdf&quot;&gt;issue associated with ‘x’, or don’t care,
values&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Do I find this multiple always block approach more confusing?  Yes.  However,
the &lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal methods&lt;/a&gt;
help to keep me out of trouble, and catch any cases I might be missing.&lt;/p&gt;

&lt;p&gt;That said, let’s walk through &lt;a href=&quot;https://github.com/ZipCPU/icozip/blob/master/rtl/icozip/spixpress.v&quot;&gt;the
code&lt;/a&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;module	spixpress(i_clk, i_reset,
		i_wb_cyc, i_wb_stb, i_cfg_stb, i_wb_we, i_wb_addr, i_wb_data,
			o_wb_stall, o_wb_ack, o_wb_data,
		o_spi_cs_n, o_spi_sck, o_spi_mosi, i_spi_miso);
	//
	// OPT_PIPE allows successive, sequential, transactions to
	// incrementing addresses without requiring a new address to be sent.
	//
	// Random access performance:	65+64(N-1)
	// Performance when pipelined:	65+32(N-1)
	//
	parameter [0:0]	OPT_PIPE = 1&#39;b1;
	//
	// OPT_CFG creates a configuration register that can be accessed through
	// i_cfg_stb when the core isn&#39;t busy.  Using this configuration
	// register, it is possible to send arbitrary commands to the flash,
	// and hence to erase or program the flash.  Since the access is
	// arbitrary, other flash features are supported as well such as
	// programming or reading the one-time-programmable memory or more.
	parameter [0:0]	OPT_CFG  = 1&#39;b1;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;You may remember the &lt;code class=&quot;highlighter-rouge&quot;&gt;bus_request&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;next_request&lt;/code&gt;, and &lt;code class=&quot;highlighter-rouge&quot;&gt;user_request&lt;/code&gt; (i.e.
the configuration port request) from our discussions above.  Here are those
definitions now.  The big differences here from the logic I presented above
are the &lt;code class=&quot;highlighter-rouge&quot;&gt;OPT_PIPE&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;OPT_CFG&lt;/code&gt; parameters.  The synthesis tool will use
these one-bit logic values to trim logic below, starting with this logic here
in case either of these two options are not defined.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	assign	bus_request  = (i_wb_stb)&amp;amp;&amp;amp;(!o_wb_stall)
					&amp;amp;&amp;amp;(!i_wb_we)&amp;amp;&amp;amp;(!cfg_user_mode);
	assign	next_request = (OPT_PIPE)&amp;amp;&amp;amp;(i_wb_stb)&amp;amp;&amp;amp;(!i_wb_we)
					&amp;amp;&amp;amp;(!cfg_user_mode)
					&amp;amp;&amp;amp;(i_wb_addr == next_addr);
	assign	user_request = (OPT_CFG)&amp;amp;&amp;amp;(i_cfg_stb)&amp;amp;&amp;amp;(!o_wb_stall)
					&amp;amp;&amp;amp;(i_wb_we)&amp;amp;&amp;amp;(!i_wb_data[8]);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;One requirement we shall place upon the
&lt;a href=&quot;/blog/2017/06/22/simple-wb-interconnect.html&quot;&gt;interconnect&lt;/a&gt;
is that the two ports are to have different addresses on the same bus.  In
other words, &lt;code class=&quot;highlighter-rouge&quot;&gt;i_wb_stb&lt;/code&gt; may be high or &lt;code class=&quot;highlighter-rouge&quot;&gt;i_cfg_stb&lt;/code&gt;, but never both on the
same clock.&lt;/p&gt;

&lt;p&gt;We’ll start building our logic with the state variable that will drive
everything else, &lt;code class=&quot;highlighter-rouge&quot;&gt;ack_delay&lt;/code&gt;.  This logic is just as we discussed above,
save that we’ve now merged all three modes together, and added support for
resets and &lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus
aborts&lt;/a&gt; that would bring us
back to an idle state early.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	initial	ack_delay = 0;
	always @(posedge i_clk)
	if ((i_reset)||(!i_wb_cyc))
		ack_delay &amp;lt;= 0;
	else if (bus_request)
		ack_delay &amp;lt;= ((o_spi_cs_n)||(!OPT_PIPE)) ? 7&#39;d65 : 7&#39;d32;
	else if (user_request)
		ack_delay &amp;lt;= 7&#39;d9;
	else if (ack_delay != 0)
		ack_delay &amp;lt;= ack_delay - 1&#39;b1;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The simplest wire to control in this design is the &lt;code class=&quot;highlighter-rouge&quot;&gt;MOSI&lt;/code&gt; wire.  This follows
from the &lt;code class=&quot;highlighter-rouge&quot;&gt;wdata_pipe&lt;/code&gt; discussion above, only we’ve now combined the two types
of bus requests together.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	initial	wdata_pipe = 0;
	always @(posedge i_clk)
	if (!o_wb_stall)
		wdata_pipe[23:0] &amp;lt;= { i_wb_addr[21:0], 2&#39;b00 };
	else
		wdata_pipe[23:0] &amp;lt;= { wdata_pipe[22:0], 1&#39;b0 };

	always @(posedge i_clk)
	if (((!OPT_CFG)||(i_wb_stb))&amp;amp;&amp;amp;(!o_wb_stall)) // (bus_request)
		wdata_pipe[32:24] &amp;lt;= { 1&#39;b0, 8&#39;h03 };
	else if ((OPT_CFG)&amp;amp;&amp;amp;(!o_wb_stall)) // (user_request)
		wdata_pipe[32:24] &amp;lt;= { 1&#39;b0, i_wb_data[7:0] };
	else
		wdata_pipe[32:24] &amp;lt;= { wdata_pipe[31:23] };

	assign	o_spi_mosi = wdata_pipe[32];&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Notice the two extra bits at the end of &lt;code class=&quot;highlighter-rouge&quot;&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;i_wb_addr[21:0],&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;2&#39;b00&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;.
These will be pruned by the optimizer within the &lt;a href=&quot;http://www.clifford.at/yosys&quot;&gt;synthesis
tool&lt;/a&gt;.
I’ve kept them in there to keep the bottom bits of shift register byte aligned,
although they could easily be pruned here.  The top zero bit of
&lt;code class=&quot;highlighter-rouge&quot;&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;1&#39;b0,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;8&#39;h03&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt; follows from the reality that it will cost a one
clock delay to get the &lt;code class=&quot;highlighter-rouge&quot;&gt;SCK&lt;/code&gt; to start toggling after we set &lt;code class=&quot;highlighter-rouge&quot;&gt;o_spi_sck&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The other thing to notice about the &lt;code class=&quot;highlighter-rouge&quot;&gt;wdata_pipe&lt;/code&gt; logic is that I’ve split
it into two blocks.  This is for exactly those same reasons I was describing
above.  Bits &lt;code class=&quot;highlighter-rouge&quot;&gt;[23:0]&lt;/code&gt; depend only upon the address, and then only upon a read
request.  Once set and the
&lt;a href=&quot;https://github.com/ZipCPU/icozip/blob/master/rtl/icozip/spixpress.v&quot;&gt;controller&lt;/a&gt;
turns busy, these become a shift register that shifts left.
Bits &lt;code class=&quot;highlighter-rouge&quot;&gt;[32:24]&lt;/code&gt; are similarly a shift register when busy, but when upon
a regular bus request these are the read command.  Otherwise on a configuration
port write, these bits are set to the bottom 8-bits from the data bus.&lt;/p&gt;

&lt;p&gt;Turning to the bus acknowledgment signal, &lt;code class=&quot;highlighter-rouge&quot;&gt;o_wb_ack&lt;/code&gt;, this is
just set any time the &lt;code class=&quot;highlighter-rouge&quot;&gt;ack_delay&lt;/code&gt; transitions to zero.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	initial	o_wb_ack = 0;
	always @(posedge i_clk)
	if (i_reset)
		o_wb_ack &amp;lt;= 0;
	else if (ack_delay == 1)
		o_wb_ack &amp;lt;= (i_wb_cyc);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Well, not quite.  We needed to support
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus aborts&lt;/a&gt;, so
&lt;code class=&quot;highlighter-rouge&quot;&gt;o_wb_ack&lt;/code&gt; is set to zero if the cycle line was dropped.&lt;/p&gt;

&lt;p&gt;Even that’s not it.  We still need to acknowledge anything that will not
set the &lt;a href=&quot;https://en.wikipedia.org/wiki/Serial_Peripheral_Interface&quot;&gt;SPI&lt;/a&gt;
port in motion.  That’s the rest of the &lt;code class=&quot;highlighter-rouge&quot;&gt;o_wb_ack&lt;/code&gt; logic.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	else if ((i_wb_stb)&amp;amp;&amp;amp;(!o_wb_stall)&amp;amp;&amp;amp;(!bus_request))
		o_wb_ack &amp;lt;= 1&#39;b1;
	else if ((OPT_CFG)&amp;amp;&amp;amp;(i_cfg_stb)&amp;amp;&amp;amp;(!o_wb_stall)&amp;amp;&amp;amp;(!user_request))
		o_wb_ack &amp;lt;= 1&#39;b1;
	else
		o_wb_ack &amp;lt;= 0;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;If the configuration port parameter, &lt;code class=&quot;highlighter-rouge&quot;&gt;OPT_CFG&lt;/code&gt;, is set then we’ll need to
keep track of whether or not the port is forcing the &lt;code class=&quot;highlighter-rouge&quot;&gt;CS_n&lt;/code&gt; line low.  We’ll
call this the &lt;code class=&quot;highlighter-rouge&quot;&gt;cfg_user_mode&lt;/code&gt; and use a register of the same name to keep
track of whether or not we need to hold &lt;code class=&quot;highlighter-rouge&quot;&gt;CS_n&lt;/code&gt; low while waiting for the
next transaction.  This idea of holding &lt;code class=&quot;highlighter-rouge&quot;&gt;CS_n&lt;/code&gt; low was shown on the right
edge of Fig 14 above.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	initial	cfg_user_mode = 0;
	always @(posedge i_clk)
	if (i_reset)
		cfg_user_mode &amp;lt;= 0;
	else if ((OPT_CFG)&amp;amp;&amp;amp;(i_cfg_stb)&amp;amp;&amp;amp;(!o_wb_stall)&amp;amp;&amp;amp;(i_wb_we))
		cfg_user_mode &amp;lt;= !i_wb_data[8];&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;One variable we didn’t discuss above was the &lt;code class=&quot;highlighter-rouge&quot;&gt;actual_sck&lt;/code&gt; register defined
below.  This register’s purpose is to unwind the delay associated with the
&lt;code class=&quot;highlighter-rouge&quot;&gt;SCK&lt;/code&gt; &lt;a href=&quot;https://github.com/ZipCPU/icozip/blob/master/rtl/icozip/oclkddr.v&quot;&gt;DDR
implementation&lt;/a&gt;,
which causes &lt;code class=&quot;highlighter-rouge&quot;&gt;SCK&lt;/code&gt; one cycle after we set &lt;code class=&quot;highlighter-rouge&quot;&gt;o_spi_sck&lt;/code&gt; high.  This register
is an important part of knowing when to shift a new bit into &lt;code class=&quot;highlighter-rouge&quot;&gt;o_wb_data&lt;/code&gt; next.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	initial	actual_sck = 1&#39;b0;
	always @(posedge i_clk)
	if ((i_reset)||(!i_wb_cyc))
		actual_sck &amp;lt;= 1&#39;b0;
	else
		actual_sck &amp;lt;= o_spi_sck;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;We need &lt;code class=&quot;highlighter-rouge&quot;&gt;actual_sck&lt;/code&gt; to tell us when to update the outgoing data register,
&lt;code class=&quot;highlighter-rouge&quot;&gt;o_wb_data&lt;/code&gt;, with a new &lt;code class=&quot;highlighter-rouge&quot;&gt;i_spi_miso&lt;/code&gt; value.  Basically, anytime &lt;code class=&quot;highlighter-rouge&quot;&gt;actual_sck&lt;/code&gt;
is high, we’ll clock in a new &lt;code class=&quot;highlighter-rouge&quot;&gt;i_spi_miso&lt;/code&gt; bit on the right, pushing everything
left.  If &lt;code class=&quot;highlighter-rouge&quot;&gt;cfg_user_mode&lt;/code&gt; is high, we’ll also clear the high 24-bits.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(posedge i_clk)
	if (actual_sck)
	begin
		if (cfg_user_mode)
			o_wb_data &amp;lt;= { 24&#39;h0, o_wb_data[6:0], i_spi_miso };
		else
			o_wb_data &amp;lt;= { o_wb_data[30:0], i_spi_miso };
	end else if (cfg_user_mode)
		o_wb_data &amp;lt;= { 24&#39;h0, o_wb_data[7:0] };&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Let’s return to the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Serial_Peripheral_Interface&quot;&gt;SPI&lt;/a&gt;
port again for a bit.  Here’s the logic for the &lt;code class=&quot;highlighter-rouge&quot;&gt;CS_n&lt;/code&gt; signal.  Note the
few differences.  First, we set (inactivate) &lt;code class=&quot;highlighter-rouge&quot;&gt;CS_n&lt;/code&gt; on any reset or bus
idle (or abort), save when &lt;code class=&quot;highlighter-rouge&quot;&gt;cfg_user_mode&lt;/code&gt; is true.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	initial	o_spi_cs_n = 1&#39;b1;
	always @(posedge i_clk)
	if (i_reset)
		o_spi_cs_n &amp;lt;= 1&#39;b1;
	else if ((!i_wb_cyc)&amp;amp;&amp;amp;(!cfg_user_mode))
		o_spi_cs_n &amp;lt;= 1&#39;b1;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Otherwise, the rest is just about as it was, save for the extra configuration
mode logic: clearing &lt;code class=&quot;highlighter-rouge&quot;&gt;o_cs_n&lt;/code&gt; and holding it clear while &lt;code class=&quot;highlighter-rouge&quot;&gt;cfg_user_mode&lt;/code&gt; is
high, until it is released by the next configuration register write–following
Fig. 14 above.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	else if (bus_request)
		o_spi_cs_n &amp;lt;= 1&#39;b0;
	else if ((OPT_CFG)&amp;amp;&amp;amp;(i_cfg_stb)&amp;amp;&amp;amp;(!o_wb_stall)&amp;amp;&amp;amp;(i_wb_we))
		o_spi_cs_n &amp;lt;= i_wb_data[8];
	else if (cfg_user_mode)
		o_spi_cs_n &amp;lt;= 1&#39;b0;
	else if ((ack_delay == 1)&amp;amp;&amp;amp;(!cfg_user_mode))
		o_spi_cs_n &amp;lt;= 1&#39;b1;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The &lt;code class=&quot;highlighter-rouge&quot;&gt;o_spi_sck&lt;/code&gt; signal is mostly just the merge of the logic above.
Differences include the reset and &lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus
abort&lt;/a&gt;
logic.  Other than that, we set &lt;code class=&quot;highlighter-rouge&quot;&gt;o_spi_sck&lt;/code&gt; on any request, and clear it once
the &lt;code class=&quot;highlighter-rouge&quot;&gt;ack_delay&lt;/code&gt; register has counted down to one.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	initial	o_spi_sck = 1&#39;b0;
	always @(posedge i_clk)
	if (i_reset)
		o_spi_sck &amp;lt;= 1&#39;b0;
	else if ((bus_request)||(user_request))
		o_spi_sck &amp;lt;= 1&#39;b1;
	else if ((i_wb_cyc)&amp;amp;&amp;amp;(ack_delay &amp;gt; 2)) // Bus abort check
		o_spi_sck &amp;lt;= 1&#39;b1;
	else if ((next_request)&amp;amp;&amp;amp;(ack_delay == 2))
		o_spi_sck &amp;lt;= 1&#39;b1;
	else
		o_spi_sck &amp;lt;= 1&#39;b0;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Notice that in the case of a pipelined read, the case where we don’t want
to clear &lt;code class=&quot;highlighter-rouge&quot;&gt;o_spi_sck&lt;/code&gt; on clock one, &lt;code class=&quot;highlighter-rouge&quot;&gt;bus_request&lt;/code&gt; will be true.  Hence we only
need to check for &lt;code class=&quot;highlighter-rouge&quot;&gt;ack_delay &amp;gt; 2&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;ack_delay == 2&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;That brings us back to the bus, and to the
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;Wishbone&lt;/a&gt;
stall signal, &lt;code class=&quot;highlighter-rouge&quot;&gt;o_wb_stall&lt;/code&gt;.  If there’s no ongoing bus cycle, we’ll set
the stall line to zero.  Likewise, on any &lt;code class=&quot;highlighter-rouge&quot;&gt;bus_request&lt;/code&gt; or configuration port
&lt;code class=&quot;highlighter-rouge&quot;&gt;user_request&lt;/code&gt;, the stall line goes high while we respond to the request.
Finally, when &lt;code class=&quot;highlighter-rouge&quot;&gt;ack_delay&lt;/code&gt; gets to zero, &lt;code class=&quot;highlighter-rouge&quot;&gt;o_wb_stall&lt;/code&gt; must also return to zero.&lt;/p&gt;

&lt;p&gt;That’s our logic below, save only for the special exemption when there’s a
request for the next address in memory, in order to support pipelined read requests.
That was the “New logic” we presented and discussed above.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	initial	o_wb_stall = 1&#39;b0;
	always @(posedge i_clk)
	if ((i_reset)||(!i_wb_cyc))
		o_wb_stall &amp;lt;= 1&#39;b0;
	else if ((bus_request)||(user_request))
		o_wb_stall &amp;lt;= 1&#39;b1;
	else if ((next_request)&amp;amp;&amp;amp;(ack_delay == 2))
		o_wb_stall &amp;lt;= 1&#39;b0;
	else
		o_wb_stall &amp;lt;= (ack_delay &amp;gt; 1);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Finally, our &lt;code class=&quot;highlighter-rouge&quot;&gt;next_addr&lt;/code&gt; logic below is identical to what we presented above,
save that this time we’ve used the &lt;code class=&quot;highlighter-rouge&quot;&gt;OPT_PIPE&lt;/code&gt; flag to guarantee that this
&lt;code class=&quot;highlighter-rouge&quot;&gt;next_addr&lt;/code&gt; calculation will only create logic when &lt;code class=&quot;highlighter-rouge&quot;&gt;OPT_PIPE&lt;/code&gt; is non-zero.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	generate if (OPT_PIPE)
	begin
		reg	[21:0]	r_next_addr;
		always @(posedge i_clk)
		if (!o_wb_stall)
			r_next_addr &amp;lt;= i_wb_addr + 1&#39;b1;

		assign	next_addr = r_next_addr;

	end else begin

		assign next_addr = 0;

	end endgenerate&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;That’s &lt;a href=&quot;https://github.com/ZipCPU/icozip/blob/master/rtl/icozip/spixpress.v&quot;&gt;our flash
controller&lt;/a&gt;!&lt;/p&gt;

&lt;p&gt;The big remaining question remaining, though, is whether or not
&lt;a href=&quot;https://github.com/ZipCPU/icozip/blob/master/rtl/icozip/spixpress.v&quot;&gt;this core&lt;/a&gt;
will work in practice and on my &lt;a href=&quot;http://www.icoboard.org&quot;&gt;ICO Board&lt;/a&gt;.  So,
let’s turn our attention from creating this
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/icozip/blob/master/rtl/icozip/spixpress.v&quot;&gt;controller&lt;/a&gt;
to verifying it.&lt;/p&gt;

&lt;h2 id=&quot;formally-verifying-the-flash&quot;&gt;Formally Verifying the flash&lt;/h2&gt;

&lt;p&gt;Normally when I get to this section of a post, I walk through the
verification of a core in the order the logic exists within a core.&lt;/p&gt;

&lt;p&gt;I’m going to try a bit of a different order today.&lt;/p&gt;

&lt;p&gt;Let’s instead work through this core in the order that I would build the
properties within the file.  I’ll try to follow the spirit of the
&lt;em&gt;formal driven development&lt;/em&gt; concept I &lt;a href=&quot;/formal/2018/07/14/dev-cycle.html&quot;&gt;shared
earlier&lt;/a&gt;.  This means
that I will start with a &lt;code class=&quot;highlighter-rouge&quot;&gt;cover()&lt;/code&gt; statement (or four), then add the
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;Wishbone bus properties&lt;/a&gt;
to the core, some ad-hoc properties, and then finally the &lt;em&gt;contract&lt;/em&gt; the
core is supposed to meet.  Actually, I normally place the contract earlier
in the process, before the ad-hoc properties, but we’ll put the contract at
the end today because that’s where the
&lt;a href=&quot;http://www.asic-world.com/systemverilog/assertions4.html#Sequences&quot;&gt;sequences&lt;/a&gt;
will be found and therefore that was the last part I verified.&lt;/p&gt;

&lt;h3 id=&quot;step-one-covering-the-results&quot;&gt;Step one: Covering the results&lt;/h3&gt;

&lt;p&gt;The first formal property I like to start with these days whenever I build
a new IP core is a &lt;code class=&quot;highlighter-rouge&quot;&gt;cover()&lt;/code&gt; statement.  For bus
&lt;a href=&quot;/zipcpu/2017/05/29/simple-wishbone.html&quot;&gt;slaves&lt;/a&gt;, this
usually takes the form of,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(posedge i_clk)
		cover(o_wb_ack);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;For many peripherals, this will exercise all of the logic in the core and
then present create a &lt;a href=&quot;/blog/2017/07/31/vcd.html&quot;&gt;trace&lt;/a&gt;
at the end of the logic flow.  This 
&lt;a href=&quot;/blog/2017/07/31/vcd.html&quot;&gt;trace&lt;/a&gt;
will show you an example of how the internal logic functions (or doesn’t).&lt;/p&gt;

&lt;p&gt;In this case, that simple &lt;code class=&quot;highlighter-rouge&quot;&gt;cover()&lt;/code&gt; statement doesn’t work like I want.
Instead of giving me a &lt;a href=&quot;/blog/2017/07/31/vcd.html&quot;&gt;trace&lt;/a&gt;
through all of the logic in the core, it just immediately returns one of the
empty acknowledgments.&lt;/p&gt;

&lt;p&gt;That’s not very useful.&lt;/p&gt;

&lt;p&gt;Hence, to get a &lt;a href=&quot;/blog/2017/07/31/vcd.html&quot;&gt;trace&lt;/a&gt; covering
both a bus request and a configuration write command, I set two flags,
&lt;code class=&quot;highlighter-rouge&quot;&gt;pending_bus_request&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;pending_user_request&lt;/code&gt;, to record when such a
request has been made.  In order to keep this logic from impacting any other
part of the proof, I place it in a generated section depending upon a formal
option cover parameter, &lt;code class=&quot;highlighter-rouge&quot;&gt;F_OPT_COVER&lt;/code&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	generate if (F_OPT_COVER)
	begin

		always @(posedge i_clk)
			cover(o_wb_ack&amp;amp;&amp;amp;(!$past(bus_request))
				&amp;amp;&amp;amp;(!$past(user_request)));

		reg	f_pending_user_request, f_pending_bus_request;

		// Pending bus (read) request
		//
		initial	f_pending_bus_request = 1&#39;b0;
		always @(posedge i_clk)
		if ((i_reset)||(!i_wb_cyc))
			f_pending_bus_request &amp;lt;= 1&#39;b0;
		else if (bus_request)
			f_pending_bus_request &amp;lt;= 1&#39;b1;
		else if (o_wb_ack)
			f_pending_bus_request &amp;lt;= 1&#39;b0;

		always @(posedge i_clk)
			cover((o_wb_ack)&amp;amp;&amp;amp;(f_pending_bus_request));&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;That captures a &lt;a href=&quot;/blog/2017/07/31/vcd.html&quot;&gt;trace&lt;/a&gt; of &lt;a href=&quot;https://github.com/ZipCPU/icozip/blob/master/rtl/icozip/spixpress.v&quot;&gt;this
core&lt;/a&gt;
illustrating a read from the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash memory&lt;/a&gt;.  You can see
this &lt;a href=&quot;/blog/2017/07/31/vcd.html&quot;&gt;trace&lt;/a&gt; below in Fig 16.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 16. Cover trace of the basic read operation&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/spix-trace-read.png&quot; alt=&quot;Trace of a SPI read transaction&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Fig 16 should look very much like our design requirement trace from Fig 12
above.&lt;/p&gt;

&lt;p&gt;Now for the configuration port.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;		initial	f_pending_user_request = 1&#39;b0;
		always @(posedge i_clk)
		if ((i_reset)||(!i_wb_cyc))
			f_pending_user_request &amp;lt;= 1&#39;b0;
		else if (user_request)
			f_pending_user_request &amp;lt;= 1&#39;b1;
		else if (o_wb_ack)
			f_pending_user_request &amp;lt;= 1&#39;b0;

		// The actual cover statement for the user request
		always @(posedge i_clk)
			cover((o_wb_ack)&amp;amp;&amp;amp;(f_pending_user_request));&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The configuration &lt;a href=&quot;/blog/2017/07/31/vcd.html&quot;&gt;trace&lt;/a&gt;
this generates is shown below in Fig 17.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 17. Cover trace of a configuration port operation&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/spix-trace-cfg.png&quot; alt=&quot;Trace of a configuration port request&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Keep in mind, I’m able to acquire and examining these
&lt;a href=&quot;/blog/2017/07/31/vcd.html&quot;&gt;traces&lt;/a&gt; &lt;em&gt;without writing any
simulation code&lt;/em&gt;.  That comes later, in a discussion we’ll need to save for
another day.&lt;/p&gt;

&lt;p&gt;Finally, to capture the pipelined read request, we’ll cover the entrance
into the pipeline read mode, just like we traced out in Fig. 13 above.
For this purpose, we can just &lt;code class=&quot;highlighter-rouge&quot;&gt;cover()&lt;/code&gt; the lowered stall line when &lt;code class=&quot;highlighter-rouge&quot;&gt;ack_delay&lt;/code&gt;
is one.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;		if (OPT_PIPE)
		begin
			always @(posedge i_clk)
				cover((f_pending_bus_request)
					&amp;amp;&amp;amp;(ack_delay == 7&#39;h1)
					&amp;amp;&amp;amp;(bus_request)&amp;amp;&amp;amp;(o_spi_sck));&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The only problem is, the formal tools failed to find
&lt;em&gt;any&lt;/em&gt; &lt;a href=&quot;/blog/2017/07/31/vcd.html&quot;&gt;trace&lt;/a&gt; that would
make this &lt;code class=&quot;highlighter-rouge&quot;&gt;cover()&lt;/code&gt; statement true.  To debug that failed &lt;code class=&quot;highlighter-rouge&quot;&gt;cover()&lt;/code&gt; statement,
I backed up a step, and tried to &lt;code class=&quot;highlighter-rouge&quot;&gt;cover()&lt;/code&gt; the prior clock cycle.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;			always @(posedge i_clk)
				cover((next_request)&amp;amp;&amp;amp;(f_pending_bus_request)
						&amp;amp;&amp;amp;(ack_delay == 7&#39;h2));
		end
	end endgenerate&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Eventually I get the &lt;a href=&quot;/blog/2017/07/31/vcd.html&quot;&gt;trace&lt;/a&gt; in
Fig 18 from the first of these two &lt;code class=&quot;highlighter-rouge&quot;&gt;cover()&lt;/code&gt; statements.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 18. Cover trace showing the entrance of a pipelined read request&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/spix-trace-pipe.png&quot; alt=&quot;Trace showing the entrance to a pipelined read&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;This is also my general approach for those times where I am struggling to
get a &lt;code class=&quot;highlighter-rouge&quot;&gt;cover()&lt;/code&gt; statement to produce a
&lt;a href=&quot;/blog/2017/07/31/vcd.html&quot;&gt;trace&lt;/a&gt;: I back up a
step, add an additional &lt;code class=&quot;highlighter-rouge&quot;&gt;cover()&lt;/code&gt; statement, and then repeat the process
until I find the bug–just like I showed here.  &lt;code class=&quot;highlighter-rouge&quot;&gt;assert()&lt;/code&gt; statements can help
this process as well.&lt;/p&gt;

&lt;p&gt;Fig 18 also illustrates one of the problems with &lt;code class=&quot;highlighter-rouge&quot;&gt;cover()&lt;/code&gt; statements: the tool
is free to cover your logic any way it pleases.  In this case, it covered the
entrance into the pipelined read, and then immediately issued a
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus abort&lt;/a&gt;
by dropping the &lt;code class=&quot;highlighter-rouge&quot;&gt;i_wb_cyc&lt;/code&gt; line.  While legal, it’s hardly satisfying.&lt;/p&gt;

&lt;p&gt;We could add some assumptions to keep this from taking place.  That’s part of
the purpose of the &lt;code class=&quot;highlighter-rouge&quot;&gt;F_OPT_COVER&lt;/code&gt; generate block–to be able to add any
assumptions necessary for getting the
&lt;a href=&quot;/blog/2017/07/31/vcd.html&quot;&gt;traces&lt;/a&gt; you want.  For example,
we could add an assumption that there would never be any
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus abort&lt;/a&gt;s during
pipelined reads.  However, this &lt;code class=&quot;highlighter-rouge&quot;&gt;cover()&lt;/code&gt; has accomplished my purpose as
it is: it has proven that a pipelined read request will bring the core
back into the regular read logic as desired.  Therefore, I’ll leave any
further work with assumptions as a exercise for the student.&lt;/p&gt;

&lt;p&gt;This &lt;a href=&quot;/formal/2018/07/14/dev-cycle.html&quot;&gt;helps me create an initial
draft&lt;/a&gt;
of this
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/icozip/blob/master/rtl/icozip/spixpress.v&quot;&gt;controller
core&lt;/a&gt;.
Well, not quite.  I’ll describe a missing piece in the next section.&lt;/p&gt;

&lt;h3 id=&quot;step-one-reset-and-bus-interaction&quot;&gt;Step one: Reset and bus interaction&lt;/h3&gt;

&lt;p&gt;One of the problems with the &lt;code class=&quot;highlighter-rouge&quot;&gt;cover()&lt;/code&gt; statements in the last section is that,
when unconstrained, the incoming bus request doesn’t act like a bus request
should.  Bus requests may be made, stalled, and then new requests will be made
even though the prior request hasn’t gone been accepted into the
&lt;a href=&quot;https://github.com/ZipCPU/icozip/blob/master/rtl/icozip/spixpress.v&quot;&gt;controller&lt;/a&gt;.
Similarly, the strobe line might be high, even though the bus cycle line is low.
For these reasons, we need to bring in some &lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;properties describing our
bus&lt;/a&gt;.  Let’s do that in
this section, starting with the &lt;code class=&quot;highlighter-rouge&quot;&gt;i_reset&lt;/code&gt; signal the
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus properties depend upon&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Reset logic uses the &lt;code class=&quot;highlighter-rouge&quot;&gt;$past()&lt;/code&gt; operator.  This operator will only work right
if the &lt;code class=&quot;highlighter-rouge&quot;&gt;$past()&lt;/code&gt; time doesn’t occur before time began with the &lt;code class=&quot;highlighter-rouge&quot;&gt;initial&lt;/code&gt;
statements.  Hence, we’ll create an &lt;code class=&quot;highlighter-rouge&quot;&gt;f_past_valid&lt;/code&gt; register to tell us when
we can use the &lt;code class=&quot;highlighter-rouge&quot;&gt;$past()&lt;/code&gt; operator successfully.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	reg	f_past_valid;

	initial	f_past_valid = 1&#39;b0;
	always @(posedge i_clk)
		f_past_valid &amp;lt;= 1&#39;b1;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;We want to &lt;code class=&quot;highlighter-rouge&quot;&gt;assume()&lt;/code&gt; that our design starts with the &lt;code class=&quot;highlighter-rouge&quot;&gt;i_reset&lt;/code&gt; line high.
This means we want to assume &lt;code class=&quot;highlighter-rouge&quot;&gt;i_reset&lt;/code&gt; in both the initial state, and anytime
&lt;code class=&quot;highlighter-rouge&quot;&gt;f_past_valid&lt;/code&gt; is false.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	initial	assume(i_reset);

	always @(*)
	if (!f_past_valid)
		assume(i_reset);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Now for a fun trick: I’d like to insure that any register responsive to an
&lt;code class=&quot;highlighter-rouge&quot;&gt;i_reset&lt;/code&gt; signal is also properly initialized to the same value.  Checking
for &lt;code class=&quot;highlighter-rouge&quot;&gt;!f_past_valid&lt;/code&gt; tells us if we are in the initial state, whereas
&lt;code class=&quot;highlighter-rouge&quot;&gt;$past(i_reset)&lt;/code&gt; checks whether or not our design just followed an
&lt;code class=&quot;highlighter-rouge&quot;&gt;i_reset&lt;/code&gt; signal.  By placing the asserted values below, that guarantees them
to be the same under both circumstances.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(posedge i_clk)
	if ((!f_past_valid)||($past(i_reset)))
	begin
		assert(o_spi_cs_n == 1&#39;b1);
		assert(o_spi_sck  == 1&#39;b0);
		//
		assert(ack_delay    ==  0);
		assert(cfg_user_mode == 0);
		assert(o_wb_stall == 1&#39;b0);
		assert(o_wb_ack   == 1&#39;b0);
	end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Now we can start to get the
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;Wishbone bus&lt;/a&gt; to act like
a &lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;Wishbone bus&lt;/a&gt; should.&lt;/p&gt;

&lt;p&gt;To do this, we’ll reference a &lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;Wishbone
bus&lt;/a&gt; &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/ex/fwb_slave.v&quot;&gt;property
file&lt;/a&gt; from the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
repository.  This core needs a bit of configuration, so let’s configure its
parameters:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;AW&lt;/code&gt;: Our address bus has 22 bits, sufficient to handle a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt;
of 16MB of memory.  (Remember the &lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;Wishbone
address&lt;/a&gt; is a &lt;em&gt;word&lt;/em&gt;
address, and not an 8-bit octet address.)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;F_MAX_STALL&lt;/code&gt;: Our design may stall the bus no more than 66 clock cycles,
 one more than the length of one non-pipelined bus read.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;F_MAX_ACK_DELAY&lt;/code&gt;: Similarly, it may take at most 66 cycles for an
acknowledgment to be returned upon any request.&lt;/p&gt;

    &lt;p&gt;This is a bit of overkill for both &lt;code class=&quot;highlighter-rouge&quot;&gt;F_MAX_STALL&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;F_MAX_ACK_DELAY&lt;/code&gt;
by one cycle, but it gives us a little wiggle room in case our design changes
in the future.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;F_LGDEPTH&lt;/code&gt;: Since both counters require 7-bits, and since we’ll never have
 more than &lt;code class=&quot;highlighter-rouge&quot;&gt;2^7&lt;/code&gt; or 128 requests outstanding, we’ll set the log (based two)
of the pipeline depth to 7.  This also determines the number of bits in our
counters: &lt;code class=&quot;highlighter-rouge&quot;&gt;f_nreqs&lt;/code&gt;, the number of requests that have been made,
&lt;code class=&quot;highlighter-rouge&quot;&gt;f_nacks&lt;/code&gt;, the number of acknowledgments that have been returned,
and &lt;code class=&quot;highlighter-rouge&quot;&gt;f_outstanding&lt;/code&gt;, the number of currently outstanding transactions.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;F_MAX_REQUESTS&lt;/code&gt; describes the maximum number of requests that can be made
in any transaction.  This creates an assertion that
&lt;code class=&quot;highlighter-rouge&quot;&gt;f_nreqs &amp;lt; F_MAX_REQUESTS&lt;/code&gt;.  While this is great for our non-pipelined mode,
in the pipelined mode it is possible to make request upon request.  Hence,
we’ll set this to one for the non-pipelined mode, and to zero if we are
running in a pipelined mode.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;That’s enough configuration to include this property set in our design.  We’ll
make one other adjustment here: we’ll &lt;code class=&quot;highlighter-rouge&quot;&gt;OR&lt;/code&gt; the &lt;code class=&quot;highlighter-rouge&quot;&gt;i_wb_stb&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;i_cfg_stb&lt;/code&gt;
together to create one unified &lt;a href=&quot;/zipcpu/2017/05/29/simple-wishbone.html&quot;&gt;slave&lt;/a&gt; port.  This saves us from including two
separate property files to describe each of the two
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;Wishbone&lt;/a&gt;
&lt;a href=&quot;/zipcpu/2017/05/29/simple-wishbone.html&quot;&gt;slaves&lt;/a&gt;, but it’ll give us a bit of hassle that we’ll have to clean up in a moment.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	localparam	F_LGDEPTH = 7;
	wire	[F_LGDEPTH-1:0]	f_nreqs, f_nacks, f_outstanding;

	fwb_slave #( .AW(22), .F_MAX_STALL(7&#39;d66), .F_MAX_ACK_DELAY(7&#39;d66),
			.F_LGDEPTH(F_LGDEPTH),
			.F_MAX_REQUESTS((OPT_PIPE) ? 0 : 1&#39;b1),
			.F_OPT_MINCLOCK_DELAY(1&#39;b1)
		) slavei(i_clk, (i_reset),
		i_wb_cyc, (i_wb_stb)||(i_cfg_stb), i_wb_we,
			i_wb_addr, i_wb_data, 4&#39;hf,
			o_wb_ack, o_wb_stall, o_wb_data, 1&#39;b0,
			f_nreqs, f_nacks, f_outstanding);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Our first clean up assumption is to require that only one &lt;code class=&quot;highlighter-rouge&quot;&gt;i_*_stb&lt;/code&gt; signal
will ever be active at any given time.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(*)
		assume((!i_cfg_stb)||(!i_wb_stb));&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Second, we’ll require that any time either of &lt;code class=&quot;highlighter-rouge&quot;&gt;i_wb_stb&lt;/code&gt; or &lt;code class=&quot;highlighter-rouge&quot;&gt;i_cfg_stb&lt;/code&gt; is
active, &lt;em&gt;and&lt;/em&gt; the bus is stalled, that the same strobe signal remains active
on the next clock.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(posedge i_clk)
	if ((f_past_valid)&amp;amp;&amp;amp;(!$past(i_reset))&amp;amp;&amp;amp;(i_wb_cyc)
		&amp;amp;&amp;amp;(($past(i_wb_stb))||($past(i_cfg_stb)))&amp;amp;&amp;amp;($past(o_wb_stall)))
		assume({i_wb_stb,i_cfg_stb}==$past({i_wb_stb,i_cfg_stb}));&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;In hindsight, this just makes sense.  In reality, I didn’t put this assumption
into place until I saw this rule violated in one of my early &lt;code class=&quot;highlighter-rouge&quot;&gt;cover()&lt;/code&gt;
&lt;a href=&quot;/blog/2017/07/31/vcd.html&quot;&gt;traces&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Now that we’ve added our
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus properties&lt;/a&gt;,
the bus starts to act right in the
&lt;a href=&quot;/blog/2017/07/31/vcd.html&quot;&gt;traces&lt;/a&gt;
generated by our &lt;code class=&quot;highlighter-rouge&quot;&gt;cover()&lt;/code&gt; statements.  The design just doesn’t pass
&lt;a href=&quot;/blog/2018/03/10/induction-exercise.html&quot;&gt;induction&lt;/a&gt;
yet.  For that, we’ll need to add some ad-hoc assertions in the next section.&lt;/p&gt;

&lt;h3 id=&quot;step-two-ad-hoc-immediate-assertions&quot;&gt;Step two: Ad-hoc Immediate assertions&lt;/h3&gt;

&lt;p&gt;Often I separate formal properties into two types: there’s the primary
type based upon the outputs of the core that’s designed to determine whether
the core functions as intended.  We’ll call this the &lt;em&gt;contract&lt;/em&gt; that the
core needs to fulfill.  Other properties are more ad-hoc.  They
wouldn’t be needed, save for the reality that
&lt;a href=&quot;/blog/2018/03/10/induction-exercise.html&quot;&gt;induction&lt;/a&gt;
starts with unconstrained values within the core.  We’ll express how
this core needs to operate, it’s &lt;em&gt;contract&lt;/em&gt; if you will, using &lt;a href=&quot;http://www.asic-world.com/systemverilog/assertions4.html#Sequences&quot;&gt;System Verilog
sequences&lt;/a&gt;
in the next section.  For the purpose of this section, let’s just constrain
the design to make certain it doesn’t enter into any illegal states during
&lt;a href=&quot;/blog/2018/03/10/induction-exercise.html&quot;&gt;induction&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;We’ll start out with some assertions regarding our
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;Wishbone properties&lt;/a&gt;.
Specifically, we need to ensure that the counters within the &lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;Wishbone property
module&lt;/a&gt;
match our current understanding of our state.  Further, since a pipelined
operation can go on forever, we’ll only examine the number of outstanding
transactions kept in the &lt;code class=&quot;highlighter-rouge&quot;&gt;f_outstanding&lt;/code&gt; value returned from the
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;Wishbone property&lt;/a&gt; set.&lt;/p&gt;

&lt;p&gt;For our first test, we’ll insist that we never have more than one outstanding
request.  That is unless we are in a pipelined read operation, where there
would be one cycle where the number of outstanding transactions would be two
instead of one.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(*)
	if (OPT_PIPE)
		assert(f_outstanding &amp;lt;= 2);
	else
		assert(f_outstanding &amp;lt;= 1);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;In a similar fashion, any time &lt;code class=&quot;highlighter-rouge&quot;&gt;ack_delay&lt;/code&gt; is zero then we aren’t in an
extended transaction.  Such a time step must either include the &lt;code class=&quot;highlighter-rouge&quot;&gt;o_wb_ack&lt;/code&gt;
from a just-ended transaction or the number of outstanding transactions
must be zero.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(posedge i_clk)
	if (ack_delay == 0)
		assert((o_wb_ack)||(f_outstanding == 0));&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Unfortunately, without anything more, we may get a
&lt;a href=&quot;/blog/2017/07/31/vcd.html&quot;&gt;trace&lt;/a&gt; from the tools
that has &lt;code class=&quot;highlighter-rouge&quot;&gt;o_wb_ack&lt;/code&gt; on for a very long time, yet &lt;code class=&quot;highlighter-rouge&quot;&gt;f_outstanding&lt;/code&gt; is some value
inconsistent with our design.  For example, the core could be responding to one
empty acknowledgment request after another while &lt;code class=&quot;highlighter-rouge&quot;&gt;f_outstanding ==2&lt;/code&gt;.&lt;br /&gt;
Of course the core would never get into this situation, but we need to
communicate that to the
&lt;a href=&quot;/blog/2018/03/10/induction-exercise.html&quot;&gt;induction&lt;/a&gt;
engine.&lt;/p&gt;

&lt;p&gt;In the first case, following any non-pipelined &lt;code class=&quot;highlighter-rouge&quot;&gt;i_wb_stb&lt;/code&gt; request, there should
then be only one request outstanding.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(posedge i_clk)
	if ((f_past_valid)&amp;amp;&amp;amp;(!i_reset)&amp;amp;&amp;amp;(i_wb_cyc))
	begin
		if (((!OPT_PIPE)||($past(o_spi_cs_n)))
			&amp;amp;&amp;amp;($past(i_wb_stb))&amp;amp;&amp;amp;(!$past(o_wb_stall))&amp;amp;&amp;amp;(i_wb_cyc))
			assert(f_outstanding == 1);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Likewise in the middle of any request, there should only be one bus request
outstanding.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;		if (ack_delay &amp;gt; 0)
			assert((o_wb_ack)||(f_outstanding == 1));
	end

&amp;lt;figure class=&quot;highlight&quot;&amp;gt;&amp;lt;pre&amp;gt;&amp;lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&amp;gt;If there are ever two acknowledgments back to back, they can only be the
empty acknowledgments we discussed earlier.  Hence, we should only have the
last request outstanding or no requests outstanding.&amp;lt;/code&amp;gt;&amp;lt;/pre&amp;gt;&amp;lt;/figure&amp;gt;

	always @(posedge i_clk)
	if ((f_past_valid)&amp;amp;&amp;amp;(o_wb_ack)&amp;amp;&amp;amp;($past(o_wb_ack)))
		assert(f_outstanding &amp;lt;= 1);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;There is only one time we should ever have two requests outstanding: that is
when we just accepted a request for a pipelined interaction and &lt;code class=&quot;highlighter-rouge&quot;&gt;OPT_PIPE&lt;/code&gt; is
true.  On that same clock, the acknowledgment line should be high, &lt;code class=&quot;highlighter-rouge&quot;&gt;o_spi_cs_n&lt;/code&gt;
should be active (low), and &lt;code class=&quot;highlighter-rouge&quot;&gt;ack_delay&lt;/code&gt; should be 32.  Under no other
circumstances should there ever be two requests outstanding.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(posedge i_clk)
	if (f_outstanding == 2)
		assert((OPT_PIPE)&amp;amp;&amp;amp;(o_wb_ack)&amp;amp;&amp;amp;(!o_spi_cs_n)&amp;amp;&amp;amp;(o_spi_sck)
			&amp;amp;&amp;amp;(ack_delay==7&#39;d32));&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Following any bus strobe that is neither a &lt;code class=&quot;highlighter-rouge&quot;&gt;bus_request&lt;/code&gt; nor a &lt;code class=&quot;highlighter-rouge&quot;&gt;user_request&lt;/code&gt;
of the configuration port, there should immediately be an acknowledgment
on the next clock.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(posedge i_clk)
	if ((f_past_valid)&amp;amp;&amp;amp;($past(i_wb_stb))&amp;amp;&amp;amp;(!$past(o_wb_stall)))
	begin
		if ((i_wb_cyc)&amp;amp;&amp;amp;(!i_reset)
				&amp;amp;&amp;amp;(!$past(user_request))&amp;amp;&amp;amp;(!$past(bus_request)))
			assert((o_wb_ack)&amp;amp;&amp;amp;(f_outstanding == 1));
	end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;That’s the last of the assertions necessary to make certain the formal
properties for &lt;a href=&quot;https://github.com/ZipCPU/icozip/blob/master/rtl/icozip/spixpress.v&quot;&gt;this
core&lt;/a&gt;
properly integrate with the properties from our
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;Wishbone property set&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Now let’s make some assertions of the 
&lt;a href=&quot;https://en.wikipedia.org/wiki/Serial_Peripheral_Interface&quot;&gt;SPI&lt;/a&gt;
protocol next.&lt;/p&gt;

&lt;p&gt;If you’ve taken my course in formal verification, you may remember that I
usually spend some time discussing how to properly describe a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Serial_Peripheral_Interface&quot;&gt;SPI&lt;/a&gt;
protocol interaction in the multi-clock section.  This is not necessary
here.  Not only is everything synchronous, but the 
&lt;a href=&quot;https://en.wikipedia.org/wiki/Serial_Peripheral_Interface&quot;&gt;SPI&lt;/a&gt; interaction
of interest isn’t slow enough to make any of those multiclock property
descriptions, &lt;code class=&quot;highlighter-rouge&quot;&gt;$rose()&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;$fell()&lt;/code&gt;, or &lt;code class=&quot;highlighter-rouge&quot;&gt;$stable()&lt;/code&gt;, all that useful here.&lt;/p&gt;

&lt;p&gt;Still, we can describe some useful parts of the interaction here.&lt;/p&gt;

&lt;p&gt;For example, we’ve chosen to leave the clock idle unless &lt;code class=&quot;highlighter-rouge&quot;&gt;o_spi_cs_n&lt;/code&gt; is low.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(*)
	if (o_spi_cs_n)
		assert(!o_spi_sck);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;While I suppose we could just leave the clock running, that would break some
other things–notably the configuration port.&lt;/p&gt;

&lt;p&gt;Similarly, any time &lt;code class=&quot;highlighter-rouge&quot;&gt;ack_delay&lt;/code&gt; is other than zero, the &lt;code class=&quot;highlighter-rouge&quot;&gt;SCK&lt;/code&gt; line should be
high.  This would reference either &lt;code class=&quot;highlighter-rouge&quot;&gt;o_spi_sck&lt;/code&gt; going to the &lt;a href=&quot;https://github.com/ZipCPU/icozip/blob/master/rtl/icozip/oclkddr.v&quot;&gt;output DDR
module&lt;/a&gt;,
or our local version of whether or &lt;code class=&quot;highlighter-rouge&quot;&gt;SCK&lt;/code&gt; is really ticking in &lt;code class=&quot;highlighter-rouge&quot;&gt;actual_sck&lt;/code&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(*)
		assert((o_spi_sck||actual_sck) == (ack_delay &amp;gt; 0));&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Anytime &lt;code class=&quot;highlighter-rouge&quot;&gt;ack_delay&lt;/code&gt; is zero, we are not in the middle of any transactions.
Hence, &lt;code class=&quot;highlighter-rouge&quot;&gt;o_wb_stall&lt;/code&gt; should also be zero.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(*)
	if (ack_delay == 0)
		assert(!o_wb_stall);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Likewise, if the &lt;code class=&quot;highlighter-rouge&quot;&gt;ack_delay&lt;/code&gt; is ever greater than one, then the bus should
be stalled.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	else if (ack_delay &amp;gt; 1)
		assert(o_wb_stall);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Indeed, with one exception any time &lt;code class=&quot;highlighter-rouge&quot;&gt;ack_delay&lt;/code&gt; is greater than zero the bus
should be stalled.  The one exception is just before a pipelined transaction.
Hence, if &lt;code class=&quot;highlighter-rouge&quot;&gt;ack_delay&lt;/code&gt; is one and pipelined reads are disabled, or equivalently
if we are in the &lt;code class=&quot;highlighter-rouge&quot;&gt;cfg_user_mode&lt;/code&gt;, then the interface should be stalled
when &lt;code class=&quot;highlighter-rouge&quot;&gt;ack_delay&lt;/code&gt; is one.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	else if ((!OPT_PIPE)&amp;amp;&amp;amp;(ack_delay == 1))
		assert(o_wb_stall);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Just to constrain the
&lt;a href=&quot;/blog/2018/03/10/induction-exercise.html&quot;&gt;induction&lt;/a&gt;
engine further, the &lt;code class=&quot;highlighter-rouge&quot;&gt;ack_delay&lt;/code&gt; should always be less than or equal to &lt;code class=&quot;highlighter-rouge&quot;&gt;65&lt;/code&gt;.
Although we know this to be true already, the
&lt;a href=&quot;/blog/2018/03/10/induction-exercise.html&quot;&gt;induction&lt;/a&gt;
engine can do some weird things if you don’t limit values like this properly.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(*)
		assert(ack_delay &amp;lt;= 7&#39;d65);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;In a similar fashion, if &lt;code class=&quot;highlighter-rouge&quot;&gt;cfg_user_mode&lt;/code&gt; is ever true, then the
&lt;code class=&quot;highlighter-rouge&quot;&gt;ack_delay&lt;/code&gt; must be less than or equal to &lt;code class=&quot;highlighter-rouge&quot;&gt;9&lt;/code&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(*)
	if (cfg_user_mode)
		assert(ack_delay &amp;lt;= 7&#39;d9);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Our final ad-hoc assertion will be that &lt;code class=&quot;highlighter-rouge&quot;&gt;o_spi_cs_n&lt;/code&gt; is only ever active
(low) if either we are in the &lt;code class=&quot;highlighter-rouge&quot;&gt;cfg_user_mode&lt;/code&gt; or if &lt;code class=&quot;highlighter-rouge&quot;&gt;ack_delay &amp;gt; 0&lt;/code&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(*)
		assert(o_spi_cs_n != ((cfg_user_mode)||(ack_delay &amp;gt; 0)));&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;These simple assertions above will keep us in the valid operating range of &lt;a href=&quot;https://github.com/ZipCPU/icozip/blob/master/rtl/icozip/spixpress.v&quot;&gt;this
core&lt;/a&gt;.
Now we just need to convince ourselves that this core actually works and does
what it is supposed to do.  To do that, we’ll try out some of the &lt;a href=&quot;http://www.asic-world.com/systemverilog/assertions4.html#Sequences&quot;&gt;System
Verilog
sequences&lt;/a&gt;
available to the &lt;a href=&quot;http://www.verific.com&quot;&gt;Verific-enabled&lt;/a&gt; version of
&lt;a href=&quot;http://www.clifford.at/yosys&quot;&gt;yosys&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&quot;step-three-sequence-assertions&quot;&gt;Step three: Sequence Assertions&lt;/h3&gt;

&lt;p&gt;If you recall from the beginning of this article, one of the reasons for
this project was to see if a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/icozip/blob/master/rtl/icozip/spixpress.v&quot;&gt;controller&lt;/a&gt;
would be a good test of &lt;a href=&quot;http://www.asic-world.com/systemverilog/assertions4.html#Sequences&quot;&gt;System Verilog
sequences&lt;/a&gt;.
In particular, I’ve been looking for some of the use cases that highlight
the utility of &lt;a href=&quot;http://www.asic-world.com/systemverilog/assertions4.html#Sequences&quot;&gt;System
Verilog’s
sequences&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Prior to this project, I had only tested
&lt;a href=&quot;http://www.clifford.at/yosys&quot;&gt;yosys&lt;/a&gt;’s ability to handle
&lt;a href=&quot;http://www.asic-world.com/systemverilog/assertions4.html#Sequences&quot;&gt;System Verilog
sequences&lt;/a&gt;
with FIFOs and a &lt;a href=&quot;https://github.com/ZipCPU/wbuart32/blob/master/rtl/txuartlite.v&quot;&gt;UART
transmitter&lt;/a&gt;.
Since starting this project, I have now tested and tried
&lt;a href=&quot;http://www.asic-world.com/systemverilog/assertions4.html#Sequences&quot;&gt;them&lt;/a&gt;
out with a &lt;a href=&quot;https://github.com/ZipCPU/wbpmic/blob/master/rtl/smpladc.v&quot;&gt;SPI-based ADC&lt;/a&gt;,
and the &lt;a href=&quot;https://en.wikipedia.org/wiki/Static_random-access_memory&quot;&gt;SRAM&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/icozip/blob/master/rtl/icozip/sramdev.v&quot;&gt;controller&lt;/a&gt;
for this same &lt;a href=&quot;https://github.com/ZipCPU/icozip&quot;&gt;ICOZip Project&lt;/a&gt;.
While I like the expressiveness of the
&lt;a href=&quot;http://www.asic-world.com/systemverilog/assertions4.html#Sequences&quot;&gt;System Verilog
sequence&lt;/a&gt;
language, I’m also glad I learned how to do
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal verification with immediate assertions only&lt;/a&gt; first.  &lt;a href=&quot;http://www.asic-world.com/systemverilog/assertions4.html#Sequences&quot;&gt;Sequence&lt;/a&gt;
are not nearly as simple or as easy to work with as the immediate assertions
we’ve been working with, and the background I gained in immediate assertions
helped me a lot while learning
&lt;a href=&quot;http://www.asic-world.com/systemverilog/assertions4.html#Sequences&quot;&gt;sequences&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;We’ll split the
&lt;a href=&quot;http://www.asic-world.com/systemverilog/assertions4.html#Sequences&quot;&gt;sequences&lt;/a&gt;
discussion here into two parts.  The first part, contained in this section,
will be about guaranteeing that our &lt;code class=&quot;highlighter-rouge&quot;&gt;ack_delay&lt;/code&gt; based state machine works as
desired.  In the next section, will dig in a bit further and verify that what
gets returned to the bus is actually what we read from the device.  Once we’re
done, we’ll move on to how I tested &lt;a href=&quot;https://github.com/ZipCPU/icozip/blob/master/rtl/icozip/spixpress.v&quot;&gt;this
core&lt;/a&gt;
on the actual hardware of the &lt;a href=&quot;http://www.icoboard.org&quot;&gt;ICO board&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;In many ways, it might make the most sense to read this section from the
bottom up, rather than the top down, because in order to finally express
what we want to at the end, we have to build a lot of infrastructure to get
there.  Hence, if you want to see where we are going, skip to the end of
this section and look over the assertions found there.&lt;/p&gt;

&lt;p&gt;That said, let’s start with two variables these
&lt;a href=&quot;http://www.asic-world.com/systemverilog/assertions4.html#Sequences&quot;&gt;sequences&lt;/a&gt;
will use.  In particular, we want some values that are guaranteed to stay
constant throughout the duration of the
&lt;a href=&quot;http://www.asic-world.com/systemverilog/assertions4.html#Sequences&quot;&gt;sequences&lt;/a&gt;–values
the &lt;a href=&quot;http://www.asic-world.com/systemverilog/assertions4.html#Sequences&quot;&gt;sequences&lt;/a&gt;
can reference, and that won’t change.  We’ll create two here, one to capture
the last address requested of the bus, and a second to capture what would be
the next address after that.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;`ifdef	VERIFIC
	reg	[21:0]	f_last_addr, f_next_addr;

	always @(posedge i_clk)
	if (bus_request)
		f_last_addr &amp;lt;= i_wb_addr[21:0];

	always @(*)
		f_next_addr &amp;lt;= f_last_addr + 1&#39;b1;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Our first assertion is something simple: Any request, other than a
&lt;code class=&quot;highlighter-rouge&quot;&gt;user_request&lt;/code&gt; (i.e. a write) of the configuration port or a normal
&lt;code class=&quot;highlighter-rouge&quot;&gt;bus_request&lt;/code&gt; (i.e. a read) should be acknowledged on the next clock, without
stalling the bus.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	assert property (@(posedge i_clk)
		disable iff ((i_reset)||(!i_wb_cyc))
		((i_wb_stb)||(i_cfg_stb))&amp;amp;&amp;amp;(!o_wb_stall)
				&amp;amp;&amp;amp;(!user_request)&amp;amp;&amp;amp;(!bus_request)
		|=&amp;gt; (o_wb_ack)&amp;amp;&amp;amp;(!o_wb_stall));&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;If this form of an assertion is new to you, then don’t let it be.  We’ve been
discussing this basic assertion for some time, only we’ve described it in
a different fashion.  Instead of,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	assert property (@(posedge i_clk)
		A |=&amp;gt; B);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;we’ve been writing&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(posedge i_clk)
	if ((f_past_valid)&amp;amp;&amp;amp;($past(A)))
		assert(B);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The two are really just two forms of the same thing.  Personally, I like the
new form.  It seems simpler and cleaner.&lt;/p&gt;

&lt;p&gt;What about the &lt;code class=&quot;highlighter-rouge&quot;&gt;disable iff&lt;/code&gt; statement?  That just disables the assertion
on any of the clocks that it would be applied to.  Hence,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	assert property (@(posedge i_clk)
		disable iff (C)
		A |=&amp;gt; B);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;is the same as&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(posedge i_clk)
	if ((f_past_valid)&amp;amp;&amp;amp;($past(A))&amp;amp;&amp;amp;(!$past(C))&amp;amp;&amp;amp;(!C))
		assert(B);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;There’s another new form as well.  Instead of writing,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(*)
	if (A)
		assert(B);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;we could equivalently write&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	assert property (@(posedge i_clk)
		A |-&amp;gt; B);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Both of these newer forms, however, currently require the
&lt;a href=&quot;http://www.verific.com&quot;&gt;Verific enabled&lt;/a&gt;
version of &lt;a href=&quot;http://www.clifford.at/yosys&quot;&gt;yosys&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Using this newer form, I can express&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	assert property (@(posedge i_clk)
		(i_wb_stb)&amp;amp;&amp;amp;(!o_wb_stall)&amp;amp;&amp;amp;(!o_spi_cs_n)&amp;amp;&amp;amp;(!i_wb_we)
			&amp;amp;&amp;amp;(!cfg_user_mode)
		|-&amp;gt; (OPT_PIPE)&amp;amp;&amp;amp;(i_wb_addr == f_next_addr)
		);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;That is to say, if we ever accept a new &lt;code class=&quot;highlighter-rouge&quot;&gt;bus_request&lt;/code&gt; while &lt;code class=&quot;highlighter-rouge&quot;&gt;o_spi_cs_n&lt;/code&gt;
is active (low), then &lt;code class=&quot;highlighter-rouge&quot;&gt;OPT_PIPE&lt;/code&gt; must be valid and this new request
address &lt;em&gt;must&lt;/em&gt; be for the next address in the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Those two assertions should get your feet wet.  Now let’s try our first
&lt;a href=&quot;http://www.asic-world.com/systemverilog/assertions4.html#Sequences&quot;&gt;sequence&lt;/a&gt;.
If you’ve never used them,
&lt;a href=&quot;http://www.asic-world.com/systemverilog/assertions4.html#Sequences&quot;&gt;sequences&lt;/a&gt;
are neither assertions nor assumptions.  Instead, they can be used to describe
a &lt;em&gt;&lt;a href=&quot;http://www.asic-world.com/systemverilog/assertions4.html#Sequences&quot;&gt;sequence&lt;/a&gt;&lt;/em&gt;
of states that can then be used within an assertion, assumption, or even
a cover property.&lt;/p&gt;

&lt;p&gt;For this first sequence, let’s describe the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt;
read command where we send a &lt;code class=&quot;highlighter-rouge&quot;&gt;8&#39;h03&lt;/code&gt; to the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt;
device.  This sequence starts with an idle cycle with &lt;code class=&quot;highlighter-rouge&quot;&gt;o_spi_cs_n&lt;/code&gt; active
and &lt;code class=&quot;highlighter-rouge&quot;&gt;o_spi_sck&lt;/code&gt; true, but &lt;code class=&quot;highlighter-rouge&quot;&gt;actual_sck&lt;/code&gt; hasn’t been set yet.&lt;/p&gt;

&lt;p&gt;We’ll start this description by naming our
&lt;a href=&quot;http://www.asic-world.com/systemverilog/assertions4.html#Sequences&quot;&gt;sequence&lt;/a&gt;,
&lt;code class=&quot;highlighter-rouge&quot;&gt;READ_COMMAND&lt;/code&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	sequence READ_COMMAND;
		// Send command 8&#39;h03&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Then we’ll describe that first state.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;		(f_last_addr == $past(i_wb_addr))
				&amp;amp;&amp;amp;(!o_spi_cs_n)&amp;amp;&amp;amp;(o_spi_sck)&amp;amp;&amp;amp;(!o_spi_mosi)
				&amp;amp;&amp;amp;(!actual_sck)&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;On the next clock, we get into sending the actual command contained in the
&lt;code class=&quot;highlighter-rouge&quot;&gt;o_spi_mosi&lt;/code&gt; output values.  To express that this will start on the next
clock, we’ll use the &lt;code class=&quot;highlighter-rouge&quot;&gt;##1&lt;/code&gt; expression.  This portion of the
&lt;a href=&quot;http://www.asic-world.com/systemverilog/assertions4.html#Sequences&quot;&gt;sequence&lt;/a&gt;,
however, will take us a whole 8 clocks.  During all of those 8 clocks,
we’ll want to assert that the &lt;code class=&quot;highlighter-rouge&quot;&gt;f_last_addr&lt;/code&gt; value stays constant, that
&lt;code class=&quot;highlighter-rouge&quot;&gt;o_spi_cs_n&lt;/code&gt; stays active, and that &lt;code class=&quot;highlighter-rouge&quot;&gt;o_spi_sck&lt;/code&gt; remains true.  Hence,
&lt;em&gt;throughout&lt;/em&gt; these next 8-clocks, these must hold.  That’s the purpose of
the &lt;em&gt;throughout&lt;/em&gt; statement.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;		##1 ( ((f_last_addr == $past(f_last_addr))
			&amp;amp;&amp;amp;(!o_spi_cs_n)&amp;amp;&amp;amp;(o_spi_sck)&amp;amp;&amp;amp;(actual_sck)) throughout&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Now we can work our way through each of those individual 8 clocks.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;				(!o_spi_mosi)&amp;amp;&amp;amp;(ack_delay==7&#39;d64)&amp;amp;&amp;amp;(actual_sck)
				##1 (!o_spi_mosi)&amp;amp;&amp;amp;(ack_delay==7&#39;d63)
				##1 (!o_spi_mosi)&amp;amp;&amp;amp;(ack_delay==7&#39;d62)
				##1 (!o_spi_mosi)&amp;amp;&amp;amp;(ack_delay==7&#39;d61)
				##1 (!o_spi_mosi)&amp;amp;&amp;amp;(ack_delay==7&#39;d60)
				##1 (!o_spi_mosi)&amp;amp;&amp;amp;(ack_delay==7&#39;d59)
				##1 ( o_spi_mosi)&amp;amp;&amp;amp;(ack_delay==7&#39;d58)
				##1 ( o_spi_mosi)&amp;amp;&amp;amp;(ack_delay==7&#39;d57));
	endsequence&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;In this
&lt;a href=&quot;http://www.asic-world.com/systemverilog/assertions4.html#Sequences&quot;&gt;sequence&lt;/a&gt;
description, I’ve tried to constrain and describe every register that’s a part
of state associated with sending this command.  Further, since the &lt;code class=&quot;highlighter-rouge&quot;&gt;o_spi_mosi&lt;/code&gt;
and &lt;code class=&quot;highlighter-rouge&quot;&gt;ack_delay&lt;/code&gt; values changed during these 8-clocks, I didn’t lump them
together with the other predicates that needed to be true &lt;code class=&quot;highlighter-rouge&quot;&gt;throughout&lt;/code&gt;
all eight of these cycles.&lt;/p&gt;

&lt;p&gt;The next
&lt;a href=&quot;http://www.asic-world.com/systemverilog/assertions4.html#Sequences&quot;&gt;sequence&lt;/a&gt;
is the one where we send the address we want to read from to the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Serial_Peripheral_Interface&quot;&gt;SPI&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt;.  Since the
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;Wishbone bus&lt;/a&gt;
is word based, and the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt; is byte based, we’ll add
two zero’s at the end of this
&lt;a href=&quot;http://www.asic-world.com/systemverilog/assertions4.html#Sequences&quot;&gt;sequence&lt;/a&gt;.
The format itself should look very similar to the
format of the last one: we’ll start by naming the 
&lt;a href=&quot;http://www.asic-world.com/systemverilog/assertions4.html#Sequences&quot;&gt;sequence&lt;/a&gt;,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	sequence	SEND_ADDRESS;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;then we’ll define those properties that must hold throughout the
&lt;a href=&quot;http://www.asic-world.com/systemverilog/assertions4.html#Sequences&quot;&gt;sequence&lt;/a&gt;,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;		(((f_last_addr == $past(f_last_addr))&amp;amp;&amp;amp;(!o_spi_cs_n)&amp;amp;&amp;amp;(o_spi_sck)
			&amp;amp;&amp;amp;(actual_sck))
		throughout&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;finally, we’ll step through each of the clock cycles within the
&lt;a href=&quot;http://www.asic-world.com/systemverilog/assertions4.html#Sequences&quot;&gt;sequence&lt;/a&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;			(o_spi_mosi == f_last_addr[21])&amp;amp;&amp;amp;(ack_delay==7&#39;d56)
			##1 (o_spi_mosi == f_last_addr[20])&amp;amp;&amp;amp;(ack_delay==7&#39;d55)
			##1 (o_spi_mosi == f_last_addr[19])&amp;amp;&amp;amp;(ack_delay==7&#39;d54)
			##1 (o_spi_mosi == f_last_addr[18])&amp;amp;&amp;amp;(ack_delay==7&#39;d53)
			##1 (o_spi_mosi == f_last_addr[17])&amp;amp;&amp;amp;(ack_delay==7&#39;d52)
			##1 (o_spi_mosi == f_last_addr[16])&amp;amp;&amp;amp;(ack_delay==7&#39;d51)
			##1 (o_spi_mosi == f_last_addr[15])&amp;amp;&amp;amp;(ack_delay==7&#39;d50)
			##1 (o_spi_mosi == f_last_addr[14])&amp;amp;&amp;amp;(ack_delay==7&#39;d49)
			##1 (o_spi_mosi == f_last_addr[13])&amp;amp;&amp;amp;(ack_delay==7&#39;d48)
			##1 (o_spi_mosi == f_last_addr[12])&amp;amp;&amp;amp;(ack_delay==7&#39;d47)
			##1 (o_spi_mosi == f_last_addr[11])&amp;amp;&amp;amp;(ack_delay==7&#39;d46)
			##1 (o_spi_mosi == f_last_addr[10])&amp;amp;&amp;amp;(ack_delay==7&#39;d45)
			##1 (o_spi_mosi == f_last_addr[ 9])&amp;amp;&amp;amp;(ack_delay==7&#39;d44)
			##1 (o_spi_mosi == f_last_addr[ 8])&amp;amp;&amp;amp;(ack_delay==7&#39;d43)
			##1 (o_spi_mosi == f_last_addr[ 7])&amp;amp;&amp;amp;(ack_delay==7&#39;d42)
			##1 (o_spi_mosi == f_last_addr[ 6])&amp;amp;&amp;amp;(ack_delay==7&#39;d41)
			##1 (o_spi_mosi == f_last_addr[ 5])&amp;amp;&amp;amp;(ack_delay==7&#39;d40)
			##1 (o_spi_mosi == f_last_addr[ 4])&amp;amp;&amp;amp;(ack_delay==7&#39;d39)
			##1 (o_spi_mosi == f_last_addr[ 3])&amp;amp;&amp;amp;(ack_delay==7&#39;d38)
			##1 (o_spi_mosi == f_last_addr[ 2])&amp;amp;&amp;amp;(ack_delay==7&#39;d37)
			##1 (o_spi_mosi == f_last_addr[ 1])&amp;amp;&amp;amp;(ack_delay==7&#39;d36)
			##1 (o_spi_mosi == f_last_addr[ 0])&amp;amp;&amp;amp;(ack_delay==7&#39;d35)&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Don’t forget the two zero bits at the end of the address!&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;			##1 (o_spi_mosi == 1&#39;b0)&amp;amp;&amp;amp;(ack_delay==7&#39;d34)
			##1 (o_spi_mosi == 1&#39;b0)&amp;amp;&amp;amp;(ack_delay==7&#39;d33));
	endsequence&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;We can now define a third
&lt;a href=&quot;http://www.asic-world.com/systemverilog/assertions4.html#Sequences&quot;&gt;sequence&lt;/a&gt;:
the one where we actually read the data from the device.  This has the exact
same form as before, only we’re going to introduce  new expression, the &lt;code class=&quot;highlighter-rouge&quot;&gt;[*8]&lt;/code&gt;
or &lt;code class=&quot;highlighter-rouge&quot;&gt;[*7]&lt;/code&gt;.  This means that we want to repeat the given state by that many
clocks.  I’m going to use this to help keep &lt;code class=&quot;highlighter-rouge&quot;&gt;ack_delay&lt;/code&gt; bounded–at least
bounded enough that the formal tools properly recognize after more than eight
clocks which state of this sequence is taking place, should they decide
to try to start in the middle of the
&lt;a href=&quot;http://www.asic-world.com/systemverilog/assertions4.html#Sequences&quot;&gt;sequence&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;As before, we start with the name of the
&lt;a href=&quot;http://www.asic-world.com/systemverilog/assertions4.html#Sequences&quot;&gt;sequence&lt;/a&gt;
followed by the properties that will hold &lt;code class=&quot;highlighter-rouge&quot;&gt;throughout&lt;/code&gt; the
&lt;a href=&quot;http://www.asic-world.com/systemverilog/assertions4.html#Sequences&quot;&gt;sequence&lt;/a&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	sequence	READ_DATA;
		(((o_wb_stall)&amp;amp;&amp;amp;(!o_spi_cs_n)&amp;amp;&amp;amp;(o_spi_sck)
			&amp;amp;&amp;amp;(o_wb_data == $past({o_wb_data[30:0], i_spi_miso})))
		throughout&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The first clock period, however, will be replicated 8 times.  It will primarily
just constrain &lt;code class=&quot;highlighter-rouge&quot;&gt;ack_delay&lt;/code&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;		(ack_delay &amp;lt;= 7&#39;d32)&amp;amp;&amp;amp;(ack_delay &amp;gt;= 7&#39;d25) [*8]&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;And so on, repeating each clock period 8 times until the last.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;		##1 (ack_delay &amp;lt;= 7&#39;d24)&amp;amp;&amp;amp;(ack_delay &amp;gt;= 7&#39;d17) [*8]
		##1 (ack_delay &amp;lt;= 7&#39;d16)&amp;amp;&amp;amp;(ack_delay &amp;gt;=  7&#39;d9) [*8]
		##1 (ack_delay &amp;lt;=  7&#39;d8)&amp;amp;&amp;amp;(ack_delay &amp;gt;=  7&#39;d2) [*7])&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Watch the parentheses, because that last line also ends the &lt;code class=&quot;highlighter-rouge&quot;&gt;throughout&lt;/code&gt;
statement that we started with, even though the we’re not done defining
this
&lt;a href=&quot;http://www.asic-world.com/systemverilog/assertions4.html#Sequences&quot;&gt;sequence&lt;/a&gt;
yet.&lt;/p&gt;

&lt;p&gt;We’ve broken the
&lt;a href=&quot;http://www.asic-world.com/systemverilog/assertions4.html#Sequences&quot;&gt;sequence&lt;/a&gt;
at this point because the next period is special.
That’s the only period where the our signals might change in order to support
a pipelined interaction.  In this case, the stall line might be low if
&lt;code class=&quot;highlighter-rouge&quot;&gt;OPT_PIPE&lt;/code&gt; is also true, otherwise we remain stalled like we were in the
last clock.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;		##1 ((!o_spi_cs_n)&amp;amp;&amp;amp;(actual_sck)&amp;amp;&amp;amp;(ack_delay == 7&#39;d1)
			&amp;amp;&amp;amp;(((OPT_PIPE)&amp;amp;&amp;amp;(i_wb_stb)&amp;amp;&amp;amp;(!i_wb_we)&amp;amp;&amp;amp;(o_spi_sck))
				||((o_wb_stall)&amp;amp;&amp;amp;(!o_spi_sck)))
			&amp;amp;&amp;amp;(o_wb_data == $past({o_wb_data[30:0], i_spi_miso})))&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Finally, we’ll end this
&lt;a href=&quot;http://www.asic-world.com/systemverilog/assertions4.html#Sequences&quot;&gt;sequence&lt;/a&gt;
describing a read from the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash memory&lt;/a&gt;
with a bus acknowledgment, and a guarantee if &lt;code class=&quot;highlighter-rouge&quot;&gt;OPT_PIPE&lt;/code&gt; isn’t true
that the bus has returned to idle.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;		##1 (o_wb_ack)
			&amp;amp;&amp;amp;(o_wb_data == $past({o_wb_data[30:0], i_spi_miso}))
			&amp;amp;&amp;amp;((OPT_PIPE)||((o_spi_cs_n)
					&amp;amp;&amp;amp;(!o_spi_sck)&amp;amp;&amp;amp;(!actual_sck)));
	endsequence&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;What can you do with all these
&lt;a href=&quot;http://www.asic-world.com/systemverilog/assertions4.html#Sequences&quot;&gt;sequence&lt;/a&gt;
we’ve just defined?  You can string them together within an assertion!&lt;/p&gt;

&lt;p&gt;The following assertion asserts that, following any read request from the
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;Wishbone bus&lt;/a&gt;,
the device will send the &lt;code class=&quot;highlighter-rouge&quot;&gt;READ_COMMAND&lt;/code&gt;, the address (&lt;code class=&quot;highlighter-rouge&quot;&gt;SEND_ADDRESS&lt;/code&gt;), and
then read the data (&lt;code class=&quot;highlighter-rouge&quot;&gt;READ_DATA&lt;/code&gt;) from the device.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	assert property (@(posedge i_clk)
		disable iff ((i_reset)||(!i_wb_cyc))
		(i_wb_stb)&amp;amp;&amp;amp;(!o_wb_stall)&amp;amp;&amp;amp;(!i_wb_we)&amp;amp;&amp;amp;(o_spi_cs_n)
			&amp;amp;&amp;amp;(!cfg_user_mode)
		// Send command 8&#39;h03
		|=&amp;gt; READ_COMMAND
		// Send the requested address
		##1 ((f_last_addr == $past(f_last_addr)) throughout
				SEND_ADDRESS)
		// Clock in 32-bits of data
		##1 READ_DATA);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Not bad, huh?&lt;/p&gt;

&lt;p&gt;This gets us most of the way there.  However, a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt;
is a type of memory, and there are
&lt;a href=&quot;/zipcpu/2018/07/13/memories.html&quot;&gt;particular properties&lt;/a&gt;
you want to formally verify with respect to any
&lt;a href=&quot;/zipcpu/2018/07/13/memories.html&quot;&gt;memory&lt;/a&gt;
interaction.  That will be our next section.&lt;/p&gt;

&lt;h3 id=&quot;step-four-known-addressdata-assertions&quot;&gt;Step four: Known Address/Data Assertions&lt;/h3&gt;

&lt;p&gt;The rule for formally verifying
&lt;a href=&quot;/zipcpu/2018/07/13/memories.html&quot;&gt;memories&lt;/a&gt; is that
you want to &lt;em&gt;assume&lt;/em&gt; any time you read from an arbitrary address, that
you get a known arbitrary value in response.  The second part is to &lt;em&gt;assert&lt;/em&gt;
that whenever you return the result of the read to the bus, you also return the
arbitrarily chosen value.&lt;/p&gt;

&lt;p&gt;I initially created those rules here in
&lt;a href=&quot;http://www.asic-world.com/systemverilog/assertions4.html#Sequences&quot;&gt;sequence&lt;/a&gt;
logic.  One property assumed known data would be read from &lt;code class=&quot;highlighter-rouge&quot;&gt;i_spi_miso&lt;/code&gt;
following a request from that known address, and the second property asserted
that the same known data would be returned in &lt;code class=&quot;highlighter-rouge&quot;&gt;o_wb_data&lt;/code&gt; once &lt;code class=&quot;highlighter-rouge&quot;&gt;o_wb_ack&lt;/code&gt; was
set.&lt;/p&gt;

&lt;p&gt;I’ve since torn that work up.  It turns out that there’s an easier way
to do the same thing when you are using
&lt;a href=&quot;http://www.asic-world.com/systemverilog/assertions4.html#Sequences&quot;&gt;sequences&lt;/a&gt;.
We’ll still allow the formal tool to pick an arbitrary data value, but we can
do this without the heavy weight of the formal
&lt;a href=&quot;/zipcpu/2018/07/13/memories.html&quot;&gt;memories&lt;/a&gt; rule.
In particular, we don’t need the arbitrary address, just the data.&lt;/p&gt;

&lt;p&gt;Here’s how we’ll do it: we’ll create a rule that whenever the arbitrary data is
read, regardless of what address it is read from, that value read from the
device is returned to the bus.&lt;/p&gt;

&lt;p&gt;We’ll start at the top by assuming a constant 32-bit value.  The formal solver
will get to pick any value it wants for these 32-bits.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	(* anyconst *) wire	[31:0]	f_data;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Next, we’ll define a
&lt;a href=&quot;http://www.asic-world.com/systemverilog/assertions4.html#Sequences&quot;&gt;sequence&lt;/a&gt;
where an arbitrary octet, &lt;code class=&quot;highlighter-rouge&quot;&gt;B&lt;/code&gt;, is received from the interface.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	sequence	DATA_BYTE(local input [7:0] B);
		(i_spi_miso == B[7])
		##1 (i_spi_miso == B[6])
		##1 (i_spi_miso == B[5])
		##1 (i_spi_miso == B[4])
		##1 (i_spi_miso == B[3])
		##1 (i_spi_miso == B[2])
		##1 (i_spi_miso == B[1])
		##1 (i_spi_miso == B[0]);
	endsequence&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Did you notice that this
&lt;a href=&quot;http://www.asic-world.com/systemverilog/assertions4.html#Sequences&quot;&gt;sequence&lt;/a&gt;
accepted an 8-bit parameter?  Neat!&lt;/p&gt;

&lt;p&gt;Now, if we string four of these 
&lt;a href=&quot;http://www.asic-world.com/systemverilog/assertions4.html#Sequences&quot;&gt;sequence&lt;/a&gt;
together, then we can describe receiving an arbitrary value on the &lt;code class=&quot;highlighter-rouge&quot;&gt;i_spi_miso&lt;/code&gt;
wire.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	sequence	THIS_DATA;
			DATA_BYTE(f_data[31:24])
			##1 DATA_BYTE(f_data[23:16])
			##1 DATA_BYTE(f_data[15: 8])
			##1 DATA_BYTE(f_data[ 7: 0]);
	endsequence&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Note that this only works because &lt;code class=&quot;highlighter-rouge&quot;&gt;f_data&lt;/code&gt; is constant, since the
&lt;a href=&quot;http://www.asic-world.com/systemverilog/assertions4.html#Sequences&quot;&gt;sequence&lt;/a&gt;
will reference the current value of &lt;code class=&quot;highlighter-rouge&quot;&gt;f_data&lt;/code&gt;, rather than the value
when the
&lt;a href=&quot;http://www.asic-world.com/systemverilog/assertions4.html#Sequences&quot;&gt;sequence&lt;/a&gt;
is activated.&lt;/p&gt;

&lt;p&gt;Now, here’s the trick: &lt;code class=&quot;highlighter-rouge&quot;&gt;THIS_DATA&lt;/code&gt; is a
&lt;a href=&quot;http://www.asic-world.com/systemverilog/assertions4.html#Sequences&quot;&gt;sequence&lt;/a&gt;
containing a description of our known data being received.  While this
&lt;a href=&quot;http://www.asic-world.com/systemverilog/assertions4.html#Sequences&quot;&gt;sequence&lt;/a&gt;
is being received, &lt;code class=&quot;highlighter-rouge&quot;&gt;ack_delay&lt;/code&gt; will go from &lt;code class=&quot;highlighter-rouge&quot;&gt;7&#39;d32&lt;/code&gt; down to &lt;code class=&quot;highlighter-rouge&quot;&gt;7&#39;d1&lt;/code&gt;.  Once
&lt;code class=&quot;highlighter-rouge&quot;&gt;ack_delay&lt;/code&gt; hits zero, or goes around again, there should also be an
acknowledgment.  So, let’s add to that assertion that the outgoing data also
matches the received data.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	assert property (@(posedge i_clk)
		(THIS_DATA and ((!i_reset)&amp;amp;&amp;amp;(i_wb_cyc)
			throughout
		((ack_delay == 7&#39;d32)
			##1 (ack_delay == $past(ack_delay)-1) [*31])))
		|=&amp;gt; (o_wb_ack)&amp;amp;&amp;amp;(o_wb_data == f_data));&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Did you see how this accomplishes both sides of the
&lt;a href=&quot;/zipcpu/2018/07/13/memories.html&quot;&gt;memory proof&lt;/a&gt;
requirement?  Because we placed the
&lt;a href=&quot;/zipcpu/2018/07/13/memories.html&quot;&gt;known data&lt;/a&gt;
&lt;a href=&quot;http://www.asic-world.com/systemverilog/assertions4.html#Sequences&quot;&gt;sequence&lt;/a&gt;
before the non-overlapping implication operator, &lt;code class=&quot;highlighter-rouge&quot;&gt;|=&amp;gt;&lt;/code&gt;, the
&lt;a href=&quot;http://www.asic-world.com/systemverilog/assertions4.html#Sequences&quot;&gt;sequence&lt;/a&gt;
acted as an assumption.  As a result, we now know that no matter what
value is received, the proper value will be returned.&lt;/p&gt;

&lt;p&gt;I then applied the same basic approach to the configuration port.  However,
in the interests of space in an already long article, I’ll let you peruse it
if you are interested.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	generate if (OPT_CFG)
	begin
		// Configuration writes
		assert property (@(posedge i_clk)
			disable iff ((i_reset)||(!i_wb_cyc))
			((i_cfg_stb)&amp;amp;&amp;amp;(!o_wb_stall)&amp;amp;&amp;amp;(i_wb_we)&amp;amp;&amp;amp;(i_wb_data[8]))
			|=&amp;gt; ((!cfg_user_mode)&amp;amp;&amp;amp;(o_spi_cs_n)&amp;amp;&amp;amp;(!o_spi_sck))
				&amp;amp;&amp;amp;(o_wb_ack)&amp;amp;&amp;amp;(!o_wb_stall));

		reg	[7:0]	f_wr_data;
		always @(posedge i_clk)
		if (user_request)
			f_wr_data &amp;lt;= i_wb_data[7:0];

		assert property (@(posedge i_clk)
			disable iff ((i_reset)||(!i_wb_cyc))
			((i_cfg_stb)&amp;amp;&amp;amp;(!o_wb_stall)&amp;amp;&amp;amp;(i_wb_we)&amp;amp;&amp;amp;(!i_wb_data[8]))
			|=&amp;gt; (((cfg_user_mode)&amp;amp;&amp;amp;(!o_spi_cs_n)&amp;amp;&amp;amp;(o_spi_sck)
				&amp;amp;&amp;amp;(o_wb_stall)) throughout
				(!o_spi_mosi)&amp;amp;&amp;amp;(ack_delay==7&#39;d9)
				##1 (o_spi_mosi == f_wr_data[7])
							&amp;amp;&amp;amp;(ack_delay==7&#39;d8)
				##1 (o_spi_mosi == f_wr_data[6])
							&amp;amp;&amp;amp;(ack_delay==7&#39;d7)
				##1 (o_spi_mosi == f_wr_data[5])
							&amp;amp;&amp;amp;(ack_delay==7&#39;d6)
				##1 (o_spi_mosi == f_wr_data[4])
							&amp;amp;&amp;amp;(ack_delay==7&#39;d5)
				##1 (o_spi_mosi == f_wr_data[3])
							&amp;amp;&amp;amp;(ack_delay==7&#39;d4)
				##1 (o_spi_mosi == f_wr_data[2])
							&amp;amp;&amp;amp;(ack_delay==7&#39;d3)
				##1 (o_spi_mosi == f_wr_data[1])
							&amp;amp;&amp;amp;(ack_delay==7&#39;d2))
			##1 ((cfg_user_mode)&amp;amp;&amp;amp;(!o_spi_cs_n)&amp;amp;&amp;amp;(!o_spi_sck)
				&amp;amp;&amp;amp;(actual_sck)&amp;amp;&amp;amp;(o_wb_stall)
				&amp;amp;&amp;amp;(o_spi_mosi == f_wr_data[0])
							&amp;amp;&amp;amp;(ack_delay==7&#39;d1))
			##1 (o_wb_ack)&amp;amp;&amp;amp;(!o_wb_stall)&amp;amp;&amp;amp;(cfg_user_mode)
				&amp;amp;&amp;amp;(!o_spi_sck)&amp;amp;&amp;amp;(!actual_sck)&amp;amp;&amp;amp;(!o_wb_stall));

		// And then configuration reads.  First the write needs to
		// charge the o_wb_data buffer
		assert property (@(posedge i_clk)
			disable iff ((i_reset)||(!i_wb_cyc))
			((i_cfg_stb)&amp;amp;&amp;amp;(!o_wb_stall)&amp;amp;&amp;amp;(i_wb_we)&amp;amp;&amp;amp;(!i_wb_data[8]))
			##2 DATA_BYTE(f_data[7:0])
			|=&amp;gt; (o_wb_ack)&amp;amp;&amp;amp;(o_wb_data == { 24&#39;h0, f_data[7:0] })
				&amp;amp;&amp;amp;(cfg_user_mode)&amp;amp;&amp;amp;(!o_wb_stall));

		// Then it needs to stay constant until another SPI
		// command
		assert property (@(posedge i_clk)
			disable iff (i_reset)
			($past(!o_spi_sck))&amp;amp;&amp;amp;(!o_spi_sck)&amp;amp;&amp;amp;(cfg_user_mode)
			|=&amp;gt; $stable(o_wb_data)&amp;amp;&amp;amp;(o_wb_data[31:8]==0));

	end endgenerate&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h2 id=&quot;how-to-test-it&quot;&gt;How to test it?&lt;/h2&gt;

&lt;p&gt;Now that we’ve built &lt;a href=&quot;https://github.com/ZipCPU/icozip/blob/master/rtl/icozip/spixpress.v&quot;&gt;our
controller&lt;/a&gt;,
how shall we test it to know that it works?&lt;/p&gt;

&lt;p&gt;Hopefully you’ve been around long enough to remember all of our work building
a &lt;a href=&quot;https://github.com/ZipCPU/dbgbus/tree/master/hexbus&quot;&gt;basic debugging bus&lt;/a&gt;,
following the &lt;a href=&quot;/blog/2017/05/22/a-vision-for-controlling-fpgas.html&quot;&gt;initial vision I presented for controlling FPGA
logic&lt;/a&gt;.
With just a little effort, we can connect a
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;Wishbone&lt;/a&gt;
&lt;a href=&quot;/blog/2017/07/08/getting-started-with-wbscope.html&quot;&gt;scope&lt;/a&gt;
and our
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/icozip/blob/master/rtl/icozip/spixpress.v&quot;&gt;controller&lt;/a&gt;
to this &lt;a href=&quot;/blog/2017/06/28/dbgbus-goal.html&quot;&gt;debugging bus&lt;/a&gt;,
and then see how our
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt; interacts
with the &lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 19. Digilent&#39;s Digital Discovery 2&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/digital-discovery-top-130.png&quot; alt=&quot;A Picture of Digilent&#39;s Digital Discovery 2 logic analyzer&quot; width=&quot;280&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;For &lt;a href=&quot;https://github.com/ZipCPU/icozip/blob/master/rtl/icozip/spixpress.v&quot;&gt;this particular core&lt;/a&gt;,
I didn’t start my debugging with the
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;Wishbone&lt;/a&gt;
&lt;a href=&quot;/blog/2017/07/08/getting-started-with-wbscope.html&quot;&gt;scope&lt;/a&gt;.
I started instead with a &lt;a href=&quot;https://store.digilentinc.com/digital-discovery-portable-logic-analyzer-and-digital-pattern-generator&quot;&gt;Digilent Digital
Discovery 2&lt;/a&gt;.
Why?  Two reasons: 1. I had it &lt;a href=&quot;/blog/2017/09/14/even-i-get-stuck.html&quot;&gt;available to
me&lt;/a&gt;
and on my desk, and 2. I was concerned about the timing of the clock pulses.
Sure enough, the 
&lt;a href=&quot;https://store.digilentinc.com/digital-discovery-portable-logic-analyzer-and-digital-pattern-generator&quot;&gt;DD&lt;/a&gt;
revealed that the
&lt;a href=&quot;http://www.latticesemi.com/Products/FPGAandCPLD/iCE40&quot;&gt;iCE40&lt;/a&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;SB_IO&lt;/code&gt; primitive in DDR mode delayed the &lt;code class=&quot;highlighter-rouge&quot;&gt;SCK&lt;/code&gt; by one clock more than I was
expecting.  (The code above has been fixed to accommodate this.)  This sent
me back through the entire design to do some massive updates:
all other signals needed to be delayed by one and the &lt;code class=&quot;highlighter-rouge&quot;&gt;o_spi_sck&lt;/code&gt; signal
needed to return to zero one cycle earlier.  Indeed, there were several head
scratching moments at this point in order to get the timing right.&lt;/p&gt;

&lt;p&gt;We’ve &lt;a href=&quot;/blog/2017/07/08/getting-started-with-wbscope.html&quot;&gt;discussed hooking
up&lt;/a&gt; the
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;Wishbone&lt;/a&gt;
&lt;a href=&quot;/blog/2017/07/08/getting-started-with-wbscope.html&quot;&gt;scope&lt;/a&gt;
to a design before.  I’ll just touch on a couple of pieces briefly here.
First, you need to decide which 32-bits you want to capture and select a
relevant trigger.  I personally like to place the trigger in the MSB of this
word–it makes it easier to switch to a &lt;a href=&quot;https://github.com/ZipCPU/wbscope/blob/master/rtl/wbscopc&quot;&gt;compressed wishbone
scope&lt;/a&gt; later if I
need to.   In my case, I ultimately chose the following wires to capture:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	assign	spixpress_debug = { (!o_spi_cs_n), wb_cyc,
				(wb_stb)&amp;amp;&amp;amp;(flash_sel),
				(wb_stb)&amp;amp;&amp;amp;(flash_cfg_sel), wb_we,
				flash_stall,flash_ack, wb_data[8:0],
				flash_data[8:0],
				3&#39;h0,
				o_spi_cs_n, o_spi_sck, o_spi_mosi, i_spi_miso };&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;That gives me access to all of the critical
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;Wishbone&lt;/a&gt;
wires, as well as the entire
&lt;a href=&quot;https://en.wikipedia.org/wiki/Serial_Peripheral_Interface&quot;&gt;SPI&lt;/a&gt;
interface.&lt;/p&gt;

&lt;p&gt;The majority of the connections required to connect this to the
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;Wishbone&lt;/a&gt;
bus were made by &lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt;–allowing
me to remove the
&lt;a href=&quot;/blog/2017/07/08/getting-started-with-wbscope.html&quot;&gt;scope&lt;/a&gt;
later if I so wish by just removing the &lt;a href=&quot;https://github.com/ZipCPU/icozip/blob/master/auto-data/spixscope.txt&quot;&gt;scope’s AutoFPGA configuration file’s
name&lt;/a&gt;
from the &lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt; command line.
Among other changes, this places the following additional code into the &lt;a href=&quot;https://github.com/ZipCPU/icozip/blob/master/rtl/icozip/main.v&quot;&gt;main
design file&lt;/a&gt; of
&lt;a href=&quot;https://github.com/ZipCPU/icozip&quot;&gt;this design&lt;/a&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	wbscope #(.LGMEM(7), .SYNCHRONOUS(1), .HOLDOFFBITS(8))
		spixscopei(i_clk, 1&#39;b1, (!o_spi_cs_n), spixpress_debug,
			i_clk, wb_cyc, (wb_stb)&amp;amp;&amp;amp;(spixscope_sel),
			wb_we, wb_addr[0], wb_data,
			spixscope_ack, spixscope_stall, spixscope_data,
			spixscope_int);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The &lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt; &lt;a href=&quot;https://github.com/ZipCPU/icozip/blob/master/auto-data/spixscope.txt&quot;&gt;configuration
file&lt;/a&gt;
also places a &lt;code class=&quot;highlighter-rouge&quot;&gt;#define&lt;/code&gt; into the
&lt;a href=&quot;https://github.com/ZipCPU/icozip/blob/master/sw/host/regdefs.h&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;regdefs.h&lt;/code&gt;&lt;/a&gt;
file, defining &lt;code class=&quot;highlighter-rouge&quot;&gt;R_SPIXSCOPE&lt;/code&gt; to have the address of the control
register for the
&lt;a href=&quot;/blog/2017/07/08/getting-started-with-wbscope.html&quot;&gt;scope&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;You can see the entire &lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/icozip/blob/master/auto-data/spixscope.txt&quot;&gt;configuration file&lt;/a&gt;
for this debugging scope
&lt;a href=&quot;https://github.com/ZipCPU/icozip/blob/master/auto-data/spixscope.txt&quot;&gt;here&lt;/a&gt;.
Adding this to the &lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt; command line
in the &lt;a href=&quot;https://github.com/ZipCPU/icozip/tree/master/rtl/auto-data&quot;&gt;auto-data&lt;/a&gt;/&lt;a href=&quot;https://github.com/ZipCPU/icozip/blob/master/rtl/auto-data/Makefile&quot;&gt;Makefile&lt;/a&gt;
will add this to the design, and removing it from the command line will remove
this component and &lt;a href=&quot;/zipcpu/2017/10/05/autofpga-intro.html&quot;&gt;all of its
dependencies&lt;/a&gt;
from the design as well.  There’s also a &lt;a href=&quot;https://github.com/ZipCPU/icozip/blob/master/sw/host/spixscope.cpp&quot;&gt;software
component&lt;/a&gt;
to this
&lt;a href=&quot;/blog/2017/07/08/getting-started-with-wbscope.html&quot;&gt;scope&lt;/a&gt;’s
setup as well, found in the &lt;a href=&quot;https://github.com/ZipCPU/icozip/tree/master/sw/host&quot;&gt;sw/host
directory&lt;/a&gt;
of &lt;a href=&quot;https://github.com/ZipCPU/icozip&quot;&gt;the project&lt;/a&gt;—but we’ve discussed &lt;a href=&quot;/blog/2017/07/08/getting-started-with-wbscope.html&quot;&gt;how
to build those
before&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&quot;test-one-using-wbregs-to-read-a-known-value-from-the-flash&quot;&gt;Test one: Using wbregs to read a known value from the flash&lt;/h3&gt;

&lt;p&gt;The next step, and really the first true test, is an important one when
designing for an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;:
you want to make certain you can read back a &lt;em&gt;known piece of data&lt;/em&gt; from the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;.  While
there may be other uses for the vendor identification protocol within the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt; specification, I find that
using it as a test read from the device is the most useful.  In particular, if
I read that ID from the &lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt;,
I can quickly determine if I managed to get the sequencing right between all of
the various signals.&lt;/p&gt;

&lt;p&gt;Looking over the &lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt;
&lt;a href=&quot;http://www.cypress.com/file/177961/download&quot;&gt;specfication&lt;/a&gt;,
you’ll see that sending a &lt;code class=&quot;highlighter-rouge&quot;&gt;0x9f&lt;/code&gt; to the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt;
chip will request this identification value.  Ever after until the chip select
is deactivated, the incoming data to the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt; is ignored, and the
outgoing data from the &lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt;
will be this known identification sequence–just as we showed in Fig. 14 above.&lt;/p&gt;

&lt;p&gt;Most of my designs contain a command-line driven
&lt;a href=&quot;https://en.wikipedia.org/wiki/PEEK_and_POKE&quot;&gt;peek and poke&lt;/a&gt;
capability &lt;a href=&quot;/blog/2017/06/16/dbg-bus-forest.html&quot;&gt;I call
&lt;code class=&quot;highlighter-rouge&quot;&gt;wbregs&lt;/code&gt;&lt;/a&gt;.
&lt;a href=&quot;https://github.com/ZipCPU/icozip/blob/master/sw/host/wbregs.cpp&quot;&gt;This command&lt;/a&gt;,
found in almost all of &lt;a href=&quot;/projects.html&quot;&gt;my system-level
projects&lt;/a&gt;, allows you to read or
write addresses within the device’s internal
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;Wishbone bus&lt;/a&gt;,
&lt;a href=&quot;/blog/2017/05/22/a-vision-for-controlling-fpgas.html&quot;&gt;just the same as though those commands were issued
internally&lt;/a&gt; from a source within the design.&lt;/p&gt;

&lt;p&gt;In &lt;a href=&quot;https://github.com/ZipCPU/icozip&quot;&gt;this project&lt;/a&gt;, which needs to support
software on both the &lt;a href=&quot;https://www.raspberrypi.org&quot;&gt;Raspberry
Pi&lt;/a&gt; and on whatever &lt;a href=&quot;/blog/2017/06/17/why-network-debugging.html&quot;&gt;host machine might connect
to it&lt;/a&gt;, the
project will build one of two versions of this
&lt;a href=&quot;https://github.com/ZipCPU/icozip/blob/master/sw/host/wbregs.cpp&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;wbregs&lt;/code&gt;&lt;/a&gt;
program.  The first is &lt;code class=&quot;highlighter-rouge&quot;&gt;arm-wbregs&lt;/code&gt; for running on the
&lt;a href=&quot;https://www.raspberrypi.org&quot;&gt;Pi&lt;/a&gt;, whereas the second is &lt;code class=&quot;highlighter-rouge&quot;&gt;pc-wbregs&lt;/code&gt; for
running on whatever other host platform might connect with the
&lt;a href=&quot;https://www.raspberrypi.org&quot;&gt;Pi&lt;/a&gt; over a &lt;a href=&quot;/blog/2017/06/17/why-network-debugging.html&quot;&gt;TCP/IP
connection&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Let’s run this &lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt; manufacture
identification test using &lt;code class=&quot;highlighter-rouge&quot;&gt;pc-wbregs&lt;/code&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;$ ./pc-wbregs flashcfg 0x0100
00200000 (FLASHCFG)-&amp;gt; 00000100
$ ./pc-wbregs flashcfg 0x09f
00200000 (FLASHCFG)-&amp;gt; 0000009f
$ ./pc-wbregs flashcfg 0x000 ; ./pc-wbregs flashcfg
00200000 (FLASHCFG)-&amp;gt; 00000000
00200000 (FLASHCFG) : [....] 00000001
$ ./pc-wbregs flashcfg 0x000 ; ./pc-wbregs flashcfg
00200000 (FLASHCFG)-&amp;gt; 00000000
00200000 (FLASHCFG) : [....] 00000020
$ ./pc-wbregs flashcfg 0x000 ; ./pc-wbregs flashcfg
00200000 (FLASHCFG)-&amp;gt; 00000000
00200000 (FLASHCFG) : [....] 00000018
$ ./pc-wbregs flashcfg 0x000 ; ./pc-wbregs flashcfg
00200000 (FLASHCFG)-&amp;gt; 00000000
00200000 (FLASHCFG) : [...M] 0000004d
$ ./pc-wbregs flashcfg 0x000 ; ./pc-wbregs flashcfg
00200000 (FLASHCFG)-&amp;gt; 00000000
00200000 (FLASHCFG) : [....] 00000001
$ ./pc-wbregs flashcfg 0x000 ; ./pc-wbregs flashcfg
00200000 (FLASHCFG)-&amp;gt; 00000000
00200000 (FLASHCFG) : [....] 00000080
$ ./pc-wbregs flashcfg 0x000 ; ./pc-wbregs flashcfg
00200000 (FLASHCFG)-&amp;gt; 00000000
00200000 (FLASHCFG) : [...1] 00000031
$ ./pc-wbregs flashcfg 0x000 ; ./pc-wbregs flashcfg
00200000 (FLASHCFG)-&amp;gt; 00000000
00200000 (FLASHCFG) : [...0] 00000030
$ ./pc-wbregs flashcfg 0x000 ; ./pc-wbregs flashcfg
00200000 (FLASHCFG)-&amp;gt; 00000000
00200000 (FLASHCFG) : [....] 00000083
$ ./pc-wbregs flashcfg 0x000 ; ./pc-wbregs flashcfg
00200000 (FLASHCFG)-&amp;gt; 00000000
00200000 (FLASHCFG) : [....] 000000ff&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;If you watched the lower octet of the results, you’ll see that we just
read the ID string: &lt;code class=&quot;highlighter-rouge&quot;&gt;01:20:18:4d:01:80:31:30:83&lt;/code&gt;.  While that works for
debugging by hand, it’s somewhat hard to read and we can do this better.  So
let’s tighten this up a bit, by switching our development to C++.&lt;/p&gt;

&lt;h3 id=&quot;test-two-accessing-the-flash-from-within-a-c-program&quot;&gt;Test two: Accessing the flash from within a C++ program&lt;/h3&gt;

&lt;p&gt;I thought it might be fun to show how easy this is to do via C++ when using
the &lt;a href=&quot;/blog/2017/05/22/a-vision-for-controlling-fpgas.html&quot;&gt;debugging bus concept&lt;/a&gt;.
When using the &lt;a href=&quot;/blog/2017/06/16/dbg-bus-forest.html&quot;&gt;debugging bus
interface&lt;/a&gt;,
all it takes is a call to the &lt;code class=&quot;highlighter-rouge&quot;&gt;m_fpga-&amp;gt;readio(addr);&lt;/code&gt; method to read from the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;, or
likewise a &lt;code class=&quot;highlighter-rouge&quot;&gt;m_fpga-&amp;gt;writeio(addr,value);&lt;/code&gt; call to write a value to the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;.  In our
case, we have a configuration register at address &lt;code class=&quot;highlighter-rouge&quot;&gt;R_FLASHCFG&lt;/code&gt; that we wish
to read from or write to, so an example of reading from this register would
look like,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;	&lt;span class=&quot;n&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m_fpga&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;readio&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;R_FLASHCFG&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Looking at the relevant portion of &lt;code class=&quot;highlighter-rouge&quot;&gt;flashid.cpp&lt;/code&gt;, it starts with clearing
the trigger for the
&lt;a href=&quot;/blog/2017/07/08/getting-started-with-wbscope.html&quot;&gt;scope&lt;/a&gt;
(if present).&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;cp&quot;&gt;#ifdef	R_SPIXSCOPE
&lt;/span&gt;	&lt;span class=&quot;c1&quot;&gt;// Start up the scope at the beginning, in case anything goes wrong
&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;m_fpga&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;writeio&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;R_SPIXSCOPE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;124&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;cp&quot;&gt;#endif&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This will cause the
&lt;a href=&quot;/blog/2017/07/08/getting-started-with-wbscope.html&quot;&gt;scope&lt;/a&gt;
to trigger on the lowering of the &lt;code class=&quot;highlighter-rouge&quot;&gt;CS_n&lt;/code&gt; line, and then to wait another
124 clocks before it &lt;a href=&quot;/blog/2017/06/08/simple-scope.html&quot;&gt;freezes its buffer and stops
collecting&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The next step is to issue the &lt;code class=&quot;highlighter-rouge&quot;&gt;READID&lt;/code&gt; command (&lt;code class=&quot;highlighter-rouge&quot;&gt;0x9f&lt;/code&gt;) to the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;	&lt;span class=&quot;n&quot;&gt;m_fpga&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;writeio&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;R_FLASHCFG&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x09f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This will send a &lt;code class=&quot;highlighter-rouge&quot;&gt;0x9f&lt;/code&gt; to the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt;, and leave the chip select
active–just the way we designed &lt;a href=&quot;https://github.com/ZipCPU/icozip/blob/master/rtl/icozip/spixpress.v&quot;&gt;this
core&lt;/a&gt; to
behave above.&lt;/p&gt;

&lt;p&gt;We can now read the actual identification bytes.  Even
though our goal is to &lt;em&gt;read&lt;/em&gt;, because of how we built the interface we’ll
need to write to the register first in order to clock the data out out of the
device.  The information we write isn’t relevant, so we can just
write a zero, and later read from the register.&lt;/p&gt;

&lt;p&gt;The following does exactly that, but with perhaps a little more flair.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;	&lt;span class=&quot;n&quot;&gt;m_fpga&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;writeio&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;R_FLASHCFG&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;ID:&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;12&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

		&lt;span class=&quot;c1&quot;&gt;// Read and print the last byte read
&lt;/span&gt;		&lt;span class=&quot;n&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m_fpga&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;readio&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;R_FLASHCFG&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;%c%02x&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;==&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;?&lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;&#39; &#39;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;&#39;:&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;mh&quot;&gt;0x0ff&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
		&lt;span class=&quot;c1&quot;&gt;// and clock in the next byte across the SPI interface
&lt;/span&gt;		&lt;span class=&quot;n&quot;&gt;m_fpga&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;writeio&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;R_FLASHCFG&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Finally, now that we are all done, we’ll want to return the &lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt; to its
default state, allowing regular reads to be made again.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;	&lt;span class=&quot;n&quot;&gt;m_fpga&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;writeio&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;R_FLASHCFG&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x100&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;What happens when we run this program?&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;./pc-flashid 
ID: 01:20:18:4d:01:80:31:30:83:ff:ff:ff&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This is essentially the same thing we did before with &lt;code class=&quot;highlighter-rouge&quot;&gt;pc-wbregs&lt;/code&gt;, only now
done from within C++.  That looks prettier now, doesn’t it?&lt;/p&gt;

&lt;p&gt;If you look this value up in the
&lt;a href=&quot;http://www.cypress.com/file/177961/download&quot;&gt;flash specification&lt;/a&gt;,
you can verify that these are indeed the right values we should expect.
Therefore, we’ve now finished test number two.&lt;/p&gt;

&lt;h3 id=&quot;test-three-copying-the-memory-out-of-the-flash&quot;&gt;Test three: Copying the memory out of the flash&lt;/h3&gt;

&lt;p&gt;For our next test, let’s try reading from the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;We could use &lt;code class=&quot;highlighter-rouge&quot;&gt;wbregs&lt;/code&gt; again to read a word from the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt;.  Here we read the
first word from the &lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;./pc-wbregs flash
01000000 &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;   FLASH&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; : &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;....] ff0000ff&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This looks like a synchronization word.  Indeed, it matches the first word
in our binary design file, suggesting this might also be the first word of the
binary that came shipped with our &lt;a href=&quot;http://www.icoboard.org&quot;&gt;ICO board&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;So … let’s read out the entire design!&lt;/p&gt;

&lt;p&gt;We’ll do that with a program I call
&lt;a href=&quot;https://github.com/ZipCPU/icozip/blob/master/sw/host/dumpflash.cpp&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;dumpflash&lt;/code&gt;&lt;/a&gt;.
It’s usually the first program I run on any board I purchase, so that I never
lose the original manufacture provided pre-loaded design image.  The relevant
line to read the entire &lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt;,
found within
&lt;a href=&quot;https://github.com/ZipCPU/icozip/blob/master/sw/host/dumpflash.cpp&quot;&gt;`dumpflash.cpp&lt;/a&gt;,
is simply&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;	&lt;span class=&quot;n&quot;&gt;m_fpga&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;readi&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;DUMPMEM&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;BUFLN&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;buf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;That’s it!  By the time that command returns, and it will take a while since
it’s reading the &lt;em&gt;ENTIRE&lt;/em&gt; &lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash
memory&lt;/a&gt;, the &lt;code class=&quot;highlighter-rouge&quot;&gt;DUMPMEM&lt;/code&gt; buffer
will contain all of the contents from the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Not all of these contents are relevant.&lt;/p&gt;

&lt;p&gt;When a &lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt; is erased, all of
the bits within it are set to ones.  Usually, upon delivery, this is how a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt;
comes from the manufacturer with one exception: the board manufacturer has
usually placed an initial load into the beginning of the &lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash
memory&lt;/a&gt;.  For this reason, we can
trim any all one’s words from the end of the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt; image.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;	&lt;span class=&quot;n&quot;&gt;sz&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;BUFLN&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sz&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;buf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sz&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0xffffffff&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;sz&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;sz&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Once done, we can write the &lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt; contents to an external file.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;	&lt;span class=&quot;n&quot;&gt;fp&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fopen&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fname&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;w&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fp&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;fprintf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;stderr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;ERR: Could not write %s&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fname&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;exit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;EXIT_FAILURE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;fwrite&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;buf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;buf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sz&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;fclose&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;That was easier than you might have expected, now, wasn’t it?  See how powerful
the &lt;a href=&quot;/blog/2017/06/16/dbg-bus-forest.html&quot;&gt;debugging bus
concept&lt;/a&gt; is?&lt;/p&gt;

&lt;p&gt;Just as a foot note, be aware that this data may be byte swapped at this
point.  The
&lt;a href=&quot;/blog/2017/06/16/dbg-bus-forest.html&quot;&gt;debugging bus&lt;/a&gt; 
&lt;a href=&quot;https://github.com/ZipCPU/dbgbus/tree/master/hexbus&quot;&gt;implementation I’ve
created&lt;/a&gt;
is &lt;a href=&quot;https://en.wikipedia.org/wiki/Endianness&quot;&gt;big endian&lt;/a&gt;,
even though most computers these days are &lt;a href=&quot;https://en.wikipedia.org/wiki/Endianness&quot;&gt;little
endian&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&quot;test-four-writing-to-the-flash&quot;&gt;Test four: Writing to the flash&lt;/h3&gt;

&lt;p&gt;Each of the projects I have containing a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash chip&lt;/a&gt; also contains a &lt;a href=&quot;https://github.com/ZipCPU/icozip/blob/master/sw/host/flashdrvr.cpp&quot;&gt;flash
driver&lt;/a&gt;
host software component.  This makes writing to the 
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt; fairly simple.&lt;/p&gt;

&lt;p&gt;The &lt;a href=&quot;https://github.com/ZipCPU/icozip/blob/master/sw/host/flashdrvr.h&quot;&gt;C++ interface&lt;/a&gt;
to this &lt;a href=&quot;https://github.com/ZipCPU/icozip/blob/master/sw/host/flashdrvr.cpp&quot;&gt;device driver&lt;/a&gt;
is primarily a simple &lt;code class=&quot;highlighter-rouge&quot;&gt;write&lt;/code&gt; function.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt;	&lt;span class=&quot;nc&quot;&gt;FLASHDRVR&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;// ...
&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;FLASHDRVR&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;DEVBUS&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fpga&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m_fpga&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fpga&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m_debug&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;// ...
&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;bool&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;write&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;addr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
			&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;verify&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;By calling this function with the address within the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt;
that you wish to write to, together with the length of the data and a pointer
to that same data, the &lt;a href=&quot;https://github.com/ZipCPU/icozip/blob/master/sw/host/flashdrvr.cpp&quot;&gt;device
driver&lt;/a&gt;
will first check what is currently written on the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt;,
erase if necessary, and then write the new values to the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;That function calls two other functions that need to work in order to be able
to program and reprogram the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt;.  The
first is the &lt;code class=&quot;highlighter-rouge&quot;&gt;erase_sector&lt;/code&gt; function, and the second the &lt;code class=&quot;highlighter-rouge&quot;&gt;page_program&lt;/code&gt;
function.  Sector in this context is 4kB
of &lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash memory&lt;/a&gt;,
aligned on a 4kB boundary.  A page is similar: it references
256 bytes of memory, aligned on a 256 byte boundary.&lt;/p&gt;

&lt;p&gt;Erasing a sector requires a couple steps.  First, a command needs to sent to the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt;
to enable write mode.  This is a simple &lt;code class=&quot;highlighter-rouge&quot;&gt;8&#39;h06&lt;/code&gt; command that needs to be sent
to the &lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt;.
It’s a straight forward use of the configuration port.  We’ll start by
clearing the configuration mode by writing &lt;code class=&quot;highlighter-rouge&quot;&gt;9&#39;100&lt;/code&gt; to the interface, just out
of an abundance of caution to make certain &lt;code class=&quot;highlighter-rouge&quot;&gt;o_spi_cs_n&lt;/code&gt; is high (inactive).
We’ll then write the &lt;code class=&quot;highlighter-rouge&quot;&gt;8&#39;h06&lt;/code&gt; write enable command, &lt;code class=&quot;highlighter-rouge&quot;&gt;F_WREN&lt;/code&gt;, and tell
the
&lt;a href=&quot;https://github.com/ZipCPU/icozip/blob/master/rtl/icozip/spixpress.v&quot;&gt;controller&lt;/a&gt;
to end the transaction by lowering &lt;code class=&quot;highlighter-rouge&quot;&gt;o_spi_cs_n&lt;/code&gt; again.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;	&lt;span class=&quot;c1&quot;&gt;// Write enable
&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;m_fpga&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;writeio&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;R_FLASHCFG&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;F_END&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;m_fpga&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;writeio&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;R_FLASHCFG&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;F_WREN&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;m_fpga&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;writeio&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;R_FLASHCFG&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;F_END&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;We can now issue the sector erase command, &lt;code class=&quot;highlighter-rouge&quot;&gt;F_SE&lt;/code&gt; or &lt;code class=&quot;highlighter-rouge&quot;&gt;0x0d8&lt;/code&gt;.  This command
is followed by a three byte argument containing the
address of the 4kB segment that we wish to erase.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;	&lt;span class=&quot;n&quot;&gt;m_fpga&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;writeio&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;R_FLASHCFG&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;F_SE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;m_fpga&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;writeio&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;R_FLASHCFG&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;flashaddr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;16&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;mh&quot;&gt;0x0ff&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;m_fpga&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;writeio&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;R_FLASHCFG&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;flashaddr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;8&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;mh&quot;&gt;0x0ff&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;m_fpga&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;writeio&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;R_FLASHCFG&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;flashaddr&lt;/span&gt;    &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;mh&quot;&gt;0x0ff&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;m_fpga&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;writeio&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;R_FLASHCFG&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;F_END&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;We’ll then wait for this operation to complete by calling &lt;code class=&quot;highlighter-rouge&quot;&gt;flwait()&lt;/code&gt;.
This function simply sends the “read-status register” command, &lt;code class=&quot;highlighter-rouge&quot;&gt;F_RDSR1=0x05&lt;/code&gt;,
to the flash.  Ever after, every time 8-clocks are sent to the flash an
updated status register will be returned.  Once the low order bit, &lt;code class=&quot;highlighter-rouge&quot;&gt;WIP=1&lt;/code&gt;,
is clear, the flash has finished erasing our sector.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;FLASHDRVR&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;flwait&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt;	&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;WIP&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;	&lt;span class=&quot;c1&quot;&gt;// Write in progress bit
&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;DEVBUS&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;BUSW&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;sr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

	&lt;span class=&quot;n&quot;&gt;m_fpga&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;writeio&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;R_FLASHCFG&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;F_END&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;m_fpga&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;writeio&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;R_FLASHCFG&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;F_RDSR1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;do&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;m_fpga&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;writeio&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;R_FLASHCFG&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;F_EMPTY&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;sr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m_fpga&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;readio&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;R_FLASHCFG&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;WIP&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;m_fpga&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;writeio&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;R_FLASHCFG&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;F_END&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Erasing a sector turns all the bits in that sector to &lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt;.  This really isn’t
what we want to do end the end.  We want our data written to the &lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt;,
regardless of whether it consists of &lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt;’s or &lt;code class=&quot;highlighter-rouge&quot;&gt;0&lt;/code&gt;’s, and we want the &lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt;’s
and &lt;code class=&quot;highlighter-rouge&quot;&gt;0&lt;/code&gt;’s put in the right place.  The difference is associated with how
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt; is built.  The only way to turn a bit from a &lt;code class=&quot;highlighter-rouge&quot;&gt;0&lt;/code&gt; to a &lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt; is to first erase a large block of &lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash
memory&lt;/a&gt;.  In this case, we erased
a 4kB sector.  Some
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt; chips allow erasing smaller
portions of memory called subsectors.&lt;/p&gt;

&lt;p&gt;One problem that results from erasing
4kB at a time in order to write to &lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash
memory&lt;/a&gt; is that of collateral
damage: it is possible that by erasing a sector, some other valuable
information in that sector will get erased.  This &lt;a href=&quot;https://github.com/ZipCPU/icozip/blob/master/sw/host/flashdrvr.cpp&quot;&gt;flash
driver&lt;/a&gt;
handles that problem by assuming that you will be smart enough
not to do that.  (You will, right?)  If you write to the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt;
using &lt;a href=&quot;https://github.com/ZipCPU/icozip/blob/master/sw/host/flashdrvr.cpp&quot;&gt;this
driver&lt;/a&gt;,
starting from a sector boundary and ending on a sector boundary then you will
have no problems.&lt;/p&gt;

&lt;p&gt;The second step of writing information to a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt; is to &lt;em&gt;program&lt;/em&gt; the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash memory&lt;/a&gt;.  Programming the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt; turns user specified bits
to &lt;code class=&quot;highlighter-rouge&quot;&gt;0&lt;/code&gt;.  It cannot return bits to &lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt;, it can only turn them from &lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt; to &lt;code class=&quot;highlighter-rouge&quot;&gt;0&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Programming the &lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt; is, in many ways, very similar to the erase cycle presented above.  It starts with sending a
write enable command to the &lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt;,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;		&lt;span class=&quot;c1&quot;&gt;// Write enable
&lt;/span&gt;		&lt;span class=&quot;n&quot;&gt;m_fpga&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;writeio&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;R_FLASHCFG&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;F_END&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;m_fpga&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;writeio&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;R_FLASHCFG&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;F_WREN&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;m_fpga&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;writeio&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;R_FLASHCFG&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;F_END&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;followed by a “page program” command, &lt;code class=&quot;highlighter-rouge&quot;&gt;F_PP = 0x02&lt;/code&gt; to actually write
the page of &lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash memory&lt;/a&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;		&lt;span class=&quot;c1&quot;&gt;// Issue the command
&lt;/span&gt;		&lt;span class=&quot;n&quot;&gt;m_fpga&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;writeio&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;R_FLASHCFG&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;F_PP&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Like the erase command, the page program command needs the address of where
to begin programming.  This is passed as a three byte argument following
the 8-bit command word.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;		&lt;span class=&quot;c1&quot;&gt;// The address
&lt;/span&gt;		&lt;span class=&quot;n&quot;&gt;m_fpga&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;writeio&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;R_FLASHCFG&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;flashaddr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;16&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;mh&quot;&gt;0x0ff&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;m_fpga&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;writeio&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;R_FLASHCFG&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;flashaddr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;8&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;mh&quot;&gt;0x0ff&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;m_fpga&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;writeio&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;R_FLASHCFG&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;flashaddr&lt;/span&gt;    &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;mh&quot;&gt;0x0ff&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The third step is to write the data, byte by byte, to the &lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt;
controller, and hence to the &lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt; chip.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;		&lt;span class=&quot;c1&quot;&gt;// Write the page data itself
&lt;/span&gt;		&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;m_fpga&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;writeio&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;R_FLASHCFG&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x0ff&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;m_fpga&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;writeio&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;R_FLASHCFG&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;F_END&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;o&quot;&gt;//&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Once this programming request closes, the &lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt;
will become busy again.  As with the erase, we’ll call the &lt;code class=&quot;highlighter-rouge&quot;&gt;flwait()&lt;/code&gt;
function to wait for the &lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt; to complete.&lt;/p&gt;

&lt;p&gt;Now, using the
&lt;a href=&quot;https://github.com/ZipCPU/icozip/blob/master/sw/host/zipload.cpp&quot;&gt;zipload&lt;/a&gt;
program, we can load a &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; executable program onto the 
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt;, to see if it runs.&lt;/p&gt;

&lt;p&gt;I’ll skip to the end at this point and just say that the interface works.
You can now run the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/icozip/blob/master/sw/board/cputest.c&quot;&gt;CPUTEST&lt;/a&gt; on the
&lt;a href=&quot;http://www.icoboard.org&quot;&gt;ICO board&lt;/a&gt;.  &lt;a href=&quot;https://github.com/ZipCPU/icozip/blob/master/sw/board/hello.c&quot;&gt;Hello
World&lt;/a&gt; 
works too!&lt;/p&gt;

&lt;p&gt;If you’d like more instructions, feel free to check out the
&lt;a href=&quot;https://github.com/ZipCPU/icozip&quot;&gt;README&lt;/a&gt;
to the &lt;a href=&quot;https://github.com/ZipCPU/icozip&quot;&gt;icozip project&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;Okay, so what have we done here?&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;We learned about basic
  &lt;a href=&quot;https://en.wikipedia.org/wiki/Serial_Peripheral_Interface&quot;&gt;SPI&lt;/a&gt;
  interactions.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;We’ve built a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/icozip/blob/master/rtl/icozip/spixpress.v&quot;&gt;controller&lt;/a&gt;
to get fast access to reading from the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt;,
quick access to continued readings, and we even created a configuration port
for issuing arbitrary commands to the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;We demonstrated how a &lt;code class=&quot;highlighter-rouge&quot;&gt;cover()&lt;/code&gt; statement can make building a new core
easier.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;We learned about System Verilog
&lt;a href=&quot;http://www.asic-world.com/systemverilog/assertions4.html#Sequences&quot;&gt;sequences&lt;/a&gt;,
and saw how they could simplify properties describing interactions that take
place over several clock cycles.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;We looked at how the
&lt;a href=&quot;/zipcpu/2018/07/13/memories.html&quot;&gt;memory properties&lt;/a&gt;
for reading the &lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt;
could be written with just a single assertion.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;We then saw how powerful the
&lt;a href=&quot;/blog/2017/06/16/dbg-bus-forest.html&quot;&gt;debugging bus&lt;/a&gt;
was in order to know if this device driver worked or not.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Finally, I pointed you to instructions for running one of two demonstration
programs on the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; on the
&lt;a href=&quot;http://www.icoboard.org&quot;&gt;ICO board&lt;/a&gt;.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;That’s a lot of ground in one post!  However, notice how it was necessary to
make it from design to demonstration to know that the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/icozip/blob/master/rtl/icozip/spixpress.v&quot;&gt;controller&lt;/a&gt;
fully worked.&lt;/p&gt;

&lt;p&gt;While this may be a first &lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/icozip/blob/master/rtl/icozip/spixpress.v&quot;&gt;controller&lt;/a&gt;,
I wouldn’t recommend stopping here.  Most &lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash
chips&lt;/a&gt; offer DSPI or QSPI support,
and even then there’s an &lt;a href=&quot;https://en.wikipedia.org/wiki/Execute_in_place&quot;&gt;eXecute In Place
(XIP)&lt;/a&gt; option on top of that.
Usually, for a &lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt; controller,
&lt;a href=&quot;https://en.wikipedia.org/wiki/Execute_in_place&quot;&gt;XIP&lt;/a&gt; means that you don’t
need to re-issue the command–you can just issue the address and start reading.
However, these are topics we may return to on another day, but until then I
would encourage you to look into on your own should you be so interested.&lt;/p&gt;
&lt;hr /&gt;&lt;p&gt;&lt;em&gt;For I am  the LORD, I change not; therefore ye sons of Jacob are not consumed. (Malachi 3:6)&lt;/em&gt;</description>
        <pubDate>Thu, 16 Aug 2018 00:00:00 -0400</pubDate>
        <link>https://zipcpu.com/blog/2018/08/16/spiflash.html</link>
        <guid isPermaLink="true">https://zipcpu.com/blog/2018/08/16/spiflash.html</guid>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>Reasons why Synthesis might not match Simulation</title>
        <description>&lt;p&gt;When I first learned digital design, I never simulated any of my designs:
I just placed them directly onto the hardware and debugged them there.&lt;/p&gt;

&lt;p&gt;I’ve since become convinced in using simulation for several reasons: simulation
can be faster than synthesizing a design.  Indeed, any time I run
&lt;a href=&quot;https://www.veripool.org/wiki/verilator&quot;&gt;Verilator&lt;/a&gt;
I can find many syntax errors in my design before Vivado fully starts up and
shows me one bug.  But that’s just synthesis.  For small designs, simulation
is still faster.  Of course, ultimately, the hardware is always faster–but 
in the time it takes to get there, you might manage to get an answer via
simulation.&lt;/p&gt;

&lt;p&gt;The second reason why I like simulation is that a simulation generated trace
will contain &lt;em&gt;every wire&lt;/em&gt; within the design.  For this reason, when something
doesn’t work in hardware, I’ll almost always return to simulation and try to do
the same thing in simulation to see if I can come across the same bug.  That
allows me to be able to turn around quickly and find the bug.&lt;/p&gt;

&lt;p&gt;Or … not so quickly.  On one recent design, I read the entire 16MB from a
SPI flash memory, only to have the design fail when reading the last word
from the flash.  Not knowing where to start, I started with simulation–but
then had to trim down the trace before filling up every bit in my computers
disk drive.&lt;/p&gt;

&lt;p&gt;But what happens when you cannot simulate the problem?  When your design
works perfectly in simulation, but fails on the hardware?&lt;/p&gt;

&lt;p&gt;I’ll admit this happened to me recently as well.  I think it happens to
everyone at some point.&lt;/p&gt;

&lt;p&gt;Therefore, to help keep you from
&lt;a href=&quot;/blog/2017/05/19/fpga-hell.html&quot;&gt;FPGA Hell&lt;/a&gt;, I &lt;a href=&quot;https://www.reddit.com/r/FPGA/comments/8g26i1/reasons_why_simulation_doesnt_match_synthesis/&quot;&gt;asked on
Reddit&lt;/a&gt;
for a list of things that might cause your simulation not to match reality.
When I asked, I thought I knew most of the reasons.  To my surprise, the kind
&lt;a href=&quot;https://www.reddit.com/r/FPGA&quot;&gt;Reddit readers&lt;/a&gt; were glad to share with me
many more reasons why simulation might not match actual hardware performance.&lt;/p&gt;

&lt;p&gt;Let me try to list and explain the reasons I’ve found here, and see if I managed
to (finally) get all of the reasons given to me on
&lt;a href=&quot;https://www.reddit.com/r/FPGA/comments/8g26i1/reasons_why_simulation_doesnt_match_synthesis/&quot;&gt;Reddit&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;timing&quot;&gt;Timing&lt;/h2&gt;

&lt;p&gt;Digital designs don’t work if the time between clock pulses isn’t sufficient
for all of the logic to take place between when one
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flip-flop_(electronics)&quot;&gt;flip flop&lt;/a&gt; 
sets its value and the next one needs the value to be held constant.  This
is often the meaning of the word
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flip-flop_(electronics)#Timing_considerations&quot;&gt;“timing”&lt;/a&gt; 
in this context.  Here are some reasons why
a design might fail associated with this design problem.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Design failed to pass timing, yet was used anyway&lt;/p&gt;

    &lt;p&gt;Following place and route, you need to check whether the resulting design
ensured that all the setup and hold requirements for all of the &lt;a href=&quot;https://en.wikipedia.org/wiki/Flip-flop_(electronics)&quot;&gt;flip
flops&lt;/a&gt; 
within (or external to) your design were met.  Usually the tools will do this
for you automatically.  However, if you fail to check this
result and use the design anyway … then it is likely to have some problems.
Worse, the behavior you see might masquerade as a completely different
problem.&lt;/p&gt;

    &lt;p&gt;For this reason, whenever I have a design that doesn’t work, I first
double check the timing report.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The timing checker wasn’t given the right clock rate&lt;/p&gt;

    &lt;p&gt;If you tell the timing checker you either have no clock in your design
(yes, I did this once), or if you give it the wrong frequency, your
design may appear to pass the timing check–even though the check
 is invalid.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Using delays in test bench design&lt;/p&gt;

    &lt;p&gt;This is one reason why I avoid the “#” syntax in Verilog, such as
&lt;code class=&quot;highlighter-rouge&quot;&gt;a &amp;lt;= #2 b;&lt;/code&gt;.  Just because you
tell the Verilog simulator that something will happen “2.5ns” later,
doesn’t mean it will achieve that “2.5ns” result in hardware.  Worse,
these statements are often ignored by the synthesizer. Hence, if you use
them, don’t use them on code you intend to place on actual hardware.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Just being wrong about the clock frequency on the board&lt;/p&gt;

    &lt;p&gt;This is subtly different from giving the timing analyzer the wrong rate.
For example, if you think your clock rate is 100MHz, and get your design
to pass the timing check for 100Mhz, even though the clock rate is really
50MHz, any logic that depends upon this number is not likely to work.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;metastabilityhttpsenwikipediaorgwikimetastabilityinelectronics&quot;&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Metastability_in_electronics&quot;&gt;Metastability&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;We’ve discussed &lt;a href=&quot;https://en.wikipedia.org/wiki/Metastability_in_electronics&quot;&gt;metastability&lt;/a&gt; a couple of times on this blog–mostly associated
with &lt;a href=&quot;/blog/2017/10/20/cdc.html&quot;&gt;crossing clock domains&lt;/a&gt;.
&lt;a href=&quot;https://en.wikipedia.org/wiki/Metastability_in_electronics&quot;&gt;Metastability&lt;/a&gt; is caused when a signal input to
a &lt;a href=&quot;https://en.wikipedia.org/wiki/Flip-flop_(electronics)&quot;&gt;flip flop&lt;/a&gt; 
is changing right as the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flip-flop_(electronics)&quot;&gt;flip flop&lt;/a&gt;s
clock arrives.  In that case, the design might have a value that is
neither “1” nor “0”, causing unpredictable results in subsequent logic.
Because &lt;a href=&quot;https://en.wikipedia.org/wiki/Metastability_in_electronics&quot;&gt;metastability&lt;/a&gt; is only caused if the signal changes right at the
clock edge, it is a rare event–but often not rare enough.  Either way,
the simulator will rarely if ever notice it.&lt;/p&gt;

&lt;p&gt;Here are some examples of things that might cause &lt;a href=&quot;https://en.wikipedia.org/wiki/Metastability_in_electronics&quot;&gt;metastability&lt;/a&gt;.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;No synchronization of async signal&lt;/p&gt;

    &lt;p&gt;Inputs to a design may be asynchronous.  A good example is a button press,
or a serial port input.  Such inputs need to be
&lt;a href=&quot;/blog/2017/10/20/cdc.html&quot;&gt;synchronized&lt;/a&gt; before
use!  This is actually a common problem among beginners–they’ll use a value
without
&lt;a href=&quot;/blog/2017/10/20/cdc.html&quot;&gt;synchronizing&lt;/a&gt;
it, ignorant that this might cause problems.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Improperly managed &lt;a href=&quot;/blog/2017/10/20/cdc.html&quot;&gt;clock domain crossing&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;This is another classic problem.  When you cross from one &lt;a href=&quot;/blog/2017/10/20/cdc.html&quot;&gt;clock
domain&lt;/a&gt;
to another, you need to manage the clock crossing with either a
&lt;a href=&quot;/blog/2017/10/20/cdc.html&quot;&gt;synchronizer&lt;/a&gt;
or an &lt;a href=&quot;/blog/2018/07/06/afifo.html&quot;&gt;asynchronous
FIFO&lt;/a&gt;–which will use
&lt;a href=&quot;/blog/2017/10/20/cdc.html&quot;&gt;synchronizers&lt;/a&gt;
internally.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Any time a register is clocked by two different clocks in the same process&lt;/p&gt;

    &lt;p&gt;I haven’t personally come across this one, but imagine a process that is
sensitive to &lt;code class=&quot;highlighter-rouge&quot;&gt;@(posedge i_clk, negedge i_reset, posedge something_else)&lt;/code&gt;.
This can be a recipe for a &lt;a href=&quot;https://en.wikipedia.org/wiki/Metastability_in_electronics&quot;&gt;metastability&lt;/a&gt; disaster.&lt;/p&gt;

    &lt;p&gt;You can read how we handled this with the &lt;a href=&quot;/formal/2018/04/12/areset.html&quot;&gt;asynchronous reset&lt;/a&gt; here.
However, I tend to try to avoid this situation by just not writing code
of this type.  This was one of those reasons why I &lt;a href=&quot;/blog/2017/08/21/rules-for-newbies.html&quot;&gt;recommended to
beginners&lt;/a&gt;
that only &lt;em&gt;clock&lt;/em&gt; edges should ever be in the sensitivity list.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Timing errors due to incorrect multipath constraints that are not checked
in simulation&lt;/p&gt;

    &lt;p&gt;When &lt;a href=&quot;/blog/2017/10/20/cdc.html&quot;&gt;crossing clock domains&lt;/a&gt;,
it’s not exactly clear upon which edge of the
next clock a particular signal will arrive.  Hence, if you have a
signal defined in one
&lt;a href=&quot;/blog/2017/10/20/cdc.html&quot;&gt;clock domain&lt;/a&gt;,
yet crossing into another in order to
be the input of two separate pieces of logic, you’ll be surprised that
in the real hardware, the two pieces of logic might not do the same
thing.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Let’s illustrate this last problem with an example.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;module test(i_clk_a, i_clk_b, i_ina, o_outb);
	input	wire	i_clk_a, i_clk_b;
	input	wire	i_ina;
	output	wire	o_outb;

	// Here&#39;s our first synchronizer
	reg	threesync, threein;
	initial	threein = 0;
	initial	threesync = 0;
	always @(posedge i_clk_b)
		{ threein, threesync } &amp;lt;= { threesync, i_ina };

	// Here&#39;s some logic dependent upon its result
	reg	[15:0]	bythrees;
	initial	bythrees = 0;
	always @(posedge i_clk_b)
	if (threein)
		bythrees &amp;lt;= bythrees + 3;

	// That&#39;s the first path, now let&#39;s look at the second path
	// It starts with a separate synchronizer
	reg	fivesync, fivein;
	initial	fivein = 0;
	initial	fivesync = 0;
	always @(posedge i_clk_b)
		{ fivein, fivesync } &amp;lt;= { fivesync, i_ina };

	
	reg	[15:0]	byfives;
	initial	byfives = 0;
	always @(posedge i_clk_b)
	if (fivein)
		byfives &amp;lt;= byfives + 5;

	assign	o_outb = byfives[0] ^ bythrees[0];&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Now, let’s assume that &lt;code class=&quot;highlighter-rouge&quot;&gt;i_ina&lt;/code&gt; is some logic that is set on &lt;code class=&quot;highlighter-rouge&quot;&gt;i_clk_a&lt;/code&gt;’s
positive edge.  You’d expect &lt;code class=&quot;highlighter-rouge&quot;&gt;o_outb&lt;/code&gt; to be zero at all times, right?  (Both
registers will toggle the lowest bit on any &lt;code class=&quot;highlighter-rouge&quot;&gt;i_ina&lt;/code&gt; input.  You
might be surprised by the hardware when it isn’t.&lt;/p&gt;

&lt;h2 id=&quot;blocking-vs-non-blocking-assignments&quot;&gt;Blocking vs Non-blocking assignments&lt;/h2&gt;

&lt;p&gt;Every now and again I need to remind myself why blocking assignments are so bad.
A blocking assignment sets the value of a register immediately, whereas a
non-blocking assignment waits until the clock tick to set the value with it’s
new result.&lt;/p&gt;

&lt;p&gt;So, tell me, what would happen in the following code,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;initial	a = 0;
always @(posedge i_clk)
	a = a + 5;

initial	b = 0;
always @(posedge i_clk)
	b &amp;lt;= a + 5;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;After the first clock tick, what will the value of &lt;code class=&quot;highlighter-rouge&quot;&gt;b&lt;/code&gt; be?  Will it be five,
or will it be ten?&lt;/p&gt;

&lt;p&gt;In hardware the result will always be five.  In simulation, the answer is … it
depends.  Specifically, it depends upon which of the two always blocks the
simulator decides to evaluate first.&lt;/p&gt;

&lt;h2 id=&quot;poor-simulation-model&quot;&gt;Poor simulation model&lt;/h2&gt;

&lt;p&gt;This one seems to hit the beginner the first time he uses simulation, when the
inputs to his simulation don’t quite match how the real hardware acts.
You can read &lt;a href=&quot;/blog/2017/06/10/lost-college-student.html&quot;&gt;one students
account&lt;/a&gt;
of how this problem bit him here on this site.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Buttons may be the most classic example&lt;/p&gt;

    &lt;p&gt;Buttons tend to be the first thing a beginner works with.  They are easy and
simple to work with, and seem to impact your design in a very reliable way.&lt;/p&gt;

    &lt;p&gt;The beginner quickly learns about buttons, and the next step is a counter.
He wants to know if his counter is working, so he creates an example piece
of code much like the following.  (We’ll assume he gets the synchronizer
right, although this does tend to be rare.)&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;module btnled(input i_clk, i_btn, o_led);
	input	wire	i_clk, i_btn;
	output	reg	o_led;

	// Let&#39;s synchronize the button, to avoid two issues
	reg	syncd, last, value;
	initial	syncd = 0;
	initial	value = 0;
	initial	last  = 0;
	always @(posedge i_clk)
		{ last, value, syncd} &amp;lt;= { value, syncd, i_btn };

	always @(posedge i_clk)
	if ((value)&amp;amp;&amp;amp;(!last)) // i.e. the button was just pressed
		o_led &amp;lt;= !o_led;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This beginner will be surprised when his LED doesn’t necessarily toggle on every
button press.  The problem?  Buttons bounce!  Feel free to take a look at &lt;a href=&quot;/blog/2017/08/02/debounce-teaser.html&quot;&gt;this
article&lt;/a&gt; for an
illustration of the problem.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;I’ve also personally struggled with Xilinx’s ICAPE2 interface&lt;/p&gt;

    &lt;p&gt;Yes, I know Xilinx described the interface in their &lt;a href=&quot;https://www.xilinx.com/support/documentation/user_guides/ug470_7Series_Config.pdf&quot;&gt;Configuration
user’s guide&lt;/a&gt;.
But how often have you misunderstood the specification and built your
simulation component to simulate the wrong interface?&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;My own I2C story&lt;/p&gt;

    &lt;p&gt;Buried within the repository for my &lt;a href=&quot;https://github.com/ZipCPU/wbscope&quot;&gt;wishbone
scope&lt;/a&gt;, is an
&lt;a href=&quot;https://github.com/ZipCPU/wbscope/tree/master/doc/examples/hdmi-eddc&quot;&gt;article&lt;/a&gt;
about how I once seriously misunderstood the &lt;a href=&quot;https://www.i2c-bus.org/specification&quot;&gt;I2C
specification&lt;/a&gt;.  I built a simulation
model for the wrong specification, and managed to get my design to work with
it.  When I moved to hardware, … it didn’t match like I thought it should.&lt;/p&gt;

    &lt;p&gt;That’s all fixed now, though.  You should find
&lt;a href=&quot;https://github.com/ZipCPU/wbi2c&quot;&gt;my simulation model&lt;/a&gt; for
&lt;a href=&quot;https://www.i2c-bus.org/specification&quot;&gt;I2C&lt;/a&gt; fully working … now.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Example: a vendor model for an SDRAM didn’t perform under burst access
like the hardware did&lt;/p&gt;

    &lt;p&gt;This one hasn’t happened to me yet.  Yet.  However, it follows the same
basic idea.  You have a design that matches a simulation specification,
but that simulation was only partially accurate.  Perhaps it didn’t implement
every mode of the device.&lt;/p&gt;

    &lt;p&gt;Either way, you’ll be surprised when your design doesn’t work, and then stuck
debugging your design in hardware–assuming you didn’t immediately get stuck
in &lt;a href=&quot;/blog/2017/05/19/fpga-hell.html&quot;&gt;FPGA Hell&lt;/a&gt;.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;asynchronous-reset-triggered-by-spurious-rf&quot;&gt;Asynchronous Reset triggered by spurious RF&lt;/h2&gt;

&lt;p&gt;I wouldn’t have believed this one myself if I hadn’t come across it while
browsing Xilinx’s forums.  You can read &lt;a href=&quot;https://forums.xilinx.com/t5/PLD-Blog-Archived/That-Dangerous-Asynchronous-Reset/ba-p/12856&quot;&gt;the article I found
here&lt;/a&gt;.
The basic sum of it is that the reset wire can act as a high frequency antenna,
and so send spurious reset signals through your design.  Ouch.&lt;/p&gt;

&lt;p&gt;This just happens to be one more reason to use a synchronous reset within
an &lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt; design.&lt;/p&gt;

&lt;h2 id=&quot;failure-to-start-the-design-in-a-known-configuration&quot;&gt;Failure to start the design in a known configuration&lt;/h2&gt;

&lt;p&gt;Over the years I’ve discovered that values not initialized on a Xilinx device
default to all ones.  They may start out as something different in simulation.
For example, I had one simulation environment that would initialize all values
to zero.  Indeed, the formal tools based upon
&lt;a href=&quot;https://www.clifford.at/yosys&quot;&gt;Yosys&lt;/a&gt;
assume all unspecified memory has an initial value of zero.&lt;/p&gt;

&lt;p&gt;This problem also highlights one of the &lt;a href=&quot;/blog/2017/10/13/fpga-v-asic.html&quot;&gt;differences between FPGA development
and ASIC development&lt;/a&gt;:
ASIC designs need that initial reset to set their values.  They have no
problems setting all RAM values to zero or one.  &lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;’s on the other hand
truly honor the &lt;code class=&quot;highlighter-rouge&quot;&gt;initial&lt;/code&gt; conditions given in the design.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Failure to set initial values for registered outputs&lt;/p&gt;

    &lt;p&gt;This is pretty much what I just described: when you don’t give your design
an initial value, it will still start with an initial value–it just might
not be the one you are intending.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Failure to match reset values to initial values&lt;/p&gt;

    &lt;p&gt;Would it surprise you if I told you this was one of the most common, and
yet simple, bugs I find with formal tools?  It’s so common that I’ve gotten
into a rut testing for it.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	reg	f_past_valid;
	initial	f_past_valid = 1&#39;b0;
	always @(posedge i_clk)
		f_past_valid &amp;lt;= 1&#39;b1;

	always @(posedge i_clk)
	if ((!f_past_valid)||($past(i_reset)))
	begin
		// For each input constrained by an initial or a reset
		assume(some_input == its_initial_value);
		// .. Repeat as necessary

		// Likewise for each local register or output
		assert(some_register == its_initial_value);
	end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Perhaps you’ll find this pattern useful in your own designs as well–it helps
to guarantee that both the reset and the initial value do the same thing.&lt;/p&gt;

&lt;p&gt;As another example, on some designs I’ll assume it starts with a reset.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	initial	assume(i_reset);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h2 id=&quot;insufficient-test-bench-cases&quot;&gt;Insufficient test bench cases&lt;/h2&gt;

&lt;p&gt;Sadly, this one was common for me–especially before I started using formal
verification.  Perhaps you may remember the &lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;problem I had with the test bench
for my initial FIFO
implementation&lt;/a&gt;? 
Sure, I had built a test bench for my &lt;a href=&quot;/blog/2017/07/29/fifo.html&quot;&gt;FIFO&lt;/a&gt;, it just didn’t quite test all of
the possible paths through my &lt;a href=&quot;/blog/2017/07/29/fifo.html&quot;&gt;FIFO&lt;/a&gt;’s logic.&lt;/p&gt;

&lt;p&gt;This hit me hard with my &lt;a href=&quot;/zipcpu/2017/12/28/ugliest-bug.html&quot;&gt;first I-cache
design&lt;/a&gt; as well.
Sure, the design worked in my simulation test bench. It just didn’t when
one day when I placed it onto the hardware.  It wasn’t the first day I had
placed the cache into hardware either–it had worked before.  What was the
problem?  That is &lt;a href=&quot;/zipcpu/2017/12/28/ugliest-bug.html&quot;&gt;a
story&lt;/a&gt;
in itself.&lt;/p&gt;

&lt;p&gt;Perhaps I just don’t have the imagination to think of every way a design
component might be accessed–correctly or incorrectly in order to truly test
every path through a design.&lt;/p&gt;

&lt;p&gt;In many ways this isn’t really a failure of simulation to match the
synthesized design in hardware, rather it’s a failure to completely test the
design in simulation.  As a result, the solution is to go back and to
simulate the design in the same way it just failed on the hardware (assuming
you can), and to see if you can try to find the bug.&lt;/p&gt;

&lt;p&gt;An even better solution is to turn to formal methods …&lt;/p&gt;

&lt;p&gt;I found myself in just this situation this last week: after reading 128MB
less the last four bytes from a flash device, the reader received a bus
timeout error on the very last word.  No, I hadn’t simulated that test
case because … well, who wants to &lt;em&gt;simulate&lt;/em&gt; reading 128MB from
a flash device over a slow debugging bus?  That said, it was the only way
I found the problem.  (The bug was mis-configured bus arbiter.  Yes, the
arbiter itself had been formally verified.  It wasn’t the arbiter’s fault, 
from that perspective, I had just hooked it up wrong and never verified the
parent module.)&lt;/p&gt;

&lt;h2 id=&quot;symbols-left-out-of-the-sensitivity-list&quot;&gt;Symbols left out of the sensitivity list&lt;/h2&gt;

&lt;p&gt;I don’t normally use sensitivity lists, but let’s see if we can build an
example of this problem.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(a)
if (a)
	b = c;
else
	b = !c;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;See the problem?  If &lt;code class=&quot;highlighter-rouge&quot;&gt;a&lt;/code&gt; changes, &lt;code class=&quot;highlighter-rouge&quot;&gt;b&lt;/code&gt; will also change.  However, the simulator
won’t adjust the value of &lt;code class=&quot;highlighter-rouge&quot;&gt;b&lt;/code&gt; if &lt;code class=&quot;highlighter-rouge&quot;&gt;c&lt;/code&gt; changes–even though the value of &lt;code class=&quot;highlighter-rouge&quot;&gt;b&lt;/code&gt; will
change in hardware upon any change of &lt;code class=&quot;highlighter-rouge&quot;&gt;c&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&quot;latches&quot;&gt;Latches&lt;/h2&gt;

&lt;p&gt;Remember the latch we placed into our &lt;a href=&quot;/formal/2018/05/31/clkswitch.html&quot;&gt;clock
switch&lt;/a&gt; design?  Here’s
what one &lt;a href=&quot;https://www.reddit.com/r/FPGA&quot;&gt;Reddit&lt;/a&gt; user wrote about latches:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Latches.  Definitely more of a problem only beginners will run into but
still good to be aware of.  Depending on synthesis settings it may fail
or it may just produce warnings but this was the most common problem I
helped students with when I was a TA for our intro to digital logic class.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Not familiar with a latch?  Here’s an example:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(*)
if (A)
	B = C;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Notice how &lt;code class=&quot;highlighter-rouge&quot;&gt;B&lt;/code&gt; isn’t being set on a clock, yet it’s required to hold its
value if &lt;code class=&quot;highlighter-rouge&quot;&gt;!A&lt;/code&gt; is true.  This is a latch.&lt;/p&gt;

&lt;p&gt;A latch is what the synthesis tools will infer anytime you don’t set the
value of a combinational result for all combinations.  The rule of thumb I’ve
been taught to make sure you avoid this is to always set the value at the
beginning of the block–then the value is set no matter how ugly the following
logic gets.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(*)
begin
	B = 0;
	if (A)
		B = C;
end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Another user recommended I beware of the &lt;code class=&quot;highlighter-rouge&quot;&gt;full_case&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;parallel_case&lt;/code&gt;
directives.  I’d never heard of these before!  However, you can read more
about misusing these directives &lt;a href=&quot;http://www.sunburst-design.com/papers/CummingsSNUG1999Boston_FullParallelCase.pdf&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;forgetting-to-assign-pin-locations&quot;&gt;Forgetting to assign pin locations&lt;/h2&gt;

&lt;p&gt;What happens if you don’t assign an output pin to a physical location?  Some
tools will pick a location for you.  How much do you want to bet that they
don’t pick the right location?&lt;/p&gt;

&lt;p&gt;A related bug is not forgetting the pin assignment, but rather assigning
the wrong pin to your logic.&lt;/p&gt;

&lt;p&gt;The solution?  Always double and triple check your pin assignments.  The master
&lt;code class=&quot;highlighter-rouge&quot;&gt;xdc&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;ucf&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;pcf&lt;/code&gt; or whatever file is very likely going to need to be changed
for your design from the one given you by the manufacturer of the board.&lt;/p&gt;

&lt;h2 id=&quot;comparing-with-x-values&quot;&gt;Comparing with ‘X’ values&lt;/h2&gt;

&lt;p&gt;(False in simulation, might be true in H/W)&lt;/p&gt;

&lt;p&gt;I’m told that the ARM development team once got themselves caught in an ugly
way with this bug.  According to the story, that happened some time ago, but
since then the story has become ingrained into their culture: don’t use
&lt;code class=&quot;highlighter-rouge&quot;&gt;x&lt;/code&gt; assignments!&lt;/p&gt;

&lt;p&gt;Why not?  Well, a &lt;code class=&quot;highlighter-rouge&quot;&gt;1&#39;bx&lt;/code&gt; value has a different meaning between synthesis and
simulation.  In synthesis, &lt;code class=&quot;highlighter-rouge&quot;&gt;1&#39;bx&lt;/code&gt; is a don’t care–the synthesis tool is allowed
to set the value to whatever it would wish.  In simulation, &lt;code class=&quot;highlighter-rouge&quot;&gt;1&#39;bx&lt;/code&gt; is a
specific value that a register might contain.
(&lt;a href=&quot;https://www.veripool.org/wiki/verilator&quot;&gt;Verilator&lt;/a&gt; doesn’t support &lt;code class=&quot;highlighter-rouge&quot;&gt;1&#39;bx&lt;/code&gt;,
so I don’t use them often.)&lt;/p&gt;

&lt;p&gt;What happens when &lt;code class=&quot;highlighter-rouge&quot;&gt;a=1&#39;bx&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;b=1&#39;b0&lt;/code&gt;?  &lt;code class=&quot;highlighter-rouge&quot;&gt;a==b&lt;/code&gt; will be false in simulation.
Worse, &lt;code class=&quot;highlighter-rouge&quot;&gt;a != b&lt;/code&gt; will also be false in simulation.  However,
in hardware the result will be tested based upon the actual achieved
voltage value, whether it be a &lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt; or a &lt;code class=&quot;highlighter-rouge&quot;&gt;0&lt;/code&gt;.
See the different result?  Avoid setting any values to &lt;code class=&quot;highlighter-rouge&quot;&gt;1&#39;bx&lt;/code&gt; to keep yourself
from this bug.&lt;/p&gt;

&lt;p&gt;You can read more about the problems with &lt;code class=&quot;highlighter-rouge&quot;&gt;x&lt;/code&gt; values
&lt;a href=&quot;https://www.researchgate.net/publication/240753489_The_Dangers_of_living_with_an_X_bugs_hidden_in_your_Verilog&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;tool-problem&quot;&gt;Tool problem&lt;/h2&gt;

&lt;p&gt;Yes, it is possible that the tools might not work for you.  There are bugs
within most if not all tool suites, they just tend to take a special design
to trigger.  Don’t believe me?  Read the forum posts associated with each
vendor’s tool suite.  Sometimes bugs get fixed.  Sometimes the fixes create
other bugs.  At other times, they are reported and the vendor does nothing.&lt;/p&gt;

&lt;h2 id=&quot;asynchronous-systems&quot;&gt;Asynchronous Systems&lt;/h2&gt;

&lt;p&gt;I don’t usually design asynchronous systems, although I have done so once or
twice.  What happens when you need the asynchronous system to operate in an
ordered fashion?&lt;/p&gt;

&lt;p&gt;Here’s what one
&lt;a href=&quot;https://www.reddit.com/r/FPGA&quot;&gt;Reddit&lt;/a&gt; user wrote:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;When you design asynchronous systems with matched delay elements between
each sequential stages.  In that case, logic delay is part of the system
behaviour.  The alternative to synthesis is to use a not synthesizable model
for delay chains based on « transport … after » statements.  Although
I must say, synthesis of asynchronous system is also a pain.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;generics&quot;&gt;Generics&lt;/h2&gt;

&lt;p&gt;Here’s one I’ve struggled with personally: using one set of top level generic
values (VHDL term for what would be called a &lt;code class=&quot;highlighter-rouge&quot;&gt;parameter&lt;/code&gt; in Verilog) for
simulation, and another for synthesis.&lt;/p&gt;

&lt;p&gt;I worry about this one when using formal methods especially.  Sometimes the
design is just too complicated to fully verify–a 12x12 multiply might be such
an example, or a &lt;a href=&quot;/dsp/2017/11/10/delayw.html&quot;&gt;delay&lt;/a&gt;
by 2047 time-steps.  So I’ll limit the design, using a Verilog parameter
(VHDL generic) to a smaller/simpler design that I can then prove–for example,
a delay by 7 time-steps instead of 2047.  I try to
convince myself that the proof will be equivalent, but … will it be?&lt;/p&gt;

&lt;h2 id=&quot;using-different-source-files-for-simulation-and-synthesis&quot;&gt;Using different source files for simulation and synthesis&lt;/h2&gt;

&lt;p&gt;I do this all the time.  I simulate the &lt;code class=&quot;highlighter-rouge&quot;&gt;main&lt;/code&gt; module, which is a subset of the
&lt;code class=&quot;highlighter-rouge&quot;&gt;toplevel&lt;/code&gt; module.  I place into my &lt;code class=&quot;highlighter-rouge&quot;&gt;toplevel&lt;/code&gt; all of the hardware specific
items that &lt;a href=&quot;https://www.veripool.org/wiki/verilator&quot;&gt;Verilator&lt;/a&gt;
can’t simulate.&lt;/p&gt;

&lt;p&gt;What happens when one of my bugs is in that top level?
You can read about my struggles with that
&lt;a href=&quot;/blog/2017/09/14/even-i-get-stuck.html&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;This is why you want to do everything you can to make certain that the
design you simulate is also the same design you intend to synthesize.&lt;/p&gt;

&lt;h2 id=&quot;block-rams-with-other-than-power-of-two-sizes&quot;&gt;Block RAM’s with other than power of two sizes&lt;/h2&gt;

&lt;p&gt;I try to only ever use block RAM’s with a power of two size.  I often forget
why.&lt;/p&gt;

&lt;p&gt;Once when I used a non-power of two block RAM, I wrote to an address that wasn’t
in the RAM and crashed &lt;a href=&quot;https://www.veripool.org/wiki/verilator&quot;&gt;Verilator&lt;/a&gt;.
Why?  &lt;a href=&quot;https://www.veripool.org/wiki/verilator&quot;&gt;Verilator&lt;/a&gt; only allocated,
in C++, the number of elements I told it were in the array.&lt;/p&gt;

&lt;p&gt;Even if you don’t write beyond the array, you might read and get a different
answer than you were expecting from simulation alone.&lt;/p&gt;

&lt;h2 id=&quot;vhdl-specific&quot;&gt;VHDL Specific&lt;/h2&gt;

&lt;p&gt;If you know me, you’ll know I don’t work in VHDL.  Others who do were kind
enough to offer my the following examples specific to VHDL.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;clk&#39;event and clk == &#39;1&#39;&lt;/code&gt; doesn’t behave the same between synthesis and
 simulation.  Always use &lt;code class=&quot;highlighter-rouge&quot;&gt;rising_edge(clk)&lt;/code&gt; instead.  (This is another one
 of those issues where &lt;code class=&quot;highlighter-rouge&quot;&gt;clk&lt;/code&gt; might be neither &lt;code class=&quot;highlighter-rouge&quot;&gt;0&lt;/code&gt; nor &lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt;, such as the &lt;code class=&quot;highlighter-rouge&quot;&gt;1b&#39;x&lt;/code&gt;
 example we discussed above.)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Forgetting to add &lt;code class=&quot;highlighter-rouge&quot;&gt;if rising_edge(clk)&lt;/code&gt; in a clocked process.  I think this
would then fit under both the latch example above as well as the signals
left out of the sensitivity list.  Feel free to correct me here if I am wrong.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Comparisons with a null range vector is “true” in Aldec and “false” in
Synplify (null ranges often occur with extensive us of generics.)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Any time a different architecture is used between synthesis and simulation&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Sense a reoccurring theme?&lt;/p&gt;

&lt;h2 id=&quot;verilog&quot;&gt;Verilog&lt;/h2&gt;

&lt;p&gt;I’ve been surprised as I’ve worked with Verilog to discover the system model
for a verilator based design is specified to be the same as if all the
files were concatenated together before synthesis, and then that single
concatenated file is synthesized.  A &lt;code class=&quot;highlighter-rouge&quot;&gt;define&lt;/code&gt; in one module can therefore
impact another–the modules are no longer independent.  If multiple files
define the same value differently, and then the order of the files changes
between simulation and synthesis … then you’ll
get different results between the two.&lt;/p&gt;

&lt;p&gt;This was not something I was expecting, and I was a bit surprised to learn it.
Once it was explained to me, it made sense, but it sure seems like a backwards
way to do things–especially for someone like me who was first trained in &lt;code class=&quot;highlighter-rouge&quot;&gt;C&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&quot;systemverilog&quot;&gt;SystemVerilog&lt;/h2&gt;

&lt;p&gt;One user wrote the following:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;I’ve found when using some of the more new SystemVerilog features
[that] simulation and synthesis can differ.  I read about unions in
Vivado being an issue here.&lt;/p&gt;

  &lt;p&gt;Personally using unpacked arrays and passing them between modules and
accidentally writing something like this:&lt;/p&gt;
&lt;/blockquote&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;moduleA has output logic bus [3:0]
moduleB has input bus[4]
// connection between them was logic[3:0]&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;blockquote&gt;
  &lt;p&gt;Modelsim and Quartus produced different results&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Since I don’t use any of SystemVerilog’s special features beyond the
formal properties we’ve already discussed on this blog, I haven’t come across
this one personally yet.  For those who do use SystemVerilog, look out for
this bug!&lt;/p&gt;

&lt;h2 id=&quot;hardware-failures&quot;&gt;Hardware Failures&lt;/h2&gt;

&lt;p&gt;Here’s a set of problems most software engineers will be surprised by: hardware
failures.  Why do I say it that way?  Because with all my own years of working
on software, I could reliably depend upon the fact that the hardware always
worked–unless in very rare cases it didn’t.  Sherlock Holmes’ logic makes the
most sense here, “Once you eliminate the impossible, whatever remains, no
matter how improbable, must be the truth.”  (Arthur Conan Doyle)&lt;/p&gt;

&lt;p&gt;That said, here are two hardware problems I’ve suffered from.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Noisy or insufficient power supply&lt;/p&gt;

    &lt;p&gt;In one RF design, the noisy power supply crept through the device into the
powered antenna and … well, the result wasn’t the pretty sampled data
I was expecting.&lt;/p&gt;

    &lt;p&gt;In another design, this one for motors, the design failed because the motor
PMod required more power than the board could supply.  In that case, the
FPGA was powered from a Raspberry Pi and the power supply just didn’t cut
it for what we needed.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;PLL’s haven’t converged&lt;/p&gt;

    &lt;p&gt;Remember when I &lt;a href=&quot;/blog/2017/09/14/even-i-get-stuck.html&quot;&gt;wrote about this
earlier&lt;/a&gt;?&lt;/p&gt;

    &lt;p&gt;At one time I assumed that PLL’s will &lt;em&gt;always&lt;/em&gt; converge.
Then I tried to a design for the iCE40 that used a PLL.  No, I didn’t use
&lt;code class=&quot;highlighter-rouge&quot;&gt;icepll&lt;/code&gt;–I should have.  Instead, I just assumed that the PLL converged.
For the life of me, I couldn’t figure out why my design wasn’t working.
I spent months scratching my head until some friends at Digilent
were kind enough to provide me with one of their &lt;a href=&quot;https://store.digilentinc.com/digital-discovery-portable-logic-analyzer-and-digital-pattern-generator/&quot;&gt;Digital
Discovery&lt;/a&gt;’s.
Yes, it took that external logic analyzer for me to figure out what the
problem was.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;You may want to keep this list in your back pocket, and remember these reasons
the next time your design doesn’t work.  Some of these reasons require good
desk checking: check your pin outs, double check your timing, etc.  Other
items require an external scope, such as the PLL that hadn’t converged.
Still others need a good internal scope, such as when the simulation model
doesn’t quite match how the hardware actually works.  Finally, it might also
be that you haven’t fully simulated the design.&lt;/p&gt;

&lt;p&gt;The bottom line is that hardware design isn’t like software design.  There are
a lot more things that can go wrong, and figuring out the problem can require
more sleuthing than you plan upon.&lt;/p&gt;

&lt;p&gt;This is also why I like working with hardware.  Sure, it’s a greater challenge,
but so too is the joy and excitement when everything works as designed on the
hardware.&lt;/p&gt;
&lt;hr /&gt;&lt;p&gt;&lt;em&gt;There is a path which no fowl knoweth, and which the vulture's eye hath not seen (Job 28:7)&lt;/em&gt;</description>
        <pubDate>Sat, 04 Aug 2018 00:00:00 -0400</pubDate>
        <link>https://zipcpu.com/blog/2018/08/04/sim-mismatch.html</link>
        <guid isPermaLink="true">https://zipcpu.com/blog/2018/08/04/sim-mismatch.html</guid>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>Why I like Formal: the ZipCPU and the ICO board</title>
        <description>&lt;p&gt;I’ve been working for some time, off and on, on
&lt;a href=&quot;http://github.com/ZipCPU/icozip&quot;&gt;a port&lt;/a&gt; of the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; to the
&lt;a href=&quot;http://www.icoboard.org&quot;&gt;ICO board&lt;/a&gt;. 
&lt;a href=&quot;https://github.com/ZipCPU/icozip&quot;&gt;The port&lt;/a&gt; isn’t complete (yet), and it’s
not paid for, so the work isn’t going very fast.  However, I came across
something very interesting in this process that I thought would be worth
sharing.&lt;/p&gt;

&lt;p&gt;At issue is the fact that the &lt;a href=&quot;https://en.wikipedia.org/wiki/ICE_(FPGA)&quot;&gt;iCE40&lt;/a&gt; doesn’t support distributed RAM.  Unlike
other &lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;’s,
it only has block RAM.&lt;/p&gt;

&lt;p&gt;To understand the distinction, consider the following piece of code from
within the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;background&quot;&gt;Background&lt;/h2&gt;

&lt;p&gt;At issue is how the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; reads from
its &lt;a href=&quot;https://en.wikipedia.org/wiki/Processor_register&quot;&gt;register file&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The &lt;a href=&quot;https://en.wikipedia.org/wiki/Processor_register&quot;&gt;register file&lt;/a&gt; itself
is declared as a memory of thirty two 32-bit words.  Internally, these are
&lt;a href=&quot;/zipcpu/2018/01/01/zipcpu-isa.html&quot;&gt;split into two register sets–a user register set and a supervisor register
set&lt;/a&gt;, but for now
all that matters is that this is declared as a RAM.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	reg	[31:0]	regset	[0:31];&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; reads from this RAM after
decoding the &lt;a href=&quot;https://en.wikipedia.org/wiki/Processor_register&quot;&gt;registers&lt;/a&gt;
that will be used by the
&lt;a href=&quot;/zipcpu/2018/01/01/zipcpu-isa.html&quot;&gt;instruction&lt;/a&gt;.  Once the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Processor_register&quot;&gt;register&lt;/a&gt; addresses,
&lt;code class=&quot;highlighter-rouge&quot;&gt;dcd_A&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;dcd_B&lt;/code&gt; are available from the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/idecode.v&quot;&gt;decoder&lt;/a&gt;, the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt; reads
from its &lt;a href=&quot;https://en.wikipedia.org/wiki/Processor_register&quot;&gt;register&lt;/a&gt; set.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	assign	w_op_Av = regset[dcd_A];
	assign	w_op_Bv = regset[dcd_B];&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Notice how this isn’t a clocked read.  This will come back into play in a
moment.&lt;/p&gt;

&lt;p&gt;This is the simple part.  The next step are the many paths from here to the
input to the
&lt;a href=&quot;/zipcpu/2017/08/11/simple-alu.html&quot;&gt;ALU&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;From here, let’s focus on the second
&lt;a href=&quot;https://en.wikipedia.org/wiki/Processor_register&quot;&gt;register&lt;/a&gt;’s path,
what I call &lt;a href=&quot;/zipcpu/2018/01/01/zipcpu-isa.html&quot;&gt;register B&lt;/a&gt;.
This rather complicated path is shown in Fig 1 below.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 1. Original path from the register read to Operand B&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/zipcpu-register-lookup.svg&quot; alt=&quot;&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;To get from this
&lt;a href=&quot;https://en.wikipedia.org/wiki/Processor_register&quot;&gt;register&lt;/a&gt; read to the input
to the &lt;a href=&quot;/zipcpu/2017/08/11/simple-alu.html&quot;&gt;ALU&lt;/a&gt;, the value
needs to go through some logic.&lt;/p&gt;

&lt;p&gt;The &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; has
&lt;a href=&quot;/zipcpu/2018/01/01/zipcpu-isa.html&quot;&gt;16 registers in its working
set&lt;/a&gt;.  Of these sixteen
&lt;a href=&quot;https://en.wikipedia.org/wiki/Processor_register&quot;&gt;registers&lt;/a&gt;,
one is the &lt;a href=&quot;https://en.wikipedia.org/wiki/Program_counter&quot;&gt;program counter&lt;/a&gt;
(register 15).  This
&lt;a href=&quot;https://en.wikipedia.org/wiki/Program_counter&quot;&gt;program counter&lt;/a&gt;, however,
isn’t maintained in the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Processor_register&quot;&gt;register file&lt;/a&gt;,
&lt;code class=&quot;highlighter-rouge&quot;&gt;regset&lt;/code&gt;.  Instead, it is maintained in one of two separate registers:
&lt;code class=&quot;highlighter-rouge&quot;&gt;ipc&lt;/code&gt; for the supervisor or interrupt level &lt;a href=&quot;https://en.wikipedia.org/wiki/Program_counter&quot;&gt;program
counter&lt;/a&gt;,
and &lt;code class=&quot;highlighter-rouge&quot;&gt;upc&lt;/code&gt; for the user &lt;a href=&quot;https://en.wikipedia.org/wiki/Program_counter&quot;&gt;program
counter&lt;/a&gt;.  The &lt;code class=&quot;highlighter-rouge&quot;&gt;gie&lt;/code&gt;
flag (global interrupt enable) controls which of the two
&lt;a href=&quot;https://en.wikipedia.org/wiki/Program_counter&quot;&gt;program counters&lt;/a&gt;
is currently in use.&lt;/p&gt;

&lt;p&gt;When this information comes from the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/idecode.v&quot;&gt;decoder&lt;/a&gt;,
&lt;code class=&quot;highlighter-rouge&quot;&gt;dcd_pc&lt;/code&gt; contains a pointer to the next
&lt;a href=&quot;/zipcpu/2018/01/01/zipcpu-isa.html&quot;&gt;instruction&lt;/a&gt;
in the current
&lt;a href=&quot;/zipcpu/2018/01/01/zipcpu-isa.html&quot;&gt;instruction&lt;/a&gt;
stream.  If we want to read our own &lt;a href=&quot;https://en.wikipedia.org/wiki/Program_counter&quot;&gt;program
counter&lt;/a&gt; for this
&lt;a href=&quot;/zipcpu/2018/01/01/zipcpu-isa.html&quot;&gt;instruction&lt;/a&gt;,
that is if the &lt;code class=&quot;highlighter-rouge&quot;&gt;gie&lt;/code&gt; flag coming from the decoder or &lt;code class=&quot;highlighter-rouge&quot;&gt;dcd_gie&lt;/code&gt; matches the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Processor_register&quot;&gt;register set&lt;/a&gt;
in question, then we’ll want the value to be &lt;code class=&quot;highlighter-rouge&quot;&gt;dcd_pc&lt;/code&gt;.  Otherwise, it can
only be the supervisor mode reading the the user mode &lt;a href=&quot;https://en.wikipedia.org/wiki/Program_counter&quot;&gt;program
counter&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;We’ll pick from between these two &lt;a href=&quot;https://en.wikipedia.org/wiki/Program_counter&quot;&gt;program
counter&lt;/a&gt; registers here.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(*)
	if (dcd_B[4] == dcd_gie)
		w_pcB_v = dcd_pc;
	else
		w_pcB_v = upc;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;We’ll need this value in another moment, so hang on to this thought.  For
now, let’s return to the read from the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Processor_register&quot;&gt;register set&lt;/a&gt;
above, where we left the result in &lt;code class=&quot;highlighter-rouge&quot;&gt;w_op_Bv&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The next thing you need to remember from the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;’s
&lt;a href=&quot;/zipcpu/2018/01/01/zipcpu-isa.html&quot;&gt;instruction set&lt;/a&gt; is that
(just about) every
&lt;a href=&quot;/zipcpu/2018/01/01/zipcpu-isa.html&quot;&gt;instruction&lt;/a&gt;
can have an immediate attached.  The two inputs, therefore, to any
&lt;a href=&quot;/zipcpu/2018/01/01/zipcpu-isa.html&quot;&gt;instruction&lt;/a&gt;
are a register I call operand &lt;code class=&quot;highlighter-rouge&quot;&gt;A&lt;/code&gt;, and a second value &lt;code class=&quot;highlighter-rouge&quot;&gt;B&lt;/code&gt; which includes an
optional register, &lt;code class=&quot;highlighter-rouge&quot;&gt;B&lt;/code&gt;, plus an immediate.  If no
&lt;a href=&quot;https://en.wikipedia.org/wiki/Processor_register&quot;&gt;register&lt;/a&gt; is read, the
&lt;a href=&quot;/zipcpu/2018/01/01/zipcpu-isa.html&quot;&gt;instruction&lt;/a&gt;
only references the immediate.&lt;/p&gt;

&lt;p&gt;To handle this selection, the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/idecode.v&quot;&gt;decoder&lt;/a&gt;
produces a flag, &lt;code class=&quot;highlighter-rouge&quot;&gt;dcd_rB&lt;/code&gt;.   This will be true any time the &lt;code class=&quot;highlighter-rouge&quot;&gt;B&lt;/code&gt; operand comes
from a register.&lt;/p&gt;

&lt;p&gt;There’s also another special register–the &lt;a href=&quot;https://en.wikipedia.org/wiki/Status_register&quot;&gt;condition
codes&lt;/a&gt;.  This register
contains a variety of
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
mode selection bits together with the traditional flags, zero (&lt;code class=&quot;highlighter-rouge&quot;&gt;Z&lt;/code&gt;),
carry (&lt;code class=&quot;highlighter-rouge&quot;&gt;C&lt;/code&gt;), negative (&lt;code class=&quot;highlighter-rouge&quot;&gt;N&lt;/code&gt;), and overflow (&lt;code class=&quot;highlighter-rouge&quot;&gt;V&lt;/code&gt;).  As with the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Program_counter&quot;&gt;program counter&lt;/a&gt; above,
there are two versions of this register–one for
supervisor mode and one for user mode.&lt;/p&gt;

&lt;p&gt;In our next step, we are going to calculate the value of the B input in
all respects except the immediate.&lt;/p&gt;

&lt;p&gt;First, if there’s no register read, then the input (not including the
immediate) is zero.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(*)
	if (!dcd_rB)
		w_op_BnI = 0;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Second, in the case of a concurrent register write, the register value is the
result of the register write.  This allows the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt; to bypass
the &lt;a href=&quot;https://en.wikipedia.org/wiki/Processor_register&quot;&gt;register file&lt;/a&gt;, so that
&lt;a href=&quot;/zipcpu/2017/08/11/simple-alu.html&quot;&gt;ALU&lt;/a&gt;
outputs can be immediately available for the next instruction–making the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt; run
that much faster.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	else if ((OPT_PIPELINED)&amp;amp;&amp;amp;(wr_reg_ce)&amp;amp;&amp;amp;(wr_reg_id == dcd_B))
		w_op_BnI = wr_gpreg_vl;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Third, if this is a reference to the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Status_register&quot;&gt;condition codes&lt;/a&gt; register, then
we’ll set that based upon some special flags.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	else if (dcd_Bcc)
		w_op_BnI = { w_cpu_info, w_op_Bv[22:16], 1&#39;b0,
				(dcd_B[4]) ? w_uflags : w_iflags };&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Once we get past all of that logic, we can finally deal with the expected
situation–that the &lt;code class=&quot;highlighter-rouge&quot;&gt;B&lt;/code&gt; operand comes from the result of the register
we just read above.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	else
		w_op_BnI = w_op_Bv;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;As a final step, we’ll add the immediate value associated with the
&lt;a href=&quot;/zipcpu/2018/01/01/zipcpu-isa.html&quot;&gt;instruction&lt;/a&gt;,
&lt;code class=&quot;highlighter-rouge&quot;&gt;dcd_I&lt;/code&gt;, to our value and register the result for the next stage.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(posedge i_clk)
	if ((!OPT_PIPELINED)||(op_ce))
	begin
		if ((dcd_Bpc)&amp;amp;&amp;amp;(dcd_rB))
			r_op_Bv &amp;lt;= w_pcB_v + { dcd_I[29:0], 2&#39;b00 };
		else
			r_op_Bv &amp;lt;= w_op_BnI + dcd_I;
	end else if ((OPT_PIPELINED)&amp;amp;&amp;amp;(op_rB)
			&amp;amp;&amp;amp;(wr_reg_ce)&amp;amp;&amp;amp;(op_Bid == wr_reg_id))
		r_op_Bv &amp;lt;= wr_gpreg_vl;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Well, not quite.  That’s the last step on that clock.  Before we send
this value to the &lt;a href=&quot;/zipcpu/2017/08/11/simple-alu.html&quot;&gt;ALU&lt;/a&gt;,
we’ll need to double check that the value isn’t being written to the &lt;a href=&quot;https://en.wikipedia.org/wiki/Processor_register&quot;&gt;register
file&lt;/a&gt;
on the same clock (again).  In this case,
&lt;code class=&quot;highlighter-rouge&quot;&gt;wr_reg_ce&lt;/code&gt; is a flag indicating that a value is being written to the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Processor_register&quot;&gt;register file&lt;/a&gt;,
&lt;code class=&quot;highlighter-rouge&quot;&gt;wr_reg_id&lt;/code&gt; is the address of that register, and &lt;code class=&quot;highlighter-rouge&quot;&gt;wr_gpreg_vl&lt;/code&gt;
is the value of that register.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	assign	op_Bv = ((OPT_PIPELINED)&amp;amp;&amp;amp;(wr_reg_ce)
					&amp;amp;&amp;amp;(wr_reg_id == op_Bid)&amp;amp;&amp;amp;(op_rB))
			? wr_gpreg_vl: r_op_Bv;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;If you got lost in the explanation above, relax.  My whole point here
is that this logic is complicated.&lt;/p&gt;

&lt;p&gt;Because of this complexity, this was one of those pieces of logic that I was
most interested in formally verifying within the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;.  Along the way I came
across &lt;a href=&quot;/blog/2018/04/02/formal-cpu-bugs.html&quot;&gt;several pipeline hazards I wasn’t
expecting&lt;/a&gt;.  For
example, what happens if you set &lt;code class=&quot;highlighter-rouge&quot;&gt;r_op_Bv&lt;/code&gt; as
the result of a register plus an immediate, only to have the register
updated on the next clock?  &lt;a href=&quot;/zipcpu/2017/08/23/cpu-pipeline.html&quot;&gt;Pipeline
logic&lt;/a&gt;,
primarily captured by the &lt;code class=&quot;highlighter-rouge&quot;&gt;op_ce&lt;/code&gt; flag, needs to prevent that from happening.&lt;/p&gt;

&lt;p&gt;Here’s the problem: the &lt;a href=&quot;https://en.wikipedia.org/wiki/ICE_(FPGA)&quot;&gt;iCE40&lt;/a&gt; doesn’t support memory reads unless the result
is immediately registered, as in:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(posedge i_clk)
		w_op_Av &amp;lt;= regset[dcd_A];

	always @(posedge i_clk)
		w_op_Bv &amp;lt;= regset[dcd_B];&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;While &lt;a href=&quot;http://www.clifford.at/yosys&quot;&gt;yosys&lt;/a&gt; will try to work around this
problem using flip-flops and &lt;a href=&quot;https://en.wikipedia.org/wiki/Logic_block&quot;&gt;LUTs&lt;/a&gt;,
it does so at &lt;a href=&quot;/blog/2017/06/12/minimizing-luts.html&quot;&gt;the
cost&lt;/a&gt; of about 3k or
more &lt;a href=&quot;https://en.wikipedia.org/wiki/Logic_block&quot;&gt;LUTs&lt;/a&gt; on a
7.6k &lt;a href=&quot;https://en.wikipedia.org/wiki/Logic_block&quot;&gt;LUT&lt;/a&gt; device.  That’s bigger
than the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; itself!  This so badly
broke the bank for the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
that unless I could change things there was no way it would work on the
&lt;a href=&quot;https://en.wikipedia.org/wiki/ICE_(FPGA)&quot;&gt;iCE40&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;the-solution&quot;&gt;The Solution&lt;/h2&gt;

&lt;p&gt;The basic solution to this problem is to move the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Processor_register&quot;&gt;register&lt;/a&gt; read logic
one clock earlier–to shuffle logic from one clock to the next.
In other words, I needed to read from the block RAM in the
&lt;a href=&quot;/zipcpu/2017/08/23/cpu-pipeline.html&quot;&gt;decode&lt;/a&gt;
stage, before I got to the selection logic above.  My fear was, how could
I patch this change in and remain certain that the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
would still work?&lt;/p&gt;

&lt;p&gt;Hint: this is one of the reasons why I like
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal methods&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;So, rather than clocking the register address into
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/idecode.v&quot;&gt;decoder&lt;/a&gt;
outputs, I left it as combinatorial logic alone–making two additional outputs
for that purpose.  I could now read the register one clock earlier, and
clock the value in with the same control signal that was used to clock the
&lt;a href=&quot;/zipcpu/2018/01/01/zipcpu-isa.html&quot;&gt;instruction&lt;/a&gt;
 &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/idecode.v&quot;&gt;decoder&lt;/a&gt;
outputs, &lt;a href=&quot;/zipcpu/2017/08/23/cpu-pipeline.html&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;dcd_ce&lt;/code&gt;&lt;/a&gt;:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	if (dcd_ce)
	begin
		pre_op_Av &amp;lt;= regset[dcd_preA];
		pre_op_Bv &amp;lt;= regset[dcd_preB];
	end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;But … what would happen if one of those
&lt;a href=&quot;https://en.wikipedia.org/wiki/Processor_register&quot;&gt;registers&lt;/a&gt;
was written on the exact same cycle?  (This is actually pretty common.)
How can we make sure we have the right value from the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Processor_register&quot;&gt;registers&lt;/a&gt;?&lt;/p&gt;

&lt;p&gt;To do that, I captured the result of the last
&lt;a href=&quot;https://en.wikipedia.org/wiki/Processor_register&quot;&gt;registers&lt;/a&gt;
write, and created a registered flag to indicate that the correct value
wasn’t from the &lt;a href=&quot;https://en.wikipedia.org/wiki/Processor_register&quot;&gt;registers&lt;/a&gt;
set.  You can see this pictorially in Fig 2.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 2. Adjusted path from the register read to Operand B&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/zipcpu-register-lookup-after.svg&quot; alt=&quot;&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;See the difference at the top of the diagram?  Let’s walk through this
updated logic in steps below.  Not only do we read from the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Processor_register&quot;&gt;register file&lt;/a&gt; on a clock,
but we also keep track of whether the register we need is being written
to the register file on this clock as well.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(posedge i_clk)
	if (dcd_ce)
	begin
		pre_rewrite_flag_A &amp;lt;= (wr_reg_ce)&amp;amp;&amp;amp;(dcd_preA == wr_reg_id);
		pre_rewrite_flag_B &amp;lt;= (wr_reg_ce)&amp;amp;&amp;amp;(dcd_preB == wr_reg_id);
		pre_rewrite_value  &amp;lt;= wr_gpreg_vl;
	end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Now, on the next clock we can select which of the two values we should be using.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	assign	w_op_Av = (pre_rewrite_flag_A) ? pre_rewrite_value : pre_op_Av;
	assign	w_op_Bv = (pre_rewrite_flag_B) ? pre_rewrite_value : pre_op_Bv;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Finally, we have some code we can use to replace the original &lt;a href=&quot;https://en.wikipedia.org/wiki/Processor_register&quot;&gt;register
file&lt;/a&gt; read, but this time the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Processor_register&quot;&gt;register file&lt;/a&gt; is read
using clocked rather than combinational logic.&lt;/p&gt;

&lt;p&gt;My fear in all of this, though, was that I would somehow get this logic
wrong.  I mean, there’s so much that can go wrong with this change, how
can I rest assured that the result works?&lt;/p&gt;

&lt;p&gt;Enter &lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal methods&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Within the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/dev/rtl/core/zipcpu.html&quot;&gt;core&lt;/a&gt;
(on the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/tree/dev&quot;&gt;dev branch&lt;/a&gt; currently),
there’s a set of properties rebuilding the logic we worked through above
describing the values going into the
&lt;a href=&quot;/zipcpu/2017/08/11/simple-alu.html&quot;&gt;ALU&lt;/a&gt;
(or &lt;a href=&quot;https://github.com/ZipCPU/blob/master/rtl/core/memops.v&quot;&gt;memory&lt;/a&gt;,
&lt;a href=&quot;https://github.com/ZipCPU/blob/master/rtl/core/div.v&quot;&gt;divide&lt;/a&gt;, etc).  Getting
the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt; and
these properties right took the majority of the work using &lt;a href=&quot;/blog/2018/04/02/formal-cpu-bugs.html&quot;&gt;formal methods on
this CPU&lt;/a&gt;
to date.  What makes these properties special is that they aren’t clocked.
They don’t need to be.
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;Formal properties&lt;/a&gt;
don’t need to meet timing requirements like synthesizable logic does.  As a
result, I can assert that both &lt;code class=&quot;highlighter-rouge&quot;&gt;op_Av&lt;/code&gt; and
&lt;code class=&quot;highlighter-rouge&quot;&gt;op_Bv&lt;/code&gt; have the &lt;em&gt;right&lt;/em&gt; value using simpler logic than the logic we expressed
above.  Even better, I can make that assertion &lt;em&gt;independent&lt;/em&gt; of any
&lt;a href=&quot;/zipcpu/2017/08/23/cpu-pipeline.html&quot;&gt;pipeline stalls&lt;/a&gt; or
hazards.  The result is that the property tends to find hazards I wasn’t
expecting.&lt;/p&gt;

&lt;p&gt;The end of this &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/dev/rtl/core/zipcpu.v&quot;&gt;chain of
logic&lt;/a&gt;
is a short set of assertions.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(posedge i_clk)
	if ((f_op_insn)&amp;amp;&amp;amp;(!f_const_illegal)&amp;amp;&amp;amp;(!fc_illegal)&amp;amp;&amp;amp;(!clear_pipeline))
	begin
		if (((!wr_reg_ce)||(wr_reg_id!= { gie, `CPU_PC_REG }))
			&amp;amp;&amp;amp;(!dbg_clear_pipe)&amp;amp;&amp;amp;(!clear_pipeline))
		begin
			if ((fc_rA)&amp;amp;&amp;amp;(fc_Aid[3:1] != 3&#39;h7))
				`PHASE_TWO_ASSERT(f_Av == op_Av);
			`PHASE_TWO_ASSERT(f_Bv == op_Bv);
		end
	end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The important part is in the middle.  First, I assert that the value of the
&lt;code class=&quot;highlighter-rouge&quot;&gt;A&lt;/code&gt; register going into the
&lt;a href=&quot;/zipcpu/2017/08/11/simple-alu.html&quot;&gt;ALU&lt;/a&gt; is as it should
be, then the &lt;code class=&quot;highlighter-rouge&quot;&gt;B&lt;/code&gt; value.&lt;/p&gt;

&lt;p&gt;Yes, there are a lot of caveats to this assertion–the values only need to be
correct if the illegal instruction flag isn’t set, if the
&lt;a href=&quot;/zipcpu/2017/08/23/cpu-pipeline.html&quot;&gt;pipeline&lt;/a&gt;
isn’t being cleared, if the
&lt;a href=&quot;/zipcpu/2017/08/25/hw-debugging.html&quot;&gt;debugging port&lt;/a&gt;
isn’t going to force the
&lt;a href=&quot;/zipcpu/2017/08/23/cpu-pipeline.html&quot;&gt;pipeline&lt;/a&gt;
to be cleared on the next clock, and so on.&lt;/p&gt;

&lt;p&gt;The good news?  Once I made the change outlined above, I could go back and
rerun the
&lt;a href=&quot;/blog/2018/04/02/formal-cpu-bugs.html&quot;&gt;formal proof&lt;/a&gt;–this
time with the &lt;code class=&quot;highlighter-rouge&quot;&gt;NO_DISTRIBUTED_RAM&lt;/code&gt; define
selected.  Once the proof passed, I knew the change “worked”.&lt;/p&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 3. Development Process&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/ice40-process.svg&quot; alt=&quot;&quot; width=&quot;360&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;One of the topics I discuss in the two-day formal verification course I teach
is the idea of moving logic between clocks.  In the course, we adjust a
flag indicating that a counter is non-zero to the clock before the counter’s
value in question. To me, this is one of the very important uses of &lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal
verification&lt;/a&gt;–being
able to tell when you make a change, no matter how complex,
that the properties you had asserted before remain true.  In this case,
I was able to prove that the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
maintained the correct
&lt;a href=&quot;https://en.wikipedia.org/wiki/Processor_register&quot;&gt;register&lt;/a&gt;
inputs, in spite of moving the logic earlier by one clock.&lt;/p&gt;

&lt;p&gt;Does this mean that the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; works on the &lt;a href=&quot;https://en.wikipedia.org/wiki/ICE_(FPGA)&quot;&gt;iCE40&lt;/a&gt;?  Well, let’s just say that
now it builds for the &lt;a href=&quot;https://en.wikipedia.org/wiki/ICE_(FPGA)&quot;&gt;iCE40&lt;/a&gt; whereas it wouldn’t build before.  The project
remains ongoing.  I would like to implement the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; both on the
&lt;a href=&quot;http://www.icoboard.org&quot;&gt;ICO board&lt;/a&gt; as well as on Luke Valenty’s new
&lt;a href=&quot;https://tinyfpga.com&quot;&gt;TinyFPGA&lt;/a&gt;.  Before I get there, though,
I’ve still got a lot of &lt;a href=&quot;/blog/2017/06/23/my-dbg-philosophy.html&quot;&gt;peripheral
simulation&lt;/a&gt;
work to get through.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/blog/2017/06/23/my-dbg-philosophy.html&quot;&gt;Simulation&lt;/a&gt;
work?  Yes.  To avoid &lt;a href=&quot;/blog/2017/05/19/fpga-hell.html&quot;&gt;FPGA
Hell&lt;/a&gt;, I’m not only
running my designs through the (incomplete) &lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal
proof&lt;/a&gt;, but also through
&lt;a href=&quot;/blog/2017/06/21/looking-at-verilator.html&quot;&gt;simulation&lt;/a&gt;.
You can see my process in the figure on the right.&lt;/p&gt;

&lt;hr /&gt;&lt;p&gt;&lt;em&gt;God is our refuge and strength, a very present help in trouble.  Ps 46:1&lt;/em&gt;</description>
        <pubDate>Sat, 21 Jul 2018 00:00:00 -0400</pubDate>
        <link>https://zipcpu.com/formal/2018/07/21/zipcpu-icoboard.html</link>
        <guid isPermaLink="true">https://zipcpu.com/formal/2018/07/21/zipcpu-icoboard.html</guid>
        
        
        <category>formal</category>
        
      </item>
    
      <item>
        <title>What does Formal Development look like in Practice?</title>
        <description>&lt;p&gt;When I initially started working with
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal verification&lt;/a&gt;,
I used &lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal methods&lt;/a&gt;
to find bugs in my designs.  Now, I struggle to build a new design component
without using
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal methods&lt;/a&gt;
along the way.&lt;/p&gt;

&lt;p&gt;What does that look like?&lt;/p&gt;

&lt;p&gt;Consider this: last night I set about to build a &lt;a href=&quot;https://github.com/ZipCPU/icozip/blob/master/rtl/icozip/spixpress.v&quot;&gt;new SPI flash
controller&lt;/a&gt;.
This isn’t the first &lt;a href=&quot;https://en.wikipedia.org/wiki/Serial_Perip-heral_Interface&quot;&gt;SPI&lt;/a&gt; &lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt; controller that I’ve built.  You can find
my first one &lt;a href=&quot;https://opencores.org/project/qspiflash&quot;&gt;here&lt;/a&gt;.  That one’s a
very general purpose controller, &lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/sim/verilated/qspiflashsim.cpp&quot;&gt;plus Verilator-based
simulator&lt;/a&gt;.
Because it’s such a general purpose controller, it requires more
logic than I often have.  (Remember, I like working with really cheap, low
logic boards.)&lt;/p&gt;

&lt;p&gt;This isn’t the first time I’ve had this problem.  The first time this
&lt;a href=&quot;http://opencores.org/project/qspiflash&quot;&gt;general purpose controller&lt;/a&gt;
didn’t fit within a design was when I was working on the
&lt;a href=&quot;https://store.digilentinc.com/cmod-s6-breadboardable-spartan-6-fpga-module&quot;&gt;CMod-S6&lt;/a&gt;, a “spartan” board containing a Spartan 6/LX4
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
and only 2400 &lt;a href=&quot;/blog/2017/06/12/minimizing-luts.html&quot;&gt;LUTs&lt;/a&gt;.  So I ripped out
the capabilities I didn’t really need: the ability to read the device ID, or to
erase and reprogram the &lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt;.  Yes, I cringed when removing these capabilities,
I really wanted to keep them.  However, if your hardware doesn’t have enough
logic, then you’ll need to find alternate and creative solutions for many
things.  The &lt;a href=&quot;https://github.com/ZipCPU/s6soc/blob/master/rtl/qflashxpress.v&quot;&gt;controller I eventually
built&lt;/a&gt;
for &lt;a href=&quot;https://github.com/ZipCPU/s6soc&quot;&gt;that design&lt;/a&gt; is fast, simple
and low logic.  However, it requires a six-wire Quad-SPI interface.&lt;/p&gt;

&lt;p&gt;Why is that important?  In one example, when I first
started working with the &lt;a href=&quot;https://tinyfpga.com&quot;&gt;TinyFPGA BX&lt;/a&gt;
it didn’t have all six Quad-SPI wires connected, only the four basic &lt;a href=&quot;https://en.wikipedia.org/wiki/Serial_Perip-heral_Interface&quot;&gt;SPI&lt;/a&gt; wires.
(Later versions now connect these last two wires.)  So I rewrote the Quad-SPI
interface from the &lt;a href=&quot;https://github.com/ZipCPU/s6soc&quot;&gt;CMod-S6 project&lt;/a&gt;
to work in a dual-SPI mode.  Dual SPI aggregates the MISO and MOSI
wires from the &lt;a href=&quot;https://en.wikipedia.org/wiki/Serial_Perip-heral_Interface&quot;&gt;SPI&lt;/a&gt; together, so that both go in the same direction.  Hence,
the &lt;a href=&quot;https://github.com/ZipCPU/tinyzip/blob/master/rtl/dualflexpress.v&quot;&gt;Dual SPI controller&lt;/a&gt;
should be about 2x as fast as a traditional &lt;a href=&quot;https://en.wikipedia.org/wiki/Serial_Perip-heral_Interface&quot;&gt;SPI&lt;/a&gt;
controller.  This is important when doing CPU work.  To handle erasing and
programming the &lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt;, I built a bit-banging interface through a control
register–something the &lt;a href=&quot;https://github.com/ZipCPU/s6soc/blob/master/rtl/qflashxpress.v&quot;&gt;CMod S6 Quad SPI flash controller
design&lt;/a&gt;
didn’t have within it.&lt;/p&gt;

&lt;p&gt;Sadly, even this won’t work on the
&lt;a href=&quot;https://icoboard.org&quot;&gt;ICO board&lt;/a&gt;–another iCE40 based design.
Because the &lt;a href=&quot;https://icoboard.org&quot;&gt;ICO board&lt;/a&gt; runs the wires for the &lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt;
through a MachXO2 chip, the wire directions are fixed.  Hence, the
&lt;a href=&quot;https://icoboard.org&quot;&gt;ICO board&lt;/a&gt;
can only run a straight 4-wire &lt;a href=&quot;https://en.wikipedia.org/wiki/Serial_Perip-heral_Interface&quot;&gt;SPI&lt;/a&gt; &lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt; interface.
I also wanted a “faster” bit-banging interface than the &lt;a href=&quot;https://github.com/ZipCPU/tinyzip/blob/master/rtl/dualflexpress.v&quot;&gt;one I had just
written&lt;/a&gt;
for the &lt;a href=&quot;https://tinyfpga.com&quot;&gt;TinyFPGA board&lt;/a&gt; I have.&lt;/p&gt;

&lt;p&gt;I say this all as background for why I was building a new
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt;
controller–again.&lt;/p&gt;

&lt;p&gt;The other reason why I share this background is so that you can place my next
claim into context: using
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal methods&lt;/a&gt;,
the controller only took about four hours to build–the time between dessert
and bed-time on a Friday night.
(No, don’t ask why I’m doing this on a Friday night … you don’t want to know.)&lt;/p&gt;

&lt;p&gt;So, what did this development cycle look like?&lt;/p&gt;

&lt;h2 id=&quot;steps-in-a-formal-driven-development-cycle&quot;&gt;Steps in a Formal Driven Development Cycle&lt;/h2&gt;

&lt;p&gt;Since it’s fresh in my mind, and since a reader asked, let me walk you
through the steps of building &lt;a href=&quot;https://github.com/ZipCPU/icozip/blob/master/rtl/icozip/spixpress.v&quot;&gt;this brand new
SPI flash controller&lt;/a&gt;.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;I started my design work at the kitchen table, where I tried to scribble out
some &lt;a href=&quot;https://en.wikipedia.org/wiki/SystemVerilog&quot;&gt;SystemVerilog&lt;/a&gt; sequence
properties.  When most people think of &lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal
verification&lt;/a&gt;, they
think of these &lt;a href=&quot;http://www.asic-world.com/systemverilog/assertions4.html&quot;&gt;sequences&lt;/a&gt;.  While I have used them a bit,
I’ve never used them enough to be comfortable with them.  However, I had just
removed the discussion of how to use
&lt;a href=&quot;http://www.asic-world.com/systemverilog/assertions4.html&quot;&gt;sequences&lt;/a&gt;
to verify a &lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash memory&lt;/a&gt;
interaction from my &lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal
verification&lt;/a&gt;
courseware, since I had never used
them to verify a &lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash memory&lt;/a&gt;
interaction, it was complicated to examine, etc.  Was this really a good
choice?  I wasn’t certain.  (I still had other proven examples.)  So I’m
sure you can understand how I imagined that that actually building
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal properties&lt;/a&gt;
from &lt;a href=&quot;http://www.asic-world.com/systemverilog/assertions4.html&quot;&gt;sequences&lt;/a&gt;
would help me teach this lesson later.&lt;/p&gt;

    &lt;p&gt;It was a good intention.&lt;/p&gt;

    &lt;p&gt;Instead, after I filled about a half sheet of paper with my chicken
scratches before realizing that the process wasn’t going anywhere fast.
Instead, I switched to the computer and typed my
&lt;a href=&quot;http://www.asic-world.com/systemverilog/assertions4.html&quot;&gt;sequences&lt;/a&gt;
in, got annoyed with them, rearranged them, got annoyed again, and
rearranged them some more.  I quickly come to the realization that it
will be plain annoying to
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formally verify&lt;/a&gt; these
&lt;a href=&quot;http://www.asic-world.com/systemverilog/assertions4.html&quot;&gt;sequences&lt;/a&gt;,
since I’d need to move my files to a project directory on another computer
having the full commercial version of &lt;a href=&quot;http://www.clifford.at/yosys&quot;&gt;yosys&lt;/a&gt;
on it.&lt;/p&gt;

    &lt;p&gt;That’s what lead me to ultimately decide to build my design without
&lt;a href=&quot;http://www.asic-world.com/systemverilog/assertions4.html&quot;&gt;sequences&lt;/a&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;So I switched from working on these (so far irrelevant) properties to
building the operational logic for my &lt;a href=&quot;https://github.com/ZipCPU/icozip/blob/master/rtl/icozip/spixpress.v&quot;&gt;basic
design&lt;/a&gt;.
This took some time, as I worked with this design until it had enough
capability within it that I could do some amount of
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal verification&lt;/a&gt;
work next.&lt;/p&gt;

    &lt;p&gt;When I say this took some time, I should point out that I couldn’t quite
decide how the controller over-ride mode was going to work.  (I needed this
to be able to erase and later program the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt; without complicating
the controller.) In the end, I decided that I wanted to have a special
control register, separate from the main
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt; memory area, that this
register would control the &lt;code class=&quot;highlighter-rouge&quot;&gt;CS_n&lt;/code&gt; pin of the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt;, and that writes to
this register would send eight bits and eight clocks to the device.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Once I thought I was ready to move on, I ran
&lt;a href=&quot;https://www.veripool.org/wiki/verilator&quot;&gt;Verilator&lt;/a&gt; on
&lt;a href=&quot;https://github.com/ZipCPU/icozip/blob/master/rtl/icozip/spixpress.v&quot;&gt;the design&lt;/a&gt;
to see if I had made any dumb mistakes.  Indeed I had: 64 will not
fit into a 6-bit register, among other problems
&lt;a href=&quot;https://www.veripool.org/wiki/verilator&quot;&gt;Verilator&lt;/a&gt; found for me.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span class=&quot;gp&quot;&gt;% &lt;/span&gt;verilator -Wall -cc spixpress.v&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;ol start=&quot;4&quot;&gt;
  &lt;li&gt;I then moved to the &lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal
property&lt;/a&gt;
section of the design, making sure it was outlined properly by &lt;code class=&quot;highlighter-rouge&quot;&gt;ifdef&lt;/code&gt;’s.
Since I had started with
&lt;a href=&quot;https://en.wikipedia.org/wiki/SystemVerilog&quot;&gt;SystemVerilog&lt;/a&gt;
&lt;a href=&quot;http://www.asic-world.com/systemverilog/assertions4.html&quot;&gt;sequence properties&lt;/a&gt;
that would only work with the commercial version of
&lt;a href=&quot;https://www.clifford.at/yosys&quot;&gt;yosys&lt;/a&gt;,
I place these in a special &lt;code class=&quot;highlighter-rouge&quot;&gt;VERIFIC&lt;/code&gt; section which I can come back to later.&lt;/li&gt;
&lt;/ol&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;`ifdef	FORMAL
	// Properties will soon go here
`endif
`ifdef	VERIFIC
	// Commercial grade formal properties can go here
`endif&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;ol start=&quot;5&quot;&gt;
  &lt;li&gt;My next step was to create an &lt;code class=&quot;highlighter-rouge&quot;&gt;f_past_valid&lt;/code&gt; register for use with any
  &lt;code class=&quot;highlighter-rouge&quot;&gt;$past&lt;/code&gt; properties I might have later.&lt;/li&gt;
&lt;/ol&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	reg	f_past_valid;

	initial	f_past_valid = 1&#39;b0;
	always @(posedge i_clk)
		f_past_valid &amp;lt;= 1&#39;b1;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;ol start=&quot;6&quot;&gt;
  &lt;li&gt;Once I had &lt;code class=&quot;highlighter-rouge&quot;&gt;f_past_valid&lt;/code&gt;, the next step was to add in some properties to
describe the reset condition/state.  There were two parts to this process.
First, I worked my way back through my code, auditing which registers really
needed a reset capability and which did not.  The second part was to create
a basic reset property form I’ve found works in almost all of my designs.
This form has worked quite well for me in the past, tying both the initial
state and the reset state together and asserting that they are identical.&lt;/li&gt;
&lt;/ol&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(posedge i_clk)
	if ((!f_past_valid)||($past(i_reset)))
	begin
		assert(o_spi_cs_n == 1&#39;b1);
		assert(o_spi_sck  == 1&#39;b0);
		// etc.
		// Register states upon reset go here.
	end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;ol start=&quot;7&quot;&gt;
  &lt;li&gt;
    &lt;p&gt;The next step was to create a &lt;code class=&quot;highlighter-rouge&quot;&gt;bench/formal&lt;/code&gt; directory, and then to copy
the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/dev/rtl/ex/fwb_slave.v&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;fwb_slave&lt;/code&gt;
properties&lt;/a&gt;
from the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU project&lt;/a&gt; to &lt;a href=&quot;https://github.com/ZipCPU/icozip/tree/master/bench/formal&quot;&gt;this new
directory&lt;/a&gt;.  &lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;The
Wishbone properties&lt;/a&gt;
will cause the &lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal&lt;/a&gt;
tools to assume that the external
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;Wishbone&lt;/a&gt; master
acts “appropriately”,
and assert that the responses of this module also act according to the
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus specification&lt;/a&gt;.&lt;/p&gt;

    &lt;p&gt;I spen5 a moment at this point trying to deciding what parameters needed
to be given to this &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/dev/rtl/ex/fwb_slave.v&quot;&gt;slave property
module&lt;/a&gt;,
but ultimately end something like the following.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	localparam	F_LGDEPTH = 7;
	wire	[F_LGDEPTH-1:0]	f_nreqs, f_nacks, f_outstanding;

	fwb_slave #( .AW(23), .F_MAX_STALL(7&#39;d70), .F_MAX_ACK_DELAY(7&#39;d70),
			.F_LGDEPTH(F_LGDEPTH),
			.F_MAX_REQUESTS(1&#39;b1),
			.F_OPT_MINCLOCK_DELAY(1&#39;b1)
		) slavei(i_clk, i_reset,
		i_wb_cyc, i_wb_stb, i_wb_we, i_wb_addr, i_wb_data, 4&#39;hf,
			o_wb_ack, o_wb_stall, o_wb_data, 1&#39;b0,
			f_nreqs, f_nacks, f_outstanding);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;ol start=&quot;8&quot;&gt;
  &lt;li&gt;
    &lt;p&gt;Just to know this design will do something useful, I add a couple ad-hoc
safety properties as well.&lt;/p&gt;

    &lt;p&gt;For example, my SCK output isn’t the true SCK for the interface.  That will
be created from a DDR I/O module at the top level–the only way to really
get a high speed SCK clock.  At this point, I wanted to make certain that
SCK is off (i.e. not toggling) any time &lt;code class=&quot;highlighter-rouge&quot;&gt;o_spi_cs_n&lt;/code&gt; is not asserted.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(*)
	if (o_spi_cs_n)
		assert(!o_spi_sck);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;ol start=&quot;9&quot;&gt;
  &lt;li&gt;I then returned to the &lt;a href=&quot;https://github.com/ZipCPU/icozip/tree/master/bench/formal&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;bench/formal&lt;/code&gt;
directory&lt;/a&gt;
and created a &lt;a href=&quot;https://symbiyosys.readthedocs.io/en/latest&quot;&gt;SymbiYosys&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/icozip/blob/master/bench/formal/spixpress.sby&quot;&gt;configuration file&lt;/a&gt;.  Since
I have no idea how well my code will or won’t work, I start it with a depth
longer than the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Serial_Perip-heral_Interface&quot;&gt;SPI&lt;/a&gt;
operation I’m interested in (about 64 cycles), and I also start it in &lt;code class=&quot;highlighter-rouge&quot;&gt;bmc&lt;/code&gt;
mode only.&lt;/li&gt;
&lt;/ol&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;[options]
mode bmc
depth 70

[engines]
smtbmc

[script]
read_verilog -formal fwb_slave.v
read_verilog -formal spixpress.v
prep -top spixpress

[files]
fwb_slave.v
../../rtl/icozip/spixpress.v&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;ol start=&quot;10&quot;&gt;
  &lt;li&gt;I now run &lt;a href=&quot;https://symbiyosys.readthedocs.io/en/latest&quot;&gt;SymbiYosys&lt;/a&gt; using
   this &lt;a href=&quot;https://github.com/ZipCPU/icozip/blob/master/bench/formal/spixpress.sby&quot;&gt;configuration file&lt;/a&gt;.&lt;/li&gt;
&lt;/ol&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span class=&quot;gp&quot;&gt;% &lt;/span&gt;sby -f spixpress.sby&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;ol start=&quot;11&quot;&gt;
  &lt;li&gt;The design didn’t even get past the second clock.  I pull up the
   &lt;a href=&quot;/blog/2017/07/31/vcd.html&quot;&gt;VCD file&lt;/a&gt;
   to examine it, and discover that my design has a problem with the &lt;code class=&quot;highlighter-rouge&quot;&gt;i_reset&lt;/code&gt;
   signal.&lt;/li&gt;
&lt;/ol&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span class=&quot;gp&quot;&gt;% &lt;/span&gt;gtkwave spixpress/engine_0/trace.vcd&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;ol start=&quot;12&quot;&gt;
  &lt;li&gt;
    &lt;p&gt;My problem was specifically that I had wanted to create a design that
   would work with or without a reset signal, potentially using only the
   &lt;code class=&quot;highlighter-rouge&quot;&gt;initial&lt;/code&gt; statements to get into the right state.  However, the
   &lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;Wishbone&lt;/a&gt;
   &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/dev/rtl/ex/fwb_slave.v&quot;&gt;property file&lt;/a&gt;
   requires a reset anytime &lt;code class=&quot;highlighter-rouge&quot;&gt;f_past_valid&lt;/code&gt; is false.  I grumble to myself and
   then grudgingly create this required reset.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;I then repeat this process: creating properties, running &lt;a href=&quot;https://symbiyosys.readthedocs.io/en/latest&quot;&gt;SymbiYosys&lt;/a&gt;,
examining the trace, adjusting my code and repeating.&lt;/p&gt;

    &lt;p&gt;Eventually I switch from &lt;code class=&quot;highlighter-rouge&quot;&gt;mode bmc&lt;/code&gt; to &lt;code class=&quot;highlighter-rouge&quot;&gt;mode prove&lt;/code&gt;.  This yields a whole
new set of
&lt;a href=&quot;/formal/2018/03/10/induction-exercise.html&quot;&gt;strangeness&lt;/a&gt;
within the trace, but the process remains the same.&lt;/p&gt;

    &lt;p&gt;Well, almost.  There are additional properties that your design will need
in order to to pass
&lt;a href=&quot;/formal/2018/03/10/induction-exercise.html&quot;&gt;induction&lt;/a&gt;.
As is often the case, most of the problems I discover simply require more
&lt;code class=&quot;highlighter-rouge&quot;&gt;assert()&lt;/code&gt; statements.&lt;/p&gt;

    &lt;p&gt;The result of this exercise is usually a jumbled mess of assertions
at the bottom of an (eventually)
&lt;a href=&quot;https://github.com/ZipCPU/icozip/blob/master/rtl/icozip/spixpress.v&quot;&gt;working design&lt;/a&gt;.
I’ll often leave these properties just like that, in a jumbled mess,
until I come back later and blog about the design–if I ever do.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;After doing this for a while, my &lt;a href=&quot;https://github.com/ZipCPU/icozip/blob/master/rtl/icozip/spixpress.v&quot;&gt;design&lt;/a&gt;
stopped failing.  Since the
&lt;a href=&quot;https://github.com/ZipCPU/icozip/blob/master/rtl/icozip/spixpress.v&quot;&gt;design&lt;/a&gt;
and its properties were at this point consistent,
&lt;a href=&quot;https://symbiyosys.readthedocs.io/en/latest&quot;&gt;SymbiYosys&lt;/a&gt;
stopped generating any &lt;a href=&quot;/blog/2017/07/31/vcd.html&quot;&gt;trace
files&lt;/a&gt; containing bugs
to look at.  When this happens it becomes harder to have any confidence
that the code is (still) working.  Sure, the tool says it’s working, but
is it?  Therefore, I added some cover properties to my design.&lt;/p&gt;

    &lt;p&gt;Unlike a safety property, such as either &lt;code class=&quot;highlighter-rouge&quot;&gt;assume&lt;/code&gt; or &lt;code class=&quot;highlighter-rouge&quot;&gt;assert&lt;/code&gt;, a cover
property is used to prove that something &lt;em&gt;could&lt;/em&gt; happen, or equivalently
that a particular state is possible.  A &lt;code class=&quot;highlighter-rouge&quot;&gt;cover&lt;/code&gt; property will only succeed
if the solver can find a trace, any trace, that will make the expression
within it true.&lt;/p&gt;

    &lt;p&gt;If you’ve never used &lt;code class=&quot;highlighter-rouge&quot;&gt;cover&lt;/code&gt; before, usually you can cover a response from
the bus to get a large bang for your buck.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	cover(o_wb_ack);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;ol start=&quot;15&quot;&gt;
  &lt;li&gt;Running in cover mode, however, required changing my
&lt;a href=&quot;https://symbiyosys.readthedocs.io/en/latest&quot;&gt;SymbiYosys&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/icozip/blob/master/bench/formal/spixpress.sby&quot;&gt;configuration file&lt;/a&gt;
to use &lt;code class=&quot;highlighter-rouge&quot;&gt;mode cover&lt;/code&gt; instead of &lt;code class=&quot;highlighter-rouge&quot;&gt;mode prove&lt;/code&gt;.  I then ran
&lt;a href=&quot;https://symbiyosys.readthedocs.io/en/latest&quot;&gt;SymbiYosys&lt;/a&gt; again, this
time focusing on the &lt;code class=&quot;highlighter-rouge&quot;&gt;cover&lt;/code&gt; property.&lt;/li&gt;
&lt;/ol&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span class=&quot;gp&quot;&gt;% &lt;/span&gt;sby -f spixpress.sby&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;ol start=&quot;16&quot;&gt;
  &lt;li&gt;
    &lt;p&gt;For this particular design, covering a
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;Wishbone&lt;/a&gt;
acknowledgement just isn’t all that satisfying.  Perhaps I’ve been
spoiled by cache designs, MMU’s or other
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt; controllers.  In this case, there’s a status register which will
respond almost instantly before the core does anything useful.&lt;/p&gt;

    &lt;p&gt;Therefore, I needed to create some extra logic just so I could capture
just the acknowledgement I was looking for in a cover statement.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	reg	f_pending_bus_request; /// A read from the flash

	initial	f_pending_bus_request = 1&#39;b0;
	always @(posedge i_clk)
	if ((i_reset)||(!i_wb_cyc))
		f_pending_bus_request &amp;lt;= 1&#39;b0;
	else if (bus_request)
		// bus_request is a wire set to (i_wb_stb)&amp;amp;&amp;amp;(!o_wb_stall)
		//	&amp;amp;&amp;amp;(!i_wb_we)&amp;amp;&amp;amp;( not the configuration register address)
		f_pending_bus_request &amp;lt;= 1&#39;b1;
	else if (o_wb_ack)
		f_pending_bus_request &amp;lt;= 1&#39;b0;

	always @(posedge i_clk)
		cover((o_wb_ack)&amp;amp;&amp;amp;(f_pending_bus_request));&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;ol start=&quot;17&quot;&gt;
  &lt;li&gt;The design felt pretty good at this point, so I took a quick look
to see how big it was in terms of logic.  This meant firing up
&lt;a href=&quot;https://www.clifford.at/yosys&quot;&gt;yosys&lt;/a&gt;,
and within a &lt;a href=&quot;https://www.clifford.at/yosys&quot;&gt;yosys&lt;/a&gt; command line I typed:&lt;/li&gt;
&lt;/ol&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&amp;gt; read_verilog spixpress.v
&amp;gt; synth_ice40
&amp;gt; stat&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;ol start=&quot;18&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/ZipCPU/icozip/blob/master/rtl/icozip/spixpress.v&quot;&gt;The design&lt;/a&gt;
only used about 150 elements.   150 elements would fit nicely on the
&lt;a href=&quot;http://icoboard.org&quot;&gt;ICO board&lt;/a&gt;.  It is also cheaper than many of my
other designs.  The last benchmark I have is about 320 cells for the
&lt;a href=&quot;https://github.com/ZipCPU/tinyzip/blob/master/rtl/dualflexpress.v&quot;&gt;Dual SPI flash
controller&lt;/a&gt;.&lt;/li&gt;
&lt;/ol&gt;

&lt;ol start=&quot;19&quot;&gt;
  &lt;li&gt;
    &lt;p&gt;Even though &lt;a href=&quot;https://github.com/ZipCPU/icozip/blob/master/rtl/icozip/spixpress.v&quot;&gt;the design&lt;/a&gt;
had passed
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal verification&lt;/a&gt;,
it still really wasn’t complete.  In particular, it didn’t yet support
pipelined bus interactions.  Instead, it would read only one 32-bit value
from the &lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt; memory at any
given time.  Hence, any &lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt;
interaction would write the “read” command, &lt;code class=&quot;highlighter-rouge&quot;&gt;8&#39;h03&lt;/code&gt;, to the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt;, write the address,
and then read the data.  If you wanted to read the next data value, you
would have to start back at the beginning with a new command.&lt;/p&gt;

    &lt;p&gt;Because of this ineffiiency, I like to create a pipeline capability in my
controllers.  Using this pipeline capaability, once you get near the end
of the data request,
&lt;a href=&quot;https://github.com/ZipCPU/icozip/blob/master/rtl/icozip/spixpress.v&quot;&gt;the design&lt;/a&gt;
will accept another
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;Wishbone&lt;/a&gt;
request, but only for the next memory address.  That allows the controller
to require &lt;code class=&quot;highlighter-rouge&quot;&gt;64&lt;/code&gt; clocks for the initial transfer, and &lt;code class=&quot;highlighter-rouge&quot;&gt;32&lt;/code&gt; for any
subsequent transfer.&lt;/p&gt;

    &lt;p&gt;To create this new capability, I added a one-bit parameter,
&lt;code class=&quot;highlighter-rouge&quot;&gt;OPT_PIPE&lt;/code&gt;.  Pipeline logic requires that the
the &lt;code class=&quot;highlighter-rouge&quot;&gt;o_wb_stall&lt;/code&gt; line be dropped before the end of the interaction, but
only if the next request from the bus is for the next word from &lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt;.
Pipeline logic also requires being able to tell if the next bus request
is for the next address in memory or not.  Hence, I added a generate block
to capture the last address logic.  This has the nice feature that it only
uses the additional logic any time &lt;code class=&quot;highlighter-rouge&quot;&gt;OPT_PIPE&lt;/code&gt; is true.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	generate if (OPT_PIPE)
	begin
		reg	[21:0]	r_next_addr;
		always @(posedge i_clk)
		if ((i_wb_stb)&amp;amp;&amp;amp;(!o_wb_stall))
			r_next_addr &amp;lt;= i_wb_addr[21:0] + 1&#39;b1;

		assign	next_addr = r_next_addr;

	end else begin

		assign next_addr = 0;

	end endgenerate&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;ol start=&quot;19&quot;&gt;
  &lt;li&gt;
    &lt;p&gt;Once accomplished, I had now adjusted my logic, so I now needed to go back
into my adjust my
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal properties&lt;/a&gt;,
run &lt;a href=&quot;https://symbiyosys.readthedocs.io/en/latest&quot;&gt;SymbiYosys&lt;/a&gt;, and
view the &lt;a href=&quot;/blog/2017/07/31/vcd.html&quot;&gt;trace&lt;/a&gt;
development cycle.&lt;/p&gt;

    &lt;p&gt;I also added a property to make certain that, if &lt;code class=&quot;highlighter-rouge&quot;&gt;o_wb_stall&lt;/code&gt; was ever
dropped during a transaction, it was only dropped if there was a read
request for the next data word.  Sure enough, this property failed the first
time around.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;ol start=&quot;21&quot;&gt;
  &lt;li&gt;
    &lt;p&gt;When &lt;a href=&quot;https://github.com/ZipCPU/icozip/blob/master/rtl/icozip/spixpress.v&quot;&gt;the design&lt;/a&gt;
was at the point where it passed the
&lt;a href=&quot;/formal/2018/03/10/induction-exercise.html&quot;&gt;induction&lt;/a&gt;
step again, I switched back to the cover mode.  Specifically, I wanted to
prove that &lt;a href=&quot;https://github.com/ZipCPU/icozip/blob/master/rtl/icozip/spixpress.v&quot;&gt;the
design&lt;/a&gt;
would be able to accept a request while the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Serial_Perip-heral_Interface&quot;&gt;SPI&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt; operation is ongoing.&lt;/p&gt;

    &lt;p&gt;This new cover property failed.&lt;/p&gt;

    &lt;p&gt;This was really annoying, because a failed cover statement doesn’t yield a
&lt;a href=&quot;/blog/2017/07/31/vcd.html&quot;&gt;trace&lt;/a&gt;.  A failed &lt;code class=&quot;highlighter-rouge&quot;&gt;assert&lt;/code&gt;
will yield a
&lt;a href=&quot;/blog/2017/07/31/vcd.html&quot;&gt;trace&lt;/a&gt;, showing you what’s
going wrong within your design.  Not so with a failed cover.  Instead, you
only get a &lt;a href=&quot;/blog/2017/07/31/vcd.html&quot;&gt;trace&lt;/a&gt;
from a cover statement when (and if) the cover statement succeeds.
Therefore, I had to create a new cover statement one step prior to the
cover that failed to try to see where it failed.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;ol start=&quot;22&quot;&gt;
  &lt;li&gt;
    &lt;p&gt;Then the cycle repeated again, until I (eventually) found a careless
assumption I had made early
on in my design.  While this assumption had made it easier to get
&lt;a href=&quot;https://github.com/ZipCPU/icozip/blob/master/rtl/icozip/spixpress.v&quot;&gt;the design&lt;/a&gt;
off the ground, it was inappropriate for a final design.  Removing this
careless assumption fixed the problem, so
&lt;a href=&quot;https://github.com/ZipCPU/icozip/blob/master/rtl/icozip/spixpress.v&quot;&gt;the design&lt;/a&gt;
then passed the updated cover check.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;At this point it was now time to clean up a bit.
&lt;a href=&quot;https://github.com/ZipCPU/icozip/blob/master/rtl/icozip/spixpress.v&quot;&gt;The design&lt;/a&gt;
had at one time passed &lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal
verification&lt;/a&gt;
in a non-cover mode, but it had been some time since this
mode had been checked and there had been some changes.  Therefore, I
returned to the &lt;a href=&quot;https://symbiyosys.readthedocs.io/en/latest&quot;&gt;SymbiYosys&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/icozip/blob/master/bench/formal/spixpress.sby&quot;&gt;configuration file&lt;/a&gt;
and created a series of four tasks: Two of these tasks apply to
the non pipelined version, and two apply to the pipelined version.
Broken out another way, two of the tasks are
&lt;a href=&quot;/formal/2018/03/10/induction-exercise.html&quot;&gt;induction&lt;/a&gt;
proofs and two are cover proofs.  The final
&lt;a href=&quot;https://symbiyosys.readthedocs.io/en/latest&quot;&gt;SymbiYosys&lt;/a&gt; &lt;a href=&quot;https://github.com/ZipCPU/icozip/blob/master/bench/formal/spixpress.sby&quot;&gt;configuration
file&lt;/a&gt;
now looked like:&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;[tasks]
safety		nopipe
safety_pipe	pipe
cover		nopipe
cover_pipe	pipe

[options]
safety:      mode prove
safety_pipe: mode prove
cover:       mode cover
cover_pipe:  mode cover
depth 70

[engines]
smtbmc

[script]
read_verilog -formal fwb_slave.v
read_verilog -formal spixpress.v
cover:      chparam -set F_OPT_COVER 1 spixpress
cover_pipe: chparam -set F_OPT_COVER 1 spixpress
nopipe:	chparam -set OPT_PIPE   0 spixpress
pipe:	chparam -set OPT_PIPE   1 spixpress
prep -top spixpress

[files]
fwb_slave.v
../../rtl/icozip/spixpress.v&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;ol start=&quot;24&quot;&gt;
  &lt;li&gt;
    &lt;p&gt;Sadly, some of the functionality that had worked earlier had now broken, so
I went back through the cycle of updating the logic, the properties, running
&lt;a href=&quot;https://symbiyosys.readthedocs.io/en/latest&quot;&gt;SymbiYosys&lt;/a&gt;, and looking
at &lt;a href=&quot;/blog/2017/07/31/vcd.html&quot;&gt;trace files&lt;/a&gt;.&lt;/p&gt;

    &lt;p&gt;This step gets difficult, though, since the
&lt;a href=&quot;https://symbiyosys.readthedocs.io/en/latest&quot;&gt;SymbiYosys&lt;/a&gt; will print its
result on the last line of processing any task, and then immediately move
on to the next task.  That means that if you want to know what task passed
and which didn’t, you’ll need to go back and examine the various result
directories.&lt;/p&gt;

    &lt;p&gt;Hence, just to make certain I hadn’t missed anything, I listed all of the
&lt;a href=&quot;https://symbiyosys.readthedocs.io/en/latest&quot;&gt;SymbiYosys&lt;/a&gt;
output directories.  Specifically, I was looking for an empty file named
&lt;code class=&quot;highlighter-rouge&quot;&gt;PASS&lt;/code&gt; in all of the various output directories.  Other possibilities would
include &lt;code class=&quot;highlighter-rouge&quot;&gt;ERROR&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;FAIL&lt;/code&gt;, and &lt;code class=&quot;highlighter-rouge&quot;&gt;UNKNOWN&lt;/code&gt;.  Each of these would’ve indicated
a problem that I’d need to go back and revisit.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;% ls spixpress*/
spixpress_cover/:
config.sby  engine_0  logfile.txt  model  PASS  spixpress_cover.xml  src

spixpress_cover_pipe/:
config.sby  engine_0  logfile.txt  model  PASS  spixpress_cover_pipe.xml  src

spixpress_safety/:
config.sby  engine_0  logfile.txt  model  PASS  spixpress_safety.xml  src

spixpress_safety_pipe/:
config.sby  engine_0  logfile.txt  model  PASS  spixpress_safety_pipe.xml  src
%&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;ol start=&quot;25&quot;&gt;
  &lt;li&gt;As a final step, I re-ran
&lt;a href=&quot;https://www.clifford.at/yosys&quot;&gt;yosys&lt;/a&gt; to measure the logic usage of
&lt;a href=&quot;https://github.com/ZipCPU/icozip/blob/master/rtl/icozip/spixpress.v&quot;&gt;the design&lt;/a&gt;.
My goal was to reassure myself that, yes, I could
truly make a low logic design.  Much to my surprise, the amount of logic
used had jumped from &lt;code class=&quot;highlighter-rouge&quot;&gt;156&lt;/code&gt; cells to &lt;code class=&quot;highlighter-rouge&quot;&gt;243&lt;/code&gt;.  This number puzzled me, so
I returned to
&lt;a href=&quot;https://github.com/ZipCPU/icozip/blob/master/rtl/icozip/spixpress.v&quot;&gt;the design&lt;/a&gt;
and turn off the &lt;code class=&quot;highlighter-rouge&quot;&gt;OPT_PIPE&lt;/code&gt; flag.  The logic usage level
returned to &lt;code class=&quot;highlighter-rouge&quot;&gt;156&lt;/code&gt; cells again.  I wasn’t expecting this, but at that point
in the evening it was too late to chase down the cause of the difference.
My design passed &lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal verification&lt;/a&gt;,
and so I headed to bed.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;What about those &lt;a href=&quot;https://en.wikipedia.org/wiki/SystemVerilog&quot;&gt;SystemVerilog&lt;/a&gt;
&lt;a href=&quot;http://www.asic-world.com/systemverilog/assertions4.html&quot;&gt;sequences&lt;/a&gt;
at the end of the file?  I still
haven’t tested them (yet), and at this point I’m not certain if I will.&lt;/p&gt;

&lt;p&gt;This isn’t the end of this low-logic &lt;a href=&quot;https://en.wikipedia.org/wiki/Serial_Perip-heral_Interface&quot;&gt;SPI&lt;/a&gt; &lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt; module with the
&lt;a href=&quot;https://icoboard.org&quot;&gt;ICO board&lt;/a&gt;, but it is the end of last night’s
development.&lt;/p&gt;

&lt;h2 id=&quot;next-steps&quot;&gt;Next Steps&lt;/h2&gt;

&lt;p&gt;I do intend to come back to &lt;a href=&quot;https://github.com/ZipCPU/icozip/blob/master/rtl/icozip/spixpress.v&quot;&gt;this
design&lt;/a&gt;
again later.  It’s not done.  It is however part of a longer term project
associated with getting the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
up and running on the
&lt;a href=&quot;https://icoboard.org&quot;&gt;ICO board&lt;/a&gt;.  To support that project, I’ll want to build
a C++ &lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt; controller to allow
me to write programs to the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt;.  Sadly, this will need to
be a new &lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt; controller,
since I just redesigned the interface necessary for erasing and then programming
the &lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;In general, I’ve been rather disappointed that the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
that worked so nicely on several Xilinx boards has yet to work on the
&lt;a href=&quot;https://icoboard.org&quot;&gt;ICO board&lt;/a&gt;.  I plan to discuss one of the really
annoying differences in an upcoming article.  However, to get to the point
where the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; works on this board
I will need to integrate &lt;a href=&quot;https://github.com/ZipCPU/icozip/blob/master/rtl/icozip/spixpress.v&quot;&gt;this flash
controller&lt;/a&gt;
into the overall design, and then finish building the &lt;a href=&quot;/blog/2017/06/21/looking-at-verilator.html&quot;&gt;Verilator
simulator&lt;/a&gt;
using it.  Then, and only then, after &lt;a href=&quot;https://github.com/ZipCPU/icozip/blob/master/rtl/icozip/spixpress.v&quot;&gt;this new controller
design&lt;/a&gt;
passes my tests in simulation, supported by a to-be-written C++ controller,
will I attempt to place it onto the actual &lt;a href=&quot;https://icoboard.org&quot;&gt;ICO board&lt;/a&gt;
hardware.&lt;/p&gt;

&lt;p&gt;Yes, I understand there are individuals who can build and verify things using
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal methods&lt;/a&gt; alone.
These individuals talk about “formal signoff”, or being able to certify that a
design is ready for tape-out using &lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal
methods&lt;/a&gt; alone.
I would love to be able to get there.  It’s one of my personal development
goals.  However, I’m not there yet.  Therefore, everything I do needs to
be both &lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formally
verified&lt;/a&gt; (the easy part
to set up), and then it needs to pass simulation.&lt;/p&gt;
&lt;hr /&gt;&lt;p&gt;&lt;em&gt;And they took him, and brought him unto Areopagus, saying, May we know what this new doctrine, whereof thou speakest, is? (Acts 17:19)&lt;/em&gt;</description>
        <pubDate>Sat, 14 Jul 2018 00:00:00 -0400</pubDate>
        <link>https://zipcpu.com/formal/2018/07/14/dev-cycle.html</link>
        <guid isPermaLink="true">https://zipcpu.com/formal/2018/07/14/dev-cycle.html</guid>
        
        
        <category>formal</category>
        
      </item>
    
      <item>
        <title>Formally Verifying Memory and Cache Components</title>
        <description>&lt;p&gt;While I was in Italy for
&lt;a href=&quot;https://orconf.org/2016&quot;&gt;ORCONF 2016&lt;/a&gt;
I started scribbling out a
&lt;a href=&quot;https://en.wikipedia.org/wiki/CPU_cache&quot;&gt;data cache&lt;/a&gt;
for the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;.  In many ways I
had to.  The
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
compared nicely to many other
&lt;a href=&quot;https://en.wikipedia.org/wiki/Soft_microprocessor&quot;&gt;soft-core CPU&lt;/a&gt;
architectures in all but two important comparisons–the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
had neither
&lt;a href=&quot;https://en.wikipedia.org/wiki/CPU_cache&quot;&gt;data cache&lt;/a&gt; nor
&lt;a href=&quot;https://en.wikipedia.org/wiki/Memory_management_unit&quot;&gt;MMU&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;That was almost two years ago.&lt;/p&gt;

&lt;p&gt;Since that time, I rewrote that
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/dcache.v&quot;&gt;data cache draft&lt;/a&gt;
many times over, but never managed to bring my effort to the finish line.
The design was just never complete.  Indeed, I never got so far as to write
the bench test for it.&lt;/p&gt;

&lt;p&gt;Two months ago, I tried again.  This time, I had a trick up my sleeve that I
never had before: I now understood how to
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formally&lt;/a&gt;
describe a memory controller.  Using
&lt;a href=&quot;http://www.clifford.at/yosys&quot;&gt;Yosys&lt;/a&gt;,
the design became much easier to build.  I could move quickly from one fault
to another, fixing one problem after another until I had a strong
confidence that the design would work.  No, I haven’t tested it on hardware
yet, but I know that when I do it will be close to all it needs to be.&lt;/p&gt;

&lt;p&gt;How much of the design did I evaluate?  Using
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal methods&lt;/a&gt;,
I only ever needed to evaluate about 20 clocks worth of the design.
I evaluated both the first 20 clocks of the design, as well as an
arbitrary set of 20 clock periods somewhere in the middle of time.  That was it.
Put together, I now know
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/dev/rtl/core/dcache.v&quot;&gt;this data cache&lt;/a&gt;
will maintain it’s
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal properties&lt;/a&gt;
for all time.&lt;/p&gt;

&lt;p&gt;This is in strong contrast to using a &lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_Functional_Model&quot;&gt;Bus Functional Model
(BFM)&lt;/a&gt;
to test whether a memory interface design works.  Consider, for example, this
&lt;a href=&quot;https://opencores.org/project/wishbone_bfm&quot;&gt;Wishbone BFM&lt;/a&gt; by
Andrew Mulcock and posted on &lt;a href=&quot;https://opencores.org&quot;&gt;OpenCores&lt;/a&gt;.  It is built
around a series of canned memory operations that can be applied to any
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;Wishbone bus&lt;/a&gt;.  It
then uses random numbers and thousands (millions?) of randomly generated tests
to verify that a design works.&lt;/p&gt;

&lt;p&gt;Wouldn’t you rather just check two sets of twenty steps, and then know that
your design will work for all time?&lt;/p&gt;

&lt;p&gt;This is the benefit of
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal methods&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;When dealing with memories, though, there is a simple trick you need to know
to make this happen.  That trick will be the focus of this article.  First,
I’ll explain the trick in the next section, we’ll then discuss how the trick
can be applied to
&lt;a href=&quot;https://en.wikipedia.org/wiki/CPU_cache&quot;&gt;caches&lt;/a&gt;,
finally we’ll walk through the design of a
&lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/rtl/memdev.v&quot;&gt;block RAM&lt;/a&gt;
controller connected to the
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;Wishbone bus&lt;/a&gt;
as an example of how this trick can be applied.&lt;/p&gt;

&lt;h2 id=&quot;formal-verifying-memory-like-components&quot;&gt;Formal Verifying Memory-like Components&lt;/h2&gt;

&lt;p&gt;Okay, so here’s the trick to
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formally verifying&lt;/a&gt;
memory-like components: assume an arbitrary address, construct the data at
that address, and then verify that transactions to/from this one arbitrary
address all match the data at this address.&lt;/p&gt;

&lt;p&gt;Yes, it is that simple–&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formally
verifying&lt;/a&gt;
one &lt;em&gt;arbitrary&lt;/em&gt; address is sufficient to
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formally verify&lt;/a&gt;
the entire memory space.&lt;/p&gt;

&lt;p&gt;Let’s walk through this concept a bit more.  We’ll start with an arbitrary
address.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;(* anyconst *)	wire	[AW-1:0]	f_addr;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Since we want the solver to pick any constant address, we’ll use
&lt;a href=&quot;http://www.clifford.at/yosys&quot;&gt;Yosys&lt;/a&gt;’s
&lt;code class=&quot;highlighter-rouge&quot;&gt;anyconst&lt;/code&gt; attribute to capture this property.&lt;/p&gt;

&lt;p&gt;We’re also going to need to start with the piece of data at that address.
In this case, we’ll just declare &lt;code class=&quot;highlighter-rouge&quot;&gt;f_data&lt;/code&gt; as a register and initialize it
to the initial value of the memory.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;reg	[DW-1:0]	f_data;

initial f_data = mem[f_addr];&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Given these two values, we can now make our only assumption about them and
our memory.  After setting &lt;code class=&quot;highlighter-rouge&quot;&gt;f_data&lt;/code&gt; to its initial value, we’ll then assert
that these two values match for the rest of time.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(*)
	assert(mem[f_addr] == f_data);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;We’ll also want to assert that any memory read from this address must also
return &lt;code class=&quot;highlighter-rouge&quot;&gt;f_data&lt;/code&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
if ((f_past_valid)
		// A wishbone transaction
		&amp;amp;&amp;amp;($past(i_wb_stb))
		// Reading from our memory
		&amp;amp;&amp;amp;(!$past(i_wb_we))
		// At this address
		&amp;amp;&amp;amp;($past(i_wb_addr == f_addr)))
	assert(o_wb_data == f_data);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;That’s all that’s required for read only memories.&lt;/p&gt;

&lt;p&gt;For memories with a write capability we’ll also need to change
our &lt;code class=&quot;highlighter-rouge&quot;&gt;f_data&lt;/code&gt; value on any memory write.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
// A wishbone transaction
if ((i_wb_stb)
		// writing to our memory
		&amp;amp;&amp;amp;(i_wb_we)
		// At this address
		&amp;amp;&amp;amp;(i_wb_addr == f_addr))
	// Then overwrite f_data
	f_data &amp;lt;= i_wb_data;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;That’s all it takes to
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formally&lt;/a&gt;
describe and verify a memory.  Pretty simple, no?&lt;/p&gt;

&lt;h3 id=&quot;properties-of-a-read-only-cache&quot;&gt;Properties of a read-only cache&lt;/h3&gt;

&lt;p&gt;But what about a
&lt;a href=&quot;https://en.wikipedia.org/wiki/CPU_cache&quot;&gt;cache&lt;/a&gt;?
I began this post by talking about implementing a
&lt;a href=&quot;https://en.wikipedia.org/wiki/CPU_cache&quot;&gt;cache&lt;/a&gt; for the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;.
What does it take to
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formally verify&lt;/a&gt; a
&lt;a href=&quot;https://en.wikipedia.org/wiki/CPU_cache&quot;&gt;cache&lt;/a&gt;?&lt;/p&gt;

&lt;p&gt;In the case of a read only
&lt;a href=&quot;https://en.wikipedia.org/wiki/CPU_cache&quot;&gt;cache&lt;/a&gt;,
such as an instruction
&lt;a href=&quot;https://en.wikipedia.org/wiki/CPU_cache&quot;&gt;cache&lt;/a&gt;,
the same basic principle applies.  You will need to support three basic
properties–roughly mirroring exactly those same basic properties that
we just discussed above.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;On any read resulting from a
&lt;a href=&quot;https://en.wikipedia.org/wiki/CPU_cache#CACHE-MISS&quot;&gt;cache miss&lt;/a&gt;
for address &lt;code class=&quot;highlighter-rouge&quot;&gt;f_addr&lt;/code&gt; from memory, &lt;code class=&quot;highlighter-rouge&quot;&gt;f_data&lt;/code&gt; is the &lt;em&gt;assumed&lt;/em&gt; result.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;If &lt;code class=&quot;highlighter-rouge&quot;&gt;f_addr&lt;/code&gt; is currently a valid address within the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Cache_(computing)&quot;&gt;cache&lt;/a&gt;,
then you’ll need to &lt;em&gt;assert&lt;/em&gt; that &lt;code class=&quot;highlighter-rouge&quot;&gt;f_data&lt;/code&gt; is the
&lt;a href=&quot;https://en.wikipedia.org/wiki/CPU_cache&quot;&gt;cache&lt;/a&gt;
value at that location.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;On any return from the
&lt;a href=&quot;https://en.wikipedia.org/wiki/CPU_cache&quot;&gt;cache&lt;/a&gt;
where &lt;code class=&quot;highlighter-rouge&quot;&gt;f_addr&lt;/code&gt; is the address of the value
returned, then &lt;em&gt;assert&lt;/em&gt; that &lt;code class=&quot;highlighter-rouge&quot;&gt;f_data&lt;/code&gt; is result.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Remember the rule: assume inputs, assert local state and outputs.&lt;/p&gt;

&lt;p&gt;Let’s look at an example of each of these properties.&lt;/p&gt;

&lt;p&gt;The first property is to assume that the response from a bus transaction,
reading from &lt;code class=&quot;highlighter-rouge&quot;&gt;f_addr&lt;/code&gt;, must return &lt;code class=&quot;highlighter-rouge&quot;&gt;f_data&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Having done this a couple of times, I often find it valuable to create a wire
just to capture the logic of whether the current return is the return of
interest.  Not only does this logic simplify the assumption, but it also
has the additional property of creating a value in the trace
file, making it easier to trouble shoot what may be end up being very complex
logic.  In this case, let’s use &lt;code class=&quot;highlighter-rouge&quot;&gt;f_this_return&lt;/code&gt; to represent if the &lt;code class=&quot;highlighter-rouge&quot;&gt;f_addr&lt;/code&gt;
value is the current one being returned from the bus.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;wire	f_this_return;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;What value should this wire have?  Well, if you are incrementing &lt;code class=&quot;highlighter-rouge&quot;&gt;o_wb_addr&lt;/code&gt;
with every address, and if &lt;code class=&quot;highlighter-rouge&quot;&gt;f_outstanding&lt;/code&gt; captures how many requests are
outstanding, then the logic describing whether or not the current return
from the bus is the &lt;code class=&quot;highlighter-rouge&quot;&gt;f_addr&lt;/code&gt; value might look like:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;assign	f_this_return = (o_wb_cyc)&amp;amp;&amp;amp;(i_wb_ack)
		&amp;amp;&amp;amp;(o_wb_addr-f_outstanding == f_addr);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Of course, your logic might vary with your needs in your own
&lt;a href=&quot;https://en.wikipedia.org/wiki/CPU_cache&quot;&gt;cache&lt;/a&gt; design.&lt;/p&gt;

&lt;p&gt;Using this &lt;code class=&quot;highlighter-rouge&quot;&gt;f_this_return&lt;/code&gt; value, we then want to assume that any response
from the bus when &lt;code class=&quot;highlighter-rouge&quot;&gt;f_this_return&lt;/code&gt; is true must equal &lt;code class=&quot;highlighter-rouge&quot;&gt;f_data&lt;/code&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(*)
if (f_this_return)
	assume(i_wb_data == f_data);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;That’s step one–&lt;em&gt;assume&lt;/em&gt; that the input matches.&lt;/p&gt;

&lt;p&gt;For the second property, we’ll need to &lt;em&gt;assert&lt;/em&gt;
that if our arbitrary address is found within the
&lt;a href=&quot;https://en.wikipedia.org/wiki/CPU_cache&quot;&gt;cache&lt;/a&gt;,
then the
&lt;a href=&quot;https://en.wikipedia.org/wiki/CPU_cache&quot;&gt;cache&lt;/a&gt;
value at that location must be &lt;code class=&quot;highlighter-rouge&quot;&gt;f_data&lt;/code&gt;.
You’ll need this assertion in order to get your design to pass
&lt;a href=&quot;/blog/2018/03/10/induction-exercise.html&quot;&gt;induction&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;This idea is a little bit more difficult to communicate–especially to someone
who hasn’t dealt with
&lt;a href=&quot;https://en.wikipedia.org/wiki/CPU_cache&quot;&gt;caches&lt;/a&gt;
before.  (&lt;a href=&quot;https://www.blueletterbible.org/kjv/jas/4/15&quot;&gt;If the Lord is
willing&lt;/a&gt;,
we’ll come back and discuss how to build a
&lt;a href=&quot;https://en.wikipedia.org/wiki/CPU_cache&quot;&gt;cache&lt;/a&gt;
like this later.)&lt;/p&gt;

&lt;p&gt;In the two
implementations that I’ve built, all &lt;a href=&quot;https://en.wikipedia.org/wiki/CPU_cache#Direct-mapped_cache&quot;&gt;direct mapped
caches&lt;/a&gt;,
I’ve split the address into
three basic sections, all shown below in Fig 1.  The
bottom &lt;code class=&quot;highlighter-rouge&quot;&gt;CS&lt;/code&gt; bits are used to describe a location within the
&lt;a href=&quot;https://en.wikipedia.org/wiki/CPU_cache&quot;&gt;cache&lt;/a&gt; memory, and
the bottom &lt;code class=&quot;highlighter-rouge&quot;&gt;LS&lt;/code&gt; of those bits are used to describe a location within a
given
&lt;a href=&quot;https://en.wikipedia.org/wiki/CPU_cache&quot;&gt;cache&lt;/a&gt;
line.  I like to think of these values as the “cache size”
and the “line size” respectively, even though they are really the
log based two of those sizes.&lt;/p&gt;

&lt;p&gt;The third component of the address is the “tag”.  This is the top portion of the
address, from &lt;code class=&quot;highlighter-rouge&quot;&gt;LS&lt;/code&gt; on upwards.&lt;/p&gt;

&lt;p&gt;You can see an address broken down into these separate components in
Fig 1 below.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 1. Components of a Cache Address&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/cache-tag.svg&quot; alt=&quot;&quot; width=&quot;640&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;In this picture, you can see how the lowest two bits aren’t really part of the
word address.  These are the octet address bits, describing an octet’s position
within a 32-bit data word.  We’ll ignore these
sub-word address bits at this stage, though, focusing only on word addresses.&lt;/p&gt;

&lt;p&gt;Second, you can see how the lowest &lt;code class=&quot;highlighter-rouge&quot;&gt;LS&lt;/code&gt; bits are the
&lt;a href=&quot;https://en.wikipedia.org/wiki/CPU_cache&quot;&gt;cache&lt;/a&gt;
line address.  These bits are not part of the tag, since all of the bits
within a given
&lt;a href=&quot;https://en.wikipedia.org/wiki/CPU_cache&quot;&gt;cache&lt;/a&gt;
line will share the same
&lt;a href=&quot;https://en.wikipedia.org/wiki/CPU_cache&quot;&gt;cache&lt;/a&gt; tag bits.&lt;/p&gt;

&lt;p&gt;The &lt;a href=&quot;https://en.wikipedia.org/wiki/CPU_cache&quot;&gt;cache&lt;/a&gt;
itself is maintained as three arrays.  The first, simply called
&lt;code class=&quot;highlighter-rouge&quot;&gt;cache&lt;/code&gt; below, uses the lower &lt;code class=&quot;highlighter-rouge&quot;&gt;CS&lt;/code&gt; bits to address word sized memory values.
This is the block RAM data structure containing the values within the
&lt;a href=&quot;https://en.wikipedia.org/wiki/CPU_cache&quot;&gt;cache&lt;/a&gt; itself.
The second array is a bit vector of &lt;code class=&quot;highlighter-rouge&quot;&gt;CS-LS&lt;/code&gt; bits called &lt;code class=&quot;highlighter-rouge&quot;&gt;cache_line_valid&lt;/code&gt;.
This tells you which
&lt;a href=&quot;https://en.wikipedia.org/wiki/CPU_cache&quot;&gt;cache&lt;/a&gt;
lines have valid values within them.
The third array is also indexed by the upper &lt;code class=&quot;highlighter-rouge&quot;&gt;CS-LS&lt;/code&gt; bits of the &lt;code class=&quot;highlighter-rouge&quot;&gt;CS&lt;/code&gt; bit
&lt;a href=&quot;https://en.wikipedia.org/wiki/CPU_cache&quot;&gt;cache&lt;/a&gt;
address.  This is an array of “tags”, called &lt;code class=&quot;highlighter-rouge&quot;&gt;cache_tag&lt;/code&gt; below.
Hence, any time 1) a
&lt;a href=&quot;https://en.wikipedia.org/wiki/CPU_cache&quot;&gt;cache&lt;/a&gt;
line is valid, and 2) its tag matches &lt;code class=&quot;highlighter-rouge&quot;&gt;f_addr&lt;/code&gt;,
then 3) the value within the
&lt;a href=&quot;https://en.wikipedia.org/wiki/CPU_cache&quot;&gt;cache&lt;/a&gt;
must match &lt;code class=&quot;highlighter-rouge&quot;&gt;f_data&lt;/code&gt; as well.&lt;/p&gt;

&lt;p&gt;Here’s how we’d express that.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(*)
	// If the cache line itself is valid
if ((cache_line_valid[f_addr[CS-LS-1:0])
	//
	// and if this valid cache line&#39;s tag matches the top
	// &quot;tag&quot; bits of our address
	&amp;amp;&amp;amp;(cache_tag[CS-LS-1:0]==f_addr[AW-1:LS]))
	//
	// then assert that this is the value in the cache
	assert(cache[f_addr[CS-1:0]] == f_data);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;We’ll have to come back to this later and provide a proper description of
how to build a
&lt;a href=&quot;https://en.wikipedia.org/wiki/CPU_cache&quot;&gt;cache&lt;/a&gt;.  For
now, this is the basics of how you would test
first that &lt;code class=&quot;highlighter-rouge&quot;&gt;f_addr&lt;/code&gt; is in the
&lt;a href=&quot;https://en.wikipedia.org/wiki/CPU_cache&quot;&gt;cache&lt;/a&gt;, and second that
the value &lt;code class=&quot;highlighter-rouge&quot;&gt;f_data&lt;/code&gt; is found at that location within the
&lt;a href=&quot;https://en.wikipedia.org/wiki/CPU_cache&quot;&gt;cache&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;We now move on to the third
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal property&lt;/a&gt;
for read-only
&lt;a href=&quot;https://en.wikipedia.org/wiki/CPU_cache&quot;&gt;caches&lt;/a&gt;,
that upon any return from the
&lt;a href=&quot;https://en.wikipedia.org/wiki/CPU_cache&quot;&gt;cache&lt;/a&gt;
that comes from the &lt;code class=&quot;highlighter-rouge&quot;&gt;f_addr&lt;/code&gt; address, the value returned should be &lt;code class=&quot;highlighter-rouge&quot;&gt;f_data&lt;/code&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(*)
if ((output_valid)&amp;amp;&amp;amp;(output_address == f_addr))
	assert(output_word == f_data);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;These three properties, the assumption regarding the input, the assertion
regarding the internal state of the
&lt;a href=&quot;https://en.wikipedia.org/wiki/CPU_cache&quot;&gt;cache&lt;/a&gt;,
and the assertion about the output, are all that is needed to
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formally&lt;/a&gt;
describe the required functionality of any read-only
&lt;a href=&quot;https://en.wikipedia.org/wiki/CPU_cache&quot;&gt;cache&lt;/a&gt;.
That said, you might need to adjust how you express
these properties for your design, as not all
&lt;a href=&quot;https://en.wikipedia.org/wiki/CPU_cache&quot;&gt;caches&lt;/a&gt;
have the same structure or the same register and memory names.&lt;/p&gt;

&lt;p&gt;If you recall, we discussed these properties earlier–in our
&lt;a href=&quot;/zipcpu/2018/03/21/dblfetch.html&quot;&gt;pipelined prefetch
article&lt;/a&gt;.  That article
discussed a simple two-element rolling instruction
&lt;a href=&quot;https://en.wikipedia.org/wiki/CPU_cache&quot;&gt;cache&lt;/a&gt;
design.&lt;/p&gt;

&lt;h3 id=&quot;properties-of-a-read-write-cache&quot;&gt;Properties of a read-write cache&lt;/h3&gt;

&lt;p&gt;What about a read-write
&lt;a href=&quot;https://en.wikipedia.org/wiki/CPU_cache&quot;&gt;cache&lt;/a&gt;,
such as the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;’s (brand new)
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/dev/rtl/core/dcache.v&quot;&gt;data cache&lt;/a&gt;
that I referenced above?  In this case, all of the properties of a read-only
&lt;a href=&quot;https://en.wikipedia.org/wiki/CPU_cache&quot;&gt;cache&lt;/a&gt;,
listed above, still need to hold.  In addition, we also need to require that
&lt;code class=&quot;highlighter-rouge&quot;&gt;f_data&lt;/code&gt; change upon any write as well.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
if ((write_request)&amp;amp;&amp;amp;(write_address == f_addr))
	f_data &amp;lt;= write_value;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;If your data value is
&lt;a href=&quot;/zipcpu/2017/05/29/select-lines.html&quot;&gt;octet addressable&lt;/a&gt;,
and your word size is 32-bits,
you’ll need to do a bit more work–but we’ll get to that below.&lt;/p&gt;

&lt;p&gt;You may also need to be careful with the timing of this write–it will need to
match the timing of any actual write to the
&lt;a href=&quot;https://en.wikipedia.org/wiki/CPU_cache&quot;&gt;cache&lt;/a&gt; memory or the second property
will fail.&lt;/p&gt;

&lt;p&gt;That’s basically it.  These simple and basic properties are all that is needed
to &lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formally verify&lt;/a&gt;
any type of memory–whether it be block RAM, an external
&lt;a href=&quot;https://en.wikipedia.org/wiki/Synchronous_dynamic_random-access_memory&quot;&gt;SDRAM&lt;/a&gt;
or &lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash device&lt;/a&gt;,
a read-only
&lt;a href=&quot;https://en.wikipedia.org/wiki/CPU_cache&quot;&gt;cache&lt;/a&gt;
or even a read-write
&lt;a href=&quot;https://en.wikipedia.org/wiki/CPU_cache&quot;&gt;cache&lt;/a&gt;.
The approach is &lt;em&gt;very&lt;/em&gt; versatile.&lt;/p&gt;

&lt;h2 id=&quot;block-ram&quot;&gt;Block RAM&lt;/h2&gt;

&lt;p&gt;Just to drive this lesson home, let’s work through the example of a &lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/rtl/memdev.v&quot;&gt;block RAM
memory controller&lt;/a&gt;,
using this same approach, and let’s verify this block RAM responds
as it should.&lt;/p&gt;

&lt;p&gt;If you’ve been building
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
designs for long, you’ll know that creating a basic &lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/rtl/memdev.v&quot;&gt;block RAM
component&lt;/a&gt;,
in Verilog consists of only a few lines of code.&lt;/p&gt;

&lt;p&gt;First, we’ll need to declare our memory.  In this declaration &lt;code class=&quot;highlighter-rouge&quot;&gt;DW&lt;/code&gt; is the
width of the data words contained in the memory, and &lt;code class=&quot;highlighter-rouge&quot;&gt;AW&lt;/code&gt; is the number of
bits required to address it.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	reg	[(DW-1):0]	mem	[0:((1&amp;lt;&amp;lt;AW)-1)];&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Reading from memory is as simple as,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	o_wb_addr &amp;lt;= mem[i_wb_addr];&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;and writing to memory is only a touch more difficult.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
begin
	if ((i_wb_stb)&amp;amp;&amp;amp;(i_wb_we)&amp;amp;&amp;amp;(i_wb_sel[3]))
		mem[w_addr][31:24] &amp;lt;= w_data[31:24];

	if ((i_wb_stb)&amp;amp;&amp;amp;(i_wb_we)&amp;amp;&amp;amp;(i_wb_sel[2]))
		mem[w_addr][23:16] &amp;lt;= w_data[23:16];

	if ((i_wb_stb)&amp;amp;&amp;amp;(i_wb_we)&amp;amp;&amp;amp;(i_wb_sel[1]))
		mem[w_addr][15: 8] &amp;lt;= w_data[15:8];

	if ((i_wb_stb)&amp;amp;&amp;amp;(i_wb_we)&amp;amp;&amp;amp;(i_wb_sel[0]))
		mem[w_addr][ 7: 0] &amp;lt;= w_data[7:0];
end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Notice how we needed to check whether or not each individual octet was
being written, and then &lt;a href=&quot;/zipcpu/2017/05/29/select-lines.html&quot;&gt;only set that octet to the new
value&lt;/a&gt; if so.&lt;/p&gt;

&lt;p&gt;We’ve discussed both of these operations before.&lt;/p&gt;

&lt;p&gt;I maintain a &lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/rtl/memdev.v&quot;&gt;block RAM
controller&lt;/a&gt;
based upon these principles in the
&lt;a href=&quot;https://github.com/ZipCPU/zbasic&quot;&gt;ZBasic repository&lt;/a&gt;.  We’ll examine
use this design for today’s discussion.&lt;/p&gt;

&lt;p&gt;There are a couple of differences in &lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/rtl/memdev.v&quot;&gt;this block RAM
controller&lt;/a&gt; from
what we’ve just discussed above, although most of them are fairly superficial.
These come from the many years that I’ve worked with this controller.  For
example, on one high speed design I discovered I couldn’t get the request
from a corner of the chip to the dedicated block RAM on-chip hardware in
the center of the chip.  I managed to solve this by adding an extra clock
to memory, but made that extra clock optional–controlled by the parameter,
&lt;code class=&quot;highlighter-rouge&quot;&gt;EXTRACLOCK&lt;/code&gt;.  Recently I added a preload option controlled by the parameter,
&lt;code class=&quot;highlighter-rouge&quot;&gt;HEXFILE&lt;/code&gt;, and even a ROM option, &lt;code class=&quot;highlighter-rouge&quot;&gt;OPT_ROM&lt;/code&gt; should you ever wish to create a
read-only memory instead of the more general purpose block RAM.&lt;/p&gt;

&lt;p&gt;The basic controller that we just outlined above still remains within that
&lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/rtl/memdev.v&quot;&gt;design&lt;/a&gt;.  Indeed,
even with the little feature bloat discussed above, the 
&lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/rtl/memdev.v&quot;&gt;design&lt;/a&gt;
remains quite simple and very readable.&lt;/p&gt;

&lt;h2 id=&quot;formal-properties&quot;&gt;Formal Properties&lt;/h2&gt;

&lt;p&gt;So what does it take to verify this controller?  We’ll skip through
some of the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_(computing)&quot;&gt;bus&lt;/a&gt;
properties and jump straight to the arbitrary address declaration.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	(* anyconst *)	wire	[(AW-1):0]	f_addr;
	reg	[31:0]		f_data;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;These two values are assigned as we discussed above.&lt;/p&gt;

&lt;p&gt;We then need to make certain that our RAM, at address &lt;code class=&quot;highlighter-rouge&quot;&gt;f_addr&lt;/code&gt;, starts with
the initial data found in `f_data.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	initial	assume(mem[f_addr] == f_data);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This guarantees that, should the memory be pre-loaded like a ROM, that the
two values start out identical.&lt;/p&gt;

&lt;p&gt;Next, just as we adjusted our memory value on any write, &lt;code class=&quot;highlighter-rouge&quot;&gt;mem[f_addr]&lt;/code&gt;,
we also need to adjust our data value, &lt;code class=&quot;highlighter-rouge&quot;&gt;f_data&lt;/code&gt;, upon any write to &lt;code class=&quot;highlighter-rouge&quot;&gt;f_addr&lt;/code&gt; as
well.  The code below is just a touch more complicated then we presented above,
simply because the code below only updates &lt;code class=&quot;highlighter-rouge&quot;&gt;f_data&lt;/code&gt; if the ROM option,
&lt;code class=&quot;highlighter-rouge&quot;&gt;OPT_ROM&lt;/code&gt;, is clear.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	generate if (!OPT_ROM)
	begin : F_MATCH_WRITES

		always @(posedge i_clk)
		if ((w_wstb)&amp;amp;&amp;amp;(f_addr == w_addr))
		begin
			if (w_sel[3])
				f_data[31:24] &amp;lt;= w_data[31:24];
			if (w_sel[2])
				f_data[23:16] &amp;lt;= w_data[23:16];
			if (w_sel[1])
				f_data[15: 8] &amp;lt;= w_data[15: 8];
			if (w_sel[0])
				f_data[ 7: 0] &amp;lt;= w_data[ 7: 0];
		end
	end else begin&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;In the case of a ROM, things are just a touch different.
First, we actually need to assign &lt;code class=&quot;highlighter-rouge&quot;&gt;f_data&lt;/code&gt; to be &lt;code class=&quot;highlighter-rouge&quot;&gt;mem[f_addr]&lt;/code&gt;.
This piece caught me by surprise.  It appears as though a value that isn’t
assigned is given an unknown value, &lt;code class=&quot;highlighter-rouge&quot;&gt;x&lt;/code&gt;, that can change on every clock tick.
Hence, we make certain we assign it here.&lt;/p&gt;

&lt;p&gt;Likewise, we assert that this value should never change–this is the ROM option
after all.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;		initial	f_data = mem[f_addr];

		always @(posedge i_clk)
		if (f_past_valid)
			assert(f_data == $past(f_data));

	end endgenerate&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;We conclude our proof by asserting that the memory at our our address &lt;code class=&quot;highlighter-rouge&quot;&gt;f_addr&lt;/code&gt;,
&lt;code class=&quot;highlighter-rouge&quot;&gt;mem[f_addr]&lt;/code&gt;, must always contain the value &lt;code class=&quot;highlighter-rouge&quot;&gt;f_data&lt;/code&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(*)
		assert(mem[f_addr] == f_data);
`endif
endmodule&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;Really, that’s all it takes–just a small number of assumptions and assertions
and you can verify that any memory controller will return the right data given
any address.  Further, notice how these same properties can be applied to both
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/pfcache.v&quot;&gt;instruction&lt;/a&gt;
and
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/dcache.v&quot;&gt;data caches&lt;/a&gt;,
to
&lt;a href=&quot;https://github.com/ZipCPU/xulalx25soc/blob/master/rtl/wbsdram.v&quot;&gt;SDRAM&lt;/a&gt; and
flash memory controllers, as well as our examples above.  Indeed, it was the
ease of describing how a
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/dev/rtl/core/dcache.v&quot;&gt;data cache&lt;/a&gt;
should work that made it so much easier to test when I finally finished
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/dev/rtl/core/dcache.v&quot;&gt;building it&lt;/a&gt;
two months ago.&lt;/p&gt;

&lt;p&gt;Would you believe this approach works for
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/zipmmu.v&quot;&gt;MMU verification&lt;/a&gt;
as well?  We may have to come back and discuss that later as well.  The approach
really is &lt;em&gt;very&lt;/em&gt; flexible!&lt;/p&gt;

&lt;p&gt;Now that you know the basics, we can come back to this topic later and discuss
how to build a basic
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/pfcache.v&quot;&gt;instruction&lt;/a&gt;
or &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/dev/rtl/core/dcache.v&quot;&gt;data cache&lt;/a&gt;,
such as the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; has.  That article
is still coming up.&lt;/p&gt;

&lt;hr /&gt;&lt;p&gt;&lt;em&gt;Then will I remember my covenant with Jacob, and also my covenant with Isaac, and also my covenant with Abraham will I remember; and I will remember the land. (Lev 26:42)&lt;/em&gt;</description>
        <pubDate>Fri, 13 Jul 2018 00:00:00 -0400</pubDate>
        <link>https://zipcpu.com/zipcpu/2018/07/13/memories.html</link>
        <guid isPermaLink="true">https://zipcpu.com/zipcpu/2018/07/13/memories.html</guid>
        
        
        <category>zipcpu</category>
        
      </item>
    
      <item>
        <title>Crossing clock domains with an Asynchronous FIFO</title>
        <description>&lt;p&gt;My first &lt;a href=&quot;https://en.wikipedia.org/wiki/VGA_connector&quot;&gt;VGA video&lt;/a&gt; project was
for a &lt;a href=&quot;https://store.digilentinc.com/basys-3-artix-7-fpga-trainer-board-recommended-for-introductory-users&quot;&gt;Basys3 board&lt;/a&gt;,
following &lt;a href=&quot;https://reference.digilentinc.com/reference/programmable-logic/basys-3/reference-manual&quot;&gt;Digilent’s
instructions&lt;/a&gt;.
The system ran at 100MHz with a 25MHz pixel clock that I could create by
dividing the 100MHz clock down in logic, rather than using a PLL.  In that
design, I could also divide the 100MHz clock by two in logic to reference
flash, and so I had a &lt;a href=&quot;https://opencores.org/project/qspiflash&quot;&gt;flash
controller&lt;/a&gt;
running from a 50MHz clock.  It was a complex design, partly because in order
to get enough bandwidth from flash to video I needed to compress the video
images on the flash device.  In the end, though, everything ran off of a single
100MHz clock–in spite of the various rates moving through the board.&lt;/p&gt;

&lt;p&gt;If only things stayed that easy.&lt;/p&gt;

&lt;p&gt;Since then, I’ve worked on a &lt;a href=&quot;https://github.com/ZipCPU/videozip&quot;&gt;video project&lt;/a&gt;
having a 148.5MHz pixel rate, but where the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Synchronous_dynamic_random-access_memory&quot;&gt;SDRAM memory&lt;/a&gt;
controller wanted a 100MHz clock.
Moving the pixels from the memory clock to the video and back again was a
challenge that I never got past–and part of the reason why the design doesn’t
quite work yet.&lt;/p&gt;

&lt;p&gt;I’ve also wanted to work on an &lt;a href=&quot;https://en.wikipedia.org/wiki/I2S&quot;&gt;I2S audio&lt;/a&gt;
system–also on &lt;a href=&quot;https://store.digilentinc.com/nexys-video-artix-7-fpga-trainer-board-for-multimedia-applications&quot;&gt;Digilent’s
Nexys Video board&lt;/a&gt;.
Like the 148.5MHz video system, the audio system on that board wants a clock
that isn’t an easy logical division of 100MHz: it wants a 49.152MHz clock.&lt;/p&gt;

&lt;p&gt;Both of these designs required having a data stream generated in one
&lt;a href=&quot;/blog/2017/10/20/cdc.html&quot;&gt;clock domain&lt;/a&gt;,
but consumed in another.&lt;/p&gt;

&lt;p&gt;Sure, I tried solving the problem using the techniques I’d discussed earlier
in my &lt;a href=&quot;/blog/2017/10/20/cdc.html&quot;&gt;clock domain
crossing&lt;/a&gt; article, but the results
… never really worked.  When passing streaming data around, the approaches
described in
&lt;a href=&quot;/blog/2017/10/20/cdc.html&quot;&gt;that article&lt;/a&gt; just weren’t
up to the task.  They were the wrong solution for the job.  A much more
appropriate solution would’ve been an &lt;a href=&quot;http://www.sunburst-design.com/papers/CummingsSNUG2002SJ_FIFO1.pdf&quot;&gt;asynchronous
FIFO&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;My journey with &lt;a href=&quot;http://www.sunburst-design.com/papers/CummingsSNUG2002SJ_FIFO1.pdf&quot;&gt;asynchronous
FIFO&lt;/a&gt;s
started out with the initial belief that they were a wizards concept
that I just didn’t understand.  Then I found a 
&lt;a href=&quot;http://www.sunburst-design.com/papers/CummingsSNUG2002SJ_FIFO1.pdf&quot;&gt;paper&lt;/a&gt;
by Cliff Cummings on the topic.  Not only did
&lt;a href=&quot;http://www.sunburst-design.com/papers/CummingsSNUG2002SJ_FIFO1.pdf&quot;&gt;this paper&lt;/a&gt;
describe what an &lt;a href=&quot;http://www.sunburst-design.com/papers/CummingsSNUG2002SJ_FIFO1.pdf&quot;&gt;asynchronous
FIFO&lt;/a&gt;
was, but it also made some amazing claims about the
&lt;a href=&quot;http://www.sunburst-design.com/papers/CummingsSNUG2002SJ_FIFO1.pdf&quot;&gt;FIFO&lt;/a&gt;’s
performance that weren’t apparent to me as I examined his code.
In particular, I wasn’t convinced that his implementation of an &lt;a href=&quot;http://www.sunburst-design.com/papers/CummingsSNUG2002SJ_FIFO1.pdf&quot;&gt;asynchronous
FIFO&lt;/a&gt;
wouldn’t overflow, wouldn’t underflow, or even that the
&lt;a href=&quot;/formal/2018/04/12/areset.html&quot;&gt;asynchronous reset&lt;/a&gt;’s
would work properly.&lt;/p&gt;

&lt;p&gt;At one time I even sat down with Cummings and asked him about his
implementation.  After chatting together, we both agreed the design might be
an ideal design to verify using &lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal
techniques&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;So let me dedicate this article to him.&lt;/p&gt;

&lt;p&gt;This article is also a gateway article to other articles discussing systems
that require &lt;a href=&quot;/blog/2017/10/20/cdc.html&quot;&gt;clock domain
crossings&lt;/a&gt;–such as presenting the
&lt;a href=&quot;https://github.com/ZipCPU/vgasim&quot;&gt;video simulator&lt;/a&gt; I posted on
&lt;a href=&quot;https://github.com/ZipCPU/vgasim&quot;&gt;github&lt;/a&gt;, and what makes it special.&lt;/p&gt;

&lt;p&gt;Since the FIFO we’ll be discussing today is asynchronous, I would
recommend you first read our discussion of properties associated with an
&lt;a href=&quot;/formal/2018/04/12/areset.html&quot;&gt;asynchronous reset&lt;/a&gt;,
as well as the &lt;a href=&quot;/formal/2018/05/31/clkswitch.html&quot;&gt;example of the asynchronous clock
switch&lt;/a&gt;.  These will
give you a bit of background regarding how we might handle multiple clocks
while at the same time working through a design
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formally&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;basic-fifo&quot;&gt;Basic FIFO&lt;/h2&gt;

&lt;p&gt;If you’ve never wrestled with the concept of an &lt;a href=&quot;http://www.sunburst-design.com/papers/CummingsSNUG2002SJ_FIFO1.pdf&quot;&gt;asynchronous
FIFO&lt;/a&gt;
before, you might ask yourself what the big deal is?  Indeed, in many ways an
&lt;a href=&quot;http://www.sunburst-design.com/papers/CummingsSNUG2002SJ_FIFO1.pdf&quot;&gt;asynchronous FIFO&lt;/a&gt;
is just like &lt;a href=&quot;/blog/2017/07/29/fifo.html&quot;&gt;any other FIFO&lt;/a&gt;.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 1. A Basic synchronous FIFO&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/afifo-sinternal.svg&quot; alt=&quot;&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Let’s compare the two FIFOs with each other.  Both a synchronous and
asynchronous FIFOs have a write pointer.  We’ll call this &lt;code class=&quot;highlighter-rouge&quot;&gt;wbin&lt;/code&gt;.  Then,
on any write, we’ll increase this pointer by one–but only if the FIFO
isn’t already FULL.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	initial	wbin = 0;
	always @(posedge i_wclk or negedge i_wrst_n)
	if (!i_wrst_n)
		wbin &amp;lt;= 0;
	else ((i_wr)&amp;amp;&amp;amp;(!o_wfull))
		wbin &amp;lt;= wbin + 1;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Did you notice that this logic takes place using the write
&lt;a href=&quot;/blog/2017/10/20/cdc.html&quot;&gt;clock domain&lt;/a&gt;,
&lt;code class=&quot;highlighter-rouge&quot;&gt;i_wclk&lt;/code&gt;?  Or that the
&lt;a href=&quot;/formal/2018/04/12/areset.html&quot;&gt;reset&lt;/a&gt;
was a negative edge driven
&lt;a href=&quot;/formal/2018/04/12/areset.html&quot;&gt;asynchronous reset&lt;/a&gt;
in the write &lt;a href=&quot;/blog/2017/10/20/cdc.html&quot;&gt;clock domain&lt;/a&gt;
as well?  You’d expect this from an &lt;a href=&quot;http://www.sunburst-design.com/papers/CummingsSNUG2002SJ_FIFO1.pdf&quot;&gt;asynchronous
FIFO&lt;/a&gt;.
The write pointer logic within a &lt;a href=&quot;/blog/2017/07/29/fifo.html&quot;&gt;synchronous
FIFO &lt;/a&gt;
would be the same except that only one
clock would be used, likely with a synchronous reset as well.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.sunburst-design.com/papers/CummingsSNUG2002SJ_FIFO1.pdf&quot;&gt;Cliff Cummings’
FIFO&lt;/a&gt;
is just subtly different from &lt;a href=&quot;/blog/2017/07/29/fifo.html&quot;&gt;my own earlier presentation of a synchronous
FIFO&lt;/a&gt;: his 
&lt;a href=&quot;http://www.sunburst-design.com/papers/CummingsSNUG2002SJ_FIFO1.pdf&quot;&gt;FIFO&lt;/a&gt;
holds a full &lt;code class=&quot;highlighter-rouge&quot;&gt;2^N&lt;/code&gt; elements.  The &lt;a href=&quot;/blog/2017/07/29/fifo.html&quot;&gt;FIFO I presented
earlier&lt;/a&gt;
only holds &lt;code class=&quot;highlighter-rouge&quot;&gt;(2^N)-1&lt;/code&gt; elements.  I like the difference, and will probably
upgrade my own synchronous FIFO implementations to follow this lead as well.
This changes &lt;code class=&quot;highlighter-rouge&quot;&gt;wbin&lt;/code&gt; slightly–we’ll now use &lt;code class=&quot;highlighter-rouge&quot;&gt;N+1&lt;/code&gt; address bits in
&lt;code class=&quot;highlighter-rouge&quot;&gt;wbin&lt;/code&gt; to hold a pointer into a &lt;code class=&quot;highlighter-rouge&quot;&gt;2^N&lt;/code&gt; element FIFO.&lt;/p&gt;

&lt;p&gt;Moving on with our comparison between asynchronous and synchronous FIFOs,
both of them will need to place the incoming data into a memory (block RAM)
on any write.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(posedge i_wclk)
	if ((i_wr)&amp;amp;&amp;amp;(!o_wfull))
		mem[wbin[AW-1:0]] &amp;lt;= i_wdata;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;In the case of the asynchronous FIFO, this is also done specifically using a
clock associated with the write channel, &lt;code class=&quot;highlighter-rouge&quot;&gt;i_wclk&lt;/code&gt;.  I’ve also used &lt;code class=&quot;highlighter-rouge&quot;&gt;AW&lt;/code&gt; to
reflect the &lt;em&gt;address width&lt;/em&gt; of this memory.  I’ll probably still refer to this
as &lt;code class=&quot;highlighter-rouge&quot;&gt;N&lt;/code&gt; throughout in this text.&lt;/p&gt;

&lt;p&gt;The read logic is very similar to the write logic above.  The logic starts
by adjusting a read address pointer which we’ll call &lt;code class=&quot;highlighter-rouge&quot;&gt;rbin&lt;/code&gt;.
Like &lt;code class=&quot;highlighter-rouge&quot;&gt;wbin&lt;/code&gt; above, this has one more bit than necessary to actually address
a value within the buffer–hence it has &lt;code class=&quot;highlighter-rouge&quot;&gt;N+1&lt;/code&gt; bits to access &lt;code class=&quot;highlighter-rouge&quot;&gt;2^N&lt;/code&gt; data points.
In a fashion similar to the write pointer, this pointer also needs to
increment: anytime there’s a read request and the buffer isn’t empty.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	initial	rbin = 0;
	always @(posedge i_rclk or negedge i_rrst_n)
	if (!i_rrst_n)
		rbin &amp;lt;= 0;
	else if ((i_rd)&amp;amp;&amp;amp;(!o_rempty))
		rbin &amp;lt;= rbin + 1;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;As a final step, we’ll read from the memory and return the result.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	assign	o_rdata = mem[rbin[AW-1:0]];&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Voila!  That’s the basics of any FIFO–synchronous or asynchronous.  How
much harder can it be?&lt;/p&gt;

&lt;p&gt;Much.&lt;/p&gt;

&lt;p&gt;As with most digital design problems, the devil lies buried in the details.
In this case, look a little closer at the two flags, &lt;code class=&quot;highlighter-rouge&quot;&gt;o_wfull&lt;/code&gt; indicating
that the FIFO is full and &lt;code class=&quot;highlighter-rouge&quot;&gt;o_rempty&lt;/code&gt; indicating that it is empty.&lt;/p&gt;

&lt;p&gt;As a first attempt to calculate these, we might express them with
combinatorial logic, as in:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	// The FIFO is empty when both read and write pointers point to the
	// same location.
	assign	o_rempty = (wbin == rbin);

	// It is full when wbin-rbin = 2^N.  In that case, the bottom AW
	// address bits are identical, but the top bit is different.
	assign	o_wfull  = (wbin[AW] != rbin[AW])
				&amp;amp;&amp;amp; (wbin[AW-1:0]==rbin[AW-1:0]);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Herein lies the problem.&lt;/p&gt;

&lt;p&gt;For a synchronous FIFO, both &lt;code class=&quot;highlighter-rouge&quot;&gt;AW+1&lt;/code&gt; bit pointers are generated on the same
clock, so there isn’t an immediately apparent problem.  Sure, you might
adjust this logic so the &lt;code class=&quot;highlighter-rouge&quot;&gt;o_rempty&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;o_wfull&lt;/code&gt; flags are registered,
but they’ll still have these same basic values.&lt;/p&gt;

&lt;p&gt;The big problem with these two pointers is specific to any
&lt;em&gt;asynchronous&lt;/em&gt; FIFO design.  In an asynchronous design, the read pointer is
kept in the read clock domain and the write pointer in a separate write clock
domain.  Calculating &lt;code class=&quot;highlighter-rouge&quot;&gt;o_rempty&lt;/code&gt; or &lt;code class=&quot;highlighter-rouge&quot;&gt;o_wfull&lt;/code&gt; requires &lt;a href=&quot;/blog/2017/10/20/cdc.html&quot;&gt;crossing clock
domains&lt;/a&gt;.
This invites problems with
&lt;a href=&quot;https://en.wikipedia.org/wiki/Metastability_in_electronics&quot;&gt;metastability&lt;/a&gt;,
where a design might fine work in simulation but not on actual hardware.
Indeed, it might work 95% of the time on actual hardware, leaving behind
incomprehensible results when it doesn’t work.&lt;/p&gt;

&lt;p&gt;I’ve tried to illustrate this problem in Fig 2 below.  In this figure, I
colored the background based upon which part of the design lies within each
&lt;a href=&quot;/blog/2017/10/20/cdc.html&quot;&gt;clock domain&lt;/a&gt;, whether
yellow for the write clock, or green for the read clock.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 2. In an Asynchronous FIFO, the pointers need to cross clock domains&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/afifo-internals.svg&quot; alt=&quot;&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Fixing these two flags is really the focus of how to build an &lt;a href=&quot;http://www.sunburst-design.com/papers/CummingsSNUG2002SJ_FIFO1.pdf&quot;&gt;asynchronous
FIFO&lt;/a&gt;.
To do so, we’ll build off of our previous work using &lt;a href=&quot;/blog/2017/10/20/cdc.html&quot;&gt;2FF or 3FF
synchronizers&lt;/a&gt;, but this time we’ll
need to introduce &lt;a href=&quot;https://en.wikipedia.org/wiki/Gray_code&quot;&gt;Gray codes&lt;/a&gt; as well.
Each of these concepts is shown in Fig 2 above.&lt;/p&gt;

&lt;h2 id=&quot;gray-codes&quot;&gt;Gray Codes&lt;/h2&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 3. A two clock synchronizer&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/cdc-dbl-clock.svg&quot; alt=&quot;&quot; width=&quot;360&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;When we &lt;a href=&quot;/blog/2017/10/20/cdc.html&quot;&gt;last discussed clock domain
crossings&lt;/a&gt;, we shows how it was
possible to use a two or a three clock synchronizer to pass a
one-bit value from one
&lt;a href=&quot;/blog/2017/10/20/cdc.html&quot;&gt;clock domain&lt;/a&gt;
to the next.  Fig 3 shows an example of this, using two
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flip-flop_(electronics)&quot;&gt;flip flops&lt;/a&gt;
clocked in the new domain–this would be a &lt;a href=&quot;/blog/2017/10/20/cdc.html&quot;&gt;two clock
synchronizer&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The code for this operation is shown below.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(posedge new_clock)
		resynchronized_value &amp;lt;= { unstable_values, unsynchronized_input };&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;In the case of this one bit difference, it doesn’t really matter if that one
bit change arrives one clock earlier or one clock later–it’s just a slow
signal with no dependencies.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 4. Counting in Gray Code&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/afifo-gray-code.svg&quot; alt=&quot;&quot; width=&quot;360&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Sadly, we’re not trying to cross a 1-bit signal from one
&lt;a href=&quot;/blog/2017/10/20/cdc.html&quot;&gt;clock domain&lt;/a&gt;
to another, but rather an &lt;code class=&quot;highlighter-rouge&quot;&gt;N&lt;/code&gt; bit (i.e. &lt;code class=&quot;highlighter-rouge&quot;&gt;AW&lt;/code&gt;-bit) signal from one
&lt;a href=&quot;/blog/2017/10/20/cdc.html&quot;&gt;clock domain&lt;/a&gt;
to the next–whether &lt;code class=&quot;highlighter-rouge&quot;&gt;wbin&lt;/code&gt; to the read clock side or &lt;code class=&quot;highlighter-rouge&quot;&gt;rbin&lt;/code&gt; to the write
clock side.  If we put the whole word into a synchronizer, like the one shown
in Fig 3 but with more bits, then the outputs
wouldn’t suffer from
&lt;a href=&quot;https://en.wikipedia.org/wiki/Metastability_in_electronics&quot;&gt;metastability&lt;/a&gt;
anymore, but they might not be stable anymore
either.  For example, if &lt;code class=&quot;highlighter-rouge&quot;&gt;rbin&lt;/code&gt; were all ones and transitioning to all zeros,
then some uncontrolled random number of ones might be set at the output of the
synchronizer–depending upon how the bits were routed, and thus upon
which arrived before the new clock signal and which arrived afterwards.
As an example, an &lt;code class=&quot;highlighter-rouge&quot;&gt;8&#39;hff&lt;/code&gt; transitioning to &lt;code class=&quot;highlighter-rouge&quot;&gt;8&#39;h00&lt;/code&gt; might be read as &lt;code class=&quot;highlighter-rouge&quot;&gt;8&#39;h52&lt;/code&gt;
(among many, many other possibilities).  This is unacceptable.&lt;/p&gt;

&lt;p&gt;The solution is to pass the address from one
&lt;a href=&quot;/blog/2017/10/20/cdc.html&quot;&gt;clock domain&lt;/a&gt;
to another in a form chosen so that only one bit will ever change at any time.
Formally, we can describe such a &lt;code class=&quot;highlighter-rouge&quot;&gt;word&lt;/code&gt; with the requirement that the
difference between any &lt;code class=&quot;highlighter-rouge&quot;&gt;word&lt;/code&gt; and the &lt;code class=&quot;highlighter-rouge&quot;&gt;$past()&lt;/code&gt; version of it must be
no more than one bit.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(posedge first_clk)
		word &amp;lt;= // Logic to create the next value;

	// Verify that it has no more than one bit difference
	always @(posedge first_clk)
		assert((word == $past(word))
			||($onehot(word ^ $past(word))));&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;$onehot&lt;/code&gt; is a &lt;a href=&quot;https://en.wikipedia.org/wiki/SystemVerilog&quot;&gt;SystemVerilog&lt;/a&gt;
function that returns &lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt; (true) if and only
if one bit is set within its argument, and zero otherwise.&lt;/p&gt;

&lt;p&gt;Sadly, the open source version of &lt;a href=&quot;https://www.clifford.at/yosys&quot;&gt;Yosys&lt;/a&gt;
doesn’t (yet) understand &lt;code class=&quot;highlighter-rouge&quot;&gt;$onehot&lt;/code&gt;.  (The commercial version does.)  We’ll
alternatively express this within a loop.&lt;/p&gt;

&lt;p&gt;Specifically, if any single bit changes between the new and old values, then
all other values must be the same.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	genvar	k;
	generate for (k=0; k &amp;lt;= AW; k=k+1)
	begin : CHECK_ONEHOT
		always @($global_clock)
			assert(word[k] == $past(word[k])
				||(word ^ $past(word) ^ (1&amp;lt;&amp;lt;k) == 0));
	end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Okay, so this is our criteria for success, but what sort of encoding meets
this criteria?  &lt;a href=&quot;https://en.wikipedia.org/wiki/Gray_code&quot;&gt;Gray coding&lt;/a&gt;!&lt;/p&gt;

&lt;p&gt;If we have a counter such as,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(posedge i_clk)
		counter &amp;lt;= counter + 1;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;then a &lt;a href=&quot;https://en.wikipedia.org/wiki/Gray_code&quot;&gt;Gray coded&lt;/a&gt;
version of that same counter will have the property that only
one bit changes at a time.  We can create this 
&lt;a href=&quot;https://en.wikipedia.org/wiki/Gray_code&quot;&gt;Gray coded&lt;/a&gt;
by exclusively &lt;code class=&quot;highlighter-rouge&quot;&gt;OR&lt;/code&gt;ing the counter with itself shifted down by one.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	assign graycounter = counter ^ (counter &amp;gt;&amp;gt; 1);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Using such a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Gray_code&quot;&gt;Gray coded&lt;/a&gt;
counter, we can &lt;a href=&quot;/blog/2017/10/20/cdc.html&quot;&gt;cross clock
domains&lt;/a&gt;
with both read
and write address pointers.  Not only will the results be stable and so
not suffer from
&lt;a href=&quot;https://en.wikipedia.org/wiki/Metastability_in_electronics&quot;&gt;metastability&lt;/a&gt;,
but they will also capture all of the 
information within the address in an fashion that won’t be corrupted
if any given bit within the word arrives earlier or later.&lt;/p&gt;

&lt;p&gt;This means we’ll add
&lt;a href=&quot;https://en.wikipedia.org/wiki/Gray_code&quot;&gt;Gray coded&lt;/a&gt; pointers to
our FIFO design in order to bridge them across
the &lt;a href=&quot;/blog/2017/10/20/cdc.html&quot;&gt;clock domain divide&lt;/a&gt;.
First, the read pointer, now
&lt;a href=&quot;https://en.wikipedia.org/wiki/Gray_code&quot;&gt;Gray coded&lt;/a&gt;
and represented as &lt;code class=&quot;highlighter-rouge&quot;&gt;rgray&lt;/code&gt;, will cross to the write &lt;a href=&quot;/blog/2017/10/20/cdc.html&quot;&gt;clock
domain&lt;/a&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	initial	{ wq2_rgray,  wq1_rgray } = 0;
	always @(posedge i_wclk or negedge i_wrst_n)
	if (!i_wrst_n)
		{ wq2_rgray, wq1_rgray } &amp;lt;= 0;
	else
		{ wq2_rgray, wq1_rgray } &amp;lt;= { wq1_rgray, rgray };&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This is just an &lt;code class=&quot;highlighter-rouge&quot;&gt;N&lt;/code&gt;-bit wide, two flip-flop synchronizer, such as we
&lt;a href=&quot;/blog/2017/10/20/cdc.html&quot;&gt;introduced earlier&lt;/a&gt;
and diagrammed in Fig 3 above.&lt;/p&gt;

&lt;p&gt;Second, the write pointer,
&lt;a href=&quot;https://en.wikipedia.org/wiki/Gray_code&quot;&gt;Gray coded&lt;/a&gt;
as &lt;code class=&quot;highlighter-rouge&quot;&gt;wgray&lt;/code&gt;, will cross from the write to the read
&lt;a href=&quot;/blog/2017/10/20/cdc.html&quot;&gt;clock domain&lt;/a&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	initial	{ rq2_wgray,  rq1_wgray } = 0;
	always @(posedge i_rclk or negedge i_rrst_n)
	if (!i_rrst_n)
		{ rq2_wgray, rq1_wgray } &amp;lt;= 0;
	else
		{ rq2_wgray, rq1_wgray } &amp;lt;= { rq1_wgray, wgray };&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This brings our two pointers, &lt;code class=&quot;highlighter-rouge&quot;&gt;rbin&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;wbin&lt;/code&gt;,  into the other
&lt;a href=&quot;/blog/2017/10/20/cdc.html&quot;&gt;clock domain&lt;/a&gt; as &lt;code class=&quot;highlighter-rouge&quot;&gt;wq2_rgray&lt;/code&gt;
and &lt;code class=&quot;highlighter-rouge&quot;&gt;rq2_wgray&lt;/code&gt;, but these values are no longer counters.  How shall we use
them in our comparisons?  Do we need to convert them back to more traditional
counters?&lt;/p&gt;

&lt;h2 id=&quot;comparing-gray-coded-pointers&quot;&gt;Comparing Gray coded pointers&lt;/h2&gt;

&lt;p&gt;Let’s examine how we might use these two
&lt;a href=&quot;https://en.wikipedia.org/wiki/Gray_code&quot;&gt;Gray&lt;/a&gt; pointers.
Remember, we need to determine when the FIFO is empty and when it is
full.  Before, we had the two lines,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	assign	o_rempty = (wbin == rbin);
	assign	o_wfull  = (wbin[AW] != rbin[AW])
				&amp;amp;&amp;amp; (wbin[AW-1:0]==rbin[AW-1:0]);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Perhaps you noticed the &lt;code class=&quot;highlighter-rouge&quot;&gt;r&lt;/code&gt; in &lt;code class=&quot;highlighter-rouge&quot;&gt;o_rempty&lt;/code&gt;, or the &lt;code class=&quot;highlighter-rouge&quot;&gt;w&lt;/code&gt; in &lt;code class=&quot;highlighter-rouge&quot;&gt;o_wfull&lt;/code&gt;.  These
are from &lt;a href=&quot;http://www.sunburst-design.com/papers/CummingsSNUG2002SJ_FIFO1.pdf&quot;&gt;Cummings’
notation&lt;/a&gt;,
and used to remind the reader that &lt;code class=&quot;highlighter-rouge&quot;&gt;o_rempty&lt;/code&gt; is calculated in the read
&lt;a href=&quot;/blog/2017/10/20/cdc.html&quot;&gt;clock domain&lt;/a&gt;,
whereas &lt;code class=&quot;highlighter-rouge&quot;&gt;o_wfull&lt;/code&gt; is calculated in the write
&lt;a href=&quot;/blog/2017/10/20/cdc.html&quot;&gt;clock domain&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;If you examine the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Gray_code&quot;&gt;Gray coded&lt;/a&gt;
counters illustrated in Fig 4, you’ll notice that the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Gray_code&quot;&gt;Gray coded&lt;/a&gt;
values are unique–just like the counters they represent.  Further, an
&lt;code class=&quot;highlighter-rouge&quot;&gt;N&lt;/code&gt; bit counter can be represented with an &lt;code class=&quot;highlighter-rouge&quot;&gt;N&lt;/code&gt; bit
&lt;a href=&quot;https://en.wikipedia.org/wiki/Gray_code&quot;&gt;Gray code&lt;/a&gt;.
In other words, if you want to check whether or not two pointers
are identical, you only need to check whether the two
&lt;a href=&quot;https://en.wikipedia.org/wiki/Gray_code&quot;&gt;Gray coded&lt;/a&gt; pointers are identical.&lt;/p&gt;

&lt;p&gt;This works great for testing whether or not the FIFO is empty.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	assign	o_rempty = (rq2_wgray == rgray);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;But how shall we test if the FIFO is full?&lt;/p&gt;

&lt;p&gt;In this case, the math is more complicated.  We want to test whether or not
&lt;code class=&quot;highlighter-rouge&quot;&gt;wbin - rbin == 2^N&lt;/code&gt;.  If this is true, then the FIFO is full.  Notice that
any time this comparison is true, the bottom &lt;code class=&quot;highlighter-rouge&quot;&gt;N-1&lt;/code&gt; bits will be constant
between &lt;code class=&quot;highlighter-rouge&quot;&gt;wbin&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;rbin&lt;/code&gt;, and the top bit will be flipped.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 5. If the top bit of an address changes, then both the top two bits of the Gray coded address change&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/afifo-ptr-to-graycode.svg&quot; alt=&quot;&quot; width=&quot;360&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;To see how this comparison changes once converted to
&lt;a href=&quot;https://en.wikipedia.org/wiki/Gray_code&quot;&gt;Gray code&lt;/a&gt;,
consider the
example of &lt;code class=&quot;highlighter-rouge&quot;&gt;16&lt;/code&gt; element FIFO.  Such a FIFO will require 5-bit read and write
pointers.  We’ll allow 5-bits of the read pointer to have the arbitrary
value, &lt;code class=&quot;highlighter-rouge&quot;&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;a,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;b,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;c,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;d,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;.  When the FIFO is full, the associated write
pointer will be &lt;code class=&quot;highlighter-rouge&quot;&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;!a,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;b,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;c,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;d,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;.  Now, consider what will happen to this
pointer when converted to
&lt;a href=&quot;https://en.wikipedia.org/wiki/Gray_code&quot;&gt;Gray code&lt;/a&gt;,
as shown in Fig 5 for the write pointer.&lt;/p&gt;

&lt;p&gt;Remember how the only bit that differed for the write pointer was the most
significant bit.  From Fig 5, you can see that all but the top two bits will
be identical between the read and write pointers following the conversion to
&lt;a href=&quot;https://en.wikipedia.org/wiki/Gray_code&quot;&gt;Gray code&lt;/a&gt;.
Hence, we can test whether the two pointers are identical
in all but their top bits by testing whether the top two bits are opposites,
but the rest of the bits are identical.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	assign	o_wfull  = (wgray[AW:AW-1] == ~wq2_rgray[AW:AW-1])
				&amp;amp;&amp;amp; (wgray[AW-2:0]==wq2_rgray[AW-2:0]);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The solution &lt;a href=&quot;http://www.sunburst-design.com/papers/CummingsSNUG2002SJ_FIFO1.pdf&quot;&gt;Cummings’
presents&lt;/a&gt;
is almost identical.  The difference is that he creates &lt;code class=&quot;highlighter-rouge&quot;&gt;o_rempty&lt;/code&gt; and
&lt;code class=&quot;highlighter-rouge&quot;&gt;o_wfull&lt;/code&gt; using clocked logic instead of combinatorial for better performance.
As a result, his solution looks more like,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(posedge i_rclk or negedge i_rrst_n)
	if (!i_rrst_n)
		o_rempty &amp;lt;= 1&#39;b0;
	else
		o_rempty &amp;lt;= (rq2_wgray == rgray);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;and&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(posedge i_wclk or negedge i_wrst_n)
	if (!i_wrst_n)
		o_wfull &amp;lt;= 1&#39;b0;
	else
		o_wfull &amp;lt;= (wgray[AW:AW-1] == ~wq2_rgray[AW:AW-1])
				&amp;amp;&amp;amp; (wgray[AW-2:0]==wq2_rgray[AW-2:0]);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;However, at this point in the development … I got lost.  Sure, these
pointers are now
&lt;a href=&quot;https://en.wikipedia.org/wiki/Gray_code&quot;&gt;Gray coded&lt;/a&gt; and so they’ll pass
from one &lt;a href=&quot;/blog/2017/10/20/cdc.html&quot;&gt;clock domain&lt;/a&gt;
to another without problems, but how shall I get some confidence that this
design actually works now that it is so different from the synchronous FIFO
I am familiar with?  I mean, what confidence can I have that these two flags,
already delayed by two clocks, are going to keep the FIFO from underruns or
overruns?
&lt;a href=&quot;http://www.sunburst-design.com/papers/CummingsSNUG2002SJ_FIFO1.pdf&quot;&gt;Cummings&lt;/a&gt;
confidently declares that his solution works, citing the works of those who
have proved these properties.  However, even after I read his document, I
remained unconvinced, and not certain of whether or not I wanted to trust my
professional designs to his hand waving.  (Sorry Cliff!)&lt;/p&gt;

&lt;p&gt;What I’d like is to have the confidence that can only come from some form
of &lt;em&gt;&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal proof&lt;/a&gt;&lt;/em&gt;
that this whole thing works–even after &lt;a href=&quot;/blog/2017/10/20/cdc.html&quot;&gt;crossing
clock domains&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Therefore, let’s start looking at the components necessary to
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formally verify&lt;/a&gt;
this design.&lt;/p&gt;

&lt;h2 id=&quot;proof-outline&quot;&gt;Proof Outline&lt;/h2&gt;

&lt;p&gt;Let’s consider what we might wish to prove.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;We’d like to make certain that the FIFO pointers are “within bounds” at all
times.  Since we used &lt;code class=&quot;highlighter-rouge&quot;&gt;AW+1&lt;/code&gt; (address width) bits to represent a &lt;code class=&quot;highlighter-rouge&quot;&gt;2^(AW)&lt;/code&gt;
element FIFO, we’ll need to measure the fill at all times and make certain
it remains within &lt;code class=&quot;highlighter-rouge&quot;&gt;0&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;2^(AW)&lt;/code&gt;.&lt;/p&gt;

    &lt;p&gt;One of the neat things about
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal methods&lt;/a&gt;
is that the variables and tests used within the formal section need not
be synthesizable, neither are they susceptible to
&lt;a href=&quot;https://en.wikipedia.org/wiki/Metastability_in_electronics&quot;&gt;metastability&lt;/a&gt;.
As a result, we can violate all principles of good synthesizable design,
and we can measure the actual FIFO fill directly at any instant (well, at
any formal timestep).&lt;/p&gt;

    &lt;p&gt;This fill should start out at zero, and it should always be less than
or equal to the total amount of space in the FIFO.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	wire	[AW-1:0]	f_fill;
	assign	f_fill = (wbin - rbin);

	initial	assert(f_fill == 0);
	always @(*)
		assert(f_fill &amp;lt;= { 1&#39;b1, {(AW){1&#39;b0}} });&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;ol start=&quot;2&quot;&gt;
  &lt;li&gt;Looking at the empty flag, we want to assert that any time the FIFO is
actually empty, that the &lt;code class=&quot;highlighter-rouge&quot;&gt;o_rempty&lt;/code&gt; flag is also high.&lt;/li&gt;
&lt;/ol&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(*)
		if (f_fill == 0)
			assert(o_rempty);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;ol start=&quot;3&quot;&gt;
  &lt;li&gt;We’ll want to do the same thing for &lt;code class=&quot;highlighter-rouge&quot;&gt;o_wfull&lt;/code&gt;: any time the FIFO is truly
full, we’ll want to assert that &lt;code class=&quot;highlighter-rouge&quot;&gt;o_wfull&lt;/code&gt; is high.&lt;/li&gt;
&lt;/ol&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(*)
		if (f_fill == { 1&#39;b1, {(AW){1&#39;b0}}})
			assert(o_rempty);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;ol start=&quot;4&quot;&gt;
  &lt;li&gt;Just to make certain that these values won’t get stuck, let’s also use
a &lt;code class=&quot;highlighter-rouge&quot;&gt;cover&lt;/code&gt; property to cover going from not-empty to empty, and from
full to not full.&lt;/li&gt;
&lt;/ol&gt;

&lt;ol start=&quot;5&quot;&gt;
  &lt;li&gt;
    &lt;p&gt;Finally, the &lt;a href=&quot;http://www.techdesignforums.com/practice/technique/doc-formal-harness-the-power-of-invariant-based-bug-hunting/&quot;&gt;classic means of proving that a FIFO
works&lt;/a&gt;
is to accept two arbitrary values into the FIFO, at an arbitrary but
sequential pair of locations, and then to verify that those same two
values may be read out of the FIFO some time later.&lt;/p&gt;

    &lt;p&gt;Let’s add that to our proof requirements as well.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;This is only a high level view of the
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal properties&lt;/a&gt;
we’d like to use.  We’ll add some other properties below as well–if for
no other reason than to make certain our design can &lt;a href=&quot;/blog/2018/03/10/induction-exercise.html&quot;&gt;pass
induction&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;cliff-cummings-asynchronous-fifo&quot;&gt;Cliff Cummings’ Asynchronous FIFO&lt;/h2&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 6. Asynchronous FIFO block diagram&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/afifo_io.svg&quot; alt=&quot;&quot; width=&quot;360&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;&lt;a href=&quot;http://www.sunburst-design.com/papers/CummingsSNUG2002SJ_FIFO1.pdf&quot;&gt;Cummings’ FIFO&lt;/a&gt;
has the basic interface shown on the right in Fig 6.  Operation starts in the
write domain, where &lt;code class=&quot;highlighter-rouge&quot;&gt;i_wdata&lt;/code&gt; is written to the FIFO anytime &lt;code class=&quot;highlighter-rouge&quot;&gt;i_wr&lt;/code&gt; is true
and the &lt;code class=&quot;highlighter-rouge&quot;&gt;o_wfull&lt;/code&gt; flag is false.  The data can then be read later from
&lt;code class=&quot;highlighter-rouge&quot;&gt;o_rdata&lt;/code&gt; any time &lt;code class=&quot;highlighter-rouge&quot;&gt;i_rd&lt;/code&gt; is true and &lt;code class=&quot;highlighter-rouge&quot;&gt;o_rempty&lt;/code&gt; is false, in the values
&lt;code class=&quot;highlighter-rouge&quot;&gt;o_rdata&lt;/code&gt;.  Likewise, there’s a clock and an
&lt;a href=&quot;/formal/2018/04/12/areset.html&quot;&gt;asynchronous reset&lt;/a&gt;
associated with each
&lt;a href=&quot;/blog/2017/10/20/cdc.html&quot;&gt;clock domain&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Indeed, the interface is very straight-forward.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.sunburst-design.com/papers/CummingsSNUG2002SJ_FIFO1.pdf&quot;&gt;Cummings’
FIFO&lt;/a&gt;,
however, is built using a series of separate modules: one module for each
clock synchronizer, one for the memory itself, and another two modules for
the read pointer and the write pointer respectively.
Since a design with any hidden states within it may &lt;a href=&quot;/blog/2018/03/10/induction-exercise.html&quot;&gt;struggle to pass
induction&lt;/a&gt;,
I took the liberty of rearranging &lt;a href=&quot;http://www.sunburst-design.com/papers/CummingsSNUG2002SJ_FIFO1.pdf&quot;&gt;Cummings’
FIFO&lt;/a&gt;
a little bit.  Specifically,
I placed all the parts and pieces into a
&lt;a href=&quot;https://github.com/ZipCPU/website/blob/master/examples/afifo.v&quot;&gt;single file&lt;/a&gt;.
This will make it easier to reference values within the design from within a
single &lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal property&lt;/a&gt;
section below.&lt;/p&gt;

&lt;p&gt;The design begins with some declarations.  Note that this FIFO will use a
parameterized data width of two bits, and an address width of 4 bits–and so
this FIFO will hold &lt;code class=&quot;highlighter-rouge&quot;&gt;2^4=16&lt;/code&gt; elements.  While the widths are arbitrary, I’ve
chosen smaller widths to help deal with the combinatorial explosion associated
with using
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal methods&lt;/a&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;module afifo(i_wclk, i_wrst_n, i_wr, i_wdata, o_wfull,
		i_rclk, i_rrst_n, i_rd, o_rdata, o_rempty);
	parameter	DSIZE = 2,
			ASIZE = 4;
	localparam	DW = DSIZE,
			AW = ASIZE;
	input	wire			i_wclk, i_wrst_n, i_wr;
	input	wire	[DW-1:0]	i_wdata;
	output	wire			o_wfull;
	input	wire			i_rclk, i_rrst_n, i_rd;
	output	wire	[DW-1:0]	o_rdata;
	output	wire			o_rempty;

	wire	[AW-1:0]	waddr, raddr;
	wire			wfull_next, rempty_next;
	reg	[AW:0]		wgray, wbin, wq2_rgray, wq1_rgray,
				rgray, rbin, rq2_wgray, rq1_wgray;
	//
	wire	[AW:0]		wgraynext, wbinnext;
	wire	[AW:0]		rgraynext, rbinnext;

	reg	[DW-1:0]	mem	[0:((1&amp;lt;&amp;lt;AW)-1)];&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;These declarations are followed by the write logic of
&lt;a href=&quot;https://github.com/ZipCPU/website/blob/master/examples/afifo.v&quot;&gt;the FIFO&lt;/a&gt;.
This includes bringing the read
&lt;a href=&quot;https://en.wikipedia.org/wiki/Gray_code&quot;&gt;Gray&lt;/a&gt; pointers into the write
&lt;a href=&quot;/blog/2017/10/20/cdc.html&quot;&gt;clock domain&lt;/a&gt;,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	//
	// Cross clock domains
	//
	// Cross the read Gray pointer into the write clock domain
	initial	{ wq2_rgray,  wq1_rgray } = 0;
	always @(posedge i_wclk or negedge i_wrst_n)
	if (!i_wrst_n)
		{ wq2_rgray, wq1_rgray } &amp;lt;= 0;
	else
		{ wq2_rgray, wq1_rgray } &amp;lt;= { wq1_rgray, rgray };&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;maintaining the write pointer and its
&lt;a href=&quot;https://en.wikipedia.org/wiki/Gray_code&quot;&gt;Gray code&lt;/a&gt;
equivalent,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	// Calculate the next write address, and the next graycode pointer.
	assign	wbinnext  = wbin + { {(AW){1&#39;b0}}, ((i_wr) &amp;amp;&amp;amp; (!o_wfull)) };
	assign	wgraynext = (wbinnext &amp;gt;&amp;gt; 1) ^ wbinnext;

	assign	waddr = wbin[AW-1:0];

	// Register these two values--the address and its Gray code
	// representation
	initial	{ wbin, wgray } = 0;
	always @(posedge i_wclk or negedge i_wrst_n)
	if (!i_wrst_n)
		{ wbin, wgray } &amp;lt;= 0;
	else
		{ wbin, wgray } &amp;lt;= { wbinnext, wgraynext };

	assign	wfull_next = (wgraynext == { ~wq2_rgray[AW:AW-1],
				wq2_rgray[AW-2:0] });&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;and writing values into the &lt;a href=&quot;https://github.com/ZipCPU/website/blob/master/examples/afifo.v&quot;&gt;asynchronous
FIFO&lt;/a&gt;
on the write clock.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	//
	// Calculate whether or not the register will be full on the next
	// clock.
	initial	o_wfull = 0;
	always @(posedge i_wclk or negedge i_wrst_n)
	if (!i_wrst_n)
		o_wfull &amp;lt;= 1&#39;b0;
	else
		o_wfull &amp;lt;= wfull_next;

	//
	// Write to the FIFO on a clock
	always @(posedge i_wclk)
	if ((i_wr)&amp;amp;&amp;amp;(!o_wfull))
		mem[waddr] &amp;lt;= i_wdata;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The write section is followed by the read section, having almost exactly the
same format.  First the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Gray_code&quot;&gt;Gray coded&lt;/a&gt;
write address crosses clocks into the read
&lt;a href=&quot;/blog/2017/10/20/cdc.html&quot;&gt;clock domain&lt;/a&gt;,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	//
	// Cross clock domains
	//
	// Cross the write Gray pointer into the read clock domain
	initial	{ rq2_wgray,  rq1_wgray } = 0;
	always @(posedge i_rclk or negedge i_rrst_n)
	if (!i_rrst_n)
		{ rq2_wgray, rq1_wgray } &amp;lt;= 0;
	else
		{ rq2_wgray, rq1_wgray } &amp;lt;= { rq1_wgray, wgray };&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;then the read pointer is adjusted.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	// Calculate the next read address,
	assign	rbinnext  = rbin + { {(AW){1&#39;b0}}, ((i_rd)&amp;amp;&amp;amp;(!o_rempty)) };
	// and the next Gray code version associated with it
	assign	rgraynext = (rbinnext &amp;gt;&amp;gt; 1) ^ rbinnext;

	// Register these two values, the read address and the Gray code version
	// of it, on the next read clock
	//
	initial	{ rbin, rgray } = 0;
	always @(posedge i_rclk or negedge i_rrst_n)
	if (!i_rrst_n)
		{ rbin, rgray } &amp;lt;= 0;
	else
		{ rbin, rgray } &amp;lt;= { rbinnext, rgraynext };

	// Memory read address Gray code and pointer calculation
	assign	raddr = rbin[AW-1:0];&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Finally, an determination is made as to whether or not
&lt;a href=&quot;https://github.com/ZipCPU/website/blob/master/examples/afifo.v&quot;&gt;the FIFO&lt;/a&gt;
is empty and then a value is (may be) read from the buffer.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	// Determine if we&#39;ll be empty on the next clock
	assign	rempty_next = (rgraynext == rq2_wgray);

	initial o_rempty = 1;
	always @(posedge i_rclk or negedge i_rrst_n)
	if (!i_rrst_n)
		o_rempty &amp;lt;= 1&#39;b1;
	else
		o_rempty &amp;lt;= rempty_next;

	//
	// Read from the memory--a clockless read here, clocked by the next
	// read FLOP in the next processing stage (somewhere else)
	//
	assign	o_rdata = mem[raddr];

endmodule&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This is all straight forward with the exception of our pending question: will
this work?&lt;/p&gt;

&lt;p&gt;Let’s write some
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal properties&lt;/a&gt;
together to find out.&lt;/p&gt;

&lt;h2 id=&quot;assuming-two-clocks&quot;&gt;Assuming two clocks&lt;/h2&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 7. Assuming an Arbitrary Clock Rate&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/afifo-clkstep.svg&quot; alt=&quot;&quot; width=&quot;240&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;We’ve &lt;a href=&quot;/formal/2018/05/31/clkswitch.html&quot;&gt;already discussed&lt;/a&gt;
how to assume a clock using
&lt;a href=&quot;https://en.wikipedia.org/wiki/SystemVerilog&quot;&gt;SystemVerilog&lt;/a&gt; properties
and &lt;a href=&quot;https://symbiyosys.readthedocs.io/en/latest&quot;&gt;SymbiYosys&lt;/a&gt;.
Basically, this involves allowing the solver to pick two
arbitrary step sizes, &lt;code class=&quot;highlighter-rouge&quot;&gt;f_wclk_step&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;f_rclk_step&lt;/code&gt;, creating counters
that step by these amounts but with arbitrary initial states, and then assuming
the incoming clock is identical to the most-significant bits of these counters.
All of this logic is shown pictorially in Fig 7 to the right.&lt;/p&gt;

&lt;p&gt;Let’s walk through those steps again, this time in Verilog.&lt;/p&gt;

&lt;p&gt;We’ll start with the arbitrary clock steps.  These are just constants, chosen
by the solver.  They are subject to assumed constraints, but nothing more.
In past articles, I would’ve used
the magic value &lt;code class=&quot;highlighter-rouge&quot;&gt;$anyconst&lt;/code&gt; to describe a value with these properties.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	localparam	F_CLKBITS=5;
	wire	[F_CLKBITS-1:0]	f_wclk_step, f_rclk_step;

	assign	f_wclk_step = $anyconst;
	assign	f_rclk_step = $anyconst;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;However, in an effort to make these random constant value declarations more
uniform, and particularly to be able to support both
&lt;a href=&quot;https://en.wikipedia.org/wiki/SystemVerilog&quot;&gt;SystemVerilog&lt;/a&gt;
&lt;em&gt;and&lt;/em&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/VHDL&quot;&gt;VHDL&lt;/a&gt;,
&lt;a href=&quot;https://www.clifford.at/yosys&quot;&gt;Yosys&lt;/a&gt;
now has the option of declaring these clock step amounts using an
attribute, &lt;code class=&quot;highlighter-rouge&quot;&gt;(* anyconst *)&lt;/code&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	(* anyconst *) wire	[F_CLKBITS-1:0]	f_wclk_step, f_rclk_step;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;We’ll assume that both of these step sizes are greater than zero.
This will guarantee that each clock moves forward–and that they are never
stuck.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(*)
		assume(f_wclk_step != 0);
	always @(*)
		assume(f_rclk_step != 0);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;We can now use these steps sizes in a counter.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	reg	[F_CLKBITS-1:0]	f_wclk_count, f_rclk_count;

	always @($global_clock)
		f_wclk_count &amp;lt;= f_wclk_count + f_wclk_step;
	always @($global_clock)
		f_rclk_count &amp;lt;= f_rclk_count + f_rclk_step;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Notice the reference to &lt;code class=&quot;highlighter-rouge&quot;&gt;$global_clock&lt;/code&gt; here.  This is a reference to the
time-step within the
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal solver&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Although &lt;code class=&quot;highlighter-rouge&quot;&gt;$global_clock&lt;/code&gt; is a
&lt;a href=&quot;https://en.wikipedia.org/wiki/SystemVerilog&quot;&gt;SystemVerilog&lt;/a&gt;
concept,
&lt;a href=&quot;https://en.wikipedia.org/wiki/SystemVerilog&quot;&gt;SystemVerilog&lt;/a&gt;
actually defines this value differently.  In
&lt;a href=&quot;https://en.wikipedia.org/wiki/SystemVerilog&quot;&gt;SystemVerilog&lt;/a&gt;,
the &lt;code class=&quot;highlighter-rouge&quot;&gt;$global_clock&lt;/code&gt; needs
to be defined before it can be used.  It’s similar, but not quite the same
as the global formal timestep.  To bridge this gap, the commercial version of
&lt;a href=&quot;https://www.clifford.at/yosys&quot;&gt;Yosys&lt;/a&gt; allows,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	(* gclk *) wire	gbl_clock;
	global clocking @(posedge gbl_clock); endclocking;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;In this case, &lt;code class=&quot;highlighter-rouge&quot;&gt;gbl_clock&lt;/code&gt; is defined to be the global simulation clock.
Transitions on any edge of this clock will reference a formal timestep.
The &lt;code class=&quot;highlighter-rouge&quot;&gt;global clocking&lt;/code&gt; declaration just defines the
&lt;a href=&quot;https://en.wikipedia.org/wiki/SystemVerilog&quot;&gt;SystemVerilog&lt;/a&gt;
identifier,
&lt;code class=&quot;highlighter-rouge&quot;&gt;$global_clock&lt;/code&gt;, to be a reference to a transition of this formal timestep
clock, &lt;code class=&quot;highlighter-rouge&quot;&gt;gbl_clock&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Now, with all this background, we can finally assume our incoming clocks
at their various speeds.  Specifically, we’ll assume that the read and write
clocks are synonymous with the most significant bit of these counters.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(*)
	begin
		assume(i_wclk == f_wclk_count[F_CLKBITS-1]);
		assume(i_rclk == f_rclk_count[F_CLKBITS-1]);
	end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This will give them each a rough 50% duty cycle.&lt;/p&gt;

&lt;p&gt;If you look at either clock within a trace, you’ll notice that the edges will
appear to jitter back and forth.  For example, the clock might take two time
periods in one cycle and three in the next.  This is normal.  It is a
byproduct of how the clocks are defined.  However, these formal clocks don’t
need to be so stable that you can drive a hardware PLL from them.  They only
need to be representative of two separate clock rates, and they will be that
for us.&lt;/p&gt;

&lt;h2 id=&quot;the-asynchronous-reset&quot;&gt;The Asynchronous Reset&lt;/h2&gt;

&lt;p&gt;Cummings’ design includes two negative logic
&lt;a href=&quot;/formal/2018/04/12/areset.html&quot;&gt;asynchronous reset&lt;/a&gt;
signals,
&lt;code class=&quot;highlighter-rouge&quot;&gt;i_wrst_n&lt;/code&gt;, and &lt;code class=&quot;highlighter-rouge&quot;&gt;i_rrst_n&lt;/code&gt;.   These two
&lt;a href=&quot;/formal/2018/04/12/areset.html&quot;&gt;resets&lt;/a&gt;
are related to each other.  Specifically, we’ll assume that the two
&lt;a href=&quot;/formal/2018/04/12/areset.html&quot;&gt;resets&lt;/a&gt;
will always be asserted at the same time together, but that they are
only ever de-asserted with their respective clocks.  This latter criteria is
sometimes called asynchronous assertion with a synchronous release.&lt;/p&gt;

&lt;p&gt;You can see this concept drawn out in Fig 8 below.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 8. Asynchronous assertion, Synchronous Release&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/afifo-async-reset.svg&quot; alt=&quot;&quot; width=&quot;540&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;This is what we are going to insist, or rather assume, of our
&lt;a href=&quot;/formal/2018/04/12/areset.html&quot;&gt;reset&lt;/a&gt;.  (Remember: assume
inputs, assert local state and outputs.)&lt;/p&gt;

&lt;p&gt;But first, let’s discuss the initial state of the
&lt;a href=&quot;/formal/2018/04/12/areset.html&quot;&gt;reset&lt;/a&gt;.
Initially, I wanted to assume that both resets started asserted.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	initial	assume(!i_wrst_n);
	initial	assume(!i_rrst_n);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;What happens, though, with this approach when you want to implement a design
where the
&lt;a href=&quot;/formal/2018/04/12/areset.html&quot;&gt;reset&lt;/a&gt;s are both hard-wired
high (inactive)?  This should be an allowed configuration for an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;.
Instead, let’s only assume that both
&lt;a href=&quot;/formal/2018/04/12/areset.html&quot;&gt;resets&lt;/a&gt;
start out the same.  That is, either the design starts with both
&lt;a href=&quot;/formal/2018/04/12/areset.html&quot;&gt;resets&lt;/a&gt;
active or with no
&lt;a href=&quot;/formal/2018/04/12/areset.html&quot;&gt;resets&lt;/a&gt;
active.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	initial	assume(i_wrst_n == i_rrst_n);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;We’ll also assume that both
&lt;a href=&quot;/formal/2018/04/12/areset.html&quot;&gt;resets&lt;/a&gt;
are driven from one source.  That means that if one
&lt;a href=&quot;/formal/2018/04/12/areset.html&quot;&gt;reset&lt;/a&gt;
line falls, i.e. that
&lt;a href=&quot;/formal/2018/04/12/areset.html&quot;&gt;reset&lt;/a&gt;
is asserted, then the other must fall as well–just as we illustrated in Fig 8
above.  Neither &lt;a href=&quot;/formal/2018/04/12/areset.html&quot;&gt;reset&lt;/a&gt;
should be asserted without the other.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @($global_clock)
		assume($fell(i_wrst_n)==$fell(i_rrst_n));&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This assumption has a sad consequence: because it is a clocked assumption,
which it needs to be in order to evaluate &lt;code class=&quot;highlighter-rouge&quot;&gt;$fell()&lt;/code&gt;, it will take a clock
edge before this assumption is applied.  As a result, many of our assertions,
particularly those that depend upon results from both
&lt;a href=&quot;/formal/2018/04/12/areset.html&quot;&gt;resets&lt;/a&gt;,
which would otherwise have depended on &lt;code class=&quot;highlighter-rouge&quot;&gt;@(*)&lt;/code&gt; are instead asserted on
&lt;code class=&quot;highlighter-rouge&quot;&gt;@($global_clock)&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;We’ll also assume a synchronous release from
&lt;a href=&quot;/formal/2018/04/12/areset.html&quot;&gt;reset&lt;/a&gt;, also shown in Fig 8
above.  Hence, if the associated clock doesn’t rise, then neither should the
&lt;a href=&quot;/formal/2018/04/12/areset.html&quot;&gt;reset&lt;/a&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @($global_clock)
	if (!$rose(i_wclk))
		assume(!$rose(i_wrst_n));

	always @($global_clock)
	if (!$rose(i_rclk))
		assume(!$rose(i_rrst_n));&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Before we leave the discussion of the
&lt;a href=&quot;/formal/2018/04/12/areset.html&quot;&gt;reset&lt;/a&gt;,
there’s one more item to check.  Following any
&lt;a href=&quot;/formal/2018/04/12/areset.html&quot;&gt;reset&lt;/a&gt;,
the read and write pointers should be zero.  If the write side deasserts the
&lt;a href=&quot;/formal/2018/04/12/areset.html&quot;&gt;reset&lt;/a&gt;
first, the write pointer may start incrementing before the read
pointer.  On the other hand, if the read side leaves the
&lt;a href=&quot;/formal/2018/04/12/areset.html&quot;&gt;reset&lt;/a&gt;
state first, it shouldn’t be allowed to read anything until something has
been written into
&lt;a href=&quot;https://github.com/ZipCPU/website/blob/master/examples/afifo.v&quot;&gt;the FIFO&lt;/a&gt;.
Hence, we’ll assert that anytime the write
&lt;a href=&quot;/formal/2018/04/12/areset.html&quot;&gt;reset&lt;/a&gt;
is low that the read address must point to the beginning of
&lt;a href=&quot;https://github.com/ZipCPU/website/blob/master/examples/afifo.v&quot;&gt;the FIFO&lt;/a&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @($global_clock)
	if (!i_wrst_n)
		assert(rbin == 0);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h2 id=&quot;assuming-synchronous-inputs&quot;&gt;Assuming Synchronous Inputs&lt;/h2&gt;

&lt;p&gt;Whenever you build a set of
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal properties&lt;/a&gt;
to describe logic in multiple
&lt;a href=&quot;/blog/2017/10/20/cdc.html&quot;&gt;clock domains&lt;/a&gt;,
you’ll want to assume that the inputs associated with each
&lt;a href=&quot;/blog/2017/10/20/cdc.html&quot;&gt;clock domain&lt;/a&gt;
remain synchronous to that
&lt;a href=&quot;/blog/2017/10/20/cdc.html&quot;&gt;domain&lt;/a&gt;.
While technically whether or not this takes
place depends upon the problem, I personally find it disconcerting to watch
values change arbitrarily within the generated trace–values that should’ve
only changed on a clock edge.  Going one step further, we should also assert
that the outputs are synchronous with each
&lt;a href=&quot;/blog/2017/10/20/cdc.html&quot;&gt;domain&lt;/a&gt;
as well.&lt;/p&gt;

&lt;p&gt;The basic form of asserting that something is synchronous to a positive
edged clock is to assert that if the clock doesn’t rise, then the value should
be stable.  This needs to be done with the &lt;code class=&quot;highlighter-rouge&quot;&gt;$global_clock&lt;/code&gt;, since it’s
describing the minimum sub-clock time interval within the design.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @($global_clock)
	if (!$rose(clk))
		assert($stable(value));&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;You also need an &lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;f_past_valid&lt;/code&gt;
flag&lt;/a&gt; to
describe this as well.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	reg	f_past_valid_gbl;
	initial	f_past_valid_gbl = 1&#39;b0;
	always $($global_clock)
		f_past_valid_gbl &amp;lt;= 1&#39;b1;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;In our case, we can use three separate &lt;code class=&quot;highlighter-rouge&quot;&gt;f_past_valid&lt;/code&gt; types of flags: one for
each of the clocks in our design, &lt;code class=&quot;highlighter-rouge&quot;&gt;$global_clock&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;i_wclk&lt;/code&gt; (not shown), and
&lt;code class=&quot;highlighter-rouge&quot;&gt;i_rclk&lt;/code&gt; (not shown).  Without these values,
the solver will try to reference an undefined value before time began and
all assertions based upon this value would fail.  For this reason, all
references to &lt;code class=&quot;highlighter-rouge&quot;&gt;$past()&lt;/code&gt; or in this case to &lt;code class=&quot;highlighter-rouge&quot;&gt;$rose()&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;$fell()&lt;/code&gt;, or &lt;code class=&quot;highlighter-rouge&quot;&gt;$stable()&lt;/code&gt;
need to be qualified by an &lt;code class=&quot;highlighter-rouge&quot;&gt;f_past_valid&lt;/code&gt; piece of logic.  In this case,
by &lt;code class=&quot;highlighter-rouge&quot;&gt;f_past_valid_gbl&lt;/code&gt;–the &lt;code class=&quot;highlighter-rouge&quot;&gt;f_past_valid&lt;/code&gt; signal we created for the formal
time-step.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @($global_clock)
	if (f_past_valid_gbl)
	begin&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;In the case of the write clock, if the write clock hasn’t risen than the
write request line, &lt;code class=&quot;highlighter-rouge&quot;&gt;i_wr&lt;/code&gt;, and the write data, &lt;code class=&quot;highlighter-rouge&quot;&gt;i_wdata&lt;/code&gt;, should both
be assumed constant.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;		if (!$rose(i_wclk))
		begin
			assume($stable(i_wr));
			assume($stable(i_wdata));&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;In a similar manner, the &lt;code class=&quot;highlighter-rouge&quot;&gt;o_wfull&lt;/code&gt; flag should also
be constant.  Since this latter flag is an output, we’ll &lt;em&gt;assert&lt;/em&gt; that it is
constant rather than &lt;em&gt;assuming&lt;/em&gt; it.  The only difficulty being the
&lt;a href=&quot;/formal/2018/04/12/areset.html&quot;&gt;reset&lt;/a&gt;.
Specifically, if the write
&lt;a href=&quot;/formal/2018/04/12/areset.html&quot;&gt;reset&lt;/a&gt;
is ever asserted, then &lt;code class=&quot;highlighter-rouge&quot;&gt;o_wfull&lt;/code&gt; will drop asynchronously.  Hence,
we’ll need to check for that.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;			assert($stable(o_wfull)||(!i_wrst_n));
		end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The read logic is almost identical as well, so it’s not that remarkable.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;		if (!$rose(i_rclk))
		begin
			assume($stable(i_rd));
			assert((o_rempty)||($stable(o_rdata)));
			assert((!i_rrst_n)||($stable(o_rempty)));
		end
	end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This is just one of those rather tedious parts of an asynchronous proof.&lt;/p&gt;

&lt;h2 id=&quot;verifying-the-reset&quot;&gt;Verifying the Reset&lt;/h2&gt;

&lt;p&gt;My readers should understand why I use &lt;code class=&quot;highlighter-rouge&quot;&gt;f_past_valid&lt;/code&gt;: if you make an assertion
using the &lt;code class=&quot;highlighter-rouge&quot;&gt;$past&lt;/code&gt; operator, one were the &lt;code class=&quot;highlighter-rouge&quot;&gt;$past()&lt;/code&gt; operator references a value
before the initial time began, then the solver can immediately declare that
assertion to be invalid.  Not only that, there will be no trace associated
with that past assertion.  To keep this from happening, I use a register I call
&lt;code class=&quot;highlighter-rouge&quot;&gt;f_past_valid&lt;/code&gt;.  It’s initialized to zero, and then set immediately to one on
the first clock tick.&lt;/p&gt;

&lt;p&gt;This is all straightforward.  It’s something I’ve been doing for many proofs,
and I’ve posted about the &lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;reasons for it
already&lt;/a&gt;
on this blog.&lt;/p&gt;

&lt;p&gt;One time, however, I was caught by surprise when I examined a trace
describing a
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal proof&lt;/a&gt;
that crossed multiple files.  In this trace, the
&lt;code class=&quot;highlighter-rouge&quot;&gt;f_past_valid&lt;/code&gt; signals didn’t line up!  Some were true, others were false.
This should’ve never happened in real life.  What made it happen was
&lt;a href=&quot;/blog/2018/03/10/induction-exercise.html&quot;&gt;induction&lt;/a&gt;,
where the solver gets to pick the initial states for all values.&lt;/p&gt;

&lt;p&gt;To keep this from happening, I will often add statements to my design forcing
the design to be in
&lt;a href=&quot;/formal/2018/04/12/areset.html&quot;&gt;reset&lt;/a&gt;
any time &lt;code class=&quot;highlighter-rouge&quot;&gt;f_past_valid&lt;/code&gt; is false.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(*)
	if (!f_past_valid)
		assume(i_reset);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;I also use &lt;code class=&quot;highlighter-rouge&quot;&gt;f_past_valid&lt;/code&gt; to double check any initialization statements.  For
synchronous logic, this usually looks something like:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(posedge i_clk)
	if ((!f_past_valid)||($past(i_reset)))
	begin
		assert(value == 0);
		// ....
	end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;In this manner, I can insist that anytime one &lt;code class=&quot;highlighter-rouge&quot;&gt;f_past_valid&lt;/code&gt; is false, the
entire design is in its
&lt;a href=&quot;/formal/2018/04/12/areset.html&quot;&gt;reset&lt;/a&gt;
state, &lt;em&gt;and&lt;/em&gt; that the
&lt;a href=&quot;/formal/2018/04/12/areset.html&quot;&gt;reset&lt;/a&gt;
state is identical to the initial state.&lt;/p&gt;

&lt;p&gt;That’s not how I verified this design, though.  In particular, within this
design I wanted to allow the
&lt;a href=&quot;/formal/2018/04/12/areset.html&quot;&gt;reset&lt;/a&gt;,
line(s) to be tied high if the designer so chose.&lt;/p&gt;

&lt;p&gt;In this design, I used the fact that the
&lt;a href=&quot;/formal/2018/04/12/areset.html&quot;&gt;reset was asynchronous&lt;/a&gt;,
to do things a little differently.  Instead of checking whether the
&lt;a href=&quot;/formal/2018/04/12/areset.html&quot;&gt;reset&lt;/a&gt;
was true in the past, we’ll do this second check based upon whether the
&lt;a href=&quot;/formal/2018/04/12/areset.html&quot;&gt;reset&lt;/a&gt;
is currently asserted.&lt;/p&gt;

&lt;p&gt;Hence, anytime the write
&lt;a href=&quot;/formal/2018/04/12/areset.html&quot;&gt;reset&lt;/a&gt;
is asserted, or until the first write clock,
all of our write values should be in their initial states.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(*)
	if ((!f_past_valid_wr)||(!i_wrst_n))
	begin
		`ASSUME(i_wr == 0);
		//
		`ASSERT(wgray == 0);
		`ASSERT(wbin == 0);
		`ASSERT(!o_wfull);
		//
		`ASSERT(wq1_rgray == 0);
		`ASSERT(wq2_rgray == 0);
		`ASSERT(rq1_wgray == 0);
		`ASSERT(rq2_wgray == 0);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;While this section is all about the &lt;em&gt;write&lt;/em&gt; side of the interface,
we’ll make an exception to this rule for two values associated with the read
clock: the FIFO read address, &lt;code class=&quot;highlighter-rouge&quot;&gt;rbin&lt;/code&gt;, and its associated &lt;code class=&quot;highlighter-rouge&quot;&gt;o_rempty&lt;/code&gt; signal.
Anytime the registers in the write clock are in their
&lt;a href=&quot;/formal/2018/04/12/areset.html&quot;&gt;reset&lt;/a&gt;,
state, these read values must also remain in their
&lt;a href=&quot;/formal/2018/04/12/areset.html&quot;&gt;reset&lt;/a&gt;
values–since the write side hasn’t yet written anything to be read, and the
read pointer isn’t allowed to move forward from an empty FIFO while it’s still
empty, etc.  You get the idea.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;		//
		`ASSERT(rbin == 0);
		`ASSERT(o_rempty);
	end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The read side is less remarkable.  It also includes roughly the same logic.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(*)
	if ((!f_past_valid_rd)||(!i_rrst_n))
	begin
		`ASSUME(i_rd == 0);
		//
		`ASSERT(rgray == 0);
		`ASSERT(rbin == 0);
		`ASSERT(rq1_wgray == 0);
		`ASSERT(rq2_wgray == 0);
		`ASSERT(wq1_rgray == 0);
		`ASSERT(wq2_rgray == 0);
	end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;At this point, we know our design starts in a
&lt;a href=&quot;/formal/2018/04/12/areset.html&quot;&gt;reset&lt;/a&gt;
configuration either at the beginning of time, or following any
&lt;a href=&quot;/formal/2018/04/12/areset.html&quot;&gt;reset&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;verifying-the-fill-levels&quot;&gt;Verifying the Fill Levels&lt;/h2&gt;

&lt;p&gt;All of the steps so far have been preliminary, set up sorts of things.  None
of them have actually impacted the proof requirements we listed above.  Let’s
now move into the actual FIFO properties associated with its operation.
We’ll start with the pointers in this section, and then verify the two
element write test in the next section.  In between these two sections,
we’ll skip the proof of the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Gray_code&quot;&gt;Gray codes&lt;/a&gt;.
It follows directly from the discussion
above, and it is in the file if you wish to reference it.
Indeed, many of the properties associated with the fill of
&lt;a href=&quot;https://github.com/ZipCPU/website/blob/master/examples/afifo.v&quot;&gt;this FIFO&lt;/a&gt;
we’ve already discussed above, but they are important enough to discuss
one more time here.&lt;/p&gt;

&lt;p&gt;Will start with a measure of how full
&lt;a href=&quot;https://github.com/ZipCPU/website/blob/master/examples/afifo.v&quot;&gt;the FIFO&lt;/a&gt; is.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	wire	[AW:0]		f_fill;

	assign	f_fill = (wbin - rbin);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;I like to prefix values, like this one, that are only used in the
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal properties&lt;/a&gt;
with a &lt;code class=&quot;highlighter-rouge&quot;&gt;f_&lt;/code&gt;.  It helps me quickly recognize which values are used for the
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal proof&lt;/a&gt;,
and which are used within the design itself.&lt;/p&gt;

&lt;p&gt;As mentioned above, because &lt;code class=&quot;highlighter-rouge&quot;&gt;f_fill&lt;/code&gt; is a value only defined in our formal
properties, it can depend upon values that
&lt;a href=&quot;/blog/2017/10/20/cdc.html&quot;&gt;cross clock domains&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;As we indicated above, we’ll start out asserting that
&lt;a href=&quot;https://github.com/ZipCPU/website/blob/master/examples/afifo.v&quot;&gt;the FIFO&lt;/a&gt;
is initially empty, and that it never has more than &lt;code class=&quot;highlighter-rouge&quot;&gt;2^(AW)&lt;/code&gt; elements within it.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	initial	`ASSERT(f_fill == 0);
	always @($global_clock)
		`ASSERT(f_fill &amp;lt;= { 1&#39;b1, {(AW){1&#39;b0}} });&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Now let’s look at &lt;code class=&quot;highlighter-rouge&quot;&gt;o_wfull&lt;/code&gt;.  In particular, anytime
&lt;a href=&quot;https://github.com/ZipCPU/website/blob/master/examples/afifo.v&quot;&gt;the FIFO&lt;/a&gt;
is full, the &lt;code class=&quot;highlighter-rouge&quot;&gt;o_wfull&lt;/code&gt; flag should be asserted.  This property should help
to assure users of &lt;a href=&quot;https://github.com/ZipCPU/website/blob/master/examples/afifo.v&quot;&gt;this asynchronous
FIFO&lt;/a&gt;
that it actually works–at least, that this flag works.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	// Any time the FIFO is full, o_wfull should be true.  It may take a
	// clock or two to clear, though, so this is an implication and not
	// an equals.
	always @($global_clock)
	if (f_fill == {1&#39;b1,{(AW){1&#39;b0}}})
		`ASSERT(o_wfull);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;We’ll also check how things work on the clock before everything is full.
Specifically, if
&lt;a href=&quot;https://github.com/ZipCPU/website/blob/master/examples/afifo.v&quot;&gt;the FIFO&lt;/a&gt;
has &lt;code class=&quot;highlighter-rouge&quot;&gt;2^(AW)-1&lt;/code&gt; elements in it, it should then be
full on the next write.  That means that either the &lt;code class=&quot;highlighter-rouge&quot;&gt;o_wfull&lt;/code&gt; flag must be true,
there’s no request to write, or &lt;code class=&quot;highlighter-rouge&quot;&gt;o_wfull&lt;/code&gt; will be set to true on the next clock.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @($global_clock)
	if (f_fill == {1&#39;b0,{(AW){1&#39;b1}}})
		`ASSERT((wfull_next)||(!i_wr)||(o_wfull));&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This was one of those extra properties necessary to pass
&lt;a href=&quot;/blog/2018/03/10/induction-exercise.html&quot;&gt;induction&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;We’ll make a similar assertion about
&lt;a href=&quot;https://github.com/ZipCPU/website/blob/master/examples/afifo.v&quot;&gt;the FIFO&lt;/a&gt;
being empty:  Any time the FIFO is truly empty, the &lt;code class=&quot;highlighter-rouge&quot;&gt;o_rempty&lt;/code&gt; must be
true.  In this design, it will also be asserted at other times as well
(i.e. there’s a lag before its cleared), so as with the write check above it,
this is a one-way implication only, and not an equals.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @($global_clock)
	if (f_fill == 0)
		`ASSERT(o_rempty);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;We’ll add another assertion in here for good measure and to help with
&lt;a href=&quot;/blog/2018/03/10/induction-exercise.html&quot;&gt;induction&lt;/a&gt;.
Specifically, we’ll assert that if the &lt;code class=&quot;highlighter-rouge&quot;&gt;f_fill&lt;/code&gt; isn’t quite zero, then either
the empty flag is true, or the empty flag will be true on the next clock,
or nothing is being read.  Put simply, let’s check the logic before the fill
becomes empty just like we did with the logic before
&lt;a href=&quot;https://github.com/ZipCPU/website/blob/master/examples/afifo.v&quot;&gt;the FIFO&lt;/a&gt;
became full.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	// If the FIFO is about to be empty, the logic should be able
	// to detect that condition as well.
	always @($global_clock)
	if (f_fill == 1)
		`ASSERT((rempty_next)||(!i_rd)||(o_rempty));&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Consistency requires that the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Gray_code&quot;&gt;Gray&lt;/a&gt; pointers
always match their respective address pointers.  Let’s insist that be the
case here, lest the
&lt;a href=&quot;/blog/2018/03/10/induction-exercise.html&quot;&gt;induction engine&lt;/a&gt;
find some way to defeat this proof using an invalid state.  This applies for
both read and write &lt;a href=&quot;https://en.wikipedia.org/wiki/Gray_code&quot;&gt;Gray&lt;/a&gt; pointers.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(*)
		`ASSERT(wgray == ((wbin&amp;gt;&amp;gt;1)^wbin));

	always @(*)
		`ASSERT(rgray == ((rbin&amp;gt;&amp;gt;1)^rbin));&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Finally, let’s double check that our
&lt;a href=&quot;https://en.wikipedia.org/wiki/Gray_code&quot;&gt;Gray&lt;/a&gt; pointer
arithmetic truly does match
our address arithmetic.  Remember, in the design above, we pushed the empty
and full logic from combinatorial logic into clocked logic.  The combinatorial
logic should still hold, so let’s check it here.&lt;/p&gt;

&lt;p&gt;First, is
&lt;a href=&quot;https://github.com/ZipCPU/website/blob/master/examples/afifo.v&quot;&gt;the FIFO&lt;/a&gt;
full?  If so, the &lt;a href=&quot;https://en.wikipedia.org/wiki/Gray_code&quot;&gt;Gray&lt;/a&gt; pointers
should differ in their top bit but be identical for the rest of their bits.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(*)
		`ASSERT( (rgray == { ~wgray[AW:AW-1], wgray[AW-2:0] })
			== (f_fill == { 1&#39;b1, {(AW){1&#39;b0}} }) );&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Second, if &lt;a href=&quot;https://github.com/ZipCPU/website/blob/master/examples/afifo.v&quot;&gt;the
FIFO&lt;/a&gt; is empty,
and only if &lt;a href=&quot;https://github.com/ZipCPU/website/blob/master/examples/afifo.v&quot;&gt;the
FIFO&lt;/a&gt;
is empty, then the &lt;a href=&quot;https://en.wikipedia.org/wiki/Gray_code&quot;&gt;Gray&lt;/a&gt; pointers
should be identical.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(*)
		`ASSERT((rgray == wgray) == (f_fill == 0));&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;These are the basic properties we want to prove about
&lt;a href=&quot;https://github.com/ZipCPU/website/blob/master/examples/afifo.v&quot;&gt;the FIFO&lt;/a&gt;’s
fill amount.
If all you want is a bounded model check, you can skip to the next section.&lt;/p&gt;

&lt;p&gt;On the other hand, if you’d like a full
&lt;a href=&quot;/blog/2018/03/10/induction-exercise.html&quot;&gt;induction&lt;/a&gt;
check, and hence a proof for all time, then we need to check
that the values and registers associated with
&lt;a href=&quot;/blog/2017/10/20/cdc.html&quot;&gt;crossing clock domains&lt;/a&gt; are
valid as well.&lt;/p&gt;

&lt;p&gt;To do this, we’ll create 2-FF synchronizers within the
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal properties&lt;/a&gt;
section to delay the binary pointer values so they’ll have an image,
in the new clock domain, synchronous with the value of their
&lt;a href=&quot;https://en.wikipedia.org/wiki/Gray_code&quot;&gt;Gray&lt;/a&gt; versions.
Again, since this isn’t synthesizable code, there’s no danger of
&lt;a href=&quot;https://en.wikipedia.org/wiki/Metastability_in_electronics&quot;&gt;metastability&lt;/a&gt;
here, as there would be in the synthesis section above.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	reg	[AW:0]	f_w2r_rbin, f_w1r_rbin,
			f_r2w_wbin, f_r1w_wbin;
	wire	[AW:0]	f_w2r_fill, f_r2w_fill;

	initial	{ f_w2r_rbin, f_w1r_rbin } = 0;
	always @(posedge i_wclk or negedge i_wrst_n)
	if (!i_wrst_n)
		{ f_w2r_rbin, f_w1r_rbin } &amp;lt;= 0;
	else
		{ f_w2r_rbin, f_w1r_rbin } &amp;lt;= { f_w1r_rbin, rbin };

	initial	{ f_r2w_wbin, f_r1w_wbin } = 0;
	always @(posedge i_rclk or negedge i_rrst_n)
	if (!i_rrst_n)
		{ f_r2w_wbin, f_r1w_wbin } &amp;lt;= 0;
	else
		{ f_r2w_wbin, f_r1w_wbin } &amp;lt;= { f_r1w_wbin, wbin };&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The next step is to force these helper variables to be properly matched to
their &lt;a href=&quot;https://en.wikipedia.org/wiki/Gray_code&quot;&gt;Gray coded&lt;/a&gt;
counter parts.  (No pun intended.)  That is, we should be able to convert
these values to &lt;a href=&quot;https://en.wikipedia.org/wiki/Gray_code&quot;&gt;Gray code&lt;/a&gt; and they
should match.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(*)
		`ASSERT(rq1_wgray == ((f_r1w_wbin&amp;gt;&amp;gt;1)^f_r1w_wbin));
	always @(*)
		`ASSERT(rq2_wgray == ((f_r2w_wbin&amp;gt;&amp;gt;1)^f_r2w_wbin));

	always @(*)
		`ASSERT(wq1_rgray == ((f_w1r_rbin&amp;gt;&amp;gt;1)^f_w1r_rbin));
	always @(*)
		`ASSERT(wq2_rgray == ((f_w2r_rbin&amp;gt;&amp;gt;1)^f_w2r_rbin));&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Finally, we can calculate the fill at the other end of this synchronizer
chain.  These two fill values, one using &lt;code class=&quot;highlighter-rouge&quot;&gt;wbin&lt;/code&gt; and the re-synchronized &lt;code class=&quot;highlighter-rouge&quot;&gt;rbin&lt;/code&gt;,
the other using &lt;code class=&quot;highlighter-rouge&quot;&gt;rbin&lt;/code&gt; and the re-synchronized &lt;code class=&quot;highlighter-rouge&quot;&gt;wbin&lt;/code&gt;, should clearly describe
our &lt;code class=&quot;highlighter-rouge&quot;&gt;o_wfull&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;o_rempty&lt;/code&gt; flags.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	assign	f_w2r_fill = wbin - f_w2r_rbin;
	assign	f_r2w_fill = f_r2w_wbin - rbin;


	// And assert that the fill is always less than or equal to full.
	// This catches underrun as well as overflow, since underrun will
	// look like the fill suddenly increases
	always @(*)
		`ASSERT(f_w2r_fill &amp;lt;= { 1&#39;b1, {(AW){1&#39;b0}} });
	always @(*)
		`ASSERT(f_r2w_fill &amp;lt;= { 1&#39;b1, {(AW){1&#39;b0}} });

	// From the writers perspective, anytime the Gray pointers are
	// equal save for the top bit, the FIFO is full and should be asserted
	// as such.  It is possible for the FIFO to be asserted as full at
	// some other times as well.
	always @(*)
	if (wgray == { ~wq2_rgray[AW:AW-1], wq2_rgray[AW-2:0] })
		`ASSERT(o_wfull);

	// The same basic principle applies to the reader as well.  From the
	// readers perspective, anytime the Gray pointers are equal the FIFO
	// is empty, and should be asserted as such.
	always @(*)
	if (rgray == rq2_wgray)
		`ASSERT(o_rempty);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;At this point, we now have full confidence in our two flags, &lt;code class=&quot;highlighter-rouge&quot;&gt;o_wfull&lt;/code&gt; and
&lt;code class=&quot;highlighter-rouge&quot;&gt;o_rempty&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;When I first
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formally verified&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/website/blob/master/examples/afifo.v&quot;&gt;this FIFO&lt;/a&gt;,
this was where I stopped.  Then I was told of &lt;a href=&quot;http://www.techdesignforums.com/practice/technique/doc-formal-harness-the-power-of-invariant-based-bug-hunting/&quot;&gt;additional FIFO
property&lt;/a&gt;,
which we’ll discuss in the next
section.&lt;/p&gt;

&lt;h2 id=&quot;fifo-contract&quot;&gt;FIFO Contract&lt;/h2&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 9. Two consecutive items written to a FIFO, must be able to be read out consecutively at a later time&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/afifo-two-items.svg&quot; alt=&quot;&quot; width=&quot;420&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;I’ve now been a part of and read several discussions about how to 
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formally verify&lt;/a&gt;
a FIFO–whether synchronous or asynchronous.  I’ve even found
&lt;a href=&quot;http://www.techdesignforums.com/practice/technique/doc-formal-harness-the-power-of-invariant-based-bug-hunting/&quot;&gt;one reference to this method&lt;/a&gt; as well,
although there must be more.
These discussions all revolve around two arbitrary values written to
&lt;a href=&quot;https://github.com/ZipCPU/website/blob/master/examples/afifo.v&quot;&gt;the FIFO&lt;/a&gt;
in succession, that then need to be able to be read out of the in succession.&lt;/p&gt;

&lt;p&gt;This was a new criteria for me when I first heard it, so I decided to try
it on one of my own FIFOs to see if it would work.  It didn’t pass
(originally)–I was overwriting the FIFO’s tail on any write request during
overrun.  Oops.  Hence, while I used to think this criteria wasn’t all that
necessary, I no longer hold that view.&lt;/p&gt;

&lt;p&gt;If you read 
&lt;a href=&quot;http://www.techdesignforums.com/practice/technique/doc-formal-harness-the-power-of-invariant-based-bug-hunting/&quot;&gt;Doc Formal’s article&lt;/a&gt;
on &lt;a href=&quot;/formal/2018/04/23/invariant.html&quot;&gt;invariants&lt;/a&gt;,
or the slides I saw at &lt;a href=&quot;https://dvcon.org-us-2018&quot;&gt;DVCON 2018&lt;/a&gt;,
they all made this proof look quite easy.  When I actually tried it myself,
I couldn’t figure out how to keep it as simple as the slides presented it.  In
particular, how can you constrain the formal engine in such a way that the
parts of the proof don’t get out of hand and into an inconsistent state?&lt;/p&gt;

&lt;p&gt;As a result, we’ll apply this criteria below in such a constrained way that
there’s no way the solver could get it wrong.  Specifically, if the solver
starts in the middle of the two element sequence described by this contract,
we’ll make certain below that the state the solver finds itself within matches
our own internal state in every way and in every step along the way.&lt;/p&gt;

&lt;p&gt;So let’s start out by picking an arbitrary location within
&lt;a href=&quot;https://github.com/ZipCPU/website/blob/master/examples/afifo.v&quot;&gt;the FIFO&lt;/a&gt;,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	(* anyconst *) wire [AW:0]		f_const_addr;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;and a location immediately following it.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	wire	[AW:0]		f_const_next_addr;

	assign	f_const_next_addr = f_const_addr + 1;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Let’s also pick two arbitrary values which will eventually will be placed in
those
locations.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	(* anyconst *) reg [DW-1:0]	f_const_first, f_const_next;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Let’s also create an expression that will be true anytime the first address,
&lt;code class=&quot;highlighter-rouge&quot;&gt;f_const_addr&lt;/code&gt;, is within the valid set of FIFO values.  This is tricky
because the read and write pointers will wrap around the end of the FIFO,
so we’ll have to break this out by stages.  Since it’s non-intuitive,
we’ll show this graphically as we go along.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	reg			f_addr_valid, f_next_valid;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Looking at the first address, &lt;code class=&quot;highlighter-rouge&quot;&gt;f_const_addr&lt;/code&gt;, if the read pointer follows
the write pointer in order, and &lt;code class=&quot;highlighter-rouge&quot;&gt;f_const_addr&lt;/code&gt; is between the two, then
&lt;code class=&quot;highlighter-rouge&quot;&gt;f_const_addr&lt;/code&gt; references an item within
&lt;a href=&quot;https://github.com/ZipCPU/website/blob/master/examples/afifo.v&quot;&gt;the FIFO&lt;/a&gt;.
This case is shown in Fig 10 below.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 10. The Arbitrary Address lies between the Read and Write Pointers&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/afifo-case-one.svg&quot; alt=&quot;&quot; width=&quot;540&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Given the picture above, the test should start to make sense.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(*)
	begin
		f_addr_valid = 1&#39;b0;
		if((wbin &amp;gt; rbin)&amp;amp;&amp;amp;(wbin &amp;gt; f_const_addr)
					&amp;amp;&amp;amp;(rbin &amp;lt;= f_const_addr))
			// Order rbin &amp;lt;= addr &amp;lt; wbin
			f_addr_valid = 1&#39;b1;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;In a similar fashion, if &lt;code class=&quot;highlighter-rouge&quot;&gt;wbin&lt;/code&gt; has wrapped around so that the write pointer
is now less than the read pointer, &lt;code class=&quot;highlighter-rouge&quot;&gt;rbin&lt;/code&gt;, but &lt;code class=&quot;highlighter-rouge&quot;&gt;f_const_addr&lt;/code&gt; remains less
than the write pointer, then &lt;code class=&quot;highlighter-rouge&quot;&gt;f_const_addr&lt;/code&gt; is within
&lt;a href=&quot;https://github.com/ZipCPU/website/blob/master/examples/afifo.v&quot;&gt;the FIFO&lt;/a&gt;.
This is shown in Fig 11 below.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 11. The Arbitrary Address lies between the Read and Write Pointers&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/afifo-case-two.svg&quot; alt=&quot;&quot; width=&quot;540&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;		else if ((wbin &amp;lt; rbin)&amp;amp;&amp;amp;(f_const_addr &amp;lt; wbin))
			// addr &amp;lt; wbin &amp;lt; rbin
			f_addr_valid = 1&#39;b1;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Finally, if the write pointer is less than the read pointer, but &lt;code class=&quot;highlighter-rouge&quot;&gt;f_const_addr&lt;/code&gt;
lies after the read pointer, then the address is in
&lt;a href=&quot;https://github.com/ZipCPU/website/blob/master/examples/afifo.v&quot;&gt;the FIFO&lt;/a&gt;.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 12. The Arbitrary Address lies between the Read and Write Pointers&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/afifo-case-three.svg&quot; alt=&quot;&quot; width=&quot;540&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;		else if ((wbin &amp;lt; rbin)&amp;amp;&amp;amp;(rbin &amp;lt;= f_const_addr))
			// wbin &amp;lt; rbin &amp;lt; addr
			f_addr_valid = 1&#39;b1;
	end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;I’ll skip the similar, though identical, comparison for the next address
following, &lt;code class=&quot;highlighter-rouge&quot;&gt;f_const_next_addr&lt;/code&gt;.  You can find it within &lt;a href=&quot;https://github.com/ZipCPU/website/blob/master/examples/afifo.v&quot;&gt;the verilog code for
the FIFO&lt;/a&gt;
if you like.&lt;/p&gt;

&lt;p&gt;The next step is to implement the logic shown in Fig 9 above.  With all the
associated details, this becomes rather complex, so let’s break it down a bit.
Specifically, we’ll create some logic to determine if the first, second, or
both values are in
&lt;a href=&quot;https://github.com/ZipCPU/website/blob/master/examples/afifo.v&quot;&gt;the FIFO&lt;/a&gt;.
That is, not only is their address a valid reference to an item within
&lt;a href=&quot;https://github.com/ZipCPU/website/blob/master/examples/afifo.v&quot;&gt;the FIFO&lt;/a&gt;,
but the data at that address must match as well.&lt;/p&gt;

&lt;p&gt;For the first value to be in
&lt;a href=&quot;https://github.com/ZipCPU/website/blob/master/examples/afifo.v&quot;&gt;the FIFO&lt;/a&gt;,
1) it’s address must lie within
&lt;a href=&quot;https://github.com/ZipCPU/website/blob/master/examples/afifo.v&quot;&gt;the FIFO&lt;/a&gt;,
and 2) the value at that address must match the first of our two values.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	wire	f_first_in_fifo, f_second_in_fifo, f_both_in_fifo;

	always @(*)
		f_first_in_fifo = (f_addr_valid)
				&amp;amp;&amp;amp;(mem[f_const_addr[AW-1:0]]==f_const_first);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The same logic applies to the second value within
&lt;a href=&quot;https://github.com/ZipCPU/website/blob/master/examples/afifo.v&quot;&gt;our FIFO&lt;/a&gt;,
only we’ll check against the next address, &lt;code class=&quot;highlighter-rouge&quot;&gt;f_const_next_addr&lt;/code&gt;, and the value
against &lt;code class=&quot;highlighter-rouge&quot;&gt;f_const_next&lt;/code&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(*)
		f_second_in_fifo = (f_next_valid)
				&amp;amp;&amp;amp;(mem[f_const_next_addr[AW-1:0]]==f_const_next);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Finally, we’ll set &lt;code class=&quot;highlighter-rouge&quot;&gt;f_both_in_fifo&lt;/code&gt; to only be true if both values are within
&lt;a href=&quot;https://github.com/ZipCPU/website/blob/master/examples/afifo.v&quot;&gt;the FIFO&lt;/a&gt;,
at their respective address locations.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(*)
		f_both_in_fifo = (f_first_in_fifo)&amp;amp;&amp;amp;(f_second_in_fifo);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Conceptually, this might look like Fig 13 below.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 13. Both addresses and data items lie within the FIFO&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/afifo-case-both.svg&quot; alt=&quot;&quot; width=&quot;540&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;At this point we want to assert that if both values are in
&lt;a href=&quot;https://github.com/ZipCPU/website/blob/master/examples/afifo.v&quot;&gt;the FIFO&lt;/a&gt;,
then we should at some point later in time be able to read them both out one
by one.&lt;/p&gt;

&lt;p&gt;If you read other articles on FIFOs, you’ll often see them simplified
using a concurrent assertion so that the logic reads something like:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	assert property (@(posedge i_clk)
		disable iff (i_rrst_n)
		f_both_in_fifo |-&amp;gt;
			f_wait_for_first_read [*0:$]
			##1 f_read_first
			##1 f_wait_for_second_read [*0:$]
			##1 f_read_second);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Decoding this, it means that if both values are in
&lt;a href=&quot;https://github.com/ZipCPU/website/blob/master/examples/afifo.v&quot;&gt;the FIFO&lt;/a&gt;,
then
&lt;a href=&quot;https://github.com/ZipCPU/website/blob/master/examples/afifo.v&quot;&gt;the FIFO&lt;/a&gt;
can remain in that state indefinitely, or alternatively a read request can
read the first value from
&lt;a href=&quot;https://github.com/ZipCPU/website/blob/master/examples/afifo.v&quot;&gt;the FIFO&lt;/a&gt;.
Then, &lt;a href=&quot;https://github.com/ZipCPU/website/blob/master/examples/afifo.v&quot;&gt;the FIFO&lt;/a&gt;
can wait with the second value in memory indefinitely
or (ultimately) it can be read out.&lt;/p&gt;

&lt;p&gt;The problem with this simplified notation is all the details.
Worse, in my case I wanted to be able to support an
&lt;a href=&quot;/blog/2018/03/10/induction-exercise.html&quot;&gt;induction&lt;/a&gt;
length shorter than the entire (potentially infinite) sequence length.  To make
certain the solver could handle this case, I wanted to make certain that every
state within the sequence was constrained unambiguously.  All registers
associated with each of the states
needed to be fully constrained so there was no room for the solver to
place the design into an invalid state.&lt;/p&gt;

&lt;p&gt;Again, feel free to use Fig 9 above as a reference in this discussion below.&lt;/p&gt;

&lt;p&gt;For example, waiting for the first read means that both values must be in
&lt;a href=&quot;https://github.com/ZipCPU/website/blob/master/examples/afifo.v&quot;&gt;the FIFO&lt;/a&gt;,
and that neither are being read at that time.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	wire	f_wait_for_first_read, f_read_first, f_read_second,
		f_wait_for_second_read;

	always @(*)
		f_wait_for_first_read = (f_both_in_fifo)
				&amp;amp;&amp;amp;((!i_rd)||(f_const_addr != rbin)||(o_rempty));&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Notice the &lt;code class=&quot;highlighter-rouge&quot;&gt;o_rempty&lt;/code&gt; flag.  I wasn’t expecting this one.  If both items are in
&lt;a href=&quot;https://github.com/ZipCPU/website/blob/master/examples/afifo.v&quot;&gt;the FIFO&lt;/a&gt;,
then &lt;code class=&quot;highlighter-rouge&quot;&gt;o_rempty&lt;/code&gt; should be zero already, right?  Not quite.  When I ran
&lt;a href=&quot;https://symbiyosys.readthedocs.io/en/latest&quot;&gt;SymbiYosys&lt;/a&gt;,
the produced trace reminded me that while &lt;code class=&quot;highlighter-rouge&quot;&gt;o_rempty&lt;/code&gt; will be raised any time
the design is empty, it may take a couple of clock cycles after the design
is no longer empty in order to be lowered.  Hence, if &lt;code class=&quot;highlighter-rouge&quot;&gt;i_rd&lt;/code&gt; is true but
&lt;code class=&quot;highlighter-rouge&quot;&gt;o_rempty&lt;/code&gt; is also true, then no read is taking place and we’ll need to keep
waiting for that first read.&lt;/p&gt;

&lt;p&gt;Reading the first value from
&lt;a href=&quot;https://github.com/ZipCPU/website/blob/master/examples/afifo.v&quot;&gt;the FIFO&lt;/a&gt;
means that there must be a read request,
&lt;a href=&quot;https://github.com/ZipCPU/website/blob/master/examples/afifo.v&quot;&gt;the FIFO&lt;/a&gt;
must not be empty (finally), and the read request must be of the first value.
Further, at the time of this read, both values must still be in
&lt;a href=&quot;https://github.com/ZipCPU/website/blob/master/examples/afifo.v&quot;&gt;the FIFO&lt;/a&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(*)
		f_read_first = (i_rd)&amp;amp;&amp;amp;(o_rdata == f_const_first)&amp;amp;&amp;amp;(!o_rempty)
			&amp;amp;&amp;amp;(rbin == f_const_addr)&amp;amp;&amp;amp;(f_both_in_fifo);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;We’ll then wait for our second read.  This may take between zero and an
infinite number of clock cycles.  While waiting, the second value must
be still in
&lt;a href=&quot;https://github.com/ZipCPU/website/blob/master/examples/afifo.v&quot;&gt;the FIFO&lt;/a&gt;,
the read pointer must point to the second of our two
addresses, and we can’t allow any reads from
&lt;a href=&quot;https://github.com/ZipCPU/website/blob/master/examples/afifo.v&quot;&gt;the FIFO&lt;/a&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(*)
		f_wait_for_second_read = (f_second_in_fifo)
				&amp;amp;&amp;amp;((!i_rd)||(o_rempty))
				&amp;amp;&amp;amp;(f_const_next_addr == rbin);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Finally, the last stage in our test is the one where the second value is read
from &lt;a href=&quot;https://github.com/ZipCPU/website/blob/master/examples/afifo.v&quot;&gt;the FIFO&lt;/a&gt;.
In this case, there must be a read request, the read data
must match the data we started with,
&lt;a href=&quot;https://github.com/ZipCPU/website/blob/master/examples/afifo.v&quot;&gt;the FIFO&lt;/a&gt;
cannot be empty, the address must match, etc.  It’s a mouthful!&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(*)
		f_read_second = (i_rd)&amp;amp;&amp;amp;(o_rdata == f_const_next)&amp;amp;&amp;amp;(!o_rempty)
				&amp;amp;&amp;amp;(rbin == f_const_next_addr)
				&amp;amp;&amp;amp;(f_second_in_fifo);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;You may have noticed that I’ve just assigned values to variables.  These
values describe the various states the FIFO may be in, but they don’t (yet)
string those states together via an assertion of any type.  That’s coming
next.&lt;/p&gt;

&lt;p&gt;If you ever find yourself needing to do this, let me share with you what not
to do.  Do not place all of these criteria into one big huge property like
the one shown below.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	assert property (@(posedge i_clk)
		(f_first_in_fifo)&amp;amp;&amp;amp;(f_second_in_fifo);
		|-&amp;gt; (f_first_in_fifo)&amp;amp;&amp;amp;(f_second_in_fifo)
			&amp;amp;&amp;amp;((!i_rd)||(f_const_addr != rbin)||(o_rempty)) [*0:$]
		##1 (i_rd)&amp;amp;&amp;amp;(o_rdata == f_const_first)&amp;amp;&amp;amp;(!o_rempty)
			&amp;amp;&amp;amp;(rbin == f_const_addr)
			&amp;amp;&amp;amp;(f_first_in_fifo)&amp;amp;&amp;amp;(f_second_in_fifo);
		##1 (f_second_in_fifo)
				&amp;amp;&amp;amp;((!i_rd)||(o_rempty))
				&amp;amp;&amp;amp;(f_const_next_addr == rbin) [*0:$]
		##1 (i_rd)&amp;amp;&amp;amp;(o_rdata == f_const_next)&amp;amp;&amp;amp;(!o_rempty)
				&amp;amp;&amp;amp;(rbin == f_const_next_addr)
				&amp;amp;&amp;amp;(f_second_in_fifo));&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;(My initial attempt was even worse–I didn’t use &lt;code class=&quot;highlighter-rouge&quot;&gt;f_first_in_fifo&lt;/code&gt; or
&lt;code class=&quot;highlighter-rouge&quot;&gt;f_sceond_in_fifo&lt;/code&gt;.)&lt;/p&gt;

&lt;p&gt;The problem with such a complicated property is, what happens when it fails?
In my case, &lt;a href=&quot;https://symbiyosys.readthedocs.io/en/latest&quot;&gt;SymbiYosys&lt;/a&gt;
would say that the assertion failed, and then
give me the line of this assertion and a trace showing me that the assertion
had failed.  It never said which part of the assertion, which line within the
assertion, or which step the assertion was within, was the one that failed.
The line number was always the line number of the whole assertion sequence.&lt;/p&gt;

&lt;p&gt;You can guess how I solved this problem using the state definitions we just
defined above.  By creating wires to contain these complicated logic
components, these logic components describing which state we are in then
show up on the trace.  This made it possible for me to understand the trace,
and thus to see what was going wrong.&lt;/p&gt;

&lt;p&gt;On the other hand, if you are using the open source version of
&lt;a href=&quot;https://symbiyosys.readthedocs.io/en/latest&quot;&gt;SymbiYosys&lt;/a&gt;,
then you’ll have to describe this check using immediate assertions alone.
Again, the wires defining the various states above will help us simplify the
state machine we’ll need to write.&lt;/p&gt;

&lt;p&gt;Starting at the top, we’ll create a quick state transition checker that will
be disabled any time &lt;code class=&quot;highlighter-rouge&quot;&gt;i_wrst_n&lt;/code&gt; gets asserted.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @($global_clock)
	if ((f_past_valid_gbl)&amp;amp;&amp;amp;(i_wrst_n))
	begin&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The state starts with both items in
&lt;a href=&quot;https://github.com/ZipCPU/website/blob/master/examples/afifo.v&quot;&gt;the FIFO&lt;/a&gt;,
or equivalently with &lt;code class=&quot;highlighter-rouge&quot;&gt;f_both_in_fifo&lt;/code&gt; true.  Following &lt;code class=&quot;highlighter-rouge&quot;&gt;f_both_in_fifo&lt;/code&gt;, we
can either read the first value or continue waiting for the
first value to be read.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;		if ((!$past(f_read_first))&amp;amp;&amp;amp;(($past(f_both_in_fifo))))
			assert((f_wait_for_first_read)
				|| (($rose(i_rclk))&amp;amp;&amp;amp;(f_read_first)));&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Let me point you attention to the &lt;code class=&quot;highlighter-rouge&quot;&gt;$rose(i_rclk)&lt;/code&gt; condition for a moment.  The
first value cannot be read without a read that starts on the rising read
clock edge.&lt;/p&gt;

&lt;p&gt;Once we’ve read that first value, we’ll need to stay in that state until the
next clock edge.  On the next read clock edge, we can either read the second
value, or start waiting for the second value to be read.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;		if ($past(f_read_first))
			assert(
				((!$rose(i_rclk))&amp;amp;&amp;amp;(f_read_first))
				||($rose(i_rclk)&amp;amp;&amp;amp;((f_read_second)
						||(f_wait_for_second_read))));&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Finally, if we were waiting for the second value to be read on the last time
step, then we can continue waiting on this time step, or if the clock rises
we can actually start reading the second value.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;		if ($past(f_wait_for_second_read))
			assert((f_wait_for_second_read)
				||(($rose(i_rclk))&amp;amp;&amp;amp;(f_read_second)));
	end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;There you have it!  That’s the majority of this proof.&lt;/p&gt;

&lt;p&gt;In hindsight, I probably didn’t need all of those free variables,
those using &lt;code class=&quot;highlighter-rouge&quot;&gt;(* anyconst *)&lt;/code&gt;, to make this work.  If I have to come back to
this later, I may remove them–instead reflecting that any input value is
by default a free variable of its own right.&lt;/p&gt;

&lt;h2 id=&quot;cover-properties&quot;&gt;Cover Properties&lt;/h2&gt;

&lt;p&gt;We’re not quite done yet.  We’d still
like to know about whether or not some things that might actually take place.
This was the fourth part in our proof outline above.  So far, we’ve skipped
it.  We’ve proved parts one through five except for part four.  Part four
requires us to demonstrate that
&lt;a href=&quot;https://github.com/ZipCPU/website/blob/master/examples/afifo.v&quot;&gt;the FIFO&lt;/a&gt;
can actually fill, and that it can actually empty.&lt;/p&gt;

&lt;p&gt;Why might we need this?  Consider, what
would happen if we had somehow accidentally assumed
&lt;a href=&quot;https://github.com/ZipCPU/website/blob/master/examples/afifo.v&quot;&gt;the FIFO&lt;/a&gt;
would remain empty, or that it would never reach it’s fill?  Just to make
certain we didn’t mess things up, let’s make sure several states are reachable.&lt;/p&gt;

&lt;p&gt;First, let’s make sure we can enter the empty state.  This is good since
we start up in the empty state.  In order to return to empty, the FIFO must
be able to both receive a value into it and to have a value read out of it.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @($global_clock)
	if (f_past_valid_gbl)
		cover((o_rempty)&amp;amp;&amp;amp;(!$past(o_rempty)));&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The same basic logic applies to the full state.  The design starts out
non-full, and we’d like to have some assurance that
&lt;a href=&quot;https://github.com/ZipCPU/website/blob/master/examples/afifo.v&quot;&gt;the FIFO&lt;/a&gt;
can be filled, and also that it can leave its full condition.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(posedge i_wclk)
	if (f_past_valid_wr)
		cover($past(o_wfull)&amp;amp;&amp;amp;(!o_wfull));&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;If you check out
&lt;a href=&quot;https://github.com/ZipCPU/website/blob/master/examples/afifo.v&quot;&gt;the design&lt;/a&gt;,
you’ll find there are several other cover properties as well.  Feel free
to examine and comment on whether I may have missed any.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;`endif
endmodule&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h2 id=&quot;conclusions&quot;&gt;Conclusions&lt;/h2&gt;

&lt;p&gt;Voila!  All of what you need to know to
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formally verify&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/website/blob/master/examples/afifo.v&quot;&gt;an asynchronous
FIFO&lt;/a&gt;.
Yes, it took a lot of work, but the good thing is that this work
only needed to be done once.  Now you can use
&lt;a href=&quot;https://github.com/ZipCPU/website/blob/master/examples/afifo.v&quot;&gt;this FIFO&lt;/a&gt;
to &lt;a href=&quot;/blog/2017/10/20/cdc.html&quot;&gt;cross clock domains&lt;/a&gt;
with all kinds of things like … bus requests even!&lt;/p&gt;

&lt;p&gt;Still not convinced?  Feel free to examine &lt;a href=&quot;https://github.com/ZipCPU/website/blob/master/examples/afifo.v&quot;&gt;the code and the
properties&lt;/a&gt;
yourself.  You can even add your own properties, in case I’ve missed
any–whatever it takes to convince you that this
&lt;a href=&quot;https://github.com/ZipCPU/website/blob/master/examples/afifo.v&quot;&gt;FIFO&lt;/a&gt;
actually works.&lt;/p&gt;

&lt;p&gt;Now, what shall we use this for?&lt;/p&gt;

&lt;p&gt;Perhaps we could use this to cross clock domains using a bus?  For example,
what if you had two &lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;wishbone
buses&lt;/a&gt;, one in each of two
&lt;a href=&quot;/blog/2017/10/20/cdc.html&quot;&gt;clock domains&lt;/a&gt;.
&lt;a href=&quot;/blog/2017/10/20/cdc.html&quot;&gt;Crossing
clock domains&lt;/a&gt;
with between those &lt;a href=&quot;/blog/2017/11/07/wb-formal.html&quot;&gt;buses&lt;/a&gt;
can be a challenge.  Not only that, but it’s a particularly challenge required
by just about any &lt;a href=&quot;https://github.com/ZipCPU/vgasim&quot;&gt;video system&lt;/a&gt;.  Why?
Well, it just so happens that in every video design I’ve ever done (there
haven’t been that many), the pixel clock ends up being at one frequency
and the memory (and system) clock is at another.  Hence, I’d like to come
back to &lt;a href=&quot;https://github.com/ZipCPU/website/blob/master/examples/afifo.v&quot;&gt;this FIFO
design&lt;/a&gt;
later and modify it so that it produces an output fill level for a
&lt;a href=&quot;https://github.com/ZipCPU/vgasim/blob/master/rtl/imgfifo.v&quot;&gt;frame buffer&lt;/a&gt;
controller.
Such a controller will wait until there is room for another burst length
in the buffer before trying to fill the buffer with a burst.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 14. Asynchronous FIFO within a Video Application&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/afifo-video.svg&quot; alt=&quot;&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Indeed, that’s part of the
&lt;a href=&quot;https://github.com/ZipCPU/vgasim&quot;&gt;VGA simulator&lt;/a&gt;
I recently posted on line.
&lt;a href=&quot;https://github.com/ZipCPU/vgasim&quot;&gt;That project&lt;/a&gt;
includes simulation code for both a
&lt;a href=&quot;https://github.com/ZipCPU/vgasim/blob/master/bench/cpp/vgasource.cpp&quot;&gt;source&lt;/a&gt;
and a &lt;a href=&quot;https://github.com/ZipCPU/vgasim/blob/master/bench/cpp/vgasim.cpp&quot;&gt;sink video
signal&lt;/a&gt;,
taking the source from a location on the screen of the simulator’s host, and
then displaying the result in a window on that same screen as well.  Of course,
there’s still plenty of room for improvement in the project.  In particular,
I have need of an HDMI simulation–something that would be an easy adjustment
to make to the &lt;a href=&quot;https://github.com/ZipCPU/vgasim&quot;&gt;VGA simulation&lt;/a&gt;
project.&lt;/p&gt;

&lt;p&gt;Perhaps we should come back to that project in a future article, and show how
you can use it?&lt;/p&gt;

&lt;p&gt;For now, let me thank Cliff Cummings for his &lt;a href=&quot;http://www.sunburst-design.com/papers/CummingsSNUG2002SJ_FIFO1.pdf&quot;&gt;excellent article on how to build
an asynchronous
FIFO&lt;/a&gt;,
and further for his encouragement to write this article!&lt;/p&gt;

&lt;hr /&gt;&lt;p&gt;&lt;em&gt;But, beloved, be not ignorant of this one thing, that one day is with the Lord as a thousand years, and a thousand years as one day. (2 Pet 3:8)&lt;/em&gt;</description>
        <pubDate>Fri, 06 Jul 2018 00:00:00 -0400</pubDate>
        <link>https://zipcpu.com/blog/2018/07/06/afifo.html</link>
        <guid isPermaLink="true">https://zipcpu.com/blog/2018/07/06/afifo.html</guid>
        
        
        <category>blog</category>
        
      </item>
    
  </channel>
</rss>
