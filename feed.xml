<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>The ZipCPU by Gisselquist Technology</title>
    <description>The ZipCPU blog, featuring how to discussions of FPGA and soft-core CPU design.  This site will be focused on Verilog solutions, using exclusively OpenSource IP products for FPGA design.  Particular focus areas include topics often left out of more mainstreeam FPGA design courses such as how to debug an FPGA design.
</description>
    <link>http://zipcpu.com/</link>
    <atom:link href="http://zipcpu.com/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Sat, 31 Mar 2018 21:22:50 -0400</pubDate>
    <lastBuildDate>Sat, 31 Mar 2018 21:22:50 -0400</lastBuildDate>
    <generator>Jekyll v3.0.1</generator>
    <image>
      <url>http://zipcpu.com/img/gt-rss.png</url>
      <title></title>
      <link></link>
    </image>
    
      <item>
        <title>Resurrection Day!</title>
        <description>&lt;p&gt;Buddha &lt;a href=&quot;https://en.wikipedia.org/wiki/Gautama_Buddha#Relics&quot;&gt;is dead&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Mohammed &lt;a href=&quot;https://en.wikipedia.org/wiki/Muhammad#Death_and_tomb&quot;&gt;is dead&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.blueletterbible.org/kjv/deu/34/1&quot;&gt;Moses died&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.blueletterbible/kjv/mat/27/50&quot;&gt;Jesus died&lt;/a&gt; as well, but unlike
these others &lt;a href=&quot;https://www.blueletterbible.org/kjv/mat/28/7&quot;&gt;He is dead no more&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;This simple fact &lt;a href=&quot;https://www.blueletterbible.org/kjv/act/17/31&quot;&gt;makes Christianity
different&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Today, we celebrate this difference.&lt;/p&gt;

&lt;h2 id=&quot;what-makes-jesus-special&quot;&gt;What makes Jesus special?&lt;/h2&gt;

&lt;p&gt;Jesus knew He was going to die.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;And as Moses lifted up the serpent in the wilderness
[&lt;a href=&quot;https://www.blueletterbible.org/kjv/num/21/8&quot;&gt;Num 21:8&lt;/a&gt;],
even so must the Son of man be lifted up [i.e. crucified]: That whosoever
believeth in him should not perish, but have eternal life.
(&lt;a href=&quot;https://www.blueletterbible.org/kjv/jhn/3/14&quot;&gt;John 3:14-15&lt;/a&gt;)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;This was His purpose in coming to the earth.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Now is my soul troubled; and what shall I say?  Father, save me from this
hour: but for this cause came I unto this hour.  Father, glorify thy name.
Then came there a voice from heaven, saying, I have both glorified it, and
will glorify it again.
(&lt;a href=&quot;https://www.blueletterbible.org/kjv/jhn/12/27&quot;&gt;John 12:27-28&lt;/a&gt;)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Jesus also knew that He could raise Himself up from the grave long before
He was put to death.  This was a commandment given to Him by His Father,
the one we call God.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Therefore doth my Father love me, because I lay down my life, that I might
take it again.  No man taketh it from me, but I lay it down of myself.
I have the power to lay it down, and I have the power to take it again.
This command have I received of my Father.
(&lt;a href=&quot;https://www.blueletterbible.org/kjv/jhn/10/17&quot;&gt;John 10:17-18&lt;/a&gt;)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;The disciples were falsely accused of hiding His body.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Saying, Say ye, His disciples came by night, and stole him away while we
slept.
(&lt;a href=&quot;https://www.blueletterbible.org/kjv/mat/28/13&quot;&gt;Mat 28:13&lt;/a&gt;).&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;In spite of this lie, no one found the missing body because there was no
missing body.  Jesus is no longer dead, He is risen!&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;And as they were afraid, and bowed down their faces to the earth, they
said unto them, “Why seek ye the living among the dead?”
(&lt;a href=&quot;https://www.blueletterbible.org/kjv/luk/24/5&quot;&gt;Luke 24:5&lt;/a&gt;)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;em&gt;(By the way, I love the song by this same name which comes from the musical
&lt;a href=&quot;https://www.youtube.com/watch?v=roxCbUndmR0&quot;&gt;The Choice&lt;/a&gt; by Nate Copeland.
[&lt;a href=&quot;https://www.youtube.com/watch?v=6bM3S5fBYec&quot;&gt;1&lt;/a&gt;],
[&lt;a href=&quot;https://www.youtube.com/watch?v=wZ-qPvYQNr4&quot;&gt;2&lt;/a&gt;],
[&lt;a href=&quot;https://www.youtube.com/watch?v=c2fg_hhDN94&quot;&gt;3&lt;/a&gt;],
[&lt;a href=&quot;https://www.youtube.com/watch?v=Osbuen8WkRI&quot;&gt;4&lt;/a&gt;])&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;The resurrection, evidenced by the empty tomb, proves the validity
of the message.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Because he hath appointed a day, in the which He will judge the world in
righteousness by that Man whom he hath ordained; whereof He hath given
assurance unto all men, in that He hath raised Him from the dead.
(&lt;a href=&quot;https://www.blueletterbible.org/kjv/act/17/31&quot;&gt;Acts 17:31&lt;/a&gt;)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Without the resurrection, there is no point in Christianity.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;And if Christ be not risen, then is our preaching vain, and your faith is
vain [i.e. useless or pointless].  Yea, and we are found false witnesses of
God [i.e. liars]; because we have testified of God that He raised up Christ:
whom He raised not up, if so be that the dead rise not.&lt;/p&gt;

  &lt;p&gt;For if the dead rise not, then is Christ not raised: and if Christ be not
raised, your faith is vain; ye are yet in your sins.
Then they also which are fallen asleep in Christ are perished.&lt;/p&gt;

  &lt;p&gt;If in this life only we have hope in Christ, we are of all men most miserable.
(&lt;a href=&quot;https://www.blueletterbible.org/kjv/1co/15/14&quot;&gt;1Cor 15:14-19&lt;/a&gt;)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Indeed, were there no resurrection, then there would be no hope in living.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;If after the manner of men I have fought with beasts at Ephesus, what
advantageth it me, if the dead rise not?  Let us eat and drink; for
tomorrow we die.
(&lt;a href=&quot;https://www.blueletterbible.org/kjv/eph/15/32&quot;&gt;Eph 15:32&lt;/a&gt;)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;But there is a resurrection!  We know this from the testimony of those who
have seen him.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;This Jesus hath God raised up, whereof we all are witnesses.
(&lt;a href=&quot;https://www.blueletterbible.org/kjv/act/4/32&quot;&gt;Acts 4:32&lt;/a&gt;)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;or again,&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;For I delivered unto you first of all that which I also received, how that
Christ died for our sins according to the scriptures;
And that he was buried, and that he rose again the third day according to
the scriptures:
And that he was seen of Cephas, then of the twelve: After that, he was seen
of above five hundred brethren at once; of whom the greater part remain to
this present, but some are fallen asleep.
After that, he was seen of James; then of all the apostles.
And last of all he was seen of me also, as of one born out of due time.
(&lt;a href=&quot;https://www.blueletterbible.org/kjv/jhn/10/17&quot;&gt;1 Cor 15:3-8&lt;/a&gt;)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;We also know this by the empty tomb, proving to all that He is the Christ!&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Therefore let all the house of Israel know assuredly, that God hath made
the same Jesus, whom ye have crucified, both Lord and Christ.
(&lt;a href=&quot;https://www.blueletterbible.org/kjv/act/4/36&quot;&gt;Acts 4:36&lt;/a&gt;)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;i-serve-a-risen-savior&quot;&gt;I serve a risen Savior&lt;/h2&gt;

&lt;p&gt;Because He lives, I have been
&lt;a href=&quot;https://www.blueletterbible.org/kjv/rom/8/1&quot;&gt;freed from my own personal sins&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Because He lives, I no longer need to live a life 
&lt;a href=&quot;https://www.blueletterbible.org/kjv/jhn/8/34&quot;&gt;controlled by my own wickedness&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Because He lives, &lt;a href=&quot;https://www.blueletterbible.org/kjv/jhn/10/28&quot;&gt;I have a
future&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Because He lives, &lt;a href=&quot;https://www.blueletterbible.org/kjv/col/3/23&quot;&gt;I blog&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Because He lives, &lt;a href=&quot;https://www.blueletterbible.org/kjv/jhn/6/37&quot;&gt;you may choose to have a future
  as well&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;If you know Christ, then
please join me today in celebrating the risen Savior, which is Christ the Lord.&lt;/p&gt;

&lt;p&gt;If you &lt;a href=&quot;https://www.blueletterbible.org/kjv/mat/7/23&quot;&gt;do not know Him&lt;/a&gt;,
or perhaps if you only know of or
&lt;a href=&quot;https://www.blueletterbible.org/kjv/jas/2/19&quot;&gt;about Him&lt;/a&gt;,
then please let me invite you discover Him through the letters His disciples
wrote describing their time with him:
&lt;a href=&quot;https://www.blueletterbible.org/kjv/mat/1&quot;&gt;Matthew&lt;/a&gt;,
&lt;a href=&quot;https://www.blueletterbible.org/kjv/mar/1&quot;&gt;Mark&lt;/a&gt;,
&lt;a href=&quot;https://www.blueletterbible.org/kjv/luk/1&quot;&gt;Luke&lt;/a&gt; and
&lt;a href=&quot;https://www.blueletterbible.org/kjv/jhn/1&quot;&gt;John&lt;/a&gt;.&lt;/p&gt;

&lt;hr /&gt;&lt;p&gt;&lt;em&gt;He is not here: for He is risen, as He said.  Come, see the place where the Lord lay. (Matthew 28:6)&lt;/em&gt;</description>
        <pubDate>Sun, 01 Apr 2018 00:00:00 -0400</pubDate>
        <link>http://zipcpu.com/blog/2018/04/01/resurrection-day.html</link>
        <guid isPermaLink="true">http://zipcpu.com/blog/2018/04/01/resurrection-day.html</guid>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>Quadratic fits are entirely inappropriate for DSP</title>
        <description>&lt;p&gt;Waveforms in nature have two characteristics that are difficult to handle in
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_signal_processing&quot;&gt;signal processing&lt;/a&gt;
applications: natural waveforms are
&lt;a href=&quot;https://en.wikipedia.org/wiki/Continuous_function&quot;&gt;continuous&lt;/a&gt;
and they are tend to last for a &lt;em&gt;long time&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;This is to be contrasted to the “signals” that &lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_signal_processing&quot;&gt;Digital Signal Processing
(DSP)&lt;/a&gt;
algorithms act upon.
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_signal_processing&quot;&gt;DSP&lt;/a&gt;
algorithms are applied to &lt;em&gt;finite&lt;/em&gt; sections of
(typically) longer waveforms that have been
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;sampled&lt;/a&gt;
at evenly spaced intervals.&lt;/p&gt;

&lt;p&gt;This leads to a fundamental problem: if you want to work on a waveform
as though it were
&lt;a href=&quot;https://en.wikipedia.org/wiki/Continuous_function&quot;&gt;continuous&lt;/a&gt;
instead of
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;sampled&lt;/a&gt;,
then you need to figure out how to reconstruct what the signal
&lt;em&gt;should be&lt;/em&gt; between the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;sample&lt;/a&gt;
points.  Perhaps you need to
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sample-rate_conversion&quot;&gt;resample&lt;/a&gt;
that signal at some new rate whose ratio is far from simple when compared
to the old rate.  Perhaps you need to
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sample-rate_conversion&quot;&gt;resample&lt;/a&gt;
your signal at locations driven by a tracking loop, such as a digital receiver
would need to do.  Perhaps you just want to zoom in on a screen plot of your
signal and &lt;a href=&quot;/dsp/2017/07/29/series-linear-interpolation.html&quot;&gt;linear
interpolation&lt;/a&gt;
leaves you with a signal that looks nothing like the original reality.  Either
way, if you want to
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;recover&lt;/a&gt;
what your signal does between
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;samples&lt;/a&gt;,
you’ll want to apply some form of
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolation&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;In the past, we’ve looked at both a &lt;a href=&quot;/dsp/2017/06/06/simple-interpolator.html&quot;&gt;sample-and-hold
“interpolator”&lt;/a&gt;
and a &lt;a href=&quot;/dsp/2017/07/29/series-linear-interpolation.html&quot;&gt;linear
interpolator&lt;/a&gt;
as possible subsample
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolation&lt;/a&gt; methods.
However, if &lt;a href=&quot;/dsp/2017/07/29/series-linear-interpolation.html&quot;&gt;linear
interpolation&lt;/a&gt;
isn’t good enough for your application, then the next best approach is some
form of &lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial_interpolation&quot;&gt;quadratic
interpolation&lt;/a&gt;.
Indeed, it’s not that hard to take three points and generate a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Quadratic_function&quot;&gt;quadratic&lt;/a&gt;
that will pass through all three of them.&lt;/p&gt;

&lt;p&gt;Stop.  Now.  Don’t do that.  Really.  Don’t.&lt;/p&gt;

&lt;p&gt;In a moment I’ll show you why not.  Then I’ll show you a better approach.
Further, when &lt;a href=&quot;https://github.com/ZipCPU/interpolation/blob/master/rtl/quadratic/quadinterp.v&quot;&gt;implemented in
logic&lt;/a&gt;,
this better approach will still use only the same two hardware multiplies that
a quadratic fit would’ve used.&lt;/p&gt;

&lt;h2 id=&quot;why-interpolation&quot;&gt;Why interpolation&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;Interpolation&lt;/a&gt; is the term used
to describe an algorithm that can be used to create (or estimate) data points
between
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;samples&lt;/a&gt;.
This is often called
&lt;a href=&quot;https://en.wikipedia.org/wiki/Upsamplers&quot;&gt;upsampling&lt;/a&gt; in a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_signal_processing&quot;&gt;Signal Processing&lt;/a&gt;
context, with the difference between
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolating&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Upsamplers&quot;&gt;upsamplers&lt;/a&gt;
and those that are not
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolating&lt;/a&gt;
is that the output of an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;
is guaranteed to go through the original
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;sample&lt;/a&gt;
points, whereas this is not necessarily the case of a more generic
&lt;a href=&quot;https://en.wikipedia.org/wiki/Upsamplers&quot;&gt;upsampler&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Today, we’ll be discussing
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolators&lt;/a&gt;
that are also infinite
&lt;a href=&quot;https://en.wikipedia.org/wiki/Upsamplers&quot;&gt;upsamplers&lt;/a&gt;, such as those &lt;a href=&quot;/dsp/2018/01/16/interpolation-is-convolution.html&quot;&gt;we
discussed earlier&lt;/a&gt;
when proving that all such
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolators&lt;/a&gt;
could be modeled as
&lt;a href=&quot;https://en.wikipedia.org/wiki/Convolution&quot;&gt;convolutions&lt;/a&gt;
of discrete-time signals with a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Continuous_function&quot;&gt;continuous&lt;/a&gt;
time filter.  Such 
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolators&lt;/a&gt;
can form the basis of an &lt;em&gt;asynchronous &lt;a href=&quot;https://en.wikipedia.org/wiki/Sample-rate_conversion&quot;&gt;sample rate
converter&lt;/a&gt;&lt;/em&gt;.
For our purposes today, though, we will limit our discussion to
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolators&lt;/a&gt;
which are simply the result of a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Piecewise&quot;&gt;piecewise&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial&quot;&gt;polynomial&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Upsamplers&quot;&gt;upsamplers&lt;/a&gt;.  We’ll even limit the
discussion further to that subset of all
&lt;a href=&quot;https://en.wikipedia.org/wiki/Piecewise&quot;&gt;piecewise&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial&quot;&gt;polynomial&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Upsamplers&quot;&gt;upsamplers&lt;/a&gt;
that is formed from quadratic
&lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial&quot;&gt;polynomials&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;I first learned the idea of
&lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial&quot;&gt;polynomial&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Upsamplers&quot;&gt;upsampling&lt;/a&gt;
from &lt;a href=&quot;http://ieeexplore.ieee.org/document/679201&quot;&gt;Harris&lt;/a&gt;,
although it seems as though
&lt;a href=&quot;http://ieeexplore.ieee.org/document/15483/&quot;&gt;Farrow&lt;/a&gt;
was the actual originator of the idea.  Hence, you might recognize our
ultimate solution as a
&lt;a href=&quot;http://ieeexplore.ieee.org/document/15483/&quot;&gt;Farrow&lt;/a&gt;
filter, although it may not look like any
&lt;a href=&quot;http://ieeexplore.ieee.org/document/15483/&quot;&gt;Farrow&lt;/a&gt;
filter you’ve seen before.  Even better, it will have provably better
asymptotic out of band performance than any
&lt;a href=&quot;http://ieeexplore.ieee.org/document/15483/&quot;&gt;Farrow&lt;/a&gt;
filter or approach I’ve seen published to date.&lt;/p&gt;

&lt;h2 id=&quot;the-problem-with-quadratic-fitting&quot;&gt;The Problem with Quadratic Fitting&lt;/h2&gt;

&lt;p&gt;I started out this post by declaring that using a quadratic fit to
the nearest three points were a horrible means of
&lt;a href=&quot;https://en.wikipedia.org/wiki/Upsamplers&quot;&gt;upsampling&lt;/a&gt;.
Let’s take a moment before going
further to see why this is the case.  We’ll do this by first creating a fit
to the nearest three points of a signal, and then examining what happens when
you extend this fit beyond those three points into the points nearby.&lt;/p&gt;

&lt;p&gt;As with any
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolation&lt;/a&gt;
problem, we’ll start with a signal, &lt;code class=&quot;highlighter-rouge&quot;&gt;x[n]&lt;/code&gt;.  I’ll
use the square brackets, &lt;code class=&quot;highlighter-rouge&quot;&gt;[]&lt;/code&gt;, to emphasize that this is a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;sampled signal&lt;/a&gt;
and hence only integer indices are allowed.  From this
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;sampled signal&lt;/a&gt;,
our goal will be to create a new signal, &lt;code class=&quot;highlighter-rouge&quot;&gt;y(t)&lt;/code&gt;, with a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Continuous_function&quot;&gt;continuous&lt;/a&gt;
index, &lt;code class=&quot;highlighter-rouge&quot;&gt;t&lt;/code&gt;–herein noted by the parentheses, &lt;code class=&quot;highlighter-rouge&quot;&gt;()&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;To create a quadratic fit, well pick three points from this signal,
&lt;code class=&quot;highlighter-rouge&quot;&gt;x[n-1]&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;x[n]&lt;/code&gt;, and &lt;code class=&quot;highlighter-rouge&quot;&gt;x[n+1]&lt;/code&gt;, and then fit a quadratic function, &lt;code class=&quot;highlighter-rouge&quot;&gt;f_n(t)&lt;/code&gt;
to these three points so that:&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/quadeqn-fit-genquad.png&quot; alt=&quot;f_n(t-n) = a(t-n)^2 + b(t-n) + c&quot; width=&quot;599&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Further, if we assume that our
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;samples&lt;/a&gt;
are spaced one unit apart, then&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/quadeqn-fit-triplet.png&quot; alt=&quot;&quot; width=&quot;203&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;The constant term of this quadratic
&lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial&quot;&gt;polynomial&lt;/a&gt;
is very simple to solve.  If we examine &lt;code class=&quot;highlighter-rouge&quot;&gt;t=n&lt;/code&gt;, then,&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/quadeqn-fit-fzero.png&quot; alt=&quot;f_0(0) = a(0)+b(0)+c&quot; width=&quot;418&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;The linear term is just a bit harder, but it can be obtained by subtracting
&lt;code class=&quot;highlighter-rouge&quot;&gt;f_n(-1)&lt;/code&gt; from &lt;code class=&quot;highlighter-rouge&quot;&gt;f_n(1)&lt;/code&gt;,&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/quadeqn-fit-fsub.png&quot; alt=&quot;&quot; width=&quot;605&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;In other words,&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/quadeqn-fit-b.png&quot; alt=&quot;&quot; width=&quot;296&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Getting the last coefficient is just a little bit more work, but follows from
adding the two end point values, &lt;code class=&quot;highlighter-rouge&quot;&gt;f_n(1)&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;f_n(-1)&lt;/code&gt; together,&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/quadeqn-fit-fsum.png&quot; alt=&quot;&quot; width=&quot;531&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;This yields our quadratic coefficint,&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/quadeqn-fit-a.png&quot; alt=&quot;&quot; width=&quot;367&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Therefore, we can fit any three
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;sample&lt;/a&gt;
values to the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial&quot;&gt;polynomial&lt;/a&gt;,&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/quadeqn-fit-complete.png&quot; alt=&quot;&quot; width=&quot;632&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Fig 1 shows an example of one such fit.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 1. An example quadratic fit of three points&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/quadeqn-fit-result.png&quot; alt=&quot;&quot; width=&quot;410&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;At first glance, this looks pretty good.  We started with three data points,
and now we’ve created a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Continuous_function&quot;&gt;continuous&lt;/a&gt;
line that smoothly
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolates&lt;/a&gt;
between these three data points.  What could the problem be?&lt;/p&gt;

&lt;p&gt;The problem comes into play when you expand out from these three data points
and examine the infinite set of
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;samples&lt;/a&gt;
that are the incoming data.  In this case, the quadratic fit turns from a nice
&lt;a href=&quot;https://en.wikipedia.org/wiki/Continuous_function&quot;&gt;continuous&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;,
to discontinuous
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;,
where the discontinuity takes place halfway between any pair of
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;samples&lt;/a&gt;.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 2. Using a quadratic fit across multiple sample points create discontinuities&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/interpolation-discontinuous-quadratic.png&quot; alt=&quot;&quot; width=&quot;603&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;What happened?&lt;/p&gt;

&lt;p&gt;What happened was that we chose to only use &lt;code class=&quot;highlighter-rouge&quot;&gt;f_n&lt;/code&gt; between &lt;code class=&quot;highlighter-rouge&quot;&gt;n-1/2&lt;/code&gt; and
&lt;code class=&quot;highlighter-rouge&quot;&gt;n+1/2&lt;/code&gt;.  Once past &lt;code class=&quot;highlighter-rouge&quot;&gt;n+1/2&lt;/code&gt;, we switched to a new
&lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial&quot;&gt;polynomial&lt;/a&gt;,
&lt;code class=&quot;highlighter-rouge&quot;&gt;f_{n+1}&lt;/code&gt;.  Since we did nothing to constrain our
&lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial&quot;&gt;polynomial&lt;/a&gt;
solution so that it was
&lt;a href=&quot;https://en.wikipedia.org/wiki/Continuous_function&quot;&gt;continuous&lt;/a&gt;
between data sets, the result wasn’t
&lt;a href=&quot;https://en.wikipedia.org/wiki/Continuous_function&quot;&gt;continuous&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Before going further, let’s consider my previous statement that “&lt;a href=&quot;/dsp/2018/01/16/interpolation-is-convolution.html&quot;&gt;Interpolation
is just a special type of
convolution&lt;/a&gt;.”
Why?  Because if you can understand this quadratic
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt; as just a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Convolution&quot;&gt;convolution&lt;/a&gt;
of your data with a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Continuous_function&quot;&gt;continuous function&lt;/a&gt;,&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/interp-is-convolution.png&quot; alt=&quot;&quot; width=&quot;275&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;then we can plot the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency_response&quot;&gt;frequency response&lt;/a&gt;
of this
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;.
Knowing that
&lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency_response&quot;&gt;frequency response&lt;/a&gt;
will allow us, further on, to compare  this quadratic fit
with other alternative quadratic
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolators&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;To see how this fits into the form of a filter’s
&lt;a href=&quot;https://en.wikipedia.org/wiki/Impulse_response&quot;&gt;impulse response&lt;/a&gt;, let’s
examine what happens when this
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;
is applied to an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Kronecker_delta&quot;&gt;impulse&lt;/a&gt;.
If we allow &lt;code class=&quot;highlighter-rouge&quot;&gt;x[n]&lt;/code&gt; to be a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Kronecker_delta&quot;&gt;Kronecker delta function&lt;/a&gt;,
where &lt;code class=&quot;highlighter-rouge&quot;&gt;x[n]=0&lt;/code&gt; for all &lt;code class=&quot;highlighter-rouge&quot;&gt;n&lt;/code&gt; save for &lt;code class=&quot;highlighter-rouge&quot;&gt;x[0]=1&lt;/code&gt;, then the result of applying
this quadratic fit to this
&lt;a href=&quot;https://en.wikipedia.org/wiki/Kronecker_delta&quot;&gt;sequence&lt;/a&gt;
will be the &lt;a href=&quot;https://en.wikipedia.org/wiki/Impulse_response&quot;&gt;impulse
response&lt;/a&gt;
of this &lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;.  Let’s do
that now.&lt;/p&gt;

&lt;p&gt;First, &lt;code class=&quot;highlighter-rouge&quot;&gt;f_{-1}(t+1)&lt;/code&gt; will
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;sample&lt;/a&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;x[0]=1&lt;/code&gt; in it’s &lt;code class=&quot;highlighter-rouge&quot;&gt;n+1&lt;/code&gt; term, yielding the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial&quot;&gt;polynomial&lt;/a&gt;,&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/quadeqn-fit-impulse-neg.png&quot; alt=&quot;&quot; width=&quot;354&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Likewise, &lt;code class=&quot;highlighter-rouge&quot;&gt;f_{0}(t)&lt;/code&gt; will
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;sample&lt;/a&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;x[0]=1&lt;/code&gt; in it’s &lt;code class=&quot;highlighter-rouge&quot;&gt;n&lt;/code&gt; term, yielding,&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/quadeqn-fit-impulse-zero.png&quot; alt=&quot;&quot; width=&quot;175&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Next, the &lt;code class=&quot;highlighter-rouge&quot;&gt;f_{1}(t)&lt;/code&gt; term will
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;sample&lt;/a&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;x[0]=1&lt;/code&gt; in it’s &lt;code class=&quot;highlighter-rouge&quot;&gt;n-1&lt;/code&gt; term, giving us
our final &lt;a href=&quot;https://en.wikipedia.org/wiki/Piecewise&quot;&gt;piecewise&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial&quot;&gt;polynomial&lt;/a&gt; component,&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/quadeqn-fit-impulse-pos.png&quot; alt=&quot;&quot; width=&quot;341&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Put together, you can see this
&lt;a href=&quot;https://en.wikipedia.org/wiki/Piecewise&quot;&gt;piecewise&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial&quot;&gt;polynomial&lt;/a&gt;
plotted out in Fig 3.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 3. Impulse response of a Quadratic Fit Interpolator&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/interpolation-fig-qfit.png&quot; alt=&quot;&quot; width=&quot;325&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;See what happened?  This
&lt;a href=&quot;https://en.wikipedia.org/wiki/Impulse_response&quot;&gt;impulse response&lt;/a&gt; isn’t
&lt;a href=&quot;https://en.wikipedia.org/wiki/Continuous_function&quot;&gt;continuous&lt;/a&gt;
at all!  This is the reason why our
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolated&lt;/a&gt;
signal wasn’t &lt;a href=&quot;https://en.wikipedia.org/wiki/Continuous_function&quot;&gt;continuous&lt;/a&gt;
either.&lt;/p&gt;

&lt;p&gt;Further, it only takes some basic integral calculus to plot the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency_response&quot;&gt;frequency response&lt;/a&gt;
of this function in Fig 4.  (I’ll spare you the calculation–while basic,
it isn’t pretty.)&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 4. Fourier Transform of a Quadratic Fit&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/interpolation-fig-qfit-H.png&quot; alt=&quot;&quot; width=&quot;325&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;The gray line in Fig 4 is proportional to &lt;code class=&quot;highlighter-rouge&quot;&gt;1/f&lt;/code&gt;, showing how this
&lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency_response&quot;&gt;frequency response&lt;/a&gt;
only slowly converges towards zero as &lt;code class=&quot;highlighter-rouge&quot;&gt;f&lt;/code&gt; goes to infinity.  This is the
consequence of the discontinuities in the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Impulse_response&quot;&gt;impulse response&lt;/a&gt;
of this fit.&lt;/p&gt;

&lt;p&gt;Now that you see the problem with using a simple quadratic fit as an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;,
let’s see if we can do better.&lt;/p&gt;

&lt;h2 id=&quot;a-better-interpolator&quot;&gt;A Better Interpolator&lt;/h2&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 5. A Piecewise Polynomial&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/interpolation-piecewise-poly.png&quot; alt=&quot;&quot; width=&quot;278&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Now that we know what can go wrong with a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Piecewise&quot;&gt;piecewise&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial&quot;&gt;polynomial&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;,
it’s time to return to where we left off in our &lt;a href=&quot;/dsp/2018/01/16/interpolation-is-convolution.html&quot;&gt;prior
post&lt;/a&gt;
on this topic, and use the principles we developed there to develop
a better &lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;.
In that post, we showed that all
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolators&lt;/a&gt;
that met a minimum set of problem related assumptions have the form of a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Piecewise&quot;&gt;piecewise&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial&quot;&gt;polynomial&lt;/a&gt;,
such as is shown in Fig 5.&lt;/p&gt;

&lt;p&gt;Further, &lt;a href=&quot;/dsp/2018/01/16/interpolation-is-convolution.html&quot;&gt;we pointed
out&lt;/a&gt;
that an &lt;code class=&quot;highlighter-rouge&quot;&gt;h(t)&lt;/code&gt; function that is given by a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Piecewise&quot;&gt;piecewise&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial&quot;&gt;polynomial&lt;/a&gt;,
such as the one shown in Fig 5, can be a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Linear_system&quot;&gt;linear&lt;/a&gt;,
discrete shift invariant,
&lt;a href=&quot;https://en.wikipedia.org/wiki/Upsamplers&quot;&gt;upsampler&lt;/a&gt;.
In Fig 5, you can see separate regions of an example filter, &lt;code class=&quot;highlighter-rouge&quot;&gt;h(t)&lt;/code&gt;, shown
in separate colors.  Each colored region represents a separate quadratic
&lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial&quot;&gt;polynomial&lt;/a&gt;.  Our goal will be
to try to use some criteria to create a useful set of
&lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial&quot;&gt;polynomials&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;As a first step to building our own, let’s define our component
&lt;a href=&quot;https://en.wikipedia.org/wiki/Piecewise&quot;&gt;piecewise&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial&quot;&gt;polynomials&lt;/a&gt; as,&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/quadeqn-nfit-piecewise-eqn.png&quot; alt=&quot;&quot; width=&quot;818&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;That is to say, we’re going to look for a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Piecewise&quot;&gt;piecewise&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial&quot;&gt;polynomials&lt;/a&gt;
function, &lt;code class=&quot;highlighter-rouge&quot;&gt;h(t)&lt;/code&gt;, defined by the equations,&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/quadeqn-criteria-eqn-defns.png&quot; alt=&quot;&quot; width=&quot;666&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Why only five intervals?  This is an arbitrary choice.
There’s no hard and fast rule here.  More intervals or a higher
&lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial&quot;&gt;polynomial&lt;/a&gt;
degree might produce a better filter, but one that will cost more logic to
calculate.  Such longer filters can be the topic for another
discussion on another day.  I do know that this setup will yield a nicely
implementable solution ultimately requiring only two RTL multiplies.&lt;/p&gt;

&lt;p&gt;Two multiplies you ask?  What about all those arbitrary coefficients in &lt;code class=&quot;highlighter-rouge&quot;&gt;h(t)&lt;/code&gt;?
Hang on, we’ll get there.&lt;/p&gt;

&lt;p&gt;Why is there no &lt;code class=&quot;highlighter-rouge&quot;&gt;b&lt;/code&gt; coefficient for the middle interval?  Or, equivalently,
why are the &lt;code class=&quot;highlighter-rouge&quot;&gt;*_1&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;*_2&lt;/code&gt; coefficients repeated?  Because I have chosen a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Linear_phase&quot;&gt;symmetric&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolation&lt;/a&gt;
filter, in the hopes of achieving a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Linear_phase&quot;&gt;linear phase&lt;/a&gt;
result.  Further, I’ve started this derivation often enough without
pre-specifying these certain coefficients, and I end up specifying
them via equations anyway.  By doing it this way, it just reduces the
number of coefficients we’ll need to solve for from the beginning.&lt;/p&gt;

&lt;p&gt;To get to our result, all that remains is to determine the coefficients of the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Piecewise&quot;&gt;piecewise&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial&quot;&gt;polynomials&lt;/a&gt;
in our chosen filter.  To do this, we’ll use some (rather ad-hoc) criteria to
set up a system of linear equations to yield the as yet unknown coefficients.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;Interpolator&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Our first criteria for &lt;code class=&quot;highlighter-rouge&quot;&gt;h(t)&lt;/code&gt; is that the resulting waveform needs to
   &lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolate&lt;/a&gt;
   the incoming waveform.  In other words, whenever &lt;code class=&quot;highlighter-rouge&quot;&gt;t&lt;/code&gt; is
   an integer, the output value should equal the input.  That is, if &lt;code class=&quot;highlighter-rouge&quot;&gt;t=n&lt;/code&gt;
   then &lt;code class=&quot;highlighter-rouge&quot;&gt;y(n) = x[n]&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;If we work this from the equation standpoint,&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/interp-is-convolution.png&quot; alt=&quot;&quot; width=&quot;275&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p style=&quot;list-style-type: none;&quot;&gt;you can see that if &lt;code class=&quot;highlighter-rouge&quot;&gt;t=n&lt;/code&gt; then &lt;code class=&quot;highlighter-rouge&quot;&gt;y(n)&lt;/code&gt; is composed of a summation across
   several &lt;code class=&quot;highlighter-rouge&quot;&gt;h(t)&lt;/code&gt;
   values, each with the index &lt;code class=&quot;highlighter-rouge&quot;&gt;n-k&lt;/code&gt;.  Further, when &lt;code class=&quot;highlighter-rouge&quot;&gt;n=k&lt;/code&gt; we get the one
   component we want, and all of the other components will just pull us off in
   one direction or another.  Hence, we need to insist that,&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/quadeqn-criteria-interpolator.png&quot; alt=&quot;&quot; width=&quot;364&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 6. An interpolating filter must go through zero for all integers but zero&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/quadeqn-criteria-interpolator-dots.png&quot; alt=&quot;&quot; width=&quot;325&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;This means that every one of our
&lt;a href=&quot;https://en.wikipedia.org/wiki/Piecewise&quot;&gt;piecewise&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial&quot;&gt;polynomial&lt;/a&gt; component
functions, save the one in the center, will need to go through zero
near the integer within it, as shown in Fig 6.  The point in the center,
on the other hand, will need to pass through &lt;code class=&quot;highlighter-rouge&quot;&gt;y=1&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;It shouldn’t take too much work to see that our set of
&lt;a href=&quot;https://en.wikipedia.org/wiki/Piecewise&quot;&gt;piecewise&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial&quot;&gt;polynomial&lt;/a&gt; will
meet this criteria if we simply set &lt;code class=&quot;highlighter-rouge&quot;&gt;c_1&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;c_2&lt;/code&gt; to be zero.  Indeed,
this is the reason why it was constructed it based upon &lt;code class=&quot;highlighter-rouge&quot;&gt;t-n&lt;/code&gt; terms in the
first place.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;DSP Guru Meditation&lt;/strong&gt;: It can be shown that if &lt;code class=&quot;highlighter-rouge&quot;&gt;h(n)&lt;/code&gt; is a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Kronecker_delta&quot;&gt;Kronecker Delta function&lt;/a&gt;,
then it must also be true that,&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/quadeqn-criteria-interpolator-guru-1.png&quot; alt=&quot;&quot; width=&quot;213&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;or, equivalently,&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/quadeqn-criteria-interpolator-guru-2.png&quot; alt=&quot;&quot; width=&quot;330&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;This, plus the fact that &lt;code class=&quot;highlighter-rouge&quot;&gt;h(t)&lt;/code&gt; is real, forces the awkward reality
that &lt;code class=&quot;highlighter-rouge&quot;&gt;H(1/2)&lt;/code&gt; &lt;em&gt;must be&lt;/em&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;1/2&lt;/code&gt; as well for all practical
&lt;a href=&quot;https://en.wikipedia.org/wiki/Low-pass_filter&quot;&gt;low-pass&lt;/a&gt;
filters.  Hence, this criteria alone forces the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Passband&quot;&gt;passband&lt;/a&gt; and
&lt;a href=&quot;https://en.wikipedia.org/wiki/Stopband&quot;&gt;stopband&lt;/a&gt;
cutoff frequencies of any
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;
to be &lt;code class=&quot;highlighter-rouge&quot;&gt;f=1/2&lt;/code&gt;.  This is a somewhat unfortunate limitation on the
performance that might be achieved using this approach.&lt;/p&gt;

&lt;p&gt;This criteria is also a point of separation from
&lt;a href=&quot;http://ieeexplore.ieee.org/document/15483/&quot;&gt;Farrow&lt;/a&gt;’s work, since
&lt;a href=&quot;http://ieeexplore.ieee.org/document/15483/&quot;&gt;Farrow&lt;/a&gt; never insisted that the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sample-rate_conversion&quot;&gt;resamplers&lt;/a&gt;
he developed went through the original
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;sample&lt;/a&gt;
points.&lt;/p&gt;

&lt;ol start=&quot;2&quot;&gt;
  &lt;li&gt;&lt;strong&gt;Constant -&amp;gt; Constant&lt;/strong&gt;: &lt;code class=&quot;highlighter-rouge&quot;&gt;x[n]=c&lt;/code&gt; implies &lt;code class=&quot;highlighter-rouge&quot;&gt;y(t)=c&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;When I built my first
&lt;a href=&quot;http://ieeexplore.ieee.org/document/15483/&quot;&gt;Farrow&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolation&lt;/a&gt;
filter
from a quadratic
&lt;a href=&quot;https://en.wikipedia.org/wiki/Piecewise&quot;&gt;piecewise&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial&quot;&gt;polynomial&lt;/a&gt;,
I was surprised to discover that a constant input to my filter was producing
a non-constant output.  Instead, there was a small but repeating quadratic
component.  How could this to happen?!  How could I call this an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;, if the
resulting
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolated&lt;/a&gt; waveform
didn’t smoothly go through the given points?&lt;/p&gt;

&lt;p&gt;So I then went back to my equations for &lt;code class=&quot;highlighter-rouge&quot;&gt;h(t)&lt;/code&gt; and the coefficients of the
component &lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial&quot;&gt;polynomials&lt;/a&gt;, 
and rebuilt them to insist that if &lt;code class=&quot;highlighter-rouge&quot;&gt;x[n]&lt;/code&gt; is the constant &lt;code class=&quot;highlighter-rouge&quot;&gt;c&lt;/code&gt;, then
&lt;code class=&quot;highlighter-rouge&quot;&gt;y(t)&lt;/code&gt; should equal that same constant &lt;code class=&quot;highlighter-rouge&quot;&gt;c&lt;/code&gt; as well.&lt;/p&gt;

&lt;p&gt;Let’s do that here.  With just a little manipulation, you’ll see that,&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/quadeqn-criteria-const-deriv.png&quot; alt=&quot;&quot; width=&quot;330&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Hence, we’ll want&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/quadeqn-criteria-const.png&quot; alt=&quot;&quot; width=&quot;375&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;for all possible values of &lt;code class=&quot;highlighter-rouge&quot;&gt;t&lt;/code&gt; between &lt;code class=&quot;highlighter-rouge&quot;&gt;-1/2&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;1/2&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;We can apply this criteria to our
&lt;a href=&quot;https://en.wikipedia.org/wiki/Piecewise&quot;&gt;piecewise&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial&quot;&gt;polynomial&lt;/a&gt;
filter without too much hassle.  I’ll spare you the gory details, although
you should know that the result is a set of equations further constraining our
&lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial&quot;&gt;polynomial&lt;/a&gt; coefficients.&lt;/p&gt;

&lt;p&gt;If we continue solving for our eight coefficients,
we’ll still need some more equations.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 7. The frequency response of a linear interpolator, showing a zero response for all integer frequencies but zero&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/quadeqn-criteria-const-H.png&quot; alt=&quot;&quot; width=&quot;378&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;&lt;strong&gt;DSP Guru Meditation&lt;/strong&gt;:
If you examine this property in
&lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency_response&quot;&gt;frequency&lt;/a&gt;,
it forces a unique and very desirable property upon the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolating&lt;/a&gt;
filter’s
&lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency_response&quot;&gt;frequency response&lt;/a&gt;.
In particular, the &lt;a href=&quot;https://en.wikipedia.org/wiki/Fourier_transform&quot;&gt;Fourier
transform&lt;/a&gt; of a constant
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;sampled&lt;/a&gt;
input has a component at &lt;code class=&quot;highlighter-rouge&quot;&gt;X(e^{j0})&lt;/code&gt; only, with &lt;code class=&quot;highlighter-rouge&quot;&gt;X(e^{j2pi f})=c delta(f)&lt;/code&gt;,
where &lt;code class=&quot;highlighter-rouge&quot;&gt;delta(f)&lt;/code&gt; is the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Dirac_delta_function&quot;&gt;Dirac delta function&lt;/a&gt;.
This would normally create aliasing components at frequencies &lt;code class=&quot;highlighter-rouge&quot;&gt;X(e^{j2pi m})&lt;/code&gt;
for all integers &lt;code class=&quot;highlighter-rouge&quot;&gt;m&lt;/code&gt; as well.  However, we just insisted that for a constant
input, the &lt;a href=&quot;https://en.wikipedia.org/wiki/Fourier_transform&quot;&gt;Fourier
transform&lt;/a&gt; of the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Continuous_function&quot;&gt;continuous&lt;/a&gt;
output function was to have a component at zero only.  Hence, we know that
&lt;code class=&quot;highlighter-rouge&quot;&gt;X(e^{j2pi f})H(f)&lt;/code&gt; must be nonzero for &lt;code class=&quot;highlighter-rouge&quot;&gt;f=0&lt;/code&gt;, and so we now know that
&lt;code class=&quot;highlighter-rouge&quot;&gt;H(0)=1&lt;/code&gt;.  We also know that &lt;code class=&quot;highlighter-rouge&quot;&gt;H(m)&lt;/code&gt; must be zero for all integers &lt;code class=&quot;highlighter-rouge&quot;&gt;m!=0&lt;/code&gt;,
&lt;code class=&quot;highlighter-rouge&quot;&gt;H(m)=0&lt;/code&gt;–just like a &lt;a href=&quot;https://en.wikipedia.org/wiki/Sinc_funtion&quot;&gt;sinc
function&lt;/a&gt; although other
functions can have this property as well.&lt;/p&gt;

&lt;p&gt;You can see this property shown in Fig 7 on the right.&lt;/p&gt;

&lt;ol start=&quot;3&quot;&gt;
  &lt;li&gt;&lt;strong&gt;Linear -&amp;gt; Linear&lt;/strong&gt;: &lt;code class=&quot;highlighter-rouge&quot;&gt;x[n] = n&lt;/code&gt; implies &lt;code class=&quot;highlighter-rouge&quot;&gt;y(t)=t&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Let’s follow that last criteria a bit further.  Instead of just insisting
that every constant produce a constant signal output, we can also insist
that every linear input produce a linear output.  Hence, if &lt;code class=&quot;highlighter-rouge&quot;&gt;x[n]=n&lt;/code&gt;,
then &lt;code class=&quot;highlighter-rouge&quot;&gt;y(t)&lt;/code&gt; should equal &lt;code class=&quot;highlighter-rouge&quot;&gt;t&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;As with our last criteria, we’ll apply our input, &lt;code class=&quot;highlighter-rouge&quot;&gt;x[n]=n&lt;/code&gt;, and then
insist that the result contains no &lt;code class=&quot;highlighter-rouge&quot;&gt;t^2&lt;/code&gt; terms.  (We already know it will
contain no constant terms.)&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 8. Constraining performance under linear inputs constrains the slope of the frequency response&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/quadeqn-criteria-const-Hdot.png&quot; alt=&quot;&quot; width=&quot;386&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;This will give us another linear constraint on our coefficients.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;DSP Guru Meditation&lt;/strong&gt;:
If you examine this criteria in
&lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency_response&quot;&gt;frequency&lt;/a&gt;, it basically
forces the slope of &lt;code class=&quot;highlighter-rouge&quot;&gt;H(m)&lt;/code&gt; to be zero for integers &lt;code class=&quot;highlighter-rouge&quot;&gt;m&lt;/code&gt;.  To be effective,
this criteria is dependent upon the constant criteria described above.&lt;/p&gt;

&lt;p&gt;This constraint therefore not only increases the width of our pass band,
but it also increases the depth of the nulls.&lt;/p&gt;

&lt;ol start=&quot;4&quot;&gt;
  &lt;li&gt;&lt;strong&gt;Quadratic -&amp;gt; Quadratic&lt;/strong&gt;: &lt;code class=&quot;highlighter-rouge&quot;&gt;x[n] = n^2&lt;/code&gt; implies &lt;code class=&quot;highlighter-rouge&quot;&gt;y(t)=t^2&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;For our fourth criteria, we’ll insist that if &lt;code class=&quot;highlighter-rouge&quot;&gt;x[n]=n^2&lt;/code&gt; then &lt;code class=&quot;highlighter-rouge&quot;&gt;y(t)&lt;/code&gt; should
equal &lt;code class=&quot;highlighter-rouge&quot;&gt;t^2&lt;/code&gt;.  In many ways this is similar to the linear criteria above.
As with the linear criteria, this also provides us with another equation
to add to the system of equations we are building to solve for &lt;code class=&quot;highlighter-rouge&quot;&gt;h(t)&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;DSP Guru Meditation&lt;/strong&gt;: This criteria constrains the second derivative of
the &lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency_response&quot;&gt;frequency response&lt;/a&gt;
near both &lt;code class=&quot;highlighter-rouge&quot;&gt;f=m&lt;/code&gt; for all integer frequencies &lt;code class=&quot;highlighter-rouge&quot;&gt;m&lt;/code&gt;, thus also widening our
passband, as well as the width of the nulls in the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency_response&quot;&gt;frequency response&lt;/a&gt;.
As a result, this criteria only intensifies our last constraint.&lt;/p&gt;

&lt;ol start=&quot;5&quot;&gt;
  &lt;li&gt;&lt;strong&gt;Continuous&lt;/strong&gt;: &lt;img src=&quot;/img/quadeqn-criteria-continuous.png&quot; width=&quot;233&quot; /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;As a final set of criteria, we’ll insist that our
&lt;a href=&quot;https://en.wikipedia.org/wiki/Piecewise&quot;&gt;piecewise&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial&quot;&gt;polynomial&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Impulse_response&quot;&gt;impulse response&lt;/a&gt; be
&lt;a href=&quot;https://en.wikipedia.org/wiki/Continuous_function&quot;&gt;continuous&lt;/a&gt;.
Hence, the &lt;code class=&quot;highlighter-rouge&quot;&gt;h(t)&lt;/code&gt; function must be
&lt;a href=&quot;https://en.wikipedia.org/wiki/Continuous_function&quot;&gt;continuous&lt;/a&gt;
at its seams: &lt;code class=&quot;highlighter-rouge&quot;&gt;t=-5/2&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;t=-3/2&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;t=-1/2&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;t=1/2&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;t=3/2&lt;/code&gt;, and &lt;code class=&quot;highlighter-rouge&quot;&gt;t=5/2&lt;/code&gt;.
However, since we constrained our
&lt;a href=&quot;https://en.wikipedia.org/wiki/Piecewise&quot;&gt;piecewise&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial&quot;&gt;polynomial&lt;/a&gt; to be
&lt;a href=&quot;https://en.wikipedia.org/wiki/Linear_phase&quot;&gt;symmetric&lt;/a&gt;
in time, we really only need to deal with half of those &lt;code class=&quot;highlighter-rouge&quot;&gt;t&lt;/code&gt; values.&lt;/p&gt;

&lt;p&gt;Because any linear combination of
&lt;a href=&quot;https://en.wikipedia.org/wiki/Continuous_function&quot;&gt;continuous functions&lt;/a&gt;
is also
&lt;a href=&quot;https://en.wikipedia.org/wiki/Continuous_function&quot;&gt;continuous&lt;/a&gt;,
&lt;code class=&quot;highlighter-rouge&quot;&gt;y(t)&lt;/code&gt; will be
&lt;a href=&quot;https://en.wikipedia.org/wiki/Continuous_function&quot;&gt;continuous&lt;/a&gt;
any time &lt;code class=&quot;highlighter-rouge&quot;&gt;h(t)&lt;/code&gt; is
&lt;a href=&quot;https://en.wikipedia.org/wiki/Continuous_function&quot;&gt;continuous&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;There’s an even more important consequence of this ad-hoc criteria: any
&lt;a href=&quot;https://en.wikipedia.org/wiki/Continuous_function&quot;&gt;continuous function&lt;/a&gt;
will have a &lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency_response&quot;&gt;frequency
response&lt;/a&gt;.
with an asymptotic decay proportional to &lt;code class=&quot;highlighter-rouge&quot;&gt;1/f^2&lt;/code&gt; or better.  This function
is no different.  Hence, when you put all of our constraints together, we’ve
now constrained the zero frequency, &lt;code class=&quot;highlighter-rouge&quot;&gt;f=0&lt;/code&gt;, and the first and second
derivatives of all integer frequencies.  By now insisting on a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Continuous_function&quot;&gt;continuous&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Impulse_response&quot;&gt;impulse response&lt;/a&gt;,
we’ve also constrained the asymptotic &lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency_response&quot;&gt;frequency
response&lt;/a&gt; of this
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolating&lt;/a&gt;
filter as well.&lt;/p&gt;

&lt;p&gt;In other words, we’ve just created an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolating&lt;/a&gt;
function with a very nice
&lt;a href=&quot;https://en.wikipedia.org/wiki/Low-pass_filter&quot;&gt;low-pass&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency_response&quot;&gt;frequency response&lt;/a&gt;–it
just doesn’t have a very narrow
&lt;a href=&quot;https://en.wikipedia.org/wiki/Transition_band&quot;&gt;transition band&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;DSP Guru Meditation&lt;/strong&gt;: I will contend, based more upon frustration then
proof, that it is actually impossible to create a finite quadratic
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolating&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial&quot;&gt;polynomial&lt;/a&gt; via this method that
will be &lt;a href=&quot;https://en.wikipedia.org/wiki/Continuous_function&quot;&gt;continuous&lt;/a&gt; in
its first derivative.  Before you jump to disprove me, remember my definition
of an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolating&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial&quot;&gt;polynomial&lt;/a&gt;, which requires that it
equal zero at all integer locations but zero.  Were we able to create such a
function, it would have an out of band asymptotic decay rate of &lt;code class=&quot;highlighter-rouge&quot;&gt;1/f^3&lt;/code&gt;–but
we’ll leave the discussion of such functions for a later discussion of either
higher order &lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolators&lt;/a&gt;,
or quadratic &lt;a href=&quot;https://en.wikipedia.org/wiki/Spline_interpolation&quot;&gt;splines&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;As an aside, it is possible to formulate the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Spline_interpolation&quot;&gt;splines&lt;/a&gt; problem in &lt;a href=&quot;/dsp/2018/01/16/interpolation-is-convolution.html&quot;&gt;this
fashion&lt;/a&gt;.
Doing so produces a solution that no longer requires solving for the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Piecewise&quot;&gt;piecewise&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial&quot;&gt;polynomial&lt;/a&gt; to be
coefficients at every step, while yielding a cleaner and (slightly) wider
&lt;a href=&quot;https://en.wikipedia.org/wiki/Passband&quot;&gt;passband&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;If you put all of the resulting equations together, for the constraints outlined
above, you will get an over-determined system.  This over determined system
will include several redundant equations which can be easily removed.  Once
the redundant equations are removed, you will then get the system
of linear equations below.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/quadeqn-criteria-eqns.png&quot; alt=&quot;&quot; width=&quot;441&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;In spite of starting with an over determined system in this process, we got
lucky: the system above has a unique solution given by,&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/quadeqn-criteria-soln.png&quot; alt=&quot;&quot; width=&quot;233&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Wow, that was a lot of work to just get a bunch of numbers.  So what,
right?  What’s the use of these five values?&lt;/p&gt;

&lt;p&gt;The value of this solution is seen in the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Impulse_response&quot;&gt;impulse response&lt;/a&gt; and
&lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency_response&quot;&gt;frequency response&lt;/a&gt;
shown in Fig 9.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 9. Impulse response (left) and Frequency Response (right) of this piecewise polynomial interpolator&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/interpolation-fig-betterq.png&quot; alt=&quot;&quot; width=&quot;728&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;As we required, the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Passband&quot;&gt;passband&lt;/a&gt; and
is “flat” near &lt;code class=&quot;highlighter-rouge&quot;&gt;f=0&lt;/code&gt;, and the nulls are deep.
Unlike both the &lt;a href=&quot;/dsp/2017/06/06/simple-interpolator.html&quot;&gt;nearest neighbor
interpolator&lt;/a&gt;
and the quadratic fit we
discussed above, the asymptotic fall off of this filter is proportional to
&lt;code class=&quot;highlighter-rouge&quot;&gt;1/f^2&lt;/code&gt;.  Further, unlike the &lt;a href=&quot;/dsp/2017/07/29/series-linear-interpolation.html&quot;&gt;linear interpolator we built
earlier&lt;/a&gt;
which also has an asymptotic fall off of &lt;code class=&quot;highlighter-rouge&quot;&gt;1/f^2&lt;/code&gt;, this
asymptotic fall off has a smaller proportionality coefficient of &lt;code class=&quot;highlighter-rouge&quot;&gt;1/f^2&lt;/code&gt;.
For comparison, consider Fix 7 above showing the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency_response&quot;&gt;frequency response&lt;/a&gt;
of the &lt;a href=&quot;/dsp/2017/07/29/series-linear-interpolation.html&quot;&gt;linear
interpolator&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;In other words, this quadratic
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt; forms a &lt;em&gt;nice&lt;/em&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Piecewise&quot;&gt;piecewise&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial&quot;&gt;polynomial&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolation&lt;/a&gt;
filter.&lt;/p&gt;

&lt;p&gt;Even better, with some careful coding (below) we can implement the coefficient
multiplication with only adds and subtracts.  This will mean that we can
evaluate this &lt;a href=&quot;https://github.com/ZipCPU/interpolation/blob/master/rtl/quadratic/quadinterp.v&quot;&gt;quadratic in
Verilog&lt;/a&gt;
using only two hardware multiplies–minimizing a precious resource found within
any digital logic component.&lt;/p&gt;

&lt;p&gt;Sadly, the development above is only an ad-hoc formulation.  While it
may be possible to truly generate &lt;em&gt;optimal&lt;/em&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolators&lt;/a&gt;
via this method, I have not yet pursued such a study in depth.&lt;/p&gt;

&lt;h2 id=&quot;three-interpolators-and-only-two-multiplies&quot;&gt;Three Interpolators and only Two Multiplies&lt;/h2&gt;

&lt;p&gt;In the next section, we’ll start discussing how to build the
&lt;a href=&quot;https://github.com/ZipCPU/interpolation/blob/master/rtl/quadratic/quadinterp.v&quot;&gt;Verilog code necessary to
implement&lt;/a&gt;
this &lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;.
Indeed, well even do one better than that: we’ll show
the Verilog code necessary to implement three separate quadratic
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolators&lt;/a&gt;–all with only
&lt;em&gt;two multiplies&lt;/em&gt;.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;The first &lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;
will be the one that results from the quadratic fit approach I was so
critical of above.  We’ll use this performance for reference below.  This
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;
is given by the equations we developed above:&lt;/li&gt;
&lt;/ol&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/quadeqn-fit-coeffs.png&quot; alt=&quot;&quot; width=&quot;367&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;As we discussed above, we can expect this
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;
to produce a discontinuous output waveform.&lt;/p&gt;

&lt;ol start=&quot;2&quot;&gt;
  &lt;li&gt;The second &lt;a href=&quot;https://en.wikipedia.org/wiki/Upsamplers&quot;&gt;upsampling&lt;/a&gt;
function may have the best &lt;a href=&quot;https://en.wikipedia.org/wiki/Stopband&quot;&gt;stopband&lt;/a&gt;
performance among all quadratic
&lt;a href=&quot;https://en.wikipedia.org/wiki/Upsamplers&quot;&gt;upsamplers&lt;/a&gt;, however it’s not a true
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;
since it doesn’t necessarily go through the original signal
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;sample&lt;/a&gt;
points.  We’ll call this the
non-&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;
for lack of a better term.  This
non-&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;
is a very valuable
&lt;a href=&quot;https://en.wikipedia.org/wiki/Upsamplers&quot;&gt;upsampling&lt;/a&gt;
function for the simple reason that its
&lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency_response&quot;&gt;frequency response&lt;/a&gt;
tail falls off faster (&lt;code class=&quot;highlighter-rouge&quot;&gt;1/f^3&lt;/code&gt;) than any other quadratic.  Indeed, it is
so valuable, that we may come back and use it to beat the performance of a
&lt;a href=&quot;/dsp/2017/08/30/cordic.html&quot;&gt;CORDIC&lt;/a&gt;–but
that will have to be the topic of a future article (it will still require
two multiples, something the
&lt;a href=&quot;/dsp/2017/08/30/cordic.html&quot;&gt;CORDIC&lt;/a&gt; doesn’t need).&lt;/li&gt;
&lt;/ol&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/quadeqn-cub-coeffs.png&quot; alt=&quot;&quot; width=&quot;383&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 11.  The impulse response of a rectangle convolved with itself three times&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/interpolation-fig-rcubd-impulse.png&quot; alt=&quot;&quot; width=&quot;325&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;This non-&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;
will not suffer from the discontinuities we discussed above.  Further, if you
are up to a calculus challenge, this function can be derived by
&lt;a href=&quot;https://en.wikipedia.org/wiki/Convolution&quot;&gt;convolving&lt;/a&gt; a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Rectangular_function&quot;&gt;rectangle function&lt;/a&gt;
with itself three separate times, hence its
&lt;a href=&quot;https://en.wikipedia.org/wiki/Impulse_response&quot;&gt;impulse response&lt;/a&gt;
is shown in Fig 11.&lt;/p&gt;

&lt;p&gt;One unique feature of this
&lt;a href=&quot;https://en.wikipedia.org/wiki/Upsamplers&quot;&gt;upsampler&lt;/a&gt;
is its properties when doing peak finding.  Indeed, peaks found following
this fit tend to be more accurately located than when using the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;
that is the topic of today’s development–but this again is a topic for
another day.&lt;/p&gt;

&lt;p&gt;Since the non-&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;’s
&lt;a href=&quot;https://en.wikipedia.org/wiki/Impulse_response&quot;&gt;impulse response&lt;/a&gt;
response is created by &lt;a href=&quot;https://en.wikipedia.org/wiki/Convolution&quot;&gt;convolving&lt;/a&gt; a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Rectangular_function&quot;&gt;rectangle function&lt;/a&gt;
with itself three separate times, its
&lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency_response&quot;&gt;frequency response&lt;/a&gt;
will be given by the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency_response&quot;&gt;frequency response&lt;/a&gt; of a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Rectangular_function&quot;&gt;rectangle function&lt;/a&gt;
cubed, or in other words by a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sinc_funtion&quot;&gt;sinc function&lt;/a&gt; cubed.&lt;/p&gt;

&lt;p&gt;Further, if you compare the coefficients of this
the non-&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;’s
&lt;a href=&quot;https://en.wikipedia.org/wiki/Impulse_response&quot;&gt;impulse response&lt;/a&gt;
with those of the quadratic fit (above), you’ll see that all but the
constant coefficients, &lt;code class=&quot;highlighter-rouge&quot;&gt;c_n&lt;/code&gt;, are identical.&lt;/p&gt;

&lt;p&gt;In &lt;a href=&quot;https://github.com/ZipCPU/interpolation/blob/master/rtl/quadratic/quadinterp.v&quot;&gt;our code&lt;/a&gt;
below, the parameter &lt;code class=&quot;highlighter-rouge&quot;&gt;OPT_IMPROVED_FIT&lt;/code&gt; will control whether or not this
non-&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolating&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Upsamplers&quot;&gt;upsampler&lt;/a&gt;
is generated or not.  If set, the traditional quadratic fit will be bypassed
for this alternative implementation.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;DSP Guru Meditation&lt;/strong&gt;: My statement above that the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency_response&quot;&gt;frequency response&lt;/a&gt;
tail of this filter asymptotically decays &lt;em&gt;faster than any other quadratic&lt;/em&gt;
isn’t quite true.  Quadratics filters composed of a linear combinations of
this filter function will also fall off at the &lt;code class=&quot;highlighter-rouge&quot;&gt;1/f^3&lt;/code&gt; rate … but we’ll
leave the further discussion of this approach to a future discussion of
quadratic (and/or cubic)
&lt;a href=&quot;https://en.wikipedia.org/wiki/Spline_interpolation&quot;&gt;splines&lt;/a&gt;, since that’s
where it is most relevant.&lt;/p&gt;

&lt;ol start=&quot;3&quot;&gt;
  &lt;li&gt;The third function we’ll implement is defined by the coefficient
equations we just developed in the last section above.&lt;/li&gt;
&lt;/ol&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/quadeqn-nfit-coeffs.png&quot; alt=&quot;&quot; width=&quot;675&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;This is the one we expect to see good results from–it is
&lt;a href=&quot;https://en.wikipedia.org/wiki/Continuous_function&quot;&gt;continuous&lt;/a&gt;,
and passes constants, lines, and quadratics without distortion.  Not
only that, the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;
generated by this function is guaranteed to go through the initial
&lt;code class=&quot;highlighter-rouge&quot;&gt;x[n]&lt;/code&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;sample&lt;/a&gt;
points given to it.&lt;/p&gt;

&lt;p&gt;The parameter &lt;code class=&quot;highlighter-rouge&quot;&gt;OPT_INTERPOLATOR&lt;/code&gt; in
&lt;a href=&quot;https://github.com/ZipCPU/interpolation/blob/master/rtl/quadratic/quadinterp.v&quot;&gt;our code below&lt;/a&gt;
will control whether or not this
implementation is used.  If set, &lt;code class=&quot;highlighter-rouge&quot;&gt;OPT_INTERPOLATOR&lt;/code&gt; will override the
&lt;code class=&quot;highlighter-rouge&quot;&gt;OPT_IMPROVED_FIT&lt;/code&gt; option parameter above, yielding an implementation of
this quadratic
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;We’ll use some careful coding techniques in the next section in order to
avoid using hardware multiplication elements when multiplying the quadratic
coefficients generated by the incoming data by these factors,
28, 16, 10, 3/4, etc.  The resulting algorithm will use only shifts and adds–up
until the final quadratic evaluation.  We will need to be careful
to make certain that we track the decimal point during this process though.&lt;/p&gt;

&lt;p&gt;When it comes to evaluating the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial&quot;&gt;polynomial&lt;/a&gt;
itself, if you’ve never implemented one numerically, then you should know
that there is a right and a wrong way to apply the multiply–a “trick” if you
will.  In particular, you don’t want to calculate your result by a
straight forward evaluation,&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/quadeqn-implementation-bad.png&quot; alt=&quot;&quot; width=&quot;243&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;This straight forward approach suffers from two problems.  The first problem is
that it costs three multiplies.  (Ouch!) The second problem is that this method
is susceptible to the loss of precision as the intermediate values are
truncated prior to their final addition.&lt;/p&gt;

&lt;p&gt;Instead, we’ll calculate this
&lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial&quot;&gt;polynomial&lt;/a&gt;’s
value based upon a different formulation:&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/quadeqn-implementation.png&quot; alt=&quot;&quot; width=&quot;217&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;This will solve both of these problems, yielding a nice solution suitable for
RTL implementation.&lt;/p&gt;

&lt;h2 id=&quot;fixed-point&quot;&gt;Fixed Point&lt;/h2&gt;

&lt;p&gt;Let’s pause for one more section before diving into
&lt;a href=&quot;https://github.com/ZipCPU/interpolation/blob/master/rtl/quadratic/quadinterp.v&quot;&gt;the code&lt;/a&gt;
below, to discuss how we are going to handle the evaluation of the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Piecewise&quot;&gt;piecewise&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial&quot;&gt;polynomial&lt;/a&gt;
function coefficients.&lt;/p&gt;

&lt;p&gt;Our first step will be to replace the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial&quot;&gt;polynomial&lt;/a&gt;,
coefficients with elements of a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;sample&lt;/a&gt;
based shift register.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
if (i_ce)
	{ x[3], x[2], x[1], x[0] } &amp;lt;= { x[2], x[1], x[0], in };&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This will eliminate the dependence of the algorithm on the integer &lt;code class=&quot;highlighter-rouge&quot;&gt;n&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;We’ll use the input data as the first element in this registers,
and use &lt;code class=&quot;highlighter-rouge&quot;&gt;x[0]&lt;/code&gt; to refer to the prior input, &lt;code class=&quot;highlighter-rouge&quot;&gt;x[1]&lt;/code&gt; to refer to the value
before that, etc.  Hence, we’ll map the following values:&lt;/p&gt;

&lt;table class=&quot;bordered-table&quot;&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Old name&lt;/th&gt;
      &lt;th&gt;New Name&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;x[n+2]&lt;/td&gt;
      &lt;td&gt;in&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;x[n+1]&lt;/td&gt;
      &lt;td&gt;x[0]&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;x[n+0]&lt;/td&gt;
      &lt;td&gt;x[1]&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;x[n-1]&lt;/td&gt;
      &lt;td&gt;x[2]&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;x[n-2]&lt;/td&gt;
      &lt;td&gt;x[3]&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;This allows us to re-express the above filter coefficient equations as,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;   16 av = 4(x[1]-8x[1])+16(x[0]+x[2])-2(in+x[3])
   16 bv = 2[(x[0]-x[2])+4(x[0]-x[2])]+(in-x[3])
   cv = x[1]&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;You may also notice that all of the multiplies necessary to calculate
the coefficients, &lt;code class=&quot;highlighter-rouge&quot;&gt;a_n&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;b_n&lt;/code&gt;, and &lt;code class=&quot;highlighter-rouge&quot;&gt;c_n&lt;/code&gt;,
have now been replaced with adds and shifts.  Instead of multiplying by &lt;code class=&quot;highlighter-rouge&quot;&gt;-28&lt;/code&gt;
for example, we can subtract &lt;code class=&quot;highlighter-rouge&quot;&gt;8x[1]&lt;/code&gt; from &lt;code class=&quot;highlighter-rouge&quot;&gt;x[1]&lt;/code&gt; and then shift the result left by two bits.  In a similar fashion, we can multiply &lt;code class=&quot;highlighter-rouge&quot;&gt;x[0]-x[2]&lt;/code&gt; by five
by adding &lt;code class=&quot;highlighter-rouge&quot;&gt;x[0]-x[2]&lt;/code&gt; to &lt;code class=&quot;highlighter-rouge&quot;&gt;4(x[0]-x[2])&lt;/code&gt;.  The final multiplication by
two, or rather left shift by one, just completes the desired multiply by ten.&lt;/p&gt;

&lt;p&gt;Even this is too hard, though, since it will take us a couple of clocks to
calculate these values.  Hence we’ll go about calculating our coefficients
in three steps each in a different clock cycle.&lt;/p&gt;

&lt;p&gt;We’ll start, therefore, by splitting this process into three sets of operations.
Eventually these will take place on separate clock cycles, but for now we can
draw them out as though they all happened at once.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;   pmidv = 8x[1] - x[1]; // = 7x[1]
   psumn =  x[0] + x[2];
   difn  =  x[0] - x[2];
   //
   diffn = difn + 4difn;	// = 5 * (x[0] - x[2])
   sumw  =   in  + x[3];
   diffw =   in  - x[3];
   midvpsumn = 4(psumn) - (pmidv); // = 4(x[0]+x[2])-7x[1]
   //
   16 av = 4(midvpsumn)-2(sumw)
   16 bv = 2(diffn)+(diffw)
   cv = x[1]&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This can then be rewritten into pseudo-RTL logic over the space of three clock
cycles.  Our notation for the shift register components from before, &lt;code class=&quot;highlighter-rouge&quot;&gt;in&lt;/code&gt;
through &lt;code class=&quot;highlighter-rouge&quot;&gt;x[3]&lt;/code&gt;, will be valid on the second clock cycle.  Hence, for the
first clock we’ll be referencing &lt;code class=&quot;highlighter-rouge&quot;&gt;in&lt;/code&gt; through &lt;code class=&quot;highlighter-rouge&quot;&gt;x[2]&lt;/code&gt; instead of &lt;code class=&quot;highlighter-rouge&quot;&gt;x[0]&lt;/code&gt;
through &lt;code class=&quot;highlighter-rouge&quot;&gt;x[3]&lt;/code&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
if (i_ce)
begin
   // First clock, pre-data
   pmidv &amp;lt;= 8x[0] - x[0]; // Was 8x[1] - x[1]
   psumn &amp;lt;=   in + x[1];  // Was x[0] + x[2]
   difn  &amp;lt;=   in - x[1];  // Was x[0] - x[2]&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This takes care of some of the inner operations from our equations above.
The next step handles some more of the “multiplies”.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;   // Second clock
   diffn &amp;lt;= difn + 4difn;	// = 5 * (x[0] - x[2])
   sumw  &amp;lt;=   in  + x[3];
   diffw &amp;lt;=   in  - x[3];
   midvpsumn &amp;lt;= 4(psumn) - (pmidv); // = 4(x[0]+x[2])-7x[1]&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;In the final clock cycle we’ll calculate the actual coefficients.  Because
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
math is primarily fixed point, we’ll leave the &lt;code class=&quot;highlighter-rouge&quot;&gt;16&lt;/code&gt; on the left–indicating
that we never divided by the necessary 16.  We’ll need to drop the extra four
bits later, but for now we’ll leave them in
place as long as possible to avoid loss of precision.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;   // Third clock, data delayed by one
   av &amp;lt;= 4(midvpsumn)-2(sumw); // * 2^4
   bv &amp;lt;= 2(diffn)+(diffw); // * 2^4
   cv &amp;lt;= x[2];
end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This gives us the coefficients of our
&lt;a href=&quot;https://en.wikipedia.org/wiki/Piecewise&quot;&gt;piecewise&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial&quot;&gt;polynomial&lt;/a&gt; for a given
set of five input samples.&lt;/p&gt;

&lt;p&gt;We still need to calculate the value of &lt;code class=&quot;highlighter-rouge&quot;&gt;t&lt;/code&gt; that needs to be used when
evaluating this &lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial&quot;&gt;polynomial&lt;/a&gt;.
This logic will follow directly from the &lt;a href=&quot;/dsp/2017/07/29/series-linear-interpolation.html&quot;&gt;linear interpolator
development&lt;/a&gt;,
and is even copied from that development.&lt;/p&gt;

&lt;p&gt;The only big difference between this and the &lt;a href=&quot;/dsp/2017/07/29/series-linear-interpolation.html&quot;&gt;linear
interpolator&lt;/a&gt;
development is that, unlike the
&lt;a href=&quot;/dsp/2017/07/29/series-linear-interpolation.html&quot;&gt;linear interpolator&lt;/a&gt;,
this &lt;a href=&quot;https://en.wikipedia.org/wiki/Piecewise&quot;&gt;piecewise&lt;/a&gt; quadratic
&lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial&quot;&gt;polynomial&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolates&lt;/a&gt;
from &lt;em&gt;around&lt;/em&gt; the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;sample&lt;/a&gt; points
(&lt;code class=&quot;highlighter-rouge&quot;&gt;|t|&amp;lt;1/2&lt;/code&gt;), rather than &lt;em&gt;between&lt;/em&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;sample&lt;/a&gt; points,
(&lt;code class=&quot;highlighter-rouge&quot;&gt;0&amp;lt;t&amp;lt;1&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;Perhaps this would make more sense with a figure.  Fig 12 therefore shows in
color how the quadratic
&lt;a href=&quot;https://en.wikipedia.org/wiki/Upsamplers&quot;&gt;upsampler&lt;/a&gt;
will interpolate from &lt;em&gt;around&lt;/em&gt; the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;sample&lt;/a&gt;
points on the left, rather than &lt;em&gt;between&lt;/em&gt; the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;sample&lt;/a&gt;
points as shown on the right.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 12. Piecewise quadratics interpolate around sample points (left), rather than between sample points (right)&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/quadeqn-intervals-compared.png&quot; alt=&quot;&quot; width=&quot;728&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;I’m not really sure why this is so, I just know that I haven’t managed to
build a symmetric quadratic
&lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial&quot;&gt;polynomial&lt;/a&gt;
&lt;em&gt;between&lt;/em&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;sample&lt;/a&gt; points
(right side of Fig. 12 above) that ended up being very useful.  To handle this
difference, we’ll keep track of the last coefficients.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
if (i_ce)
begin
	avold &amp;lt;= av;
	bvold &amp;lt;= bv;
	cvold &amp;lt;= cv;
end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Then, if our local &lt;code class=&quot;highlighter-rouge&quot;&gt;t&lt;/code&gt; value is less then zero (&lt;code class=&quot;highlighter-rouge&quot;&gt;MSB&lt;/code&gt; is set), we’ll
use the newer coefficients, &lt;code class=&quot;highlighter-rouge&quot;&gt;av&lt;/code&gt;-&lt;code class=&quot;highlighter-rouge&quot;&gt;cv&lt;/code&gt;, otherwise we’ll use the
older, delayed by one &lt;code class=&quot;highlighter-rouge&quot;&gt;avold&lt;/code&gt;-&lt;code class=&quot;highlighter-rouge&quot;&gt;cvold&lt;/code&gt; coefficients.&lt;/p&gt;

&lt;p&gt;We’d also like to add a half to &lt;code class=&quot;highlighter-rouge&quot;&gt;t&lt;/code&gt; at this point, so that it ranges between
&lt;code class=&quot;highlighter-rouge&quot;&gt;0&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt; instead of from &lt;code class=&quot;highlighter-rouge&quot;&gt;-0.5&lt;/code&gt; to &lt;code class=&quot;highlighter-rouge&quot;&gt;0.5&lt;/code&gt;.  It turns out that’s not needed.
&lt;code class=&quot;highlighter-rouge&quot;&gt;t&lt;/code&gt; naturally fits into place without change–all that’s required is to
re-interpret the signed &lt;code class=&quot;highlighter-rouge&quot;&gt;t&lt;/code&gt; value as an unsigned value and the conversion
is done.&lt;/p&gt;

&lt;p&gt;That gives us our three coefficients, &lt;code class=&quot;highlighter-rouge&quot;&gt;r_av&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;r_bv&lt;/code&gt;, and &lt;code class=&quot;highlighter-rouge&quot;&gt;r_cv&lt;/code&gt;,
together with our time offset, &lt;code class=&quot;highlighter-rouge&quot;&gt;r_offset&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Finally, as we go through the rest of the algorithm, we’ll use the prefixes
&lt;code class=&quot;highlighter-rouge&quot;&gt;r_&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;qp_&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;ls_&lt;/code&gt;, and &lt;code class=&quot;highlighter-rouge&quot;&gt;lp_&lt;/code&gt; to indicate which stage of the quadratic
algorithm we are in.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;The &lt;code class=&quot;highlighter-rouge&quot;&gt;r_&lt;/code&gt; prefix will hold the first copies of our variables in the “new”
sample rate domain.  This will include not only the quadratic coefficients,
&lt;code class=&quot;highlighter-rouge&quot;&gt;r_av&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;r_bv&lt;/code&gt;, and &lt;code class=&quot;highlighter-rouge&quot;&gt;r_cv&lt;/code&gt;, but also the value of &lt;code class=&quot;highlighter-rouge&quot;&gt;t&lt;/code&gt; associated with
these coefficients, held in &lt;code class=&quot;highlighter-rouge&quot;&gt;r_offset&lt;/code&gt;.  Finally, &lt;code class=&quot;highlighter-rouge&quot;&gt;r_ce&lt;/code&gt; will be true on
any clock where these values are valid.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The &lt;code class=&quot;highlighter-rouge&quot;&gt;qp_&lt;/code&gt; prefix will hold our variables immediately after taking
the &lt;em&gt;quadratic product&lt;/em&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;a*t&lt;/code&gt; or in terms of our registers,
&lt;code class=&quot;highlighter-rouge&quot;&gt;r_av * r_offset&lt;/code&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The &lt;code class=&quot;highlighter-rouge&quot;&gt;ls_&lt;/code&gt; prefix will refer to the variables associated with the
&lt;em&gt;linear sum&lt;/em&gt;, the result of adding &lt;code class=&quot;highlighter-rouge&quot;&gt;a*t+b&lt;/code&gt; or equivalently the output
of the quadratic product plus &lt;code class=&quot;highlighter-rouge&quot;&gt;r_bv&lt;/code&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The &lt;code class=&quot;highlighter-rouge&quot;&gt;lp_&lt;/code&gt; prefix will denote values associated with multiplying this
&lt;em&gt;last product&lt;/em&gt; and linear sum by our &lt;code class=&quot;highlighter-rouge&quot;&gt;t&lt;/code&gt; value one more time to get
&lt;code class=&quot;highlighter-rouge&quot;&gt;(at+b)*t&lt;/code&gt;.  As a result, when we add the constant to the result
of this last multiply, we’ll have our final value which we shall
call &lt;code class=&quot;highlighter-rouge&quot;&gt;r_done&lt;/code&gt;.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The algorithm below doesn’t do any rounding until the final step.  Instead,
it accumulates a lot of extra bits along the way, so that there’s not that
much precision lost along the way.&lt;/p&gt;

&lt;h2 id=&quot;the-code&quot;&gt;The Code&lt;/h2&gt;

&lt;p&gt;We’ve now made it far enough in our description that we can now walk through
the algorithm.  Feel free to skip this section if you would like and go
directly to the performance section below, and then return to this once you’ve
become convinced that you really are interested in the algorithmic details.
You can also just examine (or implement)
&lt;a href=&quot;https://github.com/ZipCPU/interpolation/blob/master/rtl/quadratic/quadinterp.v&quot;&gt;the code&lt;/a&gt;,
yourself to see what your thoughts are of it.&lt;/p&gt;

&lt;p&gt;The algorithm starts by defining some interface parameters.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	parameter	INW   = 25,	// Input width
			OWID  = INW,	// Output width
			MP    = 25,	// Multiply precision
			CTRBITS = 32;	// Bits in our counter&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;These are the input width, the output width, and the number of bits of our
time counter to use in the multiply.  The fourth value, &lt;code class=&quot;highlighter-rouge&quot;&gt;CTRBITS&lt;/code&gt;, controls
the total number of bits in the time counter.  In other words, how accurate
the fractional
&lt;a href=&quot;https://en.wikipedia.org/wiki/Upsamplers&quot;&gt;upsampling&lt;/a&gt;
ratio should be.  As with the &lt;a href=&quot;/dsp/2017/07/29/series-linear-interpolation.html&quot;&gt;linear
interpolator&lt;/a&gt;
development, this counter will step, on each input
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;sample&lt;/a&gt;,
by a step size given by the input &lt;code class=&quot;highlighter-rouge&quot;&gt;i_step&lt;/code&gt;,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;i_step = 2^(CTRBITS) (int)(old_sample_rate / new_sample_rate);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The number of bits in &lt;code class=&quot;highlighter-rouge&quot;&gt;CTRBITS&lt;/code&gt; will just control the accuracy and precision
of the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sample-rate_conversion&quot;&gt;resampling&lt;/a&gt;
function.&lt;/p&gt;

&lt;p&gt;The next two parameters, &lt;code class=&quot;highlighter-rouge&quot;&gt;OPT_INTERPOLATOR&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;OPT_IMPROVE_FIT&lt;/code&gt;, we
discussed earlier.  These control which quadratic
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sample-rate_conversion&quot;&gt;resampler&lt;/a&gt;
to implement among three defined in the code.  &lt;code class=&quot;highlighter-rouge&quot;&gt;OPT_INTERPOLATOR=1&lt;/code&gt; will
cause us to use the new
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;.
On the other hand, if &lt;code class=&quot;highlighter-rouge&quot;&gt;OPT_INTERPOLATOR=0&lt;/code&gt; but
&lt;code class=&quot;highlighter-rouge&quot;&gt;OPT_IMPROVED_FIT=1&lt;/code&gt;, then we’ll use the
non-&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;
output.  Finally, if both are zero the algorithm will calculate the
quadratic fit I’ve been so critical of.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	parameter  [0:0]	OPT_IMPROVED_FIT = 1&#39;b1;
	parameter  [0:0]	OPT_INTERPOLATOR = 1&#39;b1;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The last parameter, &lt;code class=&quot;highlighter-rouge&quot;&gt;GAIN_OFFSET&lt;/code&gt;, controls how far we shift the final result
to the right.  Ideally, this would be 4 if &lt;code class=&quot;highlighter-rouge&quot;&gt;OPT_INTERPOLATOR&lt;/code&gt; would be set in
order to divide by the factor of sixteen shown above.  Sadly, we can’t do that.
In particular, a set of constant maximum negative values surrounding a maximum
positive value, or vice versa, will yield filter results outside of that
incoming range.  Hence, to avoid overflow, we’ll only shift by three bits
(divide by eight), or two for the quadratic fit approaches.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	parameter		GAIN_OFFSET = (OPT_INTERPOLATOR)? 3:2;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The next step is to calculate the bit widths of various portions of this
algorithm.  These are held in local parameters, since they are calculated
from the main parameters above.  The first are the bit widths of the
coefficients,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;			// Bit-Width&#39;s of the quadratic, linear, and constant
			// coefficients
	localparam	AW = (OPT_INTERPOLATOR)?INW+6:INW+2,
			BW = (OPT_INTERPOLATOR)?INW+6:INW+1,
			CW = (OPT_INTERPOLATOR)?INW  :((OPT_IMPROVED_FIT)?(INW+3):INW),&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;followed by the number of bits we’ll have after the decimal place following each
computation,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;			ADEC=(OPT_INTERPOLATOR)? 4:1,
			BDEC=(OPT_INTERPOLATOR)? 4:1,
			CDEC=(OPT_INTERPOLATOR)? 0:((OPT_IMPROVED_FIT)? 3:0);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Remember, any time you want to multiply integers and fractions such as &lt;code class=&quot;highlighter-rouge&quot;&gt;A.B&lt;/code&gt;
times &lt;code class=&quot;highlighter-rouge&quot;&gt;X.Y&lt;/code&gt; (not the decimal place), you’ll need to first move the decimal
place to the far right so as to get &lt;code class=&quot;highlighter-rouge&quot;&gt;2^N(AB.)&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;2^M(XY.)&lt;/code&gt;.  Then, when
you multiply these numbers, you can shift them back to get the result you
were looking for back to where it belongs:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;A.B * X.Y = (AB. * XY.)*2^(-N-M)&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Of course, in practice this just means that we’ll track this resulting
decimal point, as you’ll see through &lt;a href=&quot;https://github.com/ZipCPU/interpolation/blob/master/rtl/quadratic/quadinterp.v&quot;&gt;the
code&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The final local parameter is the width of the internal calculations.
This is the number of bits that we will keep following each multiply.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	localparam	BMW = ((AW-ADEC&amp;gt;BW-BDEC) ? (AW-ADEC+BDEC) : BW);
	localparam	CMW = ((BMW+1-BDEC&amp;gt;CW-CDEC) ? (BMW+1-BDEC+CDEC) : CW);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;With these preliminaries aside, we can finally dig in to the
&lt;a href=&quot;https://github.com/ZipCPU/interpolation/blob/master/rtl/quadratic/quadinterp.v&quot;&gt;implementation&lt;/a&gt;
of our quadratic
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;,
beginning with how we generate the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial&quot;&gt;polynomial&lt;/a&gt;
coefficients themselves.  Since this will change depending upon our
choice of quadratic, we’ll use a generate block to select from among
several logic sets.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	generate if (OPT_INTERPOLATOR)
	begin&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;As our first step, we’ll calculate the shift register of data inputs
and a short history that we discussed above in the last section.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;		always @(posedge i_clk)
		if (i_ce)
			{ mem[3], mem[2], mem[1], mem[0] }
				&amp;lt;= { mem[2], mem[1], mem[0], i_data };&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Let’s take a moment here to discuss &lt;code class=&quot;highlighter-rouge&quot;&gt;i_ce&lt;/code&gt;.  This is the “global CE” signal
from our &lt;a href=&quot;/blog/2017/08/14/strategies-for-pipelining.html&quot;&gt;previous discussion on pipeline
strategies&lt;/a&gt;.
As you may recall from &lt;a href=&quot;/blog/2017/08/14/strategies-for-pipelining.html&quot;&gt;that
discussion&lt;/a&gt;,
the “global CE strategy” is very appropriate for
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_signal_processing&quot;&gt;signal processing&lt;/a&gt;
applications.  Further, you’ll want to remember the rules associated with the
“global CE” signal: &lt;em&gt;Nothing&lt;/em&gt; changes except on the clock that &lt;code class=&quot;highlighter-rouge&quot;&gt;i_ce&lt;/code&gt; is true.
Since this is a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sample-rate_conversion&quot;&gt;resampling&lt;/a&gt;
module, though, we’ll have to extend this rule.  Nothing on the incoming
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;sample&lt;/a&gt;,
rate side changes unless &lt;code class=&quot;highlighter-rouge&quot;&gt;i_ce&lt;/code&gt; is true.
We’ll use another CE signal, &lt;code class=&quot;highlighter-rouge&quot;&gt;r_ce&lt;/code&gt; for the output
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;sample&lt;/a&gt;
side in a moment.&lt;/p&gt;

&lt;p&gt;The next several calculations also follow directly from the last section
as well.  The only difference here is that this time we are applying the
necessary shifts to accomplish the needed “multiplies” from before.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;		always @(posedge i_clk)
		if (i_ce)
		begin
			pmidv &amp;lt;= { mem[0], 3&#39;b000 }
					- { {(3){mem[0][INW-1]}},mem[0]};// x7
			psumn &amp;lt;= { i_data[(INW-1)], i_data }
					+ { mem[1][(INW-1)], mem[1] };
			pdifn &amp;lt;= { i_data[(INW-1)], i_data }
					- { mem[1][(INW-1)], mem[1] };
			//
			sumw &amp;lt;= { mem[3][(INW-1)], mem[3] }
					+ { i_data[(INW-1)], i_data };
			// sumn &amp;lt;= psumn;
			diffn&amp;lt;= { pdifn[INW], pdifn, 2&#39;b00 }
					+ ,pdifn };// x5
			diffw&amp;lt;= { i_data[(INW-1)], i_data }
					- { mem[3][(INW-1)], mem[3] };
			// midv &amp;lt;= pmidv;
			midvpsumn &amp;lt;= -{ pmidv[(INW+2)],pmidv }
					+ { psumn[INW], psumn, 2&#39;h0 };//x7 + x4
		end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;That’s the first two clocks.  Then, on the third clock, we use these
intermediate expressions to generate the actual quadratic coefficients.
Remember, though, the &lt;code class=&quot;highlighter-rouge&quot;&gt;mem[x]&lt;/code&gt; values by this clock have shifted forward by
one extra
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;sample&lt;/a&gt;.
As a result, &lt;code class=&quot;highlighter-rouge&quot;&gt;cv&lt;/code&gt; is set to &lt;code class=&quot;highlighter-rouge&quot;&gt;mem[2]&lt;/code&gt; instead of &lt;code class=&quot;highlighter-rouge&quot;&gt;mem[1]&lt;/code&gt;.
Likewise, the &lt;code class=&quot;highlighter-rouge&quot;&gt;av&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;bv&lt;/code&gt; values here have been multiplied by sixteen
compared to the coefficients we want.  This factor of sixteen will ultimately,
and only partially, be corrected with the &lt;code class=&quot;highlighter-rouge&quot;&gt;GAIN_OFFSET&lt;/code&gt; when we are done.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;		initial	av = 0;
		initial	bv = 0;
		always @(posedge i_clk)
		if (i_ce)
		begin
			// av = x28 + x16 + x2
			// av = - { midv, 2&#39;b00 } + { sumn, 4&#39;h0 } - { sumw, 1&#39;b0 };
			av &amp;lt;= { midvpsumn, 2&#39;b00 }
					- { {(4){sumw[INW]}}, sumw, 1&#39;b0 };
			bv &amp;lt;= { diffn[INW+3],diffn, 1&#39;b0 }
				- { {(5){diffw[INW]}}, diffw };
			cv &amp;lt;= mem[2];
		end

	end else begin&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The next two sections in &lt;a href=&quot;https://github.com/ZipCPU/interpolation/blob/master/rtl/quadratic/quadinterp.v&quot;&gt;the
code&lt;/a&gt;
calculate the coefficients of the quadratic fit and
our non-&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolating&lt;/a&gt;
quadratic.  We’ll skip these here for simplicity, so that we can focus on
today’s quadratic &lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;,
however we’ll show the results of these
&lt;a href=&quot;https://en.wikipedia.org/wiki/Upsamplers&quot;&gt;upsampling&lt;/a&gt;
filters further down.&lt;/p&gt;

&lt;p&gt;At this point, then, we have our three quadratic coefficients, &lt;code class=&quot;highlighter-rouge&quot;&gt;av&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;bv&lt;/code&gt;,
and &lt;code class=&quot;highlighter-rouge&quot;&gt;cv&lt;/code&gt;–regardless of which algorithm generated them.&lt;/p&gt;

&lt;p&gt;We discussed in the last section the need for keeping the coefficients from
the last interval around, so we’ll copy them here.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(posedge i_clk)
	if (i_ce)
	begin
		avold &amp;lt;= av;
		bvold &amp;lt;= bv;
		cvold &amp;lt;= cv;
	end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;We’ll
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sample-rate_conversion&quot;&gt;resample&lt;/a&gt;
our data two clocks following any new incoming data, so let’s
capture that new value here.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(posedge i_clk)
		pre_ce &amp;lt;= i_ce;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;That brings us to calculating when to take our next
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;sample&lt;/a&gt;.
This code should be familiar, as it was lifted from our discussion on
&lt;a href=&quot;/dsp/2017/07/29/series-linear-interpolation.html&quot;&gt;linear interpolators&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;First, we calculate the when of the next
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;sample&lt;/a&gt;
point.  Our &lt;code class=&quot;highlighter-rouge&quot;&gt;t&lt;/code&gt; value is given by this counter.  When the counter overflows,
the next outgoing
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;sample&lt;/a&gt;
will require a new incoming
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;sample&lt;/a&gt;
so we’ll then stop moving forward and wait for that next
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;sample&lt;/a&gt;&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	// ...
	initial	r_ovfl  = 1&#39;b1;
	always @(posedge i_clk)
		if (i_ce)
			{ r_ovfl, r_counter } &amp;lt;= r_counter + i_step;
		else if (!r_ovfl)
			{ r_ovfl, r_counter } &amp;lt;= r_counter + i_step;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;In the end, the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;sample&lt;/a&gt;
indicator is a combination of either following a new
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;sample&lt;/a&gt;
value, or any other
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;sample&lt;/a&gt;
up until the counter overflows.  In this fashion, we’ll
&lt;a href=&quot;https://en.wikipedia.org/wiki/Upsamplers&quot;&gt;upsample&lt;/a&gt;
the incoming data.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	// ...
	initial	r_ce = 1&#39;b0;
	always @(posedge i_clk)
		r_ce &amp;lt;= ((pre_ce)||(!r_ovfl));&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Please feel free to refer back to the &lt;a href=&quot;/dsp/2017/07/29/series-linear-interpolation.html&quot;&gt;linear
interpolator&lt;/a&gt;
series if you find this logic difficult to understand.&lt;/p&gt;

&lt;p&gt;Two steps are left before evaluating the quadratic
&lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial&quot;&gt;polynomial&lt;/a&gt;: calculating &lt;code class=&quot;highlighter-rouge&quot;&gt;t&lt;/code&gt;,
and switching our coefficients so that the quadratic function we create
&lt;em&gt;surrounds&lt;/em&gt; our incoming data point. This accomplishes the transformation
illustrated in Fig 12 above.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(posedge i_clk)
	if (r_ce)
		pre_offset &amp;lt;= r_counter[(CTRBITS-1):(CTRBITS-MP)];

	// ...
	always @(posedge i_clk)
		if (r_ce)
		begin
			r_offset &amp;lt;= { pre_offset[MP-1], pre_offset[(MP-2):0] };
			if (pre_offset[(MP-1)])
			begin
				r_av &amp;lt;= av;
				r_bv &amp;lt;= bv;
				r_cv &amp;lt;= cv;
			end else begin
				r_av &amp;lt;= avold;
				r_bv &amp;lt;= bvold;
				r_cv &amp;lt;= cvold;
			end
		end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;At this point we now have our quadratic coefficients, &lt;code class=&quot;highlighter-rouge&quot;&gt;r_av&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;r_bv&lt;/code&gt;, and
&lt;code class=&quot;highlighter-rouge&quot;&gt;r_cv&lt;/code&gt;, together with our time offset, &lt;code class=&quot;highlighter-rouge&quot;&gt;r_offset&lt;/code&gt;.  These are the coefficients
of the quadratic we wish to evaluate.  Indeed, at this point all of the
difficult stuff is done.  All that remains is to handle the quadratic
evaluation itself.&lt;/p&gt;

&lt;p&gt;The first step is to multiply &lt;code class=&quot;highlighter-rouge&quot;&gt;a&lt;/code&gt; by &lt;code class=&quot;highlighter-rouge&quot;&gt;t&lt;/code&gt;.  To keep everything else aligned,
we’ll forward all of our other coefficients to the next clock.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(posedge i_clk)
	if (r_ce)
	begin
		qp_quad  &amp;lt;= r_av * r_offset;	// * 2^(-MP-ADEC)
		qp_bv    &amp;lt;= r_bv;		// * 2^(-BDEC)
		qp_cv    &amp;lt;= r_cv;		// * 2^(-CDEC)
		qp_offset&amp;lt;= r_offset;		// * 2^(-MP)
	end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Many FPGA’s have dedicated multiply accumulate capability in their
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_signal_processing&quot;&gt;DSP&lt;/a&gt;
hardware.  Such a capability would allow
us to calculate &lt;code class=&quot;highlighter-rouge&quot;&gt;r_av * r_offset + r_bv&lt;/code&gt;–with an appropriate bit select
along the way.  For right or wrong, this has never been my coding practice.
Perhaps I just want more control of the operation.  Either way, I will often
split these two calculations into two separate clocks.  That’s why we aren’t
adding the &lt;code class=&quot;highlighter-rouge&quot;&gt;bv&lt;/code&gt; coefficient to this multiplication result in this clock.&lt;/p&gt;

&lt;p&gt;Before the next step, let’s consider what we have.  We have three numbers,
with decimal points in varying locations.  &lt;code class=&quot;highlighter-rouge&quot;&gt;r_av&lt;/code&gt; for example has &lt;code class=&quot;highlighter-rouge&quot;&gt;ADEC&lt;/code&gt;
bits following the decimal point, and we just multiplied it by a value, &lt;code class=&quot;highlighter-rouge&quot;&gt;t&lt;/code&gt;,
all of whose bits were to the right of the decimal point.  Hence, we now
have &lt;code class=&quot;highlighter-rouge&quot;&gt;(MP+ADEC)&lt;/code&gt; bits following our decimal point in a number that is
&lt;code class=&quot;highlighter-rouge&quot;&gt;AW&lt;/code&gt; bits wide.  Let’s keep track of this decimal point as well as the
decimal point for &lt;code class=&quot;highlighter-rouge&quot;&gt;qb_bv&lt;/code&gt; in our notes.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	// qp_quad (AW-ADEC).(MP+ADEC)
	// qb_bv   (BW-BDEC).(BDEC)&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;We are now going to want to add the results of this multiply to our &lt;code class=&quot;highlighter-rouge&quot;&gt;b&lt;/code&gt;
coefficient in our next step.  To do this though, we’re going to first
need to normalize
both values so that they have the same number of decimal points.
In spite of the ugly looking code below, we’re just dropping the extra
bits off the bottom.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	// lw_quad (BW-BDEC).(BDEC)
	assign	lw_quad = { {(BMW-(AW+MP-(MP+ADEC-BDEC))){qp_quad[(AW+MP-1)]}},
				qp_quad[(AW+MP-1):(MP+ADEC-BDEC)] };&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Hence, we just shifted &lt;code class=&quot;highlighter-rouge&quot;&gt;qp_quad&lt;/code&gt; down by &lt;code class=&quot;highlighter-rouge&quot;&gt;(MP+ADEC-BDEC)&lt;/code&gt; binary decimal points,
so that it now has &lt;code class=&quot;highlighter-rouge&quot;&gt;BDEC&lt;/code&gt; bits following the decimal instead of &lt;code class=&quot;highlighter-rouge&quot;&gt;MP+ADEC&lt;/code&gt;.
The result, &lt;code class=&quot;highlighter-rouge&quot;&gt;lw_quad&lt;/code&gt;, now has the same number of decimal places as
&lt;code class=&quot;highlighter-rouge&quot;&gt;qp_bv&lt;/code&gt;, so we can now add these two numbers together.  As before, we’ll
forward the constants we haven’t yet used to the next clock cycle.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(posedge i_clk)
	if (r_ce)
	begin
		// ...
		ls_bv    &amp;lt;= { { (BMW+1-BW){qp_bv[BW-1] } }, qp_bv }
				+ { lw_quad[BMW-1], lw_quad };
		ls_cv    &amp;lt;= qp_cv;
		ls_offset&amp;lt;= qp_offset;
	end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;As a next step, we’ll calculate &lt;code class=&quot;highlighter-rouge&quot;&gt;(a*t+b)*t&lt;/code&gt; and place the result into &lt;code class=&quot;highlighter-rouge&quot;&gt;lp_bv&lt;/code&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(posedge i_clk)
	if (r_ce)
	begin
		lp_bv    &amp;lt;= ls_bv * ls_offset;	// * 2^(-MP-BDEC)
		lp_cv    &amp;lt;= ls_cv;		// * 2^(-   CDEC)
	end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;As before, we keep track of our decimal points at this step.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	// lp_bv (BMW+1-BDEC).(BDEC+MP)
	// lp_cv    (CW-CDEC).(CDEC)&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This helps us to know how much to shift &lt;code class=&quot;highlighter-rouge&quot;&gt;lp_bv&lt;/code&gt; by in order to align it with
&lt;code class=&quot;highlighter-rouge&quot;&gt;lp_cv&lt;/code&gt; so that the two can be added in the next step.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	wire	signed	[(CMW-1):0]	wp_bv;
	assign	wp_bv = { lp_bv[(BMW+MP):(MP+BDEC-CDEC)] };&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This brings us to the last part of calculating the quadratic, adding the
constant to the final result.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(posedge i_clk)
	if (r_ce)
		r_done &amp;lt;= { wp_bv[CMW-1], wp_bv }
				 + , lp_cv};&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;And we’re done!&lt;/p&gt;

&lt;p&gt;Okay, not quite.  We still need to drop a bunch of bits.
As &lt;a href=&quot;/dsp/2017/07/22/rounding.html&quot;&gt;we discussed earlier&lt;/a&gt;,
there’s a right and a wrong way to do drop bits in a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_signal_processing&quot;&gt;DSP&lt;/a&gt;
algorithm.  Hence, we’ll round towards the nearest even integer here
and then throw the rest of the bits away.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	generate if (CMW+1-GAIN_OFFSET &amp;gt; OWID)
	begin

		reg	[CMW-GAIN_OFFSET:0]	rounded;

		initial rounded = 0;
		always @(posedge i_clk)
		if (r_ce)
			rounded &amp;lt;= r_done[(CMW-GAIN_OFFSET):0]
				+ { {(OWID){1&#39;b0}},
					r_done[CMW-GAIN_OFFSET-OWID],
				{(CMW-OWID-GAIN_OFFSET-1)
					{!r_done[CMW-GAIN_OFFSET-OWID]}} };

		assign	o_data = rounded[(CMW-GAIN_OFFSET)
					:(CMW+1-GAIN_OFFSET-OWID)];&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The &lt;a href=&quot;https://github.com/ZipCPU/interpolation/blob/master/rtl/quadratic/quadinterp.v&quot;&gt;code&lt;/a&gt;
contains two other non-rounding choices, which we shall skip here
in our discussion.&lt;/p&gt;

&lt;p&gt;The final step is to note when this output is valid.  This involves
forwarding our new &lt;a href=&quot;/blog/2017/08/14/strategies-for-pipelining.html&quot;&gt;global CE pipeline control
signal&lt;/a&gt;
to the output.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	// ...
	end endgenerate

	assign	o_ce = r_ce;

	// ...
endmodule&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;At this, we are now done and our
&lt;a href=&quot;https://github.com/ZipCPU/interpolation/blob/master/rtl/quadratic/quadinterp.v&quot;&gt;code&lt;/a&gt;
is complete.  But does it work?  Let’s see in the next section.&lt;/p&gt;

&lt;h2 id=&quot;the-proof&quot;&gt;The Proof&lt;/h2&gt;

&lt;p&gt;I’ve always counseled individuals not to use a tool they aren’t familiar with.
Every tool in the shed has its purpose, its capabilities, and its limitations.
This &lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;
is no different from any other tool in that sense.  To see how well, or
poorly, this quadratic
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;
works, let’s test it.  In particular, we can sweep a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sine_wave&quot;&gt;sine wave&lt;/a&gt;
through the input and see what happens.  Further, let’s compare this 
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;
with four different
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolation&lt;/a&gt;
methods:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Our first method will be the simple &lt;a href=&quot;/dsp/2017/06/06/simple-interpolator.html&quot;&gt;sample and hold
circuit&lt;/a&gt; we
presented earlier.  Since the code within this module doesn’t really handle
&lt;a href=&quot;https://en.wikipedia.org/wiki/Upsamplers&quot;&gt;upsampling&lt;/a&gt;, we’ll use the &lt;a href=&quot;/blog/2017/08/14/strategies-for-pipelining.html&quot;&gt;global
CE&lt;/a&gt;
from the other
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolators&lt;/a&gt;
to know when to capture this output.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The second method will be a straight-forward
&lt;a href=&quot;/dsp/2017/07/29/series-linear-interpolation.html&quot;&gt;linear interpolator&lt;/a&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Our third choice will be the quadratic fit we developed above, allowing
you to see just how good, or poor, this
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt; is in practice.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;We’ll then use the nice quadratic
&lt;a href=&quot;https://en.wikipedia.org/wiki/Upsamplers&quot;&gt;upsampler&lt;/a&gt; from above,
the one that we chose to call the
non-&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The final test algorithm is today’s quadratic
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt; algorithm.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;While I won’t walk you through the test code (today), I will post it with the
rest of the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;’s
&lt;a href=&quot;https://github.com/ZipCPU/interpolation/blob/master/rtl/quadratic/quadinterp.v&quot;&gt;code&lt;/a&gt;
in my &lt;a href=&quot;https://github.com/ZipCPU/interpolation&quot;&gt;interpolation repository&lt;/a&gt;.
If you are interested in this test code, check out the
&lt;a href=&quot;https://github.com/ZipCPU/interpolation/tree/master/bench&quot;&gt;bench&lt;/a&gt;
subdirectories.  There you will find a &lt;a href=&quot;https://github.com/ZipCPU/interpolation/blob/master/bench/rtl/icomparison.v&quot;&gt;master Verilog
module&lt;/a&gt;
that instantiates examples of all of the filters below, as well as a &lt;a href=&quot;https://github.com/ZipCPU/interpolation/blob/master/bench/cpp/icompare.cpp&quot;&gt;Verilator
based C++&lt;/a&gt;
program that will exercise these filters and write the outputs to a data file.
Finally, there’s a &lt;a href=&quot;https://github.com/ZipCPU/interpolation/blob/master/bench/cpp/plotem.m&quot;&gt;Octave
script&lt;/a&gt;
that can be used to plot these results.&lt;/p&gt;

&lt;p&gt;Sadly, the resulting data is too voluminous to plot in its entirety here,
so I’ll just pick some useful and revealing sections of this data for
discussion.&lt;/p&gt;

&lt;p&gt;For four first example, let’s compare how these
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolation&lt;/a&gt;
functions perform for a low frequency
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sine_wave&quot;&gt;sine wave&lt;/a&gt;.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 13. Low frequency interpolation&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/quadeqn-result-lo.png&quot; alt=&quot;&quot; width=&quot;581&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;By visual inspection alone, most of the quadratic
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolators&lt;/a&gt;
did pretty well.  Even the linear
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;
seems to be tracking the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sine_wave&quot;&gt;sine wave&lt;/a&gt;.
quite nicely.&lt;/p&gt;

&lt;p&gt;If you look even closer, though, you may notice some minor discontinuities
in the quadratic fit, or locations where the quadratic
non-&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;
doesn’t go through the given
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;sample&lt;/a&gt;
points.  These effects are minimal at this low frequency, but they are present.&lt;/p&gt;

&lt;p&gt;So, let’s increase the frequency.&lt;/p&gt;

&lt;p&gt;Fig 14 below shows the same
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sine_wave&quot;&gt;sine wave&lt;/a&gt;,
but this time with a frequency between &lt;code class=&quot;highlighter-rouge&quot;&gt;0.25&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;0.3&lt;/code&gt; cycles per sample.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 14. Higher frequency interpolation&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/quadeqn-result-hi.png&quot; alt=&quot;&quot; width=&quot;582&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Here the differences become very stark.  The quadratic fit’s discontinuities
are much larger, and the
non-&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;
is clearly missing the input
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;sample&lt;/a&gt;
points.&lt;/p&gt;

&lt;p&gt;If you look closer, you may even see some kinks in the quadratic
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt; we just built.
These are a result of the fact that, although this
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt; is
&lt;a href=&quot;https://en.wikipedia.org/wiki/Continuous_function&quot;&gt;continuous&lt;/a&gt;,
it is not 
&lt;a href=&quot;https://en.wikipedia.org/wiki/Continuous_function&quot;&gt;continuous&lt;/a&gt;
in its first derivative.  Achieving that result will take more work–something
we’ll leave for another day.  Even still, though, this is probably good enough
for most purposes at this frequency.&lt;/p&gt;

&lt;p&gt;What about a higher frequency?  Why not push both of these
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolators&lt;/a&gt;
until they completely break down near the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Nyquist_frequency&quot;&gt;Nyquist frequency&lt;/a&gt;?&lt;/p&gt;

&lt;p&gt;That’s the purpose of the next figure, Fig 15.  In this figure, the incoming
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sine_wave&quot;&gt;sine wave&lt;/a&gt; is
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;sampled&lt;/a&gt;
right near the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Nyquist_frequency&quot;&gt;Nyquist cutoff frequency&lt;/a&gt;
of two samples per cycle.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 15. Interpolation near Nyquist&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/quadeqn-result-aliased.png&quot; alt=&quot;&quot; width=&quot;584&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Judging from the images above, it looks like the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolators&lt;/a&gt;
are tracking the outline of a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sine_wave&quot;&gt;sine wave&lt;/a&gt;
multiplied by some kind of envelope.  The
incoming signal, however, had no envelope function constraining it.  Indeed,
the incoming signal was nothing but a straight
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sine_wave&quot;&gt;sine wave&lt;/a&gt;.  Instead, this
apparent “envelope” is the result of undersampling a high frequency
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sine_wave&quot;&gt;sine wave&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Which &lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;
is better in this environment?  I might argue that none of them work well
this close to the &lt;a href=&quot;https://en.wikipedia.org/wiki/Nyquist_frequency&quot;&gt;Nyquist
frequency&lt;/a&gt;,
and that instead this final example frequency is really beyond their
capability.  This isn’t to say that better
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolators&lt;/a&gt;
do not exist, or that they cannot be developed.  Rather, it is simply a
statement of the reality that any
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;
will break down as it approaches the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Nyquist_frequency&quot;&gt;Nyquist frequency&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;For just the cost of a couple multiplies, several additions and bit selects,
and quite a few flip-flops, we’ve managed to implement a better
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;.
This &lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;
is better than a &lt;a href=&quot;/dsp/2017/06/06/simple-interpolator.html&quot;&gt;sample and
hold&lt;/a&gt;,
better than a
&lt;a href=&quot;/dsp/2017/07/29/series-linear-interpolation.html&quot;&gt;linear interpolator&lt;/a&gt;,
and even better than the straight forward quadratic fit we started with.
Further, unlike the more traditional
&lt;a href=&quot;http://ieeexplore.ieee.org/document/15483/&quot;&gt;Farrow&lt;/a&gt;
filter development, the output of the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sample-rate_conversion&quot;&gt;resampler&lt;/a&gt;
created by &lt;a href=&quot;https://github.com/ZipCPU/interpolation/blob/master/rtl/quadratic/quadinterp.v&quot;&gt;this interpolator&lt;/a&gt;
is actually constrained to go through the input samples.&lt;/p&gt;

&lt;p&gt;Does this mean that this is the best approach to
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolation&lt;/a&gt;?
By no means.  While &lt;a href=&quot;https://github.com/ZipCPU/interpolation/blob/master/rtl/quadratic/quadinterp.v&quot;&gt;this
solution&lt;/a&gt;
has some nice properties associated with it, it has no optimality properties.
In that sense, it’s just another ad-hoc development in a similar vein to
&lt;a href=&quot;http://ieeexplore.ieee.org/document/15483/&quot;&gt;Farrow&lt;/a&gt;’s.&lt;/p&gt;

&lt;p&gt;As with everything, though, you get want you pay for.  Better 
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolators&lt;/a&gt; of this
variety exist, but they do cost more.  For example, there’s another filter like
this one documented in my &lt;a href=&quot;https://github.com/ZipCPU/interpolation/raw/master/tutorial.pdf&quot;&gt;interpolation
tutorial&lt;/a&gt;,
although the coefficient multiplies are too difficult to do with just adds
and subtracts.  Indeed, they require a divide by 80!  Another approach is to use
&lt;a href=&quot;https://en.wikipedia.org/wiki/Spline_interpolation&quot;&gt;spline&lt;/a&gt; interpolation.
You may remember my earlier suggestion that
&lt;a href=&quot;https://en.wikipedia.org/wiki/Spline_interpolation&quot;&gt;spline&lt;/a&gt; interpolation could
be done without calculating a new matrix solution for every data point.&lt;/p&gt;

&lt;!-- Mention: Asynchronous Sample Rate Conversion? --&gt;

&lt;p&gt;This, though, will need to be a discussion for another day.&lt;/p&gt;
&lt;hr /&gt;&lt;p&gt;&lt;em&gt;And he spake also a parable unto them; No man putteth a piece of a new garment upon an old; if otherwise, then both the new maketh a rent, and the piece that was taken out of the new agreeth not with the old. (Luke 5:36)&lt;/em&gt;</description>
        <pubDate>Fri, 30 Mar 2018 00:00:00 -0400</pubDate>
        <link>http://zipcpu.com/dsp/2018/03/30/quadratic.html</link>
        <guid isPermaLink="true">http://zipcpu.com/dsp/2018/03/30/quadratic.html</guid>
        
        
        <category>dsp</category>
        
      </item>
    
      <item>
        <title>Pipelining a Prefetch</title>
        <description>&lt;p&gt;If you are familiar with the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;,
you’ll know that it was built in order to be a fully capable
&lt;a href=&quot;https://en.wikipedia.org/wiki/Soft_microprocessor&quot;&gt;CPU&lt;/a&gt;
while only using a
&lt;a href=&quot;/blog/2017/06/12/minimizing-luts.html&quot;&gt;minimal amount&lt;/a&gt; of
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt; logic.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 1. The ZipCPU&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/zipcpu.png&quot; alt=&quot;&quot; width=&quot;320&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;There’s a problem, though, with the phrase, “minimal amount of logic.”
Specifically, how much is minimal?  This is a difficult question,
since the answer changes from
&lt;a href=&quot;https://github.com/ZipCPU/s6soc&quot;&gt;one design&lt;/a&gt;
to the
&lt;a href=&quot;https://github.com/ZipCPU/openarty&quot;&gt;next&lt;/a&gt;.  When it comes to a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Soft_microprocessor&quot;&gt;soft-core CPU&lt;/a&gt;,
logic and performance start to trade off against each other as well.  What
I mean by that is that you can often spend logic within an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt; in order
to purchase better performance.  Hence, if you want to build a fast
&lt;a href=&quot;https://en.wikipedia.org/wiki/Soft_microprocessor&quot;&gt;CPU&lt;/a&gt;,
you’ll want to use as much logic as you can to purchase that high speed.  On
the other hand, if you want to &lt;a href=&quot;/blog/2017/06/12/minimizing-luts.html&quot;&gt;fit within a very small
space&lt;/a&gt;,
you might find that speed is not nearly as important.&lt;/p&gt;

&lt;p&gt;As an example, this was the trade-off within the
&lt;a href=&quot;https://github.com/ZipCPU/s6soc/&quot;&gt;S6SoC&lt;/a&gt;. The
&lt;a href=&quot;https://github.com/ZipCPU/s6soc/&quot;&gt;S6SoC&lt;/a&gt; as you
&lt;a href=&quot;/blog/2017/06/12/minimizing-luts.html&quot;&gt;may recall&lt;/a&gt;
is a demonstration
of the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; that runs within a
&lt;a href=&quot;https://www.xilinx.com/support/documentation/data_sheets/ds160.pdf&quot;&gt;Spartan 6 LX4&lt;/a&gt;–the
smallest &lt;a href=&quot;https://www.xilinx.com/support/documentation/data_sheets/ds160.pdf&quot;&gt;Spartan 6
(S6)&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
you could ever buy from
&lt;a href=&quot;https://www.xilinx.com&quot;&gt;Xilinx&lt;/a&gt;.  Getting a multi-tasking
&lt;a href=&quot;https://en.wikipedia.org/wiki/Soft_microprocessor&quot;&gt;CPU&lt;/a&gt; to fit within these
constraints was a challenge.  Getting that same
&lt;a href=&quot;https://en.wikipedia.org/wiki/Soft_microprocessor&quot;&gt;CPU&lt;/a&gt;
to have decent performance at the same time is even harder.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: left&quot;&gt;&lt;caption&gt;Fig 2. Digilent&#39;s CMod S6&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/cmods6.png&quot; alt=&quot;&quot; width=&quot;250&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Getting the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; to fit within the
&lt;a href=&quot;https://github.com/ZipCPU/s6soc&quot;&gt;S6SoC&lt;/a&gt; took a bit of trimming.  I got rid
of the
&lt;a href=&quot;/zipcpu/2017/08/23/cpu-pipeline.html&quot;&gt;pipelining&lt;/a&gt;,
switched to the lowest logic
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/memops.v&quot;&gt;memory controller&lt;/a&gt;
I knew how to
build and the lowest logic
&lt;a href=&quot;/zipcpu/2017/11/18/wb-prefetch.html&quot;&gt;prefetch&lt;/a&gt;.  I
removed the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/div.v&quot;&gt;divide unit&lt;/a&gt;
and removed
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/cpudefs.v&quot;&gt;early branching&lt;/a&gt;.
(All of these modifications can be made from within the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/cpudefs.v&quot;&gt;cpudefs.v&lt;/a&gt; file.)
I got rid of the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/zipcounter.v&quot;&gt;performance
counters&lt;/a&gt;,
the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/wbdmac.v&quot;&gt;DMA
engine&lt;/a&gt;,
and the various
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/ziptimer.v&quot;&gt;timers&lt;/a&gt;
that service the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt;.
I even had to remove the &lt;a href=&quot;/blog/2017/06/28/dbgbus-goal.html&quot;&gt;debugging
bus&lt;/a&gt;–there just wasn’t
room on the
&lt;a href=&quot;https://www.xilinx.com/support/documentation/data_sheets/ds160.pdf&quot;&gt;LX4&lt;/a&gt;.
With a bit of work, I managed to get this
&lt;a href=&quot;https://github.com/ZipCPU/s6soc/tree/master/rtl/cpu&quot;&gt;trimmed-down&lt;/a&gt;
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt; to fit within the
&lt;a href=&quot;https://www.xilinx.com/support/documentation/data_sheets/ds160.pdf&quot;&gt;S6&lt;/a&gt;
on board
&lt;a href=&quot;https://store.digilentinc.com&quot;&gt;Digilent&lt;/a&gt;’s &lt;a href=&quot;https://store.digilentinc.com/cmod-s6-breadboardable-spartan-6-fpga-module&quot;&gt;CMod
S6&lt;/a&gt;
board.&lt;/p&gt;

&lt;p&gt;Then I tried to apply this
&lt;a href=&quot;https://github.com/ZipCPU/s6soc/tree/master/rtl/cpu&quot;&gt;trimmed-down&lt;/a&gt;
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt; to an
audio application.  Oh, it was a simple
demonstration: when the button is pressed, play a doorbell sound from a
recorded &lt;code class=&quot;highlighter-rouge&quot;&gt;8 kHz&lt;/code&gt; audio sample array.&lt;/p&gt;

&lt;p&gt;The &lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt; wasn’t fast enough.&lt;/p&gt;

&lt;p&gt;All the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt; had to do was to
read the audio samples from
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt;
memory, service interrupts, and particularly service the audio interrupt to
write one sample at a time to the
&lt;a href=&quot;/blog/2017/09/04/pwm-reinvention.html&quot;&gt;audio controller&lt;/a&gt;.
(Remember, I had no room for the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/wbdmac.v&quot;&gt;DMA
engine&lt;/a&gt;
to do this automatically.)&lt;/p&gt;

&lt;p&gt;The &lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt; just wasn’t fast enough as
built for even that.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Speeding&lt;/em&gt; up a &lt;a href=&quot;https://en.wikipedia.org/wiki/Soft_microprocessor&quot;&gt;CPU&lt;/a&gt; in an
environment where
&lt;a href=&quot;/blog/2017/06/12/minimizing-luts.html&quot;&gt;every LUT matters&lt;/a&gt;
can be a challenge.&lt;/p&gt;

&lt;p&gt;The first thing I did was to move some of the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt;’s instructions from
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt;
to &lt;a href=&quot;https://en.wikipedia.org/wiki/Random-access_memory&quot;&gt;block RAM&lt;/a&gt;.
Since I didn’t have enough block
&lt;a href=&quot;https://en.wikipedia.org/wiki/Random-access_memory&quot;&gt;RAM&lt;/a&gt;
to do this for the whole multitasking
“O/S”, I only put the critical components into the limited
&lt;a href=&quot;https://en.wikipedia.org/wiki/Random-access_memory&quot;&gt;RAM&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;That still wasn’t fast enough.&lt;/p&gt;

&lt;p&gt;Then, in my last round with the &lt;a href=&quot;https://github.com/ZipCPU/s6soc&quot;&gt;S6SoC&lt;/a&gt;, I
created a better prefetch unit I called
&lt;a href=&quot;https://github.com/ZipCPU/s6soc/blob/master/rtl/cpu/dblfetch.v&quot;&gt;dblfetch&lt;/a&gt;.
&lt;a href=&quot;https://github.com/ZipCPU/s6soc/blob/master/rtl/cpu/dblfetch.v&quot;&gt;This prefetch&lt;/a&gt;
was low logic enough to fit within the space
I had, but also faster than the
&lt;a href=&quot;/zipcpu/2017/11/18/wb-prefetch.html&quot;&gt;simpler prefetch&lt;/a&gt;
I had started with.
&lt;a href=&quot;https://github.com/ZipCPU/s6soc/blob/master/rtl/cpu/dblfetch.v&quot;&gt;This prefetch&lt;/a&gt;
unit, or rather a slightly modified one, is also the subject of this article.&lt;/p&gt;

&lt;h2 id=&quot;measuring-memory-performance&quot;&gt;Measuring Memory Performance&lt;/h2&gt;

&lt;p&gt;Let’s start, though, by looking at how to measure memory performance.  In
a synchronous design, where everything takes place on a clock tick, then
memory performance can be quantified by how many clocks it takes per
transaction.&lt;/p&gt;

&lt;p&gt;When using the &lt;a href=&quot;http://opencores.org/cdn/downloads/wbspec_b3.pdf&quot;&gt;B3 version&lt;/a&gt;
of the
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;wishbone bus&lt;/a&gt;, there’s
a fixed number of clocks for every transaction–we’ll call this the
transaction’s latency, &lt;code class=&quot;highlighter-rouge&quot;&gt;L&lt;/code&gt;.  Hence, if you want to access &lt;code class=&quot;highlighter-rouge&quot;&gt;N&lt;/code&gt; memory locations,
this will cost you &lt;code class=&quot;highlighter-rouge&quot;&gt;LN&lt;/code&gt; clocks.&lt;/p&gt;

&lt;table style=&quot;float: left&quot;&gt;&lt;caption&gt;Fig 3: A pair of Wishbone bus requests&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/dblfetch-ram.svg&quot; alt=&quot;The trace for a pair of Wishbone bus requests, as drawn from the ZipCPU prefetch named dblfetch&quot; width=&quot;420&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;On the other hand, if you use the
&lt;a href=&quot;/blog/2017/08/14/strategies-for-pipelining.html&quot;&gt;pipelined&lt;/a&gt;
mode of the
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;wishbone bus&lt;/a&gt;
as illustrated in Fig 3 on the left
(&lt;a href=&quot;/doc/wbspec_b4.pdf&quot;&gt;version B4&lt;/a&gt; only), you can then have
multiple transactions in flight at the same
time.  In this case, the time it takes to accomplish a transaction becomes
&lt;code class=&quot;highlighter-rouge&quot;&gt;(N-1)S+L&lt;/code&gt;.  In other words, there’s an initial latency &lt;code class=&quot;highlighter-rouge&quot;&gt;L&lt;/code&gt;, followed by a
number of clocks &lt;code class=&quot;highlighter-rouge&quot;&gt;S&lt;/code&gt; for each additional transaction within the burst.&lt;/p&gt;

&lt;p&gt;If you look at this from a purely peripheral perspective, you can see six
separate peripheral implementations  (approximately) outlined in the table
below.&lt;/p&gt;

&lt;table class=&quot;bordered-table&quot;&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Peripheral&lt;/th&gt;
      &lt;th&gt;Clocks to access&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;a href=&quot;https://opencores.org/project,qspiflash&quot;&gt;Initial QSPI Flash&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;16N + 16&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;a href=&quot;https://github.com/ZipCPU/xulalx25soc/blob/master/rtl/wbspiflash.v&quot;&gt;Flash&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;32N + 40&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Dual SPI Flash, XIP&lt;/td&gt;
      &lt;td&gt;16N + 16&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;QSPI Flash, XIP&lt;/td&gt;
      &lt;td&gt;8N +  8&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;a href=&quot;https://github.com/ZipCPU/s6soc/blob/master/rtl/memdev.v&quot;&gt;Block RAM&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;N +  1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;a href=&quot;https://github.com/ZipCPU/xulalx25soc/blob/master/rtl/wbsdram.v&quot;&gt;SDRAM&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;2N +  6&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;DDR3 SDRAM&lt;/td&gt;
      &lt;td&gt;N + 22&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;My &lt;a href=&quot;https://github.com/ZipCPU/s6soc/blob/master/rtl/wbqspiflash.v&quot;&gt;initial controller for the QSPI
flash&lt;/a&gt;
on the &lt;a href=&quot;https://github.com/ZipCPU/s6soc&quot;&gt;S6SoC&lt;/a&gt; required 43-clocks
for a single transaction.  There was a delay or two within the logic of the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt; and the &lt;a href=&quot;https://github.com/ZipCPU/s6soc/blob/master/rtl/busmaster.v&quot;&gt;bus
structure&lt;/a&gt;–we’ll
say it was a two clock delay, with one clock on either side of the actual
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt;
access (shown in blue below).  Further, the
non-&lt;a href=&quot;/zipcpu/2017/08/23/cpu-pipeline.html&quot;&gt;pipelined&lt;/a&gt;
version of the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt; at the time
required 4 more clocks per instruction.  The result was that it cost the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt; 49 clocks per instruction (CPI).
With a 12ns clock, this meant that the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
could at best run 1.6 Million Instructions per Second (MIPS).&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 4. Unoptimized Prefetch from Flash and CPU Performance&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/pfpipe-slow-flash.svg&quot; alt=&quot;&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;At a rate of 1.6 MIPS I had 200 instructions to deal with each audio sample.
These 200 instructions had handle everything else as well: interrupts, button
presses, the software based real-time clock, etc.  No wonder it couldn’t keep
up with the 8kHz audio stream!&lt;/p&gt;

&lt;p&gt;Of course, the real answer to making a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Soft_microprocessor&quot;&gt;CPU&lt;/a&gt; faster would be to
&lt;a href=&quot;/zipcpu/2017/08/23/cpu-pipeline.html&quot;&gt;pipeline the CPU&lt;/a&gt;
and run with a &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/pfcache.v&quot;&gt;proper prefetch and instruction
cache&lt;/a&gt;–even
better, to run the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt; from an
on-board block
&lt;a href=&quot;https://en.wikipedia.org/wiki/Random-access_memory&quot;&gt;RAM&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/s6soc/blob/master/rtl/memdev.v&quot;&gt;device&lt;/a&gt;.
This approach would have the performance shown in Fig 5.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 5. Prefetch with Instruction Cache&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/pfpipe-wcache.svg&quot; alt=&quot;&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;If I only had the logic to do that, the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; would’ve ran close to one clock
per instruction, once the cache was loaded, and would then achieve nearly
82 MIPS (minus cache stalls) on the
&lt;a href=&quot;https://www.xilinx.com/support/documentation/data_sheets/ds160.pdf&quot;&gt;Spartan 6&lt;/a&gt;.
There just wasn’t enough logic in the
&lt;a href=&quot;https://www.xilinx.com/support/documentation/data_sheets/ds160.pdf&quot;&gt;LX4&lt;/a&gt;
to do this.&lt;/p&gt;

&lt;p&gt;What else could be done?&lt;/p&gt;

&lt;p&gt;If I placed the most common instructions into block
&lt;a href=&quot;https://en.wikipedia.org/wiki/Random-access_memory&quot;&gt;RAM&lt;/a&gt;,
as I discussed above, then the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt; could run at about
12 MIPS.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 6. Fetching instructions from Block RAM&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/pfpipe-bkram.svg&quot; alt=&quot;&quot; width=&quot;315&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Thanks to the author of the
&lt;a href=&quot;https://github.com/hgeisse/eco32&quot;&gt;ECO32 CPU&lt;/a&gt;
I was rather surprised to learn at the time that
&lt;a href=&quot;https://www.gnu.org/software/binutils&quot;&gt;binutils&lt;/a&gt; 
supported this sort of dual addressing–with some addresses in
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt;,
and other addresses in a section of
&lt;a href=&quot;https://en.wikipedia.org/wiki/Random-access_memory&quot;&gt;RAM&lt;/a&gt;
that had been copied/loaded from the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt;–all controlled from a
&lt;a href=&quot;https://github.com/ZipCPU/s6soc/blob/master/sw/dev/cmod.ld&quot;&gt;linker script&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;This would’ve been perfect except the
&lt;a href=&quot;https://www.xilinx.com/support/documentation/data_sheets/ds160.pdf&quot;&gt;S6 LX4&lt;/a&gt;
just doesn’t have that much block
&lt;a href=&quot;https://en.wikipedia.org/wiki/Random-access_memory&quot;&gt;RAM&lt;/a&gt;.
I &lt;em&gt;needed&lt;/em&gt; to run instructions from the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;In my case, there was more that could be done by trimming the &lt;a href=&quot;https://github.com/ZipCPU/s6soc/blob/master/rtl/wbqspiflash.v&quot;&gt;flash
controller&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;To understand the options and possibilities, let’s back up for a moment and
discuss what the
&lt;a href=&quot;https://www.cypress.com/file/177966/download&quot;&gt;QSPI flash protocol&lt;/a&gt;
requires.
After you give the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt;
a “Fast Read Quad Output” command (0xEBh), the
&lt;a href=&quot;https://www.cypress.com/file/177966/download&quot;&gt;QSPI flash&lt;/a&gt;
I was working with would enter into an eXecute In Place (XIP) mode.
From this XIP mode,
any new instruction requires lowering the &lt;code class=&quot;highlighter-rouge&quot;&gt;CS_n&lt;/code&gt; line, issuing an address,
then another byte indicating whether or not you wish to remain in XIP mode,
and then several dummy clocks.  Only after all this setup could you then read
one 32-bit value from the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt;
every eight clocks.&lt;/p&gt;

&lt;p&gt;Fig 7. below shows the clocks required in the setup.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 7. QSPI Flash Quad Read Protocol in XIP Mode&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/qspi-xip.png&quot; alt=&quot;&quot; width=&quot;600&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;This is the fastest way to read from the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt;,
although it requires an
SCK or two for setup and tear-down.
Using this mode, it will take 80 QSPI bits, or equivalently
20 QSPI SCK’s, to read any arbitrary 32-bits of data from the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;One problem with my
&lt;a href=&quot;https://opencores.org/project,qspiflash&quot;&gt;flash design&lt;/a&gt; at the time was
that it was creating a SPI
clock from logic.  On one clock cycle the SPI clock output would be a one,
then a zero, etc.  As a result, the fastest SPI clock, &lt;code class=&quot;highlighter-rouge&quot;&gt;SCK&lt;/code&gt;, I could create
was at half my system clock rate, or 41MHz.&lt;/p&gt;

&lt;p&gt;If I instead switched from a &lt;em&gt;logic generated&lt;/em&gt; clock to a clock generated by a
&lt;a href=&quot;https://www.xilinx.com&quot;&gt;Xilinx&lt;/a&gt;
&lt;a href=&quot;https://www.xilinx.com/support/documentation/sw_manuals/xilinx14_7/7series_hdl.pdf&quot;&gt;ODDR&lt;/a&gt;
primitive,
then the SPI clock &lt;code class=&quot;highlighter-rouge&quot;&gt;SCK&lt;/code&gt; would transition on each clock edge and run at the
same speed as the design’s system clock speed (82 MHz).
By doubling the speed of the SPI SCK, I could then also double the speed of the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt;
to roughly 22-clocks per fetch, or 28 clocks per instruction.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 8. Doubling the SCK speed via an ODDR&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/pfpipe-fast-flash.svg&quot; alt=&quot;&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;While a 2.9 MHz instruction rate is better than a 1.6 MHz rate, it’s still
quite dismal.&lt;/p&gt;

&lt;p&gt;If I cleaned up the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt; so that 2 of
the five stages were
&lt;a href=&quot;/zipcpu/2017/08/23/cpu-pipeline.html&quot;&gt;pipelined&lt;/a&gt;–the two
stages that didn’t suffer from
&lt;a href=&quot;/zipcpu/2017/08/23/cpu-pipeline.html&quot;&gt;pipeline&lt;/a&gt;
conflicts (prefetch and instruction decode), then I could get up to
3.0 MHz.  This would be a slight improvement.&lt;/p&gt;

&lt;p&gt;On the other hand, if I could fetch two instructions at a time, the second
instruction would benefit from the fact that the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt;
chip is already set
up to get a provide the next instruction word.  In this case, I could fetch
2 instructions in 36 clocks vice one instruction in 28 clocks.  When the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt; performance
was factored in, the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt; would now
(nominally) take 36 clocks per two instructions, or 18 clocks total (with
exceptions) per instruction.  This would mean that the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt;
could then speed up to a whopping
4.6 MIPS, based upon an (82 MHz/18 CPI).&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 9. Fetching two instructions from flash at a time&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/pfpipe-dblflash.svg&quot; alt=&quot;&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;This *was *going to be the topic of this article–how to read two instructions
at a time.  It was how I managed to speed up the
&lt;a href=&quot;https://github.com/ZipCPU/s6soc&quot;&gt;S6SoC&lt;/a&gt; at the time.  In a
moment, though, I’ll share a better, faster, and &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/dblfetch.v&quot;&gt;cheaper prefetch
module&lt;/a&gt; just
for this blog article.&lt;/p&gt;

&lt;p&gt;Before going there, though, I should finish the story of the
&lt;a href=&quot;https://github.com/ZipCPU/s6soc&quot;&gt;S6SoC&lt;/a&gt; since I made another
improvement as well: I compressed instructions.&lt;/p&gt;

&lt;p&gt;Using the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; compressed
instruction set, two 16-bit instructions can be
stored into a single 32-bit instruction word.  The performance isn’t
necessarily all that wonderful, but roughly two in ten instructions can
be packed together into a single word.
(A recent bug-fix suggests the true value might be four in ten instructions,
but I haven’t been able to measure this improvement properly yet–so we’ll
just use the two in ten number.)
I could probably do a bit better if
I taught the compiler or the assembler how to re-order instructions to maximize
this feature’s usage, but I’ll still take the 10% improvement.  Hence, the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; speed ultimately
became somewhere near (82/18/0.8) or 5.7 MHz.&lt;/p&gt;

&lt;p&gt;A funny thing happened, though, on the way to putting
&lt;a href=&quot;http://zipcpu.com/&quot;&gt;this blog&lt;/a&gt;
post together.  When I started using
&lt;a href=&quot;http://www.clifford.at/yosys&quot;&gt;yosys&lt;/a&gt;
to measure the logic usage of
&lt;a href=&quot;https://github.com/ZipCPU/s6soc/blob/master/rtl/cpu/dblfetch.v&quot;&gt;this prefetch&lt;/a&gt;,
I realized two things.  First, I was using more logic than I needed to, and
second I could adjust the algorithm so that the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt;
could run concurrently with this second fetch.  In this manner, the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/dblfetch.v&quot;&gt;prefetch&lt;/a&gt;
can run continuously.  As a result, the (new/modified) performance of this
algorithm is now shown below.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 10. Two-Instruction Prefetch&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/pfpipe-new-dblfetch.svg&quot; alt=&quot;&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;At (roughly) 8 clocks per instruction (between
&lt;a href=&quot;https://en.wikipedia.org/wiki/Branch_(computer_science)&quot;&gt;branches&lt;/a&gt;),
this new version should run at roughly
10 MIPS—a big improvement over the 2MIPS we started with.  When you
factor in the compressed instruction set, this yields an even better
12.8 MIPS when running from &lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt;
and an 82MHz clock.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 11. Two instructions sharing the same instruction word&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/pfpipe-cis.svg&quot; alt=&quot;&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Consider the difference this makes when trying to process an 8k audio stream.
Instead of struggling along at 200 &lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt;
instructions per audio sample, I now have closer to 1,600
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt; instructions per audio sample
(neglecting
&lt;a href=&quot;https://en.wikipedia.org/wiki/Branch_(computer_science)&quot;&gt;branches&lt;/a&gt;).
For just a little adjustment in logic, then, the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt; now runs &lt;em&gt;MUCH&lt;/em&gt; faster.&lt;/p&gt;

&lt;p&gt;Before leaving this topic, I would be remiss if I didn’t point out that the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; &lt;em&gt;can&lt;/em&gt; run a lot faster–it just
takes more logic to implement
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/pfcache.v&quot;&gt;the cache&lt;/a&gt;
necessary to do so.  Indeed, we may even be able to come back and discuss how
the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/pfcache.v&quot;&gt;prefetch plus instruction
cache&lt;/a&gt;
approach is put together in a later article–although we’ll have to see
if the &lt;a href=&quot;https://www.blueletterbible.org/kjv/jas/4/15&quot;&gt;Lord is willing&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;how-dblfetch-works&quot;&gt;How dblfetch Works&lt;/h2&gt;

&lt;p&gt;While I could spend some time discussing how to strip the performance of a QSPI
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt;
controller to its
&lt;a href=&quot;https://github.com/ZipCPU/s6soc/blob/master/rtl/qflashxpress.v&quot;&gt;bare minimums&lt;/a&gt;,
today’s topic is going to be how to keep an instruction fetch operation going
so as to achieve the performance shown in Fig 11 above.&lt;/p&gt;

&lt;table style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 12: The two interfaces to a prefetch&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/prefetch-interface.svg&quot; alt=&quot;A prefetch must support both an interface to a CPU and an interface to memory&quot; width=&quot;380&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;As you may recall from our earlier discussion of the
&lt;a href=&quot;/zipcpu/2017/11/18/wb-prefetch.html&quot;&gt;simpler prefetch&lt;/a&gt;,
the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; prefetch interacts with the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt;
using only a small handful of signals:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;The clock, &lt;code class=&quot;highlighter-rouge&quot;&gt;i_clk&lt;/code&gt;, and reset, &lt;code class=&quot;highlighter-rouge&quot;&gt;i_reset&lt;/code&gt;, wires should need no more
description.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;On any
&lt;a href=&quot;https://en.wikipedia.org/wiki/Branch_(computer_science)&quot;&gt;branch&lt;/a&gt;,
whether early (unconditional), or late (conditional or indirect), the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt; will raise an
&lt;code class=&quot;highlighter-rouge&quot;&gt;i_new_pc&lt;/code&gt; flag and set the new
&lt;a href=&quot;https://en.wikipedia.org/wiki/Program_counter&quot;&gt;program counter&lt;/a&gt; in &lt;code class=&quot;highlighter-rouge&quot;&gt;i_pc&lt;/code&gt;.
From then until the next
&lt;a href=&quot;https://en.wikipedia.org/wiki/Branch_(computer_science)&quot;&gt;branch&lt;/a&gt;, the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Program_counter&quot;&gt;program counter&lt;/a&gt;
will increment from one instruction to the next.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;There’s also an &lt;code class=&quot;highlighter-rouge&quot;&gt;i_clear_cache&lt;/code&gt; line, which is used to force the
prefetch
to mark any cached information as invalid.  This allows the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt;
to load instructions into a memory area, and then make sure the instructions
freshly loaded into memory are the ones the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt;
executes later.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;These are just the signaling wires coming from the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt;.  Most of the work within the
&lt;a href=&quot;/zipcpu/2017/11/18/wb-prefetch.html&quot;&gt;prefetch&lt;/a&gt;,
h, however, is done with the &lt;code class=&quot;highlighter-rouge&quot;&gt;o_valid&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;o_insn&lt;/code&gt; wires returned to the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt;.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;o_valid&lt;/code&gt; indicates that the instruction presented to the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
is a valid instruction, and by implication that the instruction fetch
has completed.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;o_insn&lt;/code&gt; is the instruction being presented to the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;.
It has meaning only if &lt;code class=&quot;highlighter-rouge&quot;&gt;o_valid&lt;/code&gt; is also true.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Basically, any time &lt;code class=&quot;highlighter-rouge&quot;&gt;o_valid&lt;/code&gt; is true, &lt;code class=&quot;highlighter-rouge&quot;&gt;o_insn&lt;/code&gt; must contain a valid
instruction.  Once set, these values must hold until the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
accepts them by raising the &lt;code class=&quot;highlighter-rouge&quot;&gt;i_stall_n&lt;/code&gt; line.  (Why this is a negative logic
signal, vs just a &lt;code class=&quot;highlighter-rouge&quot;&gt;*_ready&lt;/code&gt; line is a long story …)&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;i_stall_n&lt;/code&gt; is an active low line indicating that the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
is stalled when active (low).  For those familiar with the AXI ready
signals, this signal is basically a ready signal from the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;.
When this line is high, and &lt;code class=&quot;highlighter-rouge&quot;&gt;o_valid&lt;/code&gt; is high on the same clock, then the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
has just accepted an instruction from the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/dblfetch.v&quot;&gt;prefetch&lt;/a&gt;.
and it is time to move on to the next instruction.&lt;/p&gt;

    &lt;p&gt;This detail is key, so remember this: when &lt;code class=&quot;highlighter-rouge&quot;&gt;(o_valid)&amp;amp;&amp;amp;(i_stall_n)&lt;/code&gt;, the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
has just accepted an instruction and we can move forward.&lt;/p&gt;

    &lt;p&gt;Hence, any time &lt;code class=&quot;highlighter-rouge&quot;&gt;(o_valid)&amp;amp;&amp;amp;(!i_stall_n)&lt;/code&gt;, we’ll need to hold the
instruction valid and wait for the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
to read it.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;If this signaling system is new or confusing to you, then I’m going to
recommend that you go back and review the &lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;formal properties of the
wishbone bus&lt;/a&gt;,
and likewise the &lt;a href=&quot;/zipcpu/2017/11/18/wb-prefetch.html&quot;&gt;formal properties and initial
discussion&lt;/a&gt;
from when we examined the &lt;a href=&quot;/zipcpu/2017/11/18/wb-prefetch.html&quot;&gt;single instruction
prefetch&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;In this case, we’ll be building essentially the same &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/prefetch.v&quot;&gt;basic
prefetch&lt;/a&gt;
as &lt;a href=&quot;/zipcpu/2017/11/18/wb-prefetch.html&quot;&gt;before&lt;/a&gt;
save for a small number of changes.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;The first change is that we’ll allow up to two requests to be in flight
at a time.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The second change is that we’ll need to keep track of both responses, and
feed them to the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
one at a time.&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;The first response from the
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;
will go into the &lt;code class=&quot;highlighter-rouge&quot;&gt;o_insn&lt;/code&gt; register, and will set &lt;code class=&quot;highlighter-rouge&quot;&gt;o_valid&lt;/code&gt;.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;Subsequent responses will also go into the &lt;code class=&quot;highlighter-rouge&quot;&gt;o_insn&lt;/code&gt; register, if ever
&lt;code class=&quot;highlighter-rouge&quot;&gt;o_valid&lt;/code&gt; is false&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;If &lt;code class=&quot;highlighter-rouge&quot;&gt;o_valid&lt;/code&gt; is true, but &lt;code class=&quot;highlighter-rouge&quot;&gt;i_stall_n&lt;/code&gt; is low, indicating that the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
is stalled, we won’t be able to place the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_(computing)&quot;&gt;bus&lt;/a&gt;
return into the &lt;code class=&quot;highlighter-rouge&quot;&gt;o_insn&lt;/code&gt; wires to the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;.
Instead, we’ll create a one-instruction cache to place it into.&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;table align=&quot;center&quot; style=&quot;float: left&quot;&gt;&lt;caption&gt;Fig 13. Two bus requests issued&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/pfpipe-request.svg&quot; alt=&quot;The prefetch issues two requests to the bus&quot; width=&quot;400&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Let’s see if we can draw this out.  The process starts with a state machine
that will issue two requests.  Further requests will be issued if any
requests are outstanding when the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
accepts an instruction from the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/dblfetch.v&quot;&gt;prefetch&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The rule here, though, is that no request may be made of the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_(computing)&quot;&gt;bus&lt;/a&gt;
unless there’s a place to put the result.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 14. Responses go into an Instruction Queue&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/pfpipe-response.svg&quot; alt=&quot;The responses from these requests go into a two-instruction queue&quot; width=&quot;400&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;On the return end from the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_(computing)&quot;&gt;bus&lt;/a&gt;,
responses will go either into our &lt;code class=&quot;highlighter-rouge&quot;&gt;o_insn&lt;/code&gt;
register to be sent immediately to the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
or into the &lt;code class=&quot;highlighter-rouge&quot;&gt;cache_word&lt;/code&gt; if &lt;code class=&quot;highlighter-rouge&quot;&gt;o_insn&lt;/code&gt; already has a valid value within it.
Which location the return goes into
will be governed both by the &lt;code class=&quot;highlighter-rouge&quot;&gt;o_valid&lt;/code&gt; flag, indicating that &lt;code class=&quot;highlighter-rouge&quot;&gt;o_insn&lt;/code&gt;
has a valid instruction within it, by &lt;code class=&quot;highlighter-rouge&quot;&gt;cache_valid&lt;/code&gt;, indicating that
the &lt;code class=&quot;highlighter-rouge&quot;&gt;cache_word&lt;/code&gt; has a valid instruction within it, and &lt;code class=&quot;highlighter-rouge&quot;&gt;i_stall_n&lt;/code&gt;
indicating that everything is moving forward.&lt;/p&gt;

&lt;h2 id=&quot;the-cpus-contract-with-the-prefetch&quot;&gt;The CPU’s Contract with the Prefetch&lt;/h2&gt;

&lt;p&gt;Since I &lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;started working with formal
methods&lt;/a&gt;, I’ve
started thinking of modules
within a design as having a &lt;em&gt;contract&lt;/em&gt; with the rest of the design.  For
example, a memory module has a &lt;em&gt;contract&lt;/em&gt; to return the values found within
the memory at the requested address, and to allow you to change those
values and retrieve the changed values later.  In the case of a
&lt;a href=&quot;/zipcpu/2017/11/18/wb-prefetch.html&quot;&gt;prefetch&lt;/a&gt;,
the contract is fairly simple: the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/dblfetch.v&quot;&gt;prefetch
module&lt;/a&gt;
needs to return to the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
the memory it read from the address the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
requested.  It’s that simple.&lt;/p&gt;

&lt;p&gt;To make matters even easier,
&lt;a href=&quot;http://www.clifford.at/yosys&quot;&gt;yosys&lt;/a&gt;
offers two expressions that can help:
&lt;code class=&quot;highlighter-rouge&quot;&gt;$anyseq&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;$anyconst&lt;/code&gt;.  These describe “free variables.”  They are so
valuable, that I’d like to take a moment longer to discuss these terms.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;$anyseq&lt;/code&gt; defines an arbitrary value that can change on every clock cycle.
You might find it within a section of Verilog code that looks something like:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;wire	[N-1:0]	some_value;
assign	some_value = $anyseq;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;It’s equivalent to having an unconstrained input (i.e. a “free variable”) to
your module, but doesn’t require you to actually create such an input.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;$anyconst&lt;/code&gt; is similar, only the value of &lt;code class=&quot;highlighter-rouge&quot;&gt;$anyconst&lt;/code&gt; will never change within
a run.  Indeed, not only is it similar, but you’d write it out in the exact
same way.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;wire	[N-1:0]	some_constant;
assign	some_constant = $anyconst;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;With a just one simple assumption, &lt;code class=&quot;highlighter-rouge&quot;&gt;$anyseq&lt;/code&gt; can be turned into an &lt;code class=&quot;highlighter-rouge&quot;&gt;$anyconst&lt;/code&gt;,
as in:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;wire	[N-1:0]	some_constant;
assign	some_constant = $anyseq;
always @($global_clock)
	assume(some_valid == $past(some_value));&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;However, this is only for illustration purposes.  &lt;code class=&quot;highlighter-rouge&quot;&gt;$anyconst&lt;/code&gt; will work
for us today rather than &lt;code class=&quot;highlighter-rouge&quot;&gt;$anyseq&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Specifically, we can use &lt;code class=&quot;highlighter-rouge&quot;&gt;$anyconst&lt;/code&gt; to describe the formal contract between the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt; and
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/dblfetch.v&quot;&gt;this prefetch&lt;/a&gt;
module.  Using &lt;code class=&quot;highlighter-rouge&quot;&gt;$anyconst&lt;/code&gt;, we can describe both an arbitrary address in memory,
as well as an arbitrary value (the instruction) that will be at this address.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;wire	[AW-1:0]	f_const_addr;
wire	[DW-1:0]	f_const_insn;

assign	f_const_addr = $anyconst;
assign	f_const_insn = $anyconst;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Then the basic contract is that any time the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/dblfetch.v&quot;&gt;prefetch&lt;/a&gt;
tells the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
that it has a valid instruction, i.e. &lt;code class=&quot;highlighter-rouge&quot;&gt;o_valid&lt;/code&gt; is true, &lt;em&gt;and&lt;/em&gt; that this
instruction comes from the address listed above, &lt;code class=&quot;highlighter-rouge&quot;&gt;f_const_addr&lt;/code&gt;, &lt;em&gt;then&lt;/em&gt; the
instruction must also match the value listed above as well, &lt;code class=&quot;highlighter-rouge&quot;&gt;f_const_insn&lt;/code&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(*)
if ((o_valid)&amp;amp;&amp;amp;(o_pc == f_const_addr))
	assert(o_insn == f_const_insn);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Well, this is close but it isn’t quite right yet.  This doesn’t handle the
case where an attempt to read from this instruction address results in a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_(computing)&quot;&gt;bus&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_error&quot;&gt;error&lt;/a&gt;.
To handle that case, we’ll need an additional flag to determine
if our arbitrary example address references a legal location on the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_(computing)&quot;&gt;bus&lt;/a&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;wire	f_const_illegal;

assign	f_const_illegal = $anyconst;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Using this new flag, the contract then becomes,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(*)
if ((o_valid)&amp;amp;&amp;amp;(o_pc == f_const_addr))
begin
	assert(o_illegal == f_const_illegal);
	if (!o_illegal)
		assert(o_insn == f_const_insn);
end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Well, even that’s not quite right.  I like using the &lt;code class=&quot;highlighter-rouge&quot;&gt;o_illegal&lt;/code&gt; bit as a
sticky bit.  Once it becomes true, it should stay true until the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt; and
issues an &lt;code class=&quot;highlighter-rouge&quot;&gt;i_new_pc&lt;/code&gt; flag and new &lt;code class=&quot;highlighter-rouge&quot;&gt;i_pc&lt;/code&gt;.  Alternatively, we can clear it on the
rarer &lt;code class=&quot;highlighter-rouge&quot;&gt;i_reset&lt;/code&gt; or &lt;code class=&quot;highlighter-rouge&quot;&gt;i_clear_cache&lt;/code&gt; flags.  This means that our contract is
instead going to be,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(*)
if ((o_valid)&amp;amp;&amp;amp;(o_pc == f_const_addr))
begin
	if (f_const_illegal)
		assert(o_illegal)
	if (!o_illegal)
		assert(o_insn == f_const_insn);
end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;We’ll also have to add some assumptions to our algorithm in order to meet
this contract.  Specifically, we’ll need to assume that any time we read
from the &lt;code class=&quot;highlighter-rouge&quot;&gt;f_const_addr&lt;/code&gt; address
that the result returned will be an acknowledgment (not an error) carrying
&lt;code class=&quot;highlighter-rouge&quot;&gt;f_const_insn&lt;/code&gt; in &lt;code class=&quot;highlighter-rouge&quot;&gt;i_wb_data&lt;/code&gt; if &lt;code class=&quot;highlighter-rouge&quot;&gt;f_const_illegal&lt;/code&gt; is false, or a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_(computing)&quot;&gt;bus&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_error&quot;&gt;error&lt;/a&gt;
if &lt;code class=&quot;highlighter-rouge&quot;&gt;f_const_illegal&lt;/code&gt; is true, but that part will be prefetch specific
so we’ll hold off on that until we get to our actual properties.&lt;/p&gt;

&lt;h2 id=&quot;working-through-the-algorithm&quot;&gt;Working through the Algorithm&lt;/h2&gt;

&lt;p&gt;I normally work through an algorithm via pseudocode before presenting it
here.  Today, we’ll just walk through this by steps–since I’m not sure I
have a simple pseudocode to describe it.&lt;/p&gt;

&lt;p&gt;So, here’s how this algorithm will function:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;On any reset or request to clear the cache, wait for a new PC to be given&lt;/li&gt;
&lt;/ul&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 13. On Reset&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/dblfetch-reset.svg&quot; alt=&quot;&quot; width=&quot;320&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;We’ll assume &lt;code class=&quot;highlighter-rouge&quot;&gt;i_new_pc&lt;/code&gt; takes place on the clock after &lt;code class=&quot;highlighter-rouge&quot;&gt;i_reset&lt;/code&gt;.  That means
that on the clock following &lt;code class=&quot;highlighter-rouge&quot;&gt;i_new_pc&lt;/code&gt;, we want to initiate a bus request
with the address of the program counter just given within &lt;code class=&quot;highlighter-rouge&quot;&gt;i_pc&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;This logic is shown in Fig 13. on the right.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Likewise, on a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_(computing)&quot;&gt;bus&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_error&quot;&gt;error&lt;/a&gt;,
set the error flag and wait for a new
&lt;a href=&quot;https://en.wikipedia.org/wiki/Program_counter&quot;&gt;PC&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;You can see this in Fig 14. on the right.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 14. On a Bus Error&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/dblfetch-buserr.svg&quot; alt=&quot;&quot; width=&quot;280&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;In that figure, you can see that following a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_(computing)&quot;&gt;bus&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_error&quot;&gt;error&lt;/a&gt;:
the bus cycle ends and so &lt;code class=&quot;highlighter-rouge&quot;&gt;o_wb_cyc&lt;/code&gt; drops.  &lt;code class=&quot;highlighter-rouge&quot;&gt;o_valid&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;o_illegal&lt;/code&gt; are
then both set together.  &lt;code class=&quot;highlighter-rouge&quot;&gt;o_valid&lt;/code&gt; indicates that the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_(computing)&quot;&gt;bus&lt;/a&gt;
transaction is complete, &lt;code class=&quot;highlighter-rouge&quot;&gt;o_illegal&lt;/code&gt; that it ended with an invalid instruction.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;On any &lt;code class=&quot;highlighter-rouge&quot;&gt;i_new_pc&lt;/code&gt; request, start a new
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_(computing)&quot;&gt;bus&lt;/a&gt;
transaction.&lt;/li&gt;
&lt;/ul&gt;

&lt;table align=&quot;right&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 15. On a New PC mid-cycle&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/dblfetch-midcycle.svg&quot; alt=&quot;&quot; width=&quot;400&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;As shown in Fig 15 above, if a
  &lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_(computing)&quot;&gt;bus&lt;/a&gt;
  transaction is currently underway when the
  &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
  signals an &lt;code class=&quot;highlighter-rouge&quot;&gt;i_new_pc&lt;/code&gt;, then the
  &lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_(computing)&quot;&gt;bus&lt;/a&gt;
  request is aborted (&lt;code class=&quot;highlighter-rouge&quot;&gt;o_wb_cyc&lt;/code&gt; is dropped) and a new one is started on the
  clock following.  We’ll use the internal register
  &lt;code class=&quot;highlighter-rouge&quot;&gt;invalid_bus_cycle&lt;/code&gt;, as shown in Fig 15, to mark that a 
  &lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_(computing)&quot;&gt;bus&lt;/a&gt; transaction was aborted,
  and that a new
  &lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_(computing)&quot;&gt;bus&lt;/a&gt; transaction
  needs to be initiated on the next clock.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;When any
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_(computing)&quot;&gt;bus&lt;/a&gt;
transaction begins, immediately issue two requests.&lt;/p&gt;

    &lt;p&gt;This was what we showed above in Fig 3 when we started.  Everything starts
with two requests.  Then, if a response comes back before the second request
is issued an additional value will be requested from the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_(computing)&quot;&gt;bus&lt;/a&gt;.&lt;/p&gt;

    &lt;p&gt;Remember the rule: no request may be issued unless there is a place to put
the result–lest the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_(computing)&quot;&gt;bus&lt;/a&gt;
respond faster then we are expecting.  Hence, the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_(computing)&quot;&gt;bus&lt;/a&gt;
transaction starts out with our two instruction “cache” entries empty so we
can issue two requests.  If one value comes back and leaves our “cache” for
the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;,
then we can immediately issue a third request.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The initial address requested will be given by the value in &lt;code class=&quot;highlighter-rouge&quot;&gt;i_pc&lt;/code&gt;
whenever &lt;code class=&quot;highlighter-rouge&quot;&gt;i_new_pc&lt;/code&gt; is true.
Ever after, the request address should increment by one on each clock.&lt;/p&gt;

    &lt;p&gt;This goes for the output
&lt;a href=&quot;https://en.wikipedia.org/wiki/Program_counter&quot;&gt;PC&lt;/a&gt;
value, &lt;code class=&quot;highlighter-rouge&quot;&gt;o_pc&lt;/code&gt; as well.  It will also be set to &lt;code class=&quot;highlighter-rouge&quot;&gt;i_pc&lt;/code&gt;
any time &lt;code class=&quot;highlighter-rouge&quot;&gt;i_new_pc&lt;/code&gt; is true.  However, unlike the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_(computing)&quot;&gt;bus&lt;/a&gt;
addresses which increments on every new
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_(computing)&quot;&gt;bus&lt;/a&gt;
request that is made, this value will instead increment any time the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
accepts an instruction.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Responses to the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_(computing)&quot;&gt;bus&lt;/a&gt;
will be placed into the &lt;code class=&quot;highlighter-rouge&quot;&gt;o_insn&lt;/code&gt; register any time &lt;code class=&quot;highlighter-rouge&quot;&gt;o_valid&lt;/code&gt; is
false, or any time there’s nothing in the cache and &lt;code class=&quot;highlighter-rouge&quot;&gt;i_stall_n&lt;/code&gt; is true.&lt;/p&gt;

    &lt;p&gt;We’ll get deeper into these details in the next section.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;If an instruction is being held in &lt;code class=&quot;highlighter-rouge&quot;&gt;o_valid&lt;/code&gt;, the second return will be
placed into a &lt;code class=&quot;highlighter-rouge&quot;&gt;cache_word&lt;/code&gt;, and then
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_(computing)&quot;&gt;bus&lt;/a&gt;
transaction will stop and the
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;wishbone&lt;/a&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;CYC&lt;/code&gt; line will be lowered.&lt;/p&gt;

    &lt;p&gt;We’ve gone for too long without an image.  Here’s what I’m talking about
in Fig 16.&lt;/p&gt;

    &lt;p&gt;It is important that the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_(computing)&quot;&gt;bus&lt;/a&gt;
request end if the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
is stalled for too long (&lt;code class=&quot;highlighter-rouge&quot;&gt;i_stall_n&lt;/code&gt; is low), as the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
might be stalled at the internal &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/ex/wbdblpriarb.v&quot;&gt;memory vs prefetch
arbiter&lt;/a&gt;
while trying to access the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_(computing)&quot;&gt;bus&lt;/a&gt;.
By making sure that we never receive more than two instructions, and then
let the &lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_(computing)&quot;&gt;bus&lt;/a&gt;
return to idle, we keep the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
from entering into a deadlock state.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;All of this needs to be subject to the rule that the two element return
&lt;a href=&quot;https://en.wikipedia.org/wiki/FIFO_(computing_and_electronics)&quot;&gt;FIFO&lt;/a&gt;
cannot be allowed to ever overflow it’s two instruction depth.  We’ll use
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal properties&lt;/a&gt;
below to convince ourselves that such will never happen.&lt;/p&gt;

&lt;h2 id=&quot;the-code&quot;&gt;The Code&lt;/h2&gt;

&lt;p&gt;Now that you know the basic idea behind
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/dblfetch.v&quot;&gt;the code&lt;/a&gt;,
it’s time to examine it in detail.  Once we finish, we’ll get into the
formal properties necessary to verify that this works in the next section.&lt;/p&gt;

&lt;p&gt;We’ll start from the beginning: when shall a bus transaction begin and
end?  As you may recall from the &lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal
properties&lt;/a&gt; of the
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;wishbone bus&lt;/a&gt;,
&lt;code class=&quot;highlighter-rouge&quot;&gt;o_wb_cyc&lt;/code&gt; will capture anytime we in the middle of one (or more) transactions,
and &lt;code class=&quot;highlighter-rouge&quot;&gt;o_wb_stb&lt;/code&gt; will be true anytime we are making a request of the
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;.
You may also remember that &lt;code class=&quot;highlighter-rouge&quot;&gt;o_wb_stb&lt;/code&gt; can only ever be true during a
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;
cycle.  Hence, &lt;code class=&quot;highlighter-rouge&quot;&gt;o_wb_stb&lt;/code&gt; must imply that &lt;code class=&quot;highlighter-rouge&quot;&gt;o_wb_cyc&lt;/code&gt; is also true.&lt;/p&gt;

&lt;p&gt;The &lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;
initially starts out idle.  We’ll also return to an idle on any reset
or &lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_(computing)&quot;&gt;bus&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_error&quot;&gt;error&lt;/a&gt;.
This logic is similar to any &lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;Wishbone
bus&lt;/a&gt;
master.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	initial	o_wb_cyc = 1&#39;b0;
	initial	o_wb_stb = 1&#39;b0;
	always @(posedge i_clk)
		if ((i_reset)||((o_wb_cyc)&amp;amp;&amp;amp;(i_wb_err)))
		begin
			o_wb_cyc &amp;lt;= 1&#39;b0;
			o_wb_stb &amp;lt;= 1&#39;b0;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Next, during any
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;
transaction, we’ll keep issuing transactions
until a &lt;code class=&quot;highlighter-rouge&quot;&gt;last_stb&lt;/code&gt; flag becomes true.  We’re going to use this &lt;code class=&quot;highlighter-rouge&quot;&gt;last_stb&lt;/code&gt;
idea to keep this set of
&lt;a href=&quot;/blog/2017/06/12/minimizing-luts.html&quot;&gt;logic simpler&lt;/a&gt;,
since &lt;code class=&quot;highlighter-rouge&quot;&gt;last_stb&lt;/code&gt; can be calculated on the prior clock.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;		end else if (o_wb_cyc)
		begin
			if ((!o_wb_stb)||(!i_wb_stall))
				o_wb_stb &amp;lt;= (!last_stb);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Releasing the
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;
is a little more complicated.&lt;/p&gt;

&lt;p&gt;The first step is to count the number of items in flight at any given time.
We’ll place this count into &lt;code class=&quot;highlighter-rouge&quot;&gt;inflight&lt;/code&gt; and come back to the logic to do
this later.&lt;/p&gt;

&lt;p&gt;We’ll end the transaction on any last acknowledgment.
We’re also going to release the
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;
anytime we’ve made our last request,
and nothing is in flight.  Finally, anytime a new
&lt;a href=&quot;https://en.wikipedia.org/wiki/Program_counter&quot;&gt;program counter&lt;/a&gt;
is given to us, or any time we are asked to clear our cache, we’ll
also end this
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;
transaction.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;			if (((i_wb_ack)&amp;amp;&amp;amp;(!o_wb_stb)&amp;amp;&amp;amp;(inflight&amp;lt;=1))
				||((!o_wb_stb)&amp;amp;&amp;amp;(inflight == 0))
				// Or any new transaction request
				||((i_new_pc)||(i_clear_cache)))
			begin
				o_wb_cyc &amp;lt;= 1&#39;b0;
				o_wb_stb &amp;lt;= 1&#39;b0;
			end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;That’s how we’ll end a transaction, but when will one start?&lt;/p&gt;

&lt;p&gt;We’re going to need to start a transaction on a couple conditions.
First, if we are idle and the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
asks for a new
&lt;a href=&quot;https://en.wikipedia.org/wiki/Program_counter&quot;&gt;PC&lt;/a&gt;,
we’ll need to start
a transaction.  Likewise, if the last transaction was aborted because the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
requested a new
&lt;a href=&quot;https://en.wikipedia.org/wiki/Program_counter&quot;&gt;PC&lt;/a&gt;,
then &lt;code class=&quot;highlighter-rouge&quot;&gt;invalid_bus_cycle&lt;/code&gt; will be true and we need to start again.  Finally,
any time we’ve run our two instruction cache/FIFO
dry, then we’ll start a new
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;
cycle as well.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;		end else if ((i_new_pc)||(invalid_bus_cycle)
			||((o_valid)&amp;amp;&amp;amp;(i_stall_n)&amp;amp;&amp;amp;(!o_illegal)))
		begin
			// ...
			o_wb_cyc &amp;lt;= 1&#39;b1;
			o_wb_stb &amp;lt;= 1&#39;b1;
		end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Normally, when I build a multi-transaction
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;
master, I know ahead of time how many transaction requests to issue.  Examples
would be the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/pfcache.v&quot;&gt;prefetch plus
cache&lt;/a&gt;
bus master, which always fetches a complete cache line, and the &lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/rtl/wbuexec.v&quot;&gt;full-featured
debugging bus
master&lt;/a&gt;
I like to use.  In the case of the &lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/rtl/wbuexec.v&quot;&gt;debugging
bus&lt;/a&gt;,
the read
&lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/rtl/wbuexec.v&quot;&gt;bus&lt;/a&gt;,
request tells it how many transactions to request, although the write
&lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/rtl/wbuexec.v&quot;&gt;bus&lt;/a&gt;,
request just requests an additional transaction.&lt;/p&gt;

&lt;p&gt;This &lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;
master is different.&lt;/p&gt;

&lt;p&gt;In this case, we want to issue two requests, and then possibly more depending
on whether or not we have enough available spaces.  Doing this requires
counting the number of transactions in flight.  We’ll do this with the
register, &lt;code class=&quot;highlighter-rouge&quot;&gt;inflight&lt;/code&gt;.  Upon any successful
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;
request, we’ll increment this value and on
any acknowledgment we’ll decrement it to keep a count of what’s
in flight.  (We don’t need to adjust our count on
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_error&quot;&gt;error&lt;/a&gt;,
since the
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;
transaction will always be aborted on any
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_error&quot;&gt;error&lt;/a&gt;
anyway.)&lt;/p&gt;

&lt;p&gt;There are some key features of this logic.  Because an acknowledgment can come
back when the &lt;code class=&quot;highlighter-rouge&quot;&gt;o_wb_cyc&lt;/code&gt; line is low, such as immediately following an
aborted transaction, we’ll just set everything to zero if &lt;code class=&quot;highlighter-rouge&quot;&gt;o_wb_cyc&lt;/code&gt; is low.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	initial	inflight = 2&#39;b00;
	always @(posedge i_clk)
	if (!o_wb_cyc)
		inflight &amp;lt;= 2&#39;b00;
	else begin&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;After that, we increase the number of items in flight on any accepted
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;
request, and decrease the number on any acknowledgment.  If neither are true,
or if both are true, the count won’t change.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;		case({ ((o_wb_stb)&amp;amp;&amp;amp;(!i_wb_stall)), i_wb_ack })
		2&#39;b01:	inflight &amp;lt;= inflight - 1&#39;b1;
		2&#39;b10:	inflight &amp;lt;= inflight + 1&#39;b1;
		// If neither ack nor request, then no change.  Likewise
		// if we have both an ack and a request, there&#39;s no change
		// in the number of requests in flight.
		default: begin end
		endcase
	end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Just as an example of how
&lt;a href=&quot;/blog/2018/03/14/is-formal-hard.html&quot;&gt;easy formal can be&lt;/a&gt;,
I knew when I wrote these lines that &lt;code class=&quot;highlighter-rouge&quot;&gt;inflight&lt;/code&gt; could never be greater than
two.  Hence, I originally placed an assert statement here to that effect.
It has since been moved to our formal section and so we’ll discuss it
below when we get to it.  I only bring it up here to discuss an example
situation where it is useful to immediately write a formal property.&lt;/p&gt;

&lt;p&gt;Let’s move on to the &lt;code class=&quot;highlighter-rouge&quot;&gt;last_stb&lt;/code&gt; piece of logic.  You may recall from above
that we used a piece of logic to determine when the current request was the last
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;
request that needed to be issued.  Normally when I build a
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;
master, this is a registered value–set on the clock before the last strobe.
A good example of this would be the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/wbdmac.v&quot;&gt;DMA controller&lt;/a&gt; for the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;,
which separates the difficult logic of when to end a
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;
cycle from the already
&lt;a href=&quot;/blog/2017/06/12/minimizing-luts.html&quot;&gt;difficult logic&lt;/a&gt;,
describing the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/wbdmac.v&quot;&gt;DMA&lt;/a&gt;
state machine.&lt;/p&gt;

&lt;p&gt;This isn’t that either.&lt;/p&gt;

&lt;p&gt;This &lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;
master is different because I want to keep issuing requests anytime the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
accepts an instruction.  In this case, the second strobe will be the
last strobe–i.e. if the number in flight is more than one.  Likewise if
there’s a valid instruction waiting for the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
then this also needs to be the last
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;
request.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(*)
		last_stb = (inflight != 2&#39;b00)||((o_valid)&amp;amp;&amp;amp;(!i_stall_n));&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The next register, &lt;code class=&quot;highlighter-rouge&quot;&gt;invalid_bus_cycle&lt;/code&gt;, is one I’ve tried to get rid of many
times.  In many ways it feels redundant.  Timing, however, requires it.
Specifically, my problem is this: if &lt;code class=&quot;highlighter-rouge&quot;&gt;i_new_pc&lt;/code&gt; comes during the middle of a
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;
cycle, &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/dblfetch.v&quot;&gt;the
prefetch&lt;/a&gt;
immediately aborts that
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;
cycle.  The
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;
cycle needs to then be re-initiated on the next clock cycle, as shown in Fig 15
above.  That’s the purpose of &lt;code class=&quot;highlighter-rouge&quot;&gt;invalid_bus_cycle&lt;/code&gt;: to tell the design to start
up a new
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;
cycle after the last one was artificially ended by an &lt;code class=&quot;highlighter-rouge&quot;&gt;i_new_pc&lt;/code&gt; request.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	initial	invalid_bus_cycle = 1&#39;b0;
	always @(posedge i_clk)
		if (i_reset)
			invalid_bus_cycle &amp;lt;= 1&#39;b0;
		else if ((o_wb_cyc)&amp;amp;&amp;amp;(i_new_pc))
			invalid_bus_cycle &amp;lt;= 1&#39;b1;
		else if (!o_wb_cyc)
			invalid_bus_cycle &amp;lt;= 1&#39;b0;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;We discussed above how the
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;
request address, &lt;code class=&quot;highlighter-rouge&quot;&gt;o_wb_addr&lt;/code&gt;, will be set by
the address given on any &lt;code class=&quot;highlighter-rouge&quot;&gt;i_new_pc&lt;/code&gt; request.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	initial	o_wb_addr = {(AW){1&#39;b1}};
	always @(posedge i_clk)
		if (i_new_pc)
			o_wb_addr &amp;lt;= i_pc[AW+1:2];&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Other than on any &lt;code class=&quot;highlighter-rouge&quot;&gt;i_new_pc&lt;/code&gt; request, we’ll increment the
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;
address on every successful transaction request but leave it alone otherwise.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;		else if ((o_wb_stb)&amp;amp;&amp;amp;(!i_wb_stall))
			o_wb_addr &amp;lt;= o_wb_addr + 1&#39;b1;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;We can now look at the &lt;code class=&quot;highlighter-rouge&quot;&gt;o_valid&lt;/code&gt; signal.  As you may recall, this signal
needs to be true any time a valid instruction is being presented to the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;We’ll start on reset.  On any reset, any &lt;code class=&quot;highlighter-rouge&quot;&gt;i_new_pc&lt;/code&gt; request, or any request
to &lt;code class=&quot;highlighter-rouge&quot;&gt;i_clear_cache&lt;/code&gt;, we’ll clear this valid signal.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	initial	o_valid = 1&#39;b0;
	always @(posedge i_clk)
		if ((i_reset)||(i_new_pc)||(i_clear_cache))
			o_valid &amp;lt;= 1&#39;b0;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Further, on any valid return from the
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;,
whether an acknowledgment or an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_error&quot;&gt;error&lt;/a&gt;,
we’ll set the valid signal to true.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;		else if ((o_wb_cyc)&amp;amp;&amp;amp;((i_wb_ack)||(i_wb_err)))
			o_valid &amp;lt;= 1&#39;b1;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The final piece of logic references what to do if the
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;
isn’t providing an instruction, but the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
has just accepted the one we’ve presented to it within &lt;code class=&quot;highlighter-rouge&quot;&gt;o_insn&lt;/code&gt;.  In this case,
whether or not we are valid will be determined by whether or not the
second word in our FIFO or cache, &lt;code class=&quot;highlighter-rouge&quot;&gt;cache_word&lt;/code&gt;, has a valid value within it.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;		else if (i_stall_n)
			o_valid &amp;lt;= cache_valid;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;o_valid&lt;/code&gt; tells the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
when the instruction from the
&lt;a href=&quot;/zipcpu/2017/11/18/wb-prefetch.html&quot;&gt;prefetch&lt;/a&gt;
is a valid instruction.  The instruction itself is kept in the &lt;code class=&quot;highlighter-rouge&quot;&gt;o_insn&lt;/code&gt;
register, our next item to discuss.&lt;/p&gt;

&lt;p&gt;As you’ll recall from above, there are a couple cases to consider with &lt;code class=&quot;highlighter-rouge&quot;&gt;o_insn&lt;/code&gt;.
If &lt;code class=&quot;highlighter-rouge&quot;&gt;o_valid&lt;/code&gt; isn’t true, then &lt;code class=&quot;highlighter-rouge&quot;&gt;o_insn&lt;/code&gt; is a don’t care.  If &lt;code class=&quot;highlighter-rouge&quot;&gt;o_valid&lt;/code&gt;
is true, but &lt;code class=&quot;highlighter-rouge&quot;&gt;i_stall_n&lt;/code&gt; is false, then the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
is busy (stalled), and the
instruction must stay ready and unchanged until the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
is ready to accept it.&lt;/p&gt;

&lt;p&gt;Hence, any time &lt;code class=&quot;highlighter-rouge&quot;&gt;o_valid&lt;/code&gt; is false, or any time the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
is ready to accept an instruction, then we can update the instruction.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	initial	o_insn = {(32){1&#39;b1}};
	always @(posedge i_clk)
	if ((!o_valid)||(i_stall_n))
	begin&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;If the cache word is valid, then we want to present the cache word as the
next instruction word.  Otherwise, the next instruction word can only come from
the &lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;.
While it may not be on the
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;
on this cycle, it will eventually be on the
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;,
i.e. in &lt;code class=&quot;highlighter-rouge&quot;&gt;i_wb_data&lt;/code&gt;, and then &lt;code class=&quot;highlighter-rouge&quot;&gt;o_valid&lt;/code&gt; will be set on the
next clock–keeping us from changing again until the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
accepts the instruction.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;		if (cache_valid)
			o_insn &amp;lt;= cache_word;
		else
			o_insn &amp;lt;= i_wb_data;
	end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;As a side note, you may notice that the logic for this 32-bit word has
been kept very simple.  &lt;a href=&quot;/blog/2017/06/12/minimizing-luts.html&quot;&gt;This is
important&lt;/a&gt;.
Complex logic on a wide bus can suddenly and greatly &lt;a href=&quot;/blog/2017/06/12/minimizing-luts.html&quot;&gt;increase your logic
usage&lt;/a&gt;.
Instead, we are reserving the complex logic for the one or two wire
registers, such as &lt;code class=&quot;highlighter-rouge&quot;&gt;o_wb_cyc&lt;/code&gt; or &lt;code class=&quot;highlighter-rouge&quot;&gt;o_wb_stb&lt;/code&gt; above, while keeping the logic
for the larger registers, like &lt;code class=&quot;highlighter-rouge&quot;&gt;o_insn&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;o_wb_addr&lt;/code&gt;, or even &lt;code class=&quot;highlighter-rouge&quot;&gt;o_pc&lt;/code&gt; simple.&lt;/p&gt;

&lt;p&gt;Speaking of &lt;code class=&quot;highlighter-rouge&quot;&gt;o_pc&lt;/code&gt;, that’s our next register to examine.  The
&lt;code class=&quot;highlighter-rouge&quot;&gt;o_pc&lt;/code&gt; register is very similar to the &lt;code class=&quot;highlighter-rouge&quot;&gt;o_wb_addr&lt;/code&gt; register that we dealt with
above.  It needs to be set on any &lt;code class=&quot;highlighter-rouge&quot;&gt;i_new_pc&lt;/code&gt; event, and otherwise incremented
any time the output instruction is valid, &lt;code class=&quot;highlighter-rouge&quot;&gt;o_valid&lt;/code&gt;, and the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
accepts that instruction, &lt;code class=&quot;highlighter-rouge&quot;&gt;i_stall_n&lt;/code&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	initial	o_pc = 0;
	always @(posedge i_clk)
		if (i_new_pc)
			o_pc &amp;lt;= i_pc;
		else if ((o_valid)&amp;amp;&amp;amp;(i_stall_n))
			o_pc[AW+1:2] &amp;lt;= o_pc[AW+1:2] + 1&#39;b1;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;You’ll notice that we kept this logic
&lt;a href=&quot;/blog/2017/06/12/minimizing-luts.html&quot;&gt;simple&lt;/a&gt; as well,
since the number of LUTs required by
this logic will be required &lt;em&gt;for every bit&lt;/em&gt; of &lt;code class=&quot;highlighter-rouge&quot;&gt;o_pc&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Just to illustrate this point, the &lt;code class=&quot;highlighter-rouge&quot;&gt;o_pc&lt;/code&gt; logic alone uses 61 4-LUTs of the
total 246 LUTs used by the design as a whole on an iCE40.  That’s a whole 24%
of the total logic for this design–and it’s a very minimal piece of logic at
that.&lt;/p&gt;

&lt;p&gt;The final word used to interface with the rest of the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
is the &lt;code class=&quot;highlighter-rouge&quot;&gt;o_illegal&lt;/code&gt; register.  This is the flag used to tell the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
that the attempt to read from this address resulted in a
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_error&quot;&gt;error&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;We’ll clear this flag on any reset, or &lt;code class=&quot;highlighter-rouge&quot;&gt;i_new_pc&lt;/code&gt; request.  Likewise, we’ll
clear it on any request to clear the cache, &lt;code class=&quot;highlighter-rouge&quot;&gt;i_clear_cache&lt;/code&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	initial	o_illegal = 1&#39;b0;
	always @(posedge i_clk)
		if ((i_reset)||(i_new_pc)||(i_clear_cache))
			o_illegal &amp;lt;= 1&#39;b0;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;As with &lt;code class=&quot;highlighter-rouge&quot;&gt;o_insn&lt;/code&gt;, nothing is allowed to change if we have a valid
instruction that the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
hasn’t yet accepted the last instruction, or equivalently if
&lt;code class=&quot;highlighter-rouge&quot;&gt;(o_valid)&amp;amp;&amp;amp;(!i_stall_n)&lt;/code&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;		else if ((!o_valid)||(i_stall_n))
		begin&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;That brings us to how &lt;code class=&quot;highlighter-rouge&quot;&gt;o_illegal&lt;/code&gt; needs to be set.  If the &lt;code class=&quot;highlighter-rouge&quot;&gt;cache_word&lt;/code&gt; is
valid, then it moves into the &lt;code class=&quot;highlighter-rouge&quot;&gt;o_insn&lt;/code&gt; position.  At that same time,
if the &lt;code class=&quot;highlighter-rouge&quot;&gt;cache_illegal&lt;/code&gt; flag associated with that &lt;code class=&quot;highlighter-rouge&quot;&gt;cache_word&lt;/code&gt; is true,
that will indicate that a
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_error&quot;&gt;error&lt;/a&gt;
was returned while attempting to request the second word.  This illegal
flag will then also need to move into the &lt;code class=&quot;highlighter-rouge&quot;&gt;o_insn&lt;/code&gt; position and we’ll set
&lt;code class=&quot;highlighter-rouge&quot;&gt;o_illegal&lt;/code&gt; in that case.&lt;/p&gt;

&lt;p&gt;Otherwise, if the cached value isn’t valid, then there’s nothing in our
cache and we’ll need to set the &lt;code class=&quot;highlighter-rouge&quot;&gt;o_illegal&lt;/code&gt; flag immediately on a
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_error&quot;&gt;error&lt;/a&gt;,
since that’s the value directly going into the first output position,
&lt;code class=&quot;highlighter-rouge&quot;&gt;o_insn&lt;/code&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;			if (cache_valid)
				o_illegal &amp;lt;= (o_illegal)||(cache_illegal);
			else if ((o_wb_cyc)&amp;amp;&amp;amp;(i_wb_err))
				o_illegal &amp;lt;= 1&#39;b1;
		end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Ok, so we’ve now dealt with the output values to the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;:
&lt;code class=&quot;highlighter-rouge&quot;&gt;o_valid&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;o_insn&lt;/code&gt;, and &lt;code class=&quot;highlighter-rouge&quot;&gt;o_illegal&lt;/code&gt;.  These are the values associated
with the current item being sent to the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
from our two instruction FIFO.&lt;/p&gt;

&lt;p&gt;Let’s now turn our attention to that second response from the bus, the &lt;em&gt;other&lt;/em&gt;
element in our two instruction FIFO.  We’ll store this value in the word
&lt;code class=&quot;highlighter-rouge&quot;&gt;cache_word&lt;/code&gt;, and mark it as valid using &lt;code class=&quot;highlighter-rouge&quot;&gt;cache_valid&lt;/code&gt;.
Should this word be the result of a
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_error&quot;&gt;error&lt;/a&gt;,
we’ll then set the value &lt;code class=&quot;highlighter-rouge&quot;&gt;cache_illegal&lt;/code&gt; to reflect this.&lt;/p&gt;

&lt;p&gt;We’ll start here, though, with &lt;code class=&quot;highlighter-rouge&quot;&gt;cache_valid&lt;/code&gt;.  On any reset, any new
&lt;a href=&quot;https://en.wikipedia.org/wiki/Program_counter&quot;&gt;PC&lt;/a&gt;,
or any time we clear the cache, &lt;code class=&quot;highlighter-rouge&quot;&gt;cache_valid&lt;/code&gt; needs to be cleared.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	initial	cache_valid = 1&#39;b0;
	always @(posedge i_clk)
		if ((i_reset)||(i_new_pc)||(i_clear_cache))
			cache_valid &amp;lt;= 1&#39;b0;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Otherwise, we need to set it any time &lt;code class=&quot;highlighter-rouge&quot;&gt;o_valid&lt;/code&gt; is true, the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt; is
stalled &lt;code class=&quot;highlighter-rouge&quot;&gt;(!i_stall_n)&lt;/code&gt;, and a return comes in from the
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;.
In a similar fashion, we’ll need to clear this flag anytime the &lt;code class=&quot;highlighter-rouge&quot;&gt;cache_word&lt;/code&gt;
gets moved into the &lt;code class=&quot;highlighter-rouge&quot;&gt;o_insn&lt;/code&gt; position and presented to the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;.
 This will be when &lt;code class=&quot;highlighter-rouge&quot;&gt;i_stall_n&lt;/code&gt; is true, but not response is coming from the
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The only catch is when/if &lt;code class=&quot;highlighter-rouge&quot;&gt;cache_valid&lt;/code&gt; is already true and a new response
comes back from the
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;. (This should never
happen.) In this case, &lt;code class=&quot;highlighter-rouge&quot;&gt;cache_valid&lt;/code&gt; needs to be set as well.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;		else begin
			if ((o_valid)&amp;amp;&amp;amp;(o_wb_cyc)&amp;amp;&amp;amp;((i_wb_ack)||(i_wb_err)))
				cache_valid &amp;lt;= (!i_stall_n)||(cache_valid);
			else if (i_stall_n)
				cache_valid &amp;lt;= 1&#39;b0;
		end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This brings us to the cache word.  As you’ll recall from above, the
&lt;code class=&quot;highlighter-rouge&quot;&gt;cache_word&lt;/code&gt; register is the second word in the output FIFO after &lt;code class=&quot;highlighter-rouge&quot;&gt;o_insn&lt;/code&gt;.
This value is completely irrelevant, though, unless &lt;code class=&quot;highlighter-rouge&quot;&gt;cache_valid&lt;/code&gt; (above)
is also true.  Hence, we can set it to whatever returns from the
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt; in
&lt;code class=&quot;highlighter-rouge&quot;&gt;i_wb_data&lt;/code&gt; whenever it returns.  We’ll use other logic, above in &lt;code class=&quot;highlighter-rouge&quot;&gt;cache_valid&lt;/code&gt;,
to determine whether or not this value is relevant to us.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(posedge i_clk)
		if ((o_wb_cyc)&amp;amp;&amp;amp;(i_wb_ack))
			cache_word &amp;lt;= i_wb_data;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Obviously this will fail if an acknowledgment is returned while &lt;code class=&quot;highlighter-rouge&quot;&gt;cache_valid&lt;/code&gt;
is true.  We’ll need to make certain this never happens, and we’ll use the
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal methods&lt;/a&gt;
below to convince ourselves that this will never happen.&lt;/p&gt;

&lt;p&gt;The last value is the &lt;code class=&quot;highlighter-rouge&quot;&gt;cache_illegal&lt;/code&gt; value.  This flag is used to
indicate that the second response from the
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt; was a
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_error&quot;&gt;error&lt;/a&gt;,
&lt;code class=&quot;highlighter-rouge&quot;&gt;i_wb_err&lt;/code&gt;.  As before, this value is cleared on any &lt;code class=&quot;highlighter-rouge&quot;&gt;i_reset&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;i_new_pc&lt;/code&gt;,
or &lt;code class=&quot;highlighter-rouge&quot;&gt;i_clear_cache&lt;/code&gt;.  After that, it’s set on any &lt;code class=&quot;highlighter-rouge&quot;&gt;i_wb_err&lt;/code&gt; return where
the first
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;
return position in the FIFO is stuck waiting on the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;,
&lt;code class=&quot;highlighter-rouge&quot;&gt;(o_valid)&amp;amp;&amp;amp;(!i_stall_n)&lt;/code&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	initial	cache_illegal = 1&#39;b0;
	always @(posedge i_clk)
	if ((i_reset)||(i_clear_cache)||(i_new_pc))
		cache_illegal &amp;lt;= 1&#39;b0;
	else if ((o_wb_cyc)&amp;amp;&amp;amp;(i_wb_err)&amp;amp;&amp;amp;(o_valid)&amp;amp;&amp;amp;(!i_stall_n))
		cache_illegal &amp;lt;= 1&#39;b1;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Remember that the &lt;code class=&quot;highlighter-rouge&quot;&gt;i_wb_err&lt;/code&gt; flag needs to be cross-checked with the
&lt;code class=&quot;highlighter-rouge&quot;&gt;o_wb_cyc&lt;/code&gt; flag, since suddenly dropping &lt;code class=&quot;highlighter-rouge&quot;&gt;o_wb_cyc&lt;/code&gt; might still allow
&lt;code class=&quot;highlighter-rouge&quot;&gt;i_wb_err&lt;/code&gt; to return on the next cycle when &lt;code class=&quot;highlighter-rouge&quot;&gt;o_wb_cyc&lt;/code&gt; is low.&lt;/p&gt;

&lt;p&gt;That’s it!  At this point, we have a completed
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/dblfetch.v&quot;&gt;prefetch module&lt;/a&gt;
that will continue fetching instructions from memory until it’s two
instruction word FIFO is full and the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
remains stalled.&lt;/p&gt;

&lt;p&gt;But … does it work?  That’s the point of the
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal properties&lt;/a&gt;
presented in the next section.&lt;/p&gt;

&lt;h2 id=&quot;the-formal-properties&quot;&gt;The Formal Properties&lt;/h2&gt;

&lt;p&gt;A &lt;a href=&quot;/zipcpu/2017/11/18/wb-prefetch.html&quot;&gt;prefetch&lt;/a&gt;
has two basic interfaces it needs to maintain, as shown
above in Fig 12.  The first is formally characterized by the set of &lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;wishbone
properties&lt;/a&gt;.
The second interface is to the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;.
Therefore, we’ll spend some time putting together the assumptions and assertions
necessary for interacting with the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;.
Finally, we’ll present the logic necessary to formally verify that &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/dblfetch.v&quot;&gt;this
prefetch&lt;/a&gt;
formally maintains its &lt;em&gt;contract&lt;/em&gt; with the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt; as
we discussed above.&lt;/p&gt;

&lt;p&gt;We’ll start with the
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal properties&lt;/a&gt;
necessary for interacting with the
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;wishbone bus&lt;/a&gt;.
Aside from assuming that &lt;code class=&quot;highlighter-rouge&quot;&gt;i_reset&lt;/code&gt; is true on startup,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	initial	`ASSUME(i_reset);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;most of this is already done for us by the &lt;code class=&quot;highlighter-rouge&quot;&gt;fwb_master&lt;/code&gt; module.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	localparam	F_LGDEPTH=2;
	wire	[(F_LGDEPTH-1):0]	f_nreqs, f_nacks, f_outstanding;

	//
	// Add a bunch of wishbone-based asserts
	fwb_master #(.AW(AW), .DW(DW), .F_LGDEPTH(F_LGDEPTH),
				.F_MAX_STALL(2),
				.F_MAX_REQUESTS(0), .F_OPT_SOURCE(1),
				.F_OPT_CLK2FFLOGIC(F_OPT_CLK2FFLOGIC),
				.F_OPT_RMW_BUS_OPTION(1),
				.F_OPT_DISCONTINUOUS(0))
		f_wbm(i_clk, i_reset,
			o_wb_cyc, o_wb_stb, o_wb_we, o_wb_addr, o_wb_data, 4&#39;h0,
			i_wb_ack, i_wb_stall, i_wb_data, i_wb_err,
			f_nreqs, f_nacks, f_outstanding);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;You may remember how we built that
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;property list together&lt;/a&gt;
earlier, right?&lt;/p&gt;

&lt;p&gt;In this case, the important parts of this are the parameters being used
to set this up.  First, we’re only expecting a two items to ever be in
flight at a time, so we can set &lt;code class=&quot;highlighter-rouge&quot;&gt;F_LGDEPTH&lt;/code&gt; to two.  Second, just to keep
things moving, we’ll assume that the
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;
will never stall more than 2
clocks at a time, &lt;code class=&quot;highlighter-rouge&quot;&gt;F_MAX_STALL(2)&lt;/code&gt;.  We won’t set a maximum number of
requests, since our particular goal is to allow us to continually make
requests until our result buffer is full.  &lt;code class=&quot;highlighter-rouge&quot;&gt;F_OPT_SOURCE&lt;/code&gt; is set to
true, just to check that &lt;code class=&quot;highlighter-rouge&quot;&gt;o_wb_stb&lt;/code&gt; gets set to true any time
&lt;code class=&quot;highlighter-rouge&quot;&gt;o_wb_cyc&lt;/code&gt; rises.&lt;/p&gt;

&lt;p&gt;It’s really just about that simple, but there is one exception: we’ll
&lt;a href=&quot;/blog/2018/03/14/is-formal-hard.html&quot;&gt;need to tie our logic&lt;/a&gt;
to the &lt;code class=&quot;highlighter-rouge&quot;&gt;f_nreqs&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;f_nacks&lt;/code&gt;, and &lt;code class=&quot;highlighter-rouge&quot;&gt;f_outstanding&lt;/code&gt; signals, or we won’t pass the
&lt;a href=&quot;/blog/2018/03/10/induction-exercise.html&quot;&gt;formal induction&lt;/a&gt;
step.&lt;/p&gt;

&lt;p&gt;That logic is coming up in a bit.&lt;/p&gt;

&lt;p&gt;The next section discusses the assumptions associated with interacting with
the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;.
To make sure these statements hold properly, we’ll use a variety
of &lt;code class=&quot;highlighter-rouge&quot;&gt;f_past_*&lt;/code&gt; variables.  We’ll use these in place of the &lt;code class=&quot;highlighter-rouge&quot;&gt;$past()&lt;/code&gt; operator,
since
&lt;a href=&quot;/blog/2017/06/21/looking-at-verilator.html&quot;&gt;Verilator&lt;/a&gt;
doesn’t support it (yet).  This includes &lt;code class=&quot;highlighter-rouge&quot;&gt;f_past_reset&lt;/code&gt;,
&lt;code class=&quot;highlighter-rouge&quot;&gt;f_past_clear_cache&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;f_past_o_valid&lt;/code&gt;, and &lt;code class=&quot;highlighter-rouge&quot;&gt;f_past_stall_n&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The first assumption is that following any reset, the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
will provide a new
&lt;a href=&quot;https://en.wikipedia.org/wiki/Program_counter&quot;&gt;instruction address&lt;/a&gt;
on the next clock cycle.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(posedge i_clk)
		if ((f_past_valid)&amp;amp;&amp;amp;(f_past_reset))
			assume(i_new_pc);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;We’ll assume the same of an &lt;code class=&quot;highlighter-rouge&quot;&gt;i_clear_cache&lt;/code&gt; request, that the next clock
cycle will provide us with an new
&lt;a href=&quot;https://en.wikipedia.org/wiki/Program_counter&quot;&gt;PC&lt;/a&gt;
value.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(posedge i_clk)
		if ((f_past_valid)&amp;amp;&amp;amp;(f_past_clear_cache))
			assume(i_new_pc);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Further, we know from the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;’s code
that the &lt;code class=&quot;highlighter-rouge&quot;&gt;i_clear_cache&lt;/code&gt; request will never be held high for two clocks
in a row.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(posedge i_clk)
	if (f_past_clear_cache)
		assume(!i_clear_cache);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This brings us to a rather unusual assertion.&lt;/p&gt;

&lt;p&gt;Some time ago, I got frustrated trying to translate between word addresses
on the
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;
and the byte addresses the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
uses.  In a fit of frustration, I converted all of the versions of the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Program_counter&quot;&gt;program counter&lt;/a&gt;
maintained within the
design to byte addressing.  That means that the bottom two bits of 
&lt;code class=&quot;highlighter-rouge&quot;&gt;i_pc&lt;/code&gt; need to be zero.  It also means the bottom two bits of &lt;code class=&quot;highlighter-rouge&quot;&gt;o_pc&lt;/code&gt; will
need to be zero, but we’ll get to that one later.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(*)
		assume(i_pc[1:0] == 2&#39;b00);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The result of using byte addressing is that I can now correlate these
&lt;a href=&quot;https://en.wikipedia.org/wiki/Program_counter&quot;&gt;program counter&lt;/a&gt; values
with the byte addresses in a dump of any
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
executable.&lt;/p&gt;

&lt;p&gt;Now let’s talk about the &lt;code class=&quot;highlighter-rouge&quot;&gt;i_stall_n&lt;/code&gt; line.  Following any reset, the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
will be reset and there will be no reason to stall.  Hence, following any
reset &lt;code class=&quot;highlighter-rouge&quot;&gt;i_stall_n&lt;/code&gt; will be true indicating that the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
is &lt;em&gt;ready&lt;/em&gt; to accept an instruction.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	initial	assume(i_stall_n);
	always @(posedge i_clk)
		if ((f_past_valid)&amp;amp;&amp;amp;(f_past_reset))
			assume(i_stall_n);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;In a similar manner, the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
will never become busy and stall unless it has already accepted an instruction.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(posedge i_clk)
		if ((f_past_valid)&amp;amp;&amp;amp;(!f_past_o_valid)&amp;amp;&amp;amp;(f_past_stall_n))
			assume(i_stall_n);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Our last criteria regarding our interaction with the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
is the assumption that the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
will always accept an instruction within four clocks.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	localparam	F_CPU_DELAY = 4;
	reg	[4:0]	f_cpu_delay;

	// Now, let&#39;s look at the delay the CPU takes to accept an instruction.
	always @(posedge i_clk)
		// If no instruction is ready, then keep our counter at zero
		if ((!o_valid)||(i_stall_n))
			f_cpu_delay &amp;lt;= 0;
		else
			// Otherwise, count the clocks the CPU takes to respond
			f_cpu_delay &amp;lt;= f_cpu_delay + 1&#39;b1;

	always @(posedge i_clk)
		assume(f_cpu_delay &amp;lt; F_CPU_DELAY);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This isn’t necessarily true.  A divide instruction might cause the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
to stall for 30+ clocks.  However, it’s good enough to speed our way through
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal verification&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;We can now turn to some assertions about our outputs to the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;.
This isn’t (yet) the contract we discussed above, but we’ll get to that
in the next section.&lt;/p&gt;

&lt;p&gt;We’ll start with the assertion about the output
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;wishbone bus&lt;/a&gt;
address.
Anytime a new request is accepted by the
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;,
the &lt;code class=&quot;highlighter-rouge&quot;&gt;o_wb_pc&lt;/code&gt; should increment.  The only exception is following an
&lt;code class=&quot;highlighter-rouge&quot;&gt;i_new_pc&lt;/code&gt; signal–when it should be set by the new &lt;code class=&quot;highlighter-rouge&quot;&gt;i_pc&lt;/code&gt; value.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(posedge i_clk)
	if ((f_past_valid)&amp;amp;&amp;amp;($past(o_wb_stb))&amp;amp;&amp;amp;(!$past(i_wb_stall))
			&amp;amp;&amp;amp;(!$past(i_new_pc)))
		assert(o_wb_addr &amp;lt;= $past(o_wb_addr)+1&#39;b1);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;When it comes to the output values, the rule is that anytime the output
is valid and the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
is stalled, i.e. any time &lt;code class=&quot;highlighter-rouge&quot;&gt;(o_valid)&amp;amp;&amp;amp;(!i_stall_n)&lt;/code&gt;,
then the output values need to stay constant.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(posedge i_clk)
	if ((f_past_valid)&amp;amp;&amp;amp;(!$past(i_reset))
			&amp;amp;&amp;amp;(!$past(i_new_pc))&amp;amp;&amp;amp;(!$past(i_clear_cache))
			&amp;amp;&amp;amp;($past(o_valid))&amp;amp;&amp;amp;(!$past(i_stall_n)))
	begin
		assert($stable(o_pc));
		assert($stable(o_insn));
		assert($stable(o_valid));
		assert($stable(o_illegal));
	end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The same is true for that second cached word as well.  If that cache position
is valid, yet the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
is stalled, then it should never change.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(posedge i_clk)
	if ((f_past_valid)&amp;amp;&amp;amp;(!$past(i_reset))
			&amp;amp;&amp;amp;(!$past(i_new_pc))&amp;amp;&amp;amp;(!$past(i_clear_cache))
			&amp;amp;&amp;amp;($past(o_valid))&amp;amp;&amp;amp;(!$past(i_stall_n))
			&amp;amp;&amp;amp;($past(cache_valid)))
	begin
		assert($stable(cache_valid));
		assert($stable(cache_word));
		assert($stable(cache_illegal));
	end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;In a fashion similar to &lt;code class=&quot;highlighter-rouge&quot;&gt;o_wb_addr&lt;/code&gt; above, &lt;code class=&quot;highlighter-rouge&quot;&gt;o_pc&lt;/code&gt; should only ever increment,
and it should only do that if an instruction has been accepted–with the
exception of any time &lt;code class=&quot;highlighter-rouge&quot;&gt;i_new_pc&lt;/code&gt; is asserted.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(posedge i_clk)
	if ((f_past_valid)&amp;amp;&amp;amp;(!$past(i_new_pc))
			&amp;amp;&amp;amp;($past(o_valid))&amp;amp;&amp;amp;($past(i_stall_n)))
		assert(o_pc[AW+1:2] == $past(o_pc[AW+1:2])+1&#39;b1);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;As with &lt;code class=&quot;highlighter-rouge&quot;&gt;i_pc[1:0]&lt;/code&gt; and the frustration I described above, the bottom two
bits of the &lt;code class=&quot;highlighter-rouge&quot;&gt;o_pc&lt;/code&gt; address are unused.  Let’s assert here that they remain zero.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(*)
		assert(o_pc[1:0] == 2&#39;b00);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Upon any
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_error&quot;&gt;error&lt;/a&gt;
return, one of either &lt;code class=&quot;highlighter-rouge&quot;&gt;o_illegal&lt;/code&gt; or &lt;code class=&quot;highlighter-rouge&quot;&gt;cache_illegal&lt;/code&gt; should be
set.  Further, if &lt;code class=&quot;highlighter-rouge&quot;&gt;o_illegal&lt;/code&gt; is set, so too should be &lt;code class=&quot;highlighter-rouge&quot;&gt;o_valid&lt;/code&gt; to indicate
this is a valid return, and the same for &lt;code class=&quot;highlighter-rouge&quot;&gt;cache_valid&lt;/code&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(posedge i_clk)
	if ((f_past_valid)&amp;amp;&amp;amp;(!$past(i_reset))
			&amp;amp;&amp;amp;(!$past(i_new_pc))
			&amp;amp;&amp;amp;(!$past(i_clear_cache))
			&amp;amp;&amp;amp;($past(o_wb_cyc))&amp;amp;&amp;amp;($past(i_wb_err)))
		assert( ((o_valid)&amp;amp;&amp;amp;(o_illegal))
			||((cache_valid)&amp;amp;&amp;amp;(cache_illegal)) );&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Any time &lt;code class=&quot;highlighter-rouge&quot;&gt;o_illegal&lt;/code&gt; gets set, &lt;code class=&quot;highlighter-rouge&quot;&gt;o_valid&lt;/code&gt; should also be set at the same time.
&lt;code class=&quot;highlighter-rouge&quot;&gt;o_illegal&lt;/code&gt; will then stay true until cleared by a &lt;code class=&quot;highlighter-rouge&quot;&gt;i_reset&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;i_new_pc&lt;/code&gt;, etc,
so this is the most important part of the check.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(posedge i_clk)
	if ((f_past_valid)&amp;amp;&amp;amp;(!$past(o_illegal))&amp;amp;&amp;amp;(o_illegal))
		assert(o_valid);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;We’ll need to check for the same thing in the cache as well.  Hence, any
time the cached value was not illegal before, and the cache remains invalid
now, then the cache cannot have become illegal during this clock as well.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(posedge i_clk)
	if ((f_past_valid)&amp;amp;&amp;amp;(!$past(cache_illegal))&amp;amp;&amp;amp;(!cache_valid))
		assert(!cache_illegal);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Following any &lt;code class=&quot;highlighter-rouge&quot;&gt;i_new_pc&lt;/code&gt; request, &lt;code class=&quot;highlighter-rouge&quot;&gt;o_valid&lt;/code&gt; &lt;em&gt;must&lt;/em&gt; be low.  This assertion
comes from searching for a bug in the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/idecode.v&quot;&gt;instruction
decoder&lt;/a&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(posedge i_clk)
	if ((f_past_valid)&amp;amp;&amp;amp;($past(i_new_pc)))
		assert(!o_valid);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Finally, any time we transition from &lt;code class=&quot;highlighter-rouge&quot;&gt;o_valid&lt;/code&gt; to &lt;code class=&quot;highlighter-rouge&quot;&gt;!o_valid&lt;/code&gt;, we should also
be starting a
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;
cycle–lest we somehow get stuck.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(posedge i_clk)
	if ((f_past_valid)&amp;amp;&amp;amp;(!$past(i_reset))&amp;amp;&amp;amp;(!$past(i_clear_cache))
			&amp;amp;&amp;amp;($past(o_valid))&amp;amp;&amp;amp;(!o_valid)&amp;amp;&amp;amp;(!o_illegal))
		assert((o_wb_cyc)||(invalid_bus_cycle));&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Okay, that was a lot of properties!  Are you still with me?&lt;/p&gt;

&lt;p&gt;At this point, we are finally ready for the contract with the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;!
Remember how we discussed this above?  Let’s now take a look at how it’s done.&lt;/p&gt;

&lt;p&gt;We’ll start with three arbitrary values, an address, &lt;code class=&quot;highlighter-rouge&quot;&gt;f_const_addr&lt;/code&gt;, an
instruction, &lt;code class=&quot;highlighter-rouge&quot;&gt;f_const_insn&lt;/code&gt;, and whether or not that address will return a
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_error&quot;&gt;error&lt;/a&gt;,
&lt;code class=&quot;highlighter-rouge&quot;&gt;f_const_illegal&lt;/code&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	wire	[AW-1:0]	f_const_addr;
	wire	[DW-1:0]	f_const_insn;
	wire			f_const_illegal;

	// ...
	assign	f_const_addr    = $anyconst;
	assign	f_const_insn    = $anyconst;
	assign	f_const_illegal = $anyconst;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The next section is a bit verbose.  It probably doesn’t need to be.
But, just to tell the story …&lt;/p&gt;

&lt;p&gt;Over the course of time, while working with these values, I got somewhat
frustrated with the waveform viewing tool I was using.  One frustration was
my formal properties often contained something like &lt;code class=&quot;highlighter-rouge&quot;&gt;if ((A)&amp;amp;&amp;amp;(B)&amp;amp;&amp;amp;...)&lt;/code&gt; and
I could never tell when
something failed which of &lt;code class=&quot;highlighter-rouge&quot;&gt;A&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;B&lt;/code&gt;, or (other) wasn’t true.  To keep this
from happening, I assigned wires (below) to the various comparisons checks
I needed to do.  This way, I can examine these wires on any trace
failure and see why things failed.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	wire	f_this_addr, f_this_pc, f_this_req, f_this_data,
		f_this_insn;

	assign	f_this_addr = (o_wb_addr ==   f_const_addr);
	assign	f_this_pc   = (o_pc      == { f_const_addr, 2&#39;b00 });
	assign	f_this_req  = (i_pc      == { f_const_addr, 2&#39;b00 });
	assign	f_this_data = (i_wb_data ==   f_const_insn);
	assign	f_this_insn = (o_insn    ==   f_const_insn);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;That said, I’m undecided as to whether or not this frustration should lead me
to split out wires like this in the future.&lt;/p&gt;

&lt;p&gt;Ok, that’s the setup, here’s the contract: on any clock where the result
is valid, and where it’s our &lt;code class=&quot;highlighter-rouge&quot;&gt;f_const_addr&lt;/code&gt; address being returned, then
we need to be returning either this instruction, &lt;code class=&quot;highlighter-rouge&quot;&gt;f_const_insn&lt;/code&gt;, or
&lt;code class=&quot;highlighter-rouge&quot;&gt;o_illegal&lt;/code&gt; if this instruction returned a
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_error&quot;&gt;error&lt;/a&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(*)
	if ((o_valid)&amp;amp;&amp;amp;(f_this_pc))
	begin
		if (f_const_illegal)
			assert(o_illegal);
		if (!o_illegal)
			assert(f_this_insn);
	end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Of course, this will only work if the
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;
itself returns either this instruction or an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_error&quot;&gt;error&lt;/a&gt;
upon request.  Since this is an input of the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/dblfetch.v&quot;&gt;prefetch&lt;/a&gt;,
it needs to be assumed.&lt;/p&gt;

&lt;p&gt;The trick in making this assumption is that we need to know which return
of the many
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;
requests that we’ve made is the return value for this contract instruction.
Given that we increment &lt;code class=&quot;highlighter-rouge&quot;&gt;o_wb_addr&lt;/code&gt; any time we send a
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;
request in flight, and given that
&lt;code class=&quot;highlighter-rouge&quot;&gt;f_outstanding&lt;/code&gt; counts the number of items in flight, we can then know if this
return is our address by subtracting from &lt;code class=&quot;highlighter-rouge&quot;&gt;o_wb_addr&lt;/code&gt; the number of items
in flight.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	assign	f_this_return = (o_wb_addr - f_outstanding == f_const_addr);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Using this predicate, we can now say that if the next
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;
return will be for this request (i.e. &lt;code class=&quot;highlighter-rouge&quot;&gt;f_this_return&lt;/code&gt; is set), then if
we receive an acknowledgment from the
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;
the data should be &lt;code class=&quot;highlighter-rouge&quot;&gt;f_const_insn&lt;/code&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(*)
	if ((o_wb_cyc)&amp;amp;&amp;amp;(f_this_return))
	begin
		if (i_wb_ack)
			assume(i_wb_data == f_const_insn);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;To handle whether we get a
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_error&quot;&gt;error&lt;/a&gt;
or an acknowledgment, we’ll do it this way:  If &lt;code class=&quot;highlighter-rouge&quot;&gt;f_const_illegal&lt;/code&gt; is true, we
should &lt;em&gt;only&lt;/em&gt; get an &lt;code class=&quot;highlighter-rouge&quot;&gt;i_wb_err&lt;/code&gt; from the
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;
and never any valid acknowledgment.  Likewise the reverse: if &lt;code class=&quot;highlighter-rouge&quot;&gt;f_const_illegal&lt;/code&gt;
is false, we should &lt;em&gt;only&lt;/em&gt; ever get an acknowledgment from the
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;.
This particular way of describing this behavior allows the
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;.
to still take its own sweet time to return any values, but
yet still forces the
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_error&quot;&gt;error&lt;/a&gt;
when appropriate–i.e., when &lt;code class=&quot;highlighter-rouge&quot;&gt;f_const_illegal&lt;/code&gt; is set.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;		if (f_const_illegal)
			assume(!i_wb_ack);
		else
			assume(!i_wb_err);
	end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;There’s a corollary to our contract above.  This corollary has to do
with the cached value that hasn’t yet been given to the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;.
In this case, we still need to assert that this cached value holds to our
contract.  While this wouldn’t be necessary for a simple Bounded Model Check
(BMC), it is a &lt;a href=&quot;/blog/2018/03/10/induction-exercise.html&quot;&gt;necessary
requirement&lt;/a&gt;
in order to pass the formal
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Mathematical_induction&quot;&gt;induction step&lt;/a&gt;.
Hence, if the address within the cache, the next &lt;code class=&quot;highlighter-rouge&quot;&gt;o_pc&lt;/code&gt; address, &lt;code class=&quot;highlighter-rouge&quot;&gt;o_pc+4&lt;/code&gt;,
matches our arbitrary address, &lt;code class=&quot;highlighter-rouge&quot;&gt;f_const_addr&lt;/code&gt;, and if the cache has a valid
value within it, then these conditions apply: unless the cache value is
illegal, it should contain our arbitrary instruction word.  Likewise,
if the cache value is supposed to be illegal, then &lt;code class=&quot;highlighter-rouge&quot;&gt;cache_illegal&lt;/code&gt;
should be true as well.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(*)
	if ((o_pc[AW+1:2] + 1&#39;b1 == f_const_addr)&amp;amp;&amp;amp;(cache_valid))
	begin
		if (!cache_illegal)
			assert(cache_word == f_const_insn);

		if (f_const_illegal)
			assert(cache_illegal);
	end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;That’s our contract.  If we meet that contract, then we’ll know this
design works.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(posedge i_clk)
	if ((f_past_valid)&amp;amp;&amp;amp;(!$past(cache_illegal))&amp;amp;&amp;amp;(!cache_valid))
		assert(!cache_illegal);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;We’re not done yet, however.&lt;/p&gt;

&lt;p&gt;First, we want to make certain that our two instruction FIFO will never
overflow.  As we’ve written our design above, any overflow would be
catastrophic.  Hence, any time we request a new value, we must have a place
to put it.  In other words, either the cache value must be empty, or the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
must have just accepted a value.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(*)
	if (o_wb_stb)
		assert((!cache_valid)||(i_stall_n));&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;In a similar vein, any time both the output and the cache value are both
valid, then we need to guarantee that we aren’t requesting any more values,
and that nothing is in flight.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(*)
	if ((o_valid)&amp;amp;&amp;amp;(cache_valid))
		assert((f_outstanding == 0)&amp;amp;&amp;amp;(!o_wb_stb));&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;These should be sufficient to keep us from overflowing this two instruction
FIFO.&lt;/p&gt;

&lt;p&gt;However, the
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal properties&lt;/a&gt;
we’ve listed so far &lt;a href=&quot;/blog/2018/03/10/induction-exercise.html&quot;&gt;aren’t sufficient to
guarantee&lt;/a&gt;
that the design will pass the &lt;a href=&quot;https://en.wikipedia.org/wiki/Mathematical_induction&quot;&gt;induction
step&lt;/a&gt;.  In order to pass
&lt;a href=&quot;https://en.wikipedia.org/wiki/Mathematical_induction&quot;&gt;induction&lt;/a&gt;,
we need to restrict the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Mathematical_induction&quot;&gt;induction&lt;/a&gt;
engine so that it only considers reachable states.&lt;/p&gt;

&lt;p&gt;To make certain we don’t over-restrict our design, we’ll limit ourselves here
to only using assert statements.  As a result, the BMC and
&lt;a href=&quot;https://en.wikipedia.org/wiki/Mathematical_induction&quot;&gt;induction&lt;/a&gt;
stages will be able to catch anything that is over constrained–as long as the
number of stages examined in BMC is more than the stages examined during
&lt;a href=&quot;https://en.wikipedia.org/wiki/Mathematical_induction&quot;&gt;induction&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The first assertion is that any time we have at least one item in our FIFO,
that is any time &lt;code class=&quot;highlighter-rouge&quot;&gt;o_valid&lt;/code&gt; is true, and any time that item isn’t moving forward,
then there can only be one or zero
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;
requests outstanding.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(*)
	if ((o_valid)&amp;amp;&amp;amp;(!i_stall_n))
		assert(f_outstanding &amp;lt; 2);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The next assertion follows, but in this case any time the FIFO is completely
empty we allow ourselves to have up to two requests in flight.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(*)
	if ((!o_valid)||(i_stall_n))
		assert(f_outstanding &amp;lt;= 2);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Further, any time we are within a
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;
cycle, i.e. &lt;code class=&quot;highlighter-rouge&quot;&gt;o_wb_cyc&lt;/code&gt; is high, but yet we’ve stopped making
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;
requests, i.e. &lt;code class=&quot;highlighter-rouge&quot;&gt;o_wb_stb&lt;/code&gt; is low, then there should
be some number of requests in flight.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(posedge i_clk)
	if ((f_past_valid)&amp;amp;&amp;amp;($past(o_wb_cyc))&amp;amp;&amp;amp;(!$past(o_wb_stb))
			&amp;amp;&amp;amp;(o_wb_cyc))
		assert(inflight != 0);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Just to make sure we captured everything, let’s state this again: on any
return from the
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;,
there must be a place to put that return.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(*)
	if ((o_wb_cyc)&amp;amp;&amp;amp;(i_wb_ack))
		assert(!cache_valid);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Further, our design has two separate counters of how many items are within
flight.  One is from the &lt;code class=&quot;highlighter-rouge&quot;&gt;f_outstanding&lt;/code&gt; counter created within the
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;formal WB properties&lt;/a&gt;,
module, and the other our &lt;code class=&quot;highlighter-rouge&quot;&gt;inflight&lt;/code&gt; counter.&lt;/p&gt;

&lt;p&gt;These two counters need to be identical any time the
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;,
is in use.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(posedge i_clk)
	if (o_wb_cyc)
		assert(inflight == f_outstanding);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Now let’s look at the address of the request being made, vs the address
being given to the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;First, upon any return from the
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;,
that goes into &lt;code class=&quot;highlighter-rouge&quot;&gt;o_valid&lt;/code&gt;, the address
of the value returned needs to be equal to the value given to the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	assign	this_return_address = o_wb_addr - f_outstanding;
	assign	next_pc_address = o_pc[AW+1:2] + 1&#39;b1;

	always @(posedge i_clk)
	if ((f_past_valid)&amp;amp;&amp;amp;($past(o_wb_cyc))
			&amp;amp;&amp;amp;(!$past(i_reset))
			&amp;amp;&amp;amp;(!$past(i_new_pc))
			&amp;amp;&amp;amp;(!$past(i_clear_cache))
			&amp;amp;&amp;amp;(!$past(invalid_bus_cycle))
			&amp;amp;&amp;amp;(($past(i_wb_ack))||($past(i_wb_err)))
			&amp;amp;&amp;amp;((!$past(o_valid))||($past(i_stall_n)))
			&amp;amp;&amp;amp;(!$past(cache_valid)))
		assert(o_pc[AW+1:2] == $past(this_return_address));&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This isn’t enough, though, to constrain the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Mathematical_induction&quot;&gt;induction&lt;/a&gt;
engine.  I know, I tried.&lt;/p&gt;

&lt;p&gt;Getting
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/dblfetch.v&quot;&gt;this design&lt;/a&gt;
to pass the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Mathematical_induction&quot;&gt;induction&lt;/a&gt; step
required running the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Mathematical_induction&quot;&gt;induction&lt;/a&gt;
engine many times, then looking at the failures and trying to find out
which wires or values didn’t make sense.  When you find them, you look
at them and wonder, how on earth did that happen?  That doesn’t follow
my design principles!  Yes, but you
&lt;a href=&quot;/blog/2018/03/10/induction-exercise.html&quot;&gt;need to tell&lt;/a&gt;
the &lt;a href=&quot;https://en.wikipedia.org/wiki/Mathematical_induction&quot;&gt;induction&lt;/a&gt; step
engine that.&lt;/p&gt;

&lt;p&gt;So, let’s look at the case where &lt;code class=&quot;highlighter-rouge&quot;&gt;o_valid&lt;/code&gt; isn’t true, but yet we are within a
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;
cycle.  In this case, &lt;code class=&quot;highlighter-rouge&quot;&gt;o_pc&lt;/code&gt; must be the address of the next request
that will be returned from the
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(posedge i_clk)
	if ((f_past_valid)&amp;amp;&amp;amp;($past(o_wb_cyc))&amp;amp;&amp;amp;(!o_valid)&amp;amp;&amp;amp;(!$past(i_new_pc))
			&amp;amp;&amp;amp;(o_wb_cyc))
		assert(o_pc[AW+1:2] == this_return_address);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;We need to check the same thing with the cache word.  Any time the cache
becomes valid, the address coming back needs to be one past the &lt;code class=&quot;highlighter-rouge&quot;&gt;o_pc&lt;/code&gt;
address being presented to the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(posedge i_clk)
	if ((f_past_valid)&amp;amp;&amp;amp;($past(o_wb_cyc))
			&amp;amp;&amp;amp;(!$past(cache_valid))&amp;amp;&amp;amp;(cache_valid))
		assert(next_pc_address == $past(this_return_address));&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The final step looks at these relationships a bit more thoroughly.  We’ll
examine only those times, though, when the bus is active.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(posedge i_clk)
	if ((f_past_valid)&amp;amp;&amp;amp;($past(o_wb_cyc))&amp;amp;&amp;amp;(o_wb_cyc))
	begin&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;If there’s one active value in our FIFO, then anything returned from the
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;
should have an address given by our next
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;
address.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;		if ((o_valid)&amp;amp;&amp;amp;(!cache_valid))
			assert(this_return_address == next_pc_address);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Likewise anytime we have no valid instructions, the next value to be returned
by the
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;
must match the next
&lt;a href=&quot;https://en.wikipedia.org/wiki/Program_counter&quot;&gt;PC&lt;/a&gt;
value, &lt;code class=&quot;highlighter-rouge&quot;&gt;o_pc&lt;/code&gt;, to be sent to the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;		else if (!o_valid)
			assert(this_return_address == o_pc[AW+1:2]);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Finally, any time the
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;
is idle, and there’s only one word in our cache and it’s not illegal,
then the address remaining on the
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;
needs to be the next address to be requested.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	end else if ((f_past_valid)&amp;amp;&amp;amp;(!invalid_bus_cycle)
			&amp;amp;&amp;amp;(!o_wb_cyc)&amp;amp;&amp;amp;(o_valid)&amp;amp;&amp;amp;(!o_illegal)
			&amp;amp;&amp;amp;(!cache_valid))
		assert(o_wb_addr == next_pc_address);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This leaves us with only two more assertions.  These are sort of dogs and
cats assertions that don’t fit under any other category above.&lt;/p&gt;

&lt;p&gt;First, the &lt;code class=&quot;highlighter-rouge&quot;&gt;invalid_bus_cycle&lt;/code&gt; should only ever be true if we aren’t in a
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;
cycle.  This assertion was added to make certain I could simplify
some of the assertions above.  Since I know it is true, I could make the
other assertions simpler.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(*)
	if (invalid_bus_cycle)
		assert(!o_wb_cyc);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Finally, the &lt;code class=&quot;highlighter-rouge&quot;&gt;cache_valid&lt;/code&gt; signal should never be true unless &lt;code class=&quot;highlighter-rouge&quot;&gt;o_valid&lt;/code&gt; is
also true.  This lines up with the idea that &lt;code class=&quot;highlighter-rouge&quot;&gt;cache_valid&lt;/code&gt; is our signal that
the second item within our two-element FIFO is valid, so therefore the first
item in the FIFO must also be valid in these cases as well.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(*)
	if (cache_valid)
		assert(o_valid);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Wow!  That was a lot of work on those properties!  The cool thing about these,
though, is that now that I have these properties, I can then test simple logic
changes to my design, such as &lt;a href=&quot;/blog/2017/06/12/minimizing-luts.html&quot;&gt;trying to remove LUTs to make the design
simpler&lt;/a&gt;,
and see if those changes affect the functionality of this design.&lt;/p&gt;

&lt;h2 id=&quot;cover-properties&quot;&gt;Cover Properties&lt;/h2&gt;

&lt;p&gt;I haven’t presented &lt;code class=&quot;highlighter-rouge&quot;&gt;cover&lt;/code&gt; properties before, although they are a valuable
part of
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal methods&lt;/a&gt;.
The &lt;code class=&quot;highlighter-rouge&quot;&gt;cover&lt;/code&gt; property is very different from the &lt;code class=&quot;highlighter-rouge&quot;&gt;assume&lt;/code&gt; an &lt;code class=&quot;highlighter-rouge&quot;&gt;assert&lt;/code&gt; properties
above.  Indeed, &lt;code class=&quot;highlighter-rouge&quot;&gt;cover&lt;/code&gt; is called a “liveness” property, unlike
&lt;code class=&quot;highlighter-rouge&quot;&gt;assume&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;assert&lt;/code&gt; which are called “safety” properties.  The difference is
that &lt;code class=&quot;highlighter-rouge&quot;&gt;assume&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;assert&lt;/code&gt; properties must apply to all traces, whereas a
&lt;code class=&quot;highlighter-rouge&quot;&gt;cover&lt;/code&gt; property only needs to apply to a single trace to be true.&lt;/p&gt;

&lt;p&gt;A quick Google search suggests that there’s a bit of a disagreement as to
whether “liveness” properties are even needed, or whether “safety” properties
are sufficient.&lt;/p&gt;

&lt;p&gt;While I’m not going to enter into that debate today, I will note that
&lt;code class=&quot;highlighter-rouge&quot;&gt;cover&lt;/code&gt; statements can be used while you are building your design to
see if it is working.&lt;/p&gt;

&lt;p&gt;As an example, before I listed out all of the properties in the last
section, I wanted to know if this routine might ever get a third
acknowledgment from the same
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;
cycle.  If you’ll remember from Fig 11 above, this was part of the purpose
of
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/dblfetch.v&quot;&gt;this design&lt;/a&gt;
in the first place–to be able to continue the
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;
cycle as long as possible.  Therefore, I put the following &lt;code class=&quot;highlighter-rouge&quot;&gt;cover&lt;/code&gt;
statement into my design.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(posedge i_clk)
	cover((f_past_valid)&amp;amp;&amp;amp;($past(f_nacks)==3)
		&amp;amp;&amp;amp;($past(i_wb_ack))&amp;amp;&amp;amp;($past(o_wb_cyc)));&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;When this &lt;code class=&quot;highlighter-rouge&quot;&gt;cover&lt;/code&gt; statement failed at first, I knew I didn’t have my design
right yet.  Further, when I dug into the problem, I discovered that this
&lt;code class=&quot;highlighter-rouge&quot;&gt;cover&lt;/code&gt; statement was failing not due to my logic, but rather due to some
erroneous assumptions I had made.&lt;/p&gt;

&lt;p&gt;Erroneous assumptions can be particularly problematic in
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal methods&lt;/a&gt;,
especially if you are only using the “safety” properties, &lt;code class=&quot;highlighter-rouge&quot;&gt;assume&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;assert&lt;/code&gt;,
since an erroneous assumption will artificially limit your proof.  Worse yet,
you might not notice that your assumptions are creating this artificial
limit.  Such an assumption might then give you a false assurance that your
design works–even though it does not. (Yes, I’ve &lt;a href=&quot;/blog/2018/02/09/first-cyclonev.html&quot;&gt;been burned by
this&lt;/a&gt;
more than once.)&lt;/p&gt;

&lt;h2 id=&quot;logic-usage&quot;&gt;Logic Usage&lt;/h2&gt;

&lt;p&gt;If you’ll remember from when we started, the purpose of this particular
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/dblfetch.v&quot;&gt;prefetch
module&lt;/a&gt;
was to be a compromise–it was to have better performance than our &lt;a href=&quot;/zipcpu/2017/11/18/wb-prefetch.html&quot;&gt;one
instruction prefetch&lt;/a&gt;,
but not nearly as much as we might have with a proper &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/pfcache.v&quot;&gt;instruction
cache&lt;/a&gt;.
It’s also supposed to be a (fairly) low logic design.&lt;/p&gt;

&lt;p&gt;So, for a small design, how did we do?&lt;/p&gt;

&lt;p&gt;In particular, I’d like to place
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/dblfetch.v&quot;&gt;this prefetch&lt;/a&gt;
into both a
&lt;a href=&quot;https://tinyfpga.com&quot;&gt;TinyFPGA&lt;/a&gt;
and the &lt;a href=&quot;/blog/2017/12/16/max1k.html&quot;&gt;MAX1000 from Arrow&lt;/a&gt;.
Will it fit?&lt;/p&gt;

&lt;p&gt;The iCE40 &lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
within the &lt;a href=&quot;https://tinyfpga.com&quot;&gt;TinyFPGA&lt;/a&gt; board is perhaps the most
constrained of these two.  This
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
has just less than 8k 4-LUTs available to it.  With just a simple
&lt;a href=&quot;https://www.clifford.at/yosys&quot;&gt;yosys&lt;/a&gt;
script,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;read_verilog dblfetch.v
synth_ice40&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;we can easily measure this components usage on an iCE40–in only
a half-second no less (try doing that with a vendor tool!).  You can
see the LUT4 usage of these various components in the table below.&lt;/p&gt;

&lt;table class=&quot;bordered-table&quot;&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Prefetch&lt;/th&gt;
      &lt;th&gt;LUT4s&lt;/th&gt;
      &lt;th&gt;iCE40 Device usage&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;Single&lt;/td&gt;
      &lt;td&gt;74&lt;/td&gt;
      &lt;td&gt;1.0%&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Double&lt;/td&gt;
      &lt;td&gt;247&lt;/td&gt;
      &lt;td&gt;3.2%&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;(Before)&lt;/td&gt;
      &lt;td&gt;277&lt;/td&gt;
      &lt;td&gt;3.6%&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;w/ 4k Cache&lt;/td&gt;
      &lt;td&gt;621&lt;/td&gt;
      &lt;td&gt;8.0%&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;As you can see from the table, this module offers an area compromise between
the &lt;a href=&quot;/zipcpu/2017/11/18/wb-prefetch.html&quot;&gt;slowest prefetch
module&lt;/a&gt;
and the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/pfcache.v&quot;&gt;full prefetch and cache
module&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;running-the-zipcpu-with-this-prefetch&quot;&gt;Running the ZipCPU with this prefetch&lt;/h2&gt;

&lt;p&gt;If you want to try running the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
or even
&lt;a href=&quot;/zipcpu/2018/02/12/zbasic-intro.html&quot;&gt;ZBasic&lt;/a&gt; with this
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/dblfetch.v&quot;&gt;this prefetch&lt;/a&gt;
installed, all you need to do is to adjust the flags in
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/cpudefs.v&quot;&gt;cpudefs.v&lt;/a&gt;.
Specifically, you’ll want to make certain the &lt;code class=&quot;highlighter-rouge&quot;&gt;OPT_SINGLE_FETCH&lt;/code&gt; define is
commented,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;// `define	OPT_SINGLE_FETCH&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;and the &lt;code class=&quot;highlighter-rouge&quot;&gt;OPT_DOUBLE_FETCH&lt;/code&gt; line is not,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;`ifndef	OPT_SINGLE_FETCH
`define	OPT_DOUBLE_FETCH
`endif&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;You may recall discussing &lt;a href=&quot;/zipcpu/2018/01/31/cpu-build.html&quot;&gt;this comparison in a previous
article&lt;/a&gt;,
only now this &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/dblfetch.v&quot;&gt;compromise prefetch
module&lt;/a&gt;
has been updated for better performance and lower logic.  Hence, if you’ve
downloaded the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; before, you’ll
want to do a &lt;code class=&quot;highlighter-rouge&quot;&gt;git pull&lt;/code&gt; to get the latest version of
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/dblfetch.v&quot;&gt;this module&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;While it’s generally true that nothing comes for free, today’s post presents
a bit of an exception.  By redesigning &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/dblfetch.v&quot;&gt;my original dblfetch
module&lt;/a&gt;,
used by the &lt;a href=&quot;https://github.com/ZipCPU/s6soc&quot;&gt;S6SoC&lt;/a&gt;
and some other &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; low logic
implementations, we were able to get both better performance and
&lt;a href=&quot;/blog/2017/06/12/minimizing-luts.html&quot;&gt;fewer LUTs&lt;/a&gt;.
Hence, there are two conclusions we might draw:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;In general, the more LUTs you apply to a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Soft_microprocessor&quot;&gt;soft-core CPU&lt;/a&gt;,
the faster the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Soft_microprocessor&quot;&gt;CPU&lt;/a&gt; will be.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;There exist times when a better design can achieve more or better
performance.  Today’s post represents one of those times.  Such
performance increases, though, do tend to be asymptotic over time.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;What made the difference?  This new/updated
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/dblfetch.v&quot;&gt;prefetch&lt;/a&gt;
doesn’t use a two element memory array, nor the associated pair of valid
signals, to capture the two elements returned by the bus.&lt;/p&gt;

&lt;p&gt;How about the
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal methods&lt;/a&gt; we
used?  Did they help?  To this I’ll answer both yes and no.  The first time
I used this logic in a
&lt;a href=&quot;/blog/2017/06/21/looking-at-verilator.html&quot;&gt;simulated&lt;/a&gt;
&lt;a href=&quot;/blog/2017/12/16/max1k.html&quot;&gt;board&lt;/a&gt;, the
&lt;a href=&quot;/zipcpu/2018/02/12/zbasic-intro.html&quot;&gt;CPU test&lt;/a&gt;
failed.  That’s the “No” part of the answer.  However, the logic failed
within the early branch logic in the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/idecode.v&quot;&gt;instruction
decoder&lt;/a&gt;, not the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/dblfetch.v&quot;&gt;prefetch&lt;/a&gt;.
Indeed, this updated
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/dblfetch.v&quot;&gt;prefetch&lt;/a&gt;
has yet to have any failures since passing
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal verification&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Sadly, this wonderful anecdote of the performance of
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal methods&lt;/a&gt;
isn’t nearly as clear as I might like it to be.  The logic that failed within
the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/idecode.v&quot;&gt;instruction
decoder&lt;/a&gt;
had already been &lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formally
verified&lt;/a&gt;.
Apparently, that proof just wasn’t sufficient and I must still be only learning
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal methods&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The one question we haven’t answered is just how much faster is this
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/dblfetch.v&quot;&gt;prefetch&lt;/a&gt;?
That is, how does it’s &lt;em&gt;performance&lt;/em&gt; quantitatively compare to the other
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
&lt;a href=&quot;/zipcpu/2017/11/18/wb-prefetch.html&quot;&gt;prefetch&lt;/a&gt; modules?
I’m going to hold those questions off, though, for a future article on how
to measure your &lt;a href=&quot;https://en.wikipedia.org/wiki/Soft_microprocessor&quot;&gt;CPU&lt;/a&gt;’s
performance via a benchmark test–such as the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Dhrystone&quot;&gt;Dhrystone benchmark&lt;/a&gt;.  Such a
benchmark test will also bring us face to face with the fact that our
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;
speed measurements above weren’t accurate at all since they ignored the
(very significant) cost of
&lt;a href=&quot;https://en.wikipedia.org/wiki/Branch_(computer_science)&quot;&gt;branching&lt;/a&gt;.&lt;/p&gt;
&lt;hr /&gt;&lt;p&gt;&lt;em&gt;Many will say to me in that day, Lord, Lord, have we not prophesied in thy name? and in thy name have cast out devils? and in thy name done many wonderful works?  And then will I profess unto them, I never knew you: depart from me, ye that work iniquity.  (Matt 7:22-23)&lt;/em&gt;</description>
        <pubDate>Wed, 21 Mar 2018 00:00:00 -0400</pubDate>
        <link>http://zipcpu.com/zipcpu/2018/03/21/dblfetch.html</link>
        <guid isPermaLink="true">http://zipcpu.com/zipcpu/2018/03/21/dblfetch.html</guid>
        
        
        <category>zipcpu</category>
        
      </item>
    
      <item>
        <title>Is formal really all that hard?</title>
        <description>&lt;p&gt;I spent the first week of March, 2018, at
&lt;a href=&quot;https://dvcon.org&quot;&gt;DVCon&lt;/a&gt;
in San Francisco, talking to vendors and asking questions regarding
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;Formal Verification&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Many vendors offered Verification IP (VIP) modules that you could use in
&lt;a href=&quot;/blog/2017/06/21/looking-at-verilator.html&quot;&gt;simulation&lt;/a&gt;
to know that your interface matched the specification.  These models would
attach to your design, allowing you to then run tests on your design.  When/if
your design didn’t match what the protocol required, these commercial
VIP modules would issue an error.&lt;/p&gt;

&lt;p&gt;Indeed, it seems like the primary method of &lt;em&gt;proving&lt;/em&gt; that an
&lt;a href=&quot;/blog/2017/10/13/fpga-v-asic.html&quot;&gt;ASIC design&lt;/a&gt;
would work prior to tape out is to feed the simulated design with random data
and requests, over and over again, in order to get the design to fail.  Several
presentations discussed how to do this.  Hardware was advertised that could
help to make this happen.  While I’ll admit that the level of effort discussed
and presented goes well beyond my simple &lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;scripted test bench
failures&lt;/a&gt;,
it still only provides a small stochastic confidence that the design would work.&lt;/p&gt;

&lt;p&gt;What a difference from
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal&lt;/a&gt;!&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/v-method.svg&quot; alt=&quot;&quot; width=&quot;600&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;When using
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal methods&lt;/a&gt;,
&lt;em&gt;every&lt;/em&gt; path through the your logic is tested to determine if the design
works.  &lt;em&gt;Every path&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;This led me to wandering through the exhibit hall, asking vendor after vendor
if they had any &lt;em&gt;formal&lt;/em&gt; VIP.  Perhaps 5-10% of the VIP available was available
for proving something
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formally&lt;/a&gt;.
While the reasons were mixed, the general consensus was that
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal&lt;/a&gt;
was more difficult to use, and so there wasn’t the same market for it.  One
vendor even declared that his tools were faster, better, and cheaper than
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal&lt;/a&gt;,
although less than
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal&lt;/a&gt;
in capability.&lt;/p&gt;

&lt;p&gt;What??  Really?  Is
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal&lt;/a&gt;
really all that difficult to use?&lt;/p&gt;

&lt;p&gt;Let’s look at a simple example or two.  Then, we can discuss how I go about
getting started with
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal&lt;/a&gt; on any new
design, and what designs I apply
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal methods&lt;/a&gt; to.
Finally, we’ll attempt to address the question of whether
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal methods&lt;/a&gt;
really are all that hard.&lt;/p&gt;

&lt;h2 id=&quot;cover&quot;&gt;Cover&lt;/h2&gt;

&lt;p&gt;Just one simple &lt;code class=&quot;highlighter-rouge&quot;&gt;cover&lt;/code&gt; statement can have an amazing impact on a new design.
As an example, in a &lt;a href=&quot;https://github.com/ZipCPU/tinyzip&quot;&gt;recent design&lt;/a&gt;
I was working on for the
&lt;a href=&quot;https://tinyfpga.com&quot;&gt;TinyFPGA&lt;/a&gt;, a project I am calling
&lt;a href=&quot;https://github.com/ZipCPU/tinyzip&quot;&gt;TinyZip&lt;/a&gt;, I simply inserted&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	cover(o_wb_ack);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;into the &lt;a href=&quot;https://github.com/ZipCPU/tinyzip/blob/master/rtl/dualflexpress.v&quot;&gt;new/updated dual
I/O&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt;
controller.
(I was starting with
&lt;a href=&quot;https://github.com/ZipCPU/s6soc/blob/master/rtl/qflashxpress.v&quot;&gt;this QSPI&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt; controller.)
If you aren’t familiar with a &lt;code class=&quot;highlighter-rouge&quot;&gt;cover&lt;/code&gt; statement, you can consider
it a challenge to the
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal&lt;/a&gt;
&lt;a href=&quot;http://www.clifford.at/yosys&quot;&gt;tools&lt;/a&gt; to find some way to make the predicate
inside of the &lt;code class=&quot;highlighter-rouge&quot;&gt;cover&lt;/code&gt; statement–in this case &lt;code class=&quot;highlighter-rouge&quot;&gt;o_wb_ack&lt;/code&gt;–true.  To do this,
the &lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal&lt;/a&gt;
&lt;a href=&quot;http://www.clifford.at/yosys&quot;&gt;tools&lt;/a&gt; needed to trace &lt;a href=&quot;https://github.com/ZipCPU/tinyzip/blob/master/rtl/dualflexpress.v&quot;&gt;my
design&lt;/a&gt;
through the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt;
bring-up, the
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus request&lt;/a&gt;, the address
passing to the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt;,
and the return value.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;No extra logic was required!&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;I didn’t need to &lt;a href=&quot;/blog/2017/06/21/looking-at-verilator.html&quot;&gt;build a
simulation&lt;/a&gt;,
to tell the simulator to tick the clock,
tell it how many clocks to tick, feed it with just the right input along
the way–none of that.  With one line I had an example
trace through the important parts of my code.&lt;/p&gt;

&lt;p&gt;Was that all that hard?&lt;/p&gt;

&lt;p&gt;Ok, so it wasn’t perfect: the bus wires were being driven incoherently.
However, with some additional assumptions, such as those &lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;we discussed for the
Wishbone Bus&lt;/a&gt;, the traces
greatly improved.  (No, the
&lt;a href=&quot;https://github.com/ZipCPU/tinyzip/blob/master/rtl/dualflexpress.v&quot;&gt;controller&lt;/a&gt;
isn’t finished yet …)  Later, I added another cover statement to make
certain I could keep &lt;a href=&quot;https://github.com/ZipCPU/tinyzip/blob/master/rtl/dualflexpress.v&quot;&gt;the
design&lt;/a&gt;
loaded with one request after another.&lt;/p&gt;

&lt;h2 id=&quot;state-machines&quot;&gt;State Machines&lt;/h2&gt;

&lt;p&gt;Many of my designs use state machines that don’t completely cover
all of the states bits available.  For example, the “lite” versions of
&lt;a href=&quot;https://github.com/ZipCPU/wbuart32&quot;&gt;my serial port modules&lt;/a&gt;
only use states 0-8 and 15.  What if the design entered into any other
state?  Would such be possible?  With just a simple assertion,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	assert((state &amp;lt;= 8)||(state == 15));&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;I can then use
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal methods&lt;/a&gt;
to tell me if my state machine will ever get out of bounds.  Indeed, this
concept is so useful, it’s worth discussing further in the next section.&lt;/p&gt;

&lt;h2 id=&quot;dependent-logic&quot;&gt;Dependent logic&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;Formal methods&lt;/a&gt; are
also &lt;em&gt;very&lt;/em&gt; useful for making sure that dependencies between logic elements
are captured.  Hence, if you have two variables, &lt;code class=&quot;highlighter-rouge&quot;&gt;A&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;B&lt;/code&gt; that &lt;em&gt;must&lt;/em&gt;
have a dependent relationship,
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal methods&lt;/a&gt; are
very useful for making sure that dependent relationship is maintained.&lt;/p&gt;

&lt;p&gt;For example, many designs depend upon a state machine that transitions at a
speed much slower than the system clock.  My own &lt;a href=&quot;https://github.com/ZipCPU/wbuart32&quot;&gt;UART
implementation&lt;/a&gt; makes a great example
of this.  In this design, as with many similar ones, there is often a counter
used to determine &lt;em&gt;when&lt;/em&gt; the next state change will be.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
if (counter != 0)
	counter &amp;lt;= counter - 1&#39;b1;
else if (state_change) // &amp;amp;&amp;amp; counter == 0
	counter &amp;lt;= NEW_VALUE-1&#39;b1;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The problem with this approach is that within the state machine logic, I would
need to place tests for whether or not &lt;code class=&quot;highlighter-rouge&quot;&gt;counter == 0&lt;/code&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
if (i_reset)
	state  == reset_state;
else if (counter == 0)
begin
	case(state)
	STATE_ONE:
		// ...
	end case
end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This test for zero can make the &lt;a href=&quot;/blog/2017/06/12/minimizing-luts.html&quot;&gt;state transition logic unnecessarily
complex&lt;/a&gt;,
so I’ll often calculate it the clock prior with something like:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	zclk &amp;lt;= (counter == 1)||((counter == 0)&amp;amp;&amp;amp;(!state_change));&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;To determine if I got the logic right, I only need to
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formally verify&lt;/a&gt; that:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	assert(zclk == (counter == 0));&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;When the
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal&lt;/a&gt;
proof passes, I’ll know that these two dependent registers, &lt;code class=&quot;highlighter-rouge&quot;&gt;zclk&lt;/code&gt; and
&lt;code class=&quot;highlighter-rouge&quot;&gt;counter&lt;/code&gt;, are guaranteed to maintain their dependent relationship.
Hence, I can rely upon this dependency always being true within my
code–as I intended.&lt;/p&gt;

&lt;p&gt;Certainly other internal code dependencies can exist as well–often more
complex than this one.  For example, a packet index or address might need
to be zero any time the network is idle.  As I recognize that I have such
a dependency when writing my own code, I’ll often quickly write an
assertion to capture it.  Indeed, I do this so often that I’ll discuss
how to go about this in the next section.&lt;/p&gt;

&lt;h2 id=&quot;while-writing-code&quot;&gt;While writing code&lt;/h2&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/files-formal.svg&quot; alt=&quot;&quot; width=&quot;180&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Often, when I write RTL, I’ll come across a situation where I recognize some
dependency within my code that must be hold true.  Rather than write a fully
defensive piece of code that handles any potential internal failure, it
is often effective (and easier) to write a quick assertion to remind myself
to come back later and place this into the list of &lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal
properties&lt;/a&gt;
at the end of the module.&lt;/p&gt;

&lt;p&gt;Making sure I remember all of these dependencies later can be a hassle.&lt;/p&gt;

&lt;p&gt;Here’s a method I’ve found useful for that purpose.&lt;/p&gt;

&lt;p&gt;As I’m working on creating a module,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;//
// All files start with a (legalese) comment block
//
module name(/* portlist */);
	//
	// Module code is indented by one tab
	//&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;I’ll add any
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal properties&lt;/a&gt;
in line as I’m writing–but with the caveat that these ad-hoc properties
are not indented like the rest of the code.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;// Properties that need to be moved around later are not indented
// This helps me remember, when I see something that doesn&#39;t line
// up, that this property needs to be moved to another location.
always @(posedge i_clk)
	assume(!i_reset);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;My development will then continue, returning to my original indentation
scheme.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	//
	// Further module code (now indented again) may follow
	//&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Then, some time later, I’ll collect these ad-hoc &lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;assumtions and
assertions&lt;/a&gt;
into a section at the end of the module together with the rest of its
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal properties&lt;/a&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;`ifdef	FORMAL
	// Here&#39;s where the formal properties will eventually be placed:
	// between `ifdef FORMAL and it&#39;s associated `endif.
`endif&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;For example, a
&lt;a href=&quot;https://github.com/ZipCPU/wbuart32&quot;&gt;UART&lt;/a&gt; baud counter should never count
higher than one baud interval.  Hence, as I’m putting my
&lt;a href=&quot;https://github.com/ZipCPU/wbuart32&quot;&gt;UART&lt;/a&gt;
component design together, I’ll place an assertion to this effect into my code.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	assert(baud_counter &amp;lt; ONE_BAUD);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Some of my code, such as the &lt;a href=&quot;https://github.com/ZipCPU/tinyzip/blob/master/rtl/dualflexpress.v&quot;&gt;dual I/O flash
controller&lt;/a&gt;
I mentioned above, depends upon the ability to peek at a
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus request&lt;/a&gt;
at certain times before accepting it.  This requirement is easily captured by
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal properties&lt;/a&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
if ((f_past_valid)&amp;amp;&amp;amp;($past(request))&amp;amp;&amp;amp;(!$past(accepted)))
	assert(request_details == $past(request_details));&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Once I realize this, usually while building the code, I’ll just write it in
as I discussed above.  &lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;Asserts and
assumptions&lt;/a&gt;
like this alone have helped me flush out many
&lt;a href=&quot;/blog/2017/08/14/strategies-for-pipelining.html&quot;&gt;pipeline&lt;/a&gt;
bugs!&lt;/p&gt;

&lt;p&gt;Knowing that I intend to use
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal methods&lt;/a&gt;
to verify a design helps to encourage me to write properties within my
code as I write my code–even though I’ll place those at the end of the
file later.&lt;/p&gt;

&lt;h2 id=&quot;some-modules-are-just-too-critical-not-to-use-formal&quot;&gt;Some modules are just too critical not to use formal&lt;/h2&gt;

&lt;p&gt;Some interfaces I deal with are just &lt;em&gt;too critical&lt;/em&gt; not to use
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal methods&lt;/a&gt;
to prove a design component before introducing it to hardware.
For example, just one misbehaving &lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus
component&lt;/a&gt;
and the whole design will come crashing down.&lt;/p&gt;

&lt;p&gt;Remember how this happened to me in my first &lt;a href=&quot;/blog/2018/02/09/first-cyclonev.html&quot;&gt;Cyclone-V
project&lt;/a&gt;?  Before I
got the &lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal&lt;/a&gt;
properties of the &lt;a href=&quot;https://www.altera.com/literature/manual/mnl_avalon_spec.pdf&quot;&gt;Avalon
bus&lt;/a&gt;
just right, I had to deal with several cases of hardware lockup.
It would seem as though a
&lt;a href=&quot;/blog/2018/02/09/first-cyclonev.html&quot;&gt;Cyclone-V&lt;/a&gt;
can’t recover if my own logic fails to lower the wait request line, or
equivalently if it returns random bus responses that don’t follow requests).
In my case, only cycling power ever rescued my design, leaving me wondering
what had happened.&lt;/p&gt;

&lt;p&gt;If you’ve been reading this blog for a while, you may now recognize this
purpose in the &lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;formal WB properties
post&lt;/a&gt;.
Bus control logic is just &lt;em&gt;too sensitive&lt;/em&gt; to mess up.  All it takes
is one master missing a response to a request and your design may be locked
up until a hard reset.&lt;/p&gt;

&lt;p&gt;Cache controllers are another example, as they can be a &lt;em&gt;real pain&lt;/em&gt; to get
right.  Worse, all it takes is one &lt;a href=&quot;/zipcpu/2017/12/28/ugliest-bug.html&quot;&gt;ugly caching
error&lt;/a&gt; and you may be
&lt;a href=&quot;/blog/2017/05/19/fpga-hell.html&quot;&gt;spending days (or weeks)&lt;/a&gt;
looking in the wrong place to find the bug.&lt;/p&gt;

&lt;p&gt;My recommendation, therefore, would be that you consider this principle for
any portion of your design that, if it fails, will cause the whole design to
fail while leaving you in &lt;a href=&quot;/blog/2017/05/19/fpga-hell.html&quot;&gt;FPGA
Hell&lt;/a&gt;.
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;Formally verify&lt;/a&gt;
those components early in your design cycle, before ever placing them onto
real hardware.  Then verify them again any time you change them.&lt;/p&gt;

&lt;h2 id=&quot;some-simple-contracts&quot;&gt;Some simple contracts&lt;/h2&gt;

&lt;p&gt;I’ve recently started looking at the designs I’m building as providing a
service, and so when I start building the design I’ll often create a &lt;em&gt;contract&lt;/em&gt;
to describe the service that must be provided.  These &lt;em&gt;contracts&lt;/em&gt; are usually
just a couple of lines of &lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal
properties&lt;/a&gt;
that describe outputs in relationship to the designs inputs.
Such design contracts are often so fundamental that if the contract holds,
the design will be 80% verified (or better).&lt;/p&gt;

&lt;p&gt;Consider, for a moment, some simple peripherals from the standpoint of a
“contract”.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;Bus requests should always be followed by a bus
response&lt;/a&gt;.  There should be
no more responses than there are requests.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;A &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/dev/rtl/core/pfcache.v&quot;&gt;cache&lt;/a&gt;
should always return the value that would be found in memory at the
given address, whether it needs to read from memory to get it or instead if
it is already in the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/dev/rtl/core/pfcache.v&quot;&gt;cache&lt;/a&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Reads from a memory controller
(&lt;a href=&quot;https://github.com/ZipCPU/xulalx25soc/blob/master/rtl/wbsdram.v&quot;&gt;SDRAM&lt;/a&gt;,
&lt;a href=&quot;https://github.com/ZipCPU/tinyzip/blob/master/rtl/dualflexpress.v&quot;&gt;flash&lt;/a&gt;,
etc.) should always return the value that exists in the memory at that
location, and writes should change the memory.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;An &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/zipmmu.v&quot;&gt;MMU&lt;/a&gt;
should act as a bus bridge, between one set of addresses (the virtual ones)
and another (the physical ones), while creating page misses for anything
that doesn’t match.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The neat thing about these contracts is that they can help me prove that an
item works–to include passing the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Mathematical_induction&quot;&gt;induction&lt;/a&gt;
&lt;a href=&quot;/blog/2018/03/10/induction-exercise.html&quot;&gt;step&lt;/a&gt;.
Specifically, until the contract can be proven, the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Mathematical_induction&quot;&gt;induction&lt;/a&gt;
solver will keep presenting me with traces I need to examine.  This helps me
know how many properties I need to write.&lt;/p&gt;

&lt;p&gt;If the Lord wills, I’m hoping to blog about this concept soon with respect to a
second &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
&lt;a href=&quot;/zipcpu/2017/11/18/wb-prefetch.html&quot;&gt;prefetch module&lt;/a&gt;,
showing how a contract can be written using a couple free variables.&lt;/p&gt;

&lt;h2 id=&quot;why-do-people-think-formal-is-hard&quot;&gt;Why do people think formal is hard?&lt;/h2&gt;

&lt;p&gt;After hearing that 
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal&lt;/a&gt;
was too hard, I tried to gather all of the excuses I heard
to see if there might be some merit to any of them.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Mathematical_induction&quot;&gt;Induction&lt;/a&gt;
is harder than Bounded Model Checking (BMC)&lt;/p&gt;

    &lt;p&gt;Many of the simple examples I gave above would be perfect for bounded
proofs.  These proofs are only applicable for the first N steps (i.e
the bound) following a reset.  Bounded proofs are much easier than the
full proofs, simply because in the case of a full proof you need to
find &lt;em&gt;ALL&lt;/em&gt; the &lt;a href=&quot;/blog/2018/03/10/induction-exercise.html&quot;&gt;internal
dependencies&lt;/a&gt;.
within your design and make them known to the
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal&lt;/a&gt;
engine via additional properties–whether they be assumptions or assertions.
This can be a pain, and so I can understand that you might not wish to use
&lt;a href=&quot;https://en.wikipedia.org/wiki/Mathematical_induction&quot;&gt;induction&lt;/a&gt;
at first.  Even in this case, though, the bounded model check is still
valuable–just not nearly as valuable as the full proof with
&lt;a href=&quot;https://en.wikipedia.org/wiki/Mathematical_induction&quot;&gt;induction&lt;/a&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Some modules are just too complex to prove using
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal methods&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;This isn’t an excuse, nor should it be.  It is just a reality.&lt;/p&gt;

    &lt;p&gt;While I’ve been able to &lt;a href=&quot;/zipcpu/2018/01/22/formal-progress.html&quot;&gt;prove all of the leaf
modules&lt;/a&gt; of the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;,
the complexity of the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt; as a whole
has caused me to pause before diving into it.  While I think I &lt;em&gt;can&lt;/em&gt;
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formally prove&lt;/a&gt;
that it works, the sheer complexity has caused me to pause.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The full System Verilog Assertions syntax can be confusing&lt;/p&gt;

    &lt;p&gt;If you’ve looked at the articles I’ve written so far regarding
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal methods&lt;/a&gt;,
you may notice that I haven’t used the full System Verilog Assertion (SVA)
syntax.  This is for two reasons.&lt;/p&gt;

    &lt;p&gt;First, the open source
&lt;a href=&quot;http://www.clifford.at/yosys&quot;&gt;yosys&lt;/a&gt;
synthesis tool that I’m using to get access to
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal methods&lt;/a&gt;
without re-mortgaging my home doesn’t understand this syntax (yet).
Indeed, I’ve managed to &lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formally
verify&lt;/a&gt;
many designs with only the subset that
&lt;a href=&quot;http://www.clifford.at/yosys&quot;&gt;yosys&lt;/a&gt;
supports.  Since
&lt;a href=&quot;http://www.clifford.at/yosys&quot;&gt;yosys&lt;/a&gt;
is the tool I can afford, it’s the tool I’ve been using.&lt;/p&gt;

    &lt;p&gt;Second, I’m in the process of building a class in
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal methods&lt;/a&gt;.
This class includes a section on how to use the full SVA syntax: properties,
sequences, clocking blocks, bind statements, and more.  Since I’ve now
been introduced to the full SVA syntax, my initial impressions are that
it is very expressive, terse and compact, and as a result it is confusing
to those who are not familiar with them.  On the other hand, the
&lt;code class=&quot;highlighter-rouge&quot;&gt;assert&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;assume&lt;/code&gt; statements I’ve used within always or initial blocks
have been expressive enough for me, and simpler to understand.&lt;/p&gt;

    &lt;p&gt;It just happens that this simpler subset is also the set that
&lt;a href=&quot;http://www.clifford.at/yosys&quot;&gt;yosys&lt;/a&gt;
currently supports.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;It can be really difficult to sell
&lt;em&gt;&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal&lt;/a&gt;&lt;/em&gt;
Verification IP, simply because
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal&lt;/a&gt;
verification is a form of
&lt;a href=&quot;https://en.wikipedia.org/wiki/White_box_testing&quot;&gt;&lt;em&gt;white&lt;/em&gt; box testing&lt;/a&gt;&lt;/p&gt;

    &lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 3. Just attaching VIP to a formal design doesn&#39;t usually work&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/files-vip-unlinked.svg&quot; alt=&quot;&quot; width=&quot;360&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p style=&quot;list-style-type: none;&quot;&gt;What I mean by this is that attaching any vendor
   supplied Verification IP module to your design isn’t as simple as just
   instantiating the two components within the same design.  The
   &lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal methods&lt;/a&gt;,
   and &lt;a href=&quot;https://en.wikipedia.org/wiki/Mathematical_induction&quot;&gt;induction&lt;/a&gt;
   in particular, won’t work if you just plug and play related design pieces
   together such as Fig 3. attempts to show.  This makes it more difficult
   to sell, purchase, or use vendor provided Verification IP with
   &lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;In order to connect an external set of
   &lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal&lt;/a&gt; properties,
   such as those from a piece of vendor supplied Verification IP, to the
   &lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal&lt;/a&gt; properties
   within your own design–relevant portions of the design need to be
   constrained to be properly dependent with the VIP.
   Success in this fashion is far more intrusive, and not nearly as simple
   as just purchasing someone else’s IP.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 4. Passing Induction requires component state to interact&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/files-vip-linked.svg&quot; alt=&quot;&quot; width=&quot;360&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Perhaps a good example of this is my
   &lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;Wishbone&lt;/a&gt; &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/ex/wbpriarbiter.v&quot;&gt;bus
   arbiter&lt;/a&gt;.
   Internal to the &lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;Wishbone formal
   property&lt;/a&gt;
   &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/tree/master/rtl/ex&quot;&gt;IP modules&lt;/a&gt;
   are the counters necessary to insure that slaves will only respond
   to outstanding requests.  This
   requires counting the number of requests, the number of acknowledgments,
   and then making certain that there are never more acknowledgments than
   requests.  When I then try to use these properties within the bus
   &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/ex/wbpriarbiter.v&quot;&gt;arbiter&lt;/a&gt;
   to pass
   &lt;a href=&quot;https://en.wikipedia.org/wiki/Mathematical_induction&quot;&gt;induction&lt;/a&gt;,
   the
   &lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal&lt;/a&gt; engine
   may set these counters to &lt;a href=&quot;/blog/2018/03/10/induction-exercise.html&quot;&gt;any initial value it
   wants&lt;/a&gt;.  However,
   the arbiter
   is designed so that only one master can ever have access to the bus at a
   time.  This means that the counters for the two slave inputs and the master
   output must be kept in sync.  Doing this requires knowledge of the counters
   within the
   &lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;Wishbone&lt;/a&gt; propert
   &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/tree/master/rtl/ex&quot;&gt;module&lt;/a&gt;,
   enough so that I can assert that when one bus source has access to the bus,
   the other sources number of outstanding requests must remain at zero.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
if (r_a_owner)
begin
	// If A owns the bus

	// B must have no outstanding requests, nor may it
	// have received any acknowledgements
	assert(f_b_nreqs == 0);
	assert(f_b_nacks == 0);

	// The total number of outstanding requests must equal
	// the number of outstanding requests A is expecting
	assert(f_a_outsanding == f_outstanding);
end else begin
	// Else B must own the bus
	// Same properties as before, just reversed
	assert(f_a_nreqs == 0);
	assert(f_a_nacks == 0);
	assert(f_b_outsanding == f_outstanding);
end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig. Here&#39;s how I ended up attaching WB properties to a simple design&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/files-wb-properties.svg&quot; alt=&quot;&quot; width=&quot;480&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;If you fail to do this, your design &lt;a href=&quot;/blog/2018/03/10/induction-exercise.html&quot;&gt;won’t be able
   to pass&lt;/a&gt;
   &lt;a href=&quot;https://en.wikipedia.org/wiki/Mathematical_induction&quot;&gt;induction&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Even if your design doesn’t pass
   &lt;a href=&quot;https://en.wikipedia.org/wiki/Mathematical_induction&quot;&gt;induction&lt;/a&gt;,
   (most big chip maker designs don’t) your &lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal
   properties&lt;/a&gt;
   may still be good enough to accomplish some purposes, since you can still
   find lots of bugs via a simple Bounded Model Check.  You just can’t &lt;em&gt;prove&lt;/em&gt;
   that your design will maintain those properties for all time.&lt;/p&gt;

&lt;p&gt;Does it take a genius?  Not really.  Indeed, from my own experience,
it just takes someone smart enough to write Verilog RTL in the first place.&lt;/p&gt;

&lt;h2 id=&quot;formal-isnt-perfect&quot;&gt;Formal isn’t perfect&lt;/h2&gt;

&lt;p&gt;My thesis today is just that
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal&lt;/a&gt;
isn’t really any more difficult than normal RTL coding.  Not only that, it fits
nicely into the RTL coding process and even adds to it.  Now that I’ve used it
for a while, and now that I’ve found as many errors as I have using
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal&lt;/a&gt;,
I’m convinced from my own experience that it’s not really that hard.  Indeed,
if I had the choice today, I would find it difficult to start a project
&lt;em&gt;without&lt;/em&gt; the help
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal methods&lt;/a&gt;
provide.&lt;/p&gt;

&lt;p&gt;While I was at the
&lt;a href=&quot;https://dvcon.org&quot;&gt;DVCon&lt;/a&gt; conference, I heard two fascinating comments
regarding how valuable &lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal
methods&lt;/a&gt; are,
and many fascinating anecdotes.  The first comment I scribbled down was
that, “Without &lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal&lt;/a&gt;,
70% of the bugs in a design are found after the module is turned in.  With
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal&lt;/a&gt;,
80% of the bugs in a design are found before the module is turned in.”
No, I’m not sure any more where these numbers came from, so if I can find the
study I’d love to share it with you.  The
second comment was from one of the panelists who noted that a rough 80% of a
verification engineer’s time is spent fixing the &lt;em&gt;silly&lt;/em&gt; bugs.  The
implication in this statement was that, had only
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal methods&lt;/a&gt;
been used, the verification engineer wouldn’t need to be spending his time
fixing the stupid mistakes.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;Formal methods&lt;/a&gt;
aren’t perfect.  By that I mean that, in my own experience, I’ve still had
to chase down bugs that “passed” a formal proof.
These include problems with not constraining my design enough, with adding
careless assumptions, and even misunderstood requirements.&lt;/p&gt;

&lt;p&gt;However, I find 
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal methods&lt;/a&gt;
easier to use than the alternative, and I also feel like I am finding more
bugs by using them as part of my design process.  As a result, I now use
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal methods&lt;/a&gt;
first, and then continue with simulation when I’m done.&lt;/p&gt;

&lt;p&gt;So why do people think
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal&lt;/a&gt; is all that
difficult?  My best guess is that
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal methods&lt;/a&gt;
appear difficult to those who have not tried them, and additionally to those
selling Verification IP.&lt;/p&gt;
&lt;hr /&gt;&lt;p&gt;&lt;em&gt;Behold, I am the LORD, the God of all flesh: is there any thing too hard for me?  (Jeremiah 32:27)&lt;/em&gt;</description>
        <pubDate>Wed, 14 Mar 2018 00:00:00 -0400</pubDate>
        <link>http://zipcpu.com/blog/2018/03/14/is-formal-hard.html</link>
        <guid isPermaLink="true">http://zipcpu.com/blog/2018/03/14/is-formal-hard.html</guid>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>An Exercise in using Formal Induction</title>
        <description>&lt;p&gt;In many ways I’m still quite the beginner when it comes to proving designs
using &lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal methods&lt;/a&gt;:
I’ve only used
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal methods&lt;/a&gt;
for about about five months.  However, over those five months I’ve found
so many bugs in my “&lt;em&gt;working&lt;/em&gt;” code that I’ve started using
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal methods&lt;/a&gt;
for every new component and design I’ve built since.&lt;/p&gt;

&lt;p&gt;I’ve also found myself counseling others on the
&lt;a href=&quot;https://irclog.whitequark.org/yosys&quot;&gt;#yosys&lt;/a&gt;
&lt;a href=&quot;https://freenode.net&quot;&gt;IRC forum&lt;/a&gt;.  It’s been rather strange, though, since
I very much feel as though I myself am quite the beginner, and yet I’m
answering questions and explaining things as though I’d been doing this
for years.&lt;/p&gt;

&lt;p&gt;I haven’t.&lt;/p&gt;

&lt;p&gt;However, I’d like to share with you today an &lt;a href=&quot;/examples/kitest.v&quot;&gt;example
piece&lt;/a&gt; of code that really
taught me a lot about
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal methods&lt;/a&gt;,
and in particular about the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Mathematical_induction&quot;&gt;induction&lt;/a&gt; step.
It’s come up recently as I’ve tried to explain
&lt;a href=&quot;https://en.wikipedia.org/wiki/Mathematical_induction&quot;&gt;induction&lt;/a&gt;
to someone with even less experience than I have, and I’ve found that it
makes a good and simple example to learn from.&lt;/p&gt;

&lt;p&gt;I’ll be honest–my own mentors haven’t thought that much of the
&lt;a href=&quot;/examples/kitest.v&quot;&gt;example below&lt;/a&gt;.  Their response
has been something like, “Oh, yes, of course.” Yet to me, I’ve found
&lt;a href=&quot;/examples/kitest.v&quot;&gt;this example&lt;/a&gt;
to be &lt;em&gt;very&lt;/em&gt; instructive.&lt;/p&gt;

&lt;h2 id=&quot;the-example-code&quot;&gt;The Example Code&lt;/h2&gt;

&lt;p&gt;The &lt;a href=&quot;/examples/kitest.v&quot;&gt;basic example&lt;/a&gt;
consists of two shift registers, &lt;code class=&quot;highlighter-rouge&quot;&gt;sa&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;sb&lt;/code&gt;, although
the example would also work if you were comparing &lt;a href=&quot;/blog/2017/10/27/lfsr.html&quot;&gt;Fibonacci versus Galois
linear feedback shift registers
(LFSR)s&lt;/a&gt;–it just wouldn’t be
nearly as clear.  However, the example does require that the two
shift register outputs need to be identical.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 1. Two identical shift registers&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/kitest.svg&quot; alt=&quot;&quot; width=&quot;480&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;We’ll allow our two shift registers to have a parameterized
length, &lt;code class=&quot;highlighter-rouge&quot;&gt;LN&lt;/code&gt;, although for the purposes of today’s discussion we’ll only
set this length to a constant 16, &lt;code class=&quot;highlighter-rouge&quot;&gt;LN=16&lt;/code&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;module	kitest(i_clk, i_reset, i_ce, i_in, o_bit);
	parameter		LN=16;
	//
	input	wire		i_clk, i_reset, i_ce, i_in;
	output	wire		o_bit;

	reg	[(LN-1):0]	sa, sb;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;For this example to be instructive, both shift registers must have &lt;em&gt;identical&lt;/em&gt;
logic.  Therefore, we’ll initialize both registers to zero.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	initial	sa = 0;
	initial	sb = 0;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;We’ll clear both registers on any synchronous reset.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(posedge i_clk)
	if (i_reset)
	begin
		sa &amp;lt;= 0;
		sb &amp;lt;= 0;
	end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Finally, any time &lt;code class=&quot;highlighter-rouge&quot;&gt;i_ce&lt;/code&gt; is true, the input value will be placed into the
least significant bit (LSB) of each shift register, while we shift the rest
of the register to the left.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	else if (i_ce)
	begin
		sa &amp;lt;= { sa[(LN-2):0], i_in };
		sb &amp;lt;= { sb[(LN-2):0], i_in };
	end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;In all other clocks, &lt;code class=&quot;highlighter-rouge&quot;&gt;sa&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;sb&lt;/code&gt; will remain unchained.&lt;/p&gt;

&lt;p&gt;Our &lt;a href=&quot;/examples/kitest.v&quot;&gt;example&lt;/a&gt;
needs an output, so let’s set our output value to be the
exclusive OR of the most significant bits in each register.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	assign	o_bit = sa[LN-1] ^ sb[LN-1];&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;If these two shift registers are truly identical, then we should be able to
assert this fact to the
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal&lt;/a&gt;
solver, as in:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;`ifdef	FORMAL
	assert property(!o_bit);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;If you stop here and try to prove this one property,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;`endif
endmodule&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;it will pass a bounded model check, but not
&lt;a href=&quot;https://en.wikipedia.org/wiki/Mathematical_induction&quot;&gt;induction&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Once I understood why
&lt;a href=&quot;/examples/kitest.v&quot;&gt;this simple design&lt;/a&gt;
struggled with
&lt;a href=&quot;https://en.wikipedia.org/wiki/Mathematical_induction&quot;&gt;induction&lt;/a&gt;,
I was suddenly able to figure out why various designs were struggling with
&lt;a href=&quot;https://en.wikipedia.org/wiki/Mathematical_induction&quot;&gt;induction&lt;/a&gt;,
and I then understood how to deal with it.  Therefore, let’s
spend the rest of this article discussing the difficulty with
&lt;a href=&quot;/examples/kitest.v&quot;&gt;this design&lt;/a&gt;,
and also how we might go about solving it.&lt;/p&gt;

&lt;h2 id=&quot;running-symbiyosys&quot;&gt;Running SymbiYosys&lt;/h2&gt;

&lt;p&gt;If you have &lt;a href=&quot;https://symbiyosys.readthedocs.io/en/latest&quot;&gt;SymbiYosys&lt;/a&gt;
installed, then all it takes is a
&lt;a href=&quot;/examples/kitest.sby&quot;&gt;very simple script&lt;/a&gt; to run this test.
Since adjusting parameters is fairly easy with
&lt;a href=&quot;https://symbiyosys.readthedocs.io/en/latest&quot;&gt;SymbiYosys&lt;/a&gt;, we’ll use it for
our tests today.&lt;/p&gt;

&lt;p&gt;There are four basic parts to any
&lt;a href=&quot;https://symbiyosys.readthedocs.io/en/latest&quot;&gt;SymbiYosys&lt;/a&gt;
script: the options, the formal engine, the
&lt;a href=&quot;http://www.clifford.at/yosys&quot;&gt;yosys&lt;/a&gt;
script, and the list of component files involved.&lt;/p&gt;

&lt;p&gt;In our case, we’ll want to use the formal mode &lt;em&gt;prove&lt;/em&gt;.  This will run both
the bounded model checker (BMC), &lt;em&gt;and&lt;/em&gt; the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Mathematical_induction&quot;&gt;induction&lt;/a&gt; engine.
Other modes I’ve worked with include &lt;em&gt;bmc&lt;/em&gt;, which just runs the bounded
model checker, and &lt;em&gt;cover&lt;/em&gt;, which checks cover properties. 
&lt;a href=&quot;https://symbiyosys.readthedocs.io/en/latest&quot;&gt;SymbiYosys&lt;/a&gt;
also supports a mode for checking liveness, called mode &lt;em&gt;live&lt;/em&gt;, but I have
yet to try that mode.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;[options]
mode prove&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 2. Forall time proofs have two parts&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/formal-forall-time.svg&quot; alt=&quot;&quot; width=&quot;240&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;We’ll also be adjusting the depth of the proof.  This is the number of logic
steps the formal solver uses to test our design.  In &lt;em&gt;bmc&lt;/em&gt; mode, this will
be the number of clock cycles, measured from the beginning of time, that
are checked for any assertion failures.  For the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Mathematical_induction&quot;&gt;induction&lt;/a&gt; step, in
&lt;em&gt;prove&lt;/em&gt; mode, this will decide the number of clock cycles for both the &lt;em&gt;bmc&lt;/em&gt;
pass and the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Mathematical_induction&quot;&gt;induction&lt;/a&gt; pass.  For
the &lt;a href=&quot;https://en.wikipedia.org/wiki/Mathematical_induction&quot;&gt;induction&lt;/a&gt; pass,
all but the last cycle will assume your &lt;code class=&quot;highlighter-rouge&quot;&gt;assert&lt;/code&gt;’s are true.  On the last cycle,
however, the formal engine will try to find one example where it can show that
an assertion fails.&lt;/p&gt;

&lt;p&gt;In my initial
&lt;a href=&quot;https://symbiyosys.readthedocs.io/en/latest&quot;&gt;SymbiYosys&lt;/a&gt;
&lt;a href=&quot;/examples/kitest.sby&quot;&gt;script&lt;/a&gt;,
I’ll set this depth to 31.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;depth 31&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;As I mentioned, we’ll be adjusting this value during today’s
&lt;a href=&quot;/examples/kitest.v&quot;&gt;exercise&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;We’ll also need to specify which formal solving engine we want to use.  In
this case, the &lt;a href=&quot;http://yices.csl.sri.com&quot;&gt;yices&lt;/a&gt;
engine will work quite nicely.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;[engines]
smtbmc yices&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Other engines are available, and may produce different results.&lt;/p&gt;

&lt;p&gt;We’ll then provide
&lt;a href=&quot;https://symbiyosys.readthedocs.io/en/latest&quot;&gt;SymbiYosys&lt;/a&gt;
with a very simple set of
&lt;a href=&quot;http://www.clifford.at/yosys&quot;&gt;yosys&lt;/a&gt;
commands to build &lt;a href=&quot;/examples/kitest.v&quot;&gt;our test&lt;/a&gt;,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;[script]
read_verilog -formal kitest.v
prep -top kitest

[files]
kitest.v&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Be aware when you are working with
&lt;a href=&quot;https://symbiyosys.readthedocs.io/en/latest&quot;&gt;SymbiYosys&lt;/a&gt;
that the &lt;code class=&quot;highlighter-rouge&quot;&gt;[files]&lt;/code&gt; section
will specify where your source files are coming from.
&lt;a href=&quot;https://symbiyosys.readthedocs.io/en/latest&quot;&gt;SymbiYosys&lt;/a&gt; will then copy
these files to a working directory before running
&lt;a href=&quot;http://www.clifford.at/yosys&quot;&gt;yosys&lt;/a&gt;,
so the &lt;code class=&quot;highlighter-rouge&quot;&gt;read_verilog&lt;/code&gt; command within the
&lt;a href=&quot;http://www.clifford.at/yosys&quot;&gt;yosys&lt;/a&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;[script]&lt;/code&gt; section will reference all files
from within the current directory where
&lt;a href=&quot;https://symbiyosys.readthedocs.io/en/latest&quot;&gt;SymbiYosys&lt;/a&gt; placed them.&lt;/p&gt;

&lt;p&gt;Let’s save this script to a file,
&lt;a href=&quot;/examples/kitest.sby&quot;&gt;kitest.sby&lt;/a&gt;.
Put together, the whole
&lt;a href=&quot;https://symbiyosys.readthedocs.io/en/latest&quot;&gt;SymbiYosys&lt;/a&gt;
&lt;a href=&quot;/examples/kitest.sby&quot;&gt;script&lt;/a&gt;
will look like,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;[options]
mode prove
depth 31

[engines]
smtbmc yices

[script]
read_verilog -formal kitest.v
prep -top kitest

[files]
kitest.v&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Assuming you have
&lt;a href=&quot;https://symbiyosys.readthedocs.io/en/latest&quot;&gt;SymbiYosys&lt;/a&gt;,
&lt;a href=&quot;http://www.clifford.at/yosys&quot;&gt;yosys&lt;/a&gt;, and
&lt;a href=&quot;http://yices.csl.sri.com&quot;&gt;yices&lt;/a&gt;
installed, then all it then takes to run
&lt;a href=&quot;https://symbiyosys.readthedocs.io/en/latest&quot;&gt;SymbiYosys&lt;/a&gt;
is the command,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span class=&quot;gp&quot;&gt;% &lt;/span&gt;sby -f kitest.sby&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Pay attention to the last line returned by
&lt;a href=&quot;https://symbiyosys.readthedocs.io/en/latest&quot;&gt;SymbiYosys&lt;/a&gt;.  If all goes
well, you’ll get the line:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;SBY [kitest] DONE (PASS, rc=0)&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;However, if our design passes BMC (which it will) but
fails &lt;a href=&quot;https://en.wikipedia.org/wiki/Mathematical_induction&quot;&gt;induction&lt;/a&gt;, then
this last line will instead read,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;SBY [kitest] DONE (UNKNOWN, rc=4)&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;In the next section, we’ll look at what happens when we apply
&lt;a href=&quot;https://symbiyosys.readthedocs.io/en/latest&quot;&gt;SymbiYosys&lt;/a&gt;
to &lt;a href=&quot;/examples/kitest.v&quot;&gt;our example&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;exploring-what-happens&quot;&gt;Exploring what happens&lt;/h2&gt;

&lt;p&gt;Let’s spend some time exploring what happens within
&lt;a href=&quot;/examples/kitest.v&quot;&gt;this example design&lt;/a&gt;, and see what
it will take to get us to fully prove our property that the output bit will
always be zero.&lt;/p&gt;

&lt;p&gt;We’ll start out by describing a set of tests, each containing a different
approach to handling this problem.  We’ll use the local parameter
&lt;code class=&quot;highlighter-rouge&quot;&gt;FORMAL_TEST&lt;/code&gt; to select from among several possible options for proving
this.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	localparam [2:0]	FORMAL_TEST = 3&#39;b001;

	generate if (FORMAL_TEST == 3&#39;b000)
	begin

		always @(*)
			assume(i_ce);

	end else if (FORMAL_TEST == 3&#39;b001)
	begin

		// No extra logic

	end else if (FORMAL_TEST == 3&#39;b010)
	begin

		assert property(sa == sb);

	end else if (FORMAL_TEST == 3&#39;b011)
	begin

		always @(posedge i_clk)
		if (!$past(i_ce))
			assume(i_ce);

	end else if (FORMAL_TEST == 3&#39;b100)
	begin

		always @(posedge i_clk)
		if ((!$past(i_ce))&amp;amp;&amp;amp;(!$past(i_ce,2)))
			assume(i_ce);

	// else
	//	No formal logic
	end endgenerate&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Now, let’s work our way through these tests, shall we?&lt;/p&gt;

&lt;p&gt;When &lt;code class=&quot;highlighter-rouge&quot;&gt;FORMAL_TEST&lt;/code&gt; is zero, the test passes–much as we might expect.
Since it does pass, there’s no trace generated to examine and we can move
on.  We’ll come back to this, though, in a moment.&lt;/p&gt;

&lt;p&gt;When &lt;code class=&quot;highlighter-rouge&quot;&gt;FORMAL_TEST&lt;/code&gt; is set to &lt;code class=&quot;highlighter-rouge&quot;&gt;3&#39;b001&lt;/code&gt;, however, the test fails.  Why would
this be?  It doesn’t make sense, right?  I mean, if you look at the
&lt;a href=&quot;/examples/kitest.v&quot;&gt;code&lt;/a&gt;,
you can clearly (by examination) tell that &lt;code class=&quot;highlighter-rouge&quot;&gt;sa==sb&lt;/code&gt;, and so there must be
something wrong with the
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal methods&lt;/a&gt;,
therefore, if it can’t tell that these two are equal.&lt;/p&gt;

&lt;p&gt;Well, not quite.  Let’s dig a little deeper.&lt;/p&gt;

&lt;p&gt;In particular, let’s pull up the trace associated with this failure.  If
you look through the
&lt;a href=&quot;https://symbiyosys.readthedocs.io/en/latest&quot;&gt;SymbiYosys&lt;/a&gt;
output, you’ll find the line ending with&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;.... Writing trace to VCD file: engine_0/trace_induct.vcd&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;We can open &lt;code class=&quot;highlighter-rouge&quot;&gt;trace_induct.vcd&lt;/code&gt; in &lt;a href=&quot;http://gtkwave.sourceforge.net&quot;&gt;GTKWave&lt;/a&gt;
and look at what’s going on here.  You’ll find this file in the
&lt;code class=&quot;highlighter-rouge&quot;&gt;kitest/engine_0&lt;/code&gt; directory where
&lt;a href=&quot;https://symbiyosys.readthedocs.io/en/latest&quot;&gt;SymbiYosys&lt;/a&gt;
placed it.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 3. Induction fails&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/kitest-2.png&quot; alt=&quot;&quot; width=&quot;911&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;If you look through the trace, you’ll notice that &lt;code class=&quot;highlighter-rouge&quot;&gt;sa&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;sb&lt;/code&gt; are
indeed different.&lt;/p&gt;

&lt;p&gt;What?  How can this be?&lt;/p&gt;

&lt;p&gt;To understand this, you need to understand a bit about how formal
&lt;a href=&quot;https://en.wikipedia.org/wiki/Mathematical_induction&quot;&gt;induction&lt;/a&gt; works.
The &lt;a href=&quot;https://en.wikipedia.org/wiki/Mathematical_induction&quot;&gt;induction&lt;/a&gt; step
works by picking random initial values for every registered signal within
the design.  Well, okay, that’s not quite right.  The values aren’t truly
chosen &lt;em&gt;randomly&lt;/em&gt;, they are actually chosen &lt;em&gt;exhaustively&lt;/em&gt;.  Were they chosen
randomly, it might be possible to miss some choices that would cause the design
to fail.  The benefit of formal, however, is that it will try every possible
combination in order to find one that will cause  your design to fail.
To you as a developer looking at the traces through your code, it might feel
like these values are chosen &lt;em&gt;randomly&lt;/em&gt;, although there’s actually a method
to this madness.&lt;/p&gt;

&lt;p&gt;Either way, the engine knows nothing about whether or not the design could
ever achieve the initial values it chooses.  It only knows whether or not any
of these violate any assumptions or assertions.&lt;/p&gt;

&lt;p&gt;For the first 31 steps of this test, the only constraint upon &lt;code class=&quot;highlighter-rouge&quot;&gt;sa&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;sb&lt;/code&gt; is
that their most significant bits are equal.  The engine has kept this true for
us.  Nothing in &lt;a href=&quot;/examples/kitest.v&quot;&gt;our example&lt;/a&gt;
constrains the rest of the shift register, either &lt;code class=&quot;highlighter-rouge&quot;&gt;sa[LN-2:0]&lt;/code&gt; or &lt;code class=&quot;highlighter-rouge&quot;&gt;sb[LN-2:0]&lt;/code&gt;,
so those values can be anything.&lt;/p&gt;

&lt;p&gt;Then, in step 31, the engine chooses to set &lt;code class=&quot;highlighter-rouge&quot;&gt;i_ce&lt;/code&gt; high.  This forces a
comparison between &lt;code class=&quot;highlighter-rouge&quot;&gt;sa[LN-1]&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;sb[LN-1]&lt;/code&gt; on step 32, where the comparison
(which is formed by our assertion) fails.&lt;/p&gt;

&lt;p&gt;This is obviously not what we want, so
what can we do to fix this?  The most obvious answer is to
assert that &lt;code class=&quot;highlighter-rouge&quot;&gt;sa==sb&lt;/code&gt;.  This is &lt;code class=&quot;highlighter-rouge&quot;&gt;FORMAL_TEST&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;3&#39;b010&lt;/code&gt;.  This test passes
very quickly, with little fanfare.  This works.&lt;/p&gt;

&lt;p&gt;What else might we do?&lt;/p&gt;

&lt;p&gt;Suppose we went back and examined our first test again, with our depth
set to 15 instead of 31.  You’ll need to adjust the depth option within the
&lt;a href=&quot;https://symbiyosys.readthedocs.io/en/latest&quot;&gt;SymbiYosys&lt;/a&gt;
&lt;a href=&quot;/examples/kitest.sby&quot;&gt;configuration script&lt;/a&gt;
to do this.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;depth 15&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;As before, we can pull up the trace to see what happened.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 4. Induction fails, where it succeeded before&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/kitest-0.png&quot; alt=&quot;&quot; width=&quot;918&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;In this trace, &lt;code class=&quot;highlighter-rouge&quot;&gt;sa&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;sb&lt;/code&gt; are different again.  This time,
though, the difference starts out in bit zero on the first timestep (not shown).
On every clock following, this one differing bit moves one step closer to our
assertion that the most significant bits of &lt;code class=&quot;highlighter-rouge&quot;&gt;sa&lt;/code&gt; and&lt;code class=&quot;highlighter-rouge&quot;&gt;sb&lt;/code&gt; are identical.  As
this assertion is applied in the first 15 steps, it is applied as an
assumption–forcing the fifteen most significant bits of &lt;code class=&quot;highlighter-rouge&quot;&gt;sa&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;sb&lt;/code&gt; to be
identical.  However, on step 16, the assertion
is treated not as an assumption but rather as a full-blown assertion.
This time it fails, because we never told the formal engine that bits zero
in both shift registers were initially identical.&lt;/p&gt;

&lt;p&gt;This suggests that this test will pass for a depth of 16.  Feel free to try
that one on your own.&lt;/p&gt;

&lt;p&gt;Now let’s move on and try &lt;code class=&quot;highlighter-rouge&quot;&gt;FORMAL_TEST&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;3&#39;b011&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;In this test, &lt;code class=&quot;highlighter-rouge&quot;&gt;i_ce&lt;/code&gt; is never allowed to be zero for two clocks in a row.
It is allowed to be true on every clock, or to alternate between true and
false, or some combination between the two.&lt;/p&gt;

&lt;p&gt;Let’s make one more change as well.  We’ll set the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Mathematical_induction&quot;&gt;induction&lt;/a&gt;
depth to 30 steps in &lt;a href=&quot;/examples/kitest.sby&quot;&gt;kitest.sby&lt;/a&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;depth 30&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This test also fails.&lt;/p&gt;

&lt;p&gt;As before, we can pull up the trace to see what happened.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 5. Induction fails, i_ce is now true every other step&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/kitest-3.png&quot; alt=&quot;&quot; width=&quot;915&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;This looks very much like the last test that failed: both failed because the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Mathematical_induction&quot;&gt;induction&lt;/a&gt; engine
allowed &lt;code class=&quot;highlighter-rouge&quot;&gt;sa&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;sb&lt;/code&gt; to start out with different least significant bit.&lt;/p&gt;

&lt;p&gt;The only thing that’s different here is &lt;code class=&quot;highlighter-rouge&quot;&gt;i_ce&lt;/code&gt;.  In this case, the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Mathematical_induction&quot;&gt;induction&lt;/a&gt;
engine has chosen to alternate &lt;code class=&quot;highlighter-rouge&quot;&gt;i_ce&lt;/code&gt; with high and low.
Why?  Because the alternating &lt;code class=&quot;highlighter-rouge&quot;&gt;i_ce&lt;/code&gt; value pushes the assertion regarding
this bit far enough forward in formal steps that the proof now fails.&lt;/p&gt;

&lt;p&gt;However, it failed on the &lt;em&gt;last&lt;/em&gt; step.  I know,
&lt;a href=&quot;https://en.wikipedia.org/wiki/Mathematical_induction&quot;&gt;induction&lt;/a&gt;
always only ever fails on its last step.  That’s not what I mean.  What I mean
is that if we just extend the search depth by one clock,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;depth 31&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;then this test will pass.&lt;/p&gt;

&lt;p&gt;The last test, &lt;code class=&quot;highlighter-rouge&quot;&gt;FORMAL_TEST&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;3&#39;b100&lt;/code&gt;, is very similar to test &lt;code class=&quot;highlighter-rouge&quot;&gt;3b011&lt;/code&gt;.  I’ll
leave this one as homework for you.&lt;/p&gt;

&lt;p&gt;I’ll also leave as homework for you the task of insisting that &lt;code class=&quot;highlighter-rouge&quot;&gt;i_ce&lt;/code&gt; is
true at least one of every eight clocks cycles.  How many induction steps will
that take to succeed?&lt;/p&gt;

&lt;p&gt;I like this example, because it does a good job fleshing out how the
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Mathematical_induction&quot;&gt;induction&lt;/a&gt; proof
works.&lt;/p&gt;

&lt;p&gt;Reality turns out to be very similar to this example, although it never looks
as simple.  In most of the designs I’ve worked with, there’s always been some
amount of state that I can’t quite capture with a proper &lt;code class=&quot;highlighter-rouge&quot;&gt;assert&lt;/code&gt; statement.
By using a longer
&lt;a href=&quot;https://en.wikipedia.org/wiki/Mathematical_induction&quot;&gt;induction&lt;/a&gt;
length, though, I can often force the state within my designs to flush itself.&lt;/p&gt;

&lt;p&gt;Even this doesn’t always work.&lt;/p&gt;

&lt;p&gt;You may remember &lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;my discussion of the formal
properties&lt;/a&gt;
of a &lt;a href=&quot;/doc/wbspec_b4.pdf&quot;&gt;wishbone
bus&lt;/a&gt;.  Nothing within &lt;a href=&quot;/doc/wbspec_b4.pdf&quot;&gt;the
specification&lt;/a&gt;
forces a slave to drop its &lt;code class=&quot;highlighter-rouge&quot;&gt;STALL&lt;/code&gt; output to accept a new request within a
given number of cycles.  Likewise, nothing within the specification forces
a slave to respond to the request by raising the &lt;code class=&quot;highlighter-rouge&quot;&gt;ACK&lt;/code&gt; signal within a
given number of clock cycles.  This creates a possibility where there may
be some amount of hidden state.  In order to deal with that possibility,
just like we forced &lt;code class=&quot;highlighter-rouge&quot;&gt;i_ce&lt;/code&gt; to be high at least one in &lt;code class=&quot;highlighter-rouge&quot;&gt;N&lt;/code&gt; clock cycles, &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/ex/fwb_master.v&quot;&gt;I
would force&lt;/a&gt;
the stall line, &lt;code class=&quot;highlighter-rouge&quot;&gt;STALL&lt;/code&gt;, to be dropped if it was ever asserted for too long.
In a similar fashion, &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/ex/fwb_slave.v&quot;&gt;I would
prevent&lt;/a&gt;
the slave from waiting too many clock cycles before acknowledging a request.&lt;/p&gt;

&lt;h2 id=&quot;other-approaches&quot;&gt;Other Approaches&lt;/h2&gt;

&lt;p&gt;If you have a chance to try some other formal engines, you may find they
work better in this example.
For example, the pdr engine,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt; 
[engines]
abc pdr&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;a href=&quot;https://arieg.bitbucket.io/avy&quot;&gt;avy&lt;/a&gt;,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt; 
[engines]
aiger avy&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;and &lt;a href=&quot;https://bitbucket.org/sterin/super_prove_build&quot;&gt;suprove&lt;/a&gt;&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt; 
[engines]
aiger suprove&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;don’t seem to struggle with this problem.&lt;/p&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Mathematical_induction&quot;&gt;Induction&lt;/a&gt;
may be the more difficult step of using
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal methods&lt;/a&gt;.
It need not be, but you need to understand how it works in order to understand
the reasons while it might fail.  The
&lt;a href=&quot;/examples/kitest.v&quot;&gt;example above&lt;/a&gt; is, in my estimation,
simple enough to show the difficulties with
&lt;a href=&quot;https://en.wikipedia.org/wiki/Mathematical_induction&quot;&gt;induction&lt;/a&gt;.
If you understand the details of
&lt;a href=&quot;/examples/kitest.v&quot;&gt;this example&lt;/a&gt;,
this example, you should be ready to fully formally prove
your own designs.&lt;/p&gt;
&lt;hr /&gt;&lt;p&gt;&lt;em&gt;And thine house and thy kingdom shall be established for ever before thee: thy throne shall be established for ever. (2Sam 7:16)&lt;/em&gt;</description>
        <pubDate>Sat, 10 Mar 2018 00:00:00 -0500</pubDate>
        <link>http://zipcpu.com/blog/2018/03/10/induction-exercise.html</link>
        <guid isPermaLink="true">http://zipcpu.com/blog/2018/03/10/induction-exercise.html</guid>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>Want to use ZBasic?  Let&#39;s have some fun--no actual FPGA required!</title>
        <description>&lt;p&gt;Now that
&lt;a href=&quot;/zipcpu/2018/01/31/cpu-build.html&quot;&gt;you’ve seen&lt;/a&gt; the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; by itself, and now that &lt;a href=&quot;/zipcpu/2018/01/31/cpu-build.html&quot;&gt;you’ve
built its tool chain&lt;/a&gt;,
let’s look at together at what you can do with the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
as part of a larger design:
&lt;a href=&quot;https://github.com/ZipCPU/zbasic&quot;&gt;ZBasic&lt;/a&gt;.
Today, I’d like to show you how to run the
&lt;a href=&quot;https://github.com/ZipCPU/zbasic&quot;&gt;ZBasic&lt;/a&gt;
design within a
&lt;a href=&quot;https://www.veripool.org/wiki/verilator&quot;&gt;Verilator&lt;/a&gt;-based
simulation environment–one that simulates
a &lt;a href=&quot;https://www.opencores.org/project,wbqspiflash&quot;&gt;QSPI flash&lt;/a&gt;, a
&lt;a href=&quot;https://github.com/ZipCPU/wbuart32&quot;&gt;serial port&lt;/a&gt;, and even
(optionally) an
&lt;a href=&quot;https://github.com/ZipCPU/sdspi/blob/master/bench/cpp/sdspisim.cpp&quot;&gt;SD-Card&lt;/a&gt;.
If all goes well, we’ll run the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;’s
&lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/sw/board/cputest.c&quot;&gt;CPU-Test program&lt;/a&gt;,
and then even play
&lt;a href=&quot;https://github.com/ZipCPU/tttt&quot;&gt;4x4x4 Tic-tac-toe&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;But first, let’s start with a little history.&lt;/p&gt;

&lt;h2 id=&quot;why-zbasic&quot;&gt;Why ZBasic?&lt;/h2&gt;

&lt;p&gt;When I first started out with the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;,
my goal was to demonstrate it on a cheap hobbyist board.  After my first
development, on a &lt;a href=&quot;https://store.digilentinc.com&quot;&gt;Digilent&lt;/a&gt;
&lt;a href=&quot;https://store.digilentinc.com/basys-3-artix-7-fpga-trainer-board-recommended-for-introductory-users&quot;&gt;Basys-3&lt;/a&gt;,
I then built demonstrations for an
&lt;a href=&quot;http://www.xess.com&quot;&gt;Xess.com&lt;/a&gt;
&lt;a href=&quot;http://www.xess.com/shop/product/xula2-lx25&quot;&gt;XuLA2-LX25 board&lt;/a&gt;,
and then the
&lt;a href=&quot;https://store.digilentinc.com&quot;&gt;Digilent&lt;/a&gt;
&lt;a href=&quot;https://store.digilentinc.com/cmod-s6-breadboardable-spartan-6-fpga-module&quot;&gt;CMod S6&lt;/a&gt;, the
&lt;a href=&quot;https://store.digilentinc.com/arty-artix-7-fpga-development-board-for-makers-and-hobbyists&quot;&gt;Arty&lt;/a&gt;,
and most recently
&lt;a href=&quot;https://store.digilentinc.com/nexys-video-artix-7-fpga-trainer-board-for-multimedia-applications&quot;&gt;Nexys Video&lt;/a&gt;
boards.
You can still find most of these builds on-line in the
&lt;a href=&quot;https://github.com/ZipCPU/xulalx25soc&quot;&gt;XuLALX25SoC&lt;/a&gt;,
&lt;a href=&quot;https://github.com/ZipCPU/s6soc&quot;&gt;S6SoC&lt;/a&gt;,
&lt;a href=&quot;https://github.com/ZipCPU/openarty&quot;&gt;OpenArty&lt;/a&gt;, and
&lt;a href=&quot;https://github.com/ZipCPU/videozip&quot;&gt;VideoZip&lt;/a&gt; repositories.  Indeed, my
&lt;a href=&quot;https://github.com/ZipCPU&quot;&gt;main Github page&lt;/a&gt; still highlights the
&lt;a href=&quot;https://github.com/ZipCPU/openarty&quot;&gt;OpenArty&lt;/a&gt; project.
Many of these boards are peripheral rich, and even for those that aren’t I
purchased peripherals (mostly from
&lt;a href=&quot;https://store.digilentinc.com&quot;&gt;Digilent&lt;/a&gt;) to have something fun and new to
work with on each board.  I have found it to be a fun exercise to learn how
to build the RTL code to support a new peripheral and I would commend that
exercise to every RTL student.&lt;/p&gt;

&lt;p&gt;I then ran into the problem of supporting someone who didn’t have the
peripherals I had.  How could or should they use the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;,
if their hardware didn’t match the hardware of one of the demonstration designs?&lt;/p&gt;

&lt;p&gt;So, I backed up and took a look at all the designs I had.  Almost all of them
had some type of serial
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt;,
some amount of block RAM, and a serial port.
Why not then make a design that had &lt;em&gt;only&lt;/em&gt; these peripherals?&lt;/p&gt;

&lt;p&gt;That was, and still is, the purpose of the
&lt;a href=&quot;https://github.com/ZipCPU/zbasic&quot;&gt;ZBasic&lt;/a&gt;
design.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 1. ZBasic Components and Peripherals&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/zbasic-blok.svg&quot; alt=&quot;&quot; width=&quot;730&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Because &lt;a href=&quot;https://github.com/ZipCPU/zbasic&quot;&gt;the design&lt;/a&gt;
is intended to be generic, it has no
&lt;a href=&quot;https://en.wikipedia.org/wiki/Synchronous_dynamic_random-access_memory&quot;&gt;SDRAM&lt;/a&gt;,
nor any &lt;a href=&quot;https://en.wikipedia.org/wiki/DDR3_SDRAM&quot;&gt;DDR3 SDRAM&lt;/a&gt;,
nor any other type of external RAM chip.
These interfaces tend to be board specific, and I wanted
this distribution to be as basic and as simple as possible.  What that means,
though, is that the main
&lt;a href=&quot;https://github.com/ZipCPU/zbasic&quot;&gt;ZBasic&lt;/a&gt;
design requires 1MB of on-chip block RAM.  Well, “requires” is a harsh word,
what I mean to say is that the design as currently configured on
&lt;a href=&quot;https://github.com/ZipCPU/zbasic&quot;&gt;github&lt;/a&gt; will try to infer 1MB of block RAM.
While few chips have this much RAM, it allows the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;,
within the
&lt;a href=&quot;https://github.com/ZipCPU/zbasic&quot;&gt;ZBasic&lt;/a&gt;
design to have access to an abundance of RAM without worrying about the
interface to the RAM.  Even better, this amount of RAM can be easily
changed using
&lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt;,
by changing only one number in the
&lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt;,
&lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/auto-data/bkram.txt&quot;&gt;block RAM config
file&lt;/a&gt;
and then rebuilding the design (i.e. &lt;code class=&quot;highlighter-rouge&quot;&gt;make autodata&lt;/code&gt;).
If that’s not enough, by just adding your own user code and
&lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt;
configuration file, you can add whatever additional hardware to the
&lt;a href=&quot;https://github.com/ZipCPU/zbasic&quot;&gt;ZBasic&lt;/a&gt;
distribution you want–&lt;a href=&quot;https://en.wikipedia.org/wiki/Synchronous_dynamic_random-access_memory&quot;&gt;SDRAM&lt;/a&gt;s included.&lt;/p&gt;

&lt;p&gt;Okay, enough reminiscing, let’s discuss how to use the
&lt;a href=&quot;https://github.com/ZipCPU/zbasic&quot;&gt;ZBasic&lt;/a&gt;
design within a
&lt;a href=&quot;https://www.veripool.org/wiki/verilator&quot;&gt;Verilator&lt;/a&gt;-based
simulation.&lt;/p&gt;

&lt;h2 id=&quot;building-zbasic&quot;&gt;Building ZBasic&lt;/h2&gt;

&lt;p&gt;Your first task in using the
&lt;a href=&quot;https://github.com/ZipCPU/zbasic&quot;&gt;ZBasic&lt;/a&gt;
design will be &lt;a href=&quot;/zipcpu/2018/01/31/cpu-build.html&quot;&gt;building the
toolchain&lt;/a&gt;
for the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;:
&lt;a href=&quot;https://www.gnu.org/software/binutils&quot;&gt;binutils&lt;/a&gt;
&lt;a href=&quot;https://www.gcc.org&quot;&gt;GCC&lt;/a&gt;
and &lt;a href=&quot;https://sourceware.org/newlib&quot;&gt;newlib&lt;/a&gt;.
I’ll assume you’ve already done that, if not you’ll need to
&lt;a href=&quot;/zipcpu/2018/01/31/cpu-build.html&quot;&gt;back up a step&lt;/a&gt;.
I’m also going to assume that the toolchain is in your path, as we discussed
&lt;a href=&quot;/zipcpu/2018/01/31/cpu-build.html&quot;&gt;when building it&lt;/a&gt;.
The next step is to clone the
&lt;a href=&quot;https://github.com/ZipCPU/zbasic&quot;&gt;ZBasic&lt;/a&gt;
repository and build it.  Since this repository doesn’t include a copy of
&lt;a href=&quot;https://www.gcc.org&quot;&gt;GCC&lt;/a&gt;,
it’s fairly light and a straightforward clone will work.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;git clone https://github.com/ZipCPU/zbasic
&lt;span class=&quot;nb&quot;&gt;cd &lt;/span&gt;zbasic
make&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Voila!  You have a ready built
&lt;a href=&quot;https://www.veripool.org/wiki/verilator&quot;&gt;Verilator&lt;/a&gt;-based
project ready to run!  (Please create an issue on
&lt;a href=&quot;https://github.com/ZipCPU/zbasic&quot;&gt;Github&lt;/a&gt;
if you have problems, and this doesn’t work.)&lt;/p&gt;

&lt;p&gt;Shall we run our first test?  This test will require two windows, and a little
bit of timing to do right.  In your first window, go ahead an type the
following–but don’t hit return on that last line yet or you might miss some
of the simulation output.  This will run the main simulation “test-bench”
wrapper, and apply it to my (&lt;a href=&quot;/zipcpu/2018/01/31/cpu-build.html&quot;&gt;more
modern&lt;/a&gt;) &lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/sw/board/cputest.c&quot;&gt;CPU test
software&lt;/a&gt;–once
you hit return (don’t do it yet).&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span class=&quot;nb&quot;&gt;cd &lt;/span&gt;sim/verilated
./main_tb ../../sw/board/cputest&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;In your second window, type the following–but don’t hit return.  When you do
(eventually) hit return, this will connect you to the running
&lt;a href=&quot;https://github.com/ZipCPU/zbasic&quot;&gt;ZBasic&lt;/a&gt;
simulation.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;telnet localhost 8846&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Ok, now you can hit return in the first window and then the second.  You
should see the results of the &lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/sw/board/cputest.c&quot;&gt;CPU
test&lt;/a&gt;,
such as Fig 2 illustrates.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 2. ZBasic CPU Test Results&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/zbasic-cpu-test.png&quot; alt=&quot;&quot; width=&quot;563&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;If you had wanted, you could also turn on
&lt;a href=&quot;/blog/2017/07/31/vcd.html&quot;&gt;VCD file&lt;/a&gt;
&lt;a href=&quot;/blog/2017/06/21/looking-at-verilator.html&quot;&gt;generation&lt;/a&gt;
by using the &lt;code class=&quot;highlighter-rouge&quot;&gt;-d&lt;/code&gt; flag, and so trace every wire throughout the whole design as
it moves through this
&lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/sw/board/cputest.c&quot;&gt;CPU test&lt;/a&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;./main_tb -d ../../sw/board/cputest&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Be aware, however, there’s a reason this option is turned off by default: your
&lt;a href=&quot;/blog/2017/07/31/vcd.html&quot;&gt;VCD file&lt;/a&gt; could easily top 11GB.&lt;/p&gt;

&lt;p&gt;Alternatively, you could have just started the design on its own without
giving a program to the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;.
As the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
is configured within the
&lt;a href=&quot;https://github.com/ZipCPU/zbasic&quot;&gt;ZBasic&lt;/a&gt;
design, it starts up in a halted configuration.  (This is optional–it can be
configured to start immediately on power up–see the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/raw/master/doc/spec.pdf&quot;&gt;spec&lt;/a&gt;
for more details.)  If you give a program name as an argument, the
&lt;a href=&quot;/blog/2017/06/21/looking-at-verilator.html&quot;&gt;simulation wrapper&lt;/a&gt;
will load the program into memory and then clear the &lt;a href=&quot;/zipcpu/2017/08/25/hw-debugging.html&quot;&gt;halt bit from the
debugging interface&lt;/a&gt;.
On the other hand, if you give the simulation driver no program name,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;./main_tb&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;then you’ll need to load the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;’s
program into memory–just as you would need to do on actual
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
hardware.  This is done with the
&lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/sw/host/zipload.cpp&quot;&gt;zipload&lt;/a&gt;
program found in the
&lt;a href=&quot;https://github.com/ZipCPU/zbasic/tree/master/sw/board/&quot;&gt;sw/board&lt;/a&gt;
subdirectory.  We’ll also give this program the ‘-r’ switch, to indicate that
the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
should be started once the program is loaded into memory.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span class=&quot;nb&quot;&gt;cd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;path-to-zbasic]/sw/host
./zipload -r ../sw/board/cputest&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This does take a while, though, since we are first programming the &lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/sim/verilated/qspiflashsim.cpp&quot;&gt;simulated
flash&lt;/a&gt;
on board, and only then starting the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt;.  The
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt;
will then copy its machine code from
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt;,
to RAM, and run.&lt;/p&gt;

&lt;p&gt;There you have it!  You’ve just run your first
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
program in a (nearly)
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
representative environment.&lt;/p&gt;

&lt;h2 id=&quot;playing-tic-tac-toe&quot;&gt;Playing Tic-Tac-Toe&lt;/h2&gt;

&lt;p&gt;Ok, so you’ve run a
&lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/sw/board/cputest.c&quot;&gt;CPU test&lt;/a&gt;.
I know, &lt;strong&gt;BORING&lt;/strong&gt;!  So let’s try and have a little more fun.  Let’s now
play &lt;a href=&quot;https://github.com/ZipCPU/tttt&quot;&gt;4x4x4 tic-tac-toe&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Unlike the
&lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/sw/board/cputest.c&quot;&gt;CPU test&lt;/a&gt;,
which &lt;em&gt;only&lt;/em&gt; tests the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt; itself,
&lt;a href=&quot;https://github.com/ZipCPU/tttt&quot;&gt;4x4x4 tic-tac-toe&lt;/a&gt;
uses the
&lt;a href=&quot;https://en.wikipedia.org/wiki/C_standard_library&quot;&gt;C-library&lt;/a&gt;
as well, with such typical library system calls as &lt;code class=&quot;highlighter-rouge&quot;&gt;printf&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;fgets&lt;/code&gt;.
These calls get routed, via a &lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/sw/zlib/syscalls.c&quot;&gt;board specific glue
file&lt;/a&gt;
to the
&lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/sim/verilated/dbluartsim.cpp&quot;&gt;simulated serial port&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;To try this out, change directory into the &lt;code class=&quot;highlighter-rouge&quot;&gt;sw/board&lt;/code&gt; directory, and build
&lt;code class=&quot;highlighter-rouge&quot;&gt;tttt&lt;/code&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span class=&quot;nb&quot;&gt;cd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;path-to-zbasic]/sw/board
make tttt&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;If you get errors, relax.  The “make” command won’t build
&lt;a href=&quot;https://github.com/ZipCPU/tttt&quot;&gt;tttt (4x4x4 tic-tac-toe)&lt;/a&gt;
successfully yet, but it should clone
&lt;a href=&quot;https://github.com/ZipCPU/tttt&quot;&gt;tttt&lt;/a&gt; as a submodule into a subdirectory of the
&lt;a href=&quot;https://github.com/ZipCPU/zbasic/tree/master/sw/board&quot;&gt;sw/board&lt;/a&gt;
directory.&lt;/p&gt;

&lt;p&gt;If it doesn’t clone
&lt;a href=&quot;https://github.com/ZipCPU/tttt&quot;&gt;tttt&lt;/a&gt; (I’ve had mixed success with git
submodules so far–all probably due to a problem lying somewhere between my
keyboard and my chair …), feel free to clone
&lt;a href=&quot;https://github.com/ZipCPU/tttt&quot;&gt;tttt&lt;/a&gt;
right there in that directory.&lt;/p&gt;

&lt;p&gt;Once you have it cloned, you’ll need to adjust a couple of lines within the
&lt;a href=&quot;https://github.com/ZipCPU/tttt/blob/master/src/Makefile&quot;&gt;sw/board/tttt/src/Makefile&lt;/a&gt;
to tell
&lt;a href=&quot;https://github.com/ZipCPU/tttt&quot;&gt;tttt&lt;/a&gt; where the
&lt;a href=&quot;https://en.wikipedia.org/wiki/C_standard_library&quot;&gt;C-library&lt;/a&gt;
is.  Therefore, open the
&lt;a href=&quot;https://github.com/ZipCPU/tttt/blob/master/src/Makefile&quot;&gt;Makefile&lt;/a&gt;
in your favorite editor and replace the lines,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-make&quot; data-lang=&quot;make&quot;&gt;&lt;span class=&quot;err&quot;&gt;ifeq&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;($(ARCH),&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;zip)&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;XLIBD&lt;/span&gt;    &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; ../../branch8b/sw/zlib
&lt;span class=&quot;nv&quot;&gt;XLIBS&lt;/span&gt;    &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; -L&lt;span class=&quot;nv&quot;&gt;$(XLIBD)&lt;/span&gt; -Wl,--start-group -Wl,--Map&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;zip-tttt.map -larty
&lt;span class=&quot;nv&quot;&gt;LDSCRIPT&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$(XLIBD)&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;/../board/arty.ld&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;with these lines,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-make&quot; data-lang=&quot;make&quot;&gt;&lt;span class=&quot;err&quot;&gt;ifeq&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;($(ARCH),&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;zip)&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;XLIBD&lt;/span&gt;    &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; ../../../zlib
&lt;span class=&quot;nv&quot;&gt;XLIBS&lt;/span&gt;    &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; -L&lt;span class=&quot;nv&quot;&gt;$(XLIBD)&lt;/span&gt; -Wl,--start-group -Wl,--Map&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;zip-tttt.map -lzbasic -lc
&lt;span class=&quot;nv&quot;&gt;LDSCRIPT&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$(XLIBD)&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;/../board/board.ld&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;At this point, you should just be able to build
&lt;a href=&quot;https://github.com/ZipCPU/tttt&quot;&gt;tttt&lt;/a&gt;
without further ado.  To do this, stay in the
&lt;a href=&quot;https://github.com/ZipCPU/zbasic/tree/master/sw/board&quot;&gt;sw/board&lt;/a&gt; directory
of the &lt;a href=&quot;https://github.com/ZipCPU/zbasic&quot;&gt;ZBasic&lt;/a&gt; project and type:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;make tttt&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This will make certain the cross-compiler environment variables are properly
set to build
&lt;a href=&quot;https://github.com/ZipCPU/tttt&quot;&gt;tttt&lt;/a&gt;
for the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;.
(If you had instead cd’d into &lt;code class=&quot;highlighter-rouge&quot;&gt;tttt&lt;/code&gt; and issued a &lt;code class=&quot;highlighter-rouge&quot;&gt;make&lt;/code&gt; command, it would
build &lt;code class=&quot;highlighter-rouge&quot;&gt;tttt&lt;/code&gt; for your local/host architecture.)&lt;/p&gt;

&lt;p&gt;Now we can play.  Ready?&lt;/p&gt;

&lt;p&gt;As before, we’ll type in the command to start the simulator in one window,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span class=&quot;nb&quot;&gt;cd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;path-to-zbasic]/sim/verilated
./main_tb ../../sw/board/tttt/src/zip-tttt&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;and connect to the simulated serial port from another window,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;telnet localhost 8846&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;When you hit return on the two (in sequence), the &lt;code class=&quot;highlighter-rouge&quot;&gt;telnet&lt;/code&gt; window will show
the following:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;Trying 127.0.0.1...
Connected to localhost.
Escape character is &#39;^]&#39;.

Welcome to 4x4x4 Tic-Tac-Toe

The goal of this game is to get 4 pieces in a row.  The board is three
dimensional, even though it will be displayed on a terminal screen.  Imagine
instead of seeing four 4x4 boards side by side, that these boards are
actually standing on top of each other.  A winning four in a row can exist
on any of the 4x4 levels.  A winning four in a row can also cross through
all levels.  Diagonals are valid, as are diagonal diagonals.

To specify your move, type in a string of three numbers each in the range of
1-4.  The first two numbers describe where you wish to move within one 4x4
board, where the first number is the position counting left to right and the
second number is the position counting from top down.  The last number is
which 4x4 board you wish to move to, counting from the 4x4 on the left to
the right

Current Board: (Empty)
----  ----  ----  ----  
----  ----  ----  ----  
----  ----  ----  ----  
----  ----  ----  ----  

Your move : &lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;You should be able to just type your move in as a series of three numbers,
each 1-4, as in &lt;code class=&quot;highlighter-rouge&quot;&gt;1 1 1&lt;/code&gt;.  Have fun!&lt;/p&gt;

&lt;p&gt;Be careful, although the computer isn’t unbeatable, he does play a pretty
mean game!&lt;/p&gt;

&lt;h2 id=&quot;homework&quot;&gt;Homework&lt;/h2&gt;

&lt;p&gt;Care for some
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;
homework?  Here’s a fascinating test you can try with the
&lt;a href=&quot;https://github.com/ZipCPU/zbasic&quot;&gt;ZBasic&lt;/a&gt;
distribution, one that will help to illustrate how important having a
hardware memory copy capability is.&lt;/p&gt;

&lt;p&gt;The glue logic supporting the
&lt;a href=&quot;https://en.wikipedia.org/wiki/C_standard_library&quot;&gt;C-library&lt;/a&gt;
includes a file called
&lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/sw/zlib/crt0.c&quot;&gt;crt0.c&lt;/a&gt;.
For most
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;’s this is an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Assembly_language&quot;&gt;assembly language&lt;/a&gt;
file called crt0.s.  Not for the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;.  For the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;,
this file is written in C.  It contains two routines: &lt;code class=&quot;highlighter-rouge&quot;&gt;_start&lt;/code&gt; and
&lt;code class=&quot;highlighter-rouge&quot;&gt;_bootloader&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The first routine, &lt;code class=&quot;highlighter-rouge&quot;&gt;_start&lt;/code&gt; starts the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
by setting the stack pointer to the end of memory, and then jumping to a
function called &lt;code class=&quot;highlighter-rouge&quot;&gt;_bootloader&lt;/code&gt;.  This is really an
&lt;a href=&quot;/zipcpu/2018/01/01/zipcpu-isa.html&quot;&gt;assembly language&lt;/a&gt;
routine with a thin veneer of a C wrapper, but it’s placed within the
&lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/sw/zlib/crt0.c&quot;&gt;crt0.c&lt;/a&gt;
file anyway.  When you strip away the cruft, it basicaly reads as,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-asm&quot; data-lang=&quot;asm&quot;&gt;_start:		; Here&#39;s the global ZipCPU entry point upon reset/reboot
	LDI	_top_of_stack,SP	; Set up our supervisor stack ptr
	MOV	_kernel_is_dead(PC),uPC	; Set user PC pointer to somewhere valid
	JSR	_bootloader	; JSR to the bootloader routine
	OR	0x4000,CC	; Clear the data cache
        //
	CLR	R1		; argc = 0
	MOV	_argv(PC),R2	; argv = &amp;amp;0
	LDI	__env,R3	; env = NULL
	JSR	main		; Call the user main() function
        //
_graceful_kernel_exit:		; Halt on any return from main--gracefully
	JSR	exit		; Call the _exit as part of exiting
_hw_shutdown:
	NEXIT	R1		; If in simulation, call an exit function
_kernel_is_dead:		; Halt the CPU\n&quot;
	HALT			;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The second routine within
&lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/sw/zlib/crt0.c&quot;&gt;this file&lt;/a&gt;
is the &lt;code class=&quot;highlighter-rouge&quot;&gt;_bootloader&lt;/code&gt; routine that is called from the &lt;code class=&quot;highlighter-rouge&quot;&gt;_start&lt;/code&gt; function above.
This is the routine I’d like to demonstrate for this homework lesson.&lt;/p&gt;

&lt;p&gt;The &lt;code class=&quot;highlighter-rouge&quot;&gt;_bootloader&lt;/code&gt; function itself is really nothing more than a series of
memory copy routines.  These are based around a couple of assumptions.  First,
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt;
is non-volatile (i.e. like a ROM) and so upon startup instructions can
be found there.  The second assumption is that the block RAM is faster than
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt;.
Hence, we want to move our instructions (and data) from
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt;
into block RAM before starting any program.&lt;/p&gt;

&lt;p&gt;First, the &lt;code class=&quot;highlighter-rouge&quot;&gt;_bootloader&lt;/code&gt; copies memory from the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt;
into block RAM.  This section is framed by an
&lt;code class=&quot;highlighter-rouge&quot;&gt;#ifdef _BOARD_HAS_KERNEL_SPACE&lt;/code&gt;,  so that any
high priority (kernel) functions would be or could be placed into block RAM.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;	&lt;span class=&quot;nf&quot;&gt;_booloader&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;// ...
&lt;/span&gt;
&lt;span class=&quot;cp&quot;&gt;#ifdef  _BOARD_HAS_KERNEL_SPACE
&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;rdp&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_kernel_image_start&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;wrp&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_bkram&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_kernel_image_end&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_kernel_image_start&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;do&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
			&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;wrp&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rdp&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;wrp&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_kernel_image_end&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_kernel_image_end&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_sdram&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;wrp&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_sdram&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;cp&quot;&gt;#else
&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;rdp&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_ram_image_start&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;wrp&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_ram&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;cp&quot;&gt;#endif&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Second, the bootloader copies from
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Synchronous_dynamic_random-access_memory&quot;&gt;SDRAM&lt;/a&gt;
into any
&lt;a href=&quot;https://en.wikipedia.org/wiki/Synchronous_dynamic_random-access_memory&quot;&gt;SDRAM&lt;/a&gt;
the board might have,
as defined by the &lt;code class=&quot;highlighter-rouge&quot;&gt;_sdram&lt;/code&gt; pointer.  Since
&lt;a href=&quot;https://github.com/ZipCPU/zbasic&quot;&gt;ZBasic&lt;/a&gt;
doesn’t have any
&lt;a href=&quot;https://en.wikipedia.org/wiki/Synchronous_dynamic_random-access_memory&quot;&gt;SDRAM&lt;/a&gt;,
this second memory copy ends up continuing the write into block RAM
instead.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;        &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;wrp&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_ram_image_end&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
		&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;wrp&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rdp&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The third section of memory is the BSS section.  This is a memory section
whose initial contents are all zeros.  The &lt;code class=&quot;highlighter-rouge&quot;&gt;_bootloader&lt;/code&gt; fulfills this
commitment by writing zeros to all of the memory location within this
section.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;	&lt;span class=&quot;c1&quot;&gt;// ...
&lt;/span&gt;	&lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;wrp&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_bss_image_end&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
		&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;wrp&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;However, if you look inside the
&lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/sw/zlib/crt0.c&quot;&gt;crt0.c&lt;/a&gt;
file, you’ll actually see two choices
for how to handle these memory copies.  The first choice is applied if
&lt;code class=&quot;highlighter-rouge&quot;&gt;USE_DMA&lt;/code&gt; is defined.  This is set earlier in the file to be true only if
&lt;code class=&quot;highlighter-rouge&quot;&gt;_HAVE_ZIPSYS_DMA&lt;/code&gt; is defined–something that comes from the
&lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/rtl/cpu/cpudefs.v&quot;&gt;cpudefs.v&lt;/a&gt;
configuration file.&lt;/p&gt;

&lt;p&gt;For this homework assignment, turn on tracing with the &lt;code class=&quot;highlighter-rouge&quot;&gt;-d&lt;/code&gt; flag (you do have
a rough 4GB available, right?) and run the
&lt;a href=&quot;https://github.com/ZipCPU/tttt&quot;&gt;4x4x4 tic-tac-toe program (tttt)&lt;/a&gt;
again.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span class=&quot;nb&quot;&gt;cd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;path-to-zbasic]/sim/verilated
./main_tb -d ../../sw/board/tttt/src/zip-tttt&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;To keep it from taking up too much room on your
hard-drive, kill it as soon as the game instructions start coming up (i.e.
type Ctrl-C on the screen where you typed &lt;code class=&quot;highlighter-rouge&quot;&gt;main_tb -d ...&lt;/code&gt;).
Copy the &lt;a href=&quot;/blog/2017/07/31/vcd.html&quot;&gt;trace file&lt;/a&gt;
from &lt;code class=&quot;highlighter-rouge&quot;&gt;trace.vcd&lt;/code&gt; to &lt;code class=&quot;highlighter-rouge&quot;&gt;with-dma.vcd&lt;/code&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;mv trace.vcd with-dma.vcd&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Then comment the &lt;code class=&quot;highlighter-rouge&quot;&gt;USE_DMA&lt;/code&gt; define in
&lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/sw/zlib/crt0.c&quot;&gt;crt0.c&lt;/a&gt; by
placing two &lt;code class=&quot;highlighter-rouge&quot;&gt;//&lt;/code&gt;s at the beginning of the line,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span class=&quot;o&quot;&gt;//&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;define&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;USE_DMA&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;You can then rebuild in
&lt;a href=&quot;https://github.com/ZipCPU/zbasic/tree/master/sw/zlib/&quot;&gt;sw/zlib&lt;/a&gt; by typing
&lt;code class=&quot;highlighter-rouge&quot;&gt;make&lt;/code&gt; in that directory, but you’ll need to do a &lt;code class=&quot;highlighter-rouge&quot;&gt;make clean&lt;/code&gt; in
&lt;a href=&quot;https://github.com/ZipCPU/zbasic/tree/master/sw/board/&quot;&gt;sw/board&lt;/a&gt;
before you can re-issue &lt;code class=&quot;highlighter-rouge&quot;&gt;make&lt;/code&gt; again there.  Once done, you can issue a
&lt;code class=&quot;highlighter-rouge&quot;&gt;make&lt;/code&gt; in
&lt;a href=&quot;https://github.com/ZipCPU/zbasic/tree/master/sw/board/&quot;&gt;sw/board&lt;/a&gt;
and then &lt;code class=&quot;highlighter-rouge&quot;&gt;make tttt&lt;/code&gt;.  This will propagate this change throughout the
&lt;a href=&quot;https://en.wikipedia.org/wiki/C_standard_library&quot;&gt;C-library&lt;/a&gt;
and into the application software.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span class=&quot;nb&quot;&gt;cd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;path-to-zbasic]/sw/zlib
make
&lt;span class=&quot;nb&quot;&gt;cd&lt;/span&gt; ../sw/board
make clean
make
make tttt&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Now run the simulator again, still with the -d option.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span class=&quot;nb&quot;&gt;cd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;path-to-zbasic]/sim/verilated
main_tb -d ../../sw/board/tttt/src/zip-tttt&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Kill it (Ctrl-C) as before when the characters start getting printed to the
terminal.  Then rename the &lt;code class=&quot;highlighter-rouge&quot;&gt;trace.vcd&lt;/code&gt; file to be &lt;code class=&quot;highlighter-rouge&quot;&gt;without-dma.vcd&lt;/code&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;mv trace.vcd without-dma.vcd&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Now that you have two comparison files, pull them both up in
&lt;a href=&quot;https://gtkwave.sourceforge.net&quot;&gt;GtkWave&lt;/a&gt;.
Let’s look specifically at the
serial output line &lt;code class=&quot;highlighter-rouge&quot;&gt;o_wbu_uart_tx&lt;/code&gt; from the top level, and then from
within the top level, the
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;wishbone strobe
line &lt;code class=&quot;highlighter-rouge&quot;&gt;wb_stb&lt;/code&gt;&lt;/a&gt;, the
&lt;code class=&quot;highlighter-rouge&quot;&gt;flash_sel&lt;/code&gt; (&lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt;
select) line, and then &lt;code class=&quot;highlighter-rouge&quot;&gt;bkram_sel&lt;/code&gt; (block RAM select)
lines.  As you may recall, &lt;code class=&quot;highlighter-rouge&quot;&gt;wb_stb&lt;/code&gt; will be true anytime a request is being
made across the bus.  The other two lines indicate when the address
associated with this request is either referencing the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt;
or the block RAM.&lt;/p&gt;

&lt;p&gt;See a difference?&lt;/p&gt;

&lt;p&gt;Here’s my figure for running without the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/wbdmac.v&quot;&gt;DMA&lt;/a&gt;,&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 3. ZBasic Bootloader without DMA&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/zbasic-wodma.png&quot; alt=&quot;&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;and again for running with the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/wbdmac.v&quot;&gt;DMA&lt;/a&gt;
controller,&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 4. ZBasic Components and Peripherals&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/zbasic-wdma.png&quot; alt=&quot;&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;If you look at the far right, when &lt;code class=&quot;highlighter-rouge&quot;&gt;o_wbu_uart_tx&lt;/code&gt; starts toggling that’s when
the first characters of the game are being sent to the serial port.  This
doesn’t happen until the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;_bootloader&lt;/code&gt; has finished.  Here, you can see that it takes about nine
seconds to copy everything from
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt;
when using the &lt;code class=&quot;highlighter-rouge&quot;&gt;_bootloader&lt;/code&gt;, whereas it
takes over twenty seconds without!  You can also see a big difference in the
&lt;code class=&quot;highlighter-rouge&quot;&gt;flash_sel&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;bkram_sel&lt;/code&gt; lines.  What’s going on there?&lt;/p&gt;

&lt;p&gt;Let’s drill one level deeper and look at what’s going on by zooming in.
Let’s also add the &lt;code class=&quot;highlighter-rouge&quot;&gt;flash_ack&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;bkram_ack&lt;/code&gt; lines–there are the
wishbone acknowledgement
lines from these two peripherals, and indicate when a request has been
fulfilled.&lt;/p&gt;

&lt;p&gt;You can see the
&lt;a href=&quot;/blog/2017/07/31/vcd.html&quot;&gt;trace&lt;/a&gt;
without
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/wbdmac.v&quot;&gt;DMA&lt;/a&gt;,
in Fig 5, below.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 5. Zooming in on the ZBasic Bootloader without DMA&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/zbasic-wodma-zoom.png&quot; alt=&quot;&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;What’s not as readily apparent in this
&lt;a href=&quot;/blog/2017/07/31/vcd.html&quot;&gt;trace&lt;/a&gt;
is the context–it begins in the middle of a transaction.  A value has
already been requested from the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt;
controller by the time my screen capture starts.  Once the
&lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/rtl/wbqspiflash.v&quot;&gt;flash controller&lt;/a&gt;
acknowledges the transaction, that is when &lt;code class=&quot;highlighter-rouge&quot;&gt;flash_ack&lt;/code&gt; goes high, the data
becomes available to the &lt;code class=&quot;highlighter-rouge&quot;&gt;_bootloader&lt;/code&gt;,
and it immediately turns around and writes to the block RAM.  Since the
block RAM is quite fast, it acknowledges its transaction almost immediately.
(Remember, transaction requests only take place when &lt;code class=&quot;highlighter-rouge&quot;&gt;wb_stb&lt;/code&gt; is high, and
so Fig 6 only shows two transaction requests.)  The
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
then issues a read request of the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt;
and … everything stalls again waiting for the &lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/rtl/wbqspiflash.v&quot;&gt;flash
controller&lt;/a&gt;’s
acknowledgement.&lt;/p&gt;

&lt;p&gt;This is &lt;em&gt;very&lt;/em&gt; different from what happens when the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/wbdmac.v&quot;&gt;DMA&lt;/a&gt;,
is turned on.  For that case, you can see what happens when
in Fig 6 below.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 6. Zooming in on the ZBasic Bootloader, with the DMA in use&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/zbasic-wdma-zoom.png&quot; alt=&quot;&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;In this case, the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/wbdmac.v&quot;&gt;DMA&lt;/a&gt;
reads multiple items from the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt;
in a back to back
fashion–you can see all of the acknowledgement’s in the &lt;code class=&quot;highlighter-rouge&quot;&gt;flash_ack&lt;/code&gt; line
in Fig 6.  During this time, the block RAM is idle.  Once the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/wbdmac.v&quot;&gt;DMA&lt;/a&gt;
has finished
reading a rough 1k words from the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt;,
it then bursts these to the block
RAM.  Look at the &lt;code class=&quot;highlighter-rouge&quot;&gt;wb_stb&lt;/code&gt; line to see this–it’s nearly a constant &lt;code class=&quot;highlighter-rouge&quot;&gt;ON&lt;/code&gt;
signal, indicating that one request after another is being made.  In a
similar fashion, but unlike the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/rtl/wbqspiflash.v&quot;&gt;controller&lt;/a&gt;’s
response, the block RAM’s acknowledgment signal is also a constant high–since
the block RAM can respond to one request per clock.
As a result, this portion of the copy goes by very quickly.&lt;/p&gt;

&lt;p&gt;Given this information, would you rather copy your data using the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/wbdmac.v&quot;&gt;DMA&lt;/a&gt;,
or a tight loop within the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;?&lt;/p&gt;

&lt;h2 id=&quot;how-do-i-change-the-amount-of-block-ram&quot;&gt;How do I change the amount of block RAM?&lt;/h2&gt;

&lt;p&gt;Since I know this is going to come up, let me show you how easy it is to
change the amount of block RAM in this device.&lt;/p&gt;

&lt;p&gt;First, look in the
&lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt; &lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/auto-data/bkram.txt&quot;&gt;block ram configuration
file&lt;/a&gt;.
Within that file, find the line,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;@$LGMEMSZ=20&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This line defines a tag, &lt;code class=&quot;highlighter-rouge&quot;&gt;@LGMEMSZ&lt;/code&gt;, specifies that it is a numerical
tag with the &lt;code class=&quot;highlighter-rouge&quot;&gt;@$&lt;/code&gt; prefix, and then gives it the value of &lt;code class=&quot;highlighter-rouge&quot;&gt;20&lt;/code&gt;.
This tag is used to specify that the log, based two, of the block RAM
memory size is twenty–meaning it should have 1MB, or &lt;code class=&quot;highlighter-rouge&quot;&gt;2^20&lt;/code&gt; bytes, of
block RAM.  The key itself is unique to this
&lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/auto-data/bkram.txt&quot;&gt;block ram configuration
file&lt;/a&gt;,
so you aren’t likely to find it elsewhere.  It basically defines a local
variable within an &lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt; context.
However, with a bit of math and some substitution (remember, 
&lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt; is primarily a
copy/paste utility with a calculator and address assignment built
in), this number becomes the amount of block RAM called for in the
system design.&lt;/p&gt;

&lt;p&gt;You can change this one number, and then run &lt;code class=&quot;highlighter-rouge&quot;&gt;make autodata&lt;/code&gt; from the main
directory (assuming you have
&lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt; installed and in your path),
and the design will immediately be reconfigured for the new memory size.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span class=&quot;nb&quot;&gt;cd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;path-to-zbasic]/
make autodata&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Yes, you’ll still need to run &lt;code class=&quot;highlighter-rouge&quot;&gt;make&lt;/code&gt; from the main directory again once
you’ve done this,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;make&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;so that this newly configured design has a chance to build.&lt;/p&gt;

&lt;p&gt;What changes?&lt;/p&gt;

&lt;p&gt;Well, first, the &lt;code class=&quot;highlighter-rouge&quot;&gt;@MAIN.INSERT&lt;/code&gt; tag that same
&lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/auto-data/bkram.txt&quot;&gt;bkram.txt&lt;/a&gt;
file is used to tell
&lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt; what to place into your
&lt;a href=&quot;/blog/2017/10/05/autofpga-intro.html&quot;&gt;main.v&lt;/a&gt;
file.  In this case, it’s a reference to a
&lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/rtl/memdev.v&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;memdev&lt;/code&gt;&lt;/a&gt;
module which implements a block RAM device that is parameterized by its size.
&lt;code class=&quot;highlighter-rouge&quot;&gt;@THIS.LGMEMSZ&lt;/code&gt; is used to control this parameter.  It’s also used to
connect that design parameter to the number of address lines fed to this
component, and changing this size may cause the other peripherals on the bus
to be shuffled around to minimize the required bus logic.&lt;/p&gt;

&lt;p&gt;Second, all of the addresses will (may) be re-assigned as I just mentioned.
This includes more than just the block RAM.  These new addresses can be found
listed in the
&lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/sw/host/regdefs.h&quot;&gt;regdefs.h&lt;/a&gt;
and
&lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/sw/board/board.h&quot;&gt;board.h&lt;/a&gt;
files based upon the &lt;code class=&quot;highlighter-rouge&quot;&gt;@REGS.*&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;@BDEF.OSVAL&lt;/code&gt; tags.&lt;/p&gt;

&lt;p&gt;Third, the &lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/sw/board/board.ld&quot;&gt;linker definition
script&lt;/a&gt;
will have changed, which will adjust the
&lt;code class=&quot;highlighter-rouge&quot;&gt;_bkram&lt;/code&gt; pointer used by the &lt;code class=&quot;highlighter-rouge&quot;&gt;_bootloader&lt;/code&gt; we discussed above.&lt;/p&gt;

&lt;p&gt;Fourth, the &lt;code class=&quot;highlighter-rouge&quot;&gt;@SIM.LOAD&lt;/code&gt; tag defines the software necessary to load a program
into this memory, given the new location and length found in the updated
&lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/sw/host/regdefs.h&quot;&gt;regdefs.h&lt;/a&gt;
file.&lt;/p&gt;

&lt;p&gt;The result of all of this is that, following an
&lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt;
based reconfigure, all that is required is to rebuild the project and
we have a new amount of memory at a (potentially) different location.&lt;/p&gt;

&lt;h2 id=&quot;next-steps&quot;&gt;Next Steps&lt;/h2&gt;

&lt;p&gt;Now that you know how to run the
&lt;a href=&quot;https://github.com/ZipCPU/zbasic&quot;&gt;ZBasic&lt;/a&gt;
demonstration, the next step
will be to show how simple and easy it is to add a
&lt;a href=&quot;https://github.com/ZipCPU/wbpmic&quot;&gt;new component&lt;/a&gt;
using
&lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt;,
and then to demonstrate how we can integrate this component into our
&lt;a href=&quot;/blog/2017/06/21/looking-at-verilator.html&quot;&gt;simulation&lt;/a&gt;
and ultimately the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
design as a whole.&lt;/p&gt;

&lt;p&gt;My current plan is to do this with the
&lt;a href=&quot;https://github.com/ZipCPU/wbpmic&quot;&gt;WBPMIC&lt;/a&gt;
component.  This particular controller is designed to control a &lt;a href=&quot;http://store.digilentinc.com/pmod-mic3-mems-microphone-with-adjustable-gain&quot;&gt;MEMs audio
microphone&lt;/a&gt;
and &lt;a href=&quot;https://en.wikipedia.org/wiki/Analog-to-digital_converter&quot;&gt;A/D&lt;/a&gt;
sold by &lt;a href=&quot;https://store.digilentinc.com&quot;&gt;Digilent&lt;/a&gt;–their
“&lt;a href=&quot;http://store.digilentinc.com/pmod-mic3-mems-microphone-with-adjustable-gain&quot;&gt;PMod MIC3&lt;/a&gt;”.&lt;/p&gt;

&lt;p&gt;That will be our next step in this series, although there’s really a lot
of information we can come back to–such as how the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/wbdmac.v&quot;&gt;DMA controller&lt;/a&gt;
works in the first place.&lt;/p&gt;
&lt;hr /&gt;&lt;p&gt;&lt;em&gt;Wilt thou play with him as with a bird? or wilt thou bind him for thy maidens? (Job 41:5)&lt;/em&gt;</description>
        <pubDate>Mon, 12 Feb 2018 00:00:00 -0500</pubDate>
        <link>http://zipcpu.com/zipcpu/2018/02/12/zbasic-intro.html</link>
        <guid isPermaLink="true">http://zipcpu.com/zipcpu/2018/02/12/zbasic-intro.html</guid>
        
        
        <category>zipcpu</category>
        
      </item>
    
      <item>
        <title>Debugging a Cyclone-V</title>
        <description>&lt;p&gt;If you’ve read the description of &lt;a href=&quot;/about/gisselquist-technology.html&quot;&gt;Gisselquist
Technology&lt;/a&gt;,
you’ll remember that &lt;a href=&quot;/about/gisselquist-technology.html&quot;&gt;Gisselquist
Technology&lt;/a&gt;
is a services business.  I use
&lt;a href=&quot;http://zipcpu.com/&quot;&gt;this blog&lt;/a&gt;
and my
&lt;a href=&quot;https://github.com/ZipCPU&quot;&gt;demonstration IP cores&lt;/a&gt;
to help attract customers.  It also means that I don’t necessarily advertise
all of the IP I’ve built on my
&lt;a href=&quot;/projects.html&quot;&gt;projects page&lt;/a&gt;–since
I’m not selling IP but rather my time and abilities.  I prefer not to comment
about the customers I work with, or what their various requirements
are–that’s their business.  I just provide them with a service.&lt;/p&gt;

&lt;p&gt;However, a recent project I’ve been working on is worth commenting on from
the standpoint of how to avoid
&lt;a href=&quot;/blog/2017/05/19/fpga-hell.html&quot;&gt;FPGA Hell&lt;/a&gt;
in a somewhat unique environment: the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
+ &lt;a href=&quot;https://en.wikipedia.org/wiki/ARM_architecture&quot;&gt;ARM&lt;/a&gt;
environment.  This is probably all the more appropriate, as these
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
+ &lt;a href=&quot;https://en.wikipedia.org/wiki/ARM_architecture&quot;&gt;ARM&lt;/a&gt;
chips are becoming more and more popular.&lt;/p&gt;

&lt;p&gt;The project in question was a basic data acquisition system: control &lt;em&gt;N&lt;/em&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Analog-to-digital_converter&quot;&gt;A/D&lt;/a&gt;s
running at over a MHz in speed, and spit the results out over Ethernet.
To make this project work, we chose to use the
&lt;a href=&quot;http://www.terasic.com/cgi-bin/page/archive.pl?Language=English&amp;amp;No=1046&quot;&gt;DE10-Nano&lt;/a&gt;
as our processing device, shown below.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 1. A DE10-Nano board, shown without the A/Ds attached&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/de10-deskpic.jpg&quot; alt=&quot;Picture of a DE10-Nano FPGA board from Terasic&quot; width=&quot;768&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;This also marks my first experience with an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
+ &lt;a href=&quot;https://en.wikipedia.org/wiki/ARM_architecture&quot;&gt;ARM&lt;/a&gt;
type device, and what it takes to interface logic with an on-board
&lt;a href=&quot;https://en.wikipedia.org/wiki/ARM_architecture&quot;&gt;hard processor&lt;/a&gt;, and I
thought I might share with you some of my experiences and the
lessons I learned.&lt;/p&gt;

&lt;h2 id=&quot;general-project-structure&quot;&gt;General Project Structure&lt;/h2&gt;

&lt;p&gt;You can see the general structure of the project in Fig 2 below.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 2. Design Structure&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/de10-design.svg&quot; alt=&quot;&quot; width=&quot;400&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;In brief, the
&lt;a href=&quot;https://en.wikipedia.org/wiki/ARM_architecture&quot;&gt;ARM processor&lt;/a&gt;
has a number of buses available to it, within the chip, to communicate
over.  I chose the light-weight bus from the
&lt;a href=&quot;https://en.wikipedia.org/wiki/ARM_architecture&quot;&gt;ARM&lt;/a&gt;
to the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
for its simplicity–although I may revisit this decision later.  I then used
&lt;a href=&quot;https://www.altera.com/products/design-software/fpga-design/quartus-prime/features/qts-platform-designer.html&quot;&gt;Qsys&lt;/a&gt;
(now called the “&lt;a href=&quot;https://www.altera.com/products/design-software/fpga-design/quartus-prime/features/qts-platform-designer.html&quot;&gt;Platform Designer&lt;/a&gt;”
, although few tutorials have been updated since the name change) to
connect my application specific design component(s) to an
&lt;a href=&quot;https://www.altera.com/content/dam/altera-www/global/en_US/pdfs/literature/manual/mnl_avalon_spec.pdf&quot;&gt;Avalon&lt;/a&gt;
memory-mapped I/O bus.&lt;/p&gt;

&lt;p&gt;This brings me to my own part of the design.  For this application specific
portion, I bridged from the
&lt;a href=&quot;https://www.altera.com/content/dam/altera-www/global/en_US/pdfs/literature/manual/mnl_avalon_spec.pdf&quot;&gt;Avalon bus&lt;/a&gt;
to a
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;Wishbone (WB) bus&lt;/a&gt;
(all my legacy code was written for
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;WB&lt;/a&gt;),
and used &lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt;
to assemble my
design components together–assigning addresses and handling the bus
interconnect within my own portion of the design.&lt;/p&gt;

&lt;p&gt;This became my
“&lt;a href=&quot;/blog/2017/06/16/dbg-bus-forest.html&quot;&gt;debugging bus&lt;/a&gt;”
as well for finding bugs within my design.&lt;/p&gt;

&lt;p&gt;Further, the
&lt;a href=&quot;https://www.altera.com/products/design-software/fpga-design/quartus-prime/features/qts-platform-designer.html&quot;&gt;Platform Designer&lt;/a&gt;
output is a big black box that I needed to create a wrapper for, connecting
the
&lt;a href=&quot;https://en.wikipedia.org/wiki/ARM_architecture&quot;&gt;ARM processor&lt;/a&gt;
to the external system components–&lt;a href=&quot;https://en.wikipedia.org/wiki/DDR3_SDRAM&quot;&gt;DDR3
SDRAM&lt;/a&gt;,
&lt;a href=&quot;https://en.wikipedia.org/wiki/Gigabit_Ethernet&quot;&gt;GigE&lt;/a&gt;
network, etc.&lt;/p&gt;

&lt;h2 id=&quot;so-what-was-the-process-for-finding-bugs&quot;&gt;So what was the process for finding bugs?&lt;/h2&gt;

&lt;p&gt;My bug finding approach follows directly from &lt;a href=&quot;/blog/2017/06/23/my-dbg-philosophy.html&quot;&gt;my basic debugging
philosophy&lt;/a&gt;.
However, the
&lt;a href=&quot;/blog/2017/06/23/my-dbg-philosophy.html&quot;&gt;basic philosophy&lt;/a&gt;
really needs to be slightly updated, since I’ve started using
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal methods&lt;/a&gt;.
Basically, I followed the following steps:&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 3. Design Process&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/cyclonev-design.svg&quot; alt=&quot;Steps in design with Cyclone-V&quot; width=&quot;180&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;I wrote my design components and immediately “tested” them using the
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal methods&lt;/a&gt;
provided by
&lt;a href=&quot;http://www.clifford.at/yosys&quot;&gt;yosys-smtbmc&lt;/a&gt;
and the lint capabilities of
&lt;a href=&quot;https://veripool.org/wiki/verilator&quot;&gt;Verilator&lt;/a&gt;.
If any component didn’t pass muster from both of these tools, I
didn’t even try it on the board.&lt;/p&gt;

    &lt;p&gt;This worked well for the bottom or “leaf” nodes of my design tree.&lt;/p&gt;

    &lt;p&gt;I also applied this method to a single non-leaf node, one that included my
&lt;a href=&quot;/dsp/2017/11/10/delayw.html&quot;&gt;delay element&lt;/a&gt;
as a sub-component.
The purpose of this module was to segment the data into blocks, and to
calculate the best exponent that could be applied to all of the samples
in a given block.  The timing of this module was critical, but it wasn’t
simple to desk check–so the proof was important.  Indeed, the success
of the entire design depended upon this being done “right”.
However, after cutting the proof down as much as possible, it still
took a rough day of solid CPU computation to finish.  This was rare
among my proofs, as most completed within 5-20 minutes.  Still, I
needed the confidence of that formal verification proof and so I
“paid” that price.&lt;/p&gt;

    &lt;p&gt;Neither did I apply
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal methods&lt;/a&gt;
to all of the design components.  For example, one component contained
three parallel
&lt;a href=&quot;/blog/2017/07/29/fifo.html&quot;&gt;FIFO&lt;/a&gt;s closely
integrated together.  Another component contained the
entire signal processing chain (including the parallel
&lt;a href=&quot;/blog/2017/07/29/fifo.html&quot;&gt;FIFO&lt;/a&gt;s 
module).  Neither of these components were
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formally verified&lt;/a&gt;,
although I would’ve loved doing so–I just wasn’t certain I could manage
the complexity required to do so.  Hence these components were
desk-checked,
&lt;a href=&quot;/blog/2017/06/21/looking-at-verilator.html&quot;&gt;simulated&lt;/a&gt;,
and tested on the hardware itself but never
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formally verified&lt;/a&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;If the component passed
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal verification&lt;/a&gt;
and
&lt;a href=&quot;https://veripool.org/wiki/verilator&quot;&gt;Verilator&lt;/a&gt; linting, I’d
synthesize it and try it on the board.  If it failed on the board, I’d
add a
&lt;a href=&quot;/blog/2017/07/08/getting-started-with-wbscope.html&quot;&gt;wishbone scope&lt;/a&gt;
to see what was going on.  Since this was an
&lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt; based design, adding or
removing a &lt;a href=&quot;/blog/2017/07/08/getting-started-with-wbscope.html&quot;&gt;wishbone
scope&lt;/a&gt;
was &lt;em&gt;really&lt;/em&gt; easy to do.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;This left me stuck in
&lt;a href=&quot;/blog/2017/05/19/fpga-hell.html&quot;&gt;FPGA Hell&lt;/a&gt;
only twice, and never for very long.  First, I was stuck in
&lt;a href=&quot;/blog/2017/05/19/fpga-hell.html&quot;&gt;FPGA Hell&lt;/a&gt;
before I learned how to use the golden reference design
properly.  In these cases, the
&lt;a href=&quot;https://www.yoctoproject.org/product/angstrom-distribution&quot;&gt;Angstrom&lt;/a&gt;
Linux distribution I was using
would never get past the boot-loader.  Second, I would get stuck in
&lt;a href=&quot;/blog/2017/05/19/fpga-hell.html&quot;&gt;FPGA Hell&lt;/a&gt;
any time the system didn’t interact with the
&lt;a href=&quot;https://www.altera.com/content/dam/altera-www/global/en_US/pdfs/literature/manual/mnl_avalon_spec.pdf&quot;&gt;Avalon bus&lt;/a&gt;
properly.&lt;/p&gt;

    &lt;p&gt;In the second case, my
&lt;a href=&quot;https://veripool.org/wiki/verilator&quot;&gt;Verilator&lt;/a&gt;-based
&lt;a href=&quot;/blog/2017/06/21/looking-at-verilator.html&quot;&gt;simulation&lt;/a&gt;
rescued me nicely every time.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;No,  &lt;a href=&quot;/blog/2017/06/02/design-process.html&quot;&gt;I did not use any Verilog based test-benches&lt;/a&gt;.&lt;/p&gt;

    &lt;p&gt;After having gotten a taste of
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal methods&lt;/a&gt;,
I’m not sure I’d go back to any
&lt;a href=&quot;/blog/2017/06/02/design-process.html&quot;&gt;other approaches&lt;/a&gt;
if I didn’t need to.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;the-crazy-bug&quot;&gt;The Crazy Bug&lt;/h2&gt;

&lt;p&gt;Ok, so … I did come across a rather “Crazy Bug”.  You know, the kind that
goes down in your memory banks as one that &lt;em&gt;really&lt;/em&gt; stands out?  The one bug
in any project that takes you so long to find that you had to take notice
of it?  In my case, this bug took place across the interaction between the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
and the &lt;a href=&quot;https://en.wikipedia.org/wiki/ARM_architecture&quot;&gt;ARM&lt;/a&gt;
processor.&lt;/p&gt;

&lt;p&gt;For your sake, I’ll share what happened here, lest you get caught in
the same bug yourself.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig. 4. Basic Processing Steps&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/adc-copy-loop.svg&quot; alt=&quot;S/w outline&quot; width=&quot;180&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;After collecting samples from the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Analog-to-digital_converter&quot;&gt;A/D&lt;/a&gt;s,
those samples went through an initial signal processing chain.
Once that signal processing chain had finished working on the incoming
samples, those samples were placed into a
&lt;a href=&quot;/blog/2017/07/29/fifo.html&quot;&gt;FIFO&lt;/a&gt;.
When the software running on the
&lt;a href=&quot;https://en.wikipedia.org/wiki/ARM_architecture&quot;&gt;ARM&lt;/a&gt;
was ready, it would call the
&lt;a href=&quot;http://www.cplusplus.com/reference/cstring/memcpy/&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;memcpy()&lt;/code&gt;&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/C_standard_library&quot;&gt;C-library&lt;/a&gt; routine
to copy samples from the
&lt;a href=&quot;/blog/2017/07/29/fifo.html&quot;&gt;FIFO&lt;/a&gt;
to the user’s memory space.  These processed samples were then sent
to a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Network_socket&quot;&gt;socket&lt;/a&gt;
to be sent over
&lt;a href=&quot;https://en.wikipedia.org/wiki/Gigabit_Ethernet&quot;&gt;GigE&lt;/a&gt;
to a part of the system I had no control of.  To make this happen, the
&lt;a href=&quot;/blog/2017/07/29/fifo.html&quot;&gt;FIFO&lt;/a&gt;
was given the largest memory space I could afford, so that a vendor
optimized piece of code (i.e. the
&lt;a href=&quot;http://www.cplusplus.com/reference/cstring/memcpy/&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;memcpy()&lt;/code&gt;&lt;/a&gt;)
could just copy the memory from the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
to &lt;a href=&quot;https://en.wikipedia.org/wiki/Random-access_memory&quot;&gt;RAM&lt;/a&gt;.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig. 5. Memory Copy from FIFO to RAM&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/adc-memcpy.svg&quot; alt=&quot;MemCPY&quot; width=&quot;400&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;I’m sure the actual
&lt;a href=&quot;https://en.wikipedia.org/wiki/ARM_architecture&quot;&gt;ARM&lt;/a&gt;
&lt;a href=&quot;http://www.cplusplus.com/reference/cstring/memcpy/&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;memcpy()&lt;/code&gt;&lt;/a&gt;)
is a bit more complicated than the logic below, but the following is a basic
pseudocode outline of what the routine does:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;c1&quot;&gt;// Example memcpy
&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;	&lt;span class=&quot;nf&quot;&gt;memcpy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;size_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ln&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ln&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;ln&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Only … that’s not I the behavior I observed.&lt;/p&gt;

&lt;p&gt;Initially, all I knew was that the data coming out of the device was all
jumbled, and I couldn’t tell why.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig. 6. Counter Injection&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/counter-inject.svg&quot; alt=&quot;Injecting a counter following the A/Ds&quot; width=&quot;240&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;If you’ve never had to deal with a data acquisition process like this,
there’s one trick you need to have as part of your bag-of-tricks
to find stream-based processing bugs–the counter.  As shown in Fig 6 on the
right, the counter runs
along side the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Analog-to-digital_converter&quot;&gt;A/D&lt;/a&gt;
controller.  It increments with every sample.  A
user-configurable “switch” then selects whether the counter or the data is
sent down-stream.  If done right, you can then check the data values at
the end of your processing stream, and you can tell whether samples
were lost, corrupted, or worse–just by checking whether the ultimate
sample values still had the one-up relationship present with a counter.&lt;/p&gt;

&lt;p&gt;It was because this counter was not incrementing by one on every sample
that I knew I had a problem.&lt;/p&gt;

&lt;p&gt;So … I applied my
&lt;a href=&quot;/blog/2017/07/08/getting-started-with-wbscope.html&quot;&gt;scope&lt;/a&gt;
to the bus transaction.  My first thought was that I was somehow double
or triple stepping my
&lt;a href=&quot;/blog/2017/07/29/fifo.html&quot;&gt;FIFO&lt;/a&gt; on semi-random reads,
so I wanted to see what happened on a read from my
&lt;a href=&quot;/blog/2017/07/29/fifo.html&quot;&gt;FIFO&lt;/a&gt;.  Using this
&lt;a href=&quot;/blog/2017/07/08/getting-started-with-wbscope.html&quot;&gt;scope&lt;/a&gt;,
I discovered the &lt;a href=&quot;/blog/2017/07/29/fifo.html&quot;&gt;FIFO&lt;/a&gt;
was acting within normal limits.  However, the values
being read didn’t match the values in my code.&lt;/p&gt;

&lt;p&gt;Ok, so I adjusted the
&lt;a href=&quot;/blog/2017/07/08/getting-started-with-wbscope.html&quot;&gt;scope&lt;/a&gt;
and traced the problem up stream.  Things looked good there.&lt;/p&gt;

&lt;p&gt;So I adjusted my &lt;a href=&quot;/blog/2017/07/29/fifo.html&quot;&gt;FIFO&lt;/a&gt;
so that it would return the address pointer instead of
the data.  In this case, the
&lt;a href=&quot;http://www.cplusplus.com/reference/cstring/memcpy/&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;memcpy()&lt;/code&gt;&lt;/a&gt;)’d
buffer came back finally in order with no problems, but the
&lt;a href=&quot;/blog/2017/07/08/getting-started-with-wbscope.html&quot;&gt;scope&lt;/a&gt;
finally showed the problem.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/OUT-OF-ORDER.svg&quot; alt=&quot;&quot; width=&quot;480&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Instead of reading sample values 0, 1, 2, 3, 4, …, the
&lt;a href=&quot;https://en.wikipedia.org/wiki/ARM_architecture&quot;&gt;ARM&lt;/a&gt;
was reading sample values 0, 8, 16, 24, 1, 2, 3, 4, … and then quietly
reordering the samples back into what it thought was the “correct” order.
However, since the
&lt;a href=&quot;/blog/2017/07/29/fifo.html&quot;&gt;FIFO&lt;/a&gt;
based device was producing values in order in spite of the
out of order addresses, when the
&lt;a href=&quot;https://en.wikipedia.org/wiki/ARM_architecture&quot;&gt;ARM&lt;/a&gt;
rearranged the reads back in order–the result was the values in the buffer
were now &lt;em&gt;out of order&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Since knowing is half the battle, I now had two choices: I could fix the
&lt;a href=&quot;http://www.cplusplus.com/reference/cstring/memcpy/&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;memcpy()&lt;/code&gt;&lt;/a&gt;)
routine by writing one of my own that didn’t read out of order, or
I could shuffle the memory back into order.  I chose the former and wrote
my own
&lt;a href=&quot;http://www.cplusplus.com/reference/cstring/memcpy/&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;memcpy()&lt;/code&gt;&lt;/a&gt;), one where
I could &lt;em&gt;guarantee&lt;/em&gt; that the reads would be issued &lt;em&gt;in order&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;This new version of code &lt;em&gt;still&lt;/em&gt; read from my
&lt;a href=&quot;/blog/2017/07/29/fifo.html&quot;&gt;FIFO&lt;/a&gt;
out of order.&lt;/p&gt;

&lt;p&gt;As it turns out, it was the
&lt;a href=&quot;https://en.wikipedia.org/wiki/ARM_architecture&quot;&gt;ARM CPU&lt;/a&gt;
itself that caused the reads to be
issued out of order, and then quietly placed the memory back in order
on the other end.
However, if I rearranged my own memory copy to never
increment the “fake” address into the
&lt;a href=&quot;/blog/2017/07/29/fifo.html&quot;&gt;FIFO&lt;/a&gt;,
then it finally read it in order.&lt;/p&gt;

&lt;p&gt;I’ll say this much: I would’ve never figured this out without my &lt;a href=&quot;/blog/2017/07/08/getting-started-with-wbscope.html&quot;&gt;Wishbone
Scope&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;immediate-lessons-learned&quot;&gt;Immediate Lesson’s Learned&lt;/h2&gt;

&lt;p&gt;As with any attempt to use a new piece of technology you aren’t familiar with,
there will be hiccups.  The
&lt;a href=&quot;https://www.altera.com/products/fpga/cyclone-series/cyclone-v/overview.html&quot;&gt;Cyclone-V&lt;/a&gt;
on the
&lt;a href=&quot;http://www.terasic.com/cgi-bin/page/archive.pl?Language=English&amp;amp;No=1046&quot;&gt;DE10-Nano&lt;/a&gt;
was no exception.
Indeed, it took me almost a month of grumbling and confusion to get off the
ground before I discovered that, yes, the
&lt;a href=&quot;https://www.terasic.com.tw&quot;&gt;Terasic&lt;/a&gt;
&lt;a href=&quot;http://www.terasic.com.tw/cgi-bin/page/archive.pl?Language=English&amp;amp;CategoryNo=205&amp;amp;No=1046&amp;amp;PartNo=4&quot;&gt;documentation&lt;/a&gt;
&lt;em&gt;did&lt;/em&gt; show me how to interact with this device.  Here are some other
frustrations I came across:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;My first big frustration was &lt;a href=&quot;https://software.intel.com/en-us/articles/de10-nano-board-schematic&quot;&gt;the schematic&lt;/a&gt; I found online.  It took me some
time to realize that someone had posted a
&lt;a href=&quot;http://www.terasic.com/cgi-bin/page/archive.pl?Language=English&amp;amp;No=593&quot;&gt;DE0-Nano&lt;/a&gt;
schematic on an &lt;a href=&quot;https://software.intel.com/en-us/articles/de10-nano-board-schematic&quot;&gt;Intel
DE10-Nano support&lt;/a&gt; web-page.&lt;/p&gt;

    &lt;p&gt;Sadly, despite posting a comment to this effect, &lt;a href=&quot;https://software.intel.com/en-us/articles/de10-nano-board-schematic&quot;&gt;this official
Intel support page&lt;/a&gt; &lt;em&gt;still&lt;/em&gt; contains a link to the wrong schematic.&lt;/p&gt;

    &lt;p&gt;In the end, I needed to destroy and then recreate my project in
&lt;a href=&quot;https://www.altera.com/products/design-software/fpga-design/quartus-prime/download.html&quot;&gt;Quartus&lt;/a&gt;
just to convince myself that I had gotten rid of all of the references
to the wrong part.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;My next frustration was that I couldn’t find an
&lt;a href=&quot;https://www.altera.com&quot;&gt;Altera&lt;/a&gt; “Libraries” reference.&lt;/p&gt;

    &lt;p&gt;Perhaps I’m spoiled: &lt;a href=&quot;https://www.xilinx.com&quot;&gt;Xilinx&lt;/a&gt; offers a &lt;a href=&quot;https://www.xilinx.com/support/documentation/sw_manuals/xilinx14_7/7series_hdl.pdf&quot;&gt;libraries
guide&lt;/a&gt;
that gives you instructions for how to interface with any of the
hard components on the chip.  Hence, if I need a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Phase-locked_loop&quot;&gt;PLL&lt;/a&gt;,
I just put a reference to their
&lt;a href=&quot;https://en.wikipedia.org/wiki/Phase-locked_loop&quot;&gt;PLL&lt;/a&gt;
within my own code and off I go.&lt;/p&gt;

    &lt;p&gt;I couldn’t find a similar libraries guide for
&lt;a href=&quot;https://www.altera.com&quot;&gt;Altera&lt;/a&gt;.  Indeed, I probably
spent much too much time looking for it.&lt;/p&gt;

    &lt;p&gt;In the end, I just swallowed my aversion to working with GUI’s and built the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Phase-locked_loop&quot;&gt;PLL&lt;/a&gt;
I needed using &lt;a href=&quot;https://www.altera.com/products/design-software/fpga-design/quartus-prime/features/qts-platform-designer.html&quot;&gt;Platform
Designer&lt;/a&gt;.
Since resigning to use &lt;a href=&quot;https://www.altera.com/products/design-software/fpga-design/quartus-prime/features/qts-platform-designer.html&quot;&gt;Platform
Designer&lt;/a&gt;,
it has handled all of my needs to date–I just hate using GUI’s: they are
slow, and they can hide details where I’m not looking for them, etc.
Although, looking over the &lt;a href=&quot;https://www.altera.com/products/design-software/fpga-design/quartus-prime/features/qts-platform-designer.html&quot;&gt;Platform
Designer&lt;/a&gt;
generated data file in the end, it’s &lt;em&gt;just an XML file&lt;/em&gt;–one that submits
nicely to “diff”, and thus one I can use with
&lt;a href=&quot;https://git-scm.com&quot;&gt;git&lt;/a&gt;
quite nicely.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;My second problem had to deal with the “Golden H/W design”
&lt;a href=&quot;http://www.terasic.com.tw/cgi-bin/page/archive.pl?Language=English&amp;amp;CategoryNo=205&amp;amp;No=1046&amp;amp;PartNo=4&quot;&gt;provided by&lt;/a&gt;
&lt;a href=&quot;https://www.terasic.com.tw&quot;&gt;Terasic&lt;/a&gt; for the board.&lt;/p&gt;

    &lt;p&gt;Looking through this design with Altera’s &lt;a href=&quot;https://www.altera.com/products/design-software/fpga-design/quartus-prime/features/qts-platform-designer.html&quot;&gt;Platform
Designer&lt;/a&gt;,
I could easily identify a variety of things I didn’t need.  I dumped these
out of my project, and then cleaned up the result so that there were
only the components I needed, and then built the project.&lt;/p&gt;

    &lt;p&gt;It didn’t work.  The board would load and run the bootloader just fine.
The bootloader would load my
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
design, but would then fail to start Linux.  Not knowing how to debug Linux
loading to know what device was failing, how, or why, I just couldn’t
tell why not.&lt;/p&gt;

    &lt;p&gt;In the end, I went back and rebuilt the Golden Design
&lt;a href=&quot;http://www.terasic.com.tw/cgi-bin/page/archive.pl?Language=English&amp;amp;CategoryNo=205&amp;amp;No=1046&amp;amp;PartNo=4&quot;&gt;as provided&lt;/a&gt;,
and then only modified it for my application.  This worked.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;I really dislike vendor code that doesn’t match my own high quality coding
standards.&lt;/p&gt;

    &lt;p&gt;By this I mean two things.  First, I use &lt;code class=&quot;highlighter-rouge&quot;&gt;default_nettype none&lt;/code&gt; in all of
my designs.  It helps me avoid a whole variety of painful Verilog bugs.
However, a bug in the &lt;a href=&quot;https://www.altera.com&quot;&gt;Altera&lt;/a&gt;’s
&lt;a href=&quot;https://www.altera.com/products/fpga/cyclone-series/cyclone-v/overview.html&quot;&gt;Cyclone-V&lt;/a&gt;
IP would cause my design to fail if I tried to use this across my design.&lt;/p&gt;

    &lt;p&gt;With a little bit of help from an &lt;a href=&quot;http://www.clifford.at&quot;&gt;amazing mentor&lt;/a&gt;,
I managed to use &lt;code class=&quot;highlighter-rouge&quot;&gt;default_nettype none&lt;/code&gt; at the top of my files, and
&lt;code class=&quot;highlighter-rouge&quot;&gt;default_nettype wire&lt;/code&gt; at the bottom and
&lt;a href=&quot;https://www.altera.com&quot;&gt;Altera&lt;/a&gt;’s
broken code would still synthesize.&lt;/p&gt;

    &lt;p&gt;I then got all kinds of warnings from their “working” IP.  I mean, really
guys, can’t you clean up &lt;em&gt;your own&lt;/em&gt; IP?  How can I tell if my
implementation of your IP has problems if your IP fills the logs with
warnings–&lt;em&gt;when it works&lt;/em&gt;!?  (Incidentally,
&lt;a href=&quot;https://www.xilinx.com&quot;&gt;Xilinx&lt;/a&gt;’s code isn’t any
better, and &lt;a href=&quot;https://www.xilinx.com&quot;&gt;Xilinx&lt;/a&gt;’s MIG-generated
&lt;a href=&quot;https://en.wikipedia.org/wiki/DDR3_SDRAM&quot;&gt;DDR3 SDRAM&lt;/a&gt;
controller is a particular offender …)&lt;/p&gt;

    &lt;p&gt;The worst of these warnings said that I hadn’t mapped several pins
properly, and yet the pin mapping tool wouldn’t let me do anything with
these hardware-assigned yet somehow mis-mapped pins.  As with the
other warnings, these could be ignored, but how was I to know that when
things weren’t working?&lt;/p&gt;

    &lt;p&gt;Again, building the &lt;a href=&quot;http://www.terasic.com.tw/cgi-bin/page/archive.pl?Language=English&amp;amp;CategoryNo=205&amp;amp;No=1046&amp;amp;PartNo=4&quot;&gt;Golden H/W Reference Design&lt;/a&gt;
gave me some
confidence, as I could then see that I still got the same warnings
and yet for some outrageous reason, the
&lt;a href=&quot;http://www.terasic.com.tw/cgi-bin/page/archive.pl?Language=English&amp;amp;CategoryNo=205&amp;amp;No=1046&amp;amp;PartNo=4&quot;&gt;Golden Design&lt;/a&gt;
worked in spite of the warnings.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;This blog is about debugging
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;s,
though, so what did I learn from that standpoint?&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;One mistake in the
&lt;a href=&quot;https://www.altera.com/content/dam/altera-www/global/en_US/pdfs/literature/manual/mnl_avalon_spec.pdf&quot;&gt;Avalon bus&lt;/a&gt;
controller would lock up the device &lt;em&gt;HARD&lt;/em&gt;.&lt;/p&gt;

    &lt;p&gt;If this happened, the only solution appeared to be pulling power.&lt;/p&gt;

    &lt;p&gt;The &lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal&lt;/a&gt; proof
of the
&lt;a href=&quot;https://www.altera.com/content/dam/altera-www/global/en_US/pdfs/literature/manual/mnl_avalon_spec.pdf&quot;&gt;Avalon&lt;/a&gt;
to &lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;WB&lt;/a&gt;
converter created a bit of a false confidence for me: my design
still locked up at times.&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;
        &lt;p&gt;The first problem I had with my
&lt;a href=&quot;https://www.altera.com/content/dam/altera-www/global/en_US/pdfs/literature/manual/mnl_avalon_spec.pdf&quot;&gt;Avalon&lt;/a&gt;
bus interface
was that I somehow managed to &lt;em&gt;assume&lt;/em&gt; within my
proof that all transactions would be read transactions.  The assumption
wasn’t simple, and it wasn’t obvious, so I never realized what happened
from a simple desk check.&lt;/p&gt;

        &lt;p&gt;In the end, I figured out what was going on via
&lt;a href=&quot;/blog/2017/06/21/looking-at-verilator.html&quot;&gt;simulation&lt;/a&gt;.&lt;/p&gt;

        &lt;p&gt;When I went back to the
formal properties, I realized I hadn’t created
any “cover” properties, and that a simple “cover” property or two
would’ve revealed this problem.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;My next problem was when I mis-wired a bus component in
&lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt;.&lt;/p&gt;

        &lt;p&gt;For a given peripheral, the
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;WB strobe&lt;/a&gt;
value is given by the overall
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;wishbone strobe (a
transaction request)&lt;/a&gt;
&lt;a href=&quot;/blog/2017/06/22/simple-wb-interconnect.html&quot;&gt;logically &lt;code class=&quot;highlighter-rouge&quot;&gt;AND&lt;/code&gt;ed
with the peripheral’s address select line&lt;/a&gt;.  I had forgotten this
address select line logical &lt;code class=&quot;highlighter-rouge&quot;&gt;AND&lt;/code&gt; on one component, and so that
component was responding to &lt;em&gt;EVERY&lt;/em&gt; transaction across the bus–with
pretty catastrophic results.&lt;/p&gt;

        &lt;p&gt;As with the prior problem, I found this pretty quickly … once I fired
up the &lt;a href=&quot;/blog/2017/06/21/looking-at-verilator.html&quot;&gt;simulator&lt;/a&gt;.&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;/blog/2017/06/21/looking-at-verilator.html&quot;&gt;Simulator&lt;/a&gt;?
How …?&lt;/p&gt;

    &lt;p&gt;Yes.  Exactly.  I couldn’t simulate the
&lt;a href=&quot;https://en.wikipedia.org/wiki/ARM_architecture&quot;&gt;ARM&lt;/a&gt; processor, the
&lt;a href=&quot;https://en.wikipedia.org/wiki/DDR3_SDRAM&quot;&gt;DDR3 SDRAM&lt;/a&gt;,
the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Gigabit_Ethernet&quot;&gt;GigE&lt;/a&gt;
network, the lightweight
&lt;a href=&quot;http://www.gstitt.ece.ufl.edu/courses/fall15/eel4720_5721/labs/refs/AXI4_specification.pdf&quot;&gt;AXI&lt;/a&gt; bridge,
or the
&lt;a href=&quot;http://www.gstitt.ece.ufl.edu/courses/fall15/eel4720_5721/labs/refs/AXI4_specification.pdf&quot;&gt;AXI&lt;/a&gt; to
&lt;a href=&quot;https://www.altera.com/content/dam/altera-www/global/en_US/pdfs/literature/manual/mnl_avalon_spec.pdf&quot;&gt;Avalon&lt;/a&gt;
memory-mapped I/O bridge, but I could create a
&lt;a href=&quot;https://veripool.org/wiki/verilator&quot;&gt;Verilator&lt;/a&gt;-based
&lt;a href=&quot;/blog/2017/06/21/looking-at-verilator.html&quot;&gt;simulation&lt;/a&gt;
of the
&lt;a href=&quot;https://www.altera.com/content/dam/altera-www/global/en_US/pdfs/literature/manual/mnl_avalon_spec.pdf&quot;&gt;Avalon&lt;/a&gt;
bus interface on down–to include simulating
the &lt;a href=&quot;https://en.wikipedia.org/wiki/Analog-to-digital_converter&quot;&gt;A/D&lt;/a&gt;s.
That portion of the design was a fairly straight-forward
&lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt;
based implementation, and even though it wasn’t a full-design
&lt;a href=&quot;/blog/2017/06/21/looking-at-verilator.html&quot;&gt;simulation&lt;/a&gt;,
it was enough to
&lt;a href=&quot;/blog/2017/06/21/looking-at-verilator.html&quot;&gt;simulate&lt;/a&gt;
enough of the design to find many problems.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Given my experiences with an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
+ &lt;a href=&quot;https://en.wikipedia.org/wiki/ARM_architecture&quot;&gt;ARM&lt;/a&gt;
architecture, would I recommend it for others?  As with any engineering
decision, your choice will depend upon the requirements of your problem.
However, I would have &lt;em&gt;really&lt;/em&gt; struggled if this had been my first-ever
design.  Hence, I’d recommend beginners start with something simpler–such
as a plain
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
with an on-board (debuggable)
&lt;a href=&quot;https://en.wikipedia.org/wiki/Soft_microprocessor&quot;&gt;soft-core CPU&lt;/a&gt;,
before adding the &lt;a href=&quot;https://en.wikipedia.org/wiki/ARM_architecture&quot;&gt;ARM&lt;/a&gt;
to the mix.&lt;/p&gt;

&lt;h2 id=&quot;conclusions&quot;&gt;Conclusions&lt;/h2&gt;

&lt;p&gt;There’s more I could say, but this post is long enough as is.  I’d like to be
able to blog some more about the
&lt;a href=&quot;https://www.altera.com/content/dam/altera-www/global/en_US/pdfs/literature/manual/mnl_avalon_spec.pdf&quot;&gt;Avalon&lt;/a&gt;
to &lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;WB&lt;/a&gt;
bridge and how I managed to formally verify it,
how easy it is to suddenly add a
&lt;a href=&quot;/blog/2017/07/08/getting-started-with-wbscope.html&quot;&gt;scope&lt;/a&gt;
to a design using
&lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt;,
or indeed how powerful
&lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt;
is in general.&lt;/p&gt;

&lt;p&gt;These discussions will sadly need to wait for a later day.&lt;/p&gt;

&lt;hr /&gt;&lt;p&gt;&lt;em&gt;If we say that we have not sinned, we make him a liar, and his word is not in us. (1John 1:9)&lt;/em&gt;</description>
        <pubDate>Fri, 09 Feb 2018 00:00:00 -0500</pubDate>
        <link>http://zipcpu.com/blog/2018/02/09/first-cyclonev.html</link>
        <guid isPermaLink="true">http://zipcpu.com/blog/2018/02/09/first-cyclonev.html</guid>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>ZipCPU toolchain and initial test</title>
        <description>&lt;p&gt;Please accept my apologies for taking so long to put this article together.
I’ve made a lot of changes to the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
in order to &lt;a href=&quot;/zipcpu/2018/01/22/formal-progress.html&quot;&gt;formally
prove&lt;/a&gt;
the components.  I’ve also cleaned out all of the issues in the issue-tracker
on &lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;Github&lt;/a&gt;.  These changes have now been
integrated into &lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;the baseline&lt;/a&gt;.
They have been confirmed to build within
&lt;a href=&quot;http://www.clifford.at/yosys/&quot;&gt;yosys&lt;/a&gt;,
&lt;a href=&quot;https://www.xilinx.com/products/design-tools/ise-design-suite.html&quot;&gt;ISE&lt;/a&gt;,
&lt;a href=&quot;https://www.xilinx.com/products/design-tools/vivado.html&quot;&gt;Vivado&lt;/a&gt;,
and
&lt;a href=&quot;https://veripool.org/wiki/verilator&quot;&gt;Verilator&lt;/a&gt;.
Further, the new changes have been proven on the
&lt;a href=&quot;https://github.com/ZipCPU/zbasic&quot;&gt;ZBasic&lt;/a&gt; distribution–just not within an
actual &lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
(yet).  Further, when measuring the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Logic_block&quot;&gt;LUT&lt;/a&gt;
usage impact of the changes that
have been made, they appear to require no more than four extra
&lt;a href=&quot;https://en.wikipedia.org/wiki/Logic_block&quot;&gt;LUT&lt;/a&gt;s–suggesting the 
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
remains on target to be a low-logic
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Integration with
&lt;a href=&quot;https://github.com/olofk/fusesoc&quot;&gt;FuseSoC&lt;/a&gt;
is still now, perhaps more firmly than ever, on my to-do list.&lt;/p&gt;

&lt;p&gt;With that aside, let’s look into how you might get started.&lt;/p&gt;

&lt;h2 id=&quot;introduction&quot;&gt;Introduction&lt;/h2&gt;

&lt;p&gt;Let’s spend a couple of posts discussing how to fire up the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
and run it.  Our goal will be to show how the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
can be used to control a signal processing application.  That, however,
will take a couple of posts to get to.  For this first post, let’s
just discuss how to get the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
tool chain up and running, and then how to test and know that the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt;
itself works.&lt;/p&gt;

&lt;p&gt;If you look at the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;’s
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/README.md&quot;&gt;README file&lt;/a&gt;, you’ll
read that the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
is only one component of a (potentially) much larger system.  For example,
consider the
&lt;a href=&quot;https://github.com/ZipCPU/zbasic&quot;&gt;ZBasic&lt;/a&gt;
system in the figure below.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 1. ZBasic Components and Peripherals&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/zbasic-blok.svg&quot; alt=&quot;&quot; width=&quot;730&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/ZipCPU/zbasic&quot;&gt;This system&lt;/a&gt;
was designed to be a generic system that could demonstrate the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;’s
capabilities.  If you notice, the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
is only a small part of this full system.  Likewise, the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/zipsystem.v&quot;&gt;ZipSystem&lt;/a&gt;,
a container for the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
with some peripherals connected close to the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt;,
is still only a small portion of any full design.  To make a full design from
just a &lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt;, the
&lt;a href=&quot;https://github.com/ZipCPU/zbasic&quot;&gt;ZBasic&lt;/a&gt;
project also contains a
&lt;a href=&quot;https://github.com/ZipCPU/wbuart32&quot;&gt;serial port&lt;/a&gt;, a &lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/rtl/memdev.v&quot;&gt;block
RAM&lt;/a&gt;, a &lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/rtl/wbqspiflash.v&quot;&gt;flash (ROM)
controller&lt;/a&gt;,
an (optional)
&lt;a href=&quot;https://github.com/ZipCPU/sdspi&quot;&gt;SPI-mode SD-Card controller&lt;/a&gt;, and
(currently) a
&lt;a href=&quot;https://github.com/ZipCPU/wbscope&quot;&gt;scope&lt;/a&gt; for the
&lt;a href=&quot;https://github.com/ZipCPU/sdspi&quot;&gt;SD-card controller&lt;/a&gt;
as well.  There are also some smaller components, such as a
&lt;a href=&quot;https://github.com/ZipCPU/rtcclock&quot;&gt;real-time clock&lt;/a&gt;, a
&lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/auto-data/pwrcount.txt&quot;&gt;counter-since-power
up&lt;/a&gt;,
a second &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/icontrol.v&quot;&gt;interrupt
controller&lt;/a&gt;,
the &lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/auto-data/version.txt&quot;&gt;date of the last time the system was
built&lt;/a&gt;
 and so forth.&lt;/p&gt;

&lt;p&gt;As with all of my designs, the &lt;a href=&quot;https://github.com/ZipCPU/zbasic&quot;&gt;ZBasic design&lt;/a&gt;
also has a &lt;a href=&quot;/blog/2017/06/05/wb-bridge-overview.html&quot;&gt;debugging bus
controller&lt;/a&gt;
that can be used to control the bus within the core from an external
&lt;a href=&quot;https://github.com/ZipCPU/wbuart32&quot;&gt;serial port&lt;/a&gt;.  This version of the
debugging bus controller, however, multiplexes two 7-bit
channels onto an 8-bit serial port channel–unlike the &lt;a href=&quot;/blog/2017/06/05/wb-bridge-overview.html&quot;&gt;one we discussed
earlier&lt;/a&gt;.
This creates a
&lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/rtl/wbconsole.v&quot;&gt;console port&lt;/a&gt;
for the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt;, in addition to the
&lt;a href=&quot;/blog/2017/06/05/wb-bridge-overview.html&quot;&gt;debugging bus controller&lt;/a&gt;.
This makes it possible to experiment with the
&lt;a href=&quot;https://github.com/ZipCPU/zbasic&quot;&gt;ZBasic&lt;/a&gt;
module on any
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
board having only a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Serial_Peripheral_Interface_Bus&quot;&gt;QSPI&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt; and a
&lt;a href=&quot;https://github.com/ZipCPU/wbuart32&quot;&gt;serial port&lt;/a&gt;.  The
&lt;a href=&quot;https://github.com/ZipCPU/sdspi&quot;&gt;SDCard&lt;/a&gt; port is optional, and by using
&lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt;, the block RAM can easily be
resized.&lt;/p&gt;

&lt;p&gt;Our eventual goal in this series of articles will be to show how to run
this &lt;a href=&quot;https://github.com/ZipCPU/zbasic&quot;&gt;ZBasic design&lt;/a&gt;,
while simulating all of the components, from within
&lt;a href=&quot;/blog/2017/06/21/looking-at-verilator.html&quot;&gt;Verilator&lt;/a&gt;.  As
part of this goal, we’ll also add a
&lt;a href=&quot;https://github.com/ZipCPU/wbpmic&quot;&gt;MEMs based audio A/D&lt;/a&gt;
and may possibly even add an &lt;a href=&quot;https://github.com/ZipCPU/xulalx25soc/blob/master/rtl/wbsdram.v&quot;&gt;SDRAM
controller&lt;/a&gt;.
We’ll even use the &lt;a href=&quot;https://sourceware.org/newlib&quot;&gt;C-library&lt;/a&gt; to demonstrate a
&lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/sw/board/hello.c&quot;&gt;Hello World
example&lt;/a&gt;,
and possibly even to play &lt;a href=&quot;https://github.com/ZipCPU/tttt&quot;&gt;4x4x4 Tic-Tac-Toe&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;That will be the goal of this series.&lt;/p&gt;

&lt;p&gt;Today’s goal, however, will just be to examine the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
by itself.  To do so, we’ll trace a piece
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; history,
and run the very first piece of software ever written for the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;the-initial-zipcpu-test-software&quot;&gt;The Initial ZipCPU Test Software&lt;/h2&gt;

&lt;p&gt;The very first  piece of software I wrote for the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
just demonstrated each of the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt;’s
instructions, and its ability to execute them.&lt;/p&gt;

&lt;p&gt;The initial version of this test was created by a test generator piece of
software that at one time wrote a couple of machine code instructions
into a binary file which would then describe the block RAM memory image
for the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt;.
I was so excited to get this simple code to work!  Little did I know how
much more work would be involved in finding all the corner cases within any
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;.
This piece of code, however, is now only relic-ware.  Indeed, it is not only
a couple of &lt;a href=&quot;/zipcpu/2018/01/01/zipcpu-isa.html&quot;&gt;instruction set
architecture&lt;/a&gt;
versions out of date, but since it was causing build errors for users it has
since been removed from the repository entirely.&lt;/p&gt;

&lt;p&gt;With the introduction of the first
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/tree/master/sw/zasm&quot;&gt;assembler&lt;/a&gt;,
the program that generated machine code was replaced with an &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/bench/asm/simtest.s&quot;&gt;assembly
file&lt;/a&gt;.
Even though that
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/tree/master/sw/zasm&quot;&gt;initial assembler&lt;/a&gt;
has now also become relic-ware, the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/bench/asm/simtest.s&quot;&gt;assembly
file&lt;/a&gt;
test has been maintained to the point that it can still
be assembled using the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/sw/gas-zippatch.patch&quot;&gt;version of
binutils&lt;/a&gt;.
Unlike the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/tree/master/sw/zasm&quot;&gt;original assembler&lt;/a&gt;,
&lt;a href=&quot;https://www.gnu.org/software/binutils&quot;&gt;binutils&lt;/a&gt;
provides several valuable capabilities–such as the ability to link multiple
files together, the ability to follow a script describing where memory and/or
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt;
are located, the ability to place an initial RAM image in
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt;,
and even the ability to integrate with &lt;a href=&quot;https://gcc.gnu.org&quot;&gt;GCC&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;This &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/bench/asm/simtest.s&quot;&gt;remaining piece of
software/testware&lt;/a&gt;
starts with a branch-always followed by break test–just to make certain the
&lt;a href=&quot;/zipcpu/2017/08/23/cpu-pipeline.html&quot;&gt;pipeline&lt;/a&gt;
works.  It then continues by testing some basic register setting commands.
It was meant to be run within a &lt;a href=&quot;/zipcpu/2017/07/26/cpu-sim-debugger.html&quot;&gt;monitor
program&lt;/a&gt;.
Using this program, you can step through this software one clock cycle at a
time–just like &lt;a href=&quot;/zipcpu/2017/07/26/cpu-sim-debugger.html&quot;&gt;we discussed
earlier&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Let’s build and run
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/bench/asm/simtest.s&quot;&gt;this program&lt;/a&gt;
today, to give us some confidence that the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt;
itself continues to work.&lt;/p&gt;

&lt;h2 id=&quot;building-the-tools&quot;&gt;Building the tools&lt;/h2&gt;

&lt;p&gt;The first step in converting any
&lt;a href=&quot;https://en.wikipedia.org/wiki/Assembly_language&quot;&gt;assembly file&lt;/a&gt; into &lt;a href=&quot;https://en.wikipedia.org/wiki/Machine_code&quot;&gt;machine
code&lt;/a&gt;
is to acquire (or build) an &lt;a href=&quot;https://www.gnu.org/software/binutils&quot;&gt;assembler and
linker&lt;/a&gt;.  The
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
has backend support for &lt;a href=&quot;https://www.gnu.org/software/binutils&quot;&gt;binutils (assembler and
linker)&lt;/a&gt;, the
&lt;a href=&quot;https://gcc.gnu.org&quot;&gt;GCC C-compiler&lt;/a&gt;, and
&lt;a href=&quot;https://sourcewaire.org/newlib&quot;&gt;newlib&lt;/a&gt;.  Although only
&lt;a href=&quot;https://www.gnu.org/software/binutils&quot;&gt;binutils&lt;/a&gt;
is required for this &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/bench/asm/simtest.s&quot;&gt;testing
program&lt;/a&gt;,
all of the tools are built from the same command, so let’s build them together.&lt;/p&gt;

&lt;p&gt;To build the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
tool-suite, first make sure you have the prerequisites
for &lt;a href=&quot;https://gcc.gnu.org&quot;&gt;GCC&lt;/a&gt;.  For debian based systems, this will look like:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;sudo apt install flex bison libbison-dev libgmp-dev libmpfr-dev libmpc-dev bc&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;You’ll notice several &lt;code class=&quot;highlighter-rouge&quot;&gt;*-dev&lt;/code&gt; components.  These are different from their non
&lt;code class=&quot;highlighter-rouge&quot;&gt;-dev&lt;/code&gt; counterparts, in that they allow you to build components using these
libraries rather than just using binary components already built.  In other
words, installing &lt;code class=&quot;highlighter-rouge&quot;&gt;gmp&lt;/code&gt; isn’t good enough, you’ll need to install &lt;code class=&quot;highlighter-rouge&quot;&gt;libgmp-dev&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;You are also going to need &lt;a href=&quot;https://www.veripool.org/wiki/verilator&quot;&gt;Verilator&lt;/a&gt;
to translate
the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;’s Verilog source code into
the C++ necessary to simulate it,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;sudo apt install verilator&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The &lt;a href=&quot;/zipcpu/2017/07/26/cpu-sim-debugger.html&quot;&gt;simulation&lt;/a&gt;
driver needs
&lt;a href=&quot;http://www.mr511.de/software/english.html&quot;&gt;libelf&lt;/a&gt; in order to know
where to load programs and program components into memory,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;sudo apt install libelf-dev&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Please note that, as with the earlier components, this package is the
development version of
&lt;a href=&quot;http://www.mr511.de/software/english.html&quot;&gt;libelf&lt;/a&gt;.  We’ll need that version
to build a program that uses it that can read and process an ELF file.&lt;/p&gt;

&lt;p&gt;Many of my distributions depend upon &lt;a href=&quot;http://ctags.sourceforge.net&quot;&gt;ctags&lt;/a&gt;,
and the &lt;a href=&quot;/zipcpu/2017/07/26/cpu-sim-debugger.html&quot;&gt;simulation control
program&lt;/a&gt;
is written using
&lt;a href=&quot;https://www.gnu.org/software/ncurses&quot;&gt;ncurses&lt;/a&gt;, so let’s get those as well:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;sudo apt install ncurses-dev ctags&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;If you are using Windows,
&lt;a href=&quot;/blog/2017/07/28/cygwin-fpga.html&quot;&gt;these instructions&lt;/a&gt;
should get you started using these tools via &lt;a href=&quot;https://cygwin.com&quot;&gt;cygwin&lt;/a&gt;.
Since I’m not using Windows regularly, please let me know if you have any
problems building with &lt;a href=&quot;https://cygwin.com&quot;&gt;cygwin&lt;/a&gt;–I’ll probably never notice
the problem otherwise.&lt;/p&gt;

&lt;p&gt;One you have these prerequisites, it is now time to actually clone
the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
repository,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;git clone --depth 1 https://github.com/ZipCPU/zipcpu
&lt;span class=&quot;nb&quot;&gt;cd &lt;/span&gt;zipcpu&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;While you may have cloned repositories without the &lt;code class=&quot;highlighter-rouge&quot;&gt;depth&lt;/code&gt; command, doing so
with the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;repository&lt;/a&gt; will also download a history
containing several versions of &lt;a href=&quot;https://gcc.gnu.org&quot;&gt;GCC&lt;/a&gt;.  In other words,
you’ll be spending a lot of bandwidth downloading more of the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;repository&lt;/a&gt; than you need.&lt;/p&gt;

&lt;p&gt;At this point, you &lt;em&gt;should&lt;/em&gt; be able to just type “make”.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;make&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This will orchestrate a
&lt;a href=&quot;https://www.veripool.org/wiki/verilator&quot;&gt;Verilator&lt;/a&gt;-based
make of the “&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/tree/master/rtl&quot;&gt;rtl/&lt;/a&gt;”
directory, and a build of the simulation
directory, “&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/tree/master/sim/verilator&quot;&gt;sim/verilator&lt;/a&gt;”.  It will also trigger a build of the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
tool-suite that we’ll need to turn the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/bench/asm/simtest.s&quot;&gt;simulation test
file&lt;/a&gt;
from &lt;a href=&quot;/zipcpu/2018/01/01/zipcpu-isa.html&quot;&gt;assembly&lt;/a&gt; into
&lt;a href=&quot;https://en.wikipedia.org/wiki/Machine_code&quot;&gt;object code&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The current version of the tools will be built and placed into a “sw/install”
directory within the cloned repository of the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;.
Before going further, you will need to make certain that this directory
is a part of your path.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span class=&quot;nb&quot;&gt;export &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;PATH&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$PATH&lt;/span&gt;:&amp;lt;your-path-to-zipcpu&amp;gt;/sw/install/cross-tools/bin&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;I am very interested in any struggles you may have during this process.
Please create an issue on
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;GitHub&lt;/a&gt; if you have any errors up to this
point.&lt;/p&gt;

&lt;h2 id=&quot;running-the-test-file&quot;&gt;Running the test file&lt;/h2&gt;

&lt;p&gt;Now that you have the tool suite, and now that your &lt;code class=&quot;highlighter-rouge&quot;&gt;PATH&lt;/code&gt; environment
variable has been modified so that &lt;code class=&quot;highlighter-rouge&quot;&gt;zip-as&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;zip-cpp&lt;/code&gt; are in
your path, then it is now time to build the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/bench/asm/simtest.s&quot;&gt;simulation test
file&lt;/a&gt;.
For this, we’ll change into the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/bench/asm&quot;&gt;bench/asm&lt;/a&gt;,
and run &lt;code class=&quot;highlighter-rouge&quot;&gt;make simtest&lt;/code&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span class=&quot;nb&quot;&gt;cd &lt;/span&gt;bench/asm
make simtest&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;You can also build a disassembly file of the result, in case you are ever
interested in what the original instructions actually build into, by&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;make simtest.txt&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Once built, we can change into the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/tree/master/sim/verilator/&quot;&gt;Verilator based simulation
directory&lt;/a&gt;,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span class=&quot;nb&quot;&gt;cd&lt;/span&gt; ../..
&lt;span class=&quot;nb&quot;&gt;cd &lt;/span&gt;sim/verilator&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;From here, you can run the automated tests.  There are two such tests,
both based off of the same &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/bench/asm/simtest.s&quot;&gt;simulated test&lt;/a&gt; instructions.&lt;/p&gt;

&lt;p&gt;The first automated test just runs the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/bench/asm/simtest.s&quot;&gt;test&lt;/a&gt;
file, using the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;’s
&lt;a href=&quot;/zipcpu/2017/08/25/hw-debugging.html&quot;&gt;debug interface&lt;/a&gt;
and particularly the &lt;em&gt;step&lt;/em&gt; instruction provided by that interface–the
same &lt;em&gt;step&lt;/em&gt; control that the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt;
would use were it placed on actual hardware.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;./zipsys_tb -s ../../bench/asm/simtest&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;To know when the test is complete, the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/bench/asm/simtest.s&quot;&gt;test file&lt;/a&gt;
has been designed to “end” in one of two states.  It will either end with
1) a halt instruction (successful exit), or 2) a BUSY instruction (error exit).
The &lt;a href=&quot;/zipcpu/2017/07/26/cpu-sim-debugger.html&quot;&gt;simulator&lt;/a&gt;
will detect this interface, and return an appropriate value to the shell.&lt;/p&gt;

&lt;p&gt;The second automated test simulates how the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt; would run if it were actually
running on the device without the
&lt;a href=&quot;/zipcpu/2017/08/25/hw-debugging.html&quot;&gt;debugging interface&lt;/a&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;./zipsys_tb -a ../../bench/asm/simtest&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;These two tests are so valuable to me, that I have a make target set up
just to run both of them,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;make &lt;span class=&quot;nb&quot;&gt;test&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;There’s a third way to run the test as well–the interactive test.  Although
starting the run is just as simple,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;make itest&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;there are more details involved in commanding it, which we’ll get into in the
next section.&lt;/p&gt;

&lt;p&gt;Further, no matter how you run this
&lt;a href=&quot;/zipcpu/2017/07/26/cpu-sim-debugger.html&quot;&gt;simulator&lt;/a&gt;,
it will (currently) always create a
&lt;a href=&quot;/blog/2017/07/31/vcd.html&quot;&gt;VCD trace file&lt;/a&gt;.  You are
welcome to open this file in a waveform viewer to see the internal signals
within the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; if you would like.
This isn’t true of the 
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
&lt;a href=&quot;/zipcpu/2017/07/26/cpu-sim-debugger.html&quot;&gt;simulator&lt;/a&gt;
within the
&lt;a href=&quot;https://github.com/ZipCPU/zbasic&quot;&gt;ZBasic&lt;/a&gt; repository–since the trace files
for &lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/sim/verilated/automaster_tb.cpp&quot;&gt;that simulator&lt;/a&gt;
can easily grow to many Gigabytes in length, that one is turned off by default.
In this case, though, the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/bench/asm/simtest.s&quot;&gt;simtest
file&lt;/a&gt;
is short enough that the
&lt;a href=&quot;/blog/2017/07/31/vcd.html&quot;&gt;VCD trace file&lt;/a&gt;
should remain within a reasonable size.&lt;/p&gt;

&lt;h2 id=&quot;interactive-commands&quot;&gt;Interactive Commands&lt;/h2&gt;

&lt;p&gt;Now that you know how to start the &lt;a href=&quot;/zipcpu/2017/07/26/cpu-sim-debugger.html&quot;&gt;simulation based
debugger&lt;/a&gt;
let’s spend some time describing how to work operate it.  As you’ll recall
from the last section, starting the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
&lt;a href=&quot;/zipcpu/2017/07/26/cpu-sim-debugger.html&quot;&gt;simulation based
debugger&lt;/a&gt; is easy.
Just run&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;make itest&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;from the “&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/tree/master/sim/verilated&quot;&gt;sim/verilated&lt;/a&gt;”
subdirectory.&lt;/p&gt;

&lt;p&gt;This will apply the
&lt;a href=&quot;/zipcpu/2017/07/26/cpu-sim-debugger.html&quot;&gt;simulation&lt;/a&gt;
to the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/bench/asm/simtest.s&quot;&gt;simtest
file&lt;/a&gt;.
To start it with another file you can run,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;./zipsys_tb &amp;lt;your-executable-file&amp;gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Knowing what to do next isn’t quite as simple.  Sure, either hitting the
escape key or ‘q’ will exit, but you can do a lot more.  Here’s a cheat sheet
so you’ll know what to do.  Specifically, the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
&lt;a href=&quot;/zipcpu/2017/07/26/cpu-sim-debugger.html&quot;&gt;simulator&lt;/a&gt;
understands the following command keys:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;‘h’ Halts the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;‘g’ tells the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt;
to &lt;em&gt;go&lt;/em&gt; until given another command.&lt;/li&gt;
  &lt;li&gt;‘G’ does the same thing, but only updates the screen any time a user types
a character.  It’s useful for moving quickly through a long simulation if
necessary.&lt;/li&gt;
  &lt;li&gt;‘r’ gives the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt; the reset command,
sending it back to supervisor mode and the reset address&lt;/li&gt;
  &lt;li&gt;’s’ &lt;em&gt;steps&lt;/em&gt; the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt; using the
&lt;a href=&quot;/zipcpu/2017/08/25/hw-debugging.html&quot;&gt;debugging interface&lt;/a&gt;
that will exist within the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
implementation&lt;/li&gt;
  &lt;li&gt;‘t’ &lt;em&gt;ticks&lt;/em&gt; the clock.  It steps the
&lt;a href=&quot;/blog/2017/06/21/looking-at-verilator.html&quot;&gt;Verilator&lt;/a&gt;
&lt;a href=&quot;/zipcpu/2017/07/26/cpu-sim-debugger.html&quot;&gt;simulation&lt;/a&gt;
by one clock tick, but done in such a fashion that the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt;’s
Verilog logic doesn’t know it’s being stepped.&lt;/li&gt;
  &lt;li&gt;‘T’ releases the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt;
from the &lt;a href=&quot;/zipcpu/2017/08/25/hw-debugging.html&quot;&gt;hardware debugging
mode&lt;/a&gt;.  This is
useful if you’ve been giving it the &lt;em&gt;step&lt;/em&gt; command (separate from ticking
the clock), and you want the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt; to continue without being given
explicit &lt;em&gt;step&lt;/em&gt; instructions.&lt;/li&gt;
  &lt;li&gt;‘q’ quits the simulation&lt;/li&gt;
  &lt;li&gt;Ctrl-L redraws the screen.  This used to be really important when running
a &lt;a href=&quot;https://www.gnu.org/software/ncurses&quot;&gt;curses&lt;/a&gt;
program over a modem connection–any time someone else in the house
would pick up the phone, you’d get a bunch of garbage on the screen and your
computer would need to re-sync.  While it’s not as necessary today, I did
find it necessary to add this capability in–specifically for the case
where I have
&lt;a href=&quot;https://gtkwave.sourceforge.net&quot;&gt;GTKWave&lt;/a&gt;
running in the background spewing warnings over my screen anytime I
update the display.&lt;/li&gt;
  &lt;li&gt;‘u’ switches the performance times to show user mode performance&lt;/li&gt;
  &lt;li&gt;‘m’ switches the performance times to show global machine performance&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;If this is your first experience with the
&lt;a href=&quot;/zipcpu/2017/07/26/cpu-sim-debugger.html&quot;&gt;simulator&lt;/a&gt;,
just remember three
characters: ‘t’ steps it forward, ‘r’ restarts it, and ‘q’ exits.  You might
just wish to press ‘t’ several times and watch what happens.  If that gets
boring, try typing ‘g’–you can stop the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
anytime by typing ‘t’ later to return to single-clock-tick mode.&lt;/p&gt;

&lt;p&gt;The &lt;a href=&quot;/zipcpu/2017/07/26/cpu-sim-debugger.html&quot;&gt;simulator&lt;/a&gt;
also has the ability to adjust and change registers.  You
can move around the display using the arrow keys.  When you get to a register
you wish to adjust, press the enter key, type the new number, and then press
enter (to set the value) or escape (to leave the mode).&lt;/p&gt;

&lt;h2 id=&quot;understanding-the-interactive-display&quot;&gt;Understanding the Interactive Display&lt;/h2&gt;

&lt;p&gt;So let’s look at what this interface tells us.&lt;/p&gt;

&lt;p&gt;When you initially start the
&lt;a href=&quot;/zipcpu/2017/07/26/cpu-sim-debugger.html&quot;&gt;simulator&lt;/a&gt;,
you’ll see a screen looking like Fig 2 below.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 2, Initial Simulator Screen&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/zipsim-initial.png&quot; alt=&quot;&quot; width=&quot;562&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Let’s break down the components of this view, so that you can understand what’s
going on.  Fig 3. therefore shows the basic sections of the
&lt;a href=&quot;/zipcpu/2017/07/26/cpu-sim-debugger.html&quot;&gt;simulation&lt;/a&gt;
screen.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 3. Components of the simulation screen&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/zipsim-overview.svg&quot; alt=&quot;&quot; width=&quot;562&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Starting at the top are two lines describing the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/zipsystem.v&quot;&gt;ZipSystem&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/tree/master/peripherals&quot;&gt;peripherals&lt;/a&gt;.  These
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/tree/master/peripherals&quot;&gt;peripherals&lt;/a&gt;
are shown in the blue box of Fig 1 above, they consist of an &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/icontrol.v&quot;&gt;interrupt
controller (PIC)&lt;/a&gt;, a
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/ziptimer.v&quot;&gt;watchdog timer (WDT)&lt;/a&gt;, a
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/wbwatchdog.v&quot;&gt;bus watchdog (WBUS)&lt;/a&gt;, and the second
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/icontrol.v&quot;&gt;interrupt control register (PIC2)&lt;/a&gt;.  Judging from these
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/tree/master/peripherals&quot;&gt;peripherals&lt;/a&gt;,
you can tell if (for example) interrupts are enabled, or an interrupt is
pending.  On the next line are the three
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/ziptimer.v&quot;&gt;count-down timers (TMRA-TMRC)&lt;/a&gt;, and
a &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/zipjiffies.v&quot;&gt;Jiffies&lt;/a&gt;
peripheral for controlling absolute rather than relative programmable
interrupt timing.  (This would be useful for real-time task scheduling.)&lt;/p&gt;

&lt;p&gt;The next line, starting with &lt;code class=&quot;highlighter-rouge&quot;&gt;MTSK&lt;/code&gt;, shows the values of four
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/peripherals/zipcounter.v&quot;&gt;performance counters&lt;/a&gt;.  The first counts the number clock ticks, and the last counts
the number of instructions retired.  The two in the middle count how often the
operands stage of the
&lt;a href=&quot;/zipcpu/2017/08/23/cpu-pipeline.html&quot;&gt;pipeline&lt;/a&gt; is stalled,
and how often the
&lt;a href=&quot;/zipcpu/2017/11/18/wb-prefetch.html&quot;&gt;prefetch&lt;/a&gt;
is stalled.  These are global counters.  They count whether the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt;
is in &lt;a href=&quot;/zipcpu/2018/01/01/zipcpu-isa.html&quot;&gt;supervisor mode or user
mode&lt;/a&gt;.  There’s a
second set of identical
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/peripherals/zipcounter.v&quot;&gt;counters&lt;/a&gt;,
revealed by typing &lt;code class=&quot;highlighter-rouge&quot;&gt;u&lt;/code&gt; within the
&lt;a href=&quot;/zipcpu/2017/07/26/cpu-sim-debugger.html&quot;&gt;simulation&lt;/a&gt;,
showing the same basic values–but this second set only increments
while in user mode.  This makes it possible to measure per user-task statistics.&lt;/p&gt;

&lt;p&gt;Further information regarding these
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/tree/master/peripherals&quot;&gt;peripherals&lt;/a&gt;,
and the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/peripherals/zipcounter.v&quot;&gt;performance
counters&lt;/a&gt;
may be found within the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/raw/master/doc/spec.pdf&quot;&gt;reference manual&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The third section of the display in Fig 3 is the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt;
register section.  As you may
&lt;a href=&quot;/zipcpu/2018/01/01/zipcpu-isa.html&quot;&gt;recall&lt;/a&gt;, the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
has two sets of sixteen 32-bit registers.  These are shown in this section.
The registers range from R0 to R12, and then the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Stack_register&quot;&gt;stack pointer (SP)&lt;/a&gt;,
&lt;a href=&quot;https://en.wikipedia.org/wiki/Status_register&quot;&gt;condition codes register (CC)&lt;/a&gt;,
and &lt;a href=&quot;https://en.wikipedia.org/wiki/Program_counter&quot;&gt;program counter (PC)&lt;/a&gt;.
The supervisor set is shown on top, the user set underneath.  The set that
is highlighted indicates which mode the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt;
is currently in–in this case, the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt;
is in supervisor mode.&lt;/p&gt;

&lt;p&gt;The fourth section, coming down from the top, tells you about the bus.
The &lt;code class=&quot;highlighter-rouge&quot;&gt;PF BUS&lt;/code&gt; line gives you information about the
&lt;a href=&quot;/zipcpu/2017/11/18/wb-prefetch.html&quot;&gt;prefetch&lt;/a&gt;
unit, and the &lt;code class=&quot;highlighter-rouge&quot;&gt;MEMBUS&lt;/code&gt; line tells you about the memory module.  The third line
shows the result of the output of the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/ex/wbdblpriarb.v&quot;&gt;arbiter&lt;/a&gt;,
and which of these units actually has access to the bus.&lt;/p&gt;

&lt;p&gt;The final section shows the &lt;a href=&quot;/zipcpu/2017/08/23/cpu-pipeline.html&quot;&gt;instruction
pipeline&lt;/a&gt;.  As you may
&lt;a href=&quot;/zipcpu/2017/08/23/cpu-pipeline.html&quot;&gt;remember&lt;/a&gt;, the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
has a basic five stage &lt;a href=&quot;/zipcpu/2017/08/23/cpu-pipeline.html&quot;&gt;pipeline&lt;/a&gt;.  The bottom of the display shows only four
lines.  These are the output of the
&lt;a href=&quot;/zipcpu/2017/11/18/wb-prefetch.html&quot;&gt;prefetch&lt;/a&gt; (&lt;code class=&quot;highlighter-rouge&quot;&gt;I&lt;/code&gt;), the
output of the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/idecode.v&quot;&gt;instruction
decoder&lt;/a&gt;
(&lt;code class=&quot;highlighter-rouge&quot;&gt;Dc)&lt;/code&gt;, the output of the read operands section (&lt;code class=&quot;highlighter-rouge&quot;&gt;Op&lt;/code&gt;) and the result of the
&lt;a href=&quot;/zipcpu/2017/08/11/simple-alu.html&quot;&gt;ALU&lt;/a&gt; (&lt;code class=&quot;highlighter-rouge&quot;&gt;Al&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;Indeed, this section is &lt;em&gt;so&lt;/em&gt; important for understanding how the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt; works, that we should take a deeper
look at it.  If you hold and press the ‘t’ key for a while, you’ll come across
the state shown in Fig 4 below.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 4, Instruction Pipeline&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/zipsim-insns.png&quot; alt=&quot;&quot; width=&quot;662&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;The first two columns on the left will show &lt;code class=&quot;highlighter-rouge&quot;&gt;Ck&lt;/code&gt; to indicate that the &lt;a href=&quot;/zipcpu/2017/08/23/cpu-pipeline.html&quot;&gt;pipeline&lt;/a&gt;
stage’s &lt;code class=&quot;highlighter-rouge&quot;&gt;CE&lt;/code&gt; line is high, or &lt;code class=&quot;highlighter-rouge&quot;&gt;Stl&lt;/code&gt;, to show that the particular stage is
&lt;em&gt;stalled&lt;/em&gt;.  Most instructions will be followed by a &lt;code class=&quot;highlighter-rouge&quot;&gt;:&lt;/code&gt;, although the first
half of any compressed instruction will be followed by a &lt;code class=&quot;highlighter-rouge&quot;&gt;/&lt;/code&gt;.  Following
the decode stage, either an &lt;code class=&quot;highlighter-rouge&quot;&gt;A&lt;/code&gt; (ALU), &lt;code class=&quot;highlighter-rouge&quot;&gt;M&lt;/code&gt; (memory), or &lt;code class=&quot;highlighter-rouge&quot;&gt;I&lt;/code&gt; (illegal)
character may follow the &lt;code class=&quot;highlighter-rouge&quot;&gt;;&lt;/code&gt; (or &lt;code class=&quot;highlighter-rouge&quot;&gt;/&lt;/code&gt;).  Immediately after this (optional)
character, is the address the instruction was read from.&lt;br /&gt;
If an instruction follows, as with all of the stages in Fig 4
above, then the particular
&lt;a href=&quot;/zipcpu/2017/08/23/cpu-pipeline.html&quot;&gt;pipeline&lt;/a&gt;
stage has valid values within it.
If the instruction is highlighted, its being run in supervisor mode.
These instructions, therefore, are being run from user mode.&lt;/p&gt;

&lt;p&gt;Is this making any sense?  Perhaps you might then be interested in the homework
section that follows.&lt;/p&gt;

&lt;h2 id=&quot;interactive-homework&quot;&gt;Interactive Homework&lt;/h2&gt;

&lt;p&gt;One of the really fun parts of
&lt;a href=&quot;/zipcpu/2017/07/26/cpu-sim-debugger.html&quot;&gt;this simulation&lt;/a&gt;.
is watching how the performance
of the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt;
is impacted by how well the
&lt;a href=&quot;/zipcpu/2017/11/18/wb-prefetch.html&quot;&gt;prefetch&lt;/a&gt;
mechanism works.  This is primarily controlled by some &lt;code class=&quot;highlighter-rouge&quot;&gt;define&lt;/code&gt;s within the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/cpudefs.v&quot;&gt;cpudefs.v&lt;/a&gt; file.&lt;/p&gt;

&lt;p&gt;Since you’ve already looked at how the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt;
operates in its default configuration with a
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/pfcache.v&quot;&gt;prefetch and cache&lt;/a&gt;
enabled,
let’s see how it does with some other
&lt;a href=&quot;/zipcpu/2017/11/18/wb-prefetch.html&quot;&gt;prefetch&lt;/a&gt;
module’s enabled.  Hence, for a second test, let’s uncomment the
&lt;code class=&quot;highlighter-rouge&quot;&gt;OPT_DOUBLE_FETCH&lt;/code&gt; define within
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/cpudefs.v&quot;&gt;cpudefs.v&lt;/a&gt;,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilator&quot; data-lang=&quot;verilator&quot;&gt;define OPT_DOUBLE_FETCH&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;You will then need to re-run make in the
“&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/tree/master/rtl&quot;&gt;rtl/&lt;/a&gt;” directory,
as well as the
“&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/tree/master/sim/verilated&quot;&gt;sim/verilated&lt;/a&gt;”
directory.&lt;/p&gt;

&lt;p&gt;This will switch the CPU from using the
&lt;a href=&quot;/zipcpu/2017/11/18/wb-prefetch.html&quot;&gt;prefetch&lt;/a&gt; and
&lt;a href=&quot;https://en.wikipedia.org/wiki/CPU_cache&quot;&gt;I-cache&lt;/a&gt;
of the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/pfcache.v&quot;&gt;pfcache&lt;/a&gt;
module, to using a module that fetches two instructions at a time:
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/dblfetch.v&quot;&gt;dblfetch&lt;/a&gt;.
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/dblfetch.v&quot;&gt;dblfetch&lt;/a&gt;
was designed to be a simpler
&lt;a href=&quot;/zipcpu/2017/11/18/wb-prefetch.html&quot;&gt;prefetch&lt;/a&gt;
than the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/pfcache.v&quot;&gt;pfcache&lt;/a&gt;
module, but also to have better performance than the single instruction at a
time &lt;a href=&quot;/zipcpu/2017/11/18/wb-prefetch.html&quot;&gt;prefetch&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/prefetch.v&quot;&gt;module&lt;/a&gt;–especially
when reading instructions from
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Speaking of the
&lt;a href=&quot;/zipcpu/2017/11/18/wb-prefetch.html&quot;&gt;single prefetch&lt;/a&gt;
module, why don’t we give that one a try?
To see how the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt;
performs with a
&lt;a href=&quot;/zipcpu/2017/11/18/wb-prefetch.html&quot;&gt;prefetch&lt;/a&gt;
module that only retrieves one instruction at a time, go ahead and uncomment
the &lt;code class=&quot;highlighter-rouge&quot;&gt;OPT_SINGLE_FETCH&lt;/code&gt; line from within
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/cpudefs.v&quot;&gt;cpudefs.v&lt;/a&gt;,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilator&quot; data-lang=&quot;verilator&quot;&gt;define OPT_SINGLE_FETCH&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;and then rerun make in the
“&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/tree/master/rtl&quot;&gt;rtl/&lt;/a&gt;” directory,
and
“&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/tree/master/sim/verilated&quot;&gt;sim/verilated&lt;/a&gt;”
directories again.&lt;/p&gt;

&lt;p&gt;See the difference?&lt;/p&gt;

&lt;p&gt;With the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/pfcache.v&quot;&gt;prefetch + cache&lt;/a&gt;, the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt;
has to pause any time the
&lt;a href=&quot;https://en.wikipedia.org/wiki/CPU_cache&quot;&gt;cache&lt;/a&gt;
line needs to be re-filled.  This is particularly pronounced at the beginning
of the
&lt;a href=&quot;/zipcpu/2017/07/26/cpu-sim-debugger.html&quot;&gt;simulation&lt;/a&gt;
where you have to wait many clocks for the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt;
to fill the
&lt;a href=&quot;https://en.wikipedia.org/wiki/CPU_cache&quot;&gt;cache&lt;/a&gt;.
You may also notice the effects of
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/pfcache.v&quot;&gt;this prefetch&lt;/a&gt;
any time the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt;
hits a
branch instruction, whether a
&lt;a href=&quot;/zipcpu/2018/01/01/zipcpu-isa.html&quot;&gt;branch always &lt;code class=&quot;highlighter-rouge&quot;&gt;BRA&lt;/code&gt;&lt;/a&gt;
or a conditional branch
(&lt;a href=&quot;/zipcpu/2018/01/01/zipcpu-isa.html&quot;&gt;nominally a conditional ADD
instruction&lt;/a&gt;)–the
two will have different effects within the
&lt;a href=&quot;/zipcpu/2017/07/26/cpu-sim-debugger.html&quot;&gt;simulator&lt;/a&gt;.
The
&lt;a href=&quot;/zipcpu/2018/01/01/zipcpu-isa.html&quot;&gt;branch always&lt;/a&gt;
instruction will suffer a single stall, and then (appear to) replace the
branch instruction moving through the
&lt;a href=&quot;/zipcpu/2017/08/23/cpu-pipeline.html&quot;&gt;pipeline&lt;/a&gt; with the
instruction prior to the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Branch_(computer_science)&quot;&gt;branch&lt;/a&gt;
target.  This is primarily an effect within the
&lt;a href=&quot;/zipcpu/2017/07/26/cpu-sim-debugger.html&quot;&gt;simulator viewer&lt;/a&gt;,
the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt;
doesn’t actually execute this other instruction, but it does send the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Branch_(computer_science)&quot;&gt;branch&lt;/a&gt;’s
target address through the
&lt;a href=&quot;/zipcpu/2017/08/23/cpu-pipeline.html&quot;&gt;pipeline&lt;/a&gt;–leading to
the misleading view.  The
&lt;a href=&quot;/zipcpu/2018/01/01/zipcpu-isa.html&quot;&gt;conditional branch&lt;/a&gt;,
on the other hand, will clear the
&lt;a href=&quot;/zipcpu/2017/08/23/cpu-pipeline.html&quot;&gt;pipeline&lt;/a&gt;
anytime it is taken.  If the result is in the
&lt;a href=&quot;https://en.wikipedia.org/wiki/CPU_cache&quot;&gt;cache&lt;/a&gt;,
then the new instructions will start filling the (now empty)
&lt;a href=&quot;/zipcpu/2017/08/23/cpu-pipeline.html&quot;&gt;pipeline&lt;/a&gt;
following the branch.&lt;/p&gt;

&lt;p&gt;On the other hand, with the
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;single prefetch&lt;/a&gt;
module, the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt;
is unable to fill its
&lt;a href=&quot;/zipcpu/2017/08/23/cpu-pipeline.html&quot;&gt;pipeline&lt;/a&gt;.
It seems to be forever fetching the next instruction, while spending
very little time actually executing instructions.&lt;/p&gt;

&lt;p&gt;When I first saw this difference, I suddenly learned a lot about how
important the
&lt;a href=&quot;https://en.wikipedia.org/wiki/CPU_cache&quot;&gt;cache&lt;/a&gt;
is to
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;
performance.  It was for this purpose that I wanted to share
this demonstration with you–I just found it very valuable.&lt;/p&gt;

&lt;h2 id=&quot;next-time&quot;&gt;Next Time&lt;/h2&gt;

&lt;p&gt;Our next step, now that you’ve built the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
toolchain, will be to run the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/sw/board/cputest.c&quot;&gt;test program&lt;/a&gt;
program from within the
&lt;a href=&quot;https://github.com/ZipCPU/zbasic&quot;&gt;ZBasic&lt;/a&gt;
repository.  This goes beyond testing just the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt;–it involves testing a
&lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/sw/verilated/qspiflashsim.cpp&quot;&gt;simulated flash&lt;/a&gt;
and a &lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/sw/verilated/dbluartsim.cpp&quot;&gt;simulated serial
port&lt;/a&gt;–together
with their controllers.  If time permits, I’ll even add the instructions
to play &lt;a href=&quot;https://github.com/ZipCPU/tttt&quot;&gt;4x4x4 tic-tac-toe&lt;/a&gt;
within that demonstration–it’s a fun game and a nice way to relieve the
stress of getting something new working.&lt;/p&gt;

&lt;p&gt;Beyond that, I’ve still got a couple of blogging articles planned along
this line.  The next article I have planned will show how to add a
&lt;a href=&quot;https://github.com/ZipCPU/wbpmic&quot;&gt;microphone controller&lt;/a&gt;
component to
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;wishbone bus&lt;/a&gt;
within the
&lt;a href=&quot;https://github.com/ZipCPU/zbasic&quot;&gt;ZBasic&lt;/a&gt;
implementation using
&lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt;.  I’d also like to show
how you can profile a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;
running
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;Dhrystone&lt;/a&gt;
within a
&lt;a href=&quot;/zipcpu/2017/07/26/cpu-sim-debugger.html&quot;&gt;simulator&lt;/a&gt;,
using a capability similar to the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;’s
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/sim/verilated/pdump.cpp&quot;&gt;pdump&lt;/a&gt;
program.  This was also very instructive to me, since it helped me
understand where and when the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt;
ended up stalling, and what it would stall for under a reasonable load.&lt;/p&gt;

&lt;p&gt;So, stick around, there’s more coming!&lt;/p&gt;
&lt;hr /&gt;&lt;p&gt;&lt;em&gt;Shall the axe boast itself against him that heweth therewith? or shall the saw magnify itself against him that shaketh it? as if the rod should shake itself against them that lift it up, or as if the staff should lift up itself, as if it were no wood. (Isaiah 10:15)&lt;/em&gt;</description>
        <pubDate>Wed, 31 Jan 2018 00:00:00 -0500</pubDate>
        <link>http://zipcpu.com/zipcpu/2018/01/31/cpu-build.html</link>
        <guid isPermaLink="true">http://zipcpu.com/zipcpu/2018/01/31/cpu-build.html</guid>
        
        
        <category>zipcpu</category>
        
      </item>
    
      <item>
        <title>Updating ZipCPU files</title>
        <description>&lt;p&gt;Several of you have asked me, following the
&lt;a href=&quot;/zipcpu/2018/01/01/zipcpu-isa.html&quot;&gt;ZipCPU ISA introduction&lt;/a&gt;
article,
to present instructions for building and trying out the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; for yourselves. 
I would like to do that.  Indeed, I’m planning on it.  If the Lord is willing,
this will be my next article.  If I get stuck along the way and it takes too
long to get there, then I might just pause and describe a &lt;a href=&quot;https://github.com/ZipCPU/interpolation/blob/master/rtl/quadratic/quadinterp.v&quot;&gt;quadratic
interpolator&lt;/a&gt;
first, but if the Lord remains willing we’ll still get there.&lt;/p&gt;

&lt;p&gt;This week, however, I’ve gotten stuck into the “just-one-more” (fill in the
blank) change loop.  Most of these changes have centered around
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal verifying&lt;/a&gt;
that the various components of the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
works as designed.&lt;/p&gt;

&lt;p&gt;At first the task was easy–I just started building
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal verification&lt;/a&gt;
proofs for the little components within the 
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;–you know, the peripherals that
just &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/zipcounter.v&quot;&gt;count
instructions&lt;/a&gt;,
or the one that justs &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/zipcounter.v&quot;&gt;counts down to zero and then creates an
interrupt&lt;/a&gt;.
In each case, I’ve gotten to the point where I think I’m ready to post the
“here’s how to get started article”, and I think to myself, “Just one more
proof.”
I mean, how hard can a &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/ziptimer.v&quot;&gt;simple
timer&lt;/a&gt;
be, for example?&lt;/p&gt;

&lt;p&gt;Well, that &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/ziptimer.v&quot;&gt;simple timer&lt;/a&gt;
was harder to
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formally verify&lt;/a&gt;
than I expected.&lt;/p&gt;

&lt;p&gt;Then, after I wrote up the chart below, things started to become a challenge.
Surely I could
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formally verify&lt;/a&gt; the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/wbdmac.v&quot;&gt;DMA controller&lt;/a&gt;, right?
I wouldn’t want to present the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; to others if there was a subtle
bug within the 
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/wbdmac.v&quot;&gt;DMA
controller&lt;/a&gt; that 
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal methods&lt;/a&gt;
could find, right?
The &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/wbdmac.v&quot;&gt;DMA
controller&lt;/a&gt;,
I told myself, should be easy: I’ve already put together the set of &lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;formal
Wishbone properties&lt;/a&gt;
necessary to make certain it works, the hard work has been done, right?&lt;/p&gt;

&lt;p&gt;One day later, I have a &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/wbdmac.v&quot;&gt;wonderful
proof&lt;/a&gt;
that my &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/wbdmac.v&quot;&gt;DMA
controller&lt;/a&gt;
works, but I’m no closer to writing the getting started article.
Of course, it didn’t help that I adjusted how I expressed the
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;wishbone properties&lt;/a&gt;,
and so other components–notably the (yet to be integrated)
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/zipmmu.v&quot;&gt;MMU&lt;/a&gt;
had to be adjusted to work with this new property description as well …&lt;/p&gt;

&lt;p&gt;However, with everyone of these projects, I’m getting closer and closer to
being able to &lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formally
verify&lt;/a&gt;
the &lt;em&gt;entire &lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt;&lt;/em&gt;.  Even further, I
intended to do a full proof, including not only bounded model checking but
induction as well.&lt;/p&gt;

&lt;p&gt;Just so you see how far I’ve gotten, here’s a list of the RTL components
in the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt; project,
together with whether or not I’ve managed to finish
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formally verifying&lt;/a&gt;
the component or not.&lt;/p&gt;

&lt;table class=&quot;bordered-table&quot;&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Project&lt;/th&gt;
      &lt;th&gt;Component&lt;/th&gt;
      &lt;th&gt;Purpose&lt;/th&gt;
      &lt;th&gt;Status&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/prefetch.v&quot;&gt;prefetch&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;Single Insn Prefetch&lt;/td&gt;
      &lt;td&gt;&lt;em&gt;Proven&lt;/em&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/dblfetch.v&quot;&gt;dblfetch&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;Two Insn Pipelind Prefetch&lt;/td&gt;
      &lt;td&gt;&lt;em&gt;Proven&lt;/em&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/pfcache.v&quot;&gt;pfcache&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;Prefetch and integrated instruction cache&lt;/td&gt;
      &lt;td&gt;&lt;em&gt;Proven&lt;/em&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/idecode.v&quot;&gt;idecode&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;Instruction decoder&lt;/td&gt;
      &lt;td&gt;&lt;em&gt;Proven&lt;/em&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/div.v&quot;&gt;div&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;Divide module&lt;/td&gt;
      &lt;td&gt;&lt;em&gt;Proven&lt;/em&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/memops.v&quot;&gt;memops&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;Memory Interface Module&lt;/td&gt;
      &lt;td&gt;&lt;em&gt;Proven&lt;/em&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/pipemem.v&quot;&gt;pipemem&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;Memory Module, supporting pipelind mem access&lt;/td&gt;
      &lt;td&gt;&lt;em&gt;Proven&lt;/em&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/icontrol.v&quot;&gt;icontrol&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;Interrupt controller&lt;/td&gt;
      &lt;td&gt;&lt;em&gt;Proven&lt;/em&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/zipjiffies.v&quot;&gt;zipjiffies&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;I/O Scheduling peripheral&lt;/td&gt;
      &lt;td&gt;&lt;em&gt;Proven&lt;/em&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/zipcounter.v&quot;&gt;zipcounter&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;Performance counter&lt;/td&gt;
      &lt;td&gt;&lt;em&gt;Proven&lt;/em&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/ziptimer.v&quot;&gt;ziptimer&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;Count-down timer&lt;/td&gt;
      &lt;td&gt;&lt;em&gt;Proven&lt;/em&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/wbdmac.v&quot;&gt;wbdmac&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;CPU DMA Controller&lt;/td&gt;
      &lt;td&gt;&lt;em&gt;Proven&lt;/em&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/zipmmu.v&quot;&gt;zipmmu&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;External MMU peripheral&lt;/td&gt;
      &lt;td&gt;&lt;em&gt;Proven&lt;/em&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/ex/busdelay.v&quot;&gt;busdelay&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;A timing saving bus delay&lt;/td&gt;
      &lt;td&gt;&lt;em&gt;Proven&lt;/em&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/ex/wbpriarbiter.v&quot;&gt;wbpriarbiter&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;A wishbone priority arbiter&lt;/td&gt;
      &lt;td&gt;&lt;em&gt;Proven&lt;/em&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/ex/wbdblpriarb.v&quot;&gt;wbdblpriarb&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;A priority arbiter for a pair of shared wishbone interfaces&lt;/td&gt;
      &lt;td&gt;&lt;em&gt;Proven&lt;/em&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/cpuops.v&quot;&gt;cpuops&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;ALU component&lt;/td&gt;
      &lt;td&gt;(Not started)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;zipcpu&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;Master CPU controller&lt;/td&gt;
      &lt;td&gt;(Not started)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/zipbones.v&quot;&gt;zipbones&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;CPU Container&lt;/td&gt;
      &lt;td&gt;(Not started)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/zipsystem.v&quot;&gt;zipsystem&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;CPU Container with Peripherals&lt;/td&gt;
      &lt;td&gt;(Not started)&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 1. Components of a ZipSystem&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/zipsystem.svg&quot; alt=&quot;&quot; width=&quot;420&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;Pictorially, you can see most of these components in the diagram of the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/zipsystem.v&quot;&gt;ZipSystem&lt;/a&gt;
shown to the right in Fig 1.  I’ve proven all of the
peripheral components shown in boxes on the right, as well as all of the
sub-components within the CPU in the yellow box on the left.  (The
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
still doesn’t have an FPU component, and the
&lt;a href=&quot;/zipcpu/2017/08/11/simple-alu.html&quot;&gt;ALU&lt;/a&gt; was forgotten
when I initially built the table above.) The large yellow box on the left
that is the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
within the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/zipsystem.v&quot;&gt;ZipSystem&lt;/a&gt;
still remains to be proven, as does the area with
the blue background known as the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/zipsystem.v&quot;&gt;ZipSystem&lt;/a&gt;.
However, I’m getting a lot closer–having now proved all but one of the
components within these two aggregate components.&lt;/p&gt;

&lt;p&gt;Indeed, if you just judge from the table (and figure) above, I’ve got the
entire
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt; periphery proven, just not the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;core module&lt;/a&gt;
itself or the two container modules–the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipsystem.v&quot;&gt;zipsystem&lt;/a&gt;,
or the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipbones.v&quot;&gt;zipbones&lt;/a&gt;.
As for the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;main CPU
component&lt;/a&gt;,
I’ve started working on it–but haven’t tried it to see how far I could
get.  My biggest fear there is that there’s some pipeline bug still lying
dormant within the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
that I will only discover via
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal verification&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;I’ve certainly found several subtle bugs along the way.  For example, just
the right sequence of commands and the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/wbdmac.v&quot;&gt;DMA
controller&lt;/a&gt;
would try to initiate a bus transaction of zero length–violating a primary
assertion.  As another example, that &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/ziptimer.v&quot;&gt;simple count-down
timer&lt;/a&gt;
would “break” if just the right series of commands were given to it.  Or worse,
the (soon to be integrated)
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/zipmmu.v&quot;&gt;MMU&lt;/a&gt;
component would sometimes place the last physical page address on the bus
instead of the one appropriate for the current bus request.&lt;/p&gt;

&lt;p&gt;I’m hoping to present these proven components here on
&lt;a href=&quot;http://zipcpu.com/&quot;&gt;this blog&lt;/a&gt; in time.  If
you are interested in the proofs before then, you should be able to find some
of those proofs in the development branch of the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/tree/dev&quot;&gt;ZipCPU repository&lt;/a&gt;, otherwise feel
free to write if you don’t find what you are looking for.  It will take
me some time to integrate these components and then to write the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
getting started “how-to” instructions, since I want to make certain that
the test benches within the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/tree/dev&quot;&gt;ZipCPU
repository&lt;/a&gt;
still work (I think I broke one or two), that the &lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/sw/board/cputest.c&quot;&gt;CPU
test&lt;/a&gt;
within the &lt;a href=&quot;https://github.com/ZipCPU/zbasic&quot;&gt;ZBasic repository&lt;/a&gt;
continues to work, as well as making certain that the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt;
still builds within both &lt;a href=&quot;https://www.xilinx.com&quot;&gt;Xilinx&lt;/a&gt;’s
&lt;a href=&quot;https://www.xilinx.com/products/design-tools/ise-design-suite.html&quot;&gt;ISE&lt;/a&gt;
(i.e. the &lt;a href=&quot;https://github.com/ZipCPU/xulalx25soc&quot;&gt;XuLA2-LX25 SoC repository&lt;/a&gt;)
and &lt;a href=&quot;https://www.xilinx.com/products/design-tools/vivado.html&quot;&gt;Vivado&lt;/a&gt;
(i.e. either the &lt;a href=&quot;https://github.com/ZipCPU/videozip&quot;&gt;VideoZip&lt;/a&gt;
or the &lt;a href=&quot;https://github.com/ZipCPU/openarty&quot;&gt;OpenArty&lt;/a&gt; repository).&lt;/p&gt;

&lt;p&gt;Getting these components to build for five separate synthesis engines,
&lt;a href=&quot;https://veripool.org/wiki/verilator&quot;&gt;Verilator&lt;/a&gt;,
&lt;a href=&quot;http://www.clifford.at/yosys/&quot;&gt;yosys&lt;/a&gt;,
&lt;a href=&quot;https://www.xilinx.com/products/design-tools/ise-design-suite.html&quot;&gt;ISE&lt;/a&gt;,
&lt;a href=&quot;https://www.xilinx.com/products/design-tools/vivado.html&quot;&gt;Vivado&lt;/a&gt;, and (now
hopefully)
&lt;a href=&quot;https://www.altera.com/products/design-software/fpga-design/quartus-prime/overview.html&quot;&gt;Quartus&lt;/a&gt;,
has become such a hassle, that I’ve asked among my friends in the
&lt;a href=&quot;https://openrisc.io&quot;&gt;OpenRISC&lt;/a&gt;
world for some ideas to help, and I’ve been told that
&lt;a href=&quot;https://github.com/olofk/fusesoc&quot;&gt;FuseSoC&lt;/a&gt;
can handle testing builds for all of these different synthesis tools
with one configuration.  I think I’m going to need to try that.&lt;/p&gt;

&lt;h2 id=&quot;other-components&quot;&gt;Other Components&lt;/h2&gt;

&lt;p&gt;I’ve also slowly been
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formally verifying&lt;/a&gt;
many of the peripherals I’ve been working with.  Below, therefore, are some
other important components that I’ve managed to
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formally verify&lt;/a&gt; as
well:&lt;/p&gt;

&lt;table class=&quot;bordered-table&quot;&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Project&lt;/th&gt;
      &lt;th&gt;Component&lt;/th&gt;
      &lt;th&gt;Purpose&lt;/th&gt;
      &lt;th&gt;Status&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;a href=&quot;https://github.com/ZipCPU/xulalx25soc&quot;&gt;XuLA2-LX25&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;https://github.com/ZipCPU/xulalx25soc/blob/master/rtl/wbsdram.v&quot;&gt;wbsdram&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;SDRAM controller&lt;/td&gt;
      &lt;td&gt;&lt;em&gt;Proven&lt;/em&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;a href=&quot;https://github.com/ZipCPU/wb2axip&quot;&gt;wb2axip&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;https://github.com/ZipCPU/wb2axip/blob/master/rtl/wbm2axisp.v&quot;&gt;wbm2axip&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;Pipelined WB to AXI converter&lt;/td&gt;
      &lt;td&gt;&lt;em&gt;Proven&lt;/em&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;a href=&quot;https://github.com/ZipCPU/vgasim&quot;&gt;vgasim&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;https://github.com/ZipCPU/vgasim/blob/master/rtl/llvga.v&quot;&gt;llvga&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;Low-level VGA Controller&lt;/td&gt;
      &lt;td&gt;&lt;em&gt;Proven&lt;/em&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;a href=&quot;https://github.com/ZipCPU/wbpmic&quot;&gt;wbpmic&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;https://github.com/ZipCPU/wbpmic/blob/master/rtl/wbsmpladc.v&quot;&gt;wbsmpladc&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;Simple WB A/D Controller&lt;/td&gt;
      &lt;td&gt;&lt;em&gt;Proven&lt;/em&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;https://github.com/ZipCPU/wbpmic/blob/master/rtl/smplfifo.v&quot;&gt;smplfifo&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;A/D Converter’s FIFO&lt;/td&gt;
      &lt;td&gt;&lt;em&gt;Proven&lt;/em&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;https://github.com/ZipCPU/wbpmic/blob/master/rtl/smpladc.v&quot;&gt;smpladc&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;SPI based A/D Converter&lt;/td&gt;
      &lt;td&gt;&lt;em&gt;Proven&lt;/em&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;a href=&quot;https://github.com/ZipCPU/wbuart32&quot;&gt;wbuart&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;https://github.com/ZipCPU/wbuart32/blob/master/rtl/ufifo.v&quot;&gt;ufifo&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;Generic FIFO for serial ports&lt;/td&gt;
      &lt;td&gt;&lt;em&gt;Proven&lt;/em&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;a href=&quot;https://github.com/ZipCPU/wbuart32&quot;&gt;wbuart&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;https://github.com/ZipCPU/wbuart32/blob/master/rtl/txuartlite.v&quot;&gt;txuartlite&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;Bare bones serial port transmitter&lt;/td&gt;
      &lt;td&gt;&lt;em&gt;Proven&lt;/em&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;a href=&quot;https://github.com/ZipCPU/dspfilters&quot;&gt;dspfilters&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/lfsr.v&quot;&gt;lfsr&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;Generic LFSR&lt;/td&gt;
      &lt;td&gt;&lt;em&gt;Proven&lt;/em&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;a href=&quot;https://github.com/ZipCPU/dspfilters&quot;&gt;dspfilters&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/delayw.v&quot;&gt;delayw&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;Signal delay module&lt;/td&gt;
      &lt;td&gt;&lt;em&gt;Proven&lt;/em&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;a href=&quot;http://opencores.org/project,qspiflash&quot;&gt;qspiflash&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;https://opencores.org/websvn,filedetails?repname=qspiflash&amp;amp;path=%2Fqspiflash%2Ftrunk%2Frtl%2Fllqspi.v&quot;&gt;llqspi&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;Low level QSPI flash driver&lt;/td&gt;
      &lt;td&gt;&lt;em&gt;Proven&lt;/em&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;Each of these components has a story to tell.  For example, I found the subtlest
of bugs in the &lt;a href=&quot;https://github.com/ZipCPU/xulalx25soc/blob/master/rtl/wbsdram.v&quot;&gt;SDRAM memory
controller&lt;/a&gt;,
a bug that in rare cases would have caused the &lt;a href=&quot;https://github.com/ZipCPU/xulalx25soc/blob/master/rtl/wbsdram.v&quot;&gt;memory
controller&lt;/a&gt;
to read or write the wrong memory address (i.e., the right column but the
wrong row).  I’ll admit, I was a bit surprised to find this, as I’ve now been
using this
&lt;a href=&quot;https://github.com/ZipCPU/xulalx25soc/blob/master/rtl/wbsdram.v&quot;&gt;memory controller&lt;/a&gt;
for years now and haven’t hit that bug.  (Not all of these proofs have been
pushed to their respective repositories yet …)&lt;/p&gt;

&lt;p&gt;All of the items listed above are candidates for future blog articles–both
the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; and its components as well
as the peripherals listed above.  Not only do I think they might be of interest
to some, but blogging about them will also give me the opportunity to clean up
the code a bit following this last mad dash to prove the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Oh, by the way, if you want to get started with the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; before I write my getting
started article, you can find some &lt;a href=&quot;/zipcpu/2017/08/23/cpu-pipeline.html&quot;&gt;simple getting-started instructions
here&lt;/a&gt;–just to get you
going until I write up something prettier.&lt;/p&gt;
&lt;hr /&gt;&lt;p&gt;&lt;em&gt;So likewise ye, when ye shall have done all those things which are commanded you, say, We are unprofitable servants: we have done that which was our duty to do.  (Luke 17:10)&lt;/em&gt;</description>
        <pubDate>Mon, 22 Jan 2018 00:00:00 -0500</pubDate>
        <link>http://zipcpu.com/blog/2018/01/22/formal-progress.html</link>
        <guid isPermaLink="true">http://zipcpu.com/blog/2018/01/22/formal-progress.html</guid>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>Interpolation is just a special type of convolution</title>
        <description>&lt;p&gt;The most profound lessons I’ve learned regarding
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolation&lt;/a&gt;
were that first,
&lt;a href=&quot;https://en.wikipedia.org/wiki/Shift-invariant_system&quot;&gt;shift invariant&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolators&lt;/a&gt;
existed, and second that the effects of a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Shift-invariant_system&quot;&gt;shift invariant&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;
can be described in the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency_domain&quot;&gt;frequency domain&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;But let’s back up a step to tell this story from the beginning.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;Interpolation&lt;/a&gt;
refers to a class of methods or algorithms for reconstructing a waveform’s
value &lt;em&gt;between&lt;/em&gt; given sample points.
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;Interpolation&lt;/a&gt; is
an important part of any sample rate conversion algorithm.
As a result, it is studied as part of both
&lt;a href=&quot;https://en.wikipedia.org/wiki/Numerical_analysis&quot;&gt;numerical analysis&lt;/a&gt; is
as well as &lt;a href=&quot;https://en.wikipedia.org/wiki/Sample-rate_conversion&quot;&gt;mutirate digital signal
processing&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;As part of &lt;a href=&quot;http://zipcpu.com/&quot;&gt;this blog&lt;/a&gt;,
we’ve already discussed &lt;a href=&quot;/dsp/2017/06/06/simple-interpolator.html&quot;&gt;nearest-neighbour
interpolation&lt;/a&gt; and
&lt;a href=&quot;/dsp/2017/07/29/series-linear-interpolation.html&quot;&gt;linear interpolation&lt;/a&gt;.  Going further, though, requires a bit of a background
understanding.  Since the necessary background wasn’t something I learned
when I last studied
&lt;a href=&quot;https://en.wikipedia.org/wiki/Numerical_analysis&quot;&gt;numerical analysis&lt;/a&gt;,
I figured you might be interested as well.&lt;/p&gt;

&lt;p&gt;Today, therefore, let’s look beyond &lt;a href=&quot;/dsp/2017/07/29/series-linear-interpolation.html&quot;&gt;linear
interpolation&lt;/a&gt;
and lay the ground work for better
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
based &lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial&quot;&gt;polynomial&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolation&lt;/a&gt; algorithms.&lt;/p&gt;

&lt;h2 id=&quot;my-own-history-with-interpolation&quot;&gt;My own history with interpolation&lt;/h2&gt;

&lt;p&gt;I first became seriously interested in
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolation&lt;/a&gt;
when I tried to follow and recreate &lt;a href=&quot;https://ieeexplore.ieee.org/document/134480/&quot;&gt;William Gardner’s cyclostationary
signal processing results&lt;/a&gt;
as part of my &lt;a href=&quot;http://www.dtic.mil/dtic/tr/fulltext/u2/a423141.pdf&quot;&gt;Ph.D.
Research&lt;/a&gt;.
Gardner &lt;a href=&quot;https://ieeexplore.ieee.org/document/134480/&quot;&gt;had stated&lt;/a&gt; that by using
&lt;a href=&quot;https://en.wikipedia.org/wiki/Cyclostationary_process&quot;&gt;cyclostationary&lt;/a&gt;
methods, his &lt;a href=&quot;https://en.wikipedia.org/wiki/Multilateration&quot;&gt;time difference of arrival
(TDOA)&lt;/a&gt; algorithm could
outperform all others.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;These new algorithms are tolerant to both interfering signals and noise,
and they can outperform conventional algorithms that achieve the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Cramer-Rao_bound&quot;&gt;Cramer-Rao&lt;/a&gt;
lower bound on variance for stationary signals because the signals considered
here are nonstationary
(&lt;a href=&quot;https://en.wikipedia.org/wiki/Cyclostationary_process&quot;&gt;cyclostationary&lt;/a&gt;)
and the algorithms expoit the nonstationarity to discriminate against noise
and interference.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;A &lt;a href=&quot;https://en.wikipedia.org/wiki/Multilateration&quot;&gt;TDOA&lt;/a&gt; estimator,
for those not familiar with the algorithm, takes two input signals, where one
is nominally the other delayed by some amount of time, runs a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Cross-correlation&quot;&gt;cross-correlation&lt;/a&gt;
between them, and then finds the location of the maximum value that results.
[&lt;a href=&quot;http://theduchy.ualr.edu/wordpress/wp-content/uploads/2017/06/scan0007.pdf&quot;&gt;Ref&lt;/a&gt;]&lt;/p&gt;

&lt;p&gt;Gardner, however, had insisted in his problem setup that the two simulated
signals were to be delayed with respect to
each other by an &lt;em&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Integer&quot;&gt;integer&lt;/a&gt;
number of samples&lt;/em&gt;, and then &lt;em&gt;assumed the peak
would lie on a sample point&lt;/em&gt;.  This process skipped the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;
that would be necessary for any real life application, and so his
estimation errors suddenly (and artificially) dropped to zero.  This erroneous
result then overinflated the performance of his algorithm.&lt;/p&gt;

&lt;p&gt;This lead me to study the question of which
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;
is better when peak finding?&lt;/p&gt;

&lt;p&gt;Peak finding in &lt;a href=&quot;https://en.wikipedia.org/wiki/Multilateration&quot;&gt;TDOA&lt;/a&gt;
estimation, however, is only one purpose of an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;.
Other purposes for
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolation&lt;/a&gt;
aren’t hard to come by:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;Interpolators&lt;/a&gt;
are commonly needed to process audio signals.  They are used to &lt;a href=&quot;https://en.wikipedia.org/wiki/Sample-rate_conversion&quot;&gt;change
sampling rates&lt;/a&gt;, such
as from an 8kHz sample rate to a 44.1kHz sample rate, or from a 44.1kHz
sample rate to a 48kHz sample rate.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;Interpolators&lt;/a&gt; are used within
video display devices having a fixed resolution, to allow them to
display other resolutions.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;When I was working with
&lt;a href=&quot;https://en.wikipedia.org/wiki/Global_Positioning_System&quot;&gt;GPS&lt;/a&gt;
signals years ago, the digitizer would sample some
&lt;a href=&quot;https://en.wikipedia.org/wiki/Integer&quot;&gt;integer&lt;/a&gt;
number of samples per chip.  However, in order to use
&lt;a href=&quot;https://en.wikipedia.org/wiki/Fast_Fourier_transform&quot;&gt;Fast Fourier transform&lt;/a&gt;
signal processing methods, the data needs to be resampled from the 1023N
samples per block that came from the digitizer to &lt;code class=&quot;highlighter-rouge&quot;&gt;1024*2^M&lt;/code&gt;
samples per block–a power of two.  This requires an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Upsampling&quot;&gt;upsampling&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolation&lt;/a&gt;
rate of 1024/1023—a difficult ratio to achieve using
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sample-rate_conversion&quot;&gt;rational resampling&lt;/a&gt;
methods.  (In the end, we actually downsampled the signal by 8192/1023 …)&lt;/p&gt;

    &lt;p&gt;Indeed, &lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolation&lt;/a&gt; in a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Global_Positioning_System&quot;&gt;GPS&lt;/a&gt;
processing system isn’t limited to the front end (re)sampler.  It’s also
an important part of picking the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Cross-correlation&quot;&gt;correlation&lt;/a&gt;
peak that is part of the measurement used to determine your location as well.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Many &lt;a href=&quot;https://en.wikipedia.org/wiki/Sine_wave&quot;&gt;sine wave&lt;/a&gt;
implementations are based around a &lt;a href=&quot;/dsp/2017/07/11/simplest-sinewave-generator.html&quot;&gt;table
lookup&lt;/a&gt;.
If you want to control the distortion in the resulting
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sine_wave&quot;&gt;sine wave&lt;/a&gt;, knowing how the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt; responds is
important to evaluating how good your &lt;a href=&quot;/dsp/2017/07/11/simplest-sinewave-generator.html&quot;&gt;table
lookup&lt;/a&gt;
method is.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Most satellite &lt;a href=&quot;https://en.wikipedia.org/wiki/Orbit&quot;&gt;orbits&lt;/a&gt;
are communicated with sampled positions from a special
&lt;a href=&quot;https://en.wikipedia.org/wiki/Orbit&quot;&gt;orbital&lt;/a&gt;
propagator.  However,
&lt;a href=&quot;https://en.wikipedia.org/wiki/Satellite_navigation&quot;&gt;satellite navigation&lt;/a&gt;
work, such as
&lt;a href=&quot;https://en.wikipedia.org/wiki/Global_Positioning_System&quot;&gt;GPS&lt;/a&gt;, requires
knowing the satellite’s position often on nanosecond level timesteps.
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;Interpolation&lt;/a&gt; is used to
address the problem of determining what happens between the points.&lt;/p&gt;

    &lt;p&gt;Even better, as we’ll touch on below, if you can quantify the error in your
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;, such as by
using &lt;a href=&quot;https://en.wikipedia.org/wiki/Fourier_analysis&quot;&gt;Fourier analysis&lt;/a&gt;,
you can also quantify the error in your navigation system.  You might even
be able to relax the requirements of your numerical satellite propagation
engine with a sufficiently powerful
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;When I built a suite of tools for &lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_signal_processing&quot;&gt;digital signal
processing&lt;/a&gt;
and display years ago, I used an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt; as part of the
GUI to allow the user to zoom in on any signal by an arbitrary amount.  Even
better, by using a quadratic
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;,
the signal lost most of the obvious evidences of being sampled in the first
place.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;When presenting the &lt;a href=&quot;/dsp/2017/09/16/pwm-demo.html&quot;&gt;demonstration of the improved
PWM&lt;/a&gt; signal, we only used a
&lt;a href=&quot;/dsp/2017/06/06/simple-interpolator.html&quot;&gt;nearest-neighbour&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt; to go from the
audio sample rate to output samples.  Because we didn’t use a good
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;,
our test waveform had many &lt;a href=&quot;https://en.wikipedia.org/wiki/Aliasing&quot;&gt;aliasing&lt;/a&gt;
artifacts in addition to the artifacts due to the
&lt;a href=&quot;/dsp/2017/09/04/pwm-reinvention&quot;&gt;PWM&lt;/a&gt;
modulation.&lt;/p&gt;

    &lt;p&gt;Replacing the
&lt;a href=&quot;/dsp/2017/06/06/simple-interpolator.html&quot;&gt;nearest-neighbour&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;
with either a
&lt;a href=&quot;/dsp/2017/07/29/series-linear-interpolation.html&quot;&gt;linear&lt;/a&gt;
or quadratic
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;
would’ve removed most of those extra artifacts.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;While the description above highlights my own personal background and reasons
for studying
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolation&lt;/a&gt; theory after
my graduate studies, these few examples can hardly do justice to the number
of times and places where a good
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt; is required.
Hence, when it comes time for you to choose a good 
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;, you’ll want to
remember the lessons we are about to discuss.&lt;/p&gt;

&lt;h2 id=&quot;key-assumptions&quot;&gt;Key Assumptions&lt;/h2&gt;

&lt;p&gt;The field of &lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolation&lt;/a&gt;
is fairly well established with lots of approaches and “solutions”.  To limit
our discussion, therefore, we’ll need to make some assumptions about what
types of &lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolators&lt;/a&gt;
are appropriate for
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_signal_processing&quot;&gt;signal processing&lt;/a&gt;
on an &lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;.
You may wish to read this section carefully, though, because the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolation&lt;/a&gt; theory and
conclusions I’ll present later will be driven by these assumptions.&lt;/p&gt;

&lt;p&gt;The first couple of assumptions are quite basic to &lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_signal_processing&quot;&gt;digital signal
processing&lt;/a&gt; in general:
the input is assumed to be a
&lt;em&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;sampled&lt;/a&gt;
data stream&lt;/em&gt; that is formed from
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;sampling&lt;/a&gt;:
an &lt;em&gt;infinite signal source&lt;/em&gt; (in time) at &lt;em&gt;equidistant samples&lt;/em&gt;.
An example of such a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;sampled&lt;/a&gt;
signal is shown below in Fig 1.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 1. Sampled data, the beginning of any interpolation problem&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/sampled-data.png&quot; alt=&quot;This figure shows a picture of a swept frequency sine wave, that has been sampled.  The samples are represented by impulses, the original sinewave by a dotted curve&quot; width=&quot;595&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;In the figure above, you can see the sampled points represented by green
circles, and the original waveform in dotted gray.  The purpose of the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;
is to estimate or recover the signal between the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;sample&lt;/a&gt;
points.&lt;/p&gt;

&lt;p&gt;The waveform shown in Fig 1 above also makes a wonderful example waveform:
it is a swept frequency tone.  Hence, the frequency of the tone on the
left is lower than that on the right.  As a result, and as we’ll discuss,
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolating&lt;/a&gt;
the signal on the left side is easy, but it gets harder on the right.  Indeed,
you might notice within the figure
how &lt;a href=&quot;https://en.wikipedia.org/wiki/Aliasing&quot;&gt;aliasing&lt;/a&gt;
starts to dominate on the far right.  Indeed, this figure works as such a good
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolation&lt;/a&gt;
test, that I used it throughout the
&lt;a href=&quot;https://github.com/ZipCPU/interpolation/raw/master/tutorial.pdf&quot;&gt;tutorial slides&lt;/a&gt;
I built to discuss this the topic.  We can return to this later.&lt;/p&gt;

&lt;p&gt;For now, let’s introduce two further key assumptions.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;The first of these key assumptions is that we are looking for a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Linear_map&quot;&gt;linear operator&lt;/a&gt;.
Adding two
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;sample&lt;/a&gt;
streams together before applying the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;
should therefore produce an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolation&lt;/a&gt;
of their sum signal.  Multiplying the incoming signal by a constant (scalar)
should produce a scaled output signal.&lt;/p&gt;

    &lt;p&gt;While
&lt;a href=&quot;/dsp/2017/09/27/quantization.html&quot;&gt;quantization&lt;/a&gt;
will have an effect on these two properties of
&lt;a href=&quot;https://en.wikipedia.org/wiki/Linear_map&quot;&gt;linearity&lt;/a&gt;, let’s ignore it
for now and just focus on
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolating&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Real_number&quot;&gt;real&lt;/a&gt; signals.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The second and final key assumption is that that the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolation&lt;/a&gt;
approach we are interested in today is
&lt;em&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Shift-invariant_system&quot;&gt;shift invariant&lt;/a&gt;&lt;/em&gt;.
&lt;a href=&quot;https://en.wikipedia.org/wiki/Shift-invariant_system&quot;&gt;Shift invariance&lt;/a&gt;
in this case is a subtly different from the classic definition simply
because the input is a
&lt;em&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;sampled&lt;/a&gt;&lt;/em&gt;
data stream, defined over the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Domain_of_a_function&quot;&gt;domain&lt;/a&gt;
of all &lt;a href=&quot;https://en.wikipedia.org/wiki/Integer&quot;&gt;integers&lt;/a&gt;,
and the output is a signal defined over the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Domain_of_a_function&quot;&gt;domain&lt;/a&gt;
of &lt;a href=&quot;https://en.wikipedia.org/wiki/Real_number&quot;&gt;real numbers&lt;/a&gt;.  Therefore,
by shift invariant I mean that if you shift the incoming
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;sample&lt;/a&gt; stream
left or right by some &lt;a href=&quot;https://en.wikipedia.org/wiki/Integer&quot;&gt;integer&lt;/a&gt;
number of samples, &lt;code class=&quot;highlighter-rouge&quot;&gt;k&lt;/code&gt;, then the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolated&lt;/a&gt;
output stream (defined over the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Domain_of_a_function&quot;&gt;domain&lt;/a&gt;
of &lt;a href=&quot;https://en.wikipedia.org/wiki/Real_number&quot;&gt;real numbers&lt;/a&gt;) will
also shift by the same &lt;a href=&quot;https://en.wikipedia.org/wiki/Integer&quot;&gt;integer&lt;/a&gt;
amount.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;That’s not so hard, is it?&lt;/p&gt;

&lt;p&gt;The goal of any
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolation algorithm&lt;/a&gt;
is to estimate or recover the signal between the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;sample&lt;/a&gt;
points.  If you think about
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolation&lt;/a&gt;
in terms of Fig 1 above, the goal is to recover the gray dotted
line given only the green points.&lt;/p&gt;

&lt;p&gt;The above assumptions also drive the form of the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolation&lt;/a&gt;
solution.&lt;/p&gt;

&lt;p&gt;To see how this is the case, let’s start with a mathematical representation of
our &lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;sampled&lt;/a&gt;
signal, &lt;code class=&quot;highlighter-rouge&quot;&gt;x[n]&lt;/code&gt;, re-expressed as a series of
&lt;a href=&quot;https://en.wikipedia.org/wiki/Direc_delta_function&quot;&gt;Dirac delta functions&lt;/a&gt;
over the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Domain_of_a_function&quot;&gt;domain&lt;/a&gt;
of &lt;a href=&quot;https://en.wikipedia.org/wiki/Real_number&quot;&gt;real numbers&lt;/a&gt;.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/interp-x-made-continuous.png&quot; alt=&quot;x(t)=SUM x[n]d(t-n)&quot; width=&quot;277&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;In this representation, the function &lt;code class=&quot;highlighter-rouge&quot;&gt;x(t)&lt;/code&gt; is created from the discrete-time
input sequence &lt;code class=&quot;highlighter-rouge&quot;&gt;x[n]&lt;/code&gt; by a sum of scaled and offset
&lt;a href=&quot;https://en.wikipedia.org/wiki/Direc_delta_function&quot;&gt;Dirac delta functions&lt;/a&gt;.
Indeed, this was the meaning of the red impulses shown in Fig 1 above.  Each
&lt;a href=&quot;https://en.wikipedia.org/wiki/Direc_delta_function&quot;&gt;impulse&lt;/a&gt;
represents a scaled
&lt;a href=&quot;https://en.wikipedia.org/wiki/Direc_delta_function&quot;&gt;Dirac delta function&lt;/a&gt;,
at the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;sample&lt;/a&gt;
height, &lt;code class=&quot;highlighter-rouge&quot;&gt;x[n]&lt;/code&gt;, and location, &lt;code class=&quot;highlighter-rouge&quot;&gt;n&lt;/code&gt;, just as this equation describes.  These
&lt;a href=&quot;https://en.wikipedia.org/wiki/Direc_delta_function&quot;&gt;Dirac delta functions&lt;/a&gt;
are used to bridge the difference between the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;sampled&lt;/a&gt;
representation of a signal, &lt;code class=&quot;highlighter-rouge&quot;&gt;x[n]&lt;/code&gt;, and its continuous time equivalent,
&lt;code class=&quot;highlighter-rouge&quot;&gt;x(t)&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;We also know that every
&lt;a href=&quot;https://en.wikipedia.org/wiki/Linear_map&quot;&gt;linear&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Time-invariant_system&quot;&gt;time-invariant system&lt;/a&gt;
producing an output &lt;code class=&quot;highlighter-rouge&quot;&gt;y(t)&lt;/code&gt; from its input &lt;code class=&quot;highlighter-rouge&quot;&gt;x(t)&lt;/code&gt; can be represented by a
continuous-time
&lt;a href=&quot;https://en.wikipedia.org/wiki/Convolution&quot;&gt;convolution&lt;/a&gt;, such as the one
shown below.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/continuous-convolution.png&quot; alt=&quot;y(t)=INT h(tau)x(t-tau)&quot; width=&quot;300&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;At this point in our discussion, the form of the &lt;code class=&quot;highlighter-rouge&quot;&gt;h(t)&lt;/code&gt; that describes this
system is completely arbitrary.  It’s just a function of the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Real_number&quot;&gt;real numbers&lt;/a&gt;, producing a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Real_number&quot;&gt;real numbered&lt;/a&gt; output.  We’ll
come back later and pick a particular form to work with, but for now consider
&lt;code class=&quot;highlighter-rouge&quot;&gt;h(t)&lt;/code&gt; to be an arbitrary
&lt;a href=&quot;https://en.wikipedia.org/wiki/Real_number&quot;&gt;real&lt;/a&gt;
valued function.&lt;/p&gt;

&lt;p&gt;Since we’ve represented our original
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;sampled&lt;/a&gt;
signal, &lt;code class=&quot;highlighter-rouge&quot;&gt;x[n]&lt;/code&gt;, with a representation, &lt;code class=&quot;highlighter-rouge&quot;&gt;x(t)&lt;/code&gt;, composed of a set of scaled and
offset
&lt;a href=&quot;https://en.wikipedia.org/wiki/Direc_delta_function&quot;&gt;Dirac delta functions&lt;/a&gt;,
we can then substitute &lt;code class=&quot;highlighter-rouge&quot;&gt;x(t)&lt;/code&gt;
into this formula,&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/interp-xn-convolved.png&quot; alt=&quot;y(t)=INT h(tau) SUM x[n] d(t-tau-n)&quot; width=&quot;464&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;and then pull the summation out front,&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/interp-xn-convolved-2.png&quot; alt=&quot;y(t)=SUM x[n] INT h(tau) d(t-tau-n)&quot; width=&quot;440&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;The result is a 
&lt;a href=&quot;https://en.wikipedia.org/wiki/Convolution&quot;&gt;convolution&lt;/a&gt;
that we can evaluate.  Given the properties of the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Direc_delta_function&quot;&gt;Dirac delta functions&lt;/a&gt;,
any product of a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Direc_delta_function&quot;&gt;Dirac delta functions&lt;/a&gt;
and a function that is continuous near the region where the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Direc_delta_function&quot;&gt;Dirac delta functions&lt;/a&gt;
is non-zero, yet integrated over the point where the argument of the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Direc_delta_function&quot;&gt;Dirac delta functions&lt;/a&gt;
is goes through zero will simply yield the value of that other function at
that point.  In other words,&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/interp-is-convolution.png&quot; alt=&quot;y(t)=SUM x[n] INT h(tau) d(t-tau-n)&quot; width=&quot;275&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;and we’ve just proved that, under the assumptions we listed above,
&lt;em&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolation&lt;/a&gt;
is just another form of a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Convolution&quot;&gt;convolution&lt;/a&gt;.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;To see what I mean by this, consider Fig 2 below.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 2. Interpolation by Superposition&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/interpolation-superposition.png&quot; alt=&quot;&quot; width=&quot;810&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;In this figure, you can see the operation of the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Convolution&quot;&gt;convolution&lt;/a&gt;
taking place.  The figure shows the incoming
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;samples&lt;/a&gt;,
as green dots.  For each incoming
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;sample&lt;/a&gt;,
there is a scaled and weighted &lt;code class=&quot;highlighter-rouge&quot;&gt;h(t)&lt;/code&gt; function shown in gray.  Note how
this &lt;code class=&quot;highlighter-rouge&quot;&gt;h(t)&lt;/code&gt; function was designed so that the each gray line touches one
green circle, and yet goes through zero for the other circles.  Then, when
you sum all of these weighted and shifted &lt;code class=&quot;highlighter-rouge&quot;&gt;h(t)&lt;/code&gt; functions together, you get
the &lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolation&lt;/a&gt;
result shown in red.&lt;/p&gt;

&lt;p&gt;This conclusion has some major consequences for
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_signal_processing&quot;&gt;signal processing&lt;/a&gt;.
Among other things, it means we can use
&lt;a href=&quot;https://en.wikipedia.org/wiki/Fourier_analysis&quot;&gt;Fourier analysis&lt;/a&gt;
techniques to evaluate
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolators&lt;/a&gt;–just as we use
&lt;a href=&quot;https://en.wikipedia.org/wiki/Fourier_analysis&quot;&gt;Fourier analysis&lt;/a&gt; to evaluate
any other &lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filtering&lt;/a&gt;
operation.&lt;/p&gt;

&lt;p&gt;In particular, we can treat an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt; as nothing
more than an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Upsampling&quot;&gt;upsampling&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;.
Everything you’ve learned about
&lt;a href=&quot;https://en.wikipedia.org/wiki/Aliasing&quot;&gt;aliasing&lt;/a&gt; and
&lt;a href=&quot;https://en.wikipedia.org/wiki/Nyquist_rate&quot;&gt;Nyquist&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;sampling&lt;/a&gt;
applies now as it would with any other
&lt;a href=&quot;https://en.wikipedia.org/wiki/Upsampling&quot;&gt;upsampling&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Sadly, apart from the modern development of
&lt;a href=&quot;http://ieeexplore.ieee.org/document/15483/&quot;&gt;Farrow filters&lt;/a&gt;,
it seems that only a few
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolation&lt;/a&gt;
developments start from these assumptions.  We’ll discuss the consequences
of other choices quickly in the next section.&lt;/p&gt;

&lt;p&gt;Without loss of (too much) generality, we can use a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Piecewise&quot;&gt;piecewise&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial&quot;&gt;polynomial&lt;/a&gt;
to represent the &lt;code class=&quot;highlighter-rouge&quot;&gt;h(t)&lt;/code&gt; function above.  Doing so allows us to turn our
incoming
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;sampled&lt;/a&gt;
signal, &lt;code class=&quot;highlighter-rouge&quot;&gt;x[n]&lt;/code&gt;, into a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Piecewise&quot;&gt;piecewise&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial&quot;&gt;polynomial&lt;/a&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;y(t)&lt;/code&gt;, meaning
that what happens between
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;samples&lt;/a&gt;, i.e. the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;
result, can now be represented as a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Piecewise&quot;&gt;piecewise&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial&quot;&gt;polynomial&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Two &lt;a href=&quot;https://en.wikipedia.org/wiki/Piecewise&quot;&gt;piecewise&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial&quot;&gt;polynomial&lt;/a&gt;
forms are convenient for this purpose: those centered around the points
where the signal is defined, &lt;code class=&quot;highlighter-rouge&quot;&gt;[k-0.5,k+0.5)&lt;/code&gt; for
&lt;a href=&quot;https://en.wikipedia.org/wiki/Integer&quot;&gt;integers&lt;/a&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;k&lt;/code&gt;, and those defined between points
in a signal, such as &lt;code class=&quot;highlighter-rouge&quot;&gt;[k, k+1)&lt;/code&gt;.  We’ll come back to this more in a moment.&lt;/p&gt;

&lt;p&gt;So, to summarize, here were our assumptions:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;The incoming signal was
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;sampled&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;This will be the case with almost all
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_signal_processing&quot;&gt;DSP&lt;/a&gt;
applications.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The incoming signal is infinite in length.&lt;/p&gt;

    &lt;p&gt;While one might argue that this is never quite true, it is true that for most
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_signal_processing&quot;&gt;signal processing&lt;/a&gt;
applications there is often more data available than can be operated on at
any point in time.  For these applications, the difference between a signal
of truly infinite length and the perspective of the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_signal_processing&quot;&gt;signal processing&lt;/a&gt;
engine applied to a signal of finite length is quite irrelevant.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;All &lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;sample&lt;/a&gt;
times are equidistant&lt;/p&gt;

    &lt;p&gt;This is also true for most, although not all,
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_signal_processing&quot;&gt;DSP&lt;/a&gt;
applications.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The &lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;
must be
&lt;a href=&quot;https://en.wikipedia.org/wiki/Linear_map&quot;&gt;linear&lt;/a&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The resulting
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;
must also be shift invariant&lt;/p&gt;

    &lt;p&gt;This may be the &lt;em&gt;most significant assumption&lt;/em&gt; we’ve made along the way.
Indeed, it is this assumption that renders most of the other
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolation&lt;/a&gt;
developments inappropriate going forward–since they don’t preserve this
property.&lt;/p&gt;

    &lt;p&gt;It is also this assumption that makes
&lt;a href=&quot;https://en.wikipedia.org/wiki/Fourier_analysis&quot;&gt;Fourier analysis&lt;/a&gt; of
the &lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt; possible.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The &lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;’s
interpolation function, &lt;code class=&quot;highlighter-rouge&quot;&gt;h(t)&lt;/code&gt;, is formed from a set of
&lt;a href=&quot;https://en.wikipedia.org/wiki/Piecewise&quot;&gt;piecewise&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial&quot;&gt;polynomial&lt;/a&gt;s.&lt;/p&gt;

    &lt;p&gt;I’m sure there must be other useful
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolation&lt;/a&gt;
functions that are not formed from
&lt;a href=&quot;https://en.wikipedia.org/wiki/Piecewise&quot;&gt;piecewise&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial&quot;&gt;polynomial&lt;/a&gt;s.  However,
&lt;a href=&quot;https://en.wikipedia.org/wiki/Piecewise&quot;&gt;piecewise&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial&quot;&gt;polynomial&lt;/a&gt;s form a nice, easy
set to work with when implementing
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolators&lt;/a&gt; within
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;s–or
even &lt;a href=&quot;https://en.wikipedia.org/wiki/Embedded_system&quot;&gt;embedded&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;s for that
matter.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;For the most part, these are all quite common &lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_signal_processing&quot;&gt;digital signal
processing&lt;/a&gt;
assumptions, so I wouldn’t expect anyone to be surprised or shocked
at any of them.  What has surprised me was how rare these assumptions
are in the &lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolation&lt;/a&gt;
developments I’ve studied in the past.&lt;/p&gt;

&lt;h2 id=&quot;many-other-approaches-are-not-shift-invariant&quot;&gt;Many other approaches are not shift invariant&lt;/h2&gt;

&lt;p&gt;Since the assumptions above are not common
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolation&lt;/a&gt;
assumptions, let’s take a moment and investigate the significance of some
of them.&lt;/p&gt;

&lt;p&gt;Traditional &lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolation&lt;/a&gt;
approaches are commonly applied to only a &lt;em&gt;finite&lt;/em&gt; set of
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;sample&lt;/a&gt;
points found within a single, fixed, finite window of time.  This includes
most &lt;a href=&quot;https://en.wikipedia.org/wiki/Spline_interpolation&quot;&gt;spline interpolation&lt;/a&gt;
developments (these were always my favorites), &lt;a href=&quot;https://en.wikipedia.org/wiki/Chebyshev_polynomials&quot;&gt;Chebyshev polynomial
interpolation&lt;/a&gt;,
&lt;a href=&quot;https://en.wikipedia.org/wiki/Lagrange_polynomial&quot;&gt;Lagrange interpolation&lt;/a&gt;,
&lt;a href=&quot;https://en.wikipedia.org/wiki/Legendre_polynomials&quot;&gt;Legendre polynomial
interpolation&lt;/a&gt;
and more.&lt;/p&gt;

&lt;p&gt;These approaches, however, become less than ideal when applied to a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;sample&lt;/a&gt;
stream that is much longer than their finite time window.  Therefore, to make
these approaches viable, the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;sample&lt;/a&gt;
data stream is split into windows in time and the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;
is applied to each window.&lt;/p&gt;

&lt;p&gt;The problem with this sliding window approach revolves around what happens
at the edges where the algorithm transitions from one window to the next.
Because these
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolation&lt;/a&gt;
routines do nothing to guarantee that the result has controlled properties
between one window and the next, the transition region often suffers
from distortions not present in the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;’s
development.&lt;/p&gt;

&lt;p&gt;Nowhere is this more apparent than when combining a series of
&lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial_regression&quot;&gt;quadratic fit&lt;/a&gt;s
between
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;sample&lt;/a&gt;
points together to create a new
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolated&lt;/a&gt;
signal, such as is shown in Fig 3.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 3. The result of applying a series of sliding quadratic fits as an interpolation method&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/interpolation-discontinuous-quadratic.png&quot; alt=&quot;&quot; width=&quot;603&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;In this figure, every set of three adjacent sample points was used to create a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial_regression&quot;&gt;quadratic&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolation&lt;/a&gt;
function surrounding the middle sample.  The
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolation&lt;/a&gt;
function is only valid for plus or minus a half sample surrounding the
middle of those three points.  Outside of that region, a new
set of three samples is used to generate the next
&lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial_regression&quot;&gt;quadratic fit&lt;/a&gt;.
The resulting signal, shown in Fig 3 above, contains many unwanted
discontinuities that result from this sliding fit-window approach.&lt;/p&gt;

&lt;p&gt;Further, our desire to create an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolation&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;
that can be implemented within an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
will tend to push us away from other common
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt; structures,
such as &lt;a href=&quot;https://en.wikipedia.org/wiki/Trigonometric_interpolation&quot;&gt;trigonometric
interpolation&lt;/a&gt;,
or even &lt;a href=&quot;https://en.wikipedia.org/wiki/Rational_function&quot;&gt;rational function&lt;/a&gt;
evaluation, since these
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolators&lt;/a&gt;
depend upon functions that are more difficult to calculate within
&lt;a href=&quot;https://en.wikipedia.org/wiki/Hardware_deescription_language&quot;&gt;RTL logic&lt;/a&gt;.
That leaves us stuck with
&lt;a href=&quot;https://en.wikipedia.org/wiki/Piecewise&quot;&gt;piecewise&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial&quot;&gt;polynomial&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolation&lt;/a&gt;
functions.&lt;/p&gt;

&lt;p&gt;Not all of the other approaches avoid
&lt;a href=&quot;https://en.wikipedia.org/wiki/Shift-invariant_system&quot;&gt;shift invariance&lt;/a&gt;.
For example, the &lt;a href=&quot;https://en.wikipedia.org/wiki/Whittaker-Shannon_interpolation_formula&quot;&gt;Whittaker-Shannon&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolation&lt;/a&gt;
approach creates a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Shift-invariant_system&quot;&gt;shift invariant&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;
that can be applied to the infinite sample sets discussed above.  However, the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sinc_function&quot;&gt;sinc functions&lt;/a&gt;
it is based upon render &lt;code class=&quot;highlighter-rouge&quot;&gt;h(t)&lt;/code&gt; infinite in length, making this approach
difficult to implement.&lt;/p&gt;

&lt;p&gt;As a result, this leaves us with only one practical
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt; choice,
which we shall discuss in the next section.&lt;/p&gt;

&lt;h2 id=&quot;farrow-filters&quot;&gt;Farrow Filters&lt;/h2&gt;

&lt;p&gt;The only viable
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolation&lt;/a&gt;
alternative remaining within this set of assumptions is a
&lt;a href=&quot;http://ieeexplore.ieee.org/document/15483/&quot;&gt;Farrow filter&lt;/a&gt;.  Indeed, the
assumptions we’ve arrived at so far force us towards a
&lt;a href=&quot;http://ieeexplore.ieee.org/document/15483/&quot;&gt;Farrow filter&lt;/a&gt;, leaving us no
other alternative.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 4. A Piecewise Polynomial interpolation filter&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/interpolation-piecewise-poly.png&quot; alt=&quot;&quot; width=&quot;431&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;When using the &lt;a href=&quot;http://ieeexplore.ieee.org/document/15483/&quot;&gt;Farrow filter&lt;/a&gt;
approach, the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolation&lt;/a&gt;
function, &lt;code class=&quot;highlighter-rouge&quot;&gt;h(t)&lt;/code&gt;, is formed from a set of
&lt;a href=&quot;https://en.wikipedia.org/wiki/Piecewise&quot;&gt;piecewise&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial&quot;&gt;polynomials&lt;/a&gt;.  An example of one
such filter composed of
&lt;a href=&quot;https://en.wikipedia.org/wiki/Piecewise&quot;&gt;piecewise&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial&quot;&gt;quadratics&lt;/a&gt;
is shown in Fig 4 on the right.&lt;/p&gt;

&lt;p&gt;According to
&lt;a href=&quot;http://ieeexplore.ieee.org/document/15483/&quot;&gt;Farrow’s paper&lt;/a&gt;, the actual
“amount of delay”, i.e. the &lt;code class=&quot;highlighter-rouge&quot;&gt;t&lt;/code&gt; value when calculating the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolation&lt;/a&gt;
result, need not be calculated until it is needed.  This
is perfect for what we might wish to accomplish within an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The only question remaining is, what
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolation&lt;/a&gt;
function, &lt;code class=&quot;highlighter-rouge&quot;&gt;h(t)&lt;/code&gt;, shall we use?&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://ieeexplore.ieee.org/document/00679201/&quot;&gt;Fred Harris&lt;/a&gt; presents a
solution to
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolation&lt;/a&gt;
function generation based upon first designing a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;discrete-time filter&lt;/a&gt;
of many taps, and then approximating that function with a higher order
&lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial&quot;&gt;polynomial&lt;/a&gt;.
You may find this approach a valid solution to your
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolation&lt;/a&gt;
needs.  It is actually commonly used.&lt;/p&gt;

&lt;p&gt;I just haven’t found &lt;a href=&quot;http://ieeexplore.ieee.org/document/00679201/&quot;&gt;Harris’s ad-hoc filter derivation
method&lt;/a&gt;
personally very satisfying.  Ever since finding
&lt;a href=&quot;http://ieeexplore.ieee.org/document/00679201/&quot;&gt;Harris&lt;/a&gt;’s work, I’ve wanted
to know if there were a more rigorous and less ad-hoc approach to generating
these coefficients.  Is there some way, therefore, that an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;
can be developed using this technique and yet still meeting some
optimality properties?&lt;/p&gt;

&lt;p&gt;The answer is, yes there is, but also that we won’t get that far today. 
Instead, we’ll just lay the ground work for understanding and analyzing
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filters&lt;/a&gt;
of &lt;a href=&quot;http://ieeexplore.ieee.org/document/15483/&quot;&gt;this type&lt;/a&gt;.
Then, later, we’ll use this approach in order to develop &lt;em&gt;optimal&lt;/em&gt;
(in some sense)
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolation&lt;/a&gt; functions and their
&lt;a href=&quot;https://en.wikipedia.org/wiki/Piecewise&quot;&gt;piecewise&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial&quot;&gt;polynomial&lt;/a&gt;
coefficients.&lt;/p&gt;

&lt;h2 id=&quot;some-example-filters&quot;&gt;Some example filters&lt;/h2&gt;

&lt;p&gt;For now, let’s demonstrate some example
&lt;a href=&quot;http://ieeexplore.ieee.org/document/15483/&quot;&gt;Farrow filters&lt;/a&gt;.
Our examples will have a much lower order than those either
&lt;a href=&quot;http://ieeexplore.ieee.org/document/15483/&quot;&gt;Farrow&lt;/a&gt;
or &lt;a href=&quot;http://ieeexplore.ieee.org/document/00679201/&quot;&gt;Harris&lt;/a&gt; used, but the lower
order might help to make
&lt;a href=&quot;http://ieeexplore.ieee.org/document/15483/&quot;&gt;these filters&lt;/a&gt;
more understandable.&lt;/p&gt;

&lt;h3 id=&quot;sample-and-hold&quot;&gt;Sample and hold&lt;/h3&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 5. Sample and Hold&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/interpolation-fig-shold.png&quot; alt=&quot;&quot; width=&quot;325&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;The first &lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;
we discussed on
&lt;a href=&quot;http://zipcpu.com/&quot;&gt;this blog&lt;/a&gt;
was a sample and hold function.  While this may not seem like much of an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;,
it can be shown to have the form shown in Fig 5 on the right, and in
the equation below:&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/interpolation-eqn-shold.png&quot; alt=&quot;h(t) = 1, for 0&amp;lt;t&amp;lt;1, 0 ow&quot; width=&quot;250&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;This is actually a common
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolation&lt;/a&gt;
function in many mixed signal components, so it is worth recognizing.&lt;/p&gt;

&lt;p&gt;While this a common
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolation&lt;/a&gt;
function in many practical mixed signal
components, I’d like to do better.  Let’s keep looking, therefore.&lt;/p&gt;

&lt;h3 id=&quot;nearest-neighbour&quot;&gt;Nearest Neighbour&lt;/h3&gt;

&lt;p&gt;A similar &lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolation&lt;/a&gt;
function is the
&lt;a href=&quot;/dsp/2017/06/06/simple-interpolator.html&quot;&gt;nearest neighbor&lt;/a&gt;
function.  This has
an almost identical form for &lt;code class=&quot;highlighter-rouge&quot;&gt;h(t)&lt;/code&gt; as the sample-and-hold function above,
save that this time &lt;code class=&quot;highlighter-rouge&quot;&gt;h(t)&lt;/code&gt; is centered about the y-axis.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/interpolation-eqn-nnbor.png&quot; alt=&quot;h(t) = 1, for |t|&amp;lt;1/2, 0 ow&quot; width=&quot;252&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;It isn’t all that difficult to prove that the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Fourier_transform&quot;&gt;Fourier&lt;/a&gt;
transform of this function is a familiar
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sinc_funtion&quot;&gt;sinc function&lt;/a&gt;, which decays
out of band at a rate of &lt;code class=&quot;highlighter-rouge&quot;&gt;1/f&lt;/code&gt;.  Fig 6 below shows both this &lt;code class=&quot;highlighter-rouge&quot;&gt;h(t)&lt;/code&gt; function,
on the left, as well as its
&lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency_response&quot;&gt;frequency response&lt;/a&gt;
on the right.  Also shown on the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency_response&quot;&gt;frequency response&lt;/a&gt;
chart is a &lt;code class=&quot;highlighter-rouge&quot;&gt;1/f&lt;/code&gt; asymptote.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 6. Nearest Neighbor interpolation function and frequency response&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/interpolation-fig-nnbor.png&quot; alt=&quot;&quot; width=&quot;730&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;The asymptotic performance can be controlled in
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;
design to achieve specific performance measures, if desired.  You’ll be able
to see this as we continue.&lt;/p&gt;

&lt;h3 id=&quot;linear-interpolation&quot;&gt;Linear interpolation&lt;/h3&gt;

&lt;p&gt;If you &lt;a href=&quot;https://en.wikipedia.org/wiki/Convolution&quot;&gt;convolve&lt;/a&gt;
the &lt;a href=&quot;https://en.wikipedia.org/wiki/Rectangular_function&quot;&gt;rectangle function&lt;/a&gt;
that is the
&lt;a href=&quot;/dsp/2017/06/06/simple-interpolator.html&quot;&gt;nearest neighbor&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;
with itself, you will get a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Triangle_function&quot;&gt;triangle functions&lt;/a&gt;,&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/interpolation-eqn-linear.png&quot; alt=&quot;h(t) = 1-|t|^2, for |t|&amp;lt;1/2&quot; width=&quot;297&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Since
&lt;a href=&quot;https://en.wikipedia.org/wiki/Convolution&quot;&gt;convolution&lt;/a&gt;
in time is multiplication in frequency, the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Fourier_transform&quot;&gt;Fourier&lt;/a&gt;
transform of this function is simply a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sinc_funtion&quot;&gt;sinc function&lt;/a&gt; squared.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 7. Linear interpolation function and frequency response&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/interpolation-fig-linear.png&quot; alt=&quot;&quot; width=&quot;730&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;This creates a &lt;code class=&quot;highlighter-rouge&quot;&gt;1/f^2&lt;/code&gt; asymptote, shown above.  As a result, any out of band
&lt;a href=&quot;https://en.wikipedia.org/wiki/Aliasing&quot;&gt;aliasing&lt;/a&gt;
artifacts are further attenuated by this filter.&lt;/p&gt;

&lt;h3 id=&quot;quadratic-fit&quot;&gt;Quadratic Fit&lt;/h3&gt;

&lt;p&gt;With a little bit of work, the typical quadratic fit function, the one
producing the result in Fig 3 above, can also be
represented in this form.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/interpolation-eqn-qfit.png&quot; alt=&quot;Quadratic fit eqn&quot; width=&quot;396&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 8. Quadratic fit function&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/interpolation-fig-qfit.png&quot; alt=&quot;&quot; width=&quot;325&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;This function, however, isn’t continuous at all.  Indeed, when you plot it
out, as in Fig 8 to the right, you’ll get a feel for why the quadratic fit
in Fig 3 above looked as horrible as it did.&lt;/p&gt;

&lt;p&gt;But, what happened?  Why does this look nothing like a quadratic fit?&lt;/p&gt;

&lt;p&gt;Well, actually, it does.  If you extend the middle section on both sides,
you can see that it comes down and hits the axis at &lt;code class=&quot;highlighter-rouge&quot;&gt;x=-1&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;x=1&lt;/code&gt;.  In
a similar fashion, if you extend either of the wings out, you’ll see they
hit &lt;code class=&quot;highlighter-rouge&quot;&gt;y(0)=1&lt;/code&gt; and either &lt;code class=&quot;highlighter-rouge&quot;&gt;y(-2)=0&lt;/code&gt; or &lt;code class=&quot;highlighter-rouge&quot;&gt;y(2)=0&lt;/code&gt; respectively.  We created
exactly what we tried to create, but by moving from one fitting window
to the next we also created the discontinuous artifacts shown in Fig 8.&lt;/p&gt;

&lt;p&gt;This really shouldn’t be surprising.  When we created our quadratic fit,
we did nothing to control the transitions from one fitting region to another.
Fig 8 just shows the effects of such a choice on the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;
that results.&lt;/p&gt;

&lt;h3 id=&quot;smoothed-quadratic&quot;&gt;Smoothed quadratic&lt;/h3&gt;

&lt;p&gt;If &lt;a href=&quot;https://en.wikipedia.org/wiki/Convolution&quot;&gt;convolving&lt;/a&gt;
a &lt;a href=&quot;https://en.wikipedia.org/wiki/Rectangular_function&quot;&gt;rectangle&lt;/a&gt;
with itself generated a nice &lt;a href=&quot;/dsp/2017/07/29/series-linear-interpolation.html&quot;&gt;linear
interpolation&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Triangle_function&quot;&gt;triangle function&lt;/a&gt;,
what do you think you would you get from
&lt;a href=&quot;https://en.wikipedia.org/wiki/Convolution&quot;&gt;convolving&lt;/a&gt; a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Triangle_function&quot;&gt;triangle function&lt;/a&gt;
with that same
&lt;a href=&quot;https://en.wikipedia.org/wiki/Rectangular_function&quot;&gt;rectangle&lt;/a&gt;?  You will
get a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Piecewise&quot;&gt;piecewise&lt;/a&gt;
quadratic
&lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial&quot;&gt;polynomial&lt;/a&gt;
function whose
&lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency_response&quot;&gt;frequency response&lt;/a&gt;
decays at &lt;code class=&quot;highlighter-rouge&quot;&gt;1/f^3&lt;/code&gt;–as fast or faster than any other
&lt;a href=&quot;https://en.wikipedia.org/wiki/Piecewise&quot;&gt;piecewise&lt;/a&gt;
quadratic
&lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial&quot;&gt;polynomial&lt;/a&gt;
function.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/interpolation-eqn-rectcubed.png&quot; alt=&quot;Quadratic eqn for the quadratic created by convolving a rectangle with itself three times&quot; width=&quot;402&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;The only problem with this function is that it is no longer a true
&lt;a href=&quot;/dsp/2017/07/29/series-linear-interpolation.html&quot;&gt;interpolator&lt;/a&gt;.
By that I mean that if you were to
&lt;a href=&quot;https://en.wikipedia.org/wiki/Convolution&quot;&gt;convolve&lt;/a&gt;
your sampled data, &lt;code class=&quot;highlighter-rouge&quot;&gt;x[n]&lt;/code&gt;, with this function, then the continuous output
function, &lt;code class=&quot;highlighter-rouge&quot;&gt;y(t)&lt;/code&gt;, that would result would no longer necessarily match
&lt;code class=&quot;highlighter-rouge&quot;&gt;x[n]&lt;/code&gt; whenever &lt;code class=&quot;highlighter-rouge&quot;&gt;t=n&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;This is a result of the fact that &lt;code class=&quot;highlighter-rouge&quot;&gt;h(n)&lt;/code&gt; doesn’t equal zero for all
&lt;a href=&quot;https://en.wikipedia.org/wiki/Integer&quot;&gt;integers&lt;/a&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;n&lt;/code&gt;, where &lt;code class=&quot;highlighter-rouge&quot;&gt;n != 0&lt;/code&gt;.
You can see from Fig 9 below that this
function certainly doesn’t go through zero at &lt;code class=&quot;highlighter-rouge&quot;&gt;t=1&lt;/code&gt; as just one example.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 9. Smoother Quadratic function and frequency response&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/interpolation-fig-rcubd.png&quot; alt=&quot;&quot; width=&quot;730&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;The good news, though, is that the &lt;code class=&quot;highlighter-rouge&quot;&gt;1/f^3&lt;/code&gt; falloff was one of the best we’ve
seen yet–as shown by the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency_response&quot;&gt;frequency response&lt;/a&gt;
function on the right of Fig 9 above.&lt;/p&gt;

&lt;p&gt;Since we are trying to create
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolators&lt;/a&gt;,
a function that isn’t an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;
isn’t very acceptable.  Therefore let’s remember this function
while looking for an better alternative.&lt;/p&gt;

&lt;h3 id=&quot;ideal-interpolator&quot;&gt;Ideal Interpolator&lt;/h3&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 10. Ideal interpolator&#39;s frequency response&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/interpolation-fig-ideal.png&quot; alt=&quot;&quot; width=&quot;370&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Much as it is possible with traditional
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filtering&lt;/a&gt;
methods to specify an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sinc_filter&quot;&gt;ideal filter&lt;/a&gt;,
the same can be done with
&lt;a href=&quot;http://ieeexplore.ieee.org/document/15483/&quot;&gt;interpolation filters&lt;/a&gt;
as well.&lt;/p&gt;

&lt;p&gt;Shown in Fig 10 at the right is the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency_response&quot;&gt;frequency response&lt;/a&gt;
of an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sinc_filter&quot;&gt;ideal&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolation&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;.
As you might expect, this function passes all frequencies below the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Nyquist_rate&quot;&gt;Nyquist&lt;/a&gt;
frequency, and stops all frequencies above that.&lt;/p&gt;

&lt;p&gt;However, as with the development of more traditional
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filters&lt;/a&gt;,
this
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;
is also infinite in length, doesn’t fit nicely into a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Piecewise&quot;&gt;piecewise&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial&quot;&gt;polynomial&lt;/a&gt;
representation, and thus isn’t very suitable for practical work.&lt;/p&gt;

&lt;p&gt;It is suitable, however, for discussing the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sinc_filter&quot;&gt;ideal&lt;/a&gt;
that we would like our practical
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filters&lt;/a&gt;
to approach in terms of performance.  Therefore, we shall judge that the
closer an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolation&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter’s&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency_response&quot;&gt;frequency response&lt;/a&gt;
approximates this
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sinc_filter&quot;&gt;ideal&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;,
the better the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolation&lt;/a&gt;
will be.&lt;/p&gt;

&lt;h3 id=&quot;better-quadratic&quot;&gt;Better Quadratic&lt;/h3&gt;

&lt;p&gt;With a bit more work, we can come up with a better quadratic
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolation&lt;/a&gt;
function.  This function, shown in Fig 11 below, has a much wider
“&lt;a href=&quot;https://en.wikipedia.org/wiki/Passband&quot;&gt;passband&lt;/a&gt;”,
while still maintaining the &lt;code class=&quot;highlighter-rouge&quot;&gt;1/f^2&lt;/code&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Stopband&quot;&gt;stopband&lt;/a&gt;
fall off that the &lt;a href=&quot;/dsp/2017/07/29/series-linear-interpolation.html&quot;&gt;linear
interpolator&lt;/a&gt; had.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 11. A better quadratic interpolator function and frequency response&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/interpolation-fig-betterq.png&quot; alt=&quot;&quot; width=&quot;728&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Not only that, but this
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;
comes closer to the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sinc_filter&quot;&gt;ideal&lt;/a&gt;
in both
&lt;a href=&quot;https://en.wikipedia.org/wiki/Passband&quot;&gt;passband&lt;/a&gt; and
&lt;a href=&quot;https://en.wikipedia.org/wiki/Stopband&quot;&gt;stopband&lt;/a&gt;
then our last attempt did.  Hence, while maintaining the asymptotic
performance of a
&lt;a href=&quot;/dsp/2017/07/29/series-linear-interpolation.html&quot;&gt;linear interpolator&lt;/a&gt;,
we’ve achieved better performance at lower frequencies.  Further, the nulls
are deeper and wider than the
&lt;a href=&quot;/dsp/2017/07/29/series-linear-interpolation.html&quot;&gt;linear interpolator&lt;/a&gt; shown in Fig 7 above.&lt;/p&gt;

&lt;p&gt;For these reasons, this will be the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;
we’ll implement and demonstrate when we come back and look at quadratic
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolation&lt;/a&gt;
performance in a later post.&lt;/p&gt;

&lt;h3 id=&quot;can-we-do-better&quot;&gt;Can we do better?&lt;/h3&gt;

&lt;p&gt;I think the answer to this question is, yes, we can do even better than this.
However, I have yet to see the formal theory behind optimally generating
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolation&lt;/a&gt;
functions such as these.&lt;/p&gt;

&lt;p&gt;For now, consider this question: can the ad-hoc
&lt;a href=&quot;http://ieeexplore.ieee.org/document/15483/&quot;&gt;Farrow&lt;/a&gt; filter functions that
&lt;a href=&quot;http://ieeexplore.ieee.org/document/00679201/&quot;&gt;Harris&lt;/a&gt; espouses be
rewritten as discrete
&lt;a href=&quot;https://en.wikipedia.org/wiki/Convolution&quot;&gt;convolutions&lt;/a&gt;
of functions which are formed by
&lt;a href=&quot;https://en.wikipedia.org/wiki/Convolution&quot;&gt;convolving&lt;/a&gt; a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Rectangular_function&quot;&gt;rectangle&lt;/a&gt;
rectangle with itself many times?  If so, you could choose the rate at
which the stop band falls off, whether &lt;code class=&quot;highlighter-rouge&quot;&gt;1/f&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;1/f^2&lt;/code&gt;, etc, by choosing
which subset of these functions you wish to use when generating your
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolation&lt;/a&gt;
function.&lt;/p&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;Selecting a “good”
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolation&lt;/a&gt;
method for your signal processing application
starts with the right set of assumptions.  Indeed, the single most critical
assumption required for good
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;
development is that the resulting
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolation&lt;/a&gt;
method must be shift invariant.
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;Interpolation&lt;/a&gt;
routines chosen without this property are likely to suffer uncontrolled
effects as the interval defining the function changes with time.&lt;/p&gt;

&lt;p&gt;This, however, is only the beginning of the study of
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolation&lt;/a&gt;
for
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_signal_processing&quot;&gt;DSP&lt;/a&gt;
applications within
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;s.
While it opens up the topic by providing the necessary background, more
remains to be covered.  For example:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;It is possible, although perhaps not all that practical, to create a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Spline_interpolation&quot;&gt;spline&lt;/a&gt;
development under these assumptions.  Although the typical
&lt;a href=&quot;https://en.wikipedia.org/wiki/Spline_interpolation&quot;&gt;spline&lt;/a&gt;
development depends upon a difficult matrix inversion, an alternative
&lt;a href=&quot;https://en.wikipedia.org/wiki/Spline_interpolation&quot;&gt;spline&lt;/a&gt;
development exists which doesn’t depend upon any real-time matrix inversion.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Using this approach, we can now build some very useful and generic
quadratic
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolators&lt;/a&gt;.
Two in particular will be worth discussing: a quadratic
&lt;a href=&quot;https://en.wikipedia.org/wiki/Upsampling&quot;&gt;upsampling&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;
which may be used for
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sample-rate_conversion&quot;&gt;resampling&lt;/a&gt;
or tracking applications, and an improved
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sine_wave&quot;&gt;sine wave&lt;/a&gt; &lt;a href=&quot;/dsp/2017/07/11/simplest-sinewave-generator.html&quot;&gt;table
lookup&lt;/a&gt;
method.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Finally, it might be fun to see if it is possible to generate an &lt;em&gt;optimum&lt;/em&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;
by some measure of optimality.&lt;/p&gt;

&lt;p&gt;While I intend to come back to this topic, if you are
interested in more information about the types of
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolators&lt;/a&gt;
discussed above before that time, feel free to check out my &lt;a href=&quot;https://github.com/ZipCPU/interpolation/raw/master/tutorial.pdf&quot;&gt;tutorial
slides&lt;/a&gt;
on the topic.&lt;/p&gt;
&lt;hr /&gt;&lt;p&gt;&lt;em&gt;Is it fit to say to a king, Thou art wicked? and to princes, Ye are ungodly?  (Job 34:18)&lt;/em&gt;</description>
        <pubDate>Tue, 16 Jan 2018 00:00:00 -0500</pubDate>
        <link>http://zipcpu.com/dsp/2018/01/16/interpolation-is-convolution.html</link>
        <guid isPermaLink="true">http://zipcpu.com/dsp/2018/01/16/interpolation-is-convolution.html</guid>
        
        
        <category>dsp</category>
        
      </item>
    
  </channel>
</rss>
