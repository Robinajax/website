<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>The ZipCPU by Gisselquist Technology</title>
    <description>The ZipCPU blog, featuring how to discussions of FPGA and CPU design. This site will be focused on Verilog solutions, using exclusively OpenSource IP products for FPGA design.
</description>
    <link>http://zipcpu.com/</link>
    <atom:link href="http://zipcpu.com/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Sat, 20 May 2017 06:33:25 -0400</pubDate>
    <lastBuildDate>Sat, 20 May 2017 06:33:25 -0400</lastBuildDate>
    <generator>Jekyll v3.0.1</generator>
    
      <item>
        <title>What&#39;s wrong with Vivado&#39;s Design Flow</title>
        <description>&lt;ul&gt;
  &lt;li&gt;Not a problem for the wealthy, wholly inappropriate for the student&lt;/li&gt;
  &lt;li&gt;The student needs to learn how to build, not&lt;/li&gt;
  &lt;li&gt;Proprietary&lt;/li&gt;
  &lt;li&gt;Hard to debug&lt;/li&gt;
  &lt;li&gt;Cannot be simulated with open source tools&lt;/li&gt;
  &lt;li&gt;Doesn’t teach digital logic design, by obfuscating key details&lt;/li&gt;
  &lt;li&gt;A design working with one version of Vivado is often broken by the next&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Hello !&lt;/p&gt;

&lt;p&gt;I’m currently working on a project which consists in designing a digital lock-in amplifier on a FPGA board. For this, I am using a Nexys 4 DDR and an Analog Device’s ADC (EVAL AD7984 PMDZ).&lt;/p&gt;

&lt;p&gt;My first goal is to interface properly the ADC component with the FPGA using a Pmod port.&lt;/p&gt;

&lt;p&gt;I have some basics knowledge about the use of Vivado so that’s why I am asking you about this. I followed the tutorials about “getting started about MicroBlaze” to follow then “using Pmods IP”.&lt;/p&gt;

&lt;p&gt;My question is :&lt;/p&gt;

&lt;p&gt;When I followed the first tutorial mentionned above, we created a a basic Microblaze block design. Do I have to use all this design or is it possible to do easier ?&lt;/p&gt;

&lt;p&gt;And, do I have to design it with MicroBlaze or can I just write some VHDL code ?&lt;/p&gt;

&lt;p&gt;I want in a first part, to give a signal input in the ADC and then, light a LED on the board to confirm that the FPGA is well connected with the ADC. Can you, please, give me a plan to achieve my goal ? I don’t ask for a solution, I want to manage it by myself, but just some help to know what are the steps I have to follow.&lt;/p&gt;

&lt;p&gt;Thank you very much ! Have a good day !&lt;/p&gt;

&lt;p&gt;Welcome @Yannick!&lt;/p&gt;

&lt;p&gt;You can use either Microblaze or pure VHDL, depending on the needs of your project. If you want to do some heavier calculations involving the ADC data later, it will be easier to use Microblaze. Pure VHDL uses less onboard resources, but takes more work to do properly for complicated designs.&lt;/p&gt;

&lt;p&gt;For your first step, you have two options, use one of the provided Pmod IPs for a dual SPI/GPIO interface, and modify the C drivers for your design on Microblaze. I do not believe any of our provided designs support an equivalent of the CNV conversion pin on your ADC, hence, tying that to a bottom-row GPIO interface is likely the way to go (perhaps hacking something together from the Pmod ACL IP core). Or, you can write a custom VHDL SPI controller, with a small top-level controller sitting above it capturing data and handling your “connection established” LED.&lt;/p&gt;

&lt;p&gt;Which route you choose is up to you, but consider how complex your final design needs to be, Microblaze might not be worth it at this stage, but if you want to control your design through C later, you will want it.&lt;/p&gt;

&lt;p&gt;Hope this helps,&lt;/p&gt;

&lt;p&gt;Arthur&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Quote 

0
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;D@n&lt;/p&gt;

&lt;p&gt;@Yannick,&lt;/p&gt;

&lt;p&gt;May I provide you with an alternative view?&lt;/p&gt;

&lt;p&gt;You don’t need MicroBlaze at all.  Indeed, you can control your design from an external PC without MicroBlaze, and hence still “control it from C”–I do it all the time.  Sure, it’s slower but … the real issue isn’t your favorite way of controlling the board as @artvvb suggests, but rather … what do you wish to do with that ADC data?  And how fast you need the board to respond to your control inputs?&lt;/p&gt;

&lt;p&gt;Your first step, as you suggested, is to light an LED.  Cool.  That’s a nice first step.  But … think that first step through a little more: how will you know, if something is going wrong, what is going wrong?  You need to add logic into your design to answer this question.  Indeed, the sooner you add this logic into your design, the easier things will be to debug as your design becomes more complicated.  At the same time, I doubt this is your entire project, am I right?  This is only the first step?  So, let’s think this through some more.&lt;/p&gt;

&lt;p&gt;Do you want to fill up your Nexys-4 DDR’s memory with ADC data and read it back off slowly?  You might find your memory needs competing with MicroBlaze, should you choose to use MicroBlaze.&lt;/p&gt;

&lt;p&gt;Do you want to read from the ADC, do some on-board processing, and then output the results in real-time?  In that case, depending upon the processing you wish to do, MicroBlaze may or may not be overkill.  My general rule of thumb is that if the ADC sample rate is anything above audio rates, don’t use the onboard processor to process the data.  Even this isn’t necessarily the best rule of thumb, depending upon how you have the processor configured.&lt;/p&gt;

&lt;p&gt;But … let’s look at this from another standpoint, you bought an FPGA board so that you could do somethings that you couldn’t do on a cheaper RPi board, right?  If all the MicroBlaze does for you is turn your FPGA into a more expensive version of an RPi, then … something is wrong in your pocket book.&lt;/p&gt;

&lt;p&gt;So, going back to your questions:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Do you have to follow the microblaze design?  No.  Are their easier ways?  IMHO, yes.  MicroBlaze is a proprietary CPU design.  Other, non-proprietary designs are out there.  You can find some of these on OpenCores.  I&#39;ve personally been working with the ZipCPU.
Do you have to design with MicroBlaze?  No.  Can you just write HDL code?  Absolutely.
Plan?  Look across your whole project, and answer some questions:
    How do you plan on debugging your design?  When things don&#39;t work, how will you know what&#39;s not working?  (MicroBlaze is notoriously difficult to debug--it can be hard to know why it does or doesn&#39;t do something.)  I tend to use a homebrew scope to see what&#39;s going on within a design.
    Will your data need to be stored in that DDR3 SDRAM memory?  If so, you&#39;ll need a bus somewhere within your design.  MicroBlaze likes to connect everything up to an AXI4 bus.  I personally like the wishbone myself, but I have to convert wishbone to AXI4 to get access to anything generated by Xilinx&#39;s Memory Interface Generator (MIG).
    Will the FPGA be acting as a standalone device, or always connected to a PC USB umbilical cord?  I personally tend to convert the PC USB UART channel into a bus command/access channel, so I can see what I have going on.  It makes it easy to both debug, as well as command and control the FPGA from a PC.  While not necessary in your final version, you might find the scaffolding valuable along the way.
    How will you be controlling your design?  From C somewhere?  On a host computer?  Internal to the FPGA (MicroBlaze/ZipCPU)?  For me, I do both.  I first control things from the host PC, and then when I want to do more/faster, I move that control to the FPGA/ZipCPU and monitor it from the PC.  If I want to/need to go even faster than that, I move things into pure logic and monitor it either externally or from an onboard CPU.
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Hope this helps you think through things,&lt;/p&gt;

&lt;p&gt;Dan&lt;/p&gt;

&lt;p&gt;Hello @D@n, @artvvb !&lt;/p&gt;

&lt;p&gt;Thank you both for your answers !&lt;/p&gt;

&lt;p&gt;Actually, I’ve just started an internship and the goal is to implement a digital lock in amplifier on a board, for an optic detector. Indeed, I’m starting from a photodetector and I want to go through the ADC and then the FPGA to do some on board processing. More precisely, I want to apply the principle of a lock in amplifier which is, in an easy way, to multiply the input signal with a reference (at the same frequency), and then apply a low pass filter to recover a clean signal.&lt;/p&gt;

&lt;p&gt;So in a first part, to familiarize with the board, I wanted to put a signal from a generator until the ADC, and then light the LED on the Nexys board as I told you (before treating the real signal from the photodector). The second step would be to do the signal processing with the multiplier and the filter. But I was, and I am still, lost on how to plug and set up the ADC on the Pmod port (MicroBlaze? HDL code ? Other way ?)&lt;/p&gt;

&lt;p&gt;So to aswer to your questions @D@n, yes I want to read from the ADC, to do some on board processing and output the results it in real time. Because, the next step of this digital lock in amplifier is to create an imaging system after collecting the clean signal from the board (photodetector -&amp;gt; ADC -&amp;gt; FPGA -&amp;gt; (image processing) ).&lt;/p&gt;

&lt;p&gt;Besides, you talked about RPi board. I did not choose the board. Actually, my tutor provided me this Nexys 4 DDR and the Analog Device’s ADC (This is a 18-bit resolution ADC, that’s why we don’t use the ADC from the board) . But I am not obliged to work on this board. I was justly wondering if working on a microcontroller should be easier. What do you think about it ?&lt;/p&gt;

&lt;p&gt;I am also agree with the debugging point but what do you mean by “add logic into your design” ?&lt;/p&gt;

&lt;p&gt;Thank you very much once again.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Quote 

0
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;D@n&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Community Super-Star
D@n
Members
251
1,026 posts
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Posted March 6 · Report post&lt;/p&gt;

&lt;p&gt;@Yannick,&lt;/p&gt;

&lt;p&gt;I just looked up what a “digital lock-in amplifier” was.  Sounds like a fun project!&lt;/p&gt;

&lt;p&gt;The sample rate on your ADC will dictate a lot of your choices.  For example, if you are working at a high speed sample rate (100kHz+), then you may not be able to afford the microprocessor–at least not within your processing chain.  An ADC with an 18-bit resolution is not likely to be a very high speed ADC, so … that expands your options.&lt;/p&gt;

&lt;p&gt;Are you familiar with cordic’s at all?  You’ll find them &lt;em&gt;very&lt;/em&gt; valuable for creating the sin/cosine wave’s necessary to get that lock in amplifier working.  You’ll also find recursive averagers make for perhaps the simplest lost pass filters.&lt;/p&gt;

&lt;p&gt;But let’s get back to your question, of how to set up the ADC on the PMod port: HDL or MicroBlaze.  If you press me on this question, you’ll quickly discover I have a nearly religious answer–never use MicroBlaze.  This answer isn’t fair for me to give to struggling young students as yourself, so I try not to do so.  My reasons are based more along the lines of opensource principles and such.  Are there open alternatives to MicroBlaze?  Yes.  Are they as well supported as MicroBlaze is?  Not to my knowledge.  I mean, I’m personally working with the ZipCPU.  I think it’s a wonderful CPU.  But with the number of problems others have had getting started with it … MicroBlaze has a bit of an advantage there.  However if (when) things go wrong, you can at least trace the problems through an opensource design–not something you can do through MicroBlaze very well.&lt;/p&gt;

&lt;p&gt;But, no, here’s what I’m thinking of: what you want first and initially is not a CPU at all, but a means of knowing how that ADC device is responding to your commands.  The nightmare is that you would write 200+-lines of HDL, place it onto your device, and have the device not work, the LED doesn’t light, etc., and then to stare at the whole thing having no idea what went wrong.  This is the nightmare I would have you avoid through a little pre-project thought.  If/when you get stuck in this nightmare scenario, you will want to be able to examine more data than just that LED to know what’s going on.  Are you toggling the pins for the ADC properly?  Are you setting the clock for the ADC properly?  Are you getting data back from the ADC at all?  While LED’s are wonderful, they only provide so much info.&lt;/p&gt;

&lt;p&gt;My solution to this problem would be to first build my way to the device I needed to work with.  I would build a bus, and in particular, one that can be read from and written to from the host machine.  I personally like the wishbone bus in its B4/pipelined mode (using MicroBlaze would require AXI later), and I like to command it over a serial port via a well defined interface.  Then I would place onto that bus some form of “scope” which can record data from your FPGA-hardware interaction, and allow you to read it back from the bus.  While you might have a CPU on the bus initially, I would leave it turned off–at least until you had your hardware running.  This gets you out of the nightmare scenario I described above–at this point, you know what is going on with your ADC, what is going on with your HDL, etc.  Once it looks like its working then its time for ….&lt;/p&gt;

&lt;p&gt;The next step would be to have the “ADC” “device” write the RAM on your processor with samples (or otherwise record).  You would give commands from your PC/host such as: reset the ADC, send the ADC these setup parameters, etc., and go.  On “go”, the ADC device within your FPGA would slowly overwrite all of your RAM.  You would then download this data to your computer and examine it with MATLAB or (my favorite) Octave.  Even better, you would build your lock-in-amplifier algorithm on the host PC, and then verify that it would work with these data samples recovered from your actual ADC.  No, you wouldn’t leave it on the host PC, you would migrate it onto the FPGA, but … wouldn’t it be nice to know before stuffing it into the FPGA that it will work when it gets there?&lt;/p&gt;

&lt;p&gt;Only at this point in your development does the CPU come into play.&lt;/p&gt;

&lt;p&gt;This is how I personally would do it.  There are many other solutions, many using MicroBlaze, and I tend to hold a minority opinion.  ;)&lt;/p&gt;

&lt;p&gt;Does this help?&lt;/p&gt;

&lt;p&gt;Dan&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Quote Edit Options   

0
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Yannick&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Member
Yannick
Members
0
20 posts
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Posted March 6 · Report post&lt;/p&gt;

&lt;p&gt;It does help yes ! I’m going to work on all these points!&lt;/p&gt;

&lt;p&gt;Thank you very much @D@n !&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Quote 

0
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Yannick&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Member
Yannick
Members
0
20 posts
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Posted March 14 · Report post&lt;/p&gt;

&lt;p&gt;Hello @D@n !&lt;/p&gt;

&lt;p&gt;I’m finally trying to use the JXADC first to acquire a digital signal. I’m currently displaying the channel 3 (AD2N, AD2P) voltage on the LEDs. I use the DRP interface to  collect the data in entry of the channel 3 by the DO[15:0] bus. But there’s something I don’t understand when I read the UG480, page 25. It’s written that the 4 LSB are “Note”, what does it mean ?&lt;/p&gt;

&lt;p&gt;When I display the voltage on the LEDs, the first four are always lighted, I don’t understand why.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Quote 

0
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;D@n&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Community Super-Star
D@n
Members
251
1,026 posts
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Posted March 14 · Report post&lt;/p&gt;

&lt;p&gt;@Yannick,&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;On 3/4/2017 at 8:46 AM, D@n said:

Your first step, as you suggested, is to light an LED.  Cool.  That&#39;s a nice first step.  But ... think that first step through a little more: how will you know, if something is going wrong, what is going wrong?  You need to add logic into your design to answer this question.  Indeed, the sooner you add this logic into your design, the easier things will be to debug as your design becomes more complicated.  At the same time, I doubt this is your entire project, am I right?  This is only the first step?  So, let&#39;s think this through some more.

How do you plan on debugging your design?  When things don&#39;t work, how will you know what&#39;s not working?  (MicroBlaze is notoriously difficult to debug--it can be hard to know why it does or doesn&#39;t do something.)  I tend to use a homebrew scope to see what&#39;s going on within a design.
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;So … what’s going on internal to your design?  Can you tell?&lt;/p&gt;

&lt;p&gt;Dan&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Quote Edit Options   

0
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;D@n&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Community Super-Star
D@n
Members
251
1,026 posts
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Posted March 14 · Report post&lt;/p&gt;

&lt;p&gt;@Yannick,&lt;/p&gt;

&lt;p&gt;Sorry, took me a moment to find UG480.  The note means that the 12’bit ADC is placing the 12-valid bits into the upper 12’bits of a 16’bit value.  The user guide suggests that these bits “can be used to minimize quantization effects or improve resolution through averaging or filtering.”  This comment makes absolutely no sense to me.  I’d just understand the user guide to say that the bottom four bits are invalid, and understand that I don’t want to pay attention to them.&lt;/p&gt;

&lt;p&gt;Dan
JColvin likes this&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Quote Edit Options   

0
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Yannick&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Member
Yannick
Members
0
20 posts
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Posted March 15 · Report post&lt;/p&gt;

&lt;p&gt;Hey @D@n !&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    On 3/14/2017 at 0:10 PM, D@n said:

    This comment makes absolutely no sense to me.  I&#39;d just understand the user guide to say that the bottom four bits are invalid, and understand that I don&#39;t want to pay attention to them

I had the same opinion, thank you to confirm :) !
 

 

     
    On 3/14/2017 at 0:05 PM, D@n said:

    So ... what&#39;s going on internal to your design?  Can you tell?

Before implementing an other ADC by plugging it on the PMOD, we finally decided to try to use the internal ADC even if the resolution is 12bit. Maybe it would be enough, we don&#39;t know for the moment so let&#39;s try :) !
So I used the XADC wizard and I wrote some VHDL code (definitely not using MicroBlaze ^^ ) to convert a voltage which enter in an auxiliary channel (AD2P/AD2N) on the JXADC, and to display the digital conversion on the LEDs. It seems to work because when I have 0 V none of them light and when I have 1V they all light. But I&#39;m checking if the intermediaries steps well correspond. I was justly wondering how to check efficiently and easily if the conversion is well done (avoiding conversion binary -&amp;gt; decimal and display on 7-segment..). Because playing with the LED&#39;s and checking which of them are lighted to try to guess the binary code seem to be a bit archaic ahah. Indeed, some of them are sometimes lighted at half  ! So that&#39;s where I am for the moment, thank you for asking :).
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;And thank you very much once again for your answers !&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Quote 

0
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;D@n&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Community Super-Star
D@n
Members
251
1,026 posts
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Posted March 15 · Report post&lt;/p&gt;

&lt;p&gt;@Yannick,&lt;/p&gt;

&lt;p&gt;My favorite test to tell if the conversion is well done would be to place a nice, clean, sine wave into the input.  I’d pick a frequency near fs/4, and then I’d capture a couple waveforms, map them to a sine wave and compare.  I’d then repeat at something like fs/256 or fs/1024 or some such, and check again.  In both cases, grabbing a couple of copies of the full waveform.&lt;/p&gt;

&lt;p&gt;By watching how the sine wave you capture compares to a true sine wave, you should be able to find and ring out any imperfections in your system.  Chief and first among those, IMHO, would be making sure you had all the wires and formats right.  (Ex. nothing bit/byte swapped)  Histograms make great tools for finding format issues.  (Incidentally, live historgrams in FPGA logic are &lt;em&gt;really&lt;/em&gt; easy to do …)&lt;/p&gt;

&lt;p&gt;This is part of the reason why I was hoping to encourage you to move beyond the LED’s.&lt;/p&gt;

&lt;p&gt;Dan&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Quote Edit Options   

0
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Yannick&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Member
Yannick
Members
0
20 posts
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Posted March 15 (edited) · Report post&lt;/p&gt;

&lt;p&gt;It seems to be a good idea @D@n!&lt;/p&gt;

&lt;p&gt;But what is “fs” ? Why fs/4 ? and last one, how would you proceed to “ capture a couple waveforms, map them to a sine wave and compare” ?&lt;/p&gt;

&lt;p&gt;Edited March 15 by Yannick&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Quote 

0
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;D@n&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Community Super-Star
D@n
Members
251
1,026 posts
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Posted March 15 · Report post&lt;/p&gt;

&lt;p&gt;@Yannick,&lt;/p&gt;

&lt;p&gt;Sorry … I used terms without explaining them.  I was using “fs” to reference your sample frequency.  “fs/4” then is one fourth of your sampling frequency.  “capture a couple of waveforms” wasn’t right, it should “capture a couple of wavelengths”.  Sorry.  By “map them to a sine wave”, I mean take a linear least squares fit between the sampled values and a sine (and cosine) wave, so as to back out the amplitude and phase prior to a comparison.&lt;/p&gt;

&lt;p&gt;The trick is … to get there, you need to be able to record your samples to memory, and then read them back into your computer for processing–whether by MATLAB or Octave.  Pushing that a touch further, it means you need to have some form of bus internal to your design (necessary for reading/writing RAM), and that this bus needs to have at least two masters: one would be your XADC testing routine, the second .. whatever is reading the results off and sending them to your PC for inspection.  One example of such a program/design (without the XADC, sorry …) would be the S6SoC I’ve been working on.  Look at the alttoplevel.v interface on down–it allows complete control of an internal bus from an external computer.  Although the design is intended for a CMod S6, I think I can safely guarantee that you have enough logic on your Nexys 4 DDR device to run (most) of it.  Using such an interface, you can build C++ code that interacts with an FPGA using a very simple interface, and … then see what’s going on within your FPGA.&lt;/p&gt;

&lt;p&gt;This may be a longer discussion than you want on the forum.  Feel free to contact me at freenode IRC on the #digilent-fpga channel, if you’d like to chat further and in real time.&lt;/p&gt;

&lt;p&gt;Dan&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Quote Edit Options   

0
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Yannick&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Member
Yannick
Members
0
20 posts
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Posted March 15 · Report post&lt;/p&gt;

&lt;p&gt;@D@n,&lt;/p&gt;

&lt;p&gt;Thanks for advices and all the details ! I’m going to try all this !&lt;/p&gt;

&lt;p&gt;I’ll check you on freenode if I have more questions :).&lt;/p&gt;

&lt;p&gt;Yannick&lt;/p&gt;

</description>
        <pubDate>Sat, 20 May 2017 06:33:25 -0400</pubDate>
        <link>http://zipcpu.com/2017/05/20/vivado-design-flow.html</link>
        <guid isPermaLink="true">http://zipcpu.com/2017/05/20/vivado-design-flow.html</guid>
        
        
      </item>
    
      <item>
        <title>Knight Rider</title>
        <description>&lt;p&gt;When I was a kid, I loved watching Knight Rider.  Once I picked up FPGA design,
I wanted to know how to make LED’s move and dim … just like 
&lt;a href=&quot;https://www.youtube.com/watch?v=WxE2xWZNfO&quot;&gt;KITT’s lights&lt;/a&gt; did.&lt;/p&gt;

&lt;p&gt;If you are a beginner FPGA designer, this makes the perfect beginners project.&lt;/p&gt;

&lt;h2 id=&quot;walking-through-the-leds&quot;&gt;Walking through the LEDs&lt;/h2&gt;

&lt;p&gt;The first step requires simply walking through the LEDs.  This is a very
important step, as it demonstrates that all of your LEDs are properly set
up, properly connected, and that they will turn on when requested.&lt;/p&gt;

&lt;p&gt;In our case, we’ll do this two different ways.  First, we’ll step the LED’s
once each second.  This way, there can be no question that the LED comes on
at the proper time.  Once that works, we can speed the process up, and make
a cool LED demo.&lt;/p&gt;

&lt;p&gt;To step through the LED’s one at a time, you can use the following code:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;`default_nettype none
`define	FASTWALKER
//
module	ledwalker(i_clk, o_led);
	input	wire		i_clk;
	output	reg	[7:0]	o_led;

	// Remember the clock testing code?  This is very similar, only it
	// creates a PPS signal once per second--every time the counter rolls
	// over.  You could create this signal ever half second, or every
	// quarter second, by just dropping the number of bits in the counter.
	reg	pps;
	reg	[31:0]	time_counter;
	always @(posedge i_clk)
		{ pps, time_counter } &amp;lt;= time_counter + 32&#39;d43;

	//
	// We then want to keep track of our state: which LED will be on
	//
	reg	[2:0]	led_posn;
	always @(posedge i_clk)
		if (pps)
			led_posn &amp;lt;= led_posn + 1&#39;b1;

	//
	// Now, we turn on the one LED on corresponding to the state we have
	// chosen.
	//
	always @(posedge i_clk)
	begin
		o_led[0] &amp;lt;= (led_posn == 3&#39;h0);
		o_led[1] &amp;lt;= (led_posn == 3&#39;h1);
		o_led[2] &amp;lt;= (led_posn == 3&#39;h2);
		o_led[3] &amp;lt;= (led_posn == 3&#39;h3);
		o_led[4] &amp;lt;= (led_posn == 3&#39;h4);
		o_led[5] &amp;lt;= (led_posn == 3&#39;h5);
		o_led[6] &amp;lt;= (led_posn == 3&#39;h6);
		o_led[7] &amp;lt;= (led_posn == 3&#39;h7);
	end

endmodule&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;If you don’t want to type this in, you can find my version of this example
&lt;a href=&quot;https://github.com/ZipCPU/icozip/blob/master/rtl/pmodleds/ledwalker.v&quot;&gt;here&lt;/a&gt;.
You’ll need an &lt;a href=&quot;http://icoboard.org&quot;&gt;ICO board&lt;/a&gt; and a &lt;a href=&quot;https://store.digilentinc.com/pmod-8ld-eight-high-brightness-leds/&quot;&gt;PMod
LED8&lt;/a&gt;
from &lt;a href=&quot;http://store.digilentinc.com&quot;&gt;Digilent&lt;/a&gt; to
run it, although it’s almost generic enough to run on any FPGA board.  If you
don’t have that many LED’s?  Either don’t turn them all on, or adjust led_posn
to only cycle through the LED’s that you do have.&lt;/p&gt;

&lt;p&gt;With a little work, I’m sure you could modify this example, so that the LED
that was ON walked from left to right, and then back from right to left.&lt;/p&gt;

&lt;h2 id=&quot;dimming-the-led&quot;&gt;Dimming the LED&lt;/h2&gt;

&lt;p&gt;The next thing you need to know, once you can turn each LED on individually,
is that you can “dim” an LED by turning it on
and off faster than an eye can see.  As you transition the LED from being more
often on to more often off, the LED will appear to dim.  As an example, try the
following:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;//
`default_nettype none
//
module dimmer(i_clk, o_led);
  input  wire i_clk;
  output wire o_led;

reg [26:0] counter;
always @(posedge i_clk)
  counter &amp;lt;= counter + 1&#39;b1;

always @(posedge i_clk)
  o_led &amp;lt;= (counter[3:0] &amp;lt; counter[26:23]);

endmodule&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;If you don’t want to type this in, you can find my version of this
&lt;a href=&quot;https://github.com/ZipCPU/icozip/blob/master/rtl/basic/dimmer.v&quot;&gt;here&lt;/a&gt;,
written for the ICO Board.&lt;/p&gt;

&lt;h2 id=&quot;the-final-design&quot;&gt;The final design&lt;/h2&gt;

&lt;p&gt;You really don’t want me to give you the answer, now, do you?  Without giving
you a chance to do it yourself?  Try doing it yourself first.  Then, if you get
stuck or once you’ve achieved your goal, feel free to look at my solution
&lt;a href=&quot;https://github.com/ZipCPU/icozip/blob/master/rtl/pmodleds/ledbouncer.v&quot;&gt;here&lt;/a&gt;.
It’s a little more advanced than the ones above, in that it uses generic’s and
for loops within Verilog, but the concept remains the same.&lt;/p&gt;

&lt;p&gt;One problem I had using the “High-brightness” LED’s on the 
&lt;a href=&quot;https://store.digilentinc.com/pmod-8ld-eight-high-brightness-leds/&quot;&gt;PMod LED8&lt;/a&gt;,
was that it’s hard to see them actually “dim”.  As a result, the Knight
Rider effect is more substantial
on another board, such as the &lt;a href=&quot;https://store.digilentinc.com/nexys-video-artix-7-fpga-trainer-board-for-multimedia-applications&quot;&gt;Nexys Video&lt;/a&gt; or the &lt;a href=&quot;https://store.digilentinc.com/basys-3-artix-7-fpga-trainer-board-recommended-for-introductory-users/&quot;&gt;Basys-3&lt;/a&gt; from &lt;a href=&quot;https://store.digilentinc.com&quot;&gt;Digilent&lt;/a&gt;,
since these use red LED’s that aren’t nearly as bright.&lt;/p&gt;

</description>
        <pubDate>Sat, 20 May 2017 06:33:25 -0400</pubDate>
        <link>http://zipcpu.com/2017/05/20/knight-rider.html</link>
        <guid isPermaLink="true">http://zipcpu.com/2017/05/20/knight-rider.html</guid>
        
        
      </item>
    
      <item>
        <title>Moving to memory</title>
        <description>&lt;p&gt;Let’s see if I can answer your question(s).  I myself have an Arty board,
which has DDR3 SDRAM on it.  If I reference any hardware, it will be my
experiences with that board.&lt;/p&gt;

&lt;p&gt;Is it possible to store information line by line … I don’t see why not, as
long as your lines end on a byte boundary.  You can pack the data so that two
pixels take 3-bytes, or you can pack them so that one pixel takes two bytes,
but it seems quite possible to do.  If what you meant to ask is whether or not
someone had accomplished your problem already so that you could use/copy their
code, though, then my answer is: I don’t know.&lt;/p&gt;

&lt;p&gt;But I think what you’d like to know is the performance of the memory.  At one
time, I tried to build a DDR3 SDRAM memory controller.  I got a long ways into
the project, but still need to come back to it and finish it.  Using that
project, I worked out exactly how many clocks were necessary to access
memory–both initially and if that access were sequential to the last one.  I
tuned the memory controller so that you could read from the memory at a speed
of 128-bits per 81.25MHz clock after a couple clocks to set up the memory. 
Writes were similar.  If you look at the link above, you can see some of my
notes as I measured this.  As I recall, as long as you didn’t try to
read/write the memory during a refresh cycle, the whole operation might take
about 10-clocks.  (It’s been a while since I’ve done it, so I might be a clock
or two slow here.)  So, reading/writing from memory could then take 10+N
clocks, where N was the number of 128-bit words you wished to read or write.&lt;/p&gt;

&lt;p&gt;The problem with that controller, though, are the DQS lines–data needs to be
sampled at the rising/falling edge of DQS, and to do that you need hardware
support.  Likewise when writing, data needs to be on the bus ready to be
read/written at the rising/falling edge of DQS (the lines are bi-directional) 
Xilinx offers that hardware support as part of what the Memory Interface
Generator creates.  Their controller for the Arty, however, costs 23+N
clocks–and I can’t speak for whether or not they can read/write sequentially
for long periods separated only by the need to refresh the memory.&lt;/p&gt;

&lt;p&gt;Stepping back one step further, I wanted to then attach this memory to my CPU
bus.  The wishbone bus implementation I am using is 32-bits wide, so it can
only transfer 32-bits per clock.  On top of this, the wishbone wrapper I
placed on top of Xilinx’s memory interface core added four clocks.  So now
things cost 27+N clocks, where N is now the number of 32-bit words you wish to
read/write, and no longer the number of 128-bit words.&lt;/p&gt;

&lt;p&gt;At this point, I’m sure you could connect your CPU to the bus, at least that’s
what I did.  I’m not using a MicroBlaze CPU but rather a ZipCPU.  If you look
at section 4.6 of the ZipCPU specification, you’ll find a discussion about how
long it takes to do a memory copy.  It shouldn’t come as too much of a surprise
that it depends on how you code up your memory copy.  So, I offer a version
that takes 2+12N clocks, another that takes 32+17N/4 clocks, and a DMA approach
that takes roughly 2N clocks.  The numbers published in the specification,
though, are specific to a block RAM memory.  If you are dealing with SDRAM,
you have to add back in those 27 clocks we discussed earlier.  So you are back
to 2+39N clocks, 32+47N/4 clocks, and 2(27+1024)N/1024 clocks (N is the number
of 32-bit values)&lt;/p&gt;

&lt;p&gt;Hopefully this helps to answer your question, since you wanted details.&lt;/p&gt;

&lt;p&gt;If not, here are my takeaways:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;It depends upon your implementation
The fastest means of writing to your SDRAM will be a hardware/RTL means, not a CPU means.  (Look at the DMA numbers above, for example.)
If you choose to build a hardware controller, reading from the clock and writing to the RAM, you might manage to get close to those 23+N speeds above, where N is the number of 128-bit values you wish to write.  You may have to pack your 12-bit pixels into 128-bit words yourself to get to this speed, but it should be nearly possible.
It will also depend upon who else is trying to access the RAM at the same time--if you are running a graphics display at the same time, you may not be able to read/write for long unbroken periods.
And ... I haven&#39;t discussed memory refresh cycles, which can suddenly take the RAM offline for long periods and break any burst read/write you might be in the middle of.
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Wow, I know what you mean!  Those are some wonderful, good, and hard questions
to answer.  I’ll tell you what I know:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;I am working on a project to handle DDR3 SDRAM memory apart from Xilinx&#39;s Memory Interface Generator (MIG).  I&#39;ve been working on that project for about two months now.  If I had it working, I would commend that approach to you.  (I know I just linked to a project on OpenCores ... and yet OpenCores has been down for a couple of days now.  Kind of sad ... I&#39;ve got (what I think is a) nice blog describing my efforts to date.  The last news I have is that my &quot;logic&quot; for controlling the DDR3 SDRAM works in my home-made DDR3 simulator, and that (in the simulator) I get about a 9-clock delay from request to completion, where the MIG generated core takes about 23 clocks from request to completion.   (These are 81.25MHz clock ticks, running on an Arty ...)
Just as a little background:
    Every DDR3 memory transfer is 128 bits long.  Sure, the memory supports a 64 bit transfer mode, but that transfer mode still takes as many clocks as the 128-bit transfers, so you don&#39;t get any advantage there.  (This assumes a 16-bit bus transfer width, such as the Arty has.  Other bus transfer sizes will scale with the memory width.)
    Any transaction to/from the memory that is less than 128 bits is a misnomer--every request that crosses the DDR3 memory bus is 128 bits.
    It costs several clocks before you can write to the memory.  If you are familiar with SDRAM, there are 8-banks of memory within each chip.  To read/write memory, it must first be copied from the DRAM to an SRAM--this is called activating the bank.  If the bank was already activated with the wrong &quot;row&quot; of memory, then the bank must be closed, or as the spec calls it it must be &quot;precharged&quot; before being activated.  This takes a clock.  Once the bank is activated, you may request to read/write on the memory bus.  The following clock starts a read/write, and the full read/write takes place on the clock following.  In all, a transaction may require one clock to precharge the bank, one clock to activate it on another row, one clock to issue the read/write command, one clock to start the bus going, one clock to transfer the data, and ... Xilinx&#39;s MIG stuffs another 20+ transactions to those 5 clocks of bus interactions.  (Keep in mind, the memory clock is going at 4x the speed of the &quot;clock&quot; of your interface.)
    The memory is very particular about what clock speeds it can and cannot support.  (This is why my own controller has, to date, been rewritten about five times ...)  The memory clock speed cannot be slower than 3.3ns, and on the Arty it cannot be faster than 3ns (the spec goes much faster ...)  The speed of the controller MIG gives you is likely to be 1/4 this rate.
    The MIG can be hard to configure.  The Digilent how to&#39;s and device project files should help you do so.
    MIG wants to control your clock.   Therefore, source the clock for your whole design, and indeed your reset as well, from the MIG core.  MIG also wants your external clock input as well as a 200MHz clock input.  I find that I need to go through a PLL to generate these two clocks.  They then need to be passed to the core &quot;unbuffered&quot;.
When I finally got frustrated with my efforts above, I built a Wishbone to AXI4 bridge.  (I&#39;ve since moved this project to github from OpenCores, as you may notice from the link address ...)  This project is very similar to a prior wishbone to AXI3 bridge written by another great, with the one exception that it pipelines memory accesses to the extent the MIG and AXI4 allows.  This means that you can issue one read (or write) command per clock, and let the memory deal with things.  Xilinx does require, when sending &quot;pipelined&quot; requests across their AXI4 bus, that your request cannot cross a 4kB boundary.  (You&#39;ll have to start a new request at the boundary--this is what the documentation says, I haven&#39;t tried it in practice ...)
If you wish to look into the pipelined bridge I mention above ...
    You&#39;ll need to understand a touch about the pipelined mode within the Wishbone B4 specification.  OpenCores is down, or I&#39;d point you to that spec ... so let me give you a couple details.  To initiate a transaction, raise the CYC and STB lines, while setting the address, write-enable, and data (if it&#39;s a write transaction).  The transaction request has been made on the same clock that STB is high and STALL (from the memory peripheral) is low.  Once you&#39;ve finished requesting the transactions you wish, drop the STB line.  The transaction is complete when the ACK line goes high.  On that clock, if you requested data, the data is returned to you.  You&#39;ll then want to drop the CYC line.  (Go ahead and read the AXI4 spec--it&#39;s not nearly that simple ...)
    The bridge core (above) uses a 6-bit transaction identifier, and a 128-bit transaction width within MIG.  You&#39;ll need those numbers as you generate the core.  It also supports natural (rather than strict) ordering.  (If you select strict ordering, the portion of the bridge core that handles it ... isn&#39;t quite ready yet.  Use the non-strict bridge option--it&#39;ll cost you some extra logic and an extra clock, but it&#39;ll work.  If you really want strict ordering, you can help me get the 10 lines of code needed to get the strict ordering code working ...)
    If you only wish to write 8-bits, you&#39;ll need to still fill out at least 32-bits of a transaction on the bridge core.  You can use the SEL line to select which byte within the 32-bits you give it is actually written.  Alternatively, you can gather your write requests until they fill out a 32-bit word and write them then.  Still, the memory transaction itself is 128-bits, so the 8-bits you write will turn into a 128-bit transaction--even if all you wish to write is 8-bits.
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;If you haven’t figured it out, this solution is not the one on the beaten path.  It works, though, and I’ll be happy to discuss it further if you would like.&lt;/p&gt;

&lt;p&gt;I was afraid that would happen.  Okay, let’s work with the user interface.&lt;/p&gt;

&lt;p&gt;Do you have Xilinx’s ug586, “7 Series FPGAs Memory Inteface Solutions: User Guide”?  I’ll admit it’s not very comprehensible, but … it’s what we have to work with.&lt;/p&gt;

&lt;p&gt;Looking at the guide, and your code, let me offer some pointers:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Be careful of setting your state at the very first line of your process.  This isn&#39;t computer code, where the state is set on the first clock and then set to something else.  Still, having said that, it looks like your state machinery would still work for what you want--no corrections are necessary.
Xilinx AXI documentation talks a lot about the ready signal and the enable signal, and concerns particular race conditions.  They recommend setting the enable signal before checking the ready signal, lest some race condition occurrs.  In your code, you wait for the ready signal on the write line before setting the enable signal.
On page 156 of Xilinx&#39;s document, they show three potential write timing relationships compared to the command relationship.  I would recommend you use #1 or #2, rather than #3, because of this warning they give.
Be aware of the condition whereby the app_rdy signal is high, but wdf_rdy is not or vice versa.  With your code as written, you might find yourself issuing a whole bunch of commands, but with no data to go with them &#39;cause their data fifo wasn&#39;t ready.
You will need to assert the memory burst &quot;END&quot; command when you hit the last byte in a 32-byte group.  This could be the first data byte you send, if it&#39;s address bits end in 2&#39;b11.  The group is not defined by how much data you wish to send in total, but (at least as I understand it) but how much data will cross the interface.
You haven&#39;t set the &#39;mask&#39; bits (app_wdf_mask) anywhere in your code.  You&#39;ll probably want to make sure those are explicitly set to zero.  These bits allow write commands to only effect certain bytes in the memory.  If I understand correctly, any bit where the mask is &#39;1&#39; corresponds to a byte that is not written, whereas a mask with a bit corresponding to zero is a byte that is written.
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;There are just some observations.  They come with no guarantee that, should you follow them, your could would work.  :P&lt;/p&gt;

&lt;p&gt;Dan&lt;/p&gt;

&lt;p&gt;A couple things I noticed:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;You don&#39;t want to increase your address unless the last command was accepted.  (i.e. app_rdy was high)
Even if you don&#39;t want to use AXI4, you still might wish to take a look at that wb2axi converter.  One of the things it handles nicely is the various ready lines--both on the command bus, as well as the write bus associated with it.  Look at the o_axi_awvalid, and o_axi_wvalid line as an examples--the first is the command valid, the second is the write bus valid.  As for the core, a new value is accepted by the core anytime (i_wb_stb)&amp;amp;&amp;amp;(!o_wb_stall) is true, so that should explain those lines within that logic.
Be aware that it takes quite a bit of time for the MIG to start up.  I think this is why the MIG likes to output a reset signal--so it can hold your logic in reset until the MIG has started.  (We&#39;re talking about a ms here.  First MIG has to hold the DDR reset down for 200us, then it must clock it with the clock enable line held low for 500us, etc.--nothing you need to worry about, save that this must take place.)
If starting the MIG were painful, you also need to be aware that the MIG itself will go out to lunch every now and then (roughly every 7.8us) so that it can refresh its memory.  During that period of time, the memory will be unavailable.  By my calculation, that&#39;s about a 57 clock penalty--but who knows how Xilinx actually implemented their MIG?
I cannot comment on how well Xilinx&#39;s simulator accurately simulates a DDR3 memory at all.  I just don&#39;t know.
While I have code that will simulate a DDR3 SDRAM, it doesn&#39;t have the interface you are working with and the interface it does have  ... doesn&#39;t yet work on any Xilinx chips.  (sorry--it&#39;s just another work in progress)
As for checking in realtime, and on the hardware itself instead of via simulation--this is really what you want to do.  I highly recommend doing this.  All of my projects have included some kind of checking in real time into them, so I can see what is going on within the project.  I&#39;ve debugged interactions with the ICAPE interface, QSPI flash, DDR3 memory, and now I&#39;m working on the Arty&#39;s network card--all using this sort of approach.  I&#39;d highly recommend it to you.  Can I say that again? 
I&#39;m sure others here on this forum can describe to you how to use Xilinx&#39;s ChipScope for that purpose.  I personally have never used it.  It might be simpler than what I&#39;m about to discuss and propose to you.
To see what&#39;s going on within the hardware, I use what I call a &quot;wishbone scope&quot;.  The scope records until a trigger plus a programmable number of clocks.  So, for example, you might want to look for what happens when you assert the enable line and start recording there.  (Set the programmable delay to the size of the scope&#39;s memory)  Alternatively, you might wish to stop recording when an error condition takes place (set the delay to zero)--or later to pan through your logic from a start condition to ... however much later.  That said, doing this requires a lot of ... preliminary stuff to work.  You will need a means of communicating with your board and read/writing to the wishbone bus that the scope is parked on.  (It only takes a 1-bit address line, so even if you don&#39;t park it on a wishbone bus properly, the interface is fairly simple--but you&#39;ll still need to communicate with it from something external.)
You can see some of the projects I have where I do this on GitHub.  There&#39;s a project using a XuLA2-LX25 board, one using a CMod-S6, and I&#39;m now working on one using the Arty platform (this one uses the MIG, but via the AXI4 interface).  If you wish to cut/copy/paste, I&#39;ll warn you: none of these projects are simple, and the Arty one is still a work in progress.  My basic design works as follows: A host computer communicates via a standard protocol with the board.  The protocol was built so that I might use it no matter what the boards interface, even over PCIe if necessary.  I typically build a basic host program wbregs, just to read and write addresses on the board (like the scope configuration address) from the command line.  When that gets old, I build a C++ file to do what I need--such as reading from the scope.  From the RTL side, check out all the RTL files beginning with wbu--the top one is wbubus.v.  The interface is generic enough to be able to be run from a UART (the Arty), a JTAG/User command (the XuLA2-LX25), or even the Digilent&#39;s parallel DEPP interface.  Of course, my fear with even mentioning these is that they could easily overwhelm you like I did earlier in this thread.  (I would be overwhelmed personally ...)  At the same time, copying from such a project might be one way you could get started quickly--so I&#39;ll let you be the judge.
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Let me know if this helps, and we can go from there,&lt;/p&gt;

</description>
        <pubDate>Sat, 20 May 2017 06:33:25 -0400</pubDate>
        <link>http://zipcpu.com/2017/05/20/ddr3.html</link>
        <guid isPermaLink="true">http://zipcpu.com/2017/05/20/ddr3.html</guid>
        
        
      </item>
    
      <item>
        <title>Blinky</title>
        <description>&lt;p&gt;In C, the first program a person writes is often known  as a
&lt;a href=&quot;https://en.wikipedia.org/wiki/&amp;quot;Hello,_World!&amp;quot;_program&quot;&gt;“Hello, World!”&lt;/a&gt;
program.  It does nothing but print “Hello, World!” to the screen and exit.
While this is a wonderful first program for the C programmer, it is wholly
inappropriate for either the FPGA programmer or the embedded programmer.&lt;/p&gt;

&lt;p&gt;The FPGA or embedded programmer must work to get the serial port or the
C-library working, if he has either.  Instead, he has a simple LED to work with.
Hence the first program, &lt;a href=&quot;https://hackaday.io/project/7982-cat-board/log/37305-getting-to-blinky-cat-board-style&quot;&gt;blinky&lt;/a&gt;, simply blinks that LED.&lt;/p&gt;

&lt;h2 id=&quot;why-blinky&quot;&gt;Why blinky?&lt;/h2&gt;

&lt;p&gt;Blinky is a very important program: it proves that you can 1) program the
FPGA, that you 2) have a working clock, and that 3) you have a working LED.
These are very important steps in programming a new board.  Indeed, they are
so profound, I still run blinky as my first program on any FPGA board today.&lt;/p&gt;

&lt;h2 id=&quot;what-is-blinky&quot;&gt;What is blinky?&lt;/h2&gt;

&lt;p&gt;Below is a very simple version of the blinky program, written in Verilog.
Remember, simple is better at this point.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;//
`default_nettype none
//
module blinky(i_clk, o_led);
  input wire i_clk;
  output wire o_led;

reg	[25:0]	counter;
always @(posedge i_clk)
  counter &amp;lt;= counter + 1&#39;b1;
assign o_led = counter[25];

endmodule&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;While there’s not much to the design, the “not much” that is there is important.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Notice that I mark my inputs with the prefix i_, and my outputs with the prefix o_.  You’ll find this consistent notation through all of my work.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Notice the default_nettype directive.  We’ll come back to it later.  For now, I highly recommend every Verilog design you build start with it.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Notice the counter.  Many beginners place an LED in their design without the counter, and then wonder why things don’t work.  An FPGA runs faster than your eye can see.  Without the counter, you wouldn’t be able to see this LED blink.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;I have 26 bits in my counter (25+1).  This is just about right for most of the projects I’ve worked on.  It divides the clock by 2^26, creating a clock rate at around one Hertz.  If you pick a number too low, you won’t see the LED blink.  If you pick a number too high, you’ll get bored waiting for the LED to blink while wondering if your FPGA works.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;a-better-blinky&quot;&gt;A better blinky&lt;/h2&gt;

&lt;p&gt;With no more than just a clock and an LED, can you figure out how fast your
clock is running?&lt;/p&gt;

&lt;p&gt;This was a challenge of mine when first firing up my
&lt;a href=&quot;http://icoboard.org&quot;&gt;icoboard&lt;/a&gt;.  The
&lt;a href=&quot;https://drive.google.com/file/d/0By-zY9AlHqXIcXZ6ZWdBR2dPXzg/view&quot;&gt;schematic&lt;/a&gt;
for that board initially identified the
clock as being at 25MHz, the examples identified it as being at 100MHz.  (The
team has since fixed the schematic, to properly reflect the 100MHz clock.)  How
should I tell which of the two was the right answer?&lt;/p&gt;

&lt;p&gt;Here was my solution:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;//
`default_nettype none
//
module clktest(i_clk, o_led);
  input wire i_clk;
  output wire o_led;

// We use a larger, 32-bit, counter here so as to get some better time
// precision.
reg	[31:0]	counter;
always @(posedge i_clk)
  counter &amp;lt;= counter + 32&#39;d43; // Valid if clk rate = 100MHz

// Blink the LED sharply at the top of each second, so that
// it remains on for a quarter of a second only before turning
// off
assign o_led = (counter[31:30] == 2&#39;b00);

endmodule&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Did you notice the 32’d43 value?  This value is set to 2^32 divided by the
clock rate.  Since the clock rate on this board is 100 MHz, 2^32 divided by
100 MHz is about 43.  Hence, if the counter starts at zero, then after
100 million clock ticks, the counter should equal 2^32 and roll over to zero
again.  In this case, though, since 2^32/100M isn’t exactly 43, our clock will
run about 5% too fast.  Still … it should be close enough that we can use a
stop watch to verify that we are in about the right clock range.&lt;/p&gt;

&lt;p&gt;If you are interested, this method of clock division is also used within the
&lt;a href=&quot;https://github.com/ZipCPU/rtcclock&quot;&gt;Real-Time Clock&lt;/a&gt; project used by the
ZipCPU.  The project, though, uses a 48-bit counter to get much better 
time accuracy–assuming that the oscillator is that good.&lt;/p&gt;

&lt;h2 id=&quot;using-blinky-for-debugging&quot;&gt;Using blinky for debugging&lt;/h2&gt;

&lt;p&gt;If you ever find yourself debugging with nothing but an LED, you can use the
LED for your debugging.  It’s not the best means of debugging: it can only
return one bit of information, and sometimes not even that, but it may be
the only means you have.&lt;/p&gt;

&lt;p&gt;The basic idea is to set the LED to on any time some condition takes place.
The trick is … you need to reset the LED so that you can see if that
condition takes place again later, and you need to make certain that the
condition (whatever it is) takes place so rarely that you can understand
what’s going on.&lt;/p&gt;

&lt;p&gt;Here’s an updated blinky, therefore, that can be used within a design to help
debug it:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;reg	[24:0]	counter;
always @(posedge i_clk)
  if (debug_event)
    // Reset the counter if our event ever takes place
    counter &amp;lt;= 0;
  else if (!counter[24])
    // Increment the counter, to hold the LED for a period of time
    // long enough for us to observe it ... before turning the LED
    // back off again
    counter &amp;lt;= counter + 1&#39;b1;

// Since the reset condition sets this high order bit low and holds
// it low for a period of time, and since the light &quot;on&quot; usually
// indicates the condition has taken place, negate the top bit of
// the counter so that the LED will turn _on_ any time your event
// takes place.
assign o_led = !counter[24];&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;As before, the choice of the length of the counter is important.&lt;/p&gt;

&lt;p&gt;This time, though, we’ve used “debug_event”, a variable coming from elsewhere
in the design, to check to see if something ever happens.  If this event ever
happens, the counter is set to zero, and the LED is turned on.  The counter
then holds the LED on for 2^24 clocks, before stopping and waiting for a new
event.&lt;/p&gt;

&lt;p&gt;While better approaches exist, most of those require more logic that needs to
be debugged first.  As a result, I’ve used this approach to debug my 
&lt;a href=&quot;https://github.com/ZipCPU/wbuart32/&quot;&gt;serial port controller&lt;/a&gt;, since most of my
debugging logic depends upon a working serial port.  I’ve also used this
approach to track how much time the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;
is spending in &lt;a href=&quot;https://github.com/ZipCPU/s6soc/blob/master/sw/zipos/kernel.c#L118&quot;&gt;interrupts&lt;/a&gt;, and if
and when the ZipCPU &lt;a href=&quot;https://github.com/ZipCPU/s6soc/blob/master/rtl/busmaster.v#L448&quot;&gt;has frozen&lt;/a&gt; in &lt;a href=&quot;https://github.com/ZipCPU/s6soc&quot;&gt;designs&lt;/a&gt; that are too tight
to fit a &lt;a href=&quot;https://github.com/ZipCPU/wbscope&quot;&gt;better debugging infrastructure&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;what-next&quot;&gt;What next?&lt;/h2&gt;

&lt;p&gt;Once you have blinky running, it’s time to move on to other tasks.  These tasks, though, will be easier because you have a clock and an LED that works.  Indeed, you can use blinky to your advantage as you struggle to get those newer tasks running.&lt;/p&gt;

</description>
        <pubDate>Sat, 20 May 2017 06:33:25 -0400</pubDate>
        <link>http://zipcpu.com/blog/2017/05/20/blinky.html</link>
        <guid isPermaLink="true">http://zipcpu.com/blog/2017/05/20/blinky.html</guid>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>Knight Rider</title>
        <description>&lt;p&gt;When I was a kid, I loved watching Knight Rider.  Once I picked up FPGA design,
I wanted to know how to make LED’s move and dim … just like 
&lt;a href=&quot;https://www.youtube.com/watch?v=WxE2xWZNfO&quot;&gt;KITT’s lights&lt;/a&gt; did.&lt;/p&gt;

&lt;p&gt;If you are a beginner FPGA designer, this makes the perfect beginners project.&lt;/p&gt;

&lt;h2 id=&quot;walking-through-the-leds&quot;&gt;Walking through the LEDs&lt;/h2&gt;

&lt;p&gt;The first step requires simply walking through the LEDs.  This is a very
important step, as it demonstrates that all of your LEDs are properly set
up, properly connected, and that they will turn on when requested.&lt;/p&gt;

&lt;p&gt;In our case, we’ll do this two different ways.  First, we’ll step the LED’s
once each second.  This way, there can be no question that the LED comes on
at the proper time.  Once that works, we can speed the process up, and make
a cool LED demo.&lt;/p&gt;

&lt;p&gt;To step through the LED’s one at a time, you can use the following code:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;`default_nettype none
`define	FASTWALKER
//
module	ledwalker(i_clk, o_led);
	input	wire		i_clk;
	output	reg	[7:0]	o_led;

	// Remember the clock testing code?  This is very similar, only it
	// creates a PPS signal once per second--every time the counter rolls
	// over.  You could create this signal ever half second, or every
	// quarter second, by just dropping the number of bits in the counter.
	reg	pps;
	reg	[31:0]	time_counter;
	always @(posedge i_clk)
		{ pps, time_counter } &amp;lt;= time_counter + 32&#39;d43;

	//
	// We then want to keep track of our state: which LED will be on
	//
	reg	[2:0]	led_posn;
	always @(posedge i_clk)
		if (pps)
			led_posn &amp;lt;= led_posn + 1&#39;b1;

	//
	// Now, we turn on the one LED on corresponding to the state we have
	// chosen.
	//
	always @(posedge i_clk)
	begin
		o_led[0] &amp;lt;= (led_posn == 3&#39;h0);
		o_led[1] &amp;lt;= (led_posn == 3&#39;h1);
		o_led[2] &amp;lt;= (led_posn == 3&#39;h2);
		o_led[3] &amp;lt;= (led_posn == 3&#39;h3);
		o_led[4] &amp;lt;= (led_posn == 3&#39;h4);
		o_led[5] &amp;lt;= (led_posn == 3&#39;h5);
		o_led[6] &amp;lt;= (led_posn == 3&#39;h6);
		o_led[7] &amp;lt;= (led_posn == 3&#39;h7);
	end

endmodule&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;If you don’t want to type this in, you can find my version of this example
&lt;a href=&quot;https://github.com/ZipCPU/icozip/blob/master/rtl/pmodleds/ledwalker.v&quot;&gt;here&lt;/a&gt;.
You’ll need an &lt;a href=&quot;http://icoboard.org&quot;&gt;ICO board&lt;/a&gt; and a &lt;a href=&quot;https://store.digilentinc.com/pmod-8ld-eight-high-brightness-leds/&quot;&gt;PMod
LED8&lt;/a&gt;
from &lt;a href=&quot;http://store.digilentinc.com&quot;&gt;Digilent&lt;/a&gt; to
run it, although it’s almost generic enough to run on any FPGA board.  If you
don’t have that many LED’s?  Either don’t turn them all on, or adjust led_posn
to only cycle through the LED’s that you do have.&lt;/p&gt;

&lt;p&gt;With a little work, I’m sure you could modify this example, so that the LED
that was ON walked from left to right, and then back from right to left.&lt;/p&gt;

&lt;h2 id=&quot;dimming-the-led&quot;&gt;Dimming the LED&lt;/h2&gt;

&lt;p&gt;The next thing you need to know, once you can turn each LED on individually,
is that you can “dim” an LED by turning it on
and off faster than an eye can see.  As you transition the LED from being more
often on to more often off, the LED will appear to dim.  As an example, try the
following:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;//
`default_nettype none
//
module dimmer(i_clk, o_led);
  input  wire i_clk;
  output wire o_led;

reg [26:0] counter;
always @(posedge i_clk)
  counter &amp;lt;= counter + 1&#39;b1;

always @(posedge i_clk)
  o_led &amp;lt;= (counter[3:0] &amp;lt; counter[26:23]);

endmodule&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;If you don’t want to type this in, you can find my version of this
&lt;a href=&quot;https://github.com/ZipCPU/icozip/blob/master/rtl/basic/dimmer.v&quot;&gt;here&lt;/a&gt;,
written for the ICO Board.&lt;/p&gt;

&lt;h2 id=&quot;the-final-design&quot;&gt;The final design&lt;/h2&gt;

&lt;p&gt;You really don’t want me to give you the answer, now, do you?  Without giving
you a chance to do it yourself?  Try doing it yourself first.  Then, if you get
stuck or once you’ve achieved your goal, feel free to look at my solution
&lt;a href=&quot;https://github.com/ZipCPU/icozip/blob/master/rtl/pmodleds/ledbouncer.v&quot;&gt;here&lt;/a&gt;.
It’s a little more advanced than the ones above, in that it uses generic’s and
for loops within Verilog, but the concept remains the same.&lt;/p&gt;

&lt;p&gt;One problem I had using the “High-brightness” LED’s on the 
&lt;a href=&quot;https://store.digilentinc.com/pmod-8ld-eight-high-brightness-leds/&quot;&gt;PMod LED8&lt;/a&gt;,
was that it’s hard to see them actually “dim”.  As a result, the Knight
Rider effect is more substantial
on another board, such as the &lt;a href=&quot;https://store.digilentinc.com/nexys-video-artix-7-fpga-trainer-board-for-multimedia-applications&quot;&gt;Nexys Video&lt;/a&gt; or the &lt;a href=&quot;https://store.digilentinc.com/basys-3-artix-7-fpga-trainer-board-recommended-for-introductory-users/&quot;&gt;Basys-3&lt;/a&gt; from &lt;a href=&quot;https://store.digilentinc.com&quot;&gt;Digilent&lt;/a&gt;,
since these use red LED’s that aren’t nearly as bright.&lt;/p&gt;

</description>
        <pubDate>Sat, 20 May 2017 00:00:00 -0400</pubDate>
        <link>http://zipcpu.com/2017/05/20/knight-rider.html</link>
        <guid isPermaLink="true">http://zipcpu.com/2017/05/20/knight-rider.html</guid>
        
        
      </item>
    
      <item>
        <title>Blinky</title>
        <description>&lt;p&gt;In C, the first program a person writes is often known  as a
&lt;a href=&quot;https://en.wikipedia.org/wiki/&amp;quot;Hello,_World!&amp;quot;_program&quot;&gt;“Hello, World!”&lt;/a&gt;
program.  It does nothing but print “Hello, World!” to the screen and exit.
While this is a wonderful first program for the C programmer, it is wholly
inappropriate for either the FPGA programmer or the embedded programmer.&lt;/p&gt;

&lt;p&gt;The FPGA or embedded programmer must work to get the serial port or the
C-library working, if he has either.  Instead, he has a simple LED to work with.
Hence the first program, &lt;a href=&quot;https://hackaday.io/project/7982-cat-board/log/37305-getting-to-blinky-cat-board-style&quot;&gt;blinky&lt;/a&gt;, simply blinks that LED.&lt;/p&gt;

&lt;h2 id=&quot;why-blinky&quot;&gt;Why blinky?&lt;/h2&gt;

&lt;p&gt;Blinky is a very important program: it proves that you can 1) program the
FPGA, that you 2) have a working clock, and that 3) you have a working LED.
These are very important steps in programming a new board.  Indeed, they are
so profound, I still run blinky as my first program on any FPGA board today.&lt;/p&gt;

&lt;h2 id=&quot;what-is-blinky&quot;&gt;What is blinky?&lt;/h2&gt;

&lt;p&gt;Below is a very simple version of the blinky program, written in Verilog.
Remember, simple is better at this point.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;//
`default_nettype none
//
module blinky(i_clk, o_led);
  input wire i_clk;
  output wire o_led;

reg	[25:0]	counter;
always @(posedge i_clk)
  counter &amp;lt;= counter + 1&#39;b1;
assign o_led = counter[25];

endmodule&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;While there’s not much to the design, the “not much” that is there is important.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Notice that I mark my inputs with the prefix i_, and my outputs with the prefix o_.  You’ll find this consistent notation through all of my work.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Notice the default_nettype directive.  We’ll come back to it later.  For now, I highly recommend every Verilog design you build start with it.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Notice the counter.  Many beginners place an LED in their design without the counter, and then wonder why things don’t work.  An FPGA runs faster than your eye can see.  Without the counter, you wouldn’t be able to see this LED blink.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;I have 26 bits in my counter (25+1).  This is just about right for most of the projects I’ve worked on.  It divides the clock by 2^26, creating a clock rate at around one Hertz.  If you pick a number too low, you won’t see the LED blink.  If you pick a number too high, you’ll get bored waiting for the LED to blink while wondering if your FPGA works.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;a-better-blinky&quot;&gt;A better blinky&lt;/h2&gt;

&lt;p&gt;With no more than just a clock and an LED, can you figure out how fast your
clock is running?&lt;/p&gt;

&lt;p&gt;This was a challenge of mine when first firing up my
&lt;a href=&quot;http://icoboard.org&quot;&gt;icoboard&lt;/a&gt;.  The
&lt;a href=&quot;https://drive.google.com/file/d/0By-zY9AlHqXIcXZ6ZWdBR2dPXzg/view&quot;&gt;schematic&lt;/a&gt;
for that board initially identified the
clock as being at 25MHz, the examples identified it as being at 100MHz.  (The
team has since fixed the schematic, to properly reflect the 100MHz clock.)  How
should I tell which of the two was the right answer?&lt;/p&gt;

&lt;p&gt;Here was my solution:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;//
`default_nettype none
//
module clktest(i_clk, o_led);
  input wire i_clk;
  output wire o_led;

// We use a larger, 32-bit, counter here so as to get some better time
// precision.
reg	[31:0]	counter;
always @(posedge i_clk)
  counter &amp;lt;= counter + 32&#39;d43; // Valid if clk rate = 100MHz

// Blink the LED sharply at the top of each second, so that
// it remains on for a quarter of a second only before turning
// off
assign o_led = (counter[31:30] == 2&#39;b00);

endmodule&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Did you notice the 32’d43 value?  This value is set to 2^32 divided by the
clock rate.  Since the clock rate on this board is 100 MHz, 2^32 divided by
100 MHz is about 43.  Hence, if the counter starts at zero, then after
100 million clock ticks, the counter should equal 2^32 and roll over to zero
again.  In this case, though, since 2^32/100M isn’t exactly 43, our clock will
run about 5% too fast.  Still … it should be close enough that we can use a
stop watch to verify that we are in about the right clock range.&lt;/p&gt;

&lt;p&gt;If you are interested, this method of clock division is also used within the
&lt;a href=&quot;https://github.com/ZipCPU/rtcclock&quot;&gt;Real-Time Clock&lt;/a&gt; project used by the
ZipCPU.  The project, though, uses a 48-bit counter to get much better 
time accuracy–assuming that the oscillator is that good.&lt;/p&gt;

&lt;h2 id=&quot;using-blinky-for-debugging&quot;&gt;Using blinky for debugging&lt;/h2&gt;

&lt;p&gt;If you ever find yourself debugging with nothing but an LED, you can use the
LED for your debugging.  It’s not the best means of debugging: it can only
return one bit of information, and sometimes not even that, but it may be
the only means you have.&lt;/p&gt;

&lt;p&gt;The basic idea is to set the LED to on any time some condition takes place.
The trick is … you need to reset the LED so that you can see if that
condition takes place again later, and you need to make certain that the
condition (whatever it is) takes place so rarely that you can understand
what’s going on.&lt;/p&gt;

&lt;p&gt;Here’s an updated blinky, therefore, that can be used within a design to help
debug it:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;reg	[24:0]	counter;
always @(posedge i_clk)
  if (debug_event)
    // Reset the counter if our event ever takes place
    counter &amp;lt;= 0;
  else if (!counter[24])
    // Increment the counter, to hold the LED for a period of time
    // long enough for us to observe it ... before turning the LED
    // back off again
    counter &amp;lt;= counter + 1&#39;b1;

// Since the reset condition sets this high order bit low and holds
// it low for a period of time, and since the light &quot;on&quot; usually
// indicates the condition has taken place, negate the top bit of
// the counter so that the LED will turn _on_ any time your event
// takes place.
assign o_led = !counter[24];&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;As before, the choice of the length of the counter is important.&lt;/p&gt;

&lt;p&gt;This time, though, we’ve used “debug_event”, a variable coming from elsewhere
in the design, to check to see if something ever happens.  If this event ever
happens, the counter is set to zero, and the LED is turned on.  The counter
then holds the LED on for 2^24 clocks, before stopping and waiting for a new
event.&lt;/p&gt;

&lt;p&gt;While better approaches exist, most of those require more logic that needs to
be debugged first.  As a result, I’ve used this approach to debug my 
&lt;a href=&quot;https://github.com/ZipCPU/wbuart32/&quot;&gt;serial port controller&lt;/a&gt;, since most of my
debugging logic depends upon a working serial port.  I’ve also used this
approach to track how much time the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;
is spending in &lt;a href=&quot;https://github.com/ZipCPU/s6soc/blob/master/sw/zipos/kernel.c#L118&quot;&gt;interrupts&lt;/a&gt;, and if
and when the ZipCPU &lt;a href=&quot;https://github.com/ZipCPU/s6soc/blob/master/rtl/busmaster.v#L448&quot;&gt;has frozen&lt;/a&gt; in &lt;a href=&quot;https://github.com/ZipCPU/s6soc&quot;&gt;designs&lt;/a&gt; that are too tight
to fit a &lt;a href=&quot;https://github.com/ZipCPU/wbscope&quot;&gt;better debugging infrastructure&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;what-next&quot;&gt;What next?&lt;/h2&gt;

&lt;p&gt;Once you have blinky running, it’s time to move on to other tasks.  These tasks, though, will be easier because you have a clock and an LED that works.  Indeed, you can use blinky to your advantage as you struggle to get those newer tasks running.&lt;/p&gt;

</description>
        <pubDate>Sat, 20 May 2017 00:00:00 -0400</pubDate>
        <link>http://zipcpu.com/blog/2017/05/20/blinky.html</link>
        <guid isPermaLink="true">http://zipcpu.com/blog/2017/05/20/blinky.html</guid>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>FPGA Hell</title>
        <description>&lt;p&gt;The worst place to be in digital design is where you load the design onto your
device, it doesn’t work, and you don’t know why.&lt;/p&gt;

&lt;p&gt;I call this: &lt;em&gt;FPGA Hell&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;If you find yourself deskcheck your code and not knowing what to look for, you
may be in FPGA Hell.  Weeks and months can spent in there, and you will make no
progress towards your goal while you are there.&lt;/p&gt;

&lt;p&gt;Time is money.  FPGA Hell will cost you dearly.  Avoid FPGA Hell at &lt;em&gt;all&lt;/em&gt; cost.&lt;/p&gt;

&lt;h2 id=&quot;the-solution&quot;&gt;The solution&lt;/h2&gt;

&lt;p&gt;The solution to FPGA Hell is twofold.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;First, simulate everything.  If you don’t have a simulation to describe
the hardware you are working with, make one.&lt;/p&gt;

    &lt;p&gt;As an example, &lt;a href=&quot;https://github.com/ZipCPU/wbuart32/blob/master/bench/cpp/uartsim.cpp&quot;&gt;here is&lt;/a&gt; a simulation of a UART port.  It turns a UART port into either your
standard input and output FILE streams, or into a TCP/IP port that you can
stream your data in and out of.  I built the simulation from an &lt;a href=&quot;https://en.wikipedia.org/wiki/Universal_asynchronous_receiver/transmitter&quot;&gt;online
description&lt;/a&gt; of how a UART works.  I then use the simulation to debug any Verilog
code someone posts to &lt;a href=&quot;http://forum.digilentinc.com&quot;&gt;Digilent’s forums&lt;/a&gt;, but
now that you know my secrets, you can do it too.&lt;/p&gt;

    &lt;p&gt;The problem with this first step is: what happens if your understanding of
the device you just built a simulator doesn’t match reality?  For that, you
need a scope.  Specifically, you need to measure reality and learn what’s
actually happening, and then you need to adjust your simulation to match
reality.  This leads us to the second part of the solution: using a scope.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Use a scope.  Measure what’s really going on.  Watch your code interact with
the real hardware, and use what you learn to find where reality and your
simulation disconnect.&lt;/p&gt;

    &lt;p&gt;A good example of this is my first attempt to build an &lt;a href=&quot;https://github.com/ZipCPU/wbi2c&quot;&gt;I2C
controller&lt;/a&gt;.  For that project, I built
two controllers, &lt;a href=&quot;https://github.com/ZipCPU/wbi2c/blob/master/rtl/wbi2cslave.v&quot;&gt;one a
slave&lt;/a&gt; and &lt;a href=&quot;https://github.com/ZipCPU/wbi2c/blob/master/rtl/wbi2cmaster.v&quot;&gt;the
other a
master&lt;/a&gt;.
I then built simulations for both &lt;a href=&quot;https://github.com/ZipCPU/wbi2c/blob/master/bench/cpp/wbi2cs_tb.cpp&quot;&gt;the
slave&lt;/a&gt;
and &lt;a href=&quot;https://github.com/ZipCPU/wbi2c/blob/master/bench/cpp/wbi2cm_tb.cpp&quot;&gt;the
master&lt;/a&gt;,
and then worked with the simulations until my code worked.  Once my code
worked, I placed it onto the device and … my code didn’t work.&lt;/p&gt;

    &lt;p&gt;To get past the problem, I placed a
&lt;a href=&quot;https://github.com/ZipCPU/wbscope/blob/master/rtl/wbscopc.v&quot;&gt;scope&lt;/a&gt; into my
design, allowing me to “see” what was going on.  What I learned was that the
hardware I was talking to (my monitor) wasn’t doing what I thought it should.
I then had to find &lt;a href=&quot;https://www.i2c-bus.org/specification&quot;&gt;a better
description&lt;/a&gt; of how an I2C port
works, rebuild my simulation, get the simulation working again, and then
test on the hardware.&lt;/p&gt;

    &lt;p&gt;You can find a discussion of the result, together with pictures of what I was
looking at,
&lt;a href=&quot;https://github.com/ZipCPU/wbscope/tree/master/doc/examples/hdmi-eddc&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;If you cannot use a scope, modify &lt;a href=&quot;blinky.html&quot;&gt;blinky&lt;/a&gt; to get the
information you need.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Hopefully this helps you avoid FPGA Hell.  If not, watch this space.  I intend
to write more articles here about how to debug an FPGA design.&lt;/p&gt;
</description>
        <pubDate>Fri, 19 May 2017 00:00:00 -0400</pubDate>
        <link>http://zipcpu.com/blog/2017/05/19/fpga-hell.html</link>
        <guid isPermaLink="true">http://zipcpu.com/blog/2017/05/19/fpga-hell.html</guid>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>Blinky</title>
        <description>&lt;p&gt;In C, the first program a person writes is often known  as a
&lt;a href=&quot;https://en.wikipedia.org/wiki/&amp;quot;Hello,_World!&amp;quot;_program&quot;&gt;“Hello, World!”&lt;/a&gt;
program.  It does nothing but print “Hello, World!” to the screen and exit.
While this is a wonderful first program for the C programmer, it is wholly
inappropriate for either the FPGA programmer or the embedded programmer.&lt;/p&gt;

&lt;p&gt;The FPGA or embedded programmer must work to get the serial port or the
C-library working, if he has either.  Instead, he has a simple LED to work with.
Hence the first program, &lt;a href=&quot;https://hackaday.io/project/7982-cat-board/log/37305-getting-to-blinky-cat-board-style&quot;&gt;blinky&lt;/a&gt;, simply blinks that LED.&lt;/p&gt;

&lt;h2 id=&quot;why-blinky&quot;&gt;Why blinky?&lt;/h2&gt;

&lt;p&gt;Blinky is a very important program: it proves that you can 1) program the
FPGA, that you 2) have a working clock, and that 3) you have a working LED.
These are very important steps in programming a new board.  Indeed, they are
so profound, I still run blinky as my first program on any FPGA board today.
Even after your first configuration, blinky is still important, because it can
tell you if the problem is your design versus the ability to load the board.&lt;/p&gt;

&lt;h2 id=&quot;what-is-blinky&quot;&gt;What is blinky?&lt;/h2&gt;

&lt;p&gt;Below is a very simple version of the blinky program, written in Verilog.
Remember, simple is better at this point.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;//
`default_nettype none
//
module blinky(i_clk, o_led);
  input wire i_clk;
  output wire o_led;

reg	[25:0]	counter;
always @(posedge i_clk)
  counter &amp;lt;= counter + 1&#39;b1;
assign o_led = counter[25];

endmodule&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;While there’s not much to the design, the “not much” that is there is important.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Notice that I mark my inputs with the prefix i_, and my outputs with the prefix o_.  You’ll find this consistent notation through all of my work.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Notice the default_nettype directive.  We’ll come back to it later.  For now, I highly recommend every Verilog design you build start with it.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Notice the counter.  Many beginners place an LED in their design without the counter, and then wonder why things don’t work.  An FPGA runs faster than your eye can see.  Without the counter, you wouldn’t be able to see this LED blink.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;I have 26 bits in my counter (25+1).  This is just about right for most of the projects I’ve worked on.  It divides the clock by 2^26, creating a clock rate at around one Hertz.  If you pick a number too low, you won’t see the LED blink.  If you pick a number too high, you’ll get bored waiting for the LED to blink while wondering if your FPGA works.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;a-better-blinky&quot;&gt;A better blinky&lt;/h2&gt;

&lt;p&gt;With no more than just a clock and an LED, can you figure out how fast your
clock is running?&lt;/p&gt;

&lt;p&gt;This was a challenge of mine when first firing up my
&lt;a href=&quot;http://icoboard.org&quot;&gt;icoboard&lt;/a&gt;.  The
&lt;a href=&quot;https://drive.google.com/file/d/0By-zY9AlHqXIcXZ6ZWdBR2dPXzg/view&quot;&gt;schematic&lt;/a&gt;
for that board initially identified the
clock as being at 25MHz, the examples identified it as being at 100MHz.  (The
team has since fixed the schematic, to properly reflect the 100MHz clock.)  How
should I tell which of the two was the right answer?&lt;/p&gt;

&lt;p&gt;Here was my solution:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;//
`default_nettype none
//
module clktest(i_clk, o_led);
  input wire i_clk;
  output wire o_led;

// We use a larger, 32-bit, counter here so as to get some better time
// precision.
reg	[31:0]	counter;
always @(posedge i_clk)
  counter &amp;lt;= counter + 32&#39;d43; // Valid if clk rate = 100MHz

// Blink the LED sharply at the top of each second, so that
// it remains on for a quarter of a second only before turning
// off
assign o_led = (counter[31:30] == 2&#39;b00);

endmodule&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Did you notice the 32’d43 value?  This value is set to 2^32 divided by the
clock rate.  Since the clock rate on this board is 100 MHz, 2^32 divided by
100 MHz is about 43.  Hence, if the counter starts at zero, then after
100 million clock ticks, the counter should equal 2^32 and roll over to zero
again.  In this case, though, since 2^32/100M isn’t exactly 43, our clock will
run about 5% too fast.  Still … it should be close enough that we can use a
stop watch to verify that we are in about the right clock range.&lt;/p&gt;

&lt;p&gt;If you are interested, this method of clock division is also used within the
&lt;a href=&quot;https://github.com/ZipCPU/rtcclock&quot;&gt;Real-Time Clock&lt;/a&gt; project used by the
ZipCPU.  The project, though, uses a 48-bit counter to get much better 
time accuracy–assuming that the oscillator is that good.&lt;/p&gt;

&lt;h2 id=&quot;using-blinky-for-debugging&quot;&gt;Using blinky for debugging&lt;/h2&gt;

&lt;p&gt;If you ever find yourself debugging with nothing but an LED, you can use the
LED for your debugging.  It’s not the best means of debugging: it can only
return one bit of information, and sometimes not even that, but it may be
the only means you have.&lt;/p&gt;

&lt;p&gt;The basic idea is to set the LED to on any time some condition takes place.
The trick is … you need to reset the LED so that you can see if that
condition takes place again later, and you need to make certain that the
condition (whatever it is) takes place so rarely that you can understand
what’s going on.&lt;/p&gt;

&lt;p&gt;Here’s an updated blinky, therefore, that can be used within a design to help
debug it:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;reg	[24:0]	counter;
always @(posedge i_clk)
  if (debug_event)
    counter &amp;lt;= 0;
  else if (!&amp;amp;counter)
    counter &amp;lt;= counter + 1&#39;b1;

assign o_led = counter[24];&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;As before, the choice of the length of the counter is important.&lt;/p&gt;

&lt;p&gt;This time, though, we’ve used “debug_event”, a variable coming from elsewhere
in the design, to check to see if something ever happens.&lt;/p&gt;

&lt;p&gt;While better approaches exist, most of those require more logic that needs to
be debugged first.  As a result, I’ve used this approach to debug my 
&lt;a href=&quot;https://github.com/ZipCPU/wbuart32/&quot;&gt;serial port controller&lt;/a&gt;, since most of my
debugging logic depends upon a working serial port.  I’ve also used this
approach to track how much time the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;
is spending in &lt;a href=&quot;https://github.com/ZipCPU/s6soc/blob/master/sw/zipos/kernel.c#L118&quot;&gt;interrupts&lt;/a&gt;, and if
and when the ZipCPU &lt;a href=&quot;https://github.com/ZipCPU/s6soc/blob/master/rtl/busmaster.v#L448&quot;&gt;has frozen&lt;/a&gt; in &lt;a href=&quot;https://github.com/ZipCPU/s6soc&quot;&gt;designs&lt;/a&gt; that are too tight
to fit a &lt;a href=&quot;https://github.com/ZipCPU/wbscope&quot;&gt;better debugging infrastructure&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;what-next&quot;&gt;What next?&lt;/h2&gt;

&lt;p&gt;Once you have blinky running, it’s time to move on to other tasks.  These tasks, though, will be easier because you have a clock and an LED that works.  Indeed, you can use blinky to your advantage as you struggle to get those newer tasks running.&lt;/p&gt;

</description>
        <pubDate>Fri, 19 May 2017 00:00:00 -0400</pubDate>
        <link>http://zipcpu.com/blog/2017/05/19/blinky.html</link>
        <guid isPermaLink="true">http://zipcpu.com/blog/2017/05/19/blinky.html</guid>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>Most common Digilent FPGA support requests</title>
        <description>&lt;p&gt;I’ve been watching the &lt;a href=&quot;https://forum.digientinc.com&quot;&gt;Digilent Forum’s&lt;/a&gt;, and
I’ve now seen some very common requests for FPGA help that keep coming back
over and over again.  I’ll separate these into three groups, and share them
here with you.  They are actual hardware problems, beginner problems, and
Vivado problems.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Actual Hardware Problems&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;Device not found.
&lt;a href=&quot;https://forum.digilentinc.com/topic/4095-cmod-a7-comms-problem/&quot;&gt;[1]&lt;/a&gt;
&lt;a href=&quot;https://forum.digilentinc.com/topic/3564-problem-with-detecting-arty-on-linux/&quot;&gt;[2]&lt;/a&gt;
&lt;a href=&quot;https://forum.digilentinc.com/topic/3749-programming-flash-cmod-a7/&quot;&gt;[3]&lt;/a&gt;&lt;/p&gt;

        &lt;p&gt;User’s seem to have a problem getting their tools set up properly.  I
certainly did.  One particular problem is basically, “I just plugged in
my device and my computer doesn’t recognize it.”  This is commonly caused
by an invalid or incomplete tool-suite setup.  However, it can be caused
by a bad USB cable.  So, usually, if the device &lt;em&gt;was&lt;/em&gt; working, it tends to
be instead a bad USB cable.  Strangely enough, bad USB cables a rather
common occurrence on the forums.&lt;/p&gt;

        &lt;p&gt;&lt;strong&gt;The solution&lt;/strong&gt;: It depends on the problem&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;There’s the FTDI request. 
&lt;a href=&quot;https://forum.digilentinc.com/topic/3658-digilent-nexys-video-ft2232-eeprom/&quot;&gt;[1]&lt;/a&gt;&lt;/p&gt;

        &lt;p&gt;Many individuals have tried, either by accident or on purpose, reflashing
the FTDI interface chip on their board and, as a result, have broken their
board so badly that it no longer responds to configuration commands.  The
solution to this problem is that the Digilent staff will send this user a
private message with the correct software to reload onto their device.&lt;/p&gt;

        &lt;p&gt;The strange part of this request is that I am aware of one user who
has successfully reprogrammed the FT2232 chip on his board, and
achieved much higher data throughput as a result.&lt;/p&gt;

        &lt;p&gt;&lt;strong&gt;The solution&lt;/strong&gt;: The Digilent staff provides a private message containing
instructions and/or data to fix this problem.&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Beginner problems&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;I need to build (some instructor’s problem statement).  Please help me.
&lt;a href=&quot;https://forum.digilentinc.com/topic/4110-ise-design-suite/&quot;&gt;[1]&lt;/a&gt;
&lt;a href=&quot;https://forum.digilentinc.com/topic/4104-basys-3/&quot;&gt;[2]&lt;/a&gt;&lt;/p&gt;

        &lt;p&gt;This request gets the least help from members on the forum.  The response
is usually a kind pointer to where the user documentation is at and
nothing more.&lt;/p&gt;

        &lt;p&gt;&lt;strong&gt;The solution&lt;/strong&gt;:  The student needs to do his own homework.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;Help me, my design doesn’t work.
&lt;a href=&quot;https://forum.digilentinc.com/topic/3991-usb-keyboard-on-basys3/&quot;&gt;[1]&lt;/a&gt;
&lt;a href=&quot;https://forum.digilentinc.com/topic/3731-nexys-4-to-pc-uart-communication/&quot;&gt;[2]&lt;/a&gt;
&lt;a href=&quot;https://forum.digilentinc.com/topic/3706-not-receiving-packets-in-echo-server-example-in-nexys-4-ddr-getting-started-with-microblaze-servers/&quot;&gt;[3]&lt;/a&gt;
&lt;a href=&quot;https://forum.digilentinc.com/topic/3666-artix-nexys-4-and-keyboard/&quot;&gt;[4]&lt;/a&gt;
&lt;a href=&quot;https://forum.digilentinc.com/topic/3675-arty-display-uart-data-on-leds/&quot;&gt;[5]&lt;/a&gt;&lt;/p&gt;

        &lt;p&gt;I’ll come back to this in a moment, but many students think that
an experienced engineer can just deskcheck their work and find the bug.
While I enjoy the challenge, and while I can often do this, it
certainly wasn’t how I became an &lt;em&gt;experienced&lt;/em&gt; engineer when working
with FPGAs.  I got there through simulation to make sure my logic
worked, and using a scope (or scopes) to make sure my simulation
matched the device.&lt;/p&gt;

        &lt;p&gt;&lt;strong&gt;The solution&lt;/strong&gt;: The solution is to simulate the design together with a
simulated peripheral.  This is often how I find bugs in students serial
port designs, for example.  I’ll connect their design to a &lt;a href=&quot;https://github.com/ZipCPU/wbuart32/blob/master/bench/cpp/uartsim.cpp&quot;&gt;serial port
simulator&lt;/a&gt;,
create a &lt;a href=&quot;https://en.wikipedia.org/wiki/Value_change_dump&quot;&gt;.vcd file&lt;/a&gt; for
viewing in &lt;a href=&quot;http://gtkwave.sourceforge.net&quot;&gt;gtkwave&lt;/a&gt;, and write back about
what I found.  There’s no reason why the student couldn’t have done this.&lt;/p&gt;

        &lt;p&gt;Perhaps I’ll post these results for the next student I help?&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;Asynchronous Reset
&lt;a href=&quot;https://forum.digilentinc.com/topic/3702-pc-to-basys3-via-uart-not-working-correctly/&quot;&gt;[1]&lt;/a&gt;&lt;/p&gt;

        &lt;p&gt;While Xilinx devices support an asynchronous reset to the logic, it’s so
unreliable that &lt;a href=&quot;https://forums.xilinx.com/t5/PLD-Blog/That-Dangerous-Asynchronous-Reset/ba-p/12856&quot;&gt;they recommend users not use it&lt;/a&gt;.  This is usually a
student’s first project on an actual FPGA, and a beginner’s mistake.&lt;/p&gt;

        &lt;p&gt;&lt;strong&gt;The solution&lt;/strong&gt;: Get rid of the &lt;em&gt;negedge&lt;/em&gt; &lt;em&gt;reset&lt;/em&gt; from any always block
dependencies.  Replace these with a combination of &lt;em&gt;initial&lt;/em&gt; statements and
(if necessary) synchronous resets.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;The logic Clock
&lt;a href=&quot;https://forum.digilentinc.com/topic/681-creating-a-25-mhz-clock-on-the-basys-3/&quot;&gt;[1]&lt;/a&gt;&lt;/p&gt;

        &lt;p&gt;Many new FPGA users aren’t quite aware the clocks are special things.
They then create logic wires internal to their design which they wish
to use to divide this clock rate.  While not a problem, such logic
wires don’t have the reliability of a clock, and transitioning on their
edges doesn’t produce the result you will want.  Where the problem comes
into play is when the student wants their logic to transition on the
positive (or worse negative) edge of this clock.&lt;/p&gt;

        &lt;p&gt;&lt;strong&gt;The solution&lt;/strong&gt;: &lt;a href=&quot;https://www.quora.com/What-is-the-function-of-a-strobe-function-in-digital-system&quot;&gt;a logic strobe&lt;/a&gt;.&lt;/p&gt;

        &lt;p&gt;This solution finds a lot of application in 1. beginning FPGA student
designs, and then again in 2. signal processing designs, where the
device’s clock speed is not synchronized to the FPGA’s clock, and hence
the data comes in from the sensor at a slower speed than the devices
clock speed.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;The student who hasn’t simulated their design&lt;/p&gt;

        &lt;p&gt;In this case, someone new to FPGA design has created some design and it
doesn’t work.  They don’t know why.  This one is similar to the Vivado
library component problem: they have no idea what’s going on internal
to the FPGA to answer the “why won’t my program work” question.&lt;/p&gt;

        &lt;p&gt;The solution they want to this problem is not the industry solution.
What these students want is for some kind soul on the forum to look at
their code and tell them what they are doing wrong.&lt;/p&gt;

        &lt;p&gt;&lt;strong&gt;The industry solution&lt;/strong&gt; to this problem is to simulate the code and any
peripherals it might be working with, and then as part of that to verify
that the logic works as intended.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;They don’t know how to simulate their problem
&lt;a href=&quot;https://forum.digilentinc.com/topic/3992-something-simple-is-apparently-impossible-incrdec-number/&quot;&gt;[1]&lt;/a&gt;&lt;/p&gt;

        &lt;p&gt;Sometimes the user is trying to work with a piece of hardware they’ve
never worked with before.  As a result, they have no simulation for this
hardware because they just aren’t all that familiar with how it works.
(A user button is a good example of this, since bouncing isn’t something
most people place into simulators.) In this case, their design doesn’t work
on the real hardware and, again, they don’t know why.&lt;/p&gt;

        &lt;p&gt;&lt;strong&gt;The solution&lt;/strong&gt; to this problem is twofold.  First, build a simulator that
encapsulates your understaning of the hardware from the diagrams and
specifications you have.  Second, when that first part fails, use some
form of a  scope to measure what is actually going on across the wires
to/from the hardware.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;Crossing clock domains&lt;/p&gt;

        &lt;p&gt;Few students have ever heard of &lt;a href=&quot;https://en.wikipedia.org/wiki/Metastability_in_electronics&quot;&gt;metastability
problems&lt;/a&gt;.  As
a result, they write code that crosses clock domains realizing that there
might be a problem associated with doing so.&lt;/p&gt;

        &lt;p&gt;&lt;strong&gt;The solution&lt;/strong&gt;: The simple solution is to clock every input at the new
clock twice before using it.  This works for some things, though not all.
A more complete discussion of how to deal with crossing from one clock
can be found in &lt;a href=&quot;http://www.sunburst-design.com/papers/CummingsSNUG2008Boston_CDC.pdf&quot;&gt;this
article&lt;/a&gt;.&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Vivado problems&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;The demo doesn’t build
&lt;a href=&quot;https://forum.digilentinc.com/topic/4090-error-with-pmod-oledrgb-demo/&quot;&gt;[1]&lt;/a&gt;&lt;/p&gt;

        &lt;p&gt;Typically this is caused by the user trying to build the demo design
using one version of Vivado, while the demo was instead built with
another version of Vivado.&lt;/p&gt;

        &lt;p&gt;&lt;strong&gt;The solution&lt;/strong&gt;: The Digilent staff share what version of Vivado was used
to build the demo.  Sometimes the demo has gotten old, and the Digilent
staff need to update it.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;They’ve integrated some component from the Vivado library into their design
and “it’s not working”
&lt;a href=&quot;https://forum.digilentinc.com/topic/4011-how-to-easily-implement-a-basic-low-pass-filter-using-fir-compiler-on-nexys-4-ddr/&quot;&gt;[1]&lt;/a&gt;
&lt;a href=&quot;https://forum.digilentinc.com/topic/3735-dds-compiler-60-ip-core-for-audible-sinewave/&quot;&gt;[2]&lt;/a&gt;&lt;/p&gt;

        &lt;p&gt;Of all the times I’ve seen this problem, it has yet to be that the
Xilinx provided IP component doesn’t work.  It’s more often that the
user isn’t feeding the component properly, or using the results from
the component properly.  Making the problem worse, rarely has the user
taken the time to instrument what is going on, so they have no clue
where their problem lies.&lt;/p&gt;

        &lt;p&gt;&lt;strong&gt;The solution&lt;/strong&gt;: a good internal scope, such as the
&lt;a href=&quot;https://github.com/ZipCPU/wbscope&quot;&gt;wishbone scope&lt;/a&gt; or the &lt;a href=&quot;https://github.com/ZipCPU/wbscope/blob/master/rtl/axi4lscope.v&quot;&gt;AXI-Lite
scope&lt;/a&gt;&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;The user can’t figure out how to add custom IP to the Vivado flow
&lt;a href=&quot;https://forum.digilentinc.com/topic/3961-how-to-add-own-logic-to-arty-board-flow/&quot;&gt;[1]&lt;/a&gt;&lt;/p&gt;

        &lt;p&gt;&lt;strong&gt;The solution&lt;/strong&gt;: Well, I might be biased here, but … my solution to
this problem has been not to use the broken Vivado design flow.
I’m sure I’ll discuss more of my problems with there processing flow
as time goes on.&lt;/p&gt;

        &lt;p&gt;One of the pleasant things about the &lt;a href=&quot;https://forum.digilentinc.com&quot;&gt;Digilent
forums&lt;/a&gt; is that these common requests
are dealt with in a friendly manner–even though I’m certain someone
must be rolling their eyes at seeing the same request &lt;em&gt;again&lt;/em&gt;.&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;I think I’ll come back to this over time, adding references to this this post
of Digilent Forum posts that illustrate my points here.&lt;/p&gt;
</description>
        <pubDate>Thu, 18 May 2017 00:00:00 -0400</pubDate>
        <link>http://zipcpu.com/digilent/2017/05/18/most-common-digilent-support-requests.html</link>
        <guid isPermaLink="true">http://zipcpu.com/digilent/2017/05/18/most-common-digilent-support-requests.html</guid>
        
        
        <category>digilent</category>
        
      </item>
    
      <item>
        <title>Cannot be done</title>
        <description>&lt;p&gt;One common request on Digilent is the, “Can I do XYZ on board ABC”?&lt;/p&gt;

&lt;p&gt;I really dislike answering questions of this type.  I’ve been surprised too many
times by someone doing what I thought was impossible.  Indeed, I’ve also had my
own opportunities to surprise others by doing things they thought were
impossible.&lt;/p&gt;

&lt;p&gt;A couple examples should illustrate this point:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;I gave up early on the idea of building a Video game on a &lt;a href=&quot;https://store.digilentinc.com/basys-3-artix-7-fpga-trainer-board-recommended-for-introductory-users/&quot;&gt;Basys-3
 board&lt;/a&gt;.
 I figured the task was just plain impossible: although you can make
 a 128kB of block RAM on the board, there wasn’t enough memory on
 the board for a 640x480 piece of video memory, with a bare minimum of four
 bits per pixel (256kB required) and the Basys-3 &lt;em&gt;only&lt;/em&gt; has the
 block RAM on board.&lt;/p&gt;

    &lt;p&gt;Since giving up, I discovered some individuals had done it.  Digging
 into those who were willing to share, I learned how they had done it. 
 They took the video stream, and wrote characters directly on the stream
 using FPGA hardware.  That way, there was no storage requirement.  I
 had already done something similar to place a mouse on the screen, so
 I shouldn’t have been as surprised as I was.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;When presenting at &lt;a href=&quot;https://orconf.org/2016/&quot;&gt;ORCONF&lt;/a&gt; some time ago, I had
 the opportunity to meet my first Digilent employee.  When I shared with him
 what &lt;a href=&quot;https://github.com/ZipCPU/s6soc&quot;&gt;I had done&lt;/a&gt; with their
 &lt;a href=&quot;https://store.digilentinc.com/store.digilentinc.com/cmod-s6-breadboardable-spartan-6-fpga-module&quot;&gt;CMod S6&lt;/a&gt;, and specifically how I had managed
 to place a multi-tasking O/S (as I called it) on the board, he was
 exceptionally impressed.  Particularly since he had written off the board as
 being unfit for this type of task.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The only question left, therefore, is where the next surprise is coming from.&lt;/p&gt;
</description>
        <pubDate>Thu, 18 May 2017 00:00:00 -0400</pubDate>
        <link>http://zipcpu.com/digilent/2017/05/18/cannnot-be-done.html</link>
        <guid isPermaLink="true">http://zipcpu.com/digilent/2017/05/18/cannnot-be-done.html</guid>
        
        
        <category>digilent</category>
        
      </item>
    
  </channel>
</rss>
