<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>The ZipCPU by Gisselquist Technology</title>
    <description>The ZipCPU blog, featuring how to discussions of FPGA and soft-core CPU design.  This site will be focused on Verilog solutions, using exclusively OpenSource IP products for FPGA design.  Particular focus areas include topics often left out of more mainstream FPGA design courses such as how to debug an FPGA design.
</description>
    <link>https://zipcpu.com/</link>
    <atom:link href="https://zipcpu.com/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Sat, 23 Nov 2019 23:14:48 -0500</pubDate>
    <lastBuildDate>Sat, 23 Nov 2019 23:14:48 -0500</lastBuildDate>
    <generator>Jekyll v3.0.1</generator>
    <image>
      <url>https://zipcpu.com/img/gt-rss.png</url>
      <title></title>
      <link></link>
    </image>
    
      <item>
        <title>The ZipCPU meets blinky</title>
        <description>&lt;p&gt;If you’ve never heard of “blinky” before, it’s the name given to a piece of
software or even an FPGA design that simply blinks an LED.  &lt;a href=&quot;/blog/2017/05/19/blinky.html&quot;&gt;We’ve discussed
building blinky before&lt;/a&gt;,
as well the &lt;a href=&quot;/blog/2017/05/20/knight-rider.html&quot;&gt;more advanced (but no less fun) project
of moving an active LED back and forth across a set of
LEDs&lt;/a&gt; like one of my
&lt;a href=&quot;https://en.wikipedia.org/wiki/Knight_Rider&quot;&gt;favorite TV shows as a kid, “Knight Rider”&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Even better, we’ve also discussed how to create a &lt;a href=&quot;https://github.com/ZipCPU/arrowzip/blob/195b77dc144d6ed7d4280f506c35b2204f13908c/rtl/arrowzip/wbgpio.v&quot;&gt;general purpose I/O
controller&lt;/a&gt;,
which could then be used to &lt;a href=&quot;/zipcpu/2019/02/09/cpu-blinky.html&quot;&gt;run a blinky program from within a
CPU&lt;/a&gt;.
In that particular article, we also measured how fast a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;
could toggle an I/O pin as part of such a &lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/e7b39a56ee515d1cabe8427f30c7add0592bfab1/sw/board/gpiotoggle.c&quot;&gt;blinky
program&lt;/a&gt;.  The resulting toggle rates, between
1 and 47MHz, are fairly impressive for a soft-core running within an FPGA
with a 100MHz system clock.&lt;/p&gt;

&lt;p&gt;Today, let’s return to blinky again, but this time let’s compare and contrast
several approaches to the problem of toggling four separate LEDs: one at &lt;code class=&quot;highlighter-rouge&quot;&gt;1Hz&lt;/code&gt;,
one at &lt;code class=&quot;highlighter-rouge&quot;&gt;2Hz&lt;/code&gt;, one at &lt;code class=&quot;highlighter-rouge&quot;&gt;3Hz&lt;/code&gt;, and a fourth one at &lt;code class=&quot;highlighter-rouge&quot;&gt;5Hz&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&quot;fpga-blinky&quot;&gt;FPGA blinky&lt;/h2&gt;

&lt;p&gt;The easiest way to toggle four separate LEDs at once on an FPGA is to create
four separate blinky modules.  Each module would have a counter of some number
of bits, say &lt;code class=&quot;highlighter-rouge&quot;&gt;MSB+1&lt;/code&gt; bits, so it might be defined as &lt;code class=&quot;highlighter-rouge&quot;&gt;reg [MSB:0] counter;&lt;/code&gt;.
We could then add a different step in each module, where the step size
is &lt;code class=&quot;highlighter-rouge&quot;&gt;2^(MSB+1)/CLOCK_FREQUENCY * BLINK_FREQUENCY&lt;/code&gt;, and so create blinking LEDs
at any frequency we want.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;&lt;span class=&quot;k&quot;&gt;parameter&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;STEP&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;BLINK_FREQUENCY&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;30&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CLOCK_FREQUENCY&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;always&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;posedge&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i_clk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;counter&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;counter&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;STEP&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;assign&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;o_led&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;counter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;MSB&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 1. Four counters, each driving LED&#39;s&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/multithreaded-blinky/fpgax4.svg&quot; alt=&quot;&quot; width=&quot;280&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Internally, this might look something like Fig. 1 on the right.  Fig. 1 shows
four separate logic blocks, each similar to the block above, and each toggling
an LED at its own rate.&lt;/p&gt;

&lt;p&gt;Of course, this doesn’t tie our LEDs together in phase.  What if we wanted
all of them to have the same phase, so that they all turned on together at the
top of a second?&lt;/p&gt;

&lt;p&gt;In that case, we’d need to multiply a common counter, set to step at
&lt;code class=&quot;highlighter-rouge&quot;&gt;2^(MSB+1)/CLOCK_FREQUENCY&lt;/code&gt;, by our blink frequency to get the result.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;&lt;span class=&quot;k&quot;&gt;parameter&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;STEP&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;BLINK_FREQUENCY&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;30&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CLOCK_FREQUENCY&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;always&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;posedge&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i_clk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;counter&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;counter&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;STEP&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;always&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;posedge&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i_clk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;begin&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;counter_1hz&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;counter&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;counter_2hz&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;counter&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;counter_3hz&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;counter&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;counter_5hz&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;counter&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;assign&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;o_led_1hz&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;counter_1hz&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;MSB&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;assign&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;o_led_2hz&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;counter_2hz&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;MSB&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;assign&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;o_led_3hz&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;counter_3hz&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;MSB&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;assign&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;o_led_5hz&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;counter_5hz&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;MSB&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;table align=&quot;center&quot; style=&quot;float: left&quot;&gt;&lt;caption&gt;Fig 2. Generating synchronized blinks from a counter&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/multithreaded-blinky/fpga-sync.svg&quot; alt=&quot;&quot; width=&quot;320&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;If you’ve never built a design like this before, then I would encourage you
to try this.  Remember to formally verify it first, and then run it in
simulation.  The &lt;a href=&quot;/tutorial/&quot;&gt;tutorial&lt;/a&gt; should help you
there if you have any questions.&lt;/p&gt;

&lt;p&gt;For a next level challenge, consider removing the multiplies and replacing them
with shifts and adds.  Since we’re only multiplying by 2, 3, or 5 above,
this should be fairly easy.&lt;/p&gt;

&lt;p&gt;If you work with FPGAs at all, this test should be fairly basic–perhaps
even too easy.  If you haven’t, this is a fun place to start.&lt;/p&gt;

&lt;p&gt;Today, though, let’s take it up a notch.&lt;/p&gt;

&lt;h2 id=&quot;cpu-blinky-polled&quot;&gt;CPU Blinky, polled&lt;/h2&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 3. Placing a CPU within an FPGA&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/multithreaded-blinky/fpgawcpu.svg&quot; alt=&quot;&quot; width=&quot;480&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Moving from simple logic to a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;
is a big step within an FPGA.  Even if we use a resource minimized
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;,
such as the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;,
you’ll still need a lot of additional infrastructure.  At a minimum,
you’ll need a ROM to store startup instructions (I like using a &lt;a href=&quot;/blog/2019/03/27/qflexpress.html&quot;&gt;flash
memory device&lt;/a&gt;), a
&lt;a href=&quot;/zipcpu/2018/07/13/memories.html&quot;&gt;RAM to hold any local variables&lt;/a&gt;, a
&lt;a href=&quot;/zipcpu/2018/04/17/ziptimer.html&quot;&gt;timer&lt;/a&gt;
to determine what 1Hz is and a GPIO controller to actually set any LED values.
We’ll also use a &lt;a href=&quot;/zipcpu/2019/04/02/icontrol.html&quot;&gt;Programmable Interrupt Controller
(PIC)&lt;/a&gt;
as part of our solution.  Tying all of these together will require some type
of &lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;memory and peripheral bus (I like
Wishbone)&lt;/a&gt;, such as
is shown in Fig. 3 on the right.&lt;/p&gt;

&lt;p&gt;When we &lt;a href=&quot;/zipcpu/2019/02/09/cpu-blinky.html&quot;&gt;last discussed blinking an LED from a
CPU&lt;/a&gt;, we discussed
how to turn the LED on by &lt;a href=&quot;{ site.baseurl }}/blog/2018/11/03/soc-fpga.html&quot;&gt;writing to a particular register from a C
program&lt;/a&gt;,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;	&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_gpio&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;LED_ON&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;and then writing again to turn it off.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;	&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_gpio&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;LED_OFF&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;table align=&quot;center&quot; style=&quot;float: left&quot;&gt;&lt;caption&gt;Fig 4. Blinking with a counter&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/multithreaded-blinky/cpu-wait-counter.svg&quot; alt=&quot;&quot; width=&quot;240&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;If you wanted to toggle an LED across some time period, you could wait in a for
loop, and then toggle your LED–as shown below and in Fig. 4 on the left.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;WAITTIME&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
		&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_gpio&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;LED_ON&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

	&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;WAITTIME&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
		&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_gpio&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;LED_OFF&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Getting the value for WAITTIME just right might take some work.  Worse,
&lt;a href=&quot;https://en.wikipedia.org/wiki/CPU_cache&quot;&gt;cache&lt;/a&gt;s are notorious for
providing fast but unpredictable wait times for both instructions and data.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 5. Triggering off of a 1ms hardware counter&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/multithreaded-blinky/cpu-polled.svg&quot; alt=&quot;&quot; width=&quot;240&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;But how might we handle four LEDs each toggling at a different rates?&lt;/p&gt;

&lt;p&gt;We could use a timer!  Remember our work building an
&lt;a href=&quot;/zipcpu/2018/04/17/ziptimer.html&quot;&gt;interval timer&lt;/a&gt; some time
ago?  Let’s use it now.  We’ll suppose the address of this timer is kept in the
&lt;a href=&quot;/blog/2018/11/03/soc-fpga.html&quot;&gt;constant pointer &lt;code class=&quot;highlighter-rouge&quot;&gt;_timer&lt;/code&gt;&lt;/a&gt;,
and we’ll have it create a repeating interval of one millisecond.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;	&lt;span class=&quot;n&quot;&gt;_timer&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x80000000&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mh&quot;&gt;0x8000&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_0000&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CPU_FREQUENCY_HZ&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;We can then use our &lt;a href=&quot;/zipcpu/2019/04/02/icontrol.html&quot;&gt;interrupt
controller&lt;/a&gt;, with a
&lt;a href=&quot;/blog/2018/11/03/soc-fpga.html&quot;&gt;register addresss&lt;/a&gt;
at &lt;code class=&quot;highlighter-rouge&quot;&gt;_pic&lt;/code&gt;, to determine if this timer has tripped:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;	&lt;span class=&quot;c1&quot;&gt;// Turn off all interrupt sources, and clear
&lt;/span&gt;	&lt;span class=&quot;c1&quot;&gt;// all active interrupt indications
&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;_pic&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x7fff7fff&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;picv&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_pic&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;c1&quot;&gt;// Reset any tripped interrupts
&lt;/span&gt;		&lt;span class=&quot;n&quot;&gt;_pic&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mh&quot;&gt;0x0ffff&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;picv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;If the &lt;a href=&quot;/zipcpu/2019/04/02/icontrol.html&quot;&gt;interrupt&lt;/a&gt;
has tripped, we know a millisecond has passed, so we can increment our
millisecond counter, &lt;code class=&quot;highlighter-rouge&quot;&gt;count_ms&lt;/code&gt;, and then toggle each of our LEDs.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;		&lt;span class=&quot;c1&quot;&gt;// Poll the interrupt timer to check
&lt;/span&gt;		&lt;span class=&quot;c1&quot;&gt;// if the interrupt has tripped
&lt;/span&gt;		&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;picv&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;INT_TIMER&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
			&lt;span class=&quot;c1&quot;&gt;// if it has, adjust our LEDs
&lt;/span&gt;			&lt;span class=&quot;c1&quot;&gt;// based upon the millisecond
&lt;/span&gt;			&lt;span class=&quot;c1&quot;&gt;// counter, count_ms
&lt;/span&gt;			&lt;span class=&quot;n&quot;&gt;count_ms&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
			&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;count_ms&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
				&lt;span class=&quot;n&quot;&gt;count_ms&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;toggleled&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;count_ms&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;toggleled&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;count_ms&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;toggleled&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;count_ms&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;toggleled&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;count_ms&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;8&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
		&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Of course, polling the &lt;a href=&quot;/zipcpu/2019/04/02/icontrol.html&quot;&gt;interrupt
controller&lt;/a&gt;
like this is really the wrong way to do this, but let’s come back to
this thought in the next section when we discuss how to do this with
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interrupt&quot;&gt;interrupts&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;One of the neat things about this approach compared to the uncalibrated
&lt;code class=&quot;highlighter-rouge&quot;&gt;for&lt;/code&gt; loop above is that we can now know &lt;em&gt;exactly&lt;/em&gt; how many clocks take
place between &lt;a href=&quot;https://en.wikipedia.org/wiki/Interrupt&quot;&gt;interrupts&lt;/a&gt;.
We also know that, should the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt;,
be late in processing an LED fast enough, at least the sequence will maintain
its frequency rather than randomly getting later and later and so slower–since
the &lt;a href=&quot;/zipcpu/2018/04/17/ziptimer.html&quot;&gt;timer&lt;/a&gt;
restarts itself every ms in this case.&lt;/p&gt;

&lt;p&gt;For now, let’s look at this &lt;code class=&quot;highlighter-rouge&quot;&gt;toggle_leds_on_ms()&lt;/code&gt; function.  How should this
function work?  The same way as before!  We’ll multiply our counter by
the toggle rate, divide by the number of counts per second, and then
grab the resulting bit of interest from the number of times the counter
wraps.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;	&lt;span class=&quot;nf&quot;&gt;toggle_leds_one_ms&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;count_ms&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rate_hz&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;which_led&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;mpy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

	&lt;span class=&quot;c1&quot;&gt;// count_ms is the number of milliseconds from the top of our
&lt;/span&gt;	&lt;span class=&quot;c1&quot;&gt;// second, ranging from 0 to 999.
&lt;/span&gt;	&lt;span class=&quot;c1&quot;&gt;//
&lt;/span&gt;	&lt;span class=&quot;c1&quot;&gt;// count_ms times our rate will give us a counter that overflows
&lt;/span&gt;	&lt;span class=&quot;c1&quot;&gt;// (rate) times per second.  Twice that creates a counter that
&lt;/span&gt;	&lt;span class=&quot;c1&quot;&gt;// overflows (2*rate) times per second--enough for us to turn on
&lt;/span&gt;	&lt;span class=&quot;c1&quot;&gt;// and then off the LED.
&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;mpy&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;count_ms&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rate_hz&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;mpy&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mpy&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

	&lt;span class=&quot;c1&quot;&gt;// mpy &amp;amp; 1 now contains what we want our counter value to be
&lt;/span&gt;	&lt;span class=&quot;c1&quot;&gt;//
&lt;/span&gt;	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mpy&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;c1&quot;&gt;// Turn this LED on
&lt;/span&gt;		&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_gpio&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;which_led&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;16&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;which_led&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;c1&quot;&gt;// Turn this LED off
&lt;/span&gt;		&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_gpio&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;which_led&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;16&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Remember &lt;a href=&quot;/zipcpu/2019/02/09/cpu-blinky.html&quot;&gt;the way we constructed our GPIO
controller&lt;/a&gt;: the
top 16 bits on read are any inputs to our design, while the bottom 16 bits
are outputs.  To be able to set particular output bits and not others, we write
a mask of the outputs we wish to adjust to the top 16 bits of the
register–hence the &lt;code class=&quot;highlighter-rouge&quot;&gt;(which_led &amp;lt;&amp;lt; 16)&lt;/code&gt; logic from above.  That way we can
leave the other I/O registers alone, while just adjusting only the ones
we want to change.&lt;/p&gt;

&lt;h2 id=&quot;interrupt-driven-cpu-blinky&quot;&gt;Interrupt driven CPU Blinky&lt;/h2&gt;

&lt;p&gt;What if we could shut the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;
down, though, when nothing was changing?&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: left&quot;&gt;&lt;caption&gt;Fig 6. Using the ZipCPU WAIT instruction&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/multithreaded-blinky/wait-for-timer.svg&quot; alt=&quot;&quot; width=&quot;360&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;This it the purpose of the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;’s
&lt;a href=&quot;/zipcpu/2018/01/01/zipcpu-isa.html&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;WAIT&lt;/code&gt; instruction&lt;/a&gt;.
We can get access to it from C without needing any assembly by calling the
built-in &lt;code class=&quot;highlighter-rouge&quot;&gt;zip_wait()&lt;/code&gt; function.  This instruction sets the &lt;code class=&quot;highlighter-rouge&quot;&gt;SLEEP&lt;/code&gt; bit in the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;’s &lt;a href=&quot;/zipcpu/2018/01/01/zipcpu-isa.html&quot;&gt;control
register&lt;/a&gt;.
Further, if the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
isn’t already in &lt;a href=&quot;/zipcpu/2018/01/01/zipcpu-isa.html&quot;&gt;user mode (interrupts are enabled only in user
mode)&lt;/a&gt;, it puts the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
into &lt;a href=&quot;/zipcpu/2018/01/01/zipcpu-isa.html&quot;&gt;user mode&lt;/a&gt;.
Then, when an &lt;a href=&quot;https://en.wikipedia.org/wiki/Interrupt&quot;&gt;interrupt&lt;/a&gt;
trips, the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; will return to
&lt;a href=&quot;/zipcpu/2018/01/01/zipcpu-isa.html&quot;&gt;supervisor mode (where interrupts are
disabled)&lt;/a&gt; so that we
can process the &lt;a href=&quot;https://en.wikipedia.org/wiki/Interrupt&quot;&gt;interrupt&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/doc//spec.pdf&quot;&gt;specification&lt;/a&gt;
discusses how to do this using a &lt;code class=&quot;highlighter-rouge&quot;&gt;wait_for_interrupt&lt;/code&gt;
function.  This function primarily deals with setting up the &lt;a href=&quot;/zipcpu/2019/04/02/icontrol.html&quot;&gt;interrupt
controller&lt;/a&gt;,
but once done it issues a &lt;code class=&quot;highlighter-rouge&quot;&gt;zip_wait()&lt;/code&gt; instruction for exactly this purpose.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;	&lt;span class=&quot;nf&quot;&gt;wait_for_interrupt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;interruptmask&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;// Turn off all interrupts, while acknowledging none of them
&lt;/span&gt;	&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_pic&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x7fff0000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;// Turn on only this interrupt
&lt;/span&gt;	&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_pic&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;interruptmask&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;16&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;&lt;span class=&quot;mh&quot;&gt;0x80008000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

	&lt;span class=&quot;c1&quot;&gt;// Be careful not to adjust any interrupts that have
&lt;/span&gt;	&lt;span class=&quot;c1&quot;&gt;// already tripped (the bottom 16 bits of the
&lt;/span&gt;	&lt;span class=&quot;c1&quot;&gt;// _pic), lest we miss the interrupt we are
&lt;/span&gt;	&lt;span class=&quot;c1&quot;&gt;// looking for
&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;// Wait for the interrupt, forcing the CPU to sleep
&lt;/span&gt;	&lt;span class=&quot;c1&quot;&gt;// until the next interrupt
&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;zip_wait&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;

	&lt;span class=&quot;c1&quot;&gt;// We won&#39;t clear the interrupt here,
&lt;/span&gt;	&lt;span class=&quot;c1&quot;&gt;// lest we destroy some information the
&lt;/span&gt;	&lt;span class=&quot;c1&quot;&gt;// calling function needs.
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Now we can rewrite our code from above to wait for an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interrupt&quot;&gt;interrupt&lt;/a&gt;.
Once done, the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt;
will sleep between its top-of-the-millisecond
computations.  The biggest difference in the code below is that
we now issue a &lt;code class=&quot;highlighter-rouge&quot;&gt;wait_for_interrupt()&lt;/code&gt; call at the top of every loop.
Following that call, things should look about the same as before.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;	&lt;span class=&quot;n&quot;&gt;_pic&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0xffff7fff&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Clear all interrupts
&lt;/span&gt;	&lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;wait_for_interrupt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;INT_TIMER&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

		&lt;span class=&quot;c1&quot;&gt;// Now check for any tripped interrupts
&lt;/span&gt;		&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;picv&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_pic&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

		&lt;span class=&quot;c1&quot;&gt;// Reset any tripped interrupts
&lt;/span&gt;		&lt;span class=&quot;n&quot;&gt;_pic&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mh&quot;&gt;0x0ffff&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;picv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

		&lt;span class=&quot;c1&quot;&gt;// Check if the timer interrupt has tripped
&lt;/span&gt;		&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;picv&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;INT_TIMER&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
			&lt;span class=&quot;c1&quot;&gt;// if it has, adjust our LEDs
&lt;/span&gt;			&lt;span class=&quot;c1&quot;&gt;// based upon the millisecond
&lt;/span&gt;			&lt;span class=&quot;c1&quot;&gt;// counter, count_ms
&lt;/span&gt;			&lt;span class=&quot;n&quot;&gt;count_ms&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
			&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;count_ms&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
				&lt;span class=&quot;n&quot;&gt;count_ms&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;toggle_leds_one_ms&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;count_ms&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;toggle_leds_one_ms&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;count_ms&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;toggle_leds_one_ms&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;count_ms&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;toggle_leds_one_ms&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;count_ms&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;8&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
		&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Not bad, huh?&lt;/p&gt;

&lt;p&gt;This program now functions exactly the same as the last one, save that the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
is inactive while waiting for the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interrupt&quot;&gt;interrupt&lt;/a&gt;.
This can have two advantages.  First, the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
will stop using the bus, allowing any non-CPU logic to transfer
data without contention from the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;.  Second, since the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
will stop issuing instructions, it can be placed into a lower power state.
Stopping the CPU clock at this point might even be an option to lower power–as
long as any &lt;a href=&quot;https://en.wikipedia.org/wiki/Interrupt&quot;&gt;interrupt&lt;/a&gt;
source kept clocking, and as long as the &lt;a href=&quot;/zipcpu/2019/04/02/icontrol.html&quot;&gt;interrupt
controller&lt;/a&gt;
could restart the CPU’s clock.  Still, it is doable, although it does depend
upon how much work you want to do to keep your power down.&lt;/p&gt;

&lt;p&gt;What if we wanted to get really fancy, though, and create a &lt;a href=&quot;https://github.com/ZipCPU/arrowzip/blob/master/sw/board/intdemo.c&quot;&gt;multitasking
blinky&lt;/a&gt;?
One where we had a separate program to toggle each of several various LEDs?&lt;/p&gt;

&lt;h2 id=&quot;multi-blinky&quot;&gt;Multi Blinky&lt;/h2&gt;

&lt;p&gt;To build the multi-tasking blinky, let’s step back and just look at the question
of how to run multiple software programs on a piece of hardware.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 7. Blinking an LED with four separate CPUs&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/multithreaded-blinky/cpux4.svg&quot; alt=&quot;&quot; width=&quot;360&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;The easiest way to do this, software-wise, might be to build multiple
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;s, as shown in
Fig. 7 on the right.  Easy, that is, until the two programs need to
communicate with each other …  but that’s a story for another day. Each
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;
might then run a separate program toggling an LED.&lt;/p&gt;

&lt;p&gt;Let’s build such a program now.  We’ll start by removing the counter
from our &lt;code class=&quot;highlighter-rouge&quot;&gt;toggle_leds_one_ms()&lt;/code&gt; function.  Instead, we’ll make the total number
of milliseconds that have passed into a global variable.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;milliseconds&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;We’ll then adjust our &lt;code class=&quot;highlighter-rouge&quot;&gt;toggle_leds_one_ms&lt;/code&gt; function so that it just reads and
references this global &lt;code class=&quot;highlighter-rouge&quot;&gt;milliseconds&lt;/code&gt; counter.  We’ll call this new function
&lt;code class=&quot;highlighter-rouge&quot;&gt;toggleled&lt;/code&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;    &lt;span class=&quot;nf&quot;&gt;toggleled&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;led_bits&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;     &lt;span class=&quot;n&quot;&gt;ms&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;milliseconds&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;led&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;ms&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ms&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rate&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;led&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ms&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

		&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;led&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
			&lt;span class=&quot;c1&quot;&gt;// LED was on.  Turn it off
&lt;/span&gt;			&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_spio&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;led_bits&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;8&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;
			&lt;span class=&quot;c1&quot;&gt;// LED was off.  Turn it on
&lt;/span&gt;			&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_spio&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;led_bits&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;8&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;led_bits&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Notice our care to only read the global &lt;code class=&quot;highlighter-rouge&quot;&gt;milliseconds&lt;/code&gt; value once.  Since reads
are atomic and since we copied the &lt;code class=&quot;highlighter-rouge&quot;&gt;milliseconds&lt;/code&gt; value, we don’t have to worry
about it changing mid-routine as a result of any routine that might
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interrupt&quot;&gt;interrupt&lt;/a&gt;
this processing.&lt;/p&gt;

&lt;p&gt;A second thing to notice is that &lt;a href=&quot;https://github.com/ZipCPU/arrowzip&quot;&gt;the
design&lt;/a&gt; we are basing this off of has a
&lt;a href=&quot;https://github.com/ZipCPU/arrowzip/blob/master/rtl/arrowzip/spio.v&quot;&gt;&lt;em&gt;Special Purpose I/O&lt;/em&gt;
register&lt;/a&gt;,
&lt;code class=&quot;highlighter-rouge&quot;&gt;_spio&lt;/code&gt;.  Setting LED’s in this &lt;code class=&quot;highlighter-rouge&quot;&gt;_spio&lt;/code&gt; register is just like using the &lt;code class=&quot;highlighter-rouge&quot;&gt;_gpio&lt;/code&gt;
register above, save that the LED area is now the lower 8-bits, and the
“adjust-these-bits” area is the 8-bits above that.  Hence, our reference
above to &lt;code class=&quot;highlighter-rouge&quot;&gt;_spio&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;(led_bits&amp;lt;&amp;lt;8)&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Finally, as long as something exists to count and keep the &lt;code class=&quot;highlighter-rouge&quot;&gt;milliseconds&lt;/code&gt;
counter for us, we can write a program to toggle our first LED at 1 Hz
as simple as,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;    &lt;span class=&quot;nf&quot;&gt;one_hz&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;toggleled&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Now if each CPU on our circuit board had such a program, they could all
toggle their LEDs together.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;    &lt;span class=&quot;nf&quot;&gt;two_hz&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;toggleled&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;    &lt;span class=&quot;nf&quot;&gt;three_hz&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;toggleled&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;16&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;    &lt;span class=&quot;nf&quot;&gt;five_hz&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;toggleled&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;64&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;There are a couple of problems with this approach.  First and foremost, the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
project has been built around small FPGAs and low logic.  (I never really had
the budget for much more.)  Four
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;s,
whether on four circuit boards, four chips on the same circuit board, or four
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;s
within the same FPGA, has never been within my budget.  I’d like to
run each of these four separate programs on the same
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;
instead.&lt;/p&gt;

&lt;p&gt;The solution to this problem is to virtually switch CPUs over time, as shown
in Fig. 8 below, through a process called
&lt;a href=&quot;https://en.wikipedia.org/wiki/Time-sharing&quot;&gt;time-sharing&lt;/a&gt;.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 8. Blinking an LED with four separate CPUs&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/multithreaded-blinky/timeslice.svg&quot; alt=&quot;&quot; width=&quot;560&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Here’s how it works: First, the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt; will start out running one
program–we’ll call this context 1 or &lt;code class=&quot;highlighter-rouge&quot;&gt;C1&lt;/code&gt; for short.  Then, after some
period of time, we’ll call it a &lt;em&gt;quanta&lt;/em&gt; and set it to &lt;code class=&quot;highlighter-rouge&quot;&gt;1ms&lt;/code&gt;, an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interrupt&quot;&gt;interrupt&lt;/a&gt;
will return the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt; to its supervisory task, &lt;code class=&quot;highlighter-rouge&quot;&gt;S&lt;/code&gt;.
The supervisory task will switch programs to the second context, &lt;code class=&quot;highlighter-rouge&quot;&gt;C2&lt;/code&gt;, which
will then run for the next &lt;em&gt;quanta&lt;/em&gt;.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: left&quot;&gt;&lt;caption&gt;Fig 9. Contexts contain CPU Register sets&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/multithreaded-blinky/contexts.svg&quot; alt=&quot;&quot; width=&quot;360&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;The key to the whole operation is that each “program” needs to
believe that it owns the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;.
In order to support this,
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;s
are typically designed so that their entire state is captured within a set of
&lt;a href=&quot;https://en.wikipedia.org/wiki/Processor_register&quot;&gt;registers&lt;/a&gt;.
This
&lt;a href=&quot;https://en.wikipedia.org/wiki/Processor_register&quot;&gt;register&lt;/a&gt;
set, defining what the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;
is up to, is called a &lt;em&gt;context&lt;/em&gt;.  Each &lt;em&gt;context&lt;/em&gt; contains its own
set of &lt;a href=&quot;https://en.wikipedia.org/wiki/Processor_register&quot;&gt;register&lt;/a&gt;s,
&lt;code class=&quot;highlighter-rouge&quot;&gt;R0&lt;/code&gt;-&lt;code class=&quot;highlighter-rouge&quot;&gt;R15&lt;/code&gt; on the
&lt;a href=&quot;/zipcpu/2018/01/01/zipcpu-isa.html&quot;&gt;ZipCPU&lt;/a&gt;,
to include the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Stack_register&quot;&gt;stack pointer &lt;code class=&quot;highlighter-rouge&quot;&gt;SP&lt;/code&gt;&lt;/a&gt;
(also known as &lt;code class=&quot;highlighter-rouge&quot;&gt;R13&lt;/code&gt;), &lt;a href=&quot;https://en.wikipedia.org/wiki/Status_register&quot;&gt;condition codes
&lt;code class=&quot;highlighter-rouge&quot;&gt;CC&lt;/code&gt;&lt;/a&gt;
(also known as &lt;code class=&quot;highlighter-rouge&quot;&gt;R14&lt;/code&gt;), and the address of the next instruction, often called
the &lt;a href=&quot;https://en.wikipedia.org/wiki/Program_counter&quot;&gt;program counter &lt;code class=&quot;highlighter-rouge&quot;&gt;PC&lt;/code&gt;&lt;/a&gt;
or equivalently &lt;code class=&quot;highlighter-rouge&quot;&gt;R15&lt;/code&gt; on the
&lt;a href=&quot;/zipcpu/2018/01/01/zipcpu-isa.html&quot;&gt;ZipCPU&lt;/a&gt;.
Therefore, in order to switch from running one program to another all the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt; needs to do
is to write the current context (i.e.
&lt;a href=&quot;https://en.wikipedia.org/wiki/Processor_register&quot;&gt;register&lt;/a&gt; set)
to memory, and to then to read the stored context for the next program
from memory.  This is often called a &lt;a href=&quot;https://en.wikipedia.org/wiki/Context_switch&quot;&gt;context
switch&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;To facilitate &lt;a href=&quot;https://en.wikipedia.org/wiki/Context_switch&quot;&gt;context
switching&lt;/a&gt;, the
&lt;a href=&quot;/zipcpu/2018/01/01/zipcpu-isa.html&quot;&gt;ZipCPU&lt;/a&gt;
maintains two copies of its
&lt;a href=&quot;https://en.wikipedia.org/wiki/Processor_register&quot;&gt;register&lt;/a&gt; set:
&lt;a href=&quot;/zipcpu/2018/01/01/zipcpu-isa.html&quot;&gt;one for the supervisor and one for user
programs&lt;/a&gt;.  Of these
two, the supervisor context is never swapped.  Indeed, it is the supervisor
context that swaps user contexts.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 10. Each context needs its own stack area&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/multithreaded-blinky/memlayout.svg&quot; alt=&quot;&quot; width=&quot;360&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Outside of the &lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;,
each context will also need an area of memory for its local variables.
This is called &lt;a href=&quot;https://en.wikipedia.org/wiki/Call_stack&quot;&gt;the stack&lt;/a&gt;,
and the &lt;a href=&quot;https://en.wikipedia.org/wiki/Stack_register&quot;&gt;stack pointer&lt;/a&gt;
will point to a location within this memory–starting at the end of the memory.
As memory is allocated, the &lt;a href=&quot;https://en.wikipedia.org/wiki/Stack_register&quot;&gt;stack
pointer&lt;/a&gt; will grow towards lower
memory as shown by the upwards arrow in Fig. 10.&lt;/p&gt;

&lt;p&gt;We can use a simple array of integers to capture the information contained in
a &lt;a href=&quot;/zipcpu/2018/01/01/zipcpu-isa.html&quot;&gt;ZipCPU&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Processor_register&quot;&gt;register&lt;/a&gt; set.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span class=&quot;k&quot;&gt;typedef&lt;/span&gt;	&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt;	&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;16&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;task_context&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;To &lt;a href=&quot;https://en.wikipedia.org/wiki/Context_switch&quot;&gt;swap between one program and
the next&lt;/a&gt;, we’ll just swap
&lt;a href=&quot;https://en.wikipedia.org/wiki/Processor_register&quot;&gt;register&lt;/a&gt; sets.
The two programs will never know what happened, because when the next program
is activated, all of its data will be right there in its
&lt;a href=&quot;https://en.wikipedia.org/wiki/Processor_register&quot;&gt;register&lt;/a&gt;s
just as it was when it left off.&lt;/p&gt;

&lt;p&gt;Let’s walk through how we might do this.&lt;/p&gt;

&lt;p&gt;The first step will be to assign a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Call_stack&quot;&gt;stack&lt;/a&gt;
to each task, as shown in Fig. 10 above.  This is a place of
memory designed to hold each task’s local variables.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: left&quot;&gt;&lt;caption&gt;Fig 11. The heap grows downwards&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/multithreaded-blinky/heap.svg&quot; alt=&quot;&quot; width=&quot;280&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Normally, I’d use &lt;code class=&quot;highlighter-rouge&quot;&gt;malloc()&lt;/code&gt; to do this or even the C++ &lt;code class=&quot;highlighter-rouge&quot;&gt;new&lt;/code&gt; operator.
Today, we’re going to try to do this without the C-library.  As a result,
we’ll need an alternative.  I’m going to call that alternative &lt;code class=&quot;highlighter-rouge&quot;&gt;ugly_malloc()&lt;/code&gt;.
It will act the same as &lt;code class=&quot;highlighter-rouge&quot;&gt;malloc()&lt;/code&gt;, except that there’s no &lt;code class=&quot;highlighter-rouge&quot;&gt;free()&lt;/code&gt; call and
so the memory will never return.&lt;/p&gt;

&lt;p&gt;This &lt;code class=&quot;highlighter-rouge&quot;&gt;ugly_malloc()&lt;/code&gt; function is built around a pointer to the end of our
program’s fixed memory locations.  The &lt;a href=&quot;/zipcpu/2018/12/22/autofpga-ld.html&quot;&gt;AutoFPGA linker
scripts&lt;/a&gt; define this
pointer as &lt;code class=&quot;highlighter-rouge&quot;&gt;_top_of_heap&lt;/code&gt;.  We can grab that here,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span class=&quot;k&quot;&gt;extern&lt;/span&gt;	&lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;_top_of_heap&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;_heap&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_top_of_heap&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Just getting to the point where &lt;code class=&quot;highlighter-rouge&quot;&gt;_heap&lt;/code&gt; even gets this value takes a lot of
work, much of which we will skip here.  That work starts in the
&lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt; &lt;a href=&quot;https://github.com/ZipCPU/arrowzip/blob/master/auto-data/sdram.ld&quot;&gt;configuration
script&lt;/a&gt;
that describes where the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;’s
memory is even located on a particular hardware architecture.  That script
defines the &lt;code class=&quot;highlighter-rouge&quot;&gt;_top_of_heap&lt;/code&gt; pointer and makes certain it’s aligned.  The next
step takes place in the
&lt;a href=&quot;/zipcpu/2018/02/12/zbasic-intro.html&quot;&gt;bootloader&lt;/a&gt;,
since &lt;code class=&quot;highlighter-rouge&quot;&gt;_heap&lt;/code&gt; is a variable whose value might change.  Such variables need to
be set initially.  So, this
&lt;a href=&quot;/zipcpu/2018/02/12/zbasic-intro.html&quot;&gt;bootloader&lt;/a&gt;
copies the initial value into &lt;code class=&quot;highlighter-rouge&quot;&gt;_heap&lt;/code&gt; before starting &lt;a href=&quot;https://github.com/ZipCPU/arrowzip/blob/master/sw/board/intdemo.c&quot;&gt;our
program&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Finally, we can now write this &lt;code class=&quot;highlighter-rouge&quot;&gt;ugly_malloc()&lt;/code&gt; function.  This function works
by just grabbing the next &lt;code class=&quot;highlighter-rouge&quot;&gt;nbytes&lt;/code&gt; from the heap, and then incrementing our
&lt;code class=&quot;highlighter-rouge&quot;&gt;_heap&lt;/code&gt; pointer to the next unallocated section of memory.  Since the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
cannot (yet) read from unaligned memory, we’ll also need to make certain this
pointer remains aligned.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;    &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;ugly_malloc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nbytes&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;// Get the pointer to the next unallocated piece of memory
&lt;/span&gt;	&lt;span class=&quot;c1&quot;&gt;// This is where our returned memory will be located..
&lt;/span&gt;        &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;    &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_heap&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

	&lt;span class=&quot;c1&quot;&gt;// Advance our _heap pointer to the next available piece
&lt;/span&gt;	&lt;span class=&quot;c1&quot;&gt;// of memory, while also guaranteeing that the pointer
&lt;/span&gt;	&lt;span class=&quot;c1&quot;&gt;// remains aligned.
&lt;/span&gt;        &lt;span class=&quot;n&quot;&gt;_heap&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_heap&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nbytes&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

	&lt;span class=&quot;c1&quot;&gt;// And return the result--the value of _heap when we entered
&lt;/span&gt;        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Using this &lt;code class=&quot;highlighter-rouge&quot;&gt;ugly_malloc()&lt;/code&gt; function, we can now allocate some local
variable space for each of our programs.  This will be the &lt;a href=&quot;https://en.wikipedia.org/wiki/Call_stack&quot;&gt;“stack”
space&lt;/a&gt;
used by these programs, and so we’ll use this to set the &lt;a href=&quot;https://en.wikipedia.org/wiki/Stack_register&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;SP&lt;/code&gt;
register&lt;/a&gt;
for each of the programs.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;     &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;new_stack_ptr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nbytes&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;	&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ptr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ugly_malloc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nbytes&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

	&lt;span class=&quot;n&quot;&gt;ptr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ptr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nbytes&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ptr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Thus function allocates a section of memory &lt;code class=&quot;highlighter-rouge&quot;&gt;nbytes&lt;/code&gt; in length, and then
returns a pointer to the end of it.  Our tasks won’t actually write to this
end value, but will instead back up
&lt;a href=&quot;https://en.wikipedia.org/wiki/Stack_register&quot;&gt;this pointer&lt;/a&gt;
by however much space they need as they need it.  This is illustrated in
Fig. 11 by an upwards arrow within each task’s
&lt;a href=&quot;https://en.wikipedia.org/wiki/Call_stack&quot;&gt;stack memory area&lt;/a&gt;
showing that the &lt;a href=&quot;https://en.wikipedia.org/wiki/Call_stack&quot;&gt;stack&lt;/a&gt;
grows upwards towards low memory.&lt;/p&gt;

&lt;p&gt;The astute observer will notice that the &lt;a href=&quot;https://en.wikipedia.org/wiki/Call_stack&quot;&gt;stack
spaces&lt;/a&gt;, which are
illustrated in Fig. 10, both for the supervisor and each of the user contexts,
are not unlimited.  If they grow too far, the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Call_stack&quot;&gt;stack&lt;/a&gt; will
&lt;a href=&quot;https://en.wikipedia.org/wiki/Stack_overflow&quot;&gt;overflow&lt;/a&gt; into other memory
regions causing … lots of problems.  Picking how much space to allocate for
the &lt;a href=&quot;https://en.wikipedia.org/wiki/Call_stack&quot;&gt;stack&lt;/a&gt; is therefore quite
important, and a problem for which I don’t (yet) have a good solution for.&lt;/p&gt;

&lt;p&gt;Since we’ve chosen not to use any system libraries for this code, we’ll need
to write our own &lt;code class=&quot;highlighter-rouge&quot;&gt;memzero&lt;/code&gt; routine so that we can start our tasks off with a
clean slate.  This &lt;code class=&quot;highlighter-rouge&quot;&gt;memzero()&lt;/code&gt; (should-be a) library function is also
pretty basic,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;    &lt;span class=&quot;nf&quot;&gt;memzero&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cnt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;    &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cp&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cnt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
		&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cp&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Much as one might expect.&lt;/p&gt;

&lt;p&gt;Incidentally, we could do this operation four times faster if we took
advantage of the fact that our memory is both word aligned and an integer
number of words.  For now, we’ll leave this as an exercise for the student
to try later.&lt;/p&gt;

&lt;p&gt;Now that we have this background under our belt, it’s time to build
our &lt;a href=&quot;https://github.com/ZipCPU/arrowzip/blob/master/sw/board/intdemo.c&quot;&gt;multi-tasking blinky&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Starting at the top, the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt;
will begin by executing a
&lt;a href=&quot;/zipcpu/2018/02/12/zbasic-intro.html&quot;&gt;bootloader&lt;/a&gt;.
&lt;a href=&quot;/zipcpu/2018/02/12/zbasic-intro.html&quot;&gt;This function&lt;/a&gt;
copies our program into memory (if necessary), and then initializes
any global variables.  Once complete, the
&lt;a href=&quot;/zipcpu/2018/02/12/zbasic-intro.html&quot;&gt;bootloader&lt;/a&gt;
will call our &lt;code class=&quot;highlighter-rouge&quot;&gt;main()&lt;/code&gt; function–giving the appearance that this is where our
program starts.  Once in &lt;code class=&quot;highlighter-rouge&quot;&gt;main()&lt;/code&gt;, we will first define all of our
tasks (i.e. contexts), as well as a &lt;code class=&quot;highlighter-rouge&quot;&gt;current&lt;/code&gt; task pointer to point
to the task that is currently active.  The tasks themselves in this simple
example consist of nothing more than the &lt;code class=&quot;highlighter-rouge&quot;&gt;task_context&lt;/code&gt; structure we defined
above containing the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Processor_register&quot;&gt;register&lt;/a&gt;
values of each running program.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;	&lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;argv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;**&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;argv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// **s
&lt;/span&gt;        &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt;        &lt;span class=&quot;n&quot;&gt;heartbeats&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;task_context&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;tasks&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NTASKS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;task_context&lt;/span&gt;    &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;current&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

        &lt;span class=&quot;n&quot;&gt;memzero&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tasks&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;task_context&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NTASKS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;I’ve also declared a &lt;code class=&quot;highlighter-rouge&quot;&gt;heartbeats&lt;/code&gt; variable as well.  We’ll use this to debug
our program and to determine if anything has gone wrong and we need to enter
into the &lt;a href=&quot;/zipcpu/2017/08/25/hw-debugging.html&quot;&gt;debugger&lt;/a&gt;.
Specifically, if ever the &lt;code class=&quot;highlighter-rouge&quot;&gt;heartbeats&lt;/code&gt; counter stops
counting, we’ll know our program is dead.&lt;/p&gt;

&lt;p&gt;There’s actually a couple ways of implementing this &lt;code class=&quot;highlighter-rouge&quot;&gt;heartbeats&lt;/code&gt; idea.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;One way, shown above, is to create a variable on the stack to hold this
value.&lt;/p&gt;

    &lt;p&gt;The first problem with this approach is that the compiler might move this
variable into a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Processor_register&quot;&gt;register&lt;/a&gt;.  When it’s in
a &lt;a href=&quot;https://en.wikipedia.org/wiki/Processor_register&quot;&gt;register&lt;/a&gt;, we’ll need
to use the &lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;’s
&lt;a href=&quot;/zipcpu/2017/08/25/hw-debugging.html&quot;&gt;debugging interface&lt;/a&gt;
to read it in order to know if the &lt;code class=&quot;highlighter-rouge&quot;&gt;heartbeats&lt;/code&gt; have ever stopped, rather
than reading this value from memory using the
&lt;a href=&quot;https://github.com/ZipCPU/dbgbus/tree/master/hexbus&quot;&gt;debugging bus&lt;/a&gt;.&lt;/p&gt;

    &lt;p&gt;There two big problems with this approach.  The first is knowing whether
&lt;code class=&quot;highlighter-rouge&quot;&gt;heatbeats&lt;/code&gt; is in a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Processor_register&quot;&gt;register&lt;/a&gt;
vs being in memory.  The second problem is knowing which
&lt;a href=&quot;https://en.wikipedia.org/wiki/Processor_register&quot;&gt;register&lt;/a&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;heartbeats&lt;/code&gt; is kept within.  Until the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; supports a &lt;a href=&quot;https://en.wikipedia.org/wiki/Debugger&quot;&gt;source-level
debugger&lt;/a&gt;, this will require
examining some (dis)assembly to see how the compiler allocated it.  You
can use &lt;code class=&quot;highlighter-rouge&quot;&gt;zip-objdump -D intdemo &amp;gt; intdemo.txt&lt;/code&gt; to examine this (dis)assembly.
Since I find myself doing this so often, there’s a &lt;code class=&quot;highlighter-rouge&quot;&gt;make&lt;/code&gt; option in the
&lt;a href=&quot;https://github.com/ZipCPU/arrowzip/blob/master/sw/board/Makefile&quot;&gt;Makefile&lt;/a&gt;
to &lt;code class=&quot;highlighter-rouge&quot;&gt;make intdemo.txt&lt;/code&gt; which does almost exactly this.  The &lt;code class=&quot;highlighter-rouge&quot;&gt;make&lt;/code&gt; option
puts some other information into &lt;code class=&quot;highlighter-rouge&quot;&gt;intdemo.txt&lt;/code&gt; as well, so feel free to try
it out yourself and see what you think.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;A second way to handle the &lt;code class=&quot;highlighter-rouge&quot;&gt;heartbeats&lt;/code&gt; value would be to declare it as a
&lt;code class=&quot;highlighter-rouge&quot;&gt;volatile unsigned&lt;/code&gt; value.  If we do that, the &lt;code class=&quot;highlighter-rouge&quot;&gt;heartbeats&lt;/code&gt; value will be
forced into &lt;a href=&quot;https://en.wikipedia.org/wiki/Call_stack&quot;&gt;local (stack) memory&lt;/a&gt;.
We can then use our &lt;a href=&quot;https://github.com/ZipCPU/dbgbus/tree/master/hexbus&quot;&gt;debugging
bus&lt;/a&gt; to read it even
while the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt; is running.&lt;/p&gt;

    &lt;p&gt;The problem is, which memory address will &lt;code class=&quot;highlighter-rouge&quot;&gt;heartbeats&lt;/code&gt; get placed into?
Typically, as long as &lt;code class=&quot;highlighter-rouge&quot;&gt;heartbeats&lt;/code&gt; is the first value declared in &lt;code class=&quot;highlighter-rouge&quot;&gt;main()&lt;/code&gt;,
it’ll always be at the same place on the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Call_stack&quot;&gt;stack&lt;/a&gt;,
but finding this place the first time might take some work.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;A third option would be to declare &lt;code class=&quot;highlighter-rouge&quot;&gt;heartbeats&lt;/code&gt; as a global variable.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;heartbeats&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;	&lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;argc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;**&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;argv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// **s
&lt;/span&gt;	&lt;span class=&quot;o&quot;&gt;//&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;code&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;follows&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Were we to do this instead, &lt;code class=&quot;highlighter-rouge&quot;&gt;wbregs&lt;/code&gt; has an option where, if given a map file,
you can read this value by name.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span class=&quot;gp&quot;&gt;% &lt;/span&gt;wbregs -m obj-zip/intdemo.map heartbeats&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;But let’s get back to &lt;a href=&quot;https://github.com/ZipCPU/arrowzip/blob/master/sw/board/intdemo.c&quot;&gt;our
program&lt;/a&gt;.
We just created memory to hold &lt;code class=&quot;highlighter-rouge&quot;&gt;NTASKS&lt;/code&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Processor_register&quot;&gt;register&lt;/a&gt;
sets (contexts).  Now let’s give them some initial values.  The most
important values to provide are the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Stack_register&quot;&gt;stack pointer&lt;/a&gt; and the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Program_counter&quot;&gt;program counter&lt;/a&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span class=&quot;c1&quot;&gt;// Define a void function pointer type
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;    &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;voidfn&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)();&lt;/span&gt;	&lt;span class=&quot;c1&quot;&gt;//*
&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// ...
&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;	&lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;argv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;**&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;argv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// **s
&lt;/span&gt;	&lt;span class=&quot;c1&quot;&gt;// ...
&lt;/span&gt;	&lt;span class=&quot;c1&quot;&gt;// returning back to our main() function ...
&lt;/span&gt;	&lt;span class=&quot;c1&quot;&gt;//
&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;// Give each task a stack, and a program counter
&lt;/span&gt;	&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NTASKS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
		&lt;span class=&quot;c1&quot;&gt;// Allocate 256-bytes of local memory for each task
&lt;/span&gt;		&lt;span class=&quot;n&quot;&gt;tasks&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;13&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;new_stack_ptr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;256&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

	&lt;span class=&quot;c1&quot;&gt;// Set the &quot;Program Counter&quot; for each context, giving each
&lt;/span&gt;	&lt;span class=&quot;c1&quot;&gt;// task a function to start processing on entry
&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;tasks&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;15&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;voidfn&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;one_hz&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;tasks&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;15&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;voidfn&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;two_hz&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;tasks&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;15&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;voidfn&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;three_hz&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;tasks&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;15&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;voidfn&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;five_hz&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Once we’ve done all that, we’ve almost finished our startup processing.  There
are only a couple steps left.&lt;/p&gt;

&lt;p&gt;The first is to choose to start the first task, and then to load the user
&lt;a href=&quot;https://en.wikipedia.org/wiki/Processor_register&quot;&gt;register&lt;/a&gt;s
from that task pointer.  The
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; toolchain provides a
&lt;code class=&quot;highlighter-rouge&quot;&gt;zip_restore_context()&lt;/code&gt; function to make things easier.  This function expands
into some code to copy the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Processor_register&quot;&gt;register&lt;/a&gt;
values from the address given, in this case a pointer to &lt;code class=&quot;highlighter-rouge&quot;&gt;current-&amp;gt;r[0]&lt;/code&gt;,
into the user
&lt;a href=&quot;https://en.wikipedia.org/wiki/Processor_register&quot;&gt;register&lt;/a&gt;
set, &lt;code class=&quot;highlighter-rouge&quot;&gt;uR0&lt;/code&gt; through &lt;code class=&quot;highlighter-rouge&quot;&gt;uPC&lt;/code&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;	&lt;span class=&quot;n&quot;&gt;current&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tasks&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;zip_restore_context&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;current&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Once done, we can then issue a “return-to-usermode” instruction, assembly
&lt;code class=&quot;highlighter-rouge&quot;&gt;RTU&lt;/code&gt; or &lt;code class=&quot;highlighter-rouge&quot;&gt;zip_rtu()&lt;/code&gt; from C, to switch from supervisor to user mode.&lt;/p&gt;

&lt;p&gt;Only, we can’t do that just yet.
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
programs only exit user mode on
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interrupt&quot;&gt;interrupt&lt;/a&gt;s,
exceptions (i.e. faults), and traps (system calls).  Since our
program shouldn’t be creating any exceptions (if it works), and since
we’re not issuing any system calls, we’ll need another way to grab control
back from userspace: &lt;a href=&quot;https://en.wikipedia.org/wiki/Interrupt&quot;&gt;interrupts&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Let’s therefore set our
&lt;a href=&quot;/zipcpu/2018/04/17/ziptimer.html&quot;&gt;timer&lt;/a&gt; to
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interrupt&quot;&gt;interrupt&lt;/a&gt;
us every millisecond.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;	&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_bustimer&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mh&quot;&gt;0x80000000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CLKFREQHZ&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;// Enable interrupts, and our interrupt in particular
&lt;/span&gt;	&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_buspic&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x80008000&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;BUSPIC_BUSTIMER&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;BUSPIC_BUSTIMER&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;16&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

	&lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;It’s now time to write out main logic loop.  We’ll start out by clearing
every other LED, and incrementing our &lt;code class=&quot;highlighter-rouge&quot;&gt;heartbeats&lt;/code&gt; counter.  We can then
run the user task.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;               &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;     &lt;span class=&quot;n&quot;&gt;picv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

                &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_spio&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0xaa00&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;heartbeats&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

		&lt;span class=&quot;c1&quot;&gt;// Run the user task, via a &quot;return-to-userspace&quot; insn
&lt;/span&gt;                &lt;span class=&quot;n&quot;&gt;zip_rtu&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Once we issue the &lt;code class=&quot;highlighter-rouge&quot;&gt;RTU&lt;/code&gt; instruction, the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
will switch to using the user-register set.  Since everything is captured by
this &lt;em&gt;context&lt;/em&gt;, switching to this user-register set will feel like switching
which program is running.&lt;/p&gt;

&lt;p&gt;Unlike many other
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;s
which have a single register set, the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
maintains the supervisor’s context while running in user mode.  That means
that the supervisor
&lt;a href=&quot;https://en.wikipedia.org/wiki/Program_counter&quot;&gt;program counter&lt;/a&gt;,
&lt;a href=&quot;https://en.wikipedia.org/wiki/Stack_register&quot;&gt;stack pointer&lt;/a&gt;,
and indeed all of the &lt;a href=&quot;/zipcpu/2018/01/01/zipcpu-isa.html&quot;&gt;supervisor
registers&lt;/a&gt; are
maintained until the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt;
returns to supervisor mode from user mode.  What that means is that, on an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interrupt&quot;&gt;interrupt&lt;/a&gt;,
the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt;
will continue running this supervisor function where it left off.&lt;/p&gt;

&lt;p&gt;The more traditional approach would be for the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;
to suddenly jump to an &lt;em&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Interrupt_handler&quot;&gt;interrupt service
routine&lt;/a&gt;&lt;/em&gt;.  The address
of such a &lt;a href=&quot;https://en.wikipedia.org/wiki/Interrupt_handler&quot;&gt;routine&lt;/a&gt; would be
kept in a &lt;a href=&quot;https://en.wikipedia.org/wiki/Interrupt_vector_table&quot;&gt;special memory
location&lt;/a&gt; that the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt; could
look up and start from when the context switch needed to take place.&lt;/p&gt;

&lt;p&gt;By just switching register sets, the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; is
kind of unique in this way.  I personally find it easier
to write multi-tasking programs as a result.&lt;/p&gt;

&lt;p&gt;On our return, the first thing we’ll do is set those LEDs we just cleared–every
other LED is now set to indicate we are in supervisor mode.  I’ve found this to
be a really useful way of debugging what goes wrong when things don’t work: if
these LEDs are on, the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt;
is in supervisor mode, else it is in user mode.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;		&lt;span class=&quot;c1&quot;&gt;// Turn on LED&#39;s 1, 3, 5, 7, ...
&lt;/span&gt;                &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_spio&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0xaaaa&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;We’ll turn these off again before we leave supervisor mode.&lt;/p&gt;

&lt;p&gt;Our next step is to check the user-mode &lt;a href=&quot;https://en.wikipedia.org/wiki/Status_register&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;CC&lt;/code&gt;
register&lt;/a&gt; to see if we left user
mode as a result of some form of exception.  If so, we’ll call a &lt;code class=&quot;highlighter-rouge&quot;&gt;panic()&lt;/code&gt;
function–more on that later.  It’s important to enter the &lt;code class=&quot;highlighter-rouge&quot;&gt;panic()&lt;/code&gt; function
as soon as possible once we detect an exception, so that we can debug anything
that went wrong with as little change to the system as possible.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;                &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;zip_ucc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CC_EXCEPTION&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
                        &lt;span class=&quot;n&quot;&gt;panic&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;At long last, it’s now finally time to check the &lt;a href=&quot;/zipcpu/2019/04/02/icontrol.html&quot;&gt;interrupt
controller&lt;/a&gt;
to see if an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interrupt&quot;&gt;interrupt&lt;/a&gt;
has taken place.  If so, we’ll increment the &lt;code class=&quot;highlighter-rouge&quot;&gt;milliseconds&lt;/code&gt; counter
that all of the tasks are using.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;		&lt;span class=&quot;c1&quot;&gt;// Read the current state from the interrupt controller
&lt;/span&gt;                &lt;span class=&quot;n&quot;&gt;picv&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_buspic&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

		&lt;span class=&quot;c1&quot;&gt;// Check if the timer has triggered an interrupt
&lt;/span&gt;                &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;picv&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;BUSPIC_BUSTIMER&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                        &lt;span class=&quot;c1&quot;&gt;// Timer interrupt triggered
&lt;/span&gt;
			&lt;span class=&quot;c1&quot;&gt;// Increment our millisecond counter
&lt;/span&gt;                        &lt;span class=&quot;n&quot;&gt;milliseconds&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;milliseconds&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
                        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;milliseconds&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
                                &lt;span class=&quot;n&quot;&gt;milliseconds&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;We’ll then want to acknowledge this
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interrupt&quot;&gt;interrupt&lt;/a&gt;,
so we don’t get interrupted again until the next millisecond
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interrupt&quot;&gt;interrupt&lt;/a&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;                	&lt;span class=&quot;c1&quot;&gt;// Reset the interrupt
&lt;/span&gt;                	&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_buspic&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;BUSPIC_BUSTIMER&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
                &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Our last step is to &lt;a href=&quot;https://en.wikipedia.org/wiki/Context_switch&quot;&gt;swap tasks&lt;/a&gt;.
This is done in three parts.  The first part copies the
&lt;a href=&quot;/zipcpu/2018/01/01/zipcpu-isa.html&quot;&gt;user mode registers&lt;/a&gt;
into the &lt;code class=&quot;highlighter-rouge&quot;&gt;task_context&lt;/code&gt; memory.  In this case, since we’ve kept a
pointer to our &lt;code class=&quot;highlighter-rouge&quot;&gt;current&lt;/code&gt; task context this is fairly straightforward.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;                &lt;span class=&quot;c1&quot;&gt;// Swap tasks
&lt;/span&gt;                &lt;span class=&quot;n&quot;&gt;zip_save_context&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;current&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The second step is to decide which task to call next.  This is often called
“CPU scheduling” or “task scheduling”, and many articles have been written
on this topic.  We’ll just keep it simple here and move to the “next” task in
our list.  In hind sight, it might’ve been easier to maintain a current
&lt;code class=&quot;highlighter-rouge&quot;&gt;task_id&lt;/code&gt; index as well, but I’ll leave that to you to do.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;                &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NTASKS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;current&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tasks&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                                &lt;span class=&quot;n&quot;&gt;current&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tasks&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NTASKS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;?&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
                                &lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
                        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
                &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The final step in a
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Context_switch&quot;&gt;context switch&lt;/a&gt;
is to restore the registers from the new “current” task
back into the user register set.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;                &lt;span class=&quot;n&quot;&gt;zip_restore_context&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;current&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Context_switch&quot;&gt;Task swapping&lt;/a&gt; like this is more
often an assembly function, and so these two builtin-function calls simply
implement what would be those assembly instructions.  They are easily
identifiable from the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
disassembly since these are the only instructions that will reference the
&lt;a href=&quot;/zipcpu/2018/01/01/zipcpu-isa.html&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;uR&lt;/code&gt; register set&lt;/a&gt;.  If
you are really interested in actually seeing their
definition, you can &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/752bcc9485609f1f094100719262a7c2d386d6b7/sw/gcc-zippatch.patch&quot;&gt;find it in the GCC ZipCPU
patchset&lt;/a&gt;.  &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/752bcc9485609f1f094100719262a7c2d386d6b7/sw/gcc-zippatch.patch#L10099-L10148&quot;&gt;Here it is for saving the
context&lt;/a&gt;, and &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/752bcc9485609f1f094100719262a7c2d386d6b7/sw/gcc-zippatch.patch#L10149-L10193&quot;&gt;here again for
restoring the context&lt;/a&gt;.
The function basically works by reading four registers from either
memory or the user register set, then writing them to the user register set
or memory.  Indeed, the function is little more than a memory copy.&lt;/p&gt;

&lt;p&gt;That leaves us with only one loose end to return to: the &lt;code class=&quot;highlighter-rouge&quot;&gt;panic()&lt;/code&gt; function.&lt;/p&gt;

&lt;p&gt;The purpose of this function is just to tell us that something has gone
wrong, and we need to do some debugging. It also helps us start that
process by helping us identify which problem has taken place.  I mean,
we’re writing a blinky function therefore it should be obvious if there’s
a problem–the LEDs won’t blink like they should.  But how to start debugging
next?&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;We’ve chosen to set certain LEDs to indicate we are in supervisor mode
(interrupts disabled), and others to indicate we are in user mode (interrupts
enabled).&lt;/p&gt;

    &lt;p&gt;This supervisor mode indicator LEDs should blink so fast that they appear
to be lit dimly.  If they ever turn off, or start shining brightly,
then we can therefore identify which mode we were in when the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt; stopped.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The purpose of the &lt;code class=&quot;highlighter-rouge&quot;&gt;panic()&lt;/code&gt; function is to help us diagnose what happened
to a broken subtask.  In this case, if we just stop the LEDs from blinking,
we might not be able to tell the difference from a CPU freeze above.&lt;/p&gt;

    &lt;p&gt;Therefore we’ll blink all of our LEDs, either all on or all off together,
to indicate a user exception took place.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;This particular implementation of &lt;code class=&quot;highlighter-rouge&quot;&gt;panic()&lt;/code&gt; uses a &lt;a href=&quot;https://github.com/ZipCPU/arrowzip/blob/195b77dc144d6ed7d4280f506c35b2204f13908c/rtl/arrowzip/main.v#L888-L894&quot;&gt;system power-up
counter&lt;/a&gt;.
This counter increases on every system clock, starting at power up, until
the top bit is set.  Once the top bit is set, the power up counter keeps
that bit set and becomes a rolling 31-bit counter with the other bits.&lt;/p&gt;

&lt;p&gt;We can grab bit 28 of this counter as an indication that we need to change
the LEDs.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;    &lt;span class=&quot;nf&quot;&gt;panic&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;     &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_pwrcount&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;28&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
			&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_spio&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x0ffff&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;
			&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_spio&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x0ff00&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;While we could’ve used the
&lt;a href=&quot;/zipcpu/2018/04/17/ziptimer.html&quot;&gt;timer&lt;/a&gt; for this,
understand that we are in a &lt;code class=&quot;highlighter-rouge&quot;&gt;panic()&lt;/code&gt; situation.  We want to leave the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt; state as un-changed as possible
so that we can diagnose whatever fault took place.  In particular, we’ll want
to leave the user register set untouched.  We also don’t know if the
fault was associated with interrupt processing or task swapping or something
else.  For all of these reasons, this code is has been kept as simple as
possible.&lt;/p&gt;

&lt;p&gt;Another thing we could’ve done in this &lt;code class=&quot;highlighter-rouge&quot;&gt;panic()&lt;/code&gt; routine would’ve been to
issue a simulation &lt;code class=&quot;highlighter-rouge&quot;&gt;NHALT&lt;/code&gt; (hardware NOOP) instruction to halt any simulator
at the fault itself.  By turning tracing on and then running the simulator
like this, it’s fairly easy to figure out what went wrong.  (Easy, perhaps,
but still pretty intense–examining a trace is not trivial.)  Alternatively,
we could’ve triggered any CPU-focused &lt;a href=&quot;/blog/2017/07/08/getting-started-with-wbscope.html&quot;&gt;Wishbone
Scope&lt;/a&gt;.
This is typically how I debug the CPU if a bug makes it to hardware and the
user register set doesn’t tell me enough to know the cause of any fault.&lt;/p&gt;

&lt;h2 id=&quot;video&quot;&gt;Video&lt;/h2&gt;

&lt;p&gt;Want to see how we did?  Check out the video below.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 12. The LED&#39;s blink!  Multitasking at work&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;video width=&quot;480&quot; height=&quot;360&quot; controls=&quot;&quot;&gt;&lt;source src=&quot;/img/multithreaded-blinky/iled-video.mp4&quot; type=&quot;video/mp4&quot; /&gt;&lt;/video&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;In this video you’ll see a MAX-1000 board with 8-LED’s.  Half of the
LEDs are toggling at rates of 1Hz, 2Hz, 3Hz, and 5Hz.  These are the far left
LED, and every other LED to the right.  The other four LEDs are shining dimly,
indicating that the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt;
truly is handling
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interrupt&quot;&gt;interrupt&lt;/a&gt;s
and
&lt;a href=&quot;https://en.wikipedia.org/wiki/Context_switch&quot;&gt;swapping tasks&lt;/a&gt;
as desired.&lt;/p&gt;

&lt;h2 id=&quot;conclusions&quot;&gt;Conclusions&lt;/h2&gt;

&lt;p&gt;Since we’ve already covered both &lt;a href=&quot;/blog/2017/05/19/blinky.html&quot;&gt;how to make an LED blink from
Verilog&lt;/a&gt;,
&lt;a href=&quot;/zipcpu/2019/02/09/cpu-blinky.html&quot;&gt;as well as from C&lt;/a&gt;,
it only made sense that we’d discuss how to blink an LED in some
more advanced fashions–such as by using an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interrupt&quot;&gt;interrupt&lt;/a&gt;
or from a multi-tasking program.&lt;/p&gt;

&lt;p&gt;While blinking an LED might seem like an exceptionally trivial task, let’s
consider what we’ve learned: We learned how easy it was to blink an LED
from Verilog.  Even synchronizing multiple blinking LEDs to within a clock
period was fairly easy.  Blinking an LED on a CPU has the advantage that
it doesn’t typically take (much) more logic resources–but only after you’ve
already paid for the CPU, it’s boot code, it’s bootloader, memory, the
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;system bus&lt;/a&gt; and the
&lt;a href=&quot;/blog/2019/07/17/crossbar.html&quot;&gt;interconnect/crossbar&lt;/a&gt;
used to hold everything together.&lt;/p&gt;

&lt;p&gt;Of course, this would be more valuable if we were doing something more than
just blinking an LED.  Still, we’ve demonstrated how to build an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interrupt&quot;&gt;interrupt&lt;/a&gt;
driven task, as well as how to split the CPU’s time across
multiple independent task contexts,
by using an &lt;a href=&quot;https://en.wikipedia.org/wiki/Interrupt&quot;&gt;interrupt&lt;/a&gt; to tell us
when to
&lt;a href=&quot;https://en.wikipedia.org/wiki/Context_switch&quot;&gt;switch contexts&lt;/a&gt;.
Both of these capabilities are very powerful and can be used outside
of a simple LED context.&lt;/p&gt;

&lt;p&gt;Where the CPU starts to have an advantage over the FPGA fabric is where
you need something to perform complex sequencing operations–such as
performing a complicated startup script, or performing a complex script
periodically.  Depending on the complexity of the task, adding it to what
a CPU is already doing might be cheaper than performing it in the fabric
of the FPGA.  At the same time, adding a CPU to an FPGA just to blink an
LED is truly overkill.&lt;/p&gt;
&lt;hr /&gt;&lt;p&gt;&lt;em&gt;For my thoughts are not your thoughts, neither are your ways my ways, saith the LORD.  For as the heavens are higher than the earth, so are my ways higher than your ways, and my thoughts than your thoughts.  (Is 55:8-9)&lt;/em&gt;</description>
        <pubDate>Sat, 23 Nov 2019 00:00:00 -0500</pubDate>
        <link>https://zipcpu.com/zipcpu/2019/11/23/multithreaded-blinky.html</link>
        <guid isPermaLink="true">https://zipcpu.com/zipcpu/2019/11/23/multithreaded-blinky.html</guid>
        
        
        <category>zipcpu</category>
        
      </item>
    
      <item>
        <title>Formally Verifying a General Purpose Ultra-Micro Controller</title>
        <description>&lt;p&gt;At long last, I have formally verified a &lt;a href=&quot;https://opencores.org/project,wbddr3&quot;&gt;DDR3 SDRAM
controller&lt;/a&gt;.  Sadly,
I haven’t yet had the time to verify its operation on real hardware.
Worse, the I/O isn’t quite there yet so I don’t expect it will work … yet.&lt;/p&gt;

&lt;p&gt;For those who don’t know the story, I built a
&lt;a href=&quot;https://opencores.org/project,wbddr3&quot;&gt;DDR3 SDRAM controller&lt;/a&gt; years ago.
These were back in my stubborn days, before I was ever willing to use any
vendor modules.  I then built a
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;Wishbone&lt;/a&gt;
controlled
&lt;a href=&quot;https://opencores.org/project,wbddr3&quot;&gt;DDR3 SDRAM controller&lt;/a&gt;,
and attempted to instantiate it on my &lt;a href=&quot;https://store.digilentinc.com/arty-a7-artix-7-fpga-development-board-for-makers-and-hobbyists&quot;&gt;Arty
board&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Let’s just cut the story short: it wasn’t a successful project.&lt;/p&gt;

&lt;p&gt;There’s a world of difference between the logic used to drive the &lt;a href=&quot;https://en.wikipedia.org/wiki/DDR3_SDRAM&quot;&gt;DDR3
SDRAM&lt;/a&gt; and the actual wires
and protocol required by the &lt;a href=&quot;https://en.wikipedia.org/wiki/DDR3_SDRAM&quot;&gt;DDR3
SDRAM&lt;/a&gt;.  That world of difference
lies in the byte-strobe signals, but that’s a story for another day.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 1. A XuLA2-LX25 Board from Xess&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/XuLA2.png&quot; alt=&quot;&quot; width=&quot;250&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Prior to this &lt;a href=&quot;https://opencores.org/project,wbddr3&quot;&gt;DDR3 SDRAM
controller&lt;/a&gt;, I had built an &lt;a href=&quot;https://github.com/ZipCPU/xulalx25soc/blob/master/rtl/wbsdram.v&quot;&gt;SDRAM
controller&lt;/a&gt;
for my XuLA2 LX25 board.  It wasn’t all that had to do, and so I thought I would
try my hand at a &lt;a href=&quot;https://opencores.org/project/wbddr3&quot;&gt;DDR3 SDRAM controller&lt;/a&gt;.
Since this was a second generation &lt;a href=&quot;https://en.wikipedia.org/wiki/Synchronous_dynamic_random-access_memory&quot;&gt;Dynamic RAM
(DRAM)&lt;/a&gt;
controller for me, I came into this
project knowing a thing or two regarding what had worked before and what
hadn’t.  (Or at least, so I thought.)  I also came into the project expecting
to run at a 200MHz system clock.  Then it was a 100MHz clock, then an 80MHz
clock, then … my motivation fell apart.  This was to be expected in so many
ways–especially since the project was never funded in the first place and it
cost me several months of work.&lt;/p&gt;

&lt;p&gt;Recently, however, I’ve had the opportunity to dig up the design again.
Actually, I’ve had the opportunity to dig into both the
&lt;a href=&quot;https://github.com/ZipCPU/zipstormmx/blob/master/rtl/wbsdram.v&quot;&gt;SDRAM design&lt;/a&gt;
&lt;em&gt;and&lt;/em&gt; the &lt;a href=&quot;https://opencores.org/project/wbddr3&quot;&gt;DDR3 SDRAM design&lt;/a&gt;.  I modified
the SDRAM controller to handle &lt;a href=&quot;http://www.issi.com/WW/pdf/42-45S16100H.pdf&quot;&gt;ISSI’s SDRAM
chip&lt;/a&gt;, as found on the &lt;a href=&quot;https://www.tindie.com/products/Folknology/blackice-mx/&quot;&gt;new
IceCore board from
myStorm&lt;/a&gt; as well as
started working to port my controller to the &lt;a href=&quot;https://www.micron.com/products/dram/ddr3-sdram/part-catalog/mt41k64m16tw-107&quot;&gt;DDR3 SDRAM
chip&lt;/a&gt;
found on Lattice’s &lt;a href=&quot;https://www.latticesemi.com/en/Products/DevelopmentBoardsAndKits/ECP5VersaDevelopmentKit&quot;&gt;ECP5 Versa Board&lt;/a&gt;.  That is, until my project
funding ran out again.&lt;/p&gt;

&lt;p&gt;One of the big things that has changed between my early work with
&lt;a href=&quot;https://en.wikipedia.org/wiki/Synchronous_dynamic_random-access_memory&quot;&gt;DRAM&lt;/a&gt;
controllers and now is that &lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;I’ve discovered formal
verification&lt;/a&gt;.  Neither
of my original cores were formally verified initially.  Indeed, one of my
early formal verification stories is of trying to verify the &lt;a href=&quot;https://github.com/ZipCPU/xulalx25soc/blob/master/rtl/wbsdram.v&quot;&gt;(non-DDR) SDRAM
controller&lt;/a&gt;
and discovering a corner case where the controller might’ve accessed
the wrong piece of memory.&lt;/p&gt;

&lt;p&gt;That would’ve been &lt;a href=&quot;/blog/2019/11/14/sdspi.html&quot;&gt;hard to
debug&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Today’s discussion, however, focuses on a piece of logic found within each
controller–something I’m going to call an ultra-micro controller.&lt;/p&gt;

&lt;h2 id=&quot;the-purpose-of-the-microcontroller&quot;&gt;The Purpose of the MicroController&lt;/h2&gt;

&lt;p&gt;There are actually two ultra-micro controller’s found within each of the updated
&lt;a href=&quot;https://en.wikipedia.org/wiki/Synchronous_dynamic_random-access_memory&quot;&gt;DRAM&lt;/a&gt;
controller designs.  One of them is responsible for the &lt;a href=&quot;https://github.com/ZipCPU/zipstormmx/blob/e4cb3e6f3bc3ac5831925b28116cb19b4ed09e8d/rtl/wbsdram.v#L578-L607&quot;&gt;reset logic
sequencing&lt;/a&gt;, and the other
for the &lt;a href=&quot;https://github.com/ZipCPU/zipstormmx/blob/e4cb3e6f3bc3ac5831925b28116cb19b4ed09e8d/rtl/wbsdram.v#L622-L667&quot;&gt;refresh logic&lt;/a&gt;.
But I’m getting ahead of myself.  Let’s start with the
basic question, what is a “MicroController”?&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Microcontroller&quot;&gt;Wikipedia currently defines a
MicroController&lt;/a&gt; as&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;a small computer on a single integrated circuit on a single metal-oxide
semiconductor (MOS) integrated circuit chip. In modern terminology,
it is similar to, but less sophisticated than, a system on a chip (SoC);
an SoC may include a microcontroller as one of its components. A
microcontroller contains one or more CPUs (processor cores) along with
memory and programmable input/output peripherals. …
(Yes, Wikipedia’s definition even changed while I was writing this!)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;This is way more sophisticated than what I am talking about today.  That’s
why I’m going to use the term “ultra-micro controller”
today, I’m not talking about anything that would rank as I high as a full-blown
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;
or even anything with external memory.  Instead, I’m referring to something
a little more sophisticated than a &lt;a href=&quot;https://en.wikipedia.org/wiki/Finite-state_machine&quot;&gt;finite state
machine&lt;/a&gt;, but not
nearly as sophisticated as a full
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;.  The &lt;a href=&quot;https://github.com/ZipCPU/zipstormmx/blob/master/rtl/genuctrl.v&quot;&gt;ultra-micro
controller&lt;/a&gt;
I’m talking about today does nothing but follow a simple fixed script, setting
a single register along the way.  This script is the unique feature that
separates it from a more traditional
&lt;a href=&quot;https://en.wikipedia.org/wiki/Finite-state_machine&quot;&gt;finite state machine&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;I’m going to use this in two contexts initially, and probably many others later.
These are the reset sequence and the refresh sequence of my
&lt;a href=&quot;https://en.wikipedia.org/wiki/Synchronous_dynamic_random-access_memory&quot;&gt;DRAM&lt;/a&gt;
controllers.
Here’s the basic idea, as applied to the reset sequence: when you read through
the data sheet for a memory chip, you’ll discover that there’s a very specific
sequence of events that needs to take place from power up to the first memory
access.  This sequence includes timing relative signals given to the core.
For example, many
&lt;a href=&quot;https://en.wikipedia.org/wiki/Synchronous_dynamic_random-access_memory&quot;&gt;SDRAM&lt;/a&gt;
chips require a PRECHARGE-ALL common (initializes all of the internal memory
banks to idle), followed by a REFRESH command and then finally a SETMODE
command to set the settings within the chip, telling the chip how the
controller will interact with it.  Only after all three of these commands have
been issued is the memory ready to use.&lt;/p&gt;

&lt;p&gt;There’s one other key detail, and that is that those three startup commands,
PRECHARGE, REFRESH, and SETMODE, all have particular timing relationships
between them.  For example, there may need to be an adjustable number of idle
cycles between the PRECHARGE command and the following REFRESH command
and so forth.&lt;/p&gt;

&lt;p&gt;That’s one of the two &lt;a href=&quot;https://github.com/ZipCPU/zipstormmx/blob/master/rtl/genuctrl.v&quot;&gt;ultra-micro
controllers&lt;/a&gt;
I needed for these two
&lt;a href=&quot;https://en.wikipedia.org/wiki/Synchronous_dynamic_random-access_memory&quot;&gt;DRAM&lt;/a&gt;
controllers.&lt;/p&gt;

&lt;p&gt;The other one I’m using to handle the refresh logic.  If you aren’t familiar
with
&lt;a href=&quot;https://en.wikipedia.org/wiki/Synchronous_dynamic_random-access_memory&quot;&gt;DRAM&lt;/a&gt;,
then you need to understand first that it’s built out of capacitors.  If the
capacitor is charged, that particular bit of memory is a one else its a zero.
Building memory out of capacitors makes it possible to build memories with
very low area and low power.  The problem with using capacitors to hold memory
is that the charge within any capacitor will decay over time.  It
leaks.  If each capacitor is not re-charged periodically, they will return
to zeros, losing any data you might have stored within them.  To keep this from
happening, the controller needs to follow an internal schedule of commands
within it–periodically pulling the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Synchronous_dynamic_random-access_memory&quot;&gt;DRAM&lt;/a&gt;
off line, idling all the RAM banks, issuing a REFRESH command, and
then putting them back on line.&lt;/p&gt;

&lt;p&gt;This is all well and good, but my problem was associated with the giant
process it took to calculate the memory commands.&lt;/p&gt;

&lt;p&gt;To see how bad it got, here’s a look at what my initial draft looked like:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;&lt;span class=&quot;k&quot;&gt;always&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;posedge&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i_clk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;in_reset_sequence&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;begin&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;// The reset state machine
&lt;/span&gt;	&lt;span class=&quot;c1&quot;&gt;//
&lt;/span&gt;	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;reset_condition_one&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;o_cmd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SETMODE&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;reset_condition_two&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;o_cmd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PRECHARGE_ALL&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;reset_condition_three&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;o_cmd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;REFRESH&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;o_cmd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NOOP&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;begin&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;// ...
&lt;/span&gt;	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;need_refresh&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;begin&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;first_condition&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
			&lt;span class=&quot;c1&quot;&gt;// Wait since the last precharge
&lt;/span&gt;			&lt;span class=&quot;n&quot;&gt;o_cmd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NOOP&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;second_condition&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
			&lt;span class=&quot;c1&quot;&gt;// Precharge all banks
&lt;/span&gt;			&lt;span class=&quot;n&quot;&gt;o_cmd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PRECHARGE&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;third_condition&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
			&lt;span class=&quot;c1&quot;&gt;// Wait for all banks to become idle
&lt;/span&gt;			&lt;span class=&quot;n&quot;&gt;o_cmd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NOOP&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Wait
&lt;/span&gt;		&lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fourth_condition&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
			&lt;span class=&quot;c1&quot;&gt;// Issue the refresh command
&lt;/span&gt;			&lt;span class=&quot;n&quot;&gt;o_cmd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;REFRESH&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//
&lt;/span&gt;		&lt;span class=&quot;c1&quot;&gt;// ...
&lt;/span&gt;	&lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;begin&lt;/span&gt;
		&lt;span class=&quot;c1&quot;&gt;// Another large state machine
&lt;/span&gt;		&lt;span class=&quot;c1&quot;&gt;// To handle read and write commands
&lt;/span&gt;	&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The problem with this giant always block was that the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Finite-state_machine&quot;&gt;state machine&lt;/a&gt;
it generated was so complex it struggled to pass timing at any decent clock
speed.  Placing three separate
&lt;a href=&quot;https://en.wikipedia.org/wiki/Finite-state_machine&quot;&gt;state machines&lt;/a&gt;
into this same logic block, one for reset, one for refresh, and one for reading
and writing the RAM was … just too much for the hardware to handle in the
time allotted to it.&lt;/p&gt;

&lt;p&gt;I needed to simplify my design.  I needed to pipeline some of this logic.
(Okay, &lt;a href=&quot;/zipcpu.com/zipcpu/2019/03/28/return-decoding.html&quot;&gt;switching to a
proper&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Finite-state_machine&quot;&gt;FSM state variable&lt;/a&gt;
would’ve helped some as well.)&lt;/p&gt;

&lt;p&gt;Eventually, I decided that I should separate this &lt;em&gt;maintenance logic&lt;/em&gt;,
that’s the word I’m using for both reset and refresh logic, from the rest of
this giant logic block.  Along the way I noticed that all of the
maintenance logic was independent of any actual bus requests.  I could
run it a clock ahead of when it actually needed to be used.  In other words, I
could pre-calculate maintenance commands before they would be used and so
simplify things.  For example, I could have a reset logic block,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;&lt;span class=&quot;c1&quot;&gt;// The reset state machine
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;always&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;posedge&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i_clk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;reset_condition_one&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;reset_cmd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SETMODE&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;reset_condition_two&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;reset_cmd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PRECHARGE_ALL&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;reset_condition_three&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;reset_cmd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;REFRESH&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;reset_cmd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NOOP&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;together with a separate and independent block to calculate the refresh
command sequence,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;&lt;span class=&quot;k&quot;&gt;always&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;posedge&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i_clk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;first_refresh_condition&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;// Wait since the last precharge
&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;refresh_cmd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NOOP&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;second_refresh_condition&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;// Precharge all banks
&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;refresh_cmd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PRECHARGE&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;third_refresh_condition&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;// Wait for all banks to become idle
&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;refresh_cmd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NOOP&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Wait
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fourth_refresh_condition&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;// Issue the refresh command
&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;refresh_cmd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;REFRESH&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;//&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;I could then &lt;a href=&quot;https://github.com/ZipCPU/zipstormmx/blob/e4cb3e6f3bc3ac5831925b28116cb19b4ed09e8d/rtl/wbsdram.v#L669-L689&quot;&gt;combine these two logic sequences together&lt;/a&gt;,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;&lt;span class=&quot;k&quot;&gt;always&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;posedge&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i_clk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;reset_logic&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;maintenance_cmd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;reset_cmd&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;maintenance_cmd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;refresh_cmd&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Why would I do all of this?  To simplify the giant always block, and to
&lt;a href=&quot;http://zipcpu.com/blog/2017/09/18/clocks-for-sw-engineers.html&quot;&gt;maintain a high clock
speed&lt;/a&gt;.  Now,
instead of having multiple separate logic checks within one giant always block,
I can instead &lt;a href=&quot;https://github.com/ZipCPU/zipstormmx/blob/e4cb3e6f3bc3ac5831925b28116cb19b4ed09e8d/rtl/wbsdram.v#L366-L387&quot;&gt;just check for the flag
&lt;code class=&quot;highlighter-rouge&quot;&gt;maintenance_mode&lt;/code&gt;&lt;/a&gt;
which would indicate I wanted to issue either a command from the reset sequence
or the refresh sequence.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;&lt;span class=&quot;k&quot;&gt;always&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;posedge&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i_clk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;maintenance_mode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;begin&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;// Enter here during either reset or
&lt;/span&gt;	&lt;span class=&quot;c1&quot;&gt;// refresh
&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;o_cmd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;maintenance_cmd&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;begin&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;// ...
&lt;/span&gt;	&lt;span class=&quot;c1&quot;&gt;// The large read/write state machine to read from memory
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This greatly simplified the logic, but I now needed special
&lt;a href=&quot;https://en.wikipedia.org/wiki/Finite-state_machine&quot;&gt;state machines&lt;/a&gt;
for both reset and refresh sequences.&lt;/p&gt;

&lt;p&gt;To make this work, I just wanted a &lt;a href=&quot;https://github.com/ZipCPU/zipstormmx/blob/master/rtl/genuctrl.v&quot;&gt;simple
core&lt;/a&gt;
that would do nothing but walk through the various reset or refresh
commands in the simplest logic possible.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: left&quot;&gt;&lt;caption&gt;Fig 2. A Three-Stage Pipeline&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/genuctrl/pipeline.svg&quot; alt=&quot;&quot; width=&quot;360&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Hence the need for this ultra-micro controller.&lt;/p&gt;

&lt;p&gt;The &lt;a href=&quot;https://github.com/ZipCPU/zipstormmx/blob/master/rtl/genuctrl.v&quot;&gt;microncontroller
itself&lt;/a&gt;
worked off of a very basic 3-stage pipeline, as shown in Fig. 2.
First it would calculate an address.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;&lt;span class=&quot;k&quot;&gt;always&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;posedge&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i_clk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;r_addr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r_addr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;It would then read a command from that position in the command sequence.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;&lt;span class=&quot;k&quot;&gt;always&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;posedge&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i_clk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;r_cmd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;command_memory&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r_addr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;endcase&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Finally, it would act upon that command, setting internal registers.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;&lt;span class=&quot;k&quot;&gt;always&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;posedge&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i_clk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;begin&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;in_refresh&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r_cmd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;in_refresh&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;refresh_cmd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r_cmd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;stall_bus&lt;/span&gt;   &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r_cmd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;// ... and so on
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;endcase&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Well, … not quite.  Often the startup or refresh sequence would require delays
between particular states.  Let’s dig into that more in a moment.&lt;/p&gt;

&lt;p&gt;For now, notice two things.  First, this approach drastically simplified
my processing.  Second, getting this core to pass
&lt;a href=&quot;/blog/2018/03/10/induction-exercise.html&quot;&gt;induction&lt;/a&gt;
requires a little bit of a trick–I’ll share that in a moment.&lt;/p&gt;

&lt;p&gt;Indeed, if it weren’t for the neat trick required to pass
&lt;a href=&quot;/blog/2018/03/10/induction-exercise.html&quot;&gt;induction&lt;/a&gt;,
I wouldn’t be writing this article.  The &lt;a href=&quot;https://github.com/ZipCPU/zipstormmx/blob/master/rtl/genuctrl.v&quot;&gt;core
itself&lt;/a&gt;
is embarrassingly simple.&lt;/p&gt;

&lt;h2 id=&quot;adding-a-counter&quot;&gt;Adding a counter&lt;/h2&gt;

&lt;p&gt;The biggest problem with the logic above is simply that the various commands
also have delays and durations associated with them.  For example, on
&lt;a href=&quot;http://www.issi.com/WW/pdf/42-45S16100H.pdf&quot;&gt;ISSI’s SDRAM chip&lt;/a&gt;,
nine clocks need to separate any REFRESH command from any command following.
Our simple logic above would require 8-separate NOOP commands in our sequence
to capture that.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 3. Instruction Codes&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/genuctrl/genu-isa.svg&quot; alt=&quot;&quot; width=&quot;360&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Alternatively, we could add a second type of instruction–a “wait” instruction,
with an integrated number of wait clocks. This would then become an &lt;a href=&quot;https://github.com/ZipCPU/zipstormmx/blob/master/rtl/genuctrl.v&quot;&gt;ultra-micro
controller&lt;/a&gt;
with two op-codes: the first for setting output registers, and
the second for starting a wait counter.  You can see these two codes shown in
Fig. 3 on the right.&lt;/p&gt;

&lt;p&gt;This would change our logic above slightly.  For example, we’d only advance
the address pointer to the next instruction if the delay counter had already
finished counting down to zero.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;&lt;span class=&quot;k&quot;&gt;always&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;posedge&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i_clk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;counter&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;r_addr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r_addr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Similarly, we’d only fetch the next instruction if the delay counter were zero
as well.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;&lt;span class=&quot;k&quot;&gt;always&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;posedge&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i_clk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;counter&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;case&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r_cmd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r_cmd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;command_zero&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// ....
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;endcase&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;We’d also only update the registers controlled by this sequence if the
delay counter were zero, &lt;em&gt;and&lt;/em&gt; the next command didn’t request a delay.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;&lt;span class=&quot;k&quot;&gt;always&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;posedge&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i_clk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;counter&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r_cmd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;OPCODE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]))&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;begin&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;in_refresh&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r_cmd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;in_refresh&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;refresh_cmd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r_cmd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;stall_bus&lt;/span&gt;   &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r_cmd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;// ... and so on
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;endcase&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;With all of that out of the way, the only new feature remaining is the counter
itself.  In this case, on any new delay instruction we set the counter to the
value given in the instruction, otherwise if the counter is greater than zero
we count down.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;&lt;span class=&quot;k&quot;&gt;always&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;posedge&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i_clk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;counter&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r_cmd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;OPCODE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]))&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;counter&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r_cmd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;OPCODE&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;counter&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;counter&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;counter&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The counter really is that basic.  Indeed, perhaps you’ve noticed that many of
my formal verification quizzes started out with verifying the properties of
a similar counter.&lt;/p&gt;

&lt;p&gt;At least that’s the basic design.  We’ll come back to it in a moment and fill in
the details.&lt;/p&gt;

&lt;h2 id=&quot;the-problem-with-induction&quot;&gt;The Problem with Induction&lt;/h2&gt;

&lt;p&gt;If you’ve been reading my blog for a while, you may remember how I’ve described
the &lt;a href=&quot;/blog/2018/03/10/induction-exercise.html&quot;&gt;problem associated with induction
before&lt;/a&gt;.
&lt;a href=&quot;/blog/2018/03/10/induction-exercise.html&quot;&gt;Induction&lt;/a&gt;
is important enough that we can’t really skip it.  Without
&lt;a href=&quot;/blog/2018/03/10/induction-exercise.html&quot;&gt;induction&lt;/a&gt;
you cannot formally verify anything beyond the reset sequence.  Without
&lt;a href=&quot;/blog/2018/03/10/induction-exercise.html&quot;&gt;induction&lt;/a&gt;,
you cannot prove that the properties in your design never fail.&lt;/p&gt;

&lt;p&gt;Well, okay, that’s a debatable presumption.  I should point out that there
are others who don’t use
&lt;a href=&quot;/blog/2018/03/10/induction-exercise.html&quot;&gt;induction&lt;/a&gt;
as regularly as I do.  For example, Clifford Wolf, the author of the
&lt;a href=&quot;https://github.com/cliffordwolf/picorv32&quot;&gt;picorv32 RISC-V CPU&lt;/a&gt;,
&lt;a href=&quot;https://github.com/YosysHQ/SymbiYosys&quot;&gt;Yosys&lt;/a&gt;,
&lt;a href=&quot;https://github.com/YosysHQ/SymbiYosys&quot;&gt;SymbiYosys&lt;/a&gt;, and the &lt;a href=&quot;https://github.com/SymbioticEDA/riscv-formal&quot;&gt;riscv-formal set
of formal properties for RISC-V CPU
verification&lt;/a&gt; tends not to use
&lt;a href=&quot;/blog/2018/03/10/induction-exercise.html&quot;&gt;induction&lt;/a&gt;
as much.  Indeed, a strong argument can be made for not using
&lt;a href=&quot;/blog/2018/03/10/induction-exercise.html&quot;&gt;induction&lt;/a&gt;: it’s
complex, hard to learn, it requires its own way of thinking, and for certain
problems a bounded model check can be equivalent.&lt;/p&gt;

&lt;p&gt;We can illustrate this with a basic
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;.
Suppose we had a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;
with a 9-stage pipeline.  Chances are we could fully verify it in 20 clock
cycles.  I’ll admit, I’m guess with these numbers, but there is a mathematical
way to determine this distance and I think I can argue that the minimum bounded
check needs to be longer than a full operation.  That said, I often find myself
verifying cores with minimum cycle lengths that last longer than 256 cycles,
such as these AXI
&lt;a href=&quot;https://github.com/ZipCPU/wb2axip/blob/master/rtl/aximm2s.v&quot;&gt;MM2S&lt;/a&gt; or
&lt;a href=&quot;https://github.com/ZipCPU/wb2axip/blob/master/rtl/axis2mm.v&quot;&gt;S2MM&lt;/a&gt; cores.
Simply put, 
&lt;a href=&quot;/blog/2018/03/10/induction-exercise.html&quot;&gt;induction&lt;/a&gt;
is an important tool, but it does have its place.&lt;/p&gt;

&lt;p&gt;When you use
&lt;a href=&quot;/blog/2018/03/10/induction-exercise.html&quot;&gt;induction&lt;/a&gt;, you
will find the traces shows the &lt;em&gt;appearance&lt;/em&gt; of having started the design
somewhere between the initial state and eternity.  However, this view of
&lt;a href=&quot;/blog/2018/03/10/induction-exercise.html&quot;&gt;induction&lt;/a&gt;
often frustrates engineers who use it, because they’ll point out that &lt;code class=&quot;highlighter-rouge&quot;&gt;X&lt;/code&gt;
must happen before &lt;code class=&quot;highlighter-rouge&quot;&gt;Y&lt;/code&gt; gets set, but somehow &lt;code class=&quot;highlighter-rouge&quot;&gt;Y&lt;/code&gt; is getting set without
ever passing &lt;code class=&quot;highlighter-rouge&quot;&gt;X&lt;/code&gt;.  “But I initialized that value!” is a common refrain
that I hear.&lt;/p&gt;

&lt;p&gt;The problem is that this is not how
&lt;a href=&quot;/blog/2018/03/10/induction-exercise.html&quot;&gt;induction&lt;/a&gt;
actually works.
&lt;a href=&quot;/blog/2018/03/10/induction-exercise.html&quot;&gt;Induction&lt;/a&gt;
works by piecing together some number of logic steps for your core that don’t
break any assertions, and then tries to break your assertions on the last step.
It only offers the appearance that the state chosen is in the middle of time.
In reality, the “initial” values in the
&lt;a href=&quot;/blog/2018/03/10/induction-exercise.html&quot;&gt;induction&lt;/a&gt;
trace are arbitrary–they could be anything, with the only requirements
that they don’t break any assumptions, and again that they don’t break any
assertions until the last step.&lt;/p&gt;

&lt;p&gt;As a result, because the
&lt;a href=&quot;/blog/2018/03/10/induction-exercise.html&quot;&gt;induction&lt;/a&gt; step
doesn’t start at the initial time step, constraining every register in the
design becomes important.  This includes the registers set by our &lt;a href=&quot;https://github.com/ZipCPU/zipstormmx/blob/master/rtl/genuctrl.v&quot;&gt;ultra-micro
controller&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;To bring this point home, I had a couple of memory rules that weren’t passing
&lt;a href=&quot;/blog/2018/03/10/induction-exercise.html&quot;&gt;induction&lt;/a&gt;.
Things like, REFRESH commands that could only be issued once all the banks had
been placed in their idle modes, or that PRECHARGE commands could only take
place no earlier than some (configurable) number of clock cycles after ACTIVATE
commands, etc.&lt;/p&gt;

&lt;p&gt;The particular problem is common among pipelined processes: Unless the various
pipeline stages are so constrained, the
&lt;a href=&quot;/blog/2018/03/10/induction-exercise.html&quot;&gt;induction&lt;/a&gt;
engine might start in a state where the stages have no relationship to each
other.  The &lt;a href=&quot;https://github.com/ZipCPU/zipstormmx/blob/master/rtl/genuctrl.v&quot;&gt;ultra-micro
controller&lt;/a&gt;
might load a command to be decoded, and then the
&lt;a href=&quot;/blog/2018/03/10/induction-exercise.html&quot;&gt;induction&lt;/a&gt;
engine starts with a command in that register that’s not in the command set.
Or it might start outputting a value that nothing in the command set would
allow.  Or it might do both.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/blog/2018/03/10/induction-exercise.html&quot;&gt;Induction&lt;/a&gt;
can seem kind of strange in that way.&lt;/p&gt;

&lt;p&gt;The way we’ll solve this
&lt;a href=&quot;/blog/2018/03/10/induction-exercise.html&quot;&gt;induction&lt;/a&gt;
problem is by walking a &lt;em&gt;microcode address&lt;/em&gt; through the various pipeline stages
of processing.  We’ll use one value to describe the address pipeline stage,
&lt;code class=&quot;highlighter-rouge&quot;&gt;f_addr&lt;/code&gt;, one for the command stage, &lt;code class=&quot;highlighter-rouge&quot;&gt;f_cmd&lt;/code&gt;, and one to describe the currently
active outputs, &lt;code class=&quot;highlighter-rouge&quot;&gt;f_active&lt;/code&gt;–the final pipeline stage.  These three are all
&lt;em&gt;addresses&lt;/em&gt; into our instruction stream.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	&lt;span class=&quot;kt&quot;&gt;reg&lt;/span&gt;	&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;LGNCMDS&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;f_addr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f_cmd&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f_active&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;We’ll set all three of these pipeline-addresses to zero initially
and again upon any reset.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	&lt;span class=&quot;k&quot;&gt;initial&lt;/span&gt;	&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f_active&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f_cmd&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f_addr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;always&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;posedge&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i_clk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i_reset&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
		&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f_active&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f_cmd&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f_addr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;In all other cases, we’ll increment the address whenever we step the &lt;a href=&quot;https://github.com/ZipCPU/zipstormmx/blob/master/rtl/genuctrl.v&quot;&gt;ultra-micro
controller&lt;/a&gt;
forward by one step.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	&lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r_step&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;begin&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;f_addr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f_addr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f_active&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f_cmd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f_cmd&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f_addr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;};&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The next step is to convert these addresses to commands.  We can use a large
parameter to store these commands.  If we have &lt;code class=&quot;highlighter-rouge&quot;&gt;NCMDS&lt;/code&gt; commands, each &lt;code class=&quot;highlighter-rouge&quot;&gt;WORDWID&lt;/code&gt;
wide, this might look like,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	&lt;span class=&quot;k&quot;&gt;parameter&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NCMDS&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;WORDWID&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;COMMANDS&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
			&lt;span class=&quot;c1&quot;&gt;// An arbitrary set of commands
&lt;/span&gt;			&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;mb&quot;&gt;1&#39;b0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mb&quot;&gt;2&#39;b00&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;4&#39;h0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;},&lt;/span&gt;
			&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;mb&quot;&gt;1&#39;b0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mb&quot;&gt;2&#39;b00&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;4&#39;h3&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;},&lt;/span&gt;
			&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;mb&quot;&gt;1&#39;b1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;6&#39;h02&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;},&lt;/span&gt;
			&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;mb&quot;&gt;1&#39;b0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mb&quot;&gt;2&#39;b00&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;4&#39;hb&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;},&lt;/span&gt;
			&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;mb&quot;&gt;1&#39;b0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mb&quot;&gt;2&#39;b00&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;4&#39;h3&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;},&lt;/span&gt;
			&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;mb&quot;&gt;1&#39;b1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;6&#39;h02&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;},&lt;/span&gt;
			&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;mb&quot;&gt;1&#39;b0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mb&quot;&gt;2&#39;b00&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;4&#39;ha&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;},&lt;/span&gt;
			&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;mb&quot;&gt;1&#39;b1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;6&#39;h2f&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;},&lt;/span&gt;
			&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;mb&quot;&gt;1&#39;b0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mb&quot;&gt;2&#39;b00&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;4&#39;h0f&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
			&lt;span class=&quot;o&quot;&gt;};&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;We can then use a simple Verilog &lt;em&gt;function&lt;/em&gt; to turn this command address into
its associated command.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	&lt;span class=&quot;k&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;WORDWID&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;getcommand&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;kt&quot;&gt;input&lt;/span&gt;	&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;LGNCMDS&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;i_addr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

		&lt;span class=&quot;n&quot;&gt;getcommand&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;COMMANDS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i_addr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;WORDWID&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;WORDWID&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;endfunction&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;While I don’t normally use functions, in this case the function is the key
to this whole algorithm.  Why?  Because I can now reuse the function throughout
to map addresses to commands.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	&lt;span class=&quot;c1&quot;&gt;// f_active_cmd is the command that&#39;s currently *active* and defining
&lt;/span&gt;	&lt;span class=&quot;c1&quot;&gt;// outputs
&lt;/span&gt;	&lt;span class=&quot;k&quot;&gt;always&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;f_active_cmd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;getcommand&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f_active&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

	&lt;span class=&quot;c1&quot;&gt;// f_cmd_cmd describes the command currently waiting to be interpreted
&lt;/span&gt;	&lt;span class=&quot;k&quot;&gt;always&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;f_cmd_cmd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;getcommand&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f_cmd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

	&lt;span class=&quot;c1&quot;&gt;// f_prior_cmd is the command I was just executing before the current
&lt;/span&gt;	&lt;span class=&quot;c1&quot;&gt;// one
&lt;/span&gt;	&lt;span class=&quot;k&quot;&gt;always&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;f_prior_cmd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;getcommand&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f_active&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Because there is a single common mapping from address to command, used by both
the logic of the core and the logic of the formal properties, I can assert that
these copies of the various commands actually match what each stage of the
algorithm should be doing.&lt;/p&gt;

&lt;p&gt;Only one other big step is required: we’ll need to constrain all of these
addresses with respect to each other.  You know, the &lt;code class=&quot;highlighter-rouge&quot;&gt;f_cmd&lt;/code&gt; address must
follow &lt;code class=&quot;highlighter-rouge&quot;&gt;f_addr&lt;/code&gt;, and &lt;code class=&quot;highlighter-rouge&quot;&gt;f_active&lt;/code&gt; must follow &lt;code class=&quot;highlighter-rouge&quot;&gt;f_cmd&lt;/code&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;&lt;span class=&quot;k&quot;&gt;always&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;begin&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;assert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f_cmd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f_addr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;assert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f_active&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f_cmd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Of course, this is only an overview.  The actual logic, below, corrects
several details.  For example, &lt;code class=&quot;highlighter-rouge&quot;&gt;assert(f_cmd + 1 == f_addr);&lt;/code&gt; will fail if
&lt;code class=&quot;highlighter-rouge&quot;&gt;f_cmd&lt;/code&gt; is about to roll over to the next bit.  Similarly, my reset sequence
needs to be run only once starting from a reset command, whereas the refresh
sequence needs to repeat over and over forever.  The main core of the logic,
however, remains as simple as it always was.&lt;/p&gt;

&lt;p&gt;Shall we take a peek at how this is done?&lt;/p&gt;

&lt;h2 id=&quot;microcontroller-logic&quot;&gt;MicroController Logic&lt;/h2&gt;

&lt;p&gt;Let’s look over the basic logic of &lt;a href=&quot;https://github.com/ZipCPU/zipstormmx/blob/master/rtl/genuctrl.v&quot;&gt;this really simple ultra-micro
controller&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;First, since I only want to build this once, I’ve chosen to make it highly
configurable.  The core accepts a parameterized number of command bits and
again a parameterized number of delay bits.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;&lt;span class=&quot;k&quot;&gt;module&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;genuctrl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i_clk&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i_reset&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;o_cmd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;parameter&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;CMDWIDTH&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;parameter&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;LGDELAY&lt;/span&gt;  &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;6&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Similarly, the core accepts a power of two length command set.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	&lt;span class=&quot;k&quot;&gt;parameter&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;LGNCMDS&lt;/span&gt;  &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;localparam&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;NCMDS&lt;/span&gt;    &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;LGNCMDS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Every word in our command set needs to have at least &lt;code class=&quot;highlighter-rouge&quot;&gt;CMDWIDTH&lt;/code&gt; bits,
&lt;code class=&quot;highlighter-rouge&quot;&gt;LGDELAY&lt;/code&gt; bits, plus one more bit for the opcode if &lt;code class=&quot;highlighter-rouge&quot;&gt;LGDELAY&lt;/code&gt; indicates
we’ll use a delay counter in our opcode.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	&lt;span class=&quot;k&quot;&gt;localparam&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;WORDWID&lt;/span&gt;  &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;LGDELAY&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
			&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CMDWIDTH&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;LGDELAY&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;LGDELAY&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CMDWIDTH&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;We can now create a fairly arbitrary set of commands using this format.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	&lt;span class=&quot;k&quot;&gt;parameter&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NCMDS&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;WORDWID&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;COMMANDS&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
			&lt;span class=&quot;c1&quot;&gt;//
&lt;/span&gt;			&lt;span class=&quot;c1&quot;&gt;// Commands read from the bottom (LSBs are first)
&lt;/span&gt;			&lt;span class=&quot;c1&quot;&gt;// up to the top (MSBs are last)
&lt;/span&gt;			&lt;span class=&quot;c1&quot;&gt;//
&lt;/span&gt;			&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;mb&quot;&gt;1&#39;b0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mb&quot;&gt;2&#39;b00&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;4&#39;h0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;},&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Last command
&lt;/span&gt;			&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;mb&quot;&gt;1&#39;b0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mb&quot;&gt;2&#39;b00&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;4&#39;h3&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;},&lt;/span&gt;
			&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;mb&quot;&gt;1&#39;b1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;6&#39;h02&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;},&lt;/span&gt;
			&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;mb&quot;&gt;1&#39;b0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mb&quot;&gt;2&#39;b00&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;4&#39;hb&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;},&lt;/span&gt;
			&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;mb&quot;&gt;1&#39;b0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mb&quot;&gt;2&#39;b00&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;4&#39;h3&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;},&lt;/span&gt;
			&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;mb&quot;&gt;1&#39;b1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;6&#39;h02&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;},&lt;/span&gt;
			&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;mb&quot;&gt;1&#39;b0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mb&quot;&gt;2&#39;b00&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;4&#39;ha&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;},&lt;/span&gt;
			&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;mb&quot;&gt;1&#39;b1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;6&#39;h2f&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;},&lt;/span&gt;
			&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;mb&quot;&gt;1&#39;b0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mb&quot;&gt;2&#39;b00&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;4&#39;h0f&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;	&lt;span class=&quot;c1&quot;&gt;// First command
&lt;/span&gt;			&lt;span class=&quot;o&quot;&gt;};&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;We’ll also insist that the first command of this sequence, that’s the one
on the bottom, start with an output-register opcode.&lt;/p&gt;

&lt;p&gt;Ideally, I’d like to formally verify this core against all possible command
sets.  However, using a parameter to set these commands really keeps me from
doing this.  Why then would I use a parameter to define the commands?&lt;/p&gt;

&lt;p&gt;For a couple of reasons.  First, unlike memories, (and even ROM memories!)
parameters cannot change their values during
&lt;a href=&quot;/blog/2018/03/10/induction-exercise.html&quot;&gt;induction&lt;/a&gt;.
Second, I am depending upon the properties of the resulting sequence to then
pass verification once this core is incorporated into &lt;a href=&quot;https://github.com/ZipCPU/zipstormmx/blob/e4cb3e6f3bc3ac5831925b28116cb19b4ed09e8d/rtl/wbsdram.v#L366-L387&quot;&gt;another as a
submodule&lt;/a&gt;.
My goal is to avoid turning this module into a black box that spits out
unconstrained values.  The parent module will depend upon these outputs and
their sequencing for a successful formal proof.&lt;/p&gt;

&lt;p&gt;We’ll also pick, arbitrarily, that the first command will set an initial state.
All values throughout our processing chain will then get reset to this initial
state on any reset.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	&lt;span class=&quot;k&quot;&gt;localparam&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;WORDWID&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;INITIAL_COMMAND&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;COMMANDS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;WORDWID&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Finally, we’ll support two options: &lt;code class=&quot;highlighter-rouge&quot;&gt;OPT_REPEAT&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;OPT_DELAY&lt;/code&gt;.  &lt;code class=&quot;highlighter-rouge&quot;&gt;OPT_REPEAT&lt;/code&gt;,
if set, will indicate that we want to keep repeating these commands over and
over–such as the refresh cycle.  If &lt;code class=&quot;highlighter-rouge&quot;&gt;OPT_REPEAT&lt;/code&gt; is clear, we’ll go through
this sequence once and stop on the last step–as the reset sequence will want
to do.  &lt;code class=&quot;highlighter-rouge&quot;&gt;OPT_DELAY&lt;/code&gt; on the other hand is a simple short hand for checking
whether or not we have one or more bits allocated to the delay counter.
If &lt;code class=&quot;highlighter-rouge&quot;&gt;OPT_DELAY&lt;/code&gt; is clear, the counter will remain at zero and all commands will
proceed at the same pace.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	&lt;span class=&quot;k&quot;&gt;parameter&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;OPT_REPEAT&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mb&quot;&gt;1&#39;b1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;localparam&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;OPT_DELAY&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;LGDELAY&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;With that aside, we can move into the &lt;a href=&quot;https://github.com/ZipCPU/zipstormmx/blob/master/rtl/genuctrl.v&quot;&gt;design
itself&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Our first task will be to create a global step signal, &lt;code class=&quot;highlighter-rouge&quot;&gt;r_step&lt;/code&gt;.  If this
signal is ever true, all of our various states will step forward.  Our goal
will be to set &lt;code class=&quot;highlighter-rouge&quot;&gt;r_step&lt;/code&gt; so that it is only ever true if the counter is zero,
so that it can replace the &lt;code class=&quot;highlighter-rouge&quot;&gt;r_count == 0&lt;/code&gt; logic check above and simplify
our logic.&lt;/p&gt;

&lt;p&gt;So here’s how this works.  We’ll start with the wait count kept in &lt;code class=&quot;highlighter-rouge&quot;&gt;r_count&lt;/code&gt;.
We’ll set this to zero initially so that the first command can always
contain the bits to output on any reset.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	&lt;span class=&quot;k&quot;&gt;generate&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;OPT_DELAY&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;begin&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;DELAY_COUNTER&lt;/span&gt;
		&lt;span class=&quot;kt&quot;&gt;reg&lt;/span&gt;	&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;LGDELAY&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;r_count&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

		&lt;span class=&quot;k&quot;&gt;initial&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;r_count&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;always&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;posedge&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i_clk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;While the opcode might start with a delay, this turns out to be rather
problematic, since it leaves the output registers undefined both initially
and following any reset.  Disallowing this simplifies our initial and
reset logic therefore.&lt;/p&gt;

&lt;p&gt;The reset should always bring this counter back to this same original state.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;		&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i_reset&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;r_count&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Every time the counter reaches (or stays at) zero, we’ll advance to the next
instruction.  If that instruction, kept in &lt;code class=&quot;highlighter-rouge&quot;&gt;r_cmd&lt;/code&gt;, contains a delay
instruction then we’ll set the counter to that delay, otherwise we’ll keep it
at zero.  (Remember, &lt;code class=&quot;highlighter-rouge&quot;&gt;r_step&lt;/code&gt; is equivalent to &lt;code class=&quot;highlighter-rouge&quot;&gt;r_count == 0&lt;/code&gt;.)&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;		&lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r_step&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;begin&lt;/span&gt;
			&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r_cmd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;WORDWID&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;
				&lt;span class=&quot;c1&quot;&gt;// This is a delay instruction
&lt;/span&gt;				&lt;span class=&quot;n&quot;&gt;r_count&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r_cmd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;LGDELAY&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
			&lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;
				&lt;span class=&quot;c1&quot;&gt;// This is a command instruction
&lt;/span&gt;				&lt;span class=&quot;n&quot;&gt;r_count&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Finally, if &lt;code class=&quot;highlighter-rouge&quot;&gt;r_count != 0&lt;/code&gt;, we’ll decrement it until it does equal zero.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;		&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;r_count&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r_count&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;In order to stay off of the critical timing path, we’ll set &lt;code class=&quot;highlighter-rouge&quot;&gt;r_step&lt;/code&gt; so that
it’s equivalent to &lt;code class=&quot;highlighter-rouge&quot;&gt;r_count == 0&lt;/code&gt;.  That means that it’s logic will (roughly)
mirror that of &lt;code class=&quot;highlighter-rouge&quot;&gt;r_count&lt;/code&gt; above, with only a few subtle differences.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;		&lt;span class=&quot;k&quot;&gt;initial&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;r_step&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;always&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;posedge&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i_clk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i_reset&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;r_step&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r_step&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;begin&lt;/span&gt;
			&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r_cmd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;WORDWID&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;
				&lt;span class=&quot;c1&quot;&gt;// This is a delay instruction
&lt;/span&gt;				&lt;span class=&quot;n&quot;&gt;r_step&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r_cmd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;LGDELAY&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
			&lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;
				&lt;span class=&quot;c1&quot;&gt;// This is a command instruction
&lt;/span&gt;				&lt;span class=&quot;n&quot;&gt;r_step&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// if (!r_step)
&lt;/span&gt;			&lt;span class=&quot;n&quot;&gt;r_step&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r_count&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;While the logic above is fairly straightforward, getting it right and convincing
yourself that it’s right can be valuable.  For this, we’ll set up a single
formal property to make certain that &lt;code class=&quot;highlighter-rouge&quot;&gt;r_step&lt;/code&gt; is truly equivalent to
&lt;code class=&quot;highlighter-rouge&quot;&gt;r_count ==  0&lt;/code&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;&lt;span class=&quot;cp&quot;&gt;`ifdef&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;FORMAL&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;always&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
			&lt;span class=&quot;k&quot;&gt;assert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r_step&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r_count&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;We can also check the counter against the currently active instruction.
If the instruction is not a delay OpCode, then the counter must be zero.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;		&lt;span class=&quot;k&quot;&gt;always&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f_active_cmd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;WORDWID&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;
			&lt;span class=&quot;k&quot;&gt;assert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r_count&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Otherwise it must be less than the delay specified in the current command.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;		&lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;
			&lt;span class=&quot;k&quot;&gt;assert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r_count&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f_active_cmd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;LGDELAY&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;cp&quot;&gt;`endif&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Finally, if the number of delay bits is zero, &lt;code class=&quot;highlighter-rouge&quot;&gt;LGDELAY==0&lt;/code&gt; and so &lt;code class=&quot;highlighter-rouge&quot;&gt;!OPT_DELAY&lt;/code&gt;,
then the &lt;code class=&quot;highlighter-rouge&quot;&gt;r_step&lt;/code&gt; signal should always be high.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;begin&lt;/span&gt;

		&lt;span class=&quot;k&quot;&gt;always&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;r_step&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mb&quot;&gt;1&#39;b1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

	&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;endgenerate&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;That leaves three primary steps left to this algorithm.&lt;/p&gt;

&lt;p&gt;The first is to calculate the next command address.  Because we have chosen
a super simple command set, there are no
&lt;a href=&quot;https://en.wikipedia.org/wiki/Branch_(computer_science)&quot;&gt;jumps&lt;/a&gt;,
no &lt;a href=&quot;/blog/2017/08/14/strategies-for-pipelining.html&quot;&gt;pipeline stalls&lt;/a&gt;, nothing
but the next address.  That means we can keep this logic as simple as
initializing the address to zero and then perpetually incrementing it every
time we step forward.&lt;/p&gt;

&lt;p&gt;That would work if we wanted to repeat this logic forever–such as with the
refresh sequence.  If we want to stop, though–such as at the end of the reset
sequence, then we’ll need recognize a last address and stop incrementing
&lt;code class=&quot;highlighter-rouge&quot;&gt;r_addr&lt;/code&gt; once we get there.  In the logic below, this last address is captured
by &lt;code class=&quot;highlighter-rouge&quot;&gt;(&amp;amp;r_addr)&lt;/code&gt;–the address with every bit set.  If we are not repeating,
we’ll stop at this address.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	&lt;span class=&quot;k&quot;&gt;initial&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;r_addr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;always&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;posedge&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i_clk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i_reset&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;r_addr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r_step&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;OPT_REPEAT&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r_addr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)))&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;r_addr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r_addr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The second of the three remaining steps is to read the command from our
parameter set.  Other than the initialization and reset logic, this is
very straightforward.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	&lt;span class=&quot;k&quot;&gt;initial&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;r_cmd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;INITIAL_COMMAND&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;always&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;posedge&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i_clk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i_reset&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;r_cmd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;INITIAL_COMMAND&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r_step&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;r_cmd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;getcommand&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r_addr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Finally, the last step is to act upon the command.  For this core, we’ll act
upon it by setting a number of bits in our output, &lt;code class=&quot;highlighter-rouge&quot;&gt;o_cmd&lt;/code&gt;, based upon the
values captured by the command.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;&lt;span class=&quot;k&quot;&gt;always&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;posedge&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i_clk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r_step&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;o_cmd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r_cmd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CMDWIDTH&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Or, at least that’s the thought.&lt;/p&gt;

&lt;p&gt;The problem is that we only want to set our output bits on a command opcode
and not on a wait opcode.  So we now need to check if either we aren’t
implementing the wait opcode, or if the next command isn’t a wait command,
before setting our output bits based upon the instruction.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;&lt;span class=&quot;k&quot;&gt;always&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;posedge&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i_clk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r_step&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;OPT_DELAY&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r_cmd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;WORDWID&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]))&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;o_cmd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r_cmd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CMDWIDTH&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;But what should our initial and reset value be?  Ideally, we’d want to set
&lt;code class=&quot;highlighter-rouge&quot;&gt;o_cmd&lt;/code&gt; initially to whatever was in the first instruction and then
update it on every step following.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	&lt;span class=&quot;k&quot;&gt;initial&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;o_cmd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;INITIAL_COMMAND&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CMDWIDTH&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;always&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;posedge&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i_clk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i_reset&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;o_cmd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;INITIAL_COMMAND&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CMDWIDTH&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r_step&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;OPT_DELAY&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r_cmd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;WORDWID&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]))&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;o_cmd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r_cmd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CMDWIDTH&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;We’ve already discussed the &lt;code class=&quot;highlighter-rouge&quot;&gt;getcommand&lt;/code&gt; function above, so we don’t
really need to discuss it more here.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	&lt;span class=&quot;k&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;WORDWID&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;getcommand&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;kt&quot;&gt;input&lt;/span&gt;	&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;LGNCMDS&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;i_addr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

		&lt;span class=&quot;n&quot;&gt;getcommand&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;COMMANDS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i_addr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;WORDWID&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;WORDWID&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;endfunction&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Voila!  That’s the logic to our &lt;a href=&quot;https://github.com/ZipCPU/zipstormmx/blob/master/rtl/genuctrl.v&quot;&gt;ultra-micro
controller&lt;/a&gt;:
1) calculate an instruction address, 2) read the instruction, and then
3) do what it tells you to.&lt;/p&gt;

&lt;p&gt;Hopefully this logic appears quite straightforward.  It’s supposed to be.
If not, feel free to &lt;a href=&quot;https://github.com/ZipCPU/zipstormmx/blob/master/rtl/genuctrl.v&quot;&gt;review the Verilog
design&lt;/a&gt;
yourself to see how it works.
It’s supposed to be a very simple and reusable logic structure.&lt;/p&gt;

&lt;h2 id=&quot;formal-verification&quot;&gt;Formal Verification&lt;/h2&gt;

&lt;p&gt;That’s the basic logic associated with this simple &lt;a href=&quot;https://github.com/ZipCPU/zipstormmx/blob/master/rtl/genuctrl.v&quot;&gt;ultra-micro
controller&lt;/a&gt;,
now let’s take a look at the formal properties necessary to force the
&lt;a href=&quot;/blog/2018/03/10/induction-exercise.html&quot;&gt;induction&lt;/a&gt;
engine into a consistent state.&lt;/p&gt;

&lt;p&gt;There are two things to note before starting: First, this &lt;a href=&quot;https://github.com/ZipCPU/zipstormmx/blob/master/rtl/genuctrl.v&quot;&gt;ultra-micro
controller&lt;/a&gt;
has only one input, &lt;code class=&quot;highlighter-rouge&quot;&gt;i_reset&lt;/code&gt;.  That’s it.  That means we don’t need to make
any assumptions about how the various inputs might relate to each other.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: left&quot;&gt;&lt;caption&gt;Fig 4. Formal Packets&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/genuctrl/fpipe.svg&quot; alt=&quot;&quot; width=&quot;480&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Second, our basic approach will be to shadow the &lt;a href=&quot;https://github.com/ZipCPU/zipstormmx/blob/master/rtl/genuctrl.v&quot;&gt;ultra-micro
controller&lt;/a&gt;’s
pipeline with a set of registers used only for formal verification–a packet
of information if you will.  This is very similar to the way
&lt;a href=&quot;https://github.com/cliffordwolf/riscv-formal&quot;&gt;riscv-formal&lt;/a&gt; works:
you form a packet of information describing each instruction as it goes through
the pipeline.  In this case, however, we’ll draw our assertions about that
packet as it works its way through the pipeline rather than just at the end
as &lt;a href=&quot;https://github.com/cliffordwolf/riscv-formal&quot;&gt;riscv-formal&lt;/a&gt; does.&lt;/p&gt;

&lt;p&gt;I’m also going to use the abbreviations &lt;code class=&quot;highlighter-rouge&quot;&gt;f_addr&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;f_cmd&lt;/code&gt;, and &lt;code class=&quot;highlighter-rouge&quot;&gt;f_active&lt;/code&gt; to
describe the three different pipeline stages, while &lt;code class=&quot;highlighter-rouge&quot;&gt;prior&lt;/code&gt; will be used to
describe any stage prior to &lt;code class=&quot;highlighter-rouge&quot;&gt;active&lt;/code&gt;.  Therefore, &lt;code class=&quot;highlighter-rouge&quot;&gt;f_active_cmd&lt;/code&gt; will refer to
the command currently being carried out, whereas &lt;code class=&quot;highlighter-rouge&quot;&gt;f_cmd_cmd&lt;/code&gt; will refer to the
command we are going to interpret next, and so forth.  This will allow us to
assert, in a moment, that the output command bits are equal to either the low
order bits of &lt;code class=&quot;highlighter-rouge&quot;&gt;f_active_cmd&lt;/code&gt;, or the low order bits of the prior command,
&lt;code class=&quot;highlighter-rouge&quot;&gt;f_prior_cmd&lt;/code&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;&lt;span class=&quot;cp&quot;&gt;`ifdef&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;FORMAL&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;// reg	[LGNCMDS-1:0]	f_addr, f_cmd, f_active;
&lt;/span&gt;	&lt;span class=&quot;kt&quot;&gt;reg&lt;/span&gt;	&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;WORDWID&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;f_active_cmd&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f_cmd_cmd&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f_prior_cmd&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;kt&quot;&gt;reg&lt;/span&gt;	&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;LGNCMDS&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;fn_cmd&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fn_active&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;kt&quot;&gt;reg&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;f_past_valid&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Our first step will be to get a copy of the commands that should be
executing in each of the various stages of processing–as outlined in Fig. 4
above.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	&lt;span class=&quot;k&quot;&gt;always&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;f_active_cmd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;getcommand&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f_active&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

	&lt;span class=&quot;k&quot;&gt;always&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;f_cmd_cmd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;getcommand&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f_cmd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

	&lt;span class=&quot;k&quot;&gt;always&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;f_prior_cmd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;getcommand&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f_active&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

	&lt;span class=&quot;k&quot;&gt;always&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;assert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r_cmd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;getcommand&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f_cmd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;As discussed above, we’ll shadow the next command address with &lt;code class=&quot;highlighter-rouge&quot;&gt;f_addr&lt;/code&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	&lt;span class=&quot;k&quot;&gt;always&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;assert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f_addr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r_addr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Then, on each step, we’ll move push one command in and through the pipeline.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	&lt;span class=&quot;k&quot;&gt;initial&lt;/span&gt;	&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f_active&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f_cmd&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f_addr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;always&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;posedge&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i_clk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i_reset&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
		&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f_active&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f_cmd&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f_addr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r_step&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;begin&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;OPT_REPEAT&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f_addr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;f_addr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f_addr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f_active&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f_cmd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f_cmd&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f_addr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;};&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;One of the hassles of dealing with addition wrapping in a finite number
of bits is that &lt;code class=&quot;highlighter-rouge&quot;&gt;value + 1&lt;/code&gt; uses one more bit than &lt;code class=&quot;highlighter-rouge&quot;&gt;value&lt;/code&gt; rather than
wrapping.  To make certain that adding one to a value causes the sum to
remain within the right number of bits, we need to force it back to the
bit-width of our address.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	&lt;span class=&quot;k&quot;&gt;always&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;fn_cmd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f_cmd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

	&lt;span class=&quot;k&quot;&gt;always&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;fn_active&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f_active&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Now that I have that, I can work through how the addresses should exist
in relationship to each other.  Let’s start with the case where the &lt;a href=&quot;https://github.com/ZipCPU/zipstormmx/blob/master/rtl/genuctrl.v&quot;&gt;ultra-micro
controller&lt;/a&gt;
goes through its instructions in a one-shot (non-repeating) manner.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	&lt;span class=&quot;k&quot;&gt;always&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;OPT_REPEAT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;begin&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;We start out with everything at zero, so if &lt;code class=&quot;highlighter-rouge&quot;&gt;f_addr&lt;/code&gt; is still at zero then
everything else must still be at zero.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;		&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f_addr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;begin&lt;/span&gt;
			&lt;span class=&quot;k&quot;&gt;assert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f_cmd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
			&lt;span class=&quot;k&quot;&gt;assert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f_active&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Otherwise, if the &lt;code class=&quot;highlighter-rouge&quot;&gt;f_cmd&lt;/code&gt; stage is still at address zero, then we are one step
further–having incremented &lt;code class=&quot;highlighter-rouge&quot;&gt;f_addr&lt;/code&gt; but not yet propagated that incremented
value to &lt;code class=&quot;highlighter-rouge&quot;&gt;f_cmd&lt;/code&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;		&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f_cmd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;begin&lt;/span&gt;
			&lt;span class=&quot;k&quot;&gt;assert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f_active&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
			&lt;span class=&quot;k&quot;&gt;assert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f_addr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Now let’s turn to look at the other end.  If &lt;code class=&quot;highlighter-rouge&quot;&gt;f_active&lt;/code&gt; is all ones, then it’s
saturated at the last instruction as has everything before it.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;		&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f_active&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;begin&lt;/span&gt;
			&lt;span class=&quot;k&quot;&gt;assert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f_cmd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
			&lt;span class=&quot;k&quot;&gt;assert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f_addr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;If &lt;code class=&quot;highlighter-rouge&quot;&gt;f_active&lt;/code&gt; hasn’t yet saturated, but &lt;code class=&quot;highlighter-rouge&quot;&gt;f_cmd&lt;/code&gt; has, then &lt;code class=&quot;highlighter-rouge&quot;&gt;f_active&lt;/code&gt; will
saturate on the next clock.  Of course, &lt;code class=&quot;highlighter-rouge&quot;&gt;f_cmd&lt;/code&gt; can’t get to the last value
unless &lt;code class=&quot;highlighter-rouge&quot;&gt;f_addr&lt;/code&gt; has already done so, so &lt;code class=&quot;highlighter-rouge&quot;&gt;f_addr&lt;/code&gt; must be on the last address
as well.  Finally, notice how we can check &lt;code class=&quot;highlighter-rouge&quot;&gt;f_active+1&lt;/code&gt; against &lt;code class=&quot;highlighter-rouge&quot;&gt;f_cmd&lt;/code&gt; without
worrying about overflow, since &lt;code class=&quot;highlighter-rouge&quot;&gt;f_cmd&lt;/code&gt; is already the maximum positive number
and &lt;code class=&quot;highlighter-rouge&quot;&gt;f_active&lt;/code&gt; one less.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;		&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f_cmd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;begin&lt;/span&gt;
			&lt;span class=&quot;k&quot;&gt;assert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f_addr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
			&lt;span class=&quot;k&quot;&gt;assert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f_active&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f_cmd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;If none of those special cases are true, then we must be somewhere in the
middle: &lt;code class=&quot;highlighter-rouge&quot;&gt;f_addr + 2 == f_cmd + 1 == f_active&lt;/code&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;		&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;begin&lt;/span&gt;
			&lt;span class=&quot;k&quot;&gt;assert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f_cmd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f_addr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
			&lt;span class=&quot;k&quot;&gt;assert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f_active&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f_cmd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The case where we repeat is a touch more interesting.  In this case, &lt;code class=&quot;highlighter-rouge&quot;&gt;f_active&lt;/code&gt;
will remain equal to &lt;code class=&quot;highlighter-rouge&quot;&gt;f_cmd&lt;/code&gt; for the first two initial clock cycles.  In the
first cycle, &lt;code class=&quot;highlighter-rouge&quot;&gt;f_addr == f_cmd == f_active == 0&lt;/code&gt;.   In the second cycle,
&lt;code class=&quot;highlighter-rouge&quot;&gt;f_addr == 1&lt;/code&gt;, while &lt;code class=&quot;highlighter-rouge&quot;&gt;f_cmd == f_active == 0&lt;/code&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;begin&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f_active&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f_cmd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;begin&lt;/span&gt;
			&lt;span class=&quot;k&quot;&gt;assert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f_active&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
			&lt;span class=&quot;k&quot;&gt;assert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f_addr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Once we get past those two first cycles, we then know that &lt;code class=&quot;highlighter-rouge&quot;&gt;f_addr == f_cmd+1&lt;/code&gt;
and &lt;code class=&quot;highlighter-rouge&quot;&gt;f_cmd == f_active + 1&lt;/code&gt; with the exception that we have to math that will
wrap around after the last instruction.  This was why we created &lt;code class=&quot;highlighter-rouge&quot;&gt;fn_cmd&lt;/code&gt; and
&lt;code class=&quot;highlighter-rouge&quot;&gt;fn_active&lt;/code&gt;, and then limited them to the bare width of any address.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;		&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;begin&lt;/span&gt;
			&lt;span class=&quot;k&quot;&gt;assert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fn_cmd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f_addr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
			&lt;span class=&quot;k&quot;&gt;assert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fn_active&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f_cmd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Now, what about our outputs?  Realistically, that’s what we want to guarantee,
that we have the right outputs.  Those are kept in &lt;code class=&quot;highlighter-rouge&quot;&gt;o_cmd&lt;/code&gt;, and consist of the
bottom several bits of any command word.&lt;/p&gt;

&lt;p&gt;Here’s where all of our address work pays off.  Because we’ve set
&lt;code class=&quot;highlighter-rouge&quot;&gt;f_active_cmd&lt;/code&gt; to be equal to the instruction at &lt;code class=&quot;highlighter-rouge&quot;&gt;f_active&lt;/code&gt;, we can assert that
&lt;code class=&quot;highlighter-rouge&quot;&gt;o_cmd&lt;/code&gt; matches the bits in &lt;code class=&quot;highlighter-rouge&quot;&gt;f_active_cmd&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Well, not quite.  What if the command in the last pipeline stage is a delay
command?  Okay, so as long as it’s not a delay command we can make this
assertion.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	&lt;span class=&quot;k&quot;&gt;always&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;OPT_DELAY&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f_active_cmd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;WORDWID&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;assert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;o_cmd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f_active_cmd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CMDWIDTH&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;But what if it is a delay command?  In that case, our outgoing command bits
must match those of the prior command.  As before, though, that’s only if
the prior command isn’t also a delay.  Since it’s not likely that we’ll ever
want to place two delays in a row, this should be good enough.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	&lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f_active&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f_prior_cmd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;WORDWID&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]))&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;assert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;o_cmd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f_prior_cmd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CMDWIDTH&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;There’s one other assertion we should make, and that is that the initial
command word is going to set &lt;code class=&quot;highlighter-rouge&quot;&gt;o_cmd&lt;/code&gt; rather than be a delay instruction.
So let’s assert that this initial opcode is a set-bits op-code, that way
we’ll know that we always have a good set of output bits from the initial
state or the reset state forward.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	&lt;span class=&quot;k&quot;&gt;always&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;assert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;INITIAL_COMMAND&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;WORDWID&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;cp&quot;&gt;`endif&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;endmodule&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h2 id=&quot;the-reset-sequence&quot;&gt;The Reset Sequence&lt;/h2&gt;

&lt;p&gt;Before leaving this topic, let’s take a quick peek at how this &lt;a href=&quot;https://github.com/ZipCPU/zipstormmx/blob/master/rtl/genuctrl.v&quot;&gt;ultra-micro
controller&lt;/a&gt;
gets used in an &lt;a href=&quot;https://github.com/ZipCPU/zipstormmx/blob/master/rtl/wbsdram.v&quot;&gt;SDRAM
controller&lt;/a&gt;.
In particular, within &lt;a href=&quot;https://github.com/ZipCPU/zipstormmx/blob/e4cb3e6f3bc3ac5831925b28116cb19b4ed09e8d/rtl/wbsdram.v&quot;&gt;this controller&lt;/a&gt; for the iCE CORE
board,
you have &lt;a href=&quot;https://github.com/ZipCPU/zipstormmx/blob/e4cb3e6f3bc3ac5831925b28116cb19b4ed09e8d/rtl/wbsdram.v#L578-L607&quot;&gt;this piece of logic&lt;/a&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	&lt;span class=&quot;k&quot;&gt;localparam&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;11&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MODE_COMMAND&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;
			&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;mb&quot;&gt;5&#39;b00000&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;	&lt;span class=&quot;c1&quot;&gt;// Burst reads and writes
&lt;/span&gt;			&lt;span class=&quot;n&quot;&gt;CAS_LATENCY&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;// CAS latency (3 clocks)
&lt;/span&gt;			&lt;span class=&quot;mb&quot;&gt;1&#39;b0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;		&lt;span class=&quot;c1&quot;&gt;// Sequential (not interleaved)
&lt;/span&gt;			&lt;span class=&quot;mb&quot;&gt;3&#39;b001&lt;/span&gt;		&lt;span class=&quot;c1&quot;&gt;// 32-bit burst length
&lt;/span&gt;			&lt;span class=&quot;o&quot;&gt;};&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;genuctrl&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;#(&lt;/span&gt;
		&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CMDWIDTH&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;
		&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;LGDELAY&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;
		&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;LGNCMDS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;
		&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;OPT_REPEAT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;
		&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;COMMANDS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;c1&quot;&gt;// Read these commands from the bottom up
&lt;/span&gt;		&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;mb&quot;&gt;1&#39;b0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mb&quot;&gt;1&#39;b0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CMD_NOOP&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;      &lt;span class=&quot;n&quot;&gt;MODE_COMMAND&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;},&lt;/span&gt;
		&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;mb&quot;&gt;1&#39;b0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mb&quot;&gt;1&#39;b0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CMD_NOOP&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;      &lt;span class=&quot;n&quot;&gt;MODE_COMMAND&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;},&lt;/span&gt;
		&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;mb&quot;&gt;1&#39;b0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mb&quot;&gt;1&#39;b0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CMD_NOOP&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;      &lt;span class=&quot;n&quot;&gt;MODE_COMMAND&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;},&lt;/span&gt;
		&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;mb&quot;&gt;1&#39;b0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mb&quot;&gt;1&#39;b0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CMD_NOOP&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;      &lt;span class=&quot;n&quot;&gt;MODE_COMMAND&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;},&lt;/span&gt;
		&lt;span class=&quot;c1&quot;&gt;//
&lt;/span&gt;		&lt;span class=&quot;c1&quot;&gt;// Need two cycles following SET_MODE before the first
&lt;/span&gt;		&lt;span class=&quot;c1&quot;&gt;// command
&lt;/span&gt;		&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;mb&quot;&gt;1&#39;b0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mb&quot;&gt;1&#39;b1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CMD_NOOP&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;      &lt;span class=&quot;n&quot;&gt;MODE_COMMAND&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;},&lt;/span&gt;
		&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;mb&quot;&gt;1&#39;b0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mb&quot;&gt;1&#39;b1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CMD_SET_MODE&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;MODE_COMMAND&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;},&lt;/span&gt;
		&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;mb&quot;&gt;1&#39;b1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mb&quot;&gt;2&#39;b00&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;4&#39;h6&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;},&lt;/span&gt;
		&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;mb&quot;&gt;1&#39;b0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mb&quot;&gt;1&#39;b1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CMD_NOOP&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;      &lt;span class=&quot;n&quot;&gt;MODE_COMMAND&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;},&lt;/span&gt;
		&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;mb&quot;&gt;1&#39;b0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mb&quot;&gt;1&#39;b1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CMD_REFRESH&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;   &lt;span class=&quot;n&quot;&gt;MODE_COMMAND&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;},&lt;/span&gt;
		&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;mb&quot;&gt;1&#39;b1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mb&quot;&gt;2&#39;b00&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;4&#39;h6&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;},&lt;/span&gt;
		&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;mb&quot;&gt;1&#39;b0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mb&quot;&gt;1&#39;b1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CMD_NOOP&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;      &lt;span class=&quot;n&quot;&gt;MODE_COMMAND&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;},&lt;/span&gt;
		&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;mb&quot;&gt;1&#39;b0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mb&quot;&gt;1&#39;b1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CMD_REFRESH&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;   &lt;span class=&quot;n&quot;&gt;MODE_COMMAND&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;},&lt;/span&gt;
		&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;mb&quot;&gt;1&#39;b1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mb&quot;&gt;2&#39;b00&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;4&#39;h0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;},&lt;/span&gt;
		&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;mb&quot;&gt;1&#39;b0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mb&quot;&gt;1&#39;b1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CMD_NOOP&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;      &lt;span class=&quot;n&quot;&gt;MODE_COMMAND&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;},&lt;/span&gt;
		&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;mb&quot;&gt;1&#39;b0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mb&quot;&gt;1&#39;b1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CMD_PRECHARGE&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mb&quot;&gt;1&#39;b1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;},&lt;/span&gt;
		&lt;span class=&quot;c1&quot;&gt;// The command list starts here, with a no-op then precharge
&lt;/span&gt;		&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;mb&quot;&gt;1&#39;b0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mb&quot;&gt;1&#39;b1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CMD_NOOP&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;      &lt;span class=&quot;n&quot;&gt;MODE_COMMAND&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
		&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;reset_controller&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i_clk&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;startup_hold&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;
		&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;reset_active&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;reset_command&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;reset_addr10&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The most difficult thing about reading this is that the commands start from
low addresses and work their way up to higher addresses.  The second challenging
part is to realize that a command followed by a delay of zero issues the
same command twice, and that a command followed by a delay of one issues
it three times–so the actual number is the delay value plus two.  Now, reading
from the bottom up, we have:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;The first command is a NOOP, &lt;code class=&quot;highlighter-rouge&quot;&gt;CMD_NOOP&lt;/code&gt;.  It last’s for one cycle.&lt;/li&gt;
  &lt;li&gt;The second command is a PRECHARGE command, &lt;code class=&quot;highlighter-rouge&quot;&gt;CMD_PRECHARGE&lt;/code&gt;.  The final
bit, &lt;code class=&quot;highlighter-rouge&quot;&gt;1&#39;b1&lt;/code&gt;, controls the eleventh address bit indicating that this
command precharges all of the banks of the &lt;a href=&quot;https://en.wikipedia.org/wiki/Synchronous_dynamic_random-access_memory&quot;&gt;SDRAM&lt;/a&gt;.&lt;/li&gt;
  &lt;li&gt;We then return to a NOOP command.&lt;/li&gt;
  &lt;li&gt;We maintain that NOOP command for a one cycle delay.&lt;/li&gt;
  &lt;li&gt;Then we issue a REFRESH command, &lt;code class=&quot;highlighter-rouge&quot;&gt;CMD_REFRESH&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;Set the outputs to a NOOP, and&lt;/li&gt;
  &lt;li&gt;Wait &lt;code class=&quot;highlighter-rouge&quot;&gt;6+1&lt;/code&gt; cycles.  (Total 8-cycles of NOOP)&lt;/li&gt;
  &lt;li&gt;Issue a second REFRESH command, &lt;code class=&quot;highlighter-rouge&quot;&gt;CMD_REFRESH&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;Another NOOP&lt;/li&gt;
  &lt;li&gt;Wait for &lt;code class=&quot;highlighter-rouge&quot;&gt;6+1&lt;/code&gt; cycles again&lt;/li&gt;
  &lt;li&gt;Issue a SETMODE command, &lt;code class=&quot;highlighter-rouge&quot;&gt;CMD_SET_MODE&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;Another NOOP&lt;/li&gt;
  &lt;li&gt;Finally, that bit just more significant than the 4-bit &lt;a href=&quot;https://en.wikipedia.org/wiki/Synchronous_dynamic_random-access_memory&quot;&gt;SDRAM
command&lt;/a&gt;
gets released This is the flag indicating to the rest of the logic that
the reset sequence is complete.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;For more information on the meaning of these various commands, you should check
out the data sheet for the
&lt;a href=&quot;http://www.issi.com/WW/pdf/42-45S16100H.pdf&quot;&gt;ISSI SDRAM&lt;/a&gt;.
In general, this sequence just follows directly from the one listed in the
data sheet.&lt;/p&gt;

&lt;p&gt;Notice also that all I’ve done is to script the startup script described in the
&lt;a href=&quot;http://www.issi.com/WW/pdf/42-45S16100H.pdf&quot;&gt;SDRAM Spec&lt;/a&gt; directly into the
design.  Framing the problem in terms of this ultra-micro controller made
it fairly easy to do.&lt;/p&gt;

&lt;p&gt;That said, perhaps you noticed two confusing things.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;The instructions read backwards.  I may wish to change this in the future,
but for now that’s how the controller works.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;If you want to issue 7-cycles of NOOPs, you have to issue two commands.
The first command switches the outgoing &lt;code class=&quot;highlighter-rouge&quot;&gt;reset_command&lt;/code&gt; to a &lt;code class=&quot;highlighter-rouge&quot;&gt;CMD_NOOP&lt;/code&gt;,
and the second command waits.  As built, this is not one command
Worse, a wait cycle of ‘0’ will cause the controller to issue two NOOP’s,
not zero and not one: one for the command, and another for the delay
instruction.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;the-refresh-sequence&quot;&gt;The Refresh Sequence&lt;/h2&gt;

&lt;p&gt;The other sequence I used this ultra-micro controller for is the refresh
sequence.  In many ways, the refresh sequence is very similar to the reset
sequence.  The biggest difference is that the refresh sequence repeats.&lt;/p&gt;

&lt;p&gt;Before diving into this sequence, let me just say that
&lt;a href=&quot;https://en.wikipedia.org/wiki/Synchronous_dynamic_random-access_memory&quot;&gt;SDRAM&lt;/a&gt;
refresh control can be much more complicated than what I’m presenting here.  A
“smart”
&lt;a href=&quot;https://en.wikipedia.org/wiki/Synchronous_dynamic_random-access_memory&quot;&gt;SDRAM&lt;/a&gt;
controller might issue more refreshes any time the chip is idle.  That way the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Synchronous_dynamic_random-access_memory&quot;&gt;SDRAM&lt;/a&gt;
doesn’t necessarily need to be interrupted when busy–or at least not nearly
as often.&lt;/p&gt;

&lt;p&gt;I’m not going to over think this today.  In this case, we’ll use our
&lt;a href=&quot;https://github.com/ZipCPU/zipstormmx/blob/e4cb3e6f3bc3ac5831925b28116cb19b4ed09e8d/rtl/wbsdram.v#L622-L667&quot;&gt;ultra-micro controller to drive the refresh logic&lt;/a&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	&lt;span class=&quot;n&quot;&gt;genuctrl&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;#(&lt;/span&gt;
		&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CMDWIDTH&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;
		&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;LGDELAY&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;LGREF&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;
		&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;LGNCMDS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;
		&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;OPT_REPEAT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;
		&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;COMMANDS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;c1&quot;&gt;// Read these commands from the bottom up
&lt;/span&gt;		&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;mb&quot;&gt;1&#39;b0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;REF_ZEROS&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mb&quot;&gt;2&#39;b00&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CMD_NOOP&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;},&lt;/span&gt;
		&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;mb&quot;&gt;1&#39;b0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;REF_ZEROS&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mb&quot;&gt;2&#39;b00&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CMD_NOOP&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;},&lt;/span&gt;
		&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;mb&quot;&gt;1&#39;b0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;REF_ZEROS&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mb&quot;&gt;2&#39;b00&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CMD_NOOP&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;},&lt;/span&gt;
		&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;mb&quot;&gt;1&#39;b0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;REF_ZEROS&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mb&quot;&gt;2&#39;b00&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CMD_NOOP&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;},&lt;/span&gt;
		&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;mb&quot;&gt;1&#39;b0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;REF_ZEROS&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mb&quot;&gt;2&#39;b00&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CMD_NOOP&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;},&lt;/span&gt;
		&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;mb&quot;&gt;1&#39;b0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;REF_ZEROS&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mb&quot;&gt;2&#39;b00&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CMD_NOOP&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;},&lt;/span&gt;
		&lt;span class=&quot;c1&quot;&gt;//
&lt;/span&gt;		&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;mb&quot;&gt;1&#39;b1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CK_REFRESH_NOOP_TO_ACTIVATE&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;},&lt;/span&gt;
		&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;mb&quot;&gt;1&#39;b0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;REF_ZEROS&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mb&quot;&gt;2&#39;b11&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CMD_NOOP&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;},&lt;/span&gt;
		&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;mb&quot;&gt;1&#39;b0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;REF_ZEROS&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mb&quot;&gt;2&#39;b11&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CMD_REFRESH&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;},&lt;/span&gt;
		&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;mb&quot;&gt;1&#39;b1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CK_PRECHARGE_TO_REFRESH&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;},&lt;/span&gt;
		&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;mb&quot;&gt;1&#39;b0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;REF_ZEROS&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mb&quot;&gt;2&#39;b11&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CMD_NOOP&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;},&lt;/span&gt;
		&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;mb&quot;&gt;1&#39;b0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;REF_ZEROS&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mb&quot;&gt;2&#39;b11&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CMD_PRECHARGE&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;},&lt;/span&gt;
		&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;mb&quot;&gt;1&#39;b1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CK_WAIT_FOR_IDLE&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;},&lt;/span&gt;
		&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;mb&quot;&gt;1&#39;b0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;REF_ZEROS&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mb&quot;&gt;2&#39;b01&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CMD_NOOP&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;},&lt;/span&gt;
		&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;mb&quot;&gt;1&#39;b1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CK_REMAINING&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;},&lt;/span&gt;
		&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;mb&quot;&gt;1&#39;b0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;REF_ZEROS&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mb&quot;&gt;2&#39;b00&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CMD_NOOP&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
		&lt;span class=&quot;c1&quot;&gt;//
&lt;/span&gt;		&lt;span class=&quot;c1&quot;&gt;// ...
&lt;/span&gt;		&lt;span class=&quot;c1&quot;&gt;//
&lt;/span&gt;		&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;refresh_controller&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i_clk&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;reset_active&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;
		&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;refresh_active&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;refresh_stall&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;refresh_cmd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This &lt;a href=&quot;https://github.com/ZipCPU/zipstormmx/blob/e4cb3e6f3bc3ac5831925b28116cb19b4ed09e8d/rtl/wbsdram.v#L622-L667&quot;&gt;implementation&lt;/a&gt;
is a little different: the refresh command is placed at the low order bits.
The next two most significant bits are a refresh stall, and a refresh active
bit.  In this case, &lt;code class=&quot;highlighter-rouge&quot;&gt;refresh_stall&lt;/code&gt; is an instruction to the bus controller
to stall any bus requests that might be coming into the controller.  That allows
us to flush any active requests through the processing pipeline until the
refresh commands become active and start to override the memory control.&lt;/p&gt;

&lt;p&gt;Let’s just scan through this command set briefly, skipping commands in our
broad-brush through it:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;We start in reset.  As long as the reset sequence is active, we hold the
controller in reset.&lt;/li&gt;
  &lt;li&gt;Once we come out of reset, we’ll issue a NOOP.  Remember, this is also our
initial values that we set our results to during the reset cycle as well.
More importantly, we let the design run normally following the reset
without overriding any normal operation.
We’ll do this for &lt;code class=&quot;highlighter-rouge&quot;&gt;CK_REMAINING +2&lt;/code&gt; clock cycles.  (The formula for this
duration is beyond the scope of this article, but easily verifiable from
within the core.)&lt;/li&gt;
  &lt;li&gt;When it’s finally time to start our refresh cycle, we’ll force the Wishbone
interface to stall.  We then wait &lt;code class=&quot;highlighter-rouge&quot;&gt;CK_WAIT_FOR_IDLE+2&lt;/code&gt; cycles for any
commands in process to flush through our interface and the bus to come to
a halt.&lt;/li&gt;
  &lt;li&gt;Then we issue a PRECHARGE (all) command to close any active memory banks.
This takes &lt;code class=&quot;highlighter-rouge&quot;&gt;CK_PRECHARGE_TO_REFRESH+2&lt;/code&gt; clock cycles to complete, so we issue
a &lt;code class=&quot;highlighter-rouge&quot;&gt;CMD_NOOP&lt;/code&gt; during these cycles.&lt;/li&gt;
  &lt;li&gt;We can finally issue the REFRESH command.  However, we can’t immediately
go back to using the interface.  Instead, we need to wait
&lt;code class=&quot;highlighter-rouge&quot;&gt;CK_REFRESH_NOOP_TO_ACTIVATE+2&lt;/code&gt; cycles before the memory is (almost) ready
to accept a command.&lt;/li&gt;
  &lt;li&gt;The next command clears any maintenance-induced bus stalls, and it also
clears our refresh cycle allowing the rest of the memory control to return
to bus control.&lt;/li&gt;
  &lt;li&gt;Sadly, though, we need to go through all of the listed commands–even though
we stopped early.  Therefore, we issue idle NOOP’s until we reach the end
of our list before starting over.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;As with the reset sequence, most of this follows from the
&lt;a href=&quot;http://www.issi.com/WW/pdf/42-45S16100H.pdf&quot;&gt;ISSI SDRAM specification&lt;/a&gt;.
It’s timing driven, and specifically driven to issue one reset at a time
every &lt;code class=&quot;highlighter-rouge&quot;&gt;N&lt;/code&gt; cycles as determined from the
&lt;a href=&quot;http://www.issi.com/WW/pdf/42-45S16100H.pdf&quot;&gt;specification&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;While I’m not going to argue that this “ultra-micro controller” forms a general
purpose computer, it does have many of the attributes of a more general
purpose computer: It follows a pre-defined “program” or script of instructions.
Each instruction has an “OpCode”.  In this case, the “OpCode” was either to
output a series of bits or to wait for a given count.  Unlike more general
purpose computers, this “ultra-micro controller” has no ability to add,
subtract, test values, or branch.  Still, it was good enough for today’s
purposes to be reused in two different DRAM controllers in two different
ways.&lt;/p&gt;

&lt;p&gt;Not only that, this simple example makes a great illustration of how you can
create a packet of information as instructions work their way through a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;’s pipeline,
and assert consistency with that pipeline along the way.  This is a very
useful pattern that you will likely see time and again when formally
verifying pipelines.&lt;/p&gt;

&lt;hr /&gt;&lt;p&gt;&lt;em&gt; And she said to the king, It was a true report that I heard in mine own land of thy acts and of thy wisdom.  Howbeit I believed not the words, until I came, and mine eyes had seen it: and, behold, the half was not told me: thy wisdom and prosperity exceedeth the fame which I heard. (1King 10:6-7)&lt;/em&gt;</description>
        <pubDate>Mon, 18 Nov 2019 00:00:00 -0500</pubDate>
        <link>https://zipcpu.com/formal/2019/11/18/genuctrlr.html</link>
        <guid isPermaLink="true">https://zipcpu.com/formal/2019/11/18/genuctrlr.html</guid>
        
        
        <category>formal</category>
        
      </item>
    
      <item>
        <title>Quiz #7: Returning to $past() and our counter again</title>
        <description>&lt;!-- answer: &quot;2019/08/23/fv-answer07.html&quot; --&gt;

&lt;p&gt;Let’s return to our counter example.  (No pun intended initially, but now
I can’t seem to avoid it.)&lt;/p&gt;

&lt;p&gt;In this case, we want to build a counter that will count down from 21, but
only upon request (&lt;code class=&quot;highlighter-rouge&quot;&gt;i_start_signal&lt;/code&gt;).  Once this counter gets to zero, the
counter stops counting down and waits for the next request.  Such counters
can be used in a whole variety of circumstances, my favorite being the
&lt;code class=&quot;highlighter-rouge&quot;&gt;clk_ctr&lt;/code&gt; in my updated
&lt;a href=&quot;/blog/2019/03/27/qflexpress.html&quot;&gt;QSPI flash controller&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;If you are an ASIC engineer and don’t like initial values, then feel free
to add reset logic to this example.&lt;/p&gt;

&lt;p&gt;What do you think, will the assertion above pass?&lt;/p&gt;
</description>
        <pubDate>Sat, 16 Nov 2019 00:00:00 -0500</pubDate>
        <link>https://zipcpu.com/quiz/2019/11/16/quiz07.html</link>
        <guid isPermaLink="true">https://zipcpu.com/quiz/2019/11/16/quiz07.html</guid>
        
        
        <category>quiz</category>
        
      </item>
    
      <item>
        <title>Putting the pieces together to build a data recorder</title>
        <description>&lt;p&gt;&lt;a href=&quot;/about/gisselquist-technology.html&quot;&gt;Gisselquist Technology&lt;/a&gt;,
LLC, makes its money primarily off of contract work.  I sell occasional licenses
to my IP cores, and occasionally teach students, but most of my income is
primarily coming from building designs for customers.&lt;/p&gt;

&lt;p&gt;How I got to this point as a small businessman is a topic for another day,
although one I would very much like to share.&lt;/p&gt;

&lt;p&gt;For today, though, I’d like to discuss a project I’ve recently been working on:
a basic data recorder.&lt;/p&gt;

&lt;p&gt;Well, that’s not quite it.  You can purchase data recorders on the market
for perhaps cheaper than my hours on this project.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 1. A basic communications channel&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/sdspi/comms-channel.svg&quot; alt=&quot;&quot; width=&quot;480&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;The actual purpose of the
project is to design and build a special SONAR communications system and
perhaps even a new waveform design to support it, but the first step to getting
such a project going is to be able to transmit through a steel medium and then
to receive the result on the other side.  The focus of this part of the project
was on successfully receiving the transmitted waveform.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 2. Digilent&#39;s Nexys Video Board&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/nexys-video.png&quot; alt=&quot;&quot; width=&quot;473&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Early on, &lt;a href=&quot;https://www.extremesonar.com&quot;&gt;my customer, ExtremeSonar&lt;/a&gt;, and I
chose a &lt;a href=&quot;https://store.digilentinc.com/nexys-video-artix-7-fpga-trainer-board-for-multimedia-applications/&quot;&gt;Nexys Video board&lt;/a&gt; for the task.  Why?
First, because I already had the board.  Second, because the FPGA on the board
was beefy–it’s really overkill for this project.  With such a large FPGA I
won’t have to worry about running out of logic along the way.  Third,
we chose this board because it’s an awesome all-around board for a lot of
things.  In other words, we though that this one board might serve us well
for multiple contracts.&lt;/p&gt;

&lt;h2 id=&quot;controlling-the-transmitter&quot;&gt;Controlling the Transmitter&lt;/h2&gt;

&lt;p&gt;The first part of the design was to build a transmitter that could select
between multiple different waveforms and waveform parameters as we measured
how the medium (solid steel) would respond to these various shapes.&lt;/p&gt;

&lt;p&gt;We had several waveforms we wanted to try.  Building the transmitter was easy,
and essentially done in an afternoon.&lt;/p&gt;

&lt;p&gt;Then I ran into my first problem: how shall the board be controlled?&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: left&quot;&gt;&lt;caption&gt;Fig 3. Switch-controlled Transmitter&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/sdspi/txmux.svg&quot; alt=&quot;&quot; width=&quot;360&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;The easy answer was to build a design that could be controlled via one or
more of the on-board switches.  This worked great at the beginning when I
wanted to try out four specific waveforms, but each waveform had parameters
to it: what modulation should be used?  What bit rate should be sent?  There
were also some hardware specific parameters as well associated with the energy
in the transmitted waveform.&lt;/p&gt;

&lt;p&gt;It didn’t take long before the sixteen switches on the board just weren’t
enough.&lt;/p&gt;

&lt;p&gt;My usual approach to solving this problem would be to connect a
&lt;a href=&quot;https://github.com/ZipCPU/dbgbus/tree/master/hexbus&quot;&gt;debugging bus&lt;/a&gt;
over the serial port and control the waveforms in as much detail as I wanted.&lt;/p&gt;

&lt;p&gt;My customer didn’t have access to my debugging bus software, nor did he want
that type of low-level access.  He wanted a design he could just “plug in”
that would then “just work.”&lt;/p&gt;

&lt;p&gt;My second approach to this would be to place a
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; on the FPGA so that it could
be configured in a more user friendly fashion over a serial port console.&lt;/p&gt;

&lt;p&gt;The problem with this approach is that, without the
&lt;a href=&quot;https://github.com/ZipCPU/dbgbus/tree/master/hexbus&quot;&gt;debugging bus&lt;/a&gt;,
I can’t load flash data into a design.  Specifically, I can’t load the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;’s software
on board.  Sure, Vivado would load a flash configuration into a design for
me–but would Vivado load a
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; program?  Yes, I suppose
I might’ve bit the bullet and placed a
&lt;a href=&quot;https://en.wikipedia.org/wiki/MicroBlaze&quot;&gt;MicroBlaze CPU&lt;/a&gt; within the design
and done just that.  As you’ll see later on in this article, there were good
reasons for not doing that.&lt;/p&gt;

&lt;p&gt;Instead, I chose to create a ROM memory device on board that would hold the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;’s
software and then control the transmitter from that.&lt;/p&gt;

&lt;p&gt;This worked great, and formed the substance of my first delivery.  The biggest
problem I had with that delivery was that the &lt;a href=&quot;https://ttssh2.osdn.jp/index.html&quot;&gt;serial port software my customer
was using&lt;/a&gt; didn’t support 2MBaud.  I suppose
this shouldn’t be such a surprise, 2MBaud isn’t really a common rate.  I was
more surprised to learn that it didn’t support the more common 115.2K Baud
either.  No, I’d need to run the project at 9600 Baud.  Still, for just a
basic console, this is plenty fast.  For transferring data?  Unacceptable, but
we haven’t gotten there yet.&lt;/p&gt;

&lt;h2 id=&quot;part-two-receive-data-processing&quot;&gt;Part Two: Receive Data Processing&lt;/h2&gt;

&lt;p&gt;Building a transmitter is easy.  Making it work with a receiver, that’s much
harder.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 4. Block Receiver Design&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/sdspi/initial-receiver.svg&quot; alt=&quot;&quot; width=&quot;540&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Early on in the project I started building such a receiver, much like the one
shown in Fig. 4 on the right.  However, when we started questioning how the
medium would respond to one data rate vs another, one waveform vs another, etc,
I had to abandon those plans.  The problem was that I wanted to build a
receiver for a waveform of a known symbol type and bit rate, and yet we didn’t
yet know if the channel would support either that symbol type and bit rate
or not.&lt;/p&gt;

&lt;p&gt;We chose instead to record data for offline processing, figuring that if we
could demonstrate an offline demodulator for such a data element then it would
be easier to place it onto an FPGA.&lt;/p&gt;

&lt;p&gt;In hindsight, this should’ve always been my approach from the beginning:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Build a simulation.&lt;/li&gt;
  &lt;li&gt;Demonstrate that the algorithms work in simulation.&lt;/li&gt;
  &lt;li&gt;Port the simulation to hardware&lt;/li&gt;
&lt;/ol&gt;

&lt;table align=&quot;center&quot; style=&quot;float: left&quot;&gt;&lt;caption&gt;Fig 5. Intermediate Design Step&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/sdspi/intermediate-block-processing.svg&quot; alt=&quot;&quot; width=&quot;360&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Therefore, I scrapped my early receiver drafts and focused instead on getting
sampled data I could use to feed such a simulation.&lt;/p&gt;

&lt;p&gt;Steel has some very real acoustic properties, and without knowing what those
were success might be a challenge.  Real data, however, required something
I didn’t yet have: a data recorder.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 6. Hardware goal: real-time processing&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/sdspi/goal-streaming.svg&quot; alt=&quot;&quot; width=&quot;360&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Once I had that data recorder, I could then prove any receiver algorithms
and then port the results to hardware.&lt;/p&gt;

&lt;p&gt;Today’s story is about building that data recorder.&lt;/p&gt;

&lt;h2 id=&quot;building-the-data-recorder&quot;&gt;Building the Data Recorder&lt;/h2&gt;

&lt;p&gt;Surely a data recorder would be fairly easy: The
&lt;a href=&quot;https://store.digilentinc.com/nexys-video-artix-7-fpga-trainer-board-for-multimedia-applications/&quot;&gt;Nexys Video board&lt;/a&gt;
has 512MB of SDRAM on it–plenty to stream data into.  Indeed, if I streamed
data into the board at a maximum speed of 800Mbps (well higher than any
desired data rate), there would then be enough room to record over 5s of
data before running out of SDRAM.  That’s plenty for any need we might have.
Not only that, since the
&lt;a href=&quot;https://store.digilentinc.com/nexys-video-artix-7-fpga-trainer-board-for-multimedia-applications/&quot;&gt;Nexys Video board&lt;/a&gt;
has a &lt;a href=&quot;https://en.wikipedia.org/wiki/SD_card&quot;&gt;micro-SD-Card&lt;/a&gt; slot on it, there
should be more than enough room on
any modern
&lt;a href=&quot;https://en.wikipedia.org/wiki/SD_card&quot;&gt;SD-Card&lt;/a&gt;
to hold any capture I might create.&lt;/p&gt;

&lt;p&gt;Ahh, the best laid plans of mice and men.&lt;/p&gt;

&lt;p&gt;This was where things started to go wrong.&lt;/p&gt;

&lt;p&gt;Sure, I had everything I needed to make this work early on, starting with my own
&lt;a href=&quot;https://github.com/ZipCPU/videozip&quot;&gt;Nexys Video&lt;/a&gt; design.  This should be
easy to modify for a commercial purpose.  Indeed, it had already been modified
to set up the transmitter.&lt;/p&gt;

&lt;p&gt;As built, the design already consisted of several “working” components.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;It had a &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;/blog/2019/03/27/qflexpress.html&quot;&gt;Flash Controller&lt;/a&gt;.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/ZipCPU/wb2axip/blob/master/rtl/wbm2axisp.v&quot;&gt;Wishbone to AXI
 bridge&lt;/a&gt;,
to control a MIG based DDR3 SDRAM controller&lt;/li&gt;
  &lt;li&gt;A &lt;a href=&quot;https://github.com/ZipCPU/wbuart32&quot;&gt;serial port&lt;/a&gt; based console, with a
&lt;a href=&quot;https://github.com/ZipCPU/dbgbus/tree/master/hexbus&quot;&gt;debugging bus&lt;/a&gt;
running over the non-printable character set&lt;/li&gt;
  &lt;li&gt;I also had a &lt;a href=&quot;https://github.com/ZipCPU/sdspi&quot;&gt;SPI-based SD Card controller&lt;/a&gt;
to use&lt;/li&gt;
  &lt;li&gt;And, of course, the SONAR transmit controller we had used earlier in the
project.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;This, however, left me missing a couple of key components.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;I needed a stream to WB recorder.  This was an easy build, and took me
a quiet and pleasant vacation morning to put together.  (Yes, I do enjoy
doing this kind of work on my vacations.)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt; didn’t (yet) handle building
projects with multiple masters very well.  However, this design required
the ability to add more than one bus master (the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
and the data recorder) to the design.  In the end, I chose to upgrade
&lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt;
rather than to manually add another bus arbiter to the design.&lt;/p&gt;

    &lt;p&gt;The new AutoFPGA upgrade offers the capability to add support for multiple
different bus protocols, and multiple bus masters.&lt;/p&gt;

    &lt;p&gt;This would be the first project to use the updated AutoFPGA support, so there
was a bit of risk involved to the project by doing this.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;I also needed a way to decode the &lt;a href=&quot;https://en.wikipedia.org/wiki/Design_of_the_FAT_file_system&quot;&gt;FAT
filesystem&lt;/a&gt;,
and to be able to write a file to the
&lt;a href=&quot;https://en.wikipedia.org/wiki/SD_card&quot;&gt;SD-Card&lt;/a&gt; using it.  After a bit of
googling, I found the
&lt;a href=&quot;http://elm-chan.org/fsw/ff/00index_e.html&quot;&gt;FATFS project&lt;/a&gt; which promised
to be able to handle any &lt;a href=&quot;https://en.wikipedia.org/wiki/File_system&quot;&gt;file system&lt;/a&gt; issues for me.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Looking over all of this, most of the work had already been done.  I was just
adding a couple minor components to the design.  What could go wrong?&lt;/p&gt;

&lt;h2 id=&quot;everything-fails-in-integration&quot;&gt;Everything Fails in Integration&lt;/h2&gt;

&lt;p&gt;What could go wrong?  Everything.&lt;/p&gt;

&lt;p&gt;The first problem was that I wanted C-library support to get &lt;code class=&quot;highlighter-rouge&quot;&gt;malloc()&lt;/code&gt;,
&lt;code class=&quot;highlighter-rouge&quot;&gt;free()&lt;/code&gt;, as well as &lt;code class=&quot;highlighter-rouge&quot;&gt;printf()&lt;/code&gt; and its friends.  However, the
&lt;a href=&quot;https://sourceware.org/newlib/&quot;&gt;newlib C-library&lt;/a&gt; that I’ve been using
didn’t fit in the 64-kB block RAM image I had allocated for myself in ROM.
Normally this wouldn’t be an issue, as I would’ve just stored any
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
software on &lt;a href=&quot;/blog/2019/03/27/qflexpress.html&quot;&gt;flash&lt;/a&gt;
and then loaded the software from
&lt;a href=&quot;/blog/2019/03/27/qflexpress.html&quot;&gt;flash&lt;/a&gt;
to SDRAM early on.  There was certainly plenty of room on the on-board
&lt;a href=&quot;/blog/2019/03/27/qflexpress.html&quot;&gt;flash&lt;/a&gt;
chip for any software I might create, so this isn’t (normally) a problem.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: left&quot;&gt;&lt;caption&gt;Fig 7. Copying Software from an SD-Card&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/sdspi/sw-bootload.svg&quot; alt=&quot;&quot; width=&quot;480&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;My customer, however, didn’t have my &lt;a href=&quot;https://github.com/ZipCPU/dbgbus/tree/master/hexbus&quot;&gt;debugging
tools&lt;/a&gt;, nor did he want
that kind of access.  This left me with no means of getting any software onto
the flash memory within his board.  (We’re not co-located.)  I chose instead
to load an SDRAM image from a file on an
&lt;a href=&quot;https://en.wikipedia.org/wiki/SD_card&quot;&gt;SD-Card&lt;/a&gt;,
as shown in Fig. 7 on the left, and then to boot the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; from that
image.  This gave me as much code room as I wanted, but required using a
special program to load the file into SDRAM–a program that would need to
be built into the design itself in a special “Boot ROM” device.&lt;/p&gt;

&lt;p&gt;Once this program loaded the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;’s
software into SDRAM, the main program would begin–allowing the user to control
waveform types, parameters, and the ability to save files to an
&lt;a href=&quot;https://en.wikipedia.org/wiki/SD_card&quot;&gt;SD-Card&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;step-one-gathering-files&quot;&gt;Step One: Gathering Files&lt;/h2&gt;

&lt;p&gt;The problem with “working designs” is that they change over time.  Worse, it
had been a long time since I had worked with &lt;a href=&quot;https://github.com/ZipCPU/videozip&quot;&gt;my “working” Nexys Video
design&lt;/a&gt;.  So, to start this project, I
copied all of the files from &lt;a href=&quot;https://github.com/ZipCPU/videozip&quot;&gt;my “working” Nexys Video
design&lt;/a&gt;,
and then updated them with any changes that had been made since that design.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;The &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; had significantly changed
and gotten better.  Among other things, it now had a &lt;a href=&quot;https://github.com/ZipCPU/blob/master/rtl/core/dcache.v&quot;&gt;data
cache&lt;/a&gt; available to
me.  Even better, since this FPGA had so much logic, there was plenty of room
for it as well.&lt;/li&gt;
  &lt;li&gt;The &lt;a href=&quot;/blog/2019/03/27/qflexpress.html&quot;&gt;flash driver had completely been rewritten&lt;/a&gt;.&lt;/li&gt;
  &lt;li&gt;The &lt;a href=&quot;https://github.com/ZipCPU/wb2axip/blob/master/rtl/wbm2axisp.v&quot;&gt;Wishbone to AXI
bridge&lt;/a&gt; had been
completely rewritten, and now enjoyed full formal verification
support–something the original driver had never had&lt;/li&gt;
  &lt;li&gt;The &lt;a href=&quot;https://github.com/ZipCPU/sdspi&quot;&gt;SDSPI controller&lt;/a&gt;, the one that will
control an &lt;a href=&quot;https://en.wikipedia.org/wiki/SD_card&quot;&gt;SD-Card&lt;/a&gt;.
using a SPI based protocol, had been modified to add
75-clocks to it to allow any logic within the
&lt;a href=&quot;https://en.wikipedia.org/wiki/SD_card&quot;&gt;SD-Card&lt;/a&gt; to start up&lt;/li&gt;
  &lt;li&gt;I only really needed to remove the HDMI support that — had never yet
worked anyway.&lt;/li&gt;
  &lt;li&gt;Also, on &lt;a href=&quot;https://github.com/ZipCPU/zipversa&quot;&gt;my last project&lt;/a&gt;, I had updated
my favorite debugging bus implementation, fixing some &lt;a href=&quot;/formal/2019/10/05/formal-enough.html&quot;&gt;significant bugs in
the compression
algorithm&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;All of this code was easily copied into the new design.  It gave me a lot to
start from.  Even better, all of this code had worked in FPGAs before, so I had
a strong confidence that it would work again.  Sadly, not all of it had been
formally verified.  As a result, there were land mines within this design that
I was just completely unaware of.&lt;/p&gt;

&lt;h2 id=&quot;step-one-simulation&quot;&gt;Step One: Simulation&lt;/h2&gt;

&lt;p&gt;The first step to building something like this was to run the design in
simulation and so to demonstrate that it works in simulation alone.  To make
this happen, I set up two basic simulation setups.  The first simulation would
run a given program–such as my data collector, and the second simulation
would run the boot loader.  Selecting between them was as easy as adding a
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
program name to the command line.&lt;/p&gt;

&lt;p&gt;From these two, my goal was to demonstrate the ability to boot the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; from the
&lt;a href=&quot;https://en.wikipedia.org/wiki/SD_card&quot;&gt;SD-Card&lt;/a&gt;,
and then to collect and write/store data to the &lt;a href=&quot;https://en.wikipedia.org/wiki/File_system&quot;&gt;file system&lt;/a&gt;.  I would do this
first in simulation, then on the actual board.&lt;/p&gt;

&lt;h3 id=&quot;connectivity-tests&quot;&gt;Connectivity Tests&lt;/h3&gt;

&lt;p&gt;Normally, I use a &lt;a href=&quot;/zipcpu/2018/02/12/zbasic-intro.html&quot;&gt;small CPU testing
program&lt;/a&gt; as my way of
shaking out a new design.  However, as I got to thinking about this, &lt;a href=&quot;https://github.com/ZipCPU/videozip/blob/master/sw/board/cputest.c&quot;&gt;my CPU
testing program&lt;/a&gt;
does nothing to test the rest of the design.  Therefore, I chose to create
an additional connectivity checking program–one that would attempt to interact
with every peripheral within the design and verify that all of the peripherals
could be interacted with.&lt;/p&gt;

&lt;p&gt;For the most part, this piece of the software worked by 1) reading from some
piece of memory, 2) writing a new value to it, 3) verifying that the value
was expected, and then 3) returning the value written to its original form.
Values chosen included all ones, all zeros, and a variety of patterns in
between to make certain all bits could be written and all bytes could be
written individually.&lt;/p&gt;

&lt;p&gt;I did this because it just felt like “good practice”.  It also felt like a
complete waste of time, but for the sake of “good practice” I did it anyway.&lt;/p&gt;

&lt;p&gt;In hind sight, I’m glad I chose this step.  Much to my surprise, there were
still bugs in the new AutoFPGA bus logic generation algorithms.  This
connectivity test helped flush out those bugs during simulation testing.  Later
on, once everything was passing properly, this connectivity checking program
became a confidence builder that my design still worked following any changes.&lt;/p&gt;

&lt;p&gt;Indeed, I’m likely to make this kind of connectivity test a standard practice
with any new design I build.  Having one built now will make building the next
one easier.&lt;/p&gt;

&lt;h3 id=&quot;sd-card-controller&quot;&gt;SD-Card Controller&lt;/h3&gt;

&lt;p&gt;Now, after all that I’ve learned about digital design, I’m embarrassed to say
that my &lt;a href=&quot;https://github.com/ZipCPU/sdspi/330888ad0474293f87773d6091f097cefa2c9430&quot;&gt;SPI based SD-Card
controller&lt;/a&gt; was woefully inadequate to the task.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 8. A XuLA2-LX25 Board from Xess&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/XuLA2.png&quot; alt=&quot;&quot; width=&quot;250&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Yes, it had been &lt;a href=&quot;https://github.com/ZipCPU/xulalx25soc&quot;&gt;tested in hardware&lt;/a&gt;
before.  In hardware, I had demonstrated the ability to read a sector, to
write all ones or all zeros to the sector, and then to return it to its
original value.  Sadly, this test was far from automated.  As a result, if
I didn’t have that original
&lt;a href=&quot;http://www.xess.com/shop/product/xula2-lx25&quot;&gt;XuLA2-LX25&lt;/a&gt; on my desk (it was
in a drawer), nor did I have ISE up and running to build my design, then I
couldn’t repeat the test and verify that any changes still worked.&lt;/p&gt;

&lt;p&gt;Of course, since using the design in that initial project, the
&lt;a href=&quot;https://github.com/ZipCPU/sdspi&quot;&gt;SDSPI controller&lt;/a&gt; needed to be modified.
Among other things, &lt;a href=&quot;https://github.com/ZipCPU/sdspi/issues/1&quot;&gt;someone was kind enough to point out to me that the 
SD-Card protocol requires 75 clocks be sent to the device before any attempt at
interacting with it&lt;/a&gt;.  In it’s
&lt;a href=&quot;https://github.com/ZipCPU/xulalx25soc/blob/master/rtl/sdspi.v&quot;&gt;previous incarnation&lt;/a&gt;,
the &lt;a href=&quot;https://en.wikipedia.org/wiki/SD_card&quot;&gt;SD-Card&lt;/a&gt;
shared SPI pins with the flash chip or I might have noticed this
clocking need.  However, I dutifully made the change to be compliant with the
SD specification.&lt;/p&gt;

&lt;p&gt;In the process, I realized that the SPI arbitration code really wasn’t all that
relevant anymore.  I couldn’t properly remove it, since I have at least &lt;a href=&quot;https://github.com/ZipCPU/xulalx25soc&quot;&gt;one
design that uses it&lt;/a&gt;, but that didn’t
mean I couldn’t parameterize and thus remove the logic for those designs that
didn’t need it.  Just to make sure I did it right, I started adding formal
properties to the lower-level design component where I was making changes.&lt;/p&gt;

&lt;p&gt;To make this controller work, I created a &lt;a href=&quot;https://github.com/ZipCPU/sdspi/blob/eadca4b1a5034c7825cd4a6366b4da0e5ae369bc/sw/sdcard.c&quot;&gt;low-level software driver&lt;/a&gt; with
three basic functions: &lt;code class=&quot;highlighter-rouge&quot;&gt;sdcard_init()&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;sdcard_read(sector, buffer)&lt;/code&gt;, and
&lt;code class=&quot;highlighter-rouge&quot;&gt;sdcard_write(sector, buffer)&lt;/code&gt;.  I also created a &lt;a href=&quot;https://github.com/ZipCPU/sdspi/blob/eadca4b1a5034c7825cd4a6366b4da0e5ae369bc/sw/diskio.c&quot;&gt;DiskIO wrapper&lt;/a&gt;
for the &lt;a href=&quot;http://elm-chan.org/fsw/ff/00index_e.html&quot;&gt;FATFS&lt;/a&gt; library.  This then
provided a basic hardware abstraction layer to access the &lt;code class=&quot;highlighter-rouge&quot;&gt;sdcard_*&lt;/code&gt; functions.&lt;/p&gt;

&lt;p&gt;For simulation work, I had long ago built an &lt;a href=&quot;https://github.com/ZipCPU/sdspi/blob/eadca4b1a5034c7825cd4a6366b4da0e5ae369bc/bench/cpp/sdspisim.cpp&quot;&gt;SD-Card
emulator&lt;/a&gt;.  To use the
&lt;a href=&quot;https://github.com/ZipCPU/sdspi/blob/eadca4b1a5034c7825cd4a6366b4da0e5ae369bc/bench/cpp/sdspisim.cpp&quot;&gt;emulator&lt;/a&gt;, you’d need to create a file
on your system which would become the image of the entire
&lt;a href=&quot;https://en.wikipedia.org/wiki/SD_card&quot;&gt;SD-Card&lt;/a&gt;’s storage.
A &lt;a href=&quot;https://en.wikipedia.org/wiki/File_system&quot;&gt;file system&lt;/a&gt; could then be placed onto this image.  This made adding
a &lt;a href=&quot;https://en.wikipedia.org/wiki/File_system&quot;&gt;file system&lt;/a&gt; to my controller fairly easy to do.&lt;/p&gt;

&lt;p&gt;Of course, I expected this to “just work”, right?  Since it was “working code”
from a prior project (ignore the modifications), it should “just work.”&lt;/p&gt;

&lt;p&gt;I was caught by surprise several times during this simulation exercise, however,
when code that used to “just work” didn’t “just work” anymore.&lt;/p&gt;

&lt;p&gt;First, the &lt;a href=&quot;http://elm-chan.org/fsw/ff/00index_e.html&quot;&gt;FATFS library&lt;/a&gt; didn’t
recognize the &lt;a href=&quot;https://en.wikipedia.org/wiki/File_system&quot;&gt;file system&lt;/a&gt; I had on my disk image.  I remember just sitting at
my desk, staring at this error, and not knowing where to start to deal
with it.  I tried Voodoo logic: changing what wasn’t broken in an effort to fix
what is.  It didn’t help.  (I appealed to Voodoo logic many more times as the
project went on.  While it made me feel like I was doing something productive,
it never really helped.)  Eventually, I instrumented the
&lt;a href=&quot;http://elm-chan.org/fsw/ff/00index_e.html&quot;&gt;FATFS library&lt;/a&gt; through and through
only to discover when it read the first sector from the
&lt;a href=&quot;https://en.wikipedia.org/wiki/SD_card&quot;&gt;SD-Card&lt;/a&gt;,
the controller duplicated the first word and never returned the last word.
Since the last word contained the magic number &lt;code class=&quot;highlighter-rouge&quot;&gt;16&#39;h55aa&lt;/code&gt;, and since
&lt;a href=&quot;http://elm-chan.org/fsw/ff/00index_e.html&quot;&gt;FATFS&lt;/a&gt; never found it,
&lt;a href=&quot;http://elm-chan.org/fsw/ff/00index_e.html&quot;&gt;FATFS&lt;/a&gt; couldn’t find my
&lt;a href=&quot;https://en.wikipedia.org/wiki/File_system&quot;&gt;file system&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Of course, since this was in simulation, I was able to quickly chase this down
to the controller requiring two clocks to read a value from
it’s memory (i.e. the data read from the card), yet the Wishbone ACK was set
one clock (not two clocks) after the request.  I’d never encountered this bug
before, since I’d never read from the controller as fast as my DMA could–I had
done most of my testing via my &lt;a href=&quot;/2017/06/05/wb-bridge-overview.html&quot;&gt;slower Wishbone-over UART debugging
bus&lt;/a&gt;
approach.  High speed production reads?  Never really tested.&lt;/p&gt;

&lt;p&gt;Then, I was caught by surprise again when I discovered that my
&lt;a href=&quot;https://en.wikipedia.org/wiki/SD_card&quot;&gt;SD-Card&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/sdspi/blob/master/bench/cpp/sdspisim.cpp&quot;&gt;emulator&lt;/a&gt;
had no write capability.  Sure, you could issue write commands successfully,
but the emulator never wrote them to the file backed image.&lt;/p&gt;

&lt;p&gt;After these many changes, I really wanted to formally verify my
&lt;a href=&quot;https://en.wikipedia.org/wiki/SD_card&quot;&gt;SD-Card&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/sdspi/blob/e3d46ab24f79b62544fb11a49de77504bbdab83f/rtl/sdspi.v&quot;&gt;controller&lt;/a&gt;
Sadly, the logic was too complex.  I couldn’t get
&lt;a href=&quot;/blog/2018/03/10/induction-exercise.html&quot;&gt;induction&lt;/a&gt; to pass.
Worse, since it since it had been so many years since I had written the design,
I struggled to get a grasp on what properties to add.&lt;/p&gt;

&lt;p&gt;Nevertheless, I made the changes required and pushed forwards with using
this controller–since it had worked in hardware sometime before.&lt;/p&gt;

&lt;h3 id=&quot;the-zipcpu-and-the-zipsystem&quot;&gt;The ZipCPU and the ZipSystem&lt;/h3&gt;

&lt;table align=&quot;center&quot; style=&quot;float: left&quot;&gt;&lt;caption&gt;Fig 9. The components of the ZipSystem CPU wrapper&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/zipsystem.svg&quot; alt=&quot;&quot; width=&quot;360&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;The &lt;a href=&quot;/zipcpu/2018/01/31/cpu-build.html&quot;&gt;ZipSystem&lt;/a&gt; is a name
I have for an &lt;a href=&quot;https://github.com/ZipCPU/blob/master/rtl/zipsystem.html&quot;&gt;external
wrapper&lt;/a&gt; to the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; that
contains a set of &lt;a href=&quot;/zipcpu/2018/04/17/ziptimer.html&quot;&gt;timers&lt;/a&gt;,
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/zipcounter.v&quot;&gt;counters&lt;/a&gt;,
and possibly even a &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/wbdmac.v&quot;&gt;DMA
controller&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Some time back, when doing my
&lt;a href=&quot;/blog/2019/07/17/crossbar.html&quot;&gt;crossbar&lt;/a&gt; work, I realized
that there was a &lt;a href=&quot;/zipcpu/2019/03/28/return-decoding.html&quot;&gt;better way to write return decoders that used less
logic&lt;/a&gt;.  Since
that time,
&lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt;’s logic generator has been
updated to take advantage of this new method.  Seeing that the
&lt;a href=&quot;/zipcpu/2018/01/31/cpu-build.html&quot;&gt;ZipSystem&lt;/a&gt;
still used the old method of determining returns, I upgraded that too.&lt;/p&gt;

&lt;p&gt;The &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; also had a new
hold-in-reset counter.  Some FPGAs, notably the iCE40s, require some number
of clocks before the block RAMs can be used.  While not really needed for
this design, this was the last “working” version of the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; so I copied it into this
project.  Surely such an extra “feature” wouldn’t hurt, right?&lt;/p&gt;

&lt;p&gt;Finally, since I had last worked with my &lt;a href=&quot;https://github.com/ZipCPU/videozip&quot;&gt;VideoZip example
design&lt;/a&gt;, I’d built
(and formally verified) a &lt;a href=&quot;https://github.com/ZipCPU/blob/master/rtl/core/dcache.v&quot;&gt;data
cache&lt;/a&gt; for
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;my CPU&lt;/a&gt;.  Surely this was the time to use
it, since I had both a beefy FPGA and room to spare, right?&lt;/p&gt;

&lt;p&gt;The first problem with these changes was they broke my ability to simulate a
specific software program design.  Instead, the simulation would always start
at the reset address–regardless of whether or not I told it to start elsewhere.&lt;/p&gt;

&lt;p&gt;A quick look into the
&lt;a href=&quot;/blog/2017/07/31/vcd.html&quot;&gt;VCD file&lt;/a&gt;
generated by the simulation revealed the problem was with the new
“hold-in-reset” capability.  My top-level simulation script requires the
ability to overwrite the CPUs first instruction address, in order to guarantee
the CPU starts at the right value–wherever it might be in memory, flash, or
SDRAM.  However, if the CPU remained in reset, then any time I’d overwrite the value it would get
overwritten again with the default reset address before the CPU started.&lt;/p&gt;

&lt;p&gt;This was annoying, but certainly fixable.&lt;/p&gt;

&lt;h2 id=&quot;atoi11&quot;&gt;atoi(“11”)&lt;/h2&gt;

&lt;p&gt;One of the strangest bugs I came across along the way had to deal with
&lt;code class=&quot;highlighter-rouge&quot;&gt;atoi(&quot;11&quot;);&lt;/code&gt; returning the wrong value.&lt;/p&gt;

&lt;p&gt;This one really threw me for a loop.  I couldn’t figure out why the library
code would be broken.  I mean, &lt;code class=&quot;highlighter-rouge&quot;&gt;atoi(&quot;11&quot;)&lt;/code&gt; should be pretty basic, right?&lt;/p&gt;

&lt;p&gt;The good news with this bug is that the
&lt;a href=&quot;https://sourceware.org/newlib/&quot;&gt;newlib library&lt;/a&gt; I use is fully open
source.  That meant that I could modify it if I wanted to.  So, I added some
&lt;code class=&quot;highlighter-rouge&quot;&gt;NOUT&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;NDUMP&lt;/code&gt; instructions to announce to the console where it was in the
code, and what various values were along the way.  If you don’t &lt;a href=&quot;/zipcpu/2018/01/01/zipcpu-isa.html&quot;&gt;remember these
instructions&lt;/a&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;NOUT&lt;/code&gt;
and it’s simulation only &lt;code class=&quot;highlighter-rouge&quot;&gt;SOUT&lt;/code&gt; variant can be used to
print characters to the simulation console.  &lt;code class=&quot;highlighter-rouge&quot;&gt;NDUMP&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;SDUMP&lt;/code&gt; are similar,
save that they print register values to the console.  &lt;code class=&quot;highlighter-rouge&quot;&gt;NSTR&lt;/code&gt; is a similar
instruction used to print out strings.  For example, &lt;code class=&quot;highlighter-rouge&quot;&gt;NSTR &quot;Hello, World\r\n&quot;&lt;/code&gt;
would cause the simulator to print “Hello, World” to the console.
This &lt;code class=&quot;highlighter-rouge&quot;&gt;NSTR&lt;/code&gt; “instruction” is actually a pseudo instruction intercepted by the
assembler and then expanded into a sequence of &lt;code class=&quot;highlighter-rouge&quot;&gt;NOUT&lt;/code&gt; instructions.
If done right, these instructions won’t modify register assignment at all.&lt;/p&gt;

&lt;p&gt;Indeed, I found myself using these options so much I created macros to make
placing these instructions into a piece of code even easier:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span class=&quot;cp&quot;&gt;#define NSTR(A)         asm(&quot;NSTR \&quot;&quot; A &quot;\\n\&quot;&quot;)
#define NVAL(V)	\
	do {							\
		unsigned tmp = (unsigned)(V);			\
		asm volatile(&quot;NDUMP %0&quot;:&quot;=r&quot;(tmp):&quot;0&quot;(tmp));	\
	} while(0)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;With these modifications, I was able to chase the problem down to two opcodes.&lt;/p&gt;

&lt;p&gt;The first bug had to do with the &lt;code class=&quot;highlighter-rouge&quot;&gt;muldi3&lt;/code&gt; GCC opcode.  As part of the backend
port, the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/bd6c82b0e0eb88537f833146c79a4216f4858250/sw/gcc-zippatch.patch#L3809-#L3836&quot;&gt;needed to implement a &lt;code class=&quot;highlighter-rouge&quot;&gt;muldi3&lt;/code&gt; instruction&lt;/a&gt;.
Such an instruction needed to take two ‘di’ (64-bit) values and multiply them
together.  Since the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; only
supports 32x32-&amp;gt;64 bit multiplies, the 64x64 bit multiply needed to be converted
into component 32-bit parts, each multiplied separately, and then assembled
back into a 64-bit result.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 10. Splitting a 64-bit multiply into 32-bit multiplies&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/sdspi/muldi3.png&quot; alt=&quot;&quot; width=&quot;502&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Doing these component multiplies requires several registers.  First, it needs
two registers for each of the incoming operands.  Let’s call these &lt;code class=&quot;highlighter-rouge&quot;&gt;H1:L1&lt;/code&gt;
and again &lt;code class=&quot;highlighter-rouge&quot;&gt;H2:L2&lt;/code&gt;.  Further, the way I had written up the algorithm initially,
it also required to scratch registers, &lt;code class=&quot;highlighter-rouge&quot;&gt;S0&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;S1&lt;/code&gt; that I could use however
I wanted to.  Much to my surprise, however, I found that GCC was only giving
me four registers: the two scratch registers were already &lt;code class=&quot;highlighter-rouge&quot;&gt;H2&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;L2&lt;/code&gt;!
When I then used these scratch registers mid-algorithm I corrupted the
values I was multiplying.&lt;/p&gt;

&lt;p&gt;I rewrote the algorithm here, and so you can see it summarized below.  Imagine
that H0 and L0 are replaced by one of the operands, and H1 and L1 are replaced
by the other.  The result is placed into H0:L0.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-asm&quot; data-lang=&quot;asm&quot;&gt;	MOV	L1,L0
	MPY	L1,L0	;	L0 = L1^2
	MOV	H1,H0
	MPY	L1,H0	;	H0 = L1 * H1
	LSL	1,H0	;	H0 = (L1 * H1)*2
	MPYUHI	L1,L1
	ADD	L1,H0&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;(GCC actually requires a &lt;code class=&quot;highlighter-rouge&quot;&gt;%&lt;/code&gt; before each of these place-holder register
names.)&lt;/p&gt;

&lt;p&gt;Yes, I do put comments into my GCC generated assembly.  It really helps
debug the assembly later when you start trying to figure out what GCC was
doing.&lt;/p&gt;

&lt;p&gt;The second bug was an unsigned &lt;code class=&quot;highlighter-rouge&quot;&gt;A &amp;gt;= B&lt;/code&gt; comparison.  Since the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
didn’t initially support unsigned &lt;code class=&quot;highlighter-rouge&quot;&gt;A &amp;gt;= B&lt;/code&gt; comparisons, the GCC backend needed
to &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/bd6c82b0e0eb88537f833146c79a4216f4858250/sw/gcc-zippatch.patch#L13190-L13211&quot;&gt;silently convert these into “equivalent” &lt;code class=&quot;highlighter-rouge&quot;&gt;A +1 &amp;gt; B&lt;/code&gt; comparisons&lt;/a&gt; which the 
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; supported.  The problem, however,
is that if &lt;code class=&quot;highlighter-rouge&quot;&gt;A&lt;/code&gt; is the maximum positive value, then
&lt;code class=&quot;highlighter-rouge&quot;&gt;(Maximum positive value) &amp;gt;= B&lt;/code&gt; doesn’t have the same meaning as &lt;code class=&quot;highlighter-rouge&quot;&gt;0 &amp;gt; B&lt;/code&gt;,
where &lt;code class=&quot;highlighter-rouge&quot;&gt;0&lt;/code&gt; is the &lt;code class=&quot;highlighter-rouge&quot;&gt;(Maximum positive value)&lt;/code&gt; plus one.&lt;/p&gt;

&lt;p&gt;One of the failings of my current GCC backend is that I’m not using any of
GCC’s regression test suite.  This was originally due to the fact that the 
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; didn’t
have &lt;a href=&quot;https://sourceware.org/newlib/&quot;&gt;C-library&lt;/a&gt;
support due to a lack of 8-bit byte support.  (The
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; originally supported only
32-bit bytes.) Now that the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; supports the full C-library via
&lt;a href=&quot;https://sourceware.org/newlib/&quot;&gt;Newlib&lt;/a&gt;, I really should go back and enable
the automated testing to find problems like this earlier.&lt;/p&gt;

&lt;p&gt;One of the other “bugs” I finally dealt with in this design was a frustration
I’ve often had with the &lt;code class=&quot;highlighter-rouge&quot;&gt;SIM&lt;/code&gt; instructions.  &lt;code class=&quot;highlighter-rouge&quot;&gt;SIM&lt;/code&gt; instructions are what I refer
to the class of instructions just for the simulator, containing the &lt;code class=&quot;highlighter-rouge&quot;&gt;NOUT&lt;/code&gt;
and &lt;code class=&quot;highlighter-rouge&quot;&gt;NDUMP&lt;/code&gt; instructions I was using among other things.  Because of how they
were implemented, before any conditional checks, it was possible that a prior
branch instruction would execute and then the SIM instruction would execute
anyway.&lt;/p&gt;

&lt;p&gt;For example, in the following code, &lt;code class=&quot;highlighter-rouge&quot;&gt;R1&lt;/code&gt; should only be printed if the &lt;code class=&quot;highlighter-rouge&quot;&gt;Z&lt;/code&gt;
(zero) condition code isn’t set.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-asm&quot; data-lang=&quot;asm&quot;&gt;	BZ	_some_target
	NDUMP	R1&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The problem was that these special &lt;code class=&quot;highlighter-rouge&quot;&gt;SIM&lt;/code&gt; instructions were getting retired
prior to the last pipeline stage, and might possibly get eliminated by a
jump at the last stage.&lt;/p&gt;

&lt;p&gt;This time, I finally got fed up with the bug enough to fix it.  (The fix
hasn’t been backported yet …)  I pushed the &lt;code class=&quot;highlighter-rouge&quot;&gt;SIM&lt;/code&gt; instruction information
into the ALU pipeline stage, not just the read-operand stage, and so hopefully
I’ve fixed this for all time–or at least until I try running my next design.&lt;/p&gt;

&lt;h3 id=&quot;stream-recorder&quot;&gt;Stream Recorder&lt;/h3&gt;

&lt;p&gt;The stream recorder used by this project was a new core of mine.  It wasn’t all
that hard to create, and I managed to verify it and build it within about 6 hrs
of work or so.  In many ways, it’s very similar to my &lt;a href=&quot;https://github.com/ZipCPU/wb2axip/blob/master/rtl/axis2mm.v&quot;&gt;AXI stream to memory
bridge&lt;/a&gt;–although
that one took closer to 20hrs of work to build and verify.&lt;/p&gt;

&lt;p&gt;Time is money, right?  See why I like
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;Wishbone&lt;/a&gt;?  It’s so much
easier to work with.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: left&quot;&gt;&lt;caption&gt;Fig 11. The high-bandwidth 128-bit bus&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/sdspi/membus.svg&quot; alt=&quot;&quot; width=&quot;480&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;After building this stream processing core, I decided that I really wanted a
high speed access to my SDRAM device.  Therefore, I connected this to a
128-bit &lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;Wishbone&lt;/a&gt;
bus that contained only the SDRAM memory slave as shown in Fig. 11 on the
left.  Normally, I just use 32-bit
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;Wishbone&lt;/a&gt;
buses for everything, but if I wanted to record
800Mbps of data–why not use the full memory data rate?&lt;/p&gt;

&lt;p&gt;With the new AutoFPGA updates, AutoFPGA could now handle creating a special
128-bit bus with two masters on it–my normal 32-bit bus with a bus-expander
on it, and the stream recorder.&lt;/p&gt;

&lt;p&gt;Of course, this meant that my memory emulator needed updates as well, since
most desktops can’t handle 128-bit words natively.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 12. Memory address misalignment&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/sdspi/malloc-chunk.svg&quot; alt=&quot;&quot; width=&quot;360&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;My design then worked perfectly!  Perfectly, that is, until I tried to use the
recorder.  As it turns out, I had forgotten that the Stream to WB capability
required an &lt;em&gt;aligned&lt;/em&gt; address, and connecting it to a 128-bit bus meant that
it now needed a 128-bit aligned address.  Malloc only generated a word-aligned
(i.e. 32-bit aligned) addresses for me.  If I then used the recorder with this
not-quite-aligned address, it would overwrite the malloc
data structure, as shown in Fig. 12, and then the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt;
would crash when I tried to &lt;code class=&quot;highlighter-rouge&quot;&gt;free()&lt;/code&gt; the memory later.&lt;/p&gt;

&lt;p&gt;Ouch!&lt;/p&gt;

&lt;p&gt;Again, think of where you’d look for this bug: In the new Stream2WB core?  Or
in the &lt;code class=&quot;highlighter-rouge&quot;&gt;free()&lt;/code&gt; library call that failed with the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_(computing)&quot;&gt;bus&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_error&quot;&gt;error&lt;/a&gt;?&lt;/p&gt;

&lt;p&gt;It’s easy to write about these bugs today, long after they were found, but
finding where to look for them in the first place was a real
challenge–especially given that I was under a lot of schedule pressure.&lt;/p&gt;

&lt;p&gt;In my case, that meant generating a
&lt;a href=&quot;/blog/2017/07/31/vcd.html&quot;&gt;VCD trace&lt;/a&gt;
starting from CPU startup through stream to memory data write and the following
memory &lt;code class=&quot;highlighter-rouge&quot;&gt;free()&lt;/code&gt; where the CPU would stop on a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_(computing)&quot;&gt;bus&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_error&quot;&gt;error&lt;/a&gt;.
I could then read off the instruction pointer from the CPU
&lt;a href=&quot;/blog/2017/07/31/vcd.html&quot;&gt;trace&lt;/a&gt;,
but it pointed to
&lt;a href=&quot;https://sourceware.org/newlib/&quot;&gt;newlib&lt;/a&gt; library code that, when I stared at
the disassembly of, I wasn’t familiar with.  When I examined the
&lt;a href=&quot;https://sourceware.org/newlib/&quot;&gt;newlib&lt;/a&gt; code responsible, I couldn’t
see any bugs–so what happened to this memory value?  When did it get changed?&lt;/p&gt;

&lt;p&gt;To find this, I adjusted my test-bench wrapper to check that memory address
and report any changes to it.  I could then see the address given the “right”
value, and then get overwritten with the wrong value.  The time-stamp of this
change pointed me to time in the
&lt;a href=&quot;/blog/2017/07/31/vcd.html&quot;&gt;VCD trace&lt;/a&gt;
when the recorder just started recording–and then I had one of those forehead
smacking moments, when I realized the core was doing just what I had designed
it to do but that since designing it to do that I had forgotten about the
reality that it didn’t support unaligned transfers.&lt;/p&gt;

&lt;h2 id=&quot;step-two-hardware&quot;&gt;Step Two: Hardware&lt;/h2&gt;

&lt;p&gt;That was a lot of bugs to find in “working” code!  I’m thankful that I was able
to find those in simulation.  I’m not sure how I would’ve found all of those
in actual hardware.  The result, however, was that the design now worked in
simulation, and so it was time to move to hardware.&lt;/p&gt;

&lt;p&gt;I suppose I should’ve been excited at the prospect of moving to hardware.  I
wasn’t.  I’m often reluctant to leave simulation, simply because once the
design “works” in simulation it then “works”, right?  Only two things can
happen in hardware.  Either it continues to “just work” (not likely), or the
harder hardware debugging starts.&lt;/p&gt;

&lt;p&gt;I had no choice, I was getting paid, so I bit the bullet and started my design
in hardware–but not after enjoying a quiet weekend, Friday night movie, etc.
I certainly needed a break to celebrate my “success” while it lasted.&lt;/p&gt;

&lt;p&gt;When I then ran the design in hardware, it crashed so hard I thought the power
got pulled somehow.  My &lt;a href=&quot;/blog/2017/06/17/why-network-debugging.html&quot;&gt;serial port to TCP/IP
converter&lt;/a&gt;
suddenly closed due to an underlying error, the telnet I was using for my
console port closed, and … what just happened?&lt;/p&gt;

&lt;p&gt;Sigh.&lt;/p&gt;

&lt;p&gt;Time to start debugging.&lt;/p&gt;

&lt;h3 id=&quot;fifo-bugs&quot;&gt;FIFO bugs&lt;/h3&gt;

&lt;p&gt;The only clue I had to what was going wrong was that there was a
“&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_(computing)&quot;&gt;bus&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_error&quot;&gt;error&lt;/a&gt;”
in the
&lt;a href=&quot;/blog/2017/06/05/wb-bridge-overview.html&quot;&gt;debugging bus&lt;/a&gt;.
Sadly, that doesn’t help me much.  My best guess was
that the FIFO I was using was somehow flawed.  Perhaps it was overflowing or
reading the wrong value?  So I tore it apart and added formal properties to it.
Sure enough, I found bugs within it.  Those were easy to clean up, though.
Verifying FIFOs is fairly basic–although &lt;a href=&quot;/blog/2017/07/29/fifo.html&quot;&gt;my most recent article on the
topic&lt;/a&gt; is woefully out of
date–I’ve just learned so much since writing it.
(The &lt;a href=&quot;/tutorla&quot;&gt;tutorial&lt;/a&gt; lesson is pretty good, though.)&lt;/p&gt;

&lt;p&gt;I then ran the &lt;a href=&quot;https://github.com/ZipCPU/videozip/blob/master/sw/board/cputest.c&quot;&gt;CPU’s
self-test&lt;/a&gt;,
and then my new connectivity test.  When the results didn’t look right, I
placed a &lt;a href=&quot;/blog/2017/07/08/getting-started-with-wbscope.html&quot;&gt;Wishbone
Scope&lt;/a&gt;
onto the console port.  Sure enough, I wasn’t reading the right values from
the console.  That meant my &lt;a href=&quot;https://github.com/ZipCPU/wbuart32/blob/master/rtl/ufifo.v&quot;&gt;UART
FIFO&lt;/a&gt; was broken as
well.&lt;/p&gt;

&lt;p&gt;Yes, this was frustrating to me.  I’d just found bugs in two FIFOs I’d had
and used in many different projects over the course of several years.  No,
neither of these cores had been formally verified.  No more, though.  Now they
were verified, the bugs were gone, I could &lt;em&gt;prove&lt;/em&gt; that they were gone, and
I could now move on.&lt;/p&gt;

&lt;p&gt;[Eric Brombaugh]’s response to my tweet about this really captured my own
thoughts:&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/sdspi/brombaugh-how-long.png&quot; alt=&quot;&quot; width=&quot;589&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;I’m truly hoping this happens soon.&lt;/p&gt;

&lt;p&gt;Of course, even after fixing these two FIFOs I still knew that I had more
bugs in this design–I just didn’t know where.  For example, I still hadn’t
found that power supply issue I started out with.  Therefore, since
I knew I was going to need to do some serious work, I upped the speed of the
debugging bus back up from 9.6KBaud on up to 2MBaud again.&lt;/p&gt;

&lt;p&gt;The next bug took place in software, so I then turned to my &lt;a href=&quot;/blog/2017/07/08/getting-started-with-wbscope.html&quot;&gt;Wishbone
Scope&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/5b0269905726eacd634c025af706cc3e4702ed66/rtl/core/zipcpu.v#L2700-L2765&quot;&gt;attached to the ZipCPU&lt;/a&gt;.
When the results didn’t make sense, I dug in further and discovered the CPU
was trying to execute the wrong instruction at one point.
Where was it getting the wrong instruction from?  I started attaching
&lt;a href=&quot;/blog/2017/07/08/getting-started-with-wbscope.html&quot;&gt;WBScope&lt;/a&gt;s
further and further up stream towards the memory.&lt;/p&gt;

&lt;p&gt;Sure enough, I saw the wrong instruction come back from my
&lt;a href=&quot;https://github.com/ZipCPU/videozip/blob/7d57c21b88761dc355fc80067f665f8224da74a8/rtl/busexpander.v&quot;&gt;bus expander&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Let me back up to explain this one, though.  The
&lt;a href=&quot;https://github.com/ZipCPU/videozip/blob/7d57c21b88761dc355fc80067f665f8224da74a8/rtl/busexpander.v&quot;&gt;bus expander&lt;/a&gt;
takes a
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;Wishbone&lt;/a&gt;
request at one data width, and converts it to a request at another data width
that’s larger than the first.  In this case, it converts a 32-bit request to a
128-bit request, as shown in Fig. 11 above.  To make this work, the lower bits
of the address, the bits that aren’t needed on the 128-bit bus, are recorded
in a FIFO.  Then, when the 128-bit word is read, the 32-bit value of interest
is selected from that 128-bit value using those lower address bits.&lt;/p&gt;

&lt;p&gt;Did you catch the word &lt;em&gt;FIFO&lt;/em&gt; in that paragraph?&lt;/p&gt;

&lt;p&gt;Sure enough, this &lt;a href=&quot;https://github.com/ZipCPU/videozip/blob/7d57c21b88761dc355fc80067f665f8224da74a8/rtl/busexpander.v&quot;&gt;“hardware-proven” bus expander&lt;/a&gt;,
the one I’d used on my
&lt;a href=&quot;https://github.com/ZipCPU/videozip&quot;&gt;VideoZip project&lt;/a&gt; years earlier,
&lt;em&gt;had no FIFO overflow checking!&lt;/em&gt;  How on earth had it ever worked earlier?  I
must’ve never made more than 16 requests (the size of the FIFO), and so it
would’ve never overran before.  This time, however, I had the instruction
cache line size configured to 64-words.  Even at that, it almost
worked: the FIFO almost overflowed and then recovered since the data within it
was essentially a counter.  (The cache was reading words in order, after all.)
What kept it from working now was that my &lt;a href=&quot;/blog/2019/07/17/crossbar.html&quot;&gt;new crossbar
interconnect&lt;/a&gt; required one
extra clock stall cycle to get through the arbiter.  This stall caused the
first value to stall and hence write the same bottom address bits to the
expander twice.&lt;/p&gt;

&lt;p&gt;Ouch.  Burned again by “working in FPGA” qualified code, but not “formally
verified” code.  You’d think I’d learn by now, no?&lt;/p&gt;

&lt;p&gt;Okay, well I’d now found a lot of bugs.  Surely the design would work by now,
right?&lt;/p&gt;

&lt;h3 id=&quot;xilinxs-mig-its-not-my-fault-when-it-was&quot;&gt;Xilinx’s MIG: It’s not my fault! (when it was)&lt;/h3&gt;

&lt;p&gt;It still didn’t work.&lt;/p&gt;

&lt;p&gt;Again, I chased down the bugs I could as best I could.  As before, I’d find the
symptom of something that was broken, and then attach
&lt;a href=&quot;/blog/2017/07/08/getting-started-with-wbscope.html&quot;&gt;WBScope&lt;/a&gt;s
further and further upstream until I found the cause.&lt;/p&gt;

&lt;p&gt;Much to my surprise, I found an AXI error when working with Xilinx’s MIG
controller.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 13. MIG AXI Controller Memory Failure&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/sdspi/mig-annotated-3.png&quot; alt=&quot;&quot; width=&quot;524&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;How on earth would a write request return an unrequested read response?  This made no sense.&lt;/p&gt;

&lt;p&gt;So, I contacted Xilinx.  You can read &lt;a href=&quot;https://forums.xilinx.com/t5/Memory-Interfaces-and-NoC/MIG-DDR3-SDRAM-controller-responding-without-request/td-p/1037460&quot;&gt;my description of the bug
here&lt;/a&gt;, although
Xilinx’s representative and I went back and forth over this several times
off-forum.&lt;/p&gt;

&lt;p&gt;I was convinced the bug was in their code.  The &lt;a href=&quot;https://github.com/ZipCPU/wb2axip/blob/master/rtl/wbm2axisp.v&quot;&gt;component of mine that
interacted with their
controller&lt;/a&gt; had
been fully and formally verified.  Further, I counted requests internal to that
controller, and examining that request count I could see that this wasn’t a
response to any outstanding requests.&lt;/p&gt;

&lt;p&gt;Xilinx’s tech support, however, was just as confused by the
&lt;a href=&quot;/blog/2017/07/31/vcd.html&quot;&gt;trace&lt;/a&gt; as I was.  Perhaps there
was a read request from earlier that hadn’t been returned?  So … I
&lt;a href=&quot;/blog/2017/07/31/vcd.html&quot;&gt;traced&lt;/a&gt;
&lt;em&gt;four seconds&lt;/em&gt; of return, and &lt;em&gt;proved&lt;/em&gt; that every prior read request had been
properly returned.  (At the time, I didn’t realize just how truly awesome the
&lt;a href=&quot;https://github.com/ZipCPU/wbscope/blob/master/rtl/wbscopc.v&quot;&gt;compressed version of the Wishbone scope&lt;/a&gt; really was …)
Perhaps a request of mine broke protocol and crossed a
4kB boundary?  Couldn’t happen, I said, since none of my requests were ever
for more than a single beat.&lt;/p&gt;

&lt;p&gt;When they pointed out to me that it was unlikely their code had such an
egregious bug in it after so many others had used it, I quietly had to agree.
Surely even I would’ve seen this bug before if it was in their basic AXI
handling?&lt;/p&gt;

&lt;p&gt;Sadly, that also meant that I was really on my own to find the bug.  Well, that
and the fact that I was the only one with a design that had symptoms of being
“broken”.  (I didn’t want to give my design away by posting it on the forum …)&lt;/p&gt;

&lt;p&gt;With a little bit of digging, I discovered how to open a design after Synthesis.
I learned how to use Xilinx’s Internal Logic Analyzer.  (Yes, this was my first
&lt;a href=&quot;/blog/2017/07/08/getting-started-with-wbscope.html&quot;&gt;WBScope&lt;/a&gt;
time–I’ve only ever used my own &lt;a href=&quot;/blog/2017/07/08/getting-started-with-wbscope.html&quot;&gt;Wishbone
scope&lt;/a&gt;
before.)  I then tore into the MIG controller looking for where this
extraneous return came from.&lt;/p&gt;

&lt;p&gt;No, I never found any similar compression capability in the ILA.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: left&quot;&gt;&lt;caption&gt;Fig 14. AXI_RVALID source came from a hardware block&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/sdspi/miginternal.svg&quot; alt=&quot;&quot; width=&quot;360&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;The &lt;code class=&quot;highlighter-rouge&quot;&gt;AXI_RVALID&lt;/code&gt; signal came from a hardware FIFO, leading to a design FIFO,
leading to the &lt;code class=&quot;highlighter-rouge&quot;&gt;AXI_RVALID&lt;/code&gt; line shown in the trace above.  The only way this
hardware FIFO would return an invalid value would be if the memory returned a
read response–one that I hadn’t requested.&lt;/p&gt;

&lt;p&gt;Hmm …&lt;/p&gt;

&lt;p&gt;The other unusual thing about this bug was that there was always activity on
the “user interface” to the memory taking place at the same time.  It wasn’t
my activity.  I was using the AXI interface.  Internally, the MIG controller
turns the AXI interface into a “user interface” internally, then drives a
“native interface” from this “user interface”, and from that drives the
memory itself.  This extra activity on the “user interface” was in
addition to the activity my own code was causing.&lt;/p&gt;

&lt;p&gt;At this point I remembered hearing, some time ago, that Xilinx’s MIG controller
needed to read from the memory periodically just to keep it’s PLL’s locked.
That made sense of the extra activity, but this activity should’ve never
produced a response.  Surely their MIG controller was designed to suppress
this return, so why would I see it?&lt;/p&gt;

&lt;p&gt;I stared at this bug for a week.&lt;/p&gt;

&lt;p&gt;That’s a week I didn’t have for this project.  The project was already due.
Indeed, it was past due.  I hadn’t scheduled this time.  I was only going to
be updating an already working “FPGA proven” design.  How could I be
struggling with a bug this fundamental?&lt;/p&gt;

&lt;p&gt;I tried blaming others.  No one else was able to help without being able to
reproduce the bug, for which they’d need my design and my hardware.&lt;/p&gt;

&lt;p&gt;I tried taking the dog for a walk, hoping something would come to me.&lt;/p&gt;

&lt;p&gt;Nope, nothing.&lt;/p&gt;

&lt;p&gt;I considered using the &lt;a href=&quot;https://github.com/enjoy-digital/litedram&quot;&gt;litedram
controller&lt;/a&gt;, and then gave up when
I realized how much setup would be required.&lt;/p&gt;

&lt;p&gt;Surely there was an easier way to fix this memory bug than learning how to
integrate with a new language, no?&lt;/p&gt;

&lt;p&gt;Let me at least say this: When all else fails, prayer still works.&lt;/p&gt;

&lt;p&gt;No, I don’t have control over God.  No, He’s not required to help me any time I
want.  That said, He enjoys helping me.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;For the eyes of the LORD run to and fro throughout the whole earth, to shew
Himself strong in the behalf of them whose heart is perfect toward Him. … (2 Chron 16:9a)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;He also likes waiting for me to humbly come to Him, which tends not to happen
until after I’ve exhausted every option.  At that point, the point when there’s
no other option, and no where else help might come from, I turn to seriously
begging.&lt;/p&gt;

&lt;p&gt;It’s quite humbling.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Humble yourselves in the sight of the Lord, and he shall lift you up.
(James 4:10)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;I certainly didn’t know where else to look, and the schedule stress wasn’t
helping.&lt;/p&gt;

&lt;p&gt;Sometime after praying (more than once, I might add), I got the idea to check
the memory chip set up against the schematic.  Sure enough, &lt;em&gt;I had configured
the MIG for the wrong memory chip.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;This also explains the bug.  The MIG controller was expecting a response from
the memory chip a certain number of clocks after its request, and due to the
misconfiguration it suppressed the response from the wrong clock window.&lt;/p&gt;

&lt;p&gt;No, it wasn’t Xilinx’s fault.  In spite of all my rants and frustrations, it
was my own code at fault.  (I’m sorry, Xilinx employees, wherever and whoever
you are, for ever speaking poorly about your controller and swearing it didn’t
work.  It was my fault all the time.  This time …)&lt;/p&gt;

&lt;p&gt;Time to take a break, and then try again.  Surely the design will now work,
right?  I mean, I started with a “working” design, many of the parts and pieces
had been either formally verified or FPGA proven before I started working with
them, what more could go wrong?&lt;/p&gt;

&lt;h3 id=&quot;data-cache-bugs&quot;&gt;Data Cache Bugs&lt;/h3&gt;

&lt;p&gt;There were still two problems with the 
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; that I didn’t catch until
moving to hardware.  Both of these were related to the 
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;’s bootloader.&lt;/p&gt;

&lt;p&gt;The first problem was annoying, although I’d seen it before.&lt;/p&gt;

&lt;p&gt;In my linker scripts, I define a set of values indicating which pieces of
ROM (flash, boot ROM), kernel RAM (block RAM only) or RAM (block RAM or SDRAM)
are on board.  These addresses are provided by
&lt;a href=&quot;/zipcpu/2018/12/22/autofpga-ld.html&quot;&gt;AutoFPGA&lt;/a&gt; when the
design is put together, and may change as components are added or removed
from the design.&lt;/p&gt;

&lt;p&gt;To capture these values into my program, I use statements such as,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span class=&quot;k&quot;&gt;extern&lt;/span&gt; 	&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;_rom&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;References to &lt;code class=&quot;highlighter-rouge&quot;&gt;_rom&lt;/code&gt; now become pointer references, filled in by the
linker–just what I want.  Other approaches, such as declaring an external
unsigned pointer &lt;code class=&quot;highlighter-rouge&quot;&gt;_rom&lt;/code&gt;, tended to create memory allocations for the pointer.
This method of declaration simply evaluates to the right answer when
I want it.&lt;/p&gt;

&lt;p&gt;The problem comes about when my boot loader software checks to see if
there’s a ROM image to copy from.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span class=&quot;n&quot;&gt;bootloader&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(...)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;// ...
&lt;/span&gt;	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_rom&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;c1&quot;&gt;// We need to copy the ROM image to RAM
&lt;/span&gt;	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;//
&lt;/span&gt;	&lt;span class=&quot;c1&quot;&gt;// Other code
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The problem with this code is that the GCC compiler “knows” that &lt;code class=&quot;highlighter-rouge&quot;&gt;_rom&lt;/code&gt; isn’t
a NULL pointer, it’s a pointer to a properly allocated memory array.  (When it
might actually be a NULL pointer …)  As a result, this check gets dropped from
the code.&lt;/p&gt;

&lt;p&gt;So, I replaced the check with something that looked like,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span class=&quot;cp&quot;&gt;#define	NOTNULL	(4 != (unsigned)&amp;amp;A[1])&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;and then later,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NOTNULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_rom&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;c1&quot;&gt;// ...
&lt;/span&gt;	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;While I’m sure there’s a better way, this worked and by now I was both behind
and frustrated.&lt;/p&gt;

&lt;p&gt;The next bug I should’ve anticipated as well.  I was copying from the ROM
memory image of my code into RAM (i.e. setting global values), yet also using
that same RAM for some debugging statements.&lt;/p&gt;

&lt;p&gt;I know, I shouldn’t do that.  But the problem wasn’t severe–I just wanted to
print out certain values, and &lt;a href=&quot;https://github.com/ZipCPU/videozip/blob/6e4215b3b6ea96595a4083603636a88a5599604d/sw/board/txfns.c#L60&quot;&gt;my print routine wanted to use a global to know
if the last character printed was a carriage return or
not&lt;/a&gt;.
If it was a carriage return, it would send a new-line and suppress the next
newline.  This effectively turned a “\r\n” sequence into a “\n” sequence.&lt;/p&gt;

&lt;p&gt;If the “last-character-was-a-newline” value was wrong, the result wouldn’t look
pretty but it would still work.&lt;/p&gt;

&lt;p&gt;In this case, the bug I was getting was worse.  There was another global value
that wasn’t getting set properly.&lt;/p&gt;

&lt;p&gt;As with the other hardware bugs, I attached a &lt;a href=&quot;/blog/2017/07/08/getting-started-with-wbscope.html&quot;&gt;Wishbone
Scope&lt;/a&gt;
and started digging.  I should mention, this type of digging is a slow process.
It took Vivado about 15 minutes to create a bit file following any changes.
I’d then run the design, examine the trace, adjust things and try again.
This kind of debugging loop is quite slow.  Eventually, though, I tend to try
running the simulator to see if the same bug pops up since chasing a bug
through a simulation trace is a whole lot easier than moving a &lt;a href=&quot;/blog/2017/07/08/getting-started-with-wbscope.html&quot;&gt;Wishbone
Scope&lt;/a&gt;
around and rebuilding again.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 15. Data Cache&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/sdspi/dcache.svg&quot; alt=&quot;&quot; width=&quot;360&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;When I finally got to the root of the issue, I could’ve kicked myself.  Using
the value from the RAM that hadn’t yet been initialized caused that
uninitialized cache line (not just the one uninitialized value) to get loaded
into the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/dcache.v&quot;&gt;data cache&lt;/a&gt;.
The bootloader would then copy data from the ROM image to the RAM area where
the globals would be stored using the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/wbdmac.v&quot;&gt;DMA&lt;/a&gt;.
The &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/dcache.v&quot;&gt;data
cache&lt;/a&gt;,
however, was unaware of the DMA’s accesses, and so
the cache is now out of sync with memory–as shown in Fig. 15 on the right.&lt;/p&gt;

&lt;p&gt;Once I realized what was causing the bug, fixing it was easy: I expanded my
“clear cache” instruction to work on the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/dcache.v&quot;&gt;data
cache&lt;/a&gt;,
as well as the more established &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/pfcache.v&quot;&gt;instruction
cache&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&quot;sdspi-the-io-drivers&quot;&gt;SDSPI: The I/O Drivers&lt;/h3&gt;

&lt;p&gt;The big risk in this project, of course, was using the
&lt;a href=&quot;https://en.wikipedia.org/wiki/SD_card&quot;&gt;SD-Card&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;I knew it was a risk because I had never used the
&lt;a href=&quot;http://elm-chan.org/fsw/ff/00index_e.html&quot;&gt;FATFS&lt;/a&gt; library before.&lt;/p&gt;

&lt;p&gt;Note that I didn’t consider the fact that I’d never used the
&lt;a href=&quot;https://en.wikipedia.org/wiki/SD_card&quot;&gt;SD-Card&lt;/a&gt;
on this hardware before a risk, nor did I consider using my &lt;a href=&quot;https://github.com/ZipCPU/sdspi&quot;&gt;SD Card
controller&lt;/a&gt;
a risk since it had “worked” when it was last used.&lt;/p&gt;

&lt;p&gt;I tried the design first without an
&lt;a href=&quot;https://en.wikipedia.org/wiki/SD_card&quot;&gt;SD-Card&lt;/a&gt;
in place.&lt;/p&gt;

&lt;p&gt;I quickly realized that I needed to &lt;a href=&quot;https://github.com/ZipCPU/blob/master/rtl/sdspiv&quot;&gt;adjust my
controller&lt;/a&gt; to detect
whether or not the card was present.  &lt;a href=&quot;https://store.digilentinc.com/nexys-video-artix-7-fpga-trainer-board-for-multimedia-applications/&quot;&gt;Digilent’s Nexys Video
board&lt;/a&gt;
also includes an
electronic reset to the card that pulls power from it.  I adjusted my
controller again, so that this reset signal would release the controller
from whatever action it was in the middle of if the reset signal were present.&lt;/p&gt;

&lt;p&gt;To understand what happened next, you need to understand the first step in any
&lt;a href=&quot;https://en.wikipedia.org/wiki/SD_card&quot;&gt;SD-Card&lt;/a&gt;
interaction over SPI.  The software driver needs to send the
&lt;a href=&quot;https://en.wikipedia.org/wiki/SD_card&quot;&gt;SD-Card&lt;/a&gt;
a reset command, commonly called a “SEND_GO_IDLE” or &lt;code class=&quot;highlighter-rouge&quot;&gt;CMD0&lt;/code&gt; command.  The
card then responds with an &lt;code class=&quot;highlighter-rouge&quot;&gt;R1&lt;/code&gt; response as it’s called–basically an 8-bit
value equal to &lt;code class=&quot;highlighter-rouge&quot;&gt;8&#39;h01&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;My controller sent this &lt;code class=&quot;highlighter-rouge&quot;&gt;CMD0&lt;/code&gt; and got no response.&lt;/p&gt;

&lt;p&gt;Now what?&lt;/p&gt;

&lt;p&gt;It had been years since I’d worked with &lt;a href=&quot;https://github.com/ZipCPU/sdspi/blob/master/rtl/sdspi.v&quot;&gt;this
controller&lt;/a&gt;.  Sadly,
I didn’t remember much of how it worked.  I wasn’t certain where to start
debugging.  Still, it had a debugging output which I could place into a
&lt;a href=&quot;/blog/2017/07/08/getting-started-with-wbscope.html&quot;&gt;WBScope&lt;/a&gt;
again.&lt;/p&gt;

&lt;p&gt;I saw 7 good clock pulses per byte, and one strangely short one.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 16. An unusually short clock pulse&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/sdspi/short-sclk.svg&quot; alt=&quot;&quot; width=&quot;560&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;I quickly modified the &lt;a href=&quot;https://github.com/ZipCPU/sdspi/blob/master/rtl/llsdspi.v&quot;&gt;lower-level
driver&lt;/a&gt; to fix it.&lt;/p&gt;

&lt;p&gt;I then saw the outgoing MOSI line change while SCK was high.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 17. MOSI was now no longer aligned with the negative edge of SCK&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/sdspi/offset-mosi.svg&quot; alt=&quot;&quot; width=&quot;560&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;No, this isn’t allowed–not on one of my cores.  I wanted the MOSI line to
only change when SCK fell–never otherwise.  So I tore the &lt;a href=&quot;https://github.com/ZipCPU/sdspi/blob/master/rtl/llsdspi.v&quot;&gt;lower level
driver&lt;/a&gt; apart.
This time I rewrote it.  I added formal properties to it.  I verified the
interface against something similar to an AXI stream protocol.  (I used
STB and IDLE instead of VALID and READY …)  I ran &lt;code class=&quot;highlighter-rouge&quot;&gt;cover()&lt;/code&gt; checks.
It now worked exactly as desired and designed, so I tried again.&lt;/p&gt;

&lt;p&gt;Still no response from the
&lt;a href=&quot;https://en.wikipedia.org/wiki/SD_card&quot;&gt;SD-Card&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Not again.&lt;/p&gt;

&lt;p&gt;I reread the SD specification I had.  I double checked the power up sequencing.
No, this was right.  Just for good measure, I stuffed a 1ms power-up delay
into the &lt;a href=&quot;https://github.com/ZipCPU/sdspi/blob/master/rtl/llsdspi.v&quot;&gt;lower level
controller&lt;/a&gt;
and tried again.  Still nothing.&lt;/p&gt;

&lt;p&gt;This time I turned to Google.  I started getting worried that my off-the-shelf
&lt;a href=&quot;https://en.wikipedia.org/wiki/SD_card&quot;&gt;SD-Card&lt;/a&gt;s
didn’t support SPI.  I was using both SanDisk and Lexar cards, and with a bit
of Googling I found the specification sheet for another similar SanDisk card.
While it wasn’t quite the specification for my card, it did verify that
SanDisk supported SPI mode on at least one
&lt;a href=&quot;https://en.wikipedia.org/wiki/SD_card&quot;&gt;SD-Card&lt;/a&gt;.
It also verified how the timing was supposed to work.&lt;/p&gt;

&lt;p&gt;No, this should work.&lt;/p&gt;

&lt;p&gt;So, for the first time, I went and checked Vivado’s warnings.  Sure enough,
I had warnings for the following four lines:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	&lt;span class=&quot;k&quot;&gt;assign&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;io_sd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;w_sd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;mb&quot;&gt;1&#39;bz&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;assign&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;io_sd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;w_sd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;mb&quot;&gt;1&#39;bz&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;assign&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;io_sd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;w_sd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;mb&quot;&gt;1&#39;bz&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;assign&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;io_sd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;w_sd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;mb&quot;&gt;1&#39;bz&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;These four lines are used to set the I/O lines to 1’b1 (via an external pullup)
or 1’b0 if the I/O is active.  They are really only important when implementing
the full SDIO interface, but that’s what
&lt;a href=&quot;https://store.digilentinc.com&quot;&gt;Digilent&lt;/a&gt; had wired and so it was what
I was using here.&lt;/p&gt;

&lt;p&gt;Since Vivado had a problem with these lines, I replaced them with &lt;code class=&quot;highlighter-rouge&quot;&gt;IOBUF&lt;/code&gt;
instantiations that should’ve done the same thing.  I then convinced myself
of a bug in these instantiations, changed them, and changed them again, until
I finally had no confidence at all in my &lt;code class=&quot;highlighter-rouge&quot;&gt;IOBUF&lt;/code&gt; instantiations.&lt;/p&gt;

&lt;p&gt;With no other way to debug these, I stuffed the return values of the &lt;code class=&quot;highlighter-rouge&quot;&gt;IOBUF&lt;/code&gt;s
into a
&lt;a href=&quot;/blog/2017/07/08/getting-started-with-wbscope.html&quot;&gt;WBScope&lt;/a&gt;.
Much to my surprise, even though the outgoing data wires
were toggling appropriately, the &lt;code class=&quot;highlighter-rouge&quot;&gt;IOBUF&lt;/code&gt; return values didn’t reflect that at
all.&lt;/p&gt;

&lt;p&gt;So I got rid of the &lt;code class=&quot;highlighter-rouge&quot;&gt;1&#39;bz&lt;/code&gt; values entirely.  I suppose it’s not really a big
deal.  While the SDIO protocol uses them the SPI protocol doesn’t, so I
figured I should still be good.&lt;/p&gt;

&lt;p&gt;Suddenly, and much to my delight, the card I was working with responded!&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 18. The SD-Card responds to a reset command, CMD0&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;a href=&quot;/img/sdspi/sdspi-cmd0.png&quot;&gt;&lt;img src=&quot;/img/sdspi/sdspi-cmd0.png&quot; alt=&quot;&quot; width=&quot;648&quot; /&gt;&lt;/a&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Surly my adventure was coming to an end, right?&lt;/p&gt;

&lt;h3 id=&quot;sdspi-the-jenga-design&quot;&gt;SDSPI: The Jenga Design&lt;/h3&gt;

&lt;p&gt;Sadly, no.  This “adventure” was far from complete.  Worse, I was now nearly
two weeks later than I wanted to be in my project schedule.  At least I had the
SDSPI controller fully connected to the
&lt;a href=&quot;/blog/2017/07/08/getting-started-with-wbscope.html&quot;&gt;WBScope&lt;/a&gt;
so I could see what was going on.&lt;/p&gt;

&lt;p&gt;Before going further, let me share some more about this design.  I wrote this
design as one of my earlier digital design projects–back when I was still
“&lt;a href=&quot;/blog/2017/09/18/clocks-for-sw-engineers.html&quot;&gt;thinking like a
programmer&lt;/a&gt;” if
you will.  As a result the &lt;a href=&quot;https://github.com/ZipCPU/sdspi/blob/e3d46ab24f79b62544fb11a49de77504bbdab83f/rtl/sdspi.v#L280-L558&quot;&gt;state machine within it was incredibly complex–too
complex even&lt;/a&gt;.
Indeed, it was so complex that ISE wouldn’t even place a design with this
controller in it without failing timing.&lt;/p&gt;

&lt;p&gt;Timing shouldn’t be a problem for a SPI transaction, right?&lt;/p&gt;

&lt;p&gt;I had eventually “fixed” the problem years ago by (slightly) breaking up the
giant always block so that smaller blocks would pre-calculate values.  I also
removed any extraneous logic.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: left&quot;&gt;&lt;caption&gt;Fig 19. Jenga, a fun game from Hasboro&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/sdspi/jenga.jpeg&quot; alt=&quot;&quot; width=&quot;96&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;The result was what I’m going to call a “Jenga” design, after the classic game
from Hasbro.  That game starts with a wooden tower, from which players one by
one remove support elements and place them on top.  When the tower finally
falls (which it will do), the last person to remove a support loses.&lt;/p&gt;

&lt;p&gt;Why was this a “Jenga” design?  Well, obviously, because it appeared to be
designed to fail.  (Yes, this was one of my own designs …)  First, it was so
badly written I couldn’t tell from reading my own code how it was supposed to
work.  That meant that, second, I couldn’t track the dependencies through the
design–what signals were dependent upon which others?  Worse, when I just
slightly modified the &lt;a href=&quot;https://github.com/ZipCPU/sdspi/blob/master/rtl/llsdspi.v&quot;&gt;lower-level I/O
controller&lt;/a&gt;,
the data out valid line was delayed by one clock from the data in valid line
and … this was causing my whole design to fail.  The Jenga design had been
changed just one too many times.&lt;/p&gt;

&lt;p&gt;I tried patching it.  The patch fixed one problem, but generated another.&lt;/p&gt;

&lt;p&gt;No matter how I looked at it, there was just no easy way to fix it–especially
without a good understanding of how it was supposed to work originally.&lt;/p&gt;

&lt;p&gt;The project was already late, now what?&lt;/p&gt;

&lt;p&gt;Seeing no other way forward,
I tore the entire design apart and rebuilt it using &lt;a href=&quot;/formal/2018/07/14/dev-cycle.html&quot;&gt;formal verification
properties&lt;/a&gt; from the
ground up.  In about a day I had a newer design with much simpler state
machines.  Even better, the newer design was separated into three new but
separate modules: &lt;a href=&quot;https://github.com/ZipCPU/sdspi/blob/c74be4fdb9bbe8852c173cf325c2a51ff0b33f11/rtl/spicmd.v&quot;&gt;sending a command&lt;/a&gt;, &lt;a href=&quot;https://github.com/ZipCPU/sdspi/blob/c74be4fdb9bbe8852c173cf325c2a51ff0b33f11/rtl/spirxdata.v&quot;&gt;receiving a buffer of
data&lt;/a&gt;, and &lt;a href=&quot;https://github.com/ZipCPU/sdspi/blob/c74be4fdb9bbe8852c173cf325c2a51ff0b33f11/rtl/spitxdata.v&quot;&gt;sending a buffer of data to the
SD-Card&lt;/a&gt;.  The
[lower level controller](SD-Card](https://github.com/ZipCPU/sdspi/blob/c74be4fdb9bbe8852c173cf325c2a51ff0b33f11/rtl/llsdspi.v)
remained the same, but I could now gut most of the Jenga design
and in particular I was able to remove the
&lt;a href=&quot;https://github.com/ZipCPU/sdspi/blob/e3d46ab24f79b62544fb11a49de77504bbdab83f/rtl/sdspi.v#L280-L558&quot;&gt;unmaintainable state machine&lt;/a&gt; and
replace it with &lt;a href=&quot;https://github.com/ZipCPU/sdspi/blob/c74be4fdb9bbe8852c173cf325c2a51ff0b33f11/rtl/sdspi.v#L393-L468&quot;&gt;something much simpler&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Not only that, but I could use the formal tools to generate waveforms
illustrating how each component was supposed to work.  Not only that, I could
formally verify the whole using &lt;a href=&quot;/blog/2018/03/10/induction-exercise.html&quot;&gt;induction&lt;/a&gt;–something
I could never do with the previous Jenga design.&lt;/p&gt;

&lt;p&gt;Now, finally, perhaps the design would work?&lt;/p&gt;

&lt;p&gt;Not quite.  The first step as always was simulation.&lt;/p&gt;

&lt;p&gt;In simulation, I discovered that the CRC generation and checking code for the
data blocks wasn’t working.  (The one part I didn’t formally verify in my haste
…)&lt;/p&gt;

&lt;p&gt;Still, I was in a hurry.  After some quick changes, my design worked in
simulation, I moved to hardware.&lt;/p&gt;

&lt;h3 id=&quot;sd-cards-and-an-undocumented-feature&quot;&gt;SD-Cards, and an Undocumented Feature&lt;/h3&gt;

&lt;p&gt;I’m now just over two weeks late.  Does this design work now?&lt;/p&gt;

&lt;p&gt;Sadly, no.&lt;/p&gt;

&lt;p&gt;After running my design, something went wrong.  Badly wrong.  I started
getting
&lt;a href=&quot;https://en.wikipedia.org/wiki/File_system&quot;&gt;file system&lt;/a&gt;.
not found errors.  Resetting the card and reading the
(hopefully constant) CSD register returned values completely unexpected.&lt;/p&gt;

&lt;p&gt;Ouch.&lt;/p&gt;

&lt;p&gt;I reformatted the card, placed my software image on it and tried again.&lt;/p&gt;

&lt;p&gt;Again, something, somehow, somewhere again went badly wrong.&lt;/p&gt;

&lt;p&gt;I adjusted the software so that any block read or write would dump to the
screen.  I captured the screen using
&lt;a href=&quot;https://www.geeksforgeeks.org/script-command-in-linux-with-examples/&quot;&gt;script&lt;/a&gt;.
I scrolled back and examined what was going on.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 20. Read data.  Imagine the boxes filled with hexadecimal data&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/sdspi/sdread-good.svg&quot; alt=&quot;&quot; width=&quot;360&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Needless to say, I started staring at pages and pages of tables looking sort
of like Fig. 20 on the right.&lt;/p&gt;

&lt;p&gt;Out of luck, I happened to notice a dumped data block showing a write to the
&lt;a href=&quot;https://en.wikipedia.org/wiki/File_system&quot;&gt;file system&lt;/a&gt; that looked more
like Fig. 21 below than the prior read that had looked like Fig. 20 above.&lt;br /&gt;
(Colors added for effect, since no one reading will want to stare at hex
values.)  I started to look deeper.  Sure enough, it lead to finding a bug
in the new (hastily-verified) controller.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 21. Write data, offset by one word from the read data&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/sdspi/sdwrite-bad.svg&quot; alt=&quot;&quot; width=&quot;360&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;This bug was easy to chase down.  My &lt;a href=&quot;https://github.com/ZipCPU/sdspi/blob/c74be4fdb9bbe8852c173cf325c2a51ff0b33f11/rtl/spitxdata.v&quot;&gt;new data-write
module&lt;/a&gt;
needed to read from
a (block RAM) memory external to it, and grabbed the value one clock too
late–after the new address changed the value.  Getting this timing right was
one of those things I hadn’t checked in my haste.&lt;/p&gt;

&lt;p&gt;I adjusted the timing and tried again.&lt;/p&gt;

&lt;p&gt;Nope, still not working.  In particular, the
&lt;a href=&quot;https://en.wikipedia.org/wiki/SD_card&quot;&gt;SD-Card&lt;/a&gt;
was returning error responses.  Perhaps I could chase those down?&lt;/p&gt;

&lt;p&gt;So I turned to the
&lt;a href=&quot;/blog/2017/07/08/getting-started-with-wbscope.html&quot;&gt;WBScope&lt;/a&gt;
again to see what was going on.  This time, I triggered the
&lt;a href=&quot;/blog/2017/07/08/getting-started-with-wbscope.html&quot;&gt;scope&lt;/a&gt;
off of the first operation that received a failing return
from the card and … saw something I wasn’t expecting at all.&lt;/p&gt;

&lt;p&gt;The card was returning multiple acknowledgements even while a block was being
written.&lt;/p&gt;

&lt;p&gt;This was … unexpected.  It was as though the card were responding to the
data I was transmitting as though they were commands and not data.&lt;/p&gt;

&lt;p&gt;I adjusted the
&lt;a href=&quot;/blog/2017/07/08/getting-started-with-wbscope.html&quot;&gt;scope&lt;/a&gt;’s
trigger and tried again, hoping to get a better look.&lt;/p&gt;

&lt;p&gt;At one point, I increased the memory in the
&lt;a href=&quot;/blog/2017/07/08/getting-started-with-wbscope.html&quot;&gt;scope&lt;/a&gt;
and even adjusted its trigger in logic.
I reformatted my (now long-since broken)
&lt;a href=&quot;https://en.wikipedia.org/wiki/SD_card&quot;&gt;SD-Card&lt;/a&gt;,
put my application’s image on it again and loaded my design (again).&lt;/p&gt;

&lt;p&gt;Much to my surprise, I watched the boot loader properly set up the card, read
my design into SDRAM, and then start and run the design.&lt;/p&gt;

&lt;p&gt;This shocked me.  I thought I was suffering from bugs still.  How did this
much logic manage to work without error?  Indeed, everything worked well
until the design then tried to write to the
&lt;a href=&quot;https://en.wikipedia.org/wiki/SD_card&quot;&gt;SD-Card&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Somewhere around this time, things started to add up.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/SD_card&quot;&gt;SD-Card&lt;/a&gt;s
have some work to do following a write.  If you send the card enough
writes, back to back, you need to expect that the card will ask you to slow
down.  Forget the data rates quoted on the manufacturers sites.  Cards are
slower than that, they just transfer at that rate.&lt;/p&gt;

&lt;p&gt;So I checked the SD Spec again.&lt;/p&gt;

&lt;p&gt;Sure enough, there was a means of signaling that the card isn’t ready–by
holding D0 low following a command in SDIO mode.  Nothing was said about this,
however, in SPI mode.&lt;/p&gt;

&lt;p&gt;Perhaps this was an oversight?&lt;/p&gt;

&lt;p&gt;So I went back to my new SDSPI controller and adjusted the write-data command
so that it would wait until the card was idle (i.e. MISO returned an &lt;code class=&quot;highlighter-rouge&quot;&gt;8&#39;hff&lt;/code&gt;
instead of an &lt;code class=&quot;highlighter-rouge&quot;&gt;8&#39;h00&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;Finally, after all this work, the design works from bring up through a data
record and write to the
&lt;a href=&quot;https://en.wikipedia.org/wiki/SD_card&quot;&gt;SD-Card&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Whew!&lt;/p&gt;

&lt;h3 id=&quot;the-power-failure&quot;&gt;The “Power” Failure&lt;/h3&gt;

&lt;p&gt;What about that initial bug?  You know, the one that looked like a power
failure?&lt;/p&gt;

&lt;p&gt;At this point, I was declaring success yet I had never seen that power bug
since I first started working in actual hardware.  Indeed, I’d almost
forgotten about it.&lt;/p&gt;

&lt;p&gt;Still, I was running my serial port at 2MBaud–a rate that wouldn’t work when
I delivered this code.  So I switched back to 9.6KBaud to meet my customer’s
requirement.&lt;/p&gt;

&lt;p&gt;Just to run a final test, I ran my design at 9.6kBaud.  This time, however,
when I tried to load it into memory the loader shut down and the &lt;a href=&quot;/blog/2017/06/17/why-network-debugging.html&quot;&gt;UART to TCP/IP
bridge&lt;/a&gt;
suddenly quit again as well.&lt;/p&gt;

&lt;p&gt;This looked like that ugly “power” problem rearing it’s head again.&lt;/p&gt;

&lt;p&gt;Sigh.  Just when I thought things were working.&lt;/p&gt;

&lt;p&gt;This time, however, I knew things were working before changing serial port
speed.  Could it be something speed related?&lt;/p&gt;

&lt;p&gt;Sure enough, after describing the problem to my family, I remembered a timer
within the debugging bus I’d built.  Specifically, there’s a &lt;a href=&quot;https://github.com/ZipCPU/videozip/blob/0daadd8a0d80ad228296a3f00ae511e072845ca1/rtl/wbubus.v#L120-L135&quot;&gt;watchdog
timer&lt;/a&gt; within it.  The purpose of the timer is
to keep the Wishbone bus from ever locking up.  The timer starts when the
bus is activated, and clears when either the bus becomes idle or a new request
is accepted.  This timer is set to count a rough 500M clocks.  If the bus isn’t
released in 500M clocks, the
&lt;a href=&quot;/blog/2017/06/05/wb-bridge-overview.html&quot;&gt;debugging bus&lt;/a&gt;
will return &lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_(computing)&quot;&gt;bus&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_error&quot;&gt;error&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;To understand more of what’s going on, know that &lt;a href=&quot;/blog/2017/06/05/wb-bridge-overview.html&quot;&gt;this version of the debugging
bus&lt;/a&gt;
takes at least 6-bytes to transmit a 32-bit word.  At 100MHz and 9600Baud,
one baud clock will require about 10.5k clocks.  Ten baud clocks constitute
one character, and six characters are needed for a total of about 625,000
clocks.  Further, in order to support &lt;a href=&quot;https://github.com/ZipCPU/videozip/blob/0daadd8a0d80ad228296a3f00ae511e072845ca1/rtl/wbqspiflash.v&quot;&gt;my original flash
driver&lt;/a&gt;,
the &lt;a href=&quot;/blog/2017/06/05/wb-bridge-overview.html&quot;&gt;debugging bus&lt;/a&gt;
doesn’t release the &lt;code class=&quot;highlighter-rouge&quot;&gt;CYC&lt;/code&gt; line following any write until the whole
pattern is written.  Hence the first write goes through fine, and the bus is
held for the second write.  It then takes 625k clocks to get the second piece
of data, during which time the watchdog times out and the debugging bus
returns a &lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_(computing)&quot;&gt;bus&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_error&quot;&gt;error&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;That &lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_(computing)&quot;&gt;bus&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_error&quot;&gt;error&lt;/a&gt; then gets returned to the 
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; loader.  This is turned into an
C++ exception within the loader.  When the loader then receives this exception,
it suddenly exits complaining about a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_(computing)&quot;&gt;bus&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_error&quot;&gt;error&lt;/a&gt;.  Worse, since it exits mid
TCP/IP connection, the TCP/IP connection is suddenly reset which then creates
an error in the TCP/IP bridge–leaving me believing a “power failure” had taken
place that caused me to lose my connection to the FTDI chip.&lt;/p&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;Wait, what just happened?&lt;/p&gt;

&lt;p&gt;What happened was that I didn’t allocate enough time to get a “working”,
“FPGA proven” design to work.&lt;/p&gt;

&lt;p&gt;What happened was that I lost more than two weeks of schedule on an already
late project.&lt;/p&gt;

&lt;p&gt;Did formal verification help?  Most certainly!  Notice that every one of the
FIFOs within my design that wasn’t formally verified had bugs in it.  Notice
also how I was able to &lt;a href=&quot;https://github.com/ZipCPU/sdspi/blob/c74be4fdb9bbe8852c173cf325c2a51ff0b33f11/&quot;&gt;build a brand new SDSPI
controller&lt;/a&gt;,
using formal tools, in just over a day.  Notice also how it was possible to
quickly adjust that controller to meet the “undocumented feature” in the
&lt;a href=&quot;https://en.wikipedia.org/wiki/SD_card&quot;&gt;SD-Card&lt;/a&gt;
protocol.&lt;/p&gt;

&lt;p&gt;That said, I wouldn’t have been able to do any of this without my
&lt;a href=&quot;/blog/2017/07/08/getting-started-with-wbscope.html&quot;&gt;WBScope&lt;/a&gt;.
I can also finally describe how it’s different from Xilinx’s Internal Logic
Analyzer.&lt;/p&gt;

&lt;p&gt;First, I give Xilinx full marks for their ability to integrate their
Internal Logic Analyzer into their Vivado design flow.  Using Vivado, I found it
possible to trace lines within code that I didn’t feel like I could change.
After selecting the lines I was interested in, there was little more required
to set it up.  Again, full marks for simplicity in set up.&lt;/p&gt;

&lt;p&gt;That said, the 
&lt;a href=&quot;/blog/2017/07/08/getting-started-with-wbscope.html&quot;&gt;WBScope&lt;/a&gt;
has some capabilities that I didn’t find with Xilinx’s ILA.  The first major
difference is that I have a &lt;a href=&quot;https://github.com/ZipCPU/wbscope/blob/master/rtl/wbscopc.v&quot;&gt;compressed version of the Wishbone
scope&lt;/a&gt;.  The
compression itself is really quite simple–it’s just a basic run-length encoder.
Still, that simple compression was enough to examine every transaction from
startup to some time between 4-13 seconds later.  The second major difference
is that the
&lt;a href=&quot;/blog/2017/07/08/getting-started-with-wbscope.html&quot;&gt;WBScope&lt;/a&gt;
can be either 1) externally triggered, triggered from an internal hardware
event, or even 2) triggered internally from software.  Given that software
changes took a rough 30s to modify, triggering from software was &lt;em&gt;much&lt;/em&gt; faster
than rebuilding the design to look for a new trigger.  It also allowed me to
trigger off of some rather strange trigger conditions.&lt;/p&gt;

&lt;p&gt;Finally, I am also very thankful that, when the chips were down, God answered
my prayers.&lt;/p&gt;

&lt;p&gt;Thank you, Lord.&lt;/p&gt;
&lt;hr /&gt;&lt;p&gt;&lt;em&gt;Ask, and it shall be given you; seek, and ye shall find; knock, and it shall be opened unto you (Matt 7:7)&lt;/em&gt;</description>
        <pubDate>Thu, 14 Nov 2019 00:00:00 -0500</pubDate>
        <link>https://zipcpu.com/blog/2019/11/14/sdspi.html</link>
        <guid isPermaLink="true">https://zipcpu.com/blog/2019/11/14/sdspi.html</guid>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>Is formal verfication enough, or is simulation required?</title>
        <description>&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/enough/orconf.png&quot; alt=&quot;&quot; width=&quot;161&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;While at &lt;a href=&quot;https://orconf.org&quot;&gt;ORCONF&lt;/a&gt; this past weekend, several folks asked
me to what extent I used
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal methods&lt;/a&gt;.
Since I found myself answering this question with some stories from my own
experiences that I had yet to blog about, I thought I’d write
them down and share them here.&lt;/p&gt;

&lt;p&gt;Unlike many of my articles, this one will avoid deep dives into code.  We’ll
have plenty of opportunities to do that another time.&lt;/p&gt;

&lt;p&gt;That said, I’d like to discuss four design examples: an &lt;a href=&quot;https://github.com/ZipCPU/blob/master/rtl/core/pfcache.v&quot;&gt;instruction
cache&lt;/a&gt; that wasn’t
formally verified, chasing down
a &lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash memory&lt;/a&gt; verification error,
a &lt;a href=&quot;https://github.com/ZipCPU/blob/master/rtl/core/dcache.v&quot;&gt;data cache&lt;/a&gt; built
with formal from the beginning, and a recent speed upgrade I worked on for an
external &lt;a href=&quot;https://github.com/cliffordwolf/picorv32&quot;&gt;PicoRV32&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_(computing)&quot;&gt;Bus&lt;/a&gt; interface.&lt;/p&gt;

&lt;h2 id=&quot;the-instruction-cache&quot;&gt;The Instruction Cache&lt;/h2&gt;

&lt;p&gt;The &lt;a href=&quot;https://github.com/ZipCPU/blob/master/rtl/core/pfcache.v&quot;&gt;instruction
cache&lt;/a&gt;
story is &lt;a href=&quot;/zipcpu/2017/12/28/ugliest-bug.html&quot;&gt;one I’ve told
before&lt;/a&gt;.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: left; padding: 15px&quot;&gt;&lt;caption&gt;Fig 1. The ZipCPU Instruction Cache&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/enough/zipcpu-prefetch.svg&quot; alt=&quot;&quot; width=&quot;240&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;The &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;’s &lt;a href=&quot;https://github.com/ZipCPU/blob/master/rtl/core/pfcache.v&quot;&gt;instruction
cache&lt;/a&gt;
is actually one of several possible instruction fetch modules it can be
configured with.  We’ve already discussed the &lt;a href=&quot;/zipcpu/2017/11/18/wb-prefetch.html&quot;&gt;basic
prefetch&lt;/a&gt;, and a more
&lt;a href=&quot;/zipcpu/2018/03/21/dblfetch.html&quot;&gt;pipelined prefetch&lt;/a&gt;
implementation.  The 
&lt;a href=&quot;https://github.com/ZipCPU/blob/master/rtl/core/pfcache.v&quot;&gt;cache&lt;/a&gt; is a
drop-in replacement for either.  Then, within the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;, the
&lt;a href=&quot;/zipcpu/2017/11/18/wb-prefetch.html&quot;&gt;prefetch&lt;/a&gt;
and the load-store unit (also a plug-in with several options) are arbitrated
between to determine which gets access to the
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;Wishbone bus&lt;/a&gt;
at any given time, as shown in Fig. 2 on the left.&lt;/p&gt;

&lt;p&gt;This is just basic CPU design and background.&lt;/p&gt;

&lt;p&gt;Now, imagine if you had a program running on a CPU, and the program wasn’t
working.  Whenever you called the first function after a reset, it would fail
with a &lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_error&quot;&gt;bus error&lt;/a&gt; after writing
beyond the end of memory.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/zipcpu/2019/02/04/debugging-that-cpu.html&quot;&gt;How might you find this
bug&lt;/a&gt;?&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Desk checking&lt;/p&gt;

    &lt;p&gt;A desk check of the failing software clearly indicated that the software
shouldn’t cause a bus error.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;When I added an instruction to trigger an
&lt;a href=&quot;/blog/2017/06/08/simple-scope.html&quot;&gt;internal scope&lt;/a&gt; and
so to get a &lt;a href=&quot;/blog/2017/07/31/vcd.html&quot;&gt;trace&lt;/a&gt;, the failure
vanished.&lt;/p&gt;

    &lt;p&gt;This made me wonder, did I have a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Heisenbug&quot;&gt;Heisenbug&lt;/a&gt;?&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;If I then re-ran the broken program, it no longer failed at this same step
but instead later on.&lt;/p&gt;

    &lt;p&gt;&lt;a href=&quot;/zipcpu/2017/07/14/cpu-debugging-needs.html&quot;&gt;Restarting&lt;/a&gt;
the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; a second time brought
the bug back.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;If I stepped through the code, there was no bug.&lt;/p&gt;

    &lt;p&gt;I think this definitely meets the criteria for a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Heisenbug&quot;&gt;Heisenbug&lt;/a&gt;.&lt;/p&gt;

    &lt;p&gt;It’s also a bug you can’t let go of to come back to on another day, since it
isn’t clear that you’d be able to reproduce it some other time.  I now had
to find it while it was hot.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;/blog/2018/08/22/what-is-simulation.html&quot;&gt;Simulation&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;Okay, I gave up.  Maybe
&lt;a href=&quot;/blog/2018/08/22/what-is-simulation.html&quot;&gt;simulation&lt;/a&gt;
would help?&lt;/p&gt;

    &lt;p&gt;In this case, the design failed in
&lt;a href=&quot;/blog/2018/08/22/what-is-simulation.html&quot;&gt;Simulation&lt;/a&gt;
as well as in hardware, and with the same symptoms even.  I was on the way
to a solution!&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;You can &lt;a href=&quot;/zipcpu/2017/12/28/ugliest-bug.html&quot;&gt;read more about the story here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The bottom line was that this bug took me way too long to find, and cost me way
more project time than I wanted to devote to it.&lt;/p&gt;

&lt;p&gt;By using
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal methods&lt;/a&gt;, I have
kept this &lt;a href=&quot;https://github.com/ZipCPU/blob/master/rtl/core/pfcache.v&quot;&gt;instruction cache design
unit&lt;/a&gt; from failing
since.  Indeed, I’m now convinced that if I had used &lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal
methods&lt;/a&gt; from the get-go,
I would’ve never had this bug in the first place.&lt;/p&gt;

&lt;p&gt;In a moment, we’ll come back and test that assumption–since I’ve since built
a &lt;a href=&quot;https://github.com/ZipCPU/blob/master/rtl/core/dcache.v&quot;&gt;data cache&lt;/a&gt;
using &lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal methods&lt;/a&gt;
from the very beginning and there’s a story to share there.  First, though, I
want to share the story of a design that got missed during my switch to
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal methods&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;flash-memory-verification-error&quot;&gt;Flash Memory Verification Error&lt;/h2&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 2. A Serial port to Wishbone converter&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/wb-uart-ovw.svg&quot; alt=&quot;&quot; width=&quot;240&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;One of my recent projects involved building an FFT accelerator that
used the &lt;a href=&quot;https://riscv.org&quot;&gt;RISC-V&lt;/a&gt;
&lt;a href=&quot;https://github.com/cliffordwolf/picorv32&quot;&gt;PicoRV32&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;.
In this project, like so many others, I needed to write the
&lt;a href=&quot;https://github.com/cliffordwolf/picorv32&quot;&gt;PicoRV32&lt;/a&gt;
software to &lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt;
and then have an embedded
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;
(i.e. the &lt;a href=&quot;https://github.com/cliffordwolf/picorv32&quot;&gt;PicoRV32&lt;/a&gt; in this case)
run that program.  The first step in this process is to &lt;a href=&quot;https://github.com/ZipCPU/zipversa/blob/3a99a61b0ed531338ec745c74758f3ca5729ee4c/sw/host/flashdrvr.cpp#L413-L438&quot;&gt;read what’s currently
in the flash, and then to compare it to
what I want to be in the flash&lt;/a&gt;.  Depending
on the result of that comparison, the flash sector needs to be either erased
(bits turn to ones) and then programmed (specific bits turned to zeros), or
just programmed.  Ideally, if the design already exists in the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt; then nothing more needs
to be done.&lt;/p&gt;

&lt;p&gt;In testing, however, when I tried to load the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt;
a second time with a particular program, the comparison would fail and the
loader would say that the design needed to be loaded again, as shown
in Fig. 3 on the left.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: left; padding: 15px&quot;&gt;&lt;caption&gt;Fig 3. Comparing just-written flash memory failed&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/enough/flash-comparison.svg&quot; alt=&quot;&quot; width=&quot;240&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;This was an indication that the first effort to program the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt;
had either failed for some reason, or there was a wild pointer error writing
strange things to the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt;.
Either way, it wasn’t how things were supposed to work.&lt;/p&gt;

&lt;p&gt;My first thought was that my &lt;a href=&quot;/blog/2019/03/27/qflexpress.html&quot;&gt;updated flash
controller&lt;/a&gt; had a bug in it,
or that maybe the current
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash memory&lt;/a&gt;
I was working with had a unique feature that I wasn’t prepared for.
Much to my surprise, when I tried to reproduce the bug in
&lt;a href=&quot;/blog/2018/08/22/what-is-simulation.html&quot;&gt;simulation&lt;/a&gt;,
it failed in the exact same place with the exact same symptoms–even though I
was using an &lt;a href=&quot;https://github.com/ZipCPU/zipversa/blob/master/sim/verilator/flashsim.cpp&quot;&gt;emulated flash device&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;So I turned on the “debug by printf” feature of the &lt;a href=&quot;https://github.com/ZipCPU/zipversa/blob/master/sim/verilator/flashsim.cpp&quot;&gt;emulated flash
device&lt;/a&gt;,
and created a test: I would load the correct design into this &lt;a href=&quot;https://github.com/ZipCPU/zipversa/blob/master/sim/verilator/flashsim.cpp&quot;&gt;emulated
flash&lt;/a&gt;,
and then attempt to load my program into the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt;
a second time.  As before, the second load attempt detected a difference between
the original image and the new image, indicating that what was in the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash memory&lt;/a&gt;
didn’t match–when it was supposed to.  However, the debugging statements
indicated that the &lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash memory&lt;/a&gt;
was never changed from its initial load.&lt;/p&gt;

&lt;p&gt;Something else was wrong, and it wasn’t the &lt;a href=&quot;/blog/2019/03/27/qflexpress.html&quot;&gt;flash
controller&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;I restarted the
&lt;a href=&quot;/blog/2018/08/22/what-is-simulation.html&quot;&gt;simulation&lt;/a&gt;, this
time with &lt;a href=&quot;/blog/2017/07/31/vcd.html&quot;&gt;tracing&lt;/a&gt; enabled.
Many minutes later (it might’ve even been an hour or two …) I had a 22GB
file I could work with.&lt;/p&gt;

&lt;p&gt;I shouldn’t need to mention that 22GB is not a
&lt;a href=&quot;/blog/2017/07/31/vcd.html&quot;&gt;trace file&lt;/a&gt; size I like to
work with.  It takes forever to generate/write, and slows down my CPU user
experience.  (I’ve often noticed my favorite music stuttering during this time.)
Further, anything over about 200MB will cause
&lt;a href=&quot;http://gtkwave.sourceforge.net&quot;&gt;GTKWave&lt;/a&gt; to complain.  It also tends to lock
up my local WiFi network anytime I try to debugging on my laptop, when the
&lt;a href=&quot;/blog/2017/07/31/vcd.html&quot;&gt;trace&lt;/a&gt;
is kept on my desktop.&lt;/p&gt;

&lt;p&gt;I suppose I should point out that I tried using the
&lt;a href=&quot;/blog/2017/06/21/looking-at-verilator.html&quot;&gt;Verilator&lt;/a&gt;
FST option to generate a compressed trace.  While the result was a shorter
&lt;a href=&quot;/blog/2017/07/31/vcd.html&quot;&gt;trace&lt;/a&gt;, it took even
longer to generate.  That I even have this memory tells you that just running
the &lt;a href=&quot;/blog/2018/08/22/what-is-simulation.html&quot;&gt;simulation&lt;/a&gt;
once wasn’t enough.  It rarely is.&lt;/p&gt;

&lt;p&gt;The other problem is that it’s really hard to discover where the bug is in a
large &lt;a href=&quot;/blog/2017/07/31/vcd.html&quot;&gt;trace&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Still, I managed to find the
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;Wishbone request&lt;/a&gt;
that read from the address that was causing the fault.  (It was always the
same address, and within this section of the design the address only ever
incremented.)  Much to my surprise, the
&lt;a href=&quot;/blog/2018/08/22/what-is-simulation.html&quot;&gt;simulation&lt;/a&gt;
read the correct value from the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Then why did my load software
&lt;a href=&quot;https://github.com/ZipCPU/zipversa/blob/3a99a61b0ed531338ec745c74758f3ca5729ee4c/sw/host/flashdrvr.cpp#L429-L430&quot;&gt;report&lt;/a&gt;
that the &lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt;
didn’t match the software image, when in fact it actually did?&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 4. The bus to PC processing chain&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/enough/return-path.svg&quot; alt=&quot;&quot; width=&quot;240&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;I needed to trace this result through the design–from where I had found it
reading the correct value from the &lt;a href=&quot;https://github.com/ZipCPU/zipversa/blob/master/sim/verilator/flashsim.cpp&quot;&gt;emulated flash
device&lt;/a&gt;
all the way to the PC host software that was receiving the wrong value, as shown
in Fig. 4 on the right.&lt;/p&gt;

&lt;p&gt;Not all of the trace points were easy to work through.  The first trace point
was a
&lt;a href=&quot;https://github.com/ZipCPU/zipversa/blob/master/rtl/wbubus/wbufifo.v&quot;&gt;FIFO&lt;/a&gt;.  I
watched the correct data word go into the
&lt;a href=&quot;https://github.com/ZipCPU/zipversa/blob/master/rtl/wbubus/wbufifo.v&quot;&gt;FIFO&lt;/a&gt;.
I looked up the address it was written to, and then watched the correct word
come out of the
&lt;a href=&quot;https://github.com/ZipCPU/zipversa/blob/master/rtl/wbubus/wbufifo.v&quot;&gt;FIFO&lt;/a&gt;
a significant time later.  No errors yet.&lt;/p&gt;

&lt;p&gt;The word then went through another processing stage with no change, just
a delay.  No error there.&lt;/p&gt;

&lt;p&gt;Then it went into the &lt;a href=&quot;https://github.com/ZipCPU/zipversa/blob/master/rtl/wbubus/wbucompress.v&quot;&gt;compression algorithm&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Ouch.  Did I really need to dig into the &lt;a href=&quot;https://github.com/ZipCPU/zipversa/blob/master/rtl/wbubus/wbucompress.v&quot;&gt;compression algorithm&lt;/a&gt;?
Unlike the prior steps, it would not be easy to “see” the correct word work
its way back.  Compression could fundamentally change the word into something
else.&lt;/p&gt;

&lt;p&gt;Like any good engineer, I did what I could to avoid digging into the 
&lt;a href=&quot;https://github.com/ZipCPU/zipversa/blob/master/rtl/wbubus/wbucompress.v&quot;&gt;compression algorithm&lt;/a&gt;:
I looked at the metadata.  I watched the &lt;code class=&quot;highlighter-rouge&quot;&gt;stb&lt;/code&gt; (valid) and ready (&lt;code class=&quot;highlighter-rouge&quot;&gt;!stall&lt;/code&gt;)
signals.  I quickly noticed data changing when the downstream interface was
still stalled.  Perhaps there was a
&lt;a href=&quot;/blog/2017/08/14/strategies-for-pipelining.html&quot;&gt;pipeline&lt;/a&gt;
bug in the
&lt;a href=&quot;https://github.com/ZipCPU/zipversa/blob/master/rtl/wbubus/wbucompress.v&quot;&gt;compression algorithm&lt;/a&gt;?&lt;/p&gt;

&lt;p&gt;As it turned out, this data change was “normal”–it had just been too long
since I’d written and examined &lt;a href=&quot;https://github.com/ZipCPU/zipversa/blob/master/rtl/wbubus/wbucompress.v&quot;&gt;the
code&lt;/a&gt;,
and so I wasn’t remembering well what it was supposed to do.&lt;/p&gt;

&lt;p&gt;Nevertheless, I stepped into and through all of the steps in the
&lt;a href=&quot;https://github.com/ZipCPU/zipversa/blob/master/rtl/wbubus/wbucompress.v&quot;&gt;compression algorithm&lt;/a&gt;.  I had to.&lt;/p&gt;

&lt;p&gt;Before continuing, let me tell you a bit about this compression scheme.&lt;/p&gt;

&lt;p&gt;First, it’s part of my debugging bus protocol.  If you’ve read the &lt;a href=&quot;//blog/2017/06/05/wb-bridge-overview.html&quot;&gt;introductory
post&lt;/a&gt; in my &lt;a href=&quot;https://github.com/ZipCPU/dbgbus/tree/master/hexbus&quot;&gt;series
on building a debugging
bus&lt;/a&gt;, you’ll know that
I have two versions I use.  One is a simplified version that we built together
on the blog.  I call that one the &lt;code class=&quot;highlighter-rouge&quot;&gt;hexbus&lt;/code&gt;, since it is built around
transmitting hexadecimal numbers.  The other is my workhorse debugging bus
implementation, outlined in Fig. 2 above.  This workhorse design includes &lt;a href=&quot;https://github.com/ZipCPU/zipversa/blob/master/rtl/wbubus/wbucompress.v&quot;&gt;this
compression
module&lt;/a&gt;
within in it.  The compressor
is designed to compress 36-bit codewords, where the first 4-bits contain
meta-information, such as whether the word contains an address update, write
acknowledgment, read-return, etc., and the last 32-bits may contain encoded
data.  After the compression, the 36-bit words are broken into one or more
6-bit words followed a synchronization/end-of-word character, and these are
then mapped into printable, human-readable characters.&lt;/p&gt;

&lt;p&gt;The compression itself is based upon one of three schemes.  The first scheme
encodes the last data value into a new codeword that can be sent using a single
byte.  The second scheme encodes any one of the next eight values into what will
become a single byte again.  The third scheme encodes any of the next 512
values into what will become a two byte sequence.&lt;/p&gt;

&lt;p&gt;Sadly, this requires a compression table of 521 elements in length.  Since
FPGAs don’t offer block RAM lengths of 521 elements, I use a 1024 element
table to record the last data words I’d sent.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 5. Serial port compression algorithm&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/enough/basic-compression.svg&quot; alt=&quot;&quot; width=&quot;560&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;How does the compression work?&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Any time the host (PC) processor sets the address of a bus request, the
new address acknowledgment going back to the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;
is used as a signal to reset the compression table to zero length.  This
synchronizes any external program to the compression algorithm, especially
since multiple independent programs may want to interact with the FPGA
design over time.  (Only one will ever interact with the FPGA at any given
time.)&lt;/p&gt;

    &lt;p&gt;This is a key point.  Because I was reading from the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt;
over a long period of sequential addresses, the PC didn’t need to send new
address/synchronization requests.  This also allowed the table to fill up,
like it was supposed to, but perhaps more than it did for me normally.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Then, once a 32-bit value is read from the internal
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;Wishbone bus&lt;/a&gt;, it is
(eventually) sent to the &lt;a href=&quot;https://github.com/ZipCPU/zipversa/blob/master/rtl/wbubus/wbucompress.v&quot;&gt;compression algorithm&lt;/a&gt;
as a 36-bit data word.&lt;/p&gt;

    &lt;p&gt;This was where I was at, while following the logic through the
&lt;a href=&quot;/blog/2017/07/31/vcd.html&quot;&gt;trace&lt;/a&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The compressor immediately places this 36-bit data word onto the output.&lt;/p&gt;

    &lt;p&gt;This looked good–the 36-bit word I had been following was now on the output.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;However, since the serial port interface tends to be slow, it may take many,
many clocks for this output to be accepted.  During this time, the compressor
goes back through its past memory to see if any of the values it has sent
in the past 521 (uncompressed) samples matches this current one.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;On a match, the compression algorithm recodes the outgoing data word to
indicate a compressed codeword, and the search stops.&lt;/p&gt;

    &lt;p&gt;This was the reason I had initially thought there was a fault in the
&lt;a href=&quot;https://github.com/ZipCPU/zipversa/blob/master/rtl/wbubus/wbucompress.v&quot;&gt;compression algorithm&lt;/a&gt;–the
output was changing even though the output was stalled.  In this case, it
was the &lt;em&gt;expected&lt;/em&gt; behavior.&lt;/p&gt;

    &lt;p&gt;It’s amazing what you forget about your code between the time you write it
and the time years later you have to go back and look at it again to
understand what it’s doing when something goes wrong.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;If no matching code word is found by the time the outgoing word is ready to
be accepted, then the &lt;a href=&quot;https://github.com/ZipCPU/zipversa/blob/master/rtl/wbubus/wbucompress.v&quot;&gt;compression
algorithm&lt;/a&gt;
then writes this word to the table and knocks the last word out of the table.
All indices then advance.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;On a new word, the process starts over from step 2.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;This is sort of the background of how this algorithm is supposed to work.&lt;/p&gt;

&lt;p&gt;To find my bug, I walked through every step of this algorithm from within
the trace file.  I had to walk through each of the steps above, through the
algorithm, checking the work at every step.  I then got to the point where the
algorithm found a match from the table at 522 words ago.  (It was easy to
find–since that’s where the module output codeword changed.)  Since the number
of possible compressions is only 521 words ago, a distance further than that
should’ve been dismissed.&lt;/p&gt;

&lt;p&gt;It wasn’t.&lt;/p&gt;

&lt;p&gt;This was a serious bug.  It took a long time to find it.  The fix, once found
was easy, but finding it?&lt;/p&gt;

&lt;p&gt;So, why hadn’t I found it earlier?&lt;/p&gt;

&lt;p&gt;Let’s look a little bit deeper, and see the real story.&lt;/p&gt;

&lt;p&gt;First, understand that this algorithm was built for &lt;a href=&quot;/blog/2017/06/05/wb-bridge-overview.html&quot;&gt;one of my very first
digital designs&lt;/a&gt;–long
before I started posting all of my designs on
&lt;a href=&quot;https://github.com/ZipCPU&quot;&gt;GitHub&lt;/a&gt;, and even before I was posting them on
&lt;a href=&quot;https://opencores.org&quot;&gt;OpenCores&lt;/a&gt;.   For that early design, I verified this
&lt;a href=&quot;https://github.com/ZipCPU/zipversa/blob/master/rtl/wbubus/wbucompress.v&quot;&gt;compression algorithm&lt;/a&gt;
as part of verifying a larger project in
&lt;a href=&quot;/blog/2018/08/22/what-is-simulation.html&quot;&gt;simulation&lt;/a&gt;.
Once that larger project worked, I figured this algorithm worked as well.&lt;/p&gt;

&lt;p&gt;After being used very successfully on that first project, this design was
lifted from that project to be used on a next one.  It was then lifted from that
one to be used on another, and another, and so on.  Today, I count its use in
twelve separate designs.  Indeed, over the years that I have used this module
it has become well-honed and well trusted.&lt;/p&gt;

&lt;p&gt;Not once during this time did the design ever accumulate any automated tests,
to verify if any changes updating the design maintained the designs
functionality.&lt;/p&gt;

&lt;p&gt;This was probably my key mistake.&lt;/p&gt;

&lt;p&gt;Sometime later, after I had been using this compression design for some time,
I noticed the design was creating a synthesis warning.  For some reason, the
synthesizer was &lt;a href=&quot;https://github.com/ZipCPU/openarty/blob/69b666b68eb49b22f7d32c9501e5ae2e5618f18f/rtl/wbucompress.v#L251&quot;&gt;complaining about comparing the found code-word index against
&lt;code class=&quot;highlighter-rouge&quot;&gt;521&lt;/code&gt;&lt;/a&gt;–the
maximum table offset I had an encoding for.  The warning said there were too
many bits in the comparison.  This didn’t make sense to me.  It should
be a 10-bit comparison, but … perhaps I wasn’t seeing the problem the
synthesis tool was seeing.  So I &lt;a href=&quot;https://github.com/ZipCPU/zipversa/blob/977eca075829ec10716fb95086c7e3b65009d67a/rtl/wbubus/wbucompress.v#L251-L252&quot;&gt;removed the comparison to make the warning
go away&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Knowing I needed to test the design, I left it in my master debugging bus
repository and forgot about it.  My intent was to “verify it” when it was later
incorporated into another project.&lt;/p&gt;

&lt;p&gt;So, here I was, with a broken design and cursing my broken design process.&lt;/p&gt;

&lt;p&gt;After way too long staring at this code, I discovered the real bug: I was
&lt;a href=&quot;https://github.com/ZipCPU/openarty/blob/69b666b68eb49b22f7d32c9501e5ae2e5618f18f/rtl/wbucompress.v#L251&quot;&gt;originally comparing against&lt;/a&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;10&#39;h521&lt;/code&gt; rather than &lt;code class=&quot;highlighter-rouge&quot;&gt;10&#39;d521&lt;/code&gt;.  Look carefully.  Do you see the difference?
This bug could happen to anyone.  Had I properly created a unit verification
process for this core, I might have caught the bug long ago–or not.  I’m
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;not sure I would’ve been rigorous enough to build a test that would’ve loaded
the FPGA with this
many values&lt;/a&gt;
just to test index overflow.
That’s something only the formal solver would be annoying enough to try.&lt;/p&gt;

&lt;p&gt;There’s a lesson I learned from jumping out of airplanes that applies well
here: Back in my days as a cadet in the US Air Force Academy, I had the
opportunity to jump out of perfectly good airplanes.  It was a lot of fun.
While we all enjoyed arguing over whether this was a smart or stupid thing to
do, no one argued about whether the reserve parachute was a smart or stupid
thing to have.  Instead, we were all taught that our reserve chute was our
last chance at life–our last chance to live.  We were to protect that reserve
chute with everything we had.&lt;/p&gt;

&lt;p&gt;In many ways, the &lt;a href=&quot;/blog/2017/06/02/design-process.html&quot;&gt;debugging
bus&lt;/a&gt; has somewhat of
the same purpose–although certainly not quite as dramatic.  This, plus the
&lt;a href=&quot;/blog/2017/07/08/getting-started-with-wbscope.html&quot;&gt;scope&lt;/a&gt;
and the &lt;a href=&quot;/blog/2018/08/22/what-is-simulation.html&quot;&gt;simulator&lt;/a&gt;,
are my last lines of defense against
&lt;a href=&quot;/blog/2017/05/19/fpga-hell.html&quot;&gt;FPGA Hell&lt;/a&gt;.  If any of my
designs should’ve been &lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formally
verified&lt;/a&gt;,
it would be these ones.&lt;/p&gt;

&lt;p&gt;As an aside, I recently had the opportunity to formally verify the &lt;a href=&quot;https://github.com/ZipCPU/wbscope/blob/master/rtl/axilscope.v&quot;&gt;AXI
version&lt;/a&gt; of my 
&lt;a href=&quot;/blog/2017/07/08/getting-started-with-wbscope.html&quot;&gt;scope&lt;/a&gt;.
Much to my surprise, I also found a subtle bug that had been hiding in the
&lt;a href=&quot;/blog/2017/10/20/cdc.html&quot;&gt;clock domain crossing&lt;/a&gt;
logic of the reset signal in the &lt;a href=&quot;https://github.com/ZipCPU/wbscope/blob/master/rtl/wbscope.v&quot;&gt;Wishbone
version&lt;/a&gt;
I’d been using as well.&lt;/p&gt;

&lt;p&gt;My point?  Verify any debugging logic you use.  Getting out of
&lt;a href=&quot;/blog/2017/05/19/fpga-hell.html&quot;&gt;FPGA Hell&lt;/a&gt;
depends upon it.&lt;/p&gt;

&lt;p&gt;It’s designs like these, and hard-earned lessons like this one, that continue
to convince me that I need to use &lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal
methods&lt;/a&gt;.
Why?  Because I tend spend the longest amount of  time chasing bugs in prior
designs that were never properly verified in the first place.&lt;/p&gt;

&lt;h2 id=&quot;the-data-cache&quot;&gt;The Data Cache&lt;/h2&gt;

&lt;table align=&quot;center&quot; style=&quot;float: left&quot;&gt;&lt;caption&gt;Fig 6. The ZipCPU Data Cache&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/enough/zipcpu-lsu.svg&quot; alt=&quot;&quot; width=&quot;240&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;The third story centers around building a &lt;a href=&quot;https://github.com/ZipCPU/blob/master/rtl/core/dcache.v&quot;&gt;data
cache&lt;/a&gt; for the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Indeed, it wasn’t long after building the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
that I decided I wanted to build a
&lt;a href=&quot;https://github.com/ZipCPU/blob/master/rtl/core/dcache.v&quot;&gt;data cache&lt;/a&gt;.
Even as far back as when I first presented the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
at &lt;a href=&quot;https://orconf.org/2016/&quot;&gt;ORCONF&lt;/a&gt;, I
was using my spare time to scribble out how this
&lt;a href=&quot;https://github.com/ZipCPU/blob/master/rtl/core/dcache.v&quot;&gt;data cache&lt;/a&gt;
would work.  I then scribbled that out and started over and over again and
again.  (It didn’t help that my scribbles were being done in pen, or that
I kept finding so many bugs in the scribbles ….)  I just struggled to get
a grasp on the whole algorithm and, as I’m sure you know, details matter.&lt;/p&gt;

&lt;p&gt;That was in 2016.&lt;/p&gt;

&lt;p&gt;It wasn’t until later, in 2018, when I was preparing to &lt;a href=&quot;/tutorial/#training&quot;&gt;teach my first course
in formal methods&lt;/a&gt;
that I actually managed to get the time and focus to build it from top to
bottom.  At that time, I was experimenting with the &lt;code class=&quot;highlighter-rouge&quot;&gt;cover()&lt;/code&gt; statement, and
getting excited that I could just &lt;code class=&quot;highlighter-rouge&quot;&gt;cover()&lt;/code&gt; the data returned from the
&lt;a href=&quot;https://github.com/ZipCPU/blob/master/rtl/core/dcache.v&quot;&gt;cache&lt;/a&gt;
to get almost all the information I needed.&lt;/p&gt;

&lt;p&gt;You can see an example of what this trace might have looked like in Fig. 7,
below.  This particular trace is drawn, however, from the &lt;a href=&quot;https://github.com/ZipCPU/blob/master/rtl/core/dcache.v&quot;&gt;current
implementation&lt;/a&gt;,
rather than the original one we are discussing.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 7. Data Cache Cover Trace&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/enough/dcache8.svg&quot; alt=&quot;&quot; width=&quot;720&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Notice that in order to &lt;code class=&quot;highlighter-rouge&quot;&gt;cover()&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;o_valid&lt;/code&gt;, the formal tool needed
to generate a trace that showed:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;The &lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt; requesting to read data
from the &lt;a href=&quot;https://github.com/ZipCPU/blob/master/rtl/core/dcache.v&quot;&gt;cache&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;You can see this in Fig. 7 where &lt;code class=&quot;highlighter-rouge&quot;&gt;i_request&lt;/code&gt; goes high.  (Inside the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;, the wire name used is
&lt;code class=&quot;highlighter-rouge&quot;&gt;i_pipe_stb&lt;/code&gt;–but we’re trying to make things readable here.)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;That data had to be determined to be in a cachable address&lt;/p&gt;

    &lt;p&gt;You might notice that it takes two clocks before &lt;code class=&quot;highlighter-rouge&quot;&gt;o_wb_cyc&lt;/code&gt; goes high.
One clock is required to read from the table of
&lt;a href=&quot;https://en.wikipedia.org/wiki/Cache_(computing)&quot;&gt;cache&lt;/a&gt; tags, the second
to compare the current request against the result.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The &lt;a href=&quot;https://en.wikipedia.org/wiki/Cache_(computing)&quot;&gt;cache&lt;/a&gt;.
would’ve been empty at the time, since it was fresh from a restart.  Hence,
the requested address isn’t found in the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Cache_(computing)&quot;&gt;cache&lt;/a&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The &lt;a href=&quot;https://github.com/ZipCPU/blob/master/rtl/core/dcache.v&quot;&gt;cache logic&lt;/a&gt;
would then go out to the
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;Wishbone bus&lt;/a&gt;
and read a &lt;a href=&quot;https://en.wikipedia.org/wiki/Cache_(computing)&quot;&gt;cache line&lt;/a&gt;.
into memory.  (As shown above in Fig. 7)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Once the &lt;a href=&quot;https://en.wikipedia.org/wiki/Cache_(computing)&quot;&gt;cache line&lt;/a&gt;
was in memory, the &lt;a href=&quot;https://github.com/ZipCPU/blob/master/rtl/core/dcache.v&quot;&gt;data
cache&lt;/a&gt; would then
return the value to the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt;.&lt;/p&gt;

    &lt;p&gt;This again requires several clocks, since it costs at least one clock to
write to the cache memory, another one to check that it’s in memory, and
another one to select between several possible cache results, etc.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;I could examine all of this logic from one simple &lt;code class=&quot;highlighter-rouge&quot;&gt;cover()&lt;/code&gt; generated
&lt;a href=&quot;/blog/2017/07/31/vcd.html&quot;&gt;trace&lt;/a&gt;!&lt;/p&gt;

&lt;p&gt;Even better, were either the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt;’s or the
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;Wishbone bus protocol&lt;/a&gt;
ever violated, the &lt;code class=&quot;highlighter-rouge&quot;&gt;cover()&lt;/code&gt; request would fail and I’d get a trace showing
where the failure took place.&lt;/p&gt;

&lt;p&gt;Not only that, the proof that I was using verified that the &lt;a href=&quot;/zipcpu/2018/07/13/memories.html&quot;&gt;“right” value
would always be returned&lt;/a&gt;
by the &lt;a href=&quot;https://github.com/ZipCPU/blob/master/rtl/core/dcache.v&quot;&gt;cache&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;I had similar &lt;code class=&quot;highlighter-rouge&quot;&gt;cover()&lt;/code&gt; statements in the &lt;a href=&quot;https://github.com/ZipCPU/blob/master/rtl/core/dcache.v&quot;&gt;data cache
logic&lt;/a&gt;
to verify:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Words written to memory would go right through the
&lt;a href=&quot;https://github.com/ZipCPU/blob/master/rtl/core/dcache.v&quot;&gt;cache&lt;/a&gt;
to the bus, since I had chosen a &lt;a href=&quot;https://en.wikipedia.org/wiki/Cache_(computing)&quot;&gt;“write-through” cache
implementation&lt;/a&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Words read or written from &lt;a href=&quot;https://en.wikipedia.org/wiki/Memory-mapped_I/O&quot;&gt;non-cachable
memory&lt;/a&gt; would also go
straight to the bus&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;With no properties violated, &lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus protocols
maintained&lt;/a&gt;, and a series
of &lt;code class=&quot;highlighter-rouge&quot;&gt;cover()&lt;/code&gt; statements in hand, I was really excited to go and run
&lt;a href=&quot;https://en.wikipedia.org/wiki/Dhrystone&quot;&gt;Dhrystone&lt;/a&gt; to see how
my performance might have improved.&lt;/p&gt;

&lt;p&gt;Any guesses as to what happened?&lt;/p&gt;

&lt;p&gt;Much to my shock and surprise, the CPU with its brand &lt;a href=&quot;https://github.com/ZipCPU/blob/master/rtl/core/dcache.v&quot;&gt;new data
cache&lt;/a&gt;
installed froze when I ran it in
&lt;a href=&quot;/blog/2018/08/22/what-is-simulation.html&quot;&gt;simulation&lt;/a&gt;.
Right out of the gate.  After staring at the screen in complete puzzlement,
I restarted the
&lt;a href=&quot;/blog/2018/08/22/what-is-simulation.html&quot;&gt;simulation&lt;/a&gt;.
with &lt;a href=&quot;/blog/2017/06/21/looking-at-verilator.html&quot;&gt;tracing enabled&lt;/a&gt;, killed it, and then pulled the
&lt;a href=&quot;/blog/2017/07/31/vcd.html&quot;&gt;trace&lt;/a&gt;
up into &lt;a href=&quot;http://gtkwave.sourceforge.net&quot;&gt;GTKWave&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;It didn’t take much work to find when the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt; froze.&lt;/p&gt;

&lt;p&gt;As it turns out, I had verified every part of the &lt;a href=&quot;https://github.com/ZipCPU/blob/master/rtl/core/dcache.v&quot;&gt;data
cache&lt;/a&gt;’s operation
except one:  I never verified that the busy line would clear after
returning its result to the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Ever since, I no longer &lt;code class=&quot;highlighter-rouge&quot;&gt;cover()&lt;/code&gt; a core just returning the “right-answer” any
more.  Instead, I will always create a
&lt;a href=&quot;/blog/2017/07/31/vcd.html&quot;&gt;trace&lt;/a&gt;
showing the core returning to idle after the “right-answer” has been found.
Even better, my current &lt;code class=&quot;highlighter-rouge&quot;&gt;cover()&lt;/code&gt; checks will look into a minimum of two
requests going through the core, so I can examine what sort of overall
throughput I might expect.&lt;/p&gt;

&lt;p&gt;When trying to answer the question of whether or not formal is enough on its
own, this was a valuable lesson learned.  Since this time, however, I haven’t
found any further bugs in this core–in spite of updating it several times.
Indeed, looking back over the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blame/master/rtl/core/dcache.v&quot;&gt;commit
log&lt;/a&gt;, it looks
like all of the subsequent commits had to deal with tool issues–rather than
any more functional issues.&lt;/p&gt;

&lt;h2 id=&quot;the-new-picorv32-front-end&quot;&gt;The New PicoRV32 Front End&lt;/h2&gt;

&lt;table align=&quot;center&quot; style=&quot;float: left&quot;&gt;&lt;caption&gt;Fig 8. A basic PicoRV32-based Accelerator&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/enough/zipversa.svg&quot; alt=&quot;&quot; width=&quot;480&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;The last story focuses on the
&lt;a href=&quot;https://github.com/cliffordwolf/picorv32&quot;&gt;PicoRV32&lt;/a&gt; CPU.  In this case, a
customer had asked me to create a basic FPGA accelerator design, such as the
one shown in Fig. 8 on the right.  I chose to demonstrate this using an FFT
accelerator.  As built, the board was to receive data from GbE network, and
then the &lt;a href=&quot;https://riscv.org&quot;&gt;RISC-V&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;
within the design would then push that data through the on-chip accelerator.&lt;/p&gt;

&lt;p&gt;Of course, in the end, nothing works as desired.  The first problem I had was
the DDR3 SDRAM.  Since the goal of the project was to use entirely open source
tools, logic, and software, I needed an &lt;a href=&quot;https://github.com/ZipCPU/zipversa/blob/master/rtl/wbddrsdram.v&quot;&gt;open source DDR3
controller&lt;/a&gt;
for an ECP5.  Since this wasn’t initially available, the team chose to skip the
DDR3 SDRAM.  (There’s now a &lt;a href=&quot;https://github.com/enjoy-digital/litedram&quot;&gt;litedram
controller&lt;/a&gt; that &lt;a href=&quot;https://github.com/enjoy-digital/litedram/blob/master/litedram/phy/ecp5ddrphy.py&quot;&gt;works with the
ECP5&lt;/a&gt;.)&lt;/p&gt;

&lt;p&gt;Sadly, this had consequences.&lt;/p&gt;

&lt;p&gt;The first consequence was that the &lt;a href=&quot;https://sourceware.org/newlib/&quot;&gt;newlib
C-library&lt;/a&gt; didn’t fit into my 64kB of
block RAM.  That meant that the CPU’s instructions would need to be placed into
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash memory&lt;/a&gt;.
As you may recall from our discussions about building a &lt;a href=&quot;/blog/2019/03/27/qflexpress.html&quot;&gt;flash
controller&lt;/a&gt;,
a QSPI flash memory requires 8 serial port clocks (6 for address, and then
2 dummy clocks) just to start a transaction.  Another 8 clocks are needed
to read any 32-bit instruction word.&lt;/p&gt;

&lt;p&gt;Making matters worse, the ECP5 chip the project ran on didn’t provide first
class access to the flash clock pin.  I needed to go through a logic block
to get access to it, and that block didn’t offer access to the DDR I/O
primitives &lt;a href=&quot;/blog/2019/03/27/qflexpress.html&quot;&gt;my controller&lt;/a&gt;
needed for high speed access.  In other words, I’d need to suffer a minimum of
32 clocks per instruction access, since each SPI clock would cost two system
clocks.  When all was said and done, interfaces written, bus delays added up,
the cost ended up being closer to 38 clocks per instruction access.&lt;/p&gt;

&lt;p&gt;The next piece of this problem surrounded the
&lt;a href=&quot;https://github.com/cliffordwolf/picorv32&quot;&gt;PicoRV32&lt;/a&gt;’s interfaces.  Unlike the
&lt;a href=&quot;/zipcpu/2017/11/18/wb-prefetch.html&quot;&gt;instruction
pre-fetch interface&lt;/a&gt; I
used for the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;, the
&lt;a href=&quot;https://github.com/cliffordwolf/picorv32&quot;&gt;PicoRV32&lt;/a&gt;’s bus interface involves
setting a valid line and an address line.  The environment is then expected to
go look up what ever is at that address, and then to return it to the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;.
Further, the only difference between reading and writing is that the
&lt;a href=&quot;https://github.com/cliffordwolf/picorv32&quot;&gt;PicoRV32&lt;/a&gt; sets the write select
bits when writing–so the wrapper needs to check these as well.  Finally, the
&lt;a href=&quot;https://github.com/cliffordwolf/picorv32&quot;&gt;PicoRV32&lt;/a&gt; also includes a flag to
indicate an instruction read request rather than a memory request.&lt;/p&gt;

&lt;p&gt;While I had a &lt;a href=&quot;/zipcpu/2018/07/13/memories.html&quot;&gt;block RAM
controller&lt;/a&gt; and a &lt;a href=&quot;/blog/2019/03/27/qflexpress.html&quot;&gt;flash
controller&lt;/a&gt;
sitting on a shelf, I didn’t have a
&lt;a href=&quot;https://github.com/cliffordwolf/picorv32&quot;&gt;PicoRV32&lt;/a&gt; &lt;a href=&quot;https://github.com/ZipCPU/zipversa/blob/master/rtl/picorv/wb_picorv32.v&quot;&gt;bus control
wrapper&lt;/a&gt;
that worked with &lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;AutoFPGA’s version of
Wishbone&lt;/a&gt;.
Building this was one of the project deliverables.&lt;/p&gt;

&lt;p&gt;You can see my &lt;a href=&quot;https://github.com/ZipCPU/zipversa/blob/master/rtl/picorv/wb_picorv32.v&quot;&gt;first draft of this wrapper
here&lt;/a&gt;. 
On any new bus request, the design sends the request to the
&lt;a href=&quot;/zipcpu/2017/10/05/autofpga-intro.html&quot;&gt;AutoFPGA&lt;/a&gt; generated
bus interconnect, and then returns the result to the
&lt;a href=&quot;https://github.com/cliffordwolf/picorv32&quot;&gt;CPU&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The problem with this design is that every instruction fetch is a separate
and independent bus transaction.  As a result, when the &lt;a href=&quot;/blog/2019/03/27/qflexpress.html&quot;&gt;flash
controller&lt;/a&gt;
sees that there are no further fetches coming, it ends the burst read.
Subsequent reads will require sending the address and mode bits again.  That’s
12 clocks for the address bits, and 4 more clocks for the mode bits, for a
total of 16 extra clocks per instruction that wouldn’t be needed were
multiple requests made one after another.&lt;/p&gt;

&lt;p&gt;Therefore, once I had completed the requirements of the contract, I took a
moment to see if I might build a better
&lt;a href=&quot;https://github.com/cliffordwolf/picorv32&quot;&gt;PicoRV32&lt;/a&gt; interface.&lt;/p&gt;

&lt;p&gt;The new design &lt;a href=&quot;/zipcpu/2018/03/21/dblfetch.html&quot;&gt;followed the techniques I discussed
here&lt;/a&gt;, with just a
couple of differences.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;First, I required an extra clock to know if the requested address was
the result of a &lt;a href=&quot;https://en.wikipedia.org/wiki/Branch_(computer_science)&quot;&gt;branch
instruction&lt;/a&gt;.
In &lt;a href=&quot;/zipcpu/2017/11/18/wb-prefetch.html&quot;&gt;my own pre-fetch interface
design&lt;/a&gt; the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt; exports a wire indicating any
time the &lt;a href=&quot;https://en.wikipedia.org/wiki/Program_counter&quot;&gt;program counter&lt;/a&gt;
has changed as a result of a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Branch_(computer_science)&quot;&gt;branch&lt;/a&gt;.  Not so
with the &lt;a href=&quot;https://github.com/cliffordwolf/picorv32&quot;&gt;PicoRV32&lt;/a&gt;.  I needed
to detect this in my bus wrapper.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;I also built a deeper lookup.  Instead of looking up only two instruction
words, and then looking up the next word anytime one of those two were
accepted, I chose to lookup up four words regardless of how fast the
&lt;a href=&quot;https://github.com/cliffordwolf/picorv32&quot;&gt;PicoRV32&lt;/a&gt; consumed them.&lt;/p&gt;

    &lt;p&gt;This was a draft design after all, to see if this might help, not something
final that was going to be part of this contract.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Finally, the &lt;a href=&quot;https://github.com/cliffordwolf/picorv32&quot;&gt;PicoRV32&lt;/a&gt;
muxes both instruction and data requests together across the same external
&lt;a href=&quot;https://github.com/cliffordwolf/picorv32&quot;&gt;CPU&lt;/a&gt;
interface.  My updated &lt;a href=&quot;https://en.wikipedia.org/wiki/Prefetching&quot;&gt;prefetch&lt;/a&gt;
routine needed to handle both types of requests.  Only the instruction
stream, where I could predict the next instruction address with some
certainty, would be partially
&lt;a href=&quot;https://en.wikipedia.org/wiki/Cache_(computing)&quot;&gt;cached&lt;/a&gt;.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;a href=&quot;/formal/2018/07/14/dev-cycle.html&quot;&gt;As with any formal proof&lt;/a&gt;,
I started with the &lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus
properties&lt;/a&gt;.  I then
added further properties to include properties I felt necessary for
&lt;a href=&quot;/blog/2018/03/10/induction-exercise.html&quot;&gt;induction&lt;/a&gt;,
and also created properties to describe the CPU side of the interface.&lt;/p&gt;

&lt;p&gt;When I was confident the design worked using
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal methods&lt;/a&gt;,
I switched to simulation and immediately my “working” programs (i.e. &lt;a href=&quot;https://en.wikipedia.org/wiki/%22Hello,_World!%22_program&quot;&gt;Hello
World&lt;/a&gt;) stopped
working.&lt;/p&gt;

&lt;p&gt;What happened?&lt;/p&gt;

&lt;p&gt;In this case, the software called for a data load during one of my set of four
instruction fetches.  Instead of waiting for the series of four instruction
fetches to finish and then initiating a request for the data, the core
returned the value from the ongoing instruction fetch to the data port.&lt;/p&gt;

&lt;p&gt;Why?  Because I returned a data value on any bus acknowledgment … a simple
oversight.&lt;/p&gt;

&lt;p&gt;Couldn’t formal methods have caught this?&lt;/p&gt;

&lt;p&gt;Yes, they could’ve and they should’ve.  Why didn’t they?  Because I got sloppy.
I was trying to do something quick, and I had tried to short-circuit the
&lt;a href=&quot;/zipcpu/2018/07/13/memories.html&quot;&gt;memory property check&lt;/a&gt;
on the data bus in order to build this design on the quick.&lt;/p&gt;

&lt;p&gt;Lesson learned.&lt;/p&gt;

&lt;h2 id=&quot;the-project-with-no-bugs&quot;&gt;The Project with no bugs&lt;/h2&gt;

&lt;p&gt;The past four project stories have all involved finding ugly bugs in them.&lt;/p&gt;

&lt;p&gt;I should mention before going on that I’ve also had the experience where a
formally verified
project has no logic bugs in it.&lt;/p&gt;

&lt;p&gt;Tool issues?  Yes.  What works with the Yosys parser doesn’t necessarily work
with the Verific parser, and even that doesn’t necessarily work with Vivado or
Quartus.  What about language “standards”?  Yeah.  However, I should point out
that those who have tried my &lt;a href=&quot;/formal/2018/12/28/axilite.html&quot;&gt;formally
verified&lt;/a&gt;
&lt;a href=&quot;/blog/2019/05/29/demoaxi.html&quot;&gt;AXI&lt;/a&gt; or
&lt;a href=&quot;/blog/2019/01/12/demoaxilite.html&quot;&gt;AXI-lite slaves&lt;/a&gt;
have often commented that they’ve worked the first time.&lt;/p&gt;

&lt;p&gt;The key takeaway here is that it is possible to fully verify something using
formal methods alone.  I just need to learn how to reproduce this success in
all of my designs.&lt;/p&gt;

&lt;h2 id=&quot;lessons-learned&quot;&gt;Lessons Learned&lt;/h2&gt;

&lt;p&gt;Every year that I’ve gone to &lt;a href=&quot;https://dvcon.org&quot;&gt;DVCON&lt;/a&gt;, there’s been a
contractor or two selling “formal &lt;a href=&quot;https://en.wikipedia.org/wiki/Signoff_(electronic_design_automation)&quot;&gt;sign-off&lt;/a&gt;”
services.  I understand this to mean that by using their services, they will use
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal methods&lt;/a&gt;
to verify your design to the point where it can be trusted enough for an
&lt;a href=&quot;/blog/2017/10/13/fpga-v-asic.html&quot;&gt;ASIC&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Tape-out&quot;&gt;tape-out&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;That’s awesome.  I’ll be honest, I look up to anyone who can stand by such a
claim and ability.&lt;/p&gt;

&lt;p&gt;However, as illustrated from the examples above, this has not been my
experience in general.  While it has always been my goal, and while I’ve
had a success or two doing this, I haven’t yet been able to fully eliminate
&lt;a href=&quot;/blog/2018/08/22/what-is-simulation.html&quot;&gt;simulation&lt;/a&gt;
simulation from my personal design process.&lt;/p&gt;

&lt;p&gt;That said, these four examples above do illustrate some important takeaways:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;There’s always a need for
&lt;a href=&quot;/blog/2018/08/22/what-is-simulation.html&quot;&gt;simulation&lt;/a&gt;
in &lt;a href=&quot;https://en.wikipedia.org/wiki/Integration_testing&quot;&gt;&lt;em&gt;integration&lt;/em&gt; testing&lt;/a&gt;.&lt;/p&gt;

    &lt;p&gt;To date, I’ve only ever formally verified design &lt;em&gt;components&lt;/em&gt;, never
entire designs.  The larger the component has been, the more difficult the
formal proof becomes.  As a result, I’ve always had a need to use
&lt;a href=&quot;/blog/2018/08/22/what-is-simulation.html&quot;&gt;simulation&lt;/a&gt;
to test an entire design.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Most of my simulation testing I’ve done has tended to be rather ad-hoc.
My tests tend to be designed towards only ever demonstrate a single working
path through my design.  Indeed, simulations in general &lt;em&gt;never verify every
working path&lt;/em&gt; within a design.  Only formal does that.&lt;/p&gt;

    &lt;p&gt;The best evidence for this is the fact that I never sufficiently tested
whether element 521 could be properly returned by the compression algorithm,
but that element 522 would be properly rejected.&lt;/p&gt;

    &lt;p&gt;I am looking forward to fixing some of my personal test-script issues by
using &lt;a href=&quot;https://github.com/YosysHQ/mcy&quot;&gt;Symbiotic EDA’s new
mutation engine&lt;/a&gt;–but we’ll save the
discussion on how to use that engine for a later date.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Don’t forget to &lt;code class=&quot;highlighter-rouge&quot;&gt;cover()&lt;/code&gt; the design returning to idle.&lt;/p&gt;

    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;cover()&lt;/code&gt; is great for proving that an operation can complete, or that you
haven’t assumed away the answer.  However, just verifying that a design will
return the correct answer upon request isn’t enough–you have to &lt;code class=&quot;highlighter-rouge&quot;&gt;cover()&lt;/code&gt;
the return to the beginning or idle state.&lt;/p&gt;

    &lt;p&gt;As I mentioned above, I also like checking 2-3 transactions via a &lt;code class=&quot;highlighter-rouge&quot;&gt;cover()&lt;/code&gt;
statement, so that I can measure best-case throughput as well.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Even though the two formally verified designs above still needed to be
&lt;a href=&quot;/blog/2018/08/22/what-is-simulation.html&quot;&gt;simulated&lt;/a&gt;,
and even though new bugs were caught in that
&lt;a href=&quot;/blog/2018/08/22/what-is-simulation.html&quot;&gt;simulation&lt;/a&gt;
check, I never found more than one bug in each.&lt;/p&gt;

    &lt;p&gt;The &lt;a href=&quot;https://github.com/ZipCPU/blob/master/rtl/core/dcache.v&quot;&gt;data cache&lt;/a&gt;
has now worked for me for over a year without further logic problems.  (There
were some &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blame/master/rtl/core/dcache.v&quot;&gt;tool
incompatibilities&lt;/a&gt;
…) The &lt;a href=&quot;https://github.com/ZipCPU/blob/master/rtl/core/pfcache.v&quot;&gt;instruction
cache&lt;/a&gt;
has likewise been formally verified, and it has worked for much longer
without problems.  Indeed, it’s undergone several revisions without
suffering from any more bugs caught during
&lt;a href=&quot;/blog/2018/08/22/what-is-simulation.html&quot;&gt;simulation&lt;/a&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Individual design components need their own verification infrastructure.&lt;/p&gt;

    &lt;p&gt;This was one of the painful lessons I learned from the bus return
&lt;a href=&quot;https://github.com/ZipCPU/zipversa/blob/master/rtl/wbubus/wbucompress.v&quot;&gt;compression algorithm&lt;/a&gt;.
In this case, I had tested it as part of a larger design and missed the
difference between &lt;code class=&quot;highlighter-rouge&quot;&gt;10&#39;h521&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;10&#39;d521&lt;/code&gt;.  I then copied it from one
design to the next, to the next, to the next, and then needed to make a
change to it.  Having no method of testing the component, I instead queued
a minor disaster up for myself some time later.&lt;/p&gt;

    &lt;p&gt;Now, sadly, I’ve learned that I need to go back through this entire
debugging bus implementation in order to add in proper verification
logic–logic that should’ve been created when the design was
initially created years ago.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;There’s not a single bug listed above that could not have been caught using
either &lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal methods&lt;/a&gt;
&lt;em&gt;or&lt;/em&gt; an appropriate
&lt;a href=&quot;/blog/2018/08/22/what-is-simulation.html&quot;&gt;simulation&lt;/a&gt;.&lt;/p&gt;

    &lt;p&gt;This goes both ways.  Any bug caught via
&lt;a href=&quot;/blog/2018/08/22/what-is-simulation.html&quot;&gt;simulation&lt;/a&gt;,
but not &lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal&lt;/a&gt;, can
be turned into a formal property to be subsequently checked.  Any bug caught
via &lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal methods&lt;/a&gt;
but not
&lt;a href=&quot;/blog/2018/08/22/what-is-simulation.html&quot;&gt;simulation&lt;/a&gt;,
can be used to generate a better test script.&lt;/p&gt;

    &lt;p&gt;Indeed, my guess is that &lt;a href=&quot;/formal/2019/09/06/axi-story.html&quot;&gt;now that I’ve found bugs that weren’t caught by
Xilinx’s AXI VIP&lt;/a&gt;,
they’ll quickly adjust their product.  I certainly would if I were them.
I also expect that once these updates go through, that things that pass
their AXI VIP will look like they work again, the demonstration designs
will get fixed … and all will be look good again on the surface.  However,
the moment you make one change to those designs, everything will be up in the
air again.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Just because something “works” in practice, doesn’t truly mean it “works”&lt;/p&gt;

    &lt;p&gt;The reference to &lt;code class=&quot;highlighter-rouge&quot;&gt;10&#39;h521&lt;/code&gt; rather than &lt;code class=&quot;highlighter-rouge&quot;&gt;10&#39;d521&lt;/code&gt; existed in the compression
scheme since it was written.  It was there for many years, waiting until
just the right sequence triggered it.&lt;/p&gt;

    &lt;p&gt;Although I hadn’t noticed this bug earlier, the design never truly worked
earlier either.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The really ugly lessons learned come only after working with a design for
some period of time.&lt;/p&gt;

    &lt;p&gt;This is a sad reality of IP core development.  Just because a given IP core
works in some designs, just because it passes the threshold for the
instructor to grant an &lt;code class=&quot;highlighter-rouge&quot;&gt;A&lt;/code&gt;, or for the customer to accept the design work,
doesn’t mean it will work in all designs.  This is fundamentally the problem
with
&lt;a href=&quot;/blog/2018/08/22/what-is-simulation.html&quot;&gt;simulation&lt;/a&gt;–you
can’t test everything.&lt;/p&gt;

    &lt;p&gt;The good news is that the longer you use a given core, then (hopefully) the
closer it gets to perfection.  That is, at least until you need to rewrite
it.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Let me share one final thought:  If you choose to cut corners in verification,
like I did to test the updated
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;Wishbone&lt;/a&gt; wrapper
for the &lt;a href=&quot;https://github.com/cliffordwolf/picorv32&quot;&gt;PicoRV32&lt;/a&gt;, then it doesn’t
matter whether when using
&lt;a href=&quot;/blog/2018/08/22/what-is-simulation.html&quot;&gt;simulation&lt;/a&gt;
techniques or &lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal
methods&lt;/a&gt;.  Either way,
you are setting yourself up for getting burned later on.&lt;/p&gt;

&lt;p&gt;The good news, though, is that by using the updated wrapper I could speed up
the &lt;a href=&quot;https://github.com/cliffordwolf/picorv32&quot;&gt;PicoRV32&lt;/a&gt; by a factor of 2x.&lt;/p&gt;

&lt;p&gt;We’ll leave that thought, though, to be the topic of another article.&lt;/p&gt;
&lt;hr /&gt;&lt;p&gt;&lt;em&gt;And he began to speak unto them by parables. A certain man planted a vineyard, and set an hedge about it, and digged a place for the winefat, and built a tower, and let it out to husbandmen, and went into a far country. (Mark 12:1)&lt;/em&gt;</description>
        <pubDate>Sat, 05 Oct 2019 00:00:00 -0400</pubDate>
        <link>https://zipcpu.com/formal/2019/10/05/formal-enough.html</link>
        <guid isPermaLink="true">https://zipcpu.com/formal/2019/10/05/formal-enough.html</guid>
        
        
        <category>formal</category>
        
      </item>
    
      <item>
        <title>Quiz #6: Synchronous logic in Asynchronous contexts</title>
        <description>&lt;p&gt;This quiz is really intended for the open version of SymbiYosys.  The
open Yosys doesn’t quite implement &lt;code class=&quot;highlighter-rouge&quot;&gt;$global_clock&lt;/code&gt; properly.  According to
the SystemVerilog standard, &lt;code class=&quot;highlighter-rouge&quot;&gt;$global_clock&lt;/code&gt; is supposed to be a clock
chosen by the designer to be the default clock thoughout the design any
time a default clock is necessary throughout an entire design, rather than
(as used here) one that is set by the tools to be a formal time step.&lt;/p&gt;

&lt;p&gt;As a result, the reference to &lt;code class=&quot;highlighter-rouge&quot;&gt;$global_clock&lt;/code&gt; as used above has been
deprecated.  I also expect this non-standard usage to be removed soon enough.&lt;/p&gt;

&lt;p&gt;To fix this issue, Yosys now supports the attribute &lt;code class=&quot;highlighter-rouge&quot;&gt;(* gclk *)&lt;/code&gt; to define
a wire or register that will contain the formal timestep.  You can then use
edges of such a register, rather than &lt;code class=&quot;highlighter-rouge&quot;&gt;$global_clock&lt;/code&gt;, to specify the
formal timestep.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;gclk&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;reg&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;gbl_clk&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;always&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;posedge&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;gbl_clk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;assert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Were you using concurrent assertions, the design should read:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;gclk&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;reg&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;gbl_clk&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;assert&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;property&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;posedge&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;gbl_clk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;fell&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i_clk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|-&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;stable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;signal&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
	
&lt;span class=&quot;k&quot;&gt;assert&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;property&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;posedge&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;gbl_clk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;rose&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i_clk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|-&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;stable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;signal&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
	
&lt;span class=&quot;k&quot;&gt;assert&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;property&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;posedge&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;gbl_clk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;past&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i_clk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|-&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;stable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;signal&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;That said, only one of these captures the logic check desired.  Can you tell
which one?&lt;/p&gt;
</description>
        <pubDate>Fri, 06 Sep 2019 00:00:00 -0400</pubDate>
        <link>https://zipcpu.com/quiz/2019/09/06/quiz06.html</link>
        <guid isPermaLink="true">https://zipcpu.com/quiz/2019/09/06/quiz06.html</guid>
        
        
        <category>quiz</category>
        
      </item>
    
      <item>
        <title>AXI Verification, the story so far</title>
        <description>&lt;p&gt;&lt;a href=&quot;https://orconf.org&quot;&gt;ORCONF 2019&lt;/a&gt; is coming up, and I’m planning on presenting
slides on the topic of &lt;a href=&quot;/formal/2018/12/28/axilite.html&quot;&gt;formally verifying AXI
interfaces&lt;/a&gt;.  My intent was
just to share some of the bugs I’ve found and so to encourage folks to use
formal verification tools, such as the
&lt;a href=&quot;https://symbiyosys.readthedocs.io/en/latest&quot;&gt;SymbiYosys&lt;/a&gt; tool that I’ve been
using.  However, as I started to put the story together, I also started to
realize just how important this topic is.&lt;/p&gt;

&lt;p&gt;Here’s the bottom line: AXI is very difficult to verify using traditional
simulation based methods.  How difficult is it?  So difficult that many of the
major vendors out there have gotten it wrong.&lt;/p&gt;

&lt;p&gt;Let me back up, though, and walk you through some of the details.&lt;/p&gt;

&lt;h2 id=&quot;axi-whats-that&quot;&gt;AXI, what’s that?&lt;/h2&gt;

&lt;p&gt;It begins with the chip manufacturing industry.  There are a lot of companies
out there building their own special and secret sauce into digital electronics.
The reality, though, is that many of the tasks these chips are responsible
for performing are challenging to do in raw digital hardware.  It’s not that
they cannot be done, but rather that it’s a lot easier to do them in software.
That means that if you want to build a custom silicon widget, you are likely
to want to include a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;
into your custom widget as well.&lt;/p&gt;

&lt;p&gt;While building a basic
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;
may be a college student’s class project, building and maintaining the
assembler, linker, compiler, debugger, and indeed the whole tool chain is a
task few design houses want to take on for themselves.  It’s just easier to
purchase someone else’s
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;,
rather than to handle all of this work yourself.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 1. A basic AXI bus structure&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/axi-story/axi-in-everything.svg&quot; alt=&quot;&quot; width=&quot;360&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;One of the most popular
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;s
in the embedded sub-chip IP market is the
&lt;a href=&quot;https://en.wikipedia.org/wiki/ARM_architecture&quot;&gt;ARM&lt;/a&gt;.  While
&lt;a href=&quot;https://riscv.org&quot;&gt;RISC-V&lt;/a&gt; may well give
&lt;a href=&quot;https://en.wikipedia.org/wiki/ARM_architecture&quot;&gt;ARM&lt;/a&gt;
a run for their money, much of the industry has already standardized
around a set of &lt;a href=&quot;https://en.wikipedia.org/wiki/ARM_architecture&quot;&gt;ARM&lt;/a&gt; bus
protocol standards drawn from the &lt;a href=&quot;https://en.wikipedia.org/wiki/Advanced_Microcontroller_Bus_Architecture&quot;&gt;AMBA bus protocol
set&lt;/a&gt;.
Of these, the high bandwidth standard is clearly
&lt;a href=&quot;/blog/2019/05/29/demoaxi.html&quot;&gt;AXI&lt;/a&gt;.  As a result, if you
want to connect your secret sauce to a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt; hidden inside
your proprietary integrated circuit technology, you are likely going to be
using an &lt;a href=&quot;/blog/2019/05/29/demoaxi.html&quot;&gt;AXI bus&lt;/a&gt; to connect
the pieces together.&lt;/p&gt;

&lt;p&gt;Recognizing this reality, and the fact that
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGAs&lt;/a&gt; are
often used to test the logic within integrated circuits before &lt;a href=&quot;/blog/2017/10/13/fpga-v-asic.html&quot;&gt;burning
them into actual hardware&lt;/a&gt;,
the two major
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt; vendors
have been offering &lt;a href=&quot;/blog/2019/05/29/demoaxi.html&quot;&gt;AXI&lt;/a&gt;
based tooling for some time.  This includes not only the
&lt;a href=&quot;/blog/2019/07/17/crossbar.html&quot;&gt;AXI bus fabric&lt;/a&gt; that connects
everything together, but also several basic design components like &lt;a href=&quot;https://en.wikipedia.org/wiki/Synchronous_dynamic_random-access_memory&quot;&gt;SDRAM
controllers&lt;/a&gt;, memory movers,
&lt;a href=&quot;https://en.wikipedia.org/wiki/Direct_memory_access&quot;&gt;DMA&lt;/a&gt;
engines, &lt;a href=&quot;/blog/2018/11/29/llvga.html&quot;&gt;video controllers&lt;/a&gt;,
&lt;a href=&quot;/blog/2019/03/27/qflexpress.html&quot;&gt;flash controllers&lt;/a&gt;, as well
as example designs so that their users can get more value from their hardware.
These basic &lt;a href=&quot;/formal/2019/05/13/axifull.html&quot;&gt;AXI&lt;/a&gt;
designs are offered for free to anyone who uses their tools.  As a result, the
example designs in particular have become rather ubiquitous–so much so that
any error in one or the other tends to show up over and over again in the
code of anyone who used that example as a foundation for their own work.  Again,
this shouldn’t be surprising to anyone.&lt;/p&gt;

&lt;h2 id=&quot;formal-methods&quot;&gt;Formal methods&lt;/h2&gt;

&lt;p&gt;This was where I entered the picture.  In October, 2017, &lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;I tried out formal
methods&lt;/a&gt; for the
first time on what I thought was a fairly basic and simple design.  My plan
was just to write a review about some new “formal verification” fad and then
to go back to &lt;a href=&quot;/blog/2017/06/02/design-process.html&quot;&gt;digital design the way I had been doing
it&lt;/a&gt;.  My plan changed
when the tool found bugs in my design.  So I then tried applying the tool to
another one of my “working” designs.  The same thing happened, the tool found
bugs in it.  Valid bugs.  &lt;a href=&quot;/blog/2018/01/22/formal-progress.html&quot;&gt;Over and over I applied the formal
tools&lt;/a&gt;
to my designs and found more and more bugs.&lt;/p&gt;

&lt;p&gt;To understand how significant these bugs were, consider these: an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Synchronous_dynamic_random-access_memory&quot;&gt;SDRAM&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/xulalx25soc/blob/master/rtl/wbsdram.v&quot;&gt;controller&lt;/a&gt;
that might fetch the wrong memory address, a
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt; &lt;a href=&quot;https://en.wikipedia.org/wiki/Cache_(computing)&quot;&gt;instruction
cache&lt;/a&gt; that &lt;a href=&quot;/zipcpu/2017/12/28/ugliest-bug.html&quot;&gt;returned the
wrong instruction&lt;/a&gt;,
or even an &lt;a href=&quot;/dsp/2018/10/02/fft.html&quot;&gt;FFT&lt;/a&gt; that worked for one
set of sizes and bit widths but not for others.  The list goes on.&lt;/p&gt;

&lt;p&gt;Eventually, I stopped verifying my designs after the fact and &lt;a href=&quot;/formal/2018/07/14/dev-cycle.html&quot;&gt;started going
straight to formal verification tools before ever picking up a
simulator&lt;/a&gt;.  Design has
never been &lt;a href=&quot;/formal/2019/08/03/proof-duration.html&quot;&gt;so fast&lt;/a&gt;
or so easy as a result.  Indeed, the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/dcache.v&quot;&gt;data
cache&lt;/a&gt; that I
had wanted to build for years suddenly came together inside of two weeks.&lt;/p&gt;

&lt;p&gt;By the end of 2018, I’d also struggled many times to build my own AXI
interface components.  In &lt;a href=&quot;/blog/2019/04/27/axi-addr.html&quot;&gt;one particularly painful
example&lt;/a&gt;, I was forced
to deliver a design to a customer that didn’t live up to the promises I had
made to him.  Even now, most of my work has been done using
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;Wishbone&lt;/a&gt;–it’s much
&lt;a href=&quot;/zipcpu/2017/05/29/simple-wishbone.html&quot;&gt;simpler to use&lt;/a&gt;.
Sadly, though, if you want to interact with the modern
&lt;a href=&quot;https://en.wikipedia.org/wiki/ARM_architecture&quot;&gt;ARM&lt;/a&gt;+&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
SOC chips like either Xilinx’s Zynq or one of &lt;a href=&quot;/blog/2018/02/09/first-cyclonev.html&quot;&gt;Intel’s
SOC&lt;/a&gt;s, you will
(eventually) &lt;a href=&quot;/blog/2019/04/27/axi-addr.html&quot;&gt;need to learn to speak
AXI&lt;/a&gt;.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: left; padding: 15px&quot;&gt;&lt;caption&gt;Fig 2. Verification using a formal property file(s)&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/axi-story/fp-file.svg&quot; alt=&quot;&quot; width=&quot;320&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;As I mentioned above, my first attempts at building AXI components dismal
failures.  My second set of attempts weren’t much better.  Finally, somewhere
around last Christmas time, I started picking up AXI and formal verification
together.  I first &lt;a href=&quot;/formal/2018/12/28/axilite.html&quot;&gt;built a set of formal properties for
AXI-lite&lt;/a&gt;, and then again
later for &lt;a href=&quot;/formal/2019/05/13/axifull.html&quot;&gt;AXI&lt;/a&gt;.  These
properties make it easy to verify &lt;a href=&quot;/blog/2019/05/29/demoaxi.html&quot;&gt;AXI
bus&lt;/a&gt; components–much easier
than &lt;a href=&quot;/blog/2018/08/22/what-is-simulation.html&quot;&gt;simulation&lt;/a&gt;
alone.  The neat thing about this approach is that the property files can then
be reused from one AXI design to another with only minimal configuration
and set up.  Hence, once I built one design, getting the next one right became
easier.&lt;/p&gt;

&lt;p&gt;Not knowing whether or not I understood the bus standard well enough, my first
&lt;a href=&quot;/formal/2018/12/28/axilite.html&quot;&gt;AXI-lite&lt;/a&gt; and
&lt;a href=&quot;/formal/2019/05/13/axifull.html&quot;&gt;AXI&lt;/a&gt; verification
projects were to verify any publicly available code I could get my hands on.  I
started with Xilinx’s example code, and then moved on to verifying several
projects on Github, and finally looked into Intel’s example AXI code.
I was expecting to find examples that met the &lt;a href=&quot;/doc/axi-spec.pdf&quot;&gt;AXI
standard&lt;/a&gt; that I could then learn from.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 3. Most example designs have two parts&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/axi-story/ex-design.svg&quot; alt=&quot;&quot; width=&quot;320&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Let me pause at this point to describe what I mean by an “example” design,
or even a “demonstration” design.  These are vendor provided example logic
designs, such as the one illustrated in Fig. 3 on the right and typically
written in Verilog, VHDL, or both, that show the proper
interaction between a bus component and the bus.  Typically, they are written
in a fashion so that you can adjust a user logic section however
you might like, while another portion of the design provided by the vendor
handles all of the more difficult AXI bus interaction logic.&lt;/p&gt;

&lt;p&gt;Much to my surprise, most of the cores I examined had bugs in them.
I’ve &lt;a href=&quot;https://twitter.com/ZipCPU&quot;&gt;tweeted&lt;/a&gt; about many of these, and so now
I’m collecting these examples into some slides that I can present at
&lt;a href=&quot;https://orconf.org&quot;&gt;ORCONF&lt;/a&gt; in just a couple of weeks.&lt;/p&gt;

&lt;h2 id=&quot;its-worse-than-a-software-bug&quot;&gt;It’s worse than a software bug&lt;/h2&gt;

&lt;p&gt;One of the jokes in the flying world is that pilots need to maintain “the
ratio”: one safe landing for every take off.  AXI bus interactions are
in many ways no different, there needs to be one response for every request.
Further, just as most airplanes don’t offer ejection seats or parachutes,
AXI doesn’t offer a “bus abort” capability.  As a result, if you fail to
keep the “ratio” then really “bad” things will happen.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: left; padding: 15px&quot;&gt;&lt;caption&gt;Fig 4. Every request must get a response&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/axi-story/request-response.svg&quot; alt=&quot;&quot; width=&quot;320&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;What kind of “bad” things are we talking about?  In the case of a bus,
a bus master makes a request–whether or read or write–and the slave responds.
In the case of AXI, the fact that it has no abort capability means that a master
must wait for a response until it arrives.  The standard doesn’t allowed it to
time out and give up after waiting a second, minute, hour, or year.  Even
if the response gets dropped or otherwise becomes missing, the master must
still wait for a response.&lt;/p&gt;

&lt;p&gt;Sadly, I discovered the problem with this in my first &lt;a href=&quot;/blog/2018/02/09/first-cyclonev.html&quot;&gt;Cyclone-V
SOC&lt;/a&gt;
design.  At one point when I had a mistake within my own logic so that the
design didn’t respond to the bus like it was supposed to, the bus and the
&lt;a href=&quot;https://en.wikipedia.org/wiki/ARM_architecture&quot;&gt;ARM&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;
driving the bus, locked up hard.  Only a reset, forcing a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;
reboot, fixed the bug.&lt;/p&gt;

&lt;p&gt;In my example, I was lucky.  Knowing that there was a bug in my design, I was
able to then turn around and &lt;a href=&quot;/blog/2017/06/21/looking-at-verilator.html&quot;&gt;simulate my
design&lt;/a&gt; and
find the bug.  I haven’t always been this lucky, and things could’ve been much
worse.  Had I not been able to reproduce the bug in
&lt;a href=&quot;/blog/2018/08/22/what-is-simulation.html&quot;&gt;simulation&lt;/a&gt;,
I might have ended up stuck in &lt;a href=&quot;/blog/2017/05/19/fpga-hell.html&quot;&gt;FPGA
Hell&lt;/a&gt; myself, staring
at a flawed design with no idea how to fix it.&lt;/p&gt;

&lt;p&gt;Others haven’t been so lucky.&lt;/p&gt;

&lt;p&gt;Even among those who ask for help there are a lot of problems that can’t be
solved by a disinterested stranger looking over unfamiliar logic.  It’s only
gets worse when you have no clue where to start looking, as might happen
with a design that suddenly locks up the whole system.&lt;/p&gt;

&lt;p&gt;You need to understand, this isn’t a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Kernel_panic&quot;&gt;kernel panic&lt;/a&gt;
type of bug.  We’re not talking about the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Blue_Screen_of_Death&quot;&gt;blue sceen of death&lt;/a&gt;
here either.  Nor are we talking
about bugs where your &lt;a href=&quot;https://en.wikipedia.org/wiki/Segmentation_fault&quot;&gt;application just
failed&lt;/a&gt;.  No, we are
talking about something even more severe.  A fault in the
&lt;a href=&quot;/formal/2019/05/13/axifull.html&quot;&gt;AXI bus&lt;/a&gt; structure
whereby a component fails to respond properly is catastrophic.  The result
will be a whole system crash so hard that only a power cycle can fix it.&lt;/p&gt;

&lt;p&gt;Given that &lt;a href=&quot;/blog/2017/07/08/getting-started-with-wbscope.html&quot;&gt;I use the bus for
debugging&lt;/a&gt;,
such a crash leaves me blind to the cause.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 5. Two types of catastrophic bugs&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/axi-story/catastrophic-two-types.svg&quot; alt=&quot;There are two types of catastrophic bugs: those that return too few responses, and those that return too many&quot; width=&quot;320&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;So what kind of bugs did I find?  I found both types of catastrophic bugs.  Not
only did I find peripherals that didn’t produce as many responses as requests
they had received, but I also found bus masters that would drop requests before
the bus had accepted them.&lt;/p&gt;

&lt;p&gt;In one &lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt; I examined
from a major vendor, two load or two store instructions, back to back, would
cause a transaction to be dropped if the interconnect wasn’t immediately ready
to receive to the request.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: left; padding: 15px&quot;&gt;&lt;caption&gt;Fig 6. An interconnect bug&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/axi-story/buggy-interconnect.svg&quot; alt=&quot;Interconnect routes a slaves response to the wrong master&quot; width=&quot;480&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Worse, I even found an
&lt;a href=&quot;/blog/2019/07/17/crossbar.html&quot;&gt;interconnect&lt;/a&gt;,
something that connects multiple masters to multiple peripherals such as the
one shown in Fig. 6, where a request from one master would get sent to the
correct slave, but then the response from the slave would be returned back
to a different master.&lt;/p&gt;

&lt;p&gt;It wasn’t pretty.&lt;/p&gt;

&lt;p&gt;Indeed, I found bugs in a very large percentage of the cores I examined.&lt;/p&gt;

&lt;p&gt;It didn’t help that many demonstration cores, and how-to blog articles
I found had bugs in their example cores that were then copied into various
user designs.  Neither did it help that the example designs from &lt;em&gt;both&lt;/em&gt; major
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
vendors had catastrophic bugs within them.&lt;/p&gt;

&lt;p&gt;As you might imagine, I was rather perplexed by this.  In many ways, none of
this made any sense.  If these problems were really so bad, how was it that
no one had noticed them?&lt;/p&gt;

&lt;p&gt;One possibility was that each vendor only checked their cores in their own
environment, and somehow the environment was masking the bugs.  As an example,
some of the bugs I found would be only triggered if the bus was ever used in
a particular configuration.  I also found that one vendor had crippled
the throughput of their interconnect–perhaps because no one really knew who or
what was responsible for the user bugs.
[&lt;a href=&quot;/zipcpu/2019/02/09/cpu-blinky.html&quot;&gt;1&lt;/a&gt;] [&lt;a href=&quot;/blog/2019/05/29/demoaxi.html&quot;&gt;2&lt;/a&gt;]&lt;/p&gt;

&lt;p&gt;So I started browsing and participating in various forums.&lt;/p&gt;

&lt;h2 id=&quot;working-the-forums-for-answers&quot;&gt;Working the forums for answers&lt;/h2&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 7. Digilent&#39;s Popular Contributors&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/axi-story/leader-board.png&quot; alt=&quot;&quot; width=&quot;296&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Back in the beginning, when I first started to try to sell my services as an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
design engineer, I worked &lt;a href=&quot;/digilent/2017/05/18/most-common-digilent-support-requests.html&quot;&gt;Digilent’s
forums&lt;/a&gt;
fairly hard in the hopes that I might gain some free publicity and perhaps
even a contract.
Even to this date I’m one of their leading all time contributors, even though
I’ve stopped working the forum as hard and the forum moderator’s have since
caught up and one has passed me.
Since I had just left the military service, I was hoping this might be a way
to find some commercial work.  The technique worked well, since I found
two contracts, several long-term business relationships, and even some free
hardware as a result of it–such as a &lt;a href=&quot;https://store.digilentinc.com/nexys-video-artix-7-fpga-trainer-board-for-multimedia-applications&quot;&gt;Nexys Video
board&lt;/a&gt;
and even a &lt;a href=&quot;/blog/2017/09/14/even-i-get-stuck.html&quot;&gt;Digital
Discovery&lt;/a&gt;.
This time, however, I worked up the chain on the major vendor’s forums, rather
than those of their outlets.  Specifically, I was looking for examples of the
bugs listed above, or if not then I was hoping to discover why they weren’t
being triggered.  I was also looking for example designs to check my formal
property files against.&lt;/p&gt;

&lt;p&gt;While much of what I found was fairly benign, such as brand-new students
struggling to figure out their engineering design homework, there were
also many professional design engineers participating in these forums and
asking for help regarding the problems they had come across.&lt;/p&gt;

&lt;p&gt;In one conversation, I came across a user asking for help whose AXI slave
design wasn’t working.  When I asked if he would try my own &lt;a href=&quot;/formal/2019/01/12/demoaxilite.html&quot;&gt;formally verified
design&lt;/a&gt;,
he tried it and the bugs went away.  Sadly, we never found or identified the
bug(s) in his own (VHDL) code–perhaps because he never shared enough of his
design.  Incidentally, when I offered him &lt;a href=&quot;/formal/2019/01/12/demoaxilite.html&quot;&gt;my own design to
try&lt;/a&gt;,
I never told him that this was the first time the core had been tried in either
hardware or simulation.  It “just worked” the first time.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: left; padding: 15px&quot;&gt;&lt;caption&gt;Fig 8. Updating software breaks the hardware design&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/axi-story/new-software.svg&quot; alt=&quot;&quot; width=&quot;240&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;In another conversation, an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
design engineer had built a design and delivered it to his product team in
a “working” condition for the software programmer to take over.  The design
contained a &lt;a href=&quot;https://en.wikipedia.org/wiki/MicroBlaze&quot;&gt;MicroBlaze&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt; and whatever
application sauce they were putting into it, such as is shown in Fig. 8.  This
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
design engineer then left the company.  Some time later, the software
engineer made some changes to his
&lt;a href=&quot;https://en.wikipedia.org/wiki/MicroBlaze&quot;&gt;MicroBlaze&lt;/a&gt; software–not the
hardware design, but the software for the
&lt;a href=&quot;https://en.wikipedia.org/wiki/MicroBlaze&quot;&gt;MicroBlaze&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;
within it.  The result was that the design locked up following two adjacent
store instructions and no one could understand why.  This pattern also matched
the bugs that I had found.&lt;/p&gt;

&lt;p&gt;Someone else posted on a &lt;a href=&quot;https://reddit.com/r/FPGA&quot;&gt;Reddit forum&lt;/a&gt; that their
design wasn’t working, curious if anyone had seen similar problems before.  I
asked if he had formally verified his design.  Instead of responding to
me, he turned around and posted on the vendor’s forum no longer asking but
now declaring that their
interconnect was broken.  Again, I asked if he had formally verified his
design or, if not, if he’d release his source code and I’d check it for him.  He
then proceeded to ignored me for a second time and instead posted a trace that
was supposed to show the bug.  When you looked closer at the trace, however,
you found a bug within his core and not the interconnect: one request was
creating two responses.  His design wasn’t keeping up the “ratio”.  Formal
methods would’ve caught that.&lt;/p&gt;

&lt;p&gt;Another engineer posted, wondering what was wrong with the vendor tools.
When I asked if he could or would share his source, he refused.  Sadly, this
is a rather common though unfortunate answer.  Digital logic is designed and
sold, and protecting the market tends to keep corporations tight-lipped about
their secret algorithms–since it represents real money to them.  Instead,
this engineer offered a “sanitized” version of what he was doing.  With the
&lt;a href=&quot;/formal/2019/04/16/axi-mistakes.html&quot;&gt;experience I had gained from formal
methods&lt;/a&gt;, I could
clearly see the bug in even his sanitized design–although I have to believe
it must’ve passed his test bench for him to even open up like that.&lt;/p&gt;

&lt;p&gt;When I dug further into the forums, I found several examples of folks who had
written in, not knowing why their design was failing, but for whom no one had
responded.&lt;/p&gt;

&lt;p&gt;I also looked into any example code I could find.  I noticed that most of the
examples I found followed the vendor’s examples.  This made it fairly easy
to verify, since once I had verified one example any others that looked like
it tended to have the same bugs.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 9. Vendor interconnect logic, with multiple internal implementations&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/axi-story/vendor-interconnect.svg&quot; alt=&quot;&quot; width=&quot;320&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;At one point, I even looked into a major vendor’s interconnect structure.  I
was hoping I might be able to apply the formal tools to it, having &lt;a href=&quot;/blog/2019/07/17/crossbar.html&quot;&gt;verified
my own interconnect&lt;/a&gt; and
also since I had found some severe bugs in an academic’s interconnect–as
mentioned above.  As I worked through this design to determine if it would
even be possible to set up the tools (it wasn’t–not all of the code was
available as shown in Fig. 9), I noticed an
optional “feature”: The default setting of their interconnect
would allocate a channel from the master to the slave and at the same time from
the slave to the master.  This channel would then remain allocated until all
transactions had completed–much like my own
&lt;a href=&quot;/blog/2019/07/17/crossbar.html&quot;&gt;crossbar design&lt;/a&gt;.
An optional setting would activate a different implementation, one that would
route transaction requests in packets to the slaves,
and then route them back to the masters in a way that required bus arbitration
in both directions.  As a result of the second “return” arbitration, the slave
would experience “&lt;a href=&quot;https://en.wikipedia.org/wiki/Back_pressure&quot;&gt;back
pressure&lt;/a&gt;”–a necessary trigger
condition for some (but not all) of the bugs I had found.  This second
implementation would’ve clearly triggered the bugs that I had found, whereas
the first might not have.  Given the code I examined, it is quite possible that
a failure to test all configurations of this vendor’s design might’ve
contributed to the problem manifesting in some designs and not others.&lt;/p&gt;

&lt;p&gt;In another example from the same interconnect logic, I noticed that the
vendor crippled both read and write channels in their AXI-lite to AXI bridge.
This surprised me.  Bridging from &lt;a href=&quot;https://github.com/ZipCPU/wb2axip/blob/master/rtl/axilite2axi.v&quot;&gt;AXI-lite to
AXI&lt;/a&gt; is really
easy to do, requiring almost no logic.  Then I realized, their crippled design
probably kept some of these &lt;a href=&quot;/formal/2018/12/28/axilite.html&quot;&gt;AXI-lite
bugs&lt;/a&gt;
from triggering.  This appeared to be either a consequence of an engineer
trying to fix an ill-defined logic bug, or perhaps it was legacy code
remaining from a protocol version (AXI3) that had since fallen out of favor.&lt;/p&gt;

&lt;p&gt;I also discovered a more shocking reason why many of these bugs may have stayed
hidden, while examining some
&lt;a href=&quot;https://en.wikipedia.org/wiki/Direct_memory_access&quot;&gt;DMA&lt;/a&gt; reset questions.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 10. DMA&#39;s are used for automatic data copying&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/axi-story/dma-copy.svg&quot; alt=&quot;&quot; width=&quot;560&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;For those who are not familiar with a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Direct_memory_access&quot;&gt;DMA&lt;/a&gt;, it’s basically
a hardware component that copies data from one bus slave to another.  My own
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/wbdmac.v&quot;&gt;WB DMA&lt;/a&gt;,
works by first copying the data to an internal memory, and only then writes
it back to the bus.  It will do this several times if necessary.  If it
ever encounters a bus error,
such as I sometimes generate from a slave failing to respond,
it issues a bus abort, ends the transaction, and reports an error.&lt;/p&gt;

&lt;p&gt;This is not as easy to do with AXI.&lt;/p&gt;

&lt;p&gt;In this case, several customers had posted to the forum over a couple of days
asking asking whether or not it was possible to interrupt an ongoing
&lt;a href=&quot;https://en.wikipedia.org/wiki/Direct_memory_access&quot;&gt;DMA&lt;/a&gt;
transaction.  Apparently, these customers were trying to copy data between a
user logic core and memory and the bus was locking up mid-transaction.  They
wanted to find out how to abort the transaction.  I replied to these
individuals that there is no such thing as a bus abort in AXI: every
transaction request must receive a response.  There’s no way to timeout
a transaction.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: left; padding: 15px&quot;&gt;&lt;caption&gt;Fig 11. Using an AXI Fault Isolator&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/axi-story/axi-fault-isolator.svg&quot; alt=&quot;&quot; width=&quot;320&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Well, not quite.  There is one way to timeout a transaction.  You can use a
“firewall” of some type, such as this &lt;a href=&quot;https://github.com/ZipCPU/wb2axip/blob/master/rtl/axisafety.v&quot;&gt;bus
fault isolator&lt;/a&gt;,
to catch bugs in a faulty AXI slave.  If placed between the slave and the rest
of the bus logic, as shown in Fig. 11, it will catch faults and then isolate
the downstream slave from the rest of the system–keeping those faults from
propagating upstream and becoming catastrophic.  Of course, once the fault
is detected, you still don’t know if a subsequent response was for the
missing earlier response or not.  As a result, you can even configure 
&lt;a href=&quot;https://github.com/ZipCPU/wb2axip/blob/master/rtl/axisafety.v&quot;&gt;the core&lt;/a&gt;
to then reset the downstream slave as well.&lt;/p&gt;

&lt;p&gt;Unfortunately, this approach is not a cure-all.  Placing the &lt;a href=&quot;https://github.com/ZipCPU/wb2axip/blob/master/rtl/axisafety.v&quot;&gt;bus fault
isolator&lt;/a&gt;
between the interconnect and user logic will slow the user logic transactions
down to one at a time.  As a result, just placing
&lt;a href=&quot;https://github.com/ZipCPU/wb2axip/blob/master/rtl/axisafety.v&quot;&gt;this core&lt;/a&gt;
between the interconnect and user logic may resolve the problem just by
itself–even if it never detects a fault.&lt;/p&gt;

&lt;p&gt;Still, I shared this possibility on several of these forum threads.  If nothing
else, it would’ve helped isolate the cause of the problem.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 12. Unflattering posts were deleted&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/axi-story/deleted-post.svg&quot; alt=&quot;&quot; width=&quot;320&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;What surprised me the most about this these
&lt;a href=&quot;https://en.wikipedia.org/wiki/Direct_memory_access&quot;&gt;DMA&lt;/a&gt;
reset inquiries was that the &lt;em&gt;vendor then deleted all but one of the three
threads&lt;/em&gt; when it became apparent that it wasn’t going to be flattering to their
product line or to the bus structure they had chosen.  This left me wondering,
&lt;em&gt;how many other forum posts regarding these bugs have been deleted?&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Yes, this problem runs deep.  It also appears to be hard to find.&lt;/p&gt;

&lt;h2 id=&quot;why-havent-these-bugs-been-caught&quot;&gt;Why haven’t these bugs been caught?&lt;/h2&gt;

&lt;p&gt;Digital design has been around for a while, so why haven’t these problems been
caught before?  Why do they remain so hard to find?&lt;/p&gt;

&lt;p&gt;I think the answer to this question comes down to how digital designs are
tested and verified in the first place.  The standard test methodology
requires you to write a &lt;a href=&quot;https://www.xilinx.com/support/documentation/sw_manuals/xilinx10/isehelp/ise_c_simulation_test_bench.htm&quot;&gt;test bench&lt;/a&gt;
that exercises your design.  Much as I discovered with &lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;my first experience
with formal methods&lt;/a&gt;,
such test benches tend to only examine a “normal” design path.  In my case,
my own FIFO test bench didn’t check all combinations of reading and writing to
either full or empty FIFOs.&lt;/p&gt;

&lt;p&gt;My best guess is that the same thing is going on here.&lt;/p&gt;

&lt;p&gt;I know one individual who wrote in to Xilinx’s forums proudly proclaimed
that his core had passed Xilinx’s (AXI VIP/simulation based) verification
and so any problem he was having must be Xilinx’s fault.  Sadly, their
verification step left him believing that his user core worked, even
though it still suffered from the &lt;a href=&quot;/formal/2018/12/28/axilite.html&quot;&gt;same AXI-lite
bugs&lt;/a&gt; I had already found.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: left; padding: 15px&quot;&gt;&lt;caption&gt;Fig 13. Simulation scripts rarely test everything&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/axi-story/sim-script.svg&quot; alt=&quot;&quot; width=&quot;320&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;The basic problem is that if
you only ever test your AXI user component against one transaction at a time,
you’ll miss most of these bugs: You’ll start your simulation with a bus
master initiating a transaction while the slave is already waiting for it.
The simulated slave will then respond to the waiting master and voila you’ll
convince yourself that your design works even when you haven’t checked all
conditions.  What then happens if the interconnect sends another request
before the first one has returned?  It wasn’t tested.  What happens if either
the interconnect or bus the master aren’t yet ready to receive the bus slave’s
response?  Not tested.  Might the slave
ever lock up, due to conditions that aren’t simulated, to where it stops
processing the bus request?  These aren’t things that are normally tested in
&lt;a href=&quot;/blog/2018/08/22/what-is-simulation.html&quot;&gt;simulation&lt;/a&gt;,
but they do happen in real life.&lt;/p&gt;

&lt;p&gt;Consider the &lt;a href=&quot;https://en.wikipedia.org/wiki/Direct_memory_access&quot;&gt;DMA&lt;/a&gt;
discussion above.  A good
&lt;a href=&quot;https://en.wikipedia.org/wiki/Direct_memory_access&quot;&gt;DMA&lt;/a&gt;
will push as much data into and through a core as fast as the bus will allow,
yet the simulation approach we just discussed above will never test for this.&lt;/p&gt;

&lt;p&gt;Consider the example of the vendor’s interconnect as well, shown in Fig. 9
above.  If the interconnect has to arbitrate response packets back to the
master that sent them, then it may not be ready to receive a particular
response if another slave has the return grant to that master.  This
didn’t get tested either.&lt;/p&gt;

&lt;p&gt;What about the crippled channels?  If you had enabled them to be full speed,
by packing request after request, many of these example designs would break.
Again, this is something you won’t test if you just tested one transaction
at a time in a simulation.&lt;/p&gt;

&lt;p&gt;Some weeks ago an engineer wrote to me and asked if I had a test bench for &lt;a href=&quot;/formal/2019/01/12/demoaxilite.html&quot;&gt;one
of my cores&lt;/a&gt;.  You
know, he said, something where he might write:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;&lt;span class=&quot;n&quot;&gt;read_transaction&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;address&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;write_transaction&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;address&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;I was floored.  Indeed, I didn’t even know where to start.  Any test bench
that only checked one transaction at a time, or waited for the read transaction
to finish before starting a write transaction would mask many if not all of
the bugs I had found.&lt;/p&gt;

&lt;p&gt;On the other hand, this is &lt;a href=&quot;/blog/2017/09/18/clocks-for-sw-engineers.html&quot;&gt;how &lt;em&gt;software&lt;/em&gt; engineers
think&lt;/a&gt;,
since &lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;s
can only ever do one thing at a time: test this, then test that.  It’s how
software works, but it’s not how hardware works.&lt;/p&gt;

&lt;p&gt;This is why digital designers need
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal methods&lt;/a&gt;
now more than ever–because they actually check the cases you weren’t
anticipating.&lt;/p&gt;

&lt;p&gt;If you’ve never tried
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal methods&lt;/a&gt;
before, then understand that they are very different from
&lt;a href=&quot;/blog/2018/08/22/what-is-simulation.html&quot;&gt;simulation&lt;/a&gt;.
Instead of trying one test after another in a long chain or sequence of logic,
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal methods&lt;/a&gt;
check all logic paths at once.  Yes, “all”, in what typically is a breadth
first search.  This is both their greatest benefit, since they catch things
no one imagines, as well as their greatest curse, since the computation
required does not grow with &lt;a href=&quot;https://en.wikipedia.org/wiki/Time_complexity#Polynomial_time&quot;&gt;polynomial
time&lt;/a&gt;.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 14. Should vs should not&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/axi-story/should-not.svg&quot; alt=&quot;&quot; width=&quot;320&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Another thing that makes
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal methods&lt;/a&gt;
different is that you don’t specify how the external environment &lt;em&gt;should&lt;/em&gt;
interact with your core.  Instead, you specify how the external environment
&lt;em&gt;shouldn’t&lt;/em&gt; interact with your core.  The subtle difference in logic means
that, unless you tell the tool not to, it will try all kinds of crazy logic
inputs that you might never expect.&lt;/p&gt;

&lt;p&gt;One of the common misperceptions about formal verification techniques is that
they are only useful or cost-effective for “mission critical”
applications–things like aircraft, rockets, and satellites.  Were I to
buy into this misconception, I wouldn’t touch formal methods at all–since
my own little “sandbox” is hardly anything anyone cares about.&lt;/p&gt;

&lt;p&gt;That view might have even described me before I tried it for the first time.
After using these tools, I’d never go back to the way I was doing
digital design before starting with formal methods.  For me, formal methods
are a big time saver.  One of the things I really dislike is trying to sort
through a 15GB+ simulation trace file looking for a bug.  It takes too long,
and wears thin on my patience.  Not so with formal methods.  Indeed, most of
the formal designs I do require less than 20 time steps to find a bug.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: left; padding: 15px&quot;&gt;&lt;caption&gt;Fig 15. Reasons why I still use formal methods&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/axi-story/why-formal.svg&quot; alt=&quot;&quot; width=&quot;320&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Posting to a forum?  Personally, I’d never write into a vendor forum asking
for help unless I was not only stuck in &lt;a href=&quot;/blog/2017/05/19/fpga-hell.html&quot;&gt;FPGA
Hell&lt;/a&gt;, but I had tried
every option I knew of to get out and still ended up stuck.  I like the
ability to do my own work and to call it my own, and so I’m the type of person
who will wait until I had tried fixing my own design every way I knew how
before ever breaking down and asking for help.  Perhaps its a character flaw.
However it’s this particular bias of mine, and I don’t think it’s all that
uncommon, that makes me believe that those who had posted requesting help,
and especially the professionals among them, must have been stuck in
&lt;a href=&quot;/blog/2017/05/19/fpga-hell.html&quot;&gt;FPGA Hell&lt;/a&gt;
for a while before they risked their pride and profit to ask on a public forum.
Now imagine if you could find a logic problem quickly, perhaps even in less
time than it took to synthesize your design or even write your post for help,
and do it all at your desk.&lt;/p&gt;

&lt;p&gt;“Mission critical” or not, formal methods have saved me and my little
sandbox of the world &lt;a href=&quot;/zipcpu/2017/12/28/ugliest-bug.html&quot;&gt;a lot of
frustration&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;So &lt;a href=&quot;/formal/2019/08/03/proof-duration.html&quot;&gt;how long does it
take&lt;/a&gt;?  Well, to
give you an example, I just built my own &lt;a href=&quot;https://github.com/ZipCPU/wb2axip//blob/master/rtl/axis2mm.v&quot;&gt;AXI stream to
memory&lt;/a&gt;
converter.  After writing this core, I included the
formal bus properties into the core and started running the tools.  This
was before simulation–since I haven’t (yet) run the core through a simulation.
At first, &lt;a href=&quot;https://symbiyosys.readthedocs.io/en/latest&quot;&gt;SymbiYosys&lt;/a&gt;
founds bugs in seconds.  Those first bugs tended to be focused on initial
values and reset processing.  Once fixed, the tool then took a bit longer
and found several bugs in my AXI-lite control logic.  Once I cleared
those two hurdles, I was then stuck again between about 10-15 time steps for
a while.  During this time, the tools only required two minutes of processing
to find a bug.  At this point the bugs found included things like reading
from an empty FIFO, initiating a bus burst requests before there was enough
data in the FIFO, changing a bus request while it was waiting to be accepted,
crossing memory pages within a single request and so forth.  Now that I’ve
worked with the core for a while, it only takes 56 seconds to know if any
changes I’ve made have broken the core.&lt;/p&gt;

&lt;p&gt;Think about that for a moment.  It takes 56 seconds to know if any simple logic
change has placed a bug in the core or not.  Not only that, but by means of
&lt;a href=&quot;/blog/2018/03/10/induction-exercise.html&quot;&gt;k-induction&lt;/a&gt;,
those 56 seconds evaluate not only the first 15-timesteps, but &lt;em&gt;every set of
15-timesteps from the beginning of time through all eternity&lt;/em&gt;–or at least
until the hardware starts failing.&lt;/p&gt;

&lt;p&gt;Good luck trying to get your simulation either to run that fast or to be
that complete.&lt;/p&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;Most of the bugs I’ve found have now been posted, either in a blog article
on this site, in Xilinx’s forums, or directly to the authors of any github
cores either by filing an issue or sending an e-mail.  Many of them have not
yet been fixed as of this writing.  For example, as of Vivado 2019.1, Xilinx’s
bugs remain including one dating back as far as 2016.1.  The good news is that
their engineers are now not only aware of these bugs, but they’ve also promised
to fix them.  This is not yet true of the bugs I found in Intel’s design.
Sorry, I’ve dropped the ball there.  Other than
&lt;a href=&quot;https://twitter.com/ZipCPU&quot;&gt;tweeting&lt;/a&gt; about Intel’s bugs, I have
yet to formally post or write about my findings.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 16. It&#39;s not just for safety critical applications&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/axi-story/bubble.svg&quot; alt=&quot;&quot; width=&quot;320&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;What I will say is that I remember, years ago and before I ever started
diving deeply into FPGA technology myself,
sitting down with a co-worker to integrate their data collection logic into
my mission requirements.  Our goal was to demonstrate that we had a useful
product to the boss.  Instead, I remember this coworker struggling and
struggling with the design, hitting the reset key over and over and over
again, frustrated and confused at why the design wasn’t starting up like
it was supposed to or like it “usually” did.  No, I’m not going to repeat
his language here, but let’s just say that over the course of time while
he was hitting that reset button it became more and more colorful.&lt;/p&gt;

&lt;p&gt;Now consider that the training material I’ve found has been broken.  Indeed,
any one of the AXI bugs I’ve found in these public source vendor training
materials might’ve caused this same frustration.  These include not only the
bugs found in the training material for the vendor’s tools that I’ve already
blogged about, but also the training material for the other major vendors on the
market.&lt;/p&gt;

&lt;p&gt;Now, as I’m slowly picking up my jaw off the floor, I’m starting to get the
full impact of what’s been going on.&lt;/p&gt;

&lt;p&gt;These bugs can be found and fixed–using formal methods.&lt;/p&gt;

&lt;p&gt;If you are interested in repeating any of my work, I’ve done all of my work
using &lt;a href=&quot;https://symbiyosys.readthedocs.io/en/latest&quot;&gt;SymbiYosys&lt;/a&gt;–either the
open source or the commercial version.  I’ve also posted copies of the
Xilinx designs I’ve tested.  If you’ve never formal methods, the open
source version is capable of processing any Verilog (2005) code you might have
with a limited number of SystemVerilog extensions.  Feel free to download it
and give it a try.  You can also find my &lt;a href=&quot;/formal/2018/12/28/axilite.html&quot;&gt;AXI-lite
properties&lt;/a&gt; and &lt;a href=&quot;https://github.com/ZipCPU/wb2axip&quot;&gt;several
example designs on line&lt;/a&gt; as well.&lt;/p&gt;

&lt;p&gt;You can also start with my &lt;a href=&quot;/tutorial&quot;&gt;beginner’s design
tutorial&lt;/a&gt;.  It’s free.  Enjoy it.  Even though
&lt;a href=&quot;/blog/2019/08/20/lego-design.html&quot;&gt;Xilinx deleted my response recommending this tutorial to new
engineers&lt;/a&gt;, you are
welcome to it.  I also teach a course on how to do formal verification.
You can find &lt;a href=&quot;/tutorial#training&quot;&gt;those slides here&lt;/a&gt;,
and contact me if you are interested in taking the course either on-line or
in person on your site.  Feel free to check those out too.&lt;/p&gt;

&lt;p&gt;Finally, I look forward to meeting many of my readers at
&lt;a href=&quot;https://orconf.org&quot;&gt;ORCONF 2019&lt;/a&gt;!  Feel free to stop me and say hello.&lt;/p&gt;

&lt;!-- Counter argument: If Xilinx is having these issues, and it&#39;s not breaking their neck, it can&#39;t be such a big deal.  Other comment: IP Vendors need to adapt formal methods before their customers do, because as soon as their customers have the formal methods, they&#39;ll immediate know where to put the blame. --&gt;
&lt;hr /&gt;&lt;p&gt;&lt;em&gt;Buy the truth, and sell it not; also wisdom, and instruction, and understanding. (Prov 23:23)&lt;/em&gt;</description>
        <pubDate>Fri, 06 Sep 2019 00:00:00 -0400</pubDate>
        <link>https://zipcpu.com/formal/2019/09/06/axi-story.html</link>
        <guid isPermaLink="true">https://zipcpu.com/formal/2019/09/06/axi-story.html</guid>
        
        
        <category>formal</category>
        
      </item>
    
      <item>
        <title>Understanding AutoFPGA&#39;s address assignment algorithm</title>
        <description>&lt;p&gt;Some time ago, I figured out a basic address assignment algorithm for use in
&lt;a href=&quot;/zipcpu/2017/10/05/autofpga-intro.html&quot;&gt;AutoFPGA&lt;/a&gt;.
At the encouragement of &lt;a href=&quot;https://twitter.com/ZipCPU&quot;&gt;my twitter&lt;/a&gt; followers, I
thought it might be valuable to share this algorithm here.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/zipcpu/2017/10/05/autofpga-intro.html&quot;&gt;AutoFPGA&lt;/a&gt;,
as you may recall, connects peripherals (&lt;a href=&quot;https://github.com/ZipCPU/autofpga/tree/dev&quot;&gt;and now multiple masters
in the dev branch&lt;/a&gt;) to any
respective buses you might wish to assign them to.  While
&lt;a href=&quot;/zipcpu/2017/10/05/autofpga-intro.html&quot;&gt;AutoFPGA&lt;/a&gt;
is primarily a copy-paste design facility with some calculation mixed in,
address assignment is one of several exceptions to this rule.&lt;/p&gt;

&lt;p&gt;Consider as an example the bus structure shown in Fig. 1.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 1. Example multi-level bus structure&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/address-assignment/generic-bus-diagram.svg&quot; alt=&quot;&quot; width=&quot;720&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;In this structure, you can see three bus masters, together with four basic
slaves, four &lt;code class=&quot;highlighter-rouge&quot;&gt;DOUBLE&lt;/code&gt;-type slaves, and four &lt;code class=&quot;highlighter-rouge&quot;&gt;SINGLE&lt;/code&gt;-type slaves.  Slave one
in particular provides access to a second bus having two slaves on it.&lt;/p&gt;

&lt;p&gt;To assign addresses to all of these peripherals,
&lt;a href=&quot;/zipcpu/2017/10/05/autofpga-intro.html&quot;&gt;AutoFPGA&lt;/a&gt;
generates and maintains a list of buses found within the design.  Each bus
is composed of a number of peripherals (the PLIST), and one or more masters
(the MLIST).  Certain special “subbus” or “arbiter” masters are able to cross
from one bus to another, making it possible to have hierarchical bus structures,
such as Fig. 1 shows above.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 2. Example multi-level bus structure&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/address-assignment/bus-lists.svg&quot; alt=&quot;&quot; width=&quot;420&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;&lt;a href=&quot;/zipcpu/2017/10/05/autofpga-intro.html&quot;&gt;AutoFPGA&lt;/a&gt;s
first task is to &lt;a href=&quot;/zipcpu/2019/08/30/subbus.html&quot;&gt;split each bus into three
parts&lt;/a&gt;: The first is for
peripherals of type &lt;code class=&quot;highlighter-rouge&quot;&gt;SINGLE&lt;/code&gt;.  These are single register peripherals whose
register is immediately available for reading or writing, and who don’t stall
the bus.  The second set of peripherals, those of type &lt;code class=&quot;highlighter-rouge&quot;&gt;DOUBLE&lt;/code&gt;, can have
more registers internal to them.  This set requires a single clock period to
return a value from a bus request.  As with the &lt;code class=&quot;highlighter-rouge&quot;&gt;SINGLE&lt;/code&gt; list, this set is
not allowed to stall the bus either.  The last set of peripherals contains all
other types of peripherals.&lt;/p&gt;

&lt;p&gt;For &lt;a href=&quot;/zipcpu/2017/05/29/simple-wishbone.html&quot;&gt;WB peripherals&lt;/a&gt;,
the entire &lt;code class=&quot;highlighter-rouge&quot;&gt;SINGLE&lt;/code&gt; peripheral set is turned into a &lt;code class=&quot;highlighter-rouge&quot;&gt;DOUBLE&lt;/code&gt; peripheral, and
then that peripheral is turned into a regular peripheral of the normal variety.
While this is captured in Figs. 1 and 2 above, I haven’t yet decided if I will
do the same thing for the
&lt;a href=&quot;/formal/2018/12/28/axilite.html&quot;&gt;AXI-lite&lt;/a&gt; interface or not.&lt;/p&gt;

&lt;p&gt;Address assignment then starts at the lowest level of the bus structure, and
then works its way up to the top.  Within any given level, the &lt;code class=&quot;highlighter-rouge&quot;&gt;SINGLE&lt;/code&gt; set is
assigned first and formed into its own peripheral, then the &lt;code class=&quot;highlighter-rouge&quot;&gt;DOUBLE&lt;/code&gt; set,
and then peripheral assignment is done on the rest of the bus.&lt;/p&gt;

&lt;p&gt;Let’s look at an example from one of my more recent projects.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 3. Abbreviated bus design from a recent project&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/address-assignment/sonar-design.svg&quot; alt=&quot;&quot; width=&quot;720&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;In this project there’s your basic
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;, and then
&lt;a href=&quot;/blog/2019/03/27/qflexpress.html&quot;&gt;flash&lt;/a&gt;,
SDRAM, network, and &lt;a href=&quot;https://github.com/ZipCPU/sdspi&quot;&gt;SD-Card&lt;/a&gt;
peripherals.  Indeed, this much of the design is based upon my
&lt;a href=&quot;https://github.com/ZipCPU/videozip&quot;&gt;VideoZip design&lt;/a&gt;.  Now, using
&lt;a href=&quot;/zipcpu/2017/10/05/autofpga-intro.html&quot;&gt;AutoFPGA&lt;/a&gt;,
I can add a basic SONAR transmit controller and a boot ROM section so my
customer doesn’t need to load code into the design himself.  (The boot ROM
slave isn’t shown in Fig. 3 above.)  Finally, there’s a data recorder shown
above as the “DMA” in the picture.  If you look carefully, you’ll notice this
same slave exists on the bus in two places: once where for the control port
where it receives its commands, and again for the memory access portion
where it masters the bus.  Xilinx users might be familiar with the similar
&lt;a href=&quot;https://www.xilinx.com/support/documentation/ip_documentation/axi_datamover/v5_1/pg022_axi_datamover.pdf&quot;&gt;AXIS2MM data mover
peripheral&lt;/a&gt;,
but this particular one is my own WB creation and no real relation to theirs.&lt;/p&gt;

&lt;p&gt;Let’s spend a moment to see how
&lt;a href=&quot;/zipcpu/2017/10/05/autofpga-intro.html&quot;&gt;AutoFPGA&lt;/a&gt;
handles this address assignment problem.&lt;/p&gt;

&lt;h2 id=&quot;address-decoding&quot;&gt;Address Decoding&lt;/h2&gt;

&lt;p&gt;The first step to understanding how address assignment works is to understand
how addresses are decoded.  &lt;a href=&quot;/blog/2019/07/17/crossbar.html&quot;&gt;As we’ve discussed
before&lt;/a&gt;, address decoding is
done with two values: an address and a mask assigned on a per-slave basis.  A
particular peripheral is selected if the requested address matches the slave’s
address everywhere a mask bit is set.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;&lt;span class=&quot;n&quot;&gt;request&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;peripheral&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;valid_request&lt;/span&gt;
		&lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;requested_address&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SLAVE_MASK&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SLAVE_ADDR&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;You might also equivalently write,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;&lt;span class=&quot;n&quot;&gt;request&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;peripheral&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;valid_request&lt;/span&gt;
		&lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;requested_address&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;^&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SLAVE_ADDR&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SLAVE_MASK&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Both should generate the same logic.&lt;/p&gt;

&lt;p&gt;In general, the goal of address assignment is to both minimize the number of
mask bits and the number of address bits at the same time.&lt;/p&gt;

&lt;p&gt;Sound simple?  Let’s find out how this works.&lt;/p&gt;

&lt;h2 id=&quot;easy-address-assignment&quot;&gt;Easy Address Assignment&lt;/h2&gt;

&lt;p&gt;Just to illustrate the issue of address assignment, let’s start out with a
basic set of peripherals and assign an address to each of them.  I’ve chosen
a set of 12-peripherals for this purpose, shown in Fig. 4 on the right.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 4. Example slave peripherals&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/address-assignment/sample-plist.png&quot; alt=&quot;&quot; width=&quot;296&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;The first “peripheral” is the null space.&lt;/p&gt;

    &lt;p&gt;My initial designs didn’t include this null space.  Shall we say I got
burned and then painfully learned the wisdom of my ways?&lt;/p&gt;

    &lt;p&gt;The story dates back to before I implemented illegal instruction detection
in the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;,
feeling at the time that it was “optional”.  (I don’t feel this way any
more.)  Then one day something went wrong.  Somewhere, a pointer got set
to address zero.  Worse, all of my peripheral addresses were packed near
zero at the time.  The result was that the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt; started
wildly writing errant data to the peripheral address space.&lt;/p&gt;

    &lt;p&gt;By the time I had realized what was happening, the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt;
had written to the flash configuration control register and switched
some of the one-time programmable configuration bits.  My
&lt;a href=&quot;https://store.digilentinc.com/arty-a7-artix-7-fpga-development-board-for-makers-and-hobbyists&quot;&gt;Arty&lt;/a&gt;,
while usable, has never been the same since.&lt;/p&gt;

    &lt;p&gt;I’ve also learned to add illegal instruction detection and bus error
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_(computing)&quot;&gt;bus&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_error&quot;&gt;error&lt;/a&gt; detection to the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt;,
and similarly a null space to my address assignments.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The next couple of peripherals in this example set are &lt;a href=&quot;/blog/2017/07/08/getting-started-with-wbscope.html&quot;&gt;Wishbone
Scopes&lt;/a&gt;.
These require only two addresses, 4-bytes each, one for control and one
for data.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;I also have a &lt;a href=&quot;https://github.com/ZipCPU/wbpmic&quot;&gt;microphone peripheral&lt;/a&gt;
with a similar addressing scheme–one address for control and one for data.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The next peripheral is my &lt;a href=&quot;https://github.com/ZipCPU/wbuart32&quot;&gt;WBUART
peripheral&lt;/a&gt;.  This has transmit and
receive registers, as well as protocol control and FIFO status registers.
&lt;a href=&quot;https://github.com/ZipCPU/wbuart32/blob/master/rtl/wbuart.v&quot;&gt;This
peripheral&lt;/a&gt;
therefore requires address space for four 32-bit registers.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;My &lt;a href=&quot;https://github.com/ZipCPU/videozip/tree/enet/rtl/ethernet&quot;&gt;RGMII&lt;/a&gt; and
&lt;a href=&quot;https://github.com/ZipCPU/openarty/tree/autoarty/rtl/enetpackets.v&quot;&gt;RMII&lt;/a&gt;
controllers need two address regions–one for packet
memory and another for the controller.  The
&lt;a href=&quot;https://github.com/ZipCPU/videozip/tree/enet/rtl/ethernet/enetpackets.v&quot;&gt;controller&lt;/a&gt;
itself requires eight 32-bit registers to control the transmitter, the
receiver, the MAC address,
and to some feedback counters to capture the number of aborted packets.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;These are followed by the &lt;a href=&quot;https://github.com/ZipCPU/videozip/blob/master/rtl/enetctrl.v&quot;&gt;network management data port&lt;/a&gt;.  My network
management controller provides a separate address for everything in
the &lt;a href=&quot;https://en.wikipedia.org/wiki/Management_Data_Input/Output&quot;&gt;MDIO&lt;/a&gt;
address space, so it requires 128 bytes of address space.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The network packet memory needs to be sufficiently large to hold both a
received packet as well as the packet to be transmitted next.  Let’s pick
a memory area 32,768 bytes wide (two 16kB packets) knowing that we can
adjust this for other architectures.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;While I don’t typically use a first-stage boot-loader, one of the projects
I’m working on requires it.  That project requires a boot-ROM so we’ll throw
it in here.  A block-ROM of 256kB is more than sufficient to read a
program from an SD-card and copy it to RAM.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;We’ll then scrap together whatever’s left of our FPGA block RAM components
in order to create a &lt;a href=&quot;/zipcpu/2018/07/13/memories.html&quot;&gt;1MB block RAM
peripheral&lt;/a&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;We also have a &lt;a href=&quot;/blog/2019/03/27/qflexpress.html&quot;&gt;flash
   peripheral&lt;/a&gt; in this
   sample list.  It seems there’s a large set of
   &lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt;
   peripherals stuck at 24-bit addressing, so this will give us a
   &lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt;
   size of 16MB.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Our final peripheral is a &lt;a href=&quot;https://en.wikipedia.org/wiki/DDR3_SDRAM&quot;&gt;DDR3
   SDRAM&lt;/a&gt; having 512MB of memory.
   My current approach to this is to use the basic MIG controller, coupled
   with a &lt;a href=&quot;https://github.com/ZipCPU/wb2axisp/blob/master/rtl/wbm2axisp.v&quot;&gt;Wishbone to AXI
   bridge&lt;/a&gt;.
   As you’ll see in a moment, the sheer size of this particular peripheral will
   dominate much of how our address assignment algorithm will work.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Now, let me ask, how would you assign addresses to these peripherals?&lt;/p&gt;

&lt;p&gt;Ideally, what we might want would be a one-hot addressing scheme where
you could tell which peripheral was addressed by a single bit in the
address space.  While this sounds like an awesome idea, it fails in
practice any time an errant program accesses an address with more than one
of these otherwise one-hot bits set.  If both peripherals respond,
… “bad” things will happen.  The bus, for example, might lock up until
the next power cycle.  This is usually quite “bad”.&lt;/p&gt;

&lt;p&gt;This would also break the &lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;fundamental rule of all bus
work&lt;/a&gt;: for every request,
there is one and only one response.&lt;/p&gt;

&lt;p&gt;No, we want to make certain instead that our address assignment method works
in such a way that only one slave will ever be addressed at a time.  It doesn’t
matter if “non-allocated” addresses select that slave, but it does matter if any
addresses select more than one slave at a time.&lt;/p&gt;

&lt;p&gt;Perhaps the easiest way to do address assignment might be to first find
the slave with the biggest address width, and then assign an address space
that big to every slave.  Since the
&lt;a href=&quot;https://en.wikipedia.org/wiki/DDR3_SDRAM&quot;&gt;SDRAM&lt;/a&gt;
requires an address space of
&lt;code class=&quot;highlighter-rouge&quot;&gt;0x2000_0000&lt;/code&gt; bytes, we’ll assign every peripheral that many bytes and just
count up.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: left; padding: 15px&quot;&gt;&lt;caption&gt;Fig 5. Example slave peripherals&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/address-assignment/simple-assignment.png&quot; alt=&quot;&quot; width=&quot;643&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;As you can see from Fig. 5 on the left, we overran our 32-bit address
space and now need a 33-bit address space.
You can also see that our 8-byte peripherals were assigned 512 MBs of
address space each.  This would sort of be like running a parcel shipping
business and only supporting one size container–train box cars.&lt;/p&gt;

&lt;p&gt;Practically, this will never work.&lt;/p&gt;

&lt;p&gt;The &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
only supports a 32-bit address space (i.e. 30-bit word address space), and
of that address space there’s a reserved portion at the end from
&lt;code class=&quot;highlighter-rouge&quot;&gt;0xff00_0000&lt;/code&gt; to &lt;code class=&quot;highlighter-rouge&quot;&gt;0xffff_ffff&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Before we abandon this approach though, let’s see what else we might learn
from it.  For example, the address decoder could decode all of these separate
peripheral address ranges with a simple 4-bit lookup table, checking only
address bits 33-29 as indicated by the mask, &lt;code class=&quot;highlighter-rouge&quot;&gt;0x1_e000_0000&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;While this is a low-logic decoder, it does have a consequence.  Low-logic
means that peripherals with a small address range may exist at multiple
locations in the address map.  To continue our parcel shipping analogy, many
loaves of bread might find in a package big enough to hold a sofa–why
only pack one peripheral in such a large address space?&lt;/p&gt;

&lt;p&gt;Further, consider how the &lt;a href=&quot;https://github.com/ZipCPU/wbuart32&quot;&gt;UART
peripheral&lt;/a&gt; exists from &lt;code class=&quot;highlighter-rouge&quot;&gt;0x8000_000f&lt;/code&gt; to
&lt;code class=&quot;highlighter-rouge&quot;&gt;0x9fff_ffff&lt;/code&gt; even though it only uses four registers within that range.
What happens, then, is that all of the addresses within this range will
alias into the same four peripheral registers, allowing the
&lt;a href=&quot;https://github.com/ZipCPU/wbuart32&quot;&gt;UART&lt;/a&gt;
to be addressed anywhere in that address region.  We’ll touch more on this
in the next section.&lt;/p&gt;

&lt;p&gt;For now, we can summarize our success, or lack thereof, by two metrics–the
address width required to access all of these peripherals (33 bits–too many),
and the number of mask bits necessary to select between them, 4-bits.&lt;/p&gt;

&lt;p&gt;Can we do better?&lt;/p&gt;

&lt;h2 id=&quot;tightly-packing-addresses&quot;&gt;Tightly packing addresses&lt;/h2&gt;

&lt;p&gt;When I first started trying to handle address assignment, I would pack as many
peripherals as I could into a given address area.  Here’s how that algorithm
worked:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;I’d first sort all the peripherals, leaving the null space at zero of course.&lt;/p&gt;

    &lt;p&gt;Perhaps you’ve noticed that I’ve already sorted the peripherals listed
in Fig. 4 above.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;I’d initialize my work by setting a &lt;code class=&quot;highlighter-rouge&quot;&gt;start_address&lt;/code&gt; either to 0.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;For each peripheral, starting with the “empty” null-space and working down
the list, I’d add to the &lt;code class=&quot;highlighter-rouge&quot;&gt;start_address&lt;/code&gt; the size of the peripheral, minus
one byte.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;	&lt;span class=&quot;n&quot;&gt;pa&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;peripheral&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;address_width&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;periphera&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;base_address&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;start_address&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pa&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;ol start=&quot;4&quot;&gt;
  &lt;li&gt;
    &lt;p&gt;This would be guaranteed to overflow if there weren’t enough bits to
support my requested address range.  For example, suppose the start address
was &lt;code class=&quot;highlighter-rouge&quot;&gt;0x40&lt;/code&gt; and I wanted to allocate space for the &lt;a href=&quot;https://github.com/ZipCPU/videozip/blob/master/rtl/enetctrl.v&quot;&gt;MDIO 
peripheral&lt;/a&gt;–requiring
a register space of &lt;code class=&quot;highlighter-rouge&quot;&gt;0x80&lt;/code&gt; octets.  If you add these two together, you’d
get &lt;code class=&quot;highlighter-rouge&quot;&gt;0x40 + 0x80 = 0xc0&lt;/code&gt;.  Subtracting one brings you to &lt;code class=&quot;highlighter-rouge&quot;&gt;0xbf&lt;/code&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Now I can trim off the bottom bits, to guarantee the peripheral can use
an address mask.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;	&lt;span class=&quot;n&quot;&gt;pa&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;peripheral&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;address_width&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;periphera&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;base_address&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1l&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pa&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;ol start=&quot;6&quot;&gt;
  &lt;li&gt;
    &lt;p&gt;To follow our example from above, this would force the &lt;a href=&quot;https://github.com/ZipCPU/videozip/blob/master/rtl/enetctrl.v&quot;&gt;MDIO
peripheral&lt;/a&gt;
needing &lt;code class=&quot;highlighter-rouge&quot;&gt;0x80&lt;/code&gt; bytes of address space to have a start address equal to
&lt;code class=&quot;highlighter-rouge&quot;&gt;0x80&lt;/code&gt;–plenty of room, and with a guaranteed 7-bits to reference values
within the peripheral.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;We can then increment our start address to be ready for the next peripheral.
The new start address must be just following our assigned address space.
So, for our&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;	&lt;span class=&quot;n&quot;&gt;start_address&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;peripheral&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;base_address&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1ul&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pa&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;ol start=&quot;8&quot;&gt;
  &lt;li&gt;Then, as a first pass to knowing what mask bits we require, we set our
mask bits to be the next address bit over.&lt;/li&gt;
&lt;/ol&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;	&lt;span class=&quot;n&quot;&gt;periheral&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mask_bits&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1l&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pa&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;ol start=&quot;9&quot;&gt;
  &lt;li&gt;Finally, go back and repeat for all peripherals.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;This sounds confusing.  Perhaps a picture or two might help.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 6. Address assignment: three scopes and a serial port&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/address-assignment/uart-plus-scopes.svg&quot; alt=&quot;&quot; width=&quot;280&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;The two &lt;a href=&quot;/blog/2017/07/08/getting-started-with-wbscope.html&quot;&gt;scopes&lt;/a&gt;
and the &lt;a href=&quot;https://github.com/ZipCPU/wbpmic&quot;&gt;microphone&lt;/a&gt; all use two words of
address space.  We can therefore pack them tightly together.  However, when
we get to the &lt;a href=&quot;https://github.com/ZipCPU/wbuart32&quot;&gt;UART&lt;/a&gt;,
we need an address that’s aligned with four bus words.  Rounding up to the
nearest address that’s aligned with four bus words is going to require
stuffing two words of unused space into our address space as shown in Fig.
6 on the right.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: left; padding: 15px&quot;&gt;&lt;caption&gt;Fig 7. Adding the network control port&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/address-assignment/network-plus-uart.svg&quot; alt=&quot;&quot; width=&quot;420&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Once we’ve assigned the
&lt;a href=&quot;/blog/2017/07/08/getting-started-with-wbscope.html&quot;&gt;scopes&lt;/a&gt;
and the &lt;a href=&quot;https://github.com/ZipCPU/wbuart32&quot;&gt;UART&lt;/a&gt;, it’s now time to assign an
address to the &lt;a href=&quot;https://github.com/ZipCPU/openarty/tree/autoarty/rtl/enetpackets.v&quot;&gt;network control
port&lt;/a&gt;.
This peripheral needs an address aligned to eight 32-bit words.  However,
if you shuffle everything to an eight word width, you’ll find that the network
control addresses don’t fit unless you skip some more space.&lt;/p&gt;

&lt;p&gt;As you can see, we’re working from the smaller peripheral to the larger
ones.  At each level, the peripheral needs to be assigned to an address
aligned to the size of the peripheral.&lt;/p&gt;

&lt;p&gt;That’s what the algorithm above does.&lt;/p&gt;

&lt;p&gt;As a last step, we’ll measure the total number of bits required to do this
address decoding (30 bits), and then trim any mask bits to just that many bits.
The result would be a set of base addresses and masks describing a “full
address decoder”.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 8. Full address decoding&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/address-assignment/full-address-decoding.png&quot; alt=&quot;&quot; width=&quot;589&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;This time, you’ll notice from Fig. 8 above that we’ve done much better at
minimizing the number of address bits than we did in our first attempt shown
in Fig. 5 above.  But 27 mask bits?  Not so much.&lt;/p&gt;

&lt;p&gt;If low logic were important to us, and it has always been to me since more
logic costs more money, we might choose to just check the minimum mask bits
necessary to separate peripherals.  This would be a “partial address decoding”,
since it would leave holes in the address space.  You can see how this might
work in Fig. 9 below.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: left; padding: 15px&quot;&gt;&lt;caption&gt;Fig 9. First cut at partial address decoding&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/address-assignment/first-pass-partial.png&quot; alt=&quot;&quot; width=&quot;589&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;If you count number of bits used in the masks of Fig. 9, you’ll get eleven
non-zero bits.  Eleven mask bits would mean that decoding a peripheral’s
address would require a comparator with a length somewhere between one
bit (the &lt;a href=&quot;https://en.wikipedia.org/wiki/DDR3_SDRAM&quot;&gt;SDRAM&lt;/a&gt;)
and 11-bits (the &lt;a href=&quot;/blog/2017/07/08/getting-started-with-wbscope.html&quot;&gt;WB
Scopes&lt;/a&gt;).
Decoding addresses using an 11-bit mask would &lt;a href=&quot;/blog/2017/06/12/minimizing-luts.html&quot;&gt;require between two and three
LUTs per slave&lt;/a&gt;
depending on your architecture.&lt;/p&gt;

&lt;p&gt;While this kind of “partial address decoding” is both common and cost
effective, it’s been known to surprise those who aren’t familiar with it.
Consider as an example address &lt;code class=&quot;highlighter-rouge&quot;&gt;0x210_0000&lt;/code&gt;.  Since the
block RAM’s mask only checks bits &lt;code class=&quot;highlighter-rouge&quot;&gt;0x2110_0000&lt;/code&gt;, our address decoding
algorithm above will map this address to the block RAM–even though the
block RAM’s official address space only exists between &lt;code class=&quot;highlighter-rouge&quot;&gt;0x10_0000&lt;/code&gt; and
&lt;code class=&quot;highlighter-rouge&quot;&gt;0x1f_ffff&lt;/code&gt;.  On the other hand, &lt;code class=&quot;highlighter-rouge&quot;&gt;0x20c_0000&lt;/code&gt; would map to our block &lt;code class=&quot;highlighter-rouge&quot;&gt;ROM&lt;/code&gt;,
&lt;code class=&quot;highlighter-rouge&quot;&gt;0x30c_0000&lt;/code&gt; would map to our &lt;a href=&quot;/blog/2019/03/27/qflexpress.html&quot;&gt;Flash
peripheral&lt;/a&gt;,
and &lt;code class=&quot;highlighter-rouge&quot;&gt;0x4003_0000&lt;/code&gt; would map to our first &lt;a href=&quot;/blog/2017/07/08/getting-started-with-wbscope.html&quot;&gt;WB
Scope&lt;/a&gt;).
This isn’t a bug, but it can be a rather surprising consequence
the address decoding algorithm.&lt;/p&gt;

&lt;p&gt;So, all in all, we did okay here with our second attempt at address assignment.
&lt;a href=&quot;/zipcpu/2017/10/05/autofpga-intro.html&quot;&gt;AutoFPGA&lt;/a&gt;, however,
has a better approach to generating a “partial address decoding” mask, which
we’ll discuss in the next section.&lt;/p&gt;

&lt;h2 id=&quot;autofpgas-address-assignment-algorithm&quot;&gt;AutoFPGAs Address Assignment Algorithm&lt;/h2&gt;

&lt;p&gt;What we’ve done above nearly describes
&lt;a href=&quot;/zipcpu/2017/10/05/autofpga-intro.html&quot;&gt;AutoFPGA&lt;/a&gt;’s
address assignment algorithm.  There’s only one piece missing: minimizing
the required size of the mask.&lt;/p&gt;

&lt;p&gt;To handle this,
&lt;a href=&quot;/zipcpu/2017/10/05/autofpga-intro.html&quot;&gt;AutoFPGA&lt;/a&gt;
takes a first pass through the peripheral list to
calculate the minimum total address size.  It then increases the minimum
peripheral address size as long as the total address width remains less
than the minimum address width, and as long as the number of mask
bits goes down.&lt;/p&gt;

&lt;p&gt;How shall the minimum total address size be calculated?  Just the way we did
it in our last section: add peripherals to a bus and calculate the address
width.  The number of relevant bits is then given by the difference between
the full address size and the bloated minimum size given to every slave.&lt;/p&gt;

&lt;p&gt;For example, if we look through our example slave set, you’ll see that the
maximum slave size that doesn’t increase increase the address width is 25 bits.
Once chosen, each slave is checked for its address size.  If the slaves
address size is less than 25 bits, it is replaced by 25 bits in the
algorithm above.  The algorithm then continues as before.&lt;/p&gt;

&lt;p&gt;For the slave set example we’ve been working with today, the result then
looks like Fig. 10 below.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 10. Minimizing mask size for a given address width&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/address-assignment/final-assignment.png&quot; alt=&quot;&quot; width=&quot;589&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;You might notice that the base address just increments from one peripheral
to the next–that’s the minimum address size amount.  Further, the peripheral’s
are just one step away from each other up until the last peripheral–the
&lt;a href=&quot;https://en.wikipedia.org/wiki/DDR3_SDRAM&quot;&gt;SDRAM&lt;/a&gt; again.&lt;/p&gt;

&lt;p&gt;Looking at Fig. 10 again, you’ll notice that the total address width is just
one more than the &lt;a href=&quot;https://en.wikipedia.org/wiki/DDR3_SDRAM&quot;&gt;SDRAM&lt;/a&gt;’s
address width.  This is the minimum possible address width we could’ve
achieved.  Similarly, you’ll also notice that the address calculation now
fits in a 5-bit mask.  Since Xilinx chips allow packing two 5-LUTs into a
single 6-LUT as long as the wires are the same, that means we can do our
address decoding with only six pairs of 5-LUTs.&lt;/p&gt;

&lt;h2 id=&quot;bus-hierarchies&quot;&gt;Bus Hierarchies&lt;/h2&gt;

&lt;p&gt;This same basic approach maps quite nicely to bus hierarchies as well,
where one bus master is a slave to another bus above it.
&lt;a href=&quot;/zipcpu/2017/10/05/autofpga-intro.html&quot;&gt;AutoFPGA&lt;/a&gt;
handles bus hierarchies by simply walking the bus tree from the bottom on
up.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Start at the lowest bus in the hierarchy.  Assign addresses to it.
Once accomplished, you’ll then know the address width of this sub-bus
within the hierarchy.&lt;/p&gt;

    &lt;p&gt;This width is used to fill key tags within an bus-translator or arbiter
components, allowing them to be adjusted for the width of the bus
they are working with.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Once you then move up in the hierarchy, you can treat each bus beneath
as a self-contained slave.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Where this starts to get interesting is if you have multiple tops to the
bus tree, and those tops each have a different perspective of the
address map.  I’ve already had this problem once with both the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; and the
debugging bus
occupying the top of the tree.  My solution was rather hackish to force
a specific arrangment of the two buses, but I’m likely going to need to
revisit it in the future.&lt;/p&gt;

&lt;p&gt;Since I’m only just now starting to handle multipl-masters with
&lt;a href=&quot;/zipcpu/2017/10/05/autofpga-intro.html&quot;&gt;AutoFPGA&lt;/a&gt;, rather
than using an
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/ex/wbarbiter.v&quot;&gt;arbiter&lt;/a&gt;
to neck down every bus to a single master, I’m not quite sure how this
is going to impact things … yet.&lt;/p&gt;

&lt;h2 id=&quot;conclusions&quot;&gt;Conclusions&lt;/h2&gt;

&lt;p&gt;I’m sure there are more complicated address assignment algorithms out there,
but this one has worked rather nicely for me for some time.&lt;/p&gt;

&lt;p&gt;It’s not perfect.  One of the particular limitations of this algorithm
as written is that it doesn’t (yet) handle the case where some peripherals
have pre-assigned addresses and others need to be assigned around those.
This means that every time your run
&lt;a href=&quot;/zipcpu/2017/10/05/autofpga-intro.html&quot;&gt;AutoFPGA&lt;/a&gt;
the address structure might change.  That’s not necessarily a good thing
when you’ve already delivered a product to your client and you just want
to add a new piece of hardware to the address decoder without obsoleting
all of the software you’ve already written.  In other words, allowing
the address space to be fixed is something I am very interested in
addressing in the future.&lt;/p&gt;

&lt;p&gt;On the other hand, if you have control over all of the parts of a project and
have no problems rebuilding all of your software on every reconfiguration, then
&lt;a href=&quot;/zipcpu/2017/10/05/autofpga-intro.html&quot;&gt;AutoFPGA&lt;/a&gt;
might be the solution you need.  Not only does it move things around, but it
then updates a series of header and data files that you can then use to keep
running the same software once recompiled.  As a result, if I simply run&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;make autodata
&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;make&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;all of the addresses may get reassigned, but all of the software will rebuilt
at the same time to support the new address space.  On the other hand,
address reassignment isn’t automatic–if I don’t run &lt;code class=&quot;highlighter-rouge&quot;&gt;make autodata&lt;/code&gt; then
the design should work as is with the current address assignments.&lt;/p&gt;

&lt;p&gt;What do you think?  Feel free to drop me a line or re-post this article
if you felt this material was valuable.&lt;/p&gt;
&lt;hr /&gt;&lt;p&gt;&lt;em&gt;But he said unto them, Give ye them to eat. And they said, We have no more but five loaves and two fishes; except we should go and buy meat for all this people.  For they were about five thousand men. And he said to his disciples, Make them sit down by fifties in a company.  (Luke 9:13-14)&lt;/em&gt;</description>
        <pubDate>Tue, 03 Sep 2019 00:00:00 -0400</pubDate>
        <link>https://zipcpu.com/zipcpu/2019/09/03/address-assignment.html</link>
        <guid isPermaLink="true">https://zipcpu.com/zipcpu/2019/09/03/address-assignment.html</guid>
        
        
        <category>zipcpu</category>
        
      </item>
    
  </channel>
</rss>
