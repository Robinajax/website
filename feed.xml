<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>The ZipCPU by Gisselquist Technology</title>
    <description>The ZipCPU blog, featuring how to discussions of FPGA and soft-core CPU design.  This site will be focused on Verilog solutions, using exclusively OpenSource IP products for FPGA design.  Particular focus areas include topics often left out of more mainstreeam FPGA design courses such as how to debug an FPGA design.
</description>
    <link>http://zipcpu.com/</link>
    <atom:link href="http://zipcpu.com/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Fri, 20 Oct 2017 22:40:35 -0400</pubDate>
    <lastBuildDate>Fri, 20 Oct 2017 22:40:35 -0400</lastBuildDate>
    <generator>Jekyll v3.0.1</generator>
    <image>
      <url>http://zipcpu.com/img/gt-rss.png</url>
      <title></title>
      <link></link>
    </image>
    
      <item>
        <title>Some Simple Clock-Domain Crossing Solutions</title>
        <description>&lt;p&gt;In many ways,
&lt;a href=&quot;https://en.wikipedia.org/wiki/Metastability_in_electronics&quot;&gt;metastability&lt;/a&gt;
is the big
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bogeyman&quot;&gt;boogeyman&lt;/a&gt; within
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
design.  It is hard to see when desk-checking a design, it doesn’t show up
on all simulations (certainly not with
&lt;a href=&quot;https://www.veripool.org/wiki/verilator/&quot;&gt;Verilator&lt;/a&gt;), your synthesis tool
can’t solve it, and timing analysis often just gets in the way of dealing
with it.
&lt;a href=&quot;https://en.wikipedia.org/wiki/Metastability_in_electronics&quot;&gt;Metastability&lt;/a&gt;,
though, can make your design unreliable.  If your design has a problem with
&lt;a href=&quot;https://en.wikipedia.org/wiki/Metastability_in_electronics&quot;&gt;metastability&lt;/a&gt;,
then it might never work.  It might work today and not tomorrow.  It might
work perfectly for months, and then have a fatal flaw.&lt;/p&gt;

&lt;p&gt;In many ways,
&lt;a href=&quot;https://en.wikipedia.org/wiki/Metastability_in_electronics&quot;&gt;metastability&lt;/a&gt;
problems are the worst of all errors.  They are hard to trace.  You might
deliver to a customer a design that passes all of your internal tests,
only to have that (now) disgruntled customer tell you it doesn’t work.
Then, to add insult, when you get the hardware back to examine, it works again.
This is the nature of an unpredictable problem such as
&lt;a href=&quot;https://en.wikipedia.org/wiki/Metastability_in_electronics&quot;&gt;metastability&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Ouch!&lt;/p&gt;

&lt;p&gt;So, what causes
&lt;a href=&quot;https://en.wikipedia.org/wiki/Metastability_in_electronics&quot;&gt;metastability&lt;/a&gt;?
&lt;a href=&quot;https://en.wikipedia.org/wiki/Metastability_in_electronics&quot;&gt;Metastability&lt;/a&gt;
is caused when the &lt;a href=&quot;https://en.wikipedia.org/wiki/Flip-flop_(electronics)#Timing_considerations&quot;&gt;set up and hold
time&lt;/a&gt;
requirements of a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flip-flop_(electronics)&quot;&gt;flip-flop&lt;/a&gt;
aren’t met.  The
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flip-flop_(electronics)&quot;&gt;flip-flop&lt;/a&gt;
then enters a state which is neither zero nor one, neither high nor low.  It
may be read by some of your logic as a zero, and by other parts of your logic
as a one.
&lt;a href=&quot;https://en.wikipedia.org/wiki/Metastability_in_electronics&quot;&gt;Metastability&lt;/a&gt;,
therefore, can cause your logic to do some very unpredictable and (apparently)
illogical things.&lt;/p&gt;

&lt;p&gt;For the digital designer,
&lt;a href=&quot;https://en.wikipedia.org/wiki/Metastability_in_electronics&quot;&gt;metastability&lt;/a&gt;
can take place any time a signal crosses from one clock domain to another.
This is called a “&lt;a href=&quot;https://en.wikipedia.org/wiki/Clock_domain_crossing&quot;&gt;Clock Domain
Crossing&lt;/a&gt;”, or
&lt;a href=&quot;https://en.wikipedia.org/wiki/Clock_domain_crossing&quot;&gt;CDC&lt;/a&gt;, and it needs
some special engineering to be done properly.&lt;/p&gt;

&lt;p&gt;Today, therefore, let’s look at several basic solutions to solving
&lt;a href=&quot;https://en.wikipedia.org/wiki/Clock_domain_crossing&quot;&gt;CDC&lt;/a&gt;
issues.&lt;/p&gt;

&lt;h2 id=&quot;what-is-a-clock-domain&quot;&gt;What is a clock domain&lt;/h2&gt;

&lt;p&gt;If we need to pay special attention to &lt;a href=&quot;https://en.wikipedia.org/wiki/Clock_domain_crossing&quot;&gt;clock domain
crossings&lt;/a&gt;,
the first question that we need to answer is, just what is a “clock domain”?&lt;/p&gt;

&lt;p&gt;A “Clock Domain” is that portion of your circuitry that is generated and
processed by a single clock.  I like to build my component IP’s to use a
single master clock that I call, &lt;code class=&quot;highlighter-rouge&quot;&gt;i_clk&lt;/code&gt;.  All of the registers, then, that are
set within such components on the positive edge of this &lt;code class=&quot;highlighter-rouge&quot;&gt;i_clk&lt;/code&gt; clock signal
form a single clock domain.  Indeed, all of the registers set within an entire
design on the same edge of a same clock form a single clock domain.
Combinatorial logic based upon this register set is also within this same
clock domain.&lt;/p&gt;

&lt;table style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 1: Four clock domains&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/cdc-domains.svg&quot; alt=&quot;Blobology image, showing four separate clock domains: asynchronous inputs, posedge clock_one, negedge clock_one, and posedge clock_two&quot; width=&quot;400&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;As an example, Fig 1 shows four separate clock domains within a design.
Perhaps this might make more sense, though, if we looked at how to recognize
these examples within some Verilog RTL.&lt;/p&gt;

&lt;p&gt;Let’s examine the positive edge of &lt;code class=&quot;highlighter-rouge&quot;&gt;clock_one&lt;/code&gt;.  Any register set on the
positive edge of &lt;code class=&quot;highlighter-rouge&quot;&gt;clock_one&lt;/code&gt; is within one clock domain–the yellow domain in
Fig 1.  Hence, &lt;code class=&quot;highlighter-rouge&quot;&gt;r_reg_one&lt;/code&gt; in the example below will be within this clock
domain.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;reg	r_reg_one;
always @(posedge clock_one)
	r_reg_one &amp;lt;= (some_logic);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Any logic can be created, based upon &lt;code class=&quot;highlighter-rouge&quot;&gt;r_reg_one&lt;/code&gt; and transitioning on
the positive edge of &lt;code class=&quot;highlighter-rouge&quot;&gt;clock_one&lt;/code&gt;, without crossing a clock domain.  Hence,
&lt;code class=&quot;highlighter-rouge&quot;&gt;r_pipe_one&lt;/code&gt; below is still within the same &lt;code class=&quot;highlighter-rouge&quot;&gt;clock_one&lt;/code&gt; clock domain.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;reg	[(N-1):0]	r_pipe_one;
always @(posedge clock_one)
	r_pipe_one &amp;lt;= { r_pipe_one[(N-2):0], r_reg_one };&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This applies to combinatorial logic as well, not just register logic.  Any
combinatorial logic depending only upon inputs created within the same
clock domain is also within that clock domain.  Hence, &lt;code class=&quot;highlighter-rouge&quot;&gt;w_wire_one&lt;/code&gt; below
remains within the &lt;code class=&quot;highlighter-rouge&quot;&gt;clock_one&lt;/code&gt; clock domain.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;wire	w_wire_one;

assign	w_wire_one = |r_pipe_one;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Anything depending upon another clock, though, is in a different clock domain.
For example, &lt;code class=&quot;highlighter-rouge&quot;&gt;r_reg_two&lt;/code&gt; below is in the &lt;code class=&quot;highlighter-rouge&quot;&gt;posedge clock_two&lt;/code&gt; clock domain,
shown in red in Fig 1 above.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge clock_two)
	r_reg_two &amp;lt;= (some_other_logic);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Likewise, the negative edge of a clock is a separate clock domain from the
positive edge of the same clock.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(negedge clock_one)
	r_reg_three &amp;lt;= ...;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;So if that’s a clock domain, what’s a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Clock_domain_crossing&quot;&gt;clock domain crossing&lt;/a&gt;?&lt;/p&gt;

&lt;table style=&quot;float: left; padding: 15px&quot;&gt;&lt;caption&gt;Fig 2: Clock Domain Crossings (CDCs)&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/cdc-crossing.svg&quot; alt=&quot;Blobology image, showing four separate clock domains: asynchronous inputs, posedge clock_one, negedge clock_one, and posedge clock_two&quot; width=&quot;320&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;A &lt;a href=&quot;https://en.wikipedia.org/wiki/Clock_domain_crossing&quot;&gt;clock domain crossing
(CDC)&lt;/a&gt;
takes place anytime the inputs to a given
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flip-flop_(electronics)&quot;&gt;flip-flop&lt;/a&gt;
were set based upon something other than the clock edge used by that
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flip-flop_(electronics)&quot;&gt;flip-flop&lt;/a&gt;.
Fig 2 illustrates three examples of this that we’ll discuss below.&lt;/p&gt;

&lt;p&gt;The clearest example of a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Clock_domain_crossing&quot;&gt;CDC&lt;/a&gt;
is when the inputs to a register, say &lt;code class=&quot;highlighter-rouge&quot;&gt;r_reg_two&lt;/code&gt;, are set based upon
one clock, &lt;code class=&quot;highlighter-rouge&quot;&gt;clock_one&lt;/code&gt;, yet the output is set based upon a second
clock–in this case &lt;code class=&quot;highlighter-rouge&quot;&gt;clock_two&lt;/code&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge clock_two)
	r_reg_two &amp;lt;= (some_function_of r_reg_one);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This also applies to crossing from the positive edge of one clock to the
negative edge of any clock as well.  Hence, the following is a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Clock_domain_crossing&quot;&gt;CDC&lt;/a&gt;,
since &lt;code class=&quot;highlighter-rouge&quot;&gt;r_reg_one&lt;/code&gt; was set on the &lt;code class=&quot;highlighter-rouge&quot;&gt;posedge clock_one&lt;/code&gt; whereas &lt;code class=&quot;highlighter-rouge&quot;&gt;r_reg_three&lt;/code&gt; is
set on the negative edge of the same clock.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(negedge clock_one)
	r_reg_three &amp;lt;= (some_function_of r_reg_one);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The third type of
&lt;a href=&quot;https://en.wikipedia.org/wiki/Clock_domain_crossing&quot;&gt;clock domain crossing&lt;/a&gt;
you are likely to see is the asynchronous input. If you have an input whose
value isn’t changing on your clock, then setting any register based upon it
represents a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Clock_domain_crossing&quot;&gt;clock domain crossing&lt;/a&gt;:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge clock_one)
	r_input &amp;lt;= i_value;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Classic examples of asynchronous inputs that need carefully engineered
&lt;a href=&quot;https://en.wikipedia.org/wiki/Clock_domain_crossing&quot;&gt;CDC&lt;/a&gt;’s
are buttons, switches,
&lt;a href=&quot;https://en.wikipedia.org/wiki/Universal_asynchronous_receiver-transmitter&quot;&gt;UART receivers&lt;/a&gt;’s, and incoming
&lt;a href=&quot;https://en.wikipedia.org/wiki/Serial_Peripheral_Interface_Bus&quot;&gt;SPI&lt;/a&gt;
clocks, although other examples abound.  You may even remember the struggle
I had crossing from an &lt;a href=&quot;https://en.wikipedia.org/wiki/HDMI&quot;&gt;HDMI&lt;/a&gt; pixel clock
domain to my memory clock domain, as I discussed in a
&lt;a href=&quot;/blog/2017/09/14/even-i-get-stuck.md&quot;&gt;previous post&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The problem with all of these
&lt;a href=&quot;https://en.wikipedia.org/wiki/Clock_domain_crossing&quot;&gt;CDC&lt;/a&gt;’s
is that they need to be managed, so as to mitigate the risk of any
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flip-flop_(electronics)&quot;&gt;flip-flop&lt;/a&gt;s
being placed into a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Metastability_in_electronics&quot;&gt;metastable&lt;/a&gt; state.
How to mitigate these
&lt;a href=&quot;https://en.wikipedia.org/wiki/Clock_domain_crossing&quot;&gt;CDC&lt;/a&gt;’s
is the topic of the rest of this article.&lt;/p&gt;

&lt;h2 id=&quot;re-synchronizing-a-slow-logic-signal&quot;&gt;Re-synchronizing a slow logic signal&lt;/h2&gt;

&lt;p&gt;Chances are that, if you’ve only superficially looked into
&lt;a href=&quot;https://en.wikipedia.org/wiki/Clock_domain_crossing&quot;&gt;CDC&lt;/a&gt;’s
before, you’ve been told that the way to synchronize a value going from one
clock to another is to pass it through two
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flip-flop_(electronics)&quot;&gt;flip-flop&lt;/a&gt;s
clocked with the new clock, as shown in Fig 3.&lt;/p&gt;

&lt;table style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 3: CDC solution: Two Flip-flops&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/cdc-dbl-clock.svg&quot; alt=&quot;Crossing clock domains via two flip-flops&quot; width=&quot;400&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Each of the two
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flip-flop_(electronics)&quot;&gt;flip-flop&lt;/a&gt;s
in this figure is clocked with the clock from the new clock domain, whereas
the input to the first one was created within the old clock domain.  While the
result of the first one may have a high probability of
&lt;a href=&quot;https://en.wikipedia.org/wiki/Metastability_in_electronics&quot;&gt;metastability&lt;/a&gt;,
the output of the second
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flip-flop_(electronics)&quot;&gt;flip-flop&lt;/a&gt;
has a much lower probability of
&lt;a href=&quot;https://en.wikipedia.org/wiki/Metastability_in_electronics&quot;&gt;metastability&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Some engineers will even recommend not two
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flip-flop_(electronics)&quot;&gt;flip-flop&lt;/a&gt;s
but three.  In many ways, how many
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flip-flop_(electronics)&quot;&gt;flip-flop&lt;/a&gt;s
you use is dependent upon your application space,
and how catastrophic any
&lt;a href=&quot;https://en.wikipedia.org/wiki/Metastability_in_electronics&quot;&gt;metastability&lt;/a&gt;
problems would be.&lt;/p&gt;

&lt;p&gt;Example code for this might look like,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge new_clock)
	{ new_val, xfer_pipe } &amp;lt;= { xfer_pipe, i_val };&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;where &lt;code class=&quot;highlighter-rouge&quot;&gt;xfer_pipe&lt;/code&gt; is either one or two bits wide.&lt;/p&gt;

&lt;p&gt;The trick to remember in this process is that none of your code should
reference the output of the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flip-flop_(electronics)&quot;&gt;flip-flop&lt;/a&gt;(s)
in the &lt;a href=&quot;https://en.wikipedia.org/wiki/Metastability_in_electronics&quot;&gt;metastable&lt;/a&gt;
region of the transfer pipe, referred as &lt;code class=&quot;highlighter-rouge&quot;&gt;xfer_pipe&lt;/code&gt; above.  The value of
&lt;code class=&quot;highlighter-rouge&quot;&gt;xfer_pipe&lt;/code&gt; is the value in the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Metastability_in_electronics&quot;&gt;metastability&lt;/a&gt;
danger region, shown in Fig 3 above in red.  Instead, you should wait one
more clock and use &lt;code class=&quot;highlighter-rouge&quot;&gt;new_val&lt;/code&gt; (in this example) instead.&lt;/p&gt;

&lt;p&gt;This works nicely for cases where the value from the old clock domain changes
slowly–much slower than the frequency of the new clock domain’s clock.
Not all &lt;a href=&quot;https://en.wikipedia.org/wiki/Clock_domain_crossing&quot;&gt;CDC&lt;/a&gt;
problems, though, are that simple.  Other problems require
different solutions, but almost all such solutions are dependent upon this
first basic method.&lt;/p&gt;

&lt;h2 id=&quot;asynchronous-reset-assertion-synchronous-release&quot;&gt;Asynchronous Reset Assertion, Synchronous Release&lt;/h2&gt;

&lt;p&gt;One particularly common example of a 
&lt;a href=&quot;https://en.wikipedia.org/wiki/Clock_domain_crossing&quot;&gt;CDC&lt;/a&gt; is an
asynchronous reset.  I know I’ve given &lt;a href=&quot;/blog/2017/08/21/rules-for-newbies.html&quot;&gt;beginners the advice of never using an
asynchronous reset&lt;/a&gt;.
I stand by this advice &lt;em&gt;for beginning
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
designers&lt;/em&gt;.  [&lt;a href=&quot;https://forums.xilinx.com/t5/PLD-Blog/That-Dangerous-Asynchronous-Reset/ba-p/12856&quot;&gt;Xilinx Ref&lt;/a&gt;]
There comes a time,
though, when you need an asynchronous reset.&lt;/p&gt;

&lt;p&gt;For me, I last found myself &lt;em&gt;needing&lt;/em&gt; an asynchronous reset was when I needed
to reset a circuit whose clock I had stopped.  Without the clock, I couldn’t
reset the circuit and so I needed an asynchronous reset.&lt;/p&gt;

&lt;p&gt;The problem isn’t so much entering the reset state, the problem is
exiting the reset state.  The exit needs to be done synchronous to the
clock.  If it isn’t, you not only risk
&lt;a href=&quot;https://en.wikipedia.org/wiki/Metastability_in_electronics&quot;&gt;metastability&lt;/a&gt;
problems, but you also risk some parts of your design getting released from
the reset state before (or after) others.
(This &lt;a href=&quot;https://forums.xilinx.com/t5/PLD-Blog/That-Dangerous-Asynchronous-Reset/ba-p/12856&quot;&gt;Xilinx Ref&lt;/a&gt; discusses some of that)&lt;/p&gt;

&lt;p&gt;Creating an asynchronous reset line with a synchronous release isn’t really
all that hard to do in Verilog.  Indeed, you might argue that the Verilog
solution below looks a lot like our two
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flip-flop_(electronics)&quot;&gt;flip-flop&lt;/a&gt;
solution above.&lt;/p&gt;

&lt;p&gt;In this example, we assume an active low asynchronous reset, and we synchronize
the exit from this reset state using another active low signal, &lt;code class=&quot;highlighter-rouge&quot;&gt;s_reset_n&lt;/code&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;reg	s_reset, r_pipe;
always @(posedge i_clk, negedge i_reset_n)
	if (!i_reset)
		{ s_reset_n, r_pipe } &amp;lt;= 2&#39;b00;
	else
		{ s_reset_n, r_pipe } &amp;lt;= { r_pipe, 1&#39;b1 };&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;You can then use the &lt;code class=&quot;highlighter-rouge&quot;&gt;s_reset_n&lt;/code&gt; as an asynchronous active low reset signal
throughout your design.&lt;/p&gt;

&lt;p&gt;Engineers have argued about whether active high or active low resets are
better.  In general it doesn’t make a difference within an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;,
however the peripherals the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
controls may have specific requirements.
&lt;a href=&quot;https://en.wikipedia.org/wiki/Application-specific_integrated_circuit&quot;&gt;ASIC&lt;/a&gt;
&lt;a href=&quot;/blog/2017/10/13/fpga-v-asic.html&quot;&gt;designers&lt;/a&gt;, on the
other hand, tend to like the active low reset.  Verilog designed to handle
both &lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
and
&lt;a href=&quot;https://en.wikipedia.org/wiki/Application-specific_integrated_circuit&quot;&gt;ASIC&lt;/a&gt;
implementations will likely need this circuitry therefore.&lt;/p&gt;

&lt;h2 id=&quot;the-cross-clock-handshake&quot;&gt;The Cross-clock Handshake&lt;/h2&gt;

&lt;p&gt;One of the problems with the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flip-flop_(electronics)&quot;&gt;flip-flop&lt;/a&gt; chain
method of handling
&lt;a href=&quot;https://en.wikipedia.org/wiki/Clock_domain_crossing&quot;&gt;CDC&lt;/a&gt;’s is that
nothing guarantees that the input is stable long enough to know that the
output was received.  Sometimes, for example, you want a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Clock_domain_crossing&quot;&gt;CDC&lt;/a&gt;
method that can handle going from a slow clock to a fast clock, from a fast
clock to a slow clock, or even from one clock of unknown speed to another
clock having no known relationship to the first.  This calls for another
approach: the handshaking method, shown in Fig 4.&lt;/p&gt;

&lt;table style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 4: A Request-acknowledgement hand-shake&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/cdc-dbl-ack.svg&quot; alt=&quot;Crossing clock domains with a handshake.  First a request crosses, then the acknowlegement returns.  When both are clear, a new request can take place&quot; width=&quot;400&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;In this figure, two clock domains are shown, yellow and green, together with
the &lt;a href=&quot;https://en.wikipedia.org/wiki/Metastability_in_electronics&quot;&gt;metastable&lt;/a&gt;
region between the two shown in pink or red.  Time goes from top to bottom,
showing messages being passed back and forth from the two sides.&lt;/p&gt;

&lt;p&gt;The figure also shows how the hand-shaking method works.  The first thing
that happens is that a request is made from the old clock domain and then
passed to the new clock domain.  The request goes through the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Metastability_in_electronics&quot;&gt;metastability&lt;/a&gt;
region using the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flip-flop_(electronics)&quot;&gt;flip-flop&lt;/a&gt;
chain method described above.  Once it gets to the new clock domain,
an acknowledgement is sent back–also going through the same
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flip-flop_(electronics)&quot;&gt;flip-flop&lt;/a&gt;
chain method, but this time with the old clock driving the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flip-flop_(electronics)&quot;&gt;flip-flop&lt;/a&gt; chain.
Once the acknowledgement has been received, the request signal may be dropped
(cleared), at which point the new clock domain drops its acknowledgement flag.&lt;/p&gt;

&lt;p&gt;One trick of this method, though, is that no new request can be made until the
acknowledgement has been cleared.  This “I’m busy” region is shown in Fig 4
as a bright red bar, during which time no new requests may be sent.&lt;/p&gt;

&lt;p&gt;Let’s walk through this approach in Verilog, shall we?&lt;/p&gt;

&lt;p&gt;First, something starts this off by setting the &lt;code class=&quot;highlighter-rouge&quot;&gt;req&lt;/code&gt; register.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge old_clock)
	req &amp;lt;= (some_logic);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This logic isn’t quite complete, but we’ll come back to it in a moment.&lt;/p&gt;

&lt;p&gt;Then, on the new clock, a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flip-flop_(electronics)&quot;&gt;flip-flop&lt;/a&gt;
chain is used to receive this
&lt;a href=&quot;https://en.wikipedia.org/wiki/Clock_domain_crossing&quot;&gt;CDC&lt;/a&gt;
request from the old clock.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge new_clock)
	{ new_req, xreq_pipe } &amp;lt;= { xreq_pipe, req };&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Once the request has been received, it is immediately sent back to the original
clock in the form of an acknowledgement.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge old_clock)
	{ old_ack, xack_pipe } &amp;lt;= { xack_pipe, new_req };&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Only when this acknowledgement is low again are we ready to send any subsequent
requests.  Hence, we are busy from the time the original request is sent until
the time later when the acknowledgement is cleared.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;assign	busy = (req)||(old_ack);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This then gives us the final logic we need to create our request in the
first place.  We can send a request any time we are not busy, and 
some event has happened that we wish to place on the other clock domain.
Once the acknowledgement has been received, we drop our request line
and wait for the acknowledgement to be dropped as well.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge old_clock)
	if ((!busy)&amp;amp;&amp;amp;(some_event))
		req &amp;lt;= 1&#39;b1;
	else if (old_ack)
		req &amp;lt;= 1&#39;b0;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Indeed, this is the basic handshaking method used within my
&lt;a href=&quot;https://github.com/ZipCPU/wbscope&quot;&gt;Wishbone scope&lt;/a&gt;
in order to send information, such as a reset scope command, from the bus clock
domain to the data clock domain and back again.&lt;/p&gt;

&lt;h2 id=&quot;signaling-a-rare-event&quot;&gt;Signaling a (rare) event&lt;/h2&gt;

&lt;p&gt;From here, we can build upon this idea to send an “event” from one domain
to another.  By “event”, I mean something that will only ever be true for
a single clock cycle.  To work, though, the event will need to be rare
enough that the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Clock_domain_crossing&quot;&gt;CDC&lt;/a&gt;
circuit isn’t still busy handling the last event.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 5: Passing an event across clocks&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/cdc-stb.svg&quot; alt=&quot;An event crossing clock domains: first it triggers the request, and then the rising change in the acknowledgement triggers the event in the new domain&quot; width=&quot;480&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;The basic method, shown in Fig 5 above, is almost identical to what we did
before.  There are only two basic differences.&lt;/p&gt;

&lt;p&gt;The first difference is that we trigger off of a specific single-clock
event, rather than off of some yet to be defined logic.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge old_clock)
	if ((!busy)&amp;amp;&amp;amp;(i_stb))
		req &amp;lt;= 1&#39;b1;
	else if (old_ack)
		req &amp;lt;= 1&#39;b0;
assign	busy = (req)||(old_ack);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The second difference is that we need to recognize a rising request signal
within the new clock domain.  This means that we need to keep track of the last
state of the request signal, &lt;code class=&quot;highlighter-rouge&quot;&gt;last_req&lt;/code&gt;, in our pipeline request logic as well
as the rest of the pipeline request logic we used before.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge new_clock)
	{ last_req, new_req, xreq_pipe } &amp;lt;= { new_req, xreq_pipe, req };&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Then, any time the &lt;code class=&quot;highlighter-rouge&quot;&gt;last_req&lt;/code&gt;uest is low, but a &lt;code class=&quot;highlighter-rouge&quot;&gt;new_req&lt;/code&gt;uest has been
made, we know we need to generate the event under the new clock domain.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge new_clock)
	o_stb &amp;lt;= (!last_req)&amp;amp;&amp;amp;(new_req);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;You can use this approach to send triggers from one clock domain,
such as the video refresh interrupt created within the video clock domain
to the interrupt controller which may be within the CPU’s clock domain.&lt;/p&gt;

&lt;h2 id=&quot;sending-a-group-of-wires-at-once&quot;&gt;Sending a group of wires at once&lt;/h2&gt;

&lt;p&gt;You can also use this transfer approach to send a group of wires at once.&lt;/p&gt;

&lt;p&gt;This was the approach I used when I wanted to send a byte’s worth of data
at once from the
&lt;a href=&quot;https://www.raspberrypi.org/products/raspberry-pi-2-model-b/&quot;&gt;RPi&lt;/a&gt;
to the &lt;a href=&quot;http://www.latticesemi.com/iCE40&quot;&gt;iCE40&lt;/a&gt; on top of my
&lt;a href=&quot;http://www.icoboard.org&quot;&gt;ICO board&lt;/a&gt;.  Since I was designing the
interface with no idea of how fast the two clocks would be relative to
one another, I needed a handshaking method to control the transfer of all
8-bits at once.  You can see the project that uses this approach
&lt;a href=&quot;https://github.com/ZipCPU/icozip&quot;&gt;here&lt;/a&gt;.  The
&lt;a href=&quot;https://www.raspberrypi.org/products/raspberry-pi-2-model-b/&quot;&gt;RPi&lt;/a&gt;
software can be found in &lt;a href=&quot;https://github.com/ZipCPU/icozip/blob/master/sw/host/netpport.cpp&quot;&gt;sw/host/netpport.cpp&lt;/a&gt;,
whereas the Verilog half of the interface can be found in
&lt;a href=&quot;https://github.com/ZipCPU/icozip/blob/master/rtl/pport/pport.v&quot;&gt;pport/pport.v&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;How would we handle that?&lt;/p&gt;

&lt;p&gt;The first step would be to copy the data to a transfer region, and then
to set a “pre-transfer” signal indicating that the data was valid.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge old_clock)
	if ((!busy)&amp;amp;&amp;amp;(!valid_data))
		transfer_data &amp;lt;= i_data;
		valid_data &amp;lt;= 1&#39;b1;
	end else if (old_ack)
		valid_data &amp;lt;= 1&#39;b0;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This needs to be done on the clock before the transfer starts.&lt;/p&gt;

&lt;p&gt;You can then perform a handshake to the other clock domain.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge old_clock)
	if ((!busy)&amp;amp;&amp;amp;(valid_data))
	begin
		req &amp;lt;= 1&#39;b1;
	else if (old_ack)
		req &amp;lt;= 1&#39;b0;
assign	busy = (req)||(old_ack);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Once the changed acknowledgement has been received, the data can be copied
into &lt;a href=&quot;https://en.wikipedia.org/wiki/Flip-flop_(electronics)&quot;&gt;flip-flop&lt;/a&gt;s
controlled by the new clock domain.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge new_clock)
	if ((!last_req)&amp;amp;&amp;amp;(new_req))
		o_data &amp;lt;= transfer_data;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;No &lt;a href=&quot;https://en.wikipedia.org/wiki/Flip-flop_(electronics)&quot;&gt;flip-flop&lt;/a&gt;
chain is necessary to receive the transfer data, since the
hand shake approach has already guaranteed that the transfer data is valid.&lt;/p&gt;

&lt;p&gt;One other difference, though, is that you don’t want to acknowledge the other
side until the transfer has been completed.  Hence, you would have the
following for the acknowledgement,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge old_clock)
	{ old_ack, xack_pipe } &amp;lt;= { xack_pipe, last_req };&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This guarantees that the data will remain stable throughout the copy.&lt;/p&gt;

&lt;h2 id=&quot;sending-a-stream-of-values&quot;&gt;Sending a stream of values&lt;/h2&gt;

&lt;p&gt;What we haven’t discussed is the idea of sending a stream of values from one
clock to the next.&lt;/p&gt;

&lt;p&gt;Perhaps you are trying to write video from a camera to memory.  In this case,
you might be receiving 24-bit pixels at a high (pixel) clock rate, but that
you need to write &lt;code class=&quot;highlighter-rouge&quot;&gt;128-bits&lt;/code&gt; of data at a time to your
&lt;a href=&quot;https://en.wikipedia.org/wiki/DDR3-SDRAM&quot;&gt;DDR3-SDRAM&lt;/a&gt; memory at a lower rate.&lt;/p&gt;

&lt;table style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 6: A FIFO can cross clock domains&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/cdc-fifo-plain.svg&quot; alt=&quot;A FIFO can cross clock domains&quot; width=&quot;320&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Alternatively, you might be wanting to store and forward results from a
high speed &lt;a href=&quot;https://en.wikipedia.org/wiki/Analog-to-digital_converter&quot;&gt;analog to digital converter
(A/D)&lt;/a&gt; across an
ethernet port.  Indeed, the example applies for a low speed &lt;a href=&quot;https://en.wikipedia.org/wiki/Analog-to-digital_converter&quot;&gt;A/D 
Converter&lt;/a&gt;
as well!  Perhaps you are consistently sending data to the
new clock domain, but you are only reading it out rarely, and in high speed
bursts at that.&lt;/p&gt;

&lt;p&gt;In both examples, you have a stream of data that needs to be moved from one
clock domain to another.&lt;/p&gt;

&lt;p&gt;The solution to this problem is to use a
&lt;a href=&quot;/blog/2017/07/29/fifo.html&quot;&gt;FIFO&lt;/a&gt;, such as the one shown in
Fig 6 above.  You may recall that &lt;a href=&quot;/blog/2017/07/29/fifo.html&quot;&gt;we’ve discussed FIFO’s
before&lt;/a&gt;.
Using such a &lt;a href=&quot;/blog/2017/07/29/fifo.html&quot;&gt;FIFO&lt;/a&gt;,
you can drive the input at one rate and the output at another.&lt;/p&gt;

&lt;table style=&quot;float: left; padding: 15px;&quot;&gt;&lt;caption&gt;Fig 7: FIFO&#39;s need to manage other signals as well&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/cdc-fifo.svg&quot; alt=&quot;A FIFO can cross clock domains&quot; width=&quot;420&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;The problem, though, is how do you build a
&lt;a href=&quot;/blog/2017/07/29/fifo.html&quot;&gt;FIFO&lt;/a&gt; that
&lt;a href=&quot;https://en.wikipedia.org/wiki/Clock_domain_crossing&quot;&gt;crosses clock domains&lt;/a&gt;?
Specifically, you need to keep the source from writing if the
&lt;a href=&quot;/blog/2017/07/29/fifo.html&quot;&gt;FIFO&lt;/a&gt;
is full, and you need to keep the sink from reading the output when the
&lt;a href=&quot;/blog/2017/07/29/fifo.html&quot;&gt;FIFO&lt;/a&gt;
is empty–and both of these conditions depend on knowing information from the
other side of the 
&lt;a href=&quot;/blog/2017/07/29/fifo.html&quot;&gt;FIFO&lt;/a&gt;.  Not only that,
but you need to be able to handle the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Clock_domain_crossing&quot;&gt;CDC&lt;/a&gt;
with your reset circuitry as well.&lt;/p&gt;

&lt;p&gt;This, however, will need to remain the topic of a future post.&lt;/p&gt;

&lt;p&gt;Until then, if you are more interested in the topic,
Clifford E. Cummings of
&lt;a href=&quot;http://www.sunburst-design.com&quot;&gt;Sunburst Design&lt;/a&gt;
has written a &lt;a href=&quot;http://www.sunburst-design.com/papers/CummingsSNUG2008Boston_CDC.pdf&quot;&gt;wonderful, and rather extensive,
paper&lt;/a&gt;
on the topic.  I suspect you will find it to be very valuable–I certainly have.&lt;/p&gt;
&lt;hr /&gt;&lt;p&gt;&lt;em&gt;We know that we have passed from death unto life, because we love the brethren. He that loveth not his brother abideth in death. (1John 3:14)&lt;/em&gt;</description>
        <pubDate>Fri, 20 Oct 2017 00:00:00 -0400</pubDate>
        <link>http://zipcpu.com/blog/2017/10/20/cdc.html</link>
        <guid isPermaLink="true">http://zipcpu.com/blog/2017/10/20/cdc.html</guid>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>My first experience with Formal Methods</title>
        <description>&lt;p&gt;Clifford Wolf has written a nice tool, &lt;code class=&quot;highlighter-rouge&quot;&gt;yosys-smtbmc&lt;/code&gt;, based upon his
&lt;a href=&quot;http://www.clifford.at/yosys&quot;&gt;yosys&lt;/a&gt; synthesys tool, that allows you to apply
&lt;a href=&quot;https://en.wikipedia.org/wiki/Formal_methods&quot;&gt;formal methods&lt;/a&gt;
to your Verilog code.  The promise of
&lt;a href=&quot;https://en.wikipedia.org/wiki/Formal_methods&quot;&gt;formal methods&lt;/a&gt;
is that you can then mathematically &lt;em&gt;prove&lt;/em&gt; that your code works, or if not
then the formal solver should be able to tell you where your code is failing.&lt;/p&gt;

&lt;p&gt;I’ve only been working with these
&lt;a href=&quot;https://en.wikipedia.org/wiki/Formal_methods&quot;&gt;methods&lt;/a&gt;
for a week or so, but already there are some things I can share.&lt;/p&gt;

&lt;p&gt;The first project I tried applying these formal methods to was a simple
&lt;a href=&quot;https://github.com/ZipCPU/wbpmic&quot;&gt;SPI-based A/D converter&lt;/a&gt;.  This particular
controller is designed to interact with a
&lt;a href=&quot;https://store.digilentinc.com&quot;&gt;Digilent&lt;/a&gt; &lt;a href=&quot;https://store.digilentinc.com/pmod-mic3-mems-microphone-with-adjustable-gain/&quot;&gt;product containing a
MEMs based microphone&lt;/a&gt;.  I’ve had
&lt;a href=&quot;https://github.com/ZipCPU/wbpmic&quot;&gt;the project&lt;/a&gt;
built for some time, although I’ll admit I’ve never actually done anything
more with it than plug it in.&lt;/p&gt;

&lt;p&gt;Since &lt;a href=&quot;https://github.com/ZipCPU/wbpmic&quot;&gt;the project&lt;/a&gt; is simple enough, I
thought I’d try applying
&lt;a href=&quot;https://en.wikipedia.org/wiki/Formal_methods&quot;&gt;formal methods&lt;/a&gt;
to it, to &lt;em&gt;prove&lt;/em&gt; that my controller worked.  Sure, I had a &lt;a href=&quot;https://github.com/ZipCPU/wbpmic/blob/master/bench/cpp/wbmic_tb.cpp&quot;&gt;test
bench&lt;/a&gt;
that I had built some time earlier to convince me that the project worked.
The &lt;a href=&quot;https://github.com/ZipCPU/wbpmic/blob/master/rtl/wbmic.v&quot;&gt;design&lt;/a&gt; worked
well against this &lt;a href=&quot;https://github.com/ZipCPU/wbpmic/blob/master/bench/cpp/wbmic_tb.cpp&quot;&gt;test
bench&lt;/a&gt;,
so I didn’t expect to find many problems using
&lt;a href=&quot;https://en.wikipedia.org/wiki/Formal_methods&quot;&gt;formal methods&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Imagine my surprise when I found several bugs instead.  Not only that, many of
those bugs were within my &lt;a href=&quot;https://github.com/ZipCPU/wbpmic/blob/master/rtl/smplfifo.v&quot;&gt;FIFO
implementation&lt;/a&gt;–something
that I’d passed from one project to another for some time.  You see, when I
&lt;a href=&quot;/blog/2017/07/29/fifo.html&quot;&gt;built my FIFO&lt;/a&gt; I only tested
it in a fashion such as a “reasonable” person might use it.  Under this
“reasonable use” scenario, the
&lt;a href=&quot;/blog/2017/07/29/fifo.html&quot;&gt;FIFO&lt;/a&gt;
had done well.&lt;/p&gt;

&lt;p&gt;The formal prover, however, didn’t limit itself to what I considered
“reasonable” usage of the
&lt;a href=&quot;https://github.com/ZipCPU/wbpmic/blob/master/rtl/smplfifo.v&quot;&gt;FIFO&lt;/a&gt;.
It created underruns and overruns, wrote to the
&lt;a href=&quot;https://github.com/ZipCPU/wbpmic/blob/master/rtl/smplfifo.v&quot;&gt;FIFO&lt;/a&gt;
when it was full, and read from the
&lt;a href=&quot;https://github.com/ZipCPU/wbpmic/blob/master/rtl/smplfifo.v&quot;&gt;FIFO&lt;/a&gt;
when it was empty.
It even wrote &lt;em&gt;and&lt;/em&gt; read from the empty
&lt;a href=&quot;https://github.com/ZipCPU/wbpmic/blob/master/rtl/smplfifo.v&quot;&gt;FIFO&lt;/a&gt;
on the same clock, and it wrote and read from the full
&lt;a href=&quot;https://github.com/ZipCPU/wbpmic/blob/master/rtl/smplfifo.v&quot;&gt;FIFO&lt;/a&gt;
on the same clock as well.
When the internal logic didn’t “match” the criteria I gave the solver, it then
showed me where &lt;a href=&quot;https://github.com/ZipCPU/wbpmic/blob/master/rtl/smplfifo.v&quot;&gt;my FIFO
code&lt;/a&gt;
didn’t properly handle these conditions.&lt;/p&gt;

&lt;p&gt;I guess I just didn’t have that much creativity when I created my &lt;a href=&quot;https://github.com/ZipCPU/wbpmic/blob/master/bench/cpp/wbmic_tb.cpp&quot;&gt;test
bench&lt;/a&gt;
in the first place.&lt;/p&gt;

&lt;p&gt;Was the result worth it?  Keep in mind, I’ve never used
&lt;a href=&quot;https://en.wikipedia.org/wiki/Formal_methods&quot;&gt;these methods&lt;/a&gt;
before.  So did I think it was worth it?  I think so.  I haven’t “proved”
all of my projects yet, nor do I know if I will be able to, but I have added
proofs to some of them—and found bugs as a result.&lt;/p&gt;

&lt;p&gt;Today, though, I’d like to share some of what I have learned.&lt;/p&gt;

&lt;h2 id=&quot;state-sets&quot;&gt;State Sets&lt;/h2&gt;

&lt;p&gt;If you’ve never worked with
&lt;a href=&quot;https://en.wikipedia.org/wiki/Formal_methods&quot;&gt;formal methods&lt;/a&gt;
before, the basic concept is that you will
go through your code and declare which states are valid and which are not.
You’ll then use a theorem prover to &lt;em&gt;mathematically&lt;/em&gt; &lt;em&gt;prove&lt;/em&gt; that you can
&lt;em&gt;never&lt;/em&gt; enter an invalid state from a valid one.  If the prover cannot
prove this, then typically you will have either a bug in your
code, or a bug in your formal assertions.&lt;/p&gt;

&lt;p&gt;You can think of the “state” as the values in all of your
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flip-flop_(electronics)&quot;&gt;flip-flop&lt;/a&gt;s,
together with the values of all of your inputs.&lt;/p&gt;

&lt;table style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 1: Bounded Model Check&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/formal-bmc.svg&quot; alt=&quot;BMC starts from a valid initial state, then wanders to see if it can get to an illegal state&quot; width=&quot;320&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;The first step in yosys-smtbmc based theorem solving is the &lt;em&gt;bounded model
checker&lt;/em&gt; (BMC), figuratively shown in Fig 1.  This
part of the theorem solver starts your design in its initial state,
and then walks through all of the state transitions that it can, stepping your
logic forward from one time step to the next, just to see if any set of
conditions will drive your model to an invalid state.&lt;/p&gt;

&lt;p&gt;This may be the most straightforward part of using yosys-smtbmc, and the
easiest to understand.  The problem with the BMC step is that your time is
limited.  Therefore, you will only want to allow the BMC step to check some
finite number of transitions.  This number needs to be chosen carefully,
otherwise there may be states you might eventually get into over time that it
won’t find.&lt;/p&gt;

&lt;p&gt;You can also find these additional states via the second step:
the &lt;em&gt;induction&lt;/em&gt; step.&lt;/p&gt;

&lt;p&gt;The induction step is just like the &lt;a href=&quot;https://en.wikipedia.org/wiki/Mathematical_induction&quot;&gt;mathematical
induction&lt;/a&gt; you learned in
&lt;a href=&quot;https://en.wikipedia.org/wiki/Precalculus&quot;&gt;Pre-calculus&lt;/a&gt;.  You
first prove that some property is true for the first value,
&lt;code class=&quot;highlighter-rouge&quot;&gt;n=1&lt;/code&gt;.  This was the purpose of the BMC step above.  If it is true for this
base case, you then proceed with the inductive step.  This step assumes that
your logic is within some initially valid state, say state &lt;code class=&quot;highlighter-rouge&quot;&gt;n&lt;/code&gt;, and it then
tries to prove that your logic will only transition to a valid state,
say state &lt;code class=&quot;highlighter-rouge&quot;&gt;n+1&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;That’s the idea.&lt;/p&gt;

&lt;table style=&quot;float: left; padding: 15px&quot;&gt;&lt;caption&gt;Fig 2: The induction step&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/formal-induction.svg&quot; alt=&quot;Induction starts from a random valid state, and tries to prove that the state will never become invalid&quot; width=&quot;320&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;In practice, I’ve struggled with this induction step.  The challenge
to the designer with the induction step is that  you have to declare &lt;em&gt;every&lt;/em&gt;
unreachable state as invalid, or it might start processing from an
unreachable state you aren’t expecting.  As figure 2 shows, states
that are neither valid nor invalid,
but still states that the design will never reach, may easily become starting
states for induction.  It is therefore up to the designer to clearly
indicate that all states must be either valid or invalid.&lt;/p&gt;

&lt;table style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 3: Unreachable states should be invalid&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/formal-unreachable.svg&quot; alt=&quot;To make induction work, all unreachable states should be declared as invalid&quot; width=&quot;320&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Let me try to explain this a touch better.  In a moment we’ll go over some
System Verilog statements that
&lt;a href=&quot;http://www.clifford.at/yosys&quot;&gt;yosys&lt;/a&gt;
will recognize.  These statements declare only the state that you cannot
get to.  They do this by either reducing the size of the total state space
examined, or by declaring particular states to be illegal.  That part is the
job of the formal specification designer.  The job of the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Formal_methods&quot;&gt;formal method&lt;/a&gt;
is to determine which states may be reached, and to then cross check these
states against the illegal ones.&lt;/p&gt;

&lt;p&gt;Perhaps a simple table, such as the one in Fig 4, might help to explain this.&lt;/p&gt;

&lt;table style=&quot;float: left; padding: 15px;&quot;&gt;&lt;caption&gt;Fig 4: Unreachable vs Invalid states&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/formal-chart.svg&quot; alt=&quot;&quot; width=&quot;420&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;What you want to know, as a designer, is whether or not there is any way that
you might reach an invalid state from a valid one.  Hence, you want to know if a
particular illegal state is reachable from a valid state.  This is the
purpose of &lt;a href=&quot;https://en.wikipedia.org/wiki/Formal_methods&quot;&gt;formal method&lt;/a&gt;s.&lt;/p&gt;

&lt;p&gt;The part I struggled with while working through the induction step is that any
state that isn’t declared to be invalid might be a starting point for
induction–even if the state is unreachable.&lt;/p&gt;

&lt;p&gt;This should help give you an idea, should you try working with
&lt;a href=&quot;https://en.wikipedia.org/wiki/Formal_methods&quot;&gt;formal method&lt;/a&gt;s
yourself, that you need to make certain that unreachable states
are either declared to be invalid or removed from the set of possible states.&lt;/p&gt;

&lt;p&gt;Speaking of, that’s our next step: discussing how to declare states to be
invalid when using &lt;a href=&quot;http://www.clifford.at/yosys&quot;&gt;yosys&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;formal-declarations&quot;&gt;Formal Declarations&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;http://www.clifford.at/yosys&quot;&gt;yosys&lt;/a&gt;
can be made to understand some basic formal statements, drawn from a
subset of the System Verilog formal verification language.  This can be
frustrating for a new user of
&lt;a href=&quot;https://en.wikipedia.org/wiki/Formal_methods&quot;&gt;formal method&lt;/a&gt;s with
&lt;a href=&quot;http://www.clifford.at/yosys&quot;&gt;yosys&lt;/a&gt;,
since most of the material on line discusses the full System Verilog formal
description language subset.  What &lt;a href=&quot;http://www.clifford.at/yosys&quot;&gt;yosys&lt;/a&gt;
supports is much less than that.  Basically, 
&lt;a href=&quot;http://www.clifford.at/yosys&quot;&gt;yosys&lt;/a&gt; supports &lt;code class=&quot;highlighter-rouge&quot;&gt;assert()&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;assume()&lt;/code&gt;,
&lt;code class=&quot;highlighter-rouge&quot;&gt;restrict()&lt;/code&gt;, and some expressions about transitions.  Let’s examine those
formal verification statements here.&lt;/p&gt;

&lt;p&gt;The first statement of interest is the &lt;code class=&quot;highlighter-rouge&quot;&gt;assert()&lt;/code&gt; statement.  At first blush,
this statement works very much like the &lt;code class=&quot;highlighter-rouge&quot;&gt;assert()&lt;/code&gt; statement within C/C++.
The value given to the &lt;code class=&quot;highlighter-rouge&quot;&gt;assert()&lt;/code&gt; statement must be true, or you your design
isn’t working as desired.  &lt;code class=&quot;highlighter-rouge&quot;&gt;assert()&lt;/code&gt;s do more than that, though.
&lt;code class=&quot;highlighter-rouge&quot;&gt;assert()&lt;/code&gt;s declare states that are invalid within your design.&lt;/p&gt;

&lt;p&gt;We’ll come back to that thought in a moment.&lt;/p&gt;

&lt;p&gt;The other thing you need to know about &lt;code class=&quot;highlighter-rouge&quot;&gt;assert()&lt;/code&gt;s is that within a simulation,
if the &lt;code class=&quot;highlighter-rouge&quot;&gt;assert()&lt;/code&gt; is ever not true, the simulation will halt on a failure.
This allows you focus on what caused the problem within your design.&lt;/p&gt;

&lt;p&gt;The next basic statement is the &lt;code class=&quot;highlighter-rouge&quot;&gt;assume()&lt;/code&gt; statement.  This statement is like
the &lt;code class=&quot;highlighter-rouge&quot;&gt;assert()&lt;/code&gt;, but with the exception that the theorem prover doesn’t try to
prove that the &lt;code class=&quot;highlighter-rouge&quot;&gt;assume()&lt;/code&gt; statement is true.  Instead, it forces the &lt;code class=&quot;highlighter-rouge&quot;&gt;assume()&lt;/code&gt;
to be true.  Any logic path that would cause the &lt;code class=&quot;highlighter-rouge&quot;&gt;assume()&lt;/code&gt; to be false
is quietly culled.  From the perspective of the state space that will be
examined, the &lt;code class=&quot;highlighter-rouge&quot;&gt;assume()&lt;/code&gt; statement removes particular states from the
realm of possibilities.&lt;/p&gt;

&lt;p&gt;For example,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;initial	last_clk = 1&#39;b0;
always @($global_clock)
	assume(i_clk == !last_clk);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;will force the &lt;code class=&quot;highlighter-rouge&quot;&gt;i_clk&lt;/code&gt; input to the design to toggle with every
simulation step (that’s the meaning of the &lt;code class=&quot;highlighter-rouge&quot;&gt;$global_clock&lt;/code&gt;–it’s true on
every change of the time step).  States and state transitions where the
clock doesn’t toggle are just quietly removed from the realm of possibility.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;assume()&lt;/code&gt; statements have one more feature: if during a simulation the
condition is &lt;em&gt;invalid&lt;/em&gt;, the simulation will halt with an error just as it would
if the &lt;code class=&quot;highlighter-rouge&quot;&gt;assert()&lt;/code&gt; statement were false.&lt;/p&gt;

&lt;p&gt;The &lt;code class=&quot;highlighter-rouge&quot;&gt;restrict()&lt;/code&gt; instruction is similar to the &lt;code class=&quot;highlighter-rouge&quot;&gt;assume()&lt;/code&gt; instruction.
Like &lt;code class=&quot;highlighter-rouge&quot;&gt;assume()&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;restrict()&lt;/code&gt; also reduces the size of the state space that
the theorem prover needs to work within.  In that way, a &lt;code class=&quot;highlighter-rouge&quot;&gt;restrict&lt;/code&gt; statement
is much like an &lt;code class=&quot;highlighter-rouge&quot;&gt;assume()&lt;/code&gt; statement.
However, unlike the &lt;code class=&quot;highlighter-rouge&quot;&gt;assume()&lt;/code&gt; statement, the &lt;em&gt;simulator&lt;/em&gt; will ignore any
&lt;code class=&quot;highlighter-rouge&quot;&gt;restrict()&lt;/code&gt; statements within your code.&lt;/p&gt;

&lt;p&gt;I’ve also found several functions to be very valuable: &lt;code class=&quot;highlighter-rouge&quot;&gt;$past()&lt;/code&gt;,
&lt;code class=&quot;highlighter-rouge&quot;&gt;$stable()&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;$rose()&lt;/code&gt;, and &lt;code class=&quot;highlighter-rouge&quot;&gt;$fell()&lt;/code&gt;.  Since these are important,
let’s work our way through them.&lt;/p&gt;

&lt;p&gt;The &lt;code class=&quot;highlighter-rouge&quot;&gt;$past()&lt;/code&gt; function has the form of &lt;code class=&quot;highlighter-rouge&quot;&gt;$past(expression, N)&lt;/code&gt;, for arbitrary
expressions, and positive integers, &lt;code class=&quot;highlighter-rouge&quot;&gt;N&lt;/code&gt;.  This statement returns the value
of the expression &lt;code class=&quot;highlighter-rouge&quot;&gt;N&lt;/code&gt; clocks ago.  Hence, &lt;code class=&quot;highlighter-rouge&quot;&gt;$past(expression,1)&lt;/code&gt; references what
the expression evaluated to during the last clock.  The number of clocks
parameter, &lt;code class=&quot;highlighter-rouge&quot;&gt;N&lt;/code&gt;, defaults to one, so &lt;code class=&quot;highlighter-rouge&quot;&gt;$past(expression)&lt;/code&gt; is just the same as
&lt;code class=&quot;highlighter-rouge&quot;&gt;$past(expression,1)&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;System Verilog allows two more arguments to the &lt;code class=&quot;highlighter-rouge&quot;&gt;$past()&lt;/code&gt; function for a total
of four.  Not so with &lt;a href=&quot;http://www.clifford.at/yosys&quot;&gt;yosys&lt;/a&gt;, however you
may not find these extra arguments necessary either.  For example, the fourth
System Verilog argument to the &lt;code class=&quot;highlighter-rouge&quot;&gt;$past()&lt;/code&gt; function specifies what clock and
clock edge you are referencing the &lt;code class=&quot;highlighter-rouge&quot;&gt;$past()&lt;/code&gt; expression from.  Instead,
&lt;a href=&quot;http://www.clifford.at/yosys&quot;&gt;yosys&lt;/a&gt;
only allows expressions of &lt;code class=&quot;highlighter-rouge&quot;&gt;$past()&lt;/code&gt; values within a clocked
always block, and so it uses the clock specified in the always statement to
define the clock the &lt;code class=&quot;highlighter-rouge&quot;&gt;$past()&lt;/code&gt; function is relative to.&lt;/p&gt;

&lt;p&gt;There is one other trick with the &lt;code class=&quot;highlighter-rouge&quot;&gt;$past()&lt;/code&gt; function: prior to the first
clock, the $past value is undefined and often assumed to be zero by many
formal theorem solvers.  You’ll need to be careful, therefore, not to expect
the $past value to reference any &lt;code class=&quot;highlighter-rouge&quot;&gt;initial&lt;/code&gt; value within your logic.&lt;/p&gt;

&lt;p&gt;For this reason, I’ve gotten in the habit of creating a signal to tell me if
the past value is valid, such as:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;initial	f_past_valid = 1&#39;b0;
always @(posedge i_clk)
	f_past_valid &amp;lt;= 1&#39;b1;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;I can then use &lt;code class=&quot;highlighter-rouge&quot;&gt;f_past_valid&lt;/code&gt; as part of an expression to determine whether or
not the inputs to a &lt;a href=&quot;/zipcpu/2017/05/29/simple-wishbone.html&quot;&gt;wishbone
slave&lt;/a&gt; will not
change once the strobe goes high until the stall line is low.  Remember how
&lt;a href=&quot;/zipcpu/2017/05/29/simple-wishbone.html&quot;&gt;we discussed&lt;/a&gt;
that with &lt;a href=&quot;/doc/wbspec_b4.pdf&quot;&gt;wishbone&lt;/a&gt; nothing happens
until &lt;code class=&quot;highlighter-rouge&quot;&gt;(i_wb_stb)&amp;amp;&amp;amp;(!o_wb_stall)&lt;/code&gt;?  This means that once the
wishbone master
asserts the strobe signal, &lt;code class=&quot;highlighter-rouge&quot;&gt;i_wb_stb&lt;/code&gt;, that it is likely to wait for the
&lt;code class=&quot;highlighter-rouge&quot;&gt;o_wb_stall&lt;/code&gt; signal to lower before changing the bus request details.
To capture this thought, we’ll assume that once &lt;code class=&quot;highlighter-rouge&quot;&gt;i_wb_stb&lt;/code&gt;
goes high, none of the bus request information will change until the
clock after &lt;code class=&quot;highlighter-rouge&quot;&gt;o_wb_stall&lt;/code&gt; goes low:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	if ((f_past_valid)&amp;amp;&amp;amp;($past(i_wb_stb))&amp;amp;&amp;amp;($past_o_wb_stall))
	begin
		assume(i_wb_stb);
		assume(i_wb_we   == $past(i_wb_we));
		assume(i_wb_addr == $past(i_wb_addr));
		assume(i_wb_data == $past(i_wb_data));
		assume(i_wb_sel  == $past(i_wb_sel ));
	end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Alternatively, instead of assuming that the current value was equal to the
last value, we could have instead asserted that these values were &lt;code class=&quot;highlighter-rouge&quot;&gt;$stable()&lt;/code&gt;
for the same effect:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	if ((f_past_valid)&amp;amp;&amp;amp;($past(i_wb_stb))&amp;amp;&amp;amp;($past_o_wb_stall))
	begin
		assume(i_wb_stb);
		assume($stable(i_wb_we));
		assume($stable(i_wb_addr));
		assume($stable(i_wb_data));
		assume($stable(i_wb_sel));
	end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The last of the basic commands you’ll want to know is the &lt;code class=&quot;highlighter-rouge&quot;&gt;$rose()&lt;/code&gt; command.
This command returns true or false depending on whether the signal given to
it has risen (positive edge) over the last clock period or not.&lt;/p&gt;

&lt;p&gt;This particular function is &lt;em&gt;very&lt;/em&gt; useful for telling the theorem prover that
your inputs are only going to change on the positive edge of the clock,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @($global_clock)
	// If it isn&#39;t the positive edge ...
	if (!$rose(i_wb_clk))
	begin
		// Then nothing changes
		assume(i_wb_stb);
		assume($stable(i_wb_we));
		assume($stable(i_wb_addr));
		assume($stable(i_wb_data));
		assume($stable(i_wb_sel));
	end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;A similar &lt;code class=&quot;highlighter-rouge&quot;&gt;$fell()&lt;/code&gt; primitive exists as well for testing negative clock edges.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.clifford.at/yosys&quot;&gt;yosys&lt;/a&gt; provides one more helpful feature.
Anytime you use
&lt;a href=&quot;http://www.clifford.at/yosys&quot;&gt;yosys&lt;/a&gt;
to generate a formal description of your code, 
&lt;a href=&quot;http://www.clifford.at/yosys&quot;&gt;yosys&lt;/a&gt; defines the &lt;code class=&quot;highlighter-rouge&quot;&gt;FORMAL&lt;/code&gt; flag.  Hence, you
can surround your formal properties with &lt;code class=&quot;highlighter-rouge&quot;&gt;ifdef&lt;/code&gt;’s, as in:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;`ifdef	FORMAL
// ...
always @(posedge i_clk)
	assert(!illegal_state);
// ...
`endif&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;These, therefore, are your basic  formal declaration statements:
&lt;code class=&quot;highlighter-rouge&quot;&gt;assert()&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;assume()&lt;/code&gt;, and &lt;code class=&quot;highlighter-rouge&quot;&gt;restrict()&lt;/code&gt;.  They are helped by the functions
&lt;code class=&quot;highlighter-rouge&quot;&gt;$stable()&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;$past()&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;$rose()&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;$fell()&lt;/code&gt;, and perhaps some others that I
haven’t learned yet.  (Remember, this is only my first week.)  &lt;code class=&quot;highlighter-rouge&quot;&gt;assert()&lt;/code&gt;
declares statements to be illegal, and &lt;code class=&quot;highlighter-rouge&quot;&gt;assume()&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;restrict()&lt;/code&gt; are used
to limit the size of the state space.&lt;/p&gt;

&lt;p&gt;With these basic principles, let’s look at some formal theorem proving
concepts.&lt;/p&gt;

&lt;h2 id=&quot;basic-concept&quot;&gt;Basic concept&lt;/h2&gt;

&lt;p&gt;The basic approach to formally describing your program is to &lt;code class=&quot;highlighter-rouge&quot;&gt;assume()&lt;/code&gt; that
the inputs will be valid, and then to &lt;code class=&quot;highlighter-rouge&quot;&gt;assert()&lt;/code&gt; that the outputs are valid.
You may also wish along the way to &lt;code class=&quot;highlighter-rouge&quot;&gt;assert()&lt;/code&gt; particular internal states
are valid as well.&lt;/p&gt;

&lt;p&gt;This works until you aggregate up one level, so that you have a higher level
module instantiating a lower level one.  In that case, you want to &lt;code class=&quot;highlighter-rouge&quot;&gt;assert()&lt;/code&gt;
the values that will be passed to the lower level module rather than
&lt;code class=&quot;highlighter-rouge&quot;&gt;assume()&lt;/code&gt;ing them.&lt;/p&gt;

&lt;h2 id=&quot;a-fifo-example&quot;&gt;A FIFO example&lt;/h2&gt;

&lt;p&gt;Let’s work our way through a simple example–that of a
&lt;a href=&quot;/blog/2017/07/29/fifo.html&quot;&gt;FIFO&lt;/a&gt;.
In this case, we’ll examine the
&lt;a href=&quot;https://github.com/ZipCPU/wbpmic/blob/master/rtl/smplfifo.v&quot;&gt;FIFO&lt;/a&gt;
I just worked with for my &lt;a href=&quot;https://github.com/ZipCPU/wbpmic&quot;&gt;SPI-based microphone
ADC&lt;/a&gt; core.&lt;/p&gt;

&lt;p&gt;As you may remember from &lt;a href=&quot;/blog/2017/07/29/fifo.html&quot;&gt;our last
FIFO&lt;/a&gt; discussion, a
&lt;a href=&quot;/blog/2017/07/29/fifo.html&quot;&gt;FIFO&lt;/a&gt; depends upon two
memory pointers: the write pointer, &lt;code class=&quot;highlighter-rouge&quot;&gt;r_first&lt;/code&gt;, and the read pointer, &lt;code class=&quot;highlighter-rouge&quot;&gt;r_last&lt;/code&gt;.
The only time &lt;code class=&quot;highlighter-rouge&quot;&gt;r_first&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;r_last&lt;/code&gt; are equal is when the
&lt;a href=&quot;/blog/2017/07/29/fifo.html&quot;&gt;FIFO&lt;/a&gt; is empty.
Likewise, the number of items within the
&lt;a href=&quot;/blog/2017/07/29/fifo.html&quot;&gt;FIFO&lt;/a&gt; is
determined by &lt;code class=&quot;highlighter-rouge&quot;&gt;r_first&lt;/code&gt; minus &lt;code class=&quot;highlighter-rouge&quot;&gt;r_last&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;There are some other rules associated with these two variables.
The first is that we cannot be allowed to read from the
&lt;a href=&quot;/blog/2017/07/29/fifo.html&quot;&gt;FIFO&lt;/a&gt;
any time it is empty.  The second rule is that we cannot
write to the &lt;a href=&quot;/blog/2017/07/29/fifo.html&quot;&gt;FIFO&lt;/a&gt; when it
is full, unless we are also reading from the
&lt;a href=&quot;/blog/2017/07/29/fifo.html&quot;&gt;FIFO&lt;/a&gt; at the same time.
Any attempt to read from an empty
&lt;a href=&quot;/blog/2017/07/29/fifo.html&quot;&gt;FIFO&lt;/a&gt;, or write to a full
&lt;a href=&quot;/blog/2017/07/29/fifo.html&quot;&gt;FIFO&lt;/a&gt; should generate an error.&lt;/p&gt;

&lt;p&gt;In order to keep the state transitions from being dependent upon the
number of items in the 
&lt;a href=&quot;/blog/2017/07/29/fifo.html&quot;&gt;FIFO&lt;/a&gt;, I pre-compute two values:
&lt;code class=&quot;highlighter-rouge&quot;&gt;will_overflow&lt;/code&gt;, which is true if the next write will overflow the
&lt;a href=&quot;/blog/2017/07/29/fifo.html&quot;&gt;FIFO&lt;/a&gt;, and
&lt;code class=&quot;highlighter-rouge&quot;&gt;will_underflow&lt;/code&gt;, which will be true if the next read will read from an
empty &lt;a href=&quot;/blog/2017/07/29/fifo.html&quot;&gt;FIFO&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Further, &lt;a href=&quot;https://github.com/ZipCPU/wbpmic/blob/master/rtl/smplfifo.v&quot;&gt;this particular
FIFO&lt;/a&gt; also returns
a status value indicating 1) how many items are in the
&lt;a href=&quot;/blog/2017/07/29/fifo.html&quot;&gt;FIFO&lt;/a&gt;,
2) whether or not the FIFO is non-empty, and 3) whether or not the
&lt;a href=&quot;/blog/2017/07/29/fifo.html&quot;&gt;FIFO&lt;/a&gt;
is past half-full.&lt;/p&gt;

&lt;p&gt;All of these details may also be derived from &lt;code class=&quot;highlighter-rouge&quot;&gt;r_first&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;r_last&lt;/code&gt; alone.  If
they don’t match, the &lt;a href=&quot;/blog/2017/07/29/fifo.html&quot;&gt;FIFO&lt;/a&gt;
is in an illegal state.  Therefore, these properties are a perfect match
for learning
&lt;a href=&quot;https://en.wikipedia.org/wiki/Formal_methods&quot;&gt;formal method&lt;/a&gt;s&lt;/p&gt;

&lt;p&gt;The first step is to gate all of our work so that the synthesis tool will
ignore it, unless we are working with the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Formal_methods&quot;&gt;formal verification methods&lt;/a&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;`ifdef	FORMAL
// ... ALl of our formal specifications go here
`endif // This goes at the end of our formal specification&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Next, within this &lt;code class=&quot;highlighter-rouge&quot;&gt;FORMAL&lt;/code&gt; block we want to make certain that the assumptions
we are going to make regarding our inputs will become asserts when this core
is included into a larger design.  We’ll do this by creating an &lt;code class=&quot;highlighter-rouge&quot;&gt;ASSUME&lt;/code&gt; macro
that we can use to constrain our inputs.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;`ifdef	SMPLFIFO
`define	ASSUME	assume
`else
`define	ASSUME	assert
`endif&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Remember that you only want to constrain via &lt;code class=&quot;highlighter-rouge&quot;&gt;ASSUME&lt;/code&gt; statements about
parameters that can be set by a higher level module, not external inputs.&lt;/p&gt;

&lt;p&gt;Earlier, I described what it would take to assume that the clock toggles.
We’ll repeat that here.  We’re also going to insist that this
&lt;a href=&quot;/blog/2017/07/29/fifo.html&quot;&gt;FIFO&lt;/a&gt;
starts in it’s reset state, by insisting that the &lt;code class=&quot;highlighter-rouge&quot;&gt;i_rst&lt;/code&gt; line is initially
valid.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;initial restrict(i_rst);

always @($global_clock)
begin
	restrict(i_clk == !f_last_clk);
	f_last_clk &amp;lt;= i_clk;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Before leaving this beginning statement, let’s also insist that our
inputs &lt;em&gt;only&lt;/em&gt; change on the positive edge of the clock.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	if (!$rose(i_clk))
	begin
		`ASSUME($stable(i_rst));
		`ASSUME($stable(i_wr));
		`ASSUME($stable(i_data));
		`ASSUME($stable(i_rd));
	end
end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;We also discussed above the need to know whether the &lt;code class=&quot;highlighter-rouge&quot;&gt;$past()&lt;/code&gt; function
would return valid results.  We’ll use the &lt;code class=&quot;highlighter-rouge&quot;&gt;f_past_valid&lt;/code&gt; register for this
purpose.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;initial	f_past_valid = 1&#39;b0;
always @(posedge i_clk)
	f_past_valid &amp;lt;= 1&#39;b1;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This also highlights the fact that your formal verification logic may have
and use registers, just like the rest of your logic–even though you won’t
be using it within your design other than for formal verification.&lt;/p&gt;

&lt;p&gt;Next, let’s look at making sure that our helper logic works.&lt;/p&gt;

&lt;p&gt;First, the &lt;code class=&quot;highlighter-rouge&quot;&gt;r_fill&lt;/code&gt; output should be equal to the number of
&lt;a href=&quot;/blog/2017/07/29/fifo.html&quot;&gt;FIFO&lt;/a&gt;
memory entries that are full.  This is given by the difference between
&lt;code class=&quot;highlighter-rouge&quot;&gt;r_first&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;r_last&lt;/code&gt;.  Above, we chose to use a clocked register to hold this
value.  We did this for timing reasons, but there is the possibility that
we got this wrong.  So, let’s check it here.  Formally, one might say that
the state where &lt;code class=&quot;highlighter-rouge&quot;&gt;r_fill&lt;/code&gt; doesn’t equal this difference is an illegal state.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;assign	f_fill = r_first - r_last;
always @(posedge i_clk)
begin
	assert(f_fill == r_fill);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Now, let’s move on to our empty flag.  Any time the
&lt;a href=&quot;/blog/2017/07/29/fifo.html&quot;&gt;FIFO&lt;/a&gt;
is empty, we want to set the &lt;code class=&quot;highlighter-rouge&quot;&gt;will_underflow&lt;/code&gt; flag.  In addition, we want
&lt;code class=&quot;highlighter-rouge&quot;&gt;o_empty_n&lt;/code&gt; to be true any time we are not empty.  As I mentioned before, the
&lt;a href=&quot;/blog/2017/07/29/fifo.html&quot;&gt;FIFO&lt;/a&gt;
is empty any time &lt;code class=&quot;highlighter-rouge&quot;&gt;r_first&lt;/code&gt; is equal to &lt;code class=&quot;highlighter-rouge&quot;&gt;r_last&lt;/code&gt;.  We can use &lt;code class=&quot;highlighter-rouge&quot;&gt;f_fill&lt;/code&gt; from
above for this purpose.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	if (f_fill == 0)
	begin
		assert(will_underflow);
		assert(!o_empty_n);
	end else begin
		assert(!will_underflow);
		assert(o_empty_n);
	end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;In a similar value, any time the fill is one less than the number of items
in the buffer, then the buffer is “full”.  Let’s make sure we got that logic
right too.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;		if (f_fill == {(LGFLEN){1&#39;b1}})
			assert(will_overflow);
		else
			assert(!will_overflow);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The
&lt;a href=&quot;/blog/2017/07/29/fifo.html&quot;&gt;FIFO&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/wbpmic/blob/master/rtl/smplfifo.v&quot;&gt;code&lt;/a&gt;
also has a value, &lt;code class=&quot;highlighter-rouge&quot;&gt;r_next&lt;/code&gt;, which is supposed to
reference the next value to be read.  To know if we got this right, let’s add
one to the &lt;code class=&quot;highlighter-rouge&quot;&gt;r_last&lt;/code&gt; pointer,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;assign	f_next = r_last + 1&#39;b1;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;and then look to see if &lt;code class=&quot;highlighter-rouge&quot;&gt;r_next&lt;/code&gt; equals this as desired,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	assert(r_next == f_next);
end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Finally, let’s examine the pointers under overflow and underflow conditions.
First, on any reset, both pointers will be set to zero and any output error
will be cleared.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
if (f_past_valid)
begin
	if ($past(i_rst))
		assert(!o_err);
	else begin&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;If we are not in reset, we might have an underflow.  Let’s check.  If the
&lt;a href=&quot;/blog/2017/07/29/fifo.html&quot;&gt;FIFO&lt;/a&gt;
was empty on the last clock, &lt;em&gt;and&lt;/em&gt; if there was a request to read from the
&lt;a href=&quot;/blog/2017/07/29/fifo.html&quot;&gt;FIFO&lt;/a&gt;
on that clock, then we had an underflow.  In that case, assert that the
&lt;a href=&quot;/blog/2017/07/29/fifo.html&quot;&gt;FIFO&lt;/a&gt;
read pointer, &lt;code class=&quot;highlighter-rouge&quot;&gt;r_last&lt;/code&gt;, has not changed as a result.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;		// Underflow detection
		if (($past(i_rd))&amp;amp;&amp;amp;($past(r_fill == 0)))
		begin
			// This core doesn&#39;t report underflow errors,
			// but quietly ignores them
			//
			// assert(o_err);
			//
			// On an underflow, we need to be careful not
			// to advance the pointer.
			assert(r_last == $past(r_last));
		end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Had this pointer changed, the 
&lt;a href=&quot;/blog/2017/07/29/fifo.html&quot;&gt;FIFO&lt;/a&gt;
might accidentally jump from the empty state to the full state with garbage in
the buffer.  We want to avoid this.&lt;/p&gt;

&lt;p&gt;We do almost the same thing on an overflow condition, but there are just a
couple differences.
First, in the case of a read and write on the same clock while we are full,
no overflow has taken place.  Hence we need to check that a write without
a read has taken place.  That’s the first difference.  The second difference
is that this core reports overflow conditions, but not underflow conditions.
Hence, we assert that &lt;code class=&quot;highlighter-rouge&quot;&gt;o_err&lt;/code&gt; is true on any overflow.  Likewise, on any
overflow we also assert that the &lt;code class=&quot;highlighter-rouge&quot;&gt;r_first&lt;/code&gt; pointer hasn’t changed.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;		//
		// Overflow detection
		if (($past(i_wr))&amp;amp;&amp;amp;(!$past(i_rd))
				&amp;amp;&amp;amp;($past(will_overflow)))
		begin
			// Make sure we report this result
			assert(o_err);

			// Make sure we didn&#39;t advance our write
			// pointer on overflow
			assert(r_first == $past(r_first));
		end
	end
end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;As with the underflow, a pointer change during an overflow condition can be
catastrophic as well.  It could cause the
&lt;a href=&quot;/blog/2017/07/29/fifo.html&quot;&gt;FIFO&lt;/a&gt;
to suddenly become empty, losing any of the data within it.  This formal
check about tells the theorem prover that doing so would be illegal, and that
we want to know if anything would create such a condition.&lt;/p&gt;

&lt;p&gt;What we haven’t discussed are the
&lt;a href=&quot;http://symbiyosys.readthedocs.io/en/latest/quickstart.html&quot;&gt;instructions for installing&lt;/a&gt; 
&lt;a href=&quot;http://www.clifford.at/yosys&quot;&gt;yosys&lt;/a&gt;, Symiyosys, and the various theorem
provers.  These may be found
&lt;a href=&quot;http://symbiyosys.readthedocs.io/en/latest/quickstart.html&quot;&gt;on line&lt;/a&gt;.
Neither have we discussed the
&lt;a href=&quot;https://github.com/ZipCPU/wbpmic/blob/master/bench/cpp/Makefile&quot;&gt;Makefile&lt;/a&gt;
I used to coordinate the proof, nor the &lt;a href=&quot;https://github.com/ZipCPU/wbpmic/blob/master/bench/cpp/smplfifo.ys&quot;&gt;yosys
config&lt;/a&gt;
that I used.  Feel free to examine these on your own if you would like.&lt;/p&gt;

&lt;h2 id=&quot;what-did-i-find&quot;&gt;What did I find?&lt;/h2&gt;

&lt;p&gt;You may recall from earlier that I found several errors in my
&lt;a href=&quot;/blog/2017/07/29/fifo.html&quot;&gt;FIFO&lt;/a&gt; as a result of using
these methods.  If you are reading this, then you may be wondering just how
significant those errors were.  Here are some of the things I found:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Originally, I had said that a write during an underflow would only
take you out of the underflow condition if there was no read at the same
time.  This is wrong.&lt;/p&gt;

    &lt;p&gt;A write to an empty
&lt;a href=&quot;/blog/2017/07/29/fifo.html&quot;&gt;FIFO&lt;/a&gt;
will always succeed, independent of whether or not a read is taking place
at the same time, and a read from an empty
&lt;a href=&quot;/blog/2017/07/29/fifo.html&quot;&gt;FIFO&lt;/a&gt;
should always fail–independent of a write taking place at the same time.&lt;/p&gt;

    &lt;p&gt;Fixing this required several changes throughout.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;I hadn’t initialized all of my variables.  In particular, &lt;code class=&quot;highlighter-rouge&quot;&gt;r_next&lt;/code&gt; and
&lt;code class=&quot;highlighter-rouge&quot;&gt;r_fill&lt;/code&gt; weren’t originally initialized.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;When calculating the number of elements in the
&lt;a href=&quot;/blog/2017/07/29/fifo.html&quot;&gt;FIFO&lt;/a&gt;,
I had assumed that if the &lt;code class=&quot;highlighter-rouge&quot;&gt;will_overflow&lt;/code&gt; value was true that any write to
the &lt;a href=&quot;/blog/2017/07/29/fifo.html&quot;&gt;FIFO&lt;/a&gt; would
overflow the &lt;a href=&quot;/blog/2017/07/29/fifo.html&quot;&gt;FIFO&lt;/a&gt;.
This isn’t the case.  If &lt;code class=&quot;highlighter-rouge&quot;&gt;will_overflow&lt;/code&gt; is true, then any write &lt;em&gt;without a
concurrent read&lt;/em&gt; will overflow the
&lt;a href=&quot;/blog/2017/07/29/fifo.html&quot;&gt;FIFO&lt;/a&gt;.
A read and write during the same clock period will not overflow the
&lt;a href=&quot;/blog/2017/07/29/fifo.html&quot;&gt;FIFO&lt;/a&gt;.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;If you’d like, all of the changes are captured within the
&lt;a href=&quot;https://github.com/ZipCPU/wbpmic&quot;&gt;github repository&lt;/a&gt;
on line, so you can review what I found
&lt;a href=&quot;https://github.com/ZipCPU/wbpmic/commit/01efb009ce963b536213f5e8e695acf1c93c2d84#diff-9ce5778d79774aac9ca5e898c621af07&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;final-thoughts&quot;&gt;Final Thoughts&lt;/h2&gt;

&lt;p&gt;Please keep in mind, I’m only a beginner at
&lt;a href=&quot;https://en.wikipedia.org/wiki/Formal_methods&quot;&gt;formal methods&lt;/a&gt;.
I’ve never used any of them before this week, but I’ve already found several
problems in my own code using them.  Are
&lt;a href=&quot;https://en.wikipedia.org/wiki/Formal_methods&quot;&gt;formal methods&lt;/a&gt;
worth the effort?  Well, for me and in this example, they were.&lt;/p&gt;

&lt;p&gt;I’d like to come back to this topic in the future after I’ve learned some
more.  I’d also like to apply these methods to many other problems as well.
However, I’ve also got some problems which I’m not yet certain how to prove.
For example, while I’ve managed to prove a &lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/rtl/llqspi.v&quot;&gt;low level QSPI flash
driver&lt;/a&gt;,
I have yet to figure out how to prove the entire protocol.  Likewise, I’ve
managed to prove that my &lt;a href=&quot;https://github.com/ZipCPU/wbuart32/blob/master/rtl/txuartlite.v&quot;&gt;UART transmitter
(lite)&lt;/a&gt; works,
but not yet the receiver or the &lt;a href=&quot;https://github.com/ZipCPU/wbuart32&quot;&gt;entire IP
core&lt;/a&gt; including the &lt;a href=&quot;https://github.com/ZipCPU/wbuart32/blob/master/rtl/wbuart.v&quot;&gt;wishbone
interface&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;For now, I think I’ll just see if I can’t prove my
&lt;a href=&quot;https://github.com/ZipCPU/wb2axip&quot;&gt;WB to AXI4 bridge&lt;/a&gt; next.
I think that would be useful for all.&lt;/p&gt;
&lt;hr /&gt;&lt;p&gt;&lt;em&gt;Ye have heard that it hath been said, Thou shalt love thy neighbour, and hate thine enemy.  But I say unto you, Love your enemies, bless them that curse you, do good to them that hate you, and pray for them which despitefully use you, and persecute you (Matt 5:44)&lt;/em&gt;</description>
        <pubDate>Thu, 19 Oct 2017 00:00:00 -0400</pubDate>
        <link>http://zipcpu.com/blog/2017/10/19/formal-intro.html</link>
        <guid isPermaLink="true">http://zipcpu.com/blog/2017/10/19/formal-intro.html</guid>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>Just some notes to new readers of the ZipCPU blog</title>
        <description>&lt;p&gt;If you’ve just recently started reading
&lt;a href=&quot;http://zipcpu.com/&quot;&gt;this blog&lt;/a&gt;,
then welcome!&lt;/p&gt;

&lt;p&gt;I’ve now been blogging for only five months.  I’ve hit quite a few topics, but
I’ve still got a lot more to present—many of them fun and fundamental
topics that I think everyone will enjoy.&lt;/p&gt;

&lt;p&gt;While I have your attention, let me point out two things:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;The &lt;a href=&quot;http://zipcpu.com/&quot;&gt;ZipCPU blog&lt;/a&gt; is funded entirely by
donations.&lt;/p&gt;

    &lt;p&gt;I hate pledge drives.  I really do.  We haven’t had one here, and I’d like
to avoid them.  If you like the blog, however, please consider &lt;a href=&quot;https://www.patreon.com/ZipCPU&quot;&gt;supporting
me on Patreon&lt;/a&gt;.&lt;/p&gt;

    &lt;p&gt;Those who &lt;a href=&quot;https://www.patreon.com/ZipCPU&quot;&gt;support me on Patreon&lt;/a&gt;
get a vote regarding where the blog goes next–both in the
&lt;a href=&quot;https://github.com/ZipCPU&quot;&gt;open source projects&lt;/a&gt; I develop next, as well
in the posts I choose to post next.  Even if you choose not to
&lt;a href=&quot;https://www.patreon.com/ZipCPU&quot;&gt;support me on Patreon&lt;/a&gt;, I’m still always
looking for ideas–so feel free to write me then anyway.&lt;/p&gt;

    &lt;p&gt;While I’m not opposed to advertisement, I will insist on a certain
advertisement quality and relevance before allowing any advertiser to post
on this site.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;I’m a touch surprised that only a few visitors have looked over my
&lt;a href=&quot;/topics.html&quot;&gt;topics page&lt;/a&gt;.&lt;/p&gt;

    &lt;p&gt;The &lt;a href=&quot;/topics.html&quot;&gt;topics page&lt;/a&gt; is my notepad
of topics that I’d like to cover in the future.  After writing on
any particular topic from that list, I’ve replacing my “to write” note with a
link to the article(s) on that topic.  Sure, there have been topics that
haven’t fit into that page, but it’s the best guide I have for what topic
to write next.&lt;/p&gt;

    &lt;p&gt;At some point, I’ll collate multiple posts on a single topic together,
and then just link to a page containing all of those posts.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;I really dislike presenting code that doesn’t work.&lt;/p&gt;

    &lt;p&gt;All of the code presented on this site has been tested with
&lt;a href=&quot;https://www.veripool.org/wiki/verilator/&quot;&gt;Verilator&lt;/a&gt;,
and much of it has also been tested on an actual
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;.
Any code that is found to work with
&lt;a href=&quot;https://www.veripool.org/wiki/verilator/&quot;&gt;Verilator&lt;/a&gt;,
&lt;a href=&quot;/blog/2017/07/17/debugging-dbgbus.html&quot;&gt;but not on an actual&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
is quietly fixed whenever I discover it.&lt;/p&gt;

    &lt;p&gt;My point here is just that building examples to share takes time.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;So, let me invite you to take a look at the
&lt;a href=&quot;/topics.html&quot;&gt;topics page&lt;/a&gt;,
and then drop me a line and let me know what topics you’d be interested
in reading about in the future.&lt;/p&gt;

&lt;p&gt;My current project remains HDMI Video encoding/decoding, and the last topic
request survey suggested I should examine DSP topics.  Since then, we’ve
discussed not only how to generate sine and cosine waves, but also several
approaches to digital filtering.&lt;/p&gt;

&lt;p&gt;More recently, several individuals have been requesting a discussion of formal
methods, and in particular
&lt;a href=&quot;http://www.clifford.at/papers/2017/smtbmc-sby/slides.pdf&quot;&gt;yosys-smtbmc&lt;/a&gt;.
While I haven’t used formal methods before, I &lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;just found a bunch of bugs
in some of my FIFO’s by using them&lt;/a&gt;, so that will need to be part of the story.&lt;/p&gt;

&lt;hr /&gt;&lt;p&gt;&lt;em&gt;And they gave the money, being told, into the hands of them that did the work, that had the oversight of the house of the LORD: and they laid it out to the carpenters and builders, that wrought upon the house of the LORD (2Kings 12:11)&lt;/em&gt;</description>
        <pubDate>Wed, 18 Oct 2017 00:00:00 -0400</pubDate>
        <link>http://zipcpu.com/blog/2017/10/18/upcoming.html</link>
        <guid isPermaLink="true">http://zipcpu.com/blog/2017/10/18/upcoming.html</guid>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>Implementing the Moving Average (Boxcar) filter</title>
        <description>&lt;p&gt;When we &lt;a href=&quot;/dsp/2017/08/19/simple-filter.html&quot;&gt;first examined
filtering&lt;/a&gt;, we looked at
the two simplest &lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;digital filters&lt;/a&gt;
I knew of: a &lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/smplfir.v&quot;&gt;filter that averages adjacent
values&lt;/a&gt;, and a
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/iiravg.v&quot;&gt;filter that recursively
averages&lt;/a&gt;
multiple numbers together.  These two simple filters required only a
&lt;a href=&quot;/blog/2017/06/12/minimizing-luts.html&quot;&gt;few FPGA resources&lt;/a&gt;,
and so they were easy to implement.  Sadly, they weren’t very configurable and
so their filtering capability was quite limited.&lt;/p&gt;

&lt;p&gt;We then came back to the topic and discussed how to create a
&lt;a href=&quot;/dsp/2017/09/15/fastfir.html&quot;&gt;generic Finite Impulse Response (FIR) filter&lt;/a&gt;.  Such a
&lt;a href=&quot;/dsp/2017/09/15/fastfir.html&quot;&gt;generic&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Finite_impulse_response&quot;&gt;FIR&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;
is &lt;em&gt;very&lt;/em&gt; configurable.  Using the approach I presented, you can describe &lt;em&gt;any&lt;/em&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Finite_impulse_response&quot;&gt;FIR&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;digital filter&lt;/a&gt; in logic.
We then came back to the topic a bit later, and &lt;a href=&quot;/dsp/2017/09/29/cheaper-fast-fir.html&quot;&gt;discussed how to
create&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/fastfir.v&quot;&gt;a filter&lt;/a&gt;
that required fewer
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flip-flop_(electronics)&quot;&gt;flip-flops&lt;/a&gt;,
while still maintaining the complete configurability of any
&lt;a href=&quot;/dsp/2017/09/15/fastfir.html&quot;&gt;generic&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Finite_impulse_response&quot;&gt;FIR&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The problem with both of these generic approaches is their cost.  As with
most
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;digital filters&lt;/a&gt;,
this cost is often measured in the number of multiplies (i.e. the number of
taps).  While the number of
&lt;a href=&quot;https://en.wikipedia.org/wiki/Logic_block&quot;&gt;logic block&lt;/a&gt;’s
and &lt;a href=&quot;https://en.wikipedia.org/wiki/Flip-flop_(electronics)&quot;&gt;flip-flops&lt;/a&gt;
is also of interest, even this logic scales with the number of filter
taps required.&lt;/p&gt;

&lt;p&gt;As an example of this problem, suppose you wanted to select an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency_modulation&quot;&gt;FM&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/FM_broadcast_band&quot;&gt;broadcast&lt;/a&gt;
signal (200 kHz) from somewhere within the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency_modulation&quot;&gt;FM&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/FM_broadcast_band&quot;&gt;broadcast band&lt;/a&gt; (87-108MHz
&lt;a href=&quot;https://en.wikipedia.org/wiki/Radio_frequency&quot;&gt;RF&lt;/a&gt;
in the US).  Now suppose you also wanted to do all of this processing within
your &lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;,
and that you could afford a &lt;a href=&quot;https://store.digilentinc.com/arty-artix-7-fpga-development-board-for-makers-and-hobbyists/&quot;&gt;$99
Arty&lt;/a&gt; (plus an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency_modulation&quot;&gt;FM&lt;/a&gt; antenna, pre-amp, 
&lt;a href=&quot;https://en.wikipedia.org/wiki/Analog-to-digital_converter&quot;&gt;ADC&lt;/a&gt;, etc.).
The &lt;a href=&quot;https://store.digilentinc.com/arty-artix-7-fpga-development-board-for-makers-and-hobbyists/&quot;&gt;Arty&lt;/a&gt; contains an
&lt;a href=&quot;https://www.xilinx.com/support/documentation/data_sheets/ds180_7Series_Overview.pdf&quot;&gt;Artix-7/35T&lt;/a&gt;
&lt;a href=&quot;https://www.xilinx.com&quot;&gt;Xilinx&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
with 90 DSP slices.  That means you can implement 90 multiplies within your
logic on any given clock tick.  This would allow you to create a
&lt;a href=&quot;/dsp/2017/09/15/fastfir.html&quot;&gt;generic&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Finite_impulse_response&quot;&gt;FIR&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;
with 89 taps.  (Most
&lt;a href=&quot;https://en.wikipedia.org/wiki/Finite_impulse_response&quot;&gt;FIR&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;s
have an &lt;a href=&quot;https://en.wikipedia.org/wiki/Parks-McClellan_filter_design_algorithm&quot;&gt;odd number of
taps&lt;/a&gt;.) 
With an 89 tap &lt;a href=&quot;/dsp/2017/09/15/fastfir.html&quot;&gt;generic
filter&lt;/a&gt;, you’d
only be able to get about a 6dB separation between your channel and any other
&lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency_modulation&quot;&gt;FM&lt;/a&gt; channel, and even
the rest of your
&lt;a href=&quot;https://en.wikipedia.org/wiki/Analog-to-digital_converter&quot;&gt;ADC&lt;/a&gt;’s
&lt;a href=&quot;https://en.wikipedia.org/wiki/Passband&quot;&gt;passband&lt;/a&gt;.
Such performance is pitiful.  It’s a far cry from the 70dB that I was taught
to design to.  Indeed, it would take an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Finite_impulse_response&quot;&gt;FIR&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;
of roughly &lt;em&gt;ten thousand&lt;/em&gt; taps to provide a required 70dB separation.&lt;/p&gt;

&lt;p&gt;Not only does the
&lt;a href=&quot;https://www.xilinx.com/support/documentation/data_sheets/ds180_7Series_Overview.pdf&quot;&gt;Artix 7/35T&lt;/a&gt; (&lt;a href=&quot;https://www.digikey.com/product-detail/en/xilinx-enc/XC7A35T-1FTG256C/122-1910-ND/5039074&quot;&gt;$35&lt;/a&gt;)
on the &lt;a href=&quot;https://store.digilentinc.com/arty-artix-7-fpga-development-board-for-makers-and-hobbyists/&quot;&gt;$99 Arty&lt;/a&gt;
not have this many taps, &lt;em&gt;none of the
&lt;a href=&quot;https://www.xilinx.com&quot;&gt;Xilinx&lt;/a&gt;
&lt;a href=&quot;https://www.xilinx.com/support/documentation/data_sheets/ds180_7Series_Overview.pdf&quot;&gt;7-series parts&lt;/a&gt;
 has enough multiplies (DSP blocks) to implement a filter this large&lt;/em&gt;.
The closest is the heftiest Virtex-7, which has 2,820 DSP elements.  I couldn’t
find this on &lt;a href=&quot;https://www.digikey.com&quot;&gt;Digikey&lt;/a&gt; today, though.  The
closest Virtex 7 that I can find today on &lt;a href=&quot;https://www.digikey.com&quot;&gt;Digikey&lt;/a&gt;
is the &lt;a href=&quot;https://www.digikey.com/product-detail/en/xilinx-inc/XC7V2000T-1FHG1761C/XC7V2000T-1FHG1761C-ND/3925283&quot;&gt;Virtex 7/2000T with 2,160 DSP blocks for
$18,000&lt;/a&gt;.  In other words, money won’t buy you
out of this problem.&lt;/p&gt;

&lt;p&gt;On the other hand, if you could
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;
your signal down to less than 2MHz, without using any multiplies, you can then
save your multiplies for a later step when you could share a single multiply
between multiple taps.  Indeed, if you could do that then you might be able to
select an &lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency_modulation&quot;&gt;FM&lt;/a&gt; channel
for the cost of only a pair of multiplies–sparing your other 88 multiplies for
some other purpose.&lt;/p&gt;

&lt;p&gt;This is where the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Moving_average&quot;&gt;moving average&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;
comes into play.
A &lt;a href=&quot;https://en.wikipedia.org/wiki/Moving_average&quot;&gt;moving average&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;
requires no multiplies, only two additions, two incrementing pointers, and
some block RAM.  Although the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Moving_average&quot;&gt;filter&lt;/a&gt;
has a &lt;code class=&quot;highlighter-rouge&quot;&gt;-13&lt;/code&gt; dB &lt;a href=&quot;https://en.wikipedia.org/wiki/Stopband&quot;&gt;stopband&lt;/a&gt;, applying the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Moving_average&quot;&gt;filter&lt;/a&gt;
in a cascaded fashion &lt;code class=&quot;highlighter-rouge&quot;&gt;N&lt;/code&gt; times would give you a
&lt;code class=&quot;highlighter-rouge&quot;&gt;-13 * N&lt;/code&gt; dB
&lt;a href=&quot;https://en.wikipedia.org/wiki/Stopband&quot;&gt;stopband&lt;/a&gt;.
Six rounds of
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/boxcar.v&quot;&gt;such a filter&lt;/a&gt;
may well be sufficient, especially when each
&lt;a href=&quot;https://en.wikipedia.org/wiki/Moving_average&quot;&gt;moving average&lt;/a&gt;
round uses only a
&lt;a href=&quot;/blog/2017/06/12/minimizing-luts.html&quot;&gt;minimum amount&lt;/a&gt; of
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
logic.&lt;/p&gt;

&lt;p&gt;So, let’s take a look at what it takes to implement a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Moving_average&quot;&gt;moving average&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;.
(I’ll call it a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Boxcar_function&quot;&gt;boxcar&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;,
based upon the fact that the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Impulse_response&quot;&gt;impulse response&lt;/a&gt;
of this &lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;
is a &lt;a href=&quot;https://en.wikipedia.org/wiki/Boxcar_function&quot;&gt;boxcar function&lt;/a&gt;.)
We’ll start by examining how to build a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Moving_average&quot;&gt;moving average&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt; in general,
and then discuss an initial (broken) implementation of such a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;.
We’ll then simplify the basic idea a bit more, and show
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/boxcar.v&quot;&gt;an example&lt;/a&gt;
of how a “&lt;a href=&quot;https://en.wikipedia.org/wiki/Moving_average&quot;&gt;boxcar filter&lt;/a&gt;” &lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/boxcar.v&quot;&gt;might
be implemented&lt;/a&gt;.
We’ll then round out the discussion with a discussion on performance,
explaining what sort of
&lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency_response&quot;&gt;response&lt;/a&gt;
you might expect from this filter.&lt;/p&gt;

&lt;h2 id=&quot;the-formula&quot;&gt;The Formula&lt;/h2&gt;

&lt;p&gt;Since what we’re doing might not look so clear when we dig into &lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/boxcar.v&quot;&gt;the code
itself&lt;/a&gt;, let’s
pause for a moment first to discuss what we are intending to do.
Our goal is to create a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;
that adds an adjacent &lt;code class=&quot;highlighter-rouge&quot;&gt;N&lt;/code&gt; samples together.  As time progresses, the values
that will get averaged together will also rotate through our window as well.
This is why the operation is called a
“&lt;a href=&quot;https://en.wikipedia.org/wiki/Moving_average&quot;&gt;moving average&lt;/a&gt;”: because
the choice of which samples get averaged together moves with time.&lt;/p&gt;

&lt;table style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 1: A Generic Filter Implementation structure&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/fir-form.svg&quot; alt=&quot;Generic FIR implementation structure&quot; width=&quot;380&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Let’s back up a small step first, though.  If you recall
&lt;a href=&quot;/dsp/2017/09/15/fastfir.html&quot;&gt;from before&lt;/a&gt;,
a &lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/fastfir.v&quot;&gt;generic FIR
filter&lt;/a&gt;
has the form shown in Fig 1.  In that figure, you can see how each incoming
input sample goes into a delay line (at the top) and, at each stage of the
delay line, gets multiplied by a constant.  (The constant isn’t shown.)
All of the multiplication products are then added together to form the output.&lt;/p&gt;

&lt;p&gt;Formally, we might write the operation of this filter as,&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/fir-convolution.png&quot; alt=&quot;Formula for an FIR Convolution&quot; width=&quot;388&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;where there are &lt;code class=&quot;highlighter-rouge&quot;&gt;N&lt;/code&gt; taps to the filter, &lt;code class=&quot;highlighter-rouge&quot;&gt;x[n]&lt;/code&gt; is a sequence of input samples,
&lt;code class=&quot;highlighter-rouge&quot;&gt;h[k]&lt;/code&gt; is the sequence of &lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;
coefficients, and &lt;code class=&quot;highlighter-rouge&quot;&gt;y[n]&lt;/code&gt; is the output of the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The &lt;a href=&quot;https://en.wikipedia.org/wiki/Moving_average&quot;&gt;moving average&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt; fits this form as well,
with the unique feature that all the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;
coefficients, &lt;code class=&quot;highlighter-rouge&quot;&gt;h[k]&lt;/code&gt; are all ones.  This means that the multiplies are all
by one, and so they they can be removed from the
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/boxcar.v&quot;&gt;implementation&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Hence, you might draw this simplified
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;
as shown in Fig 2, without the multiplies.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 2: A Conceptual Moving Average Implementation structure&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/fir-mvavg-form.svg&quot; alt=&quot;A conceptual moving average filter implementation structure&quot; width=&quot;380&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Formally, we might write this as,&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/eqn-mvavg-raw.png&quot; alt=&quot;Moving Average filter&quot; width=&quot;216&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;With this simplification, the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;
has turned into nothing more than a
summation of a set of input values made on every clock tick.&lt;/p&gt;

&lt;p&gt;Even in this form, we’re not ready to implement this
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt; yet.
Instead, consider what would happen if we subtracted two of these &lt;code class=&quot;highlighter-rouge&quot;&gt;y[n]&lt;/code&gt;
values from each other.  You can see this conceptually in Fig 3.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 3: Subtracting one output from another&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/fir-mvavg-subtract.svg&quot; alt=&quot;Moving averages--subtracting the previous output from the current one&quot; width=&quot;480&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Did you catch that?  The difference between two adjacent outputs of our
filter, &lt;code class=&quot;highlighter-rouge&quot;&gt;y[n]-y[n-1]&lt;/code&gt; is given by the difference between two input samples,
&lt;code class=&quot;highlighter-rouge&quot;&gt;x[n]-x[n-N]&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Mathematically, we could write this as,&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/eqn-mvavg.png&quot; alt=&quot;Moving Average filter simplified&quot; width=&quot;356&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;This subtle change in formula, from the generic formula for a convolution to
the one above, will spare us a lot of logic–allowing us to use a running
accumulator and a block RAM instead of hardware multiplies and a lot of
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flip-flop_(electronics)&quot;&gt;flip-flops&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Further, despite this formula referencing &lt;code class=&quot;highlighter-rouge&quot;&gt;y[n-1]&lt;/code&gt;, it is &lt;em&gt;not&lt;/em&gt; an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Infinite_impulse_response&quot;&gt;IIR filter&lt;/a&gt;.
Careful design will keep it from becoming one.&lt;/p&gt;

&lt;p&gt;Let’s look at how we might
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/boxcar.v&quot;&gt;implement&lt;/a&gt;
this &lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;the-basic-equations&quot;&gt;The Basic Equations&lt;/h2&gt;

&lt;p&gt;A very quick, though incomplete, draft of this algorithm might look like:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
if (i_ce)
begin
	// Write the incoming sample to memory
	mem[wraddr] &amp;lt;= i_sample;
	wraddr &amp;lt;= wraddr + 1&#39;b1;

	// Read the x[n-N] value from memory
	memval &amp;lt;= mem[rdaddr];
	rdaddr &amp;lt;= rdaddr + 1&#39;b1;

	// Subtract x[n-N] from the incoming sample, x[n]
	// sub = x[n] - x[n-N]
	sub &amp;lt;= (i_sample - memval);

	// Add the result to the last output
	// y[n] = y[n-1] + sub = y[n-1]+x[n]-x[n-N]
	acc &amp;lt;= acc + sub;

	// rounded() is shorthand for what we wish to do
	// but not really valid Verilog
	o_result &amp;lt;= rounded(acc);
end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Walking through this implementation, our first step was to write this
new sample to memory, and update our write pointer.  At the same time, we
read the value out from &lt;code class=&quot;highlighter-rouge&quot;&gt;N&lt;/code&gt; samples ago, and updated our read pointer.&lt;/p&gt;

&lt;p&gt;We then subtracted the value we read from memory, &lt;code class=&quot;highlighter-rouge&quot;&gt;memval&lt;/code&gt; also known as
&lt;code class=&quot;highlighter-rouge&quot;&gt;x[n-N]&lt;/code&gt;, from the new value, &lt;code class=&quot;highlighter-rouge&quot;&gt;i_sample&lt;/code&gt; or &lt;code class=&quot;highlighter-rouge&quot;&gt;x[n]&lt;/code&gt;, we just received.  The
result of that subtraction was then added into our accumulator, &lt;code class=&quot;highlighter-rouge&quot;&gt;y[n]&lt;/code&gt;, just
like we discussed in the last section.  The final step was to
&lt;a href=&quot;/dsp/2017/07/22/rounding.html&quot;&gt;round&lt;/a&gt;
the output to the desired number of bits and we were done.&lt;/p&gt;

&lt;p&gt;You’ll find by the end of this article that our finished
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/boxcar.v&quot;&gt;algorithm&lt;/a&gt;,
is not going to be all that much more complex than the algorithm above,
although you may also find that it doesn’t look much like the algorithm above.&lt;/p&gt;

&lt;h2 id=&quot;reset&quot;&gt;Reset&lt;/h2&gt;

&lt;p&gt;The first problem with our first attempt is making certain that the
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/boxcar.v&quot;&gt;the filter&lt;/a&gt;
has a proper initial value.  One mistake in the accumulator, one mistake
that gets &lt;code class=&quot;highlighter-rouge&quot;&gt;y[n]&lt;/code&gt; wrong, and
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/boxcar.v&quot;&gt;this filter&lt;/a&gt;
might be turned into an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Infinite_impulse_response&quot;&gt;IIR filter&lt;/a&gt; with
an unwanted DC offset.  To keep that from happening, let’s create a reset
capability so that we can guarantee the filter starts in a known configuration.&lt;/p&gt;

&lt;p&gt;Specifically, at the time of reset, the accumulator must be set to zero,
as with any intermediate calculation values, such as &lt;code class=&quot;highlighter-rouge&quot;&gt;sub&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;memval&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The other thing we’ll need to pay attention to is the memory.  One difficulty
when using block RAM, as with all memories I know of, is that there’s no
circuitry for initializing all of our memory at once.  Instead, we’ll
“pretend” the memory is zero for a number of clocks following a reset, and
then we’ll use the memory as normal.&lt;/p&gt;

&lt;p&gt;Hence, we’ll need to modify our code such as,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
if (i_reset)
begin
	acc &amp;lt;= 0;
	full &amp;lt;= 1&#39;b0;
	sub  &amp;lt;= 0;
	wraddr &amp;lt;= 0;
	rdaddr &amp;lt;= -navg;
end else if (i_ce)
begin
	wraddr &amp;lt;= wraddr + 1&#39;b1;
	rdaddr &amp;lt;= rdaddr + 1&#39;b1;
	//
	full &amp;lt;= (full)||(rdaddr == 0);
	if (full)
		// Value read from memory is valid
		sub &amp;lt;= i_sample - memval;
	else
		// Value read from memory was never initialized
		// We&#39;ll assume here that it is zero
		sub &amp;lt;= i_sample;

	acc &amp;lt;= acc + sub.
end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This creates a new value, &lt;code class=&quot;highlighter-rouge&quot;&gt;full&lt;/code&gt;, which we can use to determine whether the
memory value is valid or not.&lt;/p&gt;

&lt;p&gt;These are the big broad-brush differences between the quick draft above,
and what we’re about to present below.  Our next step, then, will be to build
our final algorithm.&lt;/p&gt;

&lt;h2 id=&quot;the-actual-algorithm&quot;&gt;The Actual Algorithm&lt;/h2&gt;

&lt;p&gt;Let’s now use the lessons from above to build our &lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/boxcar.v&quot;&gt;verilog
algorithm&lt;/a&gt;.
Feel free to examine the &lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/boxcar.v&quot;&gt;final code
here&lt;/a&gt;,
as you follow along below.&lt;/p&gt;

&lt;p&gt;As a step number one, we’ll make &lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/boxcar.v&quot;&gt;this
filter&lt;/a&gt;
as generic as we can.  To do that, we’ll parameterize our input width,
&lt;code class=&quot;highlighter-rouge&quot;&gt;IW&lt;/code&gt;, and output width, &lt;code class=&quot;highlighter-rouge&quot;&gt;OW&lt;/code&gt;.  Further, we’ll parameterize the number of
averages allowable, which we shall controll by the log (based two) of the
maximum number of averages, &lt;code class=&quot;highlighter-rouge&quot;&gt;LGMEM&lt;/code&gt;.  This will allow us to average by
any amount between &lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;(1&amp;lt;&amp;lt;LGMEM)-1&lt;/code&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;parameter	IW=16,		// Input bit-width
		LGMEM=6,	// Size of the memory
		OW=(IW+LGMEM);	// Output bit-width&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Hence, if you want to average fifty-five 16-bit values together, you’d set &lt;code class=&quot;highlighter-rouge&quot;&gt;IW&lt;/code&gt;
to 16 and &lt;code class=&quot;highlighter-rouge&quot;&gt;LGMEM&lt;/code&gt; to 6.  If you want an output without any
&lt;a href=&quot;/dsp/2017/07/22/rounding.html&quot;&gt;rounding&lt;/a&gt;,
then the output width, &lt;code class=&quot;highlighter-rouge&quot;&gt;OW&lt;/code&gt;,
&lt;a href=&quot;/dsp/2017/07/21/bit-growth.html&quot;&gt;needs to be set to&lt;/a&gt;
the input width plus the log of the number of averages.  In the example of
averaging fifty-five 16-bit items together, this means we’d need an output
width of &lt;code class=&quot;highlighter-rouge&quot;&gt;16+6&lt;/code&gt;, or &lt;code class=&quot;highlighter-rouge&quot;&gt;OW=22&lt;/code&gt;.  Any fewer output bits than that will require
&lt;a href=&quot;/dsp/2017/07/22/rounding.html&quot;&gt;rounding&lt;/a&gt;
the internal result to the desired number of output bits.&lt;/p&gt;

&lt;p&gt;We’ll also allow the number of averages to be configurable as well–or not,
if the &lt;code class=&quot;highlighter-rouge&quot;&gt;FIXED_NAVG&lt;/code&gt; parameter is set.  If &lt;code class=&quot;highlighter-rouge&quot;&gt;FIXED_NAVG&lt;/code&gt; is set, then the number
of averages will be fixed, and set by an &lt;code class=&quot;highlighter-rouge&quot;&gt;INITIAL_AVG&lt;/code&gt; parameter.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;parameter [0:0]	FIXD_NAVG=1&#39;b0;	// True if number of averages is fixed

// Always assume we&#39;ll be averaging by the maximum amount, unless told
// otherwise.  Minus one, in two&#39;s complement, will become this number
// when interpreted as an unsigned number.
parameter [(LGMEM-1):0]	INITIAL_AVG = -1;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;If &lt;code class=&quot;highlighter-rouge&quot;&gt;FIXED_NAVG&lt;/code&gt; is not set, we’ll allow the user to set the number of averages
they want.  However, because of the dependence of the feedback relationship,
&lt;code class=&quot;highlighter-rouge&quot;&gt;y[n]&lt;/code&gt; on &lt;code class=&quot;highlighter-rouge&quot;&gt;y[n-1]&lt;/code&gt;, we’ll insist that the number of averages must not change
except on an &lt;code class=&quot;highlighter-rouge&quot;&gt;i_reset&lt;/code&gt; signal.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;wire	[(LGMEM-1):0]	w_requested_navg;
assign w_requested_navg = (FIXED_NAVG) ? INITIAL_NAVG : i_navg;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;As we’ll see later, the only part of our algorithm that depends upon this
number of averages is the initial/reset value of the memory read address.
For this reason, we won’t store the value in a register.  We’ll come back to
this later when we discuss the read address.&lt;/p&gt;

&lt;p&gt;That brings us to the logic required for accessing memory–both writing and
then reading.  Of these two, the write address is simple: we’ll start writing
to the first address of memory (address zero) on our first data
sample, and then rotate through memory locations from there.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;initial	wraddr = 0;
always @(posedge i_clk)
	if (i_reset)
		wraddr &amp;lt;= 0;
	else if (i_ce)
		wraddr &amp;lt;= wraddr + 1&#39;b1;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;What that means, though, is that we have to implement the time difference
between the initial value and the value &lt;code class=&quot;highlighter-rouge&quot;&gt;N&lt;/code&gt; samples ago using the &lt;em&gt;read&lt;/em&gt;
memory address.  We’ll do so by initializing the read address to the negative
number of averages.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;initial	rdaddr = 0;
always @(posedge i_clk)
	if (i_reset)
		rdaddr &amp;lt;= -w_requested_navg;
	else if (i_ce)
		rdaddr &amp;lt;= rdaddr + 1&#39;b1;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;As with the write address, we increment the read address on every sample clock.&lt;/p&gt;

&lt;p&gt;Following the address calculation, we’ll write out incoming sample to memory,
and read our delayed sample from memory as well.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	if (i_ce)
		mem[wraddr] &amp;lt;= i_sample;

// ...

initial	memval = 0;
always @(posedge i_clk)
	if (i_ce)
		memval &amp;lt;= mem[rdaddr];&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;So far, this is all straightforward.  Other than initial values, we haven’t
really deviated from our initial draft above.  However, things get a little
trickier when adding the input sample to this logic.  In particular, if we
want our input value to be aligned with the output of the memory read, &lt;code class=&quot;highlighter-rouge&quot;&gt;memval&lt;/code&gt;,
associated with &lt;code class=&quot;highlighter-rouge&quot;&gt;x[n-N]&lt;/code&gt;, then we’ll need to delay the input by one sample.&lt;/p&gt;

&lt;p&gt;It’s not really that obvious why this would be so.  Why does the input need to
be delayed by a sample?  The answer has to do with pipeline scheduling.
So, let’s look at how the internal values within our algorithm get set on
subsequent clocks, as shown in Fig 4.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 4: Scheduling the moving average pipeline&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/mvavg-pipeline.svg&quot; alt=&quot;Table, showing when the various values are getting assigned&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;This figure shows a list of all of our internal registers, binned within the
clocks they are set within–starting on the clock before a particular sample,
&lt;code class=&quot;highlighter-rouge&quot;&gt;i_sample[t]&lt;/code&gt;, is provided, &lt;code class=&quot;highlighter-rouge&quot;&gt;t-1&lt;/code&gt; until four clocks later at &lt;code class=&quot;highlighter-rouge&quot;&gt;t+4&lt;/code&gt;.  Hence, since &lt;code class=&quot;highlighter-rouge&quot;&gt;memval&lt;/code&gt; depends upon &lt;code class=&quot;highlighter-rouge&quot;&gt;rdaddr&lt;/code&gt;, it
shows in the clock following the one when &lt;code class=&quot;highlighter-rouge&quot;&gt;rdaddr&lt;/code&gt; gets set.  Likewise, since
the memory is set following the write address being set, &lt;code class=&quot;highlighter-rouge&quot;&gt;mem[wraddr]&lt;/code&gt; gets
set following &lt;code class=&quot;highlighter-rouge&quot;&gt;wraddr&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;While our presentation through &lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/boxcar.v&quot;&gt;the
code&lt;/a&gt; below
is going to be in chronological order, from time &lt;code class=&quot;highlighter-rouge&quot;&gt;t&lt;/code&gt; through &lt;code class=&quot;highlighter-rouge&quot;&gt;t+4&lt;/code&gt;, the chart
above was built/scheduled backwards.  &lt;code class=&quot;highlighter-rouge&quot;&gt;o_result&lt;/code&gt; is the
&lt;a href=&quot;/dsp/2017/07/22/rounding.html&quot;&gt;rounded&lt;/a&gt;
version of &lt;code class=&quot;highlighter-rouge&quot;&gt;acc&lt;/code&gt;.  It took
one clock to calculate.  &lt;code class=&quot;highlighter-rouge&quot;&gt;acc&lt;/code&gt; is the sum of the last accumulator and the
result of the subtraction, &lt;code class=&quot;highlighter-rouge&quot;&gt;sub&lt;/code&gt;.  Further, we know that we want to subtract
our new input value from the last memory value, &lt;code class=&quot;highlighter-rouge&quot;&gt;memval&lt;/code&gt;, etc.&lt;/p&gt;

&lt;p&gt;So why do we have the register &lt;code class=&quot;highlighter-rouge&quot;&gt;preval&lt;/code&gt; in this pipeline chart?  It doesn’t
seem to do anything, so why is it there?&lt;/p&gt;

&lt;p&gt;The answer is simple: we needed to delay the input by one clock in order to get
it to line up with the memory that was just written and then read.&lt;/p&gt;

&lt;p&gt;For example, let’s suppose we only wished to average one
element–a pass-through filter.  Hence, we’d want to add
our new value, &lt;code class=&quot;highlighter-rouge&quot;&gt;x[n]&lt;/code&gt;, and subtract the prior value, &lt;code class=&quot;highlighter-rouge&quot;&gt;x[n-1]&lt;/code&gt;, delayed by only
one clock.  Given that’s what we want to do, let’s follow that new value through
this pipeline schedule in Fig 5 below.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 5: Tracing the last sample through the moving average pipeline&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/mvavg-pipeline-trace.svg&quot; alt=&quot;Table, showing when the various values are getting assigned&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;i_sample[t-1]&lt;/code&gt; shows up at time &lt;code class=&quot;highlighter-rouge&quot;&gt;t-1&lt;/code&gt;, and gets written into memory,
&lt;code class=&quot;highlighter-rouge&quot;&gt;mem[wraddr]&lt;/code&gt;, at time
&lt;code class=&quot;highlighter-rouge&quot;&gt;t&lt;/code&gt;.  It can then be read at time &lt;code class=&quot;highlighter-rouge&quot;&gt;t+1&lt;/code&gt; into &lt;code class=&quot;highlighter-rouge&quot;&gt;memval&lt;/code&gt;, and then subtracted
from the new value at &lt;code class=&quot;highlighter-rouge&quot;&gt;t+2&lt;/code&gt; to create &lt;code class=&quot;highlighter-rouge&quot;&gt;sub&lt;/code&gt;.  This time, &lt;code class=&quot;highlighter-rouge&quot;&gt;t+2&lt;/code&gt;, is the earliest
the last value can be read back from memory.  This is also the time when we
need our new value, &lt;code class=&quot;highlighter-rouge&quot;&gt;x[n]&lt;/code&gt;–one clock after it shows up.  To get the new sample
value from when it is given to us into this clock period, we need to delay it
by a single cycle, placing it into &lt;code class=&quot;highlighter-rouge&quot;&gt;preval&lt;/code&gt; for that purpose.&lt;/p&gt;

&lt;p&gt;The logic necessary to do this is trivial–unlike the reasoning behind it above.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;initial	preval = 0;
always @(posedge i_clk)
	if (i_reset)
		preval &amp;lt;= 0;
	else if (i_ce)
		preval &amp;lt;= i_sample;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The other thing we’re going to need to know, at the same time we want to
know the value we just read from memory, is whether we’ve written enough
times to the memory for the values read out of the memory to be valid.  I’ve
chosen to call this &lt;code class=&quot;highlighter-rouge&quot;&gt;full&lt;/code&gt;, to indicate that the tapped-delay line memory has
been filled.&lt;/p&gt;

&lt;p&gt;Since we initialized the write address at zero, and then wrote to the zero
address in our first clock, we know that the value read from memory will
be valid as soon as we read from the zero address.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;initial	full   = 1&#39;b0;
always @(posedge i_clk)
	if (i_reset)
		full &amp;lt;= 0;
	else if (i_ce)
		full &amp;lt;= (full)||(rdaddr==0);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;We’ve now set all of the values shown in the time &lt;code class=&quot;highlighter-rouge&quot;&gt;t+1&lt;/code&gt; column from Figs 4 and 5
above, so we’ll move on to the next clock.  In this clock, we’ll subtract
the sample falling off the end of our average list from our new sample.  We’ll
place this result into &lt;code class=&quot;highlighter-rouge&quot;&gt;sub&lt;/code&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;initial	sub = 0;
always @(posedge i_clk)
if (i_reset)
	sub &amp;lt;= 0;
else if (i_ce)
begin
	if (full)
		sub &amp;lt;= { preval[(IW-1)], preval }
				- { memval[(IW-1)], memval };
	else
		sub &amp;lt;= { preval[(IW-1)], preval };
end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The rest is simple.  We add this difference to our accumulated value, creating
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/boxcar.v&quot;&gt;our filter&lt;/a&gt;’s
output value, &lt;code class=&quot;highlighter-rouge&quot;&gt;y[n]&lt;/code&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;initial	acc = 0;
always @(posedge i_clk)
	if (i_reset)
		acc &amp;lt;= 0;
	else if (i_ce)
		acc &amp;lt;= acc + { {(LGMEM-1){sub[IW]}}, sub };&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The final stage of our pipeline
&lt;a href=&quot;/dsp/2017/07/22/rounding.html&quot;&gt;rounds&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/boxcar.v&quot;&gt;our filter&lt;/a&gt;’s
outputs to the number of bits requested by the parameter, &lt;code class=&quot;highlighter-rouge&quot;&gt;OW&lt;/code&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;generate
if (IW+LGMEM == OW)
	// No rounding required, output is the acc
	assign	rounded = acc;
else if (IW+LGMEM == OW + 1)
	// Need to drop one bit, round towards even
	assign	rounded = acc + { {(OW){1&#39;b0}}, acc[1] };
else // if (IW+LGMEM &amp;gt; OW + 1)
	// Drop more than one bit, rounding towards even
	assign	rounded = acc + {
			{(OW){1&#39;b0}}, acc[(IW+LGMEM-OW)],
			{(IW+LGMEM-OW-1){!acc[(IW+LGMEM-OW)]}} };
endgenerate&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Once we are done
&lt;a href=&quot;/dsp/2017/07/22/rounding.html&quot;&gt;rounding&lt;/a&gt;
the output value, we’ll take an extra clock stage
to deal with any delay associated with
&lt;a href=&quot;/dsp/2017/07/22/rounding.html&quot;&gt;rounding&lt;/a&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	if (i_reset)
		o_result &amp;lt;= 0;
	else if (i_ce)
		o_result &amp;lt;= rounded[(IW+LGMEM-1):(IW+LGMEM-OW)];&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;While we might’ve skipped this delay if we didn’t need to drop any bits,
doing so would cause our filter to have a different delay depending on how
it was configured.  Rather than deal with that maintenance headache, the
result is always delayed
(&lt;a href=&quot;/dsp/2017/07/22/rounding.html&quot;&gt;rounded&lt;/a&gt;
or not) by one clock here.&lt;/p&gt;

&lt;h2 id=&quot;performance&quot;&gt;Performance&lt;/h2&gt;

&lt;p&gt;The &lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency_response&quot;&gt;frequency response&lt;/a&gt;
of a &lt;a href=&quot;https://en.wikipedia.org/wiki/Moving_average&quot;&gt;moving average&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;
is well known.  It’s easy enough to calculate that it makes a good assignment
for the beginning student.  It’s given by,&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/eqn-mvavg-H.png&quot; alt=&quot;H = sin(pi fN)/sin(pi f)&quot; width=&quot;308&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;If you examine this
&lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency_response&quot;&gt;response&lt;/a&gt;,
it’s really not that great.  At best, you can get a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Stopband&quot;&gt;stopband&lt;/a&gt;
of -13 dB from
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/boxcar.v&quot;&gt;this filter&lt;/a&gt;.
That’s better than the -6dB
&lt;a href=&quot;https://en.wikipedia.org/wiki/Stopband&quot;&gt;stopband&lt;/a&gt; from our
&lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency_modulation&quot;&gt;FM&lt;/a&gt;
example above, but still a far cry from the -70dB we might like.&lt;/p&gt;

&lt;p&gt;On the other hand, if you cascade &lt;code class=&quot;highlighter-rouge&quot;&gt;M&lt;/code&gt;  filters
of this type together, you can get a much deeper
&lt;a href=&quot;https://en.wikipedia.org/wiki/Stopband&quot;&gt;stopband&lt;/a&gt;.
To illustrate this,
Fig 6 below shows, in blue, the response of a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Moving_average&quot;&gt;moving average&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;
that averages five adjacent values together.  The other lines on the chart show
what happens after cascading
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/boxcar.v&quot;&gt;this filter&lt;/a&gt;
with itself two, three, four, five, or six times.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 6: Moving average frequency response&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/mvavg-response.png&quot; alt=&quot;Image showing this filters response function&quot; width=&quot;714&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;The &lt;a href=&quot;https://www.gnu.org/software/octave&quot;&gt;Octave&lt;/a&gt; code used to create this
figure can be found
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/bench/cpp/boxcar.m&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;There are two important things to notice from this figure.  First, the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Stopband&quot;&gt;stopband&lt;/a&gt;
of the filter, when cascaded, can get &lt;em&gt;very&lt;/em&gt; deep.  After cascading six of
these together, the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Stopband&quot;&gt;stopband&lt;/a&gt;
is &lt;code class=&quot;highlighter-rouge&quot;&gt;-78&lt;/code&gt; dB–pretty impressive.  The second thing to notice is that the
“&lt;a href=&quot;https://en.wikipedia.org/wiki/Passband&quot;&gt;passband&lt;/a&gt;”
is no longer flat.  As a result, we’ll need to follow
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/boxcar.v&quot;&gt;this filter&lt;/a&gt;
with another one to clean up any distortion of our signal of interest.&lt;/p&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;While a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Moving_average&quot;&gt;moving average&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;
is a far cry from a well-designed
&lt;a href=&quot;https://en.wikipedia.org/wiki/Low-pass_filter&quot;&gt;low-pass filter&lt;/a&gt;, it’s also a
very simple &lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;
to implement.  From an engineering trade-off standpoint, this simplicity
makes it a very attractive component for dealing with many
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_signal_processing&quot;&gt;DSP&lt;/a&gt;
requirements on an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;We’re not done with our lessons on
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;digital filtering&lt;/a&gt;,
though.  I’ve still got plans to discuss
&lt;a href=&quot;https://en.wikipedia.org/wiki/Linear_phase&quot;&gt;symmetric filters&lt;/a&gt;,
&lt;a href=&quot;https://en.wikipedia.org/wiki/Half-band_filter&quot;&gt;half-band filters&lt;/a&gt;,
&lt;a href=&quot;https://en.wikipedia.org/wiki/Hilbert_transform&quot;&gt;Hilbert transforms&lt;/a&gt;,
and more.  Further, I’d like to discuss not only their high speed
implementations, but also some slower implementations that would be appropriate
for those designs where there are many clocks between input samples.&lt;/p&gt;

&lt;p&gt;Even at that, we’re not done, since &lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/boxcar.v&quot;&gt;the filter
above&lt;/a&gt;,
when cascaded with itself any number of times and &lt;em&gt;followed by a downsampler&lt;/em&gt;,
can be built without needing a block RAM.&lt;/p&gt;

&lt;p&gt;We are also going to want to discuss how to go about proving that these
filters work.  What sort of test bench is appropriate for testing
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;digital filters&lt;/a&gt;?&lt;/p&gt;

&lt;p&gt;These, however, are lessons still to come.&lt;/p&gt;

&lt;hr /&gt;&lt;p&gt;&lt;em&gt;Lo, this only have I found, that God hath made man upright; but they have sought out many inventions. (Eccl 7:29)&lt;/em&gt;</description>
        <pubDate>Mon, 16 Oct 2017 00:00:00 -0400</pubDate>
        <link>http://zipcpu.com/dsp/2017/10/16/boxcar.html</link>
        <guid isPermaLink="true">http://zipcpu.com/dsp/2017/10/16/boxcar.html</guid>
        
        
        <category>dsp</category>
        
      </item>
    
      <item>
        <title>FPGAs vs ASICs</title>
        <description>&lt;p&gt;I’ve now been developing on &lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;Field Programmable Gate Arrays
(FPGA)&lt;/a&gt;’s
for about seven or eight years.  I have heard of &lt;a href=&quot;https://en.wikipedia.org/wiki/Application-specific_integrated_circuit&quot;&gt;Application-specific
integrated circuit
(ASIC)&lt;/a&gt;
development, but I’ve never done any work with
&lt;a href=&quot;https://en.wikipedia.org/wiki/Application-specific_integrated_circuit&quot;&gt;ASIC&lt;/a&gt;’s.&lt;/p&gt;

&lt;p&gt;So I thought I’d ask some folks about them: is
&lt;a href=&quot;https://en.wikipedia.org/wiki/Application-specific_integrated_circuit&quot;&gt;ASIC&lt;/a&gt;
development the same as
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt; development?
Is it just a matter of using a different set of tools?  Indeed, how
hard would it be to present my own designs as
&lt;a href=&quot;https://en.wikipedia.org/wiki/Application-specific_integrated_circuit&quot;&gt;ASIC&lt;/a&gt;
capable designs?&lt;/p&gt;

&lt;p&gt;As I started to ask around, I got quite the earful in return.  At the risk of
pontificating about what I know nothing about, I’ll try to share some of what
I learned here.  Feel free to write me and correct any misconceptions
I might have.&lt;/p&gt;

&lt;h2 id=&quot;differences-betweeen-fpga-and-asic-development&quot;&gt;Differences betweeen FPGA and ASIC development&lt;/h2&gt;

&lt;p&gt;The first thing I learned was that
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
developers have a much easier task. Unlike
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;’s,
an &lt;a href=&quot;https://en.wikipedia.org/wiki/Application-specific_integrated_circuit&quot;&gt;ASIC&lt;/a&gt;
design starts from a completely blank tableau.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 1: FPGA designers start further along in the design process&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/fpga-v-asic.svg&quot; alt=&quot;FPGA vs ASIC internals&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Whereas on an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
you start out with a large array of
&lt;a href=&quot;https://en.wikipedia.org/wiki/Logic_block&quot;&gt;logic block&lt;/a&gt;s,
clock buffers,
&lt;a href=&quot;https://en.wikipedia.org/wiki/Phase-locked_loop&quot;&gt;PLL&lt;/a&gt;’s,
on-chip
&lt;a href=&quot;https://en.wikipedia.org/wiki/Random-access_memory&quot;&gt;RAM&lt;/a&gt;’s, I/O buffers,
(de)serializers, power distribution networks and more,
&lt;a href=&quot;https://en.wikipedia.org/wiki/Application-specific_integrated_circuit&quot;&gt;ASIC&lt;/a&gt;
development
starts further down into the weeds.  This means  that these components must
either be purchased, come from the manufacture as part of a library, or they
must be individually developed for use within any
&lt;a href=&quot;https://en.wikipedia.org/wiki/Application-specific_integrated_circuit&quot;&gt;ASIC&lt;/a&gt;
design.&lt;/p&gt;

&lt;p&gt;The next big difference is the design cycle.  Simple
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
designs may be built within an afternoon, or even a couple of weeks for a
moderately more complex design.  Indeed, such designs fit nicely into the
academic calendar and make great school engineering projects.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 2: (Simplified) FPGA Design Cycle&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/fpga-design-flow.svg&quot; alt=&quot;Simplified FPGA design cycle&quot; width=&quot;380&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;This is not true of &lt;a href=&quot;https://en.wikipedia.org/wiki/Application-specific_integrated_circuit&quot;&gt;ASIC&lt;/a&gt;
design.&lt;/p&gt;

&lt;table style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 3: ASIC Design Cycle&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/asic-design-flow.svg&quot; alt=&quot;Simplified ASIC design cycle&quot; width=&quot;380&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Specifically, the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Application-specific_integrated_circuit&quot;&gt;ASIC&lt;/a&gt;
manufacturing cycle alone can take many weeks
(months) before you get your chip back, at which point you then need to
integrate it onto a circuit board and test it.  Iterative development of
&lt;a href=&quot;https://en.wikipedia.org/wiki/Application-specific_integrated_circuit&quot;&gt;ASIC&lt;/a&gt;’s
takes months longer (and $M more) per iteration than the minutes it can take
with an &lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;That’s the drawbacks.  What about the benefits?
&lt;a href=&quot;https://en.wikipedia.org/wiki/Application-specific_integrated_circuit&quot;&gt;ASIC&lt;/a&gt;
technology offers higher speeds and lower power solutions beyond what an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
can provide.  Speed differences between the two design methods can easily be
10x or more.  Further, an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
design may be reverse engineered from its bitstream, whereas reverse
engineering an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Application-specific_integrated_circuit&quot;&gt;ASIC&lt;/a&gt;
is much harder.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 4: FPGA vs ASIC benefits&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/fpga-v-asic-list.svg&quot; alt=&quot;FPGA vs ASIC Benefits Table&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;Wow!  Does this mean I could run my
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
with a 1GHz clock, just by switching from an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
based design to an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Application-specific_integrated_circuit&quot;&gt;ASIC&lt;/a&gt;
design?  I like it!&lt;/p&gt;

&lt;p&gt;So, just how bad are those drawbacks?&lt;/p&gt;

&lt;p&gt;Well, the first big drawback is the cost.
&lt;a href=&quot;https://en.wikipedia.org/wiki/Application-specific_integrated_circuit&quot;&gt;ASIC&lt;/a&gt;
design is expensive.  Just paying for a single run of a single
&lt;a href=&quot;https://en.wikipedia.org/wiki/Application-specific_integrated_circuit&quot;&gt;ASIC&lt;/a&gt;
design can cost many millions of dollars.  For a large number of chips, this
price can be cheaper than the cost of purchasing a large number of similarly
capable
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;’s.
For single one-off designs, the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
is typically much cheaper.&lt;/p&gt;

&lt;p&gt;There are also several other differences from the standpoint of the designer.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Standard Cell’s&lt;/p&gt;

    &lt;p&gt;Originally,
&lt;a href=&quot;https://en.wikipedia.org/wiki/Application-specific_integrated_circuit&quot;&gt;ASIC&lt;/a&gt;
design involved drawing and placing &lt;a href=&quot;https://en.wikipedia.org/wiki/Bipolar_junction_transistor&quot;&gt;bipolar
transistors&lt;/a&gt; and
&lt;a href=&quot;https://en.wikipedia.org/wiki/MOSFET&quot;&gt;N-FET&lt;/a&gt;’s into
a design.  Since every manufacturer’s process was different, these designs
also needed to change from one manufacturer to another.  Tools were
available to help, but these tools were incompatible from one manufacturer
to another.  As a result, designs that worked with one manufacturer’s
process could not easily be transferred to another manufacturer’s process.&lt;/p&gt;

    &lt;p&gt;This changed with the invention of &lt;a href=&quot;https://en.wikipedia.org/wiki/Application-specific_integrated_circuit&quot;&gt;Standard Cell&lt;/a&gt;’s.
&lt;a href=&quot;https://en.wikipedia.org/wiki/Application-specific_integrated_circuit&quot;&gt;Standard Cell&lt;/a&gt;’s are similar to the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Logic_block&quot;&gt;logic blocks&lt;/a&gt;
within
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;’s
that form the basic logic unit for all of the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;’s
logic.  In the same manner that arbitrary
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
logic can be created from
&lt;a href=&quot;https://en.wikipedia.org/wiki/Logic_block&quot;&gt;lookup tables (LUT)&lt;/a&gt;
within the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;,
arbitrary logic can be created using
&lt;a href=&quot;https://en.wikipedia.org/wiki/Application-specific_integrated_circuit&quot;&gt;standard cell&lt;/a&gt;’s within
&lt;a href=&quot;https://en.wikipedia.org/wiki/Application-specific_integrated_circuit&quot;&gt;ASIC&lt;/a&gt;’s.
The biggest difference, though, is that
&lt;a href=&quot;https://en.wikipedia.org/wiki/Application-specific_integrated_circuit&quot;&gt;standard cell&lt;/a&gt;’s
tend to be at a much lower logic level than
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Logic_block&quot;&gt;logic blocks&lt;/a&gt;.&lt;/p&gt;

    &lt;p&gt;As an example, the
&lt;a href=&quot;http://opencircuitdesign.com/qflow&quot;&gt;QFlow&lt;/a&gt;
open-source
&lt;a href=&quot;https://en.wikipedia.org/wiki/Application-specific_integrated_circuit&quot;&gt;ASIC&lt;/a&gt;
development tool set uses a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Application-specific_integrated_circuit&quot;&gt;standard cell&lt;/a&gt;
library provided by
&lt;a href=&quot;https://vlsiarch.ecen.okstate.edu/flows/&quot;&gt;vlsirch.ecen.okstate.edu&lt;/a&gt;.
Their &lt;a href=&quot;https://vlsiarch.ecen.okstate.edu/flows/stdcell_datasheet/tsmc025/&quot;&gt;tsmc025&lt;/a&gt;
library consists of
&lt;a href=&quot;https://vlsiarch.ecen.okstate.edu/flows/stdcell_datasheet/tsmc025/data/AND2X1.html&quot;&gt;AND&lt;/a&gt; gates,
&lt;a href=&quot;https://vlsiarch.ecen.okstate.edu/flows/stdcell_datasheet/tsmc025/data/OR2X1.html&quot;&gt;OR&lt;/a&gt; gates,
&lt;a href=&quot;https://vlsiarch.ecen.okstate.edu/flows/stdcell_datasheet/tsmc025/data/NAND2X1.html&quot;&gt;NAND&lt;/a&gt; gates,
&lt;a href=&quot;https://vlsiarch.ecen.okstate.edu/flows/stdcell_datasheet/tsmc025/data/DFFPOSX1.html&quot;&gt;D-flip flops&lt;/a&gt;,
&lt;a href=&quot;https://vlsiarch.ecen.okstate.edu/flows/stdcell_datasheet/tsmc025/data/MUX2X1.html&quot;&gt;2-1 MUX&lt;/a&gt;’s,
&lt;a href=&quot;https://vlsiarch.ecen.okstate.edu/flows/stdcell_datasheet/tsmc025/data/DFFPOSX1.html&quot;&gt;clock buffers&lt;/a&gt;’s,
and more, but no six or eight input
&lt;a href=&quot;https://en.wikipedia.org/wiki/Logic_block&quot;&gt;LUTs&lt;/a&gt;.&lt;/p&gt;

    &lt;p&gt;Still, the impact of &lt;a href=&quot;https://en.wikipedia.org/wiki/Application-specific_integrated_circuit&quot;&gt;standard cell&lt;/a&gt; technology was huge.
&lt;a href=&quot;https://en.wikipedia.org/wiki/Application-specific_integrated_circuit&quot;&gt;Standard cell&lt;/a&gt;s made it possible for
&lt;a href=&quot;https://en.wikipedia.org/wiki/Hardware_description_language&quot;&gt;Hardware Description Languages (HDL)&lt;/a&gt;, such as
&lt;a href=&quot;https://en.wikipedia.org/wiki/Verilog&quot;&gt;Verilog&lt;/a&gt;
and &lt;a href=&quot;https://en.wikipedia.org/wiki/VHDL&quot;&gt;VHDL&lt;/a&gt;, to start to proliferate
since synthesis tools could turn an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Hardware_description_language&quot;&gt;HDL&lt;/a&gt;
design into design based upon &lt;a href=&quot;https://en.wikipedia.org/wiki/Application-specific_integrated_circuit&quot;&gt;standard
cell&lt;/a&gt;s.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Clocks&lt;/p&gt;

    &lt;p&gt;A second big difference between
&lt;a href=&quot;https://en.wikipedia.org/wiki/Application-specific_integrated_circuit&quot;&gt;ASIC&lt;/a&gt;
and
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
design is the clock.  The difference is two fold.  First,
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;’s
have many resources designed to create and adjust clocks.  Second,
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;’s
have dedicated clock routing networks.  Neither of these come for free on an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Application-specific_integrated_circuit&quot;&gt;ASIC&lt;/a&gt;.
Let’s discuss each of these in detail.&lt;/p&gt;

    &lt;p&gt;First, most
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;’s
have clock management resources within them.  These
resources allow you to change the frequency of a clock, and adjust its
phase.  These clock management resources are vital to creating a variety of
I/O interfaces.&lt;/p&gt;

    &lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Application-specific_integrated_circuit&quot;&gt;ASIC&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Application-specific_integrated_circuit&quot;&gt;standard cell&lt;/a&gt;
libraries often don’t have these components within them.  The reason,
according to &lt;a href=&quot;http://anysilicon.com/asic-pll-design-overview&quot;&gt;AnySilicon&lt;/a&gt;,
is that the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Phase-locked_loop&quot;&gt;PLL&lt;/a&gt; needs of an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Application-specific_integrated_circuit&quot;&gt;ASIC&lt;/a&gt;
designer vary too much from one design to the next.  This makes it
difficult to grab a simple off the shelf
&lt;a href=&quot;https://en.wikipedia.org/wiki/Phase-locked_loop&quot;&gt;PLL&lt;/a&gt;
and place it into your design.  It also means that the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Application-specific_integrated_circuit&quot;&gt;ASIC&lt;/a&gt;
designer needs to pay to procure a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Phase-locked_loop&quot;&gt;PLL&lt;/a&gt;
designed to his problem’s needs.&lt;/p&gt;

    &lt;p&gt;The second problem was that
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;’s
have dedicated clock routing networks, while
&lt;a href=&quot;https://en.wikipedia.org/wiki/Application-specific_integrated_circuit&quot;&gt;ASIC&lt;/a&gt;’s
do not.  This means that an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Application-specific_integrated_circuit&quot;&gt;ASIC&lt;/a&gt;
designer must design the clock routing network for his design together
with the logic routing that
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
developers are familiar with.  Unlike the logic routing networks used by both
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;’s
and
&lt;a href=&quot;https://en.wikipedia.org/wiki/Application-specific_integrated_circuit&quot;&gt;ASIC&lt;/a&gt;’s,
&lt;em&gt;clock&lt;/em&gt; routing networks need to be designed so that the clock arrives at
every &lt;a href=&quot;https://en.wikipedia.org/wiki/Flip-flop_(electronics)&quot;&gt;flip-flop&lt;/a&gt;
at (roughly) the same time–making clock and logic routing more difficult.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Reset&lt;/p&gt;

    &lt;p&gt;I know that &lt;a href=&quot;/blog/2017/08/21/rules-for-newbies.html&quot;&gt;I have told beginners never to use an asynchronous
reset&lt;/a&gt;.
That advice applies to beginners, and specifically to beginning
(&lt;a href=&quot;https://www.xilinx.com&quot;&gt;Xilinx&lt;/a&gt;)
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
designers only.&lt;/p&gt;

    &lt;p&gt;The
&lt;a href=&quot;https://en.wikipedia.org/wiki/Application-specific_integrated_circuit&quot;&gt;ASIC&lt;/a&gt;
designer &lt;em&gt;needs&lt;/em&gt; the reset capability.&lt;/p&gt;

    &lt;p&gt;Unlike
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;s where
initial &lt;a href=&quot;https://en.wikipedia.org/wiki/Flip-flop_(electronics)&quot;&gt;flip-flop&lt;/a&gt;
conditions can be specified, and where the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
circuitry will quietly take care to set all of the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flip-flop_(electronics)&quot;&gt;flip-flop&lt;/a&gt; to the
initial values you specify,
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flip-flop_(electronics)&quot;&gt;flip-flop&lt;/a&gt;s within
&lt;a href=&quot;https://en.wikipedia.org/wiki/Application-specific_integrated_circuit&quot;&gt;ASIC&lt;/a&gt;
designs start with random initial values.  The &lt;code class=&quot;highlighter-rouge&quot;&gt;initial&lt;/code&gt; statement
within &lt;a href=&quot;https://en.wikipedia.org/wiki/Verilog&quot;&gt;Verilog&lt;/a&gt; just doesn’t
get synthesized by the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Application-specific_integrated_circuit&quot;&gt;ASIC&lt;/a&gt;
tools.  This means that the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Application-specific_integrated_circuit&quot;&gt;ASIC&lt;/a&gt;
designer needs to use the reset wire in order to force any hardware
registers/&lt;a href=&quot;https://en.wikipedia.org/wiki/Flip-flop_(electronics)&quot;&gt;flip-flop&lt;/a&gt;s
into known initial conditions.&lt;/p&gt;

    &lt;p&gt;On an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Application-specific_integrated_circuit&quot;&gt;ASIC&lt;/a&gt;,
the reset wire is often an active low wire.  It is also used to keep the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Application-specific_integrated_circuit&quot;&gt;ASIC&lt;/a&gt;’s
logic from triggering, and hence from drawing power, until the power within
the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Application-specific_integrated_circuit&quot;&gt;ASIC&lt;/a&gt;
is steady and reliable.&lt;/p&gt;

    &lt;p&gt;This also brings up a host of timing issues, since the global reset may
be asynchronously asserted, and there is typically an asynchronous
propagation delay across the design.  This affects both asserting the
reset as well as de-asserting the reset.&lt;/p&gt;

    &lt;p&gt;The bottom line, though, is that circuits that didn’t need reset logic
within an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
often require it when implemented within an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Application-specific_integrated_circuit&quot;&gt;ASIC&lt;/a&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;On-chip RAM&lt;/p&gt;

    &lt;p&gt;On-chip block
&lt;a href=&quot;https://en.wikipedia.org/wiki/Random-access_memory&quot;&gt;RAM&lt;/a&gt;
is an important part of any chip design.
Indeed, all of my own &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
designs depend upon block
&lt;a href=&quot;https://en.wikipedia.org/wiki/Random-access_memory&quot;&gt;RAM&lt;/a&gt;.
I used it for fast, &lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/rtl/memdev.v&quot;&gt;local
memory&lt;/a&gt;, for
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/pfcache.v&quot;&gt;cached
memory&lt;/a&gt;
structures,
&lt;a href=&quot;https://en.wikipedia.org/wiki/FIFO_(computing_and_electronics)&quot;&gt;FIFO&lt;/a&gt;’s
and more.  On-chip &lt;a href=&quot;https://en.wikipedia.org/wiki/Random-access_memory&quot;&gt;RAM&lt;/a&gt;
however, doesn’t come for free for the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Application-specific_integrated_circuit&quot;&gt;ASIC&lt;/a&gt;
designer.&lt;/p&gt;

    &lt;p&gt;While it is possible to build a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Random-access_memory&quot;&gt;RAM&lt;/a&gt; out of
&lt;a href=&quot;https://en.wikipedia.org/wiki/Application-specific_integrated_circuit&quot;&gt;standard cell&lt;/a&gt;s,
the resulting performance (area, power, speed, etc) is often
unacceptable.&lt;/p&gt;

    &lt;p&gt;This places the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Application-specific_integrated_circuit&quot;&gt;ASIC&lt;/a&gt;
designer in the position where he needs to purchase (or design his own) the
design for any on-chip
&lt;a href=&quot;https://en.wikipedia.org/wiki/Random-access_memory&quot;&gt;RAM&lt;/a&gt;
he’d like to have.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;I/O peripherals&lt;/p&gt;

    &lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
I/O pins can often handle multiple I/O standards.  These standards, while
possible for the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Application-specific_integrated_circuit&quot;&gt;ASIC&lt;/a&gt;
designer to implement, also come at a cost.&lt;/p&gt;

    &lt;p&gt;How about the input deserializers and output serializers that
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;’s
offer?  These fundamental components of
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;’s
make many I/O communication standards possible.
As with the multiple I/O standard capability, these essential I/O components
don’t come standard to the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Application-specific_integrated_circuit&quot;&gt;ASIC&lt;/a&gt;
designer either.&lt;/p&gt;

    &lt;p&gt;That’s the bad news.  The good news is that, at the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Application-specific_integrated_circuit&quot;&gt;ASIC&lt;/a&gt;
level, you can build I/O designs that are very difficult to create within an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;.
Examples include
&lt;a href=&quot;https://en.wikipedia.org/wiki/HDMI&quot;&gt;HDMI&lt;/a&gt; pre-filters,
&lt;a href=&quot;https://en.wikipedia.org/wiki/DDR_SDRAM&quot;&gt;DDR memory&lt;/a&gt; drivers,
&lt;a href=&quot;https://en.wikipedia.org/wiki/USB&quot;&gt;USB&lt;/a&gt; interface drivers,
and even analog I/O components such as &lt;a href=&quot;https://en.wikipedia.org/wiki/Analog-to-digital_converter&quot;&gt;analog to digital
converters&lt;/a&gt; or
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital-to-analog_converter&quot;&gt;digital to analog
converters&lt;/a&gt;.  As
with the rest of the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Application-specific_integrated_circuit&quot;&gt;ASIC&lt;/a&gt;
design experience, many companies will sell you these components as well.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Power&lt;/p&gt;

    &lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;’s have
wires running through them to deliver a sufficient amount of power to the
entire design.  Should the power be used unevenly, the 
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt; has
been designed to guarantee that every component still gets a sufficient
amount of power to run.&lt;/p&gt;

    &lt;p&gt;Since
&lt;a href=&quot;https://en.wikipedia.org/wiki/Application-specific_integrated_circuit&quot;&gt;ASIC&lt;/a&gt;
development is done at a lower level, the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Application-specific_integrated_circuit&quot;&gt;ASIC&lt;/a&gt;
designer needs to concern himself with power distribution throughout his
design.  In particular, he needs to insure that none of the components of
the design are power starved.  Such
&lt;a href=&quot;https://en.wikipedia.org/wiki/Brownout_(electricity)&quot;&gt;brown-out&lt;/a&gt;’s
will create problems that can be difficult to trouble-shoot later.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Process variations&lt;/p&gt;

    &lt;p&gt;If the above differences weren’t sufficient to highlight that
&lt;a href=&quot;https://en.wikipedia.org/wiki/Application-specific_integrated_circuit&quot;&gt;ASIC&lt;/a&gt;
development has many differences from
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
development, then you should know we’re not done yet.&lt;/p&gt;

    &lt;p&gt;The next difference is “process variations.”
Basically, by process variations, I am referring to the reality that
very small silicon components, on the order of tens of nanometers
or smaller, aren’t necessarily all manufactured to the same exact size.
Some components may be thicker than others just because it is difficult
to manufacture components that small to any exacting standard.&lt;/p&gt;

    &lt;p&gt;What this means for the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Application-specific_integrated_circuit&quot;&gt;ASIC&lt;/a&gt;
developer is that their design needs to be verified for process extremes.
At one extreme, logic might work faster than another extreme.  The
&lt;a href=&quot;https://en.wikipedia.org/wiki/Application-specific_integrated_circuit&quot;&gt;ASIC&lt;/a&gt;
developer, using tools designed for this purpose,
needs to be able to deal with this and properly simulate both extremes,
to validate that the logic will work within the full limits of the
manufacturer’s process.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Tools&lt;/p&gt;

    &lt;p&gt;When I first starting learning
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
design, I learned the synthesis and implementation buttons within
&lt;a href=&quot;http://www.xilinx.com&quot;&gt;Xilinx&lt;/a&gt;’s
&lt;a href=&quot;https://www.xilinx.com/products/design-tools/ise-design-suite.html&quot;&gt;ISE&lt;/a&gt;
program.  Synthesize; implement; generate programming file; load onto
hardware, and that was all I needed to know.  Moving to
&lt;a href=&quot;https://www.xilinx.com/products/design-tools/vivado.html&quot;&gt;Vivado&lt;/a&gt;
was easy: once I found the synthesis, implementation, and bitstream
generation buttons I had all I needed.&lt;/p&gt;

    &lt;p&gt;The tools required for
&lt;a href=&quot;https://en.wikipedia.org/wiki/Application-specific_integrated_circuit&quot;&gt;ASIC&lt;/a&gt;
design, however, are much more extensive.&lt;/p&gt;

    &lt;p&gt;Sure, there’s the basic
&lt;a href=&quot;https://en.wikipedia.org/wiki/Logic_synthesis&quot;&gt;synthesis&lt;/a&gt; tool, but there
are also arithmetic
synthesis and power synthesis tools as well.  These help the designer choose
and trade off multiplier architectures and power structures.&lt;/p&gt;

    &lt;p&gt;There’s also place and route tools and timing analyzers for
&lt;a href=&quot;https://en.wikipedia.org/wiki/Application-specific_integrated_circuit&quot;&gt;ASIC&lt;/a&gt;
just as there are for
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;’s.&lt;/p&gt;

    &lt;p&gt;The &lt;a href=&quot;https://en.wikipedia.org/wiki/Application-specific_integrated_circuit&quot;&gt;ASIC&lt;/a&gt;
designer also has floor planning tools to help him place components, insert
a &lt;a href=&quot;https://en.wikipedia.org/wiki/Clock_signal#Distribution&quot;&gt;clock tree&lt;/a&gt;,
&lt;a href=&quot;https://en.wikipedia.org/wiki/Scan_scan&quot;&gt;scan chains&lt;/a&gt;
and &lt;a href=&quot;http://semimd.com/favre/2015/10/26/lefdef-io-ring-check-automation/&quot;&gt;I/O rings&lt;/a&gt;.&lt;/p&gt;

    &lt;p&gt;Modern
&lt;a href=&quot;https://en.wikipedia.org/wiki/Application-specific_integrated_circuit&quot;&gt;ASIC&lt;/a&gt;
designers also need to be able to estimate
&lt;a href=&quot;https://en.wikipedia.org/wiki/Parasitic_capacitance&quot;&gt;parasitic capacitance&lt;/a&gt;,
sometimes just referred to as
&lt;a href=&quot;https://en.wikipedia.org/wiki/Parasitic_capacitance&quot;&gt;parasitics&lt;/a&gt;.
&lt;a href=&quot;https://en.wikipedia.org/wiki/Parasitic_capacitance&quot;&gt;Parasitics&lt;/a&gt; arise
when conductors of different potentials are placed close to each other.
While this effect can usually be ignored at low frequencies, it can
cause &lt;a href=&quot;https://en.wikipedia.org/wiki/Crosstalk&quot;&gt;crosstalk&lt;/a&gt;
between digital logic lines,
&lt;a href=&quot;https://en.wikipedia.org/wiki/Feedback&quot;&gt;feedback&lt;/a&gt; within analog circuits,
&lt;a href=&quot;https://en.wikipedia.org/wiki/Parasitic_oscillation&quot;&gt;parasitic
oscillations&lt;/a&gt;, and more
at higher frequencies.  To avoid these effects, the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Application-specific_integrated_circuit&quot;&gt;ASIC&lt;/a&gt;
designer uses &lt;a href=&quot;https://en.wikipedia.org/wiki/Parasitic_extraction&quot;&gt;parasitic
extraction&lt;/a&gt; tools
to estimate the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Parasitic_capacitance&quot;&gt;parasitics&lt;/a&gt; within the
design for the purpose of updating his design simulations to see if the
estimated &lt;a href=&quot;https://en.wikipedia.org/wiki/Parasitic_capacitance&quot;&gt;parasitic
capacitance&lt;/a&gt;
will impact design performance.&lt;/p&gt;

    &lt;p&gt;A &lt;a href=&quot;https://en.wikipedia.org/wiki/Formal_equivalence_checking&quot;&gt;logic equivalence
checker&lt;/a&gt;
is another 
&lt;a href=&quot;https://en.wikipedia.org/wiki/Application-specific_integrated_circuit&quot;&gt;ASIC&lt;/a&gt;
tool that may be unfamiliar to an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
designer.
&lt;a href=&quot;https://en.wikipedia.org/wiki/Formal_equivalence_checking&quot;&gt;Logic equivalence
checker&lt;/a&gt;s
are used to formally prove that the circuit designed
to this point matches the initial desired behavior.&lt;/p&gt;

    &lt;p&gt;When this is all done, there are a series of physical checks that can be
made to the &lt;a href=&quot;https://en.wikipedia.org/wiki/Physical_design_(electronics)&quot;&gt;physical
design&lt;/a&gt; before
&lt;a href=&quot;https://en.wikipedia.org/wiki/Tape-out&quot;&gt;tape out&lt;/a&gt;.  For example, the final
&lt;a href=&quot;https://en.wikipedia.org/wiki/Layout_Versus_Schematic&quot;&gt;layout should be checked to make certain it still matches the
schematic&lt;/a&gt;.
&lt;a href=&quot;https://en.wikipedia.org/wiki/Antenna_effect&quot;&gt;Antenna rule checking&lt;/a&gt; is
used to make static electric discharge does not damage the device
during manufacture.  &lt;a href=&quot;https://en.wikipedia.org/wiki/Design_rule_checking&quot;&gt;Design Rule Checks
(DRC)&lt;/a&gt; can also be
used.  DRC checks were initially used to just verify that all of the
components within a design have the correct widths, separations,
and that any enclosures were the minimum size.  Modern
&lt;a href=&quot;https://en.wikipedia.org/wiki/Design_rule_checking&quot;&gt;DRC&lt;/a&gt;
checkers now look for potential short-circuits, undriven lines, and much
more.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Selecting a Package&lt;/p&gt;

    &lt;p&gt;An
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
board designer can often select between a variety of chip shapes, form
factors, and means of connecting to the board.  Some
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;’s
have ball grid array connectors, other’s have their pins on the sides.&lt;/p&gt;

    &lt;p&gt;Unlike the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
board designer, who gets to choose from pre-made packages, the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Application-specific_integrated_circuit&quot;&gt;ASIC&lt;/a&gt;
designer is required to pick which package he wants his chip to be placed
within.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Have I convinced you that there are more parts to
&lt;a href=&quot;https://en.wikipedia.org/wiki/Application-specific_integrated_circuit&quot;&gt;ASIC&lt;/a&gt;
design than
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;’s
design?  If not, just understand that we haven’t yet touched on the
test, verification, and debugging differences yet.&lt;/p&gt;

&lt;h2 id=&quot;asic-hell-is-worse-then-fpga-hell&quot;&gt;ASIC Hell is worse then FPGA Hell&lt;/h2&gt;

&lt;p&gt;Verifying and subsequently testing an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Application-specific_integrated_circuit&quot;&gt;ASIC&lt;/a&gt;
design is very different from that of an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
design for two basic reasons: the monetary and calendar
costs.  As I mentioned above, a simple
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
design can be made, tested, and proven in an afternoon for the simple cost of
a small development board.
&lt;a href=&quot;https://en.wikipedia.org/wiki/Application-specific_integrated_circuit&quot;&gt;ASIC&lt;/a&gt;s,
on the other hand, can require months to manufacture, not to
mention the millions of dollars required to manufacture them.&lt;/p&gt;

&lt;p&gt;Now, consider how this impacts the cost of any design bug.
If you find a mistake within your
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
logic, you can often fix it within a week or so of isolating the problem.
If you’ve already delivered the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
solution to your customer, all it takes to upgrade their hardware is to send
them an updated configuration file electronically.  The cost is minimal.
On the other hand, if you find a bug in an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Application-specific_integrated_circuit&quot;&gt;ASIC&lt;/a&gt;
design, you will need to re-manufacture your chips at the cost of months
and millions of dollars.  Customer’s will be required to assemble new boards
with the new chips in their design.  As an example of how painful this can
become, you might wish to consider how Intel &lt;a href=&quot;https://en.wikipedia.org/wiki/Pentium_FDIV_bug&quot;&gt;paid roughly $475M for the
mistake in their divide
algorithm&lt;/a&gt;,
shipped with the first Pentium computers.&lt;/p&gt;

&lt;p&gt;Indeed, if you think &lt;a href=&quot;/fpga-hell.html&quot;&gt;FPGA Hell&lt;/a&gt; is a
nightmare, imagine being stuck in the same position after designing an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Application-specific_integrated_circuit&quot;&gt;ASIC&lt;/a&gt;!
Your costs would be orders of magnitude higher!  Not only would you have to pay
the multiple millions of dollars for each new mask, but imagine if you didn’t
know &lt;em&gt;what&lt;/em&gt; the problem was in order to fix it?&lt;/p&gt;

&lt;p&gt;Just to illustrate, let’s consider the cost of finding and fixing bugs in
software,
on an &lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;,
and within an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Application-specific_integrated_circuit&quot;&gt;ASIC&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;In software, the
&lt;a href=&quot;https://www.gnu.org/software/gdb/&quot;&gt;debugger&lt;/a&gt;
can help you find your fault.  You can often find and fix the problem in seconds
to minutes.  (Often, not always.)&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;’s
are harder to debug than software since you cannot see within them to examine
what’s going on.  Dealing with this problem has been one of the focuses of
&lt;a href=&quot;http://zipcpu.com/&quot;&gt;this blog&lt;/a&gt;.  Hence we’ve
discussed many techniques that can be used to find faults within
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
designs.  We’ve discussed &lt;a href=&quot;/blog/2017/06/16/dbg-bus-forest.html&quot;&gt;how to get information
into an&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
design, and how to pull information out.  We’ve discussed
&lt;a href=&quot;/digilent/2017/05/29/fft-debugging.html&quot;&gt;how to “single-step”&lt;/a&gt; an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
design, &lt;a href=&quot;/zipcpu/2017/08/25/hw-debugging.html&quot;&gt;how to “single-step” a
CPU&lt;/a&gt;
within an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
design, as well as how to &lt;a href=&quot;/blog/2017/07/08/getting-started-with-wbscope.html&quot;&gt;pull a trace out from within such a
design&lt;/a&gt;.
Using these techniques, faults can often be found within anywhere between an
hour or two on up to a couple of days–depending upon the fault.  Sometimes,
&lt;a href=&quot;https://blog/2017/09/14/even-i-get-stuck.html&quot;&gt;I’ve had faults take a month or
longer&lt;/a&gt; to find and fix–but
this is rare.&lt;/p&gt;

&lt;p&gt;Now, imagine how you would debug an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Application-specific_integrated_circuit&quot;&gt;ASIC&lt;/a&gt;
design?&lt;/p&gt;

&lt;p&gt;Your first and foremost goal would be to find problems within your
&lt;a href=&quot;https://en.wikipedia.org/wiki/Application-specific_integrated_circuit&quot;&gt;ASIC&lt;/a&gt;
design before you send it out for manufacture.  Indeed, if you can find bugs
before &lt;a href=&quot;https://en.wikipedia.org/wiki/Tape-out&quot;&gt;tape out&lt;/a&gt;, your cost per bug
will be relatively cheap.  Here are some methods you might use:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;/blog/2017/06/23/my-dbg-philosophy.html&quot;&gt;Simulation&lt;/a&gt; is
an obvious technique.  This works for both
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;’s
as well as
&lt;a href=&quot;https://en.wikipedia.org/wiki/Application-specific_integrated_circuit&quot;&gt;ASIC&lt;/a&gt;’s.&lt;/p&gt;

    &lt;p&gt;Unlike
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;s,
however,
&lt;a href=&quot;https://en.wikipedia.org/wiki/Application-specific_integrated_circuit&quot;&gt;ASIC&lt;/a&gt;’s
can contain both digital and analog circuitry.  Hence an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Application-specific_integrated_circuit&quot;&gt;ASIC&lt;/a&gt;’s
simulation needs may require tools that can handle analog circuitry
as well as digital.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Prototyping digital circuitry using an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;.&lt;/p&gt;

    &lt;p&gt;If you’d like to know if your
&lt;a href=&quot;https://en.wikipedia.org/wiki/Soft_microprocessor&quot;&gt;soft-core&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;
will even boot, or if it will properly run programs, this is often a good
place to start.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Application-specific_integrated_circuit&quot;&gt;ASIC&lt;/a&gt;
designers also tend to use &lt;a href=&quot;https://en.wikipedia.org/wiki/Formal_verification&quot;&gt;formal
methods&lt;/a&gt; to find obscure
bugs that their test benches don’t reveal.&lt;/p&gt;

    &lt;p&gt;The big difference between &lt;a href=&quot;https://en.wikipedia.org/wiki/Formal_verification&quot;&gt;formal
methods&lt;/a&gt; and more
traditional test benching approaches is that traditional test benches often
test only a couple logic paths.
&lt;a href=&quot;https://en.wikipedia.org/wiki/Formal_verification&quot;&gt;Formal methods&lt;/a&gt; attempt
to test &lt;em&gt;every&lt;/em&gt; logic path in order to &lt;em&gt;prove&lt;/em&gt; that the design “works”.&lt;/p&gt;

    &lt;p&gt;There are several types of
&lt;a href=&quot;https://en.wikipedia.org/wiki/Formal_verification&quot;&gt;formal methods&lt;/a&gt;
available, with each type able to find a different type of design fault.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;These are the cheap means of debugging an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Application-specific_integrated_circuit&quot;&gt;ASIC&lt;/a&gt;
design.  They are cheap because they can be performed without actually
manufacturing the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Application-specific_integrated_circuit&quot;&gt;ASIC&lt;/a&gt;
chips themselves.&lt;/p&gt;

&lt;p&gt;The more difficult task is testing the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Application-specific_integrated_circuit&quot;&gt;ASIC&lt;/a&gt;
after it has been manufactured.  This is often done, not for the purpose of
finding faults in the design (those were fixed before manufacture, right?),
but rather for the purpose of finding faults
within the manufacture of the particular part.&lt;/p&gt;

&lt;p&gt;Two basic approaches are used for this task.  The first approach is to use a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Scan_scan&quot;&gt;scan chain&lt;/a&gt;, the second to do
&lt;a href=&quot;https://en.wikipedia.org/wiki/Boundary_scan&quot;&gt;boundary scans&lt;/a&gt;.  While
both are similar, the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Scan_scan&quot;&gt;scan chain&lt;/a&gt; approach applies to
the internal logic within an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Application-specific_integrated_circuit&quot;&gt;ASIC&lt;/a&gt;,
whereas the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Boundary_scan&quot;&gt;boundary scan&lt;/a&gt; approach applies
to the I/O pads only.&lt;/p&gt;

&lt;p&gt;To test an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Application-specific_integrated_circuit&quot;&gt;ASIC&lt;/a&gt;
using a &lt;a href=&quot;https://en.wikipedia.org/wiki/Scan_scan&quot;&gt;scan chain&lt;/a&gt;, the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Application-specific_integrated_circuit&quot;&gt;ASIC&lt;/a&gt;
designer must first connect every
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flip-flop_(electronics)&quot;&gt;flip-flop&lt;/a&gt;
within the design to the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Scan_scan&quot;&gt;scan chain&lt;/a&gt;.  This must be done
as part of the design process, and before the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Application-specific_integrated_circuit&quot;&gt;ASIC&lt;/a&gt;
is manufactured.  A debug port is also created on the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Application-specific_integrated_circuit&quot;&gt;ASIC&lt;/a&gt;
part, allowing the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Application-specific_integrated_circuit&quot;&gt;ASIC&lt;/a&gt;
designer access to the scan chain.  When activated, every flip flop within the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Application-specific_integrated_circuit&quot;&gt;ASIC&lt;/a&gt;
may be read and set.  This allows an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Application-specific_integrated_circuit&quot;&gt;ASIC&lt;/a&gt;
designer internal visibility into their design, allowing him to determine
if the device that was manufactured accurately represents what he had
intended to manufacture.&lt;/p&gt;

&lt;p&gt;This debugging &lt;a href=&quot;https://en.wikipedia.org/wiki/Scan_scan&quot;&gt;scan chain&lt;/a&gt;
capability is often hidden within the manufacturer specified power and
ground rails supplied to the design, as well as (potentially) pins with
no particular connection to them.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Boundary_scan&quot;&gt;Boundary scan&lt;/a&gt; scan testing is
very similar, with the difference that instead of connecting to the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flip-flop_(electronics)&quot;&gt;flip-flop&lt;/a&gt;s
within a design, the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Boundary_scan&quot;&gt;boundary scan&lt;/a&gt; circuitry
connects to all of the I/O’s within a design.  As a result, a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Boundary_scan&quot;&gt;boundary scan&lt;/a&gt; can be used
to verify that different parts within a board are properly connected, and
that there are no short circuits between the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Application-specific_integrated_circuit&quot;&gt;ASIC&lt;/a&gt;
and the rest of the board it is placed within.  Unlike the hidden nature of
&lt;a href=&quot;https://en.wikipedia.org/wiki/Scan_scan&quot;&gt;scan chain&lt;/a&gt;’s, many chip manufacturers
use a standard
&lt;a href=&quot;https://en.wikipedia.org/wiki/JTAG&quot;&gt;JTAG&lt;/a&gt; interface to their
&lt;a href=&quot;https://en.wikipedia.org/wiki/Boundary_scan&quot;&gt;boundary scan&lt;/a&gt; logic.&lt;/p&gt;

&lt;p&gt;Given the above, I think it’s safe to conclude that
&lt;a href=&quot;https://en.wikipedia.org/wiki/Application-specific_integrated_circuit&quot;&gt;ASIC&lt;/a&gt;
testing methodologies are a superset of the technologies used to design
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
logic.&lt;/p&gt;

&lt;h2 id=&quot;formal-verification&quot;&gt;Formal Verification&lt;/h2&gt;

&lt;p&gt;While I haven’t discussed &lt;a href=&quot;http://www.clifford.at/yosys/about.html&quot;&gt;yosys&lt;/a&gt;
much on &lt;a href=&quot;http://zipcpu.com/&quot;&gt;this blog&lt;/a&gt;,
&lt;a href=&quot;http://www.clifford.at/yosys/about.html&quot;&gt;yosys&lt;/a&gt;
provides both an open source synthesis capability as well as access to several
open source &lt;a href=&quot;https://en.wikipedia.org/wiki/Formal_verification&quot;&gt;formal verification
methods&lt;/a&gt; for HDL designs.
These can then be used to &lt;em&gt;prove&lt;/em&gt; that the logic, either within an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
or an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Application-specific_integrated_circuit&quot;&gt;ASIC&lt;/a&gt;
design, will work.&lt;/p&gt;

&lt;p&gt;I’d like to experiment with some of these methods,
and report about them on
&lt;a href=&quot;http://zipcpu.com/&quot;&gt;this blog&lt;/a&gt;.
Indeed, I think it would be valuable to &lt;em&gt;prove&lt;/em&gt; that the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; does what that
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/doc/spec.pdf&quot;&gt;specification&lt;/a&gt;
says it is supposed to do.  Sure, I’ve tested it with a &lt;a href=&quot;https://github.com/ZipCPU/openarty/blob/master/sw/board/cputest.c&quot;&gt;roaming test
program&lt;/a&gt;,
but I expect that a 
&lt;a href=&quot;https://en.wikipedia.org/wiki/Formal_verification&quot;&gt;formal&lt;/a&gt; proof would be
more complete.&lt;/p&gt;

&lt;p&gt;Once I get the chance to try this, I’ll be glad to write about my experiences
with &lt;a href=&quot;http://www.clifford.at/yosys/about.html&quot;&gt;yosys&lt;/a&gt; verification methods,
and share any thing I discovered with everyone here.&lt;/p&gt;

&lt;hr /&gt;&lt;p&gt;&lt;em&gt;Again, the kingdom of heaven is like unto treasure hid in a field; the which when a man hath found, he hideth, and for joy thereof goeth and selleth all that he hath, and buyeth that field.&lt;/em&gt;</description>
        <pubDate>Fri, 13 Oct 2017 00:00:00 -0400</pubDate>
        <link>http://zipcpu.com/blog/2017/10/13/fpga-v-asic.html</link>
        <guid isPermaLink="true">http://zipcpu.com/blog/2017/10/13/fpga-v-asic.html</guid>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>It&#39;s all about the interfaces</title>
        <description>&lt;table style=&quot;float: right&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/cpu-serial.svg&quot; alt=&quot;CPU algorithms take time&quot; width=&quot;60&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;If you are looking for raw computational speed,
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;’s
are a well known solution.&lt;/p&gt;

&lt;p&gt;Unlike
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;’s,
a &lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;’s
speed is limited by the fact that the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;
must perform its instructions one at a time, even though many algorithms
could be made to run faster.  The
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;’s
general purpose nature simpy slows it down when compared to what
could be done within an electronic circuit.&lt;/p&gt;

&lt;p&gt;While many of the more modern
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;’s
have eight or more separate processing cores within a single chip,
this still doesn’t compare to the sheer parallelism offered within an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;.&lt;/p&gt;

&lt;table style=&quot;float: left; padding: 15px&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/fpga-parallel.svg&quot; alt=&quot;FPGAs run algorithms in parallel&quot; width=&quot;120&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Not only can
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;’s
run their algorithms in parallel, but they can also tailor their silicon for
just your algorithm.  Modern
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;’s support
divides, floating point operations, and SIMD instructions, many of which may
have nothing to do with what you are trying to accomplish.  The
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt; on the
other hand has a majority of its logic available for you to configure.
So, just how many copies of your algorithm do you wish to configure onto your
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt; solution?&lt;/p&gt;

&lt;p&gt;For these same reasons,
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;’s
can be faster than
&lt;a href=&quot;https://en.wikipedia.org/wiki/Graphics_processing_unit&quot;&gt;GPU&lt;/a&gt;’s as well–when
the algorithm in question isn’t a video algorithm such as the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Graphics_processing_unit&quot;&gt;GPU&lt;/a&gt; was optimized
for.&lt;/p&gt;

&lt;p&gt;While you might consider using an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Application-specific_integrated_circuit&quot;&gt;ASIC&lt;/a&gt;
to run your algorithm even faster,
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;’s
they tend to be a lot cheaper to debug and manufacture than
&lt;a href=&quot;https://en.wikipedia.org/wiki/Application-specific_integrated_circuit&quot;&gt;ASIC&lt;/a&gt;’s
are.  For example, making a mistake on an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt; usually
only costs your time to fix it, whereas a mistake within an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Application-specific_integrated_circuit&quot;&gt;ASIC&lt;/a&gt;
design may cost you many millions of dollars.&lt;/p&gt;

&lt;p&gt;For all these reasons, if your goal is speed, you may find yourself
considering an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
as your solution.  They are hands down the most economical means of running
an algorithm faster than a 
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt; can.&lt;/p&gt;

&lt;p&gt;Just don’t neglect the speed of your interface while you consider engineering an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
solution.&lt;/p&gt;

&lt;h2 id=&quot;its-the-interfaces-sir&quot;&gt;It’s the interfaces, Sir&lt;/h2&gt;

&lt;p&gt;I’ve noticed, as I’ve personally worked with
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;’s, that the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
fabric has rarely ever limited my algorithm’s speed and performance needs.
That’s always been the easy part of the task.&lt;/p&gt;

&lt;table style=&quot;float: left; padding: 15px&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/fpga-bottleneck.svg&quot; alt=&quot;Interfaces are an FPGA&#39;s achilles heel&quot; width=&quot;360&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Want to calculate a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Haar_wavelet&quot;&gt;Haar wavelet&lt;/a&gt;
transform on an image?
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;’s have
enough logic to run the algorithm many times over within them!  You can run
the transform horizontally, vertically, no problem–the raw task is easy for an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;That’s not the hard part.&lt;/p&gt;

&lt;p&gt;The hard part is feeding the algorithm with data, and getting the results back
out fast enough to be competitive with the alternatives.&lt;/p&gt;

&lt;p&gt;Perhaps an example will help explain what I’m talking about.&lt;/p&gt;

&lt;p&gt;Years ago, I had the opportunity to work on a really neat
&lt;a href=&quot;https://en.wikipedia.org/wiki/Global_Positioning_System&quot;&gt;GPS&lt;/a&gt;
processing algorithm.  If you are familiar with
&lt;a href=&quot;https://en.wikipedia.org/wiki/Global_Positioning_System&quot;&gt;GPS&lt;/a&gt; processing,
you’ll know that the success of a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Global_Positioning_System&quot;&gt;GPS&lt;/a&gt;
processing algorithm is based upon how many correlations you can do and how
fast you can do them.&lt;/p&gt;

&lt;p&gt;In my case, I was starting with a special algorithm that had been demonstrated
in software, and had proven itself in software on a general purpose
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;.  My problem
was that the algorithm ran slower than pond water.  My team needed speed.
For other reasons, there was an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
connected to to our
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;
microcontroller.  So we asked ourselves, why not use the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
to speed up the processing?&lt;/p&gt;

&lt;table style=&quot;float: right&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/fft-offload.svg&quot; alt=&quot;Offloading an FFT process from a CPU onto an FPGA&quot; width=&quot;360&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Specifically, I was interfacing an
&lt;a href=&quot;https://en.wikipedia.org/wiki/ARM_architecture&quot;&gt;ARM&lt;/a&gt;
based PXA271 &lt;a href=&quot;https://en.wikipedia.org/wiki/XScale&quot;&gt;XScale&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;, built by
&lt;a href=&quot;https://www.intel.com&quot;&gt;Intel&lt;/a&gt; at the time, with a Spartan 3
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;,
from &lt;a href=&quot;https://www.xilinx.com&quot;&gt;Xilinx&lt;/a&gt;.  The
&lt;a href=&quot;https://en.wikipedia.org/wiki/Global_Positioning_System&quot;&gt;GPS&lt;/a&gt;
algorithms performance was dominated by the number
&lt;a href=&quot;https://en.wikipedia.org/wiki/Fast_Fourier_transform&quot;&gt;FFT&lt;/a&gt;’s
the &lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;
had to accomplish.  Why not do those
&lt;a href=&quot;https://en.wikipedia.org/wiki/Fast_Fourier_transform&quot;&gt;FFT&lt;/a&gt;’s
within the &lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;,
and run them that much faster?&lt;/p&gt;

&lt;p&gt;If you look at
&lt;a href=&quot;https://www.xilinx.com&quot;&gt;Xilinx&lt;/a&gt;’s
&lt;a href=&quot;https://en.wikipedia.org/wiki/Fast_Fourier_transform&quot;&gt;FFT&lt;/a&gt;
IP core, they offer a pipelined
&lt;a href=&quot;https://en.wikipedia.org/wiki/Fast_Fourier_transform&quot;&gt;FFT&lt;/a&gt;
core that can run one
&lt;a href=&quot;https://en.wikipedia.org/wiki/Fast_Fourier_transform&quot;&gt;FFT&lt;/a&gt;
sample per clock–just like they did when I was working on this
problem.  Hence, an N point
&lt;a href=&quot;https://en.wikipedia.org/wiki/Fast_Fourier_transform&quot;&gt;FFT&lt;/a&gt;
costs N clocks to ingest into the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Fast_Fourier_transform&quot;&gt;FFT&lt;/a&gt;,
and after some (short) processing delay it takes N clocks to get the data
back out.  How much faster could you get?  The
&lt;a href=&quot;https://en.wikipedia.org/wiki/ARM_architecture&quot;&gt;ARM&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;
took many more clocks than that to process the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Fast_Fourier_transform&quot;&gt;FFT&lt;/a&gt;, so this should
be much faster, right?&lt;/p&gt;

&lt;p&gt;So I built it.&lt;/p&gt;

&lt;p&gt;The
&lt;a href=&quot;https://en.wikipedia.org/wiki/ARM_architecture&quot;&gt;ARM&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;
and the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
were both attached on the same physical bus.  That meant I could have the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;
send the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt; the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Fast_Fourier_transform&quot;&gt;FFT&lt;/a&gt;
data over the bus and then read it back when finished.&lt;/p&gt;

&lt;p&gt;With a little bit of debugging, I managed to get it all to work.  It wasn’t
all that hard technically to build, and speed was very important to
our application.  So, we ran the algorithm with a stop watch, anxiously
waiting to see how much faster it would run.&lt;/p&gt;

&lt;table style=&quot;float: right&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/fft-bottleneck.svg&quot; alt=&quot;The interfaces are the bottleneck&quot; width=&quot;360&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Much to my displeasure, the new
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
enhanced
&lt;a href=&quot;https://en.wikipedia.org/wiki/Fast_Fourier_transform&quot;&gt;FFT&lt;/a&gt;
algorithm &lt;em&gt;didn’t run any faster&lt;/em&gt;.  Indeed, as I recall, I think it even ran
slower.  I was shocked.  This wasn’t what I was expecting.&lt;/p&gt;

&lt;p&gt;That’s when I learned the painful lesson that an algorithm’s speed is dependent
upon the interface speed that feeds the algorithm.  In our case, the interface
was so slow that just transferring the data to the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
and reading the results back took more time to do than to perform the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Fast_Fourier_transform&quot;&gt;FFT&lt;/a&gt;
in the first place.&lt;/p&gt;

&lt;h2 id=&quot;learn-the-interfaces&quot;&gt;Learn the interfaces!&lt;/h2&gt;

&lt;p&gt;This is one of the reasons why the study of
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
design needs to include a study of interfaces and how to interact with them.
Indeed, if you look at one of my favorite
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
websites, &lt;a href=&quot;http://fpga4fun.com&quot;&gt;fpga4fun.com&lt;/a&gt;,
you’ll find a lot of discussions about how to build interfaces.
They discuss &lt;a href=&quot;http://fpga4fun.com/SerialInterface.html&quot;&gt;serial ports&lt;/a&gt;,
&lt;a href=&quot;http://www.fpga4fun.com/I2C.html&quot;&gt;I2C&lt;/a&gt;,
&lt;a href=&quot;http://www.fpga4fun.com/SPI.html&quot;&gt;SPI&lt;/a&gt;,
&lt;a href=&quot;http://www.fpga4fun.com/JTAG.html&quot;&gt;JTAG&lt;/a&gt;,
&lt;a href=&quot;http://www.fpga4fun.com/PongGame.html&quot;&gt;simple video ports (play Pong!)&lt;/a&gt;,
&lt;a href=&quot;http://www.fpga4fun.com/HDMI.html&quot;&gt;HDMI&lt;/a&gt;,
and more.  All of these interfaces have their purpose, and the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
student is well served by studying how to interact with them.&lt;/p&gt;

&lt;p&gt;Sadly, none of them would’ve been fast enough to rescue my
&lt;a href=&quot;https://en.wikipedia.org/wiki/Fast_Fourier_transform&quot;&gt;FFT&lt;/a&gt;
processing needs above.  (Although, … using the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Direct_memory_access&quot;&gt;DMA&lt;/a&gt;
controller on the &lt;a href=&quot;https://en.wikipedia.org/wiki/XScale&quot;&gt;XScale&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;
might’ve helped …)&lt;/p&gt;

&lt;p&gt;So, for this reason, let me recommend to you that before you spend your whole
dime on making your
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt; run
super fast with multiple copies of your algorithm all running in parallel,
that you at least spend as much (or more) of that dime guaranteeing that the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
can read and write your data fast enough to keep your
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
busy running that super-algorithm.&lt;/p&gt;

&lt;hr /&gt;&lt;p&gt;&lt;em&gt;But ye said, No; for we will flee upon horses; therefore shall ye flee:  and, We will ride upon the swift; therefore shall they that pursue you be swift. (Is 30:16)&lt;/em&gt;</description>
        <pubDate>Sat, 07 Oct 2017 00:00:00 -0400</pubDate>
        <link>http://zipcpu.com/blog/2017/10/07/study-interfaces.html</link>
        <guid isPermaLink="true">http://zipcpu.com/blog/2017/10/07/study-interfaces.html</guid>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>Using AutoFPGA to connect simple registers to a debugging bus</title>
        <description>&lt;p&gt;My &lt;a href=&quot;/zipcpu/2017/10/05/autofpga-intro.html&quot;&gt;prior post&lt;/a&gt;
regarding
&lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt;
discussed why I built
&lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt;
and what I intended to accomplish with it.&lt;/p&gt;

&lt;p&gt;Today, let’s take a look at how to create some simple
&lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt;
component files that you can then use within a basic
&lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt;
design.  Specifically, let’s look at how to connect
wishbone components
having only a single data register to an
&lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt;
project.&lt;/p&gt;

&lt;p&gt;To do this, we’ll start out by taking a look at
&lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt;’s
configuration file format.  You’ll need that to understand the basics of how
to read the configuration files themselves.  We’ll then discuss briefly
the two Verilog files
&lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt;
generates,
&lt;a href=&quot;https://github.com/ZipCPU/autofpga-demo/blob/master/auto-generated/toplevel.v&quot;&gt;toplevel.v&lt;/a&gt; and
&lt;a href=&quot;https://github.com/ZipCPU/autofpga-demo/blob/master/auto-generated/main.v&quot;&gt;main.v&lt;/a&gt;,
and then how the various
&lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt;
tags get placed within that structure.  This will then lead us to the point
where we can create the
&lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt;
configuration files necessary to read and write single registers
from a peripheral.&lt;/p&gt;

&lt;h2 id=&quot;autofpgas-configuration-file-format&quot;&gt;AutoFPGA’s Configuration File Format&lt;/h2&gt;

&lt;p&gt;Before we start discussing the details of how to write particular
&lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt;
cofiguration files, it only makes sense to pause to comment on the file
structure in general.  Indeed, &lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt;’s
configuration file structure is actually fairly simple, with its focus
primarily on staying out of the way.&lt;/p&gt;

&lt;h4 id=&quot;key-value-pairs&quot;&gt;Key value pairs&lt;/h4&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt;
configuration files consist of a series key value pairs.  Keys start at the
beginning of a line with an &lt;code class=&quot;highlighter-rouge&quot;&gt;@&lt;/code&gt; sign and end with an &lt;code class=&quot;highlighter-rouge&quot;&gt;=&lt;/code&gt; sign.  Hence, to
define the key &lt;code class=&quot;highlighter-rouge&quot;&gt;KEY&lt;/code&gt; to have a value &lt;code class=&quot;highlighter-rouge&quot;&gt;VALUE&lt;/code&gt;, you’d write:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;@KEY=VALUE&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;If the &lt;code class=&quot;highlighter-rouge&quot;&gt;VALUE&lt;/code&gt; fits within a single line, spaces will be trimmed from the ends
of it.&lt;/p&gt;

&lt;h4 id=&quot;multi-line-values&quot;&gt;Multi-line values&lt;/h4&gt;

&lt;p&gt;Value’s can also take up multiple lines, as in,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;@KEY=
/* The keys value will be given
 * by these series of lines.
 */&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Any white space found within multiple line &lt;code class=&quot;highlighter-rouge&quot;&gt;VALUE&lt;/code&gt;s will be left alone.&lt;/p&gt;

&lt;h4 id=&quot;comments&quot;&gt;Comments&lt;/h4&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt;
allows line based comments.  Comment lines begin with either a &lt;code class=&quot;highlighter-rouge&quot;&gt;#&lt;/code&gt; and a
space, or two &lt;code class=&quot;highlighter-rouge&quot;&gt;##&lt;/code&gt;s.  Other comment characters, such as &lt;code class=&quot;highlighter-rouge&quot;&gt;//&lt;/code&gt; or &lt;code class=&quot;highlighter-rouge&quot;&gt;/* ... */&lt;/code&gt;
will create comments within the result files that the &lt;code class=&quot;highlighter-rouge&quot;&gt;VALUE&lt;/code&gt; gets pasted into.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;# This is a comment within AutoFPGA
##This is also a comment
@KEY=
/* This comment will be copy/pasted into the source file this KEY&#39;s VALUE
 * will be pasted into.
 */
// This comment will also be copy/pasted as part of AutoFPGA&#39;s work&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h4 id=&quot;unordered&quot;&gt;Unordered&lt;/h4&gt;

&lt;p&gt;Keys within an
&lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt;
configuration file are unordered, with the only exception being the
&lt;code class=&quot;highlighter-rouge&quot;&gt;@PREFIX&lt;/code&gt; key that separates components within a given configuration file
(more on this key in a moment).
What this means is that you can place keys for the &lt;a href=&quot;https://github.com/ZipCPU/autofpga-demo/blob/master/auto-generated/toplevel.v&quot;&gt;top level module&lt;/a&gt; before
those for the
&lt;a href=&quot;https://github.com/ZipCPU/autofpga-demo/blob/master/auto-generated/main.v&quot;&gt;main module&lt;/a&gt;,
after the &lt;a href=&quot;https://github.com/ZipCPU/autofpga-demo/blob/master/auto-generated/main.v&quot;&gt;main module&lt;/a&gt;
keys, or interspersed between the two.&lt;/p&gt;

&lt;h4 id=&quot;substitution&quot;&gt;Substitution&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;VALUE&lt;/code&gt;s from one &lt;code class=&quot;highlighter-rouge&quot;&gt;KEY&lt;/code&gt; may be substituted into &lt;code class=&quot;highlighter-rouge&quot;&gt;VALUE&lt;/code&gt;s from another, by
referencing the value by its keys name, as in &lt;code class=&quot;highlighter-rouge&quot;&gt;@$(KEY)&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;For example, if you define a key &lt;code class=&quot;highlighter-rouge&quot;&gt;@DEVID&lt;/code&gt;,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;@DEVID=VERSION&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;You can later reference this key within another key’s value by using
&lt;code class=&quot;highlighter-rouge&quot;&gt;@$(DEVID&lt;/code&gt; to reference it.  Hence,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;@REGS.0= 0 R_@$(DEVID) $(DEVID)&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;will get expanded into&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;@REGS.0= 0 R_VERSION VERSION&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h4 id=&quot;expressions&quot;&gt;Expressions&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;KEY&lt;/code&gt;s that start with &lt;code class=&quot;highlighter-rouge&quot;&gt;@$&lt;/code&gt; instead of &lt;code class=&quot;highlighter-rouge&quot;&gt;@&lt;/code&gt; define integer valued expressions.
&lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt; contains a simple expression
evaluator, allowing things like:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;@$BAUDCLOCKS=@$(BAUDRATE)/@$(CLKFREQHZ)&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;In this case, if you’ve defined &lt;code class=&quot;highlighter-rouge&quot;&gt;BAUDRATE&lt;/code&gt; as&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;@BAUDRATE=1000000&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;or even&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;@$BAUDRATE=1000000&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;and &lt;code class=&quot;highlighter-rouge&quot;&gt;CLKFREQHZ&lt;/code&gt; as&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;@$CLKFREQHZ=100000000&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;then&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt; would calculate the
&lt;code class=&quot;highlighter-rouge&quot;&gt;@BAUDCLOCKS&lt;/code&gt; frequency to be 100 clocks.  If &lt;code class=&quot;highlighter-rouge&quot;&gt;@$(BAUDCLOCKS)&lt;/code&gt; is used in
an string context, it will evaluate to the string &lt;code class=&quot;highlighter-rouge&quot;&gt;&quot;100&quot;&lt;/code&gt;.  (The format
is adjustable via the &lt;code class=&quot;highlighter-rouge&quot;&gt;@BAUDCLOCKS.FORMAT&lt;/code&gt; tag, but we’ll get to that later.)&lt;/p&gt;

&lt;h4 id=&quot;the-prefix-key&quot;&gt;The @PREFIX key&lt;/h4&gt;

&lt;p&gt;All
&lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt; components begin with a
&lt;code class=&quot;highlighter-rouge&quot;&gt;@PREFIX&lt;/code&gt; key.  This key defines both the beginning of the component’s keys
within a configuration file, as well as the end of any prior component that
may also be defined within the file.  The &lt;code class=&quot;highlighter-rouge&quot;&gt;@PREFIX&lt;/code&gt; tag also creates a
sort of local variable namespace, since keys defined following a &lt;code class=&quot;highlighter-rouge&quot;&gt;@PREFIX&lt;/code&gt;
key are quietly prefixed in the global key structure by the &lt;code class=&quot;highlighter-rouge&quot;&gt;@PREFIX&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;While there are a couple of other details to
&lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt;’s
configuration files, those other details can wait until we need them later.&lt;/p&gt;

&lt;h2 id=&quot;autofpgas-rtl-file-structure&quot;&gt;AutoFPGA’s RTL File Structure&lt;/h2&gt;

&lt;p&gt;Before you integrate your component into
&lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt;,
you’ll wnat to understand how
&lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt;
looks at RTL (Verilog) files.&lt;/p&gt;

&lt;p&gt;In general,
&lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt;
insists that a design should have the structure shown in Fig 1.  In this
structure, the
&lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt; generated files are marked with
a red star.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 1: AutoFPGA RTL Structure&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/auto-rtl.svg&quot; alt=&quot;AutoFPGA RTL File Structure&quot; width=&quot;480&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;In this structure, there is a
&lt;a href=&quot;https://github.com/ZipCPU/autofpga-demo/blob/master/auto-generated/toplevel.v&quot;&gt;top level file&lt;/a&gt;.
Within this &lt;a href=&quot;https://github.com/ZipCPU/autofpga-demo/blob/master/auto-generated/toplevel.v&quot;&gt;top level file&lt;/a&gt;
are any references to vendor specific components.
For example, MMCM’s, PLL’s, ISERDESE2 and OSERDESE2 components would be placed
either in the
&lt;a href=&quot;https://github.com/ZipCPU/autofpga-demo/blob/master/auto-generated/toplevel.v&quot;&gt;top level&lt;/a&gt;
itself,
or in the vendor specific files beneath it.  As an example, the
&lt;a href=&quot;https://www.xilinx.com&quot;&gt;Xilinx&lt;/a&gt; Memory Interface Generator (MIG) code is
vendor specific, so it would belong at this top level.  Another example might
be the vendor specific components necessary for a
&lt;a href=&quot;https://en.wikipedia.org/wiki/HDMI&quot;&gt;HDMI&lt;/a&gt; receiver.  The actual line of
demarkation is made by examining what
&lt;a href=&quot;https://www.veripool.org/wiki/verilator&quot;&gt;Verilator&lt;/a&gt; can simulate.
Any components that &lt;a href=&quot;https://www.veripool.org/wiki/verilator&quot;&gt;Verilator&lt;/a&gt;
can components can be placed in
&lt;a href=&quot;https://github.com/ZipCPU/autofpga-demo/blob/master/auto-generated/main.v&quot;&gt;main.v&lt;/a&gt;
and below, anything else goes into the
&lt;a href=&quot;https://github.com/ZipCPU/autofpga-demo/blob/master/auto-generated/toplevel.v&quot;&gt;top level&lt;/a&gt; or the vendor specific component set that it references.&lt;/p&gt;

&lt;p&gt;Critical components of your design that don’t meet the criteria to be placed
into
&lt;a href=&quot;https://github.com/ZipCPU/autofpga-demo/blob/master/auto-generated/main.v&quot;&gt;main.v&lt;/a&gt;
may need external (C++ software) co-simulators.  We’ll come back to the concept
of simulation later.&lt;/p&gt;

&lt;p&gt;Also within the &lt;a href=&quot;https://github.com/ZipCPU/autofpga-demo/blob/master/auto-generated/toplevel.v&quot;&gt;top level file&lt;/a&gt;
is an instantiation of the main module.  The
&lt;a href=&quot;https://github.com/ZipCPU/autofpga-demo/blob/master/auto-generated/main.v&quot;&gt;main module&lt;/a&gt;
consists of one (or more) bus masters controlling a set of peripherals.
It can also contain items that are neither bus masters nor peripherals,
but these items won’t get attached to any bus.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt; will build both the
&lt;a href=&quot;https://github.com/ZipCPU/autofpga-demo/blob/master/auto-generated/toplevel.v&quot;&gt;top level&lt;/a&gt;
module, as well as the
&lt;a href=&quot;https://github.com/ZipCPU/autofpga-demo/blob/master/auto-generated/main.v&quot;&gt;main module&lt;/a&gt;
for you–connecting components together as the need to be for your design.&lt;/p&gt;

&lt;p&gt;However, &lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt;
has no knowledge of the vendor specific or vendor independent
component files.  All it knows how to do is to copy and paste items into these
two files to create your logic.  You tell it how to interface with the other
components, but that’s it.&lt;/p&gt;

&lt;p&gt;Well, this isn’t &lt;em&gt;quite&lt;/em&gt; true.
&lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt; supports some
Makefile based tags which can be used to create a make include file.
You can use these tags to place a list of component items into a
list of Verilog files included in your project.  Some synthesizers, such as
&lt;a href=&quot;https://www.clifford.at/yosys&quot;&gt;yosys&lt;/a&gt;
need this information in order to build the project.  Other synthesizers,
isuch as &lt;a href=&quot;https://www.veripool.org/wiki/verilator&quot;&gt;Verilator&lt;/a&gt;,
just need to be told where to look.  We’ll come back to this topic later.&lt;/p&gt;

&lt;p&gt;What I”m trying to say is that after
&lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt; has created any
&lt;a href=&quot;https://github.com/ZipCPU/autofpga-demo/blob/master/auto-generated/toplevel.v&quot;&gt;top level&lt;/a&gt; file
or &lt;a href=&quot;https://github.com/ZipCPU/autofpga-demo/blob/master/auto-generated/main.v&quot;&gt;main module&lt;/a&gt;,
you’ll still need to synthesize your design from these module files.
&lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt;
doesn’t create make files, and it doesn’t build projects.  These
capabilities need to be part of the project that uses
&lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;internal-rtl-file-structure&quot;&gt;Internal RTL File Structure&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt;
is primarily a copy and paste utility, with some additional capabilities for
composing and connecting bus structures and interrupts.  What this means
when it comes to the two RTL files that it generates is that
&lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt;
will primarily copy snippets of Verilog code, provided by your
configuration file, into their proper places within these two files.&lt;/p&gt;

&lt;p&gt;The majority of this work is done within
&lt;a href=&quot;https://github.com/ZipCPU/autofpga-demo/blob/master/auto-generated/main.v&quot;&gt;main.v&lt;/a&gt;
so let’s look at that first.&lt;/p&gt;

&lt;table style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 2: Main module structure&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/auto-mainv.svg&quot; alt=&quot;main.v structure&quot; width=&quot;320&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Fig 2 shows the structure of the
&lt;a href=&quot;https://github.com/ZipCPU/autofpga-demo/blob/master/auto-generated/main.v&quot;&gt;main module&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The &lt;a href=&quot;https://github.com/ZipCPU/autofpga-demo/blob/master/auto-generated/main.v&quot;&gt;main module&lt;/a&gt;,
as shown in Fig 2, has several parts to it.  It starts like all
&lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt;
generated file with a legal notice, copied from the file whose name is
associated with the &lt;code class=&quot;highlighter-rouge&quot;&gt;@LEGAL&lt;/code&gt; key.  After that, there’s a section where
components can define &lt;code class=&quot;highlighter-rouge&quot;&gt;ACCESS&lt;/code&gt; keys.  These are pre-processor macros, that
will be used to handle component dependencies if necessary (&lt;code class=&quot;highlighter-rouge&quot;&gt;@DEPENDS&lt;/code&gt; key).
Then comes a series of paste’d components from any &lt;code class=&quot;highlighter-rouge&quot;&gt;@MAIN.PORTLIST&lt;/code&gt; keys,
then any parameter definitions captured in &lt;code class=&quot;highlighter-rouge&quot;&gt;@MAIN.PARAM&lt;/code&gt; keys, and then any
declarations associated with &lt;code class=&quot;highlighter-rouge&quot;&gt;@MAIN.IODECL&lt;/code&gt; keys.  The file continues,
defining any interrupt wires, wires defined within &lt;code class=&quot;highlighter-rouge&quot;&gt;@MAIN.DEFNS&lt;/code&gt; tags,
interrupt vectors, and bus interaction wire components.
The big point to know here is that these keys are pasted into this file in
the order shown.  I’ve written the keys in all capitols in the positions
where their values will be pasted in within Fig 2, so you can see what goes
where.&lt;/p&gt;

&lt;p&gt;The primary module for the component, where the actual bus interaction and
any I/O wire adjustment takes place, is placed within the value of the
&lt;code class=&quot;highlighter-rouge&quot;&gt;@MAIN.INSERT&lt;/code&gt; tag for the component.  We’ll discuss many of the other details
as we go along.&lt;/p&gt;

&lt;table style=&quot;float: left; padding: 15px&quot;&gt;&lt;caption&gt;Fig 3: Toplevel file structure&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/auto-topv.svg&quot; alt=&quot;toplevel.v structure&quot; width=&quot;320&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;The &lt;a href=&quot;https://github.com/ZipCPU/autofpga-demo/blob/master/auto-generated/toplevel.v&quot;&gt;top-level&lt;/a&gt;
module has a similar, although simpler, structure as shown in Fig 3.&lt;/p&gt;

&lt;p&gt;Unlike the &lt;a href=&quot;https://github.com/ZipCPU/autofpga-demo/blob/master/auto-generated/main.v&quot;&gt;main module&lt;/a&gt;,
fewer &lt;code class=&quot;highlighter-rouge&quot;&gt;KEY&lt;/code&gt;s impact the
&lt;a href=&quot;https://github.com/ZipCPU/autofpga-demo/blob/master/auto-generated/toplevel.v&quot;&gt;top-level&lt;/a&gt;.
There’s the list of I/O ports for the module, their declarations, and any
other definitions you might wish to have.  After that, there’s the &lt;code class=&quot;highlighter-rouge&quot;&gt;KEY&lt;/code&gt;
defining wires that need to be passed to the
&lt;a href=&quot;https://github.com/ZipCPU/autofpga-demo/blob/master/auto-generated/main.v&quot;&gt;main module&lt;/a&gt;,
&lt;code class=&quot;highlighter-rouge&quot;&gt;@TOP.MAIN&lt;/code&gt;, and any RTL code that needs to be
inserted into the
&lt;a href=&quot;https://github.com/ZipCPU/autofpga-demo/blob/master/auto-generated/toplevel.v&quot;&gt;top-level&lt;/a&gt;.
module via the
&lt;code class=&quot;highlighter-rouge&quot;&gt;@TOP.INSERT&lt;/code&gt; key.&lt;/p&gt;

&lt;p&gt;Not all components will need these
&lt;a href=&quot;https://github.com/ZipCPU/autofpga-demo/blob/master/auto-generated/toplevel.v&quot;&gt;top-level&lt;/a&gt;
keys.  If no
&lt;a href=&quot;https://github.com/ZipCPU/autofpga-demo/blob/master/auto-generated/toplevel.v&quot;&gt;top-level&lt;/a&gt;
keys are given, then any keys describing ports for the
&lt;a href=&quot;https://github.com/ZipCPU/autofpga-demo/blob/master/auto-generated/main.v&quot;&gt;main.v&lt;/a&gt;,
file will automatically be assumed to be
&lt;a href=&quot;https://github.com/ZipCPU/autofpga-demo/blob/master/auto-generated/toplevel.v&quot;&gt;toplevel&lt;/a&gt;,
ports as well, so they need not be defined twice if they are the same between
both levels.&lt;/p&gt;

&lt;p&gt;So, let’s take a look at what it takes to put a configuration file together
that will specify how to impact the
&lt;a href=&quot;https://github.com/ZipCPU/autofpga-demo/blob/master/auto-generated/toplevel.v&quot;&gt;top level&lt;/a&gt;,
or &lt;a href=&quot;https://github.com/ZipCPU/autofpga-demo/blob/master/auto-generated/main.v&quot;&gt;main module&lt;/a&gt;.
We’ll start with some simple examples, and then move to some more complex
examples.&lt;/p&gt;

&lt;p&gt;Remember, as you go through these, that
&lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt;
is primarily a copy/paste utility, with some bus aggregation facilities
added into it.&lt;/p&gt;

&lt;h2 id=&quot;reading-a-simple-ad-hoc-value&quot;&gt;Reading a simple ad-hoc value&lt;/h2&gt;

&lt;p&gt;For our first example, let’s read a constant value from our bus.  The value
itself is arbitrary for this example, so we’ll just set it to
&lt;code class=&quot;highlighter-rouge&quot;&gt;32&#39;h20170926&lt;/code&gt;.  You can see the full configuration file for this example
&lt;a href=&quot;https://github.com/ZipCPU/autofpga-demo/blob/master/auto-data/fixdata.txt&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The first step is to declare this item as a peripheral–as its own entity, and
to give it a name that will distinguish it from other peripherals within our
design.  This is done via the &lt;code class=&quot;highlighter-rouge&quot;&gt;@PREFIX&lt;/code&gt; key.  Let’s give this fixed data
component the name &lt;code class=&quot;highlighter-rouge&quot;&gt;fixdata&lt;/code&gt;, since that’s what we’ll be reading from it: fixed
data.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;@PREFIX=fixdata&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The &lt;code class=&quot;highlighter-rouge&quot;&gt;@PREFIX&lt;/code&gt; key is required for all components.
It defines the beginning of the component, and ends any component definitions
prior to it.  (Yes, two components can be placed into a single configuration
file.  A good example of this would be the &lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/auto-data/flash.txt&quot;&gt;flash
component&lt;/a&gt;
that has not only read-only flash memory, but also a set of program control
registers to control the erase circuitry, and any write-enable.)&lt;/p&gt;

&lt;p&gt;We may also want an all-caps name for some of the contexts this peripheral
might be in.  This isn’t required, like the &lt;code class=&quot;highlighter-rouge&quot;&gt;@PREFIX&lt;/code&gt; key is, but it makes
a nice illustration.  For this, we’ll create the key &lt;code class=&quot;highlighter-rouge&quot;&gt;DEVID&lt;/code&gt;, and give it a
value of &lt;code class=&quot;highlighter-rouge&quot;&gt;FIXEDATA&lt;/code&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;@DEVID=FIXEDATA&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This is a classic example of a key that
&lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt;
knows nothing about.  It will have only the meaning we give it below.&lt;/p&gt;

&lt;p&gt;If you want this peripheral to have a place on the bus, then
&lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt;
needs to know how many addresses to assign to it.
Let’s take just one bus address (four bytes for a 32-bit data bus–the
default), since we’re only going to be returning a single, pre-determined,
value.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;@NADDR=1&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Most of the example’s we’ll deal with today have only one address.&lt;/p&gt;

&lt;p&gt;This particular peripheral is going to be a slave peripheral to the
main wishbone bus, &lt;code class=&quot;highlighter-rouge&quot;&gt;wb&lt;/code&gt; within our design.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;@SLAVE.BUS=wb&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Once a component is declared to be a bus slave, a series of wires will be
defined for it within &lt;a href=&quot;https://github.com/ZipCPU/autofpga-demo/blob/master/auto-generated/main.v&quot;&gt;main.v&lt;/a&gt;
as referenced in Fig 2 above.  For our component, these wires are given by,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;wire	[31:0]	fixdata_data;
wire		fixdata_ack, fixdata_stall, fixdata_sel;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;although I’ll tend to reference these as &lt;code class=&quot;highlighter-rouge&quot;&gt;@$(PREFIX)_data&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;@$(PREFIX)_ack&lt;/code&gt;,
etc., since these descriptions are more generic and can be used regardless
of what the peripherals name, given by the &lt;code class=&quot;highlighter-rouge&quot;&gt;@PREFIX&lt;/code&gt; key, actually is.  The
first three of these are the slave return wires required by the
&lt;a href=&quot;/doc/wbspec_b4.pdf&quot;&gt;wishbone bus&lt;/a&gt;.  The third wire,
&lt;code class=&quot;highlighter-rouge&quot;&gt;@$(PREFIX)_sel&lt;/code&gt; will be true any time the address on the bus references this
component.&lt;/p&gt;

&lt;p&gt;Because our value is already fixed, it won’t take any clocks to calculate
it–it’s already known.  Therefore this slave is of type &lt;code class=&quot;highlighter-rouge&quot;&gt;SINGLE&lt;/code&gt;, since it
can return a result in a &lt;code class=&quot;highlighter-rouge&quot;&gt;SINGLE&lt;/code&gt; clock cycle.  &lt;code class=&quot;highlighter-rouge&quot;&gt;SINGLE&lt;/code&gt; peripherals don’t
need to define their wishbone acknowledgement wires, &lt;code class=&quot;highlighter-rouge&quot;&gt;@$(PREFIX)_ack&lt;/code&gt;, or
their stall lines, &lt;code class=&quot;highlighter-rouge&quot;&gt;@$(PREFIX)_stall&lt;/code&gt;, since they never stall and the ack
is true the same clock the peripheral is accessed.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;@SLAVE.TYPE=SINGLE&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Other peripheral types are &lt;code class=&quot;highlighter-rouge&quot;&gt;DOUBLE&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;OTHER&lt;/code&gt;, and &lt;code class=&quot;highlighter-rouge&quot;&gt;MEMORY&lt;/code&gt;.  &lt;code class=&quot;highlighter-rouge&quot;&gt;DOUBLE&lt;/code&gt;
peripherals require a single clock to calculate their value, yet never
stall.  &lt;code class=&quot;highlighter-rouge&quot;&gt;OTHER&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;MEMORY&lt;/code&gt; peripherals are more generic wishbone
peripherals–but we’ll discuss these more later.&lt;/p&gt;

&lt;p&gt;It’s now time to return our value to the bus.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;@MAIN.INSERT=
	assign	@$(PREFIX)_data = 32&#39;h20170926;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Normally a &lt;a href=&quot;/doc/wbspec_b4.pdf&quot;&gt;wishbone&lt;/a&gt; slave also
needs to assign values to a &lt;code class=&quot;highlighter-rouge&quot;&gt;@$(PREFIX)_ack&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;@$(PREFIX)_stall&lt;/code&gt; line.
However, these are trivially defined for a &lt;code class=&quot;highlighter-rouge&quot;&gt;SINGLE&lt;/code&gt; peripheral type, so we
ignore them here.  (The &lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt; generated
&lt;a href=&quot;https://github.com/ZipCPU/autofpga-demo/blob/master/auto-generated/main.v&quot;&gt;main.v&lt;/a&gt;
file ignores these lines for &lt;code class=&quot;highlighter-rouge&quot;&gt;SINGLE&lt;/code&gt; type peripherals as well.)&lt;/p&gt;

&lt;p&gt;The last step in our peripheral definition is to give a name for this
peripheral to be used when accessing it via the debugging interface.  This is
where we’ll use the &lt;code class=&quot;highlighter-rouge&quot;&gt;@DEVID&lt;/code&gt; key we defined earlier.  The first of the lines
below just specifies that this peripheral has only one named register.  The
second line says that, at an offset of zero words from the beginning of this
peripheral’s address is a register named &lt;code class=&quot;highlighter-rouge&quot;&gt;R_@$(DEVID)&lt;/code&gt; with a user name of
&lt;code class=&quot;highlighter-rouge&quot;&gt;@$(DEVID)&lt;/code&gt;.  These will be turned into &lt;code class=&quot;highlighter-rouge&quot;&gt;R_FIXEDATA&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;FIXEDATA&lt;/code&gt;
respectively.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;@REGS.N=1
@REGS.0= 0 R_@$(DEVID) @$(DEVID)&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;If you look in
&lt;a href=&quot;https://github.com/ZipCPU/autofpga-demo/blob/master/auto-generated/regdefs.h&quot;&gt;regdefs.h&lt;/a&gt;,
or &lt;a href=&quot;https://github.com/ZipCPU/autofpga-demo/blob/master/auto-generated/regdefs.cpp&quot;&gt;regdefs.cpp&lt;/a&gt;,
for &lt;code class=&quot;highlighter-rouge&quot;&gt;R_FIXEDATA&lt;/code&gt;, you’ll see the effects of these two lines.&lt;/p&gt;

&lt;table style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 4: Software interface files and AutoFPGA&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/auto-host.svg&quot; alt=&quot;Diagram showing that AutoFPGA creates regdefs.h and regdefs.cpp&quot; width=&quot;320&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;While we haven’t discussed it, these two files,
&lt;a href=&quot;https://github.com/ZipCPU/autofpga-demo/blob/master/auto-generated/regdefs.h&quot;&gt;regdefs.h&lt;/a&gt;,
and &lt;a href=&quot;https://github.com/ZipCPU/autofpga-demo/blob/master/auto-generated/regdefs.cpp&quot;&gt;regdefs.cpp&lt;/a&gt;,
are part of the host-based software interface library specification shown in
Fig 4.  They are marked with red stars, since they are created by
&lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt;, vice the &lt;code class=&quot;highlighter-rouge&quot;&gt;design.h&lt;/code&gt; file
created by the
&lt;a href=&quot;https://github.com/ZipCPU/autofpga-demo/blob/master/rtl/Makefile&quot;&gt;RTL Makefile&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Once we include &lt;a href=&quot;https://github.com/ZipCPU/autofpga-demo/blob/master/auto-data/fixdata.txt&quot;&gt;this fixdata.txt configuration
file&lt;/a&gt;
in our design, and build it, we can then run
&lt;a href=&quot;https://github.com/ZipCPU/autofpga-demo/blob/master/sw/wbregs.cpp&quot;&gt;wbregs&lt;/a&gt;&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;wbregs FIXEDATA&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;to read from the peripheral–either in simulation or on our actual hardware.&lt;/p&gt;

&lt;h2 id=&quot;reading-a-fixed-version-number&quot;&gt;Reading a Fixed Version number&lt;/h2&gt;

&lt;p&gt;What if we want our number to be defined by an include file?&lt;/p&gt;

&lt;p&gt;Many of my designs contain an include file, &lt;code class=&quot;highlighter-rouge&quot;&gt;builddate.v&lt;/code&gt;, that is created
by a &lt;a href=&quot;https://github.com/ZipCPU/autofpga-demo/blob/master/mkdatev.pl&quot;&gt;simple perl
script&lt;/a&gt;.
This &lt;a href=&quot;https://github.com/ZipCPU/autofpga-demo/blob/master/rtl/builddate.v&quot;&gt;include
file&lt;/a&gt;
defines a value &lt;code class=&quot;highlighter-rouge&quot;&gt;DATESTAMP&lt;/code&gt; containing the date when
&lt;a href=&quot;https://github.com/ZipCPU/autofpga-demo/blob/master/mkdatev.pl&quot;&gt;mkdatev.pl&lt;/a&gt;
was last run.  I use this as a version number within my design–primarily
to make certain I’m not accidentally running an older design when I think
I’ve built and loaded a newer design.&lt;/p&gt;

&lt;p&gt;Creating a register containing &lt;a href=&quot;https://github.com/ZipCPU/autofpga-demo/blob/master/rtl/builddate.v&quot;&gt;this version
information&lt;/a&gt;
is almost identical to the last exercise.  First, we declare our bus interface
as before, although this time with a different &lt;code class=&quot;highlighter-rouge&quot;&gt;@PREFIX&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;@DEVID&lt;/code&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;@PREFIX=version
@DEVID=VERSION
@NADDR=1
@SLAVE.TYPE=SINGLE
@SLAVE.BUS=wb&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;At this point, though, we want to instruct our
&lt;a href=&quot;https://github.com/ZipCPU/autofpga-demo/blob/master/auto-generated/main.v&quot;&gt;main module&lt;/a&gt;
to include the 
&lt;a href=&quot;https://github.com/ZipCPU/autofpga-demo/blob/master/mkdatev.pl&quot;&gt;Perl-script generated&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/autofpga-demo/blob/master/rtl/builddate.v&quot;&gt;build-date version
file&lt;/a&gt;.
This is done through the &lt;code class=&quot;highlighter-rouge&quot;&gt;@MAIN.DEFNS&lt;/code&gt; key, whose value then gets pasted at
the top of the
&lt;a href=&quot;https://github.com/ZipCPU/autofpga-demo/blob/master/auto-generated/main.v&quot;&gt;main module&lt;/a&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;@MAIN.DEFNS=
`include &quot;builddate.v&quot;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Remember,
&lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt;
is primarily a copy and paste utility.  You can place any Verilog you want
into your
&lt;a href=&quot;https://github.com/ZipCPU/autofpga-demo/blob/master/auto-generated/main.v&quot;&gt;main module&lt;/a&gt; file
at this same location using this tag, although not all things you could
paste would make sense at the top of a module file and before the
module declaration.&lt;/p&gt;

&lt;p&gt;Our bus interaction code within the
&lt;a href=&quot;https://github.com/ZipCPU/autofpga-demo/blob/master/auto-generated/main.v&quot;&gt;main module&lt;/a&gt;,
given by the &lt;code class=&quot;highlighter-rouge&quot;&gt;@MAIN.INSERT&lt;/code&gt; key, is going to change only slightly.  This
time, instead of returning &lt;code class=&quot;highlighter-rouge&quot;&gt;32&#39;h20170926&lt;/code&gt;, we’ll return our &lt;code class=&quot;highlighter-rouge&quot;&gt;DATESTAMP&lt;/code&gt;
variable.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;@MAIN.INSERT=
	assign	@$(PREFIX)_data = `DATESTAMP;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The rest is just like the last example.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;@REGS.N=1
@REGS.0= 0 R_@$(DEVID) @$(DEVID)&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;You can see the full configuration file for reading this &lt;a href=&quot;https://github.com/ZipCPU/autofpga-demo/blob/master/auto-data/version.txt&quot;&gt;version information
here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;One thing to note is that
&lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt;
only creates &lt;em&gt;some&lt;/em&gt; files.  It doesn’t create an entire project.  Hence, the
creation of the &lt;code class=&quot;highlighter-rouge&quot;&gt;builddate.v&lt;/code&gt; file is done by the main
&lt;a href=&quot;https://github.com/ZipCPU/autofpga-demo/blob/master/Makefile&quot;&gt;Makefile&lt;/a&gt;
calling the
&lt;a href=&quot;https://github.com/ZipCPU/autofpga-demo/blob/master/mkdatev.pl&quot;&gt;mkdatev.pl&lt;/a&gt;
program–both of which are outside of the configuration files that
&lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/autofpga-demo/blob/master/auto-data&quot;&gt;looks at&lt;/a&gt; and
&lt;a href=&quot;https://github.com/ZipCPU/autofpga-demo/blob/master/auto-generated&quot;&gt;creates&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;read-access-to-an-internal-changing-register&quot;&gt;Read access to an internal (changing) register&lt;/h2&gt;

&lt;p&gt;Let’s create another single register within our design using
&lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt;.  Suppose we wanted to
know how many clock ticks had taken place since we first initialized our
design, and whether the count had (eventually) rolled over.  To get this
value, we’d need to initialize a register and then count clocks with it.&lt;/p&gt;

&lt;p&gt;The &lt;a href=&quot;https://github.com/ZipCPU/autofpga-demo/blob/master/auto-data/pwrcount.txt&quot;&gt;pwrcount.txt&lt;/a&gt;
configuration file describes just how to build one of such a register.
We’ll walk through this file below.&lt;/p&gt;

&lt;p&gt;Since this is a single value, again, the bus access declaration is the same as
before but with a new name, &lt;code class=&quot;highlighter-rouge&quot;&gt;pwrcount&lt;/code&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;@PREFIX=pwrcount
@NADDR=1
@SLAVE.TYPE=SINGLE
@SLAVE.BUS=wb
@REGS.N=1
@REGS.0= 0 R_PWRCOUNT PWRCOUNT&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Note that I didn’t use the &lt;code class=&quot;highlighter-rouge&quot;&gt;DEVID&lt;/code&gt; this time.
&lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt;
doesn’t know that key, and so it won’t miss it when it isn’t there.  It’s just
an example of a key you can use if it helps you, or ignore if not.&lt;/p&gt;

&lt;p&gt;At this point, I could just copy and paste a module reference into my
main module,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;@MAIN.INSERT=
	powercounter @$(PREFIX)i(i_clk, @$(PREFIX)_data);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;assuming I had a module named &lt;code class=&quot;highlighter-rouge&quot;&gt;powercounter&lt;/code&gt;.
We’ll use that approach with a later example in this post for the
special purpose I/O peripheral,
&lt;a href=&quot;https://github.com/ZipCPU/autofpga-demo/blob/master/rtl/spio.v&quot;&gt;spio.v&lt;/a&gt;,&lt;/p&gt;

&lt;p&gt;Instead of doing things that way, though, let’s define a register,
&lt;code class=&quot;highlighter-rouge&quot;&gt;r_pwrcount_data&lt;/code&gt;.  This register declaration will get placed at the top of the
&lt;a href=&quot;https://github.com/ZipCPU/autofpga-demo/blob/master/auto-generated/main.v&quot;&gt;main module&lt;/a&gt;,
before any logic, so that it can be referenced by any logic below.  Before
doing so, though, we’ll replace &lt;code class=&quot;highlighter-rouge&quot;&gt;pwrcount&lt;/code&gt; within that name by our &lt;code class=&quot;highlighter-rouge&quot;&gt;PREFIX&lt;/code&gt;
key, so as to continue the perception of variables with a local scope.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;@MAIN.DEFNS=
	reg	[31:0]	r_@$(PREFIX)_data;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Now we can create the logic that defines this value.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;@MAIN.INSERT=
	initial	r_@$(PREFIX)_data = 32&#39;h0;
	always @(posedge i_clk)
	if (r_@$(PREFIX)_data[31])
		r_@$(PREFIX)_data[30:0] &amp;lt;= r_@$(PREFIX)_data[30:0] + 1&#39;b1;
	else
		r_@$(PREFIX)_data[31:0] &amp;lt;= r_@$(PREFIX)_data[31:0] + 1&#39;b1;
	assign	@$(PREFIX)_data = r_@$(PREFIX)_data;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Note that when we we are done, we set &lt;code class=&quot;highlighter-rouge&quot;&gt;@$(PREFIX)_data&lt;/code&gt; using an assign
statement rather than using &lt;code class=&quot;highlighter-rouge&quot;&gt;r_@$(PREFIX)_data&lt;/code&gt;.  This is simply because
&lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt;
defines the bus variables for you as though you were going to create and
return them via a module–as wires, not registers.&lt;/p&gt;

&lt;h2 id=&quot;getting-the-address-of-the-last-bus-error&quot;&gt;Getting the address of the last bus error&lt;/h2&gt;

&lt;p&gt;In a similar fashion, we can place just about any logic we want within the
&lt;code class=&quot;highlighter-rouge&quot;&gt;@MAIN.INSERT&lt;/code&gt; tag.  Remember,
&lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt;
is primarily a copy and paste utility.  All you need to do is to &lt;a href=&quot;https://github.com/ZipCPU/autofpga-demo/blob/master/auto-data/buserr.txt&quot;&gt;tell it how
to wire your code
up&lt;/a&gt;
to the rest of the
&lt;a href=&quot;https://github.com/ZipCPU/autofpga-demo/blob/master/auto-generated/main.v&quot;&gt;main module&lt;/a&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;@PREFIX=buserr
# ...
@MAIN.DEFNS=
	reg	[@$(SLAVE.BUS.AWID)-1:0]	r_@$(PREFIX)_addr;
@MAIN.INSERT=
	always @(posedge @$(SLAVE.BUS.CLOCK.WIRE))
		if (@$(SLAVE.BUS.NAME)_err)
			r_@$(PREFIX)_addr &amp;lt;= @$(SLAVE.BUS.NAME)_addr;
	assign	@$(PREFIX)_data = { {(@$(SLAVE.BUS.WIDTH)-2-@$(SLAVE.BUS.AWID)){1&#39;b0}},
			r_@$(PREFIX)_addr, 2&#39;b00 };&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This works based upon the fact that there are several wires defined for each
bus.  These wires are all prefixed by the name of the bus and an underscore.
Hence, for the &lt;code class=&quot;highlighter-rouge&quot;&gt;wb&lt;/code&gt; bus, these wires will all have a &lt;code class=&quot;highlighter-rouge&quot;&gt;wb_&lt;/code&gt; prefix.
Since this is a
&lt;a href=&quot;/doc/wbspec_b4.pdf&quot;&gt;wishbone B4 pipelined bus&lt;/a&gt;, all of these
bus master wires will be defined as:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;wire			wb_cyc, wb_stb, wb_we, wb_err, wb_stall,
			wb_none_sel;
reg			wb_many_ack;
wire	[(AW-1):0]	wb_addr;
wire	[(DW-1):0]	wb_data;
reg	[(DW-1):0]	wb_idata;
wire	[(DW/8-1):0]	wb_sel;
reg			wb_ack;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;where &lt;code class=&quot;highlighter-rouge&quot;&gt;AW&lt;/code&gt; is the address width of the bus, and &lt;code class=&quot;highlighter-rouge&quot;&gt;DW&lt;/code&gt; is the data width.
&lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt;
needs to be able to support multiple busses, however, of multiple types.
For this reason, the &lt;code class=&quot;highlighter-rouge&quot;&gt;@SLAVE.BUS&lt;/code&gt; key is expanded into a series of keys:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;@SLAVE.BUS.NAME=wb
@SLAVE.BUS.AWID=16
@SLAVE.BUS.WIDTH=32
@SLAVE.BUS.TYPE=wb
@SLAVE.BUS.CLOCK.NAME=clk
@SLAVE.BUS.CLOCK.WIRE=i_clk
@SLAVE.BUS.CLOCK.FREQUENCY=1000000&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This allows us to reference the bus clock using &lt;code class=&quot;highlighter-rouge&quot;&gt;@$(SLAVE.BUS.CLOCK.WIRE)&lt;/code&gt;,
or even the &lt;code class=&quot;highlighter-rouge&quot;&gt;wb&lt;/code&gt; prefix of the bus as &lt;code class=&quot;highlighter-rouge&quot;&gt;@$(SLAVE.BUS.NAME)&lt;/code&gt;.  This means that
the address width of this slave is given by &lt;code class=&quot;highlighter-rouge&quot;&gt;@$(SLAVE.BUS.AWID)&lt;/code&gt; and the
bus data width is given by &lt;code class=&quot;highlighter-rouge&quot;&gt;@$(SLAVE.BUS.WIDTH)&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;If you find these long key names tedious, you can rename them within your
component.  For example, we could have created a key &lt;code class=&quot;highlighter-rouge&quot;&gt;@CLK&lt;/code&gt; and assigned
it to hold the value of &lt;code class=&quot;highlighter-rouge&quot;&gt;@$(SLAVE.BUS.CLOCK.WIRE)&lt;/code&gt;, another key &lt;code class=&quot;highlighter-rouge&quot;&gt;@AW&lt;/code&gt; and
assigned it to hold the value of &lt;code class=&quot;highlighter-rouge&quot;&gt;@$(SLAVE.BUS.AWID)&lt;/code&gt;, and other keys &lt;code class=&quot;highlighter-rouge&quot;&gt;@BS&lt;/code&gt;
and &lt;code class=&quot;highlighter-rouge&quot;&gt;@DW&lt;/code&gt; as in,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;@CLK= @$(SLAVE.BUS.CLOCK.WIRE)
@AW= @$(SLAVE.BUS.AWID)
@BS= @$(SLAVE.BUS.NAME)
@DW= @$(SLAVE.BUS.WIDTH)&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Had we done so, our &lt;code class=&quot;highlighter-rouge&quot;&gt;@MAIN.DEFNS&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;@MAIN.INSERT&lt;/code&gt; tag might have been
simplified to&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;@MAIN.DEFNS=
	reg	[@$(AW)-1:0]	r_@$(PREFIX)_addr;
@MAIN.INSERT=
	always @(posedge @$(CLK))
		if (@$(BN)_err)
			r_@$(PREFIX)_addr &amp;lt;= @$(BN)_addr;
	assign	@$(PREFIX)_data = { {(@$(DW)-2-@$(AW)){1&#39;b0}},
			r_@$(PREFIX)_addr, 2&#39;b00 };&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;What this particular configuration file does different from our previous
examples is to reference information about the &lt;em&gt;bus&lt;/em&gt; using the keys defined
for any bus.  This allows the bus error address register, defined above, to
only have as many bits defined as necessary
(one for each address line, or &lt;code class=&quot;highlighter-rouge&quot;&gt;@$(AW)&lt;/code&gt;).  Not only will this register size
be adjusted if the width of the address bus is adjusted, but it will also
be adjusted if the width of the data bus is adjusted–as illustrated by the
&lt;code class=&quot;highlighter-rouge&quot;&gt;@$(PREFIX)_data&lt;/code&gt;’s dependence upon both &lt;code class=&quot;highlighter-rouge&quot;&gt;@$(DW)&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;@$(AW)&lt;/code&gt;.  Had we worked
a little harder, we might’ve also set up the trailing two zero bits to
expand as necessary with any changing data width.&lt;/p&gt;

&lt;h2 id=&quot;write-support-for-the-same-value&quot;&gt;Write support for the same value&lt;/h2&gt;

&lt;p&gt;Now that you know how to read a value from the bus, what about writing to
registers on the bus?&lt;/p&gt;

&lt;p&gt;The &lt;a href=&quot;https://github.com/ZipCPU/autofpga-demo/blob/master/auto-data/rawreg.txt&quot;&gt;raw register configuration
file&lt;/a&gt;
shows how this might be done.  This example peripheral does nothing but set
a value you give to it upon any write, and then allow you to read that value
back later.&lt;/p&gt;

&lt;p&gt;In many ways, this peripheral is almost identical to the &lt;a href=&quot;&quot;&gt;power counter
component&lt;/a&gt;
we discussed earlier.  The difference is that this register can be set via
a bus write.  For this reason, the boiler plate setup is almost identical.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;@PREFIX=rawreg
@DEVID=RAWREG
@NADDR=1
@SLAVE.TYPE=SINGLE
@SLAVE.BUS=wb
@REGS.N=1
@REGS.0= 0 R_@$(DEVID) @$(DEVID)
@MAIN.DEFNS=
	reg	[31:0]	r_@$(PREFIX)_data;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The difference is found within the &lt;code class=&quot;highlighter-rouge&quot;&gt;@MAIN.INSERT&lt;/code&gt; tag describing how this
peripheral deals with the bus.  In this case, for any bus access, &lt;code class=&quot;highlighter-rouge&quot;&gt;wb_stb&lt;/code&gt;,
that is also a write, &lt;code class=&quot;highlighter-rouge&quot;&gt;wb_we&lt;/code&gt;, and that references this peripheral,
&lt;code class=&quot;highlighter-rouge&quot;&gt;@$(PREFIX)_sel&lt;/code&gt;, we update our register.  (Remember how a &lt;a href=&quot;/zipcpu/2017/05/29/simple-wishbone.html&quot;&gt;generic wishbone
slave interacts with the bus&lt;/a&gt;?)&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;@MAIN.INSERT=
	initial	r_@$(PREFIX)_data = 32&#39;h0;
	always @(posedge i_clk)
		if ((wb_stb)&amp;amp;&amp;amp;(wb_we)&amp;amp;&amp;amp;(@$(PREFIX)_sel))
			r_@$(PREFIX)_data &amp;lt;= wb_data;
	assign	@$(PREFIX)_data = r_@$(PREFIX)_data;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;We could have made this module more generic by replacing the
&lt;code class=&quot;highlighter-rouge&quot;&gt;wb&lt;/code&gt; prefixes with &lt;code class=&quot;highlighter-rouge&quot;&gt;@$(SLAVE.BUS.NAME)&lt;/code&gt;.  Had we done that, we would have then
been able to use this across busses with different names.  For now, because
of how we’ve defined this, this component will always only ever read
it’s values from the bus with a &lt;code class=&quot;highlighter-rouge&quot;&gt;wb_&lt;/code&gt; prefix.&lt;/p&gt;

&lt;h2 id=&quot;reading-values-from-external-ports&quot;&gt;Reading values from external ports&lt;/h2&gt;

&lt;p&gt;Let’s look at &lt;a href=&quot;https://github.com/ZipCPU/autofpga-demo/blob/master/auto-data/spio.txt&quot;&gt;one more
example&lt;/a&gt;
along this same theme.  Suppose we wanted to add to our design a register
allowing us to:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Read from the buttons in our design&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Read from any switches on our board&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Set any output LED’s&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Unlike our previous examples, this example will require access to I/O
ports within our design, so we’ll have to deal with this when we get there.&lt;/p&gt;

&lt;p&gt;We’ll start with the keys we’ve already defined above.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;@PREFIX=spio
@NADDR=1
@DEVID=SPIO
@SLAVE.TYPE=SINGLE
@SLAVE.BUS=wb
@REGS.N=1
@REGS.0= 0 R_@$(DEVID)		@$(DEVID)&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Now let’s walk through the new keys.&lt;/p&gt;

&lt;p&gt;The first of these new keys is an &lt;code class=&quot;highlighter-rouge&quot;&gt;@ACCESS&lt;/code&gt; key.  It’s an optional key, as you
can tell from the fact none of our other components above had this key.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;@ACCESS=SPIO_ACCESS&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This &lt;code class=&quot;highlighter-rouge&quot;&gt;@ACCESS&lt;/code&gt; key, if present, will create a &lt;code class=&quot;highlighter-rouge&quot;&gt;define&lt;/code&gt; line at the beginning
of our
&lt;a href=&quot;https://github.com/ZipCPU/autofpga-demo/blob/master/auto-generated/main.v&quot;&gt;main.v&lt;/a&gt;
file.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;`define	SPIO_ACCESS&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The &lt;a href=&quot;https://github.com/ZipCPU/autofpga-demo/blob/master/rtl/Makefile&quot;&gt;RTL
Makefile&lt;/a&gt;
then includes instructions to copy this line from the
&lt;a href=&quot;https://github.com/ZipCPU/autofpga-demo/blob/master/auto-generated/main.v&quot;&gt;main.v&lt;/a&gt;
file into a
&lt;a href=&quot;https://github.com/ZipCPU/autofpga-demo/blob/master/rtl/design.h&quot;&gt;design.h&lt;/a&gt;
file, allowing any associated C++ files to know whether or not this component
is a part of our design.&lt;/p&gt;

&lt;p&gt;The next new key is the &lt;code class=&quot;highlighter-rouge&quot;&gt;@MAIN.PORTLIST&lt;/code&gt; key.  This key specifies values to be
placed at the top of
&lt;a href=&quot;https://github.com/ZipCPU/autofpga-demo/blob/master/auto-generated/main.v&quot;&gt;main.v&lt;/a&gt;
within the portlist for the
&lt;a href=&quot;https://github.com/ZipCPU/autofpga-demo/blob/master/auto-generated/main.v&quot;&gt;main module&lt;/a&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;@MAIN.PORTLIST=
		// @$(DEVID) interface
		i_sw, i_btnc, i_btnd, i_btnl, i_btnr, i_btnu, o_led&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This key is unique in that the items within it are separated by commas,
but that the last item has no comma following it.  This allows
&lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt;
to put a comma between items, or not, as is necessary to compose
multiple component I/Os into a design.&lt;/p&gt;

&lt;p&gt;Immediately following the
&lt;a href=&quot;https://github.com/ZipCPU/autofpga-demo/blob/master/auto-generated/main.v&quot;&gt;main module&lt;/a&gt; declaration
is an opportunity to place parameters.  Let’s identify that this particular
design has five buttons, 8 LED’s, and 8 switches.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;@MAIN.PARAM=
	// @$(DEVID) interface
	localparam	NBTN=5,
			NLEDS=8,
			NSW=8;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Following any &lt;code class=&quot;highlighter-rouge&quot;&gt;@MAIN.PARAM&lt;/code&gt; values, you can declare your I/O values.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;@MAIN.IODECL=
	input	wire	[(NSW-1):0]	i_sw;
	input	wire		i_btnc, i_btnd, i_btnl, i_btnr, i_btnu;
	output	wire	[(NLEDS-1):0]	o_led;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;As with so many other keys, these values will simply be pasted into the
&lt;a href=&quot;https://github.com/ZipCPU/autofpga-demo/blob/master/auto-generated/main.v&quot;&gt;main.v&lt;/a&gt;
file following any key-value substitutions.&lt;/p&gt;

&lt;p&gt;In a like manner to the way we’ve defined variables before, we’ll define a
five valued logic vector to hold the inputs from each of our button values.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;@MAIN.DEFNS=
	wire	[(NBTN-1):0]	w_btn;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This will get placed with all of the wire and register declarations at the
top of the
&lt;a href=&quot;https://github.com/ZipCPU/autofpga-demo/blob/master/auto-generated/main.v&quot;&gt;main.v&lt;/a&gt;
file.&lt;/p&gt;

&lt;p&gt;The next required piece is the &lt;code class=&quot;highlighter-rouge&quot;&gt;@MAIN.INSERT&lt;/code&gt; key, telling
&lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt;
how we are going to interact with the bus.  In this case, we’ll compose
our five buttons into a quick vector, and then reference a special purpose
I/O module I call
&lt;a href=&quot;https://github.com/ZipCPU/autofpga-demo/blob/master/rtl/spio.v&quot;&gt;spio.v&lt;/a&gt;.
This module handles bus writes and bus reads, and is a generic
&lt;a href=&quot;/doc/wbspec_b4.pdf&quot;&gt;wishbone&lt;/a&gt;
peripheral.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;@MAIN.INSERT=
	assign	w_btn = { i_btnc, i_btnd, i_btnl, i_btnr, i_btnu };

	spio #(.NBTN(NBTN), .NLEDS(NLEDS), .NSW(NSW)) @$(PREFIX)i(i_clk,
		wb_cyc, (wb_stb)&amp;amp;&amp;amp;(@$(PREFIX)_sel), wb_we, wb_data, wb_sel,
			@$(PREFIX)_ack, @$(PREFIX)_stall, @$(PREFIX)_data,
		i_sw, w_btn, o_led, spio_int);
@MAIN.ALT=
	assign	w_btn    = 0;
	assign	o_led    = 0;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Since this is a generic peripheral, it needs to return
&lt;code class=&quot;highlighter-rouge&quot;&gt;@$(PREFIX)_ack&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;@$(PREFIX)_stall&lt;/code&gt; values–even though we’ll ignore
them since this is peripheral has a &lt;code class=&quot;highlighter-rouge&quot;&gt;SINGLE&lt;/code&gt; bus interaction type.&lt;/p&gt;

&lt;p&gt;The new key that we haven’t discussed yet is the &lt;code class=&quot;highlighter-rouge&quot;&gt;@MAIN.ALT&lt;/code&gt; key.  This
key defines the logic that will be used in the case the &lt;code class=&quot;highlighter-rouge&quot;&gt;@ACCESS&lt;/code&gt; component
defining &lt;code class=&quot;highlighter-rouge&quot;&gt;SPIO_ACCESS&lt;/code&gt; is not defined.  Items within this keyword
are used for defining values external ports, such as &lt;code class=&quot;highlighter-rouge&quot;&gt;o_led&lt;/code&gt;, should be
given should the primary logic for this component not be used.&lt;/p&gt;

&lt;p&gt;This component contains one last tag, &lt;code class=&quot;highlighter-rouge&quot;&gt;@INT.SPIO.WIRE&lt;/code&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;@INT.SPIO.WIRE=spio_int&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This tag identifies that &lt;code class=&quot;highlighter-rouge&quot;&gt;spio_int&lt;/code&gt; is a single wire, and that it may be
assigned to an interrupt vector as the interrupt generated by this peripheral.&lt;/p&gt;

&lt;p&gt;Feel free to take a look at the
&lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt;
generated
&lt;a href=&quot;https://github.com/ZipCPU/autofpga-demo/blob/master/auto-generated/main.v&quot;&gt;main.v&lt;/a&gt;
file and see how we did!&lt;/p&gt;

&lt;h2 id=&quot;more-to-come&quot;&gt;More to come!&lt;/h2&gt;

&lt;p&gt;The goal of
&lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt;
was to be able to have a simple command line interface–simply run
&lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt;
with a list of peripherals, and get output files.  You might wish to test
this by &lt;a href=&quot;https://github.com/ZipCPU/autofpga-demo/blob/master/auto-data/Makefile&quot;&gt;removing any of the above
files&lt;/a&gt;
from the &lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt;
command line to see how well we did, or even add some configuration files
of your own.&lt;/p&gt;

&lt;p&gt;If you choose to try this, you’ll notice that the
&lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/autofpga-demo&quot;&gt;demo project&lt;/a&gt;
contains more configuration files than the ones we’ve looked at today.
These are the &lt;a href=&quot;https://github.com/ZipCPU/autofpga-demo/blob/master/auto-data/bkram.txt&quot;&gt;block RAM configuration
file&lt;/a&gt;,
the &lt;a href=&quot;https://github.com/ZipCPU/autofpga-demo/blob/master/auto-data/clock.txt&quot;&gt;clock
file&lt;/a&gt;
that defines the clock and the reset wires,
the &lt;a href=&quot;https://github.com/ZipCPU/autofpga-demo/blob/master/auto-data/hexbus.txt&quot;&gt;debugging bus configuration
file&lt;/a&gt;,
and a &lt;a href=&quot;https://github.com/ZipCPU/autofpga-demo/blob/master/auto-data/global.txt&quot;&gt;global
configuration&lt;/a&gt;
file. Of these, only the &lt;a href=&quot;https://github.com/ZipCPU/autofpga-demo/blob/master/auto-data/bkram.txt&quot;&gt;block RAM configuration
file&lt;/a&gt;
may be easily removed.  The &lt;a href=&quot;https://github.com/ZipCPU/autofpga-demo/blob/master/auto-data/hexbus.txt&quot;&gt;debugging bus configuration
file&lt;/a&gt;
defines our bus master, and a bus doesn’t work very well without a master, so it
would make more sense to replace that one than to remove it if you wish to
change it.  The
&lt;a href=&quot;https://github.com/ZipCPU/autofpga-demo/blob/master/auto-data/clock.txt&quot;&gt;clock file&lt;/a&gt;
and &lt;a href=&quot;https://github.com/ZipCPU/autofpga-demo/blob/master/auto-data/global.txt&quot;&gt;global
configuration&lt;/a&gt; file are not as easily replaced.&lt;/p&gt;

&lt;p&gt;So, let’s come back and discuss the &lt;a href=&quot;https://github.com/ZipCPU/autofpga-demo/blob/master/auto-data/bkram.txt&quot;&gt;block RAM configuration
file&lt;/a&gt;
at a later time.  Specifically, you’ll love how easy it is to change the
size of the &lt;a href=&quot;https://github.com/ZipCPU/autofpga-demo/blob/master/rtl/memdev.v&quot;&gt;block RAM&lt;/a&gt;, and how well that size information is propagated throughout a
&lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt;-based design.&lt;/p&gt;

&lt;p&gt;We’ll also need to come back later to discuss how a
&lt;a href=&quot;/about/wbspec_b4.pdf&quot;&gt;wishbone bus&lt;/a&gt;
&lt;a href=&quot;/blog/2017/06/08/simple-wb-master.html&quot;&gt;master&lt;/a&gt;
can be connected using
&lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Until that time, our
&lt;a href=&quot;https://github.com/ZipCPU/autofpga-demo/&quot;&gt;demonstration project&lt;/a&gt;
plus this article should be enough to build and control most beginning
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
tasks.  Even better, and unlike most proprietary solutions, all of the code
&lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt;
builds is availble for your inspection and learning pleasure.&lt;/p&gt;

&lt;hr /&gt;&lt;p&gt;&lt;em&gt;He answered and said, Whether he be a sinner or no, I know not: one thing I know, that, whereas I was blind, now I see&lt;/em&gt;</description>
        <pubDate>Fri, 06 Oct 2017 00:00:00 -0400</pubDate>
        <link>http://zipcpu.com/zipcpu/2017/10/06/autofpga-dataword.html</link>
        <guid isPermaLink="true">http://zipcpu.com/zipcpu/2017/10/06/autofpga-dataword.html</guid>
        
        
        <category>zipcpu</category>
        
      </item>
    
      <item>
        <title>A Brief Introduction to AutoFPGA</title>
        <description>&lt;p&gt;You may have heard about
&lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt;.  Perhaps you’ve found it on
&lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;github&lt;/a&gt;.  Perhaps you’ve read about it
on my &lt;a href=&quot;/projects.html&quot;&gt;projects&lt;/a&gt; page.  Perhaps you had a
chance to hear me &lt;a href=&quot;https://github.com/ZipCPU/autofpga/blob/master/doc/orconf17.pdf&quot;&gt;describe it
at&lt;/a&gt;
&lt;a href=&quot;https://orconf.org&quot;&gt;ORCONF, 2017&lt;/a&gt; or looked over
&lt;a href=&quot;https://github.com/ZipCPU/autofpga/blob/master/doc/orconf17.pdf&quot;&gt;my slides&lt;/a&gt;.
It only seems fitting that I should share it with my readers
&lt;a href=&quot;http://zipcpu.com/&quot;&gt;here&lt;/a&gt; as well.&lt;/p&gt;

&lt;p&gt;Today, therefore, I’d like to discuss why I created
&lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt;, and some of the problems with
the alternatives.  I’ll briefly discuss the goals of
&lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt;, and the license it is released
under.  When done, I’ll discuss a &lt;a href=&quot;https://github.com/ZipCPU/autofpga-demo&quot;&gt;new
project&lt;/a&gt; I just created based upon 
&lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt;, which I’m hoping to use in the
future to explain how
&lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt; works.&lt;/p&gt;

&lt;h2 id=&quot;why-autofpga--the-backstory&quot;&gt;Why AutoFPGA?  The backstory&lt;/h2&gt;

&lt;p&gt;I started working on
&lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt;
after creating several independent
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; based projects, and getting
annoyed that it felt like I kept rebuilding the wheel.  Each project needed
to have a bus designed for it, it needed to have interrupts defined and
assigned, peripherals needed to be integrated, and all these things changed
from project to project.&lt;/p&gt;

&lt;p&gt;Perhaps an overview of these projects might help make this clear.&lt;/p&gt;

&lt;p&gt;The first &lt;a href=&quot;/doc/wbspec_b4.pdf&quot;&gt;wishbone&lt;/a&gt; based project I
worked on was based around &lt;a href=&quot;https://store.digilentinc.com&quot;&gt;Digilent&lt;/a&gt;’s
&lt;a href=&quot;https://store.digilentinc.com/basys-3-artix-7-fpga-trainer-board-recommended-for-introductory-users/&quot;&gt;Basys3&lt;/a&gt;
board.  You can see the basic outline of the project in Fig 1, from before
I added the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; to it.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 1: Basys 3 design&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/basys3.svg&quot; alt=&quot;Basys3 Design outline&quot; width=&quot;480&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;My purpose was to learn about how to do hardware design &lt;em&gt;on my own&lt;/em&gt;, without
the office support team that I had when I first started learning
hardware design.  You know, the difference between relying on the experience
of other members of your team, versus needing to have that experience yourself?&lt;/p&gt;

&lt;p&gt;Since it was my first design as part of
&lt;a href=&quot;/about/gisselquist-technology.html&quot;&gt;Gisselquist Technology&lt;/a&gt;,
there were a lot of new parts and pieces.  To highlight this new work, I’ve
outlined it in blue within Fig 1 above.  Basically everything was new.&lt;/p&gt;

&lt;p&gt;It was on the
&lt;a href=&quot;https://store.digilentinc.com/basys-3-artix-7-fpga-trainer-board-recommended-for-introductory-users/&quot;&gt;Basys3&lt;/a&gt;
that I first built a
&lt;a href=&quot;https://opencores.org/project,qspiflash&quot;&gt;flash controller&lt;/a&gt;,
a &lt;a href=&quot;https://github.com/ZipCPU/wbuart32&quot;&gt;UART&lt;/a&gt;, a VGA controller, and much more.
Eventually, I built the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
on the
&lt;a href=&quot;https://store.digilentinc.com/basys-3-artix-7-fpga-trainer-board-recommended-for-introductory-users/&quot;&gt;Basys3&lt;/a&gt;,
even though it’s not shown in Fig 1.&lt;/p&gt;

&lt;p&gt;However, I wanted to try working on a
&lt;a href=&quot;https://github.com/ZipCPU/xulalx25soc&quot;&gt;project&lt;/a&gt; that required an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
with a small form factor.  Previous designs I had worked on involved both a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;
and an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
working together, and I was curious to know if I could do all of the work
within a bigger
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;I considered the
&lt;a href=&quot;https://store.digilentinc.com/cmod-s6-breadboardable-spartan-6-fpga-module&quot;&gt;CMod S6&lt;/a&gt;,
but ultimately chose to try
&lt;a href=&quot;http://www.xess.com&quot;&gt;Xess.com&lt;/a&gt;’s
&lt;a href=&quot;http://www.xess.com/shop/product/xula2-lx25&quot;&gt;XuLA2-LX25&lt;/a&gt;
board. (I bought the &lt;a href=&quot;https://store.digilentinc.com/cmod-s6-breadboardable-spartan-6-fpga-module&quot;&gt;CMod
S6&lt;/a&gt;
later.)  The &lt;a href=&quot;http://www.xess.com/shop/product/xula2-lx25&quot;&gt;XuLA2-LX25&lt;/a&gt;
had more capability, more logic within its
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;,
had an &lt;a href=&quot;https://en.wikipedia.org/wiki/Secure_Digital&quot;&gt;SD card&lt;/a&gt; socket, and
even &lt;a href=&quot;https://en.wikipedia.org/wiki/Synchronous_dynamic_random-access_memory&quot;&gt;SDRAM
memory&lt;/a&gt;.
In the end,
&lt;a href=&quot;https://github.com/ZipCPU/xulalx25soc&quot;&gt;the design&lt;/a&gt; looked something like Fig 2.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 2: XuLA2 LX25 SoC Design&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/xula.svg&quot; alt=&quot;XuLA2-LX25 SoC Design outline&quot; width=&quot;480&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;You can still find the &lt;a href=&quot;https://github.com/ZipCPU/xulalx25soc&quot;&gt;project
here&lt;/a&gt;, should you be interested in it.
It does contain an
&lt;a href=&quot;https://github.com/ZipCPU/xulalx25soc/blob/master/sdspi.v&quot;&gt;SD-Card controller&lt;/a&gt;,
and an &lt;a href=&quot;https://github.com/ZipCPU/xulalx25soc/blob/master/wbsdram.v&quot;&gt;SDRAM
controller&lt;/a&gt;.
You can see the other components of the design in Fig 2 above.
It was the first full project that I released under an open-source license.
(Unfortunately, it’s poorly documented, despite documentation existing for all
the components.)&lt;/p&gt;

&lt;p&gt;The good news was that, when building the
&lt;a href=&quot;https://github.com/ZipCPU/xulalx25soc&quot;&gt;XuLA project&lt;/a&gt;, I
was able to re-use a lot of the components I had initially built for
my &lt;a href=&quot;https://store.digilentinc.com/basys-3-artix-7-fpga-trainer-board-recommended-for-introductory-users/&quot;&gt;Basys3&lt;/a&gt;.  Still, looking at the amount of stuff
in blue, there was still a lot of work involved in building the new design.&lt;/p&gt;

&lt;p&gt;I also decided to toy around with the idea of seeing if I could
“broadcast” on a local &lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency_modulation&quot;&gt;FM&lt;/a&gt;
channel using the board, as I had &lt;a href=&quot;https://www.raspberrypi.org/magpi/raspberry-pi-fm-transmitter&quot;&gt;seen a friend
do&lt;/a&gt; with
his &lt;a href=&quot;https://www.raspberrypi.org/&quot;&gt;Raspberry Pi&lt;/a&gt;.  (It’s always fun to one-up
a &lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt; developer with
your &lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
design.) So, I created an
&lt;a href=&quot;https://github.com/ZipCPU/wbfmtx&quot;&gt;WB FM transmitter hack&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;While the &lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency_modulation&quot;&gt;FM&lt;/a&gt; transmission
approach worked like a charm, integrating it into
&lt;a href=&quot;https://github.com/ZipCPU/xulalx25soc&quot;&gt;the project&lt;/a&gt; on
a whim and then taking it out later was pretty annoying.  There was a lot
of work involved, and several files that needed to be changed, and did I get
it all done properly?  I think you get the idea.  If that wasn’t bad enough,
what if I wanted to try the design again later, or demonstrate it for others?&lt;/p&gt;

&lt;p&gt;When it was time to move forward with my next design, I wanted to try building
something in an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;,
logic limited environment–just to prove that the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
would work on one of the &lt;em&gt;small architectures&lt;/em&gt; it had been built for.
Could it really fit in the smallest
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
development board I could find?  So, I bought a &lt;a href=&quot;https://store.digilentinc.com/cmod-s6-breadboardable-spartan-6-fpga-module&quot;&gt;CMod
S6&lt;/a&gt;
featuring a
Spartan 6LX4–the smallest
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
that &lt;a href=&quot;https://www.xilinx.com&quot;&gt;Xilinx&lt;/a&gt; sells in its the Spartan 6 line.
The challenge with this design was to make something &lt;em&gt;small&lt;/em&gt;.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 3: S6-SoC Design&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/s6soc.svg&quot; alt=&quot;Outline of the S6SoC&quot; width=&quot;480&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;For &lt;a href=&quot;https://github.com/ZipCPU/s6soc&quot;&gt;this project&lt;/a&gt;, I was able to reuse a lot
of the components I had already built.  Looking in Fig 3, you’ll see only a
small amount of development outlined in blue.  The biggest challenge to the
&lt;a href=&quot;https://github.com/ZipCPU/s6soc&quot;&gt;design&lt;/a&gt; was both building the bus logic, and
keeping everything small.&lt;/p&gt;

&lt;p&gt;This was also the first
&lt;a href=&quot;https://github.com/ZipCPU/s6soc&quot;&gt;project&lt;/a&gt; I ever built with time-slicing,
but that’s another story.&lt;/p&gt;

&lt;p&gt;Since I had never worked with
&lt;a href=&quot;https://opencores.org/project,wbddr3&quot;&gt;DDR3 SDRAM&lt;/a&gt; before,
I chose to work with
&lt;a href=&quot;https://store.digilentinc.com&quot;&gt;Digitlent&lt;/a&gt;’s
&lt;a href=&quot;https://store.digilentinc.com/arty-artix-7-fpga-development-board-for-makers-and-hobbyists/&quot;&gt;Arty&lt;/a&gt;
for my next project so that I might learn about it.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 4: OpenArty Design Overview&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/openarty.svg&quot; alt=&quot;Outline of the S6SoC&quot; width=&quot;480&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;The majority of the new work in this design was for the ethernet, the
&lt;a href=&quot;https://opencores.org/project,wbddr3&quot;&gt;DDR3 SDRAM&lt;/a&gt; controller,
the &lt;a href=&quot;https://github.com/ZipCPU/openarty/blob/master/rtl/wboled.v&quot;&gt;OLEDrgb&lt;/a&gt;,
and the &lt;a href=&quot;https://github.com/ZipCPU/openarty/blob/master/rtl/busmaster.v&quot;&gt;bus&lt;/a&gt;
(&lt;em&gt;again&lt;/em&gt;).  (Eventually, I had to shelve
&lt;a href=&quot;https://opencores.org/project,wbddr3&quot;&gt;DDR3 SDRAM&lt;/a&gt; controller, choosing instead
to use a &lt;a href=&quot;https://github.com/ZipCPU/wb2axip&quot;&gt;Wishbone to AXI4 bridge&lt;/a&gt;.
There was also a lot of work to raise the clock speed to 200MHz, but since
the &lt;a href=&quot;https://www.xilinx.com&quot;&gt;Xilinx&lt;/a&gt; MIG core could only run at 82MHz on the
&lt;a href=&quot;https://store.digilentinc.com/arty-artix-7-fpga-development-board-for-makers-and-hobbyists/&quot;&gt;Arty&lt;/a&gt;,
this work was shelved.)&lt;/p&gt;

&lt;p&gt;When it came time to build an
&lt;a href=&quot;https://en.wikipedia.org/wiki/HDMI&quot;&gt;HDMI video&lt;/a&gt;
processor, I chose to use the
&lt;a href=&quot;https://store.digilentinc.com/nexys-video-artix-7-fpga-trainer-board-for-multimedia-applications/&quot;&gt;Nexys Video&lt;/a&gt;.
By this point in time, I had finally had enough of rebuilding the wheel on
every design.&lt;/p&gt;

&lt;p&gt;For every design up until that point, I had &lt;em&gt;hand-crafted&lt;/em&gt; an interconnect to
connect all the components into the design.  (This is the horizontal blue line
in each of the figures above.)  This interconnect would connect
components to an internal &lt;a href=&quot;/doc/wbspec_b4.pdf&quot;&gt;Wishbone
bus&lt;/a&gt;, and it would connect interrupts
together from the various peripheral components to one of a couple of interrupt
controllers.  You can see examples of my interconnects for the &lt;a href=&quot;https://github.com/ZipCPU/xulalx25soc/blob/master/busmaster.v&quot;&gt;XuLA2-LX25
here&lt;/a&gt;,
the &lt;a href=&quot;https://github.com/ZipCPU/s6soc/blob/master/busmaster.v&quot;&gt;CMod S6 here&lt;/a&gt;,
and the &lt;a href=&quot;https://github.com/ZipCPU/openarty/blob/master/busmaster.v&quot;&gt;Arty here&lt;/a&gt;.
Addresses needed to be assigned, interrupts needed to be assigned,
they both needed to be documented, and these things were just taking too much
of my time.&lt;/p&gt;

&lt;p&gt;To make matters worse, anytime I adjusted the number of addresses a specific
peripheral might require, I might need to adjust its location in the address
space I was creating.  This made for a lot of work.  As you may recall, I
like to access my designs via a &lt;a href=&quot;/blog/2017/06/16/dbg-bus/forest.html&quot;&gt;bus based external controller from
software&lt;/a&gt;,
and that &lt;a href=&quot;/blog/2017/06/29/sw-dbg-interface.html&quot;&gt;software needs to know where things are located on the
bus&lt;/a&gt;.
The &lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt; also needs to know not only
where things are located on the bus, but &lt;em&gt;if&lt;/em&gt; particular peripherals are a
part of the design or not.&lt;/p&gt;

&lt;p&gt;I’ve already discussed how annoying this was when (temporarily) integrating
the &lt;a href=&quot;https://github.com/ZipCPU/wbfmtx&quot;&gt;FM transmitter hack&lt;/a&gt; into my
&lt;a href=&quot;https://github.com/ZipCPU/xulalx25soc&quot;&gt;XuLA2-LX25 SoC design&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The need for a reconfiguration assistant also came up when I was working on my
&lt;a href=&quot;https://en.wikipedia.org/wiki/HDMI&quot;&gt;HDMI video&lt;/a&gt; design.  At the time, I was
struggling to understand what was going on within my (broken)
&lt;a href=&quot;https://en.wikipedia.org/wiki/HDMI&quot;&gt;HDMI video&lt;/a&gt; stream.  I had decided that
I needed to capture some of the video stream to block RAM via a
&lt;a href=&quot;https://github.com/ZipCPU/wbscope&quot;&gt;wishbone scope&lt;/a&gt;, after which I was going to
read the results back to find out what was going wrong with my design.  The
problem with this was that video is a memory hog.  Therefore, my
&lt;a href=&quot;https://github.com/ZipCPU/wbscope&quot;&gt;wishbone scope&lt;/a&gt; needed a large block RAM.
This meant that I needed to adjust the size of the block RAM that the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt;
was using.  This necessitated changing the bus interconnect, the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt; loader, the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/sw/board/board.ld&quot;&gt;linker script&lt;/a&gt;,
the &lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/sim/verilated/main_tb.cpp&quot;&gt;simulation
driver&lt;/a&gt;
that will load the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt;
into simulated memory, and more—and all of this just to
get the results of a one-time Video capture test.&lt;/p&gt;

&lt;p&gt;This was why I wanted a capability like
&lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt;.
&lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt; simplifies the number of
changes that need to be made to a design when reconfiguring it, working
like a secretary (not a designer) to automatically connect things together,
and then let you know what it did.&lt;/p&gt;

&lt;h2 id=&quot;lessons-from-other-aggregators&quot;&gt;Lessons from Other Aggregators&lt;/h2&gt;

&lt;p&gt;I think &lt;a href=&quot;/blog/2017/05/17/welcome.html&quot;&gt;I’ve mentioned that I’ve spent a lot of time answering
questions&lt;/a&gt; on
&lt;a href=&quot;https://store.digilentinc.com&quot;&gt;Digilent&lt;/a&gt;’s
&lt;a href=&quot;https://forum.digilentinc.com&quot;&gt;forums&lt;/a&gt;.
Many students will come to the &lt;a href=&quot;https://forum.digilentinc.com&quot;&gt;forum&lt;/a&gt;
declaring that they want to build a design
in &lt;em&gt;&lt;a href=&quot;https://www.xilinx.com/products/design-tools/vivado.html&quot;&gt;Vivado&lt;/a&gt;&lt;/em&gt;,
but what they really mean is that they want to build a design using the
graphical design method
&lt;a href=&quot;https://www.xilinx.com/products/design-tools/vivado.html&quot;&gt;Vivado&lt;/a&gt; supports.
Interacting with these individuals has given me a lot of insight into the
problems many students are struggling with as they work to create (and debug)
their own designs.
From my standpoint, it seems like the biggest problem these new
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
students are struggling with &lt;em&gt;is&lt;/em&gt; the graphical design flow that they are so
eager to learn.&lt;/p&gt;

&lt;p&gt;Why is this?&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;The design flow &lt;em&gt;hides&lt;/em&gt; a lot of configuration detail.  It allows you to
connect blocks together, but yet each block needs a lot of internal
configuration that isn’t immediately visible once configured.  It takes a
bit of digging to even get at this configuration information.&lt;/p&gt;

    &lt;p&gt;As an example, I just recently helped one individual who was struggling to
get his &lt;a href=&quot;https://en.wikipedia.org/wiki/HDMI&quot;&gt;HDMI video&lt;/a&gt; data lined up with
his clock.  (He didn’t realize this was his problem until it was fixed.)
The particular configurations necessary were hidden within both
the SelectIO wizard and the clocking wizard, but neither wizard made the
users choices available upon a cursory view of the project.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The design flows aren’t textual.  You can’t do a “diff” between two designs.&lt;/p&gt;

    &lt;p&gt;This makes it hard to answer the question of “how is my design different
from the example/reference design.”&lt;/p&gt;

    &lt;p&gt;Indeed, I was actually rather surprised, when I
&lt;a href=&quot;https://github.com/ZipCPU/autofpga/blob/master/doc/orconf17.pdf&quot;&gt;presented&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt;
at &lt;a href=&quot;https://orconf.org&quot;&gt;ORCONF&lt;/a&gt; this year
that I got cheers when I declared the whole processing flow to be
“textual”, and said that you could run it from within a
&lt;a href=&quot;https://www.gnu.org/software/make/&quot;&gt;Makefile&lt;/a&gt;.  (The same audience groaned
during another presentation, when that presenter explained that his tool
&lt;em&gt;only&lt;/em&gt; had a &lt;a href=&quot;https://en.wikipedia.org/wiki/Graphical_user_interface&quot;&gt;Graphical User Interface
(GUI)&lt;/a&gt;.)&lt;/p&gt;

    &lt;p&gt;I guess I hadn’t realized how much of a drag many of the modern graphical
tools were becoming to the professional designer.
This may be because
&lt;a href=&quot;https://en.wikipedia.org/wiki/Graphical_user_interface&quot;&gt;GUI&lt;/a&gt;’s tend to
start up slowly.  It may be because
&lt;a href=&quot;https://en.wikipedia.org/wiki/Graphical_user_interface&quot;&gt;GUI&lt;/a&gt;’s tend to
limit your design options to the
&lt;a href=&quot;https://www.blueletterbible.org/kjv/mat/7/13&quot;&gt;road most people travel upon&lt;/a&gt;.
However, for me the problem is twofold:  First, a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Graphical_user_interface&quot;&gt;GUI&lt;/a&gt;
forces me to slow down and use a mouse.  Second, building a design can take
a lot of work: I like the option of using
&lt;a href=&quot;https://www.gnu.org/software/make/&quot;&gt;make&lt;/a&gt; to build &lt;em&gt;only&lt;/em&gt; those portions
of the design that have changed.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;It isn’t clear how to place a scope or a probe into such a design, to see
and understand what is going on within it.  For example, if you have
component &lt;code class=&quot;highlighter-rouge&quot;&gt;A&lt;/code&gt; connected to component &lt;code class=&quot;highlighter-rouge&quot;&gt;B&lt;/code&gt;, and the output of component &lt;code class=&quot;highlighter-rouge&quot;&gt;B&lt;/code&gt;
is somehow wrong, how shall you know which of the two is
misconfigured?&lt;/p&gt;

    &lt;p&gt;Going back to the individual struggling to get
&lt;a href=&quot;https://en.wikipedia.org/wiki/HDMI&quot;&gt;HDMI video&lt;/a&gt; working, he didn’t have
any clear locations within his design where he could &lt;a href=&quot;/blog/2017/06/08/simple-scope.html&quot;&gt;create a tap and
see the problem&lt;/a&gt;.&lt;/p&gt;

    &lt;p&gt;Sure, he could examine some wires via
&lt;a href=&quot;https://www.xilinx.com&quot;&gt;Xilinx&lt;/a&gt;’s
&lt;a href=&quot;https://www.xilinx.com/products/intellectual-property/ila.html&quot;&gt;ILA&lt;/a&gt;,
but what if you need to create an ad-hoc computer program to comprehend
the output of the scope?  It wasn’t clear how to do this with the
proprietary
&lt;a href=&quot;https://www.xilinx.com/products/intellectual-property/ila.html&quot;&gt;ILA&lt;/a&gt;.
Without it, it wasn’t clear how to identify where in the
processing chain the problem was at.&lt;/p&gt;

    &lt;p&gt;This, by the way, is one of the reasons that Open Source
&lt;a href=&quot;https://github.com/ZipCPU/wbscope&quot;&gt;scopes&lt;/a&gt; are so necessary: their measured
output values can easily be ingested into your own specialized debugging
software to be processed as you see fit.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;At one time, when I asked some other users about graphical design methods,
an online acquaintance noted that there doesn’t seem to be any way to “take
the training wheels off” of these methods, so as to be able to dig down
into the nuts and bolts of a design once you were ready to do so.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Finally, the &lt;a href=&quot;https://www.xilinx.com&quot;&gt;Xilinx&lt;/a&gt; toolchain in particular has
created a horrendous problem for 
&lt;a href=&quot;https://store.digilentinc.com&quot;&gt;Digilent&lt;/a&gt;’s support staff, in that every
new version of
&lt;a href=&quot;https://www.xilinx.com/products/design-tools/vivado.html&quot;&gt;Vivado&lt;/a&gt; breaks
their demonstration projects.&lt;/p&gt;

    &lt;p&gt;I’m not sure if this is because they rebuild or reconfigure their component
libraries from  one version to the next, or if it is because they rebuild
their TCL scripting interface, or what.  Indeed, I’ve
struggled with the problem myself when I tried rebuilding my
&lt;a href=&quot;https://github.com/ZipCPU/openarty&quot;&gt;OpenArty&lt;/a&gt; design with a newer version
of &lt;a href=&quot;https://www.xilinx.com/products/design-tools/vivado.html&quot;&gt;Vivado&lt;/a&gt;.
The result of my effort was an error so obscure that not even the
&lt;a href=&quot;https://www.xilinx.com&quot;&gt;Xilinx&lt;/a&gt; support staff on &lt;a href=&quot;https://forums.xilinx.com&quot;&gt;their
forum&lt;/a&gt; could identify.  (This is why you won’t
find any of the
&lt;a href=&quot;https://www.xilinx.com/products/design-tools/vivado.html&quot;&gt;Vivado&lt;/a&gt;
output files/products in the
&lt;a href=&quot;https://github.com/ZipCPU/openarty&quot;&gt;OpenArty&lt;/a&gt; repository.)&lt;/p&gt;

    &lt;p&gt;As a result, &lt;a href=&quot;/digilent/2017/05/18/most-common-digilent-support-requests.html&quot;&gt;I watch students&lt;/a&gt;
on the &lt;a href=&quot;https://store.digilentinc.com&quot;&gt;Digilent&lt;/a&gt;
&lt;a href=&quot;https://forum.digilentinc.com&quot;&gt;forum&lt;/a&gt; struggling to build the example
designs provided for them unless they have the exact same version of
&lt;a href=&quot;https://www.xilinx.com/products/design-tools/vivado.html&quot;&gt;Vivado&lt;/a&gt;.
Indeed, telling the student which version of
&lt;a href=&quot;https://www.xilinx.com/products/design-tools/vivado.html&quot;&gt;Vivado&lt;/a&gt; to use
to build an example/demo is a &lt;a href=&quot;/digilent/2017/05/18/most-common-digilent-support-requests.html&quot;&gt;common Digilent support request
response&lt;/a&gt;.&lt;/p&gt;

    &lt;p&gt;Wouldn’t you rather be able to separate your component library updates
from your tool updates, so that what works with one tool will work
with others?&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;All of this leads me to the conclusion that, if I wanted to create an
alternative, it would need to be OpenSource, and it would need to not take
any of the design decisions away from the designer: all of the Verilog files
would need to be available for view.&lt;/p&gt;

&lt;p&gt;Indeed, I wanted something that would generate Verilog (and c++, and Make)
project files that I could then inspect and understand–not something that
would hide details that would become difficult to debug later.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Any design flow or tool suite that hides “useless” or “irrelevant” details
will also hide the location of your bug.  (&lt;a href=&quot;https://twitter.com/zipcpu&quot;&gt;ZipCPU tweet&lt;/a&gt;)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;autofpgas-design-goals&quot;&gt;AutoFPGA’s Design Goals&lt;/h2&gt;

&lt;p&gt;My goal for
&lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt;
was simple: to be able to run
&lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt;
with a list of peripherals, and have it automatically connect those
peripherals together in a manner prescribed by their configuration files.
Indeed, if you look in an &lt;a href=&quot;https://github.com/ZipCPU/autofpga-demo/blob/master/auto-data/Makefile&quot;&gt;example
Makefile&lt;/a&gt;
that calls
&lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt;,
you’ll find a line that just calls
&lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt;
with a list of components.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;autofpga global.txt bkram.txt buserr.txt clock.txt hexbus.txt		&lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
	fixdata.txt pwrcount.txt rawreg.txt simhalt.txt	version.txt spio.txt&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;“&lt;a href=&quot;https://www.gnu.org/software/make/&quot;&gt;Make&lt;/a&gt;“able&lt;/p&gt;

    &lt;p&gt;To keep things simple, I’d like to type
“&lt;a href=&quot;https://www.gnu.org/software/make&quot;&gt;make&lt;/a&gt;” in a &lt;a href=&quot;https://github.com/ZipCPU/autofpga-demo/blob/master/Makefile&quot;&gt;top level
directory&lt;/a&gt;,
have &lt;a href=&quot;https://www.gnu.org/software/make&quot;&gt;make&lt;/a&gt;
recurse as necessary into any sub-directories to process &lt;a href=&quot;https://github.com/ZipCPU/autofpga-demo/tree/master/auto-data/&quot;&gt;component
configuration
files&lt;/a&gt;, build
&lt;a href=&quot;https://github.com/ZipCPU/autofpga-demo/tree/master/auto-generated/&quot;&gt;design files&lt;/a&gt;,
assemble those files together, and build a project all from one
&lt;a href=&quot;https://www.gnu.org/software/make&quot;&gt;make&lt;/a&gt; command.&lt;/p&gt;

    &lt;p&gt;Okay, so … I don’t know how to do this with the proprietary vendor based
tools (yet), and I don’t want to use a broken Tcl toolflow, but I do know
how to do this much with both
&lt;a href=&quot;http://www.clifford.at/yosys/&quot;&gt;yosys&lt;/a&gt;
and
&lt;a href=&quot;https://www.veripool.org/wiki/verilator&quot;&gt;Verilator&lt;/a&gt;.&lt;/p&gt;

    &lt;p&gt;(No, I’m not saying that Tcl is broken, but rather that many of the tools
that use it are–for the reasons discussed above.)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;No new language&lt;/p&gt;

    &lt;p&gt;Further, I don’t really want to create a new language for component
interaction and connection.  While I understand that other tools exist,
such as &lt;a href=&quot;https://en.wikipedia.org/wiki/IP-XACT&quot;&gt;IP-XACT&lt;/a&gt;,
&lt;a href=&quot;https://myhdl.org&quot;&gt;MyHDL&lt;/a&gt;, or
&lt;a href=&quot;https://github.com/m-labs/migen&quot;&gt;Migen&lt;/a&gt;, I didn’t want to require the
developer to learn a knew language (XML, Python,
&lt;a href=&quot;https://github.com/m-labs/migen/blob/master/fhdl.rst&quot;&gt;FHDL&lt;/a&gt;, etc.)
in order to interact with
&lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt;.  I also didn’t want to build
a compiler.  I wanted
&lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt; to be a
product that I could use to create a production system, and I
didn’t want to slow down too much to get there.&lt;/p&gt;

    &lt;p&gt;For this reason, 
&lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt; is primarily a
Copy and Paste utility.  The configuration files will identify what
things need to be copied and pasted where to create the desired output
files.  As an example, a &lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/auto-data/flash.txt&quot;&gt;Quad SPI flash
component&lt;/a&gt;
doesn’t just need to connect to a
&lt;a href=&quot;/doc/wbspec_b4.pdf&quot;&gt;wishbone bus&lt;/a&gt;, it also needs a little
bit of tri-state code inserted at the top design level.  (It’s actually worse:
since the flash clock line is shared with the load circuitry, a special
&lt;a href=&quot;https://www.xilinx.com&quot;&gt;Xilinx&lt;/a&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;STARTUPE2&lt;/code&gt; component is often required
at the top design level as
well.)&lt;/p&gt;

    &lt;p&gt;I’ll need to leave it open for debate as to whether or not I created a
“new language”, since the configuration files are neither Verilog nor are
they C++, and they are definitely not Python.  Instead, the files consist
of a simple series of “@KEY=VALUE” pairs, where the &lt;code class=&quot;highlighter-rouge&quot;&gt;VALUE&lt;/code&gt;s can take
multiple lines–often containing pieces of Verilog or C++ code.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;No hidden design components&lt;/p&gt;

    &lt;p&gt;&lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt; just creates text files.
Since 
&lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt; is primarily a copy and
paste utility, comments within the 
&lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt; configuration files will just
get copied into their respective places.&lt;/p&gt;

    &lt;p&gt;What this means is, when you have a problem with the design of one of your
components, you can look back into that components configuration file and
see what got copied and adjust it.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;While I like to think that
&lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt;
has met all of these goals and more, I’ll leave it to you and time to be the
ultimate judge.&lt;/p&gt;

&lt;h2 id=&quot;license&quot;&gt;License&lt;/h2&gt;

&lt;p&gt;If you are wondering if you can legally use
&lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt; for your project, the answer is
that you can.  &lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt; is a software
program licensed under the
&lt;a href=&quot;https://www.gnu.org/licenses/gpl.html&quot;&gt;GPLv3&lt;/a&gt;.  If you make changes to it,
or improve it, I would love to have those changes returned to the
&lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt; repository for others to use.&lt;/p&gt;

&lt;p&gt;This license doesn’t cover &lt;em&gt;your&lt;/em&gt; intellectual property, only the
&lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt; program itself.  Indeed, I
consider &lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt;
to be a piece of software similar to a compiler.  As a result,
&lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt; asserts no particular license
on the files it creates, or the projects that use it.&lt;/p&gt;

&lt;p&gt;Going one step further, all of my
&lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt; projects specify their own
license.  What I mean is that I require
&lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt; created design files to have
a license statement within them.  The license statement chosen if specified
by the global &lt;code class=&quot;highlighter-rouge&quot;&gt;@LEGAL&lt;/code&gt; tag, such as you might find in one of my
&lt;a href=&quot;https://github.com/ZipCPU/autofpga-demo/blob/master/auto-data/global.txt&quot;&gt;global configuration file&lt;/a&gt;s.
&lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt; then copies &lt;a href=&quot;https://github.com/ZipCPU/autofpga-demo/blob/master/auto-data/legalgen.txt&quot;&gt;this
license&lt;/a&gt;
into the files it generates–adjusting the filename and project name as
appropriate.  Hence while &lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt;
is released under &lt;a href=&quot;https://www.gnu.org/licenses/gpl.html&quot;&gt;GPLv3&lt;/a&gt;, I can choose
to release (or not) any project that uses it.  Feel free to adjust the &lt;code class=&quot;highlighter-rouge&quot;&gt;@LEGAL&lt;/code&gt;
tag to reference the license appropriate for your project.&lt;/p&gt;

&lt;h2 id=&quot;a-simple-autofpga-design&quot;&gt;A Simple AutoFPGA Design&lt;/h2&gt;

&lt;p&gt;Given all of that as background, I’d like to spend some time introducing
&lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt;
and discussing how to add (or remove) peripherals to(/from) a project.
I’ve created a new project, 
an &lt;a href=&quot;https://github.com/ZipCPU/autofpga-demo&quot;&gt;AutoFPGA Demo&lt;/a&gt;, which contains
a series of simple peripherals that can easily become a part of any project
using &lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt;.  This should be
simple enough for any new student to learn how to build and integrate
components together using
&lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;I have more complicated demonstrations as well, such as the
&lt;a href=&quot;https://github.com/ZipCPU/zbasic&quot;&gt;ZBasic&lt;/a&gt; project.
&lt;a href=&quot;https://github.com/ZipCPU/zbasic&quot;&gt;ZBasic&lt;/a&gt; contains a basic
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;, together with some simple
peripherals and several bus structures.  Once we exhaust the lessons from the
basic &lt;a href=&quot;https://github.com/ZipCPU/autofpga-demo&quot;&gt;AutoFPGA Demo&lt;/a&gt; project,
we may turn there for some more examples to draw demonstrations from.&lt;/p&gt;

&lt;p&gt;We’ll use &lt;a href=&quot;https://github.com/ZipCPU/autofpga-demo&quot;&gt;this example project&lt;/a&gt;
project, as a demonstration over the next couple of posts, showing what can be
done with &lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt;.&lt;/p&gt;

&lt;hr /&gt;&lt;p&gt;&lt;em&gt;And his disciples asked him, saying, 'Master, who did sin, this man, or his parents, that he was born blind?'&lt;/em&gt;</description>
        <pubDate>Thu, 05 Oct 2017 00:00:00 -0400</pubDate>
        <link>http://zipcpu.com/zipcpu/2017/10/05/autofpga-intro.html</link>
        <guid isPermaLink="true">http://zipcpu.com/zipcpu/2017/10/05/autofpga-intro.html</guid>
        
        
        <category>zipcpu</category>
        
      </item>
    
      <item>
        <title>A CORDIC testbench</title>
        <description>&lt;p&gt;Some time ago, I presented a
&lt;a href=&quot;/dsp/2017/08/30/cordic.html&quot;&gt;CORDIC algorithm&lt;/a&gt;
on
&lt;a href=&quot;http://zipcpu.com/&quot;&gt;this blog&lt;/a&gt;.
This &lt;a href=&quot;/dsp/2017/08/30/cordic.html&quot;&gt;CORDIC algorithm&lt;/a&gt;
makes it possible to generate sine and cosines using
normalized integers as phase angles and only additions and shifts.
The &lt;a href=&quot;/dsp/2017/08/30/cordic.html&quot;&gt;CORDIC algorithm&lt;/a&gt;
is unique because of the simple fact that it does not require any multiplies
to calculate these
&lt;a href=&quot;https://en.wikipedia.org/wiki/Trigonometry&quot;&gt;trigonometric&lt;/a&gt; values.&lt;/p&gt;

&lt;p&gt;Since that time, we’ve demonstrated the utility of
&lt;a href=&quot;/dsp/2017/08/30/cordic.html&quot;&gt;this algorithm&lt;/a&gt;
when &lt;a href=&quot;/dsp/2017/09/16/pwm-demo.html&quot;&gt;testing&lt;/a&gt;
a &lt;a href=&quot;/dsp/2017/09/04/pwm-reinvention.html&quot;&gt;proposed/modified PWM
algorithm&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;This is only the beginnings of what a
&lt;a href=&quot;/dsp/2017/08/30/cordic.html&quot;&gt;CORDIC algorithm&lt;/a&gt;
can be used for.  You can also modulate baseband signals to
intermediate/carrier frequencies, and downconvert them back to base band,
using the same approach.  It is really quite versatile.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/dsp/2017/08/30/cordic.html&quot;&gt;CORDIC&lt;/a&gt;’s
can also be used for generating test functions for
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
based &lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filters&lt;/a&gt;.
This is particularly where I’d like to go with the technology
on &lt;a href=&quot;http://zipcpu.com/&quot;&gt;this blog&lt;/a&gt;.
This means that our filtering test bench will depend upon this
&lt;a href=&quot;/dsp/2017/08/30/cordic.html&quot;&gt;CORDIC&lt;/a&gt; algorithm, and hence
any failure in the
&lt;a href=&quot;/dsp/2017/08/30/cordic.html&quot;&gt;CORDIC&lt;/a&gt; will have a ripple
affect into our future articles.&lt;/p&gt;

&lt;p&gt;For this reason, we need to get the
&lt;a href=&quot;/dsp/2017/08/30/cordic.html&quot;&gt;CORDIC&lt;/a&gt; &lt;a href=&quot;https://github.com/ZipCPU/cordic/blob/master/bench/cpp/cordic_tb.cpp&quot;&gt;test
bench&lt;/a&gt;
right.&lt;/p&gt;

&lt;p&gt;It also turns out that we made our problem more difficult by creating a
core generator approach to our
&lt;a href=&quot;/dsp/2017/08/30/cordic.html&quot;&gt;CORDIC algorithm&lt;/a&gt;.
Because of the core generation approach, our
&lt;a href=&quot;/dsp/2017/08/30/cordic.html&quot;&gt;CORDIC&lt;/a&gt; &lt;a href=&quot;https://github.com/ZipCPU/cordic/blob/master/bench/cpp/cordic_tb.cpp&quot;&gt;test
bench&lt;/a&gt;
will need to run across all manner of parameters: number of stages, input
data width, phase bit-width, extra internal bits, and output bit width.  So
that we could handle this extra variability, we took a pause in our
development in order to present some &lt;a href=&quot;/dsp/2017/09/27/quantization.html&quot;&gt;probabilistic quantities related to
quantization&lt;/a&gt;
which we can now use to predict the performance we expect so as to measure
how well we do in comparison to it.&lt;/p&gt;

&lt;p&gt;Building this &lt;a href=&quot;https://github.com/ZipCPU/cordic/blob/master/bench/cpp/cordic_tb.cpp&quot;&gt;test
bench&lt;/a&gt;
is going to take several steps.  The first several of those will estimate
how close we can expect the
&lt;a href=&quot;/dsp/2017/08/30/cordic.html&quot;&gt;CORDIC algorithm&lt;/a&gt;
to get to the right result.  This is important, because it will then form the
basis for any performance thresholds we might create to know if
&lt;a href=&quot;https://github.com/ZipCPU/cordic/blob/master/rtl/cordic.v&quot;&gt;our implementation&lt;/a&gt;
works.  These results can also be used as an estimate of how well the
&lt;a href=&quot;/dsp/2017/08/30/cordic.html&quot;&gt;CORDIC algorithm&lt;/a&gt;
will perform for arbitrary input parameters.&lt;/p&gt;

&lt;p&gt;Hence, after discussing both what
&lt;a href=&quot;/dsp/2017/09/27/quantization.html&quot;&gt;quantization&lt;/a&gt;
and phase &lt;a href=&quot;https://en.wikipedia.org/wiki/Variance&quot;&gt;variance&lt;/a&gt;
one might expect, we’ll turn our attention to building the actual &lt;a href=&quot;https://github.com/ZipCPU/cordic/blob/master/bench/cpp/cordic_tb.cpp&quot;&gt;test
bench&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;theorem-rules&quot;&gt;Theorem Rules&lt;/h2&gt;

&lt;p&gt;A &lt;a href=&quot;/dsp/2017/09/27/quantization.html&quot;&gt;previous post&lt;/a&gt; put
together a couple of probabilistic formula’s and
&lt;a href=&quot;https://en.wikipedia.org/wiki/Variance&quot;&gt;variance&lt;/a&gt;
rules.  Let’s just reiterate these for background here.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;/dsp/2017/09/27/quantization.html&quot;&gt;Quantization noise&lt;/a&gt;
has a &lt;a href=&quot;https://en.wikipedia.org/wiki/Variance&quot;&gt;variance&lt;/a&gt;
given by &lt;code class=&quot;highlighter-rouge&quot;&gt;1/12&lt;/code&gt;th of a perfect &lt;a href=&quot;https://en.wikipedia.org/wiki/Analog-to-digital_converter&quot;&gt;Analog to Digital Converter
(ADC)&lt;/a&gt;’s step
size.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The &lt;a href=&quot;https://en.wikipedia.org/wiki/Variance&quot;&gt;variance&lt;/a&gt;
of a &lt;a href=&quot;https://en.wikipedia.org/wiki/Random_variable&quot;&gt;random variable&lt;/a&gt;
multiplied by a constant is given by the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Variance&quot;&gt;variance&lt;/a&gt; of that
&lt;a href=&quot;https://en.wikipedia.org/wiki/Random_variable&quot;&gt;variable&lt;/a&gt;
times the constant squared.&lt;/p&gt;

    &lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/eqn-variance-scale.png&quot; alt=&quot;Equation showing how scale affects variance&quot; width=&quot;193&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

    &lt;p&gt;This applies to all
&lt;a href=&quot;https://en.wikipedia.org/wiki/Random_variable&quot;&gt;random variables&lt;/a&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;We’ll assume that any
&lt;a href=&quot;https://en.wikipedia.org/wiki/Random_variable&quot;&gt;random variables&lt;/a&gt;
we deal with are
&lt;a href=&quot;https://en.wikipedia.org/wiki/Independence_(probability_theory)&quot;&gt;independent&lt;/a&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The &lt;a href=&quot;https://en.wikipedia.org/wiki/Variance&quot;&gt;variance&lt;/a&gt; of the sum of two
&lt;a href=&quot;https://en.wikipedia.org/wiki/Random_variable&quot;&gt;random variables&lt;/a&gt; is given
by the sum of the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Variance&quot;&gt;variances&lt;/a&gt;:&lt;/p&gt;

    &lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/eqn-variance-sum.png&quot; alt=&quot;Equation showing the variance of the sum of two values&quot; width=&quot;283&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

    &lt;p&gt;This follows from our assumption that the two
&lt;a href=&quot;https://en.wikipedia.org/wiki/Random_variable&quot;&gt;random variables&lt;/a&gt;,
&lt;code class=&quot;highlighter-rouge&quot;&gt;X&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;Y&lt;/code&gt;, are
&lt;a href=&quot;https://en.wikipedia.org/wiki/Independence_(probability_theory)&quot;&gt;independent&lt;/a&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The
&lt;a href=&quot;https://en.wikipedia.org/wiki/Standard_deviation&quot;&gt;standard deviation&lt;/a&gt; of a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Random_variable&quot;&gt;random variable&lt;/a&gt;
is given by the square root of the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Variance&quot;&gt;variance&lt;/a&gt;.&lt;/p&gt;

    &lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/eqn-defn-stdev.png&quot; alt=&quot;Equation defining the standard deviation of a random variable&quot; width=&quot;145&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;These will form the basis of the error estimation work that follows.  Indeed,
we’ll use several of these properties at every step.&lt;/p&gt;

&lt;h2 id=&quot;from-core-generator-to-test-bench&quot;&gt;From Core Generator to Test Bench&lt;/h2&gt;

&lt;p&gt;One of the hassles of any test bench for a core generated algorithm is
communicating information from the core generator to other parts of the
design, such as the &lt;a href=&quot;https://github.com/ZipCPU/cordic/blob/master/bench/cpp/cordic_tb.cpp&quot;&gt;test
bench&lt;/a&gt;.
The problem has a simple solution.&lt;/p&gt;

&lt;p&gt;The approach we’ll take for dealing with this problem is to have the
&lt;a href=&quot;https://github.com/ZipCPU/cordic/tree/master/sw/&quot;&gt;core generator&lt;/a&gt; generate
not only the &lt;a href=&quot;https://github.com/ZipCPU/cordic/blob/master/rtl/cordic.v&quot;&gt;CORDIC&lt;/a&gt;
code itself, but also a
&lt;a href=&quot;https://github.com/ZipCPU/cordic/blob/master/rtl/cordic.h&quot;&gt;C header file&lt;/a&gt;
describing the relevant choices that were made in the
&lt;a href=&quot;https://github.com/ZipCPU/cordic/tree/master/sw/&quot;&gt;core generator&lt;/a&gt;.
The &lt;a href=&quot;https://github.com/ZipCPU/cordic/tree/master/sw&quot;&gt;core generator&lt;/a&gt;
will create &lt;a href=&quot;https://github.com/ZipCPU/cordic/blob/master/rtl/cordic.h&quot;&gt;this C header
file&lt;/a&gt;
any time the command line parameter &lt;code class=&quot;highlighter-rouge&quot;&gt;-c&lt;/code&gt; is given to it.&lt;/p&gt;

&lt;p&gt;The basic information found within &lt;a href=&quot;https://github.com/ZipCPU/cordic/blob/master/rtl/cordic.h&quot;&gt;this
file&lt;/a&gt;
includes the bit widths of the input (&lt;code class=&quot;highlighter-rouge&quot;&gt;IW&lt;/code&gt;), output (&lt;code class=&quot;highlighter-rouge&quot;&gt;OW&lt;/code&gt;), and phase (&lt;code class=&quot;highlighter-rouge&quot;&gt;PW&lt;/code&gt;).
It also includes the number of extra bits, &lt;code class=&quot;highlighter-rouge&quot;&gt;NEXTRA&lt;/code&gt;,
used in the &lt;a href=&quot;/dsp/2017/08/30/cordic.html&quot;&gt;CORDIC&lt;/a&gt;
computations, as well as the number of
&lt;a href=&quot;/dsp/2017/08/30/cordic.html&quot;&gt;CORDIC&lt;/a&gt;
stages, &lt;code class=&quot;highlighter-rouge&quot;&gt;NSTAGES&lt;/code&gt;.  Finally, this
&lt;a href=&quot;https://github.com/ZipCPU/cordic/blob/master/rtl/cordic.h&quot;&gt;header file&lt;/a&gt;
will contain information regarding whether or not the reset wire
or the &lt;a href=&quot;/blog/2017/08/14/strategies-for-pipelining.html&quot;&gt;traveling
CE&lt;/a&gt;
wire (&lt;code class=&quot;highlighter-rouge&quot;&gt;aux&lt;/code&gt;) were included within the design.&lt;/p&gt;

&lt;p&gt;We’ll add to this basic information some probabilistic prediction information
we’ll develop below.&lt;/p&gt;

&lt;p&gt;You can see an example of such a
&lt;a href=&quot;https://github.com/ZipCPU/cordic/blob/master/rtl/cordic.h&quot;&gt;C header file&lt;/a&gt;,
produced by our &lt;a href=&quot;https://github.com/ZipCPU/cordic/blob/master/sw/basiccordic.cpp&quot;&gt;core
generator&lt;/a&gt;,
&lt;a href=&quot;https://github.com/ZipCPU/cordic/blob/master/rtl/cordic.h&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;input-quantization&quot;&gt;Input Quantization&lt;/h2&gt;

&lt;p&gt;Now let’s start our run through the various errors or noise sources within the
&lt;a href=&quot;/dsp/2017/08/30/cordic.html&quot;&gt;CORDIC&lt;/a&gt; algorithm.&lt;/p&gt;

&lt;p&gt;The first noise source is the
&lt;a href=&quot;/dsp/2017/09/27/quantization.html&quot;&gt;quantization&lt;/a&gt;
of the input samples.  We can assume that both &lt;code class=&quot;highlighter-rouge&quot;&gt;i_xval&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;i_yval&lt;/code&gt; come with
an input &lt;a href=&quot;/dsp/2017/09/27/quantization.html&quot;&gt;quantization
variance&lt;/a&gt;
of &lt;code class=&quot;highlighter-rouge&quot;&gt;1/12&lt;/code&gt;th–as we &lt;a href=&quot;/dsp/2017/09/27/quantization.html&quot;&gt;discussed in our last
post&lt;/a&gt;.  Likewise, the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Variance&quot;&gt;variance&lt;/a&gt; of the phase is &lt;code class=&quot;highlighter-rouge&quot;&gt;1/12&lt;/code&gt;th of
the lowest phase unit squared.&lt;/p&gt;

&lt;p&gt;In our
&lt;a href=&quot;/dsp/2017/08/30/cordic.html&quot;&gt;CORDIC algorithm&lt;/a&gt;,
though, our first step was to multiply these input values by a programmable
number of extra bits.  The number of these extra bits was used to create a
working width, &lt;code class=&quot;highlighter-rouge&quot;&gt;WW&lt;/code&gt;, used below,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;// WW is the number of XTRA bits plus the maximum of IW and OW
// These lines therefore add XTRA bits to our values
//
wire	signed [(WW-1):0]	e_xval, e_yval;
assign	e_xval = { {i_xval[(IW-1)]}, i_xval, {(WW-IW-1){1&#39;b0}} };
assign	e_yval = { {i_yval[(IW-1)]}, i_yval, {(WW-IW-1){1&#39;b0}} };&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;To express this mathematically, we’ll let &lt;code class=&quot;highlighter-rouge&quot;&gt;x_i&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;y_i&lt;/code&gt; represent the
inputs to the algorithm, and &lt;code class=&quot;highlighter-rouge&quot;&gt;x_0&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;y_0&lt;/code&gt; represent the inputs to the first
rotation.  Since the precision of these values is not affected by the
pre-rotation step, no additional error is inserted there.  Hence, we have the
following representation for the inputs to our first rotation:&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/eqn-cordic-premul.png&quot; alt=&quot;Eqn for the pre-multiplication step&quot; width=&quot;281&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;In this equation, &lt;code class=&quot;highlighter-rouge&quot;&gt;e_xi&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;e_yi&lt;/code&gt; are any errors associated with the
inputs &lt;code class=&quot;highlighter-rouge&quot;&gt;x_i&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;y_i&lt;/code&gt;.  Once the multiply has been accomplished, we’ll
express the output as a sum of both the desired output &lt;code class=&quot;highlighter-rouge&quot;&gt;x_0&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;y_0&lt;/code&gt;,
together with the differences from perfection, &lt;code class=&quot;highlighter-rouge&quot;&gt;e_x0&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;e_y0&lt;/code&gt;.  These latter
two &lt;a href=&quot;https://en.wikipedia.org/wiki/Random_variable&quot;&gt;random values&lt;/a&gt;
are the errors in our precision following this step.&lt;/p&gt;

&lt;p&gt;Using our &lt;a href=&quot;https://en.wikipedia.org/wiki/Variance&quot;&gt;variance&lt;/a&gt;
rule for multiplying an input by a constant, the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Variance&quot;&gt;variance&lt;/a&gt;
of these two error terms, &lt;code class=&quot;highlighter-rouge&quot;&gt;e_x0&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;e_y0&lt;/code&gt;, is then given by,&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/eqn-cordic-premul-variance.png&quot; alt=&quot;Variance adjustment from the pre-multiplication step&quot; width=&quot;212&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;This is the then &lt;a href=&quot;https://en.wikipedia.org/wiki/Variance&quot;&gt;variance&lt;/a&gt;
at the input to our &lt;a href=&quot;/dsp/2017/08/30/cordic.html&quot;&gt;CORDIC rotation
stages&lt;/a&gt;.`
From here we’ll move to the rotation steps themselves.&lt;/p&gt;

&lt;h2 id=&quot;internal-truncation-error&quot;&gt;Internal Truncation Error&lt;/h2&gt;

&lt;p&gt;The next source of error within our &lt;a href=&quot;https://github.com/ZipCPU/cordic/blob/master/rtl/cordic.v&quot;&gt;CORDIC
implementation&lt;/a&gt;
may be found within the
&lt;a href=&quot;/dsp/2017/08/30/cordic.html&quot;&gt;CORDIC rotation stages&lt;/a&gt;
themselves.&lt;/p&gt;

&lt;p&gt;As you may recall, each
&lt;a href=&quot;/dsp/2017/08/30/cordic.html&quot;&gt;CORDIC stage&lt;/a&gt;
rotates the previous &lt;code class=&quot;highlighter-rouge&quot;&gt;x,y&lt;/code&gt; values using a transform matrix using the equations:&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/eqn-cordic-eqns-pm.png&quot; alt=&quot;Cordic equations&quot; width=&quot;350&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;There was also a corollary transform for when we wished to rotate in the
other direction.  To represent both, we used the plus-or-minus
character above.  Further, the minus-or-plus character above captures the fact
that two separate signs need to change together, but that they need to be
opposites of each other.&lt;/p&gt;

&lt;p&gt;However, while this was the rotation equation
&lt;a href=&quot;/dsp/2017/08/30/cordic.html&quot;&gt;we presented&lt;/a&gt;,
it wasn’t quite what our
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/cordic/blob/master/rtl/cordic.v&quot;&gt;code&lt;/a&gt;
accomplished within our
&lt;a href=&quot;https://github.com/ZipCPU/cordic/blob/master/rtl/cordic.v&quot;&gt;implementation&lt;/a&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;if (ph[i][(PW-1)]) // Negative phase
begin
	// If the phase is negative, rotate by the
	// CORDIC angle in a clockwise direction.
	xv[i+1] &amp;lt;= xv[i] + (yv[i]&amp;gt;&amp;gt;&amp;gt;(i+1));
	yv[i+1] &amp;lt;= yv[i] - (xv[i]&amp;gt;&amp;gt;&amp;gt;(i+1));
	ph[i+1] &amp;lt;= ph[i] + cordic_angle[i];
end else begin
	// On the other hand, if the phase is
	// positive ... rotate in the
	// counter-clockwise direction
	xv[i+1] &amp;lt;= xv[i] - (yv[i]&amp;gt;&amp;gt;&amp;gt;(i+1));
	yv[i+1] &amp;lt;= yv[i] + (xv[i]&amp;gt;&amp;gt;&amp;gt;(i+1));
	ph[i+1] &amp;lt;= ph[i] - cordic_angle[i];
end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Within our
&lt;a href=&quot;https://github.com/ZipCPU/cordic/blob/master/rtl/cordic.v&quot;&gt;implementation&lt;/a&gt;,
we truncated the values of &lt;code class=&quot;highlighter-rouge&quot;&gt;x_k&lt;/code&gt; and
&lt;code class=&quot;highlighter-rouge&quot;&gt;y_k&lt;/code&gt; after shifting them to the right.  This is equivalent to adding
&lt;a href=&quot;https://en.wikipedia.org/wiki/Random_variable&quot;&gt;random variable&lt;/a&gt;s,
&lt;code class=&quot;highlighter-rouge&quot;&gt;d_xk&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;d_yk&lt;/code&gt; to each of the &lt;code class=&quot;highlighter-rouge&quot;&gt;x_{k+1}&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;y_{k+1}&lt;/code&gt;
values in addition to the error terms brought to this stage from the prior
stage.  We can separate the desired result, &lt;code class=&quot;highlighter-rouge&quot;&gt;x_(k+1)&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;y_(k+1)&lt;/code&gt; from the
accumulated errors in the result, &lt;code class=&quot;highlighter-rouge&quot;&gt;e_x(k+1)&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;e_y(k+1)&lt;/code&gt; and re-represent
this as,&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/eqn-cordic-stage-w-err-terms.png&quot; alt=&quot;Cordic equations with noise&quot; width=&quot;617&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Using our addition of
&lt;a href=&quot;https://en.wikipedia.org/wiki/Variance&quot;&gt;variances&lt;/a&gt;
rule, together with the scale rule, we can calculate a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Variance&quot;&gt;variance&lt;/a&gt;
for the error term at the end of this stage.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/eqn-cordic-stage-variance.png&quot; alt=&quot;V[e_x] = (1+2^(-2k))*v[e_k]+V[d_k]&quot; width=&quot;393&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;At this point, we know &lt;code class=&quot;highlighter-rouge&quot;&gt;V[e_k]&lt;/code&gt; from the previous stage, and with the
exception of &lt;code class=&quot;highlighter-rouge&quot;&gt;V[d_k]&lt;/code&gt; we can calculate &lt;code class=&quot;highlighter-rouge&quot;&gt;V[e_(k+1)]&lt;/code&gt; for the next stage.
But … what is &lt;code class=&quot;highlighter-rouge&quot;&gt;V[d_k]&lt;/code&gt;?&lt;/p&gt;

&lt;p&gt;Unlike the
&lt;a href=&quot;/dsp/2017/09/27/quantization.html&quot;&gt;quantization&lt;/a&gt;
error we calculated earlier, truncation error is neither zero
&lt;a href=&quot;https://en.wikipedia.org/wiki/Mean#Mean_of_a_probability_distribution&quot;&gt;mean&lt;/a&gt;
nor does it have a &lt;code class=&quot;highlighter-rouge&quot;&gt;1/12&lt;/code&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Variance&quot;&gt;variance&lt;/a&gt;.
However, if we assume that the choice of direction is made randomly,
with a probability of one half for each rotation direction, then the truncation
error becomes zero
&lt;a href=&quot;https://en.wikipedia.org/wiki/Mean#Mean_of_a_probability_distribution&quot;&gt;mean&lt;/a&gt;.
(Half the time the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Mean#Mean_of_a_probability_distribution&quot;&gt;mean&lt;/a&gt;
is negative by one half, half the time it is positive by one half, etc.)
The &lt;a href=&quot;https://en.wikipedia.org/wiki/Variance&quot;&gt;variance&lt;/a&gt;,
though, is given by &lt;code class=&quot;highlighter-rouge&quot;&gt;1/3&lt;/code&gt; since we need to integrate from
&lt;code class=&quot;highlighter-rouge&quot;&gt;0&lt;/code&gt; to &lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt; instead of from &lt;code class=&quot;highlighter-rouge&quot;&gt;-1/2&lt;/code&gt; to &lt;code class=&quot;highlighter-rouge&quot;&gt;1/2&lt;/code&gt;:&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/eqn-cordic-truncation-variance.png&quot; alt=&quot;Truncation Variance = 1/3&quot; width=&quot;341&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Well, okay, that’s close but not quite right.  In reality, the truncation
error associated with truncating an already
&lt;a href=&quot;/dsp/2017/09/27/quantization.html&quot;&gt;quantizated&lt;/a&gt;
number requires an analysis of a &lt;a href=&quot;https://en.wikipedia.org/wiki/Probability_distribution#Discrete_probability_distribution&quot;&gt;discrete probability
distribution&lt;/a&gt;.
If we suppose that a finite number of bits, &lt;code class=&quot;highlighter-rouge&quot;&gt;k&lt;/code&gt;, are dropped in the
truncation then the variance is not &lt;code class=&quot;highlighter-rouge&quot;&gt;1/3&lt;/code&gt;rd but&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/eqn-cordic-discrete-truncation-variance.png&quot; alt=&quot;Discrete truncation variance only approximates 1/3&quot; width=&quot;380&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;The proof of this doesn’t fit on a single line, however, so we’ll leave the
details as an exercise for the student.&lt;/p&gt;

&lt;p&gt;After the
&lt;a href=&quot;/dsp/2017/08/30/cordic.html&quot;&gt;CORDIC rotation stages&lt;/a&gt;,
we rounded the result and produced an ouput.  That step, therefore, is next.&lt;/p&gt;

&lt;h2 id=&quot;output-variance&quot;&gt;Output Variance&lt;/h2&gt;

&lt;p&gt;The last step in calculating the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Variance&quot;&gt;variance&lt;/a&gt;
of the
&lt;a href=&quot;/dsp/2017/08/30/cordic.html&quot;&gt;CORDIC&lt;/a&gt;’s
output, is to adjust the resulting output
&lt;a href=&quot;https://en.wikipedia.org/wiki/Variance&quot;&gt;variance&lt;/a&gt;
due to the last rounding step:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;assign	pre_xval = xv[NSTAGES] + { {(OW){1&#39;b0}},
			xv[NSTAGES][(WW-OW)],
			{(WW-OW-1){!xv[NSTAGES][WW-OW]}}};
assign	pre_yval = yv[NSTAGES] + { {(OW){1&#39;b0}},
			yv[NSTAGES][(WW-OW)],
			{(WW-OW-1){!yv[NSTAGES][WW-OW]}}};

always @(posedge i_clk)
begin
	o_xval &amp;lt;= pre_xval[(WW-1):(WW-OW)];
	o_yval &amp;lt;= pre_yval[(WW-1):(WW-OW)];
	o_aux &amp;lt;= ax[NSTAGES];
end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;As you may recall, &lt;code class=&quot;highlighter-rouge&quot;&gt;WW&lt;/code&gt; was the working width we were using for the
&lt;a href=&quot;/dsp/2017/08/30/cordic.html&quot;&gt;CORDIC&lt;/a&gt;
transform stages, and &lt;code class=&quot;highlighter-rouge&quot;&gt;OW&lt;/code&gt; is the output width.  If &lt;code class=&quot;highlighter-rouge&quot;&gt;WW&lt;/code&gt; is greater than &lt;code class=&quot;highlighter-rouge&quot;&gt;OW&lt;/code&gt;,
then this stage drops bits and rounds the result.  This rounding step also
adds some more
&lt;a href=&quot;/dsp/2017/09/27/quantization.html&quot;&gt;quantization&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Variance&quot;&gt;variance&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Mathematically, we might write what is taking place with,&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/eqn-cordic-final-transform-step.png&quot; alt=&quot;The final CORDIC rounding step&quot; width=&quot;360&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;At this point, we know the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Variance&quot;&gt;variance&lt;/a&gt;
of just about all of the components.
&lt;code class=&quot;highlighter-rouge&quot;&gt;x_k&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;y_k&lt;/code&gt; are fixed values (not random), so their
&lt;a href=&quot;https://en.wikipedia.org/wiki/Variance&quot;&gt;variance&lt;/a&gt; is zero.
The &lt;a href=&quot;https://en.wikipedia.org/wiki/Variance&quot;&gt;variance&lt;/a&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;e_xk&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;e_yk&lt;/code&gt; were both calculated in the last step.
Using our
&lt;a href=&quot;/dsp/2017/09/27/quantization.html&quot;&gt;scale and addition rules&lt;/a&gt;,
we can express the final
&lt;a href=&quot;https://en.wikipedia.org/wiki/Variance&quot;&gt;variance&lt;/a&gt; as,&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/eqn-cordic-final-transform-variance.png&quot; alt=&quot;The final CORDIC transform variance&quot; width=&quot;361&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;The &lt;a href=&quot;https://en.wikipedia.org/wiki/Variance&quot;&gt;variance&lt;/a&gt;
of &lt;code class=&quot;highlighter-rouge&quot;&gt;d_xo&lt;/code&gt; is the only thing left to discuss.  This is the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Variance&quot;&gt;variance&lt;/a&gt;
associated with our rounding step.  If we treat the value as continuous, then
the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Variance&quot;&gt;variance&lt;/a&gt;
of &lt;code class=&quot;highlighter-rouge&quot;&gt;d_xo&lt;/code&gt; would be &lt;code class=&quot;highlighter-rouge&quot;&gt;1/12&lt;/code&gt;th.  This isn’t quite the case, since
&lt;code class=&quot;highlighter-rouge&quot;&gt;d_xo&lt;/code&gt; is quantized, but it makes a decent approximation.  (The actual number
starts at &lt;code class=&quot;highlighter-rouge&quot;&gt;1/8&lt;/code&gt; for dropping one bit, and asymptotes at &lt;code class=&quot;highlighter-rouge&quot;&gt;1/12&lt;/code&gt; for dropping
an infinite number of bits.)&lt;/p&gt;

&lt;p&gt;We can now use this value to calculate the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Variance&quot;&gt;variance&lt;/a&gt;
both at the end of each
&lt;a href=&quot;/dsp/2017/08/30/cordic.html&quot;&gt;CORDIC&lt;/a&gt;
stage, as well as at the end of the entire algorithm.
We’ll place the code to calculate this value within our generic
&lt;a href=&quot;https://github.com/ZipCPU/cordic/blob/master/sw/cordiclib.cpp&quot;&gt;CORDIC library&lt;/a&gt;:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;&lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt;	&lt;span class=&quot;nf&quot;&gt;transform_quantization_variance&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nstages&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;xtrabits&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dropped_bits&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;current_variance&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

	&lt;span class=&quot;n&quot;&gt;current_variance&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pow&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;xtrabits&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;12.&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

	&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nstages&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;current_variance&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pow&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;current_variance&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;3.&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

	&lt;span class=&quot;c1&quot;&gt;// If we drop bits from this on the output, then we add more variance
&lt;/span&gt;	&lt;span class=&quot;c1&quot;&gt;// in the process.  This is rounding variance, so the variance is
&lt;/span&gt;	&lt;span class=&quot;c1&quot;&gt;// (roughly) 1/12th.
&lt;/span&gt;	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dropped_bits&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;current_variance&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pow&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dropped_bits&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;current_variance&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;12.&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;current_variance&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The result of this calculation will be passed to the &lt;a href=&quot;https://github.com/ZipCPU/cordic/blob/master/bench/cpp/cordic_tb.cpp&quot;&gt;test
bench&lt;/a&gt;
by passing a &lt;code class=&quot;highlighter-rouge&quot;&gt;QUANTIZATION_VARIANCE&lt;/code&gt; value to the &lt;a href=&quot;https://github.com/ZipCPU/cordic/blob/master/bench/cpp/cordic_tb.cpp&quot;&gt;test
bench&lt;/a&gt;
within our core-generated
&lt;a href=&quot;https://github.com/ZipCPU/cordic/blob/master/rtl/cordic.h&quot;&gt;header file&lt;/a&gt;:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;QUANTIZATION_VARIANCE&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;actual&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;goes&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;here&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;//&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Units&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;^&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This will then inform our &lt;a href=&quot;https://github.com/ZipCPU/cordic/blob/master/bench/cpp/cordic_tb.cpp&quot;&gt;test bench
code&lt;/a&gt;
the average sum of square errors that it can expect.&lt;/p&gt;

&lt;p&gt;At this point, we’re almost done with our pre-work.  We have only one step
left, and that is looking into any
&lt;a href=&quot;https://en.wikipedia.org/wiki/Variance&quot;&gt;variance&lt;/a&gt;
associated with the phase accumulator.&lt;/p&gt;

&lt;h2 id=&quot;phase-error&quot;&gt;Phase Error&lt;/h2&gt;

&lt;p&gt;There’s one last component to the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Variance&quot;&gt;variance&lt;/a&gt;
of our result, and that’s the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Variance&quot;&gt;variance&lt;/a&gt;
associated with the phase accumulator.  You may recall that, at each
stage of our
&lt;a href=&quot;/dsp/2017/08/30/cordic.html&quot;&gt;CORDIC algorithm&lt;/a&gt;, we added
or subtracted an amount of phase to a phase accumulator.  We calculated
these phase values within
&lt;a href=&quot;https://github.com/ZipCPU/cordic/blob/master/sw/cordiclib.cpp&quot;&gt;cordiclib.cpp&lt;/a&gt;
and placed these values into the &lt;code class=&quot;highlighter-rouge&quot;&gt;cordic_angle&lt;/code&gt; array within our &lt;a href=&quot;https://github.com/ZipCPU/cordic/blob/master/rtl/cordic.v&quot;&gt;generated
routine&lt;/a&gt;.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/eqn-cordic-phase.png&quot; alt=&quot;theta_k = atan(2^{-k})&quot; width=&quot;168&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;The problem with this array is that the phase values had to be
&lt;a href=&quot;/dsp/2017/09/27/quantization.html&quot;&gt;quantized&lt;/a&gt;
in order to be placed into this integer array.  This quantization can be
found within our
&lt;a href=&quot;https://github.com/ZipCPU/cordic/blob/master/sw/cordiclib.cpp&quot;&gt;CORDIC library&lt;/a&gt;:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;	&lt;span class=&quot;nf&quot;&gt;cordic_angles&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;FILE&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nstages&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;phase_bits&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;// ...
&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nstages&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt;		&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;phase_value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

		&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;atan2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;1.&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pow&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
		&lt;span class=&quot;c1&quot;&gt;// ...
&lt;/span&gt;		&lt;span class=&quot;c1&quot;&gt;// Convert this value from radians to our integer phase units
&lt;/span&gt;		&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;4.0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1ul&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;phase_bits&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)))&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;M_PI&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;2.0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

		&lt;span class=&quot;c1&quot;&gt;// Here&#39;s where we truncate our phase from a double to an
&lt;/span&gt;		&lt;span class=&quot;c1&quot;&gt;// integer.
&lt;/span&gt;		&lt;span class=&quot;n&quot;&gt;phase_value&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;c1&quot;&gt;// ...
&lt;/span&gt;	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;// ...
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This means that though we intended to rotate by one angle,
we ended up rotating by an approximation of that angle.  If we let
&lt;code class=&quot;highlighter-rouge&quot;&gt;gamma&lt;/code&gt; reference the
&lt;a href=&quot;/dsp/2017/08/30/cordic.html&quot;&gt;CORDIC&lt;/a&gt;
gain, &lt;code class=&quot;highlighter-rouge&quot;&gt;R(theta)&lt;/code&gt; represent the rotation we
wanted to accomplish, and &lt;code class=&quot;highlighter-rouge&quot;&gt;e_ox&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;e_oy&lt;/code&gt; be the algorithm errors we’ve
been discussing so far, then our result should be:&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/eqn-cordic-desired.png&quot; alt=&quot;[X,Y] = gR(theta)+errs&quot; width=&quot;337&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;The problem with this representation is that it doesn’t acknowledge any of these
phase errors.  In other words, because we’ve only &lt;em&gt;approximated&lt;/em&gt; the
phase errors with integers, we ended up rotating by a different phase–one
that was &lt;em&gt;close&lt;/em&gt; to what we wanted to rotate by:&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/eqn-cordic-err-rotation.png&quot; alt=&quot;[X,Y] = gR(theta+eta)+errs&quot; width=&quot;375&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;If we separate the rotation into two rotations, one by the rotation we want,
&lt;code class=&quot;highlighter-rouge&quot;&gt;R(theta)&lt;/code&gt;, and the other by the rotation we didn’t want, &lt;code class=&quot;highlighter-rouge&quot;&gt;R(eta)&lt;/code&gt;, we can
rewrite this as:&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/eqn-cordic-rotation-separated.png&quot; alt=&quot;[X,Y] = gR(theta)R(eta)+errs&quot; width=&quot;544&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Finally, if we use a small angle approximation for &lt;code class=&quot;highlighter-rouge&quot;&gt;eta&lt;/code&gt;, then this can be
rewritten as something a touch more useful:&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/eqn-cordic-rotation-variance.png&quot; alt=&quot;EQN approximating eta with a small angle formula&quot; width=&quot;446&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;At this point, our results are separated between the results we want, together
with an additive “noise” term that we didn’t want.  From here, then, we can use
our &lt;a href=&quot;/dsp/2017/09/27/quantization.html&quot;&gt;scale and addition
rules&lt;/a&gt;
to determine the &lt;a href=&quot;https://en.wikipedia.org/wiki/Variance&quot;&gt;variance&lt;/a&gt;
of the result.  This is given by first the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Variance&quot;&gt;variance&lt;/a&gt;
we worked out in the last session, &lt;code class=&quot;highlighter-rouge&quot;&gt;V[e_o]&lt;/code&gt;, as well as a new term
associated with the rotation error.  This new term consists of a couple
of scalar values, both the known
&lt;a href=&quot;/dsp/2017/08/30/cordic.html&quot;&gt;CORDIC&lt;/a&gt;
gain, &lt;code class=&quot;highlighter-rouge&quot;&gt;gamma&lt;/code&gt; and the outputs of our algorithm, &lt;code class=&quot;highlighter-rouge&quot;&gt;x_k&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;y_k&lt;/code&gt;.  It also
consists of the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Variance&quot;&gt;variance&lt;/a&gt;
of our random phase variable, &lt;code class=&quot;highlighter-rouge&quot;&gt;eta&lt;/code&gt;.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/eqn-cordic-rotation-err-variance.png&quot; alt=&quot;V[ghx+ey]=g^2x^2V[h]+V[ey]&quot; width=&quot;363&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;That’s how random phase errors are going to affect our output.&lt;/p&gt;

&lt;p&gt;But, what is this last phase
&lt;a href=&quot;https://en.wikipedia.org/wiki/Variance&quot;&gt;variance&lt;/a&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;V[eta]&lt;/code&gt;?&lt;/p&gt;

&lt;p&gt;To understand that, let’s go back and look through the logic for the
&lt;a href=&quot;/dsp/2017/08/30/cordic.html&quot;&gt;CORDIC&lt;/a&gt;
stages again.  At each stage, we approximated a phase with an integer
(quantized) value.  Unlike before, where the difference between the true value
and the quantized value was unknown,
in this case we know the difference between the original phase
value and its truncated representation.  Hence, with a probability of one
half that this difference should be positive, and one half that it is
negative, we can calculate the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Variance&quot;&gt;variance&lt;/a&gt;
of the accumulated phase.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;&lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt;	&lt;span class=&quot;nf&quot;&gt;phase_variance&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nstages&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;phase_bits&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;RAD_TO_PHASE&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1ul&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;phase_bits&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)))&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;M_PI&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;variance&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

	&lt;span class=&quot;c1&quot;&gt;// Start with an initial quantization variance, before we do anything
&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;variance&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;1.&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;12.&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nstages&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt;		&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;err&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;phase_value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

		&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;atan2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;1.&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pow&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;RAD_TO_PHASE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;phase_value&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;c1&quot;&gt;// Calculate the error between the phase we want, and our
&lt;/span&gt;		&lt;span class=&quot;c1&quot;&gt;// integer phase representation
&lt;/span&gt;		&lt;span class=&quot;n&quot;&gt;err&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;phase_value&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;c1&quot;&gt;// Square it to turn it into a variance.
&lt;/span&gt;		&lt;span class=&quot;n&quot;&gt;err&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;err&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;c1&quot;&gt;// Accumulate it with the rest of the variance(s)
&lt;/span&gt;		&lt;span class=&quot;c1&quot;&gt;// from the cordic angles
&lt;/span&gt;		&lt;span class=&quot;n&quot;&gt;variance&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;err&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

	&lt;span class=&quot;c1&quot;&gt;// Convert the calculated variance back to radians
&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;variance&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pow&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;RAD_TO_PHASE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;2.&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;variance&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;We’ll calculate and place this rotation phase error into its own value
within our core-generated
&lt;a href=&quot;https://github.com/ZipCPU/cordic/blob/master/rtl/cordic.h&quot;&gt;C header file&lt;/a&gt;:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;PHASE_VARIANCE_RAD&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;actual&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;goes&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;here&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;//&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Radians&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;^&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;So, at this point we’ve worked out the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Variance&quot;&gt;variance&lt;/a&gt;
associated with our
&lt;a href=&quot;/dsp/2017/08/30/cordic.html&quot;&gt;CORDIC rotation&lt;/a&gt;s,
and now we’ve worked out the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Variance&quot;&gt;variance&lt;/a&gt;
associated with truncated our phase accumulator values.  With these values, we
can now begin to put our &lt;a href=&quot;https://github.com/ZipCPU/cordic/blob/master/bench/cpp/cordic_tb.cpp&quot;&gt;test
bench&lt;/a&gt;
together.&lt;/p&gt;

&lt;h2 id=&quot;building-the-test-bench&quot;&gt;Building the Test Bench&lt;/h2&gt;

&lt;p&gt;This has taken a lot of background, but it’s now time to build our &lt;a href=&quot;https://github.com/ZipCPU/cordic/blob/master/bench/cpp/cordic_tb.cpp&quot;&gt;test
bench&lt;/a&gt;.
Our test bench will be based around the idea of rotating a fixed, maximal
valued, input through all of the possible phase rotations.&lt;/p&gt;

&lt;p&gt;To start, we’ll define some helper values, both the log (based two) of the
number of test samples as well as the number of test samples, that the
rest of our code here can reference.  Since we’re going to go through one
wavelength of a sine wave, these are determined by the phase width parameter,
&lt;code class=&quot;highlighter-rouge&quot;&gt;PW&lt;/code&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;LGNSAMPLES&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;PW&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;NSAMPLES&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1ul&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;LGNSAMPLES&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;We’ll also set our sine wave’s amplitude to the maximum value that will not
overflow,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;&lt;span class=&quot;n&quot;&gt;m_core&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i_xval&lt;/span&gt;  &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1ul&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;IW&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;m_core&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i_yval&lt;/span&gt;  &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This value will be necessary to maximize our
&lt;a href=&quot;https://en.wikipedia.org/wiki/Carrier-to-noise_ratio&quot;&gt;Carrier-to-noise ratio&lt;/a&gt;
in the face of a fixed amount of background noise.&lt;/p&gt;

&lt;p&gt;With this as background, we can create &lt;code class=&quot;highlighter-rouge&quot;&gt;NSAMPLES&lt;/code&gt; test cases, pushing the
inputs into our
&lt;a href=&quot;/dsp/2017/08/30/cordic.html&quot;&gt;CORDIC algorithm&lt;/a&gt;’s
&lt;a href=&quot;https://github.com/ZipCPU/cordic/blob/master/rt/cordic.v&quot;&gt;HDL routine&lt;/a&gt;.
The difference from one test to the next will be the phase rotation.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;	&lt;span class=&quot;n&quot;&gt;idx&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NSAMPLES&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;shift&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;PW&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;LGNSAMPLES&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;shift&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
			&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;sv&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
			&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1ul&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;shift&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)))&lt;/span&gt;
				&lt;span class=&quot;c1&quot;&gt;// Odd value, round down
&lt;/span&gt;				&lt;span class=&quot;n&quot;&gt;sv&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1ul&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;shift&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
			&lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;
				&lt;span class=&quot;n&quot;&gt;sv&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1ul&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;shift&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;tb&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_core&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i_phase&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sv&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;shift&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
		&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;tb&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_core&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i_phase&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;shift&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;pdata&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tb&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_core&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i_phase&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;ixval&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tb&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_core&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i_xval&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;iyval&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tb&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_core&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i_yval&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;tb&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_core&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i_aux&lt;/span&gt;   &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;tb&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tick&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;

		&lt;span class=&quot;o&quot;&gt;//&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;We’re also going to insist that this algorithm uses the &lt;a href=&quot;/blog/2017/08/14/strategies-for-pipelining.html&quot;&gt;travelling
CE&lt;/a&gt;
form of pipeline management.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;	&lt;span class=&quot;n&quot;&gt;assert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;HAS_AUX&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This means that we set &lt;code class=&quot;highlighter-rouge&quot;&gt;i_aux&lt;/code&gt; on any input
with a valid value, and anytime &lt;code class=&quot;highlighter-rouge&quot;&gt;o_aux&lt;/code&gt; is true on the output we’ll have a
valid output value.  So that we can work on all these values at the same
time, we’ll place the output values into an array as they become valid.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;		&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tb&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_core&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;o_aux&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;shift&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;8&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;OW&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
			&lt;span class=&quot;c1&quot;&gt;// Make our values signed..
&lt;/span&gt;			&lt;span class=&quot;n&quot;&gt;xval&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;idx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tb&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_core&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;o_xval&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;shift&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;yval&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;idx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tb&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_core&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;o_yval&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;shift&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;xval&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;idx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;shift&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;yval&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;idx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;shift&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
			&lt;span class=&quot;c1&quot;&gt;// printf(&quot;%08x&amp;lt;&amp;lt;%d: %08x %08x\n&quot;, (unsigned)pdata[i], shift, xval[idx], yval[idx]);
&lt;/span&gt;			&lt;span class=&quot;n&quot;&gt;idx&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;You may notice how &lt;code class=&quot;highlighter-rouge&quot;&gt;idx&lt;/code&gt; is used to separate the actual loop variable, &lt;code class=&quot;highlighter-rouge&quot;&gt;i&lt;/code&gt;,
from the array index associated with the return values.  This allows us to
compensate for whatever delay the algorithm might have.&lt;/p&gt;

&lt;p&gt;Since the
&lt;a href=&quot;/dsp/2017/08/30/cordic.html&quot;&gt;CORDIC&lt;/a&gt;
takes a couple clocks to process its results, our last output will likely
not be available to us as soon as we provide our last input.  Hence, we’ll need
to flush these last results out.  To do this, we set the input &lt;a href=&quot;/blog/2017/08/14/strategies-for-pipelining.html&quot;&gt;traveling
CE&lt;/a&gt;
bit, &lt;code class=&quot;highlighter-rouge&quot;&gt;i_aux&lt;/code&gt;, to zero and wait till the output CE bit, &lt;code class=&quot;highlighter-rouge&quot;&gt;o_aux&lt;/code&gt; goes to zero
as well.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;	&lt;span class=&quot;n&quot;&gt;tb&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_core&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i_aux&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tb&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_core&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;o_aux&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;shift&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;8&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;OW&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;tb&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_core&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i_aux&lt;/span&gt;   &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;tb&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tick&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;

		&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tb&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_core&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;o_aux&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;xval&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;idx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tb&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_core&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;o_xval&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;shift&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;yval&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;idx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tb&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_core&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;o_yval&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;shift&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;xval&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;idx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;shift&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;yval&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;idx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;shift&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
			&lt;span class=&quot;c1&quot;&gt;// printf(&quot;%08x %08x\n&quot;, xval[idx], yval[idx]);
&lt;/span&gt;			&lt;span class=&quot;n&quot;&gt;idx&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;assert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;idx&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NSAMPLES&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
		&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Finally, let’s pull all these results together and examine them.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;	&lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;mxerr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;averr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mag&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;imag&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sumxy&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;sumsq&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sumd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NSAMPLES&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;shift&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;ph&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dxval&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dyval&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;err&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

		&lt;span class=&quot;o&quot;&gt;//&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The first step in evaluating these results is going to be determine the
answers that the &lt;a href=&quot;/dsp/2017/08/30/cordic.html&quot;&gt;CORDIC&lt;/a&gt;
algorithm was &lt;em&gt;supposed&lt;/em&gt; to produce.  In other words,
what angle was given to it, what rectangular coordinates were given to it,
and therefore what values, &lt;code class=&quot;highlighter-rouge&quot;&gt;dxval&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;dyval&lt;/code&gt;, &lt;em&gt;should’ve&lt;/em&gt; been returned.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;		&lt;span class=&quot;n&quot;&gt;ph&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pdata&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;ph&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ph&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;M_PI&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;2.0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1u&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;PW&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;dxval&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cos&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ph&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ixval&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ph&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;iyval&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;dyval&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ph&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ixval&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cos&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ph&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;iyval&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The &lt;a href=&quot;/dsp/2017/08/30/cordic.html&quot;&gt;CORDIC algorithm&lt;/a&gt;
applied a gain to our inputs, as we
&lt;a href=&quot;/dsp/2017/08/30/cordic.html&quot;&gt;discussed earlier&lt;/a&gt;.
Hence, the output is not just the rotated input, but that rotated result needs
to be multiplied by the
&lt;a href=&quot;/dsp/2017/08/30/cordic.html&quot;&gt;CORDIC&lt;/a&gt;
gain before we can tell if it was done right or not.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;		&lt;span class=&quot;n&quot;&gt;dxval&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GAIN&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;dyval&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GAIN&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;As a last step in trying to figure out what our answer &lt;em&gt;should&lt;/em&gt; be, we’ll need
to compensate our &lt;em&gt;perfect&lt;/em&gt; answer for any change in word width.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;		&lt;span class=&quot;n&quot;&gt;shift&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;IW&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;OW&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;IW&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;OW&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;dxval&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*=&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;1.&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1u&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;shift&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;dyval&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*=&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;1.&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1u&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;shift&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
		&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;OW&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;IW&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;dxval&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*=&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;1.&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1u&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;shift&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;dyval&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*=&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;1.&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1u&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;shift&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
		&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Now that we know the value we wanted the
&lt;a href=&quot;/dsp/2017/08/30/cordic.html&quot;&gt;CORDIC algorithm&lt;/a&gt;
to produce,
let’s compare it to the value that was produced.  We’ll estimate the
squared differences between what we think the algorithm should produce
and what it actually produced in the variable, &lt;code class=&quot;highlighter-rouge&quot;&gt;err&lt;/code&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;		&lt;span class=&quot;c1&quot;&gt;// The error between the value requested and the value resulting
&lt;/span&gt;		&lt;span class=&quot;n&quot;&gt;err&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dxval&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;xval&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dxval&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;xval&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]);&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;err&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dyval&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;yval&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dyval&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;yval&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;We can even calculate an average of this squared error, by accumulating these
square values into &lt;code class=&quot;highlighter-rouge&quot;&gt;averr&lt;/code&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;		&lt;span class=&quot;n&quot;&gt;averr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;err&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;As a final value to examine, let’s keep track of the maximum difference
between our expected and returned values.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;		&lt;span class=&quot;n&quot;&gt;err&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sqrt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;err&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;err&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mxerr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;mxerr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;err&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;To turn the sum of the squared errors into an estimated
&lt;a href=&quot;https://en.wikipedia.org/wiki/Standard_deviation&quot;&gt;standard deviation&lt;/a&gt;,
we’ll need to divide by the number of samples and take the square root of the
result.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;	&lt;span class=&quot;n&quot;&gt;averr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NSAMPLES&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;averr&lt;/span&gt;  &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sqrt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;averr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;We can check whether or not this average squared error is within bounds, and
fail if not.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;averr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;1.5&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sqrt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;QUANTIZATION_VARIANCE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;failed&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The &lt;a href=&quot;https://en.wikipedia.org/wiki/Magic_number_(programming)&quot;&gt;magic number&lt;/a&gt;
in this comparison, &lt;code class=&quot;highlighter-rouge&quot;&gt;1.5&lt;/code&gt;, is simply a heuristic that has worked for me so far.
While a threshold could be calculated from a proper &lt;a href=&quot;https://en.wikipedia.org/wiki/Statistical_hypothesis_testing&quot;&gt;statistical hypothesis
test&lt;/a&gt; basis, this
number has worked well enough for me.&lt;/p&gt;

&lt;p&gt;In a similar fashion, the maximum error should lie within a fixed number
of &lt;a href=&quot;https://en.wikipedia.org/wiki/Standard_deviation&quot;&gt;standard deviation&lt;/a&gt;s
from zero.  The
&lt;a href=&quot;https://en.wikipedia.org/wiki/Magic_number_(programming)&quot;&gt;magic number&lt;/a&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;5.2&lt;/code&gt; below is a heuristic, though, since we haven’t done the proper
statistical analysis to make this exact.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mxerr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;5.2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sqrt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;expected_err&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;ERR: Maximum error is out of bounds&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;failed&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Perhaps a more useful result is the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Carrier-to-noise_ratio&quot;&gt;Carrier-to-noise ratio&lt;/a&gt;
that can be achieved.  This should be given by the energy in the sine wave
input, times the
&lt;a href=&quot;/dsp/2017/08/30/cordic.html&quot;&gt;CORDIC&lt;/a&gt;
gain, squared and then divided by the estimated
&lt;a href=&quot;https://en.wikipedia.org/wiki/Variance&quot;&gt;variance&lt;/a&gt;.  Since we already have the
sine wave magnitude times the
&lt;a href=&quot;/dsp/2017/08/30/cordic.html&quot;&gt;CORDIC&lt;/a&gt;
gain captured by our &lt;code class=&quot;highlighter-rouge&quot;&gt;scale&lt;/code&gt; variable, we can just square this to get our
&lt;a href=&quot;/dsp/2017/08/30/cordic.html&quot;&gt;CORDIC&lt;/a&gt;
carrier energy.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;	&lt;span class=&quot;n&quot;&gt;scale&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GAIN&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;CNR    : %.2f dB&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;10.0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;scale&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;scale&lt;/span&gt;
			&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;averr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;averr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;10.0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;As a last test of whether or not this
&lt;a href=&quot;/dsp/2017/08/30/cordic.html&quot;&gt;CORDIC algorithm&lt;/a&gt;
works, let’s check out the &lt;a href=&quot;https://en.wikipedia.org/wiki/Spurious-free_dynamic_range&quot;&gt;Spurious Free Dynamic Range
(SFDR)&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;We’ll use the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Fast_Fourier_transform&quot;&gt;FFT&lt;/a&gt;
of the core’s output to find the maximum spur energy for our
&lt;a href=&quot;https://en.wikipedia.org/wiki/Spurious-free_dynamic_range&quot;&gt;SFDR&lt;/a&gt;
estimate.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;PW&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;26&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NSAMPLES&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1ul&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PW&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)))&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;typedef&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;complex&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;COMPLEX&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;COMPLEX&lt;/span&gt;	&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;outpt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt;	&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;FFTLEN&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1ul&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;PW&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

		&lt;span class=&quot;n&quot;&gt;outpt&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;COMPLEX&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;FFTLEN&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;

		&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;FFTLEN&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;outpt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;real&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;xval&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;outpt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;imag&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;yval&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
		&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

		&lt;span class=&quot;c1&quot;&gt;// Now we need to do an FFT
&lt;/span&gt;		&lt;span class=&quot;n&quot;&gt;cfft&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;outpt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;FFTLEN&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;We’ll then use the energy in the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Fast_Fourier_transform&quot;&gt;FFT&lt;/a&gt;
output bin related to our signal for our signal’s energy, while using the
maximum output bin energy across the rest of the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Fast_Fourier_transform&quot;&gt;FFT&lt;/a&gt;
for the maximum spur energy.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;		&lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;master&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;spur&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tmp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

		&lt;span class=&quot;c1&quot;&gt;// Master is the energy in the signal of interest
&lt;/span&gt;		&lt;span class=&quot;n&quot;&gt;master&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;norm&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;outpt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]);&lt;/span&gt;

		&lt;span class=&quot;c1&quot;&gt;// SPUR is the energy in any other FFT bin output
&lt;/span&gt;		&lt;span class=&quot;n&quot;&gt;spur&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;norm&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;outpt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]);&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;FFTLEN&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;tmp&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;norm&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;outpt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]);&lt;/span&gt;
			&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tmp&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;spur&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
				&lt;span class=&quot;n&quot;&gt;spur&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tmp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The ratio of these two values is the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Spurious-free_dynamic_range&quot;&gt;SFDR&lt;/a&gt;,
another indication of the quality of how well this algorithm works.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;		&lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;SPFR = %7.2f dBc&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
			&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;master&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;spur&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;10.&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Unlike the average error, though, which we could calculate from the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Expected_value&quot;&gt;expected&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Variance&quot;&gt;variance&lt;/a&gt;
above, predicting the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Spurious-free_dynamic_range&quot;&gt;SFDR&lt;/a&gt;
isn’t as simple.  Therefore, we’ll only calculate it as part of our &lt;a href=&quot;https://github.com/ZipCPU/cordic/blob/master/bench/cpp/cordic_tb.cpp&quot;&gt;test
bench&lt;/a&gt;
and leave you to decide whether it is good enough.&lt;/p&gt;

&lt;h2 id=&quot;performance-numbers&quot;&gt;Performance Numbers&lt;/h2&gt;

&lt;p&gt;We can now measure both &lt;em&gt;if&lt;/em&gt; our
&lt;a href=&quot;/dsp/2017/08/30/cordic.html&quot;&gt;CORDIC algorithm&lt;/a&gt; works,
as well as how well it works.&lt;/p&gt;

&lt;p&gt;So … how well &lt;em&gt;does&lt;/em&gt; it work?&lt;/p&gt;

&lt;p&gt;Just to find out, I ran the
&lt;a href=&quot;/dsp/2017/08/30/cordic.html&quot;&gt;CORDIC&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/cordic/tree/master/sw/&quot;&gt;core generator software&lt;/a&gt;,
and tested the
&lt;a href=&quot;/dsp/2017/08/30/cordic.html&quot;&gt;CORDIC algorithm&lt;/a&gt;
for a variety of bit widths and phase bit widths.  Shown below, in Table 1,
are the &lt;a href=&quot;https://en.wikipedia.org/wiki/Carrier-to-noise_ratio&quot;&gt;Carrier-to-noise ratio
(CNR)&lt;/a&gt; and &lt;a href=&quot;https://en.wikipedia.org/wiki/Spurious-free_dynamic_range&quot;&gt;Spurious Free
Dynamic Range&lt;/a&gt;
measurements the &lt;a href=&quot;https://github.com/ZipCPU/cordic/blob/master/bench/cpp/cordic_tb.cpp&quot;&gt;test
bench&lt;/a&gt;
recorded.&lt;/p&gt;

&lt;table align=&quot;center&quot; border=&quot;&quot;&gt;&lt;tr&gt;&lt;th&gt;IW, OW Bits&lt;/th&gt;&lt;th&gt;Phase bits&lt;/th&gt;&lt;th&gt;Xtra Bits&lt;/th&gt;&lt;th&gt;CNR&lt;/th&gt;&lt;th&gt;SFDR&lt;/th&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt; 8&lt;/td&gt;&lt;td&gt;13&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;42&lt;/td&gt;&lt;td&gt;43&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt; 8&lt;/td&gt;&lt;td&gt;14&lt;/td&gt;&lt;td&gt;2&lt;/td&gt;&lt;td&gt;46&lt;/td&gt;&lt;td&gt;57&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt; 8&lt;/td&gt;&lt;td&gt;15&lt;/td&gt;&lt;td&gt;3&lt;/td&gt;&lt;td&gt;49&lt;/td&gt;&lt;td&gt;62&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt; 8&lt;/td&gt;&lt;td&gt;16&lt;/td&gt;&lt;td&gt;4&lt;/td&gt;&lt;td&gt;50&lt;/td&gt;&lt;td&gt;64&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;12&lt;/td&gt;&lt;td&gt;17&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;65&lt;/td&gt;&lt;td&gt;69&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;12&lt;/td&gt;&lt;td&gt;18&lt;/td&gt;&lt;td&gt;2&lt;/td&gt;&lt;td&gt;69&lt;/td&gt;&lt;td&gt;82&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;12&lt;/td&gt;&lt;td&gt;19&lt;/td&gt;&lt;td&gt;3&lt;/td&gt;&lt;td&gt;73&lt;/td&gt;&lt;td&gt;88&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;12&lt;/td&gt;&lt;td&gt;20&lt;/td&gt;&lt;td&gt;4&lt;/td&gt;&lt;td&gt;74&lt;/td&gt;&lt;td&gt;94&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;16&lt;/td&gt;&lt;td&gt;21&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;87&lt;/td&gt;&lt;td&gt;92&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;16&lt;/td&gt;&lt;td&gt;22&lt;/td&gt;&lt;td&gt;2&lt;/td&gt;&lt;td&gt;92&lt;/td&gt;&lt;td&gt;106&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;16&lt;/td&gt;&lt;td&gt;23&lt;/td&gt;&lt;td&gt;3&lt;/td&gt;&lt;td&gt;96&lt;/td&gt;&lt;td&gt;112&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;16&lt;/td&gt;&lt;td&gt;24&lt;/td&gt;&lt;td&gt;4&lt;/td&gt;&lt;td&gt;98&lt;/td&gt;&lt;td&gt;117&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;24&lt;/td&gt;&lt;td&gt;29&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;(136)&lt;/td&gt;&lt;td&gt;N/A&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;24&lt;/td&gt;&lt;td&gt;30&lt;/td&gt;&lt;td&gt;2&lt;/td&gt;&lt;td&gt;(140)&lt;/td&gt;&lt;td&gt;N/A&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;24&lt;/td&gt;&lt;td&gt;31&lt;/td&gt;&lt;td&gt;3&lt;/td&gt;&lt;td&gt;(144)&lt;/td&gt;&lt;td&gt;N/A&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;24&lt;/td&gt;&lt;td&gt;32&lt;/td&gt;&lt;td&gt;4&lt;/td&gt;&lt;td&gt;(146)&lt;/td&gt;&lt;td&gt;N/A&lt;/td&gt;&lt;/tr&gt;
&lt;caption&gt;Table 1: Test-bench test results (simulation)&lt;/caption&gt;&lt;/table&gt;

&lt;p&gt;As you can see from the table, the
&lt;a href=&quot;/dsp/2017/08/30/cordic.html&quot;&gt;CORDIC algorithm&lt;/a&gt;’s
performance improves, for a given bit width, as the number of extra
internal bits increases until these get to about four.  At this point,
the improvement settles out, and little further gain can be had.&lt;/p&gt;

&lt;p&gt;One common estimate of &lt;a href=&quot;https://en.wikipedia.org/wiki/Quantization_(signal_processing)&quot;&gt;quantization noise is that you can achieve 6-dB of
performance per bit of sample
width&lt;/a&gt;.
By this measure, we might expect a 48 dB
&lt;a href=&quot;https://en.wikipedia.org/wiki/Carrier-to-noise_ratio&quot;&gt;CNR&lt;/a&gt;
for an 8-bit output, a 72 dB
&lt;a href=&quot;https://en.wikipedia.org/wiki/Carrier-to-noise_ratio&quot;&gt;CNR&lt;/a&gt;
for a 12-bit output, 96 dB
&lt;a href=&quot;https://en.wikipedia.org/wiki/Carrier-to-noise_ratio&quot;&gt;CNR&lt;/a&gt;
for a 16-bit output, and 144 dB
&lt;a href=&quot;https://en.wikipedia.org/wiki/Carrier-to-noise_ratio&quot;&gt;CNR&lt;/a&gt;
for a 24-bit output.  Our measured results are roughly consistent
with this rule, so they appear to be reasonably accurate.&lt;/p&gt;

&lt;p&gt;Likewise the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Spurious-free_dynamic_range&quot;&gt;SFDR&lt;/a&gt;
measurements showed a clear increase in performance as the bit
widths involved increased.&lt;/p&gt;

&lt;p&gt;Digging further, the predicted
&lt;a href=&quot;https://en.wikipedia.org/wiki/Carrier-to-noise_ratio&quot;&gt;CNR&lt;/a&gt; values matched
the &lt;a href=&quot;https://github.com/ZipCPU/cordic/blob/master/bench/cpp/cordic_tb.cpp&quot;&gt;test
bench&lt;/a&gt;
measured values within a &lt;a href=&quot;https://en.wikipedia.org/wiki/Decibel&quot;&gt;dB&lt;/a&gt; or two.&lt;/p&gt;

&lt;p&gt;The &lt;a href=&quot;https://github.com/ZipCPU/cordic/blob/master/bench/cpp/cordic_tb.cpp&quot;&gt;test
bench&lt;/a&gt;,
however, failed when it got to the larger phase widths: 29 and above.  In
particular, the test bench failed for all of the phase widths appropriate for
the 24-bit samples.  The error given, that of a memory allocation error,
illustrates a weakness in a test methodology that works by first recording all
of the answers into memory and then processes those results.&lt;/p&gt;

&lt;p&gt;Because the &lt;a href=&quot;https://github.com/ZipCPU/cordic/blob/master/bench/cpp/cordic_tb.cpp&quot;&gt;test
bench&lt;/a&gt;
failed for the 24-bit case, the &lt;em&gt;expected&lt;/em&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Carrier-to-noise_ratio&quot;&gt;CNR&lt;/a&gt;
values are shown (in parentheses) rather than any &lt;em&gt;measured&lt;/em&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Carrier-to-noise_ratio&quot;&gt;CNR&lt;/a&gt; values.
Since these expected values were consistent with the predicted
&lt;a href=&quot;https://en.wikipedia.org/wiki/Carrier-to-noise_ratio&quot;&gt;CNR&lt;/a&gt; values for
the rest of the test (comparison not shown), they are at least an indication
of what one might expect when using this routine for larger bit-widths.&lt;/p&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;It’s taken us a lot of work to get to this point, where we can estimate the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Carrier-to-noise_ratio&quot;&gt;CNR&lt;/a&gt; performance that a
&lt;a href=&quot;/dsp/2017/08/30/cordic.html&quot;&gt;CORDIC algorithm&lt;/a&gt;
will achieve, and then verify that it has that performance.  Indeed, the math
wasn’t pretty, and I’d be surprised if a large number of folks made it this
far.&lt;/p&gt;

&lt;p&gt;Please accept my apologies.  I would like to keep this blog as simple as the
RTL code I’m sharing, and this was not that simple.&lt;/p&gt;

&lt;p&gt;The problem that lead us to this point, though, is simple: how do you know
when an algorithm’s results are “good enough.”  It was this particular
question that sent us this deep into the (hard-to-follow) mathematics above and
in our &lt;a href=&quot;/dsp/2017/09/27/quantization.html&quot;&gt;prior post&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Further, despite the complexity of this development today, we still didn’t
solve &lt;em&gt;all&lt;/em&gt; of the mathematical problems associated with a &lt;a href=&quot;https://github.com/ZipCPU/cordic/blob/master/bench/cpp/cordic_tb.cpp&quot;&gt;test
bench&lt;/a&gt;
of this type.  In particular, we didn’t apply any proper statistical
bases to the &lt;a href=&quot;https://en.wikipedia.org/wiki/Statistical_hypothesis_testing&quot;&gt;hypothesis
test&lt;/a&gt;s within
our test bench.  As a result, we cannot be certain that this &lt;a href=&quot;https://github.com/ZipCPU/cordic/blob/master/rtl/cordic.v&quot;&gt;CORDIC
implementation&lt;/a&gt;
is as good as it can be.&lt;/p&gt;

&lt;p&gt;Still, this should be &lt;em&gt;good enough&lt;/em&gt; to move forward.&lt;/p&gt;

&lt;p&gt;Using these results, we now have some confidence that not only does the
&lt;a href=&quot;/dsp/2017/08/30/cordic.html&quot;&gt;CORDIC algorithm&lt;/a&gt; work,
but we also have the confidence that given the right parameters it will work
well enough for our purposes.&lt;/p&gt;

&lt;p&gt;What purposes might that be?  That question, my friend, we’ll have to answer
in another post.  This one has been too long already.&lt;/p&gt;
&lt;hr /&gt;&lt;p&gt;&lt;em&gt;In the beginning was the Word, and the Word was with God, and the Word was God. (John 1:1)&lt;/em&gt;</description>
        <pubDate>Mon, 02 Oct 2017 00:00:00 -0400</pubDate>
        <link>http://zipcpu.com/dsp/2017/10/02/cordic-tb.html</link>
        <guid isPermaLink="true">http://zipcpu.com/dsp/2017/10/02/cordic-tb.html</guid>
        
        
        <category>dsp</category>
        
      </item>
    
      <item>
        <title>A Cheaper Fast FIR Filter</title>
        <description>&lt;p&gt;Since we last put a generic
&lt;a href=&quot;/dsp/2017/09/15/fastfir.html&quot;&gt;high speed FIR together&lt;/a&gt;,
a friend showed me another
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
structure which can be used to create a high-speed
&lt;a href=&quot;https://en.wikipedia.org/wiki/Finite_impulse_response&quot;&gt;FIR&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;As you may recall from
&lt;a href=&quot;/dsp/2017/09/15/fastfir.html&quot;&gt;our last discussion&lt;/a&gt;,
a &lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;
is typically represented by the logic illustrated in Fig 1.&lt;/p&gt;

&lt;table style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 1: Traditional Filter Implementation&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/fir-form.svg&quot; alt=&quot;Generic FIR implementation structure&quot; width=&quot;380&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;In our &lt;a href=&quot;/dsp/2017/09/15/fastfir.html&quot;&gt;last presentation&lt;/a&gt;,
we noted that the accumulation step at the bottom of Fig 1 requires
a number of clocks to be successful.  Hence, every addition in that presentation
required a clock.  We then lined everything up by placing an extra delay
between the input data stages.&lt;/p&gt;

&lt;p&gt;Today, let’s take a look at a simpler structure for
&lt;a href=&quot;https://en.wikipedia.org/wiki/Finite_impulse_response&quot;&gt;FIR&lt;/a&gt;
evaluation.  By simpler,
I mean one that doesn’t require any of the double-delay structures we used
in our &lt;a href=&quot;/dsp/2017/09/15/fastfir.html&quot;&gt;last filter
implementation&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;simpler-structure&quot;&gt;Simpler Structure&lt;/h2&gt;

&lt;p&gt;This new simpler structure works by taking the delay line from the input
samples, and places it on the output accumulation line.  This concept is
notionally shown in Fig 2.&lt;/p&gt;

&lt;table style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 2: Simpler Filter Implementation&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/fir-dsp-structure.svg&quot; alt=&quot;Cheaper FIR implementation structure&quot; width=&quot;480&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Unlike Fig 1, there is no input delay line.  That delay line was moved to the
accumulation structure.  Another difference is that the taps are in a
reverse order.  Instead of running from &lt;code class=&quot;highlighter-rouge&quot;&gt;h[0]&lt;/code&gt; to &lt;code class=&quot;highlighter-rouge&quot;&gt;h[N-1]&lt;/code&gt; in Fig 1, the
taps in Fig 1 run from &lt;code class=&quot;highlighter-rouge&quot;&gt;h[N-1]&lt;/code&gt; to &lt;code class=&quot;highlighter-rouge&quot;&gt;h[0]&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The code for this simpler structure is &lt;em&gt;almost identical&lt;/em&gt; to the structure
we used before.  Indeed, the two are so similar, we could almost present the
code difference as a simple &lt;a href=&quot;https://en.wikipedia.org/wiki/Diff_utility&quot;&gt;diff&lt;/a&gt;.
We’ll choose to maintain a touch more context, though, and encourage you to try
a &lt;a href=&quot;https://en.wikipedia.org/wiki/Diff_utility&quot;&gt;diff&lt;/a&gt; between the two
components,
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/genericfir.v&quot;&gt;old&lt;/a&gt;
and &lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/fastfir.v&quot;&gt;new&lt;/a&gt;,
yourself.&lt;/p&gt;

&lt;p&gt;The first difference is that this simpler
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;
needs the same sample
value sent to all of the multiplies at once.  Hence, we’ll send
&lt;code class=&quot;highlighter-rouge&quot;&gt;sample[0]&lt;/code&gt; to all of the
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/firtap.v&quot;&gt;tap structures&lt;/a&gt;.
We’ll depend upon the synthesis tool to
clean up the unused delayed sample output still found within the
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/firtap.v&quot;&gt;tap structures&lt;/a&gt;.
This will generate some warnings, but should still work well.&lt;/p&gt;

&lt;p&gt;The second difference is that the taps of the
&lt;a href=&quot;/dsp/2017/09/15/fastfir.html&quot;&gt;prior generic FIR&lt;/a&gt;,
needed to be given to it in reverse order.  For this
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/fastfir.v&quot;&gt;new filter&lt;/a&gt;,
the taps are fed into
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/fastfir.v&quot;&gt;the filter&lt;/a&gt;
from &lt;code class=&quot;highlighter-rouge&quot;&gt;h[0]&lt;/code&gt; to &lt;code class=&quot;highlighter-rouge&quot;&gt;h[N_k-1]&lt;/code&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;for(k=0; k&amp;lt;NTAPS; k=k+1)
begin: FILTER

	firtap #(.FIXED_TAPS(FIXED_TAPS),
			.IW(IW), .OW(OW), .TW(TW),
			.INITIAL_VALUE(0))
		tapk(i_clk, i_reset,
			// Tap update circuitry
			tap_wr, tap[k], tapout[k+1], // !!!!!
			// Sample delay line
			// Well let the optimizer trim away sample[k+1]
			i_ce, sample[0], sample[k+1], // !!!!!
			// The output accumulator
			result[k], result[k+1]);

	if (!FIXED_TAPS)
		assign	tap[k+1] = tapout[k+1]; // !!!!!

	// ...
end endgenerate&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;I’ve placed exclamation points in-line following each of the changed
lines in the code above, so you can see where the changes are.&lt;/p&gt;

&lt;p&gt;You can find the code for &lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/fastfir.v&quot;&gt;this modified filter
here&lt;/a&gt;
next to the &lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/genericfir.v&quot;&gt;original filter&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;cost-comparison&quot;&gt;Cost Comparison&lt;/h2&gt;

&lt;p&gt;The cost of
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/fastfir.v&quot;&gt;this filter&lt;/a&gt;
is &lt;em&gt;almost&lt;/em&gt; exactly one DSP per tap–plus one
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flip-flop_(electronics)&quot;&gt;flip-flop&lt;/a&gt; per
stage per bit.&lt;/p&gt;

&lt;p&gt;There are two aspects of this design keeping this from being one DSP per tap.&lt;/p&gt;

&lt;p&gt;The first is that the &lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/firtap.v&quot;&gt;tap component
module&lt;/a&gt;
separates the addition from the multiplication.  This addition &lt;em&gt;could&lt;/em&gt; have
been subsumed, together with the multiply, into the DSP to make a multiply
and accumulate structure.  Instead, each of the &lt;code class=&quot;highlighter-rouge&quot;&gt;(N-1)&lt;/code&gt; additions still require
(roughly) two
&lt;a href=&quot;/blog/2017/06/12/minimizing-luts.html&quot;&gt;3-LUTs&lt;/a&gt; per output
bit.  The inputs to these
&lt;a href=&quot;/blog/2017/06/12/minimizing-luts.html&quot;&gt;3-LUTs&lt;/a&gt; are the
two inputs for the addition, plus the carry bit.  The output of the
&lt;a href=&quot;/blog/2017/06/12/minimizing-luts.html&quot;&gt;first LUT&lt;/a&gt;
is the addition output, and the &lt;a href=&quot;/blog/2017/06/12/minimizing-luts.html&quot;&gt;second
LUT&lt;/a&gt; the carry output.
Using &lt;a href=&quot;https://www.xilinx.com&quot;&gt;Xilinx&lt;/a&gt;
&lt;a href=&quot;https://www.xilinx.com/support/documentation/user_guides/ug474_7Series_CLB.pdf&quot;&gt;7-Series&lt;/a&gt;
devices, this addition can be &lt;a href=&quot;/blog/2017/06/12/minimizing-luts.html&quot;&gt;accomplished in one 6-LUT
per bit&lt;/a&gt; per tap.&lt;/p&gt;

&lt;p&gt;The second item keeping this from costing a single DSP per tap is the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flip-flop_(electronics)&quot;&gt;flip-flop&lt;/a&gt;
structure containing the tap values, &lt;code class=&quot;highlighter-rouge&quot;&gt;h[k]&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;When compared to the &lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/genericfir.v&quot;&gt;generic
filter&lt;/a&gt; we
&lt;a href=&quot;/dsp/2017/09/15/fastfir.html&quot;&gt;presented last time&lt;/a&gt;, the
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/genericfir.v&quot;&gt;last filter&lt;/a&gt;
included two
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flip-flop_(electronics)&quot;&gt;flip-flop&lt;/a&gt;s
per stage per bit in the input as well in addition to the rest of the logic
that remains in the &lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/fastfir.v&quot;&gt;newer
implementation&lt;/a&gt;.
These extra &lt;a href=&quot;https://en.wikipedia.org/wiki/Flip-flop_(electronics)&quot;&gt;flip-flop&lt;/a&gt;s
are gone in this &lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/fastfir.v&quot;&gt;updated
implementation&lt;/a&gt;,
rendering the &lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/fastfir.v&quot;&gt;updated
implementation&lt;/a&gt;
cheaper than the
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/genericfir.v&quot;&gt;last one&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;You might still choose to use the &lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/fastfir.v&quot;&gt;previous
implementation&lt;/a&gt;,
though.  In particular, the &lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/fastfir.v&quot;&gt;prior
implementation&lt;/a&gt;
doesn’t struggle with the fan-out issue this &lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/fastfir.v&quot;&gt;newer
implementation&lt;/a&gt;
has.  As a result, the &lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/fastfir.v&quot;&gt;previous
implementation&lt;/a&gt;
may be able to run at higher speeds.&lt;/p&gt;

&lt;h2 id=&quot;next-steps&quot;&gt;Next Steps&lt;/h2&gt;

&lt;p&gt;As I mentioned in the &lt;a href=&quot;/dsp/2017/09/15/fastfir.html&quot;&gt;last filtering
post&lt;/a&gt;,
there are many ways to implement
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filters&lt;/a&gt;
within &lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;’s
and there are many ways to simplify even this &lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/fastfir.v&quot;&gt;filter
implementation&lt;/a&gt;.
Should your application permit it, sharper
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filters&lt;/a&gt;
(i.e.  &lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filters&lt;/a&gt; with more taps)
may be possible.  For example:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Many filters are &lt;a href=&quot;https://en.wikipedia.org/wiki/Linear_phase&quot;&gt;symmetric
(linear-phase)&lt;/a&gt;.  A carefully
built &lt;a href=&quot;https://en.wikipedia.org/wiki/Linear_phase&quot;&gt;symmetric filter&lt;/a&gt; will
drop the number of required hardware multiplies in half.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Half-band_filter&quot;&gt;Half-band filters&lt;/a&gt; can be
built using only every other tap, dropping the number of hardware multiplies
required in half again.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Hilbert_transform&quot;&gt;Hilbert transforms&lt;/a&gt;,
are another special type of filter.  Both the 
&lt;a href=&quot;https://en.wikipedia.org/wiki/Half-band_filter&quot;&gt;half-band filter&lt;/a&gt; and the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Linear_phase&quot;&gt;symmetric filter&lt;/a&gt; optimizations
apply to &lt;a href=&quot;https://en.wikipedia.org/wiki/Hilbert_transform&quot;&gt;Hilbert
transforms&lt;/a&gt;, 
even though &lt;a href=&quot;https://en.wikipedia.org/wiki/Hilbert_transform&quot;&gt;Hilbert
transforms&lt;/a&gt; are neither
&lt;a href=&quot;https://en.wikipedia.org/wiki/Half-band_filter&quot;&gt;half-band&lt;/a&gt; nor
&lt;a href=&quot;https://en.wikipedia.org/wiki/Linear_phase&quot;&gt;symmetric filters&lt;/a&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;Filters&lt;/a&gt;
combined with
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sample-rate_conversion&quot;&gt;down-samplers&lt;/a&gt;
can also be accomplished with fewer hardware multiplies as well.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Once we finish or
&lt;a href=&quot;/dsp/2017/08/30/cordic.html&quot;&gt;CORDIC&lt;/a&gt;
&lt;a href=&quot;/dsp/2017/10/02/cordic-tb.html&quot;&gt;test bench&lt;/a&gt;, we’ll start
building a generic &lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filtering&lt;/a&gt;
test bench, prove these generic
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filtering&lt;/a&gt;
structures, and then come back and continue looking at some of the
optimizations outlined above.&lt;/p&gt;

&lt;hr /&gt;&lt;p&gt;&lt;em&gt;And a stranger will they not follow, but will flee from him: for they know not the voice of strangers. (John 10:5)&lt;/em&gt;</description>
        <pubDate>Fri, 29 Sep 2017 00:00:00 -0400</pubDate>
        <link>http://zipcpu.com/dsp/2017/09/29/cheaper-fast-fir.html</link>
        <guid isPermaLink="true">http://zipcpu.com/dsp/2017/09/29/cheaper-fast-fir.html</guid>
        
        
        <category>dsp</category>
        
      </item>
    
  </channel>
</rss>
