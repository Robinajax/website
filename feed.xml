<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>The ZipCPU by Gisselquist Technology</title>
    <description>The ZipCPU blog, featuring how to discussions of FPGA and CPU design. This site will be focused on Verilog solutions, using exclusively OpenSource IP products for FPGA design.
</description>
    <link>http://zipcpu.com/</link>
    <atom:link href="http://zipcpu.com/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Mon, 22 May 2017 17:02:32 -0400</pubDate>
    <lastBuildDate>Mon, 22 May 2017 17:02:32 -0400</lastBuildDate>
    <generator>Jekyll v3.0.1</generator>
    
      <item>
        <title>Moving to memory</title>
        <description>&lt;p&gt;There seems to be a difficult transition between the beginning FPGA
designer, and the more experienced designer.  From the posts I’ve watched
and replied to, this transition appears to be centered around accessing
memory.&lt;/p&gt;

&lt;h2 id=&quot;before-memory&quot;&gt;Before Memory&lt;/h2&gt;

&lt;p&gt;Usually, a beginner’s FPGA work consists of very simple tasks: building a serial
port, controlling LED’s, &lt;a href=&quot;/blog/2017/05/19/blinky.html&quot;&gt;making things blink&lt;/a&gt;,
and so on.  These tasks can seem fairly simple, and they can usually be solved
with only some simple Verilog.&lt;/p&gt;

&lt;p&gt;Once the beginner has successfully completed these tasks, they then try to 
move on to something real.  For example, maybe they want to record some video,
capture images from a camera, or even to transmit a song over a
&lt;a href=&quot;https://github.com/ZipCPU/wbfmtx&quot;&gt;FM radio peripheral&lt;/a&gt;.
Every one of these tasks, though, requires memory.  These beginners quickly
discover that … there’s just not that much block RAM within an FPGA.&lt;/p&gt;

&lt;p&gt;What these beginners want is to continue their learning process just like
they’ve done it up to that time.&lt;/p&gt;

&lt;p&gt;This is where they get stuck.&lt;/p&gt;

&lt;h2 id=&quot;why-is-memory-different&quot;&gt;Why is memory different&lt;/h2&gt;

&lt;p&gt;Up until this point, when building for an FPGA, they can access as many memories
as they want within their FPGA.  When they need a memory, the just connect it
to their circuit.&lt;/p&gt;

&lt;p&gt;Now, when they need a big memory from an external circuit, … there’s only
one memory pipe.  Anything that needs to access that memory, needs access to
the one and only memory pipe’s controls.   The controls look much like any
bus:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Given an address and a read strobe, return the value at that address.&lt;/li&gt;
  &lt;li&gt;Given an address, a data value, and a write strobe, replace the contents at
that address with the new data value.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;For this, you need a bus.&lt;/p&gt;

&lt;p&gt;Many different bus standards exist.  There’s the
&lt;a href=&quot;http://opencores.org/opencores,wishbone&quot;&gt;Wishbone&lt;/a&gt;, the
&lt;a href=&quot;http://opencores.org/cdn/downloads/wbspec_b4.pdf&quot;&gt;B4 version of the Wishbone&lt;/a&gt;
that I like and use, there’s the
&lt;a href=&quot;http://opencores.org/cdn/downloads/wbspec_b3.pdf&quot;&gt;B3 version&lt;/a&gt;
used by the &lt;a href=&quot;https://openrisc.io&quot;&gt;OpenRISC&lt;/a&gt; team,
there’s the &lt;a href=&quot;http://www.gstitt.ece.ufl.edu/courses/fall15/eel4720_5721/labs/refs/AXI4_specification.pdf&quot;&gt;AXI bus&lt;/a&gt;
used by &lt;a href=&quot;https://www.xilinx.com&quot;&gt;Xilinx&lt;/a&gt; and ARM, etc.&lt;/p&gt;

&lt;p&gt;By itself, using the &lt;a href=&quot;http://opencores.org/opencores,wishbone&quot;&gt;wishbone bus&lt;/a&gt;
is pretty easy.
&lt;a href=&quot;http://www.gstitt.ece.ufl.edu/courses/fall15/eel4720_5721/labs/refs/AXI4_specification.pdf&quot;&gt;AXI&lt;/a&gt;
is harder, but once you understand how a bus works its not that much harder.
We’ll come back to that later with some easy examples of how to use one.&lt;/p&gt;

&lt;h2 id=&quot;beginners-should-get-used-to-busses&quot;&gt;Beginners should get used to busses&lt;/h2&gt;

&lt;p&gt;Before trying to read from memory or building a memory controller, a beginner
should learn how to read and write from a bus.  Lots of simple things with
busses are really appropriate beginner tasks.&lt;/p&gt;

&lt;p&gt;For example, a very simple piece of bus logic is a bus arbiter. 
Since only
one piece of logic can access the memory at any given time, if you want
two pieces of logic to be able to access memory, you need a bus arbiter.
(See &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/aux/wbarbiter.v&quot;&gt;here&lt;/a&gt;
for a wishbone example.)&lt;/p&gt;

&lt;p&gt;A classic example of this would be a project that reads from a camera port and
writes the result to memory.  If you ever want to get that image out of memory,
you will need an arbiter controlling which logic has access to the bus.&lt;/p&gt;

&lt;p&gt;As another example, if you are going to build a bus, why not put some &lt;a href=&quot;https://github.com/ZipCPU/wbscope&quot;&gt;
debug logic&lt;/a&gt; on that bus?  It’ll make
getting your memory interface up and running later a whole lot easier.&lt;/p&gt;

&lt;p&gt;The simplest bus to get used to is one where every item on the bus has exactly
the same timing.  A simple debug port might be like this.&lt;/p&gt;

&lt;p&gt;A harder bus is one where requests must be held on the bus until the respective
peripheral is ready to read them.
(&lt;a href=&quot;http://opencores.org/cdn/downloads/wbspec_b3.pdf&quot;&gt;WB B3/Classic&lt;/a&gt;)&lt;/p&gt;

&lt;p&gt;Harder still, one where many requests may be made before the first result comes
back, some variable number of clocks later.
(&lt;a href=&quot;http://opencores.org/cdn/downloads/wbspec_b4.pdf&quot;&gt;WB B4/Pipeline&lt;/a&gt;)&lt;/p&gt;

&lt;p&gt;The &lt;a href=&quot;http://www.gstitt.ece.ufl.edu/courses/fall15/eel4720_5721/labs/refs/AXI4_specification.pdf&quot;&gt;AXI&lt;/a&gt;
bus, though, usually takes the cake for complexity.  This bus has separate
channels for read requests, write requests, write data, read data, and the write
request acknowledgement.  Each of these channels has bi-directional flow control
so that requests may have to wait for the peripheral to be ready.  Worse,
this bus may respond out of order to various requests.  Ouch!&lt;/p&gt;

&lt;h2 id=&quot;actual-memory-controllers-are-complicated&quot;&gt;Actual memory controllers are complicated&lt;/h2&gt;

&lt;p&gt;Finally, once you are comfortable using a bus, only then is it time to connect
it to a memory controller.&lt;/p&gt;

&lt;p&gt;This is also where the beginner punts and looks for a prewritten memory
controller—usually because he has never learned how to deal with a bus,
or he’s read the memory controller spec sheet and … decided it wasn’t worth
his while.&lt;/p&gt;

&lt;p&gt;These beginners will also tend to switch to the
&lt;a href=&quot;http://www.gstitt.ece.ufl.edu/courses/fall15/eel4720_5721/labs/refs/AXI4_specification.pdf&quot;&gt;AXI&lt;/a&gt;
bus, not because they know
how to use it, neither because it’s the best bus out there, but because
&lt;a href=&quot;https://www.xilinx.com&quot;&gt;Xilinx&lt;/a&gt; has provided them with a memory controller
for their memory chip that uses the
&lt;a href=&quot;http://www.gstitt.ece.ufl.edu/courses/fall15/eel4720_5721/labs/refs/AXI4_specification.pdf&quot;&gt;AXI&lt;/a&gt;
bus.&lt;/p&gt;

&lt;p&gt;This is usually also the time in their development where they abandon the
Verilog or VHDL code they’ve been working with in favor of one of the visual
and graphical tool flows.&lt;/p&gt;

&lt;p&gt;This leads to a bigger problem down the road: they’re stuck using the Xilinx
IP because 1) building
&lt;a href=&quot;https://github.com/ZipCPU/wbscope/blob/master/rtl/axi4lscope.v&quot;&gt;something&lt;/a&gt; that
interacts on an
&lt;a href=&quot;http://www.gstitt.ece.ufl.edu/courses/fall15/eel4720_5721/labs/refs/AXI4_specification.pdf&quot;&gt;AXI&lt;/a&gt;
bus isn’t simple, and
2) because it’s difficult to integrate their special sauce into the official
IP integrator.  Indeed, the problem is so complicated that 
&lt;a href=&quot;http://www.gstitt.ece.ufl.edu/courses/fall15/eel4720_5721/labs/refs/AXI4_specification.pdf&quot;&gt;AXI&lt;/a&gt;
has to offer a special subset of the AXI bus specification, AXI-lite, just to
try to make this easier.&lt;/p&gt;

&lt;h2 id=&quot;stick-around-and-ill-show-another-way&quot;&gt;Stick around, and I’ll show another way&lt;/h2&gt;

&lt;p&gt;Having now written several memory controllers, I understand they can be
difficult.  They are also, however, quite possible to build.  The beginner
who abandons their learning process for a set of ready-set of tools, however,
will quickly loose the fortitude they need to get there.&lt;/p&gt;

&lt;p&gt;If you stick around on this blog, I intend to show you another way.&lt;/p&gt;
</description>
        <pubDate>Mon, 22 May 2017 00:00:00 -0400</pubDate>
        <link>http://zipcpu.com/digilent/2017/05/22/moving-to-memory.html</link>
        <guid isPermaLink="true">http://zipcpu.com/digilent/2017/05/22/moving-to-memory.html</guid>
        
        
        <category>digilent</category>
        
      </item>
    
      <item>
        <title>A Vision for Controlling FPGA Logic</title>
        <description>&lt;p&gt;I’d like to spend some time on this forum discussing how to debug an FPGA.
Indeed, I might wish to spend a lot of time discussing how to debug an FPGA.
I’ve done it several ways, but for this post I’d like to discuss a vision
for how I like to debug FPGA’s.&lt;/p&gt;

&lt;h3 id=&quot;memory-mapped-io&quot;&gt;Memory Mapped I/O&lt;/h3&gt;

&lt;p&gt;We’ll start with the concept of
&lt;a href=&quot;https://en.wikipedia.org/wiki/Memory-mapped_I/O&quot;&gt;Memory Mapped I/O&lt;/a&gt;.
The idea is simply this: peripherals can be connected to a bus, together with
whatever memory is on that bus, so that they can be accessed like memory.
Like memory, the peripheral will have an address.  Like memory, the bus
controller, whether it be a CPU or &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/wbdmac.v&quot;&gt;DMA
peripheral&lt;/a&gt;,
can write to the peripheral
and read from it.  Unlike memory, however, reading or writing to a peripheral
can have side effects.&lt;/p&gt;

&lt;p&gt;We’ll use the term “register” to describe a single address within a peripheral.&lt;/p&gt;

&lt;p&gt;Register’s can be read only, write only, or read/write.  Further, peripherals
may have many addresses.  Finally, peripherals may take different amounts of
time to access.  For example, a
&lt;a href=&quot;https://github.com/ZipCPU/xulalx25soc/blob/master/rtl/memdev.v&quot;&gt;block RAM&lt;/a&gt;
peripheral can typically be accessed in a single cycle, whereas an
&lt;a href=&quot;https://github.com/ZipCPU/xulalx25soc/blob/master/rtl/wbsdram.v&quot;&gt;SDRAM&lt;/a&gt;
peripheral may take longer, and a
&lt;a href=&quot;https://github.com/ZipCPU/xulalx25soc/blob/master/rtl/wbspiflash.v&quot;&gt;flash&lt;/a&gt;
peripheral may take much longer.&lt;/p&gt;

&lt;p&gt;Perhaps a perfect example of this concept is that of a serial port, such as
the &lt;a href=&quot;https://github.com/ZipCPU/wbuart32&quot;&gt;wbuart32&lt;/a&gt; serial port the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt; uses.  Reading from the receiver
address of this serial port returns the next character from the receiver
queue, advancing the queue to the next character.  Writing to the transmit
register queue’s a character for sending over the port.  A third register
controls the speed and configuration of the port, whereas a fourth register
is used when the serial port has a queue to indicate how much of the queue
is used.&lt;/p&gt;

&lt;p&gt;But how does this apply to controlling an FPGA?  Simple!  We’ll implement
our logic as peripherals on an FPGA bus, and then control those peripherals
by simply reading from or writing to that bus.  By having a common standard
for accessing peripherals, we only have to build our peripherals to meet that
standard once.&lt;/p&gt;

&lt;h3 id=&quot;pcie-card&quot;&gt;PCIe card&lt;/h3&gt;

&lt;p&gt;Perhaps the vision I’m about to share will make more sense if I explain that
I first came up with it while trying to figure out how to control an
FPGA on a
&lt;a href=&quot;https://en.wikipedia.org/wiki/PCI_Express&quot;&gt;PCIe&lt;/a&gt;
card.  Indeed, I was trying to figure out how I would control
a &lt;a href=&quot;https://www.xilinx.com/products/boards-and-kits/ek-v7-vc707-g.html&quot;&gt;VC707&lt;/a&gt;
card made by &lt;a href=&quot;https://www.xilinx.com/&quot;&gt;Xilinx&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The &lt;a href=&quot;https://en.wikipedia.org/wiki/PCI_Express&quot;&gt;PCIe&lt;/a&gt;
bus allows for several different areas or sections of address space
which get assigned to each card.  These can include both memory address space,
and peripheral address space, but every thing is still accessed on a bus.
You can read from any given addresses on that bus, or write to a given
addresses, as with any other bus.&lt;/p&gt;

&lt;p&gt;Since I wanted to build an FPGA capability that could eventually be used on
an FPGA over a &lt;a href=&quot;https://en.wikipedia.org/wiki/PCI_Express&quot;&gt;PCIe&lt;/a&gt;
interface, I wanted to create something that would work on a
&lt;a href=&quot;https://en.wikipedia.org/wiki/PCI_Express&quot;&gt;PCIe&lt;/a&gt;
bus eventually, but that could be used over some other transport
prior to that point.  Further, when plugging the FPGA into the
&lt;a href=&quot;https://en.wikipedia.org/wiki/PCI_Express&quot;&gt;PCIe&lt;/a&gt; bus, I already knew that
I would need to use some sort of alternative transport in order to debug
whatever was going on.&lt;/p&gt;

&lt;p&gt;So, here was my vision: I would use the serial port on the
&lt;a href=&quot;https://www.xilinx.com/products/boards-and-kits/ek-v7-vc707-g.html&quot;&gt;VC707&lt;/a&gt;
to command the
&lt;a href=&quot;https://www.xilinx.com/products/boards-and-kits/ek-v7-vc707-g.html&quot;&gt;VC707&lt;/a&gt;
as though it were connected via
&lt;a href=&quot;https://en.wikipedia.org/wiki/PCI_Express&quot;&gt;PCIe&lt;/a&gt;.  Then, over this same
serial port, I could get the debugging information I needed to know if the
&lt;a href=&quot;https://en.wikipedia.org/wiki/PCI_Express&quot;&gt;PCIe&lt;/a&gt; bus were working, or
if not … why not?&lt;/p&gt;

&lt;h3 id=&quot;required-interactions&quot;&gt;Required Interactions&lt;/h3&gt;

&lt;p&gt;If you are going to create a memory mapped bus, that you are then going to
work with, you need to know what operations you want to do on this bus.
I captured the interface for, what I called a device bus, in a C++ header file,
&lt;a href=&quot;https://github.com/ZipCPU/openarty/blob/master/sw/host/devbus.cpp&quot;&gt;devbus.h&lt;/a&gt;.
Operations on this interface include:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;readio()&lt;/strong&gt;:  Reads a 32-bit value from any individual register&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;readz()&lt;/strong&gt;: Reading multiple 32-bit values from the same register.  While
most memories have one address per memory location, peripherals aren’t
necessarily like that.  This mode captures some of that difference.  Some
examples where this would be useful include reading from a FIFO, such as the
serial port input FIFO, and reading from my debugging scope, where
multiple reads from the data register read subsequent values from the scope’s
memory.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;readi()&lt;/strong&gt;: Reading a series of 32-bit values from consecutive registers.
This is akin to a memcpy command, where one end is coming from the device.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The same operations are then mirrored for writing to registers.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;This &lt;a href=&quot;https://github.com/ZipCPU/openarty/blob/master/sw/host/devbus.cpp&quot;&gt;bus interface&lt;/a&gt;
also allows for some minimal interrupt capability.  For example, you
can &lt;strong&gt;wait()&lt;/strong&gt; for an interrupt to be created within the device, or &lt;strong&gt;poll()&lt;/strong&gt;
to see if an interrupt has taken place.  How these interactions take place is
… up to whatever transport implements the interface.&lt;/p&gt;

&lt;p&gt;Back when I started working on computers decades ago, you could
&lt;a href=&quot;https://en.wikipedia.org/wiki/PEEK_and_POKE&quot;&gt;Peek or Poke&lt;/a&gt; an addresses within
your &lt;a href=&quot;https://en.wikipedia.org/wiki/Apple_IIe&quot;&gt;Apple IIe&lt;/a&gt; computer, and so
control the hardware.  While I thought of repeating this approach with FPGA’s,
I also like the thought of being able to name the peripheral register, rather
than trying to remembering &lt;a href=&quot;http://apple2.org.za/gswv/USA2WUG/FOUNDING.MEMBERS/HOME.PAGES/EDHEL/texts/pokes.html&quot;&gt;all the register numbers&lt;/a&gt; (OUCH!).
This would allow an FPGA to be reconfigured so the addresses might be moved
around, and yet you could still read and write the same peripherals via the
same names.  I like this idea so much,
that all of my projects have a
&lt;a href=&quot;https://github.com/ZipCPU/openarty/blob/master/sw/host/wbregs.cpp&quot;&gt;wbregs&lt;/a&gt;
program within them to control peripherals over some command line.&lt;/p&gt;

&lt;h3 id=&quot;tcpip-bridge&quot;&gt;TCP/IP bridge&lt;/h3&gt;

&lt;p&gt;Rather than getting into details regarding how such an interface might be built
(yet),
I’d like to add one more component to the vision: I want to be able to control
my FPGA devices from anywhere on my local network.  If I’m working on my
laptop, I’d like to be able to control them from my laptop.  If I’m working on
my desktop, I’d like to be able to control them from my desktop.  If I have the
device located next to an antenna in the attic, I still want to be able to
control it.&lt;/p&gt;

&lt;p&gt;For this purpose, I like to forward all of my transport connections over a
TCP/IP link.  While this would probably never be appropriate for an FPGA
with a PCIe connection, it has worked for all of my FPGA’s with slower
transport connections.&lt;/p&gt;

&lt;p&gt;Lest you be confused, this is different from having an FPGA with an Ethernet
port that can be accessed from your network.  We want to use our network
interface to command, control, and debug our FPGA before the network controller
connected to the FPGA works.&lt;/p&gt;

&lt;h3 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h3&gt;

&lt;p&gt;This vision for FPGA control leads nicely into a vision for building and
debugging an FPGA.  We’ll get more into that idea as this blog progresses,
but for now … we’ll just use this idea to keep things simple.&lt;/p&gt;
</description>
        <pubDate>Mon, 22 May 2017 00:00:00 -0400</pubDate>
        <link>http://zipcpu.com/blog/2017/05/22/a-vision-for-controlling-fpgas.html</link>
        <guid isPermaLink="true">http://zipcpu.com/blog/2017/05/22/a-vision-for-controlling-fpgas.html</guid>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>Which comes first: the CPU or the peripherals?</title>
        <description>&lt;p&gt;When working on the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;, the peripherals
came first.  &lt;em&gt;Only&lt;/em&gt; when the peripherals were known to work did I transition to
building the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Does the order matter?  I think it does.  Someone else tried to build a CPU
first before building the memory peripheral. 
The result
&lt;a href=&quot;https://forum.digilentinc.com/topic/3298-psram-chip-baked-or-am-i-just-high/&quot;&gt;wasn’t pretty&lt;/a&gt;.
While it hasn’t quite killed his project, he did run out of his startup dollars and had to put the project on the backburner.&lt;/p&gt;

&lt;p&gt;If you want to build a CPU, I recommend building in this order:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Build the debugging scaffolding.  The first thing you will need is an
interface to your FPGA that you can rely upon, one that will also allow you
to test the peripheral components found within your FPGA.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Using your scaffolding, build some peripherals.  Test them.  Get to know
them.  Get familiar with them.  Understand how many clocks they will take to
respond to a request.  Understand how to aggregate those peripherals
together so you can debug them all.&lt;/p&gt;

    &lt;p&gt;I personally hang all of my peripherals off of a
&lt;a href=&quot;http://opencores.org/opencores,wishbone&quot;&gt;Wishbone&lt;/a&gt;
&lt;a href=&quot;https://opencores.org/cdn/downloads/wbspec_b4.pdf&quot;&gt;B4 bus&lt;/a&gt;,
although other busses exist which can be used for this purpose.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Only once you know that your scaffolding and peripherals work, should you
then start on trying to place your CPU within your FPGA.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Of course, this is all my own personal and humble opinions.  On the other hand,
the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt; already runs on several platforms.&lt;/p&gt;
</description>
        <pubDate>Sat, 20 May 2017 00:00:00 -0400</pubDate>
        <link>http://zipcpu.com/zipcpu/2017/05/20/which-came-first.html</link>
        <guid isPermaLink="true">http://zipcpu.com/zipcpu/2017/05/20/which-came-first.html</guid>
        
        
        <category>zipcpu</category>
        
      </item>
    
      <item>
        <title>Knight Rider</title>
        <description>&lt;p&gt;When I was a kid, I loved watching Knight Rider.  Once I picked up FPGA design,
I wanted to know how to make LED’s move and dim … just like 
&lt;a href=&quot;https://www.youtube.com/watch?v=WxE2xWZNfOc&quot;&gt;KITT’s lights&lt;/a&gt; did.&lt;/p&gt;

&lt;p&gt;If you are a beginner FPGA designer, this makes the perfect beginners project.&lt;/p&gt;

&lt;h2 id=&quot;walking-through-the-leds&quot;&gt;Walking through the LEDs&lt;/h2&gt;

&lt;p&gt;The first step requires simply walking through the LEDs.  This is a very
important step, as it demonstrates that all of your LEDs are properly set
up, properly connected, and that they will turn on when requested.&lt;/p&gt;

&lt;p&gt;In our case, we’ll do this two different ways.  First, we’ll step the LED’s
once each second.  This way, there can be no question that the LED comes on
at the proper time.  Once that works, we can speed the process up, and make
a cool LED demo.&lt;/p&gt;

&lt;p&gt;To step through the LED’s one at a time, you can use the following code:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;`default_nettype none
`define	FASTWALKER
//
module	ledwalker(i_clk, o_led);
	input	wire		i_clk;
	output	reg	[7:0]	o_led;

	// Remember the clock testing code?  This is very similar, only it
	// creates a PPS signal once per second--every time the counter rolls
	// over.  You could create this signal ever half second, or every
	// quarter second, by just dropping the number of bits in the counter.
	reg	pps;
	reg	[31:0]	time_counter;
	always @(posedge i_clk)
		{ pps, time_counter } &amp;lt;= time_counter + 32&#39;d43;

	//
	// We then want to keep track of our state: which LED will be on
	//
	reg	[2:0]	led_posn;
	always @(posedge i_clk)
		if (pps)
			led_posn &amp;lt;= led_posn + 1&#39;b1;

	//
	// Now, we turn on the one LED on corresponding to the state we have
	// chosen.
	//
	always @(posedge i_clk)
	begin
		o_led[0] &amp;lt;= (led_posn == 3&#39;h0);
		o_led[1] &amp;lt;= (led_posn == 3&#39;h1);
		o_led[2] &amp;lt;= (led_posn == 3&#39;h2);
		o_led[3] &amp;lt;= (led_posn == 3&#39;h3);
		o_led[4] &amp;lt;= (led_posn == 3&#39;h4);
		o_led[5] &amp;lt;= (led_posn == 3&#39;h5);
		o_led[6] &amp;lt;= (led_posn == 3&#39;h6);
		o_led[7] &amp;lt;= (led_posn == 3&#39;h7);
	end

endmodule&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;If you don’t want to type this in, you can find my version of this example
&lt;a href=&quot;https://github.com/ZipCPU/icozip/blob/master/rtl/pmodleds/ledwalker.v&quot;&gt;here&lt;/a&gt;.
You’ll need an &lt;a href=&quot;http://icoboard.org&quot;&gt;ICO board&lt;/a&gt; and a &lt;a href=&quot;https://store.digilentinc.com/pmod-8ld-eight-high-brightness-leds/&quot;&gt;PMod
LED8&lt;/a&gt;
from &lt;a href=&quot;http://store.digilentinc.com&quot;&gt;Digilent&lt;/a&gt; to
run it, although it’s almost generic enough to run on any FPGA board.  If you
don’t have that many LED’s?  Either don’t turn them all on, or adjust led_posn
to only cycle through the LED’s that you do have.&lt;/p&gt;

&lt;p&gt;With a little work, I’m sure you could modify this example, so that the LED
that was ON walked from left to right, and then back from right to left.&lt;/p&gt;

&lt;h2 id=&quot;dimming-the-led&quot;&gt;Dimming the LED&lt;/h2&gt;

&lt;p&gt;The next thing you need to know, once you can turn each LED on individually,
is that you can “dim” an LED by turning it on
and off faster than an eye can see.  As you transition the LED from being more
often on to more often off, the LED will appear to dim.  As an example, try the
following:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;//
`default_nettype none
//
module dimmer(i_clk, o_led);
  input  wire i_clk;
  output wire o_led;

reg [26:0] counter;
always @(posedge i_clk)
  counter &amp;lt;= counter + 1&#39;b1;

always @(posedge i_clk)
  o_led &amp;lt;= (counter[3:0] &amp;lt; counter[26:23]);

endmodule&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;If you don’t want to type this in, you can find my version of this
&lt;a href=&quot;https://github.com/ZipCPU/icozip/blob/master/rtl/basic/dimmer.v&quot;&gt;here&lt;/a&gt;,
written for the ICO Board.&lt;/p&gt;

&lt;h2 id=&quot;the-final-design&quot;&gt;The final design&lt;/h2&gt;

&lt;p&gt;You really don’t want me to give you the answer, now, do you?  Without giving
you a chance to do it yourself?  Try doing it yourself first.  Then, if you get
stuck or once you’ve achieved your goal, feel free to look at my solution
&lt;a href=&quot;https://github.com/ZipCPU/icozip/blob/master/rtl/pmodleds/ledbouncer.v&quot;&gt;here&lt;/a&gt;.
It’s a little more advanced than the ones above, in that it uses generic’s and
for loops within Verilog, but the concept remains the same.&lt;/p&gt;

&lt;p&gt;One problem I had using the “High-brightness” LED’s on the 
&lt;a href=&quot;https://store.digilentinc.com/pmod-8ld-eight-high-brightness-leds/&quot;&gt;PMod LED8&lt;/a&gt;,
was that it’s hard to see them actually “dim”.  As a result, the Knight
Rider effect is more substantial
on another board, such as the &lt;a href=&quot;https://store.digilentinc.com/nexys-video-artix-7-fpga-trainer-board-for-multimedia-applications&quot;&gt;Nexys Video&lt;/a&gt; or the &lt;a href=&quot;https://store.digilentinc.com/basys-3-artix-7-fpga-trainer-board-recommended-for-introductory-users/&quot;&gt;Basys-3&lt;/a&gt; from &lt;a href=&quot;https://store.digilentinc.com&quot;&gt;Digilent&lt;/a&gt;,
since these use red LED’s that aren’t nearly as bright.&lt;/p&gt;

</description>
        <pubDate>Sat, 20 May 2017 00:00:00 -0400</pubDate>
        <link>http://zipcpu.com/blog/2017/05/20/knight-rider.html</link>
        <guid isPermaLink="true">http://zipcpu.com/blog/2017/05/20/knight-rider.html</guid>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>FPGA Hell</title>
        <description>&lt;p&gt;The worst place to be in digital design is where you load the design onto your
device, it doesn’t work, and you don’t know why.&lt;/p&gt;

&lt;p&gt;I call this: &lt;em&gt;FPGA Hell&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;If you find yourself deskcheck your code and not knowing what to look for, you
may be in FPGA Hell.  Weeks and months can spent in there, and you will make no
progress towards your goal while you are there.&lt;/p&gt;

&lt;p&gt;Time is money.  FPGA Hell will cost you dearly.  Avoid FPGA Hell at &lt;em&gt;all&lt;/em&gt; cost.&lt;/p&gt;

&lt;h2 id=&quot;the-solution&quot;&gt;The solution&lt;/h2&gt;

&lt;p&gt;The solution to FPGA Hell is twofold.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;First, simulate everything.  If you don’t have a simulation to describe
the hardware you are working with, make one.&lt;/p&gt;

    &lt;p&gt;As an example, &lt;a href=&quot;https://github.com/ZipCPU/wbuart32/blob/master/bench/cpp/uartsim.cpp&quot;&gt;here is&lt;/a&gt; a simulation of a UART port.  It turns a UART port into either your
standard input and output FILE streams, or into a TCP/IP port that you can
stream your data in and out of.  I built the simulation from an &lt;a href=&quot;https://en.wikipedia.org/wiki/Universal_asynchronous_receiver/transmitter&quot;&gt;online
description&lt;/a&gt; of how a UART works.  I then use the simulation to debug any Verilog
code someone posts to &lt;a href=&quot;http://forum.digilentinc.com&quot;&gt;Digilent’s forums&lt;/a&gt;, but
now that you know my secrets, you can do it too.&lt;/p&gt;

    &lt;p&gt;The problem with this first step is: what happens if your understanding of
the device you just built a simulator doesn’t match reality?  For that, you
need a scope.  Specifically, you need to measure reality and learn what’s
actually happening, and then you need to adjust your simulation to match
reality.  This leads us to the second part of the solution: using a scope.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Use a scope.  Measure what’s really going on.  Watch your code interact with
the real hardware, and use what you learn to find where reality and your
simulation disconnect.&lt;/p&gt;

    &lt;p&gt;A good example of this is my first attempt to build an &lt;a href=&quot;https://github.com/ZipCPU/wbi2c&quot;&gt;I2C
controller&lt;/a&gt;.  For that project, I built
two controllers, &lt;a href=&quot;https://github.com/ZipCPU/wbi2c/blob/master/rtl/wbi2cslave.v&quot;&gt;one a
slave&lt;/a&gt; and &lt;a href=&quot;https://github.com/ZipCPU/wbi2c/blob/master/rtl/wbi2cmaster.v&quot;&gt;the
other a
master&lt;/a&gt;.
I then built simulations for both &lt;a href=&quot;https://github.com/ZipCPU/wbi2c/blob/master/bench/cpp/wbi2cs_tb.cpp&quot;&gt;the
slave&lt;/a&gt;
and &lt;a href=&quot;https://github.com/ZipCPU/wbi2c/blob/master/bench/cpp/wbi2cm_tb.cpp&quot;&gt;the
master&lt;/a&gt;,
and then worked with the simulations until my code worked.  Once my code
worked, I placed it onto the device and … my code didn’t work.&lt;/p&gt;

    &lt;p&gt;To get past the problem, I placed a
&lt;a href=&quot;https://github.com/ZipCPU/wbscope/blob/master/rtl/wbscopc.v&quot;&gt;scope&lt;/a&gt; into my
design, allowing me to “see” what was going on.  What I learned was that the
hardware I was talking to (my monitor) wasn’t doing what I thought it should.
I then had to find &lt;a href=&quot;https://www.i2c-bus.org/specification&quot;&gt;a better
description&lt;/a&gt; of how an I2C port
works, rebuild my simulation, get the simulation working again, and then
test on the hardware.&lt;/p&gt;

    &lt;p&gt;You can find a discussion of the result, together with pictures of what I was
looking at,
&lt;a href=&quot;https://github.com/ZipCPU/wbscope/tree/master/doc/examples/hdmi-eddc&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;If you cannot use a scope, modify &lt;a href=&quot;blinky.html&quot;&gt;blinky&lt;/a&gt; to get the
information you need.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Hopefully this helps you avoid FPGA Hell.  If not, watch this space.  I intend
to write more articles here about how to debug an FPGA design.&lt;/p&gt;
</description>
        <pubDate>Fri, 19 May 2017 00:00:00 -0400</pubDate>
        <link>http://zipcpu.com/blog/2017/05/19/fpga-hell.html</link>
        <guid isPermaLink="true">http://zipcpu.com/blog/2017/05/19/fpga-hell.html</guid>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>Blinky</title>
        <description>&lt;p&gt;In C, the first program a person writes is often known  as a
&lt;a href=&quot;https://en.wikipedia.org/wiki/&amp;quot;Hello,_World!&amp;quot;_program&quot;&gt;“Hello, World!”&lt;/a&gt;
program.  It does nothing but print “Hello, World!” to the screen and exit.
While this is a wonderful first program for the C programmer, it is wholly
inappropriate for either the FPGA programmer or the embedded programmer.&lt;/p&gt;

&lt;p&gt;The FPGA or embedded programmer must work to get the serial port or the
C-library working, if he has either.  Instead, he has a simple LED to work with.
Hence the first program, &lt;a href=&quot;https://hackaday.io/project/7982-cat-board/log/37305-getting-to-blinky-cat-board-style&quot;&gt;blinky&lt;/a&gt;, simply blinks that LED.&lt;/p&gt;

&lt;h2 id=&quot;why-blinky&quot;&gt;Why blinky?&lt;/h2&gt;

&lt;p&gt;Blinky is a very important program: it proves that you can 1) program the
FPGA, that you 2) have a working clock, and that 3) you have a working LED.
These are very important steps in programming a new board.  Indeed, they are
so profound, I still run blinky as my first program on any FPGA board today.
Even after your first configuration, blinky is still important, because it can
tell you if the problem is your design versus the ability to load the board.&lt;/p&gt;

&lt;h2 id=&quot;what-is-blinky&quot;&gt;What is blinky?&lt;/h2&gt;

&lt;p&gt;Below is a very simple version of the blinky program, written in Verilog.
Remember, simple is better at this point.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;//
`default_nettype none
//
module blinky(i_clk, o_led);
  input wire i_clk;
  output wire o_led;

reg	[25:0]	counter;
always @(posedge i_clk)
  counter &amp;lt;= counter + 1&#39;b1;
assign o_led = counter[25];

endmodule&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;While there’s not much to the design, the “not much” that is there is important.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Notice that I mark my inputs with the prefix i_, and my outputs with the prefix o_.  You’ll find this consistent notation through all of my work.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Notice the default_nettype directive.  We’ll come back to it later.  For now, I highly recommend every Verilog design you build start with it.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Notice the counter.  Many beginners place an LED in their design without the counter, and then wonder why things don’t work.  An FPGA runs faster than your eye can see.  Without the counter, you wouldn’t be able to see this LED blink.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;I have 26 bits in my counter (25+1).  This is just about right for most of the projects I’ve worked on.  It divides the clock by 2^26, creating a clock rate at around one Hertz.  If you pick a number too low, you won’t see the LED blink.  If you pick a number too high, you’ll get bored waiting for the LED to blink while wondering if your FPGA works.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;a-better-blinky&quot;&gt;A better blinky&lt;/h2&gt;

&lt;p&gt;With no more than just a clock and an LED, can you figure out how fast your
clock is running?&lt;/p&gt;

&lt;p&gt;This was a challenge of mine when first firing up my
&lt;a href=&quot;http://icoboard.org&quot;&gt;icoboard&lt;/a&gt;.  The
&lt;a href=&quot;https://drive.google.com/file/d/0By-zY9AlHqXIcXZ6ZWdBR2dPXzg/view&quot;&gt;schematic&lt;/a&gt;
for that board initially identified the
clock as being at 25MHz, the examples identified it as being at 100MHz.  (The
team has since fixed the schematic, to properly reflect the 100MHz clock.)  How
should I tell which of the two was the right answer?&lt;/p&gt;

&lt;p&gt;Here was my solution:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;//
`default_nettype none
//
module clktest(i_clk, o_led);
  input wire i_clk;
  output wire o_led;

// We use a larger, 32-bit, counter here so as to get some better time
// precision.
reg	[31:0]	counter;
always @(posedge i_clk)
  counter &amp;lt;= counter + 32&#39;d43; // Valid if clk rate = 100MHz

// Blink the LED sharply at the top of each second, so that
// it remains on for a quarter of a second only before turning
// off
assign o_led = (counter[31:30] == 2&#39;b00);

endmodule&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Did you notice the 32’d43 value?  This value is set to 2^32 divided by the
clock rate.  Since the clock rate on this board is 100 MHz, 2^32 divided by
100 MHz is about 43.  Hence, if the counter starts at zero, then after
100 million clock ticks, the counter should equal 2^32 and roll over to zero
again.  In this case, though, since 2^32/100M isn’t exactly 43, our clock will
run about 5% too fast.  Still … it should be close enough that we can use a
stop watch to verify that we are in about the right clock range.&lt;/p&gt;

&lt;p&gt;If you are interested, this method of clock division is also used within the
&lt;a href=&quot;https://github.com/ZipCPU/rtcclock&quot;&gt;Real-Time Clock&lt;/a&gt; project used by the
ZipCPU.  The project, though, uses a 48-bit counter to get much better 
time accuracy–assuming that the oscillator is that good.&lt;/p&gt;

&lt;h2 id=&quot;using-blinky-for-debugging&quot;&gt;Using blinky for debugging&lt;/h2&gt;

&lt;p&gt;If you ever find yourself debugging with nothing but an LED, you can use the
LED for your debugging.  It’s not the best means of debugging: it can only
return one bit of information, and sometimes not even that, but it may be
the only means you have.&lt;/p&gt;

&lt;p&gt;The basic idea is to set the LED to on any time some condition takes place.
The trick is … you need to reset the LED so that you can see if that
condition takes place again later, and you need to make certain that the
condition (whatever it is) takes place so rarely that you can understand
what’s going on.&lt;/p&gt;

&lt;p&gt;Here’s an updated blinky, therefore, that can be used within a design to help
debug it:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;reg	[24:0]	counter;
always @(posedge i_clk)
  if (debug_event)
    // Reset the counter if our event ever takes place
    counter &amp;lt;= 0;
  else if (!counter[24])
    // Increment the counter, to hold the LED for a period of time
    // long enough for us to observe it ... before turning the LED
    // back off again
    counter &amp;lt;= counter + 1&#39;b1;

// Since the reset condition sets this high order bit low and holds
// it low for a period of time, and since the light &quot;on&quot; usually
// indicates the condition has taken place, negate the top bit of
// the counter so that the LED will turn _on_ any time your event
// takes place.
assign o_led = !counter[24];&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;As before, the choice of the length of the counter is important.&lt;/p&gt;

&lt;p&gt;This time, though, we’ve used “debug_event”, a variable coming from elsewhere
in the design, to check to see if something ever happens.  If this event ever
happens, the counter is set to zero, and the LED is turned on.  The counter
then holds the LED on for 2^24 clocks, before stopping and waiting for a new
event.&lt;/p&gt;

&lt;p&gt;While better approaches exist, most of those require more logic that needs to
be debugged first.  As a result, I’ve used this approach to debug my 
&lt;a href=&quot;https://github.com/ZipCPU/wbuart32/&quot;&gt;serial port controller&lt;/a&gt;, since most of my
debugging logic depends upon a working serial port.  I’ve also used this
approach to track how much time the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;
is spending in &lt;a href=&quot;https://github.com/ZipCPU/s6soc/blob/master/sw/zipos/kernel.c#L118&quot;&gt;interrupts&lt;/a&gt;, and if
and when the ZipCPU &lt;a href=&quot;https://github.com/ZipCPU/s6soc/blob/master/rtl/busmaster.v#L448&quot;&gt;has frozen&lt;/a&gt; in &lt;a href=&quot;https://github.com/ZipCPU/s6soc&quot;&gt;designs&lt;/a&gt; that are too tight
to fit a &lt;a href=&quot;https://github.com/ZipCPU/wbscope&quot;&gt;better debugging infrastructure&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;what-next&quot;&gt;What next?&lt;/h2&gt;

&lt;p&gt;Once you have blinky running, it’s time to move on to other tasks.  These tasks, though, will be easier because you have a clock and an LED that works.  Indeed, you can use blinky to your advantage as you struggle to get those newer tasks running.&lt;/p&gt;

</description>
        <pubDate>Fri, 19 May 2017 00:00:00 -0400</pubDate>
        <link>http://zipcpu.com/blog/2017/05/19/blinky.html</link>
        <guid isPermaLink="true">http://zipcpu.com/blog/2017/05/19/blinky.html</guid>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>Most common Digilent FPGA support requests</title>
        <description>&lt;p&gt;I’ve been watching the &lt;a href=&quot;https://forum.digilentinc.com&quot;&gt;Digilent Forum’s&lt;/a&gt;, and
I’ve now seen some very common requests for FPGA help that keep coming back
over and over again.  I’ll separate these into three groups, and share them
here with you.  They are actual hardware problems, beginner problems, and
Vivado problems.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Actual Hardware Problems&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;Device not found.
&lt;a href=&quot;https://forum.digilentinc.com/topic/4095-cmod-a7-comms-problem/&quot;&gt;[1]&lt;/a&gt;
&lt;a href=&quot;https://forum.digilentinc.com/topic/3564-problem-with-detecting-arty-on-linux/&quot;&gt;[2]&lt;/a&gt;
&lt;a href=&quot;https://forum.digilentinc.com/topic/3749-programming-flash-cmod-a7/&quot;&gt;[3]&lt;/a&gt;&lt;/p&gt;

        &lt;p&gt;User’s seem to have a problem getting their tools set up properly.  I
certainly did.  One particular problem is basically, “I just plugged in
my device and my computer doesn’t recognize it.”  This is commonly caused
by an invalid or incomplete tool-suite setup.  However, it can be caused
by a bad USB cable.  So, usually, if the device &lt;em&gt;was&lt;/em&gt; working, it tends to
be instead a bad USB cable.  Strangely enough, bad USB cables a rather
common occurrence on the forums.&lt;/p&gt;

        &lt;p&gt;&lt;strong&gt;The solution&lt;/strong&gt;: It depends on the problem&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;There’s the FTDI request. 
&lt;a href=&quot;https://forum.digilentinc.com/topic/3658-digilent-nexys-video-ft2232-eeprom/&quot;&gt;[1]&lt;/a&gt;&lt;/p&gt;

        &lt;p&gt;Many individuals have tried, either by accident or on purpose, reflashing
the FTDI interface chip on their board and, as a result, have broken their
board so badly that it no longer responds to configuration commands.  The
solution to this problem is that the Digilent staff will send this user a
private message with the correct software to reload onto their device.&lt;/p&gt;

        &lt;p&gt;The strange part of this request is that I am aware of one user who
has successfully reprogrammed the FT2232 chip on his board, and
achieved much higher data throughput as a result.&lt;/p&gt;

        &lt;p&gt;&lt;strong&gt;The solution&lt;/strong&gt;: The Digilent staff provides a private message containing
instructions and/or data to fix this problem.&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Beginner problems&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;I need to build (some instructor’s problem statement).  Please help me.
&lt;a href=&quot;https://forum.digilentinc.com/topic/4110-ise-design-suite/&quot;&gt;[1]&lt;/a&gt;
&lt;a href=&quot;https://forum.digilentinc.com/topic/4104-basys-3/&quot;&gt;[2]&lt;/a&gt;&lt;/p&gt;

        &lt;p&gt;This request gets the least help from members on the forum.  The response
is usually a kind pointer to where the user documentation is at and
nothing more.&lt;/p&gt;

        &lt;p&gt;&lt;strong&gt;The solution&lt;/strong&gt;:  The student needs to do his own homework.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;Help me, my design doesn’t work.
&lt;a href=&quot;https://forum.digilentinc.com/topic/3991-usb-keyboard-on-basys3/&quot;&gt;[1]&lt;/a&gt;
&lt;a href=&quot;https://forum.digilentinc.com/topic/3731-nexys-4-to-pc-uart-communication/&quot;&gt;[2]&lt;/a&gt;
&lt;a href=&quot;https://forum.digilentinc.com/topic/3706-not-receiving-packets-in-echo-server-example-in-nexys-4-ddr-getting-started-with-microblaze-servers/&quot;&gt;[3]&lt;/a&gt;
&lt;a href=&quot;https://forum.digilentinc.com/topic/3666-artix-nexys-4-and-keyboard/&quot;&gt;[4]&lt;/a&gt;
&lt;a href=&quot;https://forum.digilentinc.com/topic/3675-arty-display-uart-data-on-leds/&quot;&gt;[5]&lt;/a&gt;&lt;/p&gt;

        &lt;p&gt;I’ll come back to this in a moment, but many students think that
an experienced engineer can just deskcheck their work and find the bug.
While I enjoy the challenge, and while I can often do this, it
certainly wasn’t how I became an &lt;em&gt;experienced&lt;/em&gt; engineer when working
with FPGAs.  I got there through simulation to make sure my logic
worked, and using a scope (or scopes) to make sure my simulation
matched the device.&lt;/p&gt;

        &lt;p&gt;&lt;strong&gt;The solution&lt;/strong&gt;: The solution is to simulate the design together with a
simulated peripheral.  This is often how I find bugs in students serial
port designs, for example.  I’ll connect their design to a &lt;a href=&quot;https://github.com/ZipCPU/wbuart32/blob/master/bench/cpp/uartsim.cpp&quot;&gt;serial port
simulator&lt;/a&gt;,
create a &lt;a href=&quot;https://en.wikipedia.org/wiki/Value_change_dump&quot;&gt;.vcd file&lt;/a&gt; for
viewing in &lt;a href=&quot;http://gtkwave.sourceforge.net&quot;&gt;gtkwave&lt;/a&gt;, and write back about
what I found.  There’s no reason why the student couldn’t have done this.&lt;/p&gt;

        &lt;p&gt;Perhaps I’ll post these results for the next student I help?&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;Asynchronous Reset
&lt;a href=&quot;https://forum.digilentinc.com/topic/3702-pc-to-basys3-via-uart-not-working-correctly/&quot;&gt;[1]&lt;/a&gt;&lt;/p&gt;

        &lt;p&gt;While Xilinx devices support an asynchronous reset to the logic, it’s so
unreliable that &lt;a href=&quot;https://forums.xilinx.com/t5/PLD-Blog/That-Dangerous-Asynchronous-Reset/ba-p/12856&quot;&gt;they recommend users not use it&lt;/a&gt;.  This is usually a
student’s first project on an actual FPGA, and a beginner’s mistake.&lt;/p&gt;

        &lt;p&gt;&lt;strong&gt;The solution&lt;/strong&gt;: Get rid of the &lt;em&gt;negedge&lt;/em&gt; &lt;em&gt;reset&lt;/em&gt; from any always block
dependencies.  Replace these with a combination of &lt;em&gt;initial&lt;/em&gt; statements and
(if necessary) synchronous resets.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;The logic Clock
&lt;a href=&quot;https://forum.digilentinc.com/topic/681-creating-a-25-mhz-clock-on-the-basys-3/&quot;&gt;[1]&lt;/a&gt;&lt;/p&gt;

        &lt;p&gt;Many new FPGA users aren’t quite aware the clocks are special things.
They then create logic wires internal to their design which they wish
to use to divide this clock rate.  While not a problem, such logic
wires don’t have the reliability of a clock, and transitioning on their
edges doesn’t produce the result you will want.  Where the problem comes
into play is when the student wants their logic to transition on the
positive (or worse negative) edge of this clock.&lt;/p&gt;

        &lt;p&gt;&lt;strong&gt;The solution&lt;/strong&gt;: &lt;a href=&quot;https://www.quora.com/What-is-the-function-of-a-strobe-function-in-digital-system&quot;&gt;a logic strobe&lt;/a&gt;.&lt;/p&gt;

        &lt;p&gt;This solution finds a lot of application in 1. beginning FPGA student
designs, and then again in 2. signal processing designs, where the
device’s clock speed is not synchronized to the FPGA’s clock, and hence
the data comes in from the sensor at a slower speed than the devices
clock speed.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;The student who hasn’t simulated their design&lt;/p&gt;

        &lt;p&gt;In this case, someone new to FPGA design has created some design and it
doesn’t work.  They don’t know why.  This one is similar to the Vivado
library component problem: they have no idea what’s going on internal
to the FPGA to answer the “why won’t my program work” question.&lt;/p&gt;

        &lt;p&gt;The solution they want to this problem is not the industry solution.
What these students want is for some kind soul on the forum to look at
their code and tell them what they are doing wrong.&lt;/p&gt;

        &lt;p&gt;&lt;strong&gt;The industry solution&lt;/strong&gt; to this problem is to simulate the code and any
peripherals it might be working with, and then as part of that to verify
that the logic works as intended.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;They don’t know how to simulate their problem
&lt;a href=&quot;https://forum.digilentinc.com/topic/3992-something-simple-is-apparently-impossible-incrdec-number/&quot;&gt;[1]&lt;/a&gt;&lt;/p&gt;

        &lt;p&gt;Sometimes the user is trying to work with a piece of hardware they’ve
never worked with before.  As a result, they have no simulation for this
hardware because they just aren’t all that familiar with how it works.
(A user button is a good example of this, since bouncing isn’t something
most people place into simulators.) In this case, their design doesn’t work
on the real hardware and, again, they don’t know why.&lt;/p&gt;

        &lt;p&gt;&lt;strong&gt;The solution&lt;/strong&gt; to this problem is twofold.  First, build a simulator that
encapsulates your understaning of the hardware from the diagrams and
specifications you have.  Second, when that first part fails, use some
form of a  scope to measure what is actually going on across the wires
to/from the hardware.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;Crossing clock domains&lt;/p&gt;

        &lt;p&gt;Few students have ever heard of &lt;a href=&quot;https://en.wikipedia.org/wiki/Metastability_in_electronics&quot;&gt;metastability
problems&lt;/a&gt;.  As
a result, they write code that crosses clock domains realizing that there
might be a problem associated with doing so.&lt;/p&gt;

        &lt;p&gt;&lt;strong&gt;The solution&lt;/strong&gt;: The simple solution is to clock every input at the new
clock twice before using it.  This works for some things, though not all.
A more complete discussion of how to deal with crossing from one clock
can be found in &lt;a href=&quot;http://www.sunburst-design.com/papers/CummingsSNUG2008Boston_CDC.pdf&quot;&gt;this
article&lt;/a&gt;.&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Vivado problems&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;The demo doesn’t build
&lt;a href=&quot;https://forum.digilentinc.com/topic/4090-error-with-pmod-oledrgb-demo/&quot;&gt;[1]&lt;/a&gt;&lt;/p&gt;

        &lt;p&gt;Typically this is caused by the user trying to build the demo design
using one version of Vivado, while the demo was instead built with
another version of Vivado.&lt;/p&gt;

        &lt;p&gt;&lt;strong&gt;The solution&lt;/strong&gt;: The Digilent staff share what version of Vivado was used
to build the demo.  Sometimes the demo has gotten old, and the Digilent
staff need to update it.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;They’ve integrated some component from the Vivado library into their design
and “it’s not working”
&lt;a href=&quot;https://forum.digilentinc.com/topic/4011-how-to-easily-implement-a-basic-low-pass-filter-using-fir-compiler-on-nexys-4-ddr/&quot;&gt;[1]&lt;/a&gt;
&lt;a href=&quot;https://forum.digilentinc.com/topic/3735-dds-compiler-60-ip-core-for-audible-sinewave/&quot;&gt;[2]&lt;/a&gt;&lt;/p&gt;

        &lt;p&gt;Of all the times I’ve seen this problem, it has yet to be that the
Xilinx provided IP component doesn’t work.  It’s more often that the
user isn’t feeding the component properly, or using the results from
the component properly.  Making the problem worse, rarely has the user
taken the time to instrument what is going on, so they have no clue
where their problem lies.&lt;/p&gt;

        &lt;p&gt;&lt;strong&gt;The solution&lt;/strong&gt;: a good internal scope, such as the
&lt;a href=&quot;https://github.com/ZipCPU/wbscope&quot;&gt;wishbone scope&lt;/a&gt; or the &lt;a href=&quot;https://github.com/ZipCPU/wbscope/blob/master/rtl/axi4lscope.v&quot;&gt;AXI-Lite
scope&lt;/a&gt;&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;The user can’t figure out how to add custom IP to the Vivado flow
&lt;a href=&quot;https://forum.digilentinc.com/topic/3961-how-to-add-own-logic-to-arty-board-flow/&quot;&gt;[1]&lt;/a&gt;&lt;/p&gt;

        &lt;p&gt;&lt;strong&gt;The solution&lt;/strong&gt;: Well, I might be biased here, but … my solution to
this problem has been not to use the broken Vivado design flow.
I’m sure I’ll discuss more of my problems with there processing flow
as time goes on.&lt;/p&gt;

        &lt;p&gt;One of the pleasant things about the &lt;a href=&quot;https://forum.digilentinc.com&quot;&gt;Digilent
forums&lt;/a&gt; is that these common requests
are dealt with in a friendly manner–even though I’m certain someone
must be rolling their eyes at seeing the same request &lt;em&gt;again&lt;/em&gt;.&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;I think I’ll come back to this over time, adding references to this this post
of Digilent Forum posts that illustrate my points here.&lt;/p&gt;
</description>
        <pubDate>Thu, 18 May 2017 00:00:00 -0400</pubDate>
        <link>http://zipcpu.com/digilent/2017/05/18/most-common-digilent-support-requests.html</link>
        <guid isPermaLink="true">http://zipcpu.com/digilent/2017/05/18/most-common-digilent-support-requests.html</guid>
        
        
        <category>digilent</category>
        
      </item>
    
      <item>
        <title>Cannot be done</title>
        <description>&lt;p&gt;One common request on Digilent is the, “Can I do XYZ on board ABC”?&lt;/p&gt;

&lt;p&gt;I really dislike answering questions of this type.  I’ve been surprised too many
times by someone doing what I thought was impossible.  Indeed, I’ve also had my
own opportunities to surprise others by doing things they thought were
impossible.&lt;/p&gt;

&lt;p&gt;A couple examples should illustrate this point:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;I gave up early on the idea of building a Video game on a &lt;a href=&quot;https://store.digilentinc.com/basys-3-artix-7-fpga-trainer-board-recommended-for-introductory-users/&quot;&gt;Basys-3
 board&lt;/a&gt;.
 I figured the task was just plain impossible: although you can make
 a 128kB of block RAM on the board, there wasn’t enough memory on
 the board for a 640x480 piece of video memory, with a bare minimum of four
 bits per pixel (256kB required) and the Basys-3 &lt;em&gt;only&lt;/em&gt; has the
 block RAM on board.&lt;/p&gt;

    &lt;p&gt;Since giving up, I discovered some individuals had done it.  Digging
 into those who were willing to share, I learned how they had done it. 
 They took the video stream, and wrote characters directly on the stream
 using FPGA hardware.  That way, there was no storage requirement.  I
 had already done something similar to place a mouse on the screen, so
 I shouldn’t have been as surprised as I was.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;When presenting at &lt;a href=&quot;https://orconf.org/2016/&quot;&gt;ORCONF&lt;/a&gt; some time ago, I had
 the opportunity to meet my first Digilent employee.  When I shared with him
 what &lt;a href=&quot;https://github.com/ZipCPU/s6soc&quot;&gt;I had done&lt;/a&gt; with their
 &lt;a href=&quot;https://store.digilentinc.com/cmod-s6-breadboardable-spartan-6-fpga-module&quot;&gt;CMod S6&lt;/a&gt;, and specifically how I had managed
 to place a multi-tasking O/S (as I called it) on the board, he was
 exceptionally impressed.  Particularly since he had written off the board as
 being unfit for this type of task.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The only question left, therefore, is where the next surprise is coming from.&lt;/p&gt;
</description>
        <pubDate>Thu, 18 May 2017 00:00:00 -0400</pubDate>
        <link>http://zipcpu.com/digilent/2017/05/18/cannot-be-done.html</link>
        <guid isPermaLink="true">http://zipcpu.com/digilent/2017/05/18/cannot-be-done.html</guid>
        
        
        <category>digilent</category>
        
      </item>
    
      <item>
        <title>Welcome to the ZipCPU blog!</title>
        <description>&lt;p&gt;Hello, and welcome to the ZipCPU blog!  This is my first blog post, and so it is
a chance to introduce myself, the ZipCPU, and some of the insights I’ve come 
across while
&lt;a href=&quot;https://forum.digilentinc.com/profile/1454-dn/&quot;&gt;answering help requests&lt;/a&gt;
on the &lt;a href=&quot;https://forum.digilentinc.com&quot;&gt;Digilent forums&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Since this is also my first blog, please feel free to &lt;a href=&quot;&amp;#109;&amp;#097;&amp;#105;&amp;#108;&amp;#116;&amp;#111;:&amp;#122;&amp;#105;&amp;#112;&amp;#099;&amp;#112;&amp;#117;&amp;#064;&amp;#103;&amp;#109;&amp;#097;&amp;#105;&amp;#108;&amp;#046;&amp;#099;&amp;#111;&amp;#109;&quot;&gt;write to
me&lt;/a&gt; regarding any errors you find in this web-site:
broken links, broken web code, etc.&lt;/p&gt;

&lt;p&gt;I am the owner of a small company, Gisselquist Technology, LLC, a services based
company focused on providing superior Computer Engineering and Signal Processing
Services to our customers.  I am also a 20 year veteran of the U.S. Air Force.
While in the Air Force, I sought out and worked on the most difficult
engineering challenges our nation faced.  Now, after a Ph.D. and 20 years of
service, I have focused my energies on the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt; and the environment,
toolsuite, and &lt;a href=&quot;https://github.com/ZipCPU&quot;&gt;peripherals&lt;/a&gt; necessary to support
both it and any customer applications.&lt;/p&gt;

&lt;p&gt;I’d like to use this blog to share some of the lessons I have learned over the
years.  These include both Digital Signal Processing topics, as well as FPGA
design topics.  While some of these topics may be self serving, such as how to
set up the ZipCPU, I’d like to address other topics which are often the subject
of Digilent forum requests.  I’m planning on my first topic being &lt;em&gt;how&lt;/em&gt; &lt;em&gt;to&lt;/em&gt;
&lt;em&gt;debug&lt;/em&gt; &lt;em&gt;an&lt;/em&gt; &lt;em&gt;FPGA&lt;/em&gt; &lt;em&gt;design&lt;/em&gt;, especially since so many junior engineering
students writing in to &lt;a href=&quot;https://forum.digilentinc.com&quot;&gt;Digilent’s forums&lt;/a&gt;
don’t seem to know how to do that.&lt;/p&gt;

&lt;p&gt;Over time, I’d also like to answer the question of how to achieve &lt;a href=&quot;https://forum.digilentinc.com/topic/4131-just-for-fun-frequency-resolution-challenge/&quot;&gt;very clear
frequency resolution&lt;/a&gt; when doing FFT processing, or &lt;a href=&quot;https://github.com/ZipCPU/interpolation/blob/master/tutorial.pdf&quot;&gt;how to build
a universal resampler&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Dan&lt;/p&gt;
</description>
        <pubDate>Wed, 17 May 2017 00:00:00 -0400</pubDate>
        <link>http://zipcpu.com/blog/2017/05/17/welcome.html</link>
        <guid isPermaLink="true">http://zipcpu.com/blog/2017/05/17/welcome.html</guid>
        
        
        <category>blog</category>
        
      </item>
    
  </channel>
</rss>
