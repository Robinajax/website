<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>The ZipCPU by Gisselquist Technology</title>
    <description>The ZipCPU blog, featuring how to discussions of FPGA and soft-core CPU design.  This site will be focused on Verilog solutions, using exclusively OpenSource IP products for FPGA design.  Particular focus areas include topics often left out of more mainstreeam FPGA design courses such as how to debug an FPGA design.
</description>
    <link>https://zipcpu.com/</link>
    <atom:link href="https://zipcpu.com/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Fri, 13 Jul 2018 08:25:00 -0400</pubDate>
    <lastBuildDate>Fri, 13 Jul 2018 08:25:00 -0400</lastBuildDate>
    <generator>Jekyll v3.0.1</generator>
    <image>
      <url>https://zipcpu.com/img/gt-rss.png</url>
      <title></title>
      <link></link>
    </image>
    
      <item>
        <title>Formally Verifying Memory and Cache Components</title>
        <description>&lt;p&gt;While I was in Italy for
&lt;a href=&quot;https://orconf.org/2016&quot;&gt;ORCONF 2016&lt;/a&gt;
I started scribbling out a
&lt;a href=&quot;https://en.wikipedia.org/wiki/CPU_cache&quot;&gt;data cache&lt;/a&gt;
for the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;.  In many ways I
had to.  The
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
compared nicely to many other
&lt;a href=&quot;https://en.wikipedia.org/wiki/Soft_microprocessor&quot;&gt;soft-core CPU&lt;/a&gt;
architectures in all but two important comparisons–the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
had neither
&lt;a href=&quot;https://en.wikipedia.org/wiki/CPU_cache&quot;&gt;data cache&lt;/a&gt; nor
&lt;a href=&quot;https://en.wikipedia.org/wiki/Memory_management_unit&quot;&gt;MMU&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;That was almost two years ago.&lt;/p&gt;

&lt;p&gt;Since that time, I rewrote that
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/dcache.v&quot;&gt;data cache draft&lt;/a&gt;
many times over, but never managed to bring my effort to the finish line.
The design was just never complete.  Indeed, I never got so far as to write
the bench test for it.&lt;/p&gt;

&lt;p&gt;Two months ago, I tried again.  This time, I had a trick up my sleeve that I
never had before: I now understood how to
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formally&lt;/a&gt;
describe a memory controller.  Using
&lt;a href=&quot;http://www.clifford.at/yosys&quot;&gt;Yosys&lt;/a&gt;,
the design became much easier to build.  I could move quickly from one fault
to another, fixing one problem after another until I had a strong
confidence that the design would work.  No, I haven’t tested it on hardware
yet, but I know that when I do it will be close to all it needs to be.&lt;/p&gt;

&lt;p&gt;How much of the design did I evaluate?  Using
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal methods&lt;/a&gt;,
I only ever needed to evaluate about 20 clocks worth of the design.
I evaluated both the first 20 clocks of the design, as well as an
arbitrary set of 20 clock periods somewhere in the middle of time.  That was it.
Put together, I now know
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/dev/rtl/core/dcache.v&quot;&gt;this data cache&lt;/a&gt;
will maintain it’s
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal properties&lt;/a&gt;
for all time.&lt;/p&gt;

&lt;p&gt;This is in strong contrast to using a &lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_Functional_Model&quot;&gt;Bus Functional Model
(BFM)&lt;/a&gt;
to test whether a memory interface design works.  Consider, for example, this
&lt;a href=&quot;https://opencores.org/project/wishbone_bfm&quot;&gt;Wishbone BFM&lt;/a&gt; by
Andrew Mulcock and posted on &lt;a href=&quot;https://opencores.org&quot;&gt;OpenCores&lt;/a&gt;.  It is built
around a series of canned memory operations that can be applied to any
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;Wishbone bus&lt;/a&gt;.  It
then uses random numbers and thousands (millions?) of randomly generated tests
to verify that a design works.&lt;/p&gt;

&lt;p&gt;Wouldn’t you rather just check two sets of twenty steps, and then know that
your design will work for all time?&lt;/p&gt;

&lt;p&gt;This is the benefit of
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal methods&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;When dealing with memories, though, there is a simple trick you need to know
to make this happen.  That trick will be the focus of this article.  First,
I’ll explain the trick in the next section, we’ll then discuss how the trick
can be applied to
&lt;a href=&quot;https://en.wikipedia.org/wiki/CPU_cache&quot;&gt;caches&lt;/a&gt;,
finally we’ll walk through the design of a
&lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/rtl/memdev.v&quot;&gt;block RAM&lt;/a&gt;
controller connected to the
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;Wishbone bus&lt;/a&gt;
as an example of how this trick can be applied.&lt;/p&gt;

&lt;h2 id=&quot;formal-verifying-memory-like-components&quot;&gt;Formal Verifying Memory-like Components&lt;/h2&gt;

&lt;p&gt;Okay, so here’s the trick to
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formally verifying&lt;/a&gt;
memory-like components: assume an arbitrary address, construct the data at
that address, and then verify that transactions to/from this one arbitrary
address all match the data at this address.&lt;/p&gt;

&lt;p&gt;Yes, it is that simple–&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formally
verifying&lt;/a&gt;
one &lt;em&gt;arbitrary&lt;/em&gt; address is sufficient to
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formally verify&lt;/a&gt;
the entire memory space.&lt;/p&gt;

&lt;p&gt;Let’s walk through this concept a bit more.  We’ll start with an arbitrary
address.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;(* anyconst *)	wire	[AW-1:0]	f_addr;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Since we want the solver to pick any constant address, we’ll use
&lt;a href=&quot;http://www.clifford.at/yosys&quot;&gt;Yosys&lt;/a&gt;’s
&lt;code class=&quot;highlighter-rouge&quot;&gt;anyconst&lt;/code&gt; attribute to capture this property.&lt;/p&gt;

&lt;p&gt;We’re also going to need to start with the piece of data at that address.
In this case, we’ll just declare &lt;code class=&quot;highlighter-rouge&quot;&gt;f_data&lt;/code&gt; as a register and initialize it
to the initial value of the memory.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;reg	[DW-1:0]	f_data;

initial f_data = mem[f_addr];&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Given these two values, we can now make our only assumption about them and
our memory.  After setting &lt;code class=&quot;highlighter-rouge&quot;&gt;f_data&lt;/code&gt; to its initial value, we’ll then assert
that these two values match for the rest of time.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(*)
	assert(mem[f_addr] == f_data);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;We’ll also want to assert that any memory read from this address must also
return &lt;code class=&quot;highlighter-rouge&quot;&gt;f_data&lt;/code&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
if ((f_past_valid)
		// A wishbone transaction
		&amp;amp;&amp;amp;($past(i_wb_stb))
		// Reading from our memory
		&amp;amp;&amp;amp;(!$past(i_wb_we))
		// At this address
		&amp;amp;&amp;amp;($past(i_wb_addr == f_addr)))
	assert(o_wb_data == f_data);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;That’s all that’s required for read only memories.&lt;/p&gt;

&lt;p&gt;For memories with a write capability we’ll also need to change
our &lt;code class=&quot;highlighter-rouge&quot;&gt;f_data&lt;/code&gt; value on any memory write.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
// A wishbone transaction
if ((i_wb_stb)
		// writing to our memory
		&amp;amp;&amp;amp;(i_wb_we)
		// At this address
		&amp;amp;&amp;amp;(i_wb_addr == f_addr))
	// Then overwrite f_data
	f_data &amp;lt;= i_wb_data;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;That’s all it takes to
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formally&lt;/a&gt;
describe and verify a memory.  Pretty simple, no?&lt;/p&gt;

&lt;h3 id=&quot;properties-of-a-read-only-cache&quot;&gt;Properties of a read-only cache&lt;/h3&gt;

&lt;p&gt;But what about a
&lt;a href=&quot;https://en.wikipedia.org/wiki/CPU_cache&quot;&gt;cache&lt;/a&gt;?
I began this post by talking about implementing a
&lt;a href=&quot;https://en.wikipedia.org/wiki/CPU_cache&quot;&gt;cache&lt;/a&gt; for the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;.
What does it take to
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formally verify&lt;/a&gt; a
&lt;a href=&quot;https://en.wikipedia.org/wiki/CPU_cache&quot;&gt;cache&lt;/a&gt;?&lt;/p&gt;

&lt;p&gt;In the case of a read only
&lt;a href=&quot;https://en.wikipedia.org/wiki/CPU_cache&quot;&gt;cache&lt;/a&gt;,
such as an instruction
&lt;a href=&quot;https://en.wikipedia.org/wiki/CPU_cache&quot;&gt;cache&lt;/a&gt;,
the same basic principle applies.  You will need to support three basic
properties–roughly mirroring exactly those same basic properties that
we just discussed above.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;On any read resulting from a
&lt;a href=&quot;https://en.wikipedia.org/wiki/CPU_cache#CACHE-MISS&quot;&gt;cache miss&lt;/a&gt;
for address &lt;code class=&quot;highlighter-rouge&quot;&gt;f_addr&lt;/code&gt; from memory, &lt;code class=&quot;highlighter-rouge&quot;&gt;f_data&lt;/code&gt; is the &lt;em&gt;assumed&lt;/em&gt; result.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;If &lt;code class=&quot;highlighter-rouge&quot;&gt;f_addr&lt;/code&gt; is currently a valid address within the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Cache_(computing)&quot;&gt;cache&lt;/a&gt;,
then you’ll need to &lt;em&gt;assert&lt;/em&gt; that &lt;code class=&quot;highlighter-rouge&quot;&gt;f_data&lt;/code&gt; is the
&lt;a href=&quot;https://en.wikipedia.org/wiki/CPU_cache&quot;&gt;cache&lt;/a&gt;
value at that location.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;On any return from the
&lt;a href=&quot;https://en.wikipedia.org/wiki/CPU_cache&quot;&gt;cache&lt;/a&gt;
where &lt;code class=&quot;highlighter-rouge&quot;&gt;f_addr&lt;/code&gt; is the address of the value
returned, then &lt;em&gt;assert&lt;/em&gt; that &lt;code class=&quot;highlighter-rouge&quot;&gt;f_data&lt;/code&gt; is result.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Remember the rule: assume inputs, assert local state and outputs.&lt;/p&gt;

&lt;p&gt;Let’s look at an example of each of these properties.&lt;/p&gt;

&lt;p&gt;The first property is to assume that the response from a bus transaction,
reading from &lt;code class=&quot;highlighter-rouge&quot;&gt;f_addr&lt;/code&gt;, must return &lt;code class=&quot;highlighter-rouge&quot;&gt;f_data&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Having done this a couple of times, I often find it valuable to create a wire
just to capture the logic of whether the current return is the return of
interest.  Not only does this logic simplify the assumption, but it also
has the additional property of creating a value in the trace
file, making it easier to trouble shoot what may be end up being very complex
logic.  In this case, let’s use &lt;code class=&quot;highlighter-rouge&quot;&gt;f_this_return&lt;/code&gt; to represent if the &lt;code class=&quot;highlighter-rouge&quot;&gt;f_addr&lt;/code&gt;
value is the current one being returned from the bus.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;wire	f_this_return;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;What value should this wire have?  Well, if you are incrementing &lt;code class=&quot;highlighter-rouge&quot;&gt;o_wb_addr&lt;/code&gt;
with every address, and if &lt;code class=&quot;highlighter-rouge&quot;&gt;f_outstanding&lt;/code&gt; captures how many requests are
outstanding, then the logic describing whether or not the current return
from the bus is the &lt;code class=&quot;highlighter-rouge&quot;&gt;f_addr&lt;/code&gt; value might look like:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;assign	f_this_return = (o_wb_cyc)&amp;amp;&amp;amp;(i_wb_ack)
		&amp;amp;&amp;amp;(o_wb_addr-f_outstanding == f_addr);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Of course, your logic might vary with your needs in your own
&lt;a href=&quot;https://en.wikipedia.org/wiki/CPU_cache&quot;&gt;cache&lt;/a&gt; design.&lt;/p&gt;

&lt;p&gt;Using this &lt;code class=&quot;highlighter-rouge&quot;&gt;f_this_return&lt;/code&gt; value, we then want to assume that any response
from the bus when &lt;code class=&quot;highlighter-rouge&quot;&gt;f_this_return&lt;/code&gt; is true must equal &lt;code class=&quot;highlighter-rouge&quot;&gt;f_data&lt;/code&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(*)
if (f_this_return)
	assume(i_wb_data == f_data);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;That’s step one–&lt;em&gt;assume&lt;/em&gt; that the input matches.&lt;/p&gt;

&lt;p&gt;For the second property, we’ll need to &lt;em&gt;assert&lt;/em&gt;
that if our arbitrary address is found within the
&lt;a href=&quot;https://en.wikipedia.org/wiki/CPU_cache&quot;&gt;cache&lt;/a&gt;,
then the
&lt;a href=&quot;https://en.wikipedia.org/wiki/CPU_cache&quot;&gt;cache&lt;/a&gt;
value at that location must be &lt;code class=&quot;highlighter-rouge&quot;&gt;f_data&lt;/code&gt;.
You’ll need this assertion in order to get your design to pass
&lt;a href=&quot;/blog/2018/03/10/induction-exercise.html&quot;&gt;induction&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;This idea is a little bit more difficult to communicate–especially to someone
who hasn’t dealt with
&lt;a href=&quot;https://en.wikipedia.org/wiki/CPU_cache&quot;&gt;caches&lt;/a&gt;
before.  (&lt;a href=&quot;https://www.blueletterbible.org/kjv/jas/4/15&quot;&gt;If the Lord is
willing&lt;/a&gt;,
we’ll come back and discuss how to build a
&lt;a href=&quot;https://en.wikipedia.org/wiki/CPU_cache&quot;&gt;cache&lt;/a&gt;
like this later.)&lt;/p&gt;

&lt;p&gt;In the two
implementations that I’ve built, all &lt;a href=&quot;https://en.wikipedia.org/wiki/CPU_cache#Direct-mapped_cache&quot;&gt;direct mapped
caches&lt;/a&gt;,
I’ve split the address into
three basic sections, all shown below in Fig 1.  The
bottom &lt;code class=&quot;highlighter-rouge&quot;&gt;CS&lt;/code&gt; bits are used to describe a location within the
&lt;a href=&quot;https://en.wikipedia.org/wiki/CPU_cache&quot;&gt;cache&lt;/a&gt; memory, and
the bottom &lt;code class=&quot;highlighter-rouge&quot;&gt;LS&lt;/code&gt; of those bits are used to describe a location within a
given
&lt;a href=&quot;https://en.wikipedia.org/wiki/CPU_cache&quot;&gt;cache&lt;/a&gt;
line.  I like to think of these values as the “cache size”
and the “line size” respectively, even though they are really the
log based two of those sizes.&lt;/p&gt;

&lt;p&gt;The third component of the address is the “tag”.  This is the top portion of the
address, from &lt;code class=&quot;highlighter-rouge&quot;&gt;LS&lt;/code&gt; on upwards.&lt;/p&gt;

&lt;p&gt;You can see an address broken down into these separate components in
Fig 1 below.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 1. Components of a Cache Address&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/cache-tag.svg&quot; alt=&quot;&quot; width=&quot;640&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;In this picture, you can see how the lowest two bits aren’t really part of the
word address.  These are the octet address bits, describing an octet’s position
within a 32-bit data word.  We’ll ignore these
sub-word address bits at this stage, though, focusing only on word addresses.&lt;/p&gt;

&lt;p&gt;Second, you can see how the lowest &lt;code class=&quot;highlighter-rouge&quot;&gt;LS&lt;/code&gt; bits are the
&lt;a href=&quot;https://en.wikipedia.org/wiki/CPU_cache&quot;&gt;cache&lt;/a&gt;
line address.  These bits are not part of the tag, since all of the bits
within a given
&lt;a href=&quot;https://en.wikipedia.org/wiki/CPU_cache&quot;&gt;cache&lt;/a&gt;
line will share the same
&lt;a href=&quot;https://en.wikipedia.org/wiki/CPU_cache&quot;&gt;cache&lt;/a&gt; tag bits.&lt;/p&gt;

&lt;p&gt;The &lt;a href=&quot;https://en.wikipedia.org/wiki/CPU_cache&quot;&gt;cache&lt;/a&gt;
itself is maintained as three arrays.  The first, simply called
&lt;code class=&quot;highlighter-rouge&quot;&gt;cache&lt;/code&gt; below, uses the lower &lt;code class=&quot;highlighter-rouge&quot;&gt;CS&lt;/code&gt; bits to address word sized memory values.
This is the block RAM data structure containing the values within the
&lt;a href=&quot;https://en.wikipedia.org/wiki/CPU_cache&quot;&gt;cache&lt;/a&gt; itself.
The second array is a bit vector of &lt;code class=&quot;highlighter-rouge&quot;&gt;CS-LS&lt;/code&gt; bits called &lt;code class=&quot;highlighter-rouge&quot;&gt;cache_line_valid&lt;/code&gt;.
This tells you which
&lt;a href=&quot;https://en.wikipedia.org/wiki/CPU_cache&quot;&gt;cache&lt;/a&gt;
lines have valid values within them.
The third array is also indexed by the upper &lt;code class=&quot;highlighter-rouge&quot;&gt;CS-LS&lt;/code&gt; bits of the &lt;code class=&quot;highlighter-rouge&quot;&gt;CS&lt;/code&gt; bit
&lt;a href=&quot;https://en.wikipedia.org/wiki/CPU_cache&quot;&gt;cache&lt;/a&gt;
address.  This is an array of “tags”, called &lt;code class=&quot;highlighter-rouge&quot;&gt;cache_tag&lt;/code&gt; below.
Hence, any time 1) a
&lt;a href=&quot;https://en.wikipedia.org/wiki/CPU_cache&quot;&gt;cache&lt;/a&gt;
line is valid, and 2) its tag matches &lt;code class=&quot;highlighter-rouge&quot;&gt;f_addr&lt;/code&gt;,
then 3) the value within the
&lt;a href=&quot;https://en.wikipedia.org/wiki/CPU_cache&quot;&gt;cache&lt;/a&gt;
must match &lt;code class=&quot;highlighter-rouge&quot;&gt;f_data&lt;/code&gt; as well.&lt;/p&gt;

&lt;p&gt;Here’s how we’d express that.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(*)
	// If the cache line itself is valid
if ((cache_line_valid[f_addr[CS-LS-1:0])
	//
	// and if this valid cache line&#39;s tag matches the top
	// &quot;tag&quot; bits of our address
	&amp;amp;&amp;amp;(cache_tag[CS-LS-1:0]==f_addr[AW-1:LS]))
	//
	// then assert that this is the value in the cache
	assert(cache[f_addr[CS-1:0]] == f_data);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;We’ll have to come back to this later and provide a proper description of
how to build a
&lt;a href=&quot;https://en.wikipedia.org/wiki/CPU_cache&quot;&gt;cache&lt;/a&gt;.  For
now, this is the basics of how you would test
first that &lt;code class=&quot;highlighter-rouge&quot;&gt;f_addr&lt;/code&gt; is in the
&lt;a href=&quot;https://en.wikipedia.org/wiki/CPU_cache&quot;&gt;cache&lt;/a&gt;, and second that
the value &lt;code class=&quot;highlighter-rouge&quot;&gt;f_data&lt;/code&gt; is found at that location within the
&lt;a href=&quot;https://en.wikipedia.org/wiki/CPU_cache&quot;&gt;cache&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;We now move on to the third
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal property&lt;/a&gt;
for read-only
&lt;a href=&quot;https://en.wikipedia.org/wiki/CPU_cache&quot;&gt;caches&lt;/a&gt;,
that upon any return from the
&lt;a href=&quot;https://en.wikipedia.org/wiki/CPU_cache&quot;&gt;cache&lt;/a&gt;
that comes from the &lt;code class=&quot;highlighter-rouge&quot;&gt;f_addr&lt;/code&gt; address, the value returned should be &lt;code class=&quot;highlighter-rouge&quot;&gt;f_data&lt;/code&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(*)
if ((output_valid)&amp;amp;&amp;amp;(output_address == f_addr))
	assert(output_word == f_data);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;These three properties, the assumption regarding the input, the assertion
regarding the internal state of the
&lt;a href=&quot;https://en.wikipedia.org/wiki/CPU_cache&quot;&gt;cache&lt;/a&gt;,
and the assertion about the output, are all that is needed to
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formally&lt;/a&gt;
describe the required functionality of any read-only
&lt;a href=&quot;https://en.wikipedia.org/wiki/CPU_cache&quot;&gt;cache&lt;/a&gt;.
That said, you might need to adjust how you express
these properties for your design, as not all
&lt;a href=&quot;https://en.wikipedia.org/wiki/CPU_cache&quot;&gt;caches&lt;/a&gt;
have the same structure or the same register and memory names.&lt;/p&gt;

&lt;p&gt;If you recall, we discussed these properties earlier–in our
&lt;a href=&quot;/zipcpu/2018/03/21/dblfetch.html&quot;&gt;pipelined prefetch
article&lt;/a&gt;.  That article
discussed a simple two-element rolling instruction
&lt;a href=&quot;https://en.wikipedia.org/wiki/CPU_cache&quot;&gt;cache&lt;/a&gt;
design.&lt;/p&gt;

&lt;h3 id=&quot;properties-of-a-read-write-cache&quot;&gt;Properties of a read-write cache&lt;/h3&gt;

&lt;p&gt;What about a read-write
&lt;a href=&quot;https://en.wikipedia.org/wiki/CPU_cache&quot;&gt;cache&lt;/a&gt;,
such as the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;’s (brand new)
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/dev/rtl/core/dcache.v&quot;&gt;data cache&lt;/a&gt;
that I referenced above?  In this case, all of the properties of a read-only
&lt;a href=&quot;https://en.wikipedia.org/wiki/CPU_cache&quot;&gt;cache&lt;/a&gt;,
listed above, still need to hold.  In addition, we also need to require that
&lt;code class=&quot;highlighter-rouge&quot;&gt;f_data&lt;/code&gt; change upon any write as well.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
if ((write_request)&amp;amp;&amp;amp;(write_address == f_addr))
	f_data &amp;lt;= write_value;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;If your data value is
&lt;a href=&quot;/zipcpu/2017/05/29/select-lines.html&quot;&gt;octet addressable&lt;/a&gt;,
and your word size is 32-bits,
you’ll need to do a bit more work–but we’ll get to that below.&lt;/p&gt;

&lt;p&gt;You may also need to be careful with the timing of this write–it will need to
match the timing of any actual write to the
&lt;a href=&quot;https://en.wikipedia.org/wiki/CPU_cache&quot;&gt;cache&lt;/a&gt; memory or the second property
will fail.&lt;/p&gt;

&lt;p&gt;That’s basically it.  These simple and basic properties are all that is needed
to &lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formally verify&lt;/a&gt;
any type of memory–whether it be block RAM, an external
&lt;a href=&quot;https://en.wikipedia.org/wiki/Synchronous_dynamic_random-access_memory&quot;&gt;SDRAM&lt;/a&gt;
or &lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash device&lt;/a&gt;,
a read-only
&lt;a href=&quot;https://en.wikipedia.org/wiki/CPU_cache&quot;&gt;cache&lt;/a&gt;
or even a read-write
&lt;a href=&quot;https://en.wikipedia.org/wiki/CPU_cache&quot;&gt;cache&lt;/a&gt;.
The approach is &lt;em&gt;very&lt;/em&gt; versatile.&lt;/p&gt;

&lt;h2 id=&quot;block-ram&quot;&gt;Block RAM&lt;/h2&gt;

&lt;p&gt;Just to drive this lesson home, let’s work through the example of a &lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/rtl/memdev.v&quot;&gt;block RAM
memory controller&lt;/a&gt;,
using this same approach, and let’s verify this block RAM responds
as it should.&lt;/p&gt;

&lt;p&gt;If you’ve been building
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
designs for long, you’ll know that creating a basic &lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/rtl/memdev.v&quot;&gt;block RAM
component&lt;/a&gt;,
in Verilog consists of only a few lines of code.&lt;/p&gt;

&lt;p&gt;First, we’ll need to declare our memory.  In this declaration &lt;code class=&quot;highlighter-rouge&quot;&gt;DW&lt;/code&gt; is the
width of the data words contained in the memory, and &lt;code class=&quot;highlighter-rouge&quot;&gt;AW&lt;/code&gt; is the number of
bits required to address it.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	reg	[(DW-1):0]	mem	[0:((1&amp;lt;&amp;lt;AW)-1)];&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Reading from memory is as simple as,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	o_wb_addr &amp;lt;= mem[i_wb_addr];&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;and writing to memory is only a touch more difficult.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
begin
	if ((i_wb_stb)&amp;amp;&amp;amp;(i_wb_we)&amp;amp;&amp;amp;(i_wb_sel[3]))
		mem[w_addr][31:24] &amp;lt;= w_data[31:24];

	if ((i_wb_stb)&amp;amp;&amp;amp;(i_wb_we)&amp;amp;&amp;amp;(i_wb_sel[2]))
		mem[w_addr][23:16] &amp;lt;= w_data[23:16];

	if ((i_wb_stb)&amp;amp;&amp;amp;(i_wb_we)&amp;amp;&amp;amp;(i_wb_sel[1]))
		mem[w_addr][15: 8] &amp;lt;= w_data[15:8];

	if ((i_wb_stb)&amp;amp;&amp;amp;(i_wb_we)&amp;amp;&amp;amp;(i_wb_sel[0]))
		mem[w_addr][ 7: 0] &amp;lt;= w_data[7:0];
end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Notice how we needed to check whether or not each individual octet was
being written, and then &lt;a href=&quot;/zipcpu/2017/05/29/select-lines.html&quot;&gt;only set that octet to the new
value&lt;/a&gt; if so.&lt;/p&gt;

&lt;p&gt;We’ve discussed both of these operations before.&lt;/p&gt;

&lt;p&gt;I maintain a &lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/rtl/memdev.v&quot;&gt;block RAM
controller&lt;/a&gt;
based upon these principles in the
&lt;a href=&quot;https://github.com/ZipCPU/zbasic&quot;&gt;ZBasic repository&lt;/a&gt;.  We’ll examine
use this design for today’s discussion.&lt;/p&gt;

&lt;p&gt;There are a couple of differences in &lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/rtl/memdev.v&quot;&gt;this block RAM
controller&lt;/a&gt; from
what we’ve just discussed above, although most of them are fairly superficial.
These come from the many years that I’ve worked with this controller.  For
example, on one high speed design I discovered I couldn’t get the request
from a corner of the chip to the dedicated block RAM on-chip hardware in
the center of the chip.  I managed to solve this by adding an extra clock
to memory, but made that extra clock optional–controlled by the parameter,
&lt;code class=&quot;highlighter-rouge&quot;&gt;EXTRACLOCK&lt;/code&gt;.  Recently I added a preload option controlled by the parameter,
&lt;code class=&quot;highlighter-rouge&quot;&gt;HEXFILE&lt;/code&gt;, and even a ROM option, &lt;code class=&quot;highlighter-rouge&quot;&gt;OPT_ROM&lt;/code&gt; should you ever wish to create a
read-only memory instead of the more general purpose block RAM.&lt;/p&gt;

&lt;p&gt;The basic controller that we just outlined above still remains within that
&lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/rtl/memdev.v&quot;&gt;design&lt;/a&gt;.  Indeed,
even with the little feature bloat discussed above, the 
&lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/rtl/memdev.v&quot;&gt;design&lt;/a&gt;
remains quite simple and very readable.&lt;/p&gt;

&lt;h2 id=&quot;formal-properties&quot;&gt;Formal Properties&lt;/h2&gt;

&lt;p&gt;So what does it take to verify this controller?  We’ll skip through
some of the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_(computing)&quot;&gt;bus&lt;/a&gt;
properties and jump straight to the arbitrary address declaration.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	(* anyconst *)	wire	[(AW-1):0]	f_addr;
	reg	[31:0]		f_data;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;These two values are assigned as we discussed above.&lt;/p&gt;

&lt;p&gt;We then need to make certain that our RAM, at address &lt;code class=&quot;highlighter-rouge&quot;&gt;f_addr&lt;/code&gt;, starts with
the initial data found in `f_data.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	initial	assume(mem[f_addr] == f_data);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This guarantees that, should the memory be pre-loaded like a ROM, that the
two values start out identical.&lt;/p&gt;

&lt;p&gt;Next, just as we adjusted our memory value on any write, &lt;code class=&quot;highlighter-rouge&quot;&gt;mem[f_addr]&lt;/code&gt;,
we also need to adjust our data value, &lt;code class=&quot;highlighter-rouge&quot;&gt;f_data&lt;/code&gt;, upon any write to &lt;code class=&quot;highlighter-rouge&quot;&gt;f_addr&lt;/code&gt; as
well.  The code below is just a touch more complicated then we presented above,
simply because the code below only updates &lt;code class=&quot;highlighter-rouge&quot;&gt;f_data&lt;/code&gt; if the ROM option,
&lt;code class=&quot;highlighter-rouge&quot;&gt;OPT_ROM&lt;/code&gt;, is clear.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	generate if (!OPT_ROM)
	begin : F_MATCH_WRITES

		always @(posedge i_clk)
		if ((w_wstb)&amp;amp;&amp;amp;(f_addr == w_addr))
		begin
			if (w_sel[3])
				f_data[31:24] &amp;lt;= w_data[31:24];
			if (w_sel[2])
				f_data[23:16] &amp;lt;= w_data[23:16];
			if (w_sel[1])
				f_data[15: 8] &amp;lt;= w_data[15: 8];
			if (w_sel[0])
				f_data[ 7: 0] &amp;lt;= w_data[ 7: 0];
		end
	end else begin&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;In the case of a ROM, things are just a touch different.
First, we actually need to assign &lt;code class=&quot;highlighter-rouge&quot;&gt;f_data&lt;/code&gt; to be &lt;code class=&quot;highlighter-rouge&quot;&gt;mem[f_addr]&lt;/code&gt;.
This piece caught me by surprise.  It appears as though a value that isn’t
assigned is given an unknown value, &lt;code class=&quot;highlighter-rouge&quot;&gt;x&lt;/code&gt;, that can change on every clock tick.
Hence, we make certain we assign it here.&lt;/p&gt;

&lt;p&gt;Likewise, we assert that this value should never change–this is the ROM option
after all.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;		initial	f_data = mem[f_addr];

		always @(posedge i_clk)
		if (f_past_valid)
			assert(f_data == $past(f_data));

	end endgenerate&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;We conclude our proof by asserting that the memory at our our address &lt;code class=&quot;highlighter-rouge&quot;&gt;f_addr&lt;/code&gt;,
&lt;code class=&quot;highlighter-rouge&quot;&gt;mem[f_addr]&lt;/code&gt;, must always contain the value &lt;code class=&quot;highlighter-rouge&quot;&gt;f_data&lt;/code&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(*)
		assert(mem[f_addr] == f_data);
`endif
endmodule&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;Really, that’s all it takes–just a small number of assumptions and assertions
and you can verify that any memory controller will return the right data given
any address.  Further, notice how these same properties can be applied to both
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/pfcache.v&quot;&gt;instruction&lt;/a&gt;
and
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/dcache.v&quot;&gt;data caches&lt;/a&gt;,
to
&lt;a href=&quot;https://github.com/ZipCPU/xulalx25soc/blob/master/rtl/wbsdram.v&quot;&gt;SDRAM&lt;/a&gt; and
flash memory controllers, as well as our examples above.  Indeed, it was the
ease of describing how a
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/dev/rtl/core/dcache.v&quot;&gt;data cache&lt;/a&gt;
should work that made it so much easier to test when I finally finished
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/dev/rtl/core/dcache.v&quot;&gt;building it&lt;/a&gt;
two months ago.&lt;/p&gt;

&lt;p&gt;Would you believe this approach works for
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/zipmmu.v&quot;&gt;MMU verification&lt;/a&gt;
as well?  We may have to come back and discuss that later as well.  The approach
really is &lt;em&gt;very&lt;/em&gt; flexible!&lt;/p&gt;

&lt;p&gt;Now that you know the basics, we can come back to this topic later and discuss
how to build a basic
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/pfcache.v&quot;&gt;instruction&lt;/a&gt;
or &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/dev/rtl/core/dcache.v&quot;&gt;data cache&lt;/a&gt;,
such as the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; has.  That article
is still coming up.&lt;/p&gt;

&lt;hr /&gt;&lt;p&gt;&lt;em&gt;Then will I remember my covenant with Jacob, and also my covenant with Isaac, and also my covenant with Abraham will I remember; and I will remember the land. (Lev 26:42)&lt;/em&gt;</description>
        <pubDate>Fri, 13 Jul 2018 00:00:00 -0400</pubDate>
        <link>https://zipcpu.com/zipcpu/2018/07/13/memories.html</link>
        <guid isPermaLink="true">https://zipcpu.com/zipcpu/2018/07/13/memories.html</guid>
        
        
        <category>zipcpu</category>
        
      </item>
    
      <item>
        <title>Crossing clock domains with an Asynchronous FIFO</title>
        <description>&lt;p&gt;My first &lt;a href=&quot;https://en.wikipedia.org/wiki/VGA_connector&quot;&gt;VGA video&lt;/a&gt; project was
for a &lt;a href=&quot;https://store.digilentinc.com/basys-3-artix-7-fpga-trainer-board-recommended-for-introductory-users&quot;&gt;Basys3 board&lt;/a&gt;,
following &lt;a href=&quot;https://reference.digilentinc.com/reference/programmable-logic/basys-3/reference-manual&quot;&gt;Digilent’s
instructions&lt;/a&gt;.
The system ran at 100MHz with a 25MHz pixel clock that I could create by
dividing the 100MHz clock down in logic, rather than using a PLL.  In that
design, I could also divide the 100MHz clock by two in logic to reference
flash, and so I had a &lt;a href=&quot;https://opencores.org/project/qspiflash&quot;&gt;flash
controller&lt;/a&gt;
running from a 50MHz clock.  It was a complex design, partly because in order
to get enough bandwidth from flash to video I needed to compress the video
images on the flash device.  In the end, though, everything ran off of a single
100MHz clock–in spite of the various rates moving through the board.&lt;/p&gt;

&lt;p&gt;If only things stayed that easy.&lt;/p&gt;

&lt;p&gt;Since then, I’ve worked on a &lt;a href=&quot;https://github.com/ZipCPU/videozip&quot;&gt;video project&lt;/a&gt;
having a 148.5MHz pixel rate, but where the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Synchronous_dynamic_random-access_memory&quot;&gt;SDRAM memory&lt;/a&gt;
controller wanted a 100MHz clock.
Moving the pixels from the memory clock to the video and back again was a
challenge that I never got past–and part of the reason why the design doesn’t
quite work yet.&lt;/p&gt;

&lt;p&gt;I’ve also wanted to work on an &lt;a href=&quot;https://en.wikipedia.org/wiki/I2S&quot;&gt;I2S audio&lt;/a&gt;
system–also on &lt;a href=&quot;https://store.digilentinc.com/nexys-video-artix-7-fpga-trainer-board-for-multimedia-applications&quot;&gt;Digilent’s
Nexys Video board&lt;/a&gt;.
Like the 148.5MHz video system, the audio system on that board wants a clock
that isn’t an easy logical division of 100MHz: it wants a 49.152MHz clock.&lt;/p&gt;

&lt;p&gt;Both of these designs required having a data stream generated in one
&lt;a href=&quot;/blog/2017/10/20/cdc.html&quot;&gt;clock domain&lt;/a&gt;,
but consumed in another.&lt;/p&gt;

&lt;p&gt;Sure, I tried solving the problem using the techniques I’d discussed earlier
in my &lt;a href=&quot;/blog/2017/10/20/cdc.html&quot;&gt;clock domain
crossing&lt;/a&gt; article, but the results
… never really worked.  When passing streaming data around, the approaches
described in
&lt;a href=&quot;/blog/2017/10/20/cdc.html&quot;&gt;that article&lt;/a&gt; just weren’t
up to the task.  They were the wrong solution for the job.  A much more
appropriate solution would’ve been an &lt;a href=&quot;http://www.sunburst-design.com/papers/CummingsSNUG2002SJ_FIFO1.pdf&quot;&gt;asynchronous
FIFO&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;My journey with &lt;a href=&quot;http://www.sunburst-design.com/papers/CummingsSNUG2002SJ_FIFO1.pdf&quot;&gt;asynchronous
FIFO&lt;/a&gt;s
started out with the initial belief that they were a wizards concept
that I just didn’t understand.  Then I found a 
&lt;a href=&quot;http://www.sunburst-design.com/papers/CummingsSNUG2002SJ_FIFO1.pdf&quot;&gt;paper&lt;/a&gt;
by Cliff Cummings on the topic.  Not only did
&lt;a href=&quot;http://www.sunburst-design.com/papers/CummingsSNUG2002SJ_FIFO1.pdf&quot;&gt;this paper&lt;/a&gt;
describe what an &lt;a href=&quot;http://www.sunburst-design.com/papers/CummingsSNUG2002SJ_FIFO1.pdf&quot;&gt;asynchronous
FIFO&lt;/a&gt;
was, but it also made some amazing claims about the
&lt;a href=&quot;http://www.sunburst-design.com/papers/CummingsSNUG2002SJ_FIFO1.pdf&quot;&gt;FIFO&lt;/a&gt;’s
performance that weren’t apparent to me as I examined his code.
In particular, I wasn’t convinced that his implementation of an &lt;a href=&quot;http://www.sunburst-design.com/papers/CummingsSNUG2002SJ_FIFO1.pdf&quot;&gt;asynchronous
FIFO&lt;/a&gt;
wouldn’t overflow, wouldn’t underflow, or even that the
&lt;a href=&quot;/formal/2018/04/12/areset.html&quot;&gt;asynchronous reset&lt;/a&gt;’s
would work properly.&lt;/p&gt;

&lt;p&gt;At one time I even sat down with Cummings and asked him about his
implementation.  After chatting together, we both agreed the design might be
an ideal design to verify using &lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal
techniques&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;So let me dedicate this article to him.&lt;/p&gt;

&lt;p&gt;This article is also a gateway article to other articles discussing systems
that require &lt;a href=&quot;/blog/2017/10/20/cdc.html&quot;&gt;clock domain
crossings&lt;/a&gt;–such as presenting the
&lt;a href=&quot;https://github.com/ZipCPU/vgasim&quot;&gt;video simulator&lt;/a&gt; I posted on
&lt;a href=&quot;https://github.com/ZipCPU/vgasim&quot;&gt;github&lt;/a&gt;, and what makes it special.&lt;/p&gt;

&lt;p&gt;Since the FIFO we’ll be discussing today is asynchronous, I would
recommend you first read our discussion of properties associated with an
&lt;a href=&quot;/formal/2018/04/12/areset.html&quot;&gt;asynchronous reset&lt;/a&gt;,
as well as the &lt;a href=&quot;/formal/2018/05/31/clkswitch.html&quot;&gt;example of the asynchronous clock
switch&lt;/a&gt;.  These will
give you a bit of background regarding how we might handle multiple clocks
while at the same time working through a design
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formally&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;basic-fifo&quot;&gt;Basic FIFO&lt;/h2&gt;

&lt;p&gt;If you’ve never wrestled with the concept of an &lt;a href=&quot;http://www.sunburst-design.com/papers/CummingsSNUG2002SJ_FIFO1.pdf&quot;&gt;asynchronous
FIFO&lt;/a&gt;
before, you might ask yourself what the big deal is?  Indeed, in many ways an
&lt;a href=&quot;http://www.sunburst-design.com/papers/CummingsSNUG2002SJ_FIFO1.pdf&quot;&gt;asynchronous FIFO&lt;/a&gt;
is just like &lt;a href=&quot;/blog/2017/07/29/fifo.html&quot;&gt;any other FIFO&lt;/a&gt;.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 1. A Basic synchronous FIFO&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/afifo-sinternal.svg&quot; alt=&quot;&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Let’s compare the two FIFOs with each other.  Both a synchronous and
asynchronous FIFOs have a write pointer.  We’ll call this &lt;code class=&quot;highlighter-rouge&quot;&gt;wbin&lt;/code&gt;.  Then,
on any write, we’ll increase this pointer by one–but only if the FIFO
isn’t already FULL.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	initial	wbin = 0;
	always @(posedge i_wclk or negedge i_wrst_n)
	if (!i_wrst_n)
		wbin &amp;lt;= 0;
	else ((i_wr)&amp;amp;&amp;amp;(!o_wfull))
		wbin &amp;lt;= wbin + 1;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Did you notice that this logic takes place using the write
&lt;a href=&quot;/blog/2017/10/20/cdc.html&quot;&gt;clock domain&lt;/a&gt;,
&lt;code class=&quot;highlighter-rouge&quot;&gt;i_wclk&lt;/code&gt;?  Or that the
&lt;a href=&quot;/formal/2018/04/12/areset.html&quot;&gt;reset&lt;/a&gt;
was a negative edge driven
&lt;a href=&quot;/formal/2018/04/12/areset.html&quot;&gt;asynchronous reset&lt;/a&gt;
in the write &lt;a href=&quot;/blog/2017/10/20/cdc.html&quot;&gt;clock domain&lt;/a&gt;
as well?  You’d expect this from an &lt;a href=&quot;http://www.sunburst-design.com/papers/CummingsSNUG2002SJ_FIFO1.pdf&quot;&gt;asynchronous
FIFO&lt;/a&gt;.
The write pointer logic within a &lt;a href=&quot;/blog/2017/07/29/fifo.html&quot;&gt;synchronous
FIFO &lt;/a&gt;
would be the same except that only one
clock would be used, likely with a synchronous reset as well.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.sunburst-design.com/papers/CummingsSNUG2002SJ_FIFO1.pdf&quot;&gt;Cliff Cummings’
FIFO&lt;/a&gt;
is just subtly different from &lt;a href=&quot;/blog/2017/07/29/fifo.html&quot;&gt;my own earlier presentation of a synchronous
FIFO&lt;/a&gt;: his 
&lt;a href=&quot;http://www.sunburst-design.com/papers/CummingsSNUG2002SJ_FIFO1.pdf&quot;&gt;FIFO&lt;/a&gt;
holds a full &lt;code class=&quot;highlighter-rouge&quot;&gt;2^N&lt;/code&gt; elements.  The &lt;a href=&quot;/blog/2017/07/29/fifo.html&quot;&gt;FIFO I presented
earlier&lt;/a&gt;
only holds &lt;code class=&quot;highlighter-rouge&quot;&gt;(2^N)-1&lt;/code&gt; elements.  I like the difference, and will probably
upgrade my own synchronous FIFO implementations to follow this lead as well.
This changes &lt;code class=&quot;highlighter-rouge&quot;&gt;wbin&lt;/code&gt; slightly–we’ll now use &lt;code class=&quot;highlighter-rouge&quot;&gt;N+1&lt;/code&gt; address bits in
&lt;code class=&quot;highlighter-rouge&quot;&gt;wbin&lt;/code&gt; to hold a pointer into a &lt;code class=&quot;highlighter-rouge&quot;&gt;2^N&lt;/code&gt; element FIFO.&lt;/p&gt;

&lt;p&gt;Moving on with our comparison between asynchronous and synchronous FIFOs,
both of them will need to place the incoming data into a memory (block RAM)
on any write.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(posedge i_wclk)
	if ((i_wr)&amp;amp;&amp;amp;(!o_wfull))
		mem[wbin[AW-1:0]] &amp;lt;= i_wdata;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;In the case of the asynchronous FIFO, this is also done specifically using a
clock associated with the write channel, &lt;code class=&quot;highlighter-rouge&quot;&gt;i_wclk&lt;/code&gt;.  I’ve also used &lt;code class=&quot;highlighter-rouge&quot;&gt;AW&lt;/code&gt; to
reflect the &lt;em&gt;address width&lt;/em&gt; of this memory.  I’ll probably still refer to this
as &lt;code class=&quot;highlighter-rouge&quot;&gt;N&lt;/code&gt; throughout in this text.&lt;/p&gt;

&lt;p&gt;The read logic is very similar to the write logic above.  The logic starts
by adjusting a read address pointer which we’ll call &lt;code class=&quot;highlighter-rouge&quot;&gt;rbin&lt;/code&gt;.
Like &lt;code class=&quot;highlighter-rouge&quot;&gt;wbin&lt;/code&gt; above, this has one more bit than necessary to actually address
a value within the buffer–hence it has &lt;code class=&quot;highlighter-rouge&quot;&gt;N+1&lt;/code&gt; bits to access &lt;code class=&quot;highlighter-rouge&quot;&gt;2^N&lt;/code&gt; data points.
In a fashion similar to the write pointer, this pointer also needs to
increment: anytime there’s a read request and the buffer isn’t empty.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	initial	rbin = 0;
	always @(posedge i_rclk or negedge i_rrst_n)
	if (!i_rrst_n)
		rbin &amp;lt;= 0;
	else if ((i_rd)&amp;amp;&amp;amp;(!o_rempty))
		rbin &amp;lt;= rbin + 1;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;As a final step, we’ll read from the memory and return the result.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	assign	o_rdata = mem[rbin[AW-1:0]];&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Voila!  That’s the basics of any FIFO–synchronous or asynchronous.  How
much harder can it be?&lt;/p&gt;

&lt;p&gt;Much.&lt;/p&gt;

&lt;p&gt;As with most digital design problems, the devil lies buried in the details.
In this case, look a little closer at the two flags, &lt;code class=&quot;highlighter-rouge&quot;&gt;o_wfull&lt;/code&gt; indicating
that the FIFO is full and &lt;code class=&quot;highlighter-rouge&quot;&gt;o_rempty&lt;/code&gt; indicating that it is empty.&lt;/p&gt;

&lt;p&gt;As a first attempt to calculate these, we might express them with
combinatorial logic, as in:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	// The FIFO is empty when both read and write pointers point to the
	// same location.
	assign	o_rempty = (wbin == rbin);

	// It is full when wbin-rbin = 2^N.  In that case, the bottom AW
	// address bits are identical, but the top bit is different.
	assign	o_wfull  = (wbin[AW] != rbin[AW])
				&amp;amp;&amp;amp; (wbin[AW-1:0]==rbin[AW-1:0]);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Herein lies the problem.&lt;/p&gt;

&lt;p&gt;For a synchronous FIFO, both &lt;code class=&quot;highlighter-rouge&quot;&gt;AW+1&lt;/code&gt; bit pointers are generated on the same
clock, so there isn’t an immediately apparent problem.  Sure, you might
adjust this logic so the &lt;code class=&quot;highlighter-rouge&quot;&gt;o_rempty&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;o_wfull&lt;/code&gt; flags are registered,
but they’ll still have these same basic values.&lt;/p&gt;

&lt;p&gt;The big problem with these two pointers is specific to any
&lt;em&gt;asynchronous&lt;/em&gt; FIFO design.  In an asynchronous design, the read pointer is
kept in the read clock domain and the write pointer in a separate write clock
domain.  Calculating &lt;code class=&quot;highlighter-rouge&quot;&gt;o_rempty&lt;/code&gt; or &lt;code class=&quot;highlighter-rouge&quot;&gt;o_wfull&lt;/code&gt; requires &lt;a href=&quot;/blog/2017/10/20/cdc.html&quot;&gt;crossing clock
domains&lt;/a&gt;.
This invites problems with
&lt;a href=&quot;https://en.wikipedia.org/wiki/Metastability_in_electronics&quot;&gt;metastability&lt;/a&gt;,
where a design might fine work in simulation but not on actual hardware.
Indeed, it might work 95% of the time on actual hardware, leaving behind
incomprehensible results when it doesn’t work.&lt;/p&gt;

&lt;p&gt;I’ve tried to illustrate this problem in Fig 2 below.  In this figure, I
colored the background based upon which part of the design lies within each
&lt;a href=&quot;/blog/2017/10/20/cdc.html&quot;&gt;clock domain&lt;/a&gt;, whether
yellow for the write clock, or green for the read clock.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 2. In an Asynchronous FIFO, the pointers need to cross clock domains&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/afifo-internals.svg&quot; alt=&quot;&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Fixing these two flags is really the focus of how to build an &lt;a href=&quot;http://www.sunburst-design.com/papers/CummingsSNUG2002SJ_FIFO1.pdf&quot;&gt;asynchronous
FIFO&lt;/a&gt;.
To do so, we’ll build off of our previous work using &lt;a href=&quot;/blog/2017/10/20/cdc.html&quot;&gt;2FF or 3FF
synchronizers&lt;/a&gt;, but this time we’ll
need to introduce &lt;a href=&quot;https://en.wikipedia.org/wiki/Gray_code&quot;&gt;Gray codes&lt;/a&gt; as well.
Each of these concepts is shown in Fig 2 above.&lt;/p&gt;

&lt;h2 id=&quot;gray-codes&quot;&gt;Gray Codes&lt;/h2&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 3. A two clock synchronizer&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/cdc-dbl-clock.svg&quot; alt=&quot;&quot; width=&quot;360&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;When we &lt;a href=&quot;/blog/2017/10/20/cdc.html&quot;&gt;last discussed clock domain
crossings&lt;/a&gt;, we shows how it was
possible to use a two or a three clock synchronizer to pass a
one-bit value from one
&lt;a href=&quot;/blog/2017/10/20/cdc.html&quot;&gt;clock domain&lt;/a&gt;
to the next.  Fig 3 shows an example of this, using two
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flip-flop_(electronics)&quot;&gt;flip flops&lt;/a&gt;
clocked in the new domain–this would be a &lt;a href=&quot;/blog/2017/10/20/cdc.html&quot;&gt;two clock
synchronizer&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The code for this operation is shown below.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(posedge new_clock)
		resynchronized_value &amp;lt;= { unstable_values, unsynchronized_input };&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;In the case of this one bit difference, it doesn’t really matter if that one
bit change arrives one clock earlier or one clock later–it’s just a slow
signal with no dependencies.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 4. Counting in Gray Code&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/afifo-gray-code.svg&quot; alt=&quot;&quot; width=&quot;360&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Sadly, we’re not trying to cross a 1-bit signal from one
&lt;a href=&quot;/blog/2017/10/20/cdc.html&quot;&gt;clock domain&lt;/a&gt;
to another, but rather an &lt;code class=&quot;highlighter-rouge&quot;&gt;N&lt;/code&gt; bit (i.e. &lt;code class=&quot;highlighter-rouge&quot;&gt;AW&lt;/code&gt;-bit) signal from one
&lt;a href=&quot;/blog/2017/10/20/cdc.html&quot;&gt;clock domain&lt;/a&gt;
to the next–whether &lt;code class=&quot;highlighter-rouge&quot;&gt;wbin&lt;/code&gt; to the read clock side or &lt;code class=&quot;highlighter-rouge&quot;&gt;rbin&lt;/code&gt; to the write
clock side.  If we put the whole word into a synchronizer, like the one shown
in Fig 3 but with more bits, then the outputs
wouldn’t suffer from
&lt;a href=&quot;https://en.wikipedia.org/wiki/Metastability_in_electronics&quot;&gt;metastability&lt;/a&gt;
anymore, but they might not be stable anymore
either.  For example, if &lt;code class=&quot;highlighter-rouge&quot;&gt;rbin&lt;/code&gt; were all ones and transitioning to all zeros,
then some uncontrolled random number of ones might be set at the output of the
synchronizer–depending upon how the bits were routed, and thus upon
which arrived before the new clock signal and which arrived afterwards.
As an example, an &lt;code class=&quot;highlighter-rouge&quot;&gt;8&#39;hff&lt;/code&gt; transitioning to &lt;code class=&quot;highlighter-rouge&quot;&gt;8&#39;h00&lt;/code&gt; might be read as &lt;code class=&quot;highlighter-rouge&quot;&gt;8&#39;h52&lt;/code&gt;
(among many, many other possibilities).  This is unacceptable.&lt;/p&gt;

&lt;p&gt;The solution is to pass the address from one
&lt;a href=&quot;/blog/2017/10/20/cdc.html&quot;&gt;clock domain&lt;/a&gt;
to another in a form chosen so that only one bit will ever change at any time.
Formally, we can describe such a &lt;code class=&quot;highlighter-rouge&quot;&gt;word&lt;/code&gt; with the requirement that the
difference between any &lt;code class=&quot;highlighter-rouge&quot;&gt;word&lt;/code&gt; and the &lt;code class=&quot;highlighter-rouge&quot;&gt;$past()&lt;/code&gt; version of it must be
no more than one bit.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(posedge first_clk)
		word &amp;lt;= // Logic to create the next value;

	// Verify that it has no more than one bit difference
	always @(posedge first_clk)
		assert((word == $past(word))
			||($onehot(word ^ $past(word))));&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;$onehot&lt;/code&gt; is a &lt;a href=&quot;https://en.wikipedia.org/wiki/SystemVerilog&quot;&gt;SystemVerilog&lt;/a&gt;
function that returns &lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt; (true) if and only
if one bit is set within its argument, and zero otherwise.&lt;/p&gt;

&lt;p&gt;Sadly, the open source version of &lt;a href=&quot;https://www.clifford.at/yosys&quot;&gt;Yosys&lt;/a&gt;
doesn’t (yet) understand &lt;code class=&quot;highlighter-rouge&quot;&gt;$onehot&lt;/code&gt;.  (The commercial version does.)  We’ll
alternatively express this within a loop.&lt;/p&gt;

&lt;p&gt;Specifically, if any single bit changes between the new and old values, then
all other values must be the same.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	genvar	k;
	generate for (k=0; k &amp;lt;= AW; k=k+1)
	begin : CHECK_ONEHOT
		always @($global_clock)
			assert(word[k] == $past(word[k])
				||(word ^ $past(word) ^ (1&amp;lt;&amp;lt;k) == 0));
	end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Okay, so this is our criteria for success, but what sort of encoding meets
this criteria?  &lt;a href=&quot;https://en.wikipedia.org/wiki/Gray_code&quot;&gt;Gray coding&lt;/a&gt;!&lt;/p&gt;

&lt;p&gt;If we have a counter such as,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(posedge i_clk)
		counter &amp;lt;= counter + 1;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;then a &lt;a href=&quot;https://en.wikipedia.org/wiki/Gray_code&quot;&gt;Gray coded&lt;/a&gt;
version of that same counter will have the property that only
one bit changes at a time.  We can create this 
&lt;a href=&quot;https://en.wikipedia.org/wiki/Gray_code&quot;&gt;Gray coded&lt;/a&gt;
by exclusively &lt;code class=&quot;highlighter-rouge&quot;&gt;OR&lt;/code&gt;ing the counter with itself shifted down by one.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	assign graycounter = counter ^ (counter &amp;gt;&amp;gt; 1);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Using such a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Gray_code&quot;&gt;Gray coded&lt;/a&gt;
counter, we can &lt;a href=&quot;/blog/2017/10/20/cdc.html&quot;&gt;cross clock
domains&lt;/a&gt;
with both read
and write address pointers.  Not only will the results be stable and so
not suffer from
&lt;a href=&quot;https://en.wikipedia.org/wiki/Metastability_in_electronics&quot;&gt;metastability&lt;/a&gt;,
but they will also capture all of the 
information within the address in an fashion that won’t be corrupted
if any given bit within the word arrives earlier or later.&lt;/p&gt;

&lt;p&gt;This means we’ll add
&lt;a href=&quot;https://en.wikipedia.org/wiki/Gray_code&quot;&gt;Gray coded&lt;/a&gt; pointers to
our FIFO design in order to bridge them across
the &lt;a href=&quot;/blog/2017/10/20/cdc.html&quot;&gt;clock domain divide&lt;/a&gt;.
First, the read pointer, now
&lt;a href=&quot;https://en.wikipedia.org/wiki/Gray_code&quot;&gt;Gray coded&lt;/a&gt;
and represented as &lt;code class=&quot;highlighter-rouge&quot;&gt;rgray&lt;/code&gt;, will cross to the write &lt;a href=&quot;/blog/2017/10/20/cdc.html&quot;&gt;clock
domain&lt;/a&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	initial	{ wq2_rgray,  wq1_rgray } = 0;
	always @(posedge i_wclk or negedge i_wrst_n)
	if (!i_wrst_n)
		{ wq2_rgray, wq1_rgray } &amp;lt;= 0;
	else
		{ wq2_rgray, wq1_rgray } &amp;lt;= { wq1_rgray, rgray };&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This is just an &lt;code class=&quot;highlighter-rouge&quot;&gt;N&lt;/code&gt;-bit wide, two flip-flop synchronizer, such as we
&lt;a href=&quot;/blog/2017/10/20/cdc.html&quot;&gt;introduced earlier&lt;/a&gt;
and diagrammed in Fig 3 above.&lt;/p&gt;

&lt;p&gt;Second, the write pointer,
&lt;a href=&quot;https://en.wikipedia.org/wiki/Gray_code&quot;&gt;Gray coded&lt;/a&gt;
as &lt;code class=&quot;highlighter-rouge&quot;&gt;wgray&lt;/code&gt;, will cross from the write to the read
&lt;a href=&quot;/blog/2017/10/20/cdc.html&quot;&gt;clock domain&lt;/a&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	initial	{ rq2_wgray,  rq1_wgray } = 0;
	always @(posedge i_rclk or negedge i_rrst_n)
	if (!i_rrst_n)
		{ rq2_wgray, rq1_wgray } &amp;lt;= 0;
	else
		{ rq2_wgray, rq1_wgray } &amp;lt;= { rq1_wgray, wgray };&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This brings our two pointers, &lt;code class=&quot;highlighter-rouge&quot;&gt;rbin&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;wbin&lt;/code&gt;,  into the other
&lt;a href=&quot;/blog/2017/10/20/cdc.html&quot;&gt;clock domain&lt;/a&gt; as &lt;code class=&quot;highlighter-rouge&quot;&gt;wq2_rgray&lt;/code&gt;
and &lt;code class=&quot;highlighter-rouge&quot;&gt;rq2_wgray&lt;/code&gt;, but these values are no longer counters.  How shall we use
them in our comparisons?  Do we need to convert them back to more traditional
counters?&lt;/p&gt;

&lt;h2 id=&quot;comparing-gray-coded-pointers&quot;&gt;Comparing Gray coded pointers&lt;/h2&gt;

&lt;p&gt;Let’s examine how we might use these two
&lt;a href=&quot;https://en.wikipedia.org/wiki/Gray_code&quot;&gt;Gray&lt;/a&gt; pointers.
Remember, we need to determine when the FIFO is empty and when it is
full.  Before, we had the two lines,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	assign	o_rempty = (wbin == rbin);
	assign	o_wfull  = (wbin[AW] != rbin[AW])
				&amp;amp;&amp;amp; (wbin[AW-1:0]==rbin[AW-1:0]);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Perhaps you noticed the &lt;code class=&quot;highlighter-rouge&quot;&gt;r&lt;/code&gt; in &lt;code class=&quot;highlighter-rouge&quot;&gt;o_rempty&lt;/code&gt;, or the &lt;code class=&quot;highlighter-rouge&quot;&gt;w&lt;/code&gt; in &lt;code class=&quot;highlighter-rouge&quot;&gt;o_wfull&lt;/code&gt;.  These
are from &lt;a href=&quot;http://www.sunburst-design.com/papers/CummingsSNUG2002SJ_FIFO1.pdf&quot;&gt;Cummings’
notation&lt;/a&gt;,
and used to remind the reader that &lt;code class=&quot;highlighter-rouge&quot;&gt;o_rempty&lt;/code&gt; is calculated in the read
&lt;a href=&quot;/blog/2017/10/20/cdc.html&quot;&gt;clock domain&lt;/a&gt;,
whereas &lt;code class=&quot;highlighter-rouge&quot;&gt;o_wfull&lt;/code&gt; is calculated in the write
&lt;a href=&quot;/blog/2017/10/20/cdc.html&quot;&gt;clock domain&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;If you examine the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Gray_code&quot;&gt;Gray coded&lt;/a&gt;
counters illustrated in Fig 4, you’ll notice that the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Gray_code&quot;&gt;Gray coded&lt;/a&gt;
values are unique–just like the counters they represent.  Further, an
&lt;code class=&quot;highlighter-rouge&quot;&gt;N&lt;/code&gt; bit counter can be represented with an &lt;code class=&quot;highlighter-rouge&quot;&gt;N&lt;/code&gt; bit
&lt;a href=&quot;https://en.wikipedia.org/wiki/Gray_code&quot;&gt;Gray code&lt;/a&gt;.
In other words, if you want to check whether or not two pointers
are identical, you only need to check whether the two
&lt;a href=&quot;https://en.wikipedia.org/wiki/Gray_code&quot;&gt;Gray coded&lt;/a&gt; pointers are identical.&lt;/p&gt;

&lt;p&gt;This works great for testing whether or not the FIFO is empty.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	assign	o_rempty = (rq2_wgray == rgray);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;But how shall we test if the FIFO is full?&lt;/p&gt;

&lt;p&gt;In this case, the math is more complicated.  We want to test whether or not
&lt;code class=&quot;highlighter-rouge&quot;&gt;wbin - rbin == 2^N&lt;/code&gt;.  If this is true, then the FIFO is full.  Notice that
any time this comparison is true, the bottom &lt;code class=&quot;highlighter-rouge&quot;&gt;N-1&lt;/code&gt; bits will be constant
between &lt;code class=&quot;highlighter-rouge&quot;&gt;wbin&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;rbin&lt;/code&gt;, and the top bit will be flipped.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 5. If the top bit of an address changes, then both the top two bits of the Gray coded address change&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/afifo-ptr-to-graycode.svg&quot; alt=&quot;&quot; width=&quot;360&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;To see how this comparison changes once converted to
&lt;a href=&quot;https://en.wikipedia.org/wiki/Gray_code&quot;&gt;Gray code&lt;/a&gt;,
consider the
example of &lt;code class=&quot;highlighter-rouge&quot;&gt;16&lt;/code&gt; element FIFO.  Such a FIFO will require 5-bit read and write
pointers.  We’ll allow 5-bits of the read pointer to have the arbitrary
value, &lt;code class=&quot;highlighter-rouge&quot;&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;a,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;b,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;c,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;d,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;.  When the FIFO is full, the associated write
pointer will be &lt;code class=&quot;highlighter-rouge&quot;&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;!a,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;b,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;c,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;d,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;.  Now, consider what will happen to this
pointer when converted to
&lt;a href=&quot;https://en.wikipedia.org/wiki/Gray_code&quot;&gt;Gray code&lt;/a&gt;,
as shown in Fig 5 for the write pointer.&lt;/p&gt;

&lt;p&gt;Remember how the only bit that differed for the write pointer was the most
significant bit.  From Fig 5, you can see that all but the top two bits will
be identical between the read and write pointers following the conversion to
&lt;a href=&quot;https://en.wikipedia.org/wiki/Gray_code&quot;&gt;Gray code&lt;/a&gt;.
Hence, we can test whether the two pointers are identical
in all but their top bits by testing whether the top two bits are opposites,
but the rest of the bits are identical.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	assign	o_wfull  = (wgray[AW:AW-1] == ~wq2_rgray[AW:AW-1])
				&amp;amp;&amp;amp; (wgray[AW-2:0]==wq2_rgray[AW-2:0]);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The solution &lt;a href=&quot;http://www.sunburst-design.com/papers/CummingsSNUG2002SJ_FIFO1.pdf&quot;&gt;Cummings’
presents&lt;/a&gt;
is almost identical.  The difference is that he creates &lt;code class=&quot;highlighter-rouge&quot;&gt;o_rempty&lt;/code&gt; and
&lt;code class=&quot;highlighter-rouge&quot;&gt;o_wfull&lt;/code&gt; using clocked logic instead of combinatorial for better performance.
As a result, his solution looks more like,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(posedge i_rclk or negedge i_rrst_n)
	if (!i_rrst_n)
		o_rempty &amp;lt;= 1&#39;b0;
	else
		o_rempty &amp;lt;= (rq2_wgray == rgray);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;and&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(posedge i_wclk or negedge i_wrst_n)
	if (!i_wrst_n)
		o_wfull &amp;lt;= 1&#39;b0;
	else
		o_wfull &amp;lt;= (wgray[AW:AW-1] == ~wq2_rgray[AW:AW-1])
				&amp;amp;&amp;amp; (wgray[AW-2:0]==wq2_rgray[AW-2:0]);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;However, at this point in the development … I got lost.  Sure, these
pointers are now
&lt;a href=&quot;https://en.wikipedia.org/wiki/Gray_code&quot;&gt;Gray coded&lt;/a&gt; and so they’ll pass
from one &lt;a href=&quot;/blog/2017/10/20/cdc.html&quot;&gt;clock domain&lt;/a&gt;
to another without problems, but how shall I get some confidence that this
design actually works now that it is so different from the synchronous FIFO
I am familiar with?  I mean, what confidence can I have that these two flags,
already delayed by two clocks, are going to keep the FIFO from underruns or
overruns?
&lt;a href=&quot;http://www.sunburst-design.com/papers/CummingsSNUG2002SJ_FIFO1.pdf&quot;&gt;Cummings&lt;/a&gt;
confidently declares that his solution works, citing the works of those who
have proved these properties.  However, even after I read his document, I
remained unconvinced, and not certain of whether or not I wanted to trust my
professional designs to his hand waving.  (Sorry Cliff!)&lt;/p&gt;

&lt;p&gt;What I’d like is to have the confidence that can only come from some form
of &lt;em&gt;&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal proof&lt;/a&gt;&lt;/em&gt;
that this whole thing works–even after &lt;a href=&quot;/blog/2017/10/20/cdc.html&quot;&gt;crossing
clock domains&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Therefore, let’s start looking at the components necessary to
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formally verify&lt;/a&gt;
this design.&lt;/p&gt;

&lt;h2 id=&quot;proof-outline&quot;&gt;Proof Outline&lt;/h2&gt;

&lt;p&gt;Let’s consider what we might wish to prove.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;We’d like to make certain that the FIFO pointers are “within bounds” at all
times.  Since we used &lt;code class=&quot;highlighter-rouge&quot;&gt;AW+1&lt;/code&gt; (address width) bits to represent a &lt;code class=&quot;highlighter-rouge&quot;&gt;2^(AW)&lt;/code&gt;
element FIFO, we’ll need to measure the fill at all times and make certain
it remains within &lt;code class=&quot;highlighter-rouge&quot;&gt;0&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;2^(AW)&lt;/code&gt;.&lt;/p&gt;

    &lt;p&gt;One of the neat things about
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal methods&lt;/a&gt;
is that the variables and tests used within the formal section need not
be synthesizable, neither are they susceptible to
&lt;a href=&quot;https://en.wikipedia.org/wiki/Metastability_in_electronics&quot;&gt;metastability&lt;/a&gt;.
As a result, we can violate all principles of good synthesizable design,
and we can measure the actual FIFO fill directly at any instant (well, at
any formal timestep).&lt;/p&gt;

    &lt;p&gt;This fill should start out at zero, and it should always be less than
or equal to the total amount of space in the FIFO.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	wire	[AW-1:0]	f_fill;
	assign	f_fill = (wbin - rbin);

	initial	assert(f_fill == 0);
	always @(*)
		assert(f_fill &amp;lt;= { 1&#39;b1, {(AW){1&#39;b0}} });&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;ol start=&quot;2&quot;&gt;
  &lt;li&gt;Looking at the empty flag, we want to assert that any time the FIFO is
actually empty, that the &lt;code class=&quot;highlighter-rouge&quot;&gt;o_rempty&lt;/code&gt; flag is also high.&lt;/li&gt;
&lt;/ol&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(*)
		if (f_fill == 0)
			assert(o_rempty);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;ol start=&quot;3&quot;&gt;
  &lt;li&gt;We’ll want to do the same thing for &lt;code class=&quot;highlighter-rouge&quot;&gt;o_wfull&lt;/code&gt;: any time the FIFO is truly
full, we’ll want to assert that &lt;code class=&quot;highlighter-rouge&quot;&gt;o_wfull&lt;/code&gt; is high.&lt;/li&gt;
&lt;/ol&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(*)
		if (f_fill == { 1&#39;b1, {(AW){1&#39;b0}}})
			assert(o_rempty);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;ol start=&quot;4&quot;&gt;
  &lt;li&gt;Just to make certain that these values won’t get stuck, let’s also use
a &lt;code class=&quot;highlighter-rouge&quot;&gt;cover&lt;/code&gt; property to cover going from not-empty to empty, and from
full to not full.&lt;/li&gt;
&lt;/ol&gt;

&lt;ol start=&quot;5&quot;&gt;
  &lt;li&gt;
    &lt;p&gt;Finally, the &lt;a href=&quot;http://www.techdesignforums.com/practice/technique/doc-formal-harness-the-power-of-invariant-based-bug-hunting/&quot;&gt;classic means of proving that a FIFO
works&lt;/a&gt;
is to accept two arbitrary values into the FIFO, at an arbitrary but
sequential pair of locations, and then to verify that those same two
values may be read out of the FIFO some time later.&lt;/p&gt;

    &lt;p&gt;Let’s add that to our proof requirements as well.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;This is only a high level view of the
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal properties&lt;/a&gt;
we’d like to use.  We’ll add some other properties below as well–if for
no other reason than to make certain our design can &lt;a href=&quot;/blog/2018/03/10/induction-exercise.html&quot;&gt;pass
induction&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;cliff-cummings-asynchronous-fifo&quot;&gt;Cliff Cummings’ Asynchronous FIFO&lt;/h2&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 6. Asynchronous FIFO block diagram&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/afifo_io.svg&quot; alt=&quot;&quot; width=&quot;360&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;&lt;a href=&quot;http://www.sunburst-design.com/papers/CummingsSNUG2002SJ_FIFO1.pdf&quot;&gt;Cummings’ FIFO&lt;/a&gt;
has the basic interface shown on the right in Fig 6.  Operation starts in the
write domain, where &lt;code class=&quot;highlighter-rouge&quot;&gt;i_wdata&lt;/code&gt; is written to the FIFO anytime &lt;code class=&quot;highlighter-rouge&quot;&gt;i_wr&lt;/code&gt; is true
and the &lt;code class=&quot;highlighter-rouge&quot;&gt;o_wfull&lt;/code&gt; flag is false.  The data can then be read later from
&lt;code class=&quot;highlighter-rouge&quot;&gt;o_rdata&lt;/code&gt; any time &lt;code class=&quot;highlighter-rouge&quot;&gt;i_rd&lt;/code&gt; is true and &lt;code class=&quot;highlighter-rouge&quot;&gt;o_rempty&lt;/code&gt; is false, in the values
&lt;code class=&quot;highlighter-rouge&quot;&gt;o_rdata&lt;/code&gt;.  Likewise, there’s a clock and an
&lt;a href=&quot;/formal/2018/04/12/areset.html&quot;&gt;asynchronous reset&lt;/a&gt;
associated with each
&lt;a href=&quot;/blog/2017/10/20/cdc.html&quot;&gt;clock domain&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Indeed, the interface is very straight-forward.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.sunburst-design.com/papers/CummingsSNUG2002SJ_FIFO1.pdf&quot;&gt;Cummings’
FIFO&lt;/a&gt;,
however, is built using a series of separate modules: one module for each
clock synchronizer, one for the memory itself, and another two modules for
the read pointer and the write pointer respectively.
Since a design with any hidden states within it may &lt;a href=&quot;/blog/2018/03/10/induction-exercise.html&quot;&gt;struggle to pass
induction&lt;/a&gt;,
I took the liberty of rearranging &lt;a href=&quot;http://www.sunburst-design.com/papers/CummingsSNUG2002SJ_FIFO1.pdf&quot;&gt;Cummings’
FIFO&lt;/a&gt;
a little bit.  Specifically,
I placed all the parts and pieces into a
&lt;a href=&quot;https://github.com/ZipCPU/website/blob/master/examples/afifo.v&quot;&gt;single file&lt;/a&gt;.
This will make it easier to reference values within the design from within a
single &lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal property&lt;/a&gt;
section below.&lt;/p&gt;

&lt;p&gt;The design begins with some declarations.  Note that this FIFO will use a
parameterized data width of two bits, and an address width of 4 bits–and so
this FIFO will hold &lt;code class=&quot;highlighter-rouge&quot;&gt;2^4=16&lt;/code&gt; elements.  While the widths are arbitrary, I’ve
chosen smaller widths to help deal with the combinatorial explosion associated
with using
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal methods&lt;/a&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;module afifo(i_wclk, i_wrst_n, i_wr, i_wdata, o_wfull,
		i_rclk, i_rrst_n, i_rd, o_rdata, o_rempty);
	parameter	DSIZE = 2,
			ASIZE = 4;
	localparam	DW = DSIZE,
			AW = ASIZE;
	input	wire			i_wclk, i_wrst_n, i_wr;
	input	wire	[DW-1:0]	i_wdata;
	output	wire			o_wfull;
	input	wire			i_rclk, i_rrst_n, i_rd;
	output	wire	[DW-1:0]	o_rdata;
	output	wire			o_rempty;

	wire	[AW-1:0]	waddr, raddr;
	wire			wfull_next, rempty_next;
	reg	[AW:0]		wgray, wbin, wq2_rgray, wq1_rgray,
				rgray, rbin, rq2_wgray, rq1_wgray;
	//
	wire	[AW:0]		wgraynext, wbinnext;
	wire	[AW:0]		rgraynext, rbinnext;

	reg	[DW-1:0]	mem	[0:((1&amp;lt;&amp;lt;AW)-1)];&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;These declarations are followed by the write logic of
&lt;a href=&quot;https://github.com/ZipCPU/website/blob/master/examples/afifo.v&quot;&gt;the FIFO&lt;/a&gt;.
This includes bringing the read
&lt;a href=&quot;https://en.wikipedia.org/wiki/Gray_code&quot;&gt;Gray&lt;/a&gt; pointers into the write
&lt;a href=&quot;/blog/2017/10/20/cdc.html&quot;&gt;clock domain&lt;/a&gt;,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	//
	// Cross clock domains
	//
	// Cross the read Gray pointer into the write clock domain
	initial	{ wq2_rgray,  wq1_rgray } = 0;
	always @(posedge i_wclk or negedge i_wrst_n)
	if (!i_wrst_n)
		{ wq2_rgray, wq1_rgray } &amp;lt;= 0;
	else
		{ wq2_rgray, wq1_rgray } &amp;lt;= { wq1_rgray, rgray };&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;maintaining the write pointer and its
&lt;a href=&quot;https://en.wikipedia.org/wiki/Gray_code&quot;&gt;Gray code&lt;/a&gt;
equivalent,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	// Calculate the next write address, and the next graycode pointer.
	assign	wbinnext  = wbin + { {(AW){1&#39;b0}}, ((i_wr) &amp;amp;&amp;amp; (!o_wfull)) };
	assign	wgraynext = (wbinnext &amp;gt;&amp;gt; 1) ^ wbinnext;

	assign	waddr = wbin[AW-1:0];

	// Register these two values--the address and its Gray code
	// representation
	initial	{ wbin, wgray } = 0;
	always @(posedge i_wclk or negedge i_wrst_n)
	if (!i_wrst_n)
		{ wbin, wgray } &amp;lt;= 0;
	else
		{ wbin, wgray } &amp;lt;= { wbinnext, wgraynext };

	assign	wfull_next = (wgraynext == { ~wq2_rgray[AW:AW-1],
				wq2_rgray[AW-2:0] });&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;and writing values into the &lt;a href=&quot;https://github.com/ZipCPU/website/blob/master/examples/afifo.v&quot;&gt;asynchronous
FIFO&lt;/a&gt;
on the write clock.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	//
	// Calculate whether or not the register will be full on the next
	// clock.
	initial	o_wfull = 0;
	always @(posedge i_wclk or negedge i_wrst_n)
	if (!i_wrst_n)
		o_wfull &amp;lt;= 1&#39;b0;
	else
		o_wfull &amp;lt;= wfull_next;

	//
	// Write to the FIFO on a clock
	always @(posedge i_wclk)
	if ((i_wr)&amp;amp;&amp;amp;(!o_wfull))
		mem[waddr] &amp;lt;= i_wdata;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The write section is followed by the read section, having almost exactly the
same format.  First the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Gray_code&quot;&gt;Gray coded&lt;/a&gt;
write address crosses clocks into the read
&lt;a href=&quot;/blog/2017/10/20/cdc.html&quot;&gt;clock domain&lt;/a&gt;,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	//
	// Cross clock domains
	//
	// Cross the write Gray pointer into the read clock domain
	initial	{ rq2_wgray,  rq1_wgray } = 0;
	always @(posedge i_rclk or negedge i_rrst_n)
	if (!i_rrst_n)
		{ rq2_wgray, rq1_wgray } &amp;lt;= 0;
	else
		{ rq2_wgray, rq1_wgray } &amp;lt;= { rq1_wgray, wgray };&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;then the read pointer is adjusted.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	// Calculate the next read address,
	assign	rbinnext  = rbin + { {(AW){1&#39;b0}}, ((i_rd)&amp;amp;&amp;amp;(!o_rempty)) };
	// and the next Gray code version associated with it
	assign	rgraynext = (rbinnext &amp;gt;&amp;gt; 1) ^ rbinnext;

	// Register these two values, the read address and the Gray code version
	// of it, on the next read clock
	//
	initial	{ rbin, rgray } = 0;
	always @(posedge i_rclk or negedge i_rrst_n)
	if (!i_rrst_n)
		{ rbin, rgray } &amp;lt;= 0;
	else
		{ rbin, rgray } &amp;lt;= { rbinnext, rgraynext };

	// Memory read address Gray code and pointer calculation
	assign	raddr = rbin[AW-1:0];&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Finally, an determination is made as to whether or not
&lt;a href=&quot;https://github.com/ZipCPU/website/blob/master/examples/afifo.v&quot;&gt;the FIFO&lt;/a&gt;
is empty and then a value is (may be) read from the buffer.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	// Determine if we&#39;ll be empty on the next clock
	assign	rempty_next = (rgraynext == rq2_wgray);

	initial o_rempty = 1;
	always @(posedge i_rclk or negedge i_rrst_n)
	if (!i_rrst_n)
		o_rempty &amp;lt;= 1&#39;b1;
	else
		o_rempty &amp;lt;= rempty_next;

	//
	// Read from the memory--a clockless read here, clocked by the next
	// read FLOP in the next processing stage (somewhere else)
	//
	assign	o_rdata = mem[raddr];

endmodule&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This is all straight forward with the exception of our pending question: will
this work?&lt;/p&gt;

&lt;p&gt;Let’s write some
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal properties&lt;/a&gt;
together to find out.&lt;/p&gt;

&lt;h2 id=&quot;assuming-two-clocks&quot;&gt;Assuming two clocks&lt;/h2&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 7. Assuming an Arbitrary Clock Rate&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/afifo-clkstep.svg&quot; alt=&quot;&quot; width=&quot;240&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;We’ve &lt;a href=&quot;/formal/2018/05/31/clkswitch.html&quot;&gt;already discussed&lt;/a&gt;
how to assume a clock using
&lt;a href=&quot;https://en.wikipedia.org/wiki/SystemVerilog&quot;&gt;SystemVerilog&lt;/a&gt; properties
and &lt;a href=&quot;https://symbiyosys.readthedocs.io/en/latest&quot;&gt;SymbiYosys&lt;/a&gt;.
Basically, this involves allowing the solver to pick two
arbitrary step sizes, &lt;code class=&quot;highlighter-rouge&quot;&gt;f_wclk_step&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;f_rclk_step&lt;/code&gt;, creating counters
that step by these amounts but with arbitrary initial states, and then assuming
the incoming clock is identical to the most-significant bits of these counters.
All of this logic is shown pictorially in Fig 7 to the right.&lt;/p&gt;

&lt;p&gt;Let’s walk through those steps again, this time in Verilog.&lt;/p&gt;

&lt;p&gt;We’ll start with the arbitrary clock steps.  These are just constants, chosen
by the solver.  They are subject to assumed constraints, but nothing more.
In past articles, I would’ve used
the magic value &lt;code class=&quot;highlighter-rouge&quot;&gt;$anyconst&lt;/code&gt; to describe a value with these properties.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	localparam	F_CLKBITS=5;
	wire	[F_CLKBITS-1:0]	f_wclk_step, f_rclk_step;

	assign	f_wclk_step = $anyconst;
	assign	f_rclk_step = $anyconst;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;However, in an effort to make these random constant value declarations more
uniform, and particularly to be able to support both
&lt;a href=&quot;https://en.wikipedia.org/wiki/SystemVerilog&quot;&gt;SystemVerilog&lt;/a&gt;
&lt;em&gt;and&lt;/em&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/VHDL&quot;&gt;VHDL&lt;/a&gt;,
&lt;a href=&quot;https://www.clifford.at/yosys&quot;&gt;Yosys&lt;/a&gt;
now has the option of declaring these clock step amounts using an
attribute, &lt;code class=&quot;highlighter-rouge&quot;&gt;(* anyconst *)&lt;/code&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	(* anyconst *) wire	[F_CLKBITS-1:0]	f_wclk_step, f_rclk_step;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;We’ll assume that both of these step sizes are greater than zero.
This will guarantee that each clock moves forward–and that they are never
stuck.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(*)
		assume(f_wclk_step != 0);
	always @(*)
		assume(f_rclk_step != 0);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;We can now use these steps sizes in a counter.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	reg	[F_CLKBITS-1:0]	f_wclk_count, f_rclk_count;

	always @($global_clock)
		f_wclk_count &amp;lt;= f_wclk_count + f_wclk_step;
	always @($global_clock)
		f_rclk_count &amp;lt;= f_rclk_count + f_rclk_step;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Notice the reference to &lt;code class=&quot;highlighter-rouge&quot;&gt;$global_clock&lt;/code&gt; here.  This is a reference to the
time-step within the
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal solver&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Although &lt;code class=&quot;highlighter-rouge&quot;&gt;$global_clock&lt;/code&gt; is a
&lt;a href=&quot;https://en.wikipedia.org/wiki/SystemVerilog&quot;&gt;SystemVerilog&lt;/a&gt;
concept,
&lt;a href=&quot;https://en.wikipedia.org/wiki/SystemVerilog&quot;&gt;SystemVerilog&lt;/a&gt;
actually defines this value differently.  In
&lt;a href=&quot;https://en.wikipedia.org/wiki/SystemVerilog&quot;&gt;SystemVerilog&lt;/a&gt;,
the &lt;code class=&quot;highlighter-rouge&quot;&gt;$global_clock&lt;/code&gt; needs
to be defined before it can be used.  It’s similar, but not quite the same
as the global formal timestep.  To bridge this gap, the commercial version of
&lt;a href=&quot;https://www.clifford.at/yosys&quot;&gt;Yosys&lt;/a&gt; allows,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	(* gclk *) wire	gbl_clock;
	global clocking @(posedge gbl_clock); endclocking;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;In this case, &lt;code class=&quot;highlighter-rouge&quot;&gt;gbl_clock&lt;/code&gt; is defined to be the global simulation clock.
Transitions on any edge of this clock will reference a formal timestep.
The &lt;code class=&quot;highlighter-rouge&quot;&gt;global clocking&lt;/code&gt; declaration just defines the
&lt;a href=&quot;https://en.wikipedia.org/wiki/SystemVerilog&quot;&gt;SystemVerilog&lt;/a&gt;
identifier,
&lt;code class=&quot;highlighter-rouge&quot;&gt;$global_clock&lt;/code&gt;, to be a reference to a transition of this formal timestep
clock, &lt;code class=&quot;highlighter-rouge&quot;&gt;gbl_clock&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Now, with all this background, we can finally assume our incoming clocks
at their various speeds.  Specifically, we’ll assume that the read and write
clocks are synonymous with the most significant bit of these counters.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(*)
	begin
		assume(i_wclk == f_wclk_count[F_CLKBITS-1]);
		assume(i_rclk == f_rclk_count[F_CLKBITS-1]);
	end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This will give them each a rough 50% duty cycle.&lt;/p&gt;

&lt;p&gt;If you look at either clock within a trace, you’ll notice that the edges will
appear to jitter back and forth.  For example, the clock might take two time
periods in one cycle and three in the next.  This is normal.  It is a
byproduct of how the clocks are defined.  However, these formal clocks don’t
need to be so stable that you can drive a hardware PLL from them.  They only
need to be representative of two separate clock rates, and they will be that
for us.&lt;/p&gt;

&lt;h2 id=&quot;the-asynchronous-reset&quot;&gt;The Asynchronous Reset&lt;/h2&gt;

&lt;p&gt;Cummings’ design includes two negative logic
&lt;a href=&quot;/formal/2018/04/12/areset.html&quot;&gt;asynchronous reset&lt;/a&gt;
signals,
&lt;code class=&quot;highlighter-rouge&quot;&gt;i_wrst_n&lt;/code&gt;, and &lt;code class=&quot;highlighter-rouge&quot;&gt;i_rrst_n&lt;/code&gt;.   These two
&lt;a href=&quot;/formal/2018/04/12/areset.html&quot;&gt;resets&lt;/a&gt;
are related to each other.  Specifically, we’ll assume that the two
&lt;a href=&quot;/formal/2018/04/12/areset.html&quot;&gt;resets&lt;/a&gt;
will always be asserted at the same time together, but that they are
only ever de-asserted with their respective clocks.  This latter criteria is
sometimes called asynchronous assertion with a synchronous release.&lt;/p&gt;

&lt;p&gt;You can see this concept drawn out in Fig 8 below.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 8. Asynchronous assertion, Synchronous Release&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/afifo-async-reset.svg&quot; alt=&quot;&quot; width=&quot;540&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;This is what we are going to insist, or rather assume, of our
&lt;a href=&quot;/formal/2018/04/12/areset.html&quot;&gt;reset&lt;/a&gt;.  (Remember: assume
inputs, assert local state and outputs.)&lt;/p&gt;

&lt;p&gt;But first, let’s discuss the initial state of the
&lt;a href=&quot;/formal/2018/04/12/areset.html&quot;&gt;reset&lt;/a&gt;.
Initially, I wanted to assume that both resets started asserted.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	initial	assume(!i_wrst_n);
	initial	assume(!i_rrst_n);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;What happens, though, with this approach when you want to implement a design
where the
&lt;a href=&quot;/formal/2018/04/12/areset.html&quot;&gt;reset&lt;/a&gt;s are both hard-wired
high (inactive)?  This should be an allowed configuration for an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;.
Instead, let’s only assume that both
&lt;a href=&quot;/formal/2018/04/12/areset.html&quot;&gt;resets&lt;/a&gt;
start out the same.  That is, either the design starts with both
&lt;a href=&quot;/formal/2018/04/12/areset.html&quot;&gt;resets&lt;/a&gt;
active or with no
&lt;a href=&quot;/formal/2018/04/12/areset.html&quot;&gt;resets&lt;/a&gt;
active.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	initial	assume(i_wrst_n == i_rrst_n);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;We’ll also assume that both
&lt;a href=&quot;/formal/2018/04/12/areset.html&quot;&gt;resets&lt;/a&gt;
are driven from one source.  That means that if one
&lt;a href=&quot;/formal/2018/04/12/areset.html&quot;&gt;reset&lt;/a&gt;
line falls, i.e. that
&lt;a href=&quot;/formal/2018/04/12/areset.html&quot;&gt;reset&lt;/a&gt;
is asserted, then the other must fall as well–just as we illustrated in Fig 8
above.  Neither &lt;a href=&quot;/formal/2018/04/12/areset.html&quot;&gt;reset&lt;/a&gt;
should be asserted without the other.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @($global_clock)
		assume($fell(i_wrst_n)==$fell(i_rrst_n));&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This assumption has a sad consequence: because it is a clocked assumption,
which it needs to be in order to evaluate &lt;code class=&quot;highlighter-rouge&quot;&gt;$fell()&lt;/code&gt;, it will take a clock
edge before this assumption is applied.  As a result, many of our assertions,
particularly those that depend upon results from both
&lt;a href=&quot;/formal/2018/04/12/areset.html&quot;&gt;resets&lt;/a&gt;,
which would otherwise have depended on &lt;code class=&quot;highlighter-rouge&quot;&gt;@(*)&lt;/code&gt; are instead asserted on
&lt;code class=&quot;highlighter-rouge&quot;&gt;@($global_clock)&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;We’ll also assume a synchronous release from
&lt;a href=&quot;/formal/2018/04/12/areset.html&quot;&gt;reset&lt;/a&gt;, also shown in Fig 8
above.  Hence, if the associated clock doesn’t rise, then neither should the
&lt;a href=&quot;/formal/2018/04/12/areset.html&quot;&gt;reset&lt;/a&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @($global_clock)
	if (!$rose(i_wclk))
		assume(!$rose(i_wrst_n));

	always @($global_clock)
	if (!$rose(i_rclk))
		assume(!$rose(i_rrst_n));&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Before we leave the discussion of the
&lt;a href=&quot;/formal/2018/04/12/areset.html&quot;&gt;reset&lt;/a&gt;,
there’s one more item to check.  Following any
&lt;a href=&quot;/formal/2018/04/12/areset.html&quot;&gt;reset&lt;/a&gt;,
the read and write pointers should be zero.  If the write side deasserts the
&lt;a href=&quot;/formal/2018/04/12/areset.html&quot;&gt;reset&lt;/a&gt;
first, the write pointer may start incrementing before the read
pointer.  On the other hand, if the read side leaves the
&lt;a href=&quot;/formal/2018/04/12/areset.html&quot;&gt;reset&lt;/a&gt;
state first, it shouldn’t be allowed to read anything until something has
been written into
&lt;a href=&quot;https://github.com/ZipCPU/website/blob/master/examples/afifo.v&quot;&gt;the FIFO&lt;/a&gt;.
Hence, we’ll assert that anytime the write
&lt;a href=&quot;/formal/2018/04/12/areset.html&quot;&gt;reset&lt;/a&gt;
is low that the read address must point to the beginning of
&lt;a href=&quot;https://github.com/ZipCPU/website/blob/master/examples/afifo.v&quot;&gt;the FIFO&lt;/a&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @($global_clock)
	if (!i_wrst_n)
		assert(rbin == 0);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h2 id=&quot;assuming-synchronous-inputs&quot;&gt;Assuming Synchronous Inputs&lt;/h2&gt;

&lt;p&gt;Whenever you build a set of
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal properties&lt;/a&gt;
to describe logic in multiple
&lt;a href=&quot;/blog/2017/10/20/cdc.html&quot;&gt;clock domains&lt;/a&gt;,
you’ll want to assume that the inputs associated with each
&lt;a href=&quot;/blog/2017/10/20/cdc.html&quot;&gt;clock domain&lt;/a&gt;
remain synchronous to that
&lt;a href=&quot;/blog/2017/10/20/cdc.html&quot;&gt;domain&lt;/a&gt;.
While technically whether or not this takes
place depends upon the problem, I personally find it disconcerting to watch
values change arbitrarily within the generated trace–values that should’ve
only changed on a clock edge.  Going one step further, we should also assert
that the outputs are synchronous with each
&lt;a href=&quot;/blog/2017/10/20/cdc.html&quot;&gt;domain&lt;/a&gt;
as well.&lt;/p&gt;

&lt;p&gt;The basic form of asserting that something is synchronous to a positive
edged clock is to assert that if the clock doesn’t rise, then the value should
be stable.  This needs to be done with the &lt;code class=&quot;highlighter-rouge&quot;&gt;$global_clock&lt;/code&gt;, since it’s
describing the minimum sub-clock time interval within the design.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @($global_clock)
	if (!$rose(clk))
		assert($stable(value));&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;You also need an &lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;f_past_valid&lt;/code&gt;
flag&lt;/a&gt; to
describe this as well.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	reg	f_past_valid_gbl;
	initial	f_past_valid_gbl = 1&#39;b0;
	always $($global_clock)
		f_past_valid_gbl &amp;lt;= 1&#39;b1;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;In our case, we can use three separate &lt;code class=&quot;highlighter-rouge&quot;&gt;f_past_valid&lt;/code&gt; types of flags: one for
each of the clocks in our design, &lt;code class=&quot;highlighter-rouge&quot;&gt;$global_clock&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;i_wclk&lt;/code&gt; (not shown), and
&lt;code class=&quot;highlighter-rouge&quot;&gt;i_rclk&lt;/code&gt; (not shown).  Without these values,
the solver will try to reference an undefined value before time began and
all assertions based upon this value would fail.  For this reason, all
references to &lt;code class=&quot;highlighter-rouge&quot;&gt;$past()&lt;/code&gt; or in this case to &lt;code class=&quot;highlighter-rouge&quot;&gt;$rose()&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;$fell()&lt;/code&gt;, or &lt;code class=&quot;highlighter-rouge&quot;&gt;$stable()&lt;/code&gt;
need to be qualified by an &lt;code class=&quot;highlighter-rouge&quot;&gt;f_past_valid&lt;/code&gt; piece of logic.  In this case,
by &lt;code class=&quot;highlighter-rouge&quot;&gt;f_past_valid_gbl&lt;/code&gt;–the &lt;code class=&quot;highlighter-rouge&quot;&gt;f_past_valid&lt;/code&gt; signal we created for the formal
time-step.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @($global_clock)
	if (f_past_valid_gbl)
	begin&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;In the case of the write clock, if the write clock hasn’t risen than the
write request line, &lt;code class=&quot;highlighter-rouge&quot;&gt;i_wr&lt;/code&gt;, and the write data, &lt;code class=&quot;highlighter-rouge&quot;&gt;i_wdata&lt;/code&gt;, should both
be assumed constant.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;		if (!$rose(i_wclk))
		begin
			assume($stable(i_wr));
			assume($stable(i_wdata));&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;In a similar manner, the &lt;code class=&quot;highlighter-rouge&quot;&gt;o_wfull&lt;/code&gt; flag should also
be constant.  Since this latter flag is an output, we’ll &lt;em&gt;assert&lt;/em&gt; that it is
constant rather than &lt;em&gt;assuming&lt;/em&gt; it.  The only difficulty being the
&lt;a href=&quot;/formal/2018/04/12/areset.html&quot;&gt;reset&lt;/a&gt;.
Specifically, if the write
&lt;a href=&quot;/formal/2018/04/12/areset.html&quot;&gt;reset&lt;/a&gt;
is ever asserted, then &lt;code class=&quot;highlighter-rouge&quot;&gt;o_wfull&lt;/code&gt; will drop asynchronously.  Hence,
we’ll need to check for that.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;			assert($stable(o_wfull)||(!i_wrst_n));
		end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The read logic is almost identical as well, so it’s not that remarkable.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;		if (!$rose(i_rclk))
		begin
			assume($stable(i_rd));
			assert((o_rempty)||($stable(o_rdata)));
			assert((!i_rrst_n)||($stable(o_rempty)));
		end
	end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This is just one of those rather tedious parts of an asynchronous proof.&lt;/p&gt;

&lt;h2 id=&quot;verifying-the-reset&quot;&gt;Verifying the Reset&lt;/h2&gt;

&lt;p&gt;My readers should understand why I use &lt;code class=&quot;highlighter-rouge&quot;&gt;f_past_valid&lt;/code&gt;: if you make an assertion
using the &lt;code class=&quot;highlighter-rouge&quot;&gt;$past&lt;/code&gt; operator, one were the &lt;code class=&quot;highlighter-rouge&quot;&gt;$past()&lt;/code&gt; operator references a value
before the initial time began, then the solver can immediately declare that
assertion to be invalid.  Not only that, there will be no trace associated
with that past assertion.  To keep this from happening, I use a register I call
&lt;code class=&quot;highlighter-rouge&quot;&gt;f_past_valid&lt;/code&gt;.  It’s initialized to zero, and then set immediately to one on
the first clock tick.&lt;/p&gt;

&lt;p&gt;This is all straightforward.  It’s something I’ve been doing for many proofs,
and I’ve posted about the &lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;reasons for it
already&lt;/a&gt;
on this blog.&lt;/p&gt;

&lt;p&gt;One time, however, I was caught by surprise when I examined a trace
describing a
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal proof&lt;/a&gt;
that crossed multiple files.  In this trace, the
&lt;code class=&quot;highlighter-rouge&quot;&gt;f_past_valid&lt;/code&gt; signals didn’t line up!  Some were true, others were false.
This should’ve never happened in real life.  What made it happen was
&lt;a href=&quot;/blog/2018/03/10/induction-exercise.html&quot;&gt;induction&lt;/a&gt;,
where the solver gets to pick the initial states for all values.&lt;/p&gt;

&lt;p&gt;To keep this from happening, I will often add statements to my design forcing
the design to be in
&lt;a href=&quot;/formal/2018/04/12/areset.html&quot;&gt;reset&lt;/a&gt;
any time &lt;code class=&quot;highlighter-rouge&quot;&gt;f_past_valid&lt;/code&gt; is false.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(*)
	if (!f_past_valid)
		assume(i_reset);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;I also use &lt;code class=&quot;highlighter-rouge&quot;&gt;f_past_valid&lt;/code&gt; to double check any initialization statements.  For
synchronous logic, this usually looks something like:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(posedge i_clk)
	if ((!f_past_valid)||($past(i_reset)))
	begin
		assert(value == 0);
		// ....
	end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;In this manner, I can insist that anytime one &lt;code class=&quot;highlighter-rouge&quot;&gt;f_past_valid&lt;/code&gt; is false, the
entire design is in its
&lt;a href=&quot;/formal/2018/04/12/areset.html&quot;&gt;reset&lt;/a&gt;
state, &lt;em&gt;and&lt;/em&gt; that the
&lt;a href=&quot;/formal/2018/04/12/areset.html&quot;&gt;reset&lt;/a&gt;
state is identical to the initial state.&lt;/p&gt;

&lt;p&gt;That’s not how I verified this design, though.  In particular, within this
design I wanted to allow the
&lt;a href=&quot;/formal/2018/04/12/areset.html&quot;&gt;reset&lt;/a&gt;,
line(s) to be tied high if the designer so chose.&lt;/p&gt;

&lt;p&gt;In this design, I used the fact that the
&lt;a href=&quot;/formal/2018/04/12/areset.html&quot;&gt;reset was asynchronous&lt;/a&gt;,
to do things a little differently.  Instead of checking whether the
&lt;a href=&quot;/formal/2018/04/12/areset.html&quot;&gt;reset&lt;/a&gt;
was true in the past, we’ll do this second check based upon whether the
&lt;a href=&quot;/formal/2018/04/12/areset.html&quot;&gt;reset&lt;/a&gt;
is currently asserted.&lt;/p&gt;

&lt;p&gt;Hence, anytime the write
&lt;a href=&quot;/formal/2018/04/12/areset.html&quot;&gt;reset&lt;/a&gt;
is asserted, or until the first write clock,
all of our write values should be in their initial states.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(*)
	if ((!f_past_valid_wr)||(!i_wrst_n))
	begin
		`ASSUME(i_wr == 0);
		//
		`ASSERT(wgray == 0);
		`ASSERT(wbin == 0);
		`ASSERT(!o_wfull);
		//
		`ASSERT(wq1_rgray == 0);
		`ASSERT(wq2_rgray == 0);
		`ASSERT(rq1_wgray == 0);
		`ASSERT(rq2_wgray == 0);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;While this section is all about the &lt;em&gt;write&lt;/em&gt; side of the interface,
we’ll make an exception to this rule for two values associated with the read
clock: the FIFO read address, &lt;code class=&quot;highlighter-rouge&quot;&gt;rbin&lt;/code&gt;, and its associated &lt;code class=&quot;highlighter-rouge&quot;&gt;o_rempty&lt;/code&gt; signal.
Anytime the registers in the write clock are in their
&lt;a href=&quot;/formal/2018/04/12/areset.html&quot;&gt;reset&lt;/a&gt;,
state, these read values must also remain in their
&lt;a href=&quot;/formal/2018/04/12/areset.html&quot;&gt;reset&lt;/a&gt;
values–since the write side hasn’t yet written anything to be read, and the
read pointer isn’t allowed to move forward from an empty FIFO while it’s still
empty, etc.  You get the idea.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;		//
		`ASSERT(rbin == 0);
		`ASSERT(o_rempty);
	end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The read side is less remarkable.  It also includes roughly the same logic.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(*)
	if ((!f_past_valid_rd)||(!i_rrst_n))
	begin
		`ASSUME(i_rd == 0);
		//
		`ASSERT(rgray == 0);
		`ASSERT(rbin == 0);
		`ASSERT(rq1_wgray == 0);
		`ASSERT(rq2_wgray == 0);
		`ASSERT(wq1_rgray == 0);
		`ASSERT(wq2_rgray == 0);
	end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;At this point, we know our design starts in a
&lt;a href=&quot;/formal/2018/04/12/areset.html&quot;&gt;reset&lt;/a&gt;
configuration either at the beginning of time, or following any
&lt;a href=&quot;/formal/2018/04/12/areset.html&quot;&gt;reset&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;verifying-the-fill-levels&quot;&gt;Verifying the Fill Levels&lt;/h2&gt;

&lt;p&gt;All of the steps so far have been preliminary, set up sorts of things.  None
of them have actually impacted the proof requirements we listed above.  Let’s
now move into the actual FIFO properties associated with its operation.
We’ll start with the pointers in this section, and then verify the two
element write test in the next section.  In between these two sections,
we’ll skip the proof of the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Gray_code&quot;&gt;Gray codes&lt;/a&gt;.
It follows directly from the discussion
above, and it is in the file if you wish to reference it.
Indeed, many of the properties associated with the fill of
&lt;a href=&quot;https://github.com/ZipCPU/website/blob/master/examples/afifo.v&quot;&gt;this FIFO&lt;/a&gt;
we’ve already discussed above, but they are important enough to discuss
one more time here.&lt;/p&gt;

&lt;p&gt;Will start with a measure of how full
&lt;a href=&quot;https://github.com/ZipCPU/website/blob/master/examples/afifo.v&quot;&gt;the FIFO&lt;/a&gt; is.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	wire	[AW:0]		f_fill;

	assign	f_fill = (wbin - rbin);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;I like to prefix values, like this one, that are only used in the
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal properties&lt;/a&gt;
with a &lt;code class=&quot;highlighter-rouge&quot;&gt;f_&lt;/code&gt;.  It helps me quickly recognize which values are used for the
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal proof&lt;/a&gt;,
and which are used within the design itself.&lt;/p&gt;

&lt;p&gt;As mentioned above, because &lt;code class=&quot;highlighter-rouge&quot;&gt;f_fill&lt;/code&gt; is a value only defined in our formal
properties, it can depend upon values that
&lt;a href=&quot;/blog/2017/10/20/cdc.html&quot;&gt;cross clock domains&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;As we indicated above, we’ll start out asserting that
&lt;a href=&quot;https://github.com/ZipCPU/website/blob/master/examples/afifo.v&quot;&gt;the FIFO&lt;/a&gt;
is initially empty, and that it never has more than &lt;code class=&quot;highlighter-rouge&quot;&gt;2^(AW)&lt;/code&gt; elements within it.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	initial	`ASSERT(f_fill == 0);
	always @($global_clock)
		`ASSERT(f_fill &amp;lt;= { 1&#39;b1, {(AW){1&#39;b0}} });&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Now let’s look at &lt;code class=&quot;highlighter-rouge&quot;&gt;o_wfull&lt;/code&gt;.  In particular, anytime
&lt;a href=&quot;https://github.com/ZipCPU/website/blob/master/examples/afifo.v&quot;&gt;the FIFO&lt;/a&gt;
is full, the &lt;code class=&quot;highlighter-rouge&quot;&gt;o_wfull&lt;/code&gt; flag should be asserted.  This property should help
to assure users of &lt;a href=&quot;https://github.com/ZipCPU/website/blob/master/examples/afifo.v&quot;&gt;this asynchronous
FIFO&lt;/a&gt;
that it actually works–at least, that this flag works.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	// Any time the FIFO is full, o_wfull should be true.  It may take a
	// clock or two to clear, though, so this is an implication and not
	// an equals.
	always @($global_clock)
	if (f_fill == {1&#39;b1,{(AW){1&#39;b0}}})
		`ASSERT(o_wfull);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;We’ll also check how things work on the clock before everything is full.
Specifically, if
&lt;a href=&quot;https://github.com/ZipCPU/website/blob/master/examples/afifo.v&quot;&gt;the FIFO&lt;/a&gt;
has &lt;code class=&quot;highlighter-rouge&quot;&gt;2^(AW)-1&lt;/code&gt; elements in it, it should then be
full on the next write.  That means that either the &lt;code class=&quot;highlighter-rouge&quot;&gt;o_wfull&lt;/code&gt; flag must be true,
there’s no request to write, or &lt;code class=&quot;highlighter-rouge&quot;&gt;o_wfull&lt;/code&gt; will be set to true on the next clock.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @($global_clock)
	if (f_fill == {1&#39;b0,{(AW){1&#39;b1}}})
		`ASSERT((wfull_next)||(!i_wr)||(o_wfull));&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This was one of those extra properties necessary to pass
&lt;a href=&quot;/blog/2018/03/10/induction-exercise.html&quot;&gt;induction&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;We’ll make a similar assertion about
&lt;a href=&quot;https://github.com/ZipCPU/website/blob/master/examples/afifo.v&quot;&gt;the FIFO&lt;/a&gt;
being empty:  Any time the FIFO is truly empty, the &lt;code class=&quot;highlighter-rouge&quot;&gt;o_rempty&lt;/code&gt; must be
true.  In this design, it will also be asserted at other times as well
(i.e. there’s a lag before its cleared), so as with the write check above it,
this is a one-way implication only, and not an equals.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @($global_clock)
	if (f_fill == 0)
		`ASSERT(o_rempty);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;We’ll add another assertion in here for good measure and to help with
&lt;a href=&quot;/blog/2018/03/10/induction-exercise.html&quot;&gt;induction&lt;/a&gt;.
Specifically, we’ll assert that if the &lt;code class=&quot;highlighter-rouge&quot;&gt;f_fill&lt;/code&gt; isn’t quite zero, then either
the empty flag is true, or the empty flag will be true on the next clock,
or nothing is being read.  Put simply, let’s check the logic before the fill
becomes empty just like we did with the logic before
&lt;a href=&quot;https://github.com/ZipCPU/website/blob/master/examples/afifo.v&quot;&gt;the FIFO&lt;/a&gt;
became full.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	// If the FIFO is about to be empty, the logic should be able
	// to detect that condition as well.
	always @($global_clock)
	if (f_fill == 1)
		`ASSERT((rempty_next)||(!i_rd)||(o_rempty));&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Consistency requires that the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Gray_code&quot;&gt;Gray&lt;/a&gt; pointers
always match their respective address pointers.  Let’s insist that be the
case here, lest the
&lt;a href=&quot;/blog/2018/03/10/induction-exercise.html&quot;&gt;induction engine&lt;/a&gt;
find some way to defeat this proof using an invalid state.  This applies for
both read and write &lt;a href=&quot;https://en.wikipedia.org/wiki/Gray_code&quot;&gt;Gray&lt;/a&gt; pointers.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(*)
		`ASSERT(wgray == ((wbin&amp;gt;&amp;gt;1)^wbin));

	always @(*)
		`ASSERT(rgray == ((rbin&amp;gt;&amp;gt;1)^rbin));&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Finally, let’s double check that our
&lt;a href=&quot;https://en.wikipedia.org/wiki/Gray_code&quot;&gt;Gray&lt;/a&gt; pointer
arithmetic truly does match
our address arithmetic.  Remember, in the design above, we pushed the empty
and full logic from combinatorial logic into clocked logic.  The combinatorial
logic should still hold, so let’s check it here.&lt;/p&gt;

&lt;p&gt;First, is
&lt;a href=&quot;https://github.com/ZipCPU/website/blob/master/examples/afifo.v&quot;&gt;the FIFO&lt;/a&gt;
full?  If so, the &lt;a href=&quot;https://en.wikipedia.org/wiki/Gray_code&quot;&gt;Gray&lt;/a&gt; pointers
should differ in their top bit but be identical for the rest of their bits.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(*)
		`ASSERT( (rgray == { ~wgray[AW:AW-1], wgray[AW-2:0] })
			== (f_fill == { 1&#39;b1, {(AW){1&#39;b0}} }) );&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Second, if &lt;a href=&quot;https://github.com/ZipCPU/website/blob/master/examples/afifo.v&quot;&gt;the
FIFO&lt;/a&gt; is empty,
and only if &lt;a href=&quot;https://github.com/ZipCPU/website/blob/master/examples/afifo.v&quot;&gt;the
FIFO&lt;/a&gt;
is empty, then the &lt;a href=&quot;https://en.wikipedia.org/wiki/Gray_code&quot;&gt;Gray&lt;/a&gt; pointers
should be identical.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(*)
		`ASSERT((rgray == wgray) == (f_fill == 0));&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;These are the basic properties we want to prove about
&lt;a href=&quot;https://github.com/ZipCPU/website/blob/master/examples/afifo.v&quot;&gt;the FIFO&lt;/a&gt;’s
fill amount.
If all you want is a bounded model check, you can skip to the next section.&lt;/p&gt;

&lt;p&gt;On the other hand, if you’d like a full
&lt;a href=&quot;/blog/2018/03/10/induction-exercise.html&quot;&gt;induction&lt;/a&gt;
check, and hence a proof for all time, then we need to check
that the values and registers associated with
&lt;a href=&quot;/blog/2017/10/20/cdc.html&quot;&gt;crossing clock domains&lt;/a&gt; are
valid as well.&lt;/p&gt;

&lt;p&gt;To do this, we’ll create 2-FF synchronizers within the
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal properties&lt;/a&gt;
section to delay the binary pointer values so they’ll have an image,
in the new clock domain, synchronous with the value of their
&lt;a href=&quot;https://en.wikipedia.org/wiki/Gray_code&quot;&gt;Gray&lt;/a&gt; versions.
Again, since this isn’t synthesizable code, there’s no danger of
&lt;a href=&quot;https://en.wikipedia.org/wiki/Metastability_in_electronics&quot;&gt;metastability&lt;/a&gt;
here, as there would be in the synthesis section above.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	reg	[AW:0]	f_w2r_rbin, f_w1r_rbin,
			f_r2w_wbin, f_r1w_wbin;
	wire	[AW:0]	f_w2r_fill, f_r2w_fill;

	initial	{ f_w2r_rbin, f_w1r_rbin } = 0;
	always @(posedge i_wclk or negedge i_wrst_n)
	if (!i_wrst_n)
		{ f_w2r_rbin, f_w1r_rbin } &amp;lt;= 0;
	else
		{ f_w2r_rbin, f_w1r_rbin } &amp;lt;= { f_w1r_rbin, rbin };

	initial	{ f_r2w_wbin, f_r1w_wbin } = 0;
	always @(posedge i_rclk or negedge i_rrst_n)
	if (!i_rrst_n)
		{ f_r2w_wbin, f_r1w_wbin } &amp;lt;= 0;
	else
		{ f_r2w_wbin, f_r1w_wbin } &amp;lt;= { f_r1w_wbin, wbin };&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The next step is to force these helper variables to be properly matched to
their &lt;a href=&quot;https://en.wikipedia.org/wiki/Gray_code&quot;&gt;Gray coded&lt;/a&gt;
counter parts.  (No pun intended.)  That is, we should be able to convert
these values to &lt;a href=&quot;https://en.wikipedia.org/wiki/Gray_code&quot;&gt;Gray code&lt;/a&gt; and they
should match.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(*)
		`ASSERT(rq1_wgray == ((f_r1w_wbin&amp;gt;&amp;gt;1)^f_r1w_wbin));
	always @(*)
		`ASSERT(rq2_wgray == ((f_r2w_wbin&amp;gt;&amp;gt;1)^f_r2w_wbin));

	always @(*)
		`ASSERT(wq1_rgray == ((f_w1r_rbin&amp;gt;&amp;gt;1)^f_w1r_rbin));
	always @(*)
		`ASSERT(wq2_rgray == ((f_w2r_rbin&amp;gt;&amp;gt;1)^f_w2r_rbin));&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Finally, we can calculate the fill at the other end of this synchronizer
chain.  These two fill values, one using &lt;code class=&quot;highlighter-rouge&quot;&gt;wbin&lt;/code&gt; and the re-synchronized &lt;code class=&quot;highlighter-rouge&quot;&gt;rbin&lt;/code&gt;,
the other using &lt;code class=&quot;highlighter-rouge&quot;&gt;rbin&lt;/code&gt; and the re-synchronized &lt;code class=&quot;highlighter-rouge&quot;&gt;wbin&lt;/code&gt;, should clearly describe
our &lt;code class=&quot;highlighter-rouge&quot;&gt;o_wfull&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;o_rempty&lt;/code&gt; flags.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	assign	f_w2r_fill = wbin - f_w2r_rbin;
	assign	f_r2w_fill = f_r2w_wbin - rbin;


	// And assert that the fill is always less than or equal to full.
	// This catches underrun as well as overflow, since underrun will
	// look like the fill suddenly increases
	always @(*)
		`ASSERT(f_w2r_fill &amp;lt;= { 1&#39;b1, {(AW){1&#39;b0}} });
	always @(*)
		`ASSERT(f_r2w_fill &amp;lt;= { 1&#39;b1, {(AW){1&#39;b0}} });

	// From the writers perspective, anytime the Gray pointers are
	// equal save for the top bit, the FIFO is full and should be asserted
	// as such.  It is possible for the FIFO to be asserted as full at
	// some other times as well.
	always @(*)
	if (wgray == { ~wq2_rgray[AW:AW-1], wq2_rgray[AW-2:0] })
		`ASSERT(o_wfull);

	// The same basic principle applies to the reader as well.  From the
	// readers perspective, anytime the Gray pointers are equal the FIFO
	// is empty, and should be asserted as such.
	always @(*)
	if (rgray == rq2_wgray)
		`ASSERT(o_rempty);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;At this point, we now have full confidence in our two flags, &lt;code class=&quot;highlighter-rouge&quot;&gt;o_wfull&lt;/code&gt; and
&lt;code class=&quot;highlighter-rouge&quot;&gt;o_rempty&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;When I first
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formally verified&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/website/blob/master/examples/afifo.v&quot;&gt;this FIFO&lt;/a&gt;,
this was where I stopped.  Then I was told of &lt;a href=&quot;http://www.techdesignforums.com/practice/technique/doc-formal-harness-the-power-of-invariant-based-bug-hunting/&quot;&gt;additional FIFO
property&lt;/a&gt;,
which we’ll discuss in the next
section.&lt;/p&gt;

&lt;h2 id=&quot;fifo-contract&quot;&gt;FIFO Contract&lt;/h2&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 9. Two consecutive items written to a FIFO, must be able to be read out consecutively at a later time&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/afifo-two-items.svg&quot; alt=&quot;&quot; width=&quot;420&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;I’ve now been a part of and read several discussions about how to 
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formally verify&lt;/a&gt;
a FIFO–whether synchronous or asynchronous.  I’ve even found
&lt;a href=&quot;http://www.techdesignforums.com/practice/technique/doc-formal-harness-the-power-of-invariant-based-bug-hunting/&quot;&gt;one reference to this method&lt;/a&gt; as well,
although there must be more.
These discussions all revolve around two arbitrary values written to
&lt;a href=&quot;https://github.com/ZipCPU/website/blob/master/examples/afifo.v&quot;&gt;the FIFO&lt;/a&gt;
in succession, that then need to be able to be read out of the in succession.&lt;/p&gt;

&lt;p&gt;This was a new criteria for me when I first heard it, so I decided to try
it on one of my own FIFOs to see if it would work.  It didn’t pass
(originally)–I was overwriting the FIFO’s tail on any write request during
overrun.  Oops.  Hence, while I used to think this criteria wasn’t all that
necessary, I no longer hold that view.&lt;/p&gt;

&lt;p&gt;If you read 
&lt;a href=&quot;http://www.techdesignforums.com/practice/technique/doc-formal-harness-the-power-of-invariant-based-bug-hunting/&quot;&gt;Doc Formal’s article&lt;/a&gt;
on &lt;a href=&quot;/formal/2018/04/23/invariant.html&quot;&gt;invariants&lt;/a&gt;,
or the slides I saw at &lt;a href=&quot;https://dvcon.org-us-2018&quot;&gt;DVCON 2018&lt;/a&gt;,
they all made this proof look quite easy.  When I actually tried it myself,
I couldn’t figure out how to keep it as simple as the slides presented it.  In
particular, how can you constrain the formal engine in such a way that the
parts of the proof don’t get out of hand and into an inconsistent state?&lt;/p&gt;

&lt;p&gt;As a result, we’ll apply this criteria below in such a constrained way that
there’s no way the solver could get it wrong.  Specifically, if the solver
starts in the middle of the two element sequence described by this contract,
we’ll make certain below that the state the solver finds itself within matches
our own internal state in every way and in every step along the way.&lt;/p&gt;

&lt;p&gt;So let’s start out by picking an arbitrary location within
&lt;a href=&quot;https://github.com/ZipCPU/website/blob/master/examples/afifo.v&quot;&gt;the FIFO&lt;/a&gt;,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	(* anyconst *) wire [AW:0]		f_const_addr;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;and a location immediately following it.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	wire	[AW:0]		f_const_next_addr;

	assign	f_const_next_addr = f_const_addr + 1;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Let’s also pick two arbitrary values which will eventually will be placed in
those
locations.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	(* anyconst *) reg [DW-1:0]	f_const_first, f_const_next;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Let’s also create an expression that will be true anytime the first address,
&lt;code class=&quot;highlighter-rouge&quot;&gt;f_const_addr&lt;/code&gt;, is within the valid set of FIFO values.  This is tricky
because the read and write pointers will wrap around the end of the FIFO,
so we’ll have to break this out by stages.  Since it’s non-intuitive,
we’ll show this graphically as we go along.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	reg			f_addr_valid, f_next_valid;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Looking at the first address, &lt;code class=&quot;highlighter-rouge&quot;&gt;f_const_addr&lt;/code&gt;, if the read pointer follows
the write pointer in order, and &lt;code class=&quot;highlighter-rouge&quot;&gt;f_const_addr&lt;/code&gt; is between the two, then
&lt;code class=&quot;highlighter-rouge&quot;&gt;f_const_addr&lt;/code&gt; references an item within
&lt;a href=&quot;https://github.com/ZipCPU/website/blob/master/examples/afifo.v&quot;&gt;the FIFO&lt;/a&gt;.
This case is shown in Fig 10 below.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 10. The Arbitrary Address lies between the Read and Write Pointers&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/afifo-case-one.svg&quot; alt=&quot;&quot; width=&quot;540&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Given the picture above, the test should start to make sense.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(*)
	begin
		f_addr_valid = 1&#39;b0;
		if((wbin &amp;gt; rbin)&amp;amp;&amp;amp;(wbin &amp;gt; f_const_addr)
					&amp;amp;&amp;amp;(rbin &amp;lt;= f_const_addr))
			// Order rbin &amp;lt;= addr &amp;lt; wbin
			f_addr_valid = 1&#39;b1;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;In a similar fashion, if &lt;code class=&quot;highlighter-rouge&quot;&gt;wbin&lt;/code&gt; has wrapped around so that the write pointer
is now less than the read pointer, &lt;code class=&quot;highlighter-rouge&quot;&gt;rbin&lt;/code&gt;, but &lt;code class=&quot;highlighter-rouge&quot;&gt;f_const_addr&lt;/code&gt; remains less
than the write pointer, then &lt;code class=&quot;highlighter-rouge&quot;&gt;f_const_addr&lt;/code&gt; is within
&lt;a href=&quot;https://github.com/ZipCPU/website/blob/master/examples/afifo.v&quot;&gt;the FIFO&lt;/a&gt;.
This is shown in Fig 11 below.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 11. The Arbitrary Address lies between the Read and Write Pointers&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/afifo-case-two.svg&quot; alt=&quot;&quot; width=&quot;540&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;		else if ((wbin &amp;lt; rbin)&amp;amp;&amp;amp;(f_const_addr &amp;lt; wbin))
			// addr &amp;lt; wbin &amp;lt; rbin
			f_addr_valid = 1&#39;b1;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Finally, if the write pointer is less than the read pointer, but &lt;code class=&quot;highlighter-rouge&quot;&gt;f_const_addr&lt;/code&gt;
lies after the read pointer, then the address is in
&lt;a href=&quot;https://github.com/ZipCPU/website/blob/master/examples/afifo.v&quot;&gt;the FIFO&lt;/a&gt;.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 12. The Arbitrary Address lies between the Read and Write Pointers&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/afifo-case-three.svg&quot; alt=&quot;&quot; width=&quot;540&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;		else if ((wbin &amp;lt; rbin)&amp;amp;&amp;amp;(rbin &amp;lt;= f_const_addr))
			// wbin &amp;lt; rbin &amp;lt; addr
			f_addr_valid = 1&#39;b1;
	end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;I’ll skip the similar, though identical, comparison for the next address
following, &lt;code class=&quot;highlighter-rouge&quot;&gt;f_const_next_addr&lt;/code&gt;.  You can find it within &lt;a href=&quot;https://github.com/ZipCPU/website/blob/master/examples/afifo.v&quot;&gt;the verilog code for
the FIFO&lt;/a&gt;
if you like.&lt;/p&gt;

&lt;p&gt;The next step is to implement the logic shown in Fig 9 above.  With all the
associated details, this becomes rather complex, so let’s break it down a bit.
Specifically, we’ll create some logic to determine if the first, second, or
both values are in
&lt;a href=&quot;https://github.com/ZipCPU/website/blob/master/examples/afifo.v&quot;&gt;the FIFO&lt;/a&gt;.
That is, not only is their address a valid reference to an item within
&lt;a href=&quot;https://github.com/ZipCPU/website/blob/master/examples/afifo.v&quot;&gt;the FIFO&lt;/a&gt;,
but the data at that address must match as well.&lt;/p&gt;

&lt;p&gt;For the first value to be in
&lt;a href=&quot;https://github.com/ZipCPU/website/blob/master/examples/afifo.v&quot;&gt;the FIFO&lt;/a&gt;,
1) it’s address must lie within
&lt;a href=&quot;https://github.com/ZipCPU/website/blob/master/examples/afifo.v&quot;&gt;the FIFO&lt;/a&gt;,
and 2) the value at that address must match the first of our two values.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	wire	f_first_in_fifo, f_second_in_fifo, f_both_in_fifo;

	always @(*)
		f_first_in_fifo = (f_addr_valid)
				&amp;amp;&amp;amp;(mem[f_const_addr[AW-1:0]]==f_const_first);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The same logic applies to the second value within
&lt;a href=&quot;https://github.com/ZipCPU/website/blob/master/examples/afifo.v&quot;&gt;our FIFO&lt;/a&gt;,
only we’ll check against the next address, &lt;code class=&quot;highlighter-rouge&quot;&gt;f_const_next_addr&lt;/code&gt;, and the value
against &lt;code class=&quot;highlighter-rouge&quot;&gt;f_const_next&lt;/code&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(*)
		f_second_in_fifo = (f_next_valid)
				&amp;amp;&amp;amp;(mem[f_const_next_addr[AW-1:0]]==f_const_next);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Finally, we’ll set &lt;code class=&quot;highlighter-rouge&quot;&gt;f_both_in_fifo&lt;/code&gt; to only be true if both values are within
&lt;a href=&quot;https://github.com/ZipCPU/website/blob/master/examples/afifo.v&quot;&gt;the FIFO&lt;/a&gt;,
at their respective address locations.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(*)
		f_both_in_fifo = (f_first_in_fifo)&amp;amp;&amp;amp;(f_second_in_fifo);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Conceptually, this might look like Fig 13 below.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 13. Both addresses and data items lie within the FIFO&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/afifo-case-both.svg&quot; alt=&quot;&quot; width=&quot;540&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;At this point we want to assert that if both values are in
&lt;a href=&quot;https://github.com/ZipCPU/website/blob/master/examples/afifo.v&quot;&gt;the FIFO&lt;/a&gt;,
then we should at some point later in time be able to read them both out one
by one.&lt;/p&gt;

&lt;p&gt;If you read other articles on FIFOs, you’ll often see them simplified
using a concurrent assertion so that the logic reads something like:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	assert property (@(posedge i_clk)
		disable iff (i_rrst_n)
		f_both_in_fifo |-&amp;gt;
			f_wait_for_first_read [*0:$]
			##1 f_read_first
			##1 f_wait_for_second_read [*0:$]
			##1 f_read_second);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Decoding this, it means that if both values are in
&lt;a href=&quot;https://github.com/ZipCPU/website/blob/master/examples/afifo.v&quot;&gt;the FIFO&lt;/a&gt;,
then
&lt;a href=&quot;https://github.com/ZipCPU/website/blob/master/examples/afifo.v&quot;&gt;the FIFO&lt;/a&gt;
can remain in that state indefinitely, or alternatively a read request can
read the first value from
&lt;a href=&quot;https://github.com/ZipCPU/website/blob/master/examples/afifo.v&quot;&gt;the FIFO&lt;/a&gt;.
Then, &lt;a href=&quot;https://github.com/ZipCPU/website/blob/master/examples/afifo.v&quot;&gt;the FIFO&lt;/a&gt;
can wait with the second value in memory indefinitely
or (ultimately) it can be read out.&lt;/p&gt;

&lt;p&gt;The problem with this simplified notation is all the details.
Worse, in my case I wanted to be able to support an
&lt;a href=&quot;/blog/2018/03/10/induction-exercise.html&quot;&gt;induction&lt;/a&gt;
length shorter than the entire (potentially infinite) sequence length.  To make
certain the solver could handle this case, I wanted to make certain that every
state within the sequence was constrained unambiguously.  All registers
associated with each of the states
needed to be fully constrained so there was no room for the solver to
place the design into an invalid state.&lt;/p&gt;

&lt;p&gt;Again, feel free to use Fig 9 above as a reference in this discussion below.&lt;/p&gt;

&lt;p&gt;For example, waiting for the first read means that both values must be in
&lt;a href=&quot;https://github.com/ZipCPU/website/blob/master/examples/afifo.v&quot;&gt;the FIFO&lt;/a&gt;,
and that neither are being read at that time.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	wire	f_wait_for_first_read, f_read_first, f_read_second,
		f_wait_for_second_read;

	always @(*)
		f_wait_for_first_read = (f_both_in_fifo)
				&amp;amp;&amp;amp;((!i_rd)||(f_const_addr != rbin)||(o_rempty));&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Notice the &lt;code class=&quot;highlighter-rouge&quot;&gt;o_rempty&lt;/code&gt; flag.  I wasn’t expecting this one.  If both items are in
&lt;a href=&quot;https://github.com/ZipCPU/website/blob/master/examples/afifo.v&quot;&gt;the FIFO&lt;/a&gt;,
then &lt;code class=&quot;highlighter-rouge&quot;&gt;o_rempty&lt;/code&gt; should be zero already, right?  Not quite.  When I ran
&lt;a href=&quot;https://symbiyosys.readthedocs.io/en/latest&quot;&gt;SymbiYosys&lt;/a&gt;,
the produced trace reminded me that while &lt;code class=&quot;highlighter-rouge&quot;&gt;o_rempty&lt;/code&gt; will be raised any time
the design is empty, it may take a couple of clock cycles after the design
is no longer empty in order to be lowered.  Hence, if &lt;code class=&quot;highlighter-rouge&quot;&gt;i_rd&lt;/code&gt; is true but
&lt;code class=&quot;highlighter-rouge&quot;&gt;o_rempty&lt;/code&gt; is also true, then no read is taking place and we’ll need to keep
waiting for that first read.&lt;/p&gt;

&lt;p&gt;Reading the first value from
&lt;a href=&quot;https://github.com/ZipCPU/website/blob/master/examples/afifo.v&quot;&gt;the FIFO&lt;/a&gt;
means that there must be a read request,
&lt;a href=&quot;https://github.com/ZipCPU/website/blob/master/examples/afifo.v&quot;&gt;the FIFO&lt;/a&gt;
must not be empty (finally), and the read request must be of the first value.
Further, at the time of this read, both values must still be in
&lt;a href=&quot;https://github.com/ZipCPU/website/blob/master/examples/afifo.v&quot;&gt;the FIFO&lt;/a&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(*)
		f_read_first = (i_rd)&amp;amp;&amp;amp;(o_rdata == f_const_first)&amp;amp;&amp;amp;(!o_rempty)
			&amp;amp;&amp;amp;(rbin == f_const_addr)&amp;amp;&amp;amp;(f_both_in_fifo);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;We’ll then wait for our second read.  This may take between zero and an
infinite number of clock cycles.  While waiting, the second value must
be still in
&lt;a href=&quot;https://github.com/ZipCPU/website/blob/master/examples/afifo.v&quot;&gt;the FIFO&lt;/a&gt;,
the read pointer must point to the second of our two
addresses, and we can’t allow any reads from
&lt;a href=&quot;https://github.com/ZipCPU/website/blob/master/examples/afifo.v&quot;&gt;the FIFO&lt;/a&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(*)
		f_wait_for_second_read = (f_second_in_fifo)
				&amp;amp;&amp;amp;((!i_rd)||(o_rempty))
				&amp;amp;&amp;amp;(f_const_next_addr == rbin);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Finally, the last stage in our test is the one where the second value is read
from &lt;a href=&quot;https://github.com/ZipCPU/website/blob/master/examples/afifo.v&quot;&gt;the FIFO&lt;/a&gt;.
In this case, there must be a read request, the read data
must match the data we started with,
&lt;a href=&quot;https://github.com/ZipCPU/website/blob/master/examples/afifo.v&quot;&gt;the FIFO&lt;/a&gt;
cannot be empty, the address must match, etc.  It’s a mouthful!&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(*)
		f_read_second = (i_rd)&amp;amp;&amp;amp;(o_rdata == f_const_next)&amp;amp;&amp;amp;(!o_rempty)
				&amp;amp;&amp;amp;(rbin == f_const_next_addr)
				&amp;amp;&amp;amp;(f_second_in_fifo);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;You may have noticed that I’ve just assigned values to variables.  These
values describe the various states the FIFO may be in, but they don’t (yet)
string those states together via an assertion of any type.  That’s coming
next.&lt;/p&gt;

&lt;p&gt;If you ever find yourself needing to do this, let me share with you what not
to do.  Do not place all of these criteria into one big huge property like
the one shown below.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	assert property (@(posedge i_clk)
		(f_first_in_fifo)&amp;amp;&amp;amp;(f_second_in_fifo);
		|-&amp;gt; (f_first_in_fifo)&amp;amp;&amp;amp;(f_second_in_fifo)
			&amp;amp;&amp;amp;((!i_rd)||(f_const_addr != rbin)||(o_rempty)) [*0:$]
		##1 (i_rd)&amp;amp;&amp;amp;(o_rdata == f_const_first)&amp;amp;&amp;amp;(!o_rempty)
			&amp;amp;&amp;amp;(rbin == f_const_addr)
			&amp;amp;&amp;amp;(f_first_in_fifo)&amp;amp;&amp;amp;(f_second_in_fifo);
		##1 (f_second_in_fifo)
				&amp;amp;&amp;amp;((!i_rd)||(o_rempty))
				&amp;amp;&amp;amp;(f_const_next_addr == rbin) [*0:$]
		##1 (i_rd)&amp;amp;&amp;amp;(o_rdata == f_const_next)&amp;amp;&amp;amp;(!o_rempty)
				&amp;amp;&amp;amp;(rbin == f_const_next_addr)
				&amp;amp;&amp;amp;(f_second_in_fifo));&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;(My initial attempt was even worse–I didn’t use &lt;code class=&quot;highlighter-rouge&quot;&gt;f_first_in_fifo&lt;/code&gt; or
&lt;code class=&quot;highlighter-rouge&quot;&gt;f_sceond_in_fifo&lt;/code&gt;.)&lt;/p&gt;

&lt;p&gt;The problem with such a complicated property is, what happens when it fails?
In my case, &lt;a href=&quot;https://symbiyosys.readthedocs.io/en/latest&quot;&gt;SymbiYosys&lt;/a&gt;
would say that the assertion failed, and then
give me the line of this assertion and a trace showing me that the assertion
had failed.  It never said which part of the assertion, which line within the
assertion, or which step the assertion was within, was the one that failed.
The line number was always the line number of the whole assertion sequence.&lt;/p&gt;

&lt;p&gt;You can guess how I solved this problem using the state definitions we just
defined above.  By creating wires to contain these complicated logic
components, these logic components describing which state we are in then
show up on the trace.  This made it possible for me to understand the trace,
and thus to see what was going wrong.&lt;/p&gt;

&lt;p&gt;On the other hand, if you are using the open source version of
&lt;a href=&quot;https://symbiyosys.readthedocs.io/en/latest&quot;&gt;SymbiYosys&lt;/a&gt;,
then you’ll have to describe this check using immediate assertions alone.
Again, the wires defining the various states above will help us simplify the
state machine we’ll need to write.&lt;/p&gt;

&lt;p&gt;Starting at the top, we’ll create a quick state transition checker that will
be disabled any time &lt;code class=&quot;highlighter-rouge&quot;&gt;i_wrst_n&lt;/code&gt; gets asserted.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @($global_clock)
	if ((f_past_valid_gbl)&amp;amp;&amp;amp;(i_wrst_n))
	begin&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The state starts with both items in
&lt;a href=&quot;https://github.com/ZipCPU/website/blob/master/examples/afifo.v&quot;&gt;the FIFO&lt;/a&gt;,
or equivalently with &lt;code class=&quot;highlighter-rouge&quot;&gt;f_both_in_fifo&lt;/code&gt; true.  Following &lt;code class=&quot;highlighter-rouge&quot;&gt;f_both_in_fifo&lt;/code&gt;, we
can either read the first value or continue waiting for the
first value to be read.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;		if ((!$past(f_read_first))&amp;amp;&amp;amp;(($past(f_both_in_fifo))))
			assert((f_wait_for_first_read)
				|| (($rose(i_rclk))&amp;amp;&amp;amp;(f_read_first)));&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Let me point you attention to the &lt;code class=&quot;highlighter-rouge&quot;&gt;$rose(i_rclk)&lt;/code&gt; condition for a moment.  The
first value cannot be read without a read that starts on the rising read
clock edge.&lt;/p&gt;

&lt;p&gt;Once we’ve read that first value, we’ll need to stay in that state until the
next clock edge.  On the next read clock edge, we can either read the second
value, or start waiting for the second value to be read.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;		if ($past(f_read_first))
			assert(
				((!$rose(i_rclk))&amp;amp;&amp;amp;(f_read_first))
				||($rose(i_rclk)&amp;amp;&amp;amp;((f_read_second)
						||(f_wait_for_second_read))));&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Finally, if we were waiting for the second value to be read on the last time
step, then we can continue waiting on this time step, or if the clock rises
we can actually start reading the second value.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;		if ($past(f_wait_for_second_read))
			assert((f_wait_for_second_read)
				||(($rose(i_rclk))&amp;amp;&amp;amp;(f_read_second)));
	end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;There you have it!  That’s the majority of this proof.&lt;/p&gt;

&lt;p&gt;In hindsight, I probably didn’t need all of those free variables,
those using &lt;code class=&quot;highlighter-rouge&quot;&gt;(* anyconst *)&lt;/code&gt;, to make this work.  If I have to come back to
this later, I may remove them–instead reflecting that any input value is
by default a free variable of its own right.&lt;/p&gt;

&lt;h2 id=&quot;cover-properties&quot;&gt;Cover Properties&lt;/h2&gt;

&lt;p&gt;We’re not quite done yet.  We’d still
like to know about whether or not some things that might actually take place.
This was the fourth part in our proof outline above.  So far, we’ve skipped
it.  We’ve proved parts one through five except for part four.  Part four
requires us to demonstrate that
&lt;a href=&quot;https://github.com/ZipCPU/website/blob/master/examples/afifo.v&quot;&gt;the FIFO&lt;/a&gt;
can actually fill, and that it can actually empty.&lt;/p&gt;

&lt;p&gt;Why might we need this?  Consider, what
would happen if we had somehow accidentally assumed
&lt;a href=&quot;https://github.com/ZipCPU/website/blob/master/examples/afifo.v&quot;&gt;the FIFO&lt;/a&gt;
would remain empty, or that it would never reach it’s fill?  Just to make
certain we didn’t mess things up, let’s make sure several states are reachable.&lt;/p&gt;

&lt;p&gt;First, let’s make sure we can enter the empty state.  This is good since
we start up in the empty state.  In order to return to empty, the FIFO must
be able to both receive a value into it and to have a value read out of it.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @($global_clock)
	if (f_past_valid_gbl)
		cover((o_rempty)&amp;amp;&amp;amp;(!$past(o_rempty)));&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The same basic logic applies to the full state.  The design starts out
non-full, and we’d like to have some assurance that
&lt;a href=&quot;https://github.com/ZipCPU/website/blob/master/examples/afifo.v&quot;&gt;the FIFO&lt;/a&gt;
can be filled, and also that it can leave its full condition.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(posedge i_wclk)
	if (f_past_valid_wr)
		cover($past(o_wfull)&amp;amp;&amp;amp;(!o_wfull));&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;If you check out
&lt;a href=&quot;https://github.com/ZipCPU/website/blob/master/examples/afifo.v&quot;&gt;the design&lt;/a&gt;,
you’ll find there are several other cover properties as well.  Feel free
to examine and comment on whether I may have missed any.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;`endif
endmodule&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h2 id=&quot;conclusions&quot;&gt;Conclusions&lt;/h2&gt;

&lt;p&gt;Voila!  All of what you need to know to
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formally verify&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/website/blob/master/examples/afifo.v&quot;&gt;an asynchronous
FIFO&lt;/a&gt;.
Yes, it took a lot of work, but the good thing is that this work
only needed to be done once.  Now you can use
&lt;a href=&quot;https://github.com/ZipCPU/website/blob/master/examples/afifo.v&quot;&gt;this FIFO&lt;/a&gt;
to &lt;a href=&quot;/blog/2017/10/20/cdc.html&quot;&gt;cross clock domains&lt;/a&gt;
with all kinds of things like … bus requests even!&lt;/p&gt;

&lt;p&gt;Still not convinced?  Feel free to examine &lt;a href=&quot;https://github.com/ZipCPU/website/blob/master/examples/afifo.v&quot;&gt;the code and the
properties&lt;/a&gt;
yourself.  You can even add your own properties, in case I’ve missed
any–whatever it takes to convince you that this
&lt;a href=&quot;https://github.com/ZipCPU/website/blob/master/examples/afifo.v&quot;&gt;FIFO&lt;/a&gt;
actually works.&lt;/p&gt;

&lt;p&gt;Now, what shall we use this for?&lt;/p&gt;

&lt;p&gt;Perhaps we could use this to cross clock domains using a bus?  For example,
what if you had two &lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;wishbone
buses&lt;/a&gt;, one in each of two
&lt;a href=&quot;/blog/2017/10/20/cdc.html&quot;&gt;clock domains&lt;/a&gt;.
&lt;a href=&quot;/blog/2017/10/20/cdc.html&quot;&gt;Crossing
clock domains&lt;/a&gt;
with between those &lt;a href=&quot;/blog/2017/11/07/wb-formal.html&quot;&gt;buses&lt;/a&gt;
can be a challenge.  Not only that, but it’s a particularly challenge required
by just about any &lt;a href=&quot;https://github.com/ZipCPU/vgasim&quot;&gt;video system&lt;/a&gt;.  Why?
Well, it just so happens that in every video design I’ve ever done (there
haven’t been that many), the pixel clock ends up being at one frequency
and the memory (and system) clock is at another.  Hence, I’d like to come
back to &lt;a href=&quot;https://github.com/ZipCPU/website/blob/master/examples/afifo.v&quot;&gt;this FIFO
design&lt;/a&gt;
later and modify it so that it produces an output fill level for a
&lt;a href=&quot;https://github.com/ZipCPU/vgasim/blob/master/rtl/imgfifo.v&quot;&gt;frame buffer&lt;/a&gt;
controller.
Such a controller will wait until there is room for another burst length
in the buffer before trying to fill the buffer with a burst.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 14. Asynchronous FIFO within a Video Application&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/afifo-video.svg&quot; alt=&quot;&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Indeed, that’s part of the
&lt;a href=&quot;https://github.com/ZipCPU/vgasim&quot;&gt;VGA simulator&lt;/a&gt;
I recently posted on line.
&lt;a href=&quot;https://github.com/ZipCPU/vgasim&quot;&gt;That project&lt;/a&gt;
includes simulation code for both a
&lt;a href=&quot;https://github.com/ZipCPU/vgasim/blob/master/bench/cpp/vgasource.cpp&quot;&gt;source&lt;/a&gt;
and a &lt;a href=&quot;https://github.com/ZipCPU/vgasim/blob/master/bench/cpp/vgasim.cpp&quot;&gt;sink video
signal&lt;/a&gt;,
taking the source from a location on the screen of the simulator’s host, and
then displaying the result in a window on that same screen as well.  Of course,
there’s still plenty of room for improvement in the project.  In particular,
I have need of an HDMI simulation–something that would be an easy adjustment
to make to the &lt;a href=&quot;https://github.com/ZipCPU/vgasim&quot;&gt;VGA simulation&lt;/a&gt;
project.&lt;/p&gt;

&lt;p&gt;Perhaps we should come back to that project in a future article, and show how
you can use it?&lt;/p&gt;

&lt;p&gt;For now, let me thank Cliff Cummings for his &lt;a href=&quot;http://www.sunburst-design.com/papers/CummingsSNUG2002SJ_FIFO1.pdf&quot;&gt;excellent article on how to build
an asynchronous
FIFO&lt;/a&gt;,
and further for his encouragement to write this article!&lt;/p&gt;

&lt;hr /&gt;&lt;p&gt;&lt;em&gt;But, beloved, be not ignorant of this one thing, that one day is with the Lord as a thousand years, and a thousand years as one day. (2 Pet 3:8)&lt;/em&gt;</description>
        <pubDate>Fri, 06 Jul 2018 00:00:00 -0400</pubDate>
        <link>https://zipcpu.com/blog/2018/07/06/afifo.html</link>
        <guid isPermaLink="true">https://zipcpu.com/blog/2018/07/06/afifo.html</guid>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>Formally Verifying Asynchronous Components</title>
        <description>&lt;p&gt;To date, our formal verification efforts have primarily centered around
&lt;em&gt;synchronous&lt;/em&gt; designs using
&lt;a href=&quot;https://www.clifford.at/yosys&quot;&gt;yosys&lt;/a&gt;,
that is those designs where all logic transitions on the same clock edge,
rather than looking at
&lt;em&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Asynchronous_circuit&quot;&gt;asynchronous&lt;/a&gt;&lt;/em&gt;
designs.
The one exception so far has been the description of how to get an
&lt;a href=&quot;/formal/2018/04/12/areset.html&quot;&gt;asynchronous reset&lt;/a&gt;
to pass induction.  I’d like to move beyond this simple example towards
verifying a full &lt;a href=&quot;http://www.sunburst-design.com/papers/CummingsSNUG2002SJ_FIFO1.pdf&quot;&gt;asynchronous FIFO
design&lt;/a&gt;,
but that’s going to require a bit more background in how to
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formally verify&lt;/a&gt; an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Asynchronous_circuit&quot;&gt;asynchronous&lt;/a&gt;
design in general.  Today, therefore, let’s examine how to
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formally verify&lt;/a&gt; an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Asynchronous_circuit&quot;&gt;asynchronous&lt;/a&gt;
component that
&lt;a href=&quot;/blog/2017/10/20/cdc.html&quot;&gt;crosses between clock domains&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;If you aren’t familiar with
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal verification&lt;/a&gt;,
you might wish to go back and review our
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;introductory article&lt;/a&gt;
on the topic.  You might also find the
&lt;a href=&quot;/blog/2018/03/10/induction-exercise.html&quot;&gt;induction exercise&lt;/a&gt;
to be valuable as well.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 1. A Clock Switch Component&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/ckswitch-blkdiag.svg&quot; alt=&quot;&quot; width=&quot;360&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Today, let’s demonstrate how these same
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal verification&lt;/a&gt;
concepts apply an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Asynchronous_circuit&quot;&gt;asynchronous&lt;/a&gt;
design with two clocks within it.  In this
case, we’ll examine a clock switch.  Such a switch takes two clock inputs
and one line to select between them.  In our case, the two separate clocks
makes a perfect example of how
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal methods&lt;/a&gt;
can be applied to an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Asynchronous_circuit&quot;&gt;asynchronous&lt;/a&gt;
design.&lt;/p&gt;

&lt;h1 id=&quot;two-clocks&quot;&gt;Two Clocks&lt;/h1&gt;

&lt;p&gt;The first and most important step is to somehow describe both clocks via
formal properties to the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Satisfiability_modulo_theories&quot;&gt;SMT solver&lt;/a&gt;.
This step is really independent
of anything you might wish to verify, and it applies to any
&lt;a href=&quot;https://en.wikipedia.org/wiki/Asynchronous_circuit&quot;&gt;asynchronous&lt;/a&gt;
design.  Once you learn the simple trick involved, you’ll then notice that
other &lt;a href=&quot;https://en.wikipedia.org/wiki/Asynchronous_circuit&quot;&gt;asynchronous&lt;/a&gt;
verification proofs follow the exact same approach.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: left&quot;&gt;&lt;caption&gt;Fig 2. The Master rule of Formal Verification&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/fv-master-rule.svg&quot; alt=&quot;&quot; width=&quot;240&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;Specifically, we need to provide some assumptions to describe the two clocks
which will be the inputs to our clock switch design.  Why assumptions?
Because these clocks will be inputs, and the basic rule is that you should
always make assumptions about your inputs, and assertions about your local
state and any outputs.&lt;/p&gt;

&lt;p&gt;Perhaps you may remember our earlier discussion of how to create a &lt;a href=&quot;/blog/2017/06/02/generating-timing.html&quot;&gt;fractional
clock divider&lt;/a&gt;?
In &lt;a href=&quot;/blog/2017/06/02/generating-timing.html&quot;&gt;that article&lt;/a&gt;,
we used the top bit of a counter as a divided clock.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(posedge i_clk)
		counter &amp;lt;= counter + increment;

	assign divided_clock = counter[MSB];&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Clocks like this one that are generated from logic are often called
&lt;em&gt;logic&lt;/em&gt; &lt;em&gt;clocks&lt;/em&gt;.  Logic clocks are distinguished from regular clocks in that
are generated from logic within the design, rather than external hardware or
internal
&lt;a href=&quot;https://en.wikipedia.org/wiki/Phase-locked_loop&quot;&gt;PLL&lt;/a&gt;s,
and are then distributed across the design and used
like a clock.  In general, you don’t want to transition on the positive or
negative edge of any logic clock.  Doing so will make it
harder to achieve timing closure, and it will add additional
&lt;a href=&quot;/blog/2017/10/20/cdc.html&quot;&gt;clock domain crossing&lt;/a&gt;
requirements to your design.
Further, if this divided clock isn’t placed on the clock network, then
it might be seen to rise (or fall) at inconsistent times across the design.&lt;/p&gt;

&lt;p&gt;All of these are “bad” hardware consequences.&lt;/p&gt;

&lt;p&gt;None of these problems, however, will keep us from using the transitions of
this divided clock as a &lt;em&gt;&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal
constraint&lt;/a&gt;&lt;/em&gt;
on our clock input, so that’s exactly what we are about to do.&lt;/p&gt;

&lt;p&gt;We’ll start out by creating counters, &lt;code class=&quot;highlighter-rouge&quot;&gt;f_*_count&lt;/code&gt;, and increments,
&lt;code class=&quot;highlighter-rouge&quot;&gt;f_*_step&lt;/code&gt;, for each input clock.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	wire	[F_CKSTEP-1:0]	f_a_step,  f_b_step;
	reg	[F_CKSTEP-1:0]	f_a_count, f_b_count;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;In order to handle properties associated with any particular speed, we’ll allow
these increments to be completely arbitrary.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	assign	f_a_step = $anyconst;
	assign	f_b_step = $anyconst;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The &lt;code class=&quot;highlighter-rouge&quot;&gt;$anyconst&lt;/code&gt; description is specific to
&lt;a href=&quot;https://www.clifford.at/yosys&quot;&gt;yosys&lt;/a&gt;.
It means that these values will have a constant value given to
them–any value.  It’s roughly the same as having an extra unconstrained
input to the design and then forcing it to be &lt;code class=&quot;highlighter-rouge&quot;&gt;$stable&lt;/code&gt;.  Alternatively,
you can think of it as a register with no initial statement that doesn’t
produce a
&lt;a href=&quot;https://www.clifford.at/yosys&quot;&gt;yosys&lt;/a&gt;
warning on synthesis.&lt;/p&gt;

&lt;p&gt;However, these arbitrary constant values aren’t quite what we want yet.
For example, any increment having a zero value would indicate a clock
that doesn’t tick. 
This is bad, so we’ll force the increments to be greater than zero.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(*)
		assume(f_a_step &amp;gt; 0);

	always @(*)
		assume(f_b_step &amp;gt; 0);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;In a similar fashion, we can also constrain the clocks so that the fastest
one, whichever that one might be, takes four simulation time steps per cycle.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(*)
		assume((f_a_step[F_CKSTEP-1:F_CKSTEP-2] == 2&#39;b01)
			||(f_b_step[F_CKSTEP-1:F_CKSTEP-2] == 2&#39;b01));&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This will help make certain that there is always a positive edge to the clock
at least once per cycle.&lt;/p&gt;

&lt;p&gt;Now that we have an increment, we just add this increment to our counters on
every formal step–one counter per incoming clock.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @($global_clock)
	begin
		f_a_count &amp;lt;= f_a_count + f_a_step;
		f_b_count &amp;lt;= f_b_count + f_b_step;
	end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Let me draw your attention to the &lt;code class=&quot;highlighter-rouge&quot;&gt;$global_clock&lt;/code&gt; statement within the always
header.  In
&lt;a href=&quot;https://en.wikipedia.org/wiki/SystemVerilog&quot;&gt;SystemVerilog&lt;/a&gt;,
this value needs to be declared earlier in the file
as a positive or negative edge trigger based upon some pre-existing clock.
&lt;a href=&quot;https://www.clifford.at/yosys&quot;&gt;Yosys&lt;/a&gt;,
however, extends this behavior by making &lt;code class=&quot;highlighter-rouge&quot;&gt;$global_clock&lt;/code&gt; the
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal verification&lt;/a&gt;
time step.  Every time step is now examined by the formal engine,
not just those times described by an edge of a clock but intermediate times
as well.  It’s for this reason that we can use &lt;code class=&quot;highlighter-rouge&quot;&gt;$global_clock&lt;/code&gt; in this
circumstance.  Indeed, &lt;code class=&quot;highlighter-rouge&quot;&gt;$global_clock&lt;/code&gt; is one of the keys to this whole
operation.&lt;/p&gt;

&lt;p&gt;Our last formal property will be to assume that our incoming clock signals
are identical to the most significant bits of our counters.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(*)
		assume(i_clk_a = f_a_count[F_CKSTEP-1]);

	always @(*)
		assume(i_clk_b = f_b_count[F_CKSTEP-1]);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Simple enough?  We’ve just assumed the presence of two dissimilar clocks
coming into our design.  We’ve also allowed them to have arbitrary phases
and frequencies with respect to each other.&lt;/p&gt;

&lt;p&gt;There is one more required piece of
&lt;a href=&quot;https://www.clifford.at/yosys&quot;&gt;yosys&lt;/a&gt;,
magic, you’ll need to add &lt;code class=&quot;highlighter-rouge&quot;&gt;clk2fflogic&lt;/code&gt; to your
&lt;a href=&quot;https://www.clifford.at/yosys&quot;&gt;yosys&lt;/a&gt;
script file.  Alternatively, if you are using
&lt;a href=&quot;https://symbiyosys.readthedocs.io/en/latest&quot;&gt;SymbiYosys&lt;/a&gt;,
you can instead add &lt;code class=&quot;highlighter-rouge&quot;&gt;multiclock on&lt;/code&gt; to the options section.  You can
see an example of this
&lt;a href=&quot;https://symbiyosys.readthedocs.io/en/latest&quot;&gt;SymbiYosys&lt;/a&gt; &lt;a href=&quot;https://github.com/ZipCPU/website/blob/master/examples/clkswitch.sby&quot;&gt;script
here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;No more setup work is required–we’ve just formally assumed the existence of
two separate and dissimilar clock inputs.  In the next section, we’ll examine a
&lt;a href=&quot;https://github.com/ZipCPU/website/blob/master/examples/clkswitch.v&quot;&gt;clock switch
design&lt;/a&gt;
and discuss how we might
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formally verify&lt;/a&gt;
that it is glitch free.&lt;/p&gt;

&lt;h1 id=&quot;a-clock-switch&quot;&gt;A Clock Switch&lt;/h1&gt;

&lt;p&gt;At this point in our article, I usually present a working design that would
use the principle under discussion and
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal verify&lt;/a&gt; it.
Sadly, I only have a couple of
&lt;a href=&quot;https://en.wikipedia.org/wiki/Asynchronous_circuit&quot;&gt;asynchronous&lt;/a&gt;
designs to share.  I just haven’t had the need to build
that many.  That said, neither my formal proof of
&lt;a href=&quot;http://www.sunburst-design.com/papers/CummingsSNUG2002SJ_FIFO1.pdf&quot;&gt;Cliff Cumming’s asynchronous
FIFO&lt;/a&gt;
design, nor the &lt;a href=&quot;https://github.com/ZipCPU/wbuart32/blob/dev/rtl/rxuartlite.v&quot;&gt;proof of my
UART receiver&lt;/a&gt;
would be appropriate for a beginning blog post on
&lt;a href=&quot;https://en.wikipedia.org/wiki/Asynchronous_circuit&quot;&gt;asynchronous&lt;/a&gt;
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal verification&lt;/a&gt;
despite the fact that both proofs use the techniques discussed here.&lt;/p&gt;

&lt;p&gt;So let’s try something simpler.  Let’s instead examine a &lt;a href=&quot;https://github.com/ZipCPU/website/blob/master/examples/clkswitch.v&quot;&gt;clock
switch&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;A &lt;a href=&quot;https://github.com/ZipCPU/website/blob/master/examples/clkswitch.v&quot;&gt;clock
switch&lt;/a&gt;
is a design component that takes two clock inputs and a switch
input, and produces one of the two clocks as its output dependent upon how
the switch is set.
It’s not something an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
designer normally needs to build, since most
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
vendor libraries provide similar components which will be known
to work on their parts.  As an example, Xilinx offers a 
&lt;a href=&quot;https://www.xilinx.com/support/documentation/user_guides/ug472_7Series_Clocking.pdf&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;BUFGMUX&lt;/code&gt; design element&lt;/a&gt;
with similar capabilities.  However, for today’s purpose, 
a &lt;a href=&quot;https://github.com/ZipCPU/website/blob/master/examples/clkswitch.v&quot;&gt;clock
switch&lt;/a&gt;
design makes a perfect example of an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Asynchronous_circuit&quot;&gt;asynchronous&lt;/a&gt;
design which can be
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formally verified&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/ZipCPU/website/blob/master/examples/clkswitch.v&quot;&gt;Clock
switches&lt;/a&gt;
are very important parts of a failsafe designs.  A failsafe
design can start with one clock and then switch to the second clock once it
stabilizes.  In a similar fashion, if the second clock becomes unstable or
otherwise unusable, then the
&lt;a href=&quot;https://github.com/ZipCPU/website/blob/master/examples/clkswitch.v&quot;&gt;clock
switch&lt;/a&gt;
should return the design to the original clock.  A third use for a &lt;a href=&quot;https://github.com/ZipCPU/website/blob/master/examples/clkswitch.v&quot;&gt;clock
switch&lt;/a&gt;
would be in a
power sensitive design.  In such a power sensitive design, the clock
might be switched between a fast and a slow clock in order to control how
much power the design is using at any given time.&lt;/p&gt;

&lt;p&gt;So, how would you build a
&lt;a href=&quot;https://github.com/ZipCPU/website/blob/master/examples/clkswitch.v&quot;&gt;clock
switch&lt;/a&gt;?&lt;/p&gt;

&lt;p&gt;A straight forward &lt;a href=&quot;https://github.com/ZipCPU/website/blob/master/examples/clkswitch.v&quot;&gt;clock
switch&lt;/a&gt;
design might look like,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(*)
	if (i_sel)
		o_clk = i_clk_a;
	else
		o_clk = i_clk_b;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Sadly, this doesn’t work.  The problem is that the switch input &lt;code class=&quot;highlighter-rouge&quot;&gt;i_sel&lt;/code&gt;
is &lt;a href=&quot;https://en.wikipedia.org/wiki/Asynchronous_circuit&quot;&gt;asynchronous&lt;/a&gt;
to at least one of the two clock domains if not both.
The output clock period might therefore be something other than the
period of either clock if &lt;code class=&quot;highlighter-rouge&quot;&gt;i_sel&lt;/code&gt; changes mid clock.  Worse, the period
could easily be shorter then the minimum pulse width of this design.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 3. A Clock switching circuit&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/clock-switch.svg&quot; alt=&quot;&quot; width=&quot;560&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;A little googling turns up
&lt;a href=&quot;https://www.eetimes.com/document.asp?doc_id=1202359&quot;&gt;a fascinating article&lt;/a&gt;
on &lt;a href=&quot;https://www.eetimes.com&quot;&gt;EE Times&lt;/a&gt; discussing, “&lt;a href=&quot;https://www.eetimes.com/document.asp?doc_id=1202359&quot;&gt;Techniques to make clock
switching glitch free&lt;/a&gt;.”
In &lt;a href=&quot;https://www.eetimes.com/document.asp?doc_id=1202359&quot;&gt;the article&lt;/a&gt;,
Mahmud provides just the logic we need.&lt;/p&gt;

&lt;p&gt;According to
&lt;a href=&quot;https://www.eetimes.com/document.asp?doc_id=1202359&quot;&gt;the article&lt;/a&gt;,
the key piece we are missing is a pair of
&lt;a href=&quot;/blog/2017/10/20/cdc.html&quot;&gt;synchronizers&lt;/a&gt;.
Since the clock select input isn’t guaranteed to be synchronous to
either clock, it must be &lt;a href=&quot;/blog/2017/10/20/cdc.html&quot;&gt;synchronized into each
clock’s domain&lt;/a&gt;.  Once the
clock select line has been split and synchronized into each respective
clock domain, the output clock can then be synthesized by &lt;code class=&quot;highlighter-rouge&quot;&gt;and&lt;/code&gt;ing each
leg of the clock domain with its respective enable, and &lt;code class=&quot;highlighter-rouge&quot;&gt;or&lt;/code&gt;ing the
result together.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;assign	o_clk = ((a_sel)&amp;amp;&amp;amp;(i_clk_a))
		||((b_sel)&amp;amp;&amp;amp;(i_clk_b));&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This sounds simple enough.  Indeed, the article and the picture are so clear
that writing out the design is quite straightforward.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;module clkswitch(i_clk_a, i_clk_b, i_areset_n, i_sel, o_clk);
	input	wire	i_clk_a, i_clk_b;
	input	wire	i_areset_n;
	input	wire	i_sel;
	output	wire	o_clk;

	reg		aff, bff, a_sel, b_sel;

	// First half of the synchronizer for A
	//
	// Set aff on the positive edge of clock A
	initial aff = 0;
	always @(posedge i_clk_a, negedge i_areset_n)
	if (!i_areset_n)
		aff = 1;
	else
		aff &amp;lt;= (i_sel)&amp;amp;&amp;amp;(!b_sel);

	// Second half of the synchronizer for A
	//
	// Set a_sel based upon the negative edge of clock A
	//
	initial a_sel = 0;
	always @(negedge i_clk_a, negedge i_areset_n)
	if (!i_areset_n)
		a_sel = 1;
	else
		a_sel &amp;lt;= aff;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Notice that this synchronizer uses both edges of the clock to synchronize
on.  This would be a bad idea in an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;,
since you have no control over how far apart the design elements are.
However, this isn’t quite the same problem on an
&lt;a href=&quot;/blog/2017/10/13/fpga-v-asic.html&quot;&gt;ASIC&lt;/a&gt;,
as this design could be delivered as an internally
routed black box.&lt;/p&gt;

&lt;p&gt;The logic for B’s side is identical, save that it is based
upon the negation of our select signal.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	initial bff = 0;
	always @(posedge i_clk_b, negedge i_areset_n)
	if (!i_areset_n)
		bff &amp;lt;= 0;
	else
		bff &amp;lt;= (!i_sel)&amp;amp;&amp;amp;(!a_sel);

	initial b_sel = 0;
	always @(negedge i_clk_b, negedge i_areset_n)
	if (!i_areset_n)
		b_sel &amp;lt;= 0;
	else
		b_sel &amp;lt;= bff;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;As the final step, the output clock is determined by clock &lt;code class=&quot;highlighter-rouge&quot;&gt;A&lt;/code&gt; if
&lt;code class=&quot;highlighter-rouge&quot;&gt;a_sel&lt;/code&gt; is ever true, and by clock &lt;code class=&quot;highlighter-rouge&quot;&gt;B&lt;/code&gt; if &lt;code class=&quot;highlighter-rouge&quot;&gt;b_sel&lt;/code&gt; is true.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	assign	o_clk = ((a_sel)&amp;amp;&amp;amp;(i_clk_a))
			||((b_sel)&amp;amp;&amp;amp;(i_clk_b));
endmodule&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This design would be bad practice within an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;.
Besides transitioning on both positive and negative edges of a
clock, we are also sourcing a clock from combinational logic.
Both of these are big no-no’s in any
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;.
design.  If you want a &lt;a href=&quot;https://github.com/ZipCPU/website/blob/master/examples/clkswitch.v&quot;&gt;clock
switch&lt;/a&gt;
within your
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;.
design logic, use the vendor supplied black box that implements
something approximating (or better than) the above logic.&lt;/p&gt;

&lt;p&gt;Shall we see if we can
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formally verify&lt;/a&gt;
whether this circuit truly works?&lt;/p&gt;

&lt;h1 id=&quot;formally-verifying-the-clock-switch&quot;&gt;Formally Verifying the clock switch&lt;/h1&gt;

&lt;p&gt;Our first
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal verification&lt;/a&gt;
step is to determine what the “contract” is that
this design needs to meet.  Specifically, we want to make certain that&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;The outgoing clock should only transition when one of the incoming clocks
transitions.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The output clock’s high or low pulse width is no less than the width of the
fastest clock&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;We can switch from one clock to another&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Let’s work through these one by one.  The first criteria is easy: if neither
input clock rises, then we’ll assert that the output doesn’t rise either.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @($global_clock)
	if ((f_past_valid)&amp;amp;&amp;amp;(i_areset_n)&amp;amp;&amp;amp;(!$rose(i_clk_a))&amp;amp;&amp;amp;(!$rose(i_clk_b)))
		assert(!$rose(o_clk));&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Notice how I needed to add an exception for the
&lt;a href=&quot;/formal/2018/04/12/areset.html&quot;&gt;asynchronous reset&lt;/a&gt;.  Hence
this property will only hold as long as the reset line remains inactive (high).&lt;/p&gt;

&lt;p&gt;Likewise, if neither input falls, then the output shouldn’t fall either.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @($global_clock)
	if ((f_past_valid)&amp;amp;&amp;amp;(i_areset_n)&amp;amp;&amp;amp;(!$fell(i_clk_a))&amp;amp;&amp;amp;(!$fell(i_clk_b)))
		assert(!$fell(o_clk));&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;If you don’t recognize the &lt;code class=&quot;highlighter-rouge&quot;&gt;f_past_valid&lt;/code&gt; signal, we’ve discussed it many
times on this blog.  It is necessitated by the fact that on the initial time
step, &lt;code class=&quot;highlighter-rouge&quot;&gt;$rose()&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;$fell()&lt;/code&gt;, and &lt;code class=&quot;highlighter-rouge&quot;&gt;$past()&lt;/code&gt; are not well defined.  Instead,
we set the &lt;code class=&quot;highlighter-rouge&quot;&gt;f_past_valid&lt;/code&gt; just after that initial time step, and then start
checking on every step thereafter.&lt;/p&gt;

&lt;p&gt;The second criteria is a little harder to describe.  Indeed, our design choice
to use a fractional clock makes this more difficult.  Because we are
looking at the most significant bit of a counter, it’s not immediately
apparent how long each clock should be high.  Without a divide operator
to tell us how long we’d expect each clock leg to be high or low
we’re sort of stuck.&lt;/p&gt;

&lt;p&gt;We could switch from the &lt;a href=&quot;/blog/2017/06/02/generating-timing.html&quot;&gt;fractional
clock division&lt;/a&gt;
description above to an integer divide:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @($global_clock)
	if (f_a_count != 0)
		f_a_count &amp;lt;= f_a_count - 1&#39;b1;
	else
		f_a_count &amp;lt;= f_a_idiv-1;

	always @($global_clock)
	if (f_a_count == 0)
		assume(i_clk_a == !$past(i_clk_a));
	else
		assume($stable(i_clk_a);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This would offer some different properties to the clock, so I would
encourage anyone interested to try this approach.&lt;/p&gt;

&lt;p&gt;For this post, however, we’ll continue with the
&lt;a href=&quot;/blog/2017/06/02/generating-timing.html&quot;&gt;fractional divider&lt;/a&gt;
and see if we can’t find a simpler approach.&lt;/p&gt;

&lt;p&gt;If you examine the logic for the output clock, &lt;code class=&quot;highlighter-rouge&quot;&gt;o_clk&lt;/code&gt;, you’ll see that
the output clock is determined by either &lt;code class=&quot;highlighter-rouge&quot;&gt;a_sel&lt;/code&gt; or &lt;code class=&quot;highlighter-rouge&quot;&gt;b_sel&lt;/code&gt;.  If &lt;code class=&quot;highlighter-rouge&quot;&gt;a_sel&lt;/code&gt;
is true, clock &lt;code class=&quot;highlighter-rouge&quot;&gt;A&lt;/code&gt; is
produced.  Likewise if &lt;code class=&quot;highlighter-rouge&quot;&gt;b_sel&lt;/code&gt; is true, then clock B is produced.  If neither
is true, there should be no clock pulse out.  However, both should never be
true at the same time.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(*)
		assert(!a_sel || !b_sel);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;We might also choose to assert that &lt;code class=&quot;highlighter-rouge&quot;&gt;a_sel&lt;/code&gt; or &lt;code class=&quot;highlighter-rouge&quot;&gt;b_sel&lt;/code&gt; would only change
on a clock edge.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @($global_clock)
	if ((f_past_valid)&amp;amp;&amp;amp;(i_areset_n)&amp;amp;&amp;amp;(!$fell(i_clk_a)))
		assert($stable(a_sel));

	always @($global_clock)
	if ((f_past_valid)&amp;amp;&amp;amp;(i_areset_n)&amp;amp;&amp;amp;(!$fell(i_clk_b)))
		assert($stable(b_sel));&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;However, if you examine the design above you’ll see that this
is indeed the case by examination—with the exception of the
&lt;a href=&quot;/formal/2018/04/12/areset.html&quot;&gt;asynchronous reset&lt;/a&gt;
input.  This one piece of our logic might produce a clock glitch, but
we’ll assume that if you are using an
&lt;a href=&quot;/formal/2018/04/12/areset.html&quot;&gt;asynchronous reset&lt;/a&gt;
then you know what you are doing and you can handle such a glitch.&lt;/p&gt;

&lt;p&gt;For our final criteria, let’s count clock ticks in each clock domain.
We’ll start with the &lt;code class=&quot;highlighter-rouge&quot;&gt;A&lt;/code&gt; clock domain.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	reg	[2:0]	a_ticks, last_a_ticks;

	initial	a_ticks = 0;
	always @($global_clock)
		if (!i_areset_n)
			a_ticks &amp;lt;= 0;
		else if ($rose(i_clk_a)&amp;amp;&amp;amp;(a_sel)&amp;amp;&amp;amp;(! &amp;amp;a_ticks))
			a_ticks &amp;lt;= a_ticks + 1&#39;b1;
		else if (b_sel)
			a_ticks &amp;lt;= 0;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;We’ll do the same in a moment with the &lt;code class=&quot;highlighter-rouge&quot;&gt;B&lt;/code&gt; clock domain.  For now, let’s
keep track of the number of clock ticks we’ve had in the &lt;code class=&quot;highlighter-rouge&quot;&gt;A&lt;/code&gt; domain, and
remember this value even after we leave the &lt;code class=&quot;highlighter-rouge&quot;&gt;A&lt;/code&gt; domain.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	initial	last_a_ticks = 0;
	always @($global_clock)
	if (!i_areset_n)
		last_a_ticks &amp;lt;= 0;
	else if ((f_past_valid)&amp;amp;&amp;amp;($past(a_sel)))
		last_a_ticks &amp;lt;= a_ticks;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;We’ll then repeat this logic for the &lt;code class=&quot;highlighter-rouge&quot;&gt;B&lt;/code&gt; clock domain–both counting how
many ticks have taken place since changing, and keeping track of that count
once we switch back to &lt;code class=&quot;highlighter-rouge&quot;&gt;A&lt;/code&gt;s clock.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	reg	[2:0]	b_ticks, last_b_ticks;
	initial	b_ticks = 0;
	always @($global_clock)
		if (!i_areset_n)
			b_ticks &amp;lt;= 0;
		else if ($rose(i_clk_b)&amp;amp;&amp;amp;(b_sel)&amp;amp;&amp;amp;(! &amp;amp;b_ticks))
			b_ticks &amp;lt;= b_ticks + 1&#39;b1;
		else if (a_sel)
			b_ticks &amp;lt;= 0;

	initial	last_b_ticks = 0;
	always @($global_clock)
	if (!i_areset_n)
		last_b_ticks &amp;lt;= 0;
	else if ((f_past_valid)&amp;amp;&amp;amp;($past(b_sel)))
		last_b_ticks &amp;lt;= b_ticks;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;To make our traces look nice, we’ll assume that there must be at least
three clock ticks between switches.  Since this minimum duration properties
isn’t really a fundamental part of our proof, we’ll place it within an
parameterized option to the core.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	generate if (OPT_COVER)
	begin
		// Only one clock should ever be active at any time
		always @($global_clock)
		assert((a_ticks == 0)||(b_ticks == 0));

		always @($global_clock)
		if ((f_past_valid)&amp;amp;&amp;amp;($past(a_sel))&amp;amp;&amp;amp;(a_ticks == 0))
			assume(i_sel);

		always @($global_clock)
		if ((f_past_valid)&amp;amp;&amp;amp;($past(b_sel))&amp;amp;&amp;amp;(b_ticks == 0))
			assume(!i_sel);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Using these two measures of the number of times either &lt;code class=&quot;highlighter-rouge&quot;&gt;A&lt;/code&gt; or &lt;code class=&quot;highlighter-rouge&quot;&gt;B&lt;/code&gt; has
ticked between clock swaps, we can now ask the formal tools to &lt;code class=&quot;highlighter-rouge&quot;&gt;cover()&lt;/code&gt;
a clock transition from A to B where A is at least twice as fast as &lt;code class=&quot;highlighter-rouge&quot;&gt;B&lt;/code&gt;,
and again from &lt;code class=&quot;highlighter-rouge&quot;&gt;B&lt;/code&gt; to &lt;code class=&quot;highlighter-rouge&quot;&gt;A&lt;/code&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;		always @($global_clock)
		cover((f_past_valid)&amp;amp;&amp;amp;(&amp;amp;last_a_ticks)&amp;amp;&amp;amp;(&amp;amp;b_ticks)&amp;amp;&amp;amp;(b_sel)
			&amp;amp;&amp;amp;(f_a_step &amp;gt; (f_b_step&amp;lt;&amp;lt;1)));

		always @($global_clock)
		cover((f_past_valid)&amp;amp;&amp;amp;(&amp;amp;last_b_ticks)&amp;amp;&amp;amp;(&amp;amp;a_ticks)&amp;amp;&amp;amp;(a_sel)
			&amp;amp;&amp;amp;(f_a_step &amp;gt; (f_b_step&amp;lt;&amp;lt;1)));
	end endgenerate&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Now, if everything works, then when we run
&lt;a href=&quot;https://symbiyosys.readthedocs.io/en/latest&quot;&gt;SymbiYosys&lt;/a&gt;
with a &lt;code class=&quot;highlighter-rouge&quot;&gt;mode&lt;/code&gt; of &lt;code class=&quot;highlighter-rouge&quot;&gt;cover&lt;/code&gt;, and using the &lt;code class=&quot;highlighter-rouge&quot;&gt;cover&lt;/code&gt; task defined by the 
&lt;a href=&quot;https://symbiyosys.readthedocs.io/en/latest&quot;&gt;SymbiYosys&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/website/blob/master/examples/clkswitch.sby&quot;&gt;script&lt;/a&gt;,
we’ll get two traces of clock transitions.&lt;/p&gt;

&lt;p&gt;So we’ve now described two of the three properties above, and hand waved through
the third.  Will this work?&lt;/p&gt;

&lt;p&gt;Not quite.&lt;/p&gt;

&lt;p&gt;Should you test this core with only those properties above, you’ll discover
as I did that they aren’t sufficient to ensure that this &lt;a href=&quot;https://github.com/ZipCPU/website/blob/master/examples/clkswitch.v&quot;&gt;clock
switch&lt;/a&gt;
even worked.  You can see the output from
&lt;a href=&quot;https://symbiyosys.readthedocs.io/en/latest&quot;&gt;SymbiYosys&lt;/a&gt; below.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 4. SymbiYosys results from the first formal verification attempt&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/ckswitch-first-fail.png&quot; alt=&quot;Textual terminal output from SymbiYosys&quot; width=&quot;854&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;From this, we determine that our assertion from &lt;a href=&quot;https://github.com/ZipCPU/website/blob/master/examples/clkswitch.v#L184&quot;&gt;line
184&lt;/a&gt;
failed.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @($global_clock)
	assert((!a_sel)||(!b_sel));&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h2 id=&quot;what-happened&quot;&gt;What happened?&lt;/h2&gt;

&lt;p&gt;If you look near the bottom of the
&lt;a href=&quot;https://symbiyosys.readthedocs.io/en/latest&quot;&gt;SymbiYosys&lt;/a&gt;
output, you’ll see a line identifying a counterexample trace.  We can use this
trace to find out why our proof didn’t work.  This trace is shown in Fig 5
below.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 5. Trace file describing how the assertions might fail&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/ckswitch-first-trace.png&quot; alt=&quot;Failing trace, showing a_sel and b_sel both true at the same time&quot; width=&quot;827&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;If you look closely at the penultimate time step, between 70ns and 80ns,
you’ll notice that both
&lt;code class=&quot;highlighter-rouge&quot;&gt;a_sel&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;b_sel&lt;/code&gt; are true at the same time.  &lt;em&gt;This should never happen!&lt;/em&gt;
This violates all of the properties we are hoping to get from this clock
divider.&lt;/p&gt;

&lt;p&gt;Looking closer, you can see that &lt;code class=&quot;highlighter-rouge&quot;&gt;i_sel&lt;/code&gt; (shown in red) didn’t simply change
from selecting clock A to clock B.  Instead, it started out requesting clock
&lt;code class=&quot;highlighter-rouge&quot;&gt;B&lt;/code&gt;, suddenly switched to selecting clock &lt;code class=&quot;highlighter-rouge&quot;&gt;A&lt;/code&gt;, and then immediately
switched back before the synchronizers could settle.  Such a signal on
then &lt;code class=&quot;highlighter-rouge&quot;&gt;i_sel&lt;/code&gt; select line would defeat the purpose of our &lt;a href=&quot;https://github.com/ZipCPU/website/blob/master/examples/clkswitch.v&quot;&gt;clock
switch&lt;/a&gt;,
so it’s not really all that reasonable.&lt;/p&gt;

&lt;p&gt;On the other hand, if we assume that &lt;code class=&quot;highlighter-rouge&quot;&gt;i_sel&lt;/code&gt; won’t change until the clock
transition is complete, then we get a lot farther:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @($global_clock)
	if ((f_past_valid)&amp;amp;&amp;amp;($past(i_sel))&amp;amp;&amp;amp;(!a_sel))
		assume(i_sel);

	always @($global_clock)
	if ((f_past_valid)&amp;amp;&amp;amp;(!$past(i_sel))&amp;amp;&amp;amp;(!b_sel))
		assume(!i_sel);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;As another way we might express this, we might insist that anytime there is
a change propagating through the synchronizers then &lt;code class=&quot;highlighter-rouge&quot;&gt;i_sel&lt;/code&gt; will be
held constant.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @($global_clock)
	if ((a_sel != aff)||(b_sel != bff))
		assume($stable(i_sel));&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Getting this design to &lt;a href=&quot;/blog/2018/03/10/induction-exercise.html&quot;&gt;pass
induction&lt;/a&gt;
requires some additional properties.  For example, we can’t allow the
design to be transitioning in both rails at the same time.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(*)
	if (aff != a_sel)
		assert(bff == b_sel);

	always @(*)
	if (bff != b_sel)
		assert(aff == a_sel);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;With these changes the design passes, proving our first criteria–that the
outgoing clock only
ever changes on an input clock edge.  We also have a meager assurance that the
outgoing clock will not be faster than either incoming clock.  Perhaps
we should examine the third criteria, and see how this switch works when
swapping?&lt;/p&gt;

&lt;p&gt;As you may recall, our third criteria was whether or not we could
switch from one clock to the other or back again.
To see whether or not we met this criteria, we’ll need to run
&lt;a href=&quot;https://symbiyosys.readthedocs.io/en/latest&quot;&gt;SymbiYosys&lt;/a&gt;
in its cover mode.  Our
&lt;a href=&quot;https://github.com/ZipCPU/website/blob/master/examples/clkswitch.sby&quot;&gt;script&lt;/a&gt;
has a &lt;code class=&quot;highlighter-rouge&quot;&gt;cover&lt;/code&gt; task defined within it that does just that.  The result is two
generated clock traces that illustrate how clock transitions might happen.&lt;/p&gt;

&lt;p&gt;The first trace shows that a design can switch from a faster clock to a slower
clock.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 6. Cover result, switching from a faster clock to a slower clock&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/ckswitch-trace0.png&quot; alt=&quot;&quot; width=&quot;578&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;The second trace, on the other hand, shows the clock switching from a slower
clock to a faster clock.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 7. Cover result, switching from a slower clock to a faster clock&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/ckswitch-trace1.png&quot; alt=&quot;&quot; width=&quot;603&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;But what about the idea of a failsafe clock?  Didn’t we say that one reason
for using a &lt;a href=&quot;https://github.com/ZipCPU/website/blob/master/examples/clkswitch.v&quot;&gt;clock
switch&lt;/a&gt;
is to be able to have a failsafe clock, where if one
dies then the other one picks back up?&lt;/p&gt;

&lt;p&gt;This particular design doesn’t support a failsafe clock.
If &lt;code class=&quot;highlighter-rouge&quot;&gt;A&lt;/code&gt; is the failsafe clock, and &lt;code class=&quot;highlighter-rouge&quot;&gt;B&lt;/code&gt; stops transitioning, then you
can’t switch from &lt;code class=&quot;highlighter-rouge&quot;&gt;B&lt;/code&gt; back to &lt;code class=&quot;highlighter-rouge&quot;&gt;A&lt;/code&gt; using &lt;a href=&quot;https://github.com/ZipCPU/website/blob/master/examples/clkswitch.v&quot;&gt;this
design&lt;/a&gt;
since &lt;code class=&quot;highlighter-rouge&quot;&gt;b_sel&lt;/code&gt; depends upon both a positive and a negative transition from
clock &lt;code class=&quot;highlighter-rouge&quot;&gt;B&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Even though this clock switch design doesn’t offer a failsafe capability,
you should now understand the tools necessary to prove that your own design,
perhaps even one with a failsafe capability, would work—but only in an
&lt;a href=&quot;/blog/2017/10/13/fpga-v-asic.html&quot;&gt;ASIC&lt;/a&gt;
design of course!  (Remember, the clock switch is not appropriate for an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
design for the reasons given above.)&lt;/p&gt;

&lt;h2 id=&quot;next-steps&quot;&gt;Next Steps&lt;/h2&gt;

&lt;p&gt;Let’s think about what we just did.  We just verified that a design with
three &lt;a href=&quot;https://en.wikipedia.org/wiki/Asynchronous_circuit&quot;&gt;asynchronous&lt;/a&gt;
inputs “works”.  This involved formally describing two dissimilar clocks
with arbitrary phases and frequencies.  These techniques apply well beyond
this simple &lt;a href=&quot;https://github.com/ZipCPU/website/blob/master/examples/clkswitch.v&quot;&gt;clock
switch&lt;/a&gt;
design.  These techniques can be used in &lt;em&gt;any&lt;/em&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Asynchronous_circuit&quot;&gt;asynchronous&lt;/a&gt;
design component to verify that your logic is working as desired–in spite of
whatever clock phases or frequencies might be given to it.&lt;/p&gt;

&lt;p&gt;While working with
&lt;a href=&quot;https://en.wikipedia.org/wiki/Asynchronous_circuit&quot;&gt;asynchronous&lt;/a&gt;
inputs isn’t common, there are times and places for doing so.  I’ve already
mentioned some examples above: an
&lt;a href=&quot;/formal/2018/04/12/areset.html&quot;&gt;asynchronous reset&lt;/a&gt;,
a &lt;a href=&quot;https://github.com/ZipCPU/wbuart32/blob/dev/rtl/rxuartlite.v&quot;&gt;serial port
receiver&lt;/a&gt;,
or perhaps a circuit that must read memory at one clock rate and feed a video
stream at another rate.  In all of these cases, knowing how to
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formally verify&lt;/a&gt;
your component in spite of any
&lt;a href=&quot;/blog/2017/10/20/cdc.html&quot;&gt;multiple clock domains&lt;/a&gt;
will be a valuable tool.&lt;/p&gt;

&lt;p&gt;The next step in this short series on
&lt;a href=&quot;https://en.wikipedia.org/wiki/Asynchronous_circuit&quot;&gt;asynchronous&lt;/a&gt;
logic will be to take &lt;a href=&quot;http://www.sunburst-design.com/papers/CummingsSNUG2002SJ_FIFO1.pdf&quot;&gt;Cliff Cummings’ asynchronous FIFO
design&lt;/a&gt;,
and apply the same basic
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal verification&lt;/a&gt;
steps we just applied above.&lt;/p&gt;

&lt;p&gt;As an added bonus in this process, you should be able to then turn around and
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formally verify&lt;/a&gt;
any modifications you need to make to
&lt;a href=&quot;http://www.sunburst-design.com/papers/CummingsSNUG2002SJ_FIFO1.pdf&quot;&gt;his design&lt;/a&gt;
to meet your particular design requirements.&lt;/p&gt;
&lt;hr /&gt;&lt;p&gt;&lt;em&gt;And he said unto them, It is not for you to know the times or the seasons, which the Father hath put in His own power. (Acts 1:7)&lt;/em&gt;</description>
        <pubDate>Thu, 31 May 2018 00:00:00 -0400</pubDate>
        <link>https://zipcpu.com/formal/2018/05/31/clkswitch.html</link>
        <guid isPermaLink="true">https://zipcpu.com/formal/2018/05/31/clkswitch.html</guid>
        
        
        <category>formal</category>
        
      </item>
    
      <item>
        <title>A Slow but Symmetric FIR Filter Implementation</title>
        <description>&lt;p&gt;It’s been some time since we’ve discussed digital filtering on the
ZipCPU blog.
When we last left the topic, we had several filters left to present.  Today,
let’s pick up the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Linear_phase&quot;&gt;symmetric or linear phase&lt;/a&gt;
&lt;a href=&quot;/dsp/2017/09/15/fastfir.html&quot;&gt;filter&lt;/a&gt;,
and demonstrate a block RAM
based implementation of it.  I’ll call this a &lt;em&gt;slow filter&lt;/em&gt;, similar to our
last &lt;a href=&quot;/dsp/2017/12/30/slowfil.html&quot;&gt;slow filter&lt;/a&gt;,
simply because
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/slowsymf.v&quot;&gt;this filter&lt;/a&gt;
won’t be able to handle a new sample every clock
tick.  Instead, what makes
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/slowsymf.v&quot;&gt;this filter&lt;/a&gt;
special is that it only requires one dedicated hardware multiply.  Better
yet, as with the &lt;a href=&quot;/dsp/2017/12/30/slowfil.html&quot;&gt;last
slow filter&lt;/a&gt;
implementation, making
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/slowsymf.v&quot;&gt;this filter&lt;/a&gt;
adjustable won’t require a lot of resources.  Unlike the
&lt;a href=&quot;/dsp/2017/12/30/slowfil.html&quot;&gt;last filter&lt;/a&gt;,
though,
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/slowsymf.v&quot;&gt;this one&lt;/a&gt;
will offer nearly twice the performance for nearly the same amount of
resources.&lt;/p&gt;

&lt;p&gt;Interested yet?&lt;/p&gt;

&lt;p&gt;But we’ll come back to this in a moment.  In the meantime, let’s try to catch
up some of our readers who may be starting in the middle of this discussion.
Basically, we’ve been
slowly working through hardware implementations of all of the basic
&lt;a href=&quot;https://en.wikipedia.org/wiki/Finite_impulse_response&quot;&gt;FIR&lt;/a&gt;
filtering types.  We’ve already laid a lot of ground work, ground work you
might wish to review should you find yourself coming in the middle of this
discussion.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Our &lt;a href=&quot;/dsp/2017/09/15/fastfir.html&quot;&gt;first post&lt;/a&gt; on the
topic outlined what a digital filter was, and how a filter could be built that
operated at the full clock rate of an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;.
This initial post was quickly followed by an &lt;a href=&quot;/dsp/2017/09/29/cheaper-fast-fir.html&quot;&gt;updated
implementation&lt;/a&gt; that
used fewer
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flip-flop_(electronics)&quot;&gt;flip-flops&lt;/a&gt;
while achieving the same performance.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;This &lt;a href=&quot;/dsp/2017/09/15/fastfir.html&quot;&gt;initial filtering
article&lt;/a&gt;
was followed by a &lt;a href=&quot;/dsp/2017/11/04/genfil-tb.html&quot;&gt;proposed
abstraction&lt;/a&gt;
that could be applied to every
filtering implementation.
As long as any filter we built, therefore, had the I/O interface of this
&lt;a href=&quot;/dsp/2017/11/04/genfil-tb.html&quot;&gt;generic filter&lt;/a&gt;,
we could re-use a
&lt;a href=&quot;/dsp/2017/11/04/genfil-tb.html&quot;&gt;test harness&lt;/a&gt;,
to test multiple different filters.&lt;/p&gt;

    &lt;p&gt;A &lt;a href=&quot;/dsp/2017/11/22/fltr-response.html&quot;&gt;following article&lt;/a&gt;
discussed how we could use this &lt;a href=&quot;/dsp/2017/11/04/genfil-tb.html&quot;&gt;generic filter
testing&lt;/a&gt;
approach to verify that a given filter had the
&lt;a href=&quot;/dsp/2017/11/22/fltr-response.html&quot;&gt;frequency response&lt;/a&gt;
it was designed to have.&lt;/p&gt;

    &lt;p&gt;We then demonstrated how these methods could be applied to test our
&lt;a href=&quot;/dsp/2017/09/15/fastfir.html&quot;&gt;generic FIR filter&lt;/a&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Along the way, we’ve presented several different types of filters.  We
started by discussing &lt;a href=&quot;/dsp/2017/08/19/simple-filter.html&quot;&gt;two of the absolute simplest
filters&lt;/a&gt; I know of:
a pairwise averager and a &lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/iiravg.v&quot;&gt;recursive
averager&lt;/a&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;We then came back later to make the pairwise averager into a more generic
&lt;a href=&quot;/dsp/2017/10/16/boxcar.html&quot;&gt;moving (block) average
filter&lt;/a&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The last post on this topic broke the mold of a filter that accepted one
input and produced one output on every clock tick.  Instead, that &lt;a href=&quot;/dsp/2017/12/30/slowfil.html&quot;&gt;post
presented a filter&lt;/a&gt;
that would accept one input every &lt;code class=&quot;highlighter-rouge&quot;&gt;N&lt;/code&gt; clocks, allowing the
filter to accomplish all of its multiplies using a single hardware multiply
alone.&lt;/p&gt;

    &lt;p&gt;Further, since this &lt;a href=&quot;/dsp/2017/12/30/slowfil.html&quot;&gt;filtering
implementation&lt;/a&gt;
used block RAM to store and retrieve its coefficients, it cost much less to
reconfigure the filter than our prior &lt;a href=&quot;/dsp/2017/09/15/fastfir.html&quot;&gt;generic filtering
implementation&lt;/a&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Since this last post, I’ve focused on interpolation for a while, by first
proving that &lt;a href=&quot;/dsp/2018/01/16/interpolation-is-convolution.html&quot;&gt;interpolation &lt;em&gt;is&lt;/em&gt; a
convolution&lt;/a&gt;,
and then showing how that knowledge could be used to create a very useful
&lt;a href=&quot;/dsp/2018/03/30/quadratic.html&quot;&gt;quadratic interpolation&lt;/a&gt;
method with some amazing out-of-band performance.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;In other words, it’s been some time since we’ve discussed
filtering,
and there remain many types of
filters
and filtering implementations for us still to discuss.  For example, we
haven’t discussed
&lt;a href=&quot;https://en.wikipedia.org/wiki/Linear_phase&quot;&gt;symmetric&lt;/a&gt;
or &lt;a href=&quot;https://en.wikipedia.org/wiki/Half-band_filter&quot;&gt;half-band filters&lt;/a&gt;.
Neither have we discussed how to implement a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Hilbert_transform&quot;&gt;Hilbert transform&lt;/a&gt;.  Another
fun filtering topic we could discuss would be how to string multiple
filters
together to handle the case where there may be &lt;code class=&quot;highlighter-rouge&quot;&gt;N&lt;/code&gt; clocks between
samples, but the filter has more than &lt;code class=&quot;highlighter-rouge&quot;&gt;N&lt;/code&gt; coefficients.  There’s also the
ultimate
&lt;a href=&quot;https://en.wikipedia.org/wiki/Low-pass_filter&quot;&gt;lowpass filter&lt;/a&gt;:
the one that
filters
an incoming sample stream to
(just about) any arbitrary low-bandwidth for only about
&lt;code class=&quot;highlighter-rouge&quot;&gt;24&lt;/code&gt; taps–independent of the actual
&lt;a href=&quot;https://en.wikipedia.org/wiki/Low-pass_filter&quot;&gt;lowpass&lt;/a&gt;
bandwidth.
Then there’s the adaptive filters that are commonly used in the equalizers
within digital communications receivers.  Finally, there’s the grandaddy filter
of them all: the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Fast_Fourier_transform&quot;&gt;FFT&lt;/a&gt;
based
filter.
When implemented properly, an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Fast_Fourier_transform&quot;&gt;FFT&lt;/a&gt;
based filter is not only quite configurable, it’s also very easy to
reconfigure.&lt;/p&gt;

&lt;p&gt;Seems like I could keep discussing filtering for quite some time.&lt;/p&gt;

&lt;p&gt;All of these filtering topics would be fun to present here on
&lt;a href=&quot;https://zipcpu.com/&quot;&gt;this blog&lt;/a&gt;.
For today, though, let’s just examine how to build a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Linear_phase&quot;&gt;symmetric filter&lt;/a&gt;
implementation.&lt;/p&gt;

&lt;p&gt;To start off the discussion, consider that I recently counseled someone
who was studying aircraft engine noise and trying build a
filter
that would grab only 180Hz to 6300Hz of an audio signal sampled at 44.1kHz.
He was disappointed that his
&lt;a href=&quot;https://en.wikipedia.org/wiki/Butterfly_filter&quot;&gt;Butterworth filter&lt;/a&gt;
design wasn’t quite meeting his need.  Given that his design only had a 3dB
&lt;a href=&quot;https://en.wikipedia.org/wiki/Stopband&quot;&gt;stopband&lt;/a&gt;
rejection, I’m sure you can understand why not.  But let’s just consider
this specification for a moment.&lt;/p&gt;

&lt;p&gt;Suppose you wanted to design a 180Hz to 6300Hz bandpass filter.  How many
taps would you need?  Let’s say you wanted a 40Hz
&lt;a href=&quot;https://en.wikipedia.org/wiki/Transition_band&quot;&gt;transition band&lt;/a&gt;.
You would then need 4095 taps to achieve a 65dB
&lt;a href=&quot;https://en.wikipedia.org/wiki/Stopband&quot;&gt;stopband&lt;/a&gt;.
If you used the
&lt;a href=&quot;/dsp/2017/09/15/fastfir.html&quot;&gt;generic filtering&lt;/a&gt; approach,
you would need to find an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
with 4095 multiplies on board.  While I don’t know about
your budget, I certainly couldn’t afford an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
with that many multiplies.  On the other hand, if you used the
&lt;a href=&quot;/dsp/2017/12/30/slowfil.html&quot;&gt;slow filter&lt;/a&gt; from our
last discussion, you would only be able to implement a
filter
2267 taps long.  This would leave you with the choice of either loosening your
&lt;a href=&quot;https://en.wikipedia.org/wiki/Transition_band&quot;&gt;transition&lt;/a&gt;
bandwidth or your
&lt;a href=&quot;https://en.wikipedia.org/wiki/Stopband&quot;&gt;stopband&lt;/a&gt;
criteria.&lt;/p&gt;

&lt;p&gt;On the other hand, if you could exploit the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Linear_phase&quot;&gt;symmetry&lt;/a&gt;
inherent in
&lt;a href=&quot;https://en.wikipedia.org/wiki/Parks-McClellan_filter_design_algorithm&quot;&gt;most&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Finite_impulse_response&quot;&gt;FIR&lt;/a&gt;
filter designs, you’d have more than enough logic to implement your filter
design on a cheap
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
board using only one hardware multiply.&lt;/p&gt;

&lt;h2 id=&quot;background&quot;&gt;Background&lt;/h2&gt;

&lt;p&gt;So, what is this
&lt;a href=&quot;https://en.wikipedia.org/wiki/Linear_phase&quot;&gt;symmetry&lt;/a&gt;,
and how shall we exploit it?  To understand that, let’s go back to the
beginning and understand how
&lt;a href=&quot;/dsp/2017/09/15/fastfir.html&quot;&gt;digital filters&lt;/a&gt;,
are designed.&lt;/p&gt;

&lt;p&gt;To design a
filter,
the engineer must first determine a range of frequencies
he wants the filter to “pass” (i.e. the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Passband&quot;&gt;passband&lt;/a&gt;),
and another range of frequencies he wants the
filter
to “&lt;a href=&quot;https://en.wikipedia.org/wiki/Stopband&quot;&gt;stop&lt;/a&gt;”.
These two ranges tend to be disjoint, with a
“&lt;a href=&quot;https://en.wikipedia.org/wiki/Transition_band&quot;&gt;transition band&lt;/a&gt;”
between them.  Within the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Stopband&quot;&gt;stopband&lt;/a&gt;,
the engineer must determine the “depth”, also known as how much attenuation
the filter is to provide in this region.  This can also be used as a
criteria on how much (or little) distortion is allowed within the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Passband&quot;&gt;passband&lt;/a&gt;).&lt;/p&gt;

&lt;p&gt;All of these criteria are easily illustrated in Fig 1 below.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 1: FIR Filter Design Criteria&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/fir-lpf-design.png&quot; alt=&quot;Filter design regions: passband, transition band, and stop band&quot; width=&quot;776&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Given this criteria, the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Parks-McClellan_filter_design_algorithm&quot;&gt;Parks and McClellan algorithm&lt;/a&gt;
is well known for generating “optimal” filters.  &lt;a href=&quot;https://en.wikipedia.org/wiki/Parks-McClellan_filter_design_algorithm&quot;&gt;This filter design
method&lt;/a&gt;
produces filters that come closest to the filter design specification, as
measured by the maximum deviation from the specification.  There are two
other realities with using this method.  First, the filters designed by it all
have an odd number of coefficients.  Second, as designed they are all
&lt;a href=&quot;https://en.wikipedia.org/wiki/Linear_phase&quot;&gt;symmetric&lt;/a&gt; and
&lt;a href=&quot;https://en.wikipedia.org/wiki/Causal_filter&quot;&gt;non-causal&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;These two characteristics follow the fact that the
&lt;a href=&quot;/dsp/2017/09/15/fastfir.html&quot;&gt;filter&lt;/a&gt;
is specified with &lt;em&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Real_number&quot;&gt;real&lt;/a&gt;&lt;/em&gt;, as
opposed to
&lt;a href=&quot;https://en.wikipedia.org/wiki/Complex_number&quot;&gt;complex&lt;/a&gt; or
&lt;a href=&quot;https://en.wikipedia.org/wiki/Imaginary_number&quot;&gt;imaginary&lt;/a&gt;, criteria.  That
is, the desired &lt;a href=&quot;/dsp/2017/09/15/fastfir.html&quot;&gt;filter&lt;/a&gt;’s
&lt;a href=&quot;/dsp/2017/11/22/fltr-response.html&quot;&gt;frequency response&lt;/a&gt;
is expressed as a &lt;em&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Real_number&quot;&gt;real&lt;/a&gt;&lt;/em&gt;
function of frequency.&lt;/p&gt;

&lt;p&gt;Let’s think about this for a moment.  We already know that if you have a
sampled sequence, &lt;code class=&quot;highlighter-rouge&quot;&gt;x[n]&lt;/code&gt;, and apply a
&lt;a href=&quot;/dsp/2017/09/15/fastfir.html&quot;&gt;filter&lt;/a&gt;
with
&lt;a href=&quot;https://en.wikipedia.org/wiki/Impulse_response&quot;&gt;impulse response&lt;/a&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;h[k]&lt;/code&gt;,
then you will get the output &lt;code class=&quot;highlighter-rouge&quot;&gt;y[n]&lt;/code&gt;.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/eqn-convolution-raw.png&quot; alt=&quot;y[n]=SUM h[k] x[n-k]&quot; width=&quot;254&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 2: Convolution Operation&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/fir-form.svg&quot; alt=&quot;&quot; width=&quot;360&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;This operation is called a
discrete &lt;a href=&quot;https://en.wikipedia.org/wiki/Convolution&quot;&gt;convolution&lt;/a&gt;, and it
defines the operation of any
&lt;a href=&quot;/dsp/2017/09/15/fastfir.html&quot;&gt;discrete-time filter&lt;/a&gt;.
Fig 2 shows this operation pictorially, illustrating how the &lt;code class=&quot;highlighter-rouge&quot;&gt;x[n]&lt;/code&gt; elements
can be placed into a tapped delay line, multiplied by their respective &lt;code class=&quot;highlighter-rouge&quot;&gt;h[k]&lt;/code&gt;
coefficient, and then summed together to create the output &lt;code class=&quot;highlighter-rouge&quot;&gt;y[n]&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Further, if you apply this operation to a complex exponential,
such as when&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/eqn-symfil-input-sinusoid.png&quot; alt=&quot;x[n]=e^{j 2pi fn+jtheta}&quot; width=&quot;181&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;then the output of the
&lt;a href=&quot;/dsp/2017/09/15/fastfir.html&quot;&gt;filter&lt;/a&gt;
&lt;a href=&quot;/dsp/2017/11/22/fltr-response.html&quot;&gt;is the same exponential&lt;/a&gt;,
having only been multiplied by a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Complex_number&quot;&gt;complex&lt;/a&gt;
value that is independent of time,&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/eqn-symfil-output-sinusoid.png&quot; alt=&quot;y[n] = e^{jtheta}e^{j2pi fn} SUM h[k] e^{-j2pi fk}&quot; width=&quot;499&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;This complex multiplier is called the &lt;em&gt;&lt;a href=&quot;/dsp/2017/11/22/fltr-response.html&quot;&gt;frequency
response&lt;/a&gt;&lt;/em&gt;
of the filter.  It is defined by,&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/eqn-symfil-fltr-response.png&quot; alt=&quot;H(e^{j2pi f}) = SUM h[k] e^{-j2pi fk}&quot; width=&quot;301&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;This is also the function we were specifying earlier in Fig 1 above.
This should be familiar to you so far, as we have
already &lt;a href=&quot;/dsp/2017/11/22/fltr-response.html&quot;&gt;discussed the importance of a filter’s frequency
response&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Now consider what happens if we insist that this
&lt;a href=&quot;/dsp/2017/11/22/fltr-response.html&quot;&gt;frequency response&lt;/a&gt; is a
&lt;em&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Real_number&quot;&gt;real&lt;/a&gt;&lt;/em&gt;
function of frequency, just like we specified it above.  We’ll use &lt;code class=&quot;highlighter-rouge&quot;&gt;hs[k]&lt;/code&gt; and
&lt;code class=&quot;highlighter-rouge&quot;&gt;Hs&lt;/code&gt; to describe this constrained filter.  If this filter has a
&lt;em&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Real_number&quot;&gt;real&lt;/a&gt;&lt;/em&gt;
&lt;a href=&quot;/dsp/2017/11/22/fltr-response.html&quot;&gt;frequency response&lt;/a&gt;,
then the
&lt;a href=&quot;/dsp/2017/11/22/fltr-response.html&quot;&gt;frequency response&lt;/a&gt;
function must be equal to its conjugate.  We’ll start our proof there.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/eqn-symfil-real-H.png&quot; alt=&quot;H = H^&quot; width=&quot;319&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;We can then replace &lt;code class=&quot;highlighter-rouge&quot;&gt;Hs&lt;/code&gt; with its definition from above and shown in Fig 1,
and then work the conjugate through the summation.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/eqn-symfil-conjugate-sum.png&quot; alt=&quot;SUM h[k] e^{-j2pi fk} = SUM h[k] e^{j2pi fk}&quot; width=&quot;367&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Here, we note two things.  First, &lt;code class=&quot;highlighter-rouge&quot;&gt;hs[k]&lt;/code&gt; is real and so &lt;code class=&quot;highlighter-rouge&quot;&gt;hs[k]&lt;/code&gt; is also equal
to its own conjugate.  Second, if we reverse the summation on the right via a
variable substitution &lt;code class=&quot;highlighter-rouge&quot;&gt;p=-k&lt;/code&gt;, then we have&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/eqn-symfil-psum.png&quot; alt=&quot;SUM h[k] e^{-j2pi fk} = SUM h[-p] e^{-j2pi fp}&quot; width=&quot;396&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;We’ll switch back to a summation over &lt;code class=&quot;highlighter-rouge&quot;&gt;k&lt;/code&gt; for convenience of notation, although
this “new” &lt;code class=&quot;highlighter-rouge&quot;&gt;k&lt;/code&gt; value is just a dummy variable bearing no reference to the
&lt;code class=&quot;highlighter-rouge&quot;&gt;k&lt;/code&gt; three equations above.  (Yes, I did get marked off for doing this by
&lt;a href=&quot;https://www.afit.edu/BIOS/bio.cfm?facID=223&quot;&gt;my instructor&lt;/a&gt; years ago.)&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/eqn-symfil-ksum.png&quot; alt=&quot;SUM h[k] e^{-j2pi fk} = SUM h[-k] e^{-j2pi fk}&quot; width=&quot;388&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Now reflect on the fact that this relationship must be true for all
frequencies, &lt;code class=&quot;highlighter-rouge&quot;&gt;f&lt;/code&gt;.  That can only happen if&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/eqn-symfil-real-coeff.png&quot; alt=&quot;h[k] = h[-k]&quot; width=&quot;169&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;for all &lt;code class=&quot;highlighter-rouge&quot;&gt;k&lt;/code&gt;.  In other words, any filter with a
&lt;em&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Real_number&quot;&gt;real&lt;/a&gt;&lt;/em&gt;
&lt;a href=&quot;/dsp/2017/11/22/fltr-response.html&quot;&gt;frequency response&lt;/a&gt;,
such as those designed from a
&lt;em&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Real_number&quot;&gt;real&lt;/a&gt;&lt;/em&gt;
&lt;a href=&quot;/dsp/2017/11/22/fltr-response.html&quot;&gt;frequency response&lt;/a&gt;
criteria, will always be &lt;a href=&quot;https://en.wikipedia.org/wiki/Linear_phase&quot;&gt;symmetric&lt;/a&gt;
about the time axis, &lt;code class=&quot;highlighter-rouge&quot;&gt;k&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Of course, this isn’t very useful to us, since any
&lt;a href=&quot;/dsp/2017/09/15/fastfir.html&quot;&gt;filter&lt;/a&gt;
having non-zero values of &lt;code class=&quot;highlighter-rouge&quot;&gt;h[k]&lt;/code&gt; for &lt;code class=&quot;highlighter-rouge&quot;&gt;k&amp;lt;0&lt;/code&gt; is
&lt;a href=&quot;https://en.wikipedia.org/wiki/Causal_filter&quot;&gt;non-causal&lt;/a&gt; and as such
cannot be implemented: it depends upon the knowledge of &lt;em&gt;future&lt;/em&gt; values of
&lt;code class=&quot;highlighter-rouge&quot;&gt;x[n]&lt;/code&gt;.  The easy way to deal with this problem is to take the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Linear_phase&quot;&gt;symmetric&lt;/a&gt;
filter we just designed, and shift it so that it’s first non-zero coefficient
is &lt;code class=&quot;highlighter-rouge&quot;&gt;h[0]&lt;/code&gt;.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/eqn-symfil-shiftfil.png&quot; alt=&quot;h[k] = hs[k-(N-1)/2]&quot; width=&quot;204&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Hence, we now have a filter with &lt;code class=&quot;highlighter-rouge&quot;&gt;N&lt;/code&gt; non-zero coefficients, and where&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/eqn-symfil-new-symmetry.png&quot; alt=&quot;h[k] = h[N-1-k]&quot; width=&quot;219&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;This does nothing more than delay the operation of &lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/slowsymf.v&quot;&gt;our
filter&lt;/a&gt;
in time–something the designer may not care about.&lt;/p&gt;

&lt;p&gt;If you evaluate the
&lt;a href=&quot;/dsp/2017/11/22/fltr-response.html&quot;&gt;frequency response&lt;/a&gt;
of this adjusted
&lt;a href=&quot;/dsp/2017/09/15/fastfir.html&quot;&gt;filter&lt;/a&gt;,
you’ll find its
&lt;a href=&quot;/dsp/2017/11/22/fltr-response.html&quot;&gt;frequency response&lt;/a&gt;
to be related to our earlier
&lt;a href=&quot;/dsp/2017/11/22/fltr-response.html&quot;&gt;frequency response&lt;/a&gt;,
by a &lt;a href=&quot;https://en.wikipedia.org/wiki/Linear_phase&quot;&gt;linear phase&lt;/a&gt; term.&lt;/p&gt;

&lt;!-- H(e^{j2pi f}) = SUM h[k-N-1/2]e^{-j 2pi fk}
H(e^{j2pi f}) = SUM h[k]e^{-j 2pi f(k+(N-1)/2)} --&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/eqn-symfil-linear-phase.png&quot; alt=&quot;H(e^{j2pi f}) = e^{-j pi fN }SUM h[k]e^{-j 2pi fk}&quot; width=&quot;378&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;The difference between the
&lt;a href=&quot;/dsp/2017/11/22/fltr-response.html&quot;&gt;frequency response&lt;/a&gt;
of the two
&lt;a href=&quot;/dsp/2017/09/15/fastfir.html&quot;&gt;filters&lt;/a&gt;,
the one symmetric about zero and the
offset but now &lt;a href=&quot;https://en.wikipedia.org/wiki/Causal_filter&quot;&gt;causal&lt;/a&gt;
&lt;a href=&quot;/dsp/2017/09/15/fastfir.html&quot;&gt;filter&lt;/a&gt;,
is a phase term that is linear in frequency.  For this reason,
&lt;a href=&quot;/dsp/2017/09/15/fastfir.html&quot;&gt;filters&lt;/a&gt;
of this type are often called
&lt;em&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Linear_phase&quot;&gt;linear phase&lt;/a&gt;&lt;/em&gt;
&lt;a href=&quot;/dsp/2017/09/15/fastfir.html&quot;&gt;filters&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;But let’s go back a step, did you catch how this affects how we might
implement &lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/slowsymf.v&quot;&gt;this
filter&lt;/a&gt;?  If
the &lt;a href=&quot;/dsp/2017/09/15/fastfir.html&quot;&gt;filter&lt;/a&gt;
remains &lt;a href=&quot;https://en.wikipedia.org/wiki/Linear_phase&quot;&gt;symmetric&lt;/a&gt; such that,&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/eqn-symfil-new-symmetry.png&quot; alt=&quot;h[k] = h[N-1-k]&quot; width=&quot;219&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;then we can rewrite our &lt;a href=&quot;https://en.wikipedia.org/wiki/Convolution&quot;&gt;convolution&lt;/a&gt;
so it uses fewer multiplies.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/eqn-symfil-implementation.png&quot; alt=&quot;y[n] = SUM h[k] ( x[n-k] + x[n+k-(N-1)] ) + h[M]x[n-M]&quot; width=&quot;706&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 3: Convolution Operation Exploiting Coefficient Symmetry&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/fir-symfil-form.svg&quot; alt=&quot;&quot; width=&quot;360&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;This is a big deal!  It’s a big deal because we now have half as many
multiplies as we had before!  We can even scale &lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/slowsymf.v&quot;&gt;our
filter&lt;/a&gt;
such that the middle point of
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/slowsymf.v&quot;&gt;the filter&lt;/a&gt;,
&lt;code class=&quot;highlighter-rouge&quot;&gt;h[M]&lt;/code&gt;, has some sort of “simple”
value like &lt;code class=&quot;highlighter-rouge&quot;&gt;(2^(K-1))-1&lt;/code&gt; for a &lt;code class=&quot;highlighter-rouge&quot;&gt;K&lt;/code&gt; bit word size, for one fewer multiply.
Put together, we’ve just about doubled the capability of any
&lt;a href=&quot;/dsp/2017/09/15/fastfir.html&quot;&gt;filter&lt;/a&gt;
we might wish to implement for only a minimal cost in additional logic.&lt;/p&gt;

&lt;p&gt;You can see how this affects our operation in Fig 3.  Notice how the tapped
delay line containing the incoming signal is now folded in half.  Further,
before the multiply, there’s an addition where we add the pairs of signal data
points together before multiplying by the common filter coefficient.  You
might also notice the single value on the right.  This represents
the coefficient in the middle–the one we’ll multiply by a constant value.&lt;/p&gt;

&lt;p&gt;Now compare Fig 3 to Fig 2 and count the multiplies.  See the difference?
Instead of &lt;code class=&quot;highlighter-rouge&quot;&gt;N&lt;/code&gt; multiplies, there are now &lt;code class=&quot;highlighter-rouge&quot;&gt;(N-1)/2&lt;/code&gt;, or nearly half as many
as we had before.&lt;/p&gt;

&lt;p&gt;Now let’s take a look at how we might optimize our filter’s implementation
to take advantage of this property.&lt;/p&gt;

&lt;h2 id=&quot;c-implementation&quot;&gt;C++ Implementation&lt;/h2&gt;

&lt;p&gt;Although this is an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt; focused
blog, sometimes it helps to consider an algorithm in a higher level language
to understand it.  So let’s spend a moment and review the C++ code describing
our &lt;a href=&quot;/dsp/2017/12/30/slowfil.html&quot;&gt;last implementation&lt;/a&gt;, and
then show how this would change to exploit the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Linear_phase&quot;&gt;symmetry&lt;/a&gt;
inherent in most
&lt;a href=&quot;https://en.wikipedia.org/wiki/Finite_impulse_response&quot;&gt;FIR&lt;/a&gt;
filters.&lt;/p&gt;

&lt;p&gt;As we &lt;a href=&quot;/dsp/2017/12/30/slowfil.html&quot;&gt;presented it before&lt;/a&gt;,
the &lt;a href=&quot;/dsp/2017/12/30/slowfil.html&quot;&gt;slow filter&lt;/a&gt;
C++ code worked by first adding a new data sample to a circular buffer.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;&lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;FIR&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;apply&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dat&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;		&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ln&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;acc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

	&lt;span class=&quot;n&quot;&gt;m_data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_loc&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dat&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_loc&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m_len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;m_loc&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Then the filtering algorithm stepped through each
&lt;a href=&quot;/dsp/2017/09/15/fastfir.html&quot;&gt;filter&lt;/a&gt;
coefficient, multiplying it by a corresponding data sample.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;	&lt;span class=&quot;n&quot;&gt;acc&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;d&lt;/span&gt;   &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_loc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;   &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_taps&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_len&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;ln&lt;/span&gt;  &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m_len&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m_loc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ln&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;acc&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;--&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Notice that the two indices go in opposite directions.  This is an important
feature of any
&lt;a href=&quot;/dsp/2017/09/15/fastfir.html&quot;&gt;filtering&lt;/a&gt;,
implementation where the
&lt;a href=&quot;/dsp/2017/09/15/fastfir.html&quot;&gt;filter&lt;/a&gt;
might not be
&lt;a href=&quot;https://en.wikipedia.org/wiki/Linear_phase&quot;&gt;symmetric&lt;/a&gt;.
For &lt;a href=&quot;https://en.wikipedia.org/wiki/Linear_phase&quot;&gt;symmetric&lt;/a&gt;
&lt;a href=&quot;/dsp/2017/09/15/fastfir.html&quot;&gt;filters&lt;/a&gt;,
the direction the coefficients are read doesn’t really
matter all that much.&lt;/p&gt;

&lt;p&gt;The algorithm was made just a touch confusing by the fact that the data
is kept in a circular buffer.  As a result, the relevant data might cross
the boundary of the circular buffer, from the right half to the left.
If you split the loop into two parts, you can avoid checking for the
buffer split within the loop itself.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;	&lt;span class=&quot;n&quot;&gt;d&lt;/span&gt;   &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m_data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;ln&lt;/span&gt;  &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m_loc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ln&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;acc&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;--&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Finally, the algorithm ended by returning the accumulated sum of products.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;	&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;acc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;That’s the basic
&lt;a href=&quot;/dsp/2017/09/15/fastfir.html&quot;&gt;filtering&lt;/a&gt;
algorithm that you can apply to implement any
&lt;a href=&quot;https://en.wikipedia.org/wiki/Finite_impulse_response&quot;&gt;FIR&lt;/a&gt;
&lt;a href=&quot;/dsp/2017/09/15/fastfir.html&quot;&gt;filter&lt;/a&gt;.  (Remember, for
&lt;a href=&quot;https://en.wikipedia.org/wiki/Finite_impulse_response&quot;&gt;FIR&lt;/a&gt;
&lt;a href=&quot;/dsp/2017/09/15/fastfir.html&quot;&gt;filters&lt;/a&gt;
longer than about 64-taps or so,
&lt;a href=&quot;https://en.wikipedia.org/wiki/Fast_Fourier_transform&quot;&gt;FFT&lt;/a&gt;
methods are faster/better/cheaper in software than the direct form presented
above.)&lt;/p&gt;

&lt;p&gt;Now, how would we modify this algorithm to create an implementation that
would exploit the &lt;a href=&quot;https://en.wikipedia.org/wiki/Linear_phase&quot;&gt;symmetry&lt;/a&gt;
within our &lt;a href=&quot;https://en.wikipedia.org/wiki/Impulse_response&quot;&gt;impulse response&lt;/a&gt;
coefficients?&lt;/p&gt;

&lt;p&gt;We’d start out exactly as before, by adding the new data sample to our
input sample memory.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;&lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;SYMFIR&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;apply&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dat&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;		&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ln&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;acc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

	&lt;span class=&quot;n&quot;&gt;m_data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_loc&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dat&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_loc&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m_len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;m_loc&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;However, that’s about as far as we can go in common with the &lt;a href=&quot;/dsp/2017/12/30/slowfil.html&quot;&gt;previous
algorithm&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The next step is to calculate two pointers into the data–something we didn’t
need to do before.  The first, &lt;code class=&quot;highlighter-rouge&quot;&gt;dpnew&lt;/code&gt;,
will be a pointer to the most recent data that we just added into our buffer,
while the second, &lt;code class=&quot;highlighter-rouge&quot;&gt;dpold&lt;/code&gt;, will point to the oldest data in our buffer.  Since
the buffer has only as many samples within it as we have coefficients in our
&lt;a href=&quot;/dsp/2017/09/15/fastfir.html&quot;&gt;filter&lt;/a&gt;,
we only need to check for wrap around once.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;	&lt;span class=&quot;n&quot;&gt;dpnew&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_loc&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_loc&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;dpnew&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_len&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;dpold&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_loc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;We’ll also set a pointer to our coefficient memory.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;	&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m_taps&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;At each point through the summation, we’ll read two values from our
data memory, one older &lt;code class=&quot;highlighter-rouge&quot;&gt;*dpold&lt;/code&gt; and one newer &lt;code class=&quot;highlighter-rouge&quot;&gt;*dpnew&lt;/code&gt;.  We’ll then add these
two values together, and multiply the result by the
&lt;a href=&quot;/dsp/2017/09/15/fastfir.html&quot;&gt;filter&lt;/a&gt;
coefficient.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;	&lt;span class=&quot;k&quot;&gt;do&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;presum&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dpold&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dpnew&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;acc&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;presum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;So far this is all very straight forward.&lt;/p&gt;

&lt;p&gt;Where this C++ version gets difficult is when we try to handle pointer
wrapping in our circular buffer.  Unlike before, when we only had one pointer
to check, we now
have two pointers that might wrap as we work our way through memory.  Rather
than work through the math of separating this loop into three parts,
I’ll just add a wrap check inside the loop.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;		&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dpold&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_len&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;dpold&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dpnew&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;dpold&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_len&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dpold&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dpnew&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This loop will end before we get to the multiply in the middle of the
&lt;a href=&quot;/dsp/2017/09/15/fastfir.html&quot;&gt;filter&lt;/a&gt;.
So, let’s handle it now and then return our result.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;	&lt;span class=&quot;n&quot;&gt;acc&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dpold&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;acc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;For those who might ask, yes, I do like redundant parentheses.
That’s really beside the point, however.&lt;/p&gt;

&lt;p&gt;The point here is that for an &lt;code class=&quot;highlighter-rouge&quot;&gt;N&lt;/code&gt; point
&lt;a href=&quot;/dsp/2017/09/15/fastfir.html&quot;&gt;filter&lt;/a&gt;,
where &lt;code class=&quot;highlighter-rouge&quot;&gt;N&lt;/code&gt; is odd, we’ve just calculated the result using only
&lt;code class=&quot;highlighter-rouge&quot;&gt;1+(N-1)/2&lt;/code&gt; multiplies, instead of the &lt;code class=&quot;highlighter-rouge&quot;&gt;N&lt;/code&gt; multiplies it would have cost us
before.&lt;/p&gt;

&lt;p&gt;This is the basic algorithm we’ll code up in Verilog in the next section.
However, in Verilog we’ll use a memory in a circular addressing configuration.
That way we don’t have to worry (much) about wrapping the pointers around.
We will, however, need to worry about timing and pipeline scheduling.&lt;/p&gt;

&lt;h2 id=&quot;verilog-outline&quot;&gt;Verilog Outline&lt;/h2&gt;

&lt;p&gt;When we first built our
&lt;a href=&quot;/dsp/2017/12/30/slowfil.html&quot;&gt;slow filter implementation&lt;/a&gt;,
we used Fig 4 to illustrate how
&lt;a href=&quot;/dsp/2017/12/30/slowfil.html&quot;&gt;it&lt;/a&gt; worked.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 4. A Time Multiplexed filter implementation&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/fir-slow-form.svg&quot; alt=&quot;&quot; width=&quot;480&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;This diagram shows data coming in from the left, and going through two tapped
delay lines.  A selector then walks through each of the samples in the
tapped delay line picking a data value.  At the same time, a separate selector
picks a value from the
&lt;a href=&quot;/dsp/2017/12/30/slowfil.html&quot;&gt;filter&lt;/a&gt;’s
&lt;a href=&quot;https://en.wikipedia.org/wiki/Impulse_response&quot;&gt;impulse response&lt;/a&gt;
coefficients.  These two values are shown multiplied together, accumulated,
and then output.&lt;/p&gt;

&lt;p&gt;To build this
&lt;a href=&quot;https://en.wikipedia.org/wiki/Linear_phase&quot;&gt;symmetric filter&lt;/a&gt;,
we’re going to first break the tapped
delay line structure into three parts, as shown in Fig 3.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 5. Breaking the data tapped delay line into three pieces&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/slowsymf-data.svg&quot; alt=&quot;&quot; width=&quot;480&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;The parts on the left and right will be implemented by block RAMs, and
data will appear to “move” through the RAMs by just adjusting the indices
used.  The data point in the middle is point of symmetry for the filter.
This point will not reside within either of the block RAMs.  Instead, we’ll
make this the last item read from the left block RAM, and place this item
into the second block RAM on any new sample.&lt;/p&gt;

&lt;p&gt;When a sample is provided, all the data will shift right by one.  That will
be our first step.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(posedge i_clk)
	if (i_ce)
		dwidx &amp;lt;= dwidx + 1&#39;b1;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Using this index we’ll write the new sample to the left data memory.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(posedge i_clk)
	if (i_ce)
		dmem1[dwidx] &amp;lt;= i_sample;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;We’ll read the mid-point sample from the last value read from this memory.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(posedge i_clk)
	if (i_reset)
		mid_sample &amp;lt;= 0;
	else if (i_ce)
		mid_sample &amp;lt;= dleft;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Finally, we’ll write that mid-point sample to the right half of memory.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(posedge i_clk)
	if (i_ce)
		dmem2[dwidx] &amp;lt;= mid_sample;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Notice that we are using the same write index for both halves of memory.
We’ll have to deal with this a bit in our next step, since we are writing
to the newest memory on the left, and half way through the memory on the right.&lt;/p&gt;

&lt;p&gt;That will handle data movement, what about reading the data?&lt;/p&gt;

&lt;p&gt;To read the data, we’ll set two data pointers–one to each block RAM–when any
new sample comes in.  These will initially
point to the extreme locations in the memory, both the oldest and the most
recent.  These pointers will then walk, in unison, towards the center data
point, as shown in Fig 5 above.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(posedge i_clk)
	if (i_ce)
	begin
		lidx &amp;lt;= dwidx; // Newest value
		ridx &amp;lt;= dwidx-(HALFTAPS[LGNMEM-1:0])+1;
	end else if (not_done_yet)
	begin
		lidx &amp;lt;= lidx - 1&#39;b1;
		ridx &amp;lt;= ridx + 1&#39;b1;
	end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The next steps with the data are fairly straight forward.  There’s not much
magic in them.  First we’ll read the data,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
begin
	dleft  &amp;lt;= dmem1[lidx];	// Left memory
	dright &amp;lt;= dmem2[ridx];	// Right memory&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;then add the two values together,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	dsum &amp;lt;= dleft + dright;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;then multiply them by the filter coefficient,
&lt;a href=&quot;/dsp/2017/09/15/fastfir.html&quot;&gt;filter&lt;/a&gt;
coefficient,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	product &amp;lt;= dsum * tap;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;and add the result to an accumulator.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	acc &amp;lt;= acc + product;
end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;You may notice that we didn’t clear the accumulator, &lt;code class=&quot;highlighter-rouge&quot;&gt;acc&lt;/code&gt;.  We’ll have to
come back to that.  You may also notice we skipped some steps along the way,
although this is the basic algorithm.  So, let’s go back a bit.&lt;/p&gt;

&lt;p&gt;We’re going to need to read the
&lt;a href=&quot;/dsp/2017/09/15/fastfir.html&quot;&gt;filter&lt;/a&gt;
coefficient before we use it.  This will involve resetting the index
to the beginning of the coefficient memory,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
if (i_ce)
begin
	tidx &amp;lt;= 0;	// Filter coefficient index&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;and then reading the next
&lt;a href=&quot;/dsp/2017/09/15/fastfir.html&quot;&gt;filter&lt;/a&gt;
coefficient on every clock subsequent clock until we’re done.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;end else begin
	tidx &amp;lt;= tidx + 1&#39;b1;
	tap &amp;lt;= cmem[tidx];	// Filter coefficient index
end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;At this point, our algorithm roughly looks like Fig 6 below.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 6. The symmetric slow filter&#39;s block diagram&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/slowsymf-blockd.svg&quot; alt=&quot;&quot; width=&quot;480&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;We read from each data block in opposite directions and added the two
values together.  We also read from our coefficient memory, and then multiplied
the
&lt;a href=&quot;/dsp/2017/09/15/fastfir.html&quot;&gt;filter&lt;/a&gt;
coefficient by the data sum.  Finally, we accumulated the products
together to create an output.&lt;/p&gt;

&lt;p&gt;We’re still missing a couple items, though.  For example, we need to
multiply our mid-point by some value.  Let’s
fix that value to be &lt;code class=&quot;highlighter-rouge&quot;&gt;2^(M-1)-1&lt;/code&gt;, also known as the maximum positive integer
that can be represented in &lt;code class=&quot;highlighter-rouge&quot;&gt;M&lt;/code&gt; signed bits.  This works because this sample
value is usually (always?) the largest value in the
&lt;a href=&quot;/dsp/2017/09/15/fastfir.html&quot;&gt;filter&lt;/a&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
if (i_reset)
	midprod &amp;lt;= 0;
else if (m_ce)
	midprod &amp;lt;= (mid_sample &amp;lt;&amp;lt; (TW-1)) - mid_sample;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;At least, that’s the basic idea of how we &lt;em&gt;want&lt;/em&gt; the
&lt;a href=&quot;/dsp/2017/09/15/fastfir.html&quot;&gt;filter&lt;/a&gt; to work.
Sadly, this simplistic approach to the algorithm is going to give us some
headaches when we actually attempt to implement it in the next section.
Why?  Although we have a conceptual idea of what we wish to accomplish,
the devil in this case lies in the details of how we handle the
pipeline scheduling.&lt;/p&gt;

&lt;h2 id=&quot;verilog-implementation&quot;&gt;Verilog Implementation&lt;/h2&gt;

&lt;p&gt;When I first set out to implement
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/slowsymf.v&quot;&gt;this filter&lt;/a&gt;,
I thought I might just quickly modify the &lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/slowfil.v&quot;&gt;generic slow
filter&lt;/a&gt;
I had &lt;a href=&quot;/dsp/2017/12/30/slowfil.html&quot;&gt;presented earlier&lt;/a&gt;.
This is basically what I just presented above in the last section.
I’m mean, all that’s required is two memory reads, a sum and then
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/slowsymf.v&quot;&gt;the filter&lt;/a&gt;
is identical to what it was
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/slowfil.v&quot;&gt;before&lt;/a&gt;.
It’s that simple, right?&lt;/p&gt;

&lt;p&gt;No.  It isn’t.&lt;/p&gt;

&lt;p&gt;As a measure of difficulty, consider this:
I’ve gotten to the point where implementing a basic
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_signal_processing&quot;&gt;DSP&lt;/a&gt;
component like this has become fairly easy and routine.  I therefore gave
myself two days to do the task, and even then I didn’t work on it full time
for both days.  Much to my surprise, I almost didn’t finish the task within
the two days I’d given to myself.&lt;/p&gt;

&lt;p&gt;Why not?&lt;/p&gt;

&lt;p&gt;It wasn’t that the filter was really all that hard to implement,
but rather the problem was scheduling the pipeline.
To understand this, let’s work from the fixed points in the schedule.&lt;/p&gt;

&lt;p&gt;The first fixed points are the memory reads.  In order to make
certain the design tools place the data and
&lt;a href=&quot;/dsp/2017/09/15/fastfir.html&quot;&gt;filter&lt;/a&gt;
coefficients into block RAM,
they can only be accessed in the simplest of ways.  Specifically, each
RAM must takes one clock cycle to read where you do nothing else with the
value read.  Yet moving the time the data were valid from the clock in the
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/slowfil.v&quot;&gt;slow filter&lt;/a&gt;,
to the next (i.e. following the summation) made for all kinds of havoc within
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/slowsymf.v&quot;&gt;my design&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;In a humble admission, I’ll admit that I almost pulled out the
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal methods&lt;/a&gt;
to &lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formally verify&lt;/a&gt;
the design after I struggled so hard getting this to work within the
&lt;a href=&quot;/dsp/2017/11/04/genfil-tb.html&quot;&gt;test bench&lt;/a&gt;.  It seems
I’ve gotten hooked on how easy it is to get a design to work using
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal methods&lt;/a&gt;.
(Yes, it is possible to &lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formally
verify&lt;/a&gt;
a digital &lt;a href=&quot;/dsp/2017/09/15/fastfir.html&quot;&gt;filter&lt;/a&gt; using
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal methods&lt;/a&gt;.  The
problem is that the multiply makes the application of
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal methods&lt;/a&gt;
difficult.  I’ll leave this concept for another day, though, specifically
for some time after I discuss the concept of abstraction in
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal verification&lt;/a&gt;.)&lt;/p&gt;

&lt;p&gt;In the end, in order to get the &lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/slowsymf.v&quot;&gt;following
design&lt;/a&gt;
to work I had to work through the
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/slowsymf.v&quot;&gt;design&lt;/a&gt;
and its &lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/bench/cpp/slowsymf_tb.cpp&quot;&gt;test
bench&lt;/a&gt;
one clock at a time, verifying every value along the way until all of a
sudden
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/slowsymf.v&quot;&gt;the design&lt;/a&gt;
passed.  While I was successful, I do have to admit that my success took more
work than I expected.  Shall we just say my performance at the task just
wasn’t as graceful as I might have liked?&lt;/p&gt;

&lt;p&gt;The key to the success of
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/slowsymf.v&quot;&gt;this design&lt;/a&gt;
lies in the pipeline schedule.  So,
as I was building this algorithm, I scribbled out the pipeline schedule
diagram shown in Fig 7.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 7. Initial Pipeline Schedule&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/slowsymf-schedule.svg&quot; alt=&quot;&quot; width=&quot;720&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;If you remember from our prior discussions of these charts, values are
shown in the column in which they are valid.  Hence &lt;code class=&quot;highlighter-rouge&quot;&gt;i_ce&lt;/code&gt; is true on the
first clock of our cycle.  At that same time, the sample value, &lt;code class=&quot;highlighter-rouge&quot;&gt;i_sample&lt;/code&gt;,
the data write index (&lt;code class=&quot;highlighter-rouge&quot;&gt;dwidx&lt;/code&gt;), mid-point sample from the last time through
(&lt;code class=&quot;highlighter-rouge&quot;&gt;mid_sample&lt;/code&gt;), and the final data value from the left block RAM (&lt;code class=&quot;highlighter-rouge&quot;&gt;dleft&lt;/code&gt;)
are also valid.  On the next clock to the right, the data values may now
be read from memory, hence &lt;code class=&quot;highlighter-rouge&quot;&gt;dmem1[dwidx]&lt;/code&gt; is valid and so forth.  On this
clock also I’ll raise an &lt;code class=&quot;highlighter-rouge&quot;&gt;m_ce&lt;/code&gt; signaling flag so I know where I am in
this portion of the pipeline.&lt;/p&gt;

&lt;p&gt;I’ve taken the time to show particular anchor points to this diagram in
red.  These are the points we worked out above in the last section.  They are
immovable in the pipeline.  Hence, following the &lt;code class=&quot;highlighter-rouge&quot;&gt;m_ce&lt;/code&gt; (first memory read
valid) cycle there’s a first data valid cycle where &lt;code class=&quot;highlighter-rouge&quot;&gt;d_ce&lt;/code&gt; is high.  This
will be the first of many such cycles.  This is followed by a summation
cycle, &lt;code class=&quot;highlighter-rouge&quot;&gt;s_ce&lt;/code&gt;, when the first data sum is true.  This is then followed
by a product cycle, &lt;code class=&quot;highlighter-rouge&quot;&gt;p_ce&lt;/code&gt;, when the first data product is true and so on.&lt;/p&gt;

&lt;p&gt;The items in black are the ones I really struggled to get right.  In
particular, the
first &lt;a href=&quot;/dsp/2017/09/15/fastfir.html&quot;&gt;filter&lt;/a&gt; coefficient
value doesn’t have to be valid until &lt;code class=&quot;highlighter-rouge&quot;&gt;s_ce&lt;/code&gt; clock.
That means its index must be valid the clock prior and &lt;em&gt;not&lt;/em&gt; the clock
prior to that.  This one little difference marked the root of my problems.&lt;/p&gt;

&lt;p&gt;But let’s get to these difficulties in order.&lt;/p&gt;

&lt;p&gt;The first order of business is to allow the user to update the
&lt;a href=&quot;/dsp/2017/09/15/fastfir.html&quot;&gt;filter&lt;/a&gt;’s
coefficients.  This is almost the same exact code as we
&lt;a href=&quot;/dsp/2017/12/30/slowfil.html&quot;&gt;discussed earlier&lt;/a&gt;,
so it really doesn’t need much comment.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	generate if (FIXED_TAPS)
	begin : SET_FIXED_TAPS

		initial $readmemh(INITIAL_COEFFS, tapmem);

	end else begin : DYNAMIC_TAP_ADJUSTMENT
		// Coef memory write index
		reg	[(LGNMEM-1):0]	tapwidx;

		initial	tapwidx = 0;
		always @(posedge i_clk)
			if(i_reset)
				tapwidx &amp;lt;= 0;
			else if (i_tap_wr)
				tapwidx &amp;lt;= tapwidx + 1&#39;b1;

		if (INITIAL_COEFFS != 0)
			initial $readmemh(INITIAL_COEFFS, tapmem);
		always @(posedge i_clk)
			if (i_tap_wr)
				tapmem[tapwidx] &amp;lt;= i_tap;
	end endgenerate&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The next order of business is to move our data pipeline.  This happens any
time a new sample is sent to
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/slowsymf.v&quot;&gt;the filter&lt;/a&gt;,
as indicated by &lt;code class=&quot;highlighter-rouge&quot;&gt;i_ce&lt;/code&gt; being high.&lt;/p&gt;

&lt;p&gt;As you may recall, the &lt;a href=&quot;/blog/2017/08/14/strategies-for-pipelining.html&quot;&gt;global pipeline
strategy&lt;/a&gt;
works quite well for digital
&lt;a href=&quot;/dsp/2017/09/15/fastfir.html&quot;&gt;filter&lt;/a&gt;.
Within this design, however, we’ll be using a &lt;a href=&quot;/blog/2017/08/14/strategies-for-pipelining.html&quot;&gt;traveling
CE&lt;/a&gt;
approach as you saw in Fig 7 above.&lt;/p&gt;

&lt;p&gt;As part of this new sample routine, we’ll increment a data write index
on every new sample.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	initial	dwidx = 0;
	always @(posedge i_clk)
	if (i_ce)
		dwidx &amp;lt;= dwidx + 1&#39;b1;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;There is no reset on this index, despite the initial value.  This lack of a
reset allows
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/slowsymf.v&quot;&gt;the filter&lt;/a&gt;
to be cleared and flushed by holding the &lt;code class=&quot;highlighter-rouge&quot;&gt;i_reset&lt;/code&gt;
and &lt;code class=&quot;highlighter-rouge&quot;&gt;i_ce&lt;/code&gt; lines high, while also forcing &lt;code class=&quot;highlighter-rouge&quot;&gt;i_sample&lt;/code&gt; to be zero for as
many clock cycles as
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/slowsymf.v&quot;&gt;the filter&lt;/a&gt;
has taps.&lt;/p&gt;

&lt;p&gt;We’ll also write our new sample to the first memory bank,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(posedge i_clk)
	if (i_ce)
		dmem1[dwidx] &amp;lt;= i_sample;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;our midpoint sample to the second memory bank,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(posedge i_clk)
	if (i_ce)
		dmem2[dwidx] &amp;lt;= mid_sample;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;and we’ll set our midpoint sample to be the last sample read from the first
memory bank, or &lt;code class=&quot;highlighter-rouge&quot;&gt;dleft&lt;/code&gt; as I’m going to call it with reference to either
of Figs 5 or 6 above.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(posedge i_clk)
	if (i_reset)
		mid_sample &amp;lt;= 0;
	else if (i_ce)
		mid_sample &amp;lt;= dleft;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Since &lt;code class=&quot;highlighter-rouge&quot;&gt;mid_sample&lt;/code&gt; doesn’t need to be constrained to ultra-simple memory
logic, it can be sensitive to the reset.  This will halve the number of
clock cycles it will take to clear
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/slowsymf.v&quot;&gt;this filter&lt;/a&gt;
during a reset, since these zeros will then feed the second half of memory.&lt;/p&gt;

&lt;p&gt;The next signal, &lt;code class=&quot;highlighter-rouge&quot;&gt;pre_acc_ce&lt;/code&gt;, is the one we are going to use to control
whether or not to accumulate a new product into our accumulator.  This is
the control value that will also keep us from accumulating past the last
valid coefficient in
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/slowsymf.v&quot;&gt;our filter&lt;/a&gt;.
For this reason, we start out by counting how many coefficients are remaining.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	assign	taps_left = (NTAPS[LGNTAPS-1:1]-tidx);
	assign	last_tap_index = (taps_left &amp;lt;= 1);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;We’ll also calculate a flag to tell us whether or not we are at the last
data index.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	assign	last_data_index= (NTAPS[LGNTAPS-1:1]-tidx &amp;lt;= 2);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Both of these values are referenced to the pipeline cycle where the index
is valid.  What that means, though, is that this measurement needs to be
propagated to through the pipeline.  This is the purpose of &lt;code class=&quot;highlighter-rouge&quot;&gt;pre_acc_ce&lt;/code&gt;,
the “pre” calculation of whether the accumulator should be updated.
On any new data, &lt;code class=&quot;highlighter-rouge&quot;&gt;pre_acc_ce[0]&lt;/code&gt; gets set to &lt;code class=&quot;highlighter-rouge&quot;&gt;1&#39;b1&lt;/code&gt;.  This starts the beginning
of the accumulator pipeline.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	initial	pre_acc_ce = 4&#39;h0;
	always @(posedge i_clk)
	if (i_reset)
		pre_acc_ce[0] &amp;lt;= 1&#39;b0;
	else if (i_ce)
		pre_acc_ce[0] &amp;lt;= 1&#39;b1;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;It then stays at one until the index for the last coefficient.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	else if ((pre_acc_ce[0])&amp;amp;&amp;amp;(!last_tap_index))
		pre_acc_ce[0] &amp;lt;= 1&#39;b1;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Here we get to one of the surprises of the algorithm.  Because the coefficient
index and the data index are off by one cycle, this &lt;code class=&quot;highlighter-rouge&quot;&gt;last_tap_index&lt;/code&gt; value
isn’t a sufficient indicator of when to turn the &lt;code class=&quot;highlighter-rouge&quot;&gt;pre_acc_ce&lt;/code&gt; value off.
Instead, we’ll turn it off as long as we aren’t starting around again on
the next incoming sample.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	else if (!m_ce)
		pre_acc_ce[0] &amp;lt;= 1&#39;b0;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This &lt;code class=&quot;highlighter-rouge&quot;&gt;pre_acc_ce&lt;/code&gt; value now needs to be propagated through our pipeline.
We’ll use a simple shift register structure for this purpose.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(posedge i_clk)
	if (i_reset)
		pre_acc_ce[3:1] &amp;lt;= 3&#39;b0;
	else
		pre_acc_ce[3:1] &amp;lt;= { pre_acc_ce[2:1],
			((m_ce)||((pre_acc_ce[0])&amp;amp;&amp;amp;(!last_tap_index))) };
	// Where ...
	// pre_acc_ce[0] means the data index is valid
	// pre_acc_ce[1] means the data values are valid, tap index is valid
	// pre_acc_ce[2] means the data sum and tap value are valid
	// pre_acc_ce[3] means that the product is valid&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;We can now interpret &lt;code class=&quot;highlighter-rouge&quot;&gt;pre_acc_ce&lt;/code&gt; as follows.  If &lt;code class=&quot;highlighter-rouge&quot;&gt;pre_acc_ce[0]&lt;/code&gt; is true,
the data &lt;em&gt;index&lt;/em&gt; is valid.  If &lt;code class=&quot;highlighter-rouge&quot;&gt;pre_acc_ce[1]&lt;/code&gt; is true, the data &lt;em&gt;values&lt;/em&gt; are
valid.  If &lt;code class=&quot;highlighter-rouge&quot;&gt;pre_acc_ce[2]&lt;/code&gt; is true, the sum is valid and if &lt;code class=&quot;highlighter-rouge&quot;&gt;pre_acc_ce[3]&lt;/code&gt;
is true then the product is valid and may be accumulated.&lt;/p&gt;

&lt;p&gt;You’ll see how this works more in a moment.&lt;/p&gt;

&lt;p&gt;We’ll next focus on the data read indices.  These will continue to follow the
left and right convention from Figs 5 and 6 above.  Hence we’ll have a left
index, &lt;code class=&quot;highlighter-rouge&quot;&gt;lidx&lt;/code&gt;, and a right index &lt;code class=&quot;highlighter-rouge&quot;&gt;ridx&lt;/code&gt;.  On any reset, these are set to zero,
although this is really more for form than anything else.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	initial	lidx = 0;
	initial	ridx = 0;
	always @(posedge i_clk)
	if (i_reset)
	begin
		lidx &amp;lt;= 0;
		ridx &amp;lt;= 0;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Then, on any new sample, the left data index, &lt;code class=&quot;highlighter-rouge&quot;&gt;lidx&lt;/code&gt; is set to point to the
newest value just written to memory.  The right half data index is a touch
more complicated–and took me many trials to get right.  This index is
given by back tracking from the oldest value by half our
&lt;a href=&quot;/dsp/2017/09/15/fastfir.html&quot;&gt;filter&lt;/a&gt; length.  This
would’ve been the entire size of the second memory, save that we are forcing the
memory to have a power of two size, while the &lt;code class=&quot;highlighter-rouge&quot;&gt;NTAPS&lt;/code&gt; can be any arbitrary
odd number.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	end else if (i_ce)
	begin
		lidx &amp;lt;= dwidx; // Newest value
		ridx &amp;lt;= dwidx-(HALFTAPS[LGNMEM-1:0])+1;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;As a last step, we’ll step the indices as long as this isn’t the last
data index.  The left index steps backwards from the newest value to older
values, while the right index steps forwards from the oldest index to the
newer index.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	end else if ((m_ce)||(!last_data_index))
	begin
		lidx &amp;lt;= lidx - 1&#39;b1;
		ridx &amp;lt;= ridx + 1&#39;b1;
	end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Keep in mind, the &lt;code class=&quot;highlighter-rouge&quot;&gt;last_data_index&lt;/code&gt; criteria here is &lt;em&gt;key&lt;/em&gt;.  In particular,
we are about to read the left data value, &lt;code class=&quot;highlighter-rouge&quot;&gt;dleft&lt;/code&gt;, from the left memory
based upon this index.  This will turn into the mid point value on the
next sample.  For this reason, the indices cannot be allowed to just free
run.&lt;/p&gt;

&lt;p&gt;The second remarkable piece of this logic is the &lt;code class=&quot;highlighter-rouge&quot;&gt;m_ce&lt;/code&gt; criteria.  Our
&lt;code class=&quot;highlighter-rouge&quot;&gt;last_data_index&lt;/code&gt; flag depends upon the cofficient index, not the data index.
This coefficient index isn’t (yet) valid on the &lt;code class=&quot;highlighter-rouge&quot;&gt;m_ce&lt;/code&gt; cycle.  Hence, we need
to continue to walk the index forward even before the first tap index is
valid.  (Yes, this was another one of those details that surprised me as
I built this.)&lt;/p&gt;

&lt;p&gt;A very similar piece of logic is used to determine the
&lt;a href=&quot;/dsp/2017/09/15/fastfir.html&quot;&gt;filter&lt;/a&gt;
coefficient index.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	initial	tidx = 0;
	always @(posedge i_clk)
	if (i_reset)
		tidx &amp;lt;= 0;
	else if (m_ce)
		tidx &amp;lt;= 0;
	else if (!last_tap_index)
		tidx &amp;lt;= tidx + 1&#39;b1;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;While it might look like we might just let this value run as well, keep
in mind that we are using the
&lt;a href=&quot;/dsp/2017/09/15/fastfir.html&quot;&gt;filter&lt;/a&gt;
coefficient index as an indicator of when to stop accumulating.  For this
reason, this index also stops at the end of the coefficient memory.&lt;/p&gt;

&lt;p&gt;That’s the data and coefficient index calculation.  Let’s move on to the
memory read cycle(s).  We’ll mark this cycle with an &lt;code class=&quot;highlighter-rouge&quot;&gt;m_ce&lt;/code&gt; flag, as shown
in our pipeline schedule in Fig 7 above, indicating that this is the first
cycle the memory data is valid.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	initial	m_ce = 1&#39;b0;
	always @(posedge i_clk)
		m_ce &amp;lt;= (i_ce)&amp;amp;&amp;amp;(!i_reset);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;On this cycle we’ll read from the two block RAMs of data.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	initial	dleft  = 0;
	initial	dright = 0;
	always @(posedge i_clk)
	begin
		dleft  &amp;lt;= dmem1[lidx];
		dright &amp;lt;= dmem2[ridx];
	end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Following the outline in Fig 7, the next pipeline cycle and flag is the
data valid cycle, &lt;code class=&quot;highlighter-rouge&quot;&gt;d_ce&lt;/code&gt;.  This follows the &lt;code class=&quot;highlighter-rouge&quot;&gt;m_ce&lt;/code&gt;
flag, and like it this is only valid for one clock cycle.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	initial	d_ce = 0;
	always @(posedge i_clk)
		d_ce &amp;lt;= (m_ce)&amp;amp;&amp;amp;(!i_reset);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Now we can read the coefficient index,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	initial	tap = 0;
	always @(posedge i_clk)
		tap &amp;lt;= tapmem[tidx[(LGNTAPS-2):0]];&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;and add the data values together.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	initial	dsum = 0;
	always @(posedge i_clk)
	if (i_reset)
		dsum &amp;lt;= 0;
	else
		dsum   &amp;lt;= dleft + dright;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;We’ll use the &lt;code class=&quot;highlighter-rouge&quot;&gt;s_ce&lt;/code&gt; signal to mark that the first data summation is valid.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	initial	s_ce = 0;
	always @(posedge i_clk)
		s_ce &amp;lt;= (d_ce)&amp;amp;&amp;amp;(!i_reset);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The data sum times the
&lt;a href=&quot;/dsp/2017/09/15/fastfir.html&quot;&gt;filter&lt;/a&gt;
coefficient is our product value.  If this looks
familiar, it should–this matches the &lt;a href=&quot;/dsp/2017/12/30/slowfil.html&quot;&gt;slow
filter&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/slowfil.v&quot;&gt;code&lt;/a&gt;, and
was drawn from it.  This should also matches our discusion in the last section.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	initial	product = 0;
	always @(posedge i_clk)
		product &amp;lt;= tap * dsum;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The &lt;code class=&quot;highlighter-rouge&quot;&gt;midprod&lt;/code&gt; value is different.  &lt;code class=&quot;highlighter-rouge&quot;&gt;midprod&lt;/code&gt; is the product of the mid-point
sample, &lt;code class=&quot;highlighter-rouge&quot;&gt;mid_sample&lt;/code&gt; times the maximum positive integer value that fits
in &lt;code class=&quot;highlighter-rouge&quot;&gt;TW&lt;/code&gt; bits, or &lt;code class=&quot;highlighter-rouge&quot;&gt;2^(TW-1)-1&lt;/code&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	initial	midprod = 0;
	always @(posedge i_clk)
	if (i_reset)
		midprod &amp;lt;= 0;
	else if (m_ce)
		midprod &amp;lt;= { {(OW-IW-TW+1){mid_sample[IW-1]}},
					mid_sample, {(TW-1){1&#39;b0}}}
				-{ {(OW-IW){mid_sample[IW-1]} }, mid_sample};&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;That then leads us right into the accumulator.  There are three parts to
this.  First, we’ll set it to zero on any reset.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	initial	r_acc = 0;
	always @(posedge i_clk)
	if (i_reset)
		r_acc &amp;lt;= 0;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Second, on the &lt;code class=&quot;highlighter-rouge&quot;&gt;s_ce&lt;/code&gt; cycle (see Fig 7 above), we’ll initialize this
accumulator to be our midpoint product.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	else if (s_ce)
		r_acc &amp;lt;= midprod;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Third, on every subsequent sample with a valid product, we’ll add the
product to our accumulator.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	else if (pre_acc_ce[3])
		r_acc &amp;lt;= r_acc + { {(OW-(IW+TW)){product[(IW+TW-1)]}},
						product };&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Finally, on the same sample that we initialize our accumulator with the
mid-point product, we’ll
set our result to be the last value that had been in the accumulator.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	initial	o_result = 0;
	always @(posedge i_clk)
	if (s_ce)
		o_result &amp;lt;= r_acc;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;In a similar fashion, we’ll set our output clock enable strobe, so that
the rest of the signal processing pipeline can continue to follow the
&lt;a href=&quot;/blog/2017/08/14/strategies-for-pipelining.html&quot;&gt;global CE strategy&lt;/a&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	initial	o_ce = 1&#39;b0;
	always @(posedge i_clk)
		o_ce &amp;lt;= (s_ce)&amp;amp;&amp;amp;(!i_reset);

endmodule&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;That’s all it takes to build a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Linear_phase&quot;&gt;symmetric filter&lt;/a&gt;
running &lt;code class=&quot;highlighter-rouge&quot;&gt;N&lt;/code&gt; times slower than the system clock.&lt;/p&gt;

&lt;p&gt;Perhaps the biggest lesson learned to draw from this discussion is how
dependent I was on the
&lt;a href=&quot;/blog/2017/06/21/looking-at-verilator.html&quot;&gt;simulator&lt;/a&gt;
to get particular values right.
For example, did you notice the strange logic on &lt;code class=&quot;highlighter-rouge&quot;&gt;pre_acc_ce&lt;/code&gt;?  Or how about
the fact that the &lt;code class=&quot;highlighter-rouge&quot;&gt;last_data_index&lt;/code&gt; compared against two instead of zero or
one?  Or perhaps that the &lt;code class=&quot;highlighter-rouge&quot;&gt;taps_left&lt;/code&gt; calculation didn’t depend upon the
total number of taps, but rather &lt;code class=&quot;highlighter-rouge&quot;&gt;(N-1)/2&lt;/code&gt;?  (Remember, &lt;code class=&quot;highlighter-rouge&quot;&gt;N&lt;/code&gt;, the number of
coefficients, &lt;em&gt;must&lt;/em&gt; be an odd number.)  All of these values were determined
with the help of running many simulations.&lt;/p&gt;

&lt;h2 id=&quot;test-bench-performance&quot;&gt;Test Bench Performance&lt;/h2&gt;

&lt;p&gt;When it comes to building the &lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/bench/cpp/slowsymf_tb.cpp&quot;&gt;test bench for this
system&lt;/a&gt;,
there wasn’t a lot of work to be done–thanks to the work we did building
a generic filtering
&lt;a href=&quot;/dsp/2017/11/04/genfil-tb.html&quot;&gt;test bench&lt;/a&gt;
some time earlier.  Even better, if you
&lt;a href=&quot;http://meldmerge.org&quot;&gt;meld&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/bench/cpp/slowsymf_tb.cpp&quot;&gt;this test bench driver&lt;/a&gt;
against the
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/bench/cpp/slowfil_tb.cpp&quot;&gt;test bench driver&lt;/a&gt;
for the
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/slowfil.v&quot;&gt;slow filter&lt;/a&gt;,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;meld slowfil_tb.cpp slowsymf_tb.cpp&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;you’ll see only a very small, limited number of (key) differences.  While most
of these are concerned with adjusting
&lt;a href=&quot;/dsp/2017/09/15/fastfir.html&quot;&gt;filter&lt;/a&gt;
length related parameters, there is one particular difference worth commenting
on.  That difference is in the &lt;code class=&quot;highlighter-rouge&quot;&gt;testload()&lt;/code&gt; function.&lt;/p&gt;

&lt;p&gt;As you may recall from our discussion of the
&lt;a href=&quot;/dsp/2017/11/04/genfil-tb.html&quot;&gt;generic filtering test
harness&lt;/a&gt;, the &lt;code class=&quot;highlighter-rouge&quot;&gt;testload&lt;/code&gt;
method allows us to load coefficients into the
&lt;a href=&quot;/dsp/2017/09/15/fastfir.html&quot;&gt;filter&lt;/a&gt;,
and then test the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Impulse_response&quot;&gt;impulse response&lt;/a&gt;
of the filter to insure those coefficients were loaded correctly.  In our
case, this also gives us a chance to verify that the filter’s response is
&lt;a href=&quot;https://en.wikipedia.org/wiki/Linear_phase&quot;&gt;symmetric&lt;/a&gt;
as we had intended.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;        &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;    &lt;span class=&quot;nf&quot;&gt;testload&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nlen&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;c1&quot;&gt;// Load the given coefficients into the filter
&lt;/span&gt;		&lt;span class=&quot;n&quot;&gt;load&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nlen&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

		&lt;span class=&quot;c1&quot;&gt;// Loop through and test each coefficient
&lt;/span&gt;		&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NTAPS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
			&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;m&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;If the coefficient comes before the midpoint, it should match the data
given to this function and passed to &lt;code class=&quot;highlighter-rouge&quot;&gt;load&lt;/code&gt; above.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;			&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MIDP&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
				&lt;span class=&quot;n&quot;&gt;assert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Likewise if this is the midpoint, then the coefficient should be equal to
the fixed value, &lt;code class=&quot;highlighter-rouge&quot;&gt;(1&amp;lt;&amp;lt;(TW-1))-1&lt;/code&gt;, where &lt;code class=&quot;highlighter-rouge&quot;&gt;TW&lt;/code&gt; remains the maximum number of
bits in any coefficient.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;			&lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MIDP&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
				&lt;span class=&quot;n&quot;&gt;assert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;TW&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;On the other side of the midpoint, the coefficients should read back in
reverse order.  In other words, here is where we check the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Linear_phase&quot;&gt;symmetry&lt;/a&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;			&lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NTAPS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt;
				&lt;span class=&quot;n&quot;&gt;assert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NTAPS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Finally, anything beyond the number of taps in the filter should return zero.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;			&lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;
				&lt;span class=&quot;n&quot;&gt;assert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
		&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Once this is accomplished, we can now use our &lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/bench/cpp/slowsymf_tb.cpp&quot;&gt;test bench&lt;/a&gt;
&lt;a href=&quot;/dsp/2017/11/04/genfil-tb.html&quot;&gt;structure&lt;/a&gt;
to measure
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/slowsymf.v&quot;&gt;the filter&lt;/a&gt;’s
performance against the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Low-pass_filter&quot;&gt;lowpass filter&lt;/a&gt;
configuration we’ve been testing against.  The result is a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Stopband&quot;&gt;stopband&lt;/a&gt;
rejection roughly between -55 and -54 dB, which is just what we were expecting.&lt;/p&gt;

&lt;p&gt;That’s not that bad, especially if you consider that we only used half as many
clock cycles as the last &lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/slowfil.v&quot;&gt;slow filter
we studied&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/slowsymf.v&quot;&gt;This filter
implementation&lt;/a&gt;
marks one of those times where a little bit of
engineering up front will spare you a lot of design resources later.  That’s
why we added a touch more mathematics above to &lt;a href=&quot;/dsp/2017/09/15/fastfir.html&quot;&gt;what we had done
before&lt;/a&gt;.  Sure,
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/slowsymf.v&quot;&gt;our
implementation&lt;/a&gt;
is a touch more complicated than &lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/slowfil.v&quot;&gt;the last slow
filter&lt;/a&gt;.
But look at what we gained: twice the performance!  That’s what makes
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/slowsymf.v&quot;&gt;this filtering
implementation&lt;/a&gt;
valuable.  How applicable is it?  This approach applies to all filters
designed via the &lt;em&gt;optimal&lt;/em&gt; &lt;a href=&quot;https://en.wikipedia.org/wiki/Parks-McClellan_filter_design_algorithm&quot;&gt;Parks and McClellan filter design
algorithm&lt;/a&gt;.
In other words, this is almost a universally applicable optimization among
&lt;a href=&quot;https://en.wikipedia.org/wiki/Finite_impulse_response&quot;&gt;FIR&lt;/a&gt;
&lt;a href=&quot;/dsp/2017/09/15/fastfir.html&quot;&gt;filter&lt;/a&gt; implementations.&lt;/p&gt;

&lt;p&gt;As I mentioned above, we have yet to discuss many other types of
&lt;a href=&quot;/dsp/2017/09/15/fastfir.html&quot;&gt;filtering&lt;/a&gt;
implementations.  Perhaps this simplest
&lt;a href=&quot;/dsp/2017/09/15/fastfir.html&quot;&gt;filter&lt;/a&gt;
to build next would be a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Half-band_filter&quot;&gt;half band filter&lt;/a&gt;.  For
certain &lt;a href=&quot;/dsp/2017/09/15/fastfir.html&quot;&gt;filters&lt;/a&gt;, a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Half-band_filter&quot;&gt;half band filter&lt;/a&gt;
implementation can be built for half again as many resources as we just used.&lt;/p&gt;

&lt;p&gt;We’ll have to come back again on another day, though, in order to demonstrate
and discuss some of these other
&lt;a href=&quot;/dsp/2017/09/15/fastfir.html&quot;&gt;filters&lt;/a&gt;.&lt;/p&gt;
&lt;hr /&gt;&lt;p&gt;&lt;em&gt;There is one glory of the sun, and another glory of the moon, and another glory of the stars: for one star differeth from another star in glory.  (1Cor 15:41)&lt;/em&gt;</description>
        <pubDate>Thu, 17 May 2018 00:00:00 -0400</pubDate>
        <link>https://zipcpu.com/dsp/2018/05/17/slowsymf.html</link>
        <guid isPermaLink="true">https://zipcpu.com/dsp/2018/05/17/slowsymf.html</guid>
        
        
        <category>dsp</category>
        
      </item>
    
      <item>
        <title>Updated Projects List</title>
        <description>&lt;p&gt;If you haven’t noticed, there’s a
&lt;a href=&quot;/projects.html&quot;&gt;link&lt;/a&gt;
on the left of each page to the
&lt;a href=&quot;/projects.html&quot;&gt;projects&lt;/a&gt;
I’ve been working on.
&lt;a href=&quot;/projects.html&quot;&gt;That page&lt;/a&gt;
doesn’t get updated nearly as often as it should be.  However, I thought I’d
let you know that I updated it today.&lt;/p&gt;

&lt;p&gt;Perhaps the biggest new item is that I’m now teaching a two-day formal
verification course.  If you’d me to come and teach formal verification
at your workplace, please let me know.  I’m also prepared to offer individual
lessons via video teleconferencing.&lt;/p&gt;

&lt;p&gt;Other new projects listed include many of the projects you’ve seen presented
&lt;a href=&quot;https://zipcpu.com/&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Chief among these are the &lt;a href=&quot;/dsp/dsp.html&quot;&gt;DSP posts&lt;/a&gt;.
Hence, the page now lists the
&lt;a href=&quot;https://github.com/ZipCPU/cordic&quot;&gt;sine wave generators&lt;/a&gt; we’ve discussed
on the blog,
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters&quot;&gt;filters&lt;/a&gt;,
and
&lt;a href=&quot;https://github.com/ZipCPU/interpolation&quot;&gt;interpolators&lt;/a&gt;.  Further, the
&lt;a href=&quot;https://github.com/ZipCPU/dblclockfft&quot;&gt;FFT&lt;/a&gt;
is undergoing a
&lt;a href=&quot;https://github.com/ZipCPU/dblclockfft/tree/dev&quot;&gt;fascinating transformation&lt;/a&gt;
to make it more general purpose, but that’s far from complete.&lt;/p&gt;

&lt;p&gt;I also added a desscription to some of the items that had no description
before.  Perhaps the most interesting of these is the GPS schooled clock–a
basic project that can lock an internal FPGA counter to the PPS output of a
PMod GPS.&lt;/p&gt;

&lt;p&gt;Feel free to check out this new and updated project page, and by all means
please write if you find any broken links, have any questions, comments,
or suggestions!&lt;/p&gt;
&lt;hr /&gt;&lt;p&gt;&lt;em&gt;The preacher sought to find out acceptable words: and that which was written was upright, even words of truth. (Eccl 12:10)&lt;/em&gt;</description>
        <pubDate>Mon, 30 Apr 2018 00:00:00 -0400</pubDate>
        <link>https://zipcpu.com/blog/2018/04/30/updated-projects.html</link>
        <guid isPermaLink="true">https://zipcpu.com/blog/2018/04/30/updated-projects.html</guid>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>Aggregating verified modules together</title>
        <description>&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 1. The ZipCPU&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/zipcpu.svg&quot; alt=&quot;Block diagram of the ZipCPU, showing five pipeline stages&quot; width=&quot;360&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;If you’ve been following my work with the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;,
you’ll know that I have formally verified &lt;a href=&quot;/blog/2018/01/22/formal-progress.html&quot;&gt;all of the leaf
modules&lt;/a&gt;,
and that I am now working on verifying
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;the CPU&lt;/a&gt;
&lt;a href=&quot;/blog/2018/04/02/formal-cpu-bugs.html&quot;&gt;as a whole&lt;/a&gt;.
By “leaf module”, I mean a design component that references no other design
components.
You might also remember that &lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;I am rather new to formal
verification&lt;/a&gt;,
having only picked it up within this last year.  Verifying the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
may be the most complex design I’ve tried to verify yet.&lt;/p&gt;

&lt;p&gt;Prior to my attempts at formally verifying the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;,
the most difficult proof I had worked on was for a proprietary block
floating point module.  That module assigned a single exponent for all
of the values within a block of &lt;code class=&quot;highlighter-rouge&quot;&gt;2^N&lt;/code&gt; numbers, and then output the input
numbers sequentially together with their assigned floating point value.  Like
the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;,
it also involved proving a module with a leaf module underneath it.
The alignment was very difficult to get right in that implementation
and so I dependended heavily upon the &lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formally verified
properties&lt;/a&gt;
of those two modules in order to have the assurance that the component
even worked.&lt;/p&gt;

&lt;p&gt;Along the way, I’ve learned that there are some tricks to aggregating
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formally verified&lt;/a&gt;
submodules together in order to prove the whole.  I’ve now learned two
particular techniques, abstraction and invariants, to help
control the complexity of a formal proof.
Today’s discussion will focus on invariants.  If the
&lt;a href=&quot;https://www.blueletterbible.org/kjv/jas/4/15&quot;&gt;Lord is willing&lt;/a&gt;,
we’ll come back and discuss how to use abstraction, and present several
examples of it.&lt;/p&gt;

&lt;p&gt;I would love to declare, before starting out, that I am an expert on these
techniques.  I’m not.  Perhaps if I had found some article
or set of articles describing them I might be able to declare some amount
of expertise.  Sadly, while I found
a small number of articles describing invariants, I struggled to relate the
concepts presented within those articles to the
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal verification&lt;/a&gt;
problems
I was dealing with.  The one source I found to guide me along this road
was a presentation from &lt;a href=&quot;https://www.onespin.com&quot;&gt;OneSpin Solutions&lt;/a&gt; at
&lt;a href=&quot;https://dvcon.org&quot;&gt;DVCon&lt;/a&gt; 2018 in San Jose.&lt;/p&gt;

&lt;p&gt;So with credit to &lt;a href=&quot;https://www.onespin.com&quot;&gt;OneSpin Solutions&lt;/a&gt;, here’s
what I have learned about
invariants and how they apply to
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;Formal Verification&lt;/a&gt;.
More than that, I’ll
try to keep this presentation simple enough to be understandable, and
focused on how these topics apply to the
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal verification&lt;/a&gt;
of complex RTL modules.&lt;/p&gt;

&lt;h2 id=&quot;formal-property-review&quot;&gt;Formal Property Review&lt;/h2&gt;

&lt;p&gt;If you are coming in to the discussion late, then there are two concepts
you must understand in order to follow the discussion below.  These are
the &lt;code class=&quot;highlighter-rouge&quot;&gt;assume()&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;assert()&lt;/code&gt; System Verilog operators.  I like to explain
these with a set of diagrams describing the state of a design at any
given point in time.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 2. Formal regions of relevance&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/formal-bmc.svg&quot; alt=&quot;&quot; width=&quot;360&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;One such example state diagram is shown in Fig 2.  Consider every point in
this image as representing one state of all the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flip-flop_(electronics)&quot;&gt;flip-flops&lt;/a&gt;
in your design.  Any change to one of the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flip-flop_(electronics)&quot;&gt;flip-flops&lt;/a&gt;
in your design will move your system’s state to a new point on the diagram.&lt;/p&gt;

&lt;p&gt;Several parts of this diagram are worth noting.&lt;/p&gt;

&lt;p&gt;First, note that your design starts from an initial state, as defined by the
&lt;code class=&quot;highlighter-rouge&quot;&gt;initial&lt;/code&gt; statements within your design.  From this point, the inputs to your
design together with the logic within your design will cause the design
to move from one state to another.&lt;/p&gt;

&lt;p&gt;Second, note that there are three different types of states you can be in.
The first set of states are the set of “valid” states.  These are all of the
states that may be reached from your initial state without violating any
&lt;code class=&quot;highlighter-rouge&quot;&gt;assert&lt;/code&gt;ions within your design.  These are shown in green.&lt;/p&gt;

&lt;p&gt;The second set of states are those shown in red.  These are the “illegal” or
“invalid” states.  These are defined by all those states that violate an
&lt;code class=&quot;highlighter-rouge&quot;&gt;assert()&lt;/code&gt; statements within your design.
Your goal, using formal methods, will be to prove that you cannot cross from
a point in the set of valid states to one of the invalid states.&lt;/p&gt;

&lt;p&gt;There is a third set of states.  This set is shown by the largest region
containing all of the others.  This is the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Universe_(mathematics)&quot;&gt;universe&lt;/a&gt;
of all possible sets of
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flip-flop_(electronics)&quot;&gt;flip-flop&lt;/a&gt;
(register) combinations of values within your design.  Initially, this set is
defined by every
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flip-flop_(electronics)&quot;&gt;flip-flop&lt;/a&gt;
combination in your design.  Hence if you have &lt;code class=&quot;highlighter-rouge&quot;&gt;N&lt;/code&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flip-flop_(electronics)&quot;&gt;flip-flops&lt;/a&gt;
in your design, then without any further assumptions there are initially
&lt;code class=&quot;highlighter-rouge&quot;&gt;2^N&lt;/code&gt; states in this set.  Not all of these states will be &lt;em&gt;reachable&lt;/em&gt; from
your initial state.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: left&quot;&gt;&lt;caption&gt;Fig 3. The Effect of an Assumption&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/formal-bmc-assume.svg&quot; alt=&quot;&quot; width=&quot;360&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;Within your design, you have two sorts of statements you can make about the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flip-flop_(electronics)&quot;&gt;flip-flops&lt;/a&gt;
within your design.  The first is the &lt;code class=&quot;highlighter-rouge&quot;&gt;assume()&lt;/code&gt; statement.  This reduces the
size of the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Universe_(mathematics)&quot;&gt;universe&lt;/a&gt;
of values your
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flip-flop_(electronics)&quot;&gt;flip-flops&lt;/a&gt;
may be set to.&lt;/p&gt;

&lt;p&gt;To use the &lt;a href=&quot;/zipcpu/2018/04/17/ziptimer.html&quot;&gt;example of a
counter&lt;/a&gt;,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	if (i_reset)
		r_value &amp;lt;= 0;
	else if (i_start)
		r_value &amp;lt;= TIMEOUT;
	else if (r_value != 0)
		r_value &amp;lt;= r_value - 1&#39;b1;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;we might assume that the &lt;code class=&quot;highlighter-rouge&quot;&gt;i_reset&lt;/code&gt; signal is always zero.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(*)
	assume(!i_reset);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This will restrict the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Universe_(mathematics)&quot;&gt;universe&lt;/a&gt;
of possibilities to only those where &lt;code class=&quot;highlighter-rouge&quot;&gt;i_reset&lt;/code&gt; is
always zero.&lt;/p&gt;

&lt;p&gt;The goal of
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal methods&lt;/a&gt;
is to examine &lt;em&gt;every possible&lt;/em&gt; state your design can enter into in order
to prove that your design will never reach an &lt;em&gt;invalid&lt;/em&gt; state.
As I’m sure you can imagine, this task can be a challenge.  In general, this
challenge is &lt;code class=&quot;highlighter-rouge&quot;&gt;NP-hard&lt;/code&gt;–the computational complexity is roughly exponential
in the size of the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Universe_(mathematics)&quot;&gt;universe&lt;/a&gt;
within your design.  Hence, the smaller you can make the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Universe_(mathematics)&quot;&gt;universe&lt;/a&gt;
of possibilities the easier it will be to verify a design.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 4. The Effect of an Assertion&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/formal-bmc-assert.svg&quot; alt=&quot;&quot; width=&quot;360&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;The second basic formal statement is the &lt;code class=&quot;highlighter-rouge&quot;&gt;assert()&lt;/code&gt; statement.  Unlike the
&lt;code class=&quot;highlighter-rouge&quot;&gt;assume()&lt;/code&gt; statement which limits the size of the search space, the &lt;code class=&quot;highlighter-rouge&quot;&gt;assert()&lt;/code&gt;
statement declares particular states within that
&lt;a href=&quot;https://en.wikipedia.org/wiki/Universe_(mathematics)&quot;&gt;universe&lt;/a&gt;
are somehow “illegal” as shown in Fig 4.  When you use
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal methods&lt;/a&gt;,
your goal will be to guarantee your design remains in a legal state.&lt;/p&gt;

&lt;p&gt;If we return to the
&lt;a href=&quot;/zipcpu/2018/04/17/ziptimer.html&quot;&gt;timer example&lt;/a&gt;
above, we might assert that value of the counter is never one greater than
&lt;code class=&quot;highlighter-rouge&quot;&gt;TIMEOUT&lt;/code&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(*)
	assert(r_value != TIMEOUT+1);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;When applying
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal methods&lt;/a&gt;
to this example, the engine will quickly point out that
the initial state may lie within the red or illegal states–since we did nothing
to restrict &lt;code class=&quot;highlighter-rouge&quot;&gt;r_value&lt;/code&gt;s contents initially.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;initial r_value = 0;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;These two operators, &lt;code class=&quot;highlighter-rouge&quot;&gt;assume&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;assert&lt;/code&gt;, alone should be enough to get you
started with
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal methods&lt;/a&gt;,
and there’s a lot you can do with them.  However, if you want to &lt;em&gt;prove&lt;/em&gt; that
your design will work for all time rather than just the first &lt;code class=&quot;highlighter-rouge&quot;&gt;S&lt;/code&gt; time steps,
then you will need to apply the
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal method&lt;/a&gt;
called
&lt;a href=&quot;/blog/2018/03/10/induction-exercise.html&quot;&gt;induction&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/blog/2018/03/10/induction-exercise.html&quot;&gt;Induction&lt;/a&gt;
starts by assuming your design is somewhere among the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Universe_(mathematics)&quot;&gt;universe&lt;/a&gt;
of all possible states, and that the initial state the engine has chosen
is not illegal.  Its first
step is to create &lt;code class=&quot;highlighter-rouge&quot;&gt;S&lt;/code&gt; time steps where your design stays out of the
illegal set of states.  Then, on the &lt;code class=&quot;highlighter-rouge&quot;&gt;S+1&lt;/code&gt; time step, it tries to see if it
is possible to enter into the set of illegal states.&lt;/p&gt;

&lt;p&gt;The difficult part of this
&lt;a href=&quot;/blog/2018/03/10/induction-exercise.html&quot;&gt;inductive step&lt;/a&gt;
is that the formal engine cannot tell the difference between reachable states
and unreachable states.  This can be &lt;a href=&quot;/blog/2018/03/10/induction-exercise.html&quot;&gt;particularly
problematic&lt;/a&gt;
for the new user of
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal methods&lt;/a&gt;
to understand.
A common refrain is, “how did the formal engine put my design into this
state?  There’s no way it can get there!”&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: left&quot;&gt;&lt;caption&gt;Fig 5. The Lesson of Induction&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/formal-induction-soln.svg&quot; alt=&quot;&quot; width=&quot;360&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;Addressing this problem was the subject of a
&lt;a href=&quot;/blog/2018/03/10/induction-exercise.html&quot;&gt;prior article&lt;/a&gt;.
In that article, I explained that you must use either an &lt;code class=&quot;highlighter-rouge&quot;&gt;assume&lt;/code&gt; or an &lt;code class=&quot;highlighter-rouge&quot;&gt;assert&lt;/code&gt;
to keep the formal engine from reaching any unreachable states, or you will
never be able to fully &lt;em&gt;prove&lt;/em&gt; your design meets the properties you have
asserted for all time.&lt;/p&gt;

&lt;p&gt;Following our example of a timer, the formal engine might pick a value for
&lt;code class=&quot;highlighter-rouge&quot;&gt;r_value&lt;/code&gt; that was &lt;code class=&quot;highlighter-rouge&quot;&gt;TIMEOUT+S+2&lt;/code&gt;.  It would then follow &lt;code class=&quot;highlighter-rouge&quot;&gt;r_value&lt;/code&gt; for
&lt;code class=&quot;highlighter-rouge&quot;&gt;S&lt;/code&gt; steps until &lt;code class=&quot;highlighter-rouge&quot;&gt;r_value&lt;/code&gt; was &lt;code class=&quot;highlighter-rouge&quot;&gt;TIMEOUT+2&lt;/code&gt;.  On the next step, our property
that &lt;code class=&quot;highlighter-rouge&quot;&gt;(r_value != TIMEOUT+1)&lt;/code&gt; would be violated.&lt;/p&gt;

&lt;p&gt;To fix this, one would need to assert instead that &lt;code class=&quot;highlighter-rouge&quot;&gt;r_value &amp;lt;= TIMEOUT&lt;/code&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(*)
	assert(r_value &amp;lt;= TIMEOUT);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This makes the size of the “red” area large enough to include the whole
&lt;a href=&quot;https://en.wikipedia.org/wiki/Universe_(mathematics)&quot;&gt;universe&lt;/a&gt;, as shown
in Fig 5.  To follow the consequence of this in our example above,
&lt;code class=&quot;highlighter-rouge&quot;&gt;r_value&lt;/code&gt; would never be allowed to be &lt;code class=&quot;highlighter-rouge&quot;&gt;TIMEOUT+S+2&lt;/code&gt;.  It would only be allowed
to have a valid value.&lt;/p&gt;

&lt;p&gt;To know which of the two, &lt;code class=&quot;highlighter-rouge&quot;&gt;assert&lt;/code&gt; or &lt;code class=&quot;highlighter-rouge&quot;&gt;assume&lt;/code&gt;, is appropriate at any given
time, I’ve always used what I call the &lt;em&gt;master rule of Formal Verification&lt;/em&gt;
shown in Fig 6: &lt;em&gt;assume inputs&lt;/em&gt;, then &lt;em&gt;assert&lt;/em&gt; properties of both
&lt;em&gt;internal states and outputs&lt;/em&gt;.&lt;/p&gt;
&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 6. Master rule of Formal Verification&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/fv-master-rule.svg&quot; alt=&quot;&quot; width=&quot;280&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;This rule has served me well for all of my
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal verification&lt;/a&gt;
efforts to date.  Now that I’ve discovered I need to aggregate modules together,
I’ve had to learn some of the fine nuances of this rule.  These nuances
are the subject of the rest of this article.&lt;/p&gt;

&lt;h2 id=&quot;the-concept-of-an-invariant&quot;&gt;The Concept of an Invariant&lt;/h2&gt;

&lt;p&gt;What the master rule of
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal verification&lt;/a&gt;
doesn’t capture is how you deal
with things that have already been proven.  For example, let’s suppose &lt;code class=&quot;highlighter-rouge&quot;&gt;A&lt;/code&gt;
is a set of assumptions, and &lt;code class=&quot;highlighter-rouge&quot;&gt;B&lt;/code&gt; is a set of assertions.  Once you’ve proven
that &lt;code class=&quot;highlighter-rouge&quot;&gt;A&lt;/code&gt; implies &lt;code class=&quot;highlighter-rouge&quot;&gt;B&lt;/code&gt;, which I shall write as &lt;code class=&quot;highlighter-rouge&quot;&gt;A-&amp;gt;B&lt;/code&gt;, then you shouldn’t need
to prove it again.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: left&quot;&gt;&lt;caption&gt;Fig 7. (Some caption)&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/formal-invariants.svg&quot; alt=&quot;&quot; width=&quot;360&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;This is the concept of an Invariant.  Once you know that &lt;code class=&quot;highlighter-rouge&quot;&gt;A-&amp;gt;B&lt;/code&gt;, then &lt;code class=&quot;highlighter-rouge&quot;&gt;A-&amp;gt;B&lt;/code&gt;
becomes an invariant of your design.  Instead of reproving it, you may now treat
it as an assumption.  This becomes especially useful when trying to deal
with complex proofs. If you can reduce the complexity, you can then verify
larger and larger designs.&lt;/p&gt;

&lt;p&gt;There are two situations where I have found to apply this.  The first is
that of a parent module with a child (or leaf) module underneath it.  The
second place is when the proof of a design can be broken into separate sections.
I’ve encountered both while trying to verify the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;.  We’ll
examine each in turn.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 8. ZipCPU&#39;s module hierarchy&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/files-zipcpu-proved.svg&quot; alt=&quot;&quot; width=&quot;240&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;To explain the first situation, consider the module hierarchy (file structure)
of the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
shown in Fig 8.  The
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; consists of a
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/dev/rtl/core/zipcpu.v&quot;&gt;master CPU&lt;/a&gt;
file, an &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/dev/rtl/core/idecode.v&quot;&gt;instruction
decoder&lt;/a&gt;, an
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/dev/rtl/core/cpuops.v&quot;&gt;ALU&lt;/a&gt; with a
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/dev/rtl/core/mpyop.v&quot;&gt;multiply component&lt;/a&gt;
within it, a &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/dev/rtl/ex/wbdblpriarb.v&quot;&gt;twin bus
arbiter&lt;/a&gt;,
and one of two &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/dev/rtl/core/memops.v&quot;&gt;memory
controllers&lt;/a&gt;.
I use the red bar in Fig 8 to indicate the
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal properties&lt;/a&gt;
within the design.  Normally these properties are found at the end of the
source file.  You’d therefore normally expect this red bar to be at the bottom
of each file within the diagram.  However, since the concept of invariants
turns these properties on end, I show the red bar in this figure at the top
of the file–for illustration purposes.&lt;/p&gt;

&lt;p&gt;The other three components of the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; were abstracted.
These were the
&lt;a href=&quot;/zipcpu/2017/11/18/wb-prefetch.html&quot;&gt;prefetch&lt;/a&gt;,
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/div.v&quot;&gt;divide&lt;/a&gt;, and
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/mpyop.v&quot;&gt;multiply&lt;/a&gt;.
These are shown in Fig 8 as empty files with dotted lines around them,
indicating that due to the abstraction they have very little logic remaining
within them.  You can find their abstract representations in
my &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/dev/bench/formal&quot;&gt;bench/formal&lt;/a&gt;
directory.  These also made the proof easier, but for now we’ll leave the
mechanics of this for a topic for a future article.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: left&quot;&gt;&lt;caption&gt;Fig 9. Invariants applied to a parent/leaf module hierarchy&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/invariance-external.svg&quot; alt=&quot;&quot; width=&quot;480&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;To understand how I applied the principle of invariants to this design,
consider Fig 9.  This shows a parent module and a leaf or child module–both
with assertions and assumptions within them.&lt;/p&gt;

&lt;p&gt;In my first step, I verified that the leaf module works.  This is shown in the
left side of Fig 9.  During this step, I ignored the parent module, and only
proved that if the child’s assumptions held then the child would never enter
into an illegal state.&lt;/p&gt;

&lt;p&gt;Once the assumptions and module logic had been used to prove the assertions
within the module, I then switched my focus to the parent.  This is shown
on the right of Fig 9.  In this case, I no longer needed to prove the properties
of the child.  Instead, I needed to prove the properties of the parent.  To do
this, I asserted that the assumptions of the child held, and then assumed that
the assertions therefore held as well.&lt;/p&gt;

&lt;p&gt;Hmm, that statement was about as confusing as some of the mathematical articles
I’ve read on this topic.  Let me try explaining that again.&lt;/p&gt;

&lt;p&gt;Suppose we let &lt;code class=&quot;highlighter-rouge&quot;&gt;LA&lt;/code&gt; refer to the set of assumptions within the leaf module, and
&lt;code class=&quot;highlighter-rouge&quot;&gt;LB&lt;/code&gt; refer to the set of assertions within the leaf module.  By
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formally verifying&lt;/a&gt;
that module, I’ve now proved that &lt;code class=&quot;highlighter-rouge&quot;&gt;LA -&amp;gt; LB&lt;/code&gt;.
Unwrapping this a touch, this is equivalent to the
statement that either &lt;code class=&quot;highlighter-rouge&quot;&gt;LA&lt;/code&gt; is false, or &lt;code class=&quot;highlighter-rouge&quot;&gt;LB&lt;/code&gt; must be true: &lt;code class=&quot;highlighter-rouge&quot;&gt;(!LA)||(LB)&lt;/code&gt;.
Said another way, either one of the assumptions of this module must be false,
or all the assertions must be true.&lt;/p&gt;

&lt;p&gt;Now I want to move on to the parent module.  In this case, I have the additional
assumptions &lt;code class=&quot;highlighter-rouge&quot;&gt;PA&lt;/code&gt; and assertions &lt;code class=&quot;highlighter-rouge&quot;&gt;PB&lt;/code&gt; from the parent and I would like to prove
that &lt;code class=&quot;highlighter-rouge&quot;&gt;PA-&amp;gt;PB&lt;/code&gt;.
However, I also need to deal with the leaf module.  For the leaf module, I
know that &lt;code class=&quot;highlighter-rouge&quot;&gt;LA-&amp;gt;LB&lt;/code&gt;.  What I don’t know is whether or not &lt;code class=&quot;highlighter-rouge&quot;&gt;LA&lt;/code&gt; holds since
it consists of values provided by the parent module.  Unless and until I know
that &lt;code class=&quot;highlighter-rouge&quot;&gt;LA&lt;/code&gt; holds, I really know nothing about &lt;code class=&quot;highlighter-rouge&quot;&gt;LB&lt;/code&gt;.  Further, since the wires
composing &lt;code class=&quot;highlighter-rouge&quot;&gt;LA&lt;/code&gt; come from the parent, what I really need to do is to &lt;em&gt;assert&lt;/em&gt;
these properties hold in order to guarantee the proper functioning of the leaf.
Hence, I will now assert &lt;code class=&quot;highlighter-rouge&quot;&gt;LA&lt;/code&gt; and assume &lt;code class=&quot;highlighter-rouge&quot;&gt;LB&lt;/code&gt;.  This is backwards from how I
treated these components before.  As a result, I will assume &lt;code class=&quot;highlighter-rouge&quot;&gt;PA&amp;amp;LB&lt;/code&gt; and assert
&lt;code class=&quot;highlighter-rouge&quot;&gt;PB&amp;amp;LA&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The fascinating part of this is that the master rule of
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal verification&lt;/a&gt;
still applies.  We’re still &lt;em&gt;assuming&lt;/em&gt; the inputs to the parent module and
&lt;em&gt;asserting&lt;/em&gt; the properties of the internal state and any outputs.  How can this
be?  It works because the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flip-flop_(electronics)&quot;&gt;flip-flops&lt;/a&gt;
composing the internal state of the parent module are the input
connections to the child.  Hence the assumptions of the child’s inputs
are now outputs from the parent and so they may be asserted.  Likewise the
child’s outputs are now the parent’s inputs, and so it makes sense to make
assumptions about them.&lt;/p&gt;

&lt;p&gt;It this is still confusing, relax, I’ll show some code snippets
to illustrate how I applied this concept in the next section.&lt;/p&gt;

&lt;p&gt;The second way that invariants can be used within a design is within a given
design component (module).  In my case, it was within the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/dev/rtl/core/zipcpu.v&quot;&gt;ZipCPU core&lt;/a&gt;.
In this case, we’ll separate the assertions into groups of increasingly
complex logic, called stages in Fig 10 below.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 10. Invariants applied within a file&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/invariance-internal.svg&quot; alt=&quot;&quot; width=&quot;720&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Let’s call these sets of assertions &lt;code class=&quot;highlighter-rouge&quot;&gt;B0&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;B1&lt;/code&gt;, and &lt;code class=&quot;highlighter-rouge&quot;&gt;B2&lt;/code&gt;.  For the first
formal proof, we’ll prove that the assumptions together with the design
logic prove the &lt;code class=&quot;highlighter-rouge&quot;&gt;B0&lt;/code&gt; property, &lt;code class=&quot;highlighter-rouge&quot;&gt;A-&amp;gt;B0&lt;/code&gt;.  Within the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/dev/rtl/core/zipcpu.v&quot;&gt;ZipCPU core&lt;/a&gt;,
I call these &lt;code class=&quot;highlighter-rouge&quot;&gt;PHASE_ONE_ASSERT&lt;/code&gt;ions.  Once we know that &lt;code class=&quot;highlighter-rouge&quot;&gt;A-&amp;gt;B0&lt;/code&gt;,
we turn our attention to proving &lt;code class=&quot;highlighter-rouge&quot;&gt;B1&lt;/code&gt;.  In that case, we now know that
&lt;code class=&quot;highlighter-rouge&quot;&gt;A&lt;/code&gt; is true by assumption, but we also know that &lt;code class=&quot;highlighter-rouge&quot;&gt;B0&lt;/code&gt; is true by the implication
we just proved.  So for this second stage proof, we assume &lt;code class=&quot;highlighter-rouge&quot;&gt;A&lt;/code&gt; &lt;em&gt;and&lt;/em&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;B0&lt;/code&gt; and
attempt to prove &lt;code class=&quot;highlighter-rouge&quot;&gt;B1&lt;/code&gt;.  We can then repeat this again, assuming
&lt;code class=&quot;highlighter-rouge&quot;&gt;A&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;B0&lt;/code&gt;, and now &lt;code class=&quot;highlighter-rouge&quot;&gt;B1&lt;/code&gt; and proving &lt;code class=&quot;highlighter-rouge&quot;&gt;B2&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;If you’ve examined the (current)
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/dev/rtl/core/zipcpu.v&quot;&gt;formal proof&lt;/a&gt;
of the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; (it’s still a work in
progress), you may have noticed that I am using both of these methods.
First, I am verifying that the component pieces to the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
work as desired.  Then, I am aggregating those into the proof of the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; as a whole.  Second, within the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;, I’ve created two parts to the
proof: &lt;code class=&quot;highlighter-rouge&quot;&gt;B0&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;B1&lt;/code&gt;.  I’m expecting to create a third and possibly fourth
component later.  Currently, I can prove both &lt;code class=&quot;highlighter-rouge&quot;&gt;B0&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;B1&lt;/code&gt; using
&lt;a href=&quot;https://symbiyosys.readthedocs.io/en/latest&quot;&gt;SymbiYosys&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;According to &lt;a href=&quot;https://www.onespin.com&quot;&gt;OneSpin Solutions&lt;/a&gt;, this method can
increase the depth of the proof or rather the number of state transitions that
can be examined in a reasonable amount of time by perhaps a thousand fold.
These are their numbers, though.  In my own experience, I can only say that
formally verifying the second stage of the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; used to take longer than all
night.  (I’m not really sure how long–I never let it finish.)  It now takes
just over an hour.&lt;/p&gt;

&lt;h2 id=&quot;how-this-concept-appears-in-verilog&quot;&gt;How this concept appears in Verilog&lt;/h2&gt;

&lt;p&gt;The previous sections have discussed a lot about
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal verification&lt;/a&gt;
in the abstract.  They’ve
been so far from coded reality that I would imagine I’ve now left several
readers wondering what I’m talking about.  So let’s bring these abstract
concepts to reality, and discuss how they might look within a piece
of Verilog code.&lt;/p&gt;

&lt;p&gt;We’ll start with a fairly plain Verilog module.  Almost all of my modules have
the following rough format.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;// Copyright statement
`default_nettype	none
//
module thismodule( ...);
	// Core logic
`ifdef	FORMAL
	// Formal properties

	always @(*)
		assume(i_some_input);
	always @(*)
		assert(o_some_output);
`endif
endmodule&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;They start with a copyright statement, and then declare the &lt;code class=&quot;highlighter-rouge&quot;&gt;default_nettype&lt;/code&gt;
to be none instead of wire.  (This catches a &lt;em&gt;lot&lt;/em&gt; of bugs.)  The module
definition then follows with the core logic within it.  Following the module
logic, there’s an &lt;code class=&quot;highlighter-rouge&quot;&gt;ifdef FORMAL&lt;/code&gt; delimited section ending just before the
&lt;code class=&quot;highlighter-rouge&quot;&gt;endmodule&lt;/code&gt; on the last line of the file.  Inside that section I
place any assumptions or assertions regarding the logic above.  Indeed,
if you browse through any of the code I’ve formally verified, you’ll find
this to be the common form.&lt;/p&gt;

&lt;p&gt;If it is possible that this might be a leaf or child module to some other
module within a formal proof, then I’ll make some adjustments to the formal
section.  First, I’ll use a synthesis define to indicate &lt;code class=&quot;highlighter-rouge&quot;&gt;THISMODULE&lt;/code&gt; is
the module being verified.  Inside the module’s yosys script, I’ll also
modify the &lt;code class=&quot;highlighter-rouge&quot;&gt;read_verilog&lt;/code&gt; command to include a &lt;code class=&quot;highlighter-rouge&quot;&gt;-D THISMODULE&lt;/code&gt;.  So, for
example, within the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/dev/rtl/core/pipemem.v&quot;&gt;pipelined memory controller
module&lt;/a&gt;,
there’s a check for whether or not &lt;code class=&quot;highlighter-rouge&quot;&gt;PIPEMEM&lt;/code&gt; is defined.  Likewise, you
can see the definition within its &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/dev/bench/formal/pipemem.ys&quot;&gt;its yosys
script&lt;/a&gt;.
Second, I’ll define macros which I can then use to reference either the
&lt;code class=&quot;highlighter-rouge&quot;&gt;assume&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;assert&lt;/code&gt; statements.  If &lt;code class=&quot;highlighter-rouge&quot;&gt;THISMODULE&lt;/code&gt; is defined, these
will refer to &lt;code class=&quot;highlighter-rouge&quot;&gt;assume&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;assert&lt;/code&gt; as expected.  If not, they’ll be
swapped.  Then I rewrite the formal properties to use these macros.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;`ifdef	FORMAL
`ifdef	THISMODULE
`define	ASSUME	assume
`define	ASSERT	assert
`else
`define	ASSUME	assert
`define	ASSERT	assume
`endif
	// Formal properties
	always @(*)
		`ASSUME(i_some_input);
	always @(*)
		`ASSERT(o_some_output);
`endif&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This is how I handle creating the logic pictured in Fig 9 above within any
of the non-abstracted child modules.&lt;/p&gt;

&lt;p&gt;Perhaps the best example of how this might be useful is in the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;’s
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/dev/rtl/core/pipemem.v&quot;&gt;pipelined memory
controller&lt;/a&gt;.
The “contract” the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
has with the user is that it will not
&lt;a href=&quot;https://meltdownattack.com&quot;&gt;speculatively execute memory operations&lt;/a&gt;–since the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
places both memory and peripherals on the same bus.  Bus operations may be
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;pipelined&lt;/a&gt;,
meaning that multiple reads may be ongoing at any given time.  Now consider,
what would happen if one of those reads set the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Program_counter&quot;&gt;program counter&lt;/a&gt;?
There would be no way to undo any of the other reads that might be in
progress by this point.&lt;/p&gt;

&lt;p&gt;For example, consider the following string of loads.  In the
&lt;a href=&quot;/zipcpu/2018/01/01/zipcpu-isa.html&quot;&gt;ZipCPU ISA&lt;/a&gt;,
an &lt;code class=&quot;highlighter-rouge&quot;&gt;LW&lt;/code&gt; instruction loads a word of data from the bus into the register given
as the second argument.  (&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
instructions read left to right.)  The second to the last of these loads reads
a value into the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Program_counter&quot;&gt;program counter&lt;/a&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-asm&quot; data-lang=&quot;asm&quot;&gt;LW (R0),R1	; Load word from the address in R0 into the R1 register
LW 4(R0),R2	; R2 &amp;lt;- Mem[R0+4]
LW 8(R0),R3
LW 12(R0),R4
LW 16(R0),R5
LW 20(R0),PC	; PC &amp;lt;= Mem[R0+20]
LW 24(R0),R6	; Must not issue until the last load has completed&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Any time the &lt;a href=&quot;https://en.wikipedia.org/wiki/Program_counter&quot;&gt;program counter
(PC)&lt;/a&gt;
is set, the
CPU
jumps to a new instruction.  Hence, this memory read into the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Program_counter&quot;&gt;PC&lt;/a&gt;
is really a jump instruction.&lt;/p&gt;

&lt;p&gt;Should the CPU initiate the read into &lt;code class=&quot;highlighter-rouge&quot;&gt;R6&lt;/code&gt;?  No.  Not until the read into the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Program_counter&quot;&gt;PC&lt;/a&gt; completes.&lt;/p&gt;

&lt;p&gt;To check for this, the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/dev/rtl/core/pipemem.v&quot;&gt;memory
controller&lt;/a&gt;
assumes that any read into the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Program_counter&quot;&gt;program counter&lt;/a&gt;
must be the last read in a sequence.  To
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formally prove&lt;/a&gt;
this in an
&lt;a href=&quot;/blog/2018/03/10/induction-exercise.html&quot;&gt;inductive manner&lt;/a&gt;,
I need to check via assertions that the nothing in the
pipeline of ongoing reads contains a read into the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Program_counter&quot;&gt;program counter&lt;/a&gt;.
Once proven, the controller then asserts that if any output is to the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Program_counter&quot;&gt;program counter&lt;/a&gt;
then it must be the last return value in the sequence.  When this
component is aggregated, the “check every FIFO element” code is quietly
removed, being replaced only be the final assertion on the output.  This
final assertion, however, has been replaced by this process with an assumption
that no longer needs to be checked–simplifying the proof of the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
as a whole.&lt;/p&gt;

&lt;p&gt;The second method of applying invariants is the application within a given
file, as shown in Fig 10 above.  In this case, you want to prove several
sets of assertions.  Within the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/dev/rtl/core/zipcpu.v&quot;&gt;core&lt;/a&gt;,
I call these &lt;code class=&quot;highlighter-rouge&quot;&gt;PHASE_ONE&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;PHASE_TWO&lt;/code&gt;, and so on.
Associated with each phase is an assertion macro, &lt;code class=&quot;highlighter-rouge&quot;&gt;PHASE_ONE_ASSERT&lt;/code&gt;,
&lt;code class=&quot;highlighter-rouge&quot;&gt;PHASE_TWO_ASSERT&lt;/code&gt;, etc.  To then verify the component, you’d run it through
the formal engine twice: first as is, to test all of the phase one assertions,
and then again with &lt;code class=&quot;highlighter-rouge&quot;&gt;PHASE_TWO&lt;/code&gt; defined in order to test the phase two
assertions.  The second set of assertions are excluded from being evaluated
during the first set by a synthesis &lt;code class=&quot;highlighter-rouge&quot;&gt;ifdef&lt;/code&gt; directive.&lt;/p&gt;

&lt;p&gt;You can see the
&lt;a href=&quot;https://symbiyosys.readthedocs.io/en/latest&quot;&gt;SymbiYosys&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/dev/bench/formal/zipcpu.sby&quot;&gt;script for this here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The relevant code, shown below, was lifted from the beginning of the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;’s &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/dev/rtl/core/zipcpu.v&quot;&gt;formal properties
section&lt;/a&gt;.
It starts out with a commented list of all of the formal phases supported by
the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/dev/rtl/core/zipcpu.v&quot;&gt;module&lt;/a&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;`ifdef	FORMAL
//
// PHASE_X definitions control our assertion logic below.  They are to be
// defined by the synthesizer
//
// `define PHASE_TWO
// `define PHASE_THREE
// `define PHASE_FOUR
//&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;These aren’t strictly necessary, but they remind me which defines I am
supporting.&lt;/p&gt;

&lt;p&gt;Then each of the phases is given its own assertion macro.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;`define	PHASE_ONE_ASSERT	assert
`define	PHASE_TWO_ASSERT	assert
`define	PHASE_THR_ASSERT	assert
//&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;If &lt;code class=&quot;highlighter-rouge&quot;&gt;PHASE_TWO&lt;/code&gt; is defined, the &lt;code class=&quot;highlighter-rouge&quot;&gt;PHASE_ONE_ASSERT&lt;/code&gt; macro is then redefined as
an assumption.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;`ifdef	PHASE_TWO
`undef	PHASE_ONE_ASSERT
`define	PHASE_ONE_ASSERT	assume&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Likewise, if &lt;code class=&quot;highlighter-rouge&quot;&gt;PHASE_THREE&lt;/code&gt; is also defined then the &lt;code class=&quot;highlighter-rouge&quot;&gt;PHASE_TWO_ASSERT&lt;/code&gt;
is redefined to be an assumption.  This process then repeats for all of the
phases supported by the design.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;`ifdef	PHASE_THREE
`undef	PHASE_TWO_ASSERT
`define	PHASE_TWO_ASSERT	assume

`ifdef	PHASE_FOUR
`undef	PHASE_THR_ASSERT
`define	PHASE_THR_ASSERT	assume
`endif // PHASE_FOUR
`endif // PHASE_THREE
`endif // PHASE_TWO&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;At this point, the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/dev/rtl/core/zipcpu.v&quot;&gt;formal
properties&lt;/a&gt;
can proceed in sections.  The first section makes any input assumptions
necessary.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	// An example assumption
	always @(*)
		assume(i_some_input);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Then the first set of assertions follows these assumptions.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	// An example assertion
	always @(*)
		`PHASE_ONE_ASSERT(o_some_output);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This set of assertions is created
using the &lt;code class=&quot;highlighter-rouge&quot;&gt;PHASE_ONE_ASSERT&lt;/code&gt; macro.  That will allow us to replace these
assertions with assumptions in the next pass–once they’ve been proven
true in a first pass.&lt;/p&gt;

&lt;p&gt;Later, we can split into a second section of assertions–but only after
we’ve used the formal tools to verify the first set of assertions, and only
if &lt;code class=&quot;highlighter-rouge&quot;&gt;PHASE_TWO&lt;/code&gt; is defined.  In this latter section, assertions are created
using the &lt;code class=&quot;highlighter-rouge&quot;&gt;PHASE_TWO_ASSERT&lt;/code&gt; macro.  Further, in order to get into this
section the &lt;code class=&quot;highlighter-rouge&quot;&gt;PHASE_ONE_ASSERT&lt;/code&gt; macro used the previous section will have
been redefined to be an &lt;code class=&quot;highlighter-rouge&quot;&gt;assume&lt;/code&gt; statement instead of the original &lt;code class=&quot;highlighter-rouge&quot;&gt;assert&lt;/code&gt;
statement.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;`ifdef	PHASE_TWO
	always @(*)
		`PHASE_TWO_ASSERT(o_some_other_output);
`endif // PHASE_TWO
`endif // FORMAL&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;In the case of the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;,
the second phase of
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal verification&lt;/a&gt;
includes several free variables (&lt;a href=&quot;http://www.clifford.at/yosys/&quot;&gt;yosys&lt;/a&gt;’s
&lt;code class=&quot;highlighter-rouge&quot;&gt;$anyconst&lt;/code&gt;) used to track an arbitrary instruction from an arbitrary address
working its way through the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;’s
logic.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	assign	f_const_insn    = $anyconst;
	assign	f_const_addr    = $anyconst;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Using this method, I can reconstruct the operands for any operation
before that operation is issued, and verify that they have the right values.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(posedge i_clk)
	if // details
	begin
		if // more details ...
		begin
			// Check that the first operand matches
			if (fc_rA)
				`PHASE_TWO_ASSERT(f_Av == op_Av);
			// Now check the second operand
			`PHASE_TWO_ASSERT(f_Bv == op_Bv);
		end
	end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;If you’ll recall from the article describing the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;’s
&lt;a href=&quot;/zipcpu/2018/01/01/zipcpu-isa.html&quot;&gt;instruction set&lt;/a&gt;,
almost all
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
instructions have the basic form: &lt;code class=&quot;highlighter-rouge&quot;&gt;OP.C Ra,Rb+I&lt;/code&gt;, where &lt;code class=&quot;highlighter-rouge&quot;&gt;Ra&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;Rb&lt;/code&gt; are
arbitrary registers, and &lt;code class=&quot;highlighter-rouge&quot;&gt;I&lt;/code&gt; is some immediate constant.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 11. ZipCPU&#39;s ALU stage in context&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/cpu-bypass.svg&quot; alt=&quot;&quot; width=&quot;640&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Prior to entering the
&lt;a href=&quot;/zipcpu/2017/08/11/simple-alu.html&quot;&gt;ALU&lt;/a&gt;
stage, the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
adds the &lt;code class=&quot;highlighter-rouge&quot;&gt;Rb&lt;/code&gt; register value and &lt;code class=&quot;highlighter-rouge&quot;&gt;I&lt;/code&gt; together.  Then, while waiting for the
&lt;a href=&quot;/zipcpu/2017/08/11/simple-alu.html&quot;&gt;ALU&lt;/a&gt;
stage to become available, any write to either &lt;code class=&quot;highlighter-rouge&quot;&gt;Ra&lt;/code&gt; or &lt;code class=&quot;highlighter-rouge&quot;&gt;Rb&lt;/code&gt; adjusts these
values.&lt;/p&gt;

&lt;p&gt;What makes this difficult is that, in order to keep clock speed high, there’s
no opportunity to re-add the immediate constant &lt;code class=&quot;highlighter-rouge&quot;&gt;I&lt;/code&gt; to &lt;code class=&quot;highlighter-rouge&quot;&gt;Rb&lt;/code&gt;–that would take an
extra clock tick.  Dealing with this requires some careful pipeline stall
logic, and getting this logic right has been
tricky.  By allowing the formal engine to pick an arbitrary pipeline state
and then examine an arbitrary instruction going into the
&lt;a href=&quot;/zipcpu/2017/08/11/simple-alu.html&quot;&gt;ALU&lt;/a&gt;,
I can guarantee that the &lt;code class=&quot;highlighter-rouge&quot;&gt;Ra&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;Rb+I&lt;/code&gt; operands are valid no matter
which instruction precedes them.&lt;/p&gt;

&lt;p&gt;Searching through all of the possibilities of these free variables
can be expensive.  Indeed, this was the phase that was taking many hours
of processing as I was working on verifying
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;this core&lt;/a&gt;
module within the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;.  Now, using this method of
invariants, the entire formal verification of the (still not quite complete
properties of the)
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
takes less than two hours.&lt;/p&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;Invariants are only one method of handling formal complexity when aggregating
multiple modules together.  As I mentioned in the opening, I am by no means
an expert in
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal verification&lt;/a&gt;,
and so this is only my first application of
the principle of invariants to any project–in this case the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;.
However, even in the case of the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;,
the value of using invariants has saved many, many
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal verification&lt;/a&gt;
CPU cycles.&lt;/p&gt;

&lt;p&gt;We’ll have to return to this topic later in order to handle the concept of
abstraction in
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal methods&lt;/a&gt;.
Abstraction may be an even more powerful concept than invariants.
As you may remember from above, I’ve been using abstracted components to
represent the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/dev/bench/formal/abs_prefetch.v&quot;&gt;prefetch&lt;/a&gt;,
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/dev/bench/formal/abs_mpy.v&quot;&gt;multiply&lt;/a&gt;,
and
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/dev/bench/formal/abs_div.v&quot;&gt;divide&lt;/a&gt;
components.  As another illustration, consider this: when
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formally verifying&lt;/a&gt;
any container of the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;,
whether the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/zipsystem.v&quot;&gt;ZipSystem&lt;/a&gt;,
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/zipbones.v&quot;&gt;ZipBones&lt;/a&gt;,
or some yet to be determined container, I’m anticipating being able to
replace the entire complicated
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
core with an abstracted version of it, and then to be able to prove
the formal properties of the wrapper in question.&lt;/p&gt;

&lt;hr /&gt;&lt;p&gt;&lt;em&gt;And that ye study to be quiet, and to do your own business, and to work with your own hands, as we commanded you (1Thes 4:11)&lt;/em&gt;</description>
        <pubDate>Mon, 23 Apr 2018 00:00:00 -0400</pubDate>
        <link>https://zipcpu.com/formal/2018/04/23/invariant.html</link>
        <guid isPermaLink="true">https://zipcpu.com/formal/2018/04/23/invariant.html</guid>
        
        
        <category>formal</category>
        
      </item>
    
      <item>
        <title>ZipTimer: A simple countdown timer</title>
        <description>&lt;p&gt;If you are a beginning
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
designer, the first example you will be given to learn is that of a counter.
It’s sort of a tradition.  Class room exercises all illustrate concepts
with simple counters.  If you ask a question, the instructor will go to the
board and start his explanation with a counter.  At least, that’s what I would
do if I trying to teach an Verilog concept.&lt;/p&gt;

&lt;p&gt;But just how useful is a counter in the end anyway?&lt;/p&gt;

&lt;p&gt;Let’s try examining a
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/ziptimer.v&quot;&gt;counter&lt;/a&gt;
all the way from an irrelevant classroom
discussion to a vital system component.&lt;/p&gt;

&lt;p&gt;How can this be?  Well, one
peripheral necessary to any
&lt;a href=&quot;https://en.wikipedia.org/wiki/Computer_multitasking&quot;&gt;multitasking&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Operating_System&quot;&gt;operating system&lt;/a&gt;, whether
&lt;a href=&quot;http://www.unix.org/what_is_unix.html&quot;&gt;Unix&lt;/a&gt;,
&lt;a href=&quot;https://en.wikipedia.org/wiki/Linux&quot;&gt;Linux&lt;/a&gt;, Windows, or some other
&lt;a href=&quot;https://en.wikipedia.org/wiki/Operating_System&quot;&gt;O/S&lt;/a&gt;, is an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Programmable_interval_timer&quot;&gt;interval timer&lt;/a&gt;.
An &lt;a href=&quot;https://en.wikipedia.org/wiki/Programmable_interval_timer&quot;&gt;interval timer&lt;/a&gt;
is little more than a reconfigurable counter.  All it does is issue an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interrupt&quot;&gt;interrupt&lt;/a&gt;
to the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;
at a periodic interval.&lt;/p&gt;

&lt;p&gt;Embedded systems, such as those found within
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;’s,
have an additional timing
need.  These systems often need to insert known delays between different
operations.  Instead of an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Programmable_interval_timer&quot;&gt;interval timer&lt;/a&gt;,
these systems need what are known as
&lt;a href=&quot;https://en.wikipedia.org/wiki/Programmable_interval_timer&quot;&gt;“one-shot” timers&lt;/a&gt;.
Once programmed, they generate an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interrupt&quot;&gt;interrupt&lt;/a&gt;
after the programmed delay takes place and then they return to idle.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 1. The ZipSystem&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/zipsystem.svg&quot; alt=&quot;&quot; width=&quot;480&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;The
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; wrapper known as the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/zipsystem.v&quot;&gt;ZipSystem&lt;/a&gt;
has three such timers within it, shown in Fig 1 as “Generic Timers (x3)”.
I call these timers
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/ziptimer.v&quot;&gt;ZipTimers&lt;/a&gt;.
Each of these
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/ziptimer.v&quot;&gt;ZipTimers&lt;/a&gt;
supports generating either a regular
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interrupt&quot;&gt;interrupt&lt;/a&gt;
or a one-shot delay based
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interrupt&quot;&gt;interrupt&lt;/a&gt;.  These
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/ziptimer.v&quot;&gt;ZipTimers&lt;/a&gt;
have been a part of the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/zipsystem.v&quot;&gt;ZipSystem&lt;/a&gt;
since I started.  Their simplicity makes them perfect
candidates for beginner exercises, and even better candidates for learning
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal verification&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/ziptimer.v&quot;&gt;ZipTimer&lt;/a&gt;
has two capabilities beyond the traditional beginner’s counter
exercise.  These are first the ability to be programmed over a &lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;wishbone
bus&lt;/a&gt;,
and second the ability to
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interrupt&quot;&gt;interrupt&lt;/a&gt; the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Soft_microprocessor&quot;&gt;CPU&lt;/a&gt;
when the specified delay runs out.&lt;/p&gt;

&lt;p&gt;Therefore, let’s examine this &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/ziptimer.v&quot;&gt;timer
peripheral&lt;/a&gt;
as an exercise in learning Verilog,
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal verification&lt;/a&gt;,
and connecting a simple item to a bus using
&lt;a href=&quot;/zipcpu/2017/10/05/autofpga-intro.html&quot;&gt;AutoFPGA&lt;/a&gt;.
Along the way, I’ll do my best to avoid calling this a “counter example”.&lt;/p&gt;

&lt;h2 id=&quot;the-beginners-exercise&quot;&gt;The Beginner’s Exercise&lt;/h2&gt;

&lt;p&gt;Hopefully everyone reading this blog has at one time built a countdown timer
in Verilog.  Indeed, I use a basic countdown timer as one of the first examples
in the &lt;a href=&quot;/projects.html&quot;&gt;Formal Verification course&lt;/a&gt;
I now teach.  Below is the simple example timer that we’ll start
with today.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 2. A Countdown Timer&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/timer-oneshot.svg&quot; alt=&quot;&quot; width=&quot;248&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;initial	r_value = 0;
always @(posedge i_clk)
	if (i_start)
		r_value &amp;lt;= TIMEOUT;
	else if (r_value != 0)
		r_value &amp;lt;= r_value - 1&#39;b1;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This counter starts at zero.  Any time an &lt;code class=&quot;highlighter-rouge&quot;&gt;i_start&lt;/code&gt; signal takes place, the
counter is set to &lt;code class=&quot;highlighter-rouge&quot;&gt;TIMEOUT&lt;/code&gt; and then counts down to zero, as illustrated in
Fig 2.  Note that
setting this counter to &lt;code class=&quot;highlighter-rouge&quot;&gt;TIMEOUT&lt;/code&gt; doesn’t guarantee that it will take
&lt;code class=&quot;highlighter-rouge&quot;&gt;TIMEOUT&lt;/code&gt; clock ticks until it returns to zero–it is possible the &lt;code class=&quot;highlighter-rouge&quot;&gt;i_start&lt;/code&gt;
signal resets this counter back to &lt;code class=&quot;highlighter-rouge&quot;&gt;TIMEOUT&lt;/code&gt; before it hits zero.&lt;/p&gt;

&lt;p&gt;We’ll also create an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interrupt&quot;&gt;interrupt&lt;/a&gt;
signal that we will set anytime the counter becomes zero.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;initial	o_int &amp;lt;= 1&#39;b0;
always @(posedge i_clk)
	o_int &amp;lt;= (r_value == 1);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;That’s not all that hard, right?&lt;/p&gt;

&lt;p&gt;Did you notice the subtlety associated with checking &lt;code class=&quot;highlighter-rouge&quot;&gt;r_value==1&lt;/code&gt; here?
One of my readers pointed this out.  If &lt;code class=&quot;highlighter-rouge&quot;&gt;i_start&lt;/code&gt; happens to be true on the
same cycle that &lt;code class=&quot;highlighter-rouge&quot;&gt;r_value==1&lt;/code&gt;, then &lt;code class=&quot;highlighter-rouge&quot;&gt;o_int&lt;/code&gt; might be true on a clock cycle
when &lt;code class=&quot;highlighter-rouge&quot;&gt;r_value != 0&lt;/code&gt;.  Yes, this is a bug.  It’ll come back in the next section
as well.  However, I’m going to leave this bug in place because this was how I
originally designed the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/ziptimer.v&quot;&gt;ZipTimer&lt;/a&gt;–with
this bug within it.  (Oops!) It wasn’t until years later when I attempted to
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formally verify&lt;/a&gt; the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/ziptimer.v&quot;&gt;timer
code&lt;/a&gt;
presented below that I discovered this subtlety.&lt;/p&gt;

&lt;p&gt;For now, let’s just peel this onion back a bit further.&lt;/p&gt;

&lt;p&gt;The problem with the above implementation of a counter is that it isn’t very
reusable.  If you are going to generate a counter that will be
&lt;a href=&quot;https://en.wikipedia.org/wiki/Programmable_interval_timer&quot;&gt;programmable&lt;/a&gt;,
then you’ll want to add a
&lt;a href=&quot;/zipcpu/2017/05/29/simple-wishbone.html&quot;&gt;bus interface &lt;/a&gt;.
If we use the
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;wishbone bus&lt;/a&gt;,
then anytime &lt;code class=&quot;highlighter-rouge&quot;&gt;(i_wb_stb)&amp;amp;&amp;amp;(i_wb_we)&lt;/code&gt; is true, and the address reflects our
timer’s address, then we can reload our timer from &lt;code class=&quot;highlighter-rouge&quot;&gt;i_wb_data&lt;/code&gt;.
This would give us a more adaptable, configurable timer.  Such a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_(computing)&quot;&gt;bus&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Programmable_interval_timer&quot;&gt;controlled timer&lt;/a&gt;
could easily become a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Soft_microprocessor&quot;&gt;CPU&lt;/a&gt; peripheral.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;initial	r_value = 0;
always @(posedge i_clk)
	if ((i_wb_stb)&amp;amp;&amp;amp;(i_wb_we))
		r_value &amp;lt;= i_wb_data;
	else if (r_value != 0)
		r_value &amp;lt;= r_value - 1&#39;b1;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This works fine for
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
implementations, but what if you want this counter to run in a &lt;a href=&quot;/blog/2017/10/13/fpga-v-asic.html&quot;&gt;context
where &lt;code class=&quot;highlighter-rouge&quot;&gt;initial&lt;/code&gt; statements are
ignored&lt;/a&gt;?  In that case,
you need an &lt;code class=&quot;highlighter-rouge&quot;&gt;i_reset&lt;/code&gt; input.  On a reset, that is when &lt;code class=&quot;highlighter-rouge&quot;&gt;i_reset&lt;/code&gt; is high,
the counter should return to idle, &lt;code class=&quot;highlighter-rouge&quot;&gt;r_value == 0&lt;/code&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;initial	r_value = 0;
always @(posedge i_clk)
	if (i_reset)
		r_value &amp;lt;= 0;
	else if ((i_wb_stb)&amp;amp;&amp;amp;(i_wb_we))
		r_value &amp;lt;= i_wb_data;
	else if (r_value != 0)
		r_value &amp;lt;= r_value - 1&#39;b1;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;In a similar fashion, with only a tiny adjustment, we can use this module
to count events.  We’ll use an incoming &lt;code class=&quot;highlighter-rouge&quot;&gt;i_ce&lt;/code&gt; signal to denote when an event
has taken place.  Examples of such events include not only clock cycles
(&lt;code class=&quot;highlighter-rouge&quot;&gt;i_ce=1&lt;/code&gt;), but also incoming or outgoing samples in a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_signal_processing&quot;&gt;DSP&lt;/a&gt;
system, or lines or frames in a video system.  All of these options can
be created by appropriately setting an &lt;code class=&quot;highlighter-rouge&quot;&gt;i_ce&lt;/code&gt; input to one &lt;a href=&quot;/blog/2017/08/14/strategies-for-pipelining.html&quot;&gt;any time the
timer is to
step&lt;/a&gt;.
Put together, our original counter now becomes,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;initial	r_value = 0;
always @(posedge i_clk)
	if (i_reset)
		r_value &amp;lt;= 0;
	else if ((i_wb_stb)&amp;amp;&amp;amp;(i_wb_we))
		r_value &amp;lt;= i_wb_data;
	else if ((i_ce)&amp;amp;&amp;amp;(r_value != 0))
		r_value &amp;lt;= r_value - 1&#39;b1;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;That’s quite the configurable counter, no?&lt;/p&gt;

&lt;p&gt;Let’s now return to our
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus interface&lt;/a&gt;
and properly set the rest of the required
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;
&lt;a href=&quot;/zipcpu/2017/05/29/simple-wishbone.html&quot;&gt;control values&lt;/a&gt;.
Since we can respond on every clock cycle, there’s no reason to ever stall the
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;assign	o_wb_stall = 1&#39;b0;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;We’ll also need to create a response to the &lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;wishbone
bus&lt;/a&gt;.  Since
this operation takes only a single cycle, we’ll acknowledge the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_(computing)&quot;&gt;bus&lt;/a&gt;
any time we are selected.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;assign	o_wb_ack = (i_wb_stb);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;We can do this if the current counter state data is always valid on the
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;’s
&lt;code class=&quot;highlighter-rouge&quot;&gt;o_wb_data&lt;/code&gt; lines.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;assign	o_wb_data = r_value;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Voila!  A &lt;a href=&quot;/zipcpu/2017/05/29/simple-wishbone.html&quot;&gt;simple, wishbone bus
controlled&lt;/a&gt;
count-down timer!&lt;/p&gt;

&lt;h2 id=&quot;interval-timer&quot;&gt;Interval Timer&lt;/h2&gt;

&lt;p&gt;The former code works great for a one-shot timer.  However, if you want to
create a timer that
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interrupt&quot;&gt;interrupts&lt;/a&gt; the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt; every 10ms (as an example), only
to be reset by the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt; in an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interrupt_handler&quot;&gt;interrupt service routine&lt;/a&gt;,
then you will find that the interval pseudorandomly walks in phase.  The
intervals will all be longer then 10ms.  How can we fix this?&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 3. An Interval Timer&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/timer-interval.svg&quot; alt=&quot;&quot; width=&quot;248&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;One solution is to use an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Programmable_interval_timer&quot;&gt;interval timer&lt;/a&gt;.
Simply put, an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Programmable_interval_timer&quot;&gt;interval timer&lt;/a&gt;
is one that counts down to zero, and then resets itself to count down again.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;initial	r_value = 0;
always @(posedge i_clk)
	if (r_value != 0)
		r_value &amp;lt;= r_value - 1&#39;b1;
	else
		r_value &amp;lt;= interval_count;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;As before, we’ll generate an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interrupt&quot;&gt;interrupt&lt;/a&gt;
anytime this timer hits zero,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;initial	o_int &amp;lt;= 1&#39;b0;
always @(posedge i_clk)
	o_int &amp;lt;= (r_value == 1);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;But … what if we wanted to allow this reload value to be externally set?
To create this capability, we’ll attach this
&lt;a href=&quot;https://en.wikipedia.org/wiki/Programmable_interval_timer&quot;&gt;interval timer&lt;/a&gt;
to &lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;wishbone bus&lt;/a&gt;.
Perhaps we want something like,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;initial	r_value = 0;
always @(posedge i_clk)
	if ((i_wb_stb)&amp;amp;&amp;amp;(i_wb_we))
		r_interval_count &amp;lt;= i_wb_data;

always @(posedge i_clk)
	if (r_value != 0)
		r_value &amp;lt;= r_value - 1&#39;b1;
	else
		r_value &amp;lt;= r_interval_count;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This is almost identical to our original counter above, save that every time
it resets it goes back to &lt;code class=&quot;highlighter-rouge&quot;&gt;r_interval_count&lt;/code&gt; instead of the original &lt;code class=&quot;highlighter-rouge&quot;&gt;TIMEOUT&lt;/code&gt;
parameter.  Since &lt;code class=&quot;highlighter-rouge&quot;&gt;r_interval_count&lt;/code&gt; is programmable from the
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;,
we now have a &lt;a href=&quot;https://en.wikipedia.org/wiki/Programmable_interval_timer&quot;&gt;programmable interrupt
timer&lt;/a&gt;.
How hard can this be?&lt;/p&gt;

&lt;p&gt;In this case, the devil is in the details.&lt;/p&gt;

&lt;p&gt;Look closer.  Do you see any of the problems with this implementation?
For example, what happens if you want to switch from a 4-second intervals to
10ms intervals?  Just how many counts will that first 10ms interval contain?
Up to 4 seconds?&lt;/p&gt;

&lt;p&gt;If that’s not the response you want, then how should this timer respond?&lt;/p&gt;

&lt;p&gt;While we consider this, let’s also consider merging the countdown timer
together with the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Programmable_interval_timer&quot;&gt;interval timer&lt;/a&gt;
in a way that both respond to
&lt;a href=&quot;/zipcpu/2017/05/29/simple-wishbone.html&quot;&gt;bus requests&lt;/a&gt;.
Here’s the capability or requirement we’ll build to then:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;On any reset, the counter will set itself to zero and wait to be configured&lt;/p&gt;

    &lt;p&gt;This matches the count-down timer behavior we discussed above.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 4. The ZipTimer Register&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/timer-reg.png&quot; alt=&quot;&quot; width=&quot;557&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;On any write, the counter will assume the value written to it, as shown
in Fig 4 as the &lt;code class=&quot;highlighter-rouge&quot;&gt;New Counter&lt;/code&gt; bits, and will then start counting down.
If the number written was a zero, then the counter will stay at zero and stop.&lt;/p&gt;

    &lt;p&gt;Again, this matches the count-down timer behavior we originally discussed.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;If the high bit is set upon any write, shown as &lt;code class=&quot;highlighter-rouge&quot;&gt;R&lt;/code&gt; in Fig 4 above,
then the timer will enter into interval mode.  In all other cases, the timer
will be started as a one-shot countdown timer.&lt;/p&gt;

    &lt;p&gt;This is our first break from the original countdown timer’s functionality,
allowing us to run in an interval timer mode.&lt;/p&gt;

    &lt;p&gt;Further, if set to interval mode, then the value written to the timer will
become the interval definition.  Hence, when the timer finishes counting
down to zero, we’ll just automatically restart it again with the same
&lt;code class=&quot;highlighter-rouge&quot;&gt;New Counter&lt;/code&gt; value just written to it.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;On writing a zero to the counter, all ongoing counts will be ended and the
counter will return to idle.  Any interval capability will be turned off.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;We’ll also use a &lt;a href=&quot;/blog/2017/08/14/strategies-for-pipelining.html&quot;&gt;global CE
register&lt;/a&gt;,
&lt;code class=&quot;highlighter-rouge&quot;&gt;i_ce&lt;/code&gt;.  This will allow you to count down things other than clock cycles.
Perhaps you can count incoming samples on an interface.  Perhaps you
want to count video frames.  Perhaps you want to count finished instructions.
All of these can be implemented with an appropriate connection to this &lt;code class=&quot;highlighter-rouge&quot;&gt;i_ce&lt;/code&gt;
wire.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Simple enough?  Almost.&lt;/p&gt;

&lt;p&gt;If low logic is a priority, and it has always been a priority for me, then
you’ll also want to be able to configure this peripheral for just the amount
of logic necessary.  We’ll use the parameter &lt;code class=&quot;highlighter-rouge&quot;&gt;VW&lt;/code&gt; to control how many bits
are in our counter.  We’ll also use &lt;code class=&quot;highlighter-rouge&quot;&gt;BW&lt;/code&gt; to be the width of the data
bus–nominally 32 bits.  Finally we’ll use the one bit parameter,
&lt;code class=&quot;highlighter-rouge&quot;&gt;RELOADABLE&lt;/code&gt; to control whether or not this timer offers an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Programmable_interval_timer&quot;&gt;interval timer&lt;/a&gt;
mode or not.  For example, if you know you are only ever going to measure
20ms intervals from a 100MHz clock, then you won’t ever need any
more than &lt;code class=&quot;highlighter-rouge&quot;&gt;VW=21&lt;/code&gt; bits.&lt;/p&gt;

&lt;p&gt;Simple enough now?  I thought so.  Let’s dive into a walk through of the code.&lt;/p&gt;

&lt;h2 id=&quot;the-code&quot;&gt;The Code&lt;/h2&gt;

&lt;p&gt;We’ll walk through the code of the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/ziptimer.v&quot;&gt;ZipTimer&lt;/a&gt;
in two separate sections.  First, we’ll discuss the traditional Verilog code.
Then we’ll move from that to the
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal properties&lt;/a&gt;
section.  Once we’ve finished discussing the
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal properties&lt;/a&gt;
within the code, I show how to connect a peripheral like this to an
&lt;a href=&quot;/zipcpu/2017/10/05/autofpga-intro.html&quot;&gt;AutoFPGA&lt;/a&gt;
based design.&lt;/p&gt;

&lt;p&gt;Normally I skip the front matter of a Verilog file when blogging, so as to
only focus on the relevant portions.  In this case, I’ll show the three
parameters: &lt;code class=&quot;highlighter-rouge&quot;&gt;BW&lt;/code&gt;, containing the size of the bus, &lt;code class=&quot;highlighter-rouge&quot;&gt;VW&lt;/code&gt;, containing the
number of bits in our counter, and &lt;code class=&quot;highlighter-rouge&quot;&gt;RELOADABLE&lt;/code&gt;–set to one if we want
to support an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Programmable_interval_timer&quot;&gt;interval timer&lt;/a&gt;
capability in addition to the one-shot timer capability.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	parameter	BW = 32;
	parameter	VW = (BW-1);
	parameter [0:0]	RELOADABLE=1;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;I’ll also simplify the write command below to a &lt;code class=&quot;highlighter-rouge&quot;&gt;wb_write&lt;/code&gt; flag.  Since you’ll
see this often below, here’s the declaration.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	assign	wb_write = (i_wb_stb)&amp;amp;&amp;amp;(i_wb_we);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;As a result, any time you read &lt;code class=&quot;highlighter-rouge&quot;&gt;wb_write&lt;/code&gt; below you now know that it is
nothing more than a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Predicate_(mathematical_logic)&quot;&gt;predicate&lt;/a&gt;
that will be true any time the
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;
is writing to our only
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/ziptimer.v&quot;&gt;timer&lt;/a&gt;
register.&lt;/p&gt;

&lt;p&gt;We’ll also use a flag &lt;code class=&quot;highlighter-rouge&quot;&gt;r_running&lt;/code&gt; to keep track of whether or not the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/ziptimer.v&quot;&gt;timer&lt;/a&gt;
is &lt;em&gt;running&lt;/em&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	initial	r_running = 1&#39;b0;
	always @(posedge i_clk)
		if (i_reset)
			r_running &amp;lt;= 1&#39;b0;
		else if (wb_write)
			r_running &amp;lt;= (|i_wb_data[(VW-1):0]);
		else if ((r_zero)&amp;amp;&amp;amp;(!auto_reload))
			r_running &amp;lt;= 1&#39;b0;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Basically the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/ziptimer.v&quot;&gt;timer&lt;/a&gt;
is &lt;code class=&quot;highlighter-rouge&quot;&gt;r_running&lt;/code&gt; any time it is non-zero, or any time it is
zero and about to reload for the next interval.  If we wanted to, it would
&lt;a href=&quot;/blog/2018/03/14/is-formal-hard.html&quot;&gt;make sense to scribble in our
notes&lt;/a&gt;
at this point that,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(*)
if ((r_value != 0)||(auto_reload))
	assert(r_running);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The contrary case, where &lt;code class=&quot;highlighter-rouge&quot;&gt;r_running&lt;/code&gt; is not true, will be a little more
difficult to specify so we’ll save it until we have to think our way through it
in the next section.  Either way, when we get to building our
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal properties&lt;/a&gt;
section, we’ll then &lt;a href=&quot;/blog/2018/03/14/is-formal-hard.html&quot;&gt;copy our scribbled notes over
there&lt;/a&gt;
so we can place all of our
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal properties&lt;/a&gt;
in one place.&lt;/p&gt;

&lt;p&gt;Moving on, if you recall from above, we used a &lt;code class=&quot;highlighter-rouge&quot;&gt;RELOADABLE&lt;/code&gt; parameter
option to select whether or not this
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/ziptimer.v&quot;&gt;timer&lt;/a&gt;
included the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Programmable_interval_timer&quot;&gt;interval timer&lt;/a&gt;
ability, or just a one-shot capability.  Hence, if &lt;code class=&quot;highlighter-rouge&quot;&gt;RELOADABLE&lt;/code&gt; is true
then we’ll include this
&lt;a href=&quot;https://en.wikipedia.org/wiki/Programmable_interval_timer&quot;&gt;interval timer&lt;/a&gt;
capability.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	generate
	if (RELOADABLE != 0)
	begin&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The
&lt;a href=&quot;https://en.wikipedia.org/wiki/Programmable_interval_timer&quot;&gt;interval timer&lt;/a&gt;
capability itself centers around two registers.  The
first, &lt;code class=&quot;highlighter-rouge&quot;&gt;r_auto_reload&lt;/code&gt;, is a single bit flag telling us whether or not the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/ziptimer.v&quot;&gt;timer&lt;/a&gt;
needs to be restarted once it hits zero.  The second register will tell us
what our interval is should &lt;code class=&quot;highlighter-rouge&quot;&gt;r_auto_reload&lt;/code&gt; be set–but we’ll get to that
in a moment.&lt;/p&gt;

&lt;p&gt;Initially, I cleared this &lt;code class=&quot;highlighter-rouge&quot;&gt;r_auto_reload&lt;/code&gt; value upon any reset and set it
on any write where the most significant bit is set.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;		initial	r_auto_reload = 1&#39;b0;

		always @(posedge i_clk)
			if (i_reset)
				r_auto_reload &amp;lt;= 1&#39;b0;
			else if (wb_write)
				r_auto_reload &amp;lt;= (i_wb_data[(BW-1)]);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This approach failed when I tried to
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formally verify&lt;/a&gt;
the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/ziptimer.v&quot;&gt;ZipTimer&lt;/a&gt;.
When I dug a bit deeper, I realized that the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/ziptimer.v&quot;&gt;timer&lt;/a&gt;
interval could never be allowed to be zero.  Were it zero, this would
break the &lt;code class=&quot;highlighter-rouge&quot;&gt;r_running&lt;/code&gt; assertion we placed into our notes above.
Hence, I rewrote the &lt;code class=&quot;highlighter-rouge&quot;&gt;r_auto_reload&lt;/code&gt; logic above into,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;		initial	r_auto_reload = 1&#39;b0;

		always @(posedge i_clk)
			if (i_reset)
				r_auto_reload &amp;lt;= 1&#39;b0;
			else if (wb_write)
				r_auto_reload &amp;lt;= (i_wb_data[(BW-1)])
					&amp;amp;&amp;amp;(|i_wb_data[(VW-1):0]);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The big difference is that in order to create an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Programmable_interval_timer&quot;&gt;interval timer&lt;/a&gt;,
you need to not only set the high order bit but you must also provide a
non-zero interval length.&lt;/p&gt;

&lt;p&gt;The second item worth commenting on here is the assign statement.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;		assign	auto_reload = r_auto_reload;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;By assigning to a global &lt;code class=&quot;highlighter-rouge&quot;&gt;wire&lt;/code&gt; value within a &lt;code class=&quot;highlighter-rouge&quot;&gt;generate&lt;/code&gt; block, I
can then use this &lt;code class=&quot;highlighter-rouge&quot;&gt;wire&lt;/code&gt; value throughout the rest of my design without
needing to waste &lt;code class=&quot;highlighter-rouge&quot;&gt;reg&lt;/code&gt;s when &lt;code class=&quot;highlighter-rouge&quot;&gt;RELOADABLE&lt;/code&gt; is false and I don’t need them.
Optimizations within the synthesizer will then remove any extra logic dependent
upon these values.&lt;/p&gt;

&lt;p&gt;The next register associated with the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Programmable_interval_timer&quot;&gt;interval timer&lt;/a&gt;
capability is the &lt;code class=&quot;highlighter-rouge&quot;&gt;r_interval_count&lt;/code&gt; register–containing the the interval
length expressed as value to reset our register to after it reaches zero.
On any write, we’ll set this interval count to the information found on the
data &lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;
in &lt;code class=&quot;highlighter-rouge&quot;&gt;i_wb_data&lt;/code&gt;.  The &lt;code class=&quot;highlighter-rouge&quot;&gt;r_auto_reload&lt;/code&gt; we just dealt with
above will determine whether or not this &lt;code class=&quot;highlighter-rouge&quot;&gt;r_interval_count&lt;/code&gt; is relevant or not.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;		initial	r_interval_count = 0;
		always @(posedge i_clk)
			if (i_reset)
				r_interval_count &amp;lt;= 0;
			else if (wb_write)
				r_interval_count &amp;lt;= i_wb_data[(VW-1):0];
		assign	interval_count = r_interval_count;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Finally, if we are building without the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Programmable_interval_timer&quot;&gt;interval timer&lt;/a&gt;
capability, we’ll set both of these values, &lt;code class=&quot;highlighter-rouge&quot;&gt;auto_reload&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;interval_count&lt;/code&gt;,
to zero.  The synthesizer will then remove any of the relevant
&lt;a href=&quot;https://en.wikipedia.org/wiki/Programmable_interval_timer&quot;&gt;interval timer&lt;/a&gt;
logic below.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	end else begin
		assign	auto_reload = 1&#39;b0;
		assign	interval_count = 0;
	end endgenerate&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Let’s now dig into the core of this count-down timer: the counter’s value,
&lt;code class=&quot;highlighter-rouge&quot;&gt;r_value&lt;/code&gt;.  This follows primarily from the counter we started with, corrected
by our discussion above, but now with the changes necessary to handle both an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Programmable_interval_timer&quot;&gt;interval timer&lt;/a&gt;
capability as well as a &lt;a href=&quot;https://en.wikipedia.org/wiki/Programmable_interval_timer&quot;&gt;one-shot countdown
timer&lt;/a&gt;
capability.&lt;/p&gt;

&lt;p&gt;In both cases, the counter is initialized to zero, cleared on reset, and
set on any
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;
&lt;a href=&quot;/zipcpu/2017/05/29/simple-wishbone.html&quot;&gt;write&lt;/a&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	initial	r_value = 0;
	always @(posedge i_clk)
		if (i_reset)
			r_value &amp;lt;= 0;
		else if (wb_write)
			r_value &amp;lt;= i_wb_data[(VW-1):0];&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Otherwise, we’ll adjust the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/ziptimer.v&quot;&gt;timer&lt;/a&gt;
any time &lt;code class=&quot;highlighter-rouge&quot;&gt;i_ce&lt;/code&gt; is true and the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/ziptimer.v&quot;&gt;timer&lt;/a&gt;
is currently running.  As you may remember from above, the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/ziptimer.v&quot;&gt;timer&lt;/a&gt;
is &lt;code class=&quot;highlighter-rouge&quot;&gt;r_running&lt;/code&gt; any time &lt;code class=&quot;highlighter-rouge&quot;&gt;r_value&lt;/code&gt; it is nonzero, or we are in
&lt;a href=&quot;https://en.wikipedia.org/wiki/Programmable_interval_timer&quot;&gt;interval timer&lt;/a&gt;
mode (&lt;code class=&quot;highlighter-rouge&quot;&gt;r_auto_reload&lt;/code&gt; is true).&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;		else if ((i_ce)&amp;amp;&amp;amp;(r_running))
		begin&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;If the counter is not zero, we’ll count down.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;			if (!r_zero)
				r_value &amp;lt;= r_value - 1&#39;b1;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Once it reaches zero, we’ll restart it if we are in
&lt;a href=&quot;https://en.wikipedia.org/wiki/Programmable_interval_timer&quot;&gt;interval timer&lt;/a&gt;
mode.  In this mode, &lt;code class=&quot;highlighter-rouge&quot;&gt;auto_reload&lt;/code&gt; will be true.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;			else if (auto_reload)
				r_value &amp;lt;= interval_count;
		end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;If &lt;code class=&quot;highlighter-rouge&quot;&gt;auto_reload&lt;/code&gt; is not set then once the counter reaches zero, the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/ziptimer.v&quot;&gt;timer&lt;/a&gt;
will stop.&lt;/p&gt;

&lt;p&gt;The next register in our implementation is &lt;code class=&quot;highlighter-rouge&quot;&gt;r_zero&lt;/code&gt;.  &lt;code class=&quot;highlighter-rouge&quot;&gt;r_zero&lt;/code&gt; is a helper
register.  It needs to
be equivalent to &lt;code class=&quot;highlighter-rouge&quot;&gt;r_value == 0&lt;/code&gt;.  (We’ll prove that these two expressions
evaluate to the same value in a moment.)  By setting &lt;code class=&quot;highlighter-rouge&quot;&gt;r_zero&lt;/code&gt; on the clock
before &lt;code class=&quot;highlighter-rouge&quot;&gt;r_value&lt;/code&gt; reaches zero, we relieve some of the timing stress within
this module.  Hence, instead of an always block that depends upon whether
or not &lt;code class=&quot;highlighter-rouge&quot;&gt;r_value == 0&lt;/code&gt;, such as the original designs we started out with,
they can instead depend upon a single pre-calculated single-bit value &lt;code class=&quot;highlighter-rouge&quot;&gt;r_zero&lt;/code&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	reg	r_zero  = 1&#39;b1;
	always @(posedge i_clk)
		if (i_reset)
			r_zero &amp;lt;= 1&#39;b1;
		else if (wb_write)
			r_zero &amp;lt;= (i_wb_data[(VW-1):0] == 0);
		else if ((r_running)&amp;amp;&amp;amp;(i_ce))
		begin
			if (r_value == { {(VW-1){1&#39;b0}}, 1&#39;b1 })
				r_zero &amp;lt;= 1&#39;b1;
			else if ((r_zero)&amp;amp;&amp;amp;(auto_reload))
				r_zero &amp;lt;= 1&#39;b0;
		end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;a href=&quot;/blog/2018/03/14/is-formal-hard.html&quot;&gt;Were I writing this code from
scratch&lt;/a&gt;, I’d
scribble into the margin that I’ll want to come back and prove the
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal property&lt;/a&gt;
that&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(*) assert(r_zero == (r_value == 0));&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The final required piece of logic is the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interrupt&quot;&gt;interrupt&lt;/a&gt;
register, &lt;code class=&quot;highlighter-rouge&quot;&gt;o_int&lt;/code&gt;.  While we might consider setting the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interrupt&quot;&gt;interrupt&lt;/a&gt;
line to &lt;code class=&quot;highlighter-rouge&quot;&gt;r_zero&lt;/code&gt;, we’d then get lots of
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interrupt&quot;&gt;interrupt&lt;/a&gt;s
every time the counter was idle.  We’d also get lots of
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interrupt&quot;&gt;interrupt&lt;/a&gt;s
between any pair of &lt;code class=&quot;highlighter-rouge&quot;&gt;i_ce&lt;/code&gt; strobes while the counter was waiting to reload.
Hence, we’ll only set the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interrupt&quot;&gt;interrupt&lt;/a&gt;
any time &lt;code class=&quot;highlighter-rouge&quot;&gt;r_value&lt;/code&gt; transitions to zero, or more explicitly any time it is
equal to one and the &lt;code class=&quot;highlighter-rouge&quot;&gt;i_ce&lt;/code&gt; register is high.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	initial	o_int   = 1&#39;b0;
	always @(posedge i_clk)
		if ((i_reset)||(wb_write)||(!i_ce))
			o_int &amp;lt;= 1&#39;b0;
		else // if (i_ce)
			o_int &amp;lt;= (r_value == { {(VW-1){1&#39;b0}}, 1&#39;b1 });&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;As our last step, we’ll set the return data on the
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;
to be the indication of whether we are in
&lt;a href=&quot;https://en.wikipedia.org/wiki/Programmable_interval_timer&quot;&gt;interval timer&lt;/a&gt;
mode (&lt;code class=&quot;highlighter-rouge&quot;&gt;auto_reload&lt;/code&gt; is high), followed by the current
state of the counter.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	assign	o_wb_data = { auto_reload, r_value };&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Other
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;wishbone return&lt;/a&gt;
return values follow from our prior discussion:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	assign	o_wb_stall = 1&#39;b0;
	assign	o_wb_ack = (i_wb_stb);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;That’s all it takes to generate a timer peripheral for a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Soft_microprocessor&quot;&gt;CPU&lt;/a&gt;.  It’s a bit more
than the simple counter we started out with.
In the next section, we’ll discuss how we might go about &lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formally
verifying&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/ziptimer.v&quot;&gt;this timer&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;the-formal-proof&quot;&gt;The formal proof&lt;/h2&gt;

&lt;p&gt;If you are not familiar with using &lt;a href=&quot;http://www.clifford.at/yosys/&quot;&gt;yosys&lt;/a&gt;
for &lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal
verification&lt;/a&gt;,
then I’ll recommend you go back and read about my &lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;first experiences with
formal methods&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;If you just want a quick reminder, there are two basic operators we’ll be using
below.  The &lt;code class=&quot;highlighter-rouge&quot;&gt;assume()&lt;/code&gt; operator restricts the size of the possible state space
that the
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal methods&lt;/a&gt;
will examine.  The &lt;code class=&quot;highlighter-rouge&quot;&gt;assert()&lt;/code&gt; operator defines which states within
this group are illegal.  The formal engine will try all possible logic threads
to find one where the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Predicate_(mathematical_logic)&quot;&gt;predicate&lt;/a&gt;
expression inside the &lt;code class=&quot;highlighter-rouge&quot;&gt;assert()&lt;/code&gt; statement can be made to be false.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 5. The Golden Rule of Formal Verification&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/fv-master-rule.svg&quot; alt=&quot;&quot; width=&quot;360&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;To know which of &lt;code class=&quot;highlighter-rouge&quot;&gt;assume()&lt;/code&gt; or &lt;code class=&quot;highlighter-rouge&quot;&gt;assert()&lt;/code&gt; to use for any particular
property, I follow the rule shown in Fig 5.  Hence, we’ll &lt;code class=&quot;highlighter-rouge&quot;&gt;assume()&lt;/code&gt;
any properties about our inputs, and we’ll &lt;code class=&quot;highlighter-rouge&quot;&gt;assert()&lt;/code&gt; any properties
about our own internal state or any outputs we might produce.&lt;/p&gt;

&lt;p&gt;There is a third operator we’ll be using as well.  This is the &lt;code class=&quot;highlighter-rouge&quot;&gt;$past()&lt;/code&gt;
operator.  As we use it below, this operator returns the value of the
item within it one clock ago.  The problem with the &lt;code class=&quot;highlighter-rouge&quot;&gt;$past&lt;/code&gt; operator is that
it tends to misbehave prior to the beginning of time.  Hence, any time you
see me using this you’ll also see &lt;code class=&quot;highlighter-rouge&quot;&gt;f_past_valid&lt;/code&gt; in the condition list.&lt;/p&gt;

&lt;p&gt;As with most of my
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal property&lt;/a&gt;
sections, they start with the definition of the &lt;code class=&quot;highlighter-rouge&quot;&gt;f_past_valid&lt;/code&gt; variable
I just mentioned.  We discussed this above, and in more detail
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;before&lt;/a&gt;.
Basically, any assertion regarding something one clock in the &lt;code class=&quot;highlighter-rouge&quot;&gt;$past()&lt;/code&gt;,
before any &lt;code class=&quot;highlighter-rouge&quot;&gt;initial&lt;/code&gt; settings, will fail.
By checking for &lt;code class=&quot;highlighter-rouge&quot;&gt;f_past_valid&lt;/code&gt; being true as part of a formal logic
test, I can then use &lt;code class=&quot;highlighter-rouge&quot;&gt;$past()&lt;/code&gt; expressions in any &lt;code class=&quot;highlighter-rouge&quot;&gt;assert()&lt;/code&gt; statements below
without worrying about whether or not the logic being referenced occurred
before time began.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;`ifdef	FORMAL
	reg	f_past_valid;
	initial	f_past_valid = 1&#39;b0;
	always @(posedge i_clk)
		f_past_valid &amp;lt;= 1&#39;b1;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The next order of business is bounding the &lt;code class=&quot;highlighter-rouge&quot;&gt;i_reset&lt;/code&gt; signal.  This signal needs
to be true initially.  We’ll also insist that it’s true any time &lt;code class=&quot;highlighter-rouge&quot;&gt;f_past_valid&lt;/code&gt;
is false.  Aren’t these two the same condition?  Not quite. While they are
very similar, they are separate conditions.  This second
condition specifies that any time the induction engine tries to set
&lt;code class=&quot;highlighter-rouge&quot;&gt;f_past_valid&lt;/code&gt; to false, then the &lt;code class=&quot;highlighter-rouge&quot;&gt;i_reset&lt;/code&gt; line must also be true which will
then force the design into its initial state.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	initial	assume(i_reset);
	always @(*)
		if (!f_past_valid)
			assume(i_reset);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;If we do this properly, we can use &lt;code class=&quot;highlighter-rouge&quot;&gt;f_past_valid&lt;/code&gt; being false as an indication
that our design should be in its reset state.  In a similar fashion, on the
clock following any &lt;code class=&quot;highlighter-rouge&quot;&gt;i_reset&lt;/code&gt;, the design should also be in its reset state.&lt;/p&gt;

&lt;p&gt;We’ll pull any value from above that has an &lt;code class=&quot;highlighter-rouge&quot;&gt;initial&lt;/code&gt; statement or responds
to an &lt;code class=&quot;highlighter-rouge&quot;&gt;i_reset&lt;/code&gt; signal, and insist on either condition that the registers
have the same value.  We’ll also desk check our design to make certain that
registers set via an &lt;code class=&quot;highlighter-rouge&quot;&gt;initial&lt;/code&gt; statement are also responsive to an &lt;code class=&quot;highlighter-rouge&quot;&gt;i_reset&lt;/code&gt;
and vice-versa.  That is, an &lt;code class=&quot;highlighter-rouge&quot;&gt;initial&lt;/code&gt; statement should set the register
to the same value that an &lt;code class=&quot;highlighter-rouge&quot;&gt;i_reset&lt;/code&gt; would set them to.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(posedge i_clk)
	if ((!f_past_valid)||($past(i_reset)))
	begin
		assert(r_value     == 0);
		assert(r_running   == 0);
		assert(auto_reload == 0);
		assert(interval_count== 0);
		assert(r_zero      == 1&#39;b1);
	end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Let’s now move on to some internal consistency checks.  For example, we
stated above that we wanted &lt;code class=&quot;highlighter-rouge&quot;&gt;r_zero&lt;/code&gt; to be equivalent to &lt;code class=&quot;highlighter-rouge&quot;&gt;r_value==0&lt;/code&gt;.
Let’s now assert that this relationship holds.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(*)
		assert(r_zero == (r_value == 0));&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Likewise, anytime our value is non-zero the timer should be running.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(*)
		if (r_value != 0)
			assert(r_running);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;In a similar fashion, any time we are in interval mode we should be running.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(*)
		if (auto_reload)
			assert(r_running);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Perhaps you may recall these from our scribbled notes above as well?&lt;/p&gt;

&lt;p&gt;Further, if our parameter &lt;code class=&quot;highlighter-rouge&quot;&gt;RELOADABLE&lt;/code&gt; is false, then &lt;code class=&quot;highlighter-rouge&quot;&gt;auto_reload&lt;/code&gt; should
also be false.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(*)
		if (!RELOADABLE)
			assert(auto_reload == 0);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Finally, anytime &lt;code class=&quot;highlighter-rouge&quot;&gt;auto_reload&lt;/code&gt; is true, we should have a non-zero interval
time.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(*)
		if (auto_reload)
			assert(interval_count != 0);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Those are the simple properties.  The next several are more complex.&lt;/p&gt;

&lt;p&gt;Our next step will be to work through the properties associated with &lt;code class=&quot;highlighter-rouge&quot;&gt;r_value&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;For the first of these more complex properties, we’ll say that any
time &lt;code class=&quot;highlighter-rouge&quot;&gt;r_value==0&lt;/code&gt;, i.e. any time the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/ziptimer.v&quot;&gt;timer&lt;/a&gt;
has stopped counting down, then it should stay that way.  However, if you try
to express this simply,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(posedge i_clk)
	if ((f_past_valid)&amp;amp;&amp;amp;($past(r_value)==0))
		assert(r_value == 0);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;you might be surprised that your assertion doesn’t hold.  You’ll first find
that following a
&lt;a href=&quot;/zipcpu/2017/05/29/simple-wishbone.html&quot;&gt;wishbone write&lt;/a&gt;,
&lt;code class=&quot;highlighter-rouge&quot;&gt;r_value&lt;/code&gt; might be something other than zero.
You’ll then discover that, by design, following an automatic reload it won’t
be zero either.  Hence, the actual property is a touch more complex.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(posedge i_clk)
	if ((f_past_valid)&amp;amp;&amp;amp;($past(r_value)==0)
			&amp;amp;&amp;amp;(!$past(wb_write))&amp;amp;&amp;amp;(!$past(auto_reload)))
		assert(r_value == 0);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Next, let’s consider the case where &lt;code class=&quot;highlighter-rouge&quot;&gt;r_value&lt;/code&gt; was equal to zero on the last
clock, but isn’t equal to zero any more.  Specifically, we want to test
whether the interval
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/ziptimer.v&quot;&gt;timer&lt;/a&gt;
started over on a reload as desired.&lt;/p&gt;

&lt;p&gt;In this case, the simple property has several exceptions to it.  The counter
won’t move to its reload value following a reset, nor will it necessarily
move to its reload value following a
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;
&lt;a href=&quot;/zipcpu/2017/05/29/simple-wishbone.html&quot;&gt;write&lt;/a&gt;.
Finally, it should only restart if &lt;code class=&quot;highlighter-rouge&quot;&gt;i_ce&lt;/code&gt; is true, and in all other
cases remain where it was.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(posedge i_clk)
	if ((f_past_valid)&amp;amp;&amp;amp;(!$past(i_reset))&amp;amp;&amp;amp;(!$past(wb_write))
			&amp;amp;&amp;amp;($past(r_value)==0)&amp;amp;&amp;amp;($past(auto_reload)))
	begin
		if ($past(i_ce))
			assert(r_value == interval_count);
		else
			assert(r_value == $past(r_value));
	end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Now let’s consider the case where the &lt;code class=&quot;highlighter-rouge&quot;&gt;r_value&lt;/code&gt; is not equal to zero on
the last clock.  While I’d like to write the assertion that,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(posedge i_clk)
	if ((f_past_valid)&amp;amp;&amp;amp;($past(r_value)!=0))
		assert(r_value == $past(r_value)-1&#39;b1);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;the formal engine again corrects me with several traces showing why this
isn’t the case.  The first trace reminds me that, following a reset,
&lt;code class=&quot;highlighter-rouge&quot;&gt;r_value&lt;/code&gt; will be zero.  Once I fix that and try again, the second trace
reminds me that &lt;code class=&quot;highlighter-rouge&quot;&gt;r_value&lt;/code&gt; can be anything
following a
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;
&lt;a href=&quot;/zipcpu/2017/05/29/simple-wishbone.html&quot;&gt;write&lt;/a&gt;.
Rather than running the formal tools again, I go back and desk check this
time to discover that
if &lt;code class=&quot;highlighter-rouge&quot;&gt;i_ce&lt;/code&gt; isn’t true on the last clock then &lt;code class=&quot;highlighter-rouge&quot;&gt;r_value&lt;/code&gt; shouldn’t change.&lt;/p&gt;

&lt;p&gt;This brings us to the following property,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(posedge i_clk)
	if ((f_past_valid)&amp;amp;&amp;amp;(!$past(i_reset))
			&amp;amp;&amp;amp;(!$past(wb_write))&amp;amp;&amp;amp;($past(r_value)!=0))
	begin
		if ($past(i_ce))
			assert(r_value == $past(r_value)-1&#39;b1);
		else
			assert(r_value == $past(r_value));
	end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;How about a
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;
&lt;a href=&quot;/zipcpu/2017/05/29/simple-wishbone.html&quot;&gt;write&lt;/a&gt;?
Following a
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;
&lt;a href=&quot;/zipcpu/2017/05/29/simple-wishbone.html&quot;&gt;write&lt;/a&gt;,
we want our counter to have the data written to it in our value.
The exception is a reset.  If a
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;
&lt;a href=&quot;/zipcpu/2017/05/29/simple-wishbone.html&quot;&gt;write&lt;/a&gt;
and a reset occur on the same clock, we’d rather reset.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(posedge i_clk)
	if ((f_past_valid)&amp;amp;&amp;amp;(!$past(i_reset))&amp;amp;&amp;amp;($past(wb_write)))
		assert(r_value == $past(i_wb_data[(VW-1):0]));&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This also applies to the interval length.  Following a
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;
&lt;a href=&quot;/zipcpu/2017/05/29/simple-wishbone.html&quot;&gt;write&lt;/a&gt;,
if the value is non-zero, and if this module is built with the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Programmable_interval_timer&quot;&gt;interval timer&lt;/a&gt;
capability, then the high bit will determine whether or not we enter into
&lt;a href=&quot;https://en.wikipedia.org/wiki/Programmable_interval_timer&quot;&gt;interval timer&lt;/a&gt;
mode.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(posedge i_clk)
	if ((f_past_valid)&amp;amp;&amp;amp;(!$past(i_reset))&amp;amp;&amp;amp;($past(wb_write))
			&amp;amp;&amp;amp;(RELOADABLE)&amp;amp;&amp;amp;(|$past(i_wb_data[(VW-1):0])))
		assert(auto_reload == $past(i_wb_data[(BW-1)]));&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;We’re almost done.  Before leaving, we need to double check our output
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interrupt&quot;&gt;interrupt&lt;/a&gt;.
This wire, &lt;code class=&quot;highlighter-rouge&quot;&gt;o_int&lt;/code&gt;, should be set any time &lt;code class=&quot;highlighter-rouge&quot;&gt;r_value&lt;/code&gt; transitions from &lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt; to
&lt;code class=&quot;highlighter-rouge&quot;&gt;0&lt;/code&gt;.  Or, at least, that was my original thought.  Then as I worked through
this logic using &lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal
methods&lt;/a&gt;,
I realized there were some exceptions.&lt;/p&gt;

&lt;p&gt;If the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/ziptimer.v&quot;&gt;timer&lt;/a&gt;
is reset in the last cycle, then the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interrupt&quot;&gt;interrupt&lt;/a&gt;
should be inactive.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(posedge i_clk)
	if (!(f_past_valid)||($past(i_reset)))
		assert(!o_int);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Following a
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;
&lt;a href=&quot;/zipcpu/2017/05/29/simple-wishbone.html&quot;&gt;write&lt;/a&gt;, the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interrupt&quot;&gt;interrupt&lt;/a&gt;
wire should be zero as well.  This will allow us to turn the timer &lt;em&gt;off&lt;/em&gt; by
simply writing a zero to it.  Likewise, if
&lt;code class=&quot;highlighter-rouge&quot;&gt;i_ce&lt;/code&gt; wasn’t true on the last clock, then we didn’t just hit zero and the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interrupt&quot;&gt;interrupt&lt;/a&gt;
should be clear again.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	else if (($past(wb_write))||(!$past(i_ce)))
		assert(!o_int);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;So when should the output
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interrupt&quot;&gt;interrupt&lt;/a&gt;
be set?  Any time we transition to zero.
Hence, it should be set following the clock where &lt;code class=&quot;highlighter-rouge&quot;&gt;i_ce&lt;/code&gt; was high and
&lt;code class=&quot;highlighter-rouge&quot;&gt;r_value&lt;/code&gt; was a one.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	else
		assert(o_int == ((r_running)&amp;amp;&amp;amp;(r_value == 0)));&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Our last
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal properties&lt;/a&gt;
are associated with the
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;wishbone bus&lt;/a&gt;.
At first glance, these properties below may just appear like restatements
of the logic above.  In many ways they are.  However, by placing these here
I know I won’t carelessly adjust this interface logic while trying to optimize
things.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(*)
		assert(o_wb_ack == i_wb_stb);

	always @(*)
		assert(!o_wb_stall);
	always @(*)
		assert(o_wb_data[BW-1] == auto_reload);
	always @(*)
		assert(o_wb_data[VW-1:0] == r_value);
`endif
endmodule&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;That’s the last of our formal properties.  Did you notice along the way how
the formal engine helped us find the right properties for our code?  That it
found subtleties like the reset condition that needed to be checked for?
Not only that, did you notice how the formal engine helped us flesh out the
final details in our &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/ziptimer.v&quot;&gt;timer
implementation&lt;/a&gt;?&lt;/p&gt;

&lt;p&gt;These are all reasons why I have now started using
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal methods&lt;/a&gt;
before ever writing a test bench or running a simulation.  Using
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal methods&lt;/a&gt;
helps me discover details I might otherwise not think about.&lt;/p&gt;

&lt;h2 id=&quot;autofpga&quot;&gt;AutoFPGA&lt;/h2&gt;

&lt;p&gt;We have one more task before we are done: connecting &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/ziptimer.v&quot;&gt;this
timer&lt;/a&gt;
to the rest of our design.  If you are using
&lt;a href=&quot;/zipcpu/2017/10/05/autofpga-intro.html&quot;&gt;AutoFPGA&lt;/a&gt;,
that’s just as easy as adding the configuration file for this timer
to the &lt;a href=&quot;/zipcpu/2017/10/05/autofpga-intro.html&quot;&gt;AutoFPGA&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/tinyzip/blob/master/auto-data/Makefile&quot;&gt;command line&lt;/a&gt;.
Alternatively, we could &lt;a href=&quot;/blog/2017/06/22/simple-wb-interconnect.html&quot;&gt;connect this to the bus interconnect by
hand&lt;/a&gt;,
but I think you’ll find it simpler to use
&lt;a href=&quot;/zipcpu/2017/10/05/autofpga-intro.html&quot;&gt;AutoFPGA&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Normally this isn’t necessary with the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
since the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/ziptimer.v&quot;&gt;ZipTimer&lt;/a&gt;
is already connected manually within the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/zipsystem.v&quot;&gt;ZipSystem&lt;/a&gt;
module, shown above in Fig 1.
Two recent &lt;a href=&quot;/zipcpu/2017/10/05/autofpga-intro.html&quot;&gt;AutoFPGA&lt;/a&gt;
based designs, one for the
&lt;a href=&quot;https://github.com/ZipCPU/arrowzip/&quot;&gt;MAX-1000&lt;/a&gt;
and another for the
&lt;a href=&quot;https://github.com/ZipCPU/tinyzip&quot;&gt;TinyFPGA&lt;/a&gt; (neither quite complete),
however, don’t use the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/zipsystem.v&quot;&gt;ZipSystem&lt;/a&gt;
but rather the bare
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/zipbones.v&quot;&gt;ZipBones&lt;/a&gt;
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; wrapper, shown in Fig 6.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 6. The ZipBones&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/zipbones.svg&quot; alt=&quot;&quot; width=&quot;320&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;In each of these designs, you can find a
&lt;a href=&quot;/zipcpu/2017/10/05/autofpga-intro.html&quot;&gt;AutoFPGA&lt;/a&gt;
bustimer configuration within the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/zipbones.v&quot;&gt;ZipBones&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/tinyzip/blob/master/auto-data/zipbones.txt&quot;&gt;configuration&lt;/a&gt;
file, since having the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/ziptimer.v&quot;&gt;timer&lt;/a&gt;
is so useful to the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;–as
it would be to any
&lt;a href=&quot;https://en.wikipedia.org/wiki/Soft_microprocessor&quot;&gt;CPU&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;You may recall from the general format of an
&lt;a href=&quot;/zipcpu/2017/10/05/autofpga-intro.html&quot;&gt;AutoFPGA&lt;/a&gt;
configuration file that the entries consist of &lt;code class=&quot;highlighter-rouge&quot;&gt;@KEY=VALUE&lt;/code&gt; pairs.  They are
primarily used to tell
&lt;a href=&quot;/zipcpu/2017/10/05/autofpga-intro.html&quot;&gt;AutoFPGA&lt;/a&gt;
what text to copy and paste into a set of various project files.
If the &lt;code class=&quot;highlighter-rouge&quot;&gt;VALUE&lt;/code&gt; takes less than a line, the &lt;code class=&quot;highlighter-rouge&quot;&gt;@KEY=VALUE&lt;/code&gt; definition can be
placed on a single line.  Otherwise, all of the lines following &lt;code class=&quot;highlighter-rouge&quot;&gt;@KEY=&lt;/code&gt; will
consist of the &lt;code class=&quot;highlighter-rouge&quot;&gt;VALUE&lt;/code&gt; for that key.  Likewise, if the &lt;code class=&quot;highlighter-rouge&quot;&gt;VALUE&lt;/code&gt; is numeric,
you can have
&lt;a href=&quot;/zipcpu/2017/10/05/autofpga-intro.html&quot;&gt;AutoFPGA&lt;/a&gt;
calculate the value by placing a &lt;code class=&quot;highlighter-rouge&quot;&gt;$&lt;/code&gt; between the &lt;code class=&quot;highlighter-rouge&quot;&gt;@&lt;/code&gt; and the &lt;code class=&quot;highlighter-rouge&quot;&gt;KEY&lt;/code&gt; and so use
the &lt;code class=&quot;highlighter-rouge&quot;&gt;@$KEY=EXPRESSION&lt;/code&gt; form.  Finally, to reference
one value, &lt;code class=&quot;highlighter-rouge&quot;&gt;@KEYONE=VALONE&lt;/code&gt;, from within another, you would reference
it as &lt;code class=&quot;highlighter-rouge&quot;&gt;@$(KEYONE)&lt;/code&gt; within the value portion of the second
&lt;code class=&quot;highlighter-rouge&quot;&gt;@KEYTWO=VALTWO&lt;/code&gt; construct.&lt;/p&gt;

&lt;p&gt;Perhaps this would make more sense if we walked through an example.&lt;/p&gt;

&lt;p&gt;Every &lt;a href=&quot;/zipcpu/2017/10/05/autofpga-intro.html&quot;&gt;AutoFPGA&lt;/a&gt;
component description begins with a &lt;code class=&quot;highlighter-rouge&quot;&gt;@PREFIX&lt;/code&gt; tag.  This defines the beginning
of the component, as well as providing a name for the component.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;@PREFIX=bustimer&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;I chose to call this device a &lt;code class=&quot;highlighter-rouge&quot;&gt;bustimer&lt;/code&gt;.  Unlike other timers that might be
internal to other portions of the design, this one can be accessed from the
main &lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;wishbone bus&lt;/a&gt;–hence
the name.&lt;/p&gt;

&lt;p&gt;If you are following along from the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/zipbones.v&quot;&gt;ZipBones&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/tinyzip/blob/master/auto-data/zipbones.txt&quot;&gt;configuration&lt;/a&gt;
file, you can skip to the &lt;code class=&quot;highlighter-rouge&quot;&gt;@PREFIX=bustimer&lt;/code&gt; line.  The information prior
defines how to connect the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/zipbones.v&quot;&gt;ZipBones&lt;/a&gt;
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
wrapper to the bus.  A watchdog timer definition follows this one, all within
the same
&lt;a href=&quot;https://github.com/ZipCPU/tinyzip/blob/master/auto-data/zipbones.txt&quot;&gt;configuration&lt;/a&gt;
file.&lt;/p&gt;

&lt;p&gt;While &lt;a href=&quot;/zipcpu/2017/10/05/autofpga-intro.html&quot;&gt;AutoFPGA&lt;/a&gt;
doesn’t require it, I often define a &lt;code class=&quot;highlighter-rouge&quot;&gt;@DEVID&lt;/code&gt; tag.  I
primarily use this tag for contexts that don’t like lower case.
&lt;a href=&quot;/zipcpu/2017/10/05/autofpga-intro.html&quot;&gt;AutoFPGA&lt;/a&gt;
doesn’t do anything fancy with this tag, other then paste it into other
tags as I tell it to below.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;@DEVID=BUSTIMER&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The &lt;a href=&quot;https://github.com/ZipCPU/tinyzip/blob/master/rtl/main.v&quot;&gt;main.v&lt;/a&gt;
file of an
&lt;a href=&quot;/zipcpu/2017/10/05/autofpga-intro.html&quot;&gt;AutoFPGA&lt;/a&gt;
based project starts with a series of
&lt;code class=&quot;highlighter-rouge&quot;&gt;ifdef&lt;/code&gt;’s just before the &lt;code class=&quot;highlighter-rouge&quot;&gt;module&lt;/code&gt; declaration.  This allows a user to select
some items and not others, as well as capturing a set of dependencies of what
items depend upon others.  In this case, we have no dependencies, but we’ll
still create an &lt;code class=&quot;highlighter-rouge&quot;&gt;define&lt;/code&gt; line in case something else depends upon this
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_(computing)&quot;&gt;bus&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/ziptimer.v&quot;&gt;timer&lt;/a&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;@ACCESS=@$(DEVID)_ACCESS&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Now let’s connect our timer to a
&lt;a href=&quot;/zipcpu/2017/05/29/simple-wishbone.html&quot;&gt;wishbone bus&lt;/a&gt;.
Specifically, we want to connect this component to the system
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_(computing)&quot;&gt;bus&lt;/a&gt;,
by default named &lt;code class=&quot;highlighter-rouge&quot;&gt;wb&lt;/code&gt;.
We’ll also declare that this
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_(computing)&quot;&gt;bus&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/ziptimer.v&quot;&gt;timer&lt;/a&gt;
is a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_(computing)&quot;&gt;bus&lt;/a&gt;
slave whose result is always available and that never stalls,
&lt;code class=&quot;highlighter-rouge&quot;&gt;@SLAVE.TYPE=SINGLE&lt;/code&gt;, and one that has only a single address, &lt;code class=&quot;highlighter-rouge&quot;&gt;@NADDR=1&lt;/code&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;@SLAVE.BUS=wb
@SLAVE.TYPE=SINGLE
@NADDR=1&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Actually connecting this to a
&lt;a href=&quot;/zipcpu/2017/05/29/simple-wishbone.html&quot;&gt;bus&lt;/a&gt;
depends upon the code we want to place into our
&lt;a href=&quot;https://github.com/ZipCPU/tinyzip/blob/master/rtl/main.v&quot;&gt;main.v&lt;/a&gt;
file.  This is the purpose of the &lt;code class=&quot;highlighter-rouge&quot;&gt;@MAIN.INSERT&lt;/code&gt; tag.  Code within
this tag will get copied directly (after variable name substitution) into the
&lt;a href=&quot;https://github.com/ZipCPU/tinyzip/blob/master/rtl/main.v&quot;&gt;main.v&lt;/a&gt;
file.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;@MAIN.INSERT=
	ziptimer @$(PREFIX)i(i_clk, i_reset, 1&#39;b1,
			wb_cyc, (wb_stb)&amp;amp;&amp;amp;(@$(PREFIX)_sel), wb_we, wb_data,
				@$(PREFIX)_ack, @$(PREFIX)_stall,
				@$(PREFIX)_data, @$(PREFIX)_int);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;While you don’t need to reference the &lt;code class=&quot;highlighter-rouge&quot;&gt;@$(PREFIX)&lt;/code&gt; tag at all, I often use this
to help keep the names unique within any given design.  Once the pattern
matching takes place, these lines will just turn into:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;@MAIN.INSERT=
	ziptimer bustimeri(i_clk, i_reset, 1&#39;b1,
			wb_cyc, (wb_stb)&amp;amp;&amp;amp;(bustimer_sel), wb_we, wb_data,
				bustimer_ack, bustimer_stall,
				bustimer_data, bustimer_int);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;You don’t need to define the &lt;code class=&quot;highlighter-rouge&quot;&gt;bustimer_ack&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;bustimer_stall&lt;/code&gt;, or
&lt;code class=&quot;highlighter-rouge&quot;&gt;bustimer_data&lt;/code&gt; wires.
&lt;a href=&quot;/zipcpu/2017/10/05/autofpga-intro.html&quot;&gt;AutoFPGA&lt;/a&gt;
will define these for you once you tell it that this item is a
&lt;a href=&quot;/zipcpu/2017/05/29/simple-wishbone.html&quot;&gt;bus&lt;/a&gt; slave.
&lt;a href=&quot;/zipcpu/2017/10/05/autofpga-intro.html&quot;&gt;AutoFPGA&lt;/a&gt;
will also create a &lt;code class=&quot;highlighter-rouge&quot;&gt;bustimer_sel&lt;/code&gt; wire.  This wire will be true any time this
&lt;a href=&quot;/zipcpu/2017/05/29/simple-wishbone.html&quot;&gt;bus&lt;/a&gt;
component’s address is selected.  You do need to connect these wires to your
component, as we’ve done above.&lt;/p&gt;

&lt;p&gt;After running
&lt;a href=&quot;/zipcpu/2017/10/05/autofpga-intro.html&quot;&gt;AutoFPGA&lt;/a&gt;,
you should then be able to find this code snipped in the
&lt;a href=&quot;https://github.com/ZipCPU/tinyzip/blob/master/rtl/main.v&quot;&gt;main.v&lt;/a&gt;,
file.
&lt;a href=&quot;/zipcpu/2017/10/05/autofpga-intro.html&quot;&gt;AutoFPGA&lt;/a&gt;
will also declare the rest of the wires necessary to set this up as well.&lt;/p&gt;

&lt;p&gt;The last wire, &lt;code class=&quot;highlighter-rouge&quot;&gt;bustimer_int&lt;/code&gt;, is also defined automatically by
&lt;a href=&quot;/zipcpu/2017/10/05/autofpga-intro.html&quot;&gt;AutoFPGA&lt;/a&gt; as
part of generating and connecting up the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interrupt&quot;&gt;interrupt&lt;/a&gt;
wires.  In our case, we have a &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/icontrol.v&quot;&gt;programmable interrupt controller
(PIC)&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/tinyzip/blob/master/auto-data/pic.txt&quot;&gt;defined elsewhere in the
design&lt;/a&gt;
with the name of &lt;code class=&quot;highlighter-rouge&quot;&gt;buspic&lt;/code&gt;.  Hence, all we need to tell
&lt;a href=&quot;/zipcpu/2017/10/05/autofpga-intro.html&quot;&gt;AutoFPGA&lt;/a&gt;
is that we have an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interrupt&quot;&gt;interrupt&lt;/a&gt;
named &lt;code class=&quot;highlighter-rouge&quot;&gt;BUSTIMER&lt;/code&gt;, whose
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interrupt&quot;&gt;interrupt&lt;/a&gt;
wire is &lt;code class=&quot;highlighter-rouge&quot;&gt;bustimer_int&lt;/code&gt;, that needs to be connected to the
&lt;code class=&quot;highlighter-rouge&quot;&gt;buspic&lt;/code&gt;s inputs.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;@INT.BUSTIMER.WIRE= @$(PREFIX)_int
@INT.BUSTIMER.PIC= buspic&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This will add our &lt;code class=&quot;highlighter-rouge&quot;&gt;bustimer_int&lt;/code&gt; to the list of components within the
&lt;code class=&quot;highlighter-rouge&quot;&gt;bus_int_vector&lt;/code&gt;.  Hence, if you check the
&lt;a href=&quot;https://github.com/ZipCPU/tinyzip/blob/master/rtl/main.v&quot;&gt;main.v&lt;/a&gt;
file, you’ll see the &lt;code class=&quot;highlighter-rouge&quot;&gt;bustimer_int&lt;/code&gt; listed long with the other
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interrupt&quot;&gt;interrupt&lt;/a&gt;
lines.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;assign	bus_int_vector = {
	// ...
	bustimer_int,
	// ...
};&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Internal to the
&lt;a href=&quot;https://github.com/ZipCPU/tinyzip/blob/master/sw/zlib/board.h&quot;&gt;board.h&lt;/a&gt;
file that
&lt;a href=&quot;/zipcpu/2017/10/05/autofpga-intro.html&quot;&gt;AutoFPGA&lt;/a&gt;
creates for the internal processor that might use this design, this will
also create a line,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;cp&quot;&gt;#define	BUSPIC_BUSTIMER	BUSPIC(1)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;after assigning this peripheral to
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interrupt&quot;&gt;interrupt&lt;/a&gt;
control wire number one.&lt;/p&gt;

&lt;p&gt;The last two parts deal with non-Verilog parts of the design.  The first of
these deals with &lt;a href=&quot;/blog/2017/06/29/sw-dbg-interface.html&quot;&gt;connecting this device to the external debugging
interface&lt;/a&gt;.
Specifically, we’ll want to create a register, &lt;code class=&quot;highlighter-rouge&quot;&gt;R_BUSTIMER&lt;/code&gt;, with the human
name, &lt;code class=&quot;highlighter-rouge&quot;&gt;BUSTIMER&lt;/code&gt;.  These next three lines adjust the files
&lt;a href=&quot;https://github.com/ZipCPU/tinyzip/blob/master/sw/host/regdefs.h&quot;&gt;regdefs.h&lt;/a&gt;
and &lt;a href=&quot;https://github.com/ZipCPU/tinyzip/blob/master/sw/host/regdefs.cpp&quot;&gt;regdefs.cpp&lt;/a&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;@REGS.NOTE= // The bus timer
@REGS.N=1
@REGS.0= 0 R_@$(DEVID) @$(DEVID)&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;First, upon reading these lines,
&lt;a href=&quot;/zipcpu/2017/10/05/autofpga-intro.html&quot;&gt;AutoFPGA&lt;/a&gt;
will place a definition into the
&lt;a href=&quot;https://github.com/ZipCPU/tinyzip/blob/master/sw/host/regdefs.h&quot;&gt;regdefs.h&lt;/a&gt;
output file, defining an
&lt;code class=&quot;highlighter-rouge&quot;&gt;R_BUSTIMER&lt;/code&gt; identifier to be equivalent to the address of this
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/ziptimer.v&quot;&gt;timer&lt;/a&gt;
register.  This will tell external host components where in the memory
space to access this register when using &lt;code class=&quot;highlighter-rouge&quot;&gt;readio()&lt;/code&gt; or &lt;code class=&quot;highlighter-rouge&quot;&gt;writeio()&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/zipcpu/2017/10/05/autofpga-intro.html&quot;&gt;AutoFPGA&lt;/a&gt;
will also place references to this register into
&lt;a href=&quot;https://github.com/ZipCPU/tinyzip/blob/master/sw/host/regdefs.cpp&quot;&gt;regdefs.cpp&lt;/a&gt;.
&lt;a href=&quot;https://github.com/ZipCPU/tinyzip/blob/master/sw/host/regdefs.cpp&quot;&gt;This file&lt;/a&gt;
contains a mapping between the computer regiser name &lt;code class=&quot;highlighter-rouge&quot;&gt;R_BUSTIMER&lt;/code&gt;
and the user name for this register, &lt;code class=&quot;highlighter-rouge&quot;&gt;BUSTIMER&lt;/code&gt;.  As a result, you can then
use the &lt;code class=&quot;highlighter-rouge&quot;&gt;wbregs&lt;/code&gt; program, a variant of the old fashioned
&lt;a href=&quot;https://en.wikipedia.org/wiki/PEEK_and_POKE&quot;&gt;peek and poke hardware interface&lt;/a&gt;,
to read from the
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/ziptimer.v&quot;&gt;timer&lt;/a&gt;
with the command &lt;code class=&quot;highlighter-rouge&quot;&gt;wbregs bustimer&lt;/code&gt;, or to write to it via
&lt;a href=&quot;/blog/2017/06/29/sw-dbg-interface.html&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;wbregs bustimer newvalue&lt;/code&gt;&lt;/a&gt;.
(I have another version of this program called &lt;code class=&quot;highlighter-rouge&quot;&gt;avregs&lt;/code&gt; for use with the
&lt;a href=&quot;https://www.altera.com/literature/manual/mnl_avalon_spec.pdf&quot;&gt;Avalon bus&lt;/a&gt;
on a
&lt;a href=&quot;/blog/2018/02/09/first-cyclonev.html&quot;&gt;Cyclone-V&lt;/a&gt;
 …)&lt;/p&gt;

&lt;p&gt;The last item places a reference to this
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/ziptimer.v&quot;&gt;timer&lt;/a&gt;
into the
&lt;a href=&quot;https://github.com/ZipCPU/tinyzip/blob/master/sw/zlib/board.h&quot;&gt;board.h&lt;/a&gt;
file.  This file would be used by the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
to know if the
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/ziptimer.v&quot;&gt;timer&lt;/a&gt;
was built into the design and, if so, what address that
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/ziptimer.v&quot;&gt;timer&lt;/a&gt;
was placed into.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;@BDEF.IONAME=_bustimer
@BDEF.IOTYPE=unsigned
@BDEF.OSDEF=_BOARD_HAS_@$(DEVID)
@BDEF.OSVAL=static volatile @$BDEF.IOTYPE *const @$(BDEF.IONAME) = ((@$BDEF.IOTYPE *)@$[0x%08x](REGBASE));&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;a href=&quot;/zipcpu/2017/10/05/autofpga-intro.html&quot;&gt;AutoFPGA&lt;/a&gt;
will use this to create a line, similar to the following one, inside the
&lt;a href=&quot;https://github.com/ZipCPU/tinyzip/blob/master/sw/zlib/board.h&quot;&gt;board.h&lt;/a&gt;
file:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;cp&quot;&gt;#ifdef	BUSTIMER_ACCESS
#define	_BOARD_HAS_BUSTIMER
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;volatile&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_bustimer&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;mh&quot;&gt;0x00100000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;cp&quot;&gt;#endif	// BUSTIMER_ACCESS&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Remember, the goal of
&lt;a href=&quot;/zipcpu/2017/10/05/autofpga-intro.html&quot;&gt;AutoFPGA&lt;/a&gt;
is to make the inclusion of
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_(computing)&quot;&gt;bus&lt;/a&gt;
components into a design easier.  Hence, by placing these few lines into an
&lt;a href=&quot;/zipcpu/2017/10/05/autofpga-intro.html&quot;&gt;AutoFPGA&lt;/a&gt;
configuration file, this
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_(computing)&quot;&gt;bus&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/ziptimer.v&quot;&gt;timer&lt;/a&gt;
will be included into the design.  Removing these lines from the
&lt;a href=&quot;/zipcpu/2017/10/05/autofpga-intro.html&quot;&gt;AutoFPGA&lt;/a&gt;
configuration will seemlessly remove this
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_(computing)&quot;&gt;bus&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/ziptimer.v&quot;&gt;timer&lt;/a&gt;
from the design.&lt;/p&gt;

&lt;h2 id=&quot;conclusions&quot;&gt;Conclusions&lt;/h2&gt;

&lt;p&gt;We’ve now gone over everything it takes to create a useful countdown timer
within an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
design–whether a “one-shot” timer, or a fully programmable
interval timer.  Once put together, the final &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/ziptimer.v&quot;&gt;Verilog
code&lt;/a&gt;
isn’t all that much more difficult than
the original counter we started out from.  What may surprise you, though,
is how much work we went through to place such a &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/ziptimer.v&quot;&gt;simple
counter&lt;/a&gt;
into a design.  Not only did we
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formally&lt;/a&gt;
verify our
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/ziptimer.v&quot;&gt;timer&lt;/a&gt;,
but then we also had to connect it to the
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;wishbone bus&lt;/a&gt;
within the design.  We also dealt with several subtle issues associated with
making a
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/ziptimer.v&quot;&gt;timer&lt;/a&gt;
useful along the way.&lt;/p&gt;

&lt;p&gt;What can you use such a
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/ziptimer.v&quot;&gt;timer&lt;/a&gt;
for?&lt;/p&gt;

&lt;p&gt;We’ve already discussed how this can be the centerpiece of the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Computer_multitasking&quot;&gt;multitasking&lt;/a&gt;
implementation within an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Operating_System&quot;&gt;Operating System&lt;/a&gt;.
Upon any
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/ziptimer.v&quot;&gt;timer&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interrupt&quot;&gt;interrupt&lt;/a&gt;, the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Operating_System&quot;&gt;Operating System&lt;/a&gt;
can then swap user tasks or processes.
&lt;a href=&quot;https://www.blueletterbible.org/kjv/jas/4/15&quot;&gt;Should the Lord will&lt;/a&gt;, I’ll
come back and share how one
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/s6soc&quot;&gt;implementation&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/s6soc/blob/master/sw/zipos/kernel.c&quot;&gt;uses this&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interrupt&quot;&gt;interrupt&lt;/a&gt;
for exactly that purpose.&lt;/p&gt;

&lt;p&gt;There’s another valuable use of a
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/ziptimer.v&quot;&gt;timer&lt;/a&gt;
such as this–one which may not be
as obvious.  In the presentation above, we discussed wiring the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interrupt&quot;&gt;interrupt&lt;/a&gt;
wire to the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Soft_microprocessor&quot;&gt;CPU&lt;/a&gt;’s
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/icontrol.v&quot;&gt;interrupt controller&lt;/a&gt;.  If you instead connected the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interrupt&quot;&gt;interrupt&lt;/a&gt;
output to the reset wire for the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Soft_microprocessor&quot;&gt;CPU&lt;/a&gt;,
you would have created a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Watchdog_timer&quot;&gt;watchdog&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/ziptimer.v&quot;&gt;timer&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;So you see, a basic counter isn’t nearly as irrelevant as you might have
thought it would be, neither is it as simple.  It’s also provides a very
good example of the full
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
&lt;a href=&quot;/blog/2017/06/02/design-process.html&quot;&gt;design process&lt;/a&gt;.&lt;/p&gt;
&lt;hr /&gt;&lt;p&gt;&lt;em&gt;And He said unto them, It is not for you to know the times or the seasons, which the Father hath put in His own power. (Acts 1:7)&lt;/em&gt;</description>
        <pubDate>Tue, 17 Apr 2018 00:00:00 -0400</pubDate>
        <link>https://zipcpu.com/zipcpu/2018/04/17/ziptimer.html</link>
        <guid isPermaLink="true">https://zipcpu.com/zipcpu/2018/04/17/ziptimer.html</guid>
        
        
        <category>zipcpu</category>
        
      </item>
    
      <item>
        <title>Formally Verifying an Asynchronous Reset</title>
        <description>&lt;p&gt;&lt;a href=&quot;/blog/2017/10/20/cdc.html&quot;&gt;Clock Domain Crossings&lt;/a&gt;
can be difficult to get right.  This applies not only
to crossing data and logic from one clock domain to another, but also to
crossing resets from one clock domain to another.  The general rule is that all
logic &lt;a href=&quot;https://en.wikipedia.org/wiki/Flip-flop_(electronics)#Timing_considerations&quot;&gt;must have a guaranteed settling time before the next rising edge of
the next clock&lt;/a&gt;.
If this rule is violated then logic may enter a state that
is neither &lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt; nor &lt;code class=&quot;highlighter-rouge&quot;&gt;0&lt;/code&gt;, neither true nor false.&lt;/p&gt;

&lt;p&gt;This is
&lt;a href=&quot;https://en.wikipedia.org/wiki/Metastability_in_electronics&quot;&gt;metastability&lt;/a&gt;.
Avoid it at all costs.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 1. Synchronizing an Asynchronous Reset&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/areset-regions.svg&quot; width=&quot;360&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;In the case of an asynchronous reset, it usually doesn’t matter all that much
during which clock interval the design enters into the reset state.  As long
as the reset remains active long enough to fully propagate through the design,
everything will eventually enter into this state.  What matters is whether or
not the whole design leaves the reset state at the same time: on a clock edge.&lt;/p&gt;

&lt;p&gt;Fig 1. shows an example of such an asynchronous reset.  The negative logic
reset comes into the design with no guarantee of being synchronous with
the clock.
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flip-flop_(electronics)&quot;&gt;Flip-flops&lt;/a&gt;
dependent upon that reset may then enter into a metastable state, shown by
the pink background in the figure.  Logic within the design needs to
recognize this reset, and synchronize its release.  This is shown by the
green region, where the adjusted reset clears and returns to zero at
the sime time as the rising edge of the system clock.&lt;/p&gt;

&lt;p&gt;You may also notice from Fig 1 that the incoming asynchronous reset
signal is based upon negative logic.  In other words, to activate the reset
the logic needs to be pulled low.  This is a common practice in
&lt;a href=&quot;/blog/2017/10/13/fpga-v-asic.html&quot;&gt;ASIC designs&lt;/a&gt;,
since it allows a design to start entering into its reset state before
sufficient power is available to assert a positive going reset across the
entire design–although this isn’t usually required with FPGA designs.&lt;/p&gt;

&lt;p&gt;Since the logic necessary to do this is pretty simple, let’s take a look at it
in the next section.&lt;/p&gt;

&lt;h2 id=&quot;verilog&quot;&gt;Verilog&lt;/h2&gt;

&lt;p&gt;For our &lt;a href=&quot;/examples/areset.v&quot;&gt;simple Verilog example&lt;/a&gt;,
let’s create a synchronous positive logic
reset signal from a negative logic asynchronous reset.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: left&quot;&gt;&lt;caption&gt;Fig 2. Three Flip-flop Asynchronous Reset Synchronizer&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/areset-fifos.svg&quot; width=&quot;360&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;The &lt;a href=&quot;/examples/areset.v&quot;&gt;basic code&lt;/a&gt;
just sets the outgoing reset and the three
&lt;a href=&quot;/blog/2017/10/20/cdc.html&quot;&gt;flip-flop synchronizers&lt;/a&gt;
to &lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt; anytime the asynchronous reset is true, and then waits for three clock
edges to release.  You can see this basic logic pictorially in Fig 2 on the
left.&lt;/p&gt;

&lt;p&gt;Since &lt;a href=&quot;/examples/areset.v&quot;&gt;the code&lt;/a&gt;
itself is so short, I’ll spend a moment touching on some
details I usually avoid along the way.  For example, I (now) always start
any Verilog design by setting the &lt;code class=&quot;highlighter-rouge&quot;&gt;default_nettype&lt;/code&gt; to
&lt;code class=&quot;highlighter-rouge&quot;&gt;none&lt;/code&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;`default_nettype	none&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This one statement is really a blessing when it comes to finding
errors within your code.  Verilog specifies that the default synthesizer
behavior upon finding any undeclared identifier
is to assume that the identifier was supposed to reference a &lt;code class=&quot;highlighter-rouge&quot;&gt;wire&lt;/code&gt;, and so
the synthesizer will then quietly declare a &lt;code class=&quot;highlighter-rouge&quot;&gt;wire&lt;/code&gt; for you when you would have
rather had the synthesizer report an error due to your misspelling.  By
telling the synthesis tool not to do this, it becomes much easier to catch
errors you might have in your code.&lt;/p&gt;

&lt;p&gt;Our module will accept two inputs, and produce one output.  The two inputs will
be the clock, &lt;code class=&quot;highlighter-rouge&quot;&gt;i_clk&lt;/code&gt; and the negative going asynchronous reset, &lt;code class=&quot;highlighter-rouge&quot;&gt;i_areset_n&lt;/code&gt;.
The underscores here have specific meanings.  &lt;code class=&quot;highlighter-rouge&quot;&gt;i_&lt;/code&gt; references an input,
&lt;code class=&quot;highlighter-rouge&quot;&gt;o_&lt;/code&gt; in a moment will reference an output, and in the case of this reset the
&lt;code class=&quot;highlighter-rouge&quot;&gt;_n&lt;/code&gt; suffix references negative logic.  The last item in our portlist is
our synchronized output signal, &lt;code class=&quot;highlighter-rouge&quot;&gt;o_reset&lt;/code&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;module areset(i_clk, i_areset_n, o_reset);
	input	wire	i_clk, i_areset_n;
	output	reg	o_reset;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;To handle the synchronization, we’ll use a &lt;a href=&quot;/blog/2017/10/20/cdc.html&quot;&gt;three clock
synchronizer&lt;/a&gt;.  This requires
two internal state bits that we’ll call &lt;code class=&quot;highlighter-rouge&quot;&gt;sync_fifo&lt;/code&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	reg	[1:0]	sync_fifo;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;We’ll also assume the design begins in a reset state, and so initialize our
&lt;a href=&quot;/blog/2017/10/20/cdc.html&quot;&gt;synchronization FIFO&lt;/a&gt;
and our output to start in a reset condition.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	initial	sync_fifo = 2&#39;h3;
	initial	o_reset = 1&#39;b1;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Enough of the preliminaries.  What does it take to synchronize a reset?
Just the following four lines of code.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(posedge i_clk or negedge i_areset_n)
	if (!i_areset_n)
		{ o_reset, sync_fifo } &amp;lt;= 3&#39;h7;
	else
		{ o_reset, sync_fifo } &amp;lt;= { sync_fifo, 1&#39;b0 };&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;So how does this work?  As shown in Fig 1 above, anytime &lt;code class=&quot;highlighter-rouge&quot;&gt;i_areset_n&lt;/code&gt; goes low
(active), then we set the synchonizer and the output reset registers to all
ones.  Otherwise, if &lt;code class=&quot;highlighter-rouge&quot;&gt;i_areset_n&lt;/code&gt; is high (inactive), then on the positive
edge of the clock we’ll shift a zero into and through the the &lt;code class=&quot;highlighter-rouge&quot;&gt;sync_fifo&lt;/code&gt;
shift register until it clears the &lt;code class=&quot;highlighter-rouge&quot;&gt;o_reset&lt;/code&gt; output.&lt;/p&gt;

&lt;p&gt;That’s it.  There’s really not that much more to it.&lt;/p&gt;

&lt;p&gt;That is, there’s nothing more involved unless you want to
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formally verify&lt;/a&gt;
that this operation works as advertised.  Hence, let’s look at
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formally verifying&lt;/a&gt;
this reset logic in the next section.&lt;/p&gt;

&lt;h2 id=&quot;formal-properties&quot;&gt;Formal Properties&lt;/h2&gt;

&lt;p&gt;When it comes to
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal properties&lt;/a&gt;,
I’ve &lt;a href=&quot;/zipcpu/2018/03/21/dblfetch.html&quot;&gt;recently started including
“contracts”&lt;/a&gt; into the
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal properties&lt;/a&gt;
I write.  I’ve found it valuable to clearly indicate what the minimum
you want something to do is.  Let’s do that here.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;`ifdef	FORMAL
	////////////////////////////////////////////////////
	//
	// Our &quot;contract&quot;
	//
	////////////////////////////////////////////////////
	//&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;In this case, I can think of four basic properties that are relevant.&lt;/p&gt;

&lt;p&gt;The first is our one assumption that we always start in a reset state.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	initial	assume(!i_areset_n);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Our next property is that any time &lt;code class=&quot;highlighter-rouge&quot;&gt;i_areset_n&lt;/code&gt; is low (active) our outgoing
reset value &lt;code class=&quot;highlighter-rouge&quot;&gt;o_reset&lt;/code&gt; must be high (active).&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(*)
	if (!i_areset_n)
		assert(o_reset);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;At this point I can hear someone asking, doesn’t that make this an
asynchronous reset as well?&lt;/p&gt;

&lt;p&gt;Yes, technically it does.  However, &lt;code class=&quot;highlighter-rouge&quot;&gt;o_reset&lt;/code&gt; is guaranteed to also be high
for at least one clock before it is released, so we can (usually) just treat
it as a regular synchronous logic reset as well.  There is a risk
that this reset will send some
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flip-flop_(electronics)&quot;&gt;flip-flops&lt;/a&gt;
into a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Metastability_in_electronics&quot;&gt;metastable&lt;/a&gt; state
for one clock cycle.
While this is a possibility when using &lt;code class=&quot;highlighter-rouge&quot;&gt;o_reset&lt;/code&gt;, those
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flip-flop_(electronics)&quot;&gt;flip-flops&lt;/a&gt;
will be reset in the next clock interval.  If this is not acceptable
for your logic, then just treat &lt;code class=&quot;highlighter-rouge&quot;&gt;o_reset&lt;/code&gt; as an asynchronous reset.&lt;/p&gt;

&lt;p&gt;The third part of our contract is that we only ever leave the reset state
on the positive edge of any clock.  This property is a little less intuitive
to express as an &lt;code class=&quot;highlighter-rouge&quot;&gt;assert&lt;/code&gt;ion.  Specifically, we want to assert that any
time &lt;code class=&quot;highlighter-rouge&quot;&gt;o_reset&lt;/code&gt; transitions from &lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt; to &lt;code class=&quot;highlighter-rouge&quot;&gt;0&lt;/code&gt;, i.e. any time it &lt;em&gt;falls&lt;/em&gt;,
that the clock is also transitioning from &lt;code class=&quot;highlighter-rouge&quot;&gt;0&lt;/code&gt; to &lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt; (&lt;em&gt;rising&lt;/em&gt;).&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @($global_clock)
	if ($fell(o_reset))
		assert($rose(i_clk));&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;As one last part of our
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal proof&lt;/a&gt;,
let’s &lt;code class=&quot;highlighter-rouge&quot;&gt;cover()&lt;/code&gt; the release from reset to make certain this design will
release from reset like we expect it to.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(*)
		cover(!o_reset);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;At this point, if we only wanted to pass a bounded model check we’d be done.
If you instead want to &lt;em&gt;prove&lt;/em&gt; that this asynchronous reset works, then you’ll
&lt;a href=&quot;/blog/2018/03/10/induction-exercise.html&quot;&gt;need to create some more
formal properties&lt;/a&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	////////////////////////////////////////////////////
	//
	// Extras for passing induction
	//
	////////////////////////////////////////////////////&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;These extra properties are primarily used to make certain that the &lt;a href=&quot;/blog/2018/03/10/induction-exercise.html&quot;&gt;induction
engine doesn’t find the design in an unreachable
state&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;For the first of these properties, we’ll assert that any time the design
is not in a reset condition, then the &lt;code class=&quot;highlighter-rouge&quot;&gt;sync_fifo&lt;/code&gt; shift register bits should
be zero as well.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(*)
	if (!o_reset)
		assert(sync_fifo == 2&#39;b00);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;In a similar fashion, the &lt;code class=&quot;highlighter-rouge&quot;&gt;sync_fifo&lt;/code&gt; should &lt;em&gt;never&lt;/em&gt; be able to get into
a state where the bits are &lt;code class=&quot;highlighter-rouge&quot;&gt;2&#39;b01&lt;/code&gt;.  This property is necessary
to keep the &lt;a href=&quot;/blog/2018/03/10/induction-exercise.html&quot;&gt;induction stage from starting in this unreachable
state&lt;/a&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(*)
		assert(sync_fifo != 2&#39;b01);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Likewise, any time &lt;code class=&quot;highlighter-rouge&quot;&gt;sync_fifo[1]&lt;/code&gt; is &lt;em&gt;true&lt;/em&gt;, then &lt;code class=&quot;highlighter-rouge&quot;&gt;o_reset&lt;/code&gt; should be active.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(*)
	if (sync_fifo[1])
		assert(o_reset);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Finally, any time &lt;code class=&quot;highlighter-rouge&quot;&gt;i_areset_n&lt;/code&gt; is active (low), we’ll want to make certain
that &lt;code class=&quot;highlighter-rouge&quot;&gt;sync_fifo&lt;/code&gt; is in its full reset state as &lt;code class=&quot;highlighter-rouge&quot;&gt;2&#39;b11&lt;/code&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(*)
	if (!i_areset_n)
		assert(sync_fifo == 2&#39;b11);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;All four of these criteria are necessary to make certain that the design
passes induction.&lt;/p&gt;

&lt;p&gt;That also ends the
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal properties&lt;/a&gt;
of our asynchronous reset module.&lt;/p&gt;

&lt;h2 id=&quot;symbiyosys&quot;&gt;SymbiYosys&lt;/h2&gt;

&lt;p&gt;If you want to prove this design using
&lt;a href=&quot;https://symbiyosys.readthedocs.io/en/latest&quot;&gt;SymbiYosys&lt;/a&gt;,
you’ll need to put a
&lt;a href=&quot;https://symbiyosys.readthedocs.io/en/latest&quot;&gt;SymbiYosys&lt;/a&gt;
script together to do so.  Let’s take a quick moment to build this
&lt;a href=&quot;/examples/areset.sby&quot;&gt;script&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;We’ve discussed
&lt;a href=&quot;https://symbiyosys.readthedocs.io/en/latest&quot;&gt;SymbiYosys&lt;/a&gt;
scripts a little on the blog, although we haven’t discussed
&lt;a href=&quot;https://symbiyosys.readthedocs.io/en/latest&quot;&gt;SymbiYosys&lt;/a&gt;
&lt;em&gt;tasks&lt;/em&gt; much.  For this design, we’ll use a
&lt;a href=&quot;https://symbiyosys.readthedocs.io/en/latest&quot;&gt;SymbiYosys&lt;/a&gt;
task so that we can have
&lt;a href=&quot;https://symbiyosys.readthedocs.io/en/latest&quot;&gt;SymbiYosys&lt;/a&gt;
handle both &lt;em&gt;prove&lt;/em&gt;ing that our design works, as well as the &lt;em&gt;cover&lt;/em&gt; property
above.&lt;/p&gt;

&lt;p&gt;A &lt;a href=&quot;https://symbiyosys.readthedocs.io/en/latest&quot;&gt;SymbiYosys&lt;/a&gt;
&lt;a href=&quot;/examples/areset.sby&quot;&gt;script&lt;/a&gt;
with tasks in it starts with a &lt;code class=&quot;highlighter-rouge&quot;&gt;[tasks]&lt;/code&gt; section declaring the names
of the various tasks.  In our case, we’ll declare a &lt;code class=&quot;highlighter-rouge&quot;&gt;cover&lt;/code&gt; and a &lt;code class=&quot;highlighter-rouge&quot;&gt;prove&lt;/code&gt;
task.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;[tasks]
prove
cover&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The second section of the
&lt;a href=&quot;/examples/areset.sby&quot;&gt;SymbiYosys script&lt;/a&gt;
describes the options to be given to the formal solver.  The &lt;code class=&quot;highlighter-rouge&quot;&gt;mode&lt;/code&gt; option
selects what mode we wish to run the solvers in.  For the &lt;code class=&quot;highlighter-rouge&quot;&gt;prove&lt;/code&gt; task, we’ll
run in &lt;code class=&quot;highlighter-rouge&quot;&gt;prove&lt;/code&gt; mode.  This will apply both a bounded model check as well as
the &lt;em&gt;k&lt;/em&gt;-induction pass.  Passing this task will &lt;em&gt;prove&lt;/em&gt; that the safety
properties hold.  This applies to all of the &lt;code class=&quot;highlighter-rouge&quot;&gt;assume&lt;/code&gt;s and &lt;code class=&quot;highlighter-rouge&quot;&gt;assert&lt;/code&gt;s above.
The second mode, used by our
second task, is the &lt;code class=&quot;highlighter-rouge&quot;&gt;cover&lt;/code&gt; mode.  We’ll use this to make certain our
&lt;code class=&quot;highlighter-rouge&quot;&gt;cover&lt;/code&gt; statement is reached.  The final option, &lt;code class=&quot;highlighter-rouge&quot;&gt;multiclock on&lt;/code&gt;, applies
to both tasks.  This option tells
&lt;a href=&quot;https://symbiyosys.readthedocs.io/en/latest&quot;&gt;SymbiYosys&lt;/a&gt;
that we’ll be using the asynchronous or multiple clock capabilities of the
formal solvers.&lt;/p&gt;

&lt;p&gt;For those who have been following
&lt;a href=&quot;https://symbiyosys.readthedocs.io/en/latest&quot;&gt;SymbiYosys&lt;/a&gt;
development, this option replaces the &lt;code class=&quot;highlighter-rouge&quot;&gt;clk2fflogic&lt;/code&gt;
&lt;a href=&quot;http://www.clifford.at/yosys/&quot;&gt;yosys&lt;/a&gt;
option.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;[options]
prove: mode prove
cover: mode cover
multiclock on&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The third section is the &lt;code class=&quot;highlighter-rouge&quot;&gt;[engines]&lt;/code&gt; section.  This particular design doesn’t
really need any particular engine.  We’ll pick
&lt;a href=&quot;http://yices.csl.sri.com&quot;&gt;yices&lt;/a&gt;
therefore, since it is a good general purpose engine.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;[engines]
smtbmc yices&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Alternatively, we might have just stated &lt;code class=&quot;highlighter-rouge&quot;&gt;smtbmc&lt;/code&gt; without naming the
&lt;a href=&quot;http://yices.csl.sri.com&quot;&gt;yices&lt;/a&gt;
engine, since
&lt;a href=&quot;http://yices.csl.sri.com&quot;&gt;yices&lt;/a&gt; is the default engine anyway.&lt;/p&gt;

&lt;p&gt;That leaves two sections left.  The fourth section lists the commands that
&lt;a href=&quot;http://www.clifford.at/yosys/&quot;&gt;yosys&lt;/a&gt;
itself will use to prepare our design for the
&lt;a href=&quot;http://yices.csl.sri.com&quot;&gt;formal solver&lt;/a&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;[script]
read_verilog -formal areset.v
prep -top areset&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The final section lists all the files in our design–in this case, just
&lt;code class=&quot;highlighter-rouge&quot;&gt;areset.v&lt;/code&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;[files]
areset.v&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;We’re now ready to run
&lt;a href=&quot;https://symbiyosys.readthedocs.io/en/latest&quot;&gt;SymbiYosys&lt;/a&gt;!&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span class=&quot;gp&quot;&gt;&amp;gt; &lt;/span&gt;sby -f areset.sby&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;There’s really not much more to it.  That’s all that’s required to
formally verify
a simple
&lt;a href=&quot;/examples/areset.v&quot;&gt;asynchronous reset&lt;/a&gt;
design.&lt;/p&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;Proving that this &lt;a href=&quot;/examples/areset.v&quot;&gt;asynchronous reset to synchronous release
module&lt;/a&gt;
works may seem trivial, but it does demonstrate a lot of the capabilities of the
open source formal tools.  For example, did you notice that this proof applies
to &lt;em&gt;any&lt;/em&gt; clock structure?&lt;/p&gt;

&lt;p&gt;There are several other simple designs that can be proven just like this one.
Examples include a clock gate, clock switch, input or output DDR components
or even SERDES implementations.
I discuss each these projects in my Formal Verification course, before
offering them as student exercises.  &lt;a href=&quot;https://www.blueletterbible.org/kjv/jas/4/15&quot;&gt;If the Lord is
willing&lt;/a&gt;,
we’ll continue with these techniques to create and then &lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formally
verify&lt;/a&gt; an
&lt;a href=&quot;https://www.sunburst-design.com/papers/CummingsSNUG2002SJ_FIFO1.pdf&quot;&gt;asynchronous FIFO&lt;/a&gt;
as a future post.&lt;/p&gt;

&lt;hr /&gt;&lt;p&gt;&lt;em&gt;Come now, and let us reason together, saith the LORD: though your sins be as scarlet, they shall be as white as snow; though they be red like crimson, they shall be as wool.  (Is 1:18)&lt;/em&gt;</description>
        <pubDate>Thu, 12 Apr 2018 00:00:00 -0400</pubDate>
        <link>https://zipcpu.com/formal/2018/04/12/areset.html</link>
        <guid isPermaLink="true">https://zipcpu.com/formal/2018/04/12/areset.html</guid>
        
        
        <category>formal</category>
        
      </item>
    
      <item>
        <title>What would you like to see on the ZipCPU blog?</title>
        <description>&lt;p&gt;The &lt;a href=&quot;https://zipcpu.com/&quot;&gt;ZipCPU blog&lt;/a&gt; has recently picked
up a lot of readers in light of my
&lt;a href=&quot;/blog/2018/04/02/formal-cpu-bugs.html&quot;&gt;recent on-going work&lt;/a&gt;
to &lt;a href=&quot;/blog/2018/04/02/formal-cpu-bugs.html&quot;&gt;formally verify&lt;/a&gt;
the entire &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;To all of those new readers, &lt;em&gt;Welcome!&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;The &lt;a href=&quot;https://zipcpu.com/&quot;&gt;ZipCPU blog&lt;/a&gt; is dedicated to helping
FPGA designers avoid getting stuck in
&lt;a href=&quot;/blog/2017/05/19/fpga-hell.html&quot;&gt;FPGA Hell&lt;/a&gt;–a place where
&lt;a href=&quot;/blog/2017/09/14/even-i-get-stuck.html&quot;&gt;your design doesn’t work and you can’t figure out why
not&lt;/a&gt;.  To this end,
I’ve presented techniques for &lt;a href=&quot;/blog/2017/06/21/looking-at-verilator.html&quot;&gt;simulating your design using
Verilator&lt;/a&gt;,
&lt;a href=&quot;https://github.com/ZipCPU/dbgbus/blob/master/hexbus/README.md&quot;&gt;how to build a debugging
bus&lt;/a&gt; for
command, control, and internal register and state inspection, &lt;a href=&quot;/blog/2017/06/08/simple-scope.html&quot;&gt;how to build
your own internal logic
analyzer&lt;/a&gt;,
&lt;a href=&quot;/blog/2017/07/08/getting-started-with-wbscope.html&quot;&gt;how to use my own wishbone
scope&lt;/a&gt;,
&lt;a href=&quot;/blog/2017/07/31/vcd.html&quot;&gt;how the VCD file format expresses your logic
trace&lt;/a&gt;,
&lt;a href=&quot;/dsp/2017/07/24/dsp-debugging.html&quot;&gt;how to debug a DSP
algorithm&lt;/a&gt;,
&lt;a href=&quot;/blog/2017/06/17/why-network-debugging.html&quot;&gt;network debugging&lt;/a&gt;,
and more.&lt;/p&gt;

&lt;p&gt;Recently I’ve started learning about &lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal
verification&lt;/a&gt;,
and so I’ve added &lt;a href=&quot;/formal/formal.html&quot;&gt;that
topic&lt;/a&gt;
to my list as well.  As a result there have now been
&lt;a href=&quot;/formal/formal.html&quot;&gt;several articles&lt;/a&gt;
on how to &lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formally
verify&lt;/a&gt;
your logic as and after you have put it together, and &lt;a href=&quot;/blog/2018/03/14/is-formal-hard.html&quot;&gt;the value of formal
verification&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;What you as a reader need to know, however, is that these articles are
&lt;a href=&quot;https://www.patreon.com/ZipCPU&quot;&gt;sponsor supported&lt;/a&gt;.  If you find this blog
valuable, and would like to see it continue, then please consider becoming
one of my &lt;a href=&quot;https://www.patreon.com/ZipCPU&quot;&gt;Patreon Sponsors&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;One of the perks of being a
&lt;a href=&quot;https://www.patreon.com/ZipCPU&quot;&gt;sponsor&lt;/a&gt;
is that I am responsive to the topics my
&lt;a href=&quot;https://www.patreon.com/ZipCPU&quot;&gt;sponsors&lt;/a&gt;
are interested in.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.patreon.com/ZipCPU&quot;&gt;sponsors&lt;/a&gt;.
So, here’s a short list of some of the upcoming topics which I think would be
fun to post about.  If you are one of my
&lt;a href=&quot;https://www.patreon.com/ZipCPU&quot;&gt;sponsors&lt;/a&gt;,
then please consider yourself invited to contact me and let me know
which of these (or other) topics you might be interested in.  There
is also a more complete list of both past and upcoming topics in the site
&lt;a href=&quot;/topics.html&quot;&gt;topics&lt;/a&gt; list as well.&lt;/p&gt;

&lt;p&gt;So, without further delay, here are some of the topics I am considering
writing about in the near future, should &lt;a href=&quot;https://www.blueletterbible.org/kjv/jas/4/15&quot;&gt;the Lord be
willing&lt;/a&gt;:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;ZBasic ZipCPU Peripheral&lt;/strong&gt;: Some time ago, I promised I was going to
discuss how easy it was to add a peripheral to the
&lt;a href=&quot;https://github.com/ZipCPU/zbasic&quot;&gt;ZBasic&lt;/a&gt;
using &lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt;.
I am still fully intending to do this, although I am somewhat struggling to
decide what that example peripheral should be–there are just too many
&lt;a href=&quot;https://github.com/ZipCPU?tab=repositories&quot;&gt;possibilities&lt;/a&gt;.  Feel free
to make a suggestion if you would like.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Quadratic Sinewave generation&lt;/strong&gt;: &lt;a href=&quot;/dsp/2017/08/30/cordic.html&quot;&gt;CORDIC sinewave
generation&lt;/a&gt; is really cool,
but it can also be logically expensive within an FPGA.
A potentially cheaper algorithm, requiring only two multiplies, would be to
apply our &lt;a href=&quot;/dsp/2018/03/30/quadratic.html&quot;&gt;quadratic interpolation
techniques&lt;/a&gt;
to generating a cleaner sine wave.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;/blog/2018/07/06/afifo.html&quot;&gt;Asynchronous FIFO&lt;/a&gt;&lt;/strong&gt;:
I have a nice formal proof of &lt;a href=&quot;http://www.sunburst-design.com/papers/CummingsSNUG2002SJ_FIFO1.pdf&quot;&gt;Cliff Cummings’
asynchronous FIFO
design&lt;/a&gt;
that I think would be valuable to present as well.  Unlike many of &lt;a href=&quot;/formal/formal.html&quot;&gt;my other
formal articles&lt;/a&gt;, this one requires
a formal solution across more than one clock domain, and for arbitrary
clock speeds.  This will add to the interest and value of it.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Ethernet CRC&lt;/strong&gt;: When I recently built a Ethernet CRC module for the 1Gb
Ethernet port of the &lt;a href=&quot;https://store.digilentinc.com/nexys-video-artix-7-fpga-trainer-board-for-multimedia-applications&quot;&gt;Nexys Video
board&lt;/a&gt;,
I was surprised at how much formal methods could help simplify
the complicated math of a multi-stepping CRC generator.  This would
therefore be a fun topic to share, as there is a lot of practical
information within it.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Dual I/O SPI flash&lt;/strong&gt;: While I am personally quite biased towards a &lt;a href=&quot;http://opencores.org/project,qspiflash&quot;&gt;Quad
SPI flash implementation&lt;/a&gt;,
recent events have led me to need to build a
&lt;em&gt;Dual I/O SPI flash&lt;/em&gt; implementation for a couple of logic challenged
implementations.  This means that this controller should be simple enough to
both present and understand, and makes a nice blog topic&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;TinyFPGA&lt;/strong&gt;: I’m also building a &lt;a href=&quot;https://github.com/ZipCPU/tinyzip&quot;&gt;TinyFPGA BX
design&lt;/a&gt; using the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;, and would love to blog about
this design.  Yes, the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; does
fit nicely on that board with room to spare (when &lt;a href=&quot;https://github.com/ZipCPU/tinyzip/blob/master/rtl/cpu/cpudefs.v&quot;&gt;properly
trimmed&lt;/a&gt;),
however my &lt;a href=&quot;https://github.com/ZipCPU/s6soc/blob/master/rtl/qflashxpress.v&quot;&gt;minimal flash
controller&lt;/a&gt;
needed to be redesigned, and my C++ &lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/sim/verilated/qspiflashsim.cpp&quot;&gt;flash
simulator&lt;/a&gt;
needed to be adjusted to get this to work.  Once I’ve finished verifying
that I can program and run the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
on this board, then it would be fun to describe my experiences.  Because of
the dependence upon the flash controller, however, this post would follow the
discussion of the &lt;strong&gt;Dual I/O SPI flash&lt;/strong&gt; design.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Some Simple Formal Verification Proofs&lt;/strong&gt;: It might be nice to return to our
(event) &lt;a href=&quot;/blog/2017/06/02/generating-timing.html&quot;&gt;timing control solutions
post&lt;/a&gt;,
and take a new look at them in light of &lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal
verification&lt;/a&gt;.
For example, how would you verify that a timer provides you with the right
number of clock ticks, or how would you speed up an otherwise exceptionally
long proof.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Prefetch with Cache&lt;/strong&gt;: The
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; has a 1-way instruction
cache that would be fun to present, and would also conclude our discussion
of prefetch methods.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Data Movement&lt;/strong&gt;: One of the sad realities of FPGA work is that its not all
about data transformation.  There’s a lot to be done in data movement as well.&lt;/p&gt;

    &lt;p&gt;The &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZiPCPU&lt;/a&gt; contains a
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/wbdmac.v&quot;&gt;DMA controller&lt;/a&gt;
that can be set up to automatically move data from one place to another within
any &lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;wishbone based
design&lt;/a&gt;.  &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/wbdmac.v&quot;&gt;This
component&lt;/a&gt;,
and its formal properties would be useful to many of my readers.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Abstraction in Formal Verification&lt;/strong&gt;: The recent
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
&lt;a href=&quot;/blog/2018/04/02/formal-cpu-bugs.html&quot;&gt;verification work&lt;/a&gt;
depends heavily on formal verification concepts of abstraction and
invariance.  Both techniques are useful when trying to break a complicated
design, such as a full CPU, down into its subcomponents.&lt;/p&gt;

    &lt;p&gt;This article would present abstraction.  In short, abstraction is based upon
the statement that if &lt;code class=&quot;highlighter-rouge&quot;&gt;A&lt;/code&gt; implies &lt;code class=&quot;highlighter-rouge&quot;&gt;B&lt;/code&gt;, then &lt;code class=&quot;highlighter-rouge&quot;&gt;A&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;C&lt;/code&gt; must also imply
&lt;code class=&quot;highlighter-rouge&quot;&gt;B&lt;/code&gt;.  The figures and outline of this lesson would be taken from the
formal verification course I’ve put together for
&lt;a href=&quot;https://www.symbioticeda.com&quot;&gt;Symbiotic EDA&lt;/a&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;/formal/2018/04/23/invariant.html&quot;&gt;Invariance in Formal Verification&lt;/a&gt;&lt;/strong&gt;: Invariance is a second very powerful
tool that can be used to simplify the formal prove of a component.  Put
simply, if you can prove the &lt;code class=&quot;highlighter-rouge&quot;&gt;A&lt;/code&gt; is true, you no longer need to prove &lt;code class=&quot;highlighter-rouge&quot;&gt;A&lt;/code&gt;
anymore.  The difference over what can, and cannot, be proven using this
technique can be drastic.&lt;/p&gt;

    &lt;p&gt;The figures and outline of this lesson would also be taken from the
formal verification course I’ve put together for
&lt;a href=&quot;https://www.symbioticeda.com&quot;&gt;Symbiotic EDA&lt;/a&gt;, just like the proposed
abstraction post discussed above.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;More filtering&lt;/strong&gt;: We left our discussion of filtering incomplete, and
so I’d still like to come back to demonstrate both
&lt;a href=&quot;/dsp/2018/05/17/slowsymf.html&quot;&gt;symmetric&lt;/a&gt; and halfband
filters.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Dhrystone&lt;/strong&gt;: Also on my list of items to discuss is Dhrystone, the
outdated-yet-still-useful CPU bench mark.  For all of you who are
interested in comparing your CPU’s performance against Dhrystone, this
article would take a quick look at how Dhrystone can be run within a
Verilator simulation, and how I’ve gone about interpreting the results.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Synchronization&lt;/strong&gt;: One common problem in &lt;a href=&quot;/dsp/dsp.html&quot;&gt;digital signal
processing&lt;/a&gt; is the
“two-clock” problem where data comes into the algorithm on one clock, and
yet needs to be output on the edges of an unrelated clock.  Now that we’ve
spent some time with
&lt;a href=&quot;/dsp/2018/03/30/quadratic.html&quot;&gt;interpolation&lt;/a&gt;,
as well as &lt;a href=&quot;/dsp/2017/12/14/logic-pll.html&quot;&gt;how to build a simple PLL
module&lt;/a&gt;, it only makes
sense that we would connect these two concepts to be able to synchronize
two data streams.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Generating an Arbitrary Clock Signal&lt;/strong&gt;: I also have a simple design
component that can be used to generate a clock signal at an arbitrary
frequency, without requiring any additional clock chips.  (The FPGA still
needs its input clock.)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Building a HyperRAM controller&lt;/strong&gt;:
&lt;a href=&quot;http://www.cypress.com/products/hyperram-memory&quot;&gt;HyperRAM&lt;/a&gt; is a powerful
RAM communication protocol.  Unlike
DDR3 SDRAM, building a controller for
&lt;a href=&quot;http://www.cypress.com/products/hyperram-memory&quot;&gt;HyperRAM&lt;/a&gt;
doesn’t require undocumented chip features.  This article would discuss
such a controller, both how to build it as well as how to formally verify
that it works.&lt;/p&gt;

    &lt;p&gt;If there’s enough demand, a separate article could discuss how to build a
simulation component for this device.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;If you’ve made it this far, let share this with you: I’m creating today
a &lt;a href=&quot;/formal/formal.html&quot;&gt;formal page&lt;/a&gt; which will capture
all of my formal verification posts.  This should make it easier for someone
who is only interested in &lt;a href=&quot;/formal/formal.html&quot;&gt;formal
verification&lt;/a&gt; to find articles that
discuss or provide examples of &lt;a href=&quot;/formal/formal.html&quot;&gt;formal
verification&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/formal/formal.html&quot;&gt;This new topical page&lt;/a&gt;
joins my prior &lt;a href=&quot;/dsp/dsp.html&quot;&gt;DSP topical page&lt;/a&gt;.  However,
&lt;em&gt;all&lt;/em&gt; articles will remain on the blog’s main page.&lt;/p&gt;

&lt;p&gt;Finally, if you are one of my
&lt;a href=&quot;https://www.patreon.com/ZipCPU&quot;&gt;Patreon sponsors&lt;/a&gt;,
please feel free to contact me at the e-mail address below and let me know
which, if any, of these topics you might be interested in.  Even better,
these are only suggestions.  If you are interested in a topic that isn’t
listed above, please feel free to share that topic with me as well.  Just please
be aware that topics not on this list, such as creating a GCC port, might
take a bit longer to work up to.&lt;/p&gt;

&lt;p&gt;If you are not one of my
&lt;a href=&quot;https://www.patreon.com/ZipCPU&quot;&gt;Patreon sponsors&lt;/a&gt;,
and yet you find this
&lt;a href=&quot;https://zipcpu.com/&quot;&gt;blog valuable&lt;/a&gt;, please consider joining
the team!  While I have no intention of restricting
&lt;a href=&quot;https://zipcpu.com/&quot;&gt;the blog&lt;/a&gt;’s content to subscribers only,
your support will help
&lt;a href=&quot;https://zipcpu.com/&quot;&gt;this blog&lt;/a&gt; continue into the future.&lt;/p&gt;
&lt;hr /&gt;&lt;p&gt;&lt;em&gt;The husbandman that laboureth must be first partaker of the fruits. (2Tim 2:6)&lt;/em&gt;</description>
        <pubDate>Thu, 05 Apr 2018 00:00:00 -0400</pubDate>
        <link>https://zipcpu.com/blog/2018/04/05/topatreon.html</link>
        <guid isPermaLink="true">https://zipcpu.com/blog/2018/04/05/topatreon.html</guid>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>Will formal methods ever find a bug in a working CPU?</title>
        <description>&lt;p&gt;Today, I’m starting what will likely be the slow process of
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formally verifying&lt;/a&gt;
the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;.  I’m going to use
&lt;a href=&quot;http://www.clifford.at/yosys&quot;&gt;yosys&lt;/a&gt; for this process initially, but given
&lt;a href=&quot;https://symbiyosys.readthedocs.io/en/latest&quot;&gt;SymbiYosys&lt;/a&gt;’s ability to
run multiple formal configurations as separate tasks, I will probably need to
switch after I get some distance along.&lt;/p&gt;

&lt;p&gt;At this point in the game, I’ve already &lt;a href=&quot;/blog/2018/01/22/formal-progress.html&quot;&gt;formally proven all of the
components&lt;/a&gt;
of the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;.
What remains is to prove the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU itself&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;So here’s my question: How many bugs would you expect to find in a “working”
soft-core CPU?  One?  Ten?  Twenty?  One hundred?  Shall we count?  I propose
keeping a running log of the bugs I find in the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; while using
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formally methods&lt;/a&gt;.
Perhaps this log will help to convince you the value of
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formally methods&lt;/a&gt;,
perhaps not.  Either way, I’ll keep it accurate to the information I discover.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;The memory manager refused to release the bus if the response came back
on the same cycle.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Certain errors should cause the CPU to halt–such as encountering a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_(computing)&quot;&gt;bus&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_error&quot;&gt;error&lt;/a&gt;
when reading from instruction memory.  Due to a (now locally fixed) bug
in the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;, these errors
would not cause the CPU to halt if they were one of the first couple
instructions.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; is designed so that
memory reads or writes &lt;em&gt;never&lt;/em&gt; need to be rolled back. This is to
facilitate using the memory bus for reading and
writing peripherals, such as the serial port.  Reads from such peripherals
have side effects that cannot be rolled back.  The formal methods however,
discovered an example where reading into the program counter, such as during
an indirect jump, my cause a following memory instruction to need to be
rolled back.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;’s current approach to
the compressed instruction set (CIS)
is to prevent the CPU from interrupting in the middle of a CIS instruction.
Formal methods, however, found an internal accounting bug which prevented
this logic from working properly.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Several bugs have been found in the debug infrastructure, allowing an
external debugger to change registers internal to the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;.&lt;/p&gt;

    &lt;p&gt;In one example, this was violating the rules the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; uses when issuing
pipelined memory instructions.&lt;/p&gt;

    &lt;p&gt;In another example, during a divide that was to write its results into &lt;code class=&quot;highlighter-rouge&quot;&gt;R0&lt;/code&gt;,
the external debug infrastructure was allowed to write to a register,
say &lt;code class=&quot;highlighter-rouge&quot;&gt;R1&lt;/code&gt;.  This would cause the divide to write its results into &lt;code class=&quot;highlighter-rouge&quot;&gt;R1&lt;/code&gt; upon
completion, rather than &lt;code class=&quot;highlighter-rouge&quot;&gt;R0&lt;/code&gt;.&lt;/p&gt;

    &lt;p&gt;The &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; has
therefore been adjusted so that the debug infrastructure
can only modify the value of a register if the CPU has been fully halted.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The flag indicating that the CPU is fully halted was not properly
implemented.  Specifically, the CPU might declare it was halted in the middle
of a CIS instruction when the second half of the instruction still needed
to be flushed through the pipeline.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;On a multi-cycle ALU operation (i.e. one of the multiplies), the flags
were being set before the operation was complete&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The clock-less version of the instruction decoder, used by the formal
properties alone to know what to expect from an instruction, didn’t match
the actual instruction decoder when it came to whether or not SIM
instructions should cause an illegal interrupt exception&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The divide wouldn’t wait for a multiply to complete before starting.  Such
a multiply might have provided the divide with its operand, but due to this
bug the divide input would’ve been the prior value of the register.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Under certain circumstances in the pipeline, the break instruction would
get bypassed.&lt;/p&gt;

    &lt;p&gt;I’m actually looking forward to simplifying this break logic by merging it
with the illegal instruction logic, since the two do the same thing in
different ways.  I’m holding off on this for now, however.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Writes to the user PC register, such as by the debug port or even the ALU,
   while in supervisor (not user) mode, would corrupt any logic depending
   upon the user PC register that was already in the pipeline.  Hence, the
   pipeline needs to be cleared following any such write.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;After making several fixes, the memory instruction following an illegal
instruction would be issued.  This error isn’t so much a bug in the working
CPU, but rather a bug in my pipeline logic rewrite.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Perhaps this would never happen.  However, the memory controller wouldn’t
stall when it ran out of internal memory to keep track of where the
write back results would be written to.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;On an early branch or an illegal instruction, the valid memory instruction
flag was still being set, eventually violating the contract with the memory
device.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The switch to interrupt flag wasn’t waiting for any ongoing memory
operations to complete first&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;On a divide error, the memory unit would still issue an instruction.
This creates a problem because a memory operation to a peripheral device
cannot be withdrawn, as the CPU tries to switch to its exception handling
code.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Under certain circumstances, the CPU would continue issuing instructions
following a bus error or division by zero error.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;At this point, I’m going to stop counting.  It’s not because there are so
many errors remaining, but rather because its no longer clear which of the
remaining errors were originally
in the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
and which ones were added while trying to fix the earlier bugs.&lt;/p&gt;

&lt;h2 id=&quot;bugs-in-the-formal-properties&quot;&gt;Bugs in the Formal Properties&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;The formal properties within the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;core&lt;/a&gt;,
as well as the abstracted components, are still quite immature.
Multiple bugs are still being found within them.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/ex/wbdblpriarb.v&quot;&gt;Wishbone
arbiter&lt;/a&gt;
had a careless assumption within it.  This prevented the arbiter from ever
being fully tested and verified.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
recognizes two memory regions: a local region for CPU-specific
peripherals from &lt;code class=&quot;highlighter-rouge&quot;&gt;0xff000000&lt;/code&gt; to &lt;code class=&quot;highlighter-rouge&quot;&gt;0xffffffff&lt;/code&gt; (used by the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/zipsystem.v&quot;&gt;ZipSystem&lt;/a&gt;,
and a more global memory
region (everything else).  Crossing regions within the same memory operation
is a fault that needs to be prevented in software, and the formal
properties for describing this fault were &lt;code class=&quot;highlighter-rouge&quot;&gt;assert()&lt;/code&gt; functions rather than
&lt;code class=&quot;highlighter-rouge&quot;&gt;restrict()&lt;/code&gt; functions.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;current-status&quot;&gt;Current status&lt;/h2&gt;

&lt;p&gt;I’m currently fully verifying the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;’s
capability using an &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/dev/bench/formal/abs_prefetch.v&quot;&gt;abstract
prefetch&lt;/a&gt;,
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/dev/bench/formal/abs_div.v&quot;&gt;abstract
divide&lt;/a&gt;,
and an &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/dev/bench/formal/abs_mpy.v&quot;&gt;abstract
multiply&lt;/a&gt;.
Thanks to SymbiYosys and “abc pdr”, the pipeline properties I’ve now verified
constitutes a full formal proof (BMC + induction) of the first set of
formal properties for the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;.
A second stage of properties have since been added, dependent upon the
synthesizer define &lt;code class=&quot;highlighter-rouge&quot;&gt;PHASE_ONE&lt;/code&gt;. The proof of this second set of properties
remains ongoing.&lt;/p&gt;

&lt;p&gt;First, the formal properties:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;I’ve proven that the assumptions within all of the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;’s
sub-modules hold.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;I’ve manage to verify that the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;’s
pipeline logic won’t accidentally “delete” an instruction in the pipeline.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;I’ve also added the properties that the operands given to the
ALU, memory, or divide unit, need to be valid.&lt;/p&gt;

    &lt;p&gt;This portion of the proof is ongoing.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Following any ALU or divide instruction, only the correct register will
ever be written if at all–I haven’t dealt with predicates yet.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;BREAK&lt;/code&gt; instructions never pass the OP stage as desired.  This makes certain
these instructions will not increment the PC when encountered.  This is
very similar to an illegal operand instruction, and the logic for these
may yet be merged.  For now, the &lt;code class=&quot;highlighter-rouge&quot;&gt;BREAK&lt;/code&gt; instruction bypasses the ALU
stage of the CPU as desired.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;I haven’t gotten to the cover properties yet, those are yet to come.  As a
result, I may have carelessly assumed away a portion of the proof and can’t
tell yet.&lt;/p&gt;

&lt;p&gt;Here’s how far I’ve gotten:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Without pipelining the memory bus, the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; made it for a full 40 clocks
in a bounded model check.  This was the extent of the test.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;With the pipelined memory bus, the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; has formally passed
&lt;em&gt;all of the formal properties&lt;/em&gt; now written for it&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The updated formal code is currently in a git repository branch that hasn’t
(yet) been pushed.  Upon request I have pushed components of this
proof into the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/tree/dev&quot;&gt;dev branc&lt;/a&gt;,
although I’d still be a bit embarrassed to present the (not quite working)
CPU yet.  This includes the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/dev/bench/formal/abs_mpy.v&quot;&gt;abstract
multiply&lt;/a&gt;
mentioned above, as well as the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/dev/rtl/core/mpyop.v&quot;&gt;multiply
module&lt;/a&gt; that it
replaces.&lt;/p&gt;

    &lt;p&gt;My apologies to all that have indicated an interest in seeing this code.
Thank you for your interest.  I guess it surprised me a bit.
I’m just not quite ready yet to post the code–mostly because things aren’t
fully working.  I do anticipate fully sharing this code in due time.  If
you are really interested in seeing this before it is complete, then
please send me an e-mail and I will consider placing it on
&lt;a href=&quot;https://gitlab.com&quot;&gt;gitlab&lt;/a&gt; where
&lt;a href=&quot;https://www.patreon.com/ZipCPU&quot;&gt;sponsors&lt;/a&gt; can have access to the current
work in progress.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;You can find my work in the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/tree/dev&quot;&gt;dev branch&lt;/a&gt;
of the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;github repository&lt;/a&gt;
for the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;.  Specifically,
you can find the properties that I’m working with at the bottom of the core
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/dev/rtl/core/zipcpu.v&quot;&gt;zipcpu.v&lt;/a&gt;
Verilog file.  I’m using a &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/dev/bench/formal/Makefile&quot;&gt;“make”
file&lt;/a&gt; within
the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/tree/dev/bench/formal&quot;&gt;bench/formal&lt;/a&gt;
directory to control the process.&lt;/p&gt;
&lt;hr /&gt;&lt;p&gt;&lt;em&gt;Again, when the wicked man turneth away from his wickedness that he hath committed, and doeth that which is lawful and right, he shall save his soul alive.  (Ezek 18:27)&lt;/em&gt;</description>
        <pubDate>Mon, 02 Apr 2018 00:00:00 -0400</pubDate>
        <link>https://zipcpu.com/blog/2018/04/02/formal-cpu-bugs.html</link>
        <guid isPermaLink="true">https://zipcpu.com/blog/2018/04/02/formal-cpu-bugs.html</guid>
        
        
        <category>blog</category>
        
      </item>
    
  </channel>
</rss>
