<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>The ZipCPU by Gisselquist Technology</title>
    <description>The ZipCPU blog, featuring how to discussions of FPGA and CPU design. This site will be focused on Verilog solutions, using exclusively OpenSource IP products for FPGA design.
</description>
    <link>http://zipcpu.com/</link>
    <atom:link href="http://zipcpu.com/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Fri, 28 Jul 2017 09:03:56 -0400</pubDate>
    <lastBuildDate>Fri, 28 Jul 2017 09:03:56 -0400</lastBuildDate>
    <generator>Jekyll v3.0.1</generator>
    
      <item>
        <title>Windows FPGA designers may not need a Linux machine ... yet</title>
        <description>&lt;p&gt;While I do all my work on a Linux platform, all of the OpenSource tools that I
use can be built and used under Windows just as well as under Linux.&lt;/p&gt;

&lt;p&gt;Here’s a set of FPGA tools that can also be used under Windows:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://veripool.org/wiki/verilator&quot;&gt;Verilator&lt;/a&gt; provides an integrated
simulation capability&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://gtkwave.sourceforge.net&quot;&gt;GTKWave&lt;/a&gt; provides a very useful trace
viewing capability.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The &lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt; toolchain also uses:
&lt;a href=&quot;https://www.gnu.org/binutils&quot;&gt;binutils&lt;/a&gt;,
&lt;a href=&quot;https://gcc.gnu.org&quot;&gt;GCC&lt;/a&gt;,
&lt;a href=&quot;https://sourceware.org/newlib&quot;&gt;newlib&lt;/a&gt;, and
&lt;a href=&quot;http://www.mr511.de/software&quot;&gt;libelf&lt;/a&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;I also use &lt;a href=&quot;https://www.gnu.org/software/ncurses&quot;&gt;ncurses&lt;/a&gt; for creating
textual displays, such as any of the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt; debuggers.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;When I need a home-made graphical capability, such as an OLED, VGA, or HDMI
simulator, &lt;a href=&quot;https://www.gtkmm.org&quot;&gt;GTKmm&lt;/a&gt; provides me with a nice platform
independent windowing library&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;At first glance, these might appear to be Linux-only applications.&lt;/p&gt;

&lt;p&gt;They aren’t.&lt;/p&gt;

&lt;p&gt;They can also run under Windows.&lt;/p&gt;

&lt;p&gt;Today, we’ll discuss how to get this toolchain working under Windows.&lt;/p&gt;

&lt;h2 id=&quot;cygwin-and-how-to-intall-it&quot;&gt;CygWin, and how to intall it&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://cygwin.com&quot;&gt;Cygwin&lt;/a&gt; is a program and set of libraries that can be
used on a Microsoft Windows machine to make it look, act, and feel like a
Linux system.&lt;/p&gt;

&lt;p&gt;We’ll use &lt;a href=&quot;https://cygwin.com&quot;&gt;Cygwin&lt;/a&gt; today to give us access to enough of a
Linux environment, so that we can then run
&lt;a href=&quot;https://veripool.org/wiki/verilator&quot;&gt;Verilator&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;You can find the &lt;a href=&quot;https://cygwin.com&quot;&gt;Cygwin&lt;/a&gt; install page
&lt;a href=&quot;https://cygwin.com/install.html&quot;&gt;here&lt;/a&gt;.  Go ahead and download the
software appropriate for your computer, whether 32 or 64-bit (if you don’t
know, download the 64-bit version).  Start the installer, and accept the
default configuration options until you get to the package page.&lt;/p&gt;

&lt;p&gt;The package page lists all of the programs that can be installed under
&lt;a href=&quot;https://cygwin.com&quot;&gt;Cygwin&lt;/a&gt;, and it lists them by category.  You might find
it daunting at first—there are a lot of packages to chose from. 
We’ll select the packages here that are necessary
to run &lt;a href=&quot;https://veripool.org/wiki/verilator&quot;&gt;Verilator&lt;/a&gt;,
&lt;a href=&quot;https://gtkwave.sourceforge.net&quot;&gt;GTKWave&lt;/a&gt;, and even the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt; compiler/toolchain.  We’ll also
grab some of the packages we may wish to have later in order to install either
&lt;a href=&quot;https://store.digilentinc.com/pmod-oledrgb-96-x-64-rgb-led-display-with-16-bit-color-resolution&quot;&gt;OLED&lt;/a&gt;
or VGA simulations.  You may need to use the search facility at the top of
the page to find the following packages–just don’t hit the return key until
you are done.&lt;/p&gt;

&lt;p&gt;Here’s our list of packages to enable:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;flex bison libtool make gcc-core gdb ddd ctags colorgcc gperf
libisl-devel libisl-doc libmpfr-devel libmpc-devel libmpc-doc
libgmp-devel libgmp-doc binutils automake autoconf autoconf2.5 automake1.15
libcairomm1.0_1-devel libcairomm1.0_1-doc libcairomm1.0_1-base
libelf-devel libncurses-devel
aspell-en enscript less source-highlight ghostscript gv
git git-gui svn patch dos2unix
tcl-devel tcl-tk tcl-tk-devel tcl-tck-iwidgets
gtk-doc libgtk2.0-devel libgtk2.0-doc libgtkmm2.4-doc libgtkmm2.4-devel
libgtk3-doc libgtkmm3.0-doc
xorg-server xorg-server-devel WindowMaker xterm
perl-doc&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;A lot of these packages have LaTeX based documentation.  If you want to be able
to rebuild that documentation, you may need to download LaTeX as well.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;texinfo texinfo-tex texlive texlive-collection-basic-doc
texlive-collection-latex texlive-collection-latex-doc
texlive-collection-latexextra  texlive-collection-latexextra-doc
texlive-collection-langenglish texlive-collection-pstricks
texlive-collection-pstricks-doc&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;If you find out later that you missed any packages, just restart the same
&lt;a href=&quot;https://cygwin.com&quot;&gt;Cygwin&lt;/a&gt; setup program that you just ran, but at that
later time when you know you need more packages.  You can then
repeat the configuration, but when you get to the package screen you can
add any packages you missed as though you were installing them initially.
&lt;a href=&quot;https://cygwin.com&quot;&gt;Cygwin&lt;/a&gt; will install only the changes, as you would like
it to.  Just … don’t forget where you put the
&lt;a href=&quot;https://cygwin.com&quot;&gt;Cygwin&lt;/a&gt; installer!&lt;/p&gt;

&lt;p&gt;Because we’re going to spend some time working on this machine as well, and
perhaps even need to do some real work, let’s add in some of my favorite
Linux packages to work with:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;hexchat putty gnome-terminal screen gvim meld
octave octave-devel octave-doc gnuplot
dia dia-shapes inkscape&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;These are my favorite editor, &lt;em&gt;gvim&lt;/em&gt;,
my favorite code-comparison tool, &lt;em&gt;meld&lt;/em&gt;,
my favorite IRC client, &lt;em&gt;hexchat&lt;/em&gt;,
and my favorite screen multiplexer, &lt;em&gt;screen&lt;/em&gt;.
Also included in this list is &lt;em&gt;octave&lt;/em&gt;, a free and open source package
offering a Matlab-like capability,
and &lt;em&gt;dia&lt;/em&gt;, a program for making quick vector graphics diagrams. 
I personally like &lt;em&gt;dia&lt;/em&gt;.  However you may find that you not only like
&lt;em&gt;inkspace&lt;/em&gt; better, but also that it is better maintained.&lt;/p&gt;

&lt;p&gt;While all of these may not be needed, this was the set I used to prove the
toolsuite I use.&lt;/p&gt;

&lt;p&gt;Once &lt;a href=&quot;https://cygwin.com&quot;&gt;Cygwin&lt;/a&gt; finishes installing, it’ll ask you if you
wish to place a cygwin icon on the desktop and in your start menu.  I
chose to accept the default, which was to say “yes” to both.  Then, to start
up the &lt;a href=&quot;https://cygwin.com&quot;&gt;Cygwin&lt;/a&gt; environment, you can just double click
on the &lt;a href=&quot;https://cygwin.com&quot;&gt;Cygwin&lt;/a&gt; icon that should now be on your desktop.
That will bring up a terminal window that we can then use for our next steps.&lt;/p&gt;

&lt;p&gt;Indeed, we are not done yet.  Though we have &lt;a href=&quot;https://cygwin.com&quot;&gt;Cygwin&lt;/a&gt;
installed, &lt;a href=&quot;https://cygwin.com&quot;&gt;Cygwin&lt;/a&gt; didn’t come with all of our favorite
packages, or the packages we need.  Specifically, neither
&lt;a href=&quot;https://www.veripool.org/wiki/verilator&quot;&gt;Verilator&lt;/a&gt; nor
&lt;a href=&quot;http://gtkwave.sourceforge.net&quot;&gt;GTKWave&lt;/a&gt; were on
&lt;a href=&quot;https://cygwin.com&quot;&gt;Cygwin&lt;/a&gt;’s list.  So, we’ll have to go back and get them
separately.&lt;/p&gt;

&lt;h2 id=&quot;installing-verilator&quot;&gt;Installing Verilator&lt;/h2&gt;

&lt;p&gt;The first FPGA support package to get is
&lt;a href=&quot;https://www.veripool.org/wiki/verilator&quot;&gt;Verilator&lt;/a&gt;.  We’ll start by grabbing
the sources for &lt;a href=&quot;https://www.veripool.org/wiki/verilator&quot;&gt;Verilator&lt;/a&gt;
from a tarball found on &lt;a href=&quot;https://www.veripool.org/projects/verilator/wiki/installing&quot;&gt;this
page&lt;/a&gt;.  In my
case, that tarball was named &lt;em&gt;verilator-3.904.tgz&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;The instructions for installing
&lt;a href=&quot;https://www.veripool.org/wiki/verilator&quot;&gt;Verilator&lt;/a&gt;, also found on that
&lt;a href=&quot;https://www.veripool.org/projects/verilator/wiki/installing&quot;&gt;same page&lt;/a&gt;,
are fairly simple.  At your command line, type:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;unset VERILATOR_ROOT
tar xvzf verilator*.t*gz
cd verilator\*
./configure
make
sudo make install&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Much to my surprise, this worked without any hassles.  (I was expecting things
to be harder.)&lt;/p&gt;

&lt;h2 id=&quot;installing-gtkwave&quot;&gt;Installing GTKWave&lt;/h2&gt;

&lt;p&gt;The next program we’ll install is &lt;a href=&quot;http://gtkwave.sourceforge.net&quot;&gt;GTKWave&lt;/a&gt;.
We’ll use this program later to view any traces &lt;a href=&quot;/blog/2017/06/21/looking-at-verilator.html&quot;&gt;created by
simulations&lt;/a&gt;
we might run and try.&lt;/p&gt;

&lt;p&gt;You can find &lt;a href=&quot;http://gtkwave.sourceforge.net&quot;&gt;GTKWave&lt;/a&gt; on it’s
&lt;a href=&quot;http://gtkwave.sourceforge.net&quot;&gt;sourceforge website&lt;/a&gt;.  On their front page,
they have a link to a source tarball.  In my case, that tarball was named
&lt;a href=&quot;http://gtkwave.sourceforge.net/gtkwave-3.3.81.tar.gz&quot;&gt;gtkwave-3.3.81.tar.gz&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;We’ll download this tarball and place it into our
&lt;a href=&quot;https://cygwin.com&quot;&gt;Cygwin&lt;/a&gt; home directory.  Once done, we can build
&lt;a href=&quot;http://gtkwave.sourceforge.net&quot;&gt;GTKWave&lt;/a&gt; simply with:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;tar -xvzf gtkwave-3.3.81.tar.gz
cd gtkwave-3.3.81/
./configure --disable-xz
make install&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;At this point, we’re &lt;em&gt;almost&lt;/em&gt; ready to try it.  One step remains.  We need to
start up the X-server.  We’ll start the server, and then start a window manager
(wmaker) and an xterm.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;X &amp;amp;
wmaker -display :0 &amp;amp;
xterm -display :0 &amp;amp;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This will create a large window on the display, and place a terminal within
it.  We can now simulate something with
&lt;a href=&quot;https://www.veripool.org/wiki/verilator&quot;&gt;Verilator&lt;/a&gt;,
and then display it from this window using
&lt;a href=&quot;http://gtkwave.sourceforge.net&quot;&gt;GTKWave&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;running-a-serial-port-test&quot;&gt;Running a Serial Port Test&lt;/h2&gt;

&lt;p&gt;Now that we have everything installed, we need something to test to prove that
this install works.&lt;/p&gt;

&lt;p&gt;Perhaps the easiest package to test, and the package that offers a complete
end-to-end test case without requiring anything else,
is the &lt;a href=&quot;https://github.com/ZipCPU/wbuart32&quot;&gt;wbuart32&lt;/a&gt; serial
port package.  This package contains a complete &lt;a href=&quot;https://github.com/ZipCPU/wbuart32/blob/master/rtl/wbuart.v&quot;&gt;wishbone controlled UART
peripheral&lt;/a&gt;,
together with some &lt;a href=&quot;https://github.com/ZipCPU/wbuart32/tree/master/bench/verilog&quot;&gt;self-contained testing
programs&lt;/a&gt;–such
as &lt;a href=&quot;https://github.com/ZipCPU/wbuart32/blob/master/bench/verilog/helloworld.v&quot;&gt;Hello World&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;To run this test, we’ll first clone the git repository,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;git clone https://github.com/ZipCPU/wbuart32&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;and then we’ll change into the new directory we’ve just created.  From here,
we can build the distro.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;cd wbuart32 ; make&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This will also run a UART simulation test, just to prove that the package
works.&lt;/p&gt;

&lt;p&gt;Once the build and test bench have completed, we’ll move into the C++ test
directory and run the &lt;a href=&quot;https://github.com/ZipCPU/wbuart32/blob/master/bench/cpp/helloworld.cpp&quot;&gt;Hello
World&lt;/a&gt;
program on its own.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;cd bench/cpp
./helloworld&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;If all works well, you should see the “Hello, World!” characters printed
across your screen, and then the program should exit.&lt;/p&gt;

&lt;p&gt;Now if you look in your directory (type ‘ls’), you should be able to find a
“helloworld.vcd” file.  This is a 
&lt;a href=&quot;https://en.wikipedia.org/wiki/Value_change_dump&quot;&gt;value-change-dump&lt;/a&gt; type of
file, that contains
the value of every variable as it existed on every clock cycle within the
simulation we just ran.  Not bad, huh?&lt;/p&gt;

&lt;p&gt;Let’s start up &lt;a href=&quot;http://gtkwave.sourceforge.net&quot;&gt;GTKWave&lt;/a&gt;,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;gtkwave helloworld.vcd&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;and take a look at what we can find.&lt;/p&gt;

&lt;p&gt;If you’ve never used
&lt;a href=&quot;http://gtkwave.sourceforge.net&quot;&gt;GTKWave&lt;/a&gt; before, stay with me.
When I first started using &lt;a href=&quot;http://gtkwave.sourceforge.net&quot;&gt;GTKWave&lt;/a&gt;,
the opening screen left me confused.  It
was big and black with green lines and … didn’t do anything.&lt;/p&gt;

&lt;table style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 1: GTKWave, your first click&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/gtkwave-firstclick.png&quot; alt=&quot;Step one with gtkwave&quot; width=&quot;240&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Now that I’ve used it for some time, I no longer find it so confusing.  Just
go over to the left side of the screen.  There, in the top of two white panel’s,
will be the name of our top level module, TOP, with a plus beside it.  Go ahead
and click on it (the word TOP, not the plus yet).&lt;/p&gt;
&lt;table style=&quot;float: left; padding: 15px&quot;&gt;&lt;caption&gt;Fig 2: GTKWave, drag items to view&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/gtkwave-firstdrag.png&quot; alt=&quot;Dragging waveforms to view in GTKWave&quot; width=&quot;240&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;You’ll then see, listed in
the small panel below, all of the external I/O ports associated with our
design.  Let’s use the mouse to grab the clock register, &lt;code class=&quot;highlighter-rouge&quot;&gt;i_clk&lt;/code&gt;
and drag it to the display area.  Next, let’s grab the output serial port
register, &lt;code class=&quot;highlighter-rouge&quot;&gt;o_uart&lt;/code&gt;, and drag that to the display as well.&lt;/p&gt;

&lt;p&gt;Ok, so now you’ve got two green lines in the display.  We can do one better.&lt;/p&gt;

&lt;p&gt;While holding the control key down, scroll with the mouse wheel.  Go ahead
and scroll out until you see the &lt;code class=&quot;highlighter-rouge&quot;&gt;o_uart&lt;/code&gt; field changing.  You can then
move over to it and control scroll zoom-in and see what we just did, or simply
use the scroll button to move left or right in time.  Doing this, you should
be able to see the waveform shown in Fig. 3 below.&lt;/p&gt;

&lt;table style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 3: GTKWave: Hello World&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/gtkwave-hello.png&quot; alt=&quot;Hello World UART output in GTKWave&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;You can view other variables as well.  Just go back to that “TOP” value in
the upper left pane and click on the plus.  This will bring up the next
level down in your design.  You can then drag any the variables you are
interested in into the main green window and see how they line up with
the serial port and clock wires that we already added in.&lt;/p&gt;

&lt;p&gt;We’ll have to leave for another time, though, the further details of what’s
going on.  This is enough for the day as it is.&lt;/p&gt;

&lt;h2 id=&quot;the-power-of-the-simulator&quot;&gt;The power of the simulator&lt;/h2&gt;

&lt;p&gt;Before closing, let me just ask: do you realize the significance of what we’ve
just done?  We’ve just
ran a simulator as though it were a real FPGA.  The simulator talked to a
console port, just like any real serial port connected to an FPGA might have
done.  The great point here is that you can learn a lot about what it takes
to build and run logic using this simulator!&lt;/p&gt;

&lt;p&gt;Sure, it’s not quite the same thing as the real thing.  A real FPGA has
limits on the amount of logic that can take place between two clock pulses.
A real FPGA has a finite number of resources that can be assigned to your
logic.  A real FPGA would also need to match the baud rate on your terminal
program.  Still, simulation is one of the big things that will keep you from
&lt;a href=&quot;/fpga-hell.html&quot;&gt;FPGA Hell&lt;/a&gt;, and we’ve just shown you how you can simulate a
serial port.&lt;/p&gt;

&lt;p&gt;Feel free to write me if you have any struggles, or &lt;a href=&quot;https://www.patreon.com/ZipCPU&quot;&gt;support this blog on
Patreon&lt;/a&gt;, and get a vote into what I
write about next!&lt;/p&gt;
</description>
        <pubDate>Fri, 28 Jul 2017 00:00:00 -0400</pubDate>
        <link>http://zipcpu.com/blog/2017/07/28/cygwin-fpga.html</link>
        <guid isPermaLink="true">http://zipcpu.com/blog/2017/07/28/cygwin-fpga.html</guid>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>How to build a simulation based debugger for your own soft-core CPU</title>
        <description>&lt;p&gt;So you want to build a soft-core CPU?&lt;/p&gt;

&lt;p&gt;Have you given any thought to how you will test that CPU, or &lt;a href=&quot;/zipcpu/2017/07/14/cpu-debugging-needs.html&quot;&gt;how you will
debug the
programs&lt;/a&gt;
you are running within it?&lt;/p&gt;

&lt;p&gt;If you know &lt;a href=&quot;/blog/2017/06/23/my-dbg-philosophy.html&quot;&gt;my debugging
philosophy&lt;/a&gt;, you’ll
also know that I am a firm believer in simulation.  I like to use not only
&lt;a href=&quot;https://www.veripool.org/wiki/verilator&quot;&gt;Verilator&lt;/a&gt;
for simulating my cores, but also printf() and
&lt;a href=&quot;http://gtkwave.sourceforge.net&quot;&gt;GTKWave&lt;/a&gt;
for examining the results as I’ve discussed
&lt;a href=&quot;/blog/2017/06/21/looking-at-verilator.html&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Somehow, as with &lt;a href=&quot;/dsp/2017/07/22/dsp-debugging.html&quot;&gt;DSP
debugging&lt;/a&gt;,
these two approaches are insufficient when it comes to debugging a sort-core
CPU.  Another approach is needed.&lt;/p&gt;

&lt;p&gt;Therefore, this article will present a simpler approach to debugging a CPU
when using 
&lt;a href=&quot;https://www.veripool.org/wiki/verilator&quot;&gt;Verilator&lt;/a&gt;.
Sure, it will take a bit more work to set up, but I think you’ll find the result
well worth the effort when it comes time to debug your own CPU.&lt;/p&gt;

&lt;h2 id=&quot;debugger-overview&quot;&gt;Debugger Overview&lt;/h2&gt;

&lt;p&gt;You may remember from our discussion of CPU debuggers what the requirements
of a debugger in simulation are, shown in Fig 1.&lt;/p&gt;

&lt;table style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 1: Debugging a CPU in simulation&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/cpu-dbg-simulation.svg&quot; alt=&quot;CPU Debugging needs ... in simulation&quot; width=&quot;350&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Today, we’ll be focusing our efforts on building the interaction in the
&lt;em&gt;simulation&lt;/em&gt; column.&lt;/p&gt;

&lt;p&gt;What makes building a CPU debugger different from any other
&lt;a href=&quot;https://www.veripool.org/wiki/verilator&quot;&gt;Verilator&lt;/a&gt; based
simulation test harness, is the requirement that you may wish to examine the
CPU state after every clock tick.  It is this examination
that will be the primary focus of the discussion today.  Along the way,
we’ll show how to step the CPU by a single clock tick, as well as how to
generate trace information.  Stopping on a break point, though,
will require a handshake between your simulation and your CPU.&lt;/p&gt;

&lt;table style=&quot;float: left; padding: 15px&quot;&gt;&lt;caption&gt;Fig 2: Integrated Debugging&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/dbg-by-integrated-sim.svg&quot; alt=&quot;Integrated Debugging&quot; width=&quot;300&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;We’ll start with the code that we’ve written and 
&lt;a href=&quot;/blog/2017/06/21/looking-at-verilator.html&quot;&gt;discussed&lt;/a&gt;
for simulating an FPGA design while also simulating multiple peripherals.
We &lt;a href=&quot;/blog/2017/06/23/my-dbg-philosophy.html&quot;&gt;illustrated this concept&lt;/a&gt; before using Fig 2.
If you haven’t already built a simple
&lt;a href=&quot;/blog/2017/06/21/looking-at-verilator.html&quot;&gt;test harness&lt;/a&gt;
for your FPGA design,
you’ll want to put that functionality together before we start.  You don’t
have to make it work yet.  Building a Verilator based CPU debugger will
require some other modifications before getting there.&lt;/p&gt;

&lt;p&gt;Then, to that basic test harness, we’ll add an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Ncurses&quot;&gt;ncurses&lt;/a&gt;
display functionality, as outlined in Fig 3. below.  In this case, we’ll break
up the
Verilator
test harness
while loop, and add an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Ncurses&quot;&gt;ncurses&lt;/a&gt;
interface to it in order to achieve a debugging capability.&lt;/p&gt;

&lt;table style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 3: Structure of a Verilator CPU Debugger&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/vlator-debugger.svg&quot; alt=&quot;Pictorial image of a Verilaor Debugger&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;If you’ve never used the &lt;a href=&quot;https://www.gnu.org/software/ncurses&quot;&gt;ncurses library&lt;/a&gt;
before, it’s &lt;a href=&quot;http://invisible-island.net/ncurses/NCURSES-Programming-HOWTO.html#WHATIS&quot;&gt;really not all that
hard&lt;/a&gt;,
and it really simplifies building a textual debugger.&lt;/p&gt;

&lt;h2 id=&quot;loading-your-program&quot;&gt;Loading your program&lt;/h2&gt;

&lt;p&gt;The &lt;a href=&quot;https://www.gnu.org/software/ncurses&quot;&gt;ncurses library&lt;/a&gt; library is very
much about textual screen manipulation.  We’ll use that to place register
values on the screen, and to accept user input to control the simulation.&lt;/p&gt;

&lt;p&gt;However, before any screen manipulation, you’ll want to process any command
line arguments to your test harness program.  This includes finding and loading
any initial memory, whether into your
&lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/sim/verilated/qspiflashsim.cpp&quot;&gt;flash&lt;/a&gt; or
SDRAM simulator or other.&lt;/p&gt;

&lt;p&gt;In particular, if there’s any reason why your test program would need to end
on an error, it helps to find and handle those errors before starting the
&lt;a href=&quot;http://invisible-island.net/ncurses/NCURSES-Programming-HOWTO.html#INIT&quot;&gt;ncurses&lt;/a&gt;,
environment.  Once
&lt;a href=&quot;http://invisible-island.net/ncurses/NCURSES-Programming-HOWTO.html&quot;&gt;ncurses&lt;/a&gt;,
starts, we’ll need to be careful to make sure that your program &lt;em&gt;only&lt;/em&gt;
exits by way of the &lt;a href=&quot;http://invisible-island.net/ncurses/NCURSES-Programming-HOWTO.html#ABOUT-ENDWIN&quot;&gt;ncurses
endwin&lt;/a&gt;,
function before calling exit.&lt;/p&gt;

&lt;h2 id=&quot;starting-and-stopping-ncurses&quot;&gt;Starting and stopping ncurses&lt;/h2&gt;

&lt;p&gt;Once you are sure your test harness is ready to fire up your design,
then it’s time to start the
&lt;a href=&quot;http://invisible-island.net/ncurses/NCURSES-Programming-HOWTO.html#ABOUTINIT&quot;&gt;ncurses&lt;/a&gt;
screen environment.  &lt;a href=&quot;http://invisible-island.net/ncurses/NCURSES-Programming-HOWTO.html#ABOUTINIT&quot;&gt;Starting up 
ncurses&lt;/a&gt;
involves calling four basic functions:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;cp&quot;&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;ncurses.h&amp;gt;
&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(...)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;// Process arguments
&lt;/span&gt;	&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;// Initialize ncurses
&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;initscr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;raw&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;noecho&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;keypad&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;stdscr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;//
&lt;/span&gt;	&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The first of these functions,
&lt;a href=&quot;http://invisible-island.net/ncurses/NCURSES-Programming-HOWTO.html#ABOUT-INITSCR&quot;&gt;initscr()&lt;/a&gt;,
just initializes &lt;a href=&quot;https://en.wikipedia.org/wiki/Ncurses&quot;&gt;ncurses&lt;/a&gt;
and starts up the display.&lt;/p&gt;

&lt;p&gt;The 
&lt;a href=&quot;http://invisible-island.net/ncurses/NCURSES-Programming-HOWTO.html#RAWCBREAK&quot;&gt;raw()&lt;/a&gt;
function tells &lt;a href=&quot;https://en.wikipedia.org/wiki/Ncurses&quot;&gt;ncurses&lt;/a&gt;
that we don’t want any input buffering.  This will become
important later, as we’d like to be able to step the CPU one clock at a time
on a keypress, and we don’t want to have to wait for a return key along the way.&lt;/p&gt;

&lt;p&gt;If you want to be able to just hit a key and step the CPU, then you aren’t
really going to want that key displayed to the screen.  That’s the purpose
of the 
&lt;a href=&quot;http://invisible-island.net/ncurses/NCURSES-Programming-HOWTO.html#ECHONOECHO&quot;&gt;noecho()&lt;/a&gt; function call.&lt;/p&gt;

&lt;p&gt;Finally, the
&lt;a href=&quot;http://invisible-island.net/ncurses/NCURSES-Programming-HOWTO.html#KEYPAD&quot;&gt;keypad(stdscr, true)&lt;/a&gt;
command requests that all special characters (function keys, arrows, etc), be
sent to our processing loop just like everything else.&lt;/p&gt;

&lt;p&gt;The other part of the basic
&lt;a href=&quot;https://en.wikipedia.org/wiki/Ncurses&quot;&gt;ncurses&lt;/a&gt;
setup is stopping your simulation.  Once you finally get
to the end of your debugging and simulation session, then you are going to want
to call
&lt;a href=&quot;http://invisible-island.net/ncurses/NCURSES-Programming-HOWTO.html#ABOUT-ENDWIN&quot;&gt;endwin&lt;/a&gt;
to return your screen to normal, like it was before you started your simulator.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;n&quot;&gt;endwin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;If you get in trouble, you may find that typing&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;n&quot;&gt;stty&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sane&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;helps.  Modern terminals often have a reset terminal button that cna help as
well.&lt;/p&gt;

&lt;p&gt;That’s the basics of getting
&lt;a href=&quot;https://en.wikipedia.org/wiki/Ncurses&quot;&gt;ncurses&lt;/a&gt;
started, now let’s see if we can’t turn around and use it to help us
simulate this design.&lt;/p&gt;

&lt;h2 id=&quot;the-verilator-loop&quot;&gt;The Verilator Loop&lt;/h2&gt;

&lt;p&gt;Remember the &lt;a href=&quot;/blog/2017/06/21/looking-at-verilator.html&quot;&gt;previous Verilator test harness loop
function&lt;/a&gt;,
we built?  It looked something like:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(...)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;// ...
&lt;/span&gt;	&lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;done&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;tb&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tick&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;// ...
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;As you &lt;a href=&quot;/blog/2017/06/21/looking-at-verilator.html&quot;&gt;may recall from the Verilator
article&lt;/a&gt;,
this function then called a testbench method
which toggled our clock and provided any peripheral inputs:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;CPU&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_TB&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;// ...
&lt;/span&gt;	&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tick&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;m_tickcount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

		&lt;span class=&quot;c1&quot;&gt;// ... Handle peripheral inputs
&lt;/span&gt;
		&lt;span class=&quot;c1&quot;&gt;// Allow combinatorial logic to settle before toggling the
&lt;/span&gt;		&lt;span class=&quot;c1&quot;&gt;// clock
&lt;/span&gt;		&lt;span class=&quot;n&quot;&gt;m_core&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i_clk&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;m_core&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;eval&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_trace&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m_trace&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dump&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_tickcount&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

		&lt;span class=&quot;c1&quot;&gt;// Simulate the positive edge of the clock
&lt;/span&gt;		&lt;span class=&quot;n&quot;&gt;m_core&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i_clk&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;m_core&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;eval&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_trace&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m_trace&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dump&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_tickcount&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

		&lt;span class=&quot;c1&quot;&gt;// Simulate the negative edge of the clock
&lt;/span&gt;		&lt;span class=&quot;n&quot;&gt;m_core&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i_clk&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;m_core&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;eval&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_trace&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;m_trace&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dump&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_tickcount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;m_trace&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;flush&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
		&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
		&lt;span class=&quot;c1&quot;&gt;// ... Handle any debugging output requirements
&lt;/span&gt;	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;// ...
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This is going to be the first thing we’ll need to change.&lt;/p&gt;

&lt;p&gt;Specifically, we’re going to rebuild the inner loop portion of &lt;code class=&quot;highlighter-rouge&quot;&gt;main&lt;/code&gt; function.
The new inner loop is going to read a user keypress, and then its going to
process that keypress as you would like.  For demonstration purposes, we’ll
set this up so that:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;If the user types a control-L, the screen will redraw itself&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;If the user types an ‘r’, the CPU will restart&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;If he types a ‘q’, we’ll quit.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Finally, if the user types a &lt;code class=&quot;highlighter-rouge&quot;&gt;t&lt;/code&gt;, and only then, will we actually step the
CPU &lt;em&gt;by one clock only&lt;/em&gt;.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;cp&quot;&gt;#define	CTRL(X)	((X)&amp;amp;0x01f)
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;done&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;// Get a user command
&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;chv&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;getch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;

	&lt;span class=&quot;c1&quot;&gt;// Process the user&#39;s command
&lt;/span&gt;	&lt;span class=&quot;k&quot;&gt;switch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tolower&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;chv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;// Place any user keyboard commands you&#39;d like here.
&lt;/span&gt;	&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;// Some I use include:
&lt;/span&gt;	&lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CTRL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;&#39;L&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Redraw the screen on control-L
&lt;/span&gt;		&lt;span class=&quot;n&quot;&gt;redrawwin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;stdscr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;sc&quot;&gt;&#39;q&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Reset the CPU
&lt;/span&gt;		&lt;span class=&quot;n&quot;&gt;done&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;sc&quot;&gt;&#39;r&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Reset the CPU
&lt;/span&gt;		&lt;span class=&quot;n&quot;&gt;tb&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;reset&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;sc&quot;&gt;&#39;t&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Tick the CPU by one clock tick
&lt;/span&gt;		&lt;span class=&quot;c1&quot;&gt;// tb-&amp;gt;tick() toggles our clock,
&lt;/span&gt;		&lt;span class=&quot;c1&quot;&gt;// and sends CPU values to a trace file
&lt;/span&gt;		&lt;span class=&quot;n&quot;&gt;tb&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tick&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;default&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
		&lt;span class=&quot;c1&quot;&gt;// Either no keypress was available, or the
&lt;/span&gt;		&lt;span class=&quot;c1&quot;&gt;// user hit an accidental keypress.
&lt;/span&gt;		&lt;span class=&quot;c1&quot;&gt;//
&lt;/span&gt;		&lt;span class=&quot;c1&quot;&gt;// In either case: do nothing
&lt;/span&gt;	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

	&lt;span class=&quot;n&quot;&gt;tb&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;show_cpu_state&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The code above presents a couple of new functions.  These include
two new ncurses commands,
&lt;a href=&quot;http://invisible-island.net/ncurses/NCURSES-Programming-HOWTO.html#GETCHCLASS&quot;&gt;getch()&lt;/a&gt;
and redrawwin(stdscr).  They also include
some methods to add to our testbench.&lt;/p&gt;

&lt;p&gt;The first of these, &lt;a href=&quot;http://invisible-island.net/ncurses/NCURSES-Programming-HOWTO.html#GETCHCLASS&quot;&gt;getch()&lt;/a&gt;, simply returns a character from the terminal.
This function also hides a beginner bug.  Normally, after any change to the
screen, ncurses will require you to call
&lt;a href=&quot;http://invisible-island.net/ncurses/NCURSES-Programming-HOWTO.html#MYST-REFRESH&quot;&gt;refresh()&lt;/a&gt;
to update the screen.
The reality of ncurses is that none of the functions that write to the screen
actually send any output to the screen until
&lt;a href=&quot;http://invisible-island.net/ncurses/NCURSES-Programming-HOWTO.html#MYST-REFRESH&quot;&gt;refresh()&lt;/a&gt;
is called.  Hence, if you aren’t familiar with ncurses, you might get frustrated
when nothing gets written to your screen.
&lt;a href=&quot;http://invisible-island.net/ncurses/NCURSES-Programming-HOWTO.html#GETCHCLASS&quot;&gt;getch()&lt;/a&gt;
helps us avoid this error, by quietly calling
&lt;a href=&quot;http://invisible-island.net/ncurses/NCURSES-Programming-HOWTO.html#MYST-REFRESH&quot;&gt;refresh()&lt;/a&gt;
for us anytime we call
&lt;a href=&quot;http://invisible-island.net/ncurses/NCURSES-Programming-HOWTO.html#GETCHCLASS&quot;&gt;getch()&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The other command, redrawwin(stdscr), repaints the screen from scratch.  It’s
not normally necessary, but if some other program has written to your screen
you will enjoy the ability to refresh what’s on it.  Ctrl-L seems to be a
common key among other programs for this purpose, 
so we continue that capability here.&lt;/p&gt;

&lt;p&gt;You can also get creative in this main loop.  For example, if you know that
your CPU will have a problem &lt;code class=&quot;highlighter-rouge&quot;&gt;N&lt;/code&gt; clocks after reboot, you can run a simple
&lt;em&gt;for loop&lt;/em&gt; before entering this main while loop in order to skip those
&lt;code class=&quot;highlighter-rouge&quot;&gt;N&lt;/code&gt; clocks before starting your debugging session.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;c1&quot;&gt;//...
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;STARTUP_TICKS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;tb&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tick&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;done&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;// ...
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;For example, you might wish to skip the bootloader that copies data from
flash to memory, so you can debug your actual program.&lt;/p&gt;

&lt;p&gt;All in all, though, this while loop handles the logic necessary to step and
reset the CPU, as well as the
logic necessary to quit the simulation from the standpoint of the main loop. 
The big capability we are missing at this point is how to implement these
new testbench methods.&lt;/p&gt;

&lt;h2 id=&quot;the-testbench-class&quot;&gt;The Testbench Class&lt;/h2&gt;

&lt;p&gt;So let’s look at the test bench methods that will need to change.  From the
source above, we needed three functions: &lt;code class=&quot;highlighter-rouge&quot;&gt;reset()&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;show_cpu_state()&lt;/code&gt;, as
well as the &lt;code class=&quot;highlighter-rouge&quot;&gt;tick()&lt;/code&gt; function that we’ve already discussed.&lt;/p&gt;

&lt;p&gt;Of these three functions, &lt;code class=&quot;highlighter-rouge&quot;&gt;reset()&lt;/code&gt;, is the simplest to implement–assuming
your CPU has an input for a synchronous reset:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CPU_TB&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;reset&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;m_core&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i_reset&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;tick&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;m_core&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i_reset&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Showing the CPU’s state will take a bit more work.  The first step is to
find the variables and registers within
&lt;a href=&quot;https://www.veripool.org/wiki/verilator&quot;&gt;Verilator&lt;/a&gt;’s
variable set.  To do this, I usually browse the &lt;code class=&quot;highlighter-rouge&quot;&gt;*.h&lt;/code&gt; file found within the
&lt;a href=&quot;https://www.veripool.org/wiki/verilator&quot;&gt;Verilator&lt;/a&gt;
output directory.  (This defaults to &lt;code class=&quot;highlighter-rouge&quot;&gt;obj_dir/&lt;/code&gt;).  In the case of the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;, the register set
can be found in
&lt;a href=&quot;https://www.veripool.org/wiki/verilator&quot;&gt;Verilator&lt;/a&gt;’s
&lt;code class=&quot;highlighter-rouge&quot;&gt;v__DOT__thecpu__DOT__regset&lt;/code&gt; variable.  If you aren’t familiar with
&lt;a href=&quot;https://www.veripool.org/wiki/verilator&quot;&gt;Verilator&lt;/a&gt;’s
naming scheme, this is the name
&lt;a href=&quot;https://www.veripool.org/wiki/verilator&quot;&gt;Verilator&lt;/a&gt;
gives to the &lt;code class=&quot;highlighter-rouge&quot;&gt;regset&lt;/code&gt; array found
within the &lt;code class=&quot;highlighter-rouge&quot;&gt;thecpu&lt;/code&gt; module found at the top level.  Be aware that
&lt;a href=&quot;https://www.veripool.org/wiki/verilator&quot;&gt;Verilator&lt;/a&gt;
has recently changed its naming schemes, so you may have to look a bit.&lt;/p&gt;

&lt;p&gt;Now that I know where to find my register array, I can copy it to a local
variable where I can then use it:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;n&quot;&gt;CPU_TB&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;read_state_from_cpu&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;memcpy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_state&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m_core&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v__DOT__thecpu__DOT__regset&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;NREGS&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v__DOT__thecpu__DOT__regset&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]));&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Now that we know what our register values are, it’s time to place them onto
the screen.  The easiest way to do this is with the
&lt;a href=&quot;http://invisible-island.net/ncurses/NCURSES-Programming-HOWTO.html#GETCHCLASS&quot;&gt;mvprintw()&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Ncurses&quot;&gt;ncurses&lt;/a&gt;
command.  This command combines screen movement with a printf-like
interface.  Hence, we can write the values of all our registers to the
screen, as in:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;n&quot;&gt;CPU_TB&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;show_cpu_state&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;read_state_from_cpu&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;

	&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;16&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;mvprintw&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;20&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;R%2d: 0x%08x&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m_state&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Don’t get surprised: the coordinates are not in &lt;code class=&quot;highlighter-rouge&quot;&gt;x, y&lt;/code&gt; order, but rather
&lt;code class=&quot;highlighter-rouge&quot;&gt;y, x&lt;/code&gt; order.&lt;/p&gt;

&lt;p&gt;You can also get as fancy as you want in this step.  For example, I like to
look up the instruction memory at the program counter, and disassemble
the instructions in the CPU pipeline.&lt;/p&gt;

&lt;p&gt;In my case, it has gotten so that every time I need to debug a register
within the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;, I tend to just add another
&lt;a href=&quot;http://invisible-island.net/ncurses/NCURSES-Programming-HOWTO.html#GETCHCLASS&quot;&gt;mvprintw()&lt;/a&gt;
function call to my CPU-state display, so I can see how that new line
is being adjusted as the CPU runs.  The result looks something like Fig
4 below.&lt;/p&gt;

&lt;table style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 4: Debugging the ZipCPU in simulation&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/zipdbg-simtest.png&quot; alt=&quot;Snapshot of the ZipCPU simulation debugger&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Indeed, I have not only register sets and disassembled instruction words,
but also bus debugging information (&lt;code class=&quot;highlighter-rouge&quot;&gt;PFCACH&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;PF BUS&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;MEMBUS&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;SYSBSM&lt;/code&gt;,
etc), and pipeline stall information (see the &lt;code class=&quot;highlighter-rouge&quot;&gt;Ck&lt;/code&gt; at the far left).&lt;/p&gt;

&lt;p&gt;That’s just about it: you’ve now made all of the modifications you need to make
to turn your
&lt;a href=&quot;https://www.veripool.org/wiki/verilator&quot;&gt;Verilator&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/sim/verilator/testb.h&quot;&gt;test harness&lt;/a&gt; into a &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/sim/verilator/zippy_tb.cpp&quot;&gt;usable CPU debugger&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;compiling-with-ncurses&quot;&gt;Compiling with ncurses&lt;/h2&gt;

&lt;p&gt;Getting this test bench to compile shouldn’t be any more difficult than
getting any
&lt;a href=&quot;https://www.veripool.org/wiki/verilator&quot;&gt;Verilator&lt;/a&gt;
based test bench to compile, but with one significant
difference: You’ll need to add &lt;code class=&quot;highlighter-rouge&quot;&gt;-lncurses&lt;/code&gt; to your final compile to make
sure that the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Ncurses&quot;&gt;ncurses&lt;/a&gt;
library gets included.&lt;/p&gt;

&lt;h2 id=&quot;the-big-drawback-to-an-ncurses-based-display&quot;&gt;The big drawback to an ncurses based display&lt;/h2&gt;

&lt;p&gt;Having used a debugger of this form for a couple of years now, I find there
is one significant drawback to it: once you type ‘t’ and cause the simulator
to ‘tick’ the clock and step the processor forward by a single clock tick,
there’s no going back to look at the previous state.&lt;/p&gt;

&lt;p&gt;While I’ve dreamed of implementing a ‘back’ key, my
current approach is to do any further debugging with printf() and
&lt;a href=&quot;http://gtkwave.sourceforge.net&quot;&gt;GTKWave&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The problem with printf() based debugging at this point, though, is that
the screen is already being used.  While I suppose you could pipe the output
of an &lt;a href=&quot;https://en.wikipedia.org/wiki/Ncurses&quot;&gt;ncurses&lt;/a&gt;
based program into a file, the screen control keys that
&lt;a href=&quot;https://en.wikipedia.org/wiki/Ncurses&quot;&gt;ncurses&lt;/a&gt; uses
are likely going to keep it from being very legible.&lt;/p&gt;

&lt;p&gt;I get around this problem by adding some debugging functions to the &lt;code class=&quot;highlighter-rouge&quot;&gt;tick()&lt;/code&gt;
method.  Specifically, between every positive clock edge and the next,
I will dump any debugging information such as the program counter or register
set, to a debugging file so that I can look back later and understand
what just took place.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;n&quot;&gt;CPU_TB&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tick&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;// ...
&lt;/span&gt;	&lt;span class=&quot;c1&quot;&gt;// Provide any simulated inputs to your core here.
&lt;/span&gt;	&lt;span class=&quot;c1&quot;&gt;// ...
&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;// Tick the clock
&lt;/span&gt;	&lt;span class=&quot;c1&quot;&gt;// ...
&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;// Take a moment to write things to a debugging file, for after
&lt;/span&gt;	&lt;span class=&quot;c1&quot;&gt;// action tracing.  I just use fprintf&#39;s here.
&lt;/span&gt;	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_dbgfp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;fprintf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_dbgfp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Some useful information&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h2 id=&quot;other-things-you-can-do&quot;&gt;Other things you can do&lt;/h2&gt;

&lt;p&gt;If you haven’t figured it out yet, the moral of all of this story is that
&lt;a href=&quot;https://www.veripool.org/wiki/verilator&quot;&gt;Verilator&lt;/a&gt;
turns an FPGA debugging and development session into any other C++ program.
You can add functionality to this program just like you would any other.&lt;/p&gt;

&lt;p&gt;For example, here are some additional functions that you may find very useful:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Creating commands to simulate debugging the CPU via your chosen hardware
debugging interface.&lt;/p&gt;

    &lt;p&gt;On the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;, the step command is
implemented this way.  Typing an ‘s’ will
“step” the CPU by one instruction, using the same interface that will be
needed to control the CPU for debugging later.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;A “Go” until breakpoint command&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Perhaps I should describe how to use the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt; debugging simulator as an example
of this lesson?
It’s actually really fun to watch, since you can see what happens on each
pipeline step, when instructions need to stall, or even how the pipeline
fills behind a stalled instruction.&lt;/p&gt;

&lt;p&gt;Let me know what you think!&lt;/p&gt;
</description>
        <pubDate>Wed, 26 Jul 2017 00:00:00 -0400</pubDate>
        <link>http://zipcpu.com/zipcpu/2017/07/26/cpu-sim-debugger.html</link>
        <guid isPermaLink="true">http://zipcpu.com/zipcpu/2017/07/26/cpu-sim-debugger.html</guid>
        
        
        <category>zipcpu</category>
        
      </item>
    
      <item>
        <title>How to Debug a DSP algorithm</title>
        <description>&lt;p&gt;We’ve now written a &lt;a href=&quot;/dsp/2017/07/19/linear-upsampling.html&quot;&gt;linear upsampling
algorithm&lt;/a&gt;, and
discussed how to handle both &lt;a href=&quot;/dsp/2017/07/21/bit-growth.html&quot;&gt;bit
growth&lt;/a&gt; and
&lt;a href=&quot;/dsp/2017/07/22/rounding.html&quot;&gt;rounding&lt;/a&gt; within it.  It’s
now time to debug it, and prove that it does (or doesn’t) work.&lt;/p&gt;

&lt;p&gt;The problem I’ve always had at this point is that my favorite tools don’t
work very well for this task.&lt;/p&gt;

&lt;p&gt;My favorite tool for debugging my own programs has always been (f)printf().
Sure, I’ve used &lt;a href=&quot;https://www.gnu.org/software/gdb&quot;&gt;gdb&lt;/a&gt;, and even its
friendlier cousin &lt;a href=&quot;https://www.gnu.org/software/ddd&quot;&gt;ddd&lt;/a&gt;.  It’s just that
these two debuggers have not been my favorite tool.  (f)printf() is still my
favorite tool when it comes to debugging logic with
&lt;a href=&quot;https://www.veripool.org/wiki/verilator&quot;&gt;Verilator&lt;/a&gt;.
In the case of HDL, &lt;a href=&quot;http://gtkwave.sourceforge.net&quot;&gt;GTKWave&lt;/a&gt; comes in as a
close second.&lt;/p&gt;

&lt;p&gt;None of these approaches has ever worked well for me when debugging &lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_signal_processing&quot;&gt;Digital
Signal Processing (DSP)&lt;/a&gt;
algorithms like this &lt;a href=&quot;https://github.com/ZipCPU/interpolation/blob/master/rtl/lininterp/lininterp.v&quot;&gt;linear
interpolator&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;There’s just no substitute for the ability to plot waveforms, raw, processed,
and even partially processed, on an ad-hoc basis.  This ad-hoc capability
is available through &lt;a href=&quot;https://www.gnu.org&quot;&gt;GNU&lt;/a&gt;’s
&lt;a href=&quot;https://www.gnu.org/software/octave&quot;&gt;Octave&lt;/a&gt;,
&lt;a href=&quot;https://www.mathworks.com&quot;&gt;Matlab&lt;/a&gt;, and to some extent with 
&lt;a href=&quot;http://www.gnuplot.info&quot;&gt;gnuplot&lt;/a&gt;.  Of these three, my favorite has been
&lt;a href=&quot;https://www.gnu.org/software/octave&quot;&gt;Octave&lt;/a&gt;–mostly because I cannot
afford &lt;a href=&quot;https://www.mathworks.com&quot;&gt;Matlab&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;In this post, we’ll return to examining our
&lt;a href=&quot;https://github.com/ZipCPU/interpolation/blob/master/rtl/lininterp/lininterp.v&quot;&gt;linear interpolator&lt;/a&gt;, 
but this time we’ll place it within a &lt;a href=&quot;https://github.com/ZipCPU/interpolation/blob/master/rtl/lininterp/lininterp.cpp&quot;&gt;test
harness&lt;/a&gt;
to find out whether or not it works, and to see why or why not.&lt;/p&gt;

&lt;p&gt;This &lt;a href=&quot;https://github.com/ZipCPU/interpolation/blob/master/rtl/lininterp/lininterp.cpp&quot;&gt;test harness&lt;/a&gt;
is the topic of this post.&lt;/p&gt;

&lt;h2 id=&quot;test-points&quot;&gt;Test Points&lt;/h2&gt;

&lt;p&gt;We know what we want our &lt;a href=&quot;https://github.com/ZipCPU/interpolation/blob/master/rtl/lininterp/lininterp.v&quot;&gt;linear
interpolator&lt;/a&gt;
to do.  &lt;a href=&quot;https://en.wikipedia.org/wiki/Linear_interpolation&quot;&gt;That theory&lt;/a&gt; was
well developed before we started.  Hence, no &lt;em&gt;validation&lt;/em&gt; is required.  What we
want to know instead is whether or not our &lt;a href=&quot;https://github.com/ZipCPU/interpolation/blob/master/rtl/lininterp/lininterp.v&quot;&gt;linear
interpolator&lt;/a&gt;
is coming up with the right answers.  That is, we want to &lt;em&gt;verify&lt;/em&gt; that our
Verilog logic works.&lt;/p&gt;

&lt;p&gt;The easiest way to find any errors within our logic is going to be to build a
&lt;a href=&quot;https://github.com/ZipCPU/interpolation/blob/master/rtl/lininterp/lintest.m&quot;&gt;duplicate set of logic&lt;/a&gt;
to do the &lt;em&gt;exact&lt;/em&gt; same thing, and then to compare the results to see if they
match.  While the approach isn’t perfect, the likelihood that both test
fixture &lt;em&gt;and&lt;/em&gt; system under test will be in error is much smaller than just
the one being in error.&lt;/p&gt;

&lt;p&gt;That means we are going to need to know:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;The input(s) to our routine&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Any intermediate results calculated by the routine, such as the slope the
routine generated, and&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The output of the routine.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The trick is that all of these values need to be lined up together in order
for &lt;a href=&quot;https://www.gnu.org/software/octave&quot;&gt;Octave&lt;/a&gt;
to repeat the calculation and compare the result.&lt;/p&gt;

&lt;p&gt;This isn’t quite as simple as it sounds, particularly because the outputs of
the &lt;a href=&quot;https://github.com/ZipCPU/interpolation/blob/master/rtl/lininterp/lininterp.v&quot;&gt;linear
interpolator&lt;/a&gt;,
as we built it, aren’t evenly spaced every &lt;code class=&quot;highlighter-rouge&quot;&gt;N&lt;/code&gt; ticks apart, but rather they get
produced in groups or bunches.  Hence, when you look at them in 
&lt;a href=&quot;http://gtkwave.sourceforge.net&quot;&gt;GTKWave&lt;/a&gt;, you may easily struggle to “see”
the waveform is that the interpolator is actually producing, as seen in Fig 1
below.&lt;/p&gt;

&lt;table style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 1: GTKWave view of the interpolated signal&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/lininterp-gtkwave.png&quot; alt=&quot;Example GTKWave window showing the output of a linear interpolator&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;So, we’re going to add to our &lt;a href=&quot;https://github.com/ZipCPU/interpolation/blob/master/rtl/lininterp/lininterp.cpp&quot;&gt;test
harness&lt;/a&gt;
a quick capability to write a debugging file out.  We’ll write this file
as a series of 32-bit integer binary values–something
&lt;a href=&quot;https://www.gnu.org/software/octave&quot;&gt;Octave&lt;/a&gt; will have no problems ingesting.
For test purposes, we’ll also use some logic within the
&lt;a href=&quot;https://github.com/ZipCPU/interpolation/blob/master/rtl/lininterp/lininterp.v&quot;&gt;core&lt;/a&gt; 
to keep the &lt;a href=&quot;https://github.com/ZipCPU/interpolation/blob/master/rtl/lininterp/lininterp.cpp&quot;&gt;test
harness&lt;/a&gt;
test points aligned.&lt;/p&gt;

&lt;p&gt;Our goal will be to produce two data sets, using
&lt;a href=&quot;https://www.gnu.org/software/octave&quot;&gt;Octave&lt;/a&gt;,
and to plot them one on top of the other.  The first line on the graph will
be our alternate calculation, done within
&lt;a href=&quot;https://www.gnu.org/software/octave&quot;&gt;Octave&lt;/a&gt;,
showing what the linear interpolators result &lt;em&gt;should&lt;/em&gt; be.  The second line
will plot what the result &lt;em&gt;actually is&lt;/em&gt;.  If the two functions
lie on top of each other, then we’ll know our algorithm works.&lt;/p&gt;

&lt;h2 id=&quot;the-test-harness&quot;&gt;The Test Harness&lt;/h2&gt;

&lt;p&gt;Let’s look through how the &lt;a href=&quot;https://github.com/ZipCPU/interpolation/blob/master/rtl/lininterp/lininterp.cpp&quot;&gt;test
harness&lt;/a&gt;
for this &lt;a href=&quot;https://github.com/ZipCPU/interpolation/blob/master/rtl/lininterp/lininterp.v&quot;&gt;linear
interpolator&lt;/a&gt;
is put together.  While in many ways it’s just like any other
&lt;a href=&quot;https://www.veripool.org/wiki/verilator&quot;&gt;Verilator&lt;/a&gt;
based test harness, one thing that makes it very unique is what happens
&lt;em&gt;after&lt;/em&gt; the clock tick.  To keep this simple, we’ll work in broad brush
strokes to explain how this works, skipping large portions of it.  If this
gets confusing, please look back at our &lt;a href=&quot;/blog/2017/06/21/looking-at-verilator.html&quot;&gt;first Verilator
tutorial&lt;/a&gt;, or
even the &lt;a href=&quot;https://github.com/ZipCPU/interpolation/blob/master/rtl/lininterp/lininterp.cpp&quot;&gt;test
harness&lt;/a&gt;
itself to see what’s going on.&lt;/p&gt;

&lt;p&gt;To set this up, at the beginning of &lt;a href=&quot;https://github.com/ZipCPU/interpolation/blob/master/rtl/lininterp/lininterp.cpp&quot;&gt;the test
harness&lt;/a&gt;’s
main routine, I created a debugging output file and pointer:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt;   &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;    &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;DBGFNAME&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;dbgfp.32t&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;FILE&lt;/span&gt;    &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dbg_fp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;dbg_fp&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fopen&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;DBGFNAME&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;w&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This file will also need to get closed when we’re all done.&lt;/p&gt;

&lt;p&gt;Second, it turns out that picking the right interpolation frequency is
rather important.  You want your input clock to be fairly low, and your
output clock fairly high if you want to make the pretty looking pictures below.
Testing with an output clock rate very near the input clock rate can also be
very useful and instructive as well, it just tends to be harder to understand
the results.&lt;/p&gt;

&lt;p&gt;For this &lt;a href=&quot;https://github.com/ZipCPU/interpolation/blob/master/rtl/lininterp/lininterp.cpp&quot;&gt;test
harness&lt;/a&gt;,
I set the input sample rate to be one input sample for every forty clock ticks.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;iclocks&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;40&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Third, we need to pick a signal to evaluate.  I chose a sine wave.  I set this
to be at a fairly low frequency, 24 input samples per wavelength, because it
will help to reveal any problems with our interpolator.  Higher frequencies
may also help, but they’ll test and reveal a different set of errors.&lt;/p&gt;

&lt;p&gt;The sine wave function call takes place between one input sample and the next.
To create the desired frequency, we’ll step the phase forward by some angle
on every input sample.  In the &lt;a href=&quot;https://github.com/ZipCPU/interpolation/blob/master/rtl/lininterp/lininterp.cpp&quot;&gt;test
harness&lt;/a&gt;
code snippet below, I have called this step &lt;code class=&quot;highlighter-rouge&quot;&gt;dphase&lt;/code&gt;, for a &lt;em&gt;phase difference&lt;/em&gt;
or phase step.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;c1&quot;&gt;// dphase is the phase increment of our test sinewave.  It&#39;s really
// represented by a phase step, rater than a frequency.  The phase
// step is how many radians to advance on each SYSTEM clock pulse
// (not input sample pulse).  This difference just makes things
// easier to track later.
&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// double	dphase = 1 / (double)iclocks / 260.0, dtheta = 0.0;
&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;dphase&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;iclocks&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;24.0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dtheta&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;DPHASE = %f&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dphase&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(...)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;

	&lt;span class=&quot;c1&quot;&gt;// As well as the phase of the simulated input sinewave
&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;dtheta&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dtheta&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dphase&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dtheta&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;1.0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;dtheta&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-=&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;1.0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

	&lt;span class=&quot;c1&quot;&gt;// Do I need to produce a new input sample to be interpolated?
&lt;/span&gt;	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;inow&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;iclocks&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;
		&lt;span class=&quot;c1&quot;&gt;// Calculate a new test sample via a sine wave
&lt;/span&gt;		&lt;span class=&quot;n&quot;&gt;rv&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cos&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;2.0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;M_PI&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dtheta&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
		&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Notice how &lt;code class=&quot;highlighter-rouge&quot;&gt;dphase&lt;/code&gt; increments the actual phase, &lt;code class=&quot;highlighter-rouge&quot;&gt;dtheta&lt;/code&gt; (double valued
theta).  Further, any time &lt;code class=&quot;highlighter-rouge&quot;&gt;dtheta&lt;/code&gt; wraps, we just subtract one to keep it
between zero and one.  Then, when an input sample is required, we use this
phase as an input to the cosine function.&lt;/p&gt;

&lt;p&gt;Fourth, there’s no reason to run this simulation until your PC needs to be
rebooted.  Hence, we’ll only look at a finite number of clock ticks before
halting our simulation:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;clocks&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MAXTICKS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;clocks&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Finally, the real important part of any &lt;a href=&quot;https://github.com/ZipCPU/interpolation/blob/master/rtl/lininterp/lininterp.cpp&quot;&gt;DSP
debugger&lt;/a&gt;,
in &lt;a href=&quot;https://www.veripool.org/wiki/verilator&quot;&gt;Verilator&lt;/a&gt;
(or any C++ algorithm for that matter), is to output values that
you can then ingest into &lt;a href=&quot;https://www.gnu.org/software/octave&quot;&gt;Octave&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;For our example, we’ll pick the inputs and outputs of the &lt;a href=&quot;https://github.com/ZipCPU/interpolation/blob/master/rtl/lininterp/lininterp.v&quot;&gt;linear
interpolator&lt;/a&gt;,
together with four internal values.  These will all be converted to signed
32-bit integers, and dumped to a file: six outputs at a time.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;c1&quot;&gt;// If the core is producing an output, then let&#39;s examine
// what went into it, and what it&#39;s calculations were.
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tb&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;o_ce&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;// We&#39;ll record six values
&lt;/span&gt;	&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;vals&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;6&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;

	&lt;span class=&quot;c1&quot;&gt;// Capture, from the core, the values to send to
&lt;/span&gt;	&lt;span class=&quot;c1&quot;&gt;// our binary debugging file
&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;vals&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tb&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i_data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;vals&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tb&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;o_data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;vals&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tb&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;o_last&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;vals&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tb&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;o_next&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;vals&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tb&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;o_slope&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;vals&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tb&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;o_offset&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

	&lt;span class=&quot;c1&quot;&gt;// Sign extend these values first
&lt;/span&gt;	&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;

	&lt;span class=&quot;c1&quot;&gt;// Write these to the debugging file
&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;fwrite&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vals&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;6&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dbg_fp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

	&lt;span class=&quot;c1&quot;&gt;// Just to prove we are doing something useful, print
&lt;/span&gt;	&lt;span class=&quot;c1&quot;&gt;// results out.  These tend to be incomprehensible to
&lt;/span&gt;	&lt;span class=&quot;c1&quot;&gt;// me in general, but I like seeing them because they
&lt;/span&gt;	&lt;span class=&quot;c1&quot;&gt;// convince me that something&#39;s going on.
&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;%8.2f: %08x, %08x, (%08x, %08x)&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;rv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tb&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i_data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tb&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;o_data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;vals&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;vals&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;You’ll see in the next section, when we discuss the
&lt;a href=&quot;https://www.gnu.org/software/octave&quot;&gt;Octave&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/interpolation/blob/master/rtl/lininterp/lintest.m&quot;&gt;test script&lt;/a&gt;,
why we chose a constant number of values, and a common type for all of these
same values.&lt;/p&gt;

&lt;h2 id=&quot;the-octave-script&quot;&gt;The Octave Script&lt;/h2&gt;

&lt;p&gt;The first step to processing this data within 
&lt;a href=&quot;https://www.gnu.org/software/octave&quot;&gt;Octave&lt;/a&gt;
is to load the information into
&lt;a href=&quot;https://www.gnu.org/software/octave&quot;&gt;Octave&lt;/a&gt;.
You’ll notice that all of the data we produced was uniform in
type, and all of the records had the same number of samples, six.  This
makes loading the file into octave very easy.  Indeed, it’s so easy that
I usually do it by hand for the first several rounds of debugging, before
I turn it into &lt;a href=&quot;https://github.com/ZipCPU/interpolation/blob/master/rtl/lininterp/lintest.m&quot;&gt;a script&lt;/a&gt;:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-matlab&quot; data-lang=&quot;matlab&quot;&gt;&lt;span class=&quot;n&quot;&gt;fid&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;fopen&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&#39;dbgfp.32t&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&#39;r&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;dat&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;fread&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,[&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;6&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;inf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&#39;int32&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;fclose&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;% Assign names to these values&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;i_data&lt;/span&gt;  &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dat&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,:);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;o_data&lt;/span&gt;  &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dat&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,:);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;o_last&lt;/span&gt;  &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dat&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,:);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;o_next&lt;/span&gt;  &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dat&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,:);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;o_slope&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dat&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,:);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;o_offset&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dat&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;6&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,:);&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;% We used 28 bits for our values internal to our simulation.  We&#39;d like to&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;% plot our sine wave here between +1 and -2.  Hence, we&#39;ll need to scale&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;% them by 1/2^27.&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;nbits&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;28&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;mxv&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;^&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nbits&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;I think if I needed multiple data types, I’d probably first promote values to
the largest type, and if that didn’t work I’d create multiple data files.&lt;/p&gt;

&lt;p&gt;Now that our data has been ingested into
&lt;a href=&quot;https://www.gnu.org/software/octave&quot;&gt;Octave&lt;/a&gt;,
let’s see if we can
&lt;a href=&quot;https://github.com/ZipCPU/interpolation/blob/master/rtl/lininterp/lintest.m&quot;&gt;redo the arithmetic&lt;/a&gt;
the FPGA is supposed to do, only this time in double precision math.&lt;/p&gt;

&lt;p&gt;In this case, all the required math was discussed in our
&lt;a href=&quot;/2017/07/19/linear-upsampling.html&quot;&gt;first post&lt;/a&gt;, so
here we just repeat it.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-matlab&quot; data-lang=&quot;matlab&quot;&gt;&lt;span class=&quot;n&quot;&gt;redo&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;o_last&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;o_next&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;o_last&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;o_offset&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mxv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;redo&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;redo&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mxv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;One key difference in this version, from the discussion of how to do this
within the FPGA, is the divide by &lt;code class=&quot;highlighter-rouge&quot;&gt;mxv*2&lt;/code&gt;.  This comes back to a bit growth
issue, but a fixed vs floating point version of it.  &lt;code class=&quot;highlighter-rouge&quot;&gt;o_offset&lt;/code&gt;, as &lt;a href=&quot;/2017/07/19/linear-upsampling.html&quot;&gt;you may
recall&lt;/a&gt;,
is an integer being used to represent a value between zero and one.
Hence, we need to divide it by its scale factor to turn it back into a floating
point value between zero and one.&lt;/p&gt;

&lt;p&gt;We’re also dividing our result, and indeed our input values as well, by &lt;code class=&quot;highlighter-rouge&quot;&gt;mxv&lt;/code&gt;
so that we can plot the result between more reasonable bounds.&lt;/p&gt;

&lt;p&gt;All that remains is to plot the results and see how well (or poorly) we did.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-matlab&quot; data-lang=&quot;matlab&quot;&gt;&lt;span class=&quot;nb&quot;&gt;plot&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i_data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mxv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&#39;b;Input Signal;&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;redo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&#39;r;Octave results;&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;o_data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mxv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&#39;g;Interpolated/Output Signal;&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;axis&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;([&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2501&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]);&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;grid&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;on&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;title&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&#39;Comparing output results to Octave calculated results&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;xlabel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&#39;Output Samples&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;ylabel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&#39;Units&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Plotting data like this will &lt;em&gt;really&lt;/em&gt; help you &lt;em&gt;see&lt;/em&gt; problems in your code,
and by seeing them, recognizing them will become easier to do.&lt;/p&gt;

&lt;h2 id=&quot;bugs-i-found&quot;&gt;Bugs I found&lt;/h2&gt;

&lt;p&gt;I really dislike sharing buggy code on this Blog.  Sorry.  As a result, I’m
not going to show how how I messed this up along the way. 
(My code always works the first time, right?)  Therefore, if you examine the
&lt;a href=&quot;https://github.com/ZipCPU/interpolation/blob/master/rtl/lininterp/lininterp.v&quot;&gt;linear interpolation example Verilog
code&lt;/a&gt;,
you’re not likely to find any bugs within it.  (I won’t put it past you,
though–as of today, I’ve only bench tested this component.)&lt;/p&gt;

&lt;p&gt;In reality, there were bugs within it when I first simulated it.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;The first bug I struggled with was a bit-width bug.&lt;/p&gt;

    &lt;p&gt;At several points during the linear interpolation algorithm, bits need to
be selected and &lt;a href=&quot;/dsp/2017/07/22/rounding.html&quot;&gt;even dropped&lt;/a&gt;.&lt;/p&gt;

    &lt;p&gt;When I first ran this test, I dropped some of the more significant bits
along the way.  The result looked &lt;em&gt;very&lt;/em&gt; &lt;em&gt;jumbled&lt;/em&gt;.   Further, since I was
trying to view a sinewave in
&lt;a href=&quot;http://gtkwave.sourceforge.net&quot;&gt;GTKWave&lt;/a&gt;,
they looked even more jumbled.  If you think you are
struggling with this problem at all, try increasing the bit width (there’s
a reason it’s set to 28 for this test), and backing away from full range to
see if it helps.&lt;/p&gt;

    &lt;p&gt;Because the number of input bits in our test is so large, this problem
can be see to have a clear signature (now) in Fig 2.&lt;/p&gt;

    &lt;table style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 2: Internal bit selects in error&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/lininterp-badbits.png&quot; alt=&quot;Linear interpolator bugs: errant bit selects&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

    &lt;p&gt;Once the algorithm works, you can remove any extra bits that were needed to
test and prove it.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Signed multiplies are different from unsigned multiplies&lt;/p&gt;

    &lt;p&gt;This was another of my problems.&lt;/p&gt;

    &lt;p&gt;If you aren’t familiar with this problem, the consider multiplying some
&lt;a href=&quot;https://en.wikipedia.org/wiki/Two&#39;s_complement&quot;&gt;two’s complement&lt;/a&gt; 3’bit
numbers together.  A &lt;code class=&quot;highlighter-rouge&quot;&gt;-2&lt;/code&gt; would be represented as &lt;code class=&quot;highlighter-rouge&quot;&gt;3&#39;b110&lt;/code&gt;.  Multiplying &lt;code class=&quot;highlighter-rouge&quot;&gt;-2&lt;/code&gt;
times &lt;code class=&quot;highlighter-rouge&quot;&gt;-2&lt;/code&gt; should be a six bit &lt;code class=&quot;highlighter-rouge&quot;&gt;-4&lt;/code&gt;, or &lt;code class=&quot;highlighter-rouge&quot;&gt;6&#39;b111100&lt;/code&gt; (Remember to
&lt;a href=&quot;/dsp/2017/07/21/bit-growth.html&quot;&gt;add the bit widths&lt;/a&gt;
of the inputs together to get the final bitwidth.)
However, if you use unsigned multiplication then &lt;code class=&quot;highlighter-rouge&quot;&gt;3&#39;b110&lt;/code&gt; (6) times
&lt;code class=&quot;highlighter-rouge&quot;&gt;3&#39;b110&lt;/code&gt; (6) is 6’b100100 (36) not 6’b111100.  See the difference?&lt;/p&gt;

    &lt;p&gt;You’ll notice this problem when everything works properly for positive
numbers, and then fails for negative numbers.  Indeed, if you ever see
a result where things work in sections but not entirely,
then you might want to check for this bug.&lt;/p&gt;

    &lt;table style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 3: Unsigned vs Signed Multiplication Error&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/lininterp-badsign.png&quot; alt=&quot;Unsigned vs Signed Multiplication Error&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

    &lt;p&gt;To fix this, I needed to declare the inputs to the multiply to be &lt;code class=&quot;highlighter-rouge&quot;&gt;signed&lt;/code&gt;
wire’s or registers.
I also needed to extend the unsigned time offset by a zero bit, to make
sure it had the right sign.  Once done, this bug cleared up as well.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;You can find the final working &lt;a href=&quot;https://github.com/ZipCPU/interpolation/blob/master/rtl/lininterp/lininterp.v&quot;&gt;linear interpolator
here&lt;/a&gt;. 
The two bugs listed above have been fixed.  As a result, the interpolator’s
test bench output now looks like Fig 4 below.&lt;/p&gt;

&lt;table style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 4: A Working Interpolator&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/lininterp-working.png&quot; alt=&quot;Working Linear Interpolator Output&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Not bad, huh?  In fact, it’s just the result we wanted.&lt;/p&gt;

&lt;h2 id=&quot;when-simulation-doesnt-match-realtiy&quot;&gt;When Simulation doesn’t Match Realtiy&lt;/h2&gt;

&lt;p&gt;Since I’ve only tested this linear interpolation core under simulation, there
may well be some residual problems if/when I try it on some actual hardware. 
It’s just a fact of life.&lt;/p&gt;

&lt;p&gt;If you ever find yourself in that situation, then just repeat the same test,
or one similar, but this time do it within the hardware itself.  Remember,
that was what your &lt;a href=&quot;/blog/2017/06/08/simple-scope.html&quot;&gt;internal
scope&lt;/a&gt; was for, right?&lt;/p&gt;

&lt;p&gt;You can also use the debugging method &lt;a href=&quot;/digilent/2017/05/29/fft-debugging.html&quot;&gt;discussed
here&lt;/a&gt;, should you
have problems where this works in simulation but not in hardware.  Further,
feel free to post any bugs below, or on the &lt;a href=&quot;https://github.com/ZipCPU/interpolation/issues&quot;&gt;issues
page&lt;/a&gt; for the
&lt;a href=&quot;https://github.com/ZipCPU/interpolation&quot;&gt;GitHub repo&lt;/a&gt;, and I’ll
fix anything you point out.&lt;/p&gt;

&lt;h2 id=&quot;lessons-learned&quot;&gt;Lessons Learned&lt;/h2&gt;

&lt;p&gt;This example should illustrate for you two important lessons:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;To determine if an FPGA algorithm is working, create another (similar)
non-FPGA algorithm and test the two against each other.&lt;/p&gt;

    &lt;p&gt;In this example, we compared an
&lt;a href=&quot;https://www.gnu.org/software/octave&quot;&gt;Octave&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/interpolation/blob/master/rtl/lininterp/lintest.m&quot;&gt;script&lt;/a&gt;’s
version of our interpolator (we called this &lt;code class=&quot;highlighter-rouge&quot;&gt;redo&lt;/code&gt;) with the outputs of our
&lt;a href=&quot;https://github.com/ZipCPU/interpolation/blob/master/rtl/lininterp/lininterp.v&quot;&gt;Verilog
interpolator&lt;/a&gt;.
When they matched, as in Fig 4 above, we knew the algorithm worked.&lt;/p&gt;

    &lt;p&gt;While this example accomplishes our needs for debugging a DSP algorithm,
the same approach can (in general) be applied to &lt;em&gt;many&lt;/em&gt; other FPGA
algorithms.
For example, you can find my &lt;a href=&quot;https://github.com/ZipCPU/wbuart32/tree/master/bench/cpp&quot;&gt;UART protocol validator here&lt;/a&gt;, my QSPI flash
&lt;a href=&quot;http://opencores.org/project,qspiflash&quot;&gt;validator here&lt;/a&gt;, and an
&lt;a href=&quot;https://github.com/ZipCPU/sdspi/tree/master/bench/cpp&quot;&gt;SD-Card SPI-based protocol validator here&lt;/a&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The easiest way of writing the logic twice with a DSP algorithm is to do
(and plot) the work within &lt;a href=&quot;https://www.gnu.org/software/octave&quot;&gt;Octave&lt;/a&gt;.&lt;/p&gt;

    &lt;p&gt;The neat thing about &lt;a href=&quot;https://www.gnu.org/software/octave&quot;&gt;Octave&lt;/a&gt;
is that you can plot various things in an ad-hoc manner.  Data can be
scaled, reshaped and resampled, Fourier transforms may be applied, axes
can be changed, labels adjusted, screen sizes changed, bit widths adjusted,
etc., all very quickly and easily.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;As an interesting side note, I once debugged the signal processing internal to
a two-way radio communications channel in a similar fashion to this.  This
approach really works very well.&lt;/p&gt;

&lt;p&gt;Feel free to share your own experiences below!&lt;/p&gt;

</description>
        <pubDate>Mon, 24 Jul 2017 00:00:00 -0400</pubDate>
        <link>http://zipcpu.com/dsp/2017/07/24/dsp-debugging.html</link>
        <guid isPermaLink="true">http://zipcpu.com/dsp/2017/07/24/dsp-debugging.html</guid>
        
        
        <category>dsp</category>
        
      </item>
    
      <item>
        <title>Rounding Numbers without Adding a Bias</title>
        <description>&lt;p&gt;Every time I’ve built a signal processing system, I’ve struggled with bit-width.
&lt;a href=&quot;/dsp/2017/07/21/bit-growth.html&quot;&gt;Bit width grows&lt;/a&gt; when you
apply a filter.  It grows when you add two streams together.  It grows when
you multiply your signal by an sine wave or a complex exponential.  Indeed,
&lt;a href=&quot;/dsp/2017/07/21/bit-growth.html&quot;&gt;bit growth&lt;/a&gt; alone can be
a challenge to keep track of.&lt;/p&gt;

&lt;p&gt;If you are not careful, you will make the problem worse like I first did when
you try to deal with it.&lt;/p&gt;

&lt;p&gt;You see, on my first
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt; &lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_signal_processing&quot;&gt;Digital
Signal Processing (DSP)&lt;/a&gt;
project, I just got rid of the bits I didn’t need by simply dropping them.  I’d
take the result of whatever arithmetic I had accomplished, and I’d only keep
the top &lt;code class=&quot;highlighter-rouge&quot;&gt;N&lt;/code&gt; bits.  Problem solved, right?&lt;/p&gt;

&lt;p&gt;Not quite.  While that approach kept the number of bits I was using in
bounds, it also created artifacts at DC that confused both myself and the
team of individuals I was working with.  Did the system really have an
uncontrolled DC bias?  Where did this bias come from?  Did we need better
analog filtering?  Better bias control up front?&lt;/p&gt;

&lt;p&gt;The answer was none of the above.  The problem was that I had not properly
handled dropping bits, although it took building
&lt;a href=&quot;https://github.com/ZipCPU/dblclockfft&quot;&gt;my own&lt;/a&gt; &lt;a href=&quot;https://en.wikipedia.org/wiki/Fast_Fourier_transform&quot;&gt;Fast Fourier Transform
(FFT)&lt;/a&gt; to realize I
had a problem.&lt;/p&gt;

&lt;p&gt;So let’s examine how to round numbers within an FPGA.
We’ll examine several forms of rounding, and look at how each of these
forms biases the result one way or another from true. Along the way, we’ll
use consider diagrams, similar Fig 1 below, to explain what’s happening.&lt;/p&gt;

&lt;table style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 1: The need for Rounding&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/rounding-tbd.svg&quot; alt=&quot;Outlining the rounding discussion&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;This figure shows a series of numbers, and a series of boxes.  The boxes
represent the incoming values, and the numbers above represent the possible
output values.  They are placed above the box where the operation would be
exact.&lt;/p&gt;

&lt;p&gt;If you look closer, you’ll notice that there are eight boxes per output
integer.  The boxes that line up exactly are under the arrows, and they are
also shown in color, to representing the integer they are assigned to. 
This leaves seven boxes between exact results that need to be determined.&lt;/p&gt;

&lt;p&gt;This is the issue of rounding.  When given a value (represented by one of
these boxes) between two integers, how shall it be mapped to one of the
integers above?  We’ll represent individual chosen mappings via color below,
so you can see and get a feel the concept.&lt;/p&gt;

&lt;p&gt;With this background, we can return to our question: how to go from
too many bits, to just the right number?&lt;/p&gt;

&lt;h1 id=&quot;go-for-easy-truncation&quot;&gt;Go for easy: truncation&lt;/h1&gt;

&lt;p&gt;The first way of dropping bits may be the easiest … just get rid of any
excess bits.  This was what I had done originally.  Consider, if you have
a data values &lt;code class=&quot;highlighter-rouge&quot;&gt;i_data&lt;/code&gt; coming in with &lt;code class=&quot;highlighter-rouge&quot;&gt;IWID&lt;/code&gt; (input width) bits, and you want
to create a data value with &lt;code class=&quot;highlighter-rouge&quot;&gt;OWID&lt;/code&gt; bits, why not just grab the top &lt;code class=&quot;highlighter-rouge&quot;&gt;OWID&lt;/code&gt; bits?&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;assign o_truncate = i_data[(IWID-1):(IWID-OWID)];&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;If you just want something quick and simple, this approach works.&lt;/p&gt;

&lt;p&gt;Well, sort of.&lt;/p&gt;

&lt;p&gt;Maybe not really.&lt;/p&gt;

&lt;p&gt;It’s what I used before I started working on an &lt;a href=&quot;https://github.com/ZipCPU/dblclockfft&quot;&gt;FFT
algorithm&lt;/a&gt;.  When I built my testbench
for the &lt;a href=&quot;https://github.com/ZipCPU/dblclockfft&quot;&gt;FFT&lt;/a&gt;, one of my inputs would
be a sine wave.  I expected as an output a single non-zero value at or near the
frequency of the sine wave.  While I got the value I was looking for at the
frequency of the sine wave, I also kept getting values at DC that didn’t make
sense to me.&lt;/p&gt;

&lt;p&gt;When I dug into this, I discovered that dropping bits in this fashion biases
the result by about a half of a bit in the negative direction.  If you consider
Fig 1 below, you can see this effect since it shows how the area covered by
each number is biased to the right of the number.&lt;/p&gt;

&lt;table style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 2: Truncation effects&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/rounding-bytruncation.svg&quot; alt=&quot;Effect of dropping bits by truncation&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;So it was working on this &lt;a href=&quot;https://github.com/ZipCPU/dblclockfft&quot;&gt;FFT algorithm&lt;/a&gt;
that sent me looking for alternatives.  The best explanation I found of the
various alternatives was on &lt;a href=&quot;https://en.wikipedia.org/wiki/Rounding&quot;&gt;wikipedia’s rounding
page&lt;/a&gt;.  Here, we’ll just explain
the types of rounding discussed &lt;a href=&quot;https://en.wikipedia.org/wiki/Rounding&quot;&gt;there&lt;/a&gt;,
and show some Verilog examples of how to do each.&lt;/p&gt;

&lt;h1 id=&quot;basic-rounding-round-half-up&quot;&gt;Basic rounding: Round half up&lt;/h1&gt;

&lt;p&gt;My next approach to dropping bits was to add a half.  This was the type of
rounding I learned to do as a child in grade school. 
&lt;a href=&quot;https://en.wikipedia.org/wiki/Rounding&quot;&gt;Wikipedia calls this&lt;/a&gt;
“round half up”.&lt;/p&gt;

&lt;p&gt;The Verilog code for doing this is nice, in that it only needs &lt;code class=&quot;highlighter-rouge&quot;&gt;OWID+1&lt;/code&gt; bits
to work on.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;assign	w_halfup = i_data[(IWID-1):0]
		+ { {(OWID){1&#39;b0}}, 1&#39;b1, {(IWID-OWID-1){1&#39;b0}} };
always @(posedge i_clk)
	o_halfup &amp;lt;= w_halfup[(IWID-1):(IWID-OWID)];&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Many of the other approaches we’ll discuss will require adding numbers to all
&lt;code class=&quot;highlighter-rouge&quot;&gt;IWID&lt;/code&gt; bits, so this approach turns out to be simpler than the other
rounding approaches below.&lt;/p&gt;

&lt;p&gt;While this approach worked a lot better, it still leaves a bias within the data
values.&lt;/p&gt;

&lt;table style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 3: Round Half-Up&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/rounding-halfup.svg&quot; alt=&quot;Round Half-Up&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;To understand what the problem is, consider the bins around our output numbers,
as shown in Fig 4 below:&lt;/p&gt;

&lt;table style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 4: Illustrating the problem with rounding&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/rounding-problem.svg&quot; alt=&quot;Illustrating the problem(s) with rounding&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;We might argue that every bin should be attached to the output value “nearest”
to it.&lt;/p&gt;

&lt;p&gt;That leaves the bins or boxes in the exact center, exactly located between
any two integer values.&lt;/p&gt;

&lt;p&gt;If you connect all those between bins to the integers
on the right, you’ll create the bias we saw in Fig 3.  Sure, it’s less than
the bias in Fig 2, bit its still a bias.&lt;/p&gt;

&lt;p&gt;On the other hand, if you connect all these in-between bins to the integer
values on the left (round half down), you’ll create a similar bias–only
in the other direction.&lt;/p&gt;

&lt;p&gt;Several types of rounding will fix this.&lt;/p&gt;

&lt;h1 id=&quot;round-towards-zero&quot;&gt;Round towards zero&lt;/h1&gt;

&lt;p&gt;One unbiased method of rounding is to round towards zero, shown in Fig 5 below.&lt;/p&gt;

&lt;table style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 5: Rounding towards zero&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/rounding-tozero.svg&quot; alt=&quot;Rounding towards zero&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;In this case, we select the integer nearest zero for our midpoint.&lt;/p&gt;

&lt;p&gt;Doing this in Verilog is simple, too:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;assign	w_tozero = i_data[(IWID-1):0] + , i_data[(IWID-1)],
			{(IWID-OWID-1){!i_data[(IWID-1)]}}};
always @(posedge i_clk)
	o_tozero &amp;lt;= w_tozero[(IWID-1):(IWID-OWID)];&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;An almost identical method is to round away from zero.  In this case, the
mid point values are assigned to the integer nearest them that is farthest
from zero.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;assign	w_fromzero = i_data[(IWID-1):0] + , !i_data[(IWID-1)],
			{(IWID-OWID-1){i_data[(IWID-1)]}}};
always @(posedge i_clk)
	o_fromzero &amp;lt;= w_fromzero[(IWID-1):(IWID-OWID)];&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The problem with these two approaches is that they will subtly change
the amplitude of your signal.&lt;/p&gt;

&lt;p&gt;Is there a better approach?&lt;/p&gt;

&lt;h1 id=&quot;convergent-rounding-round-half-to-even&quot;&gt;Convergent rounding: Round half to even&lt;/h1&gt;

&lt;p&gt;Thankfully, I didn’t need to invent a better approach.  Several solutions to the
rounding problem were already listed for me in a 
&lt;a href=&quot;https://en.wikipedia.org/wiki/Rounding&quot;&gt;Wikipedia&lt;/a&gt; article.&lt;/p&gt;

&lt;p&gt;The better approach that I have found is called convergent rounding, although
&lt;a href=&quot;https://en.wikipedia.org/wiki/Rounding#Round_half_to_even&quot;&gt;Wikipedia&lt;/a&gt; gives it many other names.
Perhaps “Round half to even” is the most
descriptive.  Convergent rounding starts out in an identical fashion to the
more traditional rounding (round half up), with the exception of when you are
at the exact half way point.  In that case, convergent rounding rounds towards
the nearest &lt;em&gt;even&lt;/em&gt; integer, as shown in Fig 6 below.&lt;/p&gt;

&lt;table style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 6: Convergent Rounding&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/rounding-toeven.svg&quot; alt=&quot;Illustrating convergent rouding&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;If you count the number of input bins assigned to each output integer, you’ll
notice that 0 gets 9 bins, 1 gets 7, 2 gets 9, etc.&lt;/p&gt;

&lt;p&gt;Likewise, the Verilog code to perform this operation is no more difficult
than rounding towards (or away from) zero.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;assign	w_convergent = i_data[(IWID-1):0]
			+ { {(OWID){1&#39;b0}},
				i_data[(IWID-OWID)],
				{(IWID-OWID-1){!i_data[(IWID-OWID)]}}};
always @(posedge i_clk)
	o_convergent &amp;lt;= w_convergent[(IWID-1):(IWID-OWID)];&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;You may notice that these last several forms of rounding required a single clock
delay to calculate the answer.  That extra clock is required to perform a
full word’s worth of addition.  This is the addition required to get the carry
to propagate through the entire input number.&lt;/p&gt;

&lt;p&gt;If you can’t afford the extra clock, consider just dropping the extra bit, as
in our first example.&lt;/p&gt;

&lt;p&gt;By the way, I’m not the only one who likes this approach.  According to the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Rounding#Round_half_to_even&quot;&gt;Wikipedia&lt;/a&gt;
article, it is the “default rounding mode used in &lt;a href=&quot;https://en.wikipedia.org/wiki/IEEE_754&quot;&gt;IEEE
754&lt;/a&gt; computing functions”.  Recognize
that standard?  &lt;a href=&quot;https://en.wikipedia.org/wiki/IEEE_754&quot;&gt;IEEE 754&lt;/a&gt; is the
standard that defines how floating point is done within your computer.&lt;/p&gt;

&lt;h1 id=&quot;the-dblclock-fft&quot;&gt;The DblClock FFT&lt;/h1&gt;

&lt;p&gt;In my motivation above, I mentiond the
&lt;a href=&quot;https://github.com/ZipCPU/dblclockfft&quot;&gt;FFT&lt;/a&gt; I had built earlier.  This
&lt;a href=&quot;https://github.com/ZipCPU/dblclockfft&quot;&gt;FFT&lt;/a&gt; is built a bit differently from a
lot of the other Verilog cores I’ve worked with and those I’ve come across. 
In particularly, the &lt;a href=&quot;https://github.com/ZipCPU/dblclockfft&quot;&gt;dblclockfft&lt;/a&gt;
project consists not in a Verilog core, but rather the
&lt;a href=&quot;https://github.com/ZipCPU/dblclockfft/blob/master/sw/fftgen.cpp&quot;&gt;C++ code&lt;/a&gt;
necessary to build a Verilog core.  This gives it the flexibility to build
any &lt;a href=&quot;https://github.com/ZipCPU/dblclockfft&quot;&gt;FFT&lt;/a&gt; size or bit-width you want.&lt;/p&gt;

&lt;p&gt;It’s also a bit of a niche product, since it takes two input samples per clock.&lt;/p&gt;

&lt;p&gt;In other words, &lt;a href=&quot;https://github.com/ZipCPU/dblclockfft&quot;&gt;dblclockfft&lt;/a&gt; can be
configured for arbitrary FFT sizes (subject to the amount of logic on your
device), incoming and outgoing bit widths, as well as the number of hardware
multiplies used internally.  It also allows you (internally) to configure
the type of rounding that will be used within the resulting algorithm.&lt;/p&gt;

&lt;p&gt;It was while testing &lt;a href=&quot;https://github.com/ZipCPU/dblclockfft&quot;&gt;this FFT core&lt;/a&gt;
that I noticed sinewaves going into the core were producing results on the
DC bin coming out.  The problem, when fully traced out, came down to rounding.
Using the &lt;a href=&quot;https://github.com/ZipCPU/dblclockfft/blob/master/sw/fftgen.cpp&quot;&gt;C++ core generator
program&lt;/a&gt;,
I then tested and compared multiple rounding
approaches against each other, and decided upon the convergent rounding
approach discussed above.  (That’s why the type of rounding can be configured
internally.)&lt;/p&gt;

&lt;p&gt;As a side note, with just a touch of care and feeding the
&lt;a href=&quot;https://github.com/ZipCPU/dblclockfft&quot;&gt;dblclockfft&lt;/a&gt; could be adjusted to
meet anyone’s
&lt;a href=&quot;https://en.wikipedia.org/wiki/Fast_Fourier_transform&quot;&gt;FFT&lt;/a&gt;
needs.  Want a single sample in per clock?  It’s &lt;em&gt;almost&lt;/em&gt;
there.  Want a real (vice complex)
&lt;a href=&quot;https://en.wikipedia.org/wiki/Fast_Fourier_transform&quot;&gt;FFT&lt;/a&gt;?
It only needs one additional module.
How about running an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Fast_Fourier_transform&quot;&gt;FFT&lt;/a&gt;?
in a non-pipelined mode, with only two hardware
multiplies required &lt;em&gt;in total&lt;/em&gt;, and the size cost turned into a block RAM cost? 
Most of the pieces are there for that as well.  In other words, with a &lt;a href=&quot;https://www.patreon.com/ZipCPU&quot;&gt;touch
of support&lt;/a&gt;, that &lt;a href=&quot;https://github.com/ZipCPU/dblclockfft&quot;&gt;FFT
project&lt;/a&gt; could be made &lt;em&gt;very&lt;/em&gt; generic.&lt;/p&gt;

&lt;h1 id=&quot;next-steps&quot;&gt;Next steps&lt;/h1&gt;

&lt;p&gt;This particular post is actually only one in a series of posts building up to a
working linear upsampling interpolator.  We’ve already discussed the basic
&lt;a href=&quot;/dsp/2017/07/19/linear-upsampling.html&quot;&gt;upsampling linear
interpolator&lt;/a&gt;, and
&lt;a href=&quot;/dsp/2017/07/21/bit-growth.html&quot;&gt;bit growth&lt;/a&gt; within it. 
Now that we understand rounding, our next step in building this
&lt;a href=&quot;https://github.com/ZipCPU/rtl/lininterp/lininterp.v&quot;&gt;interpolator&lt;/a&gt;
will be to discuss how to debug a DSP algorithm.&lt;/p&gt;

&lt;p&gt;Stick around, debugging the linear upsampler makes a great example of how to
&lt;a href=&quot;/dsp/2017/07/24/dsp-debugging.html&quot;&gt;debug a DSP algorithm&lt;/a&gt;.&lt;/p&gt;

</description>
        <pubDate>Sat, 22 Jul 2017 00:00:00 -0400</pubDate>
        <link>http://zipcpu.com/dsp/2017/07/22/rounding.html</link>
        <guid isPermaLink="true">http://zipcpu.com/dsp/2017/07/22/rounding.html</guid>
        
        
        <category>dsp</category>
        
      </item>
    
      <item>
        <title>Bit growth in FPGA arithmetic</title>
        <description>&lt;p&gt;We just started a discussion of
&lt;a href=&quot;/dsp/2017/07/19/linear-upsampling.html&quot;&gt;linear-upsampling&lt;/a&gt;.
In many ways the &lt;a href=&quot;/dsp/2017/07/19/linear-upsampling.html&quot;&gt;linear-upsampling&lt;/a&gt;
algorithm is much like &lt;em&gt;any&lt;/em&gt; DSP algorithm: samples come in, multiplies, adds,
and subtracts get applied, and samples go out.
Like any other algorithm using these operations, every add or multiply
will increase the number of bits required to represent the result.
So it seems only fitting to look at bit growth, so we can know how many bits
to allocate for our internal results.&lt;/p&gt;

&lt;p&gt;Since dropping bits, once grown, is even more complicated than just tracking
bit growth, we’ll save that discussion for it’s own post later.&lt;/p&gt;

&lt;p&gt;If you’ve never dealt with, or heard of, bit growth before then it can be
confusing.  It doesn’t need to be so.  As we’ll show here, there are only
two rules you need to keep track of.  Follow the two basic rules, and you
should be okay.  That said, we’ll present three rules today.&lt;/p&gt;

&lt;p&gt;My basic approach for understanding bit growth is to look
at the extremes of any &lt;code class=&quot;highlighter-rouge&quot;&gt;N&lt;/code&gt; bit arithmetic operation, and see how many bits
it takes to represent that extreme.  Indeed, if you ever get confused, just
come back to this approach and examine the extremes of the values you
are calculated within your application.&lt;/p&gt;

&lt;p&gt;Looking at the extremes in the representation, an &lt;code class=&quot;highlighter-rouge&quot;&gt;N&lt;/code&gt; bit number,
&lt;code class=&quot;highlighter-rouge&quot;&gt;a&lt;/code&gt;, can be any one of a range of signed or unsigned values.  In the
case of signed, &lt;a href=&quot;https://en.wikipedia.org/wiki/Two&#39;s_complement&quot;&gt;two’s
complement&lt;/a&gt;
values, the range of an &lt;code class=&quot;highlighter-rouge&quot;&gt;N&lt;/code&gt; bit number is given by,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;-2^(N-1) &amp;lt;= a &amp;lt;= 2^(N-1) -1&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Hence, a four bit number can represent values between -8 and +7 inclusive.&lt;/p&gt;

&lt;p&gt;Likewise the range of an unsigned value &lt;code class=&quot;highlighter-rouge&quot;&gt;N&lt;/code&gt; bits wide is,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;0 &amp;lt;= a &amp;lt; 2^(N) -1&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;and a four bit unsigned number can represent values from 0 to 15.&lt;/p&gt;

&lt;p&gt;If you add, subtract, or multiply numbers at the ends of these ranges,
by how much must &lt;code class=&quot;highlighter-rouge&quot;&gt;N&lt;/code&gt; be increased to capture the new result without overflow?&lt;/p&gt;

&lt;p&gt;There are a couple of cases you might not consider along the way, and so I’ll
note these below and keep this page updated as a reminder of what the corner
cases are.&lt;/p&gt;

&lt;h2 id=&quot;add-one-bit-on-every-add&quot;&gt;Add one bit on every add&lt;/h2&gt;

&lt;p&gt;The rule for addition is that adding two &lt;code class=&quot;highlighter-rouge&quot;&gt;N&lt;/code&gt; bit numbers together requires
an extra bit to represent the result.  Let’s test this to see if this is
true:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;(2^N-1) + (2^N-1) = 2^(N+1)-2&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;That certainly works for the positive end of the range, what about the negative
end?&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;-2^N - 2^N = -2^(N+1)&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;So, at the negative end we are good with adding an additional bit as well.&lt;/p&gt;

&lt;p&gt;If you know that the numbers you will be adding will have different signs,
then no bit growth is needed, since the absolute value of the result will
tend towards zero rather than increasing.  I’ve just never found an
application that can use this nuance.&lt;/p&gt;

&lt;p&gt;Unsigned numbers are roughly the same, with exception that you need to be
careful when subtracting two unsigned numbers.  The problem here being that
the result might be negative.
This means that, unless you can guarantee that the result will
not overflow (i.e. go below zero), you will need to add a sign bit.  Hence,
again, one bit of growth–but this comes with an &lt;a href=&quot;https://en.wikipedia.org/wiki/Two&#39;s_complement&quot;&gt;alternate representation
(two’s complement)&lt;/a&gt; as well.&lt;/p&gt;

&lt;p&gt;So the rule of adding one bit per addition (or) subtraction has special case
we’ll need to be careful of, where the data representation changes as well,
but otherwise it holds.&lt;/p&gt;

&lt;p&gt;What if you are adding values with different bit widths?  Suppose you wish to
add an &lt;code class=&quot;highlighter-rouge&quot;&gt;N&lt;/code&gt; bit number to an &lt;code class=&quot;highlighter-rouge&quot;&gt;M&lt;/code&gt; bit number?  As before, the answer can be found
by examining the extremes.  If you add the two positive extremes:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;2^(N-1)-1+2^(M-1)-1 &amp;lt; 2^(N) - 1&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;as long as &lt;code class=&quot;highlighter-rouge&quot;&gt;M&amp;lt;N&lt;/code&gt;.  The same is true for the negative extreme.  Here, then,
the rule is that the output must have one more bit than the widest of the
two input numbers.&lt;/p&gt;

&lt;p&gt;Now, let’s apply this to bits within an FPGA.  When building DSP algorithms,
you’ll want to adjust them for the appropriate width &lt;em&gt;later&lt;/em&gt;.  That way you
can write one routine that works for multiple bit-widths, and may even work
across multiple projects.  Hence, you’ll want to declare your various bit
widths as parameters.  We’ll use this approach for our &lt;a href=&quot;/dsp/2017/07/19/linear-upsampling.html&quot;&gt;linear
interpolator&lt;/a&gt;,
as well.)  For example, if you want to add two number, &lt;code class=&quot;highlighter-rouge&quot;&gt;a&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;b&lt;/code&gt;,
together, you might do something like:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;module add(i_clk, a, b, out);
parameter	AWIDTH=16, BWIDTH=4;
		// Output width is given by one more than the maximum of A&#39;s
		// width and B&#39;s width.  Make this a localparam so that
		// it can&#39;t be overridden
localparam	OUTWID = (AWIDTH &amp;gt; BWIDTH) ? (AWIDTH + 1) : (BWIDTH+1);

input	wire	[(AWIDTH-1):0]	a;
input	wire	[(BWIDTH-1):0]	b;
output	reg	[(OUTWID-1):0]	out;

always @(posedge i_clk)
	out &amp;lt;= a + b;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This captures all of the logic we just discussed above: adding one bit on
any addition or subtraction.&lt;/p&gt;

&lt;h2 id=&quot;long-strings-of-addition&quot;&gt;Long strings of addition&lt;/h2&gt;

&lt;p&gt;Since the fundamental DSP operation is a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Convolution&quot;&gt;convolution&lt;/a&gt;, and since
&lt;a href=&quot;https://en.wikipedia.org/wiki/Convolution&quot;&gt;convolutions&lt;/a&gt;
require adding lots of numbers together, this creates a special case of
bit growth that needs to be discussed.&lt;/p&gt;

&lt;p&gt;Imagine you had &lt;code class=&quot;highlighter-rouge&quot;&gt;K&lt;/code&gt; words, &lt;code class=&quot;highlighter-rouge&quot;&gt;N&lt;/code&gt; bits each, that all needed to be added together.
If you applied the rule above, you might allocate &lt;code class=&quot;highlighter-rouge&quot;&gt;K+N&lt;/code&gt; bits to the result.
While the result would work, it’s also more bits than you need.&lt;/p&gt;

&lt;p&gt;As before, we’ll look at the extremes.  What happens when you add &lt;code class=&quot;highlighter-rouge&quot;&gt;K&lt;/code&gt; extreme
values together?  We’ll consider only the signed case, since the unsigned
case is roughly the same:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;K * (2^(N-1)-1)&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Before taking the next step, let’s imagine a number of bits, &lt;code class=&quot;highlighter-rouge&quot;&gt;M&lt;/code&gt;, that can hold
the value &lt;code class=&quot;highlighter-rouge&quot;&gt;K&lt;/code&gt;, such that:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;K &amp;lt;= 2^M&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Further, we want &lt;code class=&quot;highlighter-rouge&quot;&gt;M&lt;/code&gt; to be the smallest number possible so that this inequality
holds.  Mathematically, we might say that,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;M = ceil(log(K)/log(2))&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;or equivalently that &lt;code class=&quot;highlighter-rouge&quot;&gt;M&lt;/code&gt; is the &lt;a href=&quot;https://en.wikipedia.org/wiki/Floor_and_ceiling_functions&quot;&gt;ceiling (smallest integer above or equal
to)&lt;/a&gt;
of the base two &lt;a href=&quot;https://en.wikipedia.org/wiki/Logarithm&quot;&gt;logarithm&lt;/a&gt;
of &lt;code class=&quot;highlighter-rouge&quot;&gt;K&lt;/code&gt;.  In simpler terms, it’s just the log (base
two) of &lt;code class=&quot;highlighter-rouge&quot;&gt;K&lt;/code&gt;, rounded up to the nearest integer.&lt;/p&gt;

&lt;p&gt;Now, using this number, we know that&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;K &amp;lt;= 2^M&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;and so that,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;K * (2^(N-1)-1) &amp;lt;= (2^M)*(2^(N-1)-1) = 2^(M+N-1)-1&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;And that’s our defining case.  When adding a large number of values together,
all having the same bit width, the number of bits required to hold the result
is given by the original number of bits plus the log, base two, of the
number of elements added together.&lt;/p&gt;

&lt;p&gt;We’ll save the Verilog example for when we build an FIR filter on this blog.&lt;/p&gt;

&lt;h2 id=&quot;add-the-number-of-bits-on-every-multiply&quot;&gt;Add the number of bits on every multiply&lt;/h2&gt;

&lt;p&gt;Let’s now look at multiplying two numbers.  We’ll start by looking at signed
multiplication, but then look at unsigned multiplication before finishing.&lt;/p&gt;

&lt;p&gt;Our first step will be to examine
&lt;a href=&quot;https://en.wikipedia.org/wiki/Two&#39;s_complement&quot;&gt;two’s complement&lt;/a&gt;
multiplication.  Suppose we multiply
a signed &lt;code class=&quot;highlighter-rouge&quot;&gt;N&lt;/code&gt; bit number with a signed &lt;code class=&quot;highlighter-rouge&quot;&gt;M&lt;/code&gt; bit number.  If you multiply
the two largest of these numbers together, the result will fit in &lt;code class=&quot;highlighter-rouge&quot;&gt;N+M-1&lt;/code&gt; bits:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;(2^(N-1) -1) * (2^(M-1) -1) = 2^(N+M-2) -2^(M-1) - 2^(N-1) +1 &amp;lt; 2^(N+M-2)-1&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Don’t forget to check the other extreme!  Multiplying the two most negative
numbers together yields a positive result, so this is an important check:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;(-2^(N-1)) * (-2^(M-1)) = 2^(N+M-2) &amp;lt; 2^(N+M-1)&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;You may note that 2^(N+M-2) just barely doesn’t fit in &lt;code class=&quot;highlighter-rouge&quot;&gt;N+M&lt;/code&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Two&#39;s_complement&quot;&gt;two’s complement&lt;/a&gt;
bits, so this becomes the defining case: &lt;code class=&quot;highlighter-rouge&quot;&gt;N+M&lt;/code&gt; bits are required to hold the
output, although fitting within &lt;code class=&quot;highlighter-rouge&quot;&gt;N+M-1&lt;/code&gt; bits will be more common.&lt;/p&gt;

&lt;p&gt;In Verilog, multiplying two signed numbers together would look like:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;module multiply(i_clk, a, b, out);
parameter	AWIDTH=16, BWIDTH=4;
		// Output width is given by one more than the maximum of A&#39;s
		// width and B&#39;s width
localparam	OUTWID = (AWIDTH + BWIDTH);

input	signed wire	[(AWIDTH-1):0]	a;
input	signed wire	[(BWIDTH-1):0]	b;
output	signed reg	[(OUTWID-1):0]	out;

always @(posedge i_clk)
	out &amp;lt;= a * b;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Notice again that, just like the add, we allow the bit width to be specified
(and overruled) by a parameter.  This allows us to adjust the bit-width
later.&lt;/p&gt;

&lt;p&gt;Now let’s consider unsigned multiplication.  In this case, we only need to check
the positive edge of the interval,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;(2^(N) -1) * (2^(M) -1) = 2^(N+M) -2^(M) - 2^(N) +1 &amp;lt; 2^(N+M)-1&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;As before, &lt;code class=&quot;highlighter-rouge&quot;&gt;N+M&lt;/code&gt; bits are required to hold the product of an &lt;code class=&quot;highlighter-rouge&quot;&gt;N&lt;/code&gt; bit number
with an &lt;code class=&quot;highlighter-rouge&quot;&gt;M&lt;/code&gt; bit number.  Indeed, the Verilog code for doing this is the same
as before, with the only exception that the &lt;code class=&quot;highlighter-rouge&quot;&gt;signed&lt;/code&gt; tag needs to be
removed to do unsigned multiplication.&lt;/p&gt;

&lt;h2 id=&quot;rules-to-live-by&quot;&gt;Rules to Live By&lt;/h2&gt;

&lt;p&gt;Let’s summarize our rules here:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;When adding two numbers, increase the number of bits in the result by one.&lt;/p&gt;

    &lt;p&gt;Be careful of subtracting unsigned numbers.  Your new bit may change
you from unsigned to signed &lt;a href=&quot;https://en.wikipedia.org/wiki/Two&#39;s_complement&quot;&gt;two’s
complement&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;When adding long strings of numbers, each with an identical number of bits,
such as you would do when implementing a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Convolution&quot;&gt;convolution&lt;/a&gt;
the bit growth goes as the log of the length of the string, rather than one
bit per addition.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;When multiplying two numbers, store the output in a register having as many
bits within it as the two multiplicands had combined.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;We’re not quite ready to finish our lesson on &lt;a href=&quot;/dsp/2017/07/19/linear-upsampling.html&quot;&gt;Linear
Interpolation&lt;/a&gt;,
though.  We still need to discuss&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;How to &lt;a href=&quot;/dsp/2017/07/22/rounding.html&quot;&gt;drop bits&lt;/a&gt;
when processing signals, and&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;How to &lt;a href=&quot;/dsp/2017/07/24/dsp-debugging.html&quot;&gt;debug DSP
algorithms&lt;/a&gt;.&lt;/p&gt;

    &lt;p&gt;The approach you will need to debug a DSP based algorithm is very distinctly
different from the tools necessary to debug the rest of your logic.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Then we can come back and finish building our
&lt;a href=&quot;/dsp/2017/07/19/linear-upsampling.html&quot;&gt;linear interpolator&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;If you see any mistakes in the rules above, or any rules regarding bit growth
that I’ve missed, please feel free to comment and note them below.&lt;/p&gt;
</description>
        <pubDate>Fri, 21 Jul 2017 00:00:00 -0400</pubDate>
        <link>http://zipcpu.com/dsp/2017/07/21/bit-growth.html</link>
        <guid isPermaLink="true">http://zipcpu.com/dsp/2017/07/21/bit-growth.html</guid>
        
        
        <category>dsp</category>
        
      </item>
    
      <item>
        <title>A Basic Upsampling Linear Interpolator</title>
        <description>&lt;p&gt;Our &lt;a href=&quot;/dsp/2017/06/06/simple-interpolator.html&quot;&gt;last post on
interpolation&lt;/a&gt;
discussed how to &lt;a href=&quot;https://en.wikipedia.org/wiki/Sample_rate_conversion&quot;&gt;change the data
rate&lt;/a&gt; of a signal within
a system from one rate to another by using a &lt;a href=&quot;/dsp/2017/06/06/simple-interpolator.html&quot;&gt;sample and hold
interpolator&lt;/a&gt;.
If you’ve spent much time working with Digital Signal Processing (DSP)
algorithms, you’ll understand that this approach offers absolutely no
&lt;a href=&quot;https://en.wikipedia.org/wiki/Aliasing&quot;&gt;antialiasing protection&lt;/a&gt;.
Sure, it works, but it’s not necessarily how you will want to build a quality
system.&lt;/p&gt;

&lt;p&gt;As an example, let’s consider a simple waveform, drawn below in blue.&lt;/p&gt;

&lt;table style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 1: The Original (Sampled) Signal&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/original.png&quot; alt=&quot;Original (Sampled) Signal&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;This waveform has been sampled at the green dot locations.&lt;/p&gt;

&lt;p&gt;If we now used the &lt;a href=&quot;/dsp/2017/06/06/simple-interpolator.html&quot;&gt;sample and
hold&lt;/a&gt;
algorithm to resample this signal, we’d get
a result looking like the red dots in Fig 2.&lt;/p&gt;

&lt;table style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 2: Sample and Hold&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/sample-and-hold.png&quot; alt=&quot;Sample and Hold Resampling&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;While we could center the diagram, and thereby do a nearest neighbour
interpolation (Fig 3),&lt;/p&gt;

&lt;table style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 3: Nearest Neighbour&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/nearest-neighbour.png&quot; alt=&quot;Nearest Neighbour Resampling&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;the result just doesn’t look much better.  It still doesn’t look anything like
our original signal, shown in blue.&lt;/p&gt;

&lt;p&gt;For this post, let’s try to do one better.  Let’s build a upsampling
interpolator, that will &lt;a href=&quot;https://en.wikipedia.org/wiki/Linear_interpolation&quot;&gt;linearly
interpolate&lt;/a&gt; between two
data points.&lt;/p&gt;

&lt;h2 id=&quot;what-is-a-linear-interpolator&quot;&gt;What is a Linear Interpolator&lt;/h2&gt;

&lt;p&gt;Linear interpolators are very similar to the child’s “dot-to-dot” method of
drawing, where a picture is given with numbered dots, and the child must
draw a line from one dot to the next.  The resulting waveform might look
very much like Fig 2 below.&lt;/p&gt;

&lt;table style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 4: Linear Upsampling&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/dot-to-dot.png&quot; alt=&quot;Linear Upsampling&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;If we now sample this waveform, using an upsampler, we should get the black
dots shown in Fig 5.&lt;/p&gt;

&lt;table style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 5: Linear Resampling&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/linear-up.png&quot; alt=&quot;Linear Resampler&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Or, if you have a higher oversampling rate (i.e. more green dots), it might
look like Fig 3 below:&lt;/p&gt;

&lt;table style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 6: Linear Resampling, lower frequency signal&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/hslinear-up.png&quot; alt=&quot;Figure of Linear Resampler applied to a lower frequency signal&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;At this point, you can see how our sampler starts to track the incoming signal
a lot better.&lt;/p&gt;

&lt;p&gt;The equation for a linear upsampler, one that generates a line between two
given sample points, is straightforward:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;n = floor(t/Ts);
y(t/Ts) = x[n] + (t/Ts-n)(x[n+1]-x[n]);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;where samples are spaced by &lt;code class=&quot;highlighter-rouge&quot;&gt;Ts&lt;/code&gt; seconds apart.&lt;/p&gt;

&lt;p&gt;To get a feel for this equation, consider what happens when &lt;code class=&quot;highlighter-rouge&quot;&gt;t=nTs&lt;/code&gt;.  In
that case, the linear term drops to zero and the result is &lt;code class=&quot;highlighter-rouge&quot;&gt;x[n]&lt;/code&gt;.  On the
other hand, if &lt;code class=&quot;highlighter-rouge&quot;&gt;t&lt;/code&gt; is infinitesimally less than &lt;code class=&quot;highlighter-rouge&quot;&gt;t=(n+1)Ts&lt;/code&gt;, then &lt;code class=&quot;highlighter-rouge&quot;&gt;t/Ts-n&lt;/code&gt;
will evaluate to &lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;y(t/Ts)&lt;/code&gt; will evaluate the &lt;code class=&quot;highlighter-rouge&quot;&gt;x[n+1]&lt;/code&gt;.  In other
words, this equation simply describes a series of line segments connecting
&lt;code class=&quot;highlighter-rouge&quot;&gt;x[n]&lt;/code&gt; to &lt;code class=&quot;highlighter-rouge&quot;&gt;x[n+1]&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The linear sampler we are going to build today will return the values
&lt;code class=&quot;highlighter-rouge&quot;&gt;y(kV/Ts)&lt;/code&gt;, for some new sample interval &lt;code class=&quot;highlighter-rouge&quot;&gt;V &amp;lt; Ts&lt;/code&gt;, just likes Figs 5 and 6 above
demonstrate.&lt;/p&gt;

&lt;p&gt;This leaves us with two challenges:  The first is evaluating the equation for
upsampling, and the second problem is figuring how how to do this evaluation
every &lt;code class=&quot;highlighter-rouge&quot;&gt;V&lt;/code&gt; seconds to produce an output.&lt;/p&gt;

&lt;h2 id=&quot;handling-the-incoming-clock&quot;&gt;Handling the incoming clock&lt;/h2&gt;

&lt;p&gt;The first step towards building this interpolator is to calculate &lt;code class=&quot;highlighter-rouge&quot;&gt;n&lt;/code&gt; and
&lt;code class=&quot;highlighter-rouge&quot;&gt;(k (V/Ts)-n)&lt;/code&gt;.  Well, not quite.  Practically, there is no need to know
&lt;code class=&quot;highlighter-rouge&quot;&gt;n&lt;/code&gt; itself.  Indeed, without an absolute time to reference everything to,
&lt;code class=&quot;highlighter-rouge&quot;&gt;n&lt;/code&gt; is quite arbitrary.  That leaves &lt;code class=&quot;highlighter-rouge&quot;&gt;k (V/Ts) -n&lt;/code&gt;.  Let’s call this number
&lt;code class=&quot;highlighter-rouge&quot;&gt;dt&lt;/code&gt; to facilitate our discussion.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;dt&lt;/code&gt; is a number whose value goes from zero to one, and then suddenly back
to zero again.&lt;br /&gt;
In other words, we can keep track of this number in a similar manner to the
way we kept track of the &lt;a href=&quot;/dsp/2017/06/15/no-pi-for-you.html&quot;&gt;phase of a sine
wave&lt;/a&gt; earlier.  To
do this, we’ll keep track of a number between 0 and 2^N-1, which is given by
&lt;code class=&quot;highlighter-rouge&quot;&gt;2^N dt&lt;/code&gt;.
To this number, on each clock, we’ll add &lt;code class=&quot;highlighter-rouge&quot;&gt;2^N(V/Ts)&lt;/code&gt; to it (rounded to the
nearest integer, of course).  Then, when this
number overflows &lt;code class=&quot;highlighter-rouge&quot;&gt;N&lt;/code&gt; bits, we’ll wait for the next sample (i.e. for &lt;code class=&quot;highlighter-rouge&quot;&gt;floor(t)&lt;/code&gt;
to go from &lt;code class=&quot;highlighter-rouge&quot;&gt;n&lt;/code&gt; to &lt;code class=&quot;highlighter-rouge&quot;&gt;n+1&lt;/code&gt;, before using the new phase.&lt;/p&gt;

&lt;p&gt;Let’s define a register, &lt;code class=&quot;highlighter-rouge&quot;&gt;i_counter&lt;/code&gt;, to hold the integer portion of this
number, &lt;code class=&quot;highlighter-rouge&quot;&gt;2^N dt&lt;/code&gt;.  You can make &lt;code class=&quot;highlighter-rouge&quot;&gt;N&lt;/code&gt; as big as you need to in order to make
this work.  Likewise, we’ll define &lt;code class=&quot;highlighter-rouge&quot;&gt;i_step&lt;/code&gt; to hold the delta 2^N(V/Ts).&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;i_step = 2^N (int)(V/Ts)&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Now, with these two values, we can calculate the offset from the top
of the last sample:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	pre_ce &amp;lt;= i_ce;

always @(posedge i_clk)
	if (i_ce)
		// r_ovfl will get set on any overflow
		{ r_ovfl, r_counter } &amp;lt;= r_counter + i_step;
	else if (!r_ovfl)
		{ r_ovfl, r_counter } &amp;lt;= r_counter + i_step;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Notice how, when any new sample arrives, we update our counter (and produce
an output).  Likewise, until the update overflows, we’ll keep updating the
counter and producing an output.&lt;/p&gt;

&lt;p&gt;This sounds confusing.&lt;/p&gt;

&lt;p&gt;Perhaps a picture might help.  See Fig 7 below.&lt;/p&gt;

&lt;table style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 7: Resampling clock&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/upsampling-clock.svg&quot; alt=&quot;Upsampling clock described&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;This figure shows incoming samples coming in at one sample every four
system clocks.  In this example, the output clocks take place every three
system clocks.  Hence, the output “clock” (really a logic pulse) must be
separated by 3/4 distance between input samples.  Let’s trace this distance
from the incoming clock from where the two are minimally aligned:
0, 3/4, (next input sample) 1/2,
(next input sample) 1/4, (next input sample) 0, and then it repeats.  One
trick to building this upsampler will be waiting for the next sample when
we need a next sample, or otherwise creating a new sample if we don’t need to
wait.  That’s what’s going on with &lt;code class=&quot;highlighter-rouge&quot;&gt;r_ovfl&lt;/code&gt; above.&lt;/p&gt;

&lt;p&gt;Fig 8 below shows another figure for you to consider.  In this case, each
incoming sample
takes 8 system clocks, and we want to upsample that amount to create an
output every 3 system clocks.  Feel free to work out the math, although
in the end it’s roughly the same as the previous math.&lt;/p&gt;

&lt;table style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 8: Higher rate upsampling&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/faster-upsampling-clock.svg&quot; alt=&quot;Higher rate upsampling clock described&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;h2 id=&quot;the-incoming-samples&quot;&gt;The Incoming Samples&lt;/h2&gt;

&lt;p&gt;When an incoming sample comes in, we’ll need to keep track of not only
&lt;code class=&quot;highlighter-rouge&quot;&gt;x[n]&lt;/code&gt;, but also the slope, &lt;code class=&quot;highlighter-rouge&quot;&gt;x[n+1]-x[n]&lt;/code&gt;, between our samples.  This
implies that within an FPGA, we’ll need to keep track of &lt;code class=&quot;highlighter-rouge&quot;&gt;x[n+1]&lt;/code&gt; as the
latest sample (&lt;code class=&quot;highlighter-rouge&quot;&gt;r_next&lt;/code&gt;), and set our “current” sample, &lt;code class=&quot;highlighter-rouge&quot;&gt;x[n]&lt;/code&gt;, to the last
value of &lt;code class=&quot;highlighter-rouge&quot;&gt;x[n+1]&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Indeed, this part is just that simple:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
if (i_ce)
begin
	r_next &amp;lt;= i_data;		// r_next = x[n+1]
	r_last &amp;lt;= r_next;		// r_last = x[n]
	r_slope &amp;lt;= i_data - r_next;	// r_slope = x[n+1] - x[n]
end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;We’re also going to need to know if an output value needs to be produced.
Remember from before how some input samples produced multiple outputs, while
others produced only a single output?
In the case of what we are up to, every sample moves us forward by a fraction
of the incoming sample.  Once the counter overflows, then it’s time for a new
incoming sample.  Between the time when the first sample shows up, and the
last sample gets produced, we’ll produce an output.&lt;/p&gt;

&lt;p&gt;Let’s capture the logic of when we’ll need to produce an output, and
keep it synchronized with our input logic (&lt;code class=&quot;highlighter-rouge&quot;&gt;r_next&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;r_last&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;r_slope&lt;/code&gt;, etc.)
above.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	r_ce &amp;lt;= ((pre_ce)||(!r_ovfl));&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h2 id=&quot;doing-the-multiply&quot;&gt;Doing the multiply&lt;/h2&gt;

&lt;p&gt;At this point we have our last input value, &lt;code class=&quot;highlighter-rouge&quot;&gt;r_last&lt;/code&gt;, and our slope &lt;code class=&quot;highlighter-rouge&quot;&gt;r_slope&lt;/code&gt;.
We also have our offset:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	if (r_ce)
		r_offset &amp;lt;= r_counter;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;From these two pieces of information, we should be able to create our
new output point:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;n&quot;&gt;output&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r_offset&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r_slope&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r_last&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The problem is that hardware multiplies are usually the most expensive and
time consuming operation on an FPGA and so they tend to define the overall
clock speed.  Hence, it can be difficult to multiply &lt;em&gt;and&lt;/em&gt; add in the same
clock.  Therefore, for this next clock, we’ll simply do the multiply and copy
&lt;code class=&quot;highlighter-rouge&quot;&gt;r_last&lt;/code&gt; for adding to the result on the next clock.&lt;/p&gt;

&lt;p&gt;We’ll also copy our last data value, &lt;code class=&quot;highlighter-rouge&quot;&gt;r_last&lt;/code&gt; so that it is available to
us on the next clock cycle.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(posedge i_clk)
	if (r_ce)
	begin
		x_base   &amp;lt;= r_last;	// x[n]
		x_offset &amp;lt;= r_slope * r_offset; // (t-n)*(x[n+1]-x[n])
	end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Our output from this stage will be valid any time our inputs are valid, or
more realistically any time we were intending to produce an output.  We’ll
push that timing signal forward for the next clock.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	x_ce &amp;lt;= r_ce;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h2 id=&quot;creating-the-final-result&quot;&gt;Creating the final result&lt;/h2&gt;

&lt;p&gt;Now that we have our last sample and the product of the slope times the
time delta, we can calculate an output by adding these two values together.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	if (x_ce)
		o_value &amp;lt;= x_base + x_offset;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;We can also create a signal letting us know when this result will be valid.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	o_ce &amp;lt;= x_ce;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;That’s the basics of the algorithm.  How hard can it be?&lt;/p&gt;

&lt;h2 id=&quot;the-missing-details&quot;&gt;The Missing Details&lt;/h2&gt;

&lt;p&gt;How hard can it be?  A &lt;em&gt;lot&lt;/em&gt; harder.  Indeed, I had to work with the code
for about two days before I eventually got it working.&lt;/p&gt;

&lt;p&gt;We’ll come back to this post, therefore, and discuss:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;/dsp/2017/07/21/bit-growth.html&quot;&gt;Bit growth&lt;/a&gt;: how adds and multiplies increase the number of bits in a value&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;How to &lt;a href=&quot;/dsp/2017/07/22/rounding.html&quot;&gt;drop bits&lt;/a&gt;.  In
other words, if you have 16-bit samples in, this
routine might give you 32-bit samples out … if you don’t drop some bits.
How exactly to do this, without creating artifacts, isn’t as simple as it
sounds.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;How to &lt;a href=&quot;/dsp/2017/07/24/dsp-debugging.html&quot;&gt;debug a DSP design&lt;/a&gt; (hint: you’ll want to use something like
&lt;a href=&quot;https://www.mathworks.com&quot;&gt;Matlab&lt;/a&gt; or (my OpenSource favorite)
&lt;a href=&quot;https://www.gnu.org&quot;&gt;GNU&lt;/a&gt; &lt;a href=&quot;https://www.gnu.org/software/octave&quot;&gt;Octave&lt;/a&gt;)&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;For now, hold your finger on this design.  We’ll come back to it.&lt;/p&gt;

</description>
        <pubDate>Wed, 19 Jul 2017 00:00:00 -0400</pubDate>
        <link>http://zipcpu.com/dsp/2017/07/19/linear-upsampling.html</link>
        <guid isPermaLink="true">http://zipcpu.com/dsp/2017/07/19/linear-upsampling.html</guid>
        
        
        <category>dsp</category>
        
      </item>
    
      <item>
        <title>Verilator doesn&#39;t find everything (today)</title>
        <description>&lt;p&gt;So, my thought from last week was that I might be able to post something about
using push-buttons on an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;,
and the problems they struggle with. 
Specifically, I wanted to discuss
&lt;a href=&quot;https://en.wikipedia.org/wiki/Switch#Contact_bounce&quot;&gt;bouncing&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The &lt;a href=&quot;https://github.com/ZipCPU/dbgbus&quot;&gt;debugging bus&lt;/a&gt;
&lt;a href=&quot;/blog/2017/06/29/sw-dbg-interface.html&quot;&gt;we just created&lt;/a&gt;
provides the perfect environment for evaluating button
&lt;a href=&quot;https://en.wikipedia.org/wiki/Switch#Contact_bounce&quot;&gt;bouncing&lt;/a&gt;,
and so I started to put a post together on the topic.  But … I
wanted to add something more on the topic beyond what I had read of this
phenomena.  I wanted to add scope/traces of signals
&lt;a href=&quot;https://en.wikipedia.org/wiki/Switch#Contact_bounce&quot;&gt;bouncing&lt;/a&gt;,
and even share the code so that anyone could download it and try it and see
how their own development board responded when a button was pressed.&lt;/p&gt;

&lt;p&gt;Sounds neat, right?&lt;/p&gt;

&lt;p&gt;But doing this required I run the debugging
&lt;a href=&quot;https://github.com/ZipCPU/dbgbus/blob/master/bench/rtl/testbus.v&quot;&gt;test bus&lt;/a&gt;
(with modifications for catching
&lt;a href=&quot;https://en.wikipedia.org/wiki/Switch#Contact_bounce&quot;&gt;bouncing&lt;/a&gt;
components), on my hardware.  In this case, I was going to use the &lt;a href=&quot;http://store.digilentinc.com/arty-artix-7-fpga-development-board-for-makers-and-hobbyists&quot;&gt;Digilent
Arty&lt;/a&gt;,
for a demonstration,
although the test should run on any
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;,
with a UART and I may try out some
others to see if the button performance I am getting is any different.&lt;/p&gt;

&lt;p&gt;My first surprise came when I tried building the new/modified project
using Vivado: I was quickly reminded that things that work with
&lt;a href=&quot;https://www.veripool.org/wiki/verilator&quot;&gt;Verilator&lt;/a&gt;
may not always always work with your build tools.&lt;/p&gt;

&lt;h2 id=&quot;what-was-different&quot;&gt;What was different&lt;/h2&gt;

&lt;p&gt;I found a couple differences between
&lt;a href=&quot;https://www.veripool.org/wiki/verilator&quot;&gt;Verilator&lt;/a&gt; and Vivado this week:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://www.veripool.org/wiki/verilator&quot;&gt;Verilator&lt;/a&gt;
doesn’t detect when a wire (or register) is being set in multiple places.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://www.veripool.org/wiki/verilator&quot;&gt;Verilator&lt;/a&gt;
can’t always tell the difference between wires and registers.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;I am aware of a third difference as well: in Xilinx, all unspecified flip
flops start initially with a value of &lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt;. 
&lt;a href=&quot;https://www.veripool.org/wiki/verilator&quot;&gt;Verilator&lt;/a&gt;
starts with what appears to be random values.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Given that &lt;a href=&quot;https://www.veripool.org/wiki/verilator&quot;&gt;Verilator&lt;/a&gt; is an open
source project, and that posts on the web (like this one) seem to live forever,
these differences may be gone by the time you read this post.&lt;/p&gt;

&lt;p&gt;I’ve since &lt;a href=&quot;https://github.com/ZipCPU/dbgbus/commits/master&quot;&gt;updated&lt;/a&gt; the
&lt;a href=&quot;https://github.com/ZipCPU/dbgbus&quot;&gt;debugging bus project&lt;/a&gt; with these changes,
so that it now works.  I also found a bug or two in the software support.  Those
have also been changed, and so the whole now works on real hardware (i.e., on
my &lt;a href=&quot;http://store.digilentinc.com/arty-artix-7-fpga-development-board-for-makers-and-hobbyists&quot;&gt;Digilent
Arty&lt;/a&gt;).&lt;/p&gt;

&lt;p&gt;If you’d like to see the changes, please feel free to browse the project’s
&lt;a href=&quot;https://github.com/ZipCPU/dbgbus/commits/master&quot;&gt;GitHub log&lt;/a&gt;.
There you’ll find a set of six changes that were made to the debugging bus
in order to get it to synthesize and work.&lt;/p&gt;

&lt;h2 id=&quot;i-still-love-verilator&quot;&gt;I still love Verilator&lt;/h2&gt;

&lt;p&gt;These differences aren’t deterring me from using
&lt;a href=&quot;https://www.veripool.org/wiki/verilator&quot;&gt;Verilator&lt;/a&gt;.
How could they?
&lt;a href=&quot;https://www.veripool.org/wiki/verilator&quot;&gt;Verilator&lt;/a&gt;
still finds most of the bugs in any design in the time it takes Vivado
to &lt;em&gt;start&lt;/em&gt; synthesizing my code.  It can also find bugs that Vivado doesn’t
find (bus width mis-match, for example).  So I still love
&lt;a href=&quot;https://www.veripool.org/wiki/verilator&quot;&gt;Verilator&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;My point is that, as of today, it doesn’t find everything.  Things that work in
&lt;a href=&quot;https://www.veripool.org/wiki/verilator&quot;&gt;Verilator&lt;/a&gt;
will &lt;em&gt;usually&lt;/em&gt; work in your hardware, but not always.&lt;/p&gt;

&lt;p&gt;But … that’s one of the purposes of a
&lt;a href=&quot;blog/2017/06/08/simple-scope.html&quot;&gt;logic scope&lt;/a&gt;, right? 
Such a scope will help you debug what’s going on within your design when the
simulation and the hardware don’t act the same.&lt;/p&gt;

</description>
        <pubDate>Mon, 17 Jul 2017 00:00:00 -0400</pubDate>
        <link>http://zipcpu.com/blog/2017/07/17/debugging-dbgbus.html</link>
        <guid isPermaLink="true">http://zipcpu.com/blog/2017/07/17/debugging-dbgbus.html</guid>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>Design Needs when Debugging a SoftCore CPU</title>
        <description>&lt;p&gt;Building your own &lt;a href=&quot;https://en.wikipedia.org/wiki/Soft_microprocessor&quot;&gt;soft
core&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt; within an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
can be a tremendous learning experience.  Doing so will provide you with an
in-depth insight into how a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;
works that may be difficult to come by otherwise.&lt;/p&gt;

&lt;p&gt;As you consider the requirements of the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;
you would like to build, let
me also recommend that you consider what it will take to debug your
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt; early
on.  It might keep you from rebuilding parts and pieces of your
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt; later.&lt;/p&gt;

&lt;p&gt;Sure, there’s component testing to make sure the components of the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt; work,
but what will it take to actually debug the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;–in
both hardware &lt;em&gt;and&lt;/em&gt; software?&lt;/p&gt;

&lt;p&gt;Let’s look at this from two different standpoints.  First, what do you need
to debug a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;
in general, and specifically what operations will your debugger
need to be able to perform.  Second, what are the different contexts that you
will need in order to debug your
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;?&lt;/p&gt;

&lt;h2 id=&quot;debugging-needs&quot;&gt;Debugging needs&lt;/h2&gt;

&lt;p&gt;If you’ve ever used a debugger, the debugger typically offers you several things
you can do with your program.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Reboot&lt;/strong&gt;:  You can start or restart the program.  On an embedded
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt; that
doesn’t support multiple independent programs, this may mean issuing a
command to reboot
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Step&lt;/strong&gt;: The
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;
will then either start, or start in a stopped state.
While in this stopped state, you should be able to step your
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;
forward through its instructions.&lt;/p&gt;

    &lt;p&gt;This often means something different depending upon context.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Stop on Breakpoint&lt;/strong&gt;: Stepping through a long list of instructions,
such as a bootloader loading a program from ROM into RAM, before you get to
the logic you actually want to debug can be a real drag.  For this reason,
debuggers offer the capability to set and clear breakpoints within your
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;.&lt;/p&gt;

    &lt;p&gt;The idea is basically this: once a breakpoint is set, the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;
can be let loose to run.  When the CPU hits the breakpoint, it will halt
and bring up the debugger for you to examine where it is at.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Examine CPU State&lt;/strong&gt;: Any time the CPU, or the program the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt; is running,
is stopped, the user should then be able to examine the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;’s state.  This
may mean examining the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Processor_register&quot;&gt;registers&lt;/a&gt;
of a register based
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;,
or the stack of a &lt;a href=&quot;https://en.wikipedia.org/wiki/Stack_machine&quot;&gt;stack
based CPU&lt;/a&gt;—perhaps even both.&lt;/p&gt;

    &lt;p&gt;For example, on the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;,
the assembly level debugger brings up a view of all 32
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Processor_register&quot;&gt;registers&lt;/a&gt;,
and the current instruction sequence (See Figs 1 or 2 below).  One of the
two debugging views (Fig 2) also shows
a couple variables on the top of the stack as well.&lt;/p&gt;

    &lt;p&gt;When evaluating the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;
within simulation, you’ll also want to see internal
variables that aren’t typically considered an “official” part of the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;
state, but yet form a part of the state that you need in order to debug it.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Continue&lt;/strong&gt;: If you’ve stopped the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;,
you’ll also want the ability to
restart it after you’ve examined what is going on within the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Trace&lt;/strong&gt;: This isn’t normally a considered a debugger capability, and
probably won’t find this support within your typical debugger,
yet being able to get a trace of what’s going on within your
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;.
is an important part of fault diagnosis.&lt;/p&gt;

    &lt;p&gt;Creating a trace file on a fault is actually my only method of debugging the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;
when dealing with an interrupt context, simply because it can be &lt;em&gt;so&lt;/em&gt;
difficult to predict when an interrupt takes place, or to stop and examine
the &lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;
on that interrupt along the way.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Your debugging support will need at least one more item of support, and that
item isn’t really a debugging &lt;em&gt;operation&lt;/em&gt;.  Specifically, you’ll want some
way of reading the source code your
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;
is running as you debug your program.  Currently, the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
has disassembly support and not source level support.
The reason is simply this: it’s easier to build an assembly level debugger
than it is to build a source level debugger.&lt;/p&gt;

&lt;p&gt;These are the things I’ve found useful when trying to debug the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Keep in mind, this is by no means a comprehensive list of all the tools you
might want or need to debug your
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;.
However, you might find it to be a
sufficient list to get you started–particularly because certain items on
this list will require hardware support, and you may want to think about
this support early in your
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;.
design phase.&lt;/p&gt;

&lt;h2 id=&quot;debugging-contexts&quot;&gt;Debugging Contexts&lt;/h2&gt;

&lt;p&gt;From my own experience, I have found that there are three separate contexts
for debugging a computer program on a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;.  The
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
supports two of these contexts, and I have plans to support the third.&lt;/p&gt;

&lt;p&gt;These are listed below:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Simulator&lt;/strong&gt;: The first context you will want to debug your
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt; within
is within a simulator.  Sure, the simulator isn’t nearly as fast as the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;,
but within a simulator your debugger should be able to access the
values of &lt;em&gt;every&lt;/em&gt; internal variable within your design.&lt;/p&gt;

    &lt;table style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 1: Debugging ZipCPU under Verilator&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/zipdbg-simtest.png&quot; alt=&quot;The ZipCPU debugger under Verilator&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

    &lt;p&gt;The problem I struggled with is that there are only so many characters on the
screen.  As a result, some of the items on the screen tend to be somewhat
cryptic.  For example, consider the “PFCACH: v=0000007f” item below
the user registers.  This tells me that the seven lowest number instruction
&lt;a href=&quot;https://en.wikipedia.org/wiki/Cache_(computing)&quot;&gt;cache&lt;/a&gt;
lines are valid.  Cryptic, right?&lt;/p&gt;

    &lt;p&gt;Still, even through this view is somewhat cryptic, each item on the screen
was useful to me (at some time) to learn and know what was going on within
the &lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;.
In particular, these many items were really easy to add to the
screen when I needed them.&lt;/p&gt;

    &lt;p&gt;In spite of the cryptic information within the screen, you can still see
all of the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
registers: sR0 throught sPC, and uR0 through uPC.  You can
also see the instructions each of the various stages are working on,
as well as the fact that each stage is being clocked (Ck on the left).&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Hardware&lt;/strong&gt;: Once you place
your &lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;
initially onto a piece of hardware, you’ll want access to the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;
to debug it.  This means that you want to be
able to support all of your typical debugging actions, enumerated in the
last section, yet you’ll want to be able to invoke those operations from
an external computer connected to your
&lt;a href=&quot;https://en.wikipedia.org/wiki/Soft_microprocessor&quot;&gt;soft-core&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;.&lt;/p&gt;

    &lt;p&gt;Remember the &lt;a href=&quot;https://github.com/ZipCPU/dbgbus&quot;&gt;debugging bus&lt;/a&gt; we put
together?  I use a similar &lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/rtl/wbubus.v&quot;&gt;debugging
bus&lt;/a&gt; to debug the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;.&lt;/p&gt;

    &lt;p&gt;Of course, some things of necessity will change when you debug things in
hardware.  Two examples will prove this point: First, you are not likely to
have access to every wire within your design  when you wish to examine your
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;
state.  For this reason, the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; debugger,
&lt;a href=&quot;https://github.com/ZipCPU/openarty/blob/master/sw/zipdbg.cpp&quot;&gt;zipdbg&lt;/a&gt;,
provides access to all 32-registers within the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;,
but not all that much more.  Second, your peripherals may not take well to
stepping them by individual clock ticks.  Hence memory interactions may
need to be stepped through, one interaction at a time.  For the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;,
this has meant that the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;
can only step by single instructions, rather
than by individual clock ticks, when debugging the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt; within the
hardware.&lt;/p&gt;

    &lt;table style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 2: Debugging ZipCPU on the Arty&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/zipdbg-arty-cputest.png&quot; alt=&quot;The ZipCPU debugger under Verilator&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Software&lt;/strong&gt;: What I mean by the &lt;em&gt;Software&lt;/em&gt; context is that of a debugger,
such as &lt;a href=&quot;https://www.gnu.org/software/dbg/&quot;&gt;gdb&lt;/a&gt;, running natively from
software within your
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;
and applied to debugging another process running on your
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;.&lt;/p&gt;

    &lt;p&gt;While this might take some work to build, it’s worth considering when you
design your processor whether or not you want your processor to eventually
support this type of capability.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;One thing that will throw a thorn in all of these context’s, though, is that
you may struggle to know what is happening on or within your
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt; when it
responds to an interrupt.  Sure, there’s a way to deal with this, but
interrupts can make debugging via either hardware or software less than
truly realistic.  This is where the capability of creating a full-speed
trace becomes important.&lt;/p&gt;

&lt;h2 id=&quot;all-together&quot;&gt;All together&lt;/h2&gt;

&lt;p&gt;To wrap this up, Figure 3 (below) places these ideas in a conceptual
graphic, to help draw this discussion to memory.  Notice that all of the
operations we’ve discussed are shown on the left, and the three separate
contexts are shown across the top.&lt;/p&gt;

&lt;table style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 3: Debugging Operations and Contexts&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/cpu-dbg-needs.svg&quot; alt=&quot;Types of CPU Debugger Support&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;One thing the chart doesn’t show is that the columns (contexts) aren’t totally
independent.  Before you leave your simulator debugging context, you’ll want
to make sure that you have proven that your hardware debugging interface works
within the simulator.  Likewise, before you move from the hardware debugging
context to work on software debugging, you’ll want to double check, via either
the hardware or simulator contexts, that the support you’ve placed within your
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;
for software debugging actually works.&lt;/p&gt;

&lt;p&gt;Perhaps I should mention that this is not my first attempt at putting this
post together.  On my first attempt, I tried to describe how to perform
&lt;em&gt;every&lt;/em&gt; one of the operations in &lt;em&gt;every&lt;/em&gt; one of the contexts shown in Fig 3.
The result was too much information for a single post.  For now, just realize
that there’s a different story behind each box on the chart, each choice of
context and operation.&lt;/p&gt;

</description>
        <pubDate>Fri, 14 Jul 2017 00:00:00 -0400</pubDate>
        <link>http://zipcpu.com/zipcpu/2017/07/14/cpu-debugging-needs.html</link>
        <guid isPermaLink="true">http://zipcpu.com/zipcpu/2017/07/14/cpu-debugging-needs.html</guid>
        
        
        <category>zipcpu</category>
        
      </item>
    
      <item>
        <title>The simplest sine wave generator within an FPGA</title>
        <description>&lt;p&gt;Ever need a sine wave when working within an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;?  When
you see the solution to this problem presented below, you may never use a
canned digital synthesizer again.&lt;/p&gt;

&lt;h2 id=&quot;digital-oscillator-phase&quot;&gt;Digital Oscillator phase&lt;/h2&gt;

&lt;p&gt;The first step to building this synthesizer is creating the phase input
for the sine wave you wish to create.&lt;/p&gt;

&lt;p&gt;We’ve already discussed the ideal units for phase within an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
&lt;a href=&quot;/dsp/2017/06/15/no-pi-for-you.html&quot;&gt;here&lt;/a&gt;.
Basically, you’ll want to keep track of phase in a digital unit that
naturally wraps at your word width, N.  (We’ll arbitrarily choose to use
&lt;code class=&quot;highlighter-rouge&quot;&gt;N=32&lt;/code&gt; for our examples below.)  To convert from radians to these digital
units, simply multiple by 2^N and divide by 2PI.  Likewise to convert from
degrees to these digital units, multiple by 2^N and divide by 360.&lt;/p&gt;

&lt;p&gt;Frequency in a digital synthesis system is nothing more than a
change in phase.  Hence, a phase can change by a small delta on
every clock cycle to create the frequency you need.  Something
like the following will work well.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;reg [31:0]	phase;
// The initial value is usually irrelevant
always @(posedge clock)
	// Allow for an D/A running at a lower speed from your FPGA
	if (sample_clock_ce)
		phase &amp;lt;= phase + frequency_step;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This assumes you have a signal (&lt;code class=&quot;highlighter-rouge&quot;&gt;sample_clock_ce&lt;/code&gt;) that is &lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt; anytime the DAC
needs an output, and &lt;code class=&quot;highlighter-rouge&quot;&gt;0&lt;/code&gt; otherwise.  This will allow you to work with
slower signal rates than your system clock rate if necessary.  You can
also just set the &lt;code class=&quot;highlighter-rouge&quot;&gt;sample_clock_ce&lt;/code&gt;
value to a constant &lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt; in order process samples at your
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;’s
clock rate.&lt;/p&gt;

&lt;p&gt;The right frequency step will depend upon your sample clock rate.
Note, this rate may be slower than your
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;’s
system clock rate.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;frequency_step = 2^N * frequency_hz / sample_clock_rate_hz&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;To make certain we have the formula right, consider a frequency which is
at the Nyquist sample rate of one half of your sample clock rate.  This
frequency should take two steps to wrap back to where it came from.
Looking at the frequency step above, in this case the frequency step would
become &lt;code class=&quot;highlighter-rouge&quot;&gt;2^(N-1)&lt;/code&gt; and two steps (&lt;code class=&quot;highlighter-rouge&quot;&gt;2*frequency_step&lt;/code&gt;) would indeed wrap back
around.  Smaller steps should naturally represent lower frequencies.&lt;/p&gt;

&lt;p&gt;Let’s assume a 100MHz sample clock rate for the sake of discussion.&lt;/p&gt;

&lt;p&gt;If you choose to represent both phase and frequency step with &lt;code class=&quot;highlighter-rouge&quot;&gt;N=32&lt;/code&gt; bits,
you can represent any frequency between zero and your sample clock rate
divided by two, with a precision given by:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;frequency_precision_hz = sample_clock_rate_hz / 2^N&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This is nothing more than solving for the frequency associated with the
difference between two steps.  Equivalently, this is the frequency associated
with a step of one, or the smallest frequency that this approach can generate.&lt;/p&gt;

&lt;p&gt;If our system has a 100MHz sample rate clock, a 32-bit frequency step would
allow us to represent &lt;em&gt;any&lt;/em&gt; frequency between zero and 50MHz in steps of
about 0.02 Hz.&lt;/p&gt;

&lt;p&gt;Not bad, but how about generating a sine wave from this phase?&lt;/p&gt;

&lt;h2 id=&quot;the-no-more-logic-solution&quot;&gt;The “No more logic” Solution&lt;/h2&gt;

&lt;p&gt;Since I offered this post as the “Simplest Sine Wave Generator”, I feel
compelled to provide the following solution:&lt;/p&gt;

&lt;p&gt;If you don’t want to use any more logic than your phase generator requires,
then just output the top bit of the phase accumulator.  That’ll give you a
square wave at the frequency you want — with 0.02Hz precision.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;assign	sinewave = phase[31];&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;As this isn’t really much of a sine wave, but rather a square wave, let’s
continue looking for a better alternative.&lt;/p&gt;

&lt;h2 id=&quot;digital-oscillator-frequency-output&quot;&gt;Digital Oscillator frequency output&lt;/h2&gt;

&lt;p&gt;Now that we know the phase of our outgoing digital oscillator, it’s time
to generate the sine wave itself.  Since an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
offers free lookup tables, let’s use them to generate our sine wave.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge clock)
	if (sample_clock_ce)
		sinewave &amp;lt;= sinewave_table[phase[31:24];&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Notice that we only used the top 8-bits from the phase.  This keeps our logic
simple, while still giving you the full 0.02 Hz resolution we had above.  While
we could use an 8-bit phase accumulator alone, that would’ve only given us
frequency steps in the 400kHz range.&lt;/p&gt;

&lt;p&gt;What happens with the 32-bit phase is that eventually the upper 8-bits will
repeat or skip steps as necessary to provide the frequency resolution you want.&lt;/p&gt;

&lt;p&gt;Gosh, that was so easy, we could end this post right there.  The task is done!&lt;/p&gt;

&lt;p&gt;Before leaving the topic, though, let’s examine two more items: First, let’s
look at the mechanics of setting the sinewave table above, and second let’s
make some rough estimates as to the cost and performance of the synthesizer.&lt;/p&gt;

&lt;h2 id=&quot;how-to-set-the-table&quot;&gt;How to set the table?&lt;/h2&gt;

&lt;p&gt;Since all of the logic is captured within that sinewave table, perhaps we
should spend some time working out how to set the values of the table.
In general, there are three basic approaches for setting the values of the
table.  All three are roughly equivalent in the functionality they will use.&lt;/p&gt;

&lt;p&gt;The first approach is to build a giant case statement:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge clock)
if (sample_clock_ce)
	case(phase[31:24])
	8&#39;h00:  sinewave &amp;lt;= 7&#39;h00;
	8&#39;h01:  sinewave &amp;lt;= 7&#39;h01;
	8&#39;h02:  sinewave &amp;lt;= 7&#39;h03;
	...
	8&#39;h40:  sinewave &amp;lt;= 7&#39;h3f;
	...
	8&#39;h80:  sinewave &amp;lt;= 7&#39;h00;
	...
	8&#39;hc0:  sinewave &amp;lt;= 7&#39;h41;
	...
	8&#39;hfe:  sinewave &amp;lt;= 7&#39;h7d;
	8&#39;hff:  sinewave &amp;lt;= 7&#39;h7f;
	endcase&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The synthesizer will turn the logic from this case statement into the table
lookup implementation we want.&lt;/p&gt;

&lt;p&gt;The second approach would be to use an actual table read-only register
array, and to set all of the values of the table with individual values
of the sine wave as we want it.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;reg	[6:0]	table [0:255];

initial table[0] = 7&#39;h00;
initial table[1] = 7&#39;h01;
initial table[2] = 7&#39;h03;
initial table[3] = 7&#39;h04;
initial table[4] = 7&#39;h06;
// etc.&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This approach, though, get’s old &lt;em&gt;really&lt;/em&gt; fast–especially if you are building
it by hand.  A better approach is to use $readmemh.  (Be aware, in my
experience Xilinx’s ISE can’t handle $readmemh.)&lt;/p&gt;

&lt;p&gt;Using $readmemh, you’ll create a hexadecimal text file first.  In our case,
it would probably look something like:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;@00000000 00 01 03 04 06 07 09 0a 0c 0d 0f 10 12 13 15 16 
@00000010 18 19 1a 1c 1d 1f 20 21 23 24 25 26 27 29 2a 2b 
@00000020 2c 2d 2e 2f 30 31 32 33 34 35 36 36 37 38 38 39 
@00000030 3a 3a 3b 3b 3c 3c 3d 3d 3d 3e 3e 3e 3e 3e 3e 3e 
@00000040 3f 3e 3e 3e 3e 3e 3e 3e 3d 3d 3d 3c 3c 3b 3b 3a 
@00000050 3a 39 38 38 37 36 36 35 34 33 32 31 30 2f 2e 2d 
@00000060 2c 2b 2a 29 27 26 25 24 23 21 20 1f 1d 1c 1a 19 
@00000070 18 16 15 13 12 10 0f 0d 0c 0a 09 07 06 04 03 01 
@00000080 00 7f 7d 7c 7a 79 77 76 74 73 71 70 6e 6d 6b 6a 
@00000090 68 67 66 64 63 61 60 5f 5d 5c 5b 5a 59 57 56 55 
@000000a0 54 53 52 51 50 4f 4e 4d 4c 4b 4a 4a 49 48 48 47 
@000000b0 46 46 45 45 44 44 43 43 43 42 42 42 42 42 42 42 
@000000c0 41 42 42 42 42 42 42 42 43 43 43 44 44 45 45 46 
@000000d0 46 47 48 48 49 4a 4a 4b 4c 4d 4e 4f 50 51 52 53 
@000000e0 54 55 56 57 59 5a 5b 5c 5d 5f 60 61 63 64 66 67 
@000000f0 68 6a 6b 6d 6e 70 71 73 74 76 77 79 7a 7c 7d 7f &lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The first part of the line indicates where in the array the coming values
will be placed, whereas the rest of the line consists of values to be placed
in the array separated by spaces.&lt;/p&gt;

&lt;p&gt;Then, to use this approach, you’ll need one more line within your
Verilog code to read and set your array:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;initial $readmemh(&quot;table.hex&quot;, table);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;where &lt;code class=&quot;highlighter-rouge&quot;&gt;table.hex&lt;/code&gt; is the name of your hexadecimal text file.&lt;/p&gt;

&lt;p&gt;Given that you are trying to make a sine wave, and that a sine is a rather
complex function, you might want to create this table via a C++ program
instead of by hand (I did).  Just remember: the maximum sine wave value needs
to be +/- 63 since it’s the maximum 7-bit value that has an identical positive
and negative integer value.&lt;/p&gt;

&lt;h2 id=&quot;estimating-the-cost-of-the-synthesizer&quot;&gt;Estimating the Cost of the Synthesizer&lt;/h2&gt;

&lt;p&gt;While we’re essentially done here, having presented how to generate a quick
and simple sine wave, let’s spend another moment or too looking at how many
table entries we want (32, 64, 128, or 256), as well as how many bits wide
the elements in the table should be.&lt;/p&gt;

&lt;p&gt;In general, this will cost us one look up table per output bit in for each
output sample our sinewave.
However, on the Xilinx architecture, two output bits can share a 6-LUT if
they share the same 5-bit inputs.  Likewise it takes two 6-LUTs to look up
a seven bit value, and four 6-LUTs to look up an 8-bit value. 
&lt;a href=&quot;/blog/2017/06/12/minimizing-luts.html&quot;&gt;[Ref]&lt;/a&gt; Let’s examine
the two ends of these possibilities therefore.&lt;/p&gt;

&lt;p&gt;If we were to use 5-bit lookup tables, we’d have only &lt;code class=&quot;highlighter-rouge&quot;&gt;2^5=32&lt;/code&gt; entries to the 
sine wave table.  A table size of 32 would allow us to divide the unit circle
up into steps separated by &lt;code class=&quot;highlighter-rouge&quot;&gt;11 degrees&lt;/code&gt;.
This means that your sinewave would jump by at most &lt;code class=&quot;highlighter-rouge&quot;&gt;0.195&lt;/code&gt; in value from one
phase to the next.  Representing something with this level of precision only
takes about 4 bits, so this lookup would cost two 6-LUTs total.&lt;/p&gt;

&lt;p&gt;That’s pretty cheap.  The 32-bit phase update logic would likely cost more
LUTs (16) than that.&lt;/p&gt;

&lt;p&gt;At the other end of the spectrum, suppose we wanted to use 8-bits of phase.
We’d then be able to represent things at &lt;code class=&quot;highlighter-rouge&quot;&gt;360/2^8=1.4 degree&lt;/code&gt; intervals.  The
biggest jump in the sine wave would be about &lt;code class=&quot;highlighter-rouge&quot;&gt;0.024&lt;/code&gt; units. Representing such
a number with that level of precision could easily be done with 7 bits. 
Hence, this approach would cost &lt;code class=&quot;highlighter-rouge&quot;&gt;28 6-LUTs&lt;/code&gt;.  That’s still pretty cheap,
although now it costs more than phase calculation.&lt;/p&gt;

&lt;h2 id=&quot;better-approaches-are-available&quot;&gt;Better Approaches are Available&lt;/h2&gt;

&lt;p&gt;Our focus today has been on what it takes to generate a &lt;em&gt;really&lt;/em&gt; cheap and
simple sine wave within an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;.
At &lt;code class=&quot;highlighter-rouge&quot;&gt;28 LUTs&lt;/code&gt; for the synthesizer and &lt;code class=&quot;highlighter-rouge&quot;&gt;16 LUTs&lt;/code&gt; to track phase, I think we did
just that.&lt;/p&gt;

&lt;p&gt;However, if you want to generate a higher quality sine wave, then you
might wish to switch from a simple table look up to a
&lt;a href=&quot;http://www.andraka.com/files/crdcsrvy.pdf&quot;&gt;CORDIC approach&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Perhaps we should come back and discuss that approach later?
&lt;a href=&quot;http://www.andraka.com/files/crdcsrvy.pdf&quot;&gt;CORDIC&lt;/a&gt;’s
aren’t that hard to build, and they make an excellent lesson for the
beginner in how to design
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
based algorithms.&lt;/p&gt;

</description>
        <pubDate>Tue, 11 Jul 2017 00:00:00 -0400</pubDate>
        <link>http://zipcpu.com/dsp/2017/07/11/simplest-sinewave-generator.html</link>
        <guid isPermaLink="true">http://zipcpu.com/dsp/2017/07/11/simplest-sinewave-generator.html</guid>
        
        
        <category>dsp</category>
        
      </item>
    
      <item>
        <title>Getting Started with the Wishbone Scope</title>
        <description>&lt;p&gt;Ever found yourself stuck with an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
design that didn’t work and no idea why not?  This seems to be a &lt;a href=&quot;/fpga-hell.html&quot;&gt;common
problem&lt;/a&gt; within
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
design.  Perhaps
the design works within a simulator.  Perhaps you don’t know how to simulate
the hardware component the design is working with.  Either way, you will
want to know how to somehow draw information out of the broken design to
see where it fails.&lt;/p&gt;

&lt;p&gt;We’ll show an example of how to do that here, using two primary components to
make this happen.  The first is any device or simulation imeplementing a
generic &lt;a href=&quot;https://github.com/ZipCPU/dbgbus/blob/master/sw/devbus.h&quot;&gt;DEVBUS&lt;/a&gt;
interface into a wishbone bus implemneted within your
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;.
If you don’t have such an interface as part of your design, the
&lt;a href=&quot;https://github.com/ZipCPU/dbgbus/tree/master/hexbus&quot;&gt;HEXBUS&lt;/a&gt;
interface should still suite your purposes nicely, although it will require
a serial port to communicate on.  The second necessary component is a
&lt;a href=&quot;https://github.com/ZipCPU/wbscope&quot;&gt;wishbone scope&lt;/a&gt;, which you can access
using the &lt;a href=&quot;https://github.com/ZipCPU/dbgbus/blob/master/sw/devbus.h&quot;&gt;DEVBUS&lt;/a&gt;
interface.&lt;/p&gt;

&lt;p&gt;There are two parts required to adding a
&lt;a href=&quot;https://github.com/ZipCPU/wbscope&quot;&gt;wishbone scope&lt;/a&gt; into your design, the 
&lt;a href=&quot;/blog/2017/06/22/simple-wb-interconnect.html&quot;&gt;Verilog
integration&lt;/a&gt;
and the &lt;a href=&quot;https://github.com/ZipCPU/dbgbus/blob/master/sw/memscope.cpp&quot;&gt;software
component&lt;/a&gt;.
The first part is to connect the scope to your design: both by selecting
wires from within your design that you wish to examine, as well as identifying
trigger logic within your design to know when to capture those wires.
(The block RAM used to capture a trace isn’t unlimited.)
The second part is the logic necessary to read that capture off of the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;,
and format it into a &lt;a href=&quot;https://en.wikipedia.org/wiki/Value_change_dump&quot;&gt;VCD file&lt;/a&gt;
that you can use to view your data on a clock for clock basis using
&lt;a href=&quot;http://gtkwave.sourceforge.net&quot;&gt;gtkwave&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;We’ll walk through the two steps separately, and then show an example
of using them to view a bus interaction.&lt;/p&gt;

&lt;h2 id=&quot;changes-to-your-design&quot;&gt;Changes to your design&lt;/h2&gt;

&lt;p&gt;There are only four basic changes to your design that you’ll need to make in
order to connect a
&lt;a href=&quot;https://github.com/ZipCPU/wbscope&quot;&gt;wishbone scope&lt;/a&gt; into your
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt; design.&lt;/p&gt;

&lt;p&gt;First, you’ll need to add the scope to your &lt;a href=&quot;https://github.com/ZipCPU/dbgbus/blob/master/bench/rtl/testbus.v&quot;&gt;wishbone
interconnect&lt;/a&gt;
within your design.  This involves six basic points of adjustment:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;You’ll need to decode the scope’s address.  I like to create an address
select line (not to be confused with the byte SELect linse), indicating
that the current address references the scope.  Make sure that ADDR[0]
is not a part of this computation, as the scope needs that line to
determine which internal register is being accessed.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;You’ll need to add the scope to the design, and wire the wishbone inputs
to the scope.  The STB line from the wishbone master needs to be gated
(anded) with the address select logic result.  The scope requires only
one ADDR bit, so no others need to be connected.  The wishbone outputs:
ACK, STALL, and DATA will be declared and connected.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The ACK line needs to be logically OR’d with other ACK lines within your
design.  This logic should already exist, if you have a working wishbone
interconnect, so follow along there and see what’s required.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;As with the ACK, the DATA line needs to be integrated into the bus
data return.  In particular, the bus data return to the master should
contain the scope’s data anytime time the scope’s ACK line is true.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Because the
&lt;a href=&quot;https://github.com/ZipCPU/wbscope&quot;&gt;wishbone scope&lt;/a&gt; will never stall the
bus, you can technically
ignore the STALL line.  For form and maintainability, though, you’ll
probably want to use this line to create the wishbone master’s STALL
return line.  This is usually created by a large OR of every device’s
address decode line AND’ed with their STALL line.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;I often use a touch of logic to determine whether or not many ACK’s are
begin returned at once, if more than one device is selected, or if no
devices are selected.  This logic will need to be adjusted as well.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;If you are going to use the scope that already exists within the
&lt;a href=&quot;https://github.com/ZipCPU/dbgbus/blob/master/rtl/testbus.v&quot;&gt;DBGBUS&lt;/a&gt;’s
test infrastructure, all of this logic has already been taken care of for you.
For more details, we also discussed how to do this in &lt;a href=&quot;/blog/06/22/simple-wb-interconnect.html&quot;&gt;the article on building
a simple wishbone
interconnect&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The second step is deciding what you wish to trigger on.  This is as simple
a piece of logic as you wish.  Within the
&lt;a href=&quot;https://github.com/ZipCPU/dbgbus/blob/master/rtl/testbus.v&quot;&gt;DBGBUS&lt;/a&gt;’s
implementation, you’ll find a line that looks like:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;assign scope_trigger = (mem_sel)&amp;amp;&amp;amp;(wb_stb);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This triggers the scope on any attempt to reference the block RAM peripheral
within the testbus, although what you choose to trigger on is up to you.
Want to trigger on any time the wishbone error is set as an example?  The
following logic would do that:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;assign scope_trigger = (wb_err);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;We’ll stick to the former, though.&lt;/p&gt;

&lt;p&gt;Third, you’ll want to select those wires that you want to capture and
record.  These wires can be anything you are interested in within your design.
In our case, we’re going to capture some signals from within the
wishbone bus’s interaction.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;assign	debug_data = { wb_cyc, wb_stb, wb_we, wb_ack, wb_stall,
		wb_addr[5:0], 1&#39;b1,
		wb_odata[9:0],
		wb_idata[9:0] };&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The &lt;a href=&quot;https://github.com/ZipCPU/wbscope&quot;&gt;wishbone scope&lt;/a&gt;
fixes this amount of debug data at 32-bits per clock, otherwise we might have
grabbed more of this bus interaction.  If you need more, you should be able to
using multiple &lt;a href=&quot;https://github.com/ZipCPU/wbscope&quot;&gt;scopes&lt;/a&gt;
at the same time to achieve a wider capture.&lt;/p&gt;

&lt;p&gt;As a final step, you can limit the
&lt;a href=&quot;https://github.com/ZipCPU/wbscope&quot;&gt;scope&lt;/a&gt; so that it only captures data any
time a particular bit is true within your design.  This capability is very
useful for digital signal processing applications, where the data of interest
may not exist on every clock.  This is the &lt;code class=&quot;highlighter-rouge&quot;&gt;i_ce&lt;/code&gt; input to the scope. 
For this simple example, we’ll keep this set to ‘1’.&lt;/p&gt;

&lt;p&gt;While we aren’t going to reconfigure the basic
&lt;a href=&quot;https://github.com/ZipCPU/wbscope&quot;&gt;wishbone scope&lt;/a&gt; for this example, there
are several configuration parameters that can be set.  These parameters
include:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;The log of the size of the memory within the scope, LGMEM.  By default, this
is set to 10, so by default the scope will use 2^10 words of block RAM.
Powers of two from anywhere between 2^2 and 2^31 are possible–with the
natural consequence being that your actual
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
hardware will limit how memory you can actually use.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Whether or not the scope is synchronous with your wishbone clock or not.
This is the SYNCHRONOUS flag.  It defaults to true (&lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt;).  If you ever need
to collect data on one clock and read it on another, then set this to
zero.  That will trigger the inclusion of a lot of clock transfer logic
within the design.&lt;/p&gt;

    &lt;p&gt;For our design, we’ll leave this at the default as a synchronous scope,
but that will also require the same &lt;code class=&quot;highlighter-rouge&quot;&gt;i_clk&lt;/code&gt; parameter being passed to the
core twice.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The default holdoff parameter sets the initial holdoff of the scope. 
This holdoff parameter may be changed at a later time by simply writing the
new holdoff to the control register.  Setting it within a parameter just
sets the initial value of the holdoff register.&lt;/p&gt;

    &lt;p&gt;If the holdoff is set to zero, the trigger will be aligned with the last
data sample in the scope’s memory.  As the holdoff time is increased,
the trigger location will move towards the beginning of the scope’s memory.&lt;/p&gt;

    &lt;p&gt;As another way to put it, once triggered, the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
waits for a number of
clocks given by the holdoff value before stopping its collect.  Hence, a
holdoff of zero can be used to capture any logic leading up to an event,
whereas a holdoff of the size of the buffer will capture any logic
immediately following an event.&lt;/p&gt;

    &lt;p&gt;The default parameter value for the default holdoff places the trigger
near the middle of the collect.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;That’s it!  That’s all you need to do to set up a
&lt;a href=&quot;https://github.com/ZipCPU/wbscope&quot;&gt;wishbone scope&lt;/a&gt; within the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
part of your design.&lt;/p&gt;

&lt;h2 id=&quot;the-software-controller&quot;&gt;The software controller&lt;/h2&gt;

&lt;p&gt;To use the &lt;a href=&quot;https://github.com/ZipCPU/wbscope&quot;&gt;Wishbone scope&lt;/a&gt;, you’ll also
want to set up a software controller to handle the communication between the
design, and to reformat the result into whatever you wish it to be.
This is the purpose of the
&lt;a href=&quot;https://github.com/ZipCPU/wbscope&quot;&gt;scope&lt;/a&gt;
software controller.  It is also specific to the logic you’ve chosen to
capture, so this section will show you how to set it up.&lt;/p&gt;

&lt;p&gt;When I initially used the &lt;a href=&quot;https://github.com/ZipCPU/wbscope&quot;&gt;Wishbone scope&lt;/a&gt;
in my earlier projects, all the scope controller ever did was to check that
the scope had indeed been triggered, and then dump every piece of data that
had been collected to the terminal.&lt;/p&gt;

&lt;p&gt;At one time, I wrote a new software controller every time I needed a scope
within my design.  If you wander through my designs, you can even find
examples of these older scope controllers, such as &lt;a href=&quot;https://github.com/ZipCPU/xulalx25soc/blob/master/sw/ramscope.cpp&quot;&gt;this
example&lt;/a&gt;
 that I used when debugging an &lt;a href=&quot;https://github.com/ZipCPU/xulalx25soc/blob/master/rtl/wbsdram.v&quot;&gt;SDRAM
controller&lt;/a&gt;.
These controller’s, though, all had the same logic:&lt;/p&gt;

&lt;p&gt;Step one: Check if the scope is ready to be read, and exit if not.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m_fpga&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;readio&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;R_SCOPE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mh&quot;&gt;0x60000000&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x60000000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Scope is not yet ready&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;exit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Step two: Calculate the size of the scope and allocate a buffer&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;n&quot;&gt;lglen&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;20&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x01f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;scoplen&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lgln&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;buf&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;DEVBUS&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;BUSW&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;scoplen&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Step three: Read the scope’s memory from the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;,
transferring it from the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
to a buffer on your local computer.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;n&quot;&gt;m_fpga&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;readz&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;R_SCOPD&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;scoplen&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;buf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Step four: Decode the scope’s data&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;scoplen&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;// Do something to printf buf[i] to the screen
&lt;/span&gt;	&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;After a while, though, I found myself cut/copy and pasting the same code
from one controller to the next. 
Just the code above created a &lt;em&gt;lot&lt;/em&gt; of boilerplate.&lt;/p&gt;

&lt;p&gt;To help get reduce the amount of boilerplate code, the scope now has a
&lt;a href=&quot;https://github.com/ZipCPU/wbscope/blob/master/sw/scopecls.cpp&quot;&gt;controller scope
class&lt;/a&gt;.
Since building that &lt;a href=&quot;https://github.com/ZipCPU/wbscope/blob/master/sw/scopecls.cpp&quot;&gt;scope control
class&lt;/a&gt;,
the scope’s capabilities have
significantly increased.  For example, the scope controller can now
create a &lt;a href=&quot;https://en.wikipedia.org/wiki/Value_change_dump&quot;&gt;VCD file&lt;/a&gt;.
It can now identify which sample produced the trigger
(thanks to some &lt;a href=&quot;https://github.com/ZipCPU/wbscope/blob/master/bench/cpp/wbscope_tb.cpp&quot;&gt;bench
testing&lt;/a&gt;, and so it can place the inferred
trigger into the &lt;a href=&quot;https://en.wikipedia.org/wiki/Value_change_dump&quot;&gt;VCD file&lt;/a&gt;
as well.  So let’s instead discuss how to interact with this &lt;a href=&quot;https://github.com/ZipCPU/wbscope/blob/master/sw/scopecls.cpp&quot;&gt;scope controller
object&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The first step to using this
&lt;a href=&quot;https://github.com/ZipCPU/wbscope/blob/master/sw/scopecls.cpp&quot;&gt;controller&lt;/a&gt;.
framework is to create your own
subclass of the
&lt;a href=&quot;https://github.com/ZipCPU/wbscope/blob/master/sw/scopecls.cpp&quot;&gt;controller&lt;/a&gt;.
to desccibe your particular wire choices within your RTL logic.&lt;/p&gt;

&lt;p&gt;For the example we are working with, we’ll call this controller subclass a
&lt;a href=&quot;https://github.com/ZipCPU/dbgbus/blob/master/sw/memscope.cpp&quot;&gt;MEMSCOPE&lt;/a&gt;–since
it’s going to look at interactions with the block RAM memory.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt;	&lt;span class=&quot;nc&quot;&gt;MEMSCOPE&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SCOPE&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;MEMSCOPE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;FPGA&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fpga&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;addr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SCOPE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fpga&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;addr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{};&lt;/span&gt;
	&lt;span class=&quot;o&quot;&gt;~&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;MEMSCOPE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The scope object is created with a pointer to the FPGA object implementing the
&lt;a href=&quot;https://github.com/ZipCPU/dbgbus/blob/master/sw/devbus.h&quot;&gt;DEVBUS&lt;/a&gt;
interface, together with the address of where this scope is within
our wishbone bus.&lt;/p&gt;

&lt;p&gt;Two virtual methods then need to be overloaded.  The first method, called
decode(), simply decodes the scope wires onto stdout.  This is where the
printf() interface I used to use ends up.  The difference, though, is that
the &lt;a href=&quot;https://github.com/ZipCPU/wbscope/blob/master/sw/scopecls.cpp&quot;&gt;class&lt;/a&gt;
takes care of reading from the &lt;a href=&quot;https://github.com/ZipCPU/wbscope&quot;&gt;scope&lt;/a&gt;,
calculating the memory
address, as well as marking where the trigger is.  To make this work,
be careful not to end any of the printf()’s within your decode function
with a newline.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;k&quot;&gt;virtual&lt;/span&gt;	&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;MEMSCOPE&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;decode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;DEVBUS&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;BUSW&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;val&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;cyc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stb&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;we&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ack&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stall&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;addr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;odata&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;idata&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

	&lt;span class=&quot;n&quot;&gt;cyc&lt;/span&gt;   &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;31&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;stb&lt;/span&gt;   &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;30&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;we&lt;/span&gt;    &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;29&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;ack&lt;/span&gt;   &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;28&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;stall&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;27&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;addr&lt;/span&gt;  &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;21&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;mh&quot;&gt;0x3f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;odata&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;mh&quot;&gt;0x3ff&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;idata&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;val&lt;/span&gt;      &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;mh&quot;&gt;0x3ff&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

	&lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;%s&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cyc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;?&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;CYC&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;   &quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot; %s&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;stb&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;?&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;STB&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;   &quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot; %s&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;we&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;?&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;W&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;R&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;[@....%02x]...%03x-&amp;gt;...%03x&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;addr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;odata&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;idata&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot; %s&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ack&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;?&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;ACK&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;   &quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot; %s&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;stall&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;?&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;(STALL)&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;       &quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The second method that needs to be overloaded is the define_traces() method.
This is where the connection is made between your design and the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Value_change_dump&quot;&gt;VCD file&lt;/a&gt;
the
&lt;a href=&quot;https://github.com/ZipCPU/wbscope/blob/master/sw/scopecls.cpp&quot;&gt;scope object&lt;/a&gt;
can generate.  To make this possible, the
&lt;a href=&quot;https://github.com/ZipCPU/wbscope/blob/master/sw/scopecls.cpp&quot;&gt;scope object&lt;/a&gt;
offers a register_trace() function.  register_trace() takes three arguments.
The first is the name of the wire or trace that’s being defined.
The second argument specifies how many bits the trace has of the 32 the
scope has captured.   The third and final argument
specifies which bit position this value starts at.
Hence, we can define all of our traces with a simple:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;k&quot;&gt;virtual&lt;/span&gt;	&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;MEMSCOPE&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;define_traces&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;register_trace&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;wb_cyc&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;    &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;31&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;register_trace&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;wb_stb&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;    &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;30&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;register_trace&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;wb_we&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;     &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;29&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;register_trace&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;wb_ack&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;    &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;28&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;register_trace&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;wb_stall&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;  &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;27&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;register_trace&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;wb_addr&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;   &lt;span class=&quot;mi&quot;&gt;6&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;21&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;register_trace&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;wb_odata&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;register_trace&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;wb_idata&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;  &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;All that remains is to create and run this &lt;a href=&quot;https://github.com/ZipCPU/dbgbus/blob/master/sw/memscope.cpp&quot;&gt;scope
controller&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Creating it is simple, after connecting to your
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
and creating an object supporting the
&lt;a href=&quot;https://github.com/ZipCPU/dbgbus/blob/master/sw/devbus.h&quot;&gt;DEVBUS interface&lt;/a&gt;,
you can just create the new scope from a pointer to the
&lt;a href=&quot;https://github.com/ZipCPU/dbgbus/blob/master/sw/devbus.h&quot;&gt;DEVBUS&lt;/a&gt;
and the &lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
address of &lt;a href=&quot;https://github.com/ZipCPU/wbscope&quot;&gt;the scope&lt;/a&gt;:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;n&quot;&gt;MEMSCOPE&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;scope&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MEMSCOPE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_fpga&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;R_SCOPE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;You can check whether or not
&lt;a href=&quot;https://github.com/ZipCPU/wbscope&quot;&gt;the scope&lt;/a&gt;
is ready to be read with a simple&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;scope&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ready&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Scope is not yet ready:&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Otherwise we’ll simply print our results, and write out a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Value_change_dump&quot;&gt;VCD file&lt;/a&gt;:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;scope&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;

	&lt;span class=&quot;n&quot;&gt;scope&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;writevcd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;scopd.vcd&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;That’s it!  That’s all the software required to use
&lt;a href=&quot;https://github.com/ZipCPU/wbscope&quot;&gt;the Wishbone scope&lt;/a&gt;
and to capture and output a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Value_change_dump&quot;&gt;VCD file&lt;/a&gt;
containing the scope information.&lt;/p&gt;

&lt;h2 id=&quot;trying-it-out&quot;&gt;Trying it out&lt;/h2&gt;

&lt;p&gt;Let’s use this with the
&lt;a href=&quot;https://github.com/ZipCPU/dbgbus&quot;&gt;debugging bus interface&lt;/a&gt; &lt;a href=&quot;https://github.com/ZipCPU/dbgbus/blob/master/bench/rtl/testbus.v&quot;&gt;example
design&lt;/a&gt;,
and show how we can pull the data we need out of the design.&lt;/p&gt;

&lt;p&gt;You’ll first need to build the example design.  To do this, you’ll need to
have &lt;a href=&quot;https://gcc.gnu.org&quot;&gt;g++&lt;/a&gt;,
&lt;a href=&quot;https://www.veripool.org/wiki/verilator&quot;&gt;Verilator&lt;/a&gt;,
&lt;a href=&quot;https://git-scm.com&quot;&gt;git&lt;/a&gt;, and
&lt;a href=&quot;http://gtkwave.sourceforge.net&quot;&gt;GTKWave&lt;/a&gt; installed.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;git clone https://github.com/ZipCPU/dbgbus
&lt;span class=&quot;nb&quot;&gt;cd &lt;/span&gt;dbgbus
make&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;We’ll demonstrate grabbing
&lt;a href=&quot;https://github.com/ZipCPU/wbscope&quot;&gt;the scope&lt;/a&gt;’s
output while running the
&lt;a href=&quot;https://www.veripool.org/wiki/verilator&quot;&gt;Verilator&lt;/a&gt;,
simulation, although you could use this with your
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
just as well.
Indeed, if your
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
is connected to the TCP/IP port that our
&lt;a href=&quot;https://www.veripool.org/wiki/verilator&quot;&gt;Verilator&lt;/a&gt;,
simulation is using, then you can interact with your
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
with no changes.
The first step will be to start the simulation in one window:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span class=&quot;nb&quot;&gt;cd &lt;/span&gt;bench/cpp
./testbus_tb&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Were you trying to do this on an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;,
you’d instead use the
&lt;a href=&quot;https://github.com/ZipCPU/dbgbus/blob/master/sw/netuart.cpp&quot;&gt;netuart&lt;/a&gt;
program to bridge a serial port on your FPGA to the TCP/IP port that our
&lt;a href=&quot;https://github.com/ZipCPU/dbgbus/blob/master/sw/devbus.h&quot;&gt;DEVBUS&lt;/a&gt;
software interface will interact with.&lt;/p&gt;

&lt;p&gt;Either way, your next step will be to move to another window and interact
with your &lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;.
If you are using the &lt;a href=&quot;https://github.com/ZipCPU/dbgbus/blob/master/bench/rtl/testbus.v&quot;&gt;DBGBUS
demo&lt;/a&gt;,
you’ll need to either read or write from the memory to trigger the scope:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span class=&quot;nb&quot;&gt;cd &lt;/span&gt;sw/
./wbregs mem 0xdeadbeef&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Now that the scope has finished its collection (even in simulation it’s
pretty quick from trigger to stop), let’s use our &lt;a href=&quot;https://github.com/ZipCPU/dbgbus/blob/master/sw/memscope.cpp&quot;&gt;scope
controller&lt;/a&gt;
to grab the result:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;./memscope&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This will take a couple of moments to read the data from the simulation.
(It’s a lot faster when using real hardware.)  On my computer it can take
close to a full minute, but that might be very CPU dependent.&lt;/p&gt;

&lt;p&gt;The result, though, will be a file &lt;code class=&quot;highlighter-rouge&quot;&gt;scopd.vcd&lt;/code&gt;.  To examine this, just type&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;gtkwave scopd.vcd&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;With a little work with gtkwave, here’s what our results look like:&lt;/p&gt;

&lt;table style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 1: Example Output using MEMSCOPE&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/memscope.png&quot; alt=&quot;Example Scope Output&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;h2 id=&quot;thats-it&quot;&gt;That’s it!&lt;/h2&gt;

&lt;p&gt;Did you see how easy that was?  The only hard part was
&lt;a href=&quot;/blog/2017/06/05/wb-bridge-overview.html&quot;&gt;building the means to communicate between the FPGA and your host
PC&lt;/a&gt;.  After that,
all that you really needed to do was to add the
&lt;a href=&quot;https://github.com/ZipCPU/wbscope&quot;&gt;wishbone scope&lt;/a&gt;
component to the wishbone bus within your design, and then define the traces
you wanted to follow in your subclass of the &lt;a href=&quot;https://github.com/ZipCPU/wbscope/blob/master/sw/scopecls.cpp&quot;&gt;software scope
controller&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Stick around, though.  &lt;a href=&quot;/about/gisselquist-technology.html&quot;&gt;Gisselquist
Technology&lt;/a&gt; is working
on a simpler way to connect your wishbone device components together using
&lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;autofpga&lt;/a&gt;.&lt;/p&gt;

</description>
        <pubDate>Sat, 08 Jul 2017 00:00:00 -0400</pubDate>
        <link>http://zipcpu.com/blog/2017/07/08/getting-started-with-wbscope.html</link>
        <guid isPermaLink="true">http://zipcpu.com/blog/2017/07/08/getting-started-with-wbscope.html</guid>
        
        
        <category>blog</category>
        
      </item>
    
  </channel>
</rss>
