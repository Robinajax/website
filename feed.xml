<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>The ZipCPU by Gisselquist Technology</title>
    <description>The ZipCPU blog, featuring how to discussions of FPGA and CPU design. This site will be focused on Verilog solutions, using exclusively OpenSource IP products for FPGA design.
</description>
    <link>http://zipcpu.com/</link>
    <atom:link href="http://zipcpu.com/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Fri, 02 Jun 2017 17:38:52 -0400</pubDate>
    <lastBuildDate>Fri, 02 Jun 2017 17:38:52 -0400</lastBuildDate>
    <generator>Jekyll v3.0.1</generator>
    
      <item>
        <title>Controlling Timing within an FPGA</title>
        <description>&lt;p&gt;Within an FPGA, everything is based upon event based timing.  SPI controllers
require a logic generated clock, I2C controllers have some maximum limit they
can communicate at, UART controllers run at some user defined baud rate …
everything wants to communicate at a carefully controlled speed.&lt;/p&gt;

&lt;p&gt;Here we’ll discuss a couple ways to create the timing you need.&lt;/p&gt;

&lt;h2 id=&quot;the-power-of-two-clock-divider&quot;&gt;The Power of Two Clock Divider&lt;/h2&gt;

&lt;p&gt;The first approach I will use to timing events is usually a clock divider.
It’s just too simple and too easy to build to ignore.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;reg	[(N-1):0]	counter;
always @(posedge i_clk)
	counter &amp;lt;= counter + 1&#39;b1;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Using this approach, your clock will be nicely divided by an even 2^N.
Hence, if you attach an LED to &lt;strong&gt;counter[(N-1)]&lt;/strong&gt; you’ll have the slower clock
you need.&lt;/p&gt;

&lt;h2 id=&quot;the-simple-clock-divider&quot;&gt;The Simple Clock Divider&lt;/h2&gt;

&lt;p&gt;A very common beginners task is to create a 1kHz, 100Hz, or even a 10 Hz clock
from your input clock.  Since these are not the result of dividing your clock
by 2^N, a different approach is necessary.&lt;/p&gt;

&lt;p&gt;Suppose for example that your system clock were at 100MHz.  You’d then need to
divide it by 10M if you wanted to get a 10Hz clock.  This is easily done with
a more generic clock divider circuit.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;reg	[(N-1):0]	counter;
always @(posedge i_clk)
	if (counter &amp;lt; THRESHOLD-1&#39;b1)
		counter &amp;lt;= counter + 1&#39;b1;
	else
		counter &amp;lt;= 0;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;As before, you can then use &lt;strong&gt;counter[N-1]&lt;/strong&gt; as an LED driver, and you will
have divided your clock by whatever value you set THRESHOLD to be.&lt;/p&gt;

&lt;h2 id=&quot;the-strobe-signal&quot;&gt;The Strobe Signal&lt;/h2&gt;

&lt;p&gt;The problem with the simple clock dividers above is that the clock signal is N
bits wide, and the top bit may be one for many clocks and zero for many clocks.
How shall you make your logic work only once in all those clocks?&lt;/p&gt;

&lt;p&gt;As a first rule, &lt;em&gt;do not drive your logic like this&lt;/em&gt;:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge counter[N-1])
	begin
		// DON&#39;T DO THIS
	end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This will cause you all kinds of grief, either leading you to an unreliable
design, or forcing you to deal with multiple clock domains, clock domain
transfers, and worse.  Unless you really know what you are doing … don’t
use this approach.&lt;/p&gt;

&lt;p&gt;When I first started building FPGA designs, I would check for zero within
whatever state machine logic I had that was going to rely upon my new clock.
As a result, I tended to use something like this instead:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	if (counter == 0)
	begin
		// Don&#39;t do this
	end else if (some_other_condition)
	begin
		// Other logic goes here
	end else if ...&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;My problem was that I then needed to come back later and rebuild all this
logic.  While it worked, it required more LUTs than was actually necessary, and
it couldn’t be clocked at any high speed.&lt;/p&gt;

&lt;p&gt;So … don’t do it this way either.&lt;/p&gt;

&lt;p&gt;One way to understand the problem with this approach is to count the cost of
your logic.  This cost may be estimated by
the number of inputs necessary to create any of your logic registers. 
The larger the number of inputs, the more LUTs will be required to implement
it, the slower the logic will take.  Having
an N-bit wide clock driving a lot of logic just adds N-1 unnecessary bits to
complicate things.  As a result, while this approach will work (and did for me
for many years), it’ll only work for FPGA logic with a slow &lt;strong&gt;i_clk&lt;/strong&gt;
frequency.&lt;/p&gt;

&lt;p&gt;The better alternative is even simpler, and there’s no reason not to use it.&lt;/p&gt;

&lt;p&gt;Instead of testing for (counter == 0) within your logic, create a
strobe signal.  We’ll call our strobe signal &lt;strong&gt;ck_stb&lt;/strong&gt;:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	ck_stb &amp;lt;= (counter == THRESHOLD-1&#39;b1);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;What makes this signal so useful is that it will only ever be on for one clock
period at a time, and that one clock period will be the period that you need to
do something.  As a result, you will then only need to check whether or not
&lt;strong&gt;ck_stb&lt;/strong&gt; is true whenever you need to do something, rather than all
&lt;strong&gt;N&lt;/strong&gt; bits of &lt;strong&gt;counter&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;The next step is to build your logic so that it transitions on this strobe:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	if (ck_stb)
	begin
		// Build your logic this way instead
	end else if (some_other_condition)
	begin
	end else if ...&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;You can find an example of this within my &lt;a href=&quot;https://github.com/ZipCPU/wbuart32/tree/master/rtl&quot;&gt;WBUART cores&lt;/a&gt;.  Look for the variables &lt;strong&gt;baud_counter&lt;/strong&gt;
and &lt;strong&gt;zero_baud_counter&lt;/strong&gt; within either the transmitter or receiver
modules.&lt;/p&gt;

&lt;h2 id=&quot;the-fractional-clock-divider&quot;&gt;The Fractional Clock Divider&lt;/h2&gt;

&lt;p&gt;What if you need to divide your clock by 3.1415926535…?  Not a problem.
You can accomplish this using a fractional clock divider.  The result will
look something like:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;reg	[15:0]	counter;
always @(posedge i_clk)
	{ ck_stb, counter } &amp;lt;= counter + 16&#39;h517d;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Ok, so … there’s a couple pieces to doing this that are worth discussing in order to understand it.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;How does this work?  Well, consider what happens after 2^16 clocks … you’ll have 16’h517d transitions.  Hence, you’ve divided your clock by 16’h517d or &lt;em&gt;about&lt;/em&gt; by pi.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The &lt;strong&gt;ck_stb&lt;/strong&gt; signal will be set anytime this counter rolls over.  Because &lt;strong&gt;ck_stb&lt;/strong&gt; isn’t used to calculate the next counter, but only used as the output of this equation, &lt;strong&gt;ck_stb&lt;/strong&gt; becomes a logic signal you can use to drive your logic at the rate you want.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Notice that this clock register is 16 bits wide rather than N-bits wide.  Because of how the clock width couples with the fractional division number, I had to make this width a constant instead of a generic.  You can still change it to whatever you need it to be.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;As for the 16’h517d, this number is given by 2^16 divided by PI.  Where does the 16 come from?  It’s the width of your counter.  Does it need to be 16?  The more bits you have, the closer you’ll get to the actual frequency you wish to create.  I’ve often used 48-bits within my &lt;a href=&quot;https://github.com/ZipCPU/rtcclock&quot;&gt;Real-Time Clock Core&lt;/a&gt;, but what you choose should be a matter of your design needs and choices.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;You can also use the &lt;strong&gt;ck_stb&lt;/strong&gt; signal within your code to do things every 1/pi’th clock, just like we used the &lt;strong&gt;ck_stb&lt;/strong&gt; before.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;What if you need to generate an actual clock signal, and not just a clocked strobe?  You can use the top bit of this counter as a clock signal that you can send to peripherals if you need to.  Just … don’t use it as a clock signal within your own logic unless you really know what you are doing.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;What is the actual clock period of this clock?  Well, because we are dividing by PI, you will find either three or four ticks between &lt;strong&gt;ck_stb&lt;/strong&gt; signals, never more, never less.  This is going to create some &lt;em&gt;phase noise&lt;/em&gt; in your &lt;em&gt;clock&lt;/em&gt;.  It can cause problems with some systems, so make sure you check the spec of whatever system you might be working with in order to know what is acceptable.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;You can find a simple example of this fractional divider in &lt;a href=&quot;https://github.com/ZipCPU/icozip/blob/master/rtl/basic/clktest.v&quot;&gt;this version of
blinky&lt;/a&gt; for
the &lt;a href=&quot;http://icoboard.org&quot;&gt;ICO board&lt;/a&gt;.  I used this code to test and measure the
speed of the input clock to my &lt;a href=&quot;http://icoboard.org&quot;&gt;ICO board&lt;/a&gt;.  By using
this approach, I was able to prove that the incoming clock was 100MHz, as
opposed to the 25MHz oscillator listed in the schematic (Oops!).&lt;/p&gt;

&lt;p&gt;As a fun example, I used this same fractional clock generator approach to
create a &lt;a href=&quot;https://github.com/ZipCPU/wbfmtxhack&quot;&gt;single bit FM signal&lt;/a&gt; that I
then “transmitted” out of my GPIO ports.  Sure, it was an ugly signal, but it
was enough to lock a FM receiver to it and listen to Queen on “the radio”.&lt;/p&gt;

&lt;h2 id=&quot;the-divided-counter&quot;&gt;The Divided Counter&lt;/h2&gt;

&lt;p&gt;If your counter is so long that you can’t meet timing, there’s usually no cost
to splitting the counter into a higher word and a lower word:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;reg	low_stb, ck_stb;
reg	[(N-1):0]	low_counter, hi_counter;
always @(posedge i_clk)
	{ low_stb, low_counter } &amp;lt;= low_counter + 1&#39;b1;
always @(posedge i_clk)
	if (low_stb)
		{ ck_stb, counter } &amp;lt;= counter + 1&#39;b1;
	else
		ck_stb &amp;lt;= 1&#39;b0;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Sure, the two words may not be synchronized, but … this is still a very
doable approach.&lt;/p&gt;

&lt;h2 id=&quot;the-divided-fractional-clock-divider&quot;&gt;The Divided Fractional Clock Divider&lt;/h2&gt;

&lt;p&gt;What if you are using a fractional divider?  If you can’t meet timing with your fractional division clock, you can also divide that one into two words, both upper and lower:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;reg	[(N-1):0]	low_counter, hi_counter;
always @(posedge i_clk)
	{ low_pps, low_counter } &amp;lt;= low_counter + LOW_STEP;
always @(posedge i_clk)
	{ ck_stb, counter } &amp;lt;= counter + HIGH_STEP + low_pps;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;As before, the two counters are not in lock step with each other.  If you want to actually have a synchronized timer, you might need to delay the lower counter ‘till they line up:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;reg	[(N-1):0]	low_counter, hi_counter, dly_counter;
wire	[(2\*N-1):0]	full_counter;
always @(posedge i_clk)
	{ low_pps, low_counter } &amp;lt;= low_counter + LOW_STEP;
always @(posedge i_clk)
	dly_counter &amp;lt;= low_counter;
always @(posedge i_clk)
	{ ck_stb, counter } &amp;lt;= counter + HIGH_STEP + low_pps;
assign	full_counter = { counter, dly_counter };&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;As you can see from the many different examples above, dividing your input clock down to a rate that you can then use for your logic is fairly easy.  Given the many ways of doing this wrong, we have now at least showed you several methods for doing this “right”.&lt;/p&gt;

&lt;p&gt;Try it!  Let me know how these techniques work for you.&lt;/p&gt;
</description>
        <pubDate>Fri, 02 Jun 2017 00:00:00 -0400</pubDate>
        <link>http://zipcpu.com/blog/2017/06/02/generating-timing.html</link>
        <guid isPermaLink="true">http://zipcpu.com/blog/2017/06/02/generating-timing.html</guid>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>The Actual FPGA Design Process</title>
        <description>&lt;p&gt;As I’ve been watching students and others request help on the &lt;a href=&quot;https://forum.digilentinc.com&quot;&gt;Digilent
Forums&lt;/a&gt;, it has become apparent to me that
there’s quite a difference between the design process college students are using
and the one reality has driven me to.&lt;/p&gt;

&lt;p&gt;Perhaps pointing this out will serve as a warning to the young FPGA engineer
to start their task early, and to not underestimate the amount of work
required.&lt;/p&gt;

&lt;h2 id=&quot;the-students-fpga-design-process&quot;&gt;The Student’s FPGA Design Process&lt;/h2&gt;

&lt;p&gt;Most of the student’s I’ve seen on the forum show up about a week before
their project is due.  They want to get things done quickly, and they want
to take the fastest path they can take to get to the goal. 
Indeed, they are following the design process shown in Fig. 1.&lt;/p&gt;

&lt;table style=&quot;float: right&quot;&gt;&lt;caption&gt;Figure 1: The Student&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/student-design-process.svg&quot; alt=&quot;Student FPGA Design Process Figure&quot; width=&quot;140&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;ol&gt;
  &lt;li&gt;The student builds his design in Verilog&lt;/li&gt;
  &lt;li&gt;He then implements it on an FPGA, adjusting his design as necessary to meet
timing and build requirements&lt;/li&gt;
  &lt;li&gt;The design is then placed onto the FPGA for a test, and …&lt;/li&gt;
  &lt;li&gt;The student can’t figure out why it isn’t working.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Perhaps these students are coming from the software world.  When I program
software, I can usually debug a program using the “debug by printf” method.
If things get difficult, moving to the debugger is easy.  Either way, at any
point in my program, I can look at and examine any variable at any time and
understand what is going on within it.&lt;/p&gt;

&lt;p&gt;If you expect to do this with hardware, and particularly with FPGA’s, you are
going to end up with the other students in your class at the end of the semester
wondering what happened.  You just don’t get that much visibility into an FPGA
design.&lt;/p&gt;

&lt;p&gt;Plan for it.&lt;/p&gt;

&lt;h2 id=&quot;the-experts-design-process&quot;&gt;The Expert’s Design Process&lt;/h2&gt;

&lt;p&gt;Now, if you instead turn around and ask an expert about their design process,
they will discuss something like Fig. 2 with you.&lt;/p&gt;

&lt;table style=&quot;float: right&quot;&gt;&lt;caption&gt;Figure 2: The Expert&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img width=&quot;240&quot; src=&quot;/img/expert-design-process.svg&quot; alt=&quot;The Expert&#39;s FPGA Design Process Figure&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;If you don’t have an instructor, you have to find the specifications for
whatever chip you are going to work with.  This applies to both the FPGA’s
you work with, as well as any peripherals.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Once you think you understand how the device you wish to interface with
works, you’ll build your design to interface with that device.&lt;/p&gt;

    &lt;p&gt;I make
a particular point at this stage in my design process to document, at the
top of any Verilog files I build, how that Verilog file is going to connect
to the rest of any design.  While all of my files tend to use the
&lt;a href=&quot;http://opencores.org/opencores,wishbone&quot;&gt;Wishbone Bus&lt;/a&gt;,
I still need to define the various registers on that bus, as well
as what each of the bits within those registers means, whether the registers
are read/write, etc.&lt;/p&gt;

    &lt;p&gt;As I build my design, these become my notes and
reference.  I keep them up to date–especially before any spec sheet is ever
written.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The next step is to build a simulator for the device.  This will allow your
simulated logic to think it is talking to the actual device.&lt;/p&gt;

    &lt;p&gt;Have I skipped this step before?  Absolutely!  What was the result?  I’ve
almost always had to come back, retrace my steps, and build this simulator.
(I’m currently needing to do that with an HDMI interface I’m building.)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Once you have your logic, and a simulator in place, you can now build a test
bench that will exercise your logic against the simulator and see whether
or not your logic works.&lt;/p&gt;

    &lt;p&gt;Have I skipped this step before?  You bet!  The result?  I just got burned
this last week.&lt;/p&gt;

    &lt;p&gt;The story has to do with a &lt;a href=&quot;http://opencores.org/project,qspiflash&quot;&gt;flash
controller&lt;/a&gt; I had built.
I was recently trying to squeeze every last LUT out of my
&lt;a href=&quot;https://github.com/ZipCPU/s6soc&quot;&gt;S6SoC design&lt;/a&gt;, and
made changes to it.  I then changed it in another design, and again, and
eventually I had four different flash controllers and couldn’t tell which
worked and which didn’t.  I needed a test bench to prove that my changes
still left me with a working controller.&lt;/p&gt;

    &lt;p&gt;I had no choice, but to backtrack and build the test bench I should’ve built
in the first place.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Only after things work on the test bench, will the expert place them onto
the FPGA.  Changes made in this process (usually because something just
doesn’t quite meet timing) will still be validated through the
simulator and the test bench.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Then the expert applies his design for its first Hardware in the Loop (HITL)
test.  If the hardware he’s working with doesn’t match his simulation,
he goes back and adjusts the simulation, his design, and the test bench.&lt;/p&gt;

    &lt;p&gt;If I can, I like to use the same software for bench testing as I do for
hardware in the loop testing.  While this is not always possible, it can be
used to save a step … if you can.  That’s actually the reason why I like
to use a &lt;a href=&quot;https://github.com/ZipCPU/openarty/blob/master/sw/host/netuart.cpp&quot;&gt;TCP/IP
connection&lt;/a&gt; to connect to my boards–because you can never
tell, then, whether you are connecting to the real thing or a simulation.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Only after any design passes unit testing, is it fully integrated with the
rest of whatever the expert wishes to do.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Finally, the entire unit is tested as a whole.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The expert will also firmly scold the student for not following this form
exactly.  Sorry, students, it always happens.&lt;/p&gt;

&lt;h2 id=&quot;the-actual-design-process&quot;&gt;The Actual Design Process&lt;/h2&gt;

&lt;p&gt;The problem with this description of the expert’s design process is that the
expert isn’t telling the whole story.&lt;/p&gt;

&lt;p&gt;Because this isn’t his first design, he has already built up a small library
of routines–most of them surrounding how to communicate with an FPGA and how
to get diagnostics from the FPGA.  Indeed, his design flow is perhaps more
appropriately characterized by Fig 3.&lt;/p&gt;

&lt;table style=&quot;float: right&quot;&gt;&lt;caption&gt;Figure 3: Reality&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img width=&quot;600&quot; src=&quot;/img/actual-design-process.svg&quot; alt=&quot;What the Expert actually does&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;The result is that the expert can draw values and hence insights from the logic
running within the FPGA, while the student is still stuck wondering what
happened.&lt;/p&gt;

&lt;p&gt;In my case, this scaffolding consists of both my
open source &lt;a href=&quot;https://github.com/ZipCPU/wbscope&quot;&gt;Wishbone Scope&lt;/a&gt; that works 
with &lt;a href=&quot;https://gtkwave.sourceforge.net&quot;&gt;GTK Wave&lt;/a&gt;, and 2) my open source
&lt;a href=&quot;https://github.com/ZipCPU/openarty/blob/master/rtl/wbubus.v&quot;&gt;UART to wishbone&lt;/a&gt;
converter which gives you access to that
&lt;a href=&quot;http://opencores.org/opencores,wishbone&quot;&gt;Wishbone Bus&lt;/a&gt;, to include the 
&lt;a href=&quot;https://github.com/ZipCPU/wbscope&quot;&gt;wishbone scope&lt;/a&gt; that I place on that bus.
Of course, when I first started I didn’t have
&lt;a href=&quot;https://gtkwave.sourceforge.net&quot;&gt;GTK Wave&lt;/a&gt; support–but that just illustrates
how an expert’s toolset can grow to become more useful over time.&lt;/p&gt;

&lt;h2 id=&quot;what-the-student-should-have-done&quot;&gt;What the Student should have done&lt;/h2&gt;

&lt;p&gt;What the student should have done was to take some time, between the simple
&lt;a href=&quot;/blog/2017/05/19/blinky.html&quot;&gt;blinky&lt;/a&gt; and
&lt;a href=&quot;/blog/2017/05/24/serial-port.html&quot;&gt;UART&lt;/a&gt;
projects but before the more complex projects, to build some scaffolding.
Specifically, he needs to build a means of evaluating logic from within the
FPGA, and of learning how to discover whether or not the device he’s working
with responds the way he thinks it should or not.&lt;/p&gt;

&lt;p&gt;The typical curricula doesn’t lead the student to this approach.
Instead, the typical curricula works from
&lt;a href=&quot;/blog/2017/05/19/blinky.html&quot;&gt;blinky&lt;/a&gt; to more and more
complex projects, but never focuses on how to build scaffolding out of these
projects that is necessary to be truly competent at the more complex tasks.&lt;/p&gt;

&lt;p&gt;The problem with this approach is that 1) few students know that this is a
requirement on their road to success, and 2) few students allocate time for
failure along the way.&lt;/p&gt;

&lt;p&gt;This is why student’s stumble on their complex FPGA design projects.&lt;/p&gt;

&lt;p&gt;If this has been your experience, please write to me.  I’d love to share any
lessons you’ve learned from your design projects here on this blog.&lt;/p&gt;
</description>
        <pubDate>Fri, 02 Jun 2017 00:00:00 -0400</pubDate>
        <link>http://zipcpu.com/blog/2017/06/02/design-process.html</link>
        <guid isPermaLink="true">http://zipcpu.com/blog/2017/06/02/design-process.html</guid>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>Building a simple wishbone slave</title>
        <description>&lt;p&gt;If you’ve never written bus logic before, the
&lt;a href=&quot;http://opencores.org/opencores,wishbone&quot;&gt;wishbone bus&lt;/a&gt; is a good place to
start.  Although other busses have more features to them, 
the &lt;a href=&quot;http://opencores.org/opencores,wishbone&quot;&gt;wishbone bus&lt;/a&gt; can be simplified
into an extremely easy bus to work with.&lt;/p&gt;

&lt;p&gt;For our purpose, we’ll be using the
&lt;a href=&quot;http://opencores.org/cdn/downloads/wbspec_b4.pdf&quot;&gt;B4 version of the specification&lt;/a&gt;,
and specifically the pipelined mode within it.&lt;/p&gt;

&lt;h2 id=&quot;wishbone-bus-components&quot;&gt;Wishbone bus components&lt;/h2&gt;

&lt;p&gt;The first step, though, is to simplify the wishbone bus for our discussion.
As with the other logic I have presented, I prefix ports with &lt;strong&gt;i_&lt;/strong&gt; if they
are inputs, and &lt;strong&gt;o_&lt;/strong&gt; if they are outputs.  Further, because these inputs
and outputs to our bus slave are wishbone connected, I’ll adjust their
prefixes to read &lt;strong&gt;i_wb_&lt;/strong&gt; for inputs and &lt;strong&gt;o_wb_&lt;/strong&gt; for outputs.&lt;/p&gt;

&lt;p&gt;Using this notation, the
&lt;a href=&quot;http://opencores.org/cdn/downloads/wbspec_b4.pdf&quot;&gt;wishbone specification&lt;/a&gt;
defines the following wires from the perspective of a slave:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;i_wb_cyc&lt;/strong&gt; is true any time a wishbone transaction is taking place.  It
 needs to become true on (or before) the first &lt;strong&gt;i_wb_stb&lt;/strong&gt; clock,
 and generally stays true until the last &lt;strong&gt;o_wb_ack&lt;/strong&gt;.&lt;/p&gt;

    &lt;p&gt;We’re going to assume that the &lt;strong&gt;i_wb_cyc&lt;/strong&gt; line is high during our
 transaction, and that the logic necessary to insure this has already been
 taken care of within the bus master.  Therefore, we’ll ignore this wire.&lt;/p&gt;

    &lt;p&gt;Incidentally, the &lt;a href=&quot;http://opencores.org/cdn/downloads/wbspec_b4.pdf&quot;&gt;specification&lt;/a&gt;
 isn’t clear regarding whether or not this signal can be ignored by the slave.
 (It cannot be ignored by the interconnect …)  If you
 are dealing with a master you aren’t certain of, you can &lt;em&gt;and&lt;/em&gt; your
 &lt;strong&gt;i_wb_stb&lt;/strong&gt; line with your &lt;strong&gt;i_wb_cyc&lt;/strong&gt; signal and do just as well.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;i_wb_stb&lt;/strong&gt; is true for any bus transaction request.  While &lt;strong&gt;i_wb_stb&lt;/strong&gt;
 is true, the other wishbone slave inputs (&lt;strong&gt;i_wb_we&lt;/strong&gt;, &lt;strong&gt;i_wb_addr&lt;/strong&gt;,
 &lt;strong&gt;i_wb_data&lt;/strong&gt;, and &lt;strong&gt;i_wb_sel&lt;/strong&gt;) are valid and reference the same
 transaction.  The transaction is accepted by the slave any time
 &lt;strong&gt;i_wb_stb&lt;/strong&gt; is true at the same time as &lt;strong&gt;o_wb_stall&lt;/strong&gt; is false.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;i_wb_we&lt;/strong&gt; is true for any write requests&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;i_wb_addr&lt;/strong&gt; contains the address of the request&lt;/p&gt;

    &lt;p&gt;From the perspective of
 the wishbone slave that we are working with, this address contains only the
 address lines of relevance to the slave.  Hence, while the bus may have 32
 address lines, the slave might only be interested in might have anywhere
 between no address lines and all 32 address lines.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;i_wb_data&lt;/strong&gt; contains the data we wish to write.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;o_wb_ack&lt;/strong&gt; is a response from the slave, indicating that the request has
 been completed.  For every request given to the slave, there must be one
 and only one clock cycle with &lt;strong&gt;o_wb_ack&lt;/strong&gt; high&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;o_wb_stall&lt;/strong&gt; is used to control the flow of data into the slave.  It will
 be true on any cycle when the master &lt;em&gt;cannot&lt;/em&gt; accept data from the slave,
 and false any time data can be accepted.  This allows the slave to control
 the flow of requests being given to it.&lt;/p&gt;

    &lt;p&gt;For our simple example, we’ll just set this line to zero.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;o_wb_data&lt;/strong&gt; is the data returned by the slave to the bus master as a 
 result of any read request.  It is valid whenever &lt;strong&gt;o_wb_ack&lt;/strong&gt; is true,
 and it’s value may be ignored any time &lt;strong&gt;o_wb_ack&lt;/strong&gt; is false.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;While &lt;a href=&quot;http://opencores.org/cdn/downloads/wbspec_b4.pdf&quot;&gt;the spec&lt;/a&gt;,
defines other wires that may be a part of this interface, we’ll ignore these
and instead focus on the minimum required logic
necessary to get a simplified demonstration up and running.&lt;/p&gt;

&lt;h2 id=&quot;writes-to-the-slave&quot;&gt;Writes to the slave&lt;/h2&gt;

&lt;p&gt;You may remember from our discussion on how to write to a 
&lt;a href=&quot;/zipcpu/2017/05/23/simplebus.html&quot;&gt;very simple bus&lt;/a&gt; that we based all of
our logic off of an &lt;strong&gt;i_wr&lt;/strong&gt; line.  Whenever this line was true, we would
read from the bus.  As a review,
the &lt;a href=&quot;/zipcpu/2017/05/23/simplebus.html&quot;&gt;simple bus&lt;/a&gt; write logic was written as,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	if (i_wr)
		memory[i_addr] &amp;lt;= i_data;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Moving from this simple example to the wishbone is quite easy.  In particular,
&lt;em&gt;all&lt;/em&gt; we need to do is to adjust the &lt;strong&gt;i_wr&lt;/strong&gt; logic for the wishbone bus.
Once done, the interaction should look identical:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	if ((i_wb_stb)&amp;amp;&amp;amp;(i_wb_we)&amp;amp;&amp;amp;(!o_wb_stall))
	begin
		// Your write logic here, such as
		// memory[i_addr] &amp;lt;= i_data;
	end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Simple, huh?&lt;/p&gt;

&lt;h2 id=&quot;reads-from-the-slave&quot;&gt;Reads from the slave&lt;/h2&gt;

&lt;p&gt;Reading from the port is fairly easy as well.  The first step is to create a
response for every address given to us, as we did before.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	//
	// Basically o_wb_data &amp;lt;= memory[i_wb_addr];
	//
	// If you aren&#39;t implementing a memory, your
	// result will instead look like ...
	case(i_wb_addr)
	4&#39;h0: o_wb_data &amp;lt;= some_register;
	// ...
	default: o_wb_data &amp;lt;= some_default response;
	end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;One more step is required for both reading and writing: we need to return an
acknowledgement back to the bus that this transaction has been completed, and
that the data on the bus is now valid.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	o_wb_ack &amp;lt;= ((i_wb_stb)&amp;amp;&amp;amp;(!o_wb_stall));&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;For some peripherals, the answer is known before you request it.  In that
case, you might just &lt;em&gt;assign&lt;/em&gt; the &lt;strong&gt;o_wb_ack&lt;/strong&gt; signal instead of waiting for
the positive edge of the clock.&lt;/p&gt;

&lt;p&gt;Other peripherals may need to delay the acknowledgement by another clock.  Two examples of this would be the &lt;a href=&quot;https://github.com/ZipCPU/wbscope&quot;&gt;wishbone scope&lt;/a&gt; and the &lt;a href=&quot;https://github.com/ZipCPU/wbuart/blob/master/wbuart.v&quot;&gt;wbuart serial port&lt;/a&gt; controller.  Both of these examples require one clock to calculate an output,
and then another clock to select between possible outputs.&lt;/p&gt;

&lt;p&gt;The other key piece to any wishbone interaction is the stall line.  For our
simple interaction, we’ll just hold this line zero.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;assign	o_wb_stall = 1&#39;b0;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;What that means is that we are able to accept a wishbone request on every
clock cycle, and that our transaction rate will be as fast as the clock rate.
This works well for many peripherals, although some peripherals such as
&lt;a href=&quot;http://opencores.org/project,qspiflash&quot;&gt;flash&lt;/a&gt;
or &lt;a href=&quot;http://github.com/ZipCPU/xulalx25/blob/master/rtl/wbsdram.v&quot;&gt;SDRAM&lt;/a&gt; may
need to adjust this line if they cannot accept a new request every
clock cycle.&lt;/p&gt;

&lt;h2 id=&quot;what-if-you-can-only-accept-requests--sometimes&quot;&gt;What if you can only accept requests … sometimes?&lt;/h2&gt;

&lt;p&gt;So … what if your peripheral cannot accept requests on every clock cycle?&lt;/p&gt;

&lt;p&gt;Here’s an example set of logic where the peripheral starts a state machine
upon any request, and only returns a result once the state machine becomes
idle.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;reg	busy;

always @(posedge i_clk)
	if ((i_wb_stb)&amp;amp;&amp;amp;(!o_wb_stall))
	begin
		state &amp;lt;= SOME_NEW_STATE;
		local_data &amp;lt;= i_wb_data;
		busy &amp;lt;= 1&#39;b1;
	end else case(state)
	SOME_NEW_STATE: begin
		// Your logic here ...
		if (some_condition)
			state &amp;lt;= SOME_NEXT_STATE;
		end
	...
	SOME_FINAL_STATE: begin
		state &amp;lt;= IDLE_STATE;
		busy &amp;lt;= 1&#39;b0;
		ack  &amp;lt;= 1&#39;b1;
		o_data &amp;lt;= any_read_data_response;
	enddcase

assign	o_wb_stall &amp;lt;= busy;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Examples of this in practice include the
&lt;a href=&quot;https://github.com/ZipCPU/wbicapetwo&quot;&gt;wishbone ICAPE2 controller&lt;/a&gt;,
and a &lt;a href=&quot;http://opencores.org/project,qspiflash&quot;&gt;QSPI flash controller&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;what-can-you-use-this-interface-for&quot;&gt;What can you use this interface for?&lt;/h2&gt;

&lt;p&gt;What can you use this for?  Anything!  Feel free to look over our
&lt;a href=&quot;/projects.html&quot;&gt;projects page&lt;/a&gt; for some example peripheral components that
use this simple interaction.&lt;/p&gt;

&lt;p&gt;In particular, I intend to follow up this article with the idea of using a
wishbone interface to create an interface whereby
&lt;a href=&quot;https://github.com/ZipCPU/wbscope&quot;&gt;a scope&lt;/a&gt; may be read for improved
debugging purposes.&lt;/p&gt;
</description>
        <pubDate>Mon, 29 May 2017 00:00:00 -0400</pubDate>
        <link>http://zipcpu.com/zipcpu/2017/05/29/simple-wishbone.html</link>
        <guid isPermaLink="true">http://zipcpu.com/zipcpu/2017/05/29/simple-wishbone.html</guid>
        
        
        <category>zipcpu</category>
        
      </item>
    
      <item>
        <title>Bus Select Lines</title>
        <description>&lt;p&gt;In a previous post, I discussed how to build a &lt;a href=&quot;/zipcpu/2017/05/29/simple-wishbone.html&quot;&gt;simple wishbone bus
slave&lt;/a&gt;.  That post
eliminated a lot of the bus lines so as to make building a simple bus slave
easy.&lt;/p&gt;

&lt;p&gt;As a result, that bus as built could not handle 8-bit bytes.&lt;/p&gt;

&lt;p&gt;This post will describe how to add the appearance of 8-bit addressing to a
wishbone bus slave.&lt;/p&gt;

&lt;h2 id=&quot;bus-word-size&quot;&gt;Bus Word Size&lt;/h2&gt;

&lt;p&gt;The word size of any bus is given by by the number of data lines contained
within that bus.  The speed of the bus is constrained to be one transaction
per clock, at most, and hence any bus design can at most read (or write)
one bus word at a time.  Hence, increasing the width of the bus will increase
the throughput of that bus.&lt;/p&gt;

&lt;p&gt;The consequence of this, though, is that addresses on the bus don’t reference
octets (8-bit bytes), but rather words.  Instead, a wider bus represents an
array of words, not an array of bytes.&lt;/p&gt;

&lt;p&gt;The problem with word references is that most software is built with the
legacy understanding that memory exists as a series of octets (8-bit bytes).&lt;/p&gt;

&lt;p&gt;So … although the bus exists as an array of words, modern computer software
considers it to be an array of octets.&lt;/p&gt;

&lt;p&gt;How shall this illusion be kept?&lt;/p&gt;

&lt;h2 id=&quot;select-lines&quot;&gt;Select lines&lt;/h2&gt;

&lt;p&gt;The answer to the question of how to make an array of words look like an array
of bytes is the bus select lines.&lt;/p&gt;

&lt;p&gt;Remember how we defined how a memory would access a bus &lt;a href=&quot;/zipcpu/2017/05/23/simplebus.html&quot;&gt;earlier&lt;/a&gt;?&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	if (i_wr)
		memory[i_addr] &amp;lt;= i_data;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Or how &lt;a href=&quot;/zipcpu/2017/05/29/simple-wishbone.html&quot;&gt;we discussed&lt;/a&gt; what this would look like for the &lt;a href=&quot;http://opencores.org/cdn/downloads/wbspec_b4.pdf&quot;&gt;wishbone bus&lt;/a&gt;?&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	if ((i_wb_stb)&amp;amp;&amp;amp;(i_wb_we))
		memory[i_addr] &amp;lt;= i_data;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Adding select lines to this transaction is fairly easy.  In particular, the
four select lines indicate which byte on the bus has valid data within it.
What we do, therefore, is to gate each of the individual byte writes by this
select line:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	reg	[(BUS_WIDTH-1):0]	mem	[(0:((1&amp;lt;&amp;lt;(ADDRESS_WIDTH)-1)];
	always @(posedge i_clk)
	begin
		if ((i_wb_stb)&amp;amp;&amp;amp;(i_wb_we)&amp;amp;&amp;amp;(w_sel[3]))
			mem[i_wb_addr][31:24] &amp;lt;= i_wb_data[31:24];
		if ((i_wb_stb)&amp;amp;&amp;amp;(i_wb_we)&amp;amp;&amp;amp;(w_sel[2]))
			mem[i_wb_addr][23:16] &amp;lt;= i_wb_data[23:16];
		if ((i_wb_stb)&amp;amp;&amp;amp;(i_wb_we)&amp;amp;&amp;amp;(w_sel[1]))
			mem[i_wb_addr][15: 8] &amp;lt;= i_wb_data[15:8];
		if ((i_wb_stb)&amp;amp;&amp;amp;(i_wb_we)&amp;amp;&amp;amp;(w_sel[0]))
			mem[i_wb_addr][ 7: 0] &amp;lt;= i_wb_data[7:0];
	end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Format here is important.  Just a subtle change in this formula, and the
synthesis tool may no longer infer a block RAM.  If this happens, your LUT
usage is likely to massively increase.  To deal with this issue, know where
to find the guide that specifies how block RAM’s are inferred.  For example,
&lt;a href=&quot;https://www.xilinx.com/support/documentation/white_papers/wp231.pdf&quot;&gt;here’s a link&lt;/a&gt; to the guide for Xilinx.&lt;/p&gt;

&lt;p&gt;If you can’t get your synthesis tool to recognize a memory with select lines,
you may have to do this final bus decoding yourself:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;reg	[(7-1):0]	mem_a	[(0:((1&amp;lt;&amp;lt;(ADDRESS_WIDTH)-1)];
reg	[(7-1):0]	mem_b	[(0:((1&amp;lt;&amp;lt;(ADDRESS_WIDTH)-1)];
reg	[(7-1):0]	mem_c	[(0:((1&amp;lt;&amp;lt;(ADDRESS_WIDTH)-1)];
reg	[(7-1):0]	mem_d	[(0:((1&amp;lt;&amp;lt;(ADDRESS_WIDTH)-1)];

always @(posedge i_clk)
begin
	if ((i_wb_stb)&amp;amp;&amp;amp;(i_wb_we)&amp;amp;&amp;amp;(w_sel[3]))
		mem_a[i_wb_addr] &amp;lt;= i_wb_data[31:24];
	if ((i_wb_stb)&amp;amp;&amp;amp;(i_wb_we)&amp;amp;&amp;amp;(w_sel[2]))
		mem_b[i_wb_addr] &amp;lt;= i_wb_data[23:16];
	if ((i_wb_stb)&amp;amp;&amp;amp;(i_wb_we)&amp;amp;&amp;amp;(w_sel[1]))
		mem_c[i_wb_addr] &amp;lt;= i_wb_data[15:8];
	if ((i_wb_stb)&amp;amp;&amp;amp;(i_wb_we)&amp;amp;&amp;amp;(w_sel[0]))
		mem_d[i_wb_addr] &amp;lt;= i_wb_data[7:0];
end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;If you have to do this decoding yourself, reading from the bus would also
change to:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	o_wb_data &amp;lt;= { mem_a[i_wb_addr], mem_b[i_wb_addr],
		mem_c[i_wb_addr], mem_d[i_wb_addr] };&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;But I tend to avoid this approach if at all possible–it just seems and feels
messier.&lt;/p&gt;

&lt;h2 id=&quot;what-about-reading-from-the-bus&quot;&gt;What about reading from the bus?&lt;/h2&gt;

&lt;p&gt;The only time you need to worry about the select lines when reading from a 
wishbone bus is when you are the master and you want to decode the result
from the bus.  Hence, the bus master will just read a whole word, and then
grab the byte (or bytes) necessary when the bus request returns its data.&lt;/p&gt;

&lt;p&gt;In other words, nothing changes in the slave when you read less than a word
size from the bus.&lt;/p&gt;

&lt;h2 id=&quot;do-all-peripherals-need-to-offers-8-bit-support&quot;&gt;Do all peripherals need to offers 8-bit support?&lt;/h2&gt;

&lt;p&gt;Not at all.  If you read through device specification sheets, it’s not uncommon
for the designer to say that accesses of less than a word size are not
supported, and that their results are undefined.  This is the hardware
designer’s way of saying that the select lines may not be relied upon.&lt;/p&gt;

&lt;p&gt;In other words: when building your peripheral, you don’t need to provide select
line support.&lt;/p&gt;

&lt;p&gt;However, in order for the various string libraries to work, memory peripherals
&lt;em&gt;must&lt;/em&gt; have select line support.&lt;/p&gt;

&lt;h2 id=&quot;examples&quot;&gt;Examples&lt;/h2&gt;

&lt;p&gt;Few of my generic peripherals support memory byte selection, but all of my
memory peripherals now do.  You can find an example block RAM memory device 
&lt;a href=&quot;https://github.com/ZipCPU/openarty/blob/master/rtl/memdev.v&quot;&gt;here&lt;/a&gt;, showing
all the required pieces of what it takes to interact with a bus slave.&lt;/p&gt;

&lt;p&gt;If this is interesting to you, then stick around: discussing how to build a
wishbone bus master is next!&lt;/p&gt;
</description>
        <pubDate>Mon, 29 May 2017 00:00:00 -0400</pubDate>
        <link>http://zipcpu.com/zipcpu/2017/05/29/select-lines.html</link>
        <guid isPermaLink="true">http://zipcpu.com/zipcpu/2017/05/29/select-lines.html</guid>
        
        
        <category>zipcpu</category>
        
      </item>
    
      <item>
        <title>FFT debugging</title>
        <description>&lt;p&gt;Some time ago, an individual wrote into &lt;a href=&quot;https://forum.digilentinc.com&quot;&gt;Digilent’s forums&lt;/a&gt; asking why their
FFT wasn’t working.  You can read that interchange here
&lt;a href=&quot;https://forum.digilentinc.com/topic/2951-transfer-the-data-from-my-artix-7-board-to-a-txt-file-on-the-pc/&quot;&gt;[1]&lt;/a&gt;
&lt;a href=&quot;https://forum.digilentinc.com/topic/3101-problems-fft-ip-core-v90&quot;&gt;[2]&lt;/a&gt;
&lt;a href=&quot;https://forum.digilentinc.com/topic/3137-fft-problems-doesnt-finish-never&quot;&gt;[3]&lt;/a&gt;
&lt;a href=&quot;https://forum.digilentinc.com/topic/3160-xadc-and-the-fft&quot;&gt;[4]&lt;/a&gt;
&lt;a href=&quot;https://forum.digilentinc.com/topic/3211-back-the-fft-again&quot;&gt;[5]&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;My advice to anyone working on such a problem like this is that you need to
build the debug infrastructure first, before you try to implement an FFT.
Here on this blog, we’ve already discussed most of the pieces describing how
to do just that:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;You start by getting a simple means of communicating with the device working&lt;/p&gt;

    &lt;p&gt;We discussed an example of getting a &lt;a href=&quot;https://github.com/ZipCPU/wbuart32&quot;&gt;basic serial port&lt;/a&gt; up and running &lt;a href=&quot;/blog/2017/05/24/serial-port.html&quot;&gt;here&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;You use that communications channel to get some kind of bus up and running
on your FPGA.  (I prefer &lt;a href=&quot;http://opencores.org/opencores,wishbone&quot;&gt;wishbone&lt;/a&gt;.)
You then use this bus to read from
the internal variables of your FPGA, or set variables within it.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Once built, you can then use one of your peripheral registers to control a
stepping signal, so as to step all of your logic under test by one clock.&lt;/p&gt;

    &lt;p&gt;We discussed how to turn a serial port into such a debug peripheral
&lt;a href=&quot;/blog/2017/05/26/simpledbg.html&quot;&gt;here&lt;/a&gt;.  We’ll discuss
it more in the context of an FFT below.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;This works when debugging the &lt;a href=&quot;https://www.xilinx.com/support/documentation/ip_documentation/xfft/v9_0/pg109-xfft.pdf&quot;&gt;Xilinx FFT&lt;/a&gt;, as well as &lt;a href=&quot;https://github.com/ZipCPU/dblclockfft&quot;&gt;my own FFT&lt;/a&gt;.  Indeed, debugging
any FFT is no more difficult than debugging any other component, as we’ll
discuss in this post.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;why-you-need-to-break-up-the-problem&quot;&gt;Why you need to break up the problem&lt;/h2&gt;

&lt;p&gt;The first step, though, is to break the problem into pieces, and to debug
each piece individually.&lt;/p&gt;

&lt;p&gt;FFT’s are rarely found all alone.  Usually, they are found within a larger
context.  They are often connected to 
a sampling device, there may be other processing in front of them, and the
whole often runs faster than your debug interface.  Put together, a simple
FFT architecture might look like:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/multi-block-fft.svg&quot; /&gt;&lt;/p&gt;

&lt;p&gt;The problem with this simple architecture is that, unless you can isolate the
FFT component by itself, you will never know which of the components in this
processing chain is failing.  This was the problem the
&lt;a href=&quot;https://forum.digilentinc.com/topic/3101-problems-fft-ip-core-v90&quot;&gt;Digilent poster&lt;/a&gt;
had when trying to get his FFT working.&lt;/p&gt;

&lt;p&gt;This post will discuss how to isolate just the FFT.&lt;/p&gt;

&lt;p&gt;Ideally, you could build a simulation which would allow you to simulate how
this FFT works.  However, if you are like me and enjoy building simulations
from open source tools only,
&lt;a href=&quot;https://www.veripool.org/wiki/verilator&quot;&gt;Verilator&lt;/a&gt; for example,
then you’ll be stuck and unable to simulate a proprietary IP core anywhere other
than on the FPGA itself.  Hence, we’re going to run our test benches on the
FPGA hardware itself.&lt;/p&gt;

&lt;p&gt;To do that, we’re going to add a &lt;a href=&quot;http://opencores.org/opencores,wishbone&quot;&gt;wishbone&lt;/a&gt; slave interface to our FFT, so that
you can debug the FFT, and only the FFT, just like you would read and write
from any &lt;a href=&quot;zipcpu/2017/05/29/simple-wishbone.html&quot;&gt;wishbone slave peripheral&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;my-example&quot;&gt;My example&lt;/h2&gt;

&lt;p&gt;The following is an example piece of code, cut from a time when I needed to
debug
&lt;a href=&quot;https://www.xilinx.com/support/documentation/ip_documentation/xfft/v9_0/pg109-xfft.pdf&quot;&gt;Xilinx’s FFT&lt;/a&gt; within one of my designs (I was comparing their
implementation to &lt;a href=&quot;https://github.com/ZipCPU/dblclockfft&quot;&gt;my own&lt;/a&gt; at the time).
Minimal edits have been made to simplify the presentation.&lt;/p&gt;

&lt;p&gt;As with any test, you want to start from known conditions.  This test is no
difference.  Hence, our first step will be to reset the FFT.  We’ll do that by
setting the reset line any time the user writes to the zero address associated
witht he FFT.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;// Writes to the control register reset the FFT.  Note that the reset lasts
// only one clock
always @(posedge i_clk)
	fft_reset&amp;lt;=(i_wb_stb)&amp;amp;&amp;amp;(i_wb_we)&amp;amp;&amp;amp;(i_wb_addr[3:0]== 4&#39;h0);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The register names should
be familiar from either the &lt;a href=&quot;http://opencores.org/opencores,wishbone&quot;&gt;wishbone spec&lt;/a&gt;, or &lt;a href=&quot;zipcpu/2017/05/29/simple-wishbone.html&quot;&gt;our discussion&lt;/a&gt; on how to build a simple wishbone slave.&lt;/p&gt;

&lt;p&gt;The next step is to set up the input value for the each FFT clock.  In our
case, we’ll set one input value any time someone writes to the bus.   Well,
almost.  In my example, I have two input samples because I was testing a
&lt;a href=&quot;https://github.com/ZipCPU/dblclockfft&quot;&gt;two-sample input FFT&lt;/a&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;// Writes to the FFT control logic
always @(posedge i_clk)
	if ((i_wb_stb)&amp;amp;&amp;amp;(i_wb_we))
	begin case(i_wb_addr[3:0])
		// 4&#39;h0:	fft_reset &amp;lt;= 1&#39;b1;
		4&#39;h2:	fft_in_left &amp;lt;= { i_wb_data[31:(32-FFTBITS)],
					i_wb_data[15:(16-FFTBITS)] };
		4&#39;h3:	begin
			fft_in_right&amp;lt;= { i_wb_data[31:(32-FFTBITS)],
					i_wb_data[15:(16-FFTBITS)] };
			end
		default: begin end
	endcase end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Since I was setting the values two at a time, you’ll notice the FFT input values
are name &lt;strong&gt;fft_in_left&lt;/strong&gt; and
&lt;strong&gt;fft_in_right&lt;/strong&gt;—the even and odd inputs to the FFT respectively.
Likewise, you may also notice that I accepted FFTBITS per input.  This allowed
me to experiment with input samples having less than 16-bits each, even though
I was passing two values at a time (real and imaginary) packed into the upper
bits of each half-word.&lt;/p&gt;

&lt;p&gt;Now that the FFT has its inputs given and assigned to it, we then need to
step the clock by one tick, and one tick only.  To do this, we’ll use the
clock enable (ce) line found within each FFT.  We connect this clock enable
line to the bus via a bus write: any time the user writes to address 3 of our
bus, the clock enable line will get set for one clock tick.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;// Writes to register #3 step the FFT
always @(posedge i_clk)
	fft_ce &amp;lt;= (i_wb_stb)&amp;amp;&amp;amp;(i_wb_we)&amp;amp;&amp;amp;(i_wb_addr[3:0] == 4&#39;h3);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;You may notice that this is also the register for one of our inputs
(&lt;strong&gt;fft_in_right&lt;/strong&gt; above).  In this fashion, we only need to set the inputs in
order to have the FFT step forward by one clock tick.&lt;/p&gt;

&lt;p&gt;The last step is to read the results from the FFT.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;// Reads from the FFT control logic
always @(posedge i_clk)
case(i_wb_addr[3:0]) // Read
	// Read from a control register
	4&#39;h0: o_wb_data &amp;lt;= { 28&#39;hff0000, 3&#39;h0,
				fft_sync };
	// Read from the input port for the left channel
	4&#39;h2: o_wb_data &amp;lt;= fft_in_left;
	// Read from the input port for the right channel
	4&#39;h3: o_wb_data &amp;lt;= fft_in_right;
	// Read the FFT outputs, from first the left then the right ports
	4&#39;h4: o_wb_data &amp;lt;= fft_out_left;
	4&#39;h5: o_wb_data &amp;lt;= fft_out_right;
	// And ... set every other register to zero
	default: o_wb_data &amp;lt;= 32&#39;h0000;
endcase&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The first register allowed me to read back the status from the FFT itself.
In particular, the FFT sets a synchronization flag on the first valid
output from the FFT.  In order to align our results with the FFT, we need
to read that flag.&lt;/p&gt;

&lt;p&gt;Reads from addresses two and three allowed us to verify that the bus was
working, by simply reading back the values we’d written to the input channel.&lt;/p&gt;

&lt;p&gt;Reads from addresses four and five allowed us to read the result from the FFT.&lt;/p&gt;

&lt;p&gt;The &lt;strong&gt;o_wb_ack&lt;/strong&gt; and &lt;strong&gt;o_wb_stall&lt;/strong&gt; lines can use the same logic as we
used for our &lt;a href=&quot;zipcpu/2017/05/29/simple-wishbone.html&quot;&gt;simple wishbone slave implementation&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;That’s it!  You can now debug an FFT as a wishbone slave component, feed it
with your test data, and single step it to see what it does and how it works!&lt;/p&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;So, we’ve now discussed how to debug an FFT isolated from everything else.
With a little ingenuity, you should be able to figure out how to debug any
other DSP logic on your FPGA in a similar fashion.  This approach should get
you to the point of being able to debug your processing flow all the way from
the Pre-DSP component through to your reported results.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/fft-almost-there.svg&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Where this approach fails is when you have real–time inputs to your FFT that
you cannot slow down–such as the results from any analog to digital
converter.  There are two approaches to that problem:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;You can copy the outputs of your sampler directly into a buffer, record that
  buffer, and then use the data from that buffer as inputs to your FFT.  That
  will allow you to continue using this debugging approach.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;You can also use some form of a scope to capture a snapshot of the
  real–time data as it runs through the FFT.   This is the approach used by
  the &lt;a href=&quot;https://github.com/ZipCPU/wbscope&quot;&gt;wishbone scope&lt;/a&gt;, and an approach
  we’ll slowly work up to within this blog.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Which solution should you use?  Both!  But … we’ll get back to that in a
later post.&lt;/p&gt;

</description>
        <pubDate>Mon, 29 May 2017 00:00:00 -0400</pubDate>
        <link>http://zipcpu.com/digilent/2017/05/29/fft-debugging.html</link>
        <guid isPermaLink="true">http://zipcpu.com/digilent/2017/05/29/fft-debugging.html</guid>
        
        
        <category>digilent</category>
        
      </item>
    
      <item>
        <title>Debugging an FPGA through the serial port--first steps</title>
        <description>&lt;p&gt;Now that you have a working &lt;a href=&quot;https://github.com/ZipCPU/wbuart32&quot;&gt;serial port&lt;/a&gt;
which you can use to interact with your CPU, and now again that you know how to
&lt;a href=&quot;/zipcpu/2017/05/23/simplebus.html&quot;&gt;respond to simple bus requests&lt;/a&gt;,
let’s examine whether these two be put together to create a simple means of
debugging your FPGA.&lt;/p&gt;

&lt;p&gt;In this post, we’ll build a generic means for both reading registers
internal to an FPGA using a serial port, and then using that approach to
debug your design.&lt;/p&gt;

&lt;h2 id=&quot;an-generic-serial-port-communication-interface&quot;&gt;An generic serial port communication interface&lt;/h2&gt;

&lt;p&gt;For the purpose of this discussion, let’s assume your serial port receiver
produces two outputs:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;rx_stb&lt;/strong&gt; – a logic value that is true any time a value has been received
across the receive port.  It is to be true for one clock cycle, and one clock
cycle only, any time something is received.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;rx_data&lt;/strong&gt; – Eight bits of logic representing the most recently received
data value from the received serial port.  This value has meaning anytime
&lt;strong&gt;rx_data&lt;/strong&gt; is true, and ignored at all other times.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Likewise, we’ll assume that your serial port transmitter has two inputs,
&lt;strong&gt;tx_stb&lt;/strong&gt; and &lt;strong&gt;tx_data&lt;/strong&gt;.  Their meaning will be analogous to that of the
receivers ports.&lt;/p&gt;

&lt;p&gt;The advanced student may notice this interface protocol isn’t complete.
In particular, the transmitter may be busy some time &lt;strong&gt;tx_stb&lt;/strong&gt; is true, and
nothing above allows us to capture that reality.  To be complete, then, you
will need a third wire, this one coming from your transmit interface:
&lt;strong&gt;tx_busy&lt;/strong&gt;.  This wire is true any time the transmitter is busy.  When put
together with the rest of the interface, a character will be accepted into
the transmit interface any time &lt;strong&gt;tx_stb&lt;/strong&gt; is true &lt;em&gt;and&lt;/em&gt; &lt;strong&gt;tx_busy&lt;/strong&gt; is
false.  We’ll ignore this wire for now.  As long as you don’t press this
interface too hard, the approach below will work.&lt;/p&gt;

&lt;p&gt;With that out of the way, we can move on to building our basic debug protocol,
based upon this interface to a serial port.&lt;/p&gt;

&lt;h2 id=&quot;using-a-clock-enable-as-part-of-a-debug-process&quot;&gt;Using a Clock Enable as part of a debug process&lt;/h2&gt;

&lt;p&gt;The first step is a clock enable line.  I’ll call this &lt;strong&gt;logic_ce&lt;/strong&gt; for now,
but you may see me call it &lt;strong&gt;i_ce&lt;/strong&gt; later.
We’ll use this clock enable line to gate all of your logic, such as:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	if (logic_ce)
	begin
		//
		// Your debuggable FPGA logic goes here.
		//

		// You could even stuff a full blown CPU in here, if you
		// wanted to debug it this way.

		// Anything that doesn&#39;t fit in this always block, will
		// still need to have it&#39;s logic gated by the ce line above.
	end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The goal here is to keep &lt;em&gt;any&lt;/em&gt; logic from changing unless the &lt;strong&gt;logic_ce&lt;/strong&gt;
line is true.&lt;/p&gt;

&lt;p&gt;Why are we doing this?  We’re doing this to slow down your logic to the point
where it can be inspected.&lt;/p&gt;

&lt;p&gt;What … how shall this ce line be controlled?&lt;br /&gt;
You can use the serial port to control this clock enable.   For this
example, we’ll set the serial port up so that any time you send an
8’h00 across the serial port channel, you also step all the logic by one clock.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	logic_ce &amp;lt;= (rx_stb)&amp;amp;&amp;amp;(rx_data == 8&#39;h00);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Sure, this will &lt;em&gt;really&lt;/em&gt; slow down your logic, but … you’ll still be running
&lt;em&gt;your&lt;/em&gt; logic on the FPGA.  Where this gets useful is in the next step, reading
data back ouf of the FPGA.&lt;/p&gt;

&lt;h2 id=&quot;reading-data-back-from-within-your-fpga&quot;&gt;Reading data back from within your FPGA&lt;/h2&gt;

&lt;p&gt;What really makes this idea flow work, is that now, because of the &lt;em&gt;ce&lt;/em&gt; line
above, we can step any logic within the FPGA.  We can then read values back
out of the FPGA while everything is stopped.  Using that UART to control your
bus, you can read out any of your data points with code something like this:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	if (rx_stb)
	begin
		tx_stb &amp;lt;= 1&#39;b1;
		case(rx_data)
		8&#39;h00: tx_data &amp;lt;= 8&#39;h00;
		8&#39;h01: tx_data &amp;lt;= one_of_my_registers;
		8&#39;h02: tx_data &amp;lt;= another_of_my_registers;
		8&#39;h03: tx_data &amp;lt;= a_third_set_of_internal_variables;
		...
		8&#39;hff: tx_data &amp;lt;= the_last_result_i_might_return;
		default: tx_data &amp;lt;= 8&#39;h00;
		endcase
	end else
		tx_stb &amp;lt;= 1&#39;b0;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Using this simple approach, you can now read the results of any logic within
your design.  You could also do something similar in the other direction
to set any values within your design if you so wished, but I’ll leave that last
change up to you.&lt;/p&gt;

&lt;h2 id=&quot;this-really-needs-a-software-controller&quot;&gt;This really needs a software controller&lt;/h2&gt;

&lt;p&gt;While reading from addresses ‘0’-‘9’ (i.e. 8’d48 to 8’d57) may be pretty
simple, and may be done within a
simple terminal program, chances are that if you wish to make this work you’ll
want to connect a computer program to that terminal program.   That computer
program will need to send the full set of characters from 8’d0 to 8’d255.&lt;/p&gt;

&lt;p&gt;You can see how I drive my serial port in the
&lt;a href=&quot;https://github.com/ZipCPU/openarty/blob/master/sw/host/netuart.cpp&quot;&gt;netuart&lt;/a&gt;
program I use to
bounce the serial port to a TCP/IP port, but there’s no reason why you couldn’t
use this as an example of how to interact with a serial port.  The commands
would be similar, only the network stuff would need to come out.&lt;/p&gt;

&lt;h2 id=&quot;multi-stepping&quot;&gt;Multi-Stepping&lt;/h2&gt;

&lt;p&gt;There’s no reason why you cannot step several steps at a time using this
approach.  You could also set-up multi-cycle instructions that will start
whenever you write a NULL to the port, and whose data may be read after a
programmable number of clocks.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;reg	counter;
always @(posedge i_clk)
	if ((rx_stb)&amp;amp;&amp;amp;(rx_data == 8&#39;h00))
		counter &amp;lt;= 0;
		logic_ce &amp;lt;= 1&#39;b1;
	else if (counter &amp;lt; NCLOCKS-1)
		counter &amp;lt;= counter + 1&#39;b1;
	else
		logic_ce &amp;lt;= 1&#39;b0;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Indeed, the possibilities of using this approach for debugging are nearly
endless.&lt;/p&gt;

&lt;h2 id=&quot;output-formats&quot;&gt;Output Formats&lt;/h2&gt;

&lt;p&gt;If you’d like, you can take the outputs you get from this debugging interface
and build a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Value_change_dump&quot;&gt;VCD&lt;/a&gt; file for viewing in
&lt;a href=&quot;gtkwave.sourceforge.net&quot;&gt;GTKwave&lt;/a&gt;.  If your not sure how to build a 
&lt;a href=&quot;https://en.wikipedia.org/wiki/Value_change_dump&quot;&gt;VCD&lt;/a&gt; file, then just dump
the results into a pseudo-human readable text file and you can then wait
for a later discussion on how to create
&lt;a href=&quot;https://en.wikipedia.org/wiki/Value_change_dump&quot;&gt;VCD&lt;/a&gt; files.&lt;/p&gt;

&lt;p&gt;Me?  Back when I last used this approach (yes, it was some time ago), I just
created a file that I could view using &lt;a href=&quot;https://www.gnu.org/software/octave&quot;&gt;octave&lt;/a&gt;.  &lt;a href=&quot;https://www.gnu.org/software/octave&quot;&gt;Octave&lt;/a&gt; allowed me to not only read in a set of binary data, but it aso allowed me to create
&lt;a href=&quot;gtkwave.sourceforge.net&quot;&gt;GTKwave&lt;/a&gt; types of graphs of the signals within my
design.  Then again, that was a personal choice and you might wish to view
the results in another fashion..&lt;/p&gt;

&lt;p&gt;Am I still using this approach?  Not really.  I’ve built something better
since.  Stick around, and you’ll hear about it.  For now, …&lt;/p&gt;

&lt;p&gt;Go ahead, take this opportunity to surprise me with your ingenuity.&lt;/p&gt;

</description>
        <pubDate>Fri, 26 May 2017 00:00:00 -0400</pubDate>
        <link>http://zipcpu.com/blog/2017/05/26/simpledbg.html</link>
        <guid isPermaLink="true">http://zipcpu.com/blog/2017/05/26/simpledbg.html</guid>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>That first serial port: Debugging when you are blind</title>
        <description>&lt;p&gt;Getting your first communications port up and running on an FPGA can be a &lt;em&gt;real&lt;/em&gt;
challenge.  After you get your serial port up and running, you can then use it
to get the next item up and running–since a serial port can provide a lot of 
feedback.  But until you can read that feedback, how can you avoid
&lt;a href=&quot;/blog/2017/05/19/fpga-hell.html&quot;&gt;FPGA hell&lt;/a&gt; long enough to
get that first port up and running?&lt;/p&gt;

&lt;h2 id=&quot;the-easy-way&quot;&gt;The easy way&lt;/h2&gt;

&lt;p&gt;If you want to do things the easy way, then just connect your serial port logic
to a known working
&lt;a href=&quot;https://en.wikipedia.org/wiki/Universal_asynchronous_receiver/transmitter&quot;&gt;UART&lt;/a&gt;
simulator, such as &lt;a href=&quot;https://github.com/ZipCPU/wbuart32/blob/master/bench/cpp/uartsim.cpp&quot;&gt;this
one&lt;/a&gt;,
and examine the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Value_change_dump&quot;&gt;VCD&lt;/a&gt;
output until you get the right answers from the serial
port.  As an example, consider the
&lt;a href=&quot;https://github.com/ZipCPU/wbuart/blob/master/bench/verilog/helloworld.v&quot;&gt;helloworld.v&lt;/a&gt;
module, together with the
&lt;a href=&quot;https://github.com/ZipCPU/wbuart/blob/master/bench/cpp/helloworld.cpp&quot;&gt;helloworld.cpp&lt;/a&gt;
&lt;a href=&quot;https://www.veripool.org/wiki/verilator&quot;&gt;Verilator&lt;/a&gt; driver,
for inspiration on how you might do this.&lt;/p&gt;

&lt;p&gt;Once your hello world design runs in the simulator, and once you get “Hello
World” on the screen, you are reading for real hardware.&lt;/p&gt;

&lt;p&gt;That’s the easy way.&lt;/p&gt;

&lt;h2 id=&quot;building-your-own-simulator&quot;&gt;Building your own simulator&lt;/h2&gt;

&lt;p&gt;But … what happens if you wish to communicate with your FPGA over something
other than a serial port, and you have no serial port to bootstrap your
efforts?&lt;/p&gt;

&lt;p&gt;In that case, you’ll want to build your own simulator.&lt;/p&gt;

&lt;p&gt;Since I’ve done this so often, I maintain a &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/sim/verilator/testb.h&quot;&gt;test bench C++
class&lt;/a&gt;
which I often use for wrapping the
&lt;a href=&quot;https://www.veripool.org/wiki/verilator&quot;&gt;Verilator&lt;/a&gt;
commands within a simulator. 
While it doesn’t handle all of the
&lt;a href=&quot;https://www.veripool.org/wiki/verilator&quot;&gt;Verilator&lt;/a&gt;
code, it does handle most of it.  Still, there’s often quite a bit of work
to be done.  You can see examples of simulators I’ve built for
&lt;a href=&quot;https://github.com/ZipCPU/wbi2c/blob/master/bench/cpp&quot;&gt;I2C controller&lt;/a&gt;,
a &lt;a href=&quot;https://github.com/ZipCPU/wbpmic/blob/master/bench/cpp&quot;&gt;PMod MIC controller&lt;/a&gt;,
a &lt;a href=&quot;https://github.com/ZipCPU/sdspi/blob/master/bench/cpp&quot;&gt;SPI based SD-card controller&lt;/a&gt;,
or even the &lt;a href=&quot;https://github.com/ZipCPU/wbscope/blob/master/bench/cpp&quot;&gt;wishbone scope&lt;/a&gt;, which I hope to work our way up to in this blog.&lt;/p&gt;

&lt;p&gt;I would also recommend making heavy use of the
&lt;a href=&quot;http://www.cplusplus.com/refernce/cassert/assert/&quot;&gt;C assert&lt;/a&gt;
statement any time your code &lt;em&gt;must&lt;/em&gt; do something.  For example, if you must
wait at least 20 clocks from any request to the next, then count clocks within
your simulator and
&lt;a href=&quot;http://www.cplusplus.com/refernce/cassert/assert/&quot;&gt;assert&lt;/a&gt;
that the time between accesses is less than 20.  Just be careful to make
certain you flush any
&lt;a href=&quot;https://en.wikipedia.org/wiki/Value_change_dump&quot;&gt;VCD&lt;/a&gt;
file you are creating before calling
&lt;a href=&quot;http://www.cplusplus.com/refernce/cassert/assert/&quot;&gt;assert&lt;/a&gt;, lest
you don’t get the data leading up to it.
(The &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/sim/verilator/testb.h&quot;&gt;test bench
class&lt;/a&gt;
was recently updated to handle this by default)&lt;/p&gt;

&lt;p&gt;Once your code works in your simulated environment, the next step is to try
it on the hardware.&lt;/p&gt;

&lt;h2 id=&quot;the-easy-move-to-hardware&quot;&gt;The Easy Move to Hardware&lt;/h2&gt;

&lt;p&gt;The easy way of getting this next step going is to use an oscilloscope.  You’ll
want to build a development board with particular “test-points” where you can
hook up the probe for the scope, and see what’s going on.  Barring test points
on the actual wires, sometimes you can use a general purpose I/O pin to become
a test point.&lt;/p&gt;

&lt;p&gt;This is also the expensive way.&lt;/p&gt;

&lt;p&gt;I don’t own a scope, neither do I have the cash to design my own boards, so …
enjoy this approach if you can do it.&lt;/p&gt;

&lt;h2 id=&quot;the-harder-way-to-get-hardware-working&quot;&gt;The Harder way to get Hardware Working&lt;/h2&gt;

&lt;p&gt;The difficult part of this first task on your hardware is, how do you know
what’s going on at high speed?  If you don’t have an Oscilloscope to measure
that high speed interaction, if all you have are your LED’s and your clock,
how shall you get to the next step?&lt;/p&gt;

&lt;p&gt;The answer is to use your LED(s), just like we discussed when &lt;a href=&quot;/blog/2017/05/19/blinky.html&quot;&gt;building
blinky&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Let’s take a look a some particular tests you can try.&lt;/p&gt;

&lt;h2 id=&quot;look-for-whether-or-not-the-serial-port-is-getting-set&quot;&gt;Look for whether or not the serial port is getting set&lt;/h2&gt;

&lt;p&gt;Your first question is going to be, am I even toggling the right wire, or
vice versa, am I listening to the right wire?&lt;/p&gt;

&lt;p&gt;In the case of a serial port, the line should idle high (at one) when nothing
is being sent.  So anytime the line isn’t one is an event you are interested in,
right?&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	if (!ck_uart)
		counter &amp;lt;= 0;
	else if (!counter[24])
		counter &amp;lt;= counter + 1&#39;b1;
assign	o_led = counter[24];&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;You did remember to use two flip flops to synchronize an asynchronous input,
right?&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	r_uart &amp;lt;= i_uart;
always @(posedge i_clk)
	ck_uart &amp;lt;= r_uart;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Put together, this will turn your LED off if the UART line is ever active. 
Once the character has been sent, the LED should idle high.  (This way you
know the LED works …)  If the LED isn’t
idling high, or if the line never goes low, then you know that you may be
listening to the wrong wire.  If the LED never turns off, you might not
have the right serial port coming out of your computer.&lt;/p&gt;

&lt;p&gt;Incidentally, this test usually finds most of the UART problems that take
place using code that passes the simulation test.&lt;/p&gt;

&lt;h2 id=&quot;check-to-see-if-your-baud-rate-is-set-right&quot;&gt;Check to see if your baud rate is set right&lt;/h2&gt;

&lt;p&gt;Since the start bit in any &lt;a href=&quot;https://en.wikipedia.org/wiki/Universal_asynchronous_receiver/transmitter&quot;&gt;serial port transaction is always
zero&lt;/a&gt;, we should be able
to check for whether or not that first clock stays low for a full baud duration
as follows:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	if ((counter[24])&amp;amp;&amp;amp;(!ck_uart))
	begin
		// If we are idle and something comes across the wire,
		// start counting.
		counter &amp;lt;= 0;
		transitioned &amp;lt;= 1&#39;b0;
	end else if (!counter[24])
	begin
		// While we are not yet idle, count up on the counter
		// to something near a second ...
		counter &amp;lt;= counter + 1&#39;b1;

		// Set the bit_interval counter on *every* clock,
		// up until the UART line goes high again
		if (!transitioned)
			bit_interval &amp;lt;= counter;

		// When that first transition from zero happens, grab
		// how long things had been low.
		if ((ck_uart)&amp;amp;&amp;amp;(!transitioned))
			transitioned &amp;lt;= 1&#39;b1;
	end

// Now that we have a bit_interval estimate, test it and set our LED
always @(posedge i_clk)
	o_led &amp;lt;= ((transitioned)&amp;amp;&amp;amp;&amp;amp;(bit_interval &amp;lt; ONE_AND_A_TENTH_BAUD)
			&amp;amp;&amp;amp;(bit_interval &amp;gt; NINE_TENTHS_OF_A_BAUD));&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This should help you discover what speed your port is transmitting at.  Just
to check, send an “A” to the port.  Since “A” is represented by 8’d65, which
is an odd number, and since serial ports transmit the
&lt;a href=&quot;https://upload.wikipedia.org/wikipedia/commons/thumb/2/24/UART_timing_diagram.svg/800px&quot;&gt;LSB first&lt;/a&gt;, this should
allow you to determine if you are within the baud rate you are expecting.
If “A” doesn’t pass, but “B” does, then you’re baud rate is too slow.&lt;/p&gt;

&lt;p&gt;This simple test &lt;em&gt;should&lt;/em&gt; find most of the rest of your problems.&lt;/p&gt;

&lt;h2 id=&quot;check-to-see-if-you-are-discovering-any-characters-at-all&quot;&gt;Check to see if you are discovering any characters at all&lt;/h2&gt;

&lt;p&gt;At this point, we turn from common and known problems to answering whether
we can debug something … not so well known.  This example tests whether
or not the serial port ever declares that a value has been read (i.e.,
sets rx_stb high for one cycle).&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	if ((counter[24])&amp;amp;&amp;amp;(!ck_uart))
	begin
		counter &amp;lt;= 0;
		found &amp;lt;= 1&#39;b0;
	end else if (!counter[24])
	begin
		if (rx_stb)
			found &amp;lt;= 1&#39;b1;
		counter &amp;lt;= counter + 1&#39;b1;
	end else
		counter[23:0] &amp;lt;= counter[23:0] + 1&#39;b1;

assign	o_led = (found)&amp;amp;&amp;amp;(counter[23]);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Usually, though, if you’ve passed the simulation test, you’ll never have this
problem.  Still, it can be useful to determine what’s going on.&lt;/p&gt;

&lt;p&gt;Did you notice that we kept the bottom 24 bits of this counter counting,
even after the 25th bit went high?  Or the fact that the LED was the AND
of the found light and the 24th counter bit?  In other words, if anything
was found, the light will blink.  If the UART line ever goes active, but
rx_stb never goes high during this time frame, then the LED will stay off.&lt;/p&gt;

&lt;h2 id=&quot;check-to-see-what-character-you-are-reading&quot;&gt;Check to see what character you are reading&lt;/h2&gt;

&lt;p&gt;If you know you are receiving a character, but don’t know what it is, then …
use the LED to find out!&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	if ((counter[24])&amp;amp;&amp;amp;(!ck_uart))
	begin
		counter &amp;lt;= 0;
	end else if (!counter[24])
	begin
		if (rx_stb)
			read_data &amp;lt;= rx_data;
		counter &amp;lt;= counter + 1&#39;b1;
	end else
		counter[23:0] &amp;lt;= counter[23:0] + 1&#39;b1;

// If you don&#39;t have 8 LED&#39;s, there&#39;s no reason why you can&#39;t do this one
// LED at a time ... it&#39;ll just take longer to do.
assign	o_led[7:0] = read_data;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Of course, this solution depends upon your being able to display eight data bits
on your LEDs at the same time.&lt;/p&gt;

&lt;h2 id=&quot;what-about-the-transmitter&quot;&gt;What about the transmitter?&lt;/h2&gt;

&lt;p&gt;While the examples shown above apply to the UART receiver, there’s no reason
why they cannot be turned around and made to work for the transmitter as well.
You’ll probably want to check the transmitter output in the reverse order,
though: first that it is getting something to send, then whether or not the
baud rate is set right, etc.&lt;/p&gt;

&lt;h2 id=&quot;possibilities-are-endless&quot;&gt;Possibilities are endless&lt;/h2&gt;

&lt;p&gt;The number of ways you can set an LED as you work through a problem like
this is endless.  There are just so many tests you can do.&lt;/p&gt;

&lt;p&gt;Even still, … this approach has two problems:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;An LED can only give you one bit of information over the course of a 
  quarter second or so … at best!  If you need more complete information
  about what is going on within your design, getting it out via this means
  will take a long time and may well turn into an exercise in frustration.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;LED’s can’t tell you what’s happening on a clock by clock basis.  While you
  might be able to build a serial port without knowing this information, on
  anything more complex this approach will become a challenge.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;So, stick around–how to use an FPGA to debug itself is the subject of this
blog.&lt;/p&gt;
</description>
        <pubDate>Wed, 24 May 2017 00:00:00 -0400</pubDate>
        <link>http://zipcpu.com/blog/2017/05/24/serial-port.html</link>
        <guid isPermaLink="true">http://zipcpu.com/blog/2017/05/24/serial-port.html</guid>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>Building a simple bus</title>
        <description>&lt;p&gt;Busses consist of both bus masters, and bus slaves.  Masters command which
addresses need to be read from or written to, while slaves respond to the
requests of the bus master(s).  For this article, we’ll discuss the logic
necessary to implement a very simple bus slave.  Why?  Because at the core of
every memory mapped peripheral is just a touch of simple bus logic.&lt;/p&gt;

&lt;p&gt;To understand this concept, let’s consider a very simple bus.  Three things
can only ever happen on this bus on any given clock cycle.  1) The vast majority
of the time, the bus will be idle.  2) You might write to the bus.  Or 3),
you might read from the bus.  On a simple bus, this type of interaction can
easily be understood with just a few simple wires:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;i_wr&lt;/strong&gt;: True any time a write is requested.  If true for two clocks in a row, then two writes should take place in a row.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;i_rd&lt;/strong&gt;: True any time a read is requested&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;i_addr&lt;/strong&gt;: The address of the value to read/write&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;i_data&lt;/strong&gt;: The data to be written on any write access&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;o_data&lt;/strong&gt;: The data to be returned on any read access&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;a-simple-write-cycle&quot;&gt;A Simple Write Cycle&lt;/h1&gt;

&lt;p&gt;Using these values, writing to a memory might be as simple as:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	if (i_wr)
		memory[i_addr] &amp;lt;= i_data;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Writing to an arbitrary peripheral has much the same logic, but what it does
is a little bit different:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	if (i_wr) case(i_addr)
	4&#39;h0: config &amp;lt;= i_data;
	4&#39;h1: begin end // A read only address
	4&#39;h2: begin end // A read only address
	4&#39;h3: begin
		transmitter_data &amp;lt;= i_data;
		transmitter_stb  &amp;lt;= 1&#39;b1;
	default: begin end
	endcase else
		transmitter_stb &amp;lt;= 1&#39;b0;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Specifically, writes to a peripheral specify some logic to be done for each
possible address you might write to.&lt;/p&gt;

&lt;p&gt;In this example, writing to address zero simply sets a configuration register.
Writes to
addresses one and two are ignored: these addresses reference read only
registers.  Finally, address three sets a strobe value indicating that
some action is to take place, together with the data necessary for that
action.&lt;/p&gt;

&lt;p&gt;Indeed, from this perspective, the write cycle is pretty simple.&lt;/p&gt;

&lt;h1 id=&quot;a-simple-read-cycle&quot;&gt;A Simple Read Cycle&lt;/h1&gt;

&lt;p&gt;The read cycle isn’t really that much more complicated either.  For a simple
memory, it would look like:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	o_data &amp;lt;= memory[i_addr];&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Within a more generic peripheral, where reads might have side-effects, the
read logic might look instead like:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	case(i_addr)
	4&#39;h0: o_data &amp;lt;= config;
	4&#39;h1: begin o_data &amp;lt;= w_internal_values; advance_data_stb &amp;lt;= i_rd; end
	4&#39;h2: o_data &amp;lt;= w_other_internal_values;
	// 4&#39;h3: // A write only address
	defautl: o_data &amp;lt;= 0;
	endcase else
		advance_data_stb &amp;lt;= 1&#39;b0;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;You may notice that o_data gets set any time the address changes.
What if nothing is being read?  In this case, it’s not a problem.  The right
answer is being placed on the bus either way.  However, if you have an input
queue, such as in a read FIFO, you might wish to advance that queue on reads
only.  This is the idea behind the advance_data_stb logic above.&lt;/p&gt;

&lt;h2 id=&quot;shared-data-lines&quot;&gt;Shared data lines&lt;/h2&gt;

&lt;p&gt;Having separate input data lines, i_data, and output data lines, o_data,
makes a lot of sense within an FPGA.&lt;/p&gt;

&lt;p&gt;However, between components on a circuit board, cost may be measured in both
area and the number of wires routed from one place to another.&lt;/p&gt;

&lt;p&gt;For this reason, when communicating over an external bus, the simple bus we
have been describing has one more step:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;assign io_data (i_rd) ? 32&#39;bzzzz_..._zzzz : o_data;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This last step determines which of multiple digital pieces of logic drives
the bus.&lt;/p&gt;

&lt;h2 id=&quot;thats-it&quot;&gt;That’s it!&lt;/h2&gt;

&lt;p&gt;That’s all there is to working with a bus.  You need to read the address,
check if you are being read or written to, and return a value and act
appropriately.  At some level, every bus acts in this fashion.  Hence,
if you can understand how to interact with a bus like this, you’ve gone
through the first step of ever interacting with any bus.&lt;/p&gt;
</description>
        <pubDate>Tue, 23 May 2017 00:00:00 -0400</pubDate>
        <link>http://zipcpu.com/zipcpu/2017/05/23/simplebus.html</link>
        <guid isPermaLink="true">http://zipcpu.com/zipcpu/2017/05/23/simplebus.html</guid>
        
        
        <category>zipcpu</category>
        
      </item>
    
      <item>
        <title>Moving to memory</title>
        <description>&lt;p&gt;There seems to be a difficult transition between the beginning FPGA
designer, and the more experienced designer.  From the posts I’ve watched
and replied to, this transition appears to be centered around accessing
memory.&lt;/p&gt;

&lt;h2 id=&quot;before-memory&quot;&gt;Before Memory&lt;/h2&gt;

&lt;p&gt;Usually, a beginner’s FPGA work consists of very simple tasks: building a serial
port, controlling LED’s, &lt;a href=&quot;/blog/2017/05/19/blinky.html&quot;&gt;making things blink&lt;/a&gt;,
and so on.  These tasks can seem fairly simple, and they can usually be solved
with only some simple Verilog.&lt;/p&gt;

&lt;p&gt;Once the beginner has successfully completed these tasks, they then try to 
move on to something real.  For example, maybe they want to record some video,
capture images from a camera, or even to transmit a song over a
&lt;a href=&quot;https://github.com/ZipCPU/wbfmtx&quot;&gt;FM radio peripheral&lt;/a&gt;.
Every one of these tasks, though, requires memory.  These beginners quickly
discover that … there’s just not that much block RAM within an FPGA.&lt;/p&gt;

&lt;p&gt;What these beginners want is to continue their learning process just like
they’ve done it up to that time.&lt;/p&gt;

&lt;p&gt;This is where they get stuck.&lt;/p&gt;

&lt;h2 id=&quot;why-is-memory-different&quot;&gt;Why is memory different&lt;/h2&gt;

&lt;p&gt;Up until this point, when building for an FPGA, they can access as many memories
as they want within their FPGA.  When they need a memory, the just connect it
to their circuit.&lt;/p&gt;

&lt;p&gt;Now, when they need a big memory from an external circuit, … there’s only
one memory pipe.  Anything that needs to access that memory, needs access to
the one and only memory pipe’s controls.   The controls look much like any
bus:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Given an address and a read strobe, return the value at that address.&lt;/li&gt;
  &lt;li&gt;Given an address, a data value, and a write strobe, replace the contents at
that address with the new data value.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;For this, you need a bus.&lt;/p&gt;

&lt;p&gt;Many different bus standards exist.  There’s the
&lt;a href=&quot;http://opencores.org/opencores,wishbone&quot;&gt;Wishbone&lt;/a&gt;, the
&lt;a href=&quot;http://opencores.org/cdn/downloads/wbspec_b4.pdf&quot;&gt;B4 version of the Wishbone&lt;/a&gt;
that I like and use, there’s the
&lt;a href=&quot;http://opencores.org/cdn/downloads/wbspec_b3.pdf&quot;&gt;B3 version&lt;/a&gt;
used by the &lt;a href=&quot;https://openrisc.io&quot;&gt;OpenRISC&lt;/a&gt; team,
there’s the &lt;a href=&quot;http://www.gstitt.ece.ufl.edu/courses/fall15/eel4720_5721/labs/refs/AXI4_specification.pdf&quot;&gt;AXI bus&lt;/a&gt;
used by &lt;a href=&quot;https://www.xilinx.com&quot;&gt;Xilinx&lt;/a&gt; and ARM, etc.&lt;/p&gt;

&lt;p&gt;By itself, using the &lt;a href=&quot;http://opencores.org/opencores,wishbone&quot;&gt;wishbone bus&lt;/a&gt;
is pretty easy.
&lt;a href=&quot;http://www.gstitt.ece.ufl.edu/courses/fall15/eel4720_5721/labs/refs/AXI4_specification.pdf&quot;&gt;AXI&lt;/a&gt;
is harder, but once you understand how a bus works its not that much harder.
We’ll come back to that later with some easy examples of how to use one.&lt;/p&gt;

&lt;h2 id=&quot;beginners-should-get-used-to-busses&quot;&gt;Beginners should get used to busses&lt;/h2&gt;

&lt;p&gt;Before trying to read from memory or building a memory controller, a beginner
should learn how to read and write from a bus.  Lots of simple things with
busses are really appropriate beginner tasks.&lt;/p&gt;

&lt;p&gt;For example, a very simple piece of bus logic is a bus arbiter. 
Since only
one piece of logic can access the memory at any given time, if you want
two pieces of logic to be able to access memory, you need a bus arbiter.
(See &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/aux/wbarbiter.v&quot;&gt;here&lt;/a&gt;
for a wishbone example.)&lt;/p&gt;

&lt;p&gt;A classic example of this would be a project that reads from a camera port and
writes the result to memory.  If you ever want to get that image out of memory,
you will need an arbiter controlling which logic has access to the bus.&lt;/p&gt;

&lt;p&gt;As another example, if you are going to build a bus, why not put some &lt;a href=&quot;https://github.com/ZipCPU/wbscope&quot;&gt;
debug logic&lt;/a&gt; on that bus?  It’ll make
getting your memory interface up and running later a whole lot easier.&lt;/p&gt;

&lt;p&gt;The simplest bus to get used to is one where every item on the bus has exactly
the same timing.  A simple debug port might be like this.&lt;/p&gt;

&lt;p&gt;A harder bus is one where requests must be held on the bus until the respective
peripheral is ready to read them.
(&lt;a href=&quot;http://opencores.org/cdn/downloads/wbspec_b3.pdf&quot;&gt;WB B3/Classic&lt;/a&gt;)&lt;/p&gt;

&lt;p&gt;Harder still, one where many requests may be made before the first result comes
back, some variable number of clocks later.
(&lt;a href=&quot;http://opencores.org/cdn/downloads/wbspec_b4.pdf&quot;&gt;WB B4/Pipeline&lt;/a&gt;)&lt;/p&gt;

&lt;p&gt;The &lt;a href=&quot;http://www.gstitt.ece.ufl.edu/courses/fall15/eel4720_5721/labs/refs/AXI4_specification.pdf&quot;&gt;AXI&lt;/a&gt;
bus, though, usually takes the cake for complexity.  This bus has separate
channels for read requests, write requests, write data, read data, and the write
request acknowledgement.  Each of these channels has bi-directional flow control
so that requests may have to wait for the peripheral to be ready.  Worse,
this bus may respond out of order to various requests.  Ouch!&lt;/p&gt;

&lt;h2 id=&quot;actual-memory-controllers-are-complicated&quot;&gt;Actual memory controllers are complicated&lt;/h2&gt;

&lt;p&gt;Finally, once you are comfortable using a bus, only then is it time to connect
it to a memory controller.&lt;/p&gt;

&lt;p&gt;This is also where the beginner punts and looks for a prewritten memory
controller—usually because he has never learned how to deal with a bus,
or he’s read the memory controller spec sheet and … decided it wasn’t worth
his while.&lt;/p&gt;

&lt;p&gt;These beginners will also tend to switch to the
&lt;a href=&quot;http://www.gstitt.ece.ufl.edu/courses/fall15/eel4720_5721/labs/refs/AXI4_specification.pdf&quot;&gt;AXI&lt;/a&gt;
bus, not because they know
how to use it, neither because it’s the best bus out there, but because
&lt;a href=&quot;https://www.xilinx.com&quot;&gt;Xilinx&lt;/a&gt; has provided them with a memory controller
for their memory chip that uses the
&lt;a href=&quot;http://www.gstitt.ece.ufl.edu/courses/fall15/eel4720_5721/labs/refs/AXI4_specification.pdf&quot;&gt;AXI&lt;/a&gt;
bus.&lt;/p&gt;

&lt;p&gt;This is usually also the time in their development where they abandon the
Verilog or VHDL code they’ve been working with in favor of one of the visual
and graphical tool flows.&lt;/p&gt;

&lt;p&gt;This leads to a bigger problem down the road: they’re stuck using the Xilinx
IP because 1) building
&lt;a href=&quot;https://github.com/ZipCPU/wbscope/blob/master/rtl/axi4lscope.v&quot;&gt;something&lt;/a&gt; that
interacts on an
&lt;a href=&quot;http://www.gstitt.ece.ufl.edu/courses/fall15/eel4720_5721/labs/refs/AXI4_specification.pdf&quot;&gt;AXI&lt;/a&gt;
bus isn’t simple, and
2) because it’s difficult to integrate their special sauce into the official
IP integrator.  Indeed, the problem is so complicated that 
&lt;a href=&quot;http://www.gstitt.ece.ufl.edu/courses/fall15/eel4720_5721/labs/refs/AXI4_specification.pdf&quot;&gt;AXI&lt;/a&gt;
has to offer a special subset of the AXI bus specification, AXI-lite, just to
try to make this easier.&lt;/p&gt;

&lt;h2 id=&quot;stick-around-and-ill-show-another-way&quot;&gt;Stick around, and I’ll show another way&lt;/h2&gt;

&lt;p&gt;Having now written several memory controllers, I understand they can be
difficult.  They are also, however, quite possible to build.  The beginner
who abandons their learning process for a set of ready-set of tools, however,
will quickly loose the fortitude they need to get there.&lt;/p&gt;

&lt;p&gt;If you stick around on this blog, I intend to show you another way.&lt;/p&gt;
</description>
        <pubDate>Mon, 22 May 2017 00:00:00 -0400</pubDate>
        <link>http://zipcpu.com/digilent/2017/05/22/moving-to-memory.html</link>
        <guid isPermaLink="true">http://zipcpu.com/digilent/2017/05/22/moving-to-memory.html</guid>
        
        
        <category>digilent</category>
        
      </item>
    
      <item>
        <title>A Vision for Controlling FPGA Logic</title>
        <description>&lt;p&gt;I’d like to spend some time on this forum discussing how to debug an FPGA.
Indeed, I might wish to spend a lot of time discussing how to debug an FPGA.
I’ve done it several ways, but for this post I’d like to discuss a vision
for how I like to debug FPGA’s.&lt;/p&gt;

&lt;h3 id=&quot;memory-mapped-io&quot;&gt;Memory Mapped I/O&lt;/h3&gt;

&lt;p&gt;We’ll start with the concept of
&lt;a href=&quot;https://en.wikipedia.org/wiki/Memory-mapped_I/O&quot;&gt;Memory Mapped I/O&lt;/a&gt;.
The idea is simply this: peripherals can be connected to a bus, together with
whatever memory is on that bus, so that they can be accessed like memory.
Like memory, the peripheral will have an address.  Like memory, the bus
controller, whether it be a CPU or &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/wbdmac.v&quot;&gt;DMA
peripheral&lt;/a&gt;,
can write to the peripheral
and read from it.  Unlike memory, however, reading or writing to a peripheral
can have side effects.&lt;/p&gt;

&lt;p&gt;We’ll use the term “register” to describe a single address within a peripheral.&lt;/p&gt;

&lt;p&gt;Register’s can be read only, write only, or read/write.  Further, peripherals
may have many addresses.  Finally, peripherals may take different amounts of
time to access.  For example, a
&lt;a href=&quot;https://github.com/ZipCPU/xulalx25soc/blob/master/rtl/memdev.v&quot;&gt;block RAM&lt;/a&gt;
peripheral can typically be accessed in a single cycle, whereas an
&lt;a href=&quot;https://github.com/ZipCPU/xulalx25soc/blob/master/rtl/wbsdram.v&quot;&gt;SDRAM&lt;/a&gt;
peripheral may take longer, and a
&lt;a href=&quot;https://github.com/ZipCPU/xulalx25soc/blob/master/rtl/wbspiflash.v&quot;&gt;flash&lt;/a&gt;
peripheral may take much longer.&lt;/p&gt;

&lt;p&gt;Perhaps a perfect example of this concept is that of a serial port, such as
the &lt;a href=&quot;https://github.com/ZipCPU/wbuart32&quot;&gt;wbuart32&lt;/a&gt; serial port the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt; uses.  Reading from the receiver
address of this serial port returns the next character from the receiver
queue, advancing the queue to the next character.  Writing to the transmit
register queue’s a character for sending over the port.  A third register
controls the speed and configuration of the port, whereas a fourth register
is used when the serial port has a queue to indicate how much of the queue
is used.&lt;/p&gt;

&lt;p&gt;But how does this apply to controlling an FPGA?  Simple!  We’ll implement
our logic as peripherals on an FPGA bus, and then control those peripherals
by simply reading from or writing to that bus.  By having a common standard
for accessing peripherals, we only have to build our peripherals to meet that
standard once.&lt;/p&gt;

&lt;h3 id=&quot;pcie-card&quot;&gt;PCIe card&lt;/h3&gt;

&lt;p&gt;Perhaps the vision I’m about to share will make more sense if I explain that
I first came up with it while trying to figure out how to control an
FPGA on a
&lt;a href=&quot;https://en.wikipedia.org/wiki/PCI_Express&quot;&gt;PCIe&lt;/a&gt;
card.  Indeed, I was trying to figure out how I would control
a &lt;a href=&quot;https://www.xilinx.com/products/boards-and-kits/ek-v7-vc707-g.html&quot;&gt;VC707&lt;/a&gt;
card made by &lt;a href=&quot;https://www.xilinx.com/&quot;&gt;Xilinx&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The &lt;a href=&quot;https://en.wikipedia.org/wiki/PCI_Express&quot;&gt;PCIe&lt;/a&gt;
bus allows for several different areas or sections of address space
which get assigned to each card.  These can include both memory address space,
and peripheral address space, but every thing is still accessed on a bus.
You can read from any given addresses on that bus, or write to a given
addresses, as with any other bus.&lt;/p&gt;

&lt;p&gt;Since I wanted to build an FPGA capability that could eventually be used on
an FPGA over a &lt;a href=&quot;https://en.wikipedia.org/wiki/PCI_Express&quot;&gt;PCIe&lt;/a&gt;
interface, I wanted to create something that would work on a
&lt;a href=&quot;https://en.wikipedia.org/wiki/PCI_Express&quot;&gt;PCIe&lt;/a&gt;
bus eventually, but that could be used over some other transport
prior to that point.  Further, when plugging the FPGA into the
&lt;a href=&quot;https://en.wikipedia.org/wiki/PCI_Express&quot;&gt;PCIe&lt;/a&gt; bus, I already knew that
I would need to use some sort of alternative transport in order to debug
whatever was going on.&lt;/p&gt;

&lt;p&gt;So, here was my vision: I would use the serial port on the
&lt;a href=&quot;https://www.xilinx.com/products/boards-and-kits/ek-v7-vc707-g.html&quot;&gt;VC707&lt;/a&gt;
to command the
&lt;a href=&quot;https://www.xilinx.com/products/boards-and-kits/ek-v7-vc707-g.html&quot;&gt;VC707&lt;/a&gt;
as though it were connected via
&lt;a href=&quot;https://en.wikipedia.org/wiki/PCI_Express&quot;&gt;PCIe&lt;/a&gt;.  Then, over this same
serial port, I could get the debugging information I needed to know if the
&lt;a href=&quot;https://en.wikipedia.org/wiki/PCI_Express&quot;&gt;PCIe&lt;/a&gt; bus were working, or
if not … why not?&lt;/p&gt;

&lt;h3 id=&quot;required-interactions&quot;&gt;Required Interactions&lt;/h3&gt;

&lt;p&gt;If you are going to create a memory mapped bus, that you are then going to
work with, you need to know what operations you want to do on this bus.
I captured the interface for, what I called a device bus, in a C++ header file,
&lt;a href=&quot;https://github.com/ZipCPU/openarty/blob/master/sw/host/devbus.cpp&quot;&gt;devbus.h&lt;/a&gt;.
Operations on this interface include:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;readio()&lt;/strong&gt;:  Reads a 32-bit value from any individual register&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;readz()&lt;/strong&gt;: Reading multiple 32-bit values from the same register.  While
most memories have one address per memory location, peripherals aren’t
necessarily like that.  This mode captures some of that difference.  Some
examples where this would be useful include reading from a FIFO, such as the
serial port input FIFO, and reading from my debugging scope, where
multiple reads from the data register read subsequent values from the scope’s
memory.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;readi()&lt;/strong&gt;: Reading a series of 32-bit values from consecutive registers.
This is akin to a memcpy command, where one end is coming from the device.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The same operations are then mirrored for writing to registers.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;This &lt;a href=&quot;https://github.com/ZipCPU/openarty/blob/master/sw/host/devbus.cpp&quot;&gt;bus interface&lt;/a&gt;
also allows for some minimal interrupt capability.  For example, you
can &lt;strong&gt;wait()&lt;/strong&gt; for an interrupt to be created within the device, or &lt;strong&gt;poll()&lt;/strong&gt;
to see if an interrupt has taken place.  How these interactions take place is
… up to whatever transport implements the interface.&lt;/p&gt;

&lt;p&gt;Back when I started working on computers decades ago, you could
&lt;a href=&quot;https://en.wikipedia.org/wiki/PEEK_and_POKE&quot;&gt;Peek or Poke&lt;/a&gt; an addresses within
your &lt;a href=&quot;https://en.wikipedia.org/wiki/Apple_IIe&quot;&gt;Apple IIe&lt;/a&gt; computer, and so
control the hardware.  While I thought of repeating this approach with FPGA’s,
I also like the thought of being able to name the peripheral register, rather
than trying to remembering &lt;a href=&quot;http://apple2.org.za/gswv/USA2WUG/FOUNDING.MEMBERS/HOME.PAGES/EDHEL/texts/pokes.html&quot;&gt;all the register numbers&lt;/a&gt; (OUCH!).
This would allow an FPGA to be reconfigured so the addresses might be moved
around, and yet you could still read and write the same peripherals via the
same names.  I like this idea so much,
that all of my projects have a
&lt;a href=&quot;https://github.com/ZipCPU/openarty/blob/master/sw/host/wbregs.cpp&quot;&gt;wbregs&lt;/a&gt;
program within them to control peripherals over some command line.&lt;/p&gt;

&lt;h3 id=&quot;tcpip-bridge&quot;&gt;TCP/IP bridge&lt;/h3&gt;

&lt;p&gt;Rather than getting into details regarding how such an interface might be built
(yet),
I’d like to add one more component to the vision: I want to be able to control
my FPGA devices from anywhere on my local network.  If I’m working on my
laptop, I’d like to be able to control them from my laptop.  If I’m working on
my desktop, I’d like to be able to control them from my desktop.  If I have the
device located next to an antenna in the attic, I still want to be able to
control it.&lt;/p&gt;

&lt;p&gt;For this purpose, I like to forward all of my transport connections over a
TCP/IP link.  While this would probably never be appropriate for an FPGA
with a PCIe connection, it has worked for all of my FPGA’s with slower
transport connections.&lt;/p&gt;

&lt;p&gt;Lest you be confused, this is different from having an FPGA with an Ethernet
port that can be accessed from your network.  We want to use our network
interface to command, control, and debug our FPGA before the network controller
connected to the FPGA works.&lt;/p&gt;

&lt;h3 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h3&gt;

&lt;p&gt;This vision for FPGA control leads nicely into a vision for building and
debugging an FPGA.  We’ll get more into that idea as this blog progresses,
but for now … we’ll just use this idea to keep things simple.&lt;/p&gt;
</description>
        <pubDate>Mon, 22 May 2017 00:00:00 -0400</pubDate>
        <link>http://zipcpu.com/blog/2017/05/22/a-vision-for-controlling-fpgas.html</link>
        <guid isPermaLink="true">http://zipcpu.com/blog/2017/05/22/a-vision-for-controlling-fpgas.html</guid>
        
        
        <category>blog</category>
        
      </item>
    
  </channel>
</rss>
