<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>The ZipCPU by Gisselquist Technology</title>
    <description>The ZipCPU blog, featuring how to discussions of FPGA and soft-core CPU design.  This site will be focused on Verilog solutions, using exclusively OpenSource IP products for FPGA design.  Particular focus areas include topics often left out of more mainstreeam FPGA design courses such as how to debug an FPGA design.
</description>
    <link>http://zipcpu.com/</link>
    <atom:link href="http://zipcpu.com/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Wed, 06 Sep 2017 09:11:17 -0400</pubDate>
    <lastBuildDate>Wed, 06 Sep 2017 09:11:17 -0400</lastBuildDate>
    <generator>Jekyll v3.0.1</generator>
    <image>
      <url>http://zipcpu.com/img/gt-rss.png</url>
      <title></title>
      <link></link>
    </image>
    
      <item>
        <title>Off to ORCONF-2017!</title>
        <description>&lt;p&gt;After a year of waiting, it’s time for &lt;a href=&quot;https://orconf.org&quot;&gt;ORCONF&lt;/a&gt;.
If you are not familiar with &lt;a href=&quot;https://orconf.org&quot;&gt;ORCONF&lt;/a&gt;,
then allow me to encourage you to examine &lt;a href=&quot;https://orconf.org&quot;&gt;their web-page&lt;/a&gt;,
and look over the &lt;a href=&quot;https://orconf.org/#presentations&quot;&gt;abstracts of the
presentations&lt;/a&gt; that will be given this year.
Looks like it will be quite the lineup.&lt;/p&gt;

&lt;p&gt;This year, I’ll be giving two presentations.&lt;/p&gt;

&lt;p&gt;My first presentation will be a quick
update on the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;.
Since &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/doc/orconf.pdf&quot;&gt;last year&lt;/a&gt;,
the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; has been updated so as to
support …&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;8-bit byte-level access across the 32-bit bus.&lt;/p&gt;

    &lt;p&gt;Prior to this redesign, the 
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
was one of a few rare 32-bit byte machines.&lt;/p&gt;

    &lt;p&gt;Now, the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; fully supports
8-bit bytes instead of the 32-bit bytes it supported before.&lt;/p&gt;

    &lt;p&gt;This required a bit of instruction set redesign.  Opcodes were re-ordered.
Rotate left &lt;code class=&quot;highlighter-rouge&quot;&gt;ROL&lt;/code&gt; and population count &lt;code class=&quot;highlighter-rouge&quot;&gt;POPC&lt;/code&gt; instructions have been removed.
The load and store instructions have been renamed load word &lt;code class=&quot;highlighter-rouge&quot;&gt;LW&lt;/code&gt; and store
word &lt;code class=&quot;highlighter-rouge&quot;&gt;SW&lt;/code&gt; instructions.  Four basic instructions have been added as well:
load half-word &lt;code class=&quot;highlighter-rouge&quot;&gt;LH&lt;/code&gt;, store halfword &lt;code class=&quot;highlighter-rouge&quot;&gt;SH&lt;/code&gt;, load byte &lt;code class=&quot;highlighter-rouge&quot;&gt;LB&lt;/code&gt; and store byte &lt;code class=&quot;highlighter-rouge&quot;&gt;SB&lt;/code&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;A compressed instruction set (CIS).&lt;/p&gt;

    &lt;p&gt;The &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; has always had a CIS,
although it was previously mis-named as a &lt;a href=&quot;https://en.wikipedia.org/wiki/Very_long_instruction_word&quot;&gt;Very Long Instruction Word
(VLIW)&lt;/a&gt;
set of instructions–which it never really was.  The CIS instruction set
allows you to integrate pairs of 16-bit instructions together with the
32-bit instructions.  It provides some increased code density as a result.&lt;/p&gt;

    &lt;p&gt;Over the last year, I’ve had the opportunity to test the CIS instructions on
the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; and work out the bugs
within them.  The &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/tree/master/sw&quot;&gt;current
toolchain&lt;/a&gt; builds with CIS
instructions enabled by default.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Nearly the same number of LUTs&lt;/p&gt;

    &lt;p&gt;Despite all of these changes, the number of LUTs used by the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; remains roughly the same.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;As a result of these changes, the &lt;a href=&quot;https://sourceware.org/newlib&quot;&gt;newlib&lt;/a&gt;
C-library now runs on the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;–something it didn’t do before.
That means you can now play &lt;a href=&quot;https://github.com/ZipCPU/tttt&quot;&gt;4x4x4 Tic-Tac-Toe&lt;/a&gt;
on the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;!&lt;/p&gt;

&lt;p&gt;My &lt;a href=&quot;https://github.com/ZipCPU/autofpga/blob/master/doc/orconf17.pdf&quot;&gt;second
presentation&lt;/a&gt;
will be an overview of &lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt;.
Here’s the abstract:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Placing a &lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;
into a new environment can be a daunting task.  Components
need to be selected, resources allocated, addresses given, interrupts
assigned, and peripherals configured–not only in the HDL code, but also for
all of the software support.  The problem with this approach to designing
hardware is that it works very well for one-off solutions, but not as well
for quickly creating generic solutions to new problems.  This is where
&lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt; comes in.&lt;/p&gt;

  &lt;p&gt;Given a &lt;a href=&quot;https://github.com/zipCPU/autofpga/tree/master/auto-data&quot;&gt;set of
components&lt;/a&gt;,
&lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt;
builds the &lt;a href=&quot;https://github.com/ZipCPU/autofpga/tree/master/demo-out/&quot;&gt;boiler plate
files&lt;/a&gt;, the &lt;a href=&quot;https://github.com/ZipCPU/autofpga/blob/master/demo-out/toplevel.v&quot;&gt;top
level&lt;/a&gt;
and &lt;a href=&quot;https://github.com/ZipCPU/autofpga/blob/master/demo-out/main.v&quot;&gt;main&lt;/a&gt;
design files, the &lt;a href=&quot;/doc/wbspec_b4.pdf&quot;&gt;Wishbone&lt;/a&gt;
interconnect, and the &lt;a href=&quot;https://github.com/ZipCPU/autofpga/blob/master/demo-out/board.h&quot;&gt;software header
file&lt;/a&gt;s
necessary for software support within that design.  As a result, I can
reconfigure a project with new hardware in a matter of minutes, rather
than the days it took before.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;When I get back, I’ll post about my experiences and thoughts.  When the
presentation video’s are posted on youtube, I intend to post those links
here as well.&lt;/p&gt;
&lt;hr /&gt;&lt;p&gt;&lt;em&gt;For the kingdom ofheaven is as a man travelling into a far country, who called his own servants, and delivered unto them his goods.  (Matt 25:14)&lt;/em&gt;</description>
        <pubDate>Wed, 06 Sep 2017 00:00:00 -0400</pubDate>
        <link>http://zipcpu.com/blog/2017/09/06/orconf-2017.html</link>
        <guid isPermaLink="true">http://zipcpu.com/blog/2017/09/06/orconf-2017.html</guid>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>Reinventing PWM</title>
        <description>&lt;p&gt;A common &lt;a href=&quot;http://www.fpga4fun.com/PWM_DAC.html&quot;&gt;beginners FPGA&lt;/a&gt; task is to
build a &lt;a href=&quot;https://en.wikipedia.org/wiki/Pulse-width_modulation&quot;&gt;Pulse Width
Modulated (PWM)&lt;/a&gt;
signal.  Such signals, when fed into an &lt;a href=&quot;store.digilentinc.com/pmod-amp2-audio-amplifier/&quot;&gt;appropriately modified
amplifier&lt;/a&gt;, can
be used to create an audio signal that can then be heard.&lt;/p&gt;

&lt;p&gt;Indeed, you might think of this as a poor man’s digital to analog converter,
since the circuitry required to turn a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Pulse-width_modulation&quot;&gt;PWM&lt;/a&gt; signal into
an audio signal is quite minimal.  Likewise,
&lt;a href=&quot;https://en.wikipedia.org/wiki/Pulse-width_modulation&quot;&gt;PWM&lt;/a&gt;
&lt;a href=&quot;https://store.digilentinc.com/pmod-amp2-audio-amplifier/&quot;&gt;audio hardware&lt;/a&gt;
($10 USD) can be cheaper than the corresponding
&lt;a href=&quot;https://en.wikipedia.org/wiki/I2S&quot;&gt;I2S&lt;/a&gt;
&lt;a href=&quot;https://store.digilentinc.com/pmod-i2s-stereo-audio-output/&quot;&gt;based Digital to Analog Converter&lt;/a&gt; ($15 USD).&lt;/p&gt;

&lt;p&gt;Today, let’s add some additional functionality and performance to this
&lt;a href=&quot;http://www.fpga4fun.com/PWM_DAC.html&quot;&gt;traditional beginner’s project&lt;/a&gt;.
Even better, let’s make this a simple &lt;em&gt;no cost&lt;/em&gt; improvement to the
traditional audio output–one that solves several common problems commonly
associated with the traditional
&lt;a href=&quot;https://en.wikipedia.org/wiki/Pulse-width_modulation&quot;&gt;PWM&lt;/a&gt;
development.
Our result will have the quality of a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Pulse-density_modulation&quot;&gt;PDM&lt;/a&gt;
signal, but without the painful cost of generating one.&lt;/p&gt;

&lt;h2 id=&quot;the-traditional-development&quot;&gt;The traditional development&lt;/h2&gt;

&lt;p&gt;Let’s start by outlining the basics of a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Pulse-width_modulation&quot;&gt;PWM&lt;/a&gt;
signal.  A &lt;a href=&quot;https://en.wikipedia.org/wiki/Pulse-width_modulation&quot;&gt;PWM&lt;/a&gt;
signal is simply a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_signal&quot;&gt;digital signal&lt;/a&gt;
that gets used in an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Analog_signal&quot;&gt;analog&lt;/a&gt;
context.  You can think of the
&lt;a href=&quot;https://store.digilentinc.com/pmod-amp2-audio-amplifier&quot;&gt;PModAMP2&lt;/a&gt;
as a good hardware example for this discussion, although the discussion
is much more general than just the
&lt;a href=&quot;https://store.digilentinc.com/pmod-amp2-audio-amplifier&quot;&gt;PModAMP2&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The definition of a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Pulse-width_modulation&quot;&gt;PWM&lt;/a&gt;
signal revolves around an time interval, &lt;code class=&quot;highlighter-rouge&quot;&gt;T&lt;/code&gt;.  During that
interval, the output signal starts as a logic one.  After some period of
time, determined by the desired but approximate output voltage, the signal
transitions to zero. 
A minimum output voltage is created by transitioning immediately to zero.
A maximum output voltage is created by waiting to the end of the interval
before transitioning to a logic zero.&lt;/p&gt;

&lt;p&gt;Pictorially, this might look like Fig 1.&lt;/p&gt;

&lt;table style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 1: A PWM waveform sample&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/pwm-example-defn.png&quot; alt=&quot;Setting up a CORDIC&quot; width=&quot;868&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;In this figure, the 
&lt;a href=&quot;https://en.wikipedia.org/wiki/Pulse-width_modulation&quot;&gt;PWM&lt;/a&gt;
signal is shown in red.  The current time this waveform is positive is given
by &lt;code class=&quot;highlighter-rouge&quot;&gt;tau&lt;/code&gt;.  The information within the waveform is captured by moving the
transition time back and forth with respect to the center of the period.&lt;/p&gt;

&lt;p&gt;With a signal description that simple, generating a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Pulse-width_modulation&quot;&gt;PWM modulator&lt;/a&gt;
is as simple as any good beginner’s assignment should be.&lt;/p&gt;

&lt;p&gt;First, you will need a counter.  This will count from the beginning to the end
of the interval, and then start over.  If we use the &lt;a href=&quot;/blog/2017/08/14/strategies-for-pipelining.html&quot;&gt;handshake pipeline
signaling&lt;/a&gt;
strategy, then we’ll need an &lt;code class=&quot;highlighter-rouge&quot;&gt;o_busy&lt;/code&gt; (a.k.a. stall) signal to slow down any
logic that is feeding our pipeline.  Hence, if we allow for a constant length
interval of &lt;code class=&quot;highlighter-rouge&quot;&gt;COUNTS_PER_INTERVAL&lt;/code&gt; clock ticks, the first part of our code
will look like:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	if (counter &amp;gt;= COUNTS_PER_INTERVAL-1)
	begin
		counter &amp;lt;= 0;
		sample &amp;lt;= i_sample;
	end else
		counter &amp;lt;= counter + 1&#39;b1;

always @(posedge i_clk)
	o_busy &amp;lt;= (counter == COUNTS_PER_INTERVAL-2);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Note that we need to compare the counter against &lt;code class=&quot;highlighter-rouge&quot;&gt;COUNTS_PER_INTERVAL-1&lt;/code&gt;
to make certain that we have an interval &lt;code class=&quot;highlighter-rouge&quot;&gt;COUNTS_PER_INTERVAL&lt;/code&gt; long.  Likewise,
we want the &lt;code class=&quot;highlighter-rouge&quot;&gt;o_busy&lt;/code&gt; signal to be true for the one clock when
&lt;code class=&quot;highlighter-rouge&quot;&gt;counts == COUNTS_PER_INTERVAL-1&lt;/code&gt;, and to do that we need to set it one
clock earlier.&lt;/p&gt;

&lt;p&gt;The last step, that of determining whether or not our pin should be on or off,
is determined by the simplest comparison:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	o_pin &amp;lt;= (counter &amp;lt; sample);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;That’s how you build an audio
&lt;a href=&quot;https://en.wikipedia.org/wiki/Pulse-width_modulation&quot;&gt;PWM&lt;/a&gt;
peripheral.&lt;/p&gt;

&lt;p&gt;The problem wih this approach is that audio sounds horrible.&lt;/p&gt;

&lt;h2 id=&quot;problems-with-the-traditional-development&quot;&gt;Problems with the traditional development&lt;/h2&gt;

&lt;p&gt;Let’s spend a moment and discuss all of the problems associated with generating
a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Pulse-width_modulation&quot;&gt;PWM&lt;/a&gt;
signal in this fashion.  This will help guide our solution later.&lt;/p&gt;

&lt;p&gt;The first problem with this algorithm is that the samples need to range
between one and &lt;code class=&quot;highlighter-rouge&quot;&gt;COUNTS_PER_INTERVAL-1&lt;/code&gt;.  Commonly, samples are represented as
&lt;a href=&quot;https://en.wikipedia.org/wiki/Twos_complement&quot;&gt;two’s complement&lt;/a&gt;
integers ranging from between &lt;code class=&quot;highlighter-rouge&quot;&gt;-2^(N-1)&lt;/code&gt; to &lt;code class=&quot;highlighter-rouge&quot;&gt;2^(N-1)-1&lt;/code&gt;.
Converting from
&lt;a href=&quot;https://en.wikipedia.org/wiki/Twos_complement&quot;&gt;two’s complement&lt;/a&gt;
to the samples this algorithm would require is going to require
multiplying by &lt;code class=&quot;highlighter-rouge&quot;&gt;(COUNTS_PER_INTERVAL-2)/2^N&lt;/code&gt; and then flipping the sign bit.
While the divide by &lt;code class=&quot;highlighter-rouge&quot;&gt;2^N&lt;/code&gt; can be accomplished just dropping the lower
&lt;code class=&quot;highlighter-rouge&quot;&gt;N&lt;/code&gt; bits, this still requires a multiply by
&lt;code class=&quot;highlighter-rouge&quot;&gt;COUNTS_PER_INTERVAL-2&lt;/code&gt;.
It would be nice to have an alternative that doesn’t require any multiplies.&lt;/p&gt;

&lt;p&gt;The second problem with the standard
&lt;a href=&quot;https://en.wikipedia.org/wiki/Pulse-width_modulation&quot;&gt;PWM&lt;/a&gt;
development is that the only way to send a zero is to send a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Square_wave&quot;&gt;square wave&lt;/a&gt;
with a 50% duty cycle (tau is in the center of the interval).  Such a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Square_wave&quot;&gt;square wave&lt;/a&gt;
is a tone which can be heard when the audio is supposed to be silent, should
the &lt;code class=&quot;highlighter-rouge&quot;&gt;COUNTS_PER_INTERVAL&lt;/code&gt; be large enough.  Indeed, this “silent” tone can be
very obnoxious on the ears.&lt;/p&gt;

&lt;p&gt;The third problem with the development above is that the sample rate
&lt;em&gt;must&lt;/em&gt; be an integer divisor of the system sample rate.  This limits the
sample rates that can be created.&lt;/p&gt;

&lt;p&gt;Coupled with the sample rate is the difficulty of getting a high
&lt;a href=&quot;https://en.wikipedia.org/wiki/Dynamic_range&quot;&gt;dynamic range&lt;/a&gt;.
More output voltage resolution requires a slower sample rate.
However, a slower sample rate brings the nasty audio
&lt;a href=&quot;https://en.wikipedia.org/wiki/Harmonic&quot;&gt;harmonics&lt;/a&gt;
into the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Hearing_range&quot;&gt;audio range&lt;/a&gt;.
For this reason, it can appear impossible to get good sound quality
from a &lt;a href=&quot;https://en.wikipedia.org/wiki/Pulse-width_modulation&quot;&gt;PWM&lt;/a&gt;
output.  Perhaps this was the idea, but we’ll do better in a moment.&lt;/p&gt;

&lt;p&gt;The final problem with this means of creating an audio signal is that
it creates lots of unwanted
&lt;a href=&quot;https://en.wikipedia.org/wiki/Harmonic&quot;&gt;harmonics&lt;/a&gt;,
i.e. distortions, in the audio that you
wish to produce.  We’ll see these when we introduce our improvements in a
moment.  Our goal should be to reduce these distortions.&lt;/p&gt;

&lt;p&gt;Hang on, that’s coming up.&lt;/p&gt;

&lt;h2 id=&quot;how-a-pwm-fits-into-a-digital-audio-system&quot;&gt;How a PWM fits into a digital audio system&lt;/h2&gt;

&lt;table style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 2: Audio Hearing Range&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/pwm-hearing-range.svg&quot; alt=&quot;A PWM sinewave&quot; width=&quot;380&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;Before we can make an improvement, you need to understand that the &lt;a href=&quot;https://en.wikipedia.org/wiki/Hearing_range&quot;&gt;ear can
&lt;em&gt;only&lt;/em&gt; hear sounds between about 20Hz and
20kHz&lt;/a&gt;.  To be successful, the
period of the &lt;a href=&quot;https://en.wikipedia.org/wiki/Pulse-width_modulation&quot;&gt;PWM&lt;/a&gt;
signal will then need to be well above 20kHz—out of the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Hearing_range&quot;&gt;range of hearing&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Hence, a good
&lt;a href=&quot;https://store.digilentinc.com/pmod-amp2-audio-amplifier&quot;&gt;audio circuit&lt;/a&gt;
(audiophile’s please forgive me for calling this “good”), following
a &lt;a href=&quot;https://en.wikipedia.org/wiki/Pulse-width_modulation&quot;&gt;PWM&lt;/a&gt;
output, will place a filter on the output to remove anything above 20kHz.&lt;/p&gt;

&lt;p&gt;This means that if we can push any distortions towards higher frequency
components, then these distortions will get filtered out by the amplifier
circuitry (or your ear), and the result will sound more pleasing to the ear.&lt;/p&gt;

&lt;p&gt;Can this be done?&lt;/p&gt;

&lt;h2 id=&quot;a-better-pwm&quot;&gt;A better PWM&lt;/h2&gt;

&lt;p&gt;Ok, you’ve waited enough, here’s the technique: &lt;em&gt;Bit-reverse the counter&lt;/em&gt; before
comparing it with the sample.
Further, we’ll insist that our
&lt;a href=&quot;https://en.wikipedia.org/wiki/Pulse-width_modulation&quot;&gt;PWM&lt;/a&gt;
counter have a power of two length so that
the bit reversed counter will take on the same values that the counter would’ve
taken on in the first place.  The result is a waveform that is like
&lt;a href=&quot;https://en.wikipedia.org/wiki/Pulse-width_modulation&quot;&gt;PWM&lt;/a&gt;,
although technically not a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Pulse-width_modulation&quot;&gt;PWM&lt;/a&gt; signal.
It is more generally a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Pulse-density_modulation&quot;&gt;PDM&lt;/a&gt; signal,
but unlike the implementation of
&lt;a href=&quot;https://en.wikipedia.org/wiki/Pulse-density_modulation&quot;&gt;PDM&lt;/a&gt;
presented on &lt;a href=&quot;https://en.wikipedia.org/wiki/Pulse-density_modulation&quot;&gt;Wikipedia&lt;/a&gt;
this implementation is very easy to calculate.  Like both
&lt;a href=&quot;https://en.wikipedia.org/wiki/Pulse-width_modulation&quot;&gt;PWM&lt;/a&gt; and
&lt;a href=&quot;https://en.wikipedia.org/wiki/Pulse-density_modulation&quot;&gt;PDM&lt;/a&gt;
the result will nominally maintain the same number of output clock periods
that a &lt;a href=&quot;https://en.wikipedia.org/wiki/Pulse-width_modulation&quot;&gt;PWM&lt;/a&gt;
output would have been on.  Likewise, it will also be off for the same number
of clock periods that a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Pulse-width_modulation&quot;&gt;PWM&lt;/a&gt;
output would have been off.  (Assuming &lt;code class=&quot;highlighter-rouge&quot;&gt;2^N&lt;/code&gt; clocks per interva.)  It will
produce the same number of one’s, and
the same number of zero’s.  The only difference is that bit-reversing the
counter will cause these one’s and zero’s to be produced in a different order.&lt;/p&gt;

&lt;p&gt;I’m going to call this new signal type simply &lt;em&gt;bit-reversed
&lt;a href=&quot;https://en.wikipedia.org/wiki/Pulse-width_modulation&quot;&gt;PWM&lt;/a&gt;&lt;/em&gt;,
even though technically it’s not really a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Pulse-width_modulation&quot;&gt;PWM&lt;/a&gt; signal at all
any more.&lt;/p&gt;

&lt;p&gt;To understand what’s going on, let’s consider what the traditional
&lt;a href=&quot;https://en.wikipedia.org/wiki/Pulse-width_modulation&quot;&gt;PWM&lt;/a&gt;
output would be for a sine-wave (shown in Fig 3 below).&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 3: A PWM sinewave&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/pwm-sinewave.png&quot; alt=&quot;A PWM sinewave&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Now, let’s take a look at that same sine wave output, but this time we’ll
bit reverse the counter before creating our output signal.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 4: An improved PWM sinewave&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/pwm-sine-improved.png&quot; alt=&quot;An improved PWM sinewave&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;From this figure, you can see that there are &lt;em&gt;many&lt;/em&gt; more transitions in the
bit-reversed
&lt;a href=&quot;https://en.wikipedia.org/wiki/Pulse-width_modulation&quot;&gt;PWM&lt;/a&gt;
signal.  Another way of saying this is that the
bit-reversed
&lt;a href=&quot;https://en.wikipedia.org/wiki/Pulse-width_modulation&quot;&gt;PWM&lt;/a&gt;
signal has a lot more high frequency content.  This extra high frequency
content should be easier to filter out with cheap analog circuitry, and hence
the remaining audio quality should be better.&lt;/p&gt;

&lt;p&gt;Enough of the hand-waving, is this new approach actually better?  To answer
that question, let’s look at a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Fourier_transform&quot;&gt;Fourier transform&lt;/a&gt;
of the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Pulse-width_modulation&quot;&gt;PWM&lt;/a&gt;
encoded sine wave in Fig 3, and let’s compare it to the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Fourier_transform&quot;&gt;Fourier transform&lt;/a&gt;
of the bit-reversed
&lt;a href=&quot;https://en.wikipedia.org/wiki/Pulse-width_modulation&quot;&gt;PWM&lt;/a&gt; sinewave from
Fig 4.  We’ll place this frequency comparison into Fig 5 below.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 5: Comparing PWM frequency responses&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/pwm-harmonics.png&quot; alt=&quot;Comparing PWM frequency responses&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;In this Figure, the vertical bars are frequency components, running from just
above zero frequency at the left to higher frequencies at the right.  Their
height is given by the magnitude squared of the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Fourier_transform&quot;&gt;Fourier transform&lt;/a&gt;
output values.  These are not &lt;a href=&quot;https://en.wikipedia.orgg/wiki/Decibel&quot;&gt;decibel&lt;/a&gt;
 values.
The tone we want to create is represented by the tall
vertical bar near the y-axis line.  The
&lt;a href=&quot;https://en.wikipedia.org/wiki/Fourier_transform&quot;&gt;Fourier transform&lt;/a&gt;
of the original 
&lt;a href=&quot;https://en.wikipedia.org/wiki/Pulse-width_modulation&quot;&gt;PWM&lt;/a&gt;
scheme is represented in red, whereas the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Fourier_transform&quot;&gt;Fourier transform&lt;/a&gt;
of our modified bit-reversed
&lt;a href=&quot;https://en.wikipedia.org/wiki/Pulse-width_modulation&quot;&gt;PWM&lt;/a&gt;
sinewave is represented in green.&lt;/p&gt;

&lt;p&gt;Now that you understand the graph, notice the additional red bars to the
right of the bar associated with our audio signal (the sinewave).  These are
distortions.  Your
ear will hear these distortions, and the result won’t sound like the pleasant
tone you wanted.&lt;/p&gt;

&lt;p&gt;If you look further, you won’t see any green distortions to
speak of.  It’s not that they aren’t there, it’s just that they’ve been spread
out and spread across a much higher frequency range.  Those distortions in
green that do remain within the audio range are much smaller in magnitude.&lt;/p&gt;

&lt;p&gt;The next step, now that we know how to improve this
&lt;a href=&quot;https://en.wikipedia.org/wiki/Pulse-width_modulation&quot;&gt;PWM&lt;/a&gt;
development, is to build our improved signal and hear what it sounds like.&lt;/p&gt;

&lt;h2 id=&quot;building-the-updated-pwms-logic&quot;&gt;Building the updated PWM’s logic&lt;/h2&gt;

&lt;p&gt;Let’s now work through how to code this bit-reversed
&lt;a href=&quot;https://en.wikipedia.org/wiki/Pulse-width_modulation&quot;&gt;PWM&lt;/a&gt;
signal, and make an
&lt;a href=&quot;https://github.com/ZipCPU/wbpwmaudio&quot;&gt;audio controller&lt;/a&gt;
using the scheme.&lt;/p&gt;

&lt;p&gt;The first step to creating a more pleasing sounding
&lt;a href=&quot;https://en.wikipedia.org/wiki/Pulse-width_modulation&quot;&gt;PWM&lt;/a&gt;
audio waveform is to bit–reverse the counter.  If we let our counter be a
simple 16-bit number, we can reverse it with a for loop within a Verilog
generate statement.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;// The bit-reversed (br) counter
wire	[15:0]	br_counter;
genvar	k;
generate for(k=0; k&amp;lt;16; k=k+1)
begin : bit_reversal_loop
	assign br_counter[k] = pwm_counter[15-k];
end endgenerate&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The beginning
&lt;a href=&quot;https://en.wikipedia.org/wiki/Hardware_description_language&quot;&gt;HDL&lt;/a&gt;.
student should remember that for loops in Verilog &lt;em&gt;are not
like for loops in software&lt;/em&gt;.  This loop does nothing but rename the wires
within the original &lt;code class=&quot;highlighter-rouge&quot;&gt;pwm_counter&lt;/code&gt;.  It requires no
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;
instructions, nor
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Logic_block&quot;&gt;logic elements&lt;/a&gt;,
to be accomplished.  As a result,
there’s no time consumed by the logic this loop creates.&lt;/p&gt;

&lt;p&gt;This loop is actually the whole key to the algorithm, and the source of the
difference we are going to create.  If you’ve built
a &lt;a href=&quot;https://en.wikipedia.org/wiki/Pulse-width_modulation&quot;&gt;PWM&lt;/a&gt; based audio signal
before, you now understand how to build a better one.  We’ll keep going,
though, just for completeness.&lt;/p&gt;

&lt;p&gt;We can then create our output from comparing this bit-reversed counter to the
sample we would desire to output.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;// Create the PWM output
always @(posedge i_clk)
	o_pin &amp;lt;= (sample_out &amp;lt;= br_counter);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;You can find the code to create this type of waveform in my &lt;a href=&quot;https://github.com/ZipCPU/wbpwmaudio/blob/master/rtl/wbpwmaudio.v&quot;&gt;wbpwmaudio
repository&lt;/a&gt;
on &lt;a href=&quot;https://github.com/ZipCPU&quot;&gt;GitHub&lt;/a&gt;.  However, if you look over &lt;a href=&quot;https://github.com/ZipCPU/wbpwmaudio/blob/master/rtl/wbpwmaudio.v&quot;&gt;the
code&lt;/a&gt;
alone, you might find there’s a bit more to it than the code written above.&lt;/p&gt;

&lt;p&gt;The first thing missing is the timer to tell the
bit reversed
&lt;a href=&quot;https://en.wikipedia.org/wiki/Pulse-width_modulation&quot;&gt;PWM&lt;/a&gt;
audio driver when to switch samples.  Unlike our original development,
the &lt;a href=&quot;https://github.com/ZipCPU/wbpwmaudio/blob/master/rtl/wbpwmaudio.v&quot;&gt;wbpwmaudio
core&lt;/a&gt;
uses a user-configurable count-down timer.  This configurable value is placed
into &lt;code class=&quot;highlighter-rouge&quot;&gt;w_reload_value&lt;/code&gt;, allowing us to write our count-down timer as,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;initial	timer = DEFAULT_RELOAD;
initial	ztimer= 1&#39;b0;

// ztimer is true for one clock pulse any time the timer restarts.
always @(posedge i_clk)
	ztimer &amp;lt;= (timer == { {(TIMING_BITS-1){1&#39;b0}}, 1&#39;b1 });
always @(posedge i_clk)
	if (ztimer)
		timer &amp;lt;= w_reload_value;
	else
		timer &amp;lt;= timer - ,1&#39;b1};&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;You might find this code very similar to the count-down timer logic found
in our &lt;a href=&quot;/blog/2017/06/02/generating-timing.html&quot;&gt;timing
post&lt;/a&gt;.
The big thing you may find different is the parameterized number of bits in
the counter.  In this case, the number of bits in the timer counter is
defined by the parameter,&lt;code class=&quot;highlighter-rouge&quot;&gt;TIMING_BITS&lt;/code&gt;.  Why?  Because I needed to be able
to trim the logic within the
&lt;a href=&quot;https://github.com/ZipCPU/s6soc&quot;&gt;S6SoC&lt;/a&gt; project down until the project
&lt;a href=&quot;/blog/2017/06/12/minimizing-luts.html&quot;&gt;could fit&lt;/a&gt;
onto
&lt;a href=&quot;https://store.digilentinc.com&quot;&gt;Digilent&lt;/a&gt;’s &lt;a href=&quot;https://store.digilentinc.com/cmod-s6-breadboardable-spartan-6-fpga-module&quot;&gt;CMod
S6&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The other thing you may notice is that the timer reload value isn’t connected
to the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Pulse-width_modulation&quot;&gt;PWM&lt;/a&gt;
counter any more.  Heresy!  No, actually it makes a lot of sense.  Because the
output bit order is spread uniformly across the sample interval, chopping a
value off before it’s had enough time to send all of its bits isn’t something
the ear will notice.  Further, this allows us to use arbitrary audio
intervals, without suffering significant loss.&lt;/p&gt;

&lt;p&gt;Incidentally, this simple change renders genering samples easier.  Not only
can we feed this value
&lt;a href=&quot;https://en.wikipedia.org/wiki/Twos_complement&quot;&gt;two’s complement&lt;/a&gt;
values now, but we can do so at our
favorite rate.  What if there aren’t enough clocks to transmit all the bits
in this new value?  Not a problem, the algorithm will adjust so that it
transmits as many bits as you have time to transmit.&lt;/p&gt;

&lt;p&gt;In other words, that’s all it takes to generate this bit-reversed
&lt;a href=&quot;https://en.wikipedia.org/wiki/Pulse-width_modulation&quot;&gt;PWM&lt;/a&gt;
signal.&lt;/p&gt;

&lt;p&gt;Let’s go one step further, though.  Let’s connect this controller to a
&lt;a href=&quot;/doc/wbspec_b4.pdf&quot;&gt;Wishbone bus&lt;/a&gt;, so
that we can send values to our core across such an interface.&lt;/p&gt;

&lt;h2 id=&quot;adding-wishbone-control&quot;&gt;Adding Wishbone Control&lt;/h2&gt;

&lt;p&gt;Let’s now turn this into a fairly complete
&lt;a href=&quot;https://en.wikipedia.org/wiki/Pulse-width_modulation&quot;&gt;PWM&lt;/a&gt;
audio controller.  To do this, we’ll add a user configurable sample rate,
some registers to control the power control wires in the
&lt;a href=&quot;https://store.digilentinc.com/pmod-amp2-audio-amplifier&quot;&gt;PModAMP2&lt;/a&gt;,
and a means of sending audio samples to the controller.  Finally, we’ll add an
interrupt line to let the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;bus master&lt;/a&gt;
know that another sample is needed.&lt;/p&gt;

&lt;p&gt;A more capable controller would include a
&lt;a href=&quot;/blog/2017/07/29/fifo.html&quot;&gt;FIFO&lt;/a&gt;
so as to minimize the cost of servicing this controller, but I’ll leave that
as an exercise for the student.  For now, we’ll follow the development used
for the &lt;a href=&quot;https://github.com/ZipCPU/s6soc&quot;&gt;S6SoC&lt;/a&gt;,
where the whole goal was to &lt;a href=&quot;/blog/2017/06/12/minimizing-luts.html&quot;&gt;minimize the amount of the
logic&lt;/a&gt;, and leave the
&lt;a href=&quot;/blog/2017/07/29/fifo.html&quot;&gt;FIFO&lt;/a&gt; out.&lt;/p&gt;

&lt;p&gt;If you’ve never built a
&lt;a href=&quot;/doc/wbspec_b4.pdf&quot;&gt;wishbone&lt;/a&gt;
slave before, you might wish to read our
&lt;a href=&quot;/zipcpu/2017/05/29/simple-wishbone.md&quot;&gt;previous discussion&lt;/a&gt;
as a background reference first.&lt;/p&gt;

&lt;p&gt;Our first task is going to be creating a reconfigurable sample rate.  In a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Pulse-width_modulation&quot;&gt;PWM&lt;/a&gt;
system, the sample rate is determined by the number of clocks per sample
duration.  We’ll call this number of samples &lt;code class=&quot;highlighter-rouge&quot;&gt;w_reload_value&lt;/code&gt;–something you’ve
already seen above.  The
&lt;a href=&quot;https://github.com/ZipCPU/wbpwmaudio/blob/master/rtl/wbpwmaudio.v&quot;&gt;wbpwmaudio&lt;/a&gt;
code offers two methods of setting this value.  These two methods are selectable
at design time via the &lt;code class=&quot;highlighter-rouge&quot;&gt;VARIABLE_RATE&lt;/code&gt; parameter.  If &lt;code class=&quot;highlighter-rouge&quot;&gt;VARIABLE_RATE&lt;/code&gt; is zero
(false), then the timer will always reload its value from a fixed
parameter value, &lt;code class=&quot;highlighter-rouge&quot;&gt;DEFAULT_RELOAD&lt;/code&gt;, at the end of every interval.  If
&lt;code class=&quot;highlighter-rouge&quot;&gt;VARIABLE_RATE&lt;/code&gt; is true, on the other hand, then the timer will reload its
value from a programmable register.&lt;/p&gt;

&lt;p&gt;Since we are using &lt;a href=&quot;http://zipcpu.com/doc/wbspec_b4.pdf&quot;&gt;wishbone&lt;/a&gt; control,
this register will need to be set from the bus any time &lt;code class=&quot;highlighter-rouge&quot;&gt;(i_wb_stb)&lt;/code&gt; is high,
indicating a bus cycle, &lt;code class=&quot;highlighter-rouge&quot;&gt;(i_wb_we)&lt;/code&gt; is high, indicating a bus write cycle, and
&lt;code class=&quot;highlighter-rouge&quot;&gt;(i_wb_addr)&lt;/code&gt; is high, indicating we are writing to the second of two
registers–the timer reload register.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;generate if (VARIABLE_RATE != 0)
begin
	reg	[(TIMING_BITS-1):0]	r_reload_value;
	initial	r_reload_value = DEFAULT_RELOAD;
	always @(posedge i_clk) // Data write
		if ((i_wb_stb)&amp;amp;&amp;amp;(i_wb_addr)&amp;amp;&amp;amp;(i_wb_we))
			r_reload_value &amp;lt;= i_wb_data[(TIMING_BITS-1):0];
	assign	w_reload_value = r_reload_value;
end else begin
	assign	w_reload_value = DEFAULT_RELOAD;
end endgenerate&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;We’ve already seen above how this affects our timer: when the timer runs out,
it gets reset with this value.  Likewise, &lt;code class=&quot;highlighter-rouge&quot;&gt;ztimer&lt;/code&gt; is set to be true any
time the timer has run out.&lt;/p&gt;

&lt;p&gt;This is also going to control when the design accepts the next sample:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	if (ztimer)
		sample_out &amp;lt;= next_sample;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;next_sample&lt;/code&gt; is a one-sample buffer.  It allows the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt;
or any other
&lt;a href=&quot;/blog/2017/06/08/simple-wb-master.html&quot;&gt;bus master&lt;/a&gt;ing
audio controller
a full sample interval in order to reload the value.&lt;/p&gt;

&lt;p&gt;Setting this one-sample buffer will be our next step.  In this case, we’ll
set it any time a bus write takes place &lt;code class=&quot;highlighter-rouge&quot;&gt;(i_wb_stb)&amp;amp;&amp;amp;(i_wb_we)&lt;/code&gt; to the
zero address of this port &lt;code class=&quot;highlighter-rouge&quot;&gt;(!i_wb_addr)&lt;/code&gt;.
Alternatively, if we are using a fixed sample rate, we’ll ignore the address
and just set the sample.  In this case, we’ll set the sample based upon the
16-bit sample value on the input
&lt;a href=&quot;/doc/wbspec_b4..pdf&quot;&gt;wishbone bus&lt;/a&gt;
data lines.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;initial	next_valid = 1&#39;b1;
initial	next_sample = 16&#39;h8000;
always @(posedge i_clk) // Data write
	if ((i_wb_stb)&amp;amp;&amp;amp;(i_wb_we)
			&amp;amp;&amp;amp;((!i_wb_addr)||(VARIABLE_RATE==0)))
	begin
		// Write with two&#39;s complement data, convert it
		// internally to binary offset
		next_sample &amp;lt;= { !i_wb_data[15], i_wb_data[14:0] };
		next_valid &amp;lt;= 1&#39;b1;
		if (i_wb_data[16])
			o_aux &amp;lt;= i_wb_data[(NAUX+20-1):20];
	end else if (ztimer)
		next_valid &amp;lt;= 1&#39;b0;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;There’s a couple things to notice here.  First, notice the negation of bit
fifteen–a 16-bit sample’s most significant bit.  This is the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Twos_complement&quot;&gt;two’s complement&lt;/a&gt;
sign bit.  Flipping the sign bit is the way to convert
&lt;a href=&quot;https://en.wikipedia.org/wiki/Twos_complement&quot;&gt;two’s complement&lt;/a&gt; values,
ranging from &lt;code class=&quot;highlighter-rouge&quot;&gt;-2^(N-1)&lt;/code&gt; to &lt;code class=&quot;highlighter-rouge&quot;&gt;2^(N-1)-1&lt;/code&gt; to the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Offset_binary&quot;&gt;offset binary&lt;/a&gt; values, ranging
from &lt;code class=&quot;highlighter-rouge&quot;&gt;0&lt;/code&gt; to &lt;code class=&quot;highlighter-rouge&quot;&gt;2^N-1&lt;/code&gt;, that a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Pulse-width_modulation&quot;&gt;PWM&lt;/a&gt;
modulator needs.  Second, you’ll want to notice the &lt;code class=&quot;highlighter-rouge&quot;&gt;next_valid&lt;/code&gt; logic.
This logic tells us whether or not the sample in our buffer is a valid
sample or not.  Upon any write, this value is set high to indicate we have a
valid sample in our buffer.  Whereas
any time the sample is moved from the one-sample buffer into the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Pulse-width_modulation&quot;&gt;PWM&lt;/a&gt;
modulation code as &lt;code class=&quot;highlighter-rouge&quot;&gt;sample_out&lt;/code&gt;, the &lt;code class=&quot;highlighter-rouge&quot;&gt;next_valid&lt;/code&gt; bit will be cleared to
indicate that there’s no valid sample in the buffer.&lt;/p&gt;

&lt;p&gt;In this code, &lt;code class=&quot;highlighter-rouge&quot;&gt;next_sample&lt;/code&gt; is set any time an audio sample is written to the
controller.  This is then fed to our output-sample value when the period
ends.  We’ll also note, upon setting this value, that the value is
valid (&lt;code class=&quot;highlighter-rouge&quot;&gt;next_valid&lt;/code&gt;).  We’ll keep this valid signal true until our &lt;code class=&quot;highlighter-rouge&quot;&gt;next_sample&lt;/code&gt;
value moves into the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Pulse-width_modulation&quot;&gt;PWM&lt;/a&gt;
output processing stage (above) as &lt;code class=&quot;highlighter-rouge&quot;&gt;sample_out&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;You may also notice the &lt;code class=&quot;highlighter-rouge&quot;&gt;o_aux&lt;/code&gt; value above.  I use the bits in &lt;code class=&quot;highlighter-rouge&quot;&gt;o_aux&lt;/code&gt; to
control two bits which can then be used to control the gain and shutdown pins
from within this controller.  So that we can choose whether or not to send
samples or updated control pins, we require that bit sixteen be set if you
want to update the control pins, otherwise we leave the control pins alone.&lt;/p&gt;

&lt;p&gt;At this point, we can move on and examine the values this controller
returns from the bus.  As in our &lt;a href=&quot;/zipcpu/2017/05/29/simple-wishbone.html&quot;&gt;first discussion of how to make a wishbone
peripheral&lt;/a&gt;,
we’ll set the bus output lines no matter whether we are writing or reading.
It just simplifies the logic.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;generate if (VARIABLE_RATE == 0)
begin
	assign o_wb_data = { {(12-NAUX){1&#39;b0}}, o_aux,
				3&#39;h0, o_int, sample_out };
end else begin
	reg	[31:0]	r_wb_data;
	always @(posedge i_clk)
		if (i_wb_addr)
			r_wb_data &amp;lt;= w_reload_value;
		else
			r_wb_data &amp;lt;= { {(12-NAUX){1&#39;b0}}, o_aux,
					3&#39;h0, o_int, sample_out };
	assign	o_wb_data = r_wb_data;
end endgenerate&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Selecting between which register to output took us one clock, so we’ll wait
one clock before acknowledge the clock in order to keep the acknowledgement
aligned with the data.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;initial	o_wb_ack = 1&#39;b0;
always @(posedge i_clk)
	o_wb_ack &amp;lt;= (i_wb_stb);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Further, the value(s) returned by this routine are always ready.  This routine
never has a reason to stall the bus.  (Repeated writes to the data register
will just over-write the buffer value.)  So, we’ll just keep the stall line low.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;assign	o_wb_stall = 1&#39;b0;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Finally, we’ll add in one further flair: an interrupt line to tell the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt;
when the buffer is no longer valid and can be refilled.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;assign	o_int &amp;lt;= (!next_valid);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;While I suppose
&lt;a href=&quot;/doc/wbspec_b4.pdf&quot;&gt;wishbone&lt;/a&gt;
support isn’t necessary for every core we present, this core already has it
and it was fun to present how a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Pulse-width_modulation&quot;&gt;PWM&lt;/a&gt;
generator might be created as a bus slave.&lt;/p&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;That just about wraps up this post!&lt;/p&gt;

&lt;p&gt;We’ve now gone over and discussed the traditional
&lt;a href=&quot;https://en.wikipedia.org/wiki/Pulse-width_modulation&quot;&gt;PWM&lt;/a&gt;
development, presenting how a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Pulse-width_modulation&quot;&gt;PWM&lt;/a&gt;
signal can be used as a cheap
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital-to-analog_converter&quot;&gt;digital to analog converter&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;We then presented a new approach to 
&lt;a href=&quot;https://en.wikipedia.org/wiki/Pulse-width_modulation&quot;&gt;PWM&lt;/a&gt;
that we called the “bit-reversed
&lt;a href=&quot;https://en.wikipedia.org/wiki/Pulse-width_modulation&quot;&gt;PWM&lt;/a&gt;”
approach.  We pointed out how this approach spreads the unwanted
&lt;a href=&quot;https://en.wikipedia.org/wiki/Pulse-width_modulation&quot;&gt;PWM&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Harmonic&quot;&gt;harmonic&lt;/a&gt;
energy into higher frequencies, relieving some of the stress on
the anti-aliasing filter.  This approach also separated the timer
determining the edges of the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Pulse-width_modulation&quot;&gt;PWM&lt;/a&gt;
signal from the sample generator, with the purpose of removing some of the
noise associated with the periodic signal associated with no signal.&lt;/p&gt;

&lt;p&gt;I have personally listened to the quality of the output of this amplifier.
My test signal has been a doorbell sound.  The doorbell comes out sounding
pure, with no noticable audio distortions.&lt;/p&gt;

&lt;p&gt;No, I’m not suggesting this is “professional” audio quality, but it is better
than the alternative.&lt;/p&gt;

&lt;p&gt;Perhaps I may encourage you to try &lt;a href=&quot;https://github.com/ZipCPU/wbpwmaudio&quot;&gt;this component
IP&lt;/a&gt;
yourself, to hear how it sounds?&lt;/p&gt;

&lt;p&gt;Hmm … perhaps I should show you instead how this component may be
simply and easily be integrated into a basic debugging bus, so that you
can hear the sound quality for yourself?  That will have to remain, though,
as a lesson for another day.&lt;/p&gt;

&lt;hr /&gt;&lt;p&gt;&lt;em&gt;And whosoever shall fall on this stone shall be broken: but on whomsoever it shall fall, it will grind him to powder.&lt;/em&gt;</description>
        <pubDate>Mon, 04 Sep 2017 00:00:00 -0400</pubDate>
        <link>http://zipcpu.com/dsp/2017/09/04/pwm-reinvention.html</link>
        <guid isPermaLink="true">http://zipcpu.com/dsp/2017/09/04/pwm-reinvention.html</guid>
        
        
        <category>dsp</category>
        
      </item>
    
      <item>
        <title>Big Money Engineering Integrity</title>
        <description>&lt;p&gt;Every now and then, the &lt;a href=&quot;&quot;&gt;ZipCPU blog&lt;/a&gt; includes a short
discussion on engineering ethics.  Our last post challenged you with the
question, &lt;a href=&quot;/blog/2017/08/12/caused-to-lie.html&quot;&gt;what would cause you to
lie&lt;/a&gt;?  Below is a
discussion from some of my own experience, illustrating the extent to which
an integrity problem can destroy the foundation of solid engineering.&lt;/p&gt;

&lt;p&gt;Before I started &lt;a href=&quot;/about/gisselquist-technology.html&quot;&gt;Gisselquist
Technology&lt;/a&gt;,
I had my own moral strength and integrity challenged.&lt;/p&gt;

&lt;p&gt;Many years ago, I was asked to join the government team managing a
multibillion dollar contract.  To protect the innocent, we’ll leave the name
of the project and the name of the office supporting it nameless.  Suffice
to say that I was working for a government procurement office.&lt;/p&gt;

&lt;p&gt;The director of my office asked me to examine the product that he was
responsible for procuring on behalf of the US government.  I was not asked
because it was my current job (I had been working on another team), but
rather
because of some heated disagreements over whether or not the product actually
worked.  Since my academic background was in a nearly related field, I was
deemed to be uniquely suited to evaluate the product that was being produced.&lt;/p&gt;

&lt;h2 id=&quot;what-my-research-revealed&quot;&gt;What my research revealed&lt;/h2&gt;

&lt;p&gt;As I started researching this program, its requirements and history, I quickly
discovered that the history of the program was quite colored.&lt;/p&gt;

&lt;table style=&quot;float: right&quot;&gt;&lt;caption&gt;Liar&#39;s Dilemma&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/integrity-big-money-liars-dilemma.svg&quot; alt=&quot;The liar&#39;s dilemma&quot; width=&quot;320&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;Interviews with the contractor revealed a history of employees getting
re-assigned or fired for telling the government procurement lead that the
product didn’t or wouldn’t work.  Those that remained, the ones I was able to
talk to, were very aware that remaining on the contract, indeed their very
job and livelihood, would only be possible if they said nothing about any
problems the system had.&lt;/p&gt;

&lt;p&gt;Those who worked for the contractor were both scared and morally scarred.
They were living under a lie and they knew it and didn’t like it.  However,
they felt trapped.  If they spoke up, they knew that they lose their jobs
and how would they then feed their family?&lt;/p&gt;

&lt;p&gt;The corruption wasn’t limited to the one office.  Rather, it spread throughout
the contractor’s facility, throughout the government procurement office, and
even into the leadership of those who were supposed to use this product.&lt;/p&gt;

&lt;p&gt;For example, all of the official program briefs presented glowing numbers
showing the amount of data the system could process.  The quantity was
deemed to make the program a success.  The program manager was very quick
to display all kinds of figures showing the massive amounts of data this
system produced.  However, he had no means of proving that any one of those
outputs were in fact correct.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Two views of whether or not the system worked&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/integrity-big-money-does-it-work.svg&quot; alt=&quot;Does it work?&quot; width=&quot;680&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;The actual user’s of the program, on the other hand, would present example
upon example demonstrating
the failures of the program.  However, without maintaining the data set that
created those failures, the failures could never be reproduced.  Since the
failures couldn’t be reproduced, they couldn’t be used as test cases and formed
ambiguous requests for improvement within the program office.  Further,
since the system was never tested against known inputs in conditions similar
to those that had caused known failures, it was impossible to know if the
failures were common behaviors, or just the one in a million rare example.&lt;/p&gt;

&lt;p&gt;The result was that any time the two offices got together, the meetings
could easily devolve into shouting matches.  It works!  It’s broken!
With no truth under-girding either argument, the two sides might just as well
have been arguing: &lt;a href=&quot;http://www.sportsonearth.com/article/63816024&quot;&gt;Taste’s great!  Less
filling!&lt;/a&gt;  There would have
been no difference in the result.&lt;/p&gt;

&lt;p&gt;This is the sad result of what happens when sound engineering practice is
abandoned.&lt;/p&gt;

&lt;p&gt;Rather than treating this as the integrity problem it was, the problem was
officially characterized as “political”.  By management fiat, I was instructed
and told that the problem had nothing to do with sound engineering practice.&lt;/p&gt;

&lt;p&gt;However, the problem was not “political” as my boss had instructed me.  The
problem was the result of the loss of the Godly integrity that forms the
foundation of sound engineering practice.&lt;/p&gt;

&lt;table style=&quot;float: right&quot;&gt;&lt;caption&gt;Does it work?&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/integrity-big-money-venn.svg&quot; alt=&quot;A Venn Diagram of Performance&quot; width=&quot;360&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;In the digital design world, we might say that the project didn’t include
any representative test-benches.  How was it tested, you ask, without
test-benches?  By comparing the system’s results before any software changes
to the results after the improvements.  But … which of those results were
actually correct?  No one knew.&lt;/p&gt;

&lt;p&gt;No one was placing known inputs into the device to measure whether or not it
was producing the correctly expected outputs.  This is the idea behind a
“ground truth” test.  Known inputs are measured against what should be known
outputs.  Differences are recorded, quantified, and reported on.&lt;/p&gt;

&lt;h2 id=&quot;ground-truth-testing&quot;&gt;Ground truth testing&lt;/h2&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;A Ground Truth Test&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/integrity-big-money-ground-truth.svg&quot; alt=&quot;Ground truth methodology outline&quot; width=&quot;680&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;A “ground truth” testing program that compared the output of this product
against an expected or “correct” output was called for.  Further, a library
of “ground truth” test cases having known inputs needed to be assembled that
would highlight any problems, and also allow the development team to fix
them.  The program basically needed test benches with physically realistic
inputs.&lt;/p&gt;

&lt;p&gt;With this goal in mind, I quickly assembled a small team and secured funding
for a project that would help to determine how the system actually performed
against known inputs.  We called it a “ground truth” testing program.  To my
surprise, the idea of “ground truth” testing program was not universally
acclaimed as good engineering.  Indeed, it was my own office that
considered the idea “controversial.”  I was told that such testing would be
a waste of precious dollars, and that it wouldn’t prove anything to those
that “didn’t like” the system.&lt;/p&gt;

&lt;p&gt;While this “ground truth” testing program was underway, a senior leadership
“taskforce” was appointed to fix all the system’s problems.  Management gave
them ninety days to be successful.  Reality,
though, is that years of engineering integrity problems are not easily fixed
in ninety days.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Project Timelines&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/integrity-big-money-timeline.svg&quot; alt=&quot;A timeline showing events&quot; width=&quot;680&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Think about that one: what would you do if &lt;em&gt;you&lt;/em&gt; were the one appointed to
a ninety day task force, and tasked with fixing problems that were the
result of years of integrity neglect?&lt;/p&gt;

&lt;p&gt;While I was not personally involved in this “taskforce”, I read with great
interest their results and conclusions.&lt;/p&gt;

&lt;p&gt;Much as one might expect, the “taskforce” declared the system fixed.
Had they compared the output of the system against known inputs?  No.&lt;/p&gt;

&lt;p&gt;Did the “task force” collect examples of inputs causing “known failures”,
apply fixes, and then run those same examples again to see if the result
got better?
No.  They applied fixes and tested the system with new data which may or may
not have had the original problem within it.  There was no
way to know if the fixes even worked.  Indeed, all those who weren’t
part of the senior leadership team were instructed to accept that the
problems had been fixed–independent of any real facts.&lt;/p&gt;

&lt;p&gt;This is not how you fix such a system.&lt;/p&gt;

&lt;p&gt;What the “task force” should have done would have been to first find data sets
that would have reproduced the problems, and then replayed those data sets
through the system later to see if any of the “fixes” worked.  Further,
their data sets needed to come with known answers–such as the “ground truth”
testing approach was working to create.&lt;/p&gt;

&lt;p&gt;When I saw the results of this senior leadership “taskforce”, I spoke up.  I
sent an internal memo to the rest of the procurement team outlining how the
process was broken.  I explained that the senior leadership “taskforce” hadn’t
demonstrated that they had fixed anything, since they had abandoned sound
engineering practice.  As I’m sure you can imagine, my office manager wasn’t
pleased with my views.  When he read this memo, he then called me into his
office and threatened me.  “You pull another stunt like this, and you will be
fired.”&lt;/p&gt;

&lt;p&gt;During this time, the ground truth testing effort continued.&lt;/p&gt;

&lt;p&gt;To illustrate how bad the environment was at the contractor’s facility,
they were making bets over when the ground truth project was going to be
killed by my management (in the procurement office).&lt;/p&gt;

&lt;p&gt;The procurement management team never liked the “ground truth” testing
approach, probably because they didn’t feel like they could control it’s
results.  Measurements are pesky things, and comparisons between system
outputs and known “correct” answers are hard to spin.  Indeed, the “ground
truth” testing project was nearly terminated once when the procurement
manager, whom I worked for, realized what I was up to.  (It was also nearly
terminated when he read the memo I referenced above.)&lt;/p&gt;

&lt;p&gt;As you might expect, testing a product in a way that it has never been tested
before will likely yield unexpected results.  This is normal.  This was the
result of the “ground truth” tests.&lt;/p&gt;

&lt;p&gt;The product itself was not irreversibly broken.  Sound engineering process,
built upon true engineering and integrity, would’ve fixed it.  The real
problem was that no one was using sound engineering principles because of the
lies and the fear involved.  True God given engineering integrity had been
lost.&lt;/p&gt;

&lt;p&gt;Sure enough, when the procurement manager read the “ground truth” report,
he didn’t like its results.  He then directed me to withhold these results
from the people who were going to use this product.&lt;/p&gt;

&lt;h2 id=&quot;the-aftermath&quot;&gt;The aftermath&lt;/h2&gt;

&lt;p&gt;This was about where the office’s &lt;a href=&quot;https://en.wikipedia.org/wiki/Office_of_Inspector_General_(United_States)&quot;&gt;Inspector General (IG)&lt;/a&gt; got involved.&lt;/p&gt;

&lt;p&gt;This was also the point where I learned the legal definition of the word
“fraud”.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Fraud is generally defined in the law as an intentional misrepresentation
of material existing fact made by one person
to another with knowledge of its falsity and for the
purpose of inducing the other person to act,
and upon which the other person relies with resulting injury
or damage.  Fraud may also be made by an omission or purposeful failure
to state material facts, which nondisclosure makes other statements
misleading.  &lt;a href=&quot;https://definitions.uslegal.com/fraud&quot;&gt;uslegal.com&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Let’s break this down into simpler terms.  I had created for my office a
“material fact”: the ground truth testing report.  By withholding this
fact from the operations office (fraud by omission) that was supposed to
accept our product, they had suffered “damage”: they were forced to accept
as operational a system that never passed a valid test.  This met the
legal definition of fraud.&lt;/p&gt;

&lt;p&gt;Following the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Office_of_Inspector_General_(United_States)&quot;&gt;IG&lt;/a&gt;’s
report, the program had a change of leadership.  Some individuals lost their
jobs.  Several individuals were quietly forced to retire.  I was also given my
one and only chance to brief the US Congress.  I would have rather had my
opportunity under more pleasurable circumstances.  However, I knew my duty.&lt;/p&gt;

&lt;p&gt;I also chose to leave that community and seek other work, so as to avoid
any ethical or whistle-blower issues.&lt;/p&gt;

&lt;p&gt;Since then, I have kept up with members of contractor’s office.  I have
thus kept track of what has happened after my departure.  A new management
team has been assigned to replace the old.  The new management team, though,
kept the same advisors from the last team.  The sad result is that the old
advisors convinced them to follow the same crooked path that had led them
into the mess in the first place.  As a result, this product is still built
upon lies, having no sound engineering integrity within it.&lt;/p&gt;

&lt;h2 id=&quot;breaking-the-liars-dilemma&quot;&gt;Breaking the Liar’s Dilemma&lt;/h2&gt;

&lt;p&gt;Throughout this whole process, I would constantly explain to my team that
your actions should all depend upon your judge.  If the boss is your judge,
do as he tells you to do.  If the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Office_of_Inspector_General_(United_States)&quot;&gt;IG&lt;/a&gt;
or Congress will be your judge, act so as to impress them.  On the otherhand,
if anticipate that God will be your judge, then don’t worry about the boss, the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Office_of_Inspector_General_(United_States)&quot;&gt;IG&lt;/a&gt;,
or Congress: focus your life on pleasing God.&lt;/p&gt;

&lt;p&gt;What about the liar’s dilemma?&lt;/p&gt;

&lt;p&gt;Jesus provides some clear guidance:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Therefore take no thought, saying, What shall we eat? or, What shall we
drink? or, Wherewithal shall we be clothed? (For after all these things
do the Gentiles seek:) for your heavenly Father knoweth that ye have
need of all these things.  But seek ye first the kingdom of God, and his
righteousness; and all these things shall be added unto you.
Take therefore no thought for the morrow: for the morrow shall take thought
for the things of itself. Sufficient unto the day is the evil thereof.
(&lt;a href=&quot;https://www.blueletterbible.org/kjv/mat/6/33&quot;&gt;Matt 6:31-34&lt;/a&gt;)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Indeed, this guidance breaks the trap of the liar’s dilemma.  In this verse,
Jesus promises that God will provide and all we need to do is to “seek first
the kingdom of God”.  The big problem with the liar’s dilemma is that
those caught within it believe that their life will be worse, if not even
destroyed, if they do not lie.  Yet for those willing to trust Jesus at His
word, they will learn that this is never the case.&lt;/p&gt;

&lt;p&gt;I read these verses many times during my work on this project.&lt;/p&gt;

&lt;p&gt;Yes, I have left that job and that twisted work environment.  No, I am not
making the “big bucks” today, but I did manage to leave with my integrity.
Thanks be to God.&lt;/p&gt;
&lt;hr /&gt;&lt;p&gt;&lt;em&gt;Better is the poor that walketh in his integrity, than he that is perverse in his lips, and is a fool.&lt;/em&gt;</description>
        <pubDate>Sat, 02 Sep 2017 00:00:00 -0400</pubDate>
        <link>http://zipcpu.com/blog/2017/09/02/big-money-integrity.html</link>
        <guid isPermaLink="true">http://zipcpu.com/blog/2017/09/02/big-money-integrity.html</guid>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>CORDIC part two: rectangular to polar conversion</title>
        <description>&lt;p&gt;We’ve now discussed three methods of generating sine waves: &lt;a href=&quot;/dsp/2017/07/11/simplest-sinewave-generator.html&quot;&gt;a simple table
lookup
approach&lt;/a&gt;,
&lt;a href=&quot;/dsp/2017/08/26/quarterwave.html&quot;&gt;a quarter wave table
lookup approach&lt;/a&gt;,
and most recently
&lt;a href=&quot;/dsp/2017/08/30/cordic.html&quot;&gt;a CORDIC approach&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Today, let’s take another look at the
&lt;a href=&quot;/dsp/2017/08/30/cordic.html&quot;&gt;CORDIC&lt;/a&gt;
approach.  In particular, the
&lt;a href=&quot;/dsp/2017/08/30/cordic.html&quot;&gt;CORDIC&lt;/a&gt;
algorithm can also be used in “reverse”–not to rotate a
vector by some amount, but rather to find out what angular rotation that
vector has as in Fig 1.&lt;/p&gt;

&lt;table style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 1: Using a CORDIC for rectangular to polar conversion&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/topolar-problem-setup.svg&quot; alt=&quot;Using a CORDIC for rectangular to polar conversion&quot; width=&quot;320&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;This “reverse” CORDIC can be used as a complex signal magnitude detector,
as well as an arctangent calculator.  This arctangent calculator can be used
as a &lt;a href=&quot;https://en.wikipedia.org/wiki/Phase_detector&quot;&gt;phase-detector&lt;/a&gt; within a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Phase-locked_loop&quot;&gt;phase locked loop&lt;/a&gt;.
Indeed, today’s 
&lt;a href=&quot;https://en.wikipedia.org/wiki/CORDIC&quot;&gt;CORDIC&lt;/a&gt;
algorithm can be an important part of any
&lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency_modulation&quot;&gt;FM&lt;/a&gt;,
or &lt;a href=&quot;https://en.wikipedia.org/wiki/Amplitude_modulation&quot;&gt;AM&lt;/a&gt;
signal &lt;a href=&quot;https://en.wikipedia.org/wiki/Demodulation&quot;&gt;demodulator&lt;/a&gt;.
You might even use this approach to build an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Electronic_tuner&quot;&gt;audio tuner&lt;/a&gt;–so that you can
tell if your musical instrument’s are “in tune”.&lt;/p&gt;

&lt;p&gt;To get there, though, we’re going to need to learn how to run the
&lt;a href=&quot;https://en.wikipedia.org/wiki/CORDIC&quot;&gt;CORDIC&lt;/a&gt;
in the rectangular to polar conversion mode.&lt;/p&gt;

&lt;p&gt;We’ll use the same
&lt;a href=&quot;https://en.wikipedia.org/wiki/CORDIC&quot;&gt;CORDIC&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Rotation_matrix&quot;&gt;rotation matrices&lt;/a&gt;
&lt;a href=&quot;/dsp/2017/08/30/cordic.html&quot;&gt;as before&lt;/a&gt;.
Indeed, many parts and pieces of today’s algorithm are nearly identical
to &lt;a href=&quot;/dsp/2017/08/30/cordic.html&quot;&gt;our last discussion&lt;/a&gt;:
we’ll need to expand our variables by one bit as before (to &lt;code class=&quot;highlighter-rouge&quot;&gt;e_xval&lt;/code&gt; and
&lt;code class=&quot;highlighter-rouge&quot;&gt;e_yval&lt;/code&gt;),
we’ll need to declare variables for every stage (&lt;code class=&quot;highlighter-rouge&quot;&gt;xv&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;yv&lt;/code&gt;, and &lt;code class=&quot;highlighter-rouge&quot;&gt;ph&lt;/code&gt;),
we’ll need to calculate  our &lt;code class=&quot;highlighter-rouge&quot;&gt;cordic_angle&lt;/code&gt;s and CORDIC gain as before (we
can even use the same &lt;a href=&quot;https://github.com/ZipCPU/cordic/blob/master/sw/cordiclib.cpp&quot;&gt;C++
code&lt;/a&gt;,
and we’ll offer to insert some “traveling CE” &lt;a href=&quot;/blog/2017/08/14/strategies-for-pipelining.html&quot;&gt;pipeline
logic&lt;/a&gt;
just as before.
If you aren’t familiar with any of these parts of the algorithm, please check
out our &lt;a href=&quot;/dsp/2017/08/30/cordic.html&quot;&gt;last post&lt;/a&gt; for reference.&lt;/p&gt;

&lt;p&gt;Today we’ll focus on the differences between this application of the
&lt;a href=&quot;https://en.wikipedia.org/wiki/CORDIC&quot;&gt;CORDIC&lt;/a&gt;
and
&lt;a href=&quot;/dsp/2017/08/30/cordic.html&quot;&gt;our last one&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Indeed, there are really only three things we need to do different.
We’ll start off our discussion with a brief recap of how the process works
in general.  Then we’ll get into the three basic changes, illustrating the
changes with examples of
&lt;a href=&quot;https://github.com/ZipCPU/cordic/blob/master/rtl/topolar.v&quot;&gt;working code&lt;/a&gt;.
The first change will be how we map our input to plus or minus forty five
degrees in a different fashion from before.  The second change will be 
adjusting how the
&lt;a href=&quot;https://en.wikipedia.org/wiki/CORDIC&quot;&gt;CORDIC&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Rotation_matrix&quot;&gt;rotations&lt;/a&gt;
are applied, based upon a different method of choosing which rotation.
Finally, the variable(s) that need to be
&lt;a href=&quot;/dsp/2017/07/22/rounding.html&quot;&gt;rounded&lt;/a&gt;
will change at the end as well.&lt;/p&gt;

&lt;h2 id=&quot;how-the-process-works&quot;&gt;How the process works&lt;/h2&gt;

&lt;p&gt;When we used the
&lt;a href=&quot;https://en.wikipedia.org/wiki/CORDIC&quot;&gt;CORDIC&lt;/a&gt;
algorithm
&lt;a href=&quot;/dsp/2017/08/30/cordic.html&quot;&gt;before&lt;/a&gt;,
we were given a two-dimensional vector, &lt;code class=&quot;highlighter-rouge&quot;&gt;i_xval&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;i_yval&lt;/code&gt;, and tasked
with rotating it in the Counter-Clockwise (CCW) direction by some given
&lt;a href=&quot;/dsp/2017/06/15/no-pi-for-you.html&quot;&gt;phase&lt;/a&gt;,
&lt;code class=&quot;highlighter-rouge&quot;&gt;i_phase&lt;/code&gt;.  For today’s conversion, we’ll start with a given
two-dimensional vector again, but this time we’re going to measure how far this
vector needs to be rotated in the clockwise (CW) direction until it lies on the
positive x-axis as shown in Fig 1 above.  The
&lt;a href=&quot;/dsp/2017/06/15/no-pi-for-you.html&quot;&gt;angle&lt;/a&gt;
we measure will then be produced on the output, and called &lt;code class=&quot;highlighter-rouge&quot;&gt;o_phase&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Hence, any time our vector is below the x-axis, &lt;code class=&quot;highlighter-rouge&quot;&gt;yv &amp;lt; 0&lt;/code&gt;, we’ll rotate our
vector in the CCW direction.  In a similar fashion, any
time our vector is at or above the x-axis, &lt;code class=&quot;highlighter-rouge&quot;&gt;yv &amp;gt;= 0&lt;/code&gt;, we’ll rotate in the CW
direction.  In both cases, we’ll adjust the
&lt;a href=&quot;/dsp/2017/06/15/no-pi-for-you.html&quot;&gt;phase&lt;/a&gt;
accumulator, &lt;code class=&quot;highlighter-rouge&quot;&gt;ph&lt;/code&gt;, but unlike
&lt;a href=&quot;/dsp/2017/08/30/cordic.html&quot;&gt;before&lt;/a&gt;
we won’t use the
&lt;a href=&quot;/dsp/2017/06/15/no-pi-for-you.html&quot;&gt;phase&lt;/a&gt;
to determine which direction to rotate.&lt;/p&gt;

&lt;p&gt;You may recall from our
&lt;a href=&quot;/dsp/2017/08/30/cordic.html&quot;&gt;previous post&lt;/a&gt;
that the
&lt;a href=&quot;https://en.wikipedia.org/wiki/CORDIC&quot;&gt;CORDIC&lt;/a&gt;
transformation matrix is given by,&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/eqn-bare-cordic-transform.png&quot; alt=&quot;EQN for a bare cordic stage&quot; width=&quot;281&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;This transformation matrix has the unique property that it can be applied
to an x and y coordinate vector without requiring any hardware multiplies
to calculate the result.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/eqn-cordic-eqns.png&quot; alt=&quot;Cordic equations&quot; width=&quot;350&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;We’ve also &lt;a href=&quot;/dsp/2017/08/30/cordic.html&quot;&gt;discussed&lt;/a&gt;
how this coordinate transformation can be rearranged to look like a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Rotation_matrix&quot;&gt;rotation matrix&lt;/a&gt;,&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/eqn-cordic-transform-simplified.png&quot; alt=&quot;Eqn for the cordic stage, after simplification&quot; width=&quot;459&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;where&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/eqn-cordic-phase.png&quot; alt=&quot;Cordic rotation phase&quot; width=&quot;168&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Likewise, if you switch the sign of the
&lt;a href=&quot;/dsp/2017/06/15/no-pi-for-you.html&quot;&gt;angle&lt;/a&gt;, the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Rotation_matrix&quot;&gt;rotation&lt;/a&gt;
is easily reversed.  The resulting transform looks almost identical, save
for a couple of sign differences,&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/eqn-cordic-negative-transform.png&quot; alt=&quot;Eqn for the cordic stage, negated angle, after simplification&quot; width=&quot;459&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;For this algorithm, we’ll apply a series of
&lt;a href=&quot;https://en.wikipedia.org/wiki/CORDIC&quot;&gt;CORDIC&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Rotation_matrix&quot;&gt;rotation matrices&lt;/a&gt;
to our input vector until the &lt;code class=&quot;highlighter-rouge&quot;&gt;y&lt;/code&gt; value lies on the x-axis.
If you’d like, you can follow along the discussion that follows while
looking at the Verilog &lt;a href=&quot;https://github.com/ZipCPU/cordic/blob/master/rtl/topolar.v&quot;&gt;code for this operation
here&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;the-preliminary-stage&quot;&gt;The preliminary stage&lt;/h2&gt;

&lt;p&gt;You may remember from
&lt;a href=&quot;/dsp/2017/08/30/cordic.html&quot;&gt;before&lt;/a&gt;
that the maximum
&lt;a href=&quot;https://en.wikipedia.org/wiki/CORDIC&quot;&gt;CORDIC&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Rotation_matrix&quot;&gt;rotation&lt;/a&gt;
is +/- 45 degrees.  We’d like to create an algorithm that works
for all
&lt;a href=&quot;/dsp/2017/06/15/no-pi-for-you.html&quot;&gt;angles&lt;/a&gt;.
That means we’re going to need to a preliminary rotation step to bring us to
within +/- 45 degrees of the x-axis, as shown in Fig 2.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 2: Pre-rotation results&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/topolar-prerotation.svg&quot; alt=&quot;The CORDIC pre-rotation step, converting to +/- 45 degrees&quot; width=&quot;520&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;table style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 3: Pre-rotation to +/- 45 degrees&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/topolar-prequadrants.svg&quot; alt=&quot;Using a CORDIC for rectangular to polar conversion&quot; width=&quot;320&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;Unlike &lt;a href=&quot;/dsp/2017/08/30/cordic.html&quot;&gt;the last time&lt;/a&gt;,
we can’t use the &lt;code class=&quot;highlighter-rouge&quot;&gt;i_phase&lt;/code&gt;
&lt;a href=&quot;/dsp/2017/06/15/no-pi-for-you.html&quot;&gt;angle&lt;/a&gt;
to define this initial rotation, since the
&lt;a href=&quot;/dsp/2017/06/15/no-pi-for-you.html&quot;&gt;phase&lt;/a&gt;
is something we are trying to calculate.
Instead, we’ll use the signs of the initial vector, &lt;code class=&quot;highlighter-rouge&quot;&gt;i_xval, i_yval&lt;/code&gt; to
determine our pre-rotation coordinate conversion.  This leads us to a
pre-rotation step that looks like Fig 3.&lt;/p&gt;

&lt;p&gt;Notice from the figures that our initial rotation areas are aligned on
multiples of ninety degrees.  This is a result of starting with the signs of
&lt;code class=&quot;highlighter-rouge&quot;&gt;i_xval&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;i_yval&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;You may find that the
&lt;a href=&quot;https://github.com/ZipCPU/cordic/blob/master/rtl/topolar.v&quot;&gt;code&lt;/a&gt;
for this initial rotation looks very similar to the
&lt;a href=&quot;https://github.com/ZipCPU/cordic/blob/master/rtl/cordic.v&quot;&gt;code&lt;/a&gt; we presented
in our &lt;a href=&quot;/dsp/2017/08/30/cordic.html&quot;&gt;original CORDIC post&lt;/a&gt;.
Unlike &lt;a href=&quot;/dsp/2017/08/30/cordic.html&quot;&gt;the last time&lt;/a&gt;,
this pre-rotation requires &lt;em&gt;adding&lt;/em&gt; the (potentially 
negated) &lt;code class=&quot;highlighter-rouge&quot;&gt;x&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;y&lt;/code&gt; values together to accomplish the rotation.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;// First stage, map to within +/- 45 degrees
always @(posedge i_clk)
if (i_ce)
	case({i_xval[IW-1], i_yval[IW-1]})
	2&#39;b01: begin // Rotate by -315 degrees
		xv[0] &amp;lt;=  e_xval - e_yval;
		yv[0] &amp;lt;=  e_xval + e_yval;
		ph[0] &amp;lt;= 19&#39;h70000;
		end
	2&#39;b10: begin // Rotate by -135 degrees
		xv[0] &amp;lt;= -e_xval + e_yval;
		yv[0] &amp;lt;= -e_xval - e_yval;
		ph[0] &amp;lt;= 19&#39;h30000;
		end
	2&#39;b11: begin // Rotate by -225 degrees
		xv[0] &amp;lt;= -e_xval - e_yval;
		yv[0] &amp;lt;=  e_xval - e_yval;
		ph[0] &amp;lt;= 19&#39;h50000;
		end
	// 2&#39;b00:
	default: begin // Rotate by -45 degrees
		xv[0] &amp;lt;=  e_xval + e_yval;
		yv[0] &amp;lt;= -e_xval + e_yval;
		ph[0] &amp;lt;= 19&#39;h10000;
		end
	endcase&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;That’s the pre-rotation step.  We’re now within forty five degrees of the
final “correct” answer.&lt;/p&gt;

&lt;h2 id=&quot;rotating-the-vector-towards-zero&quot;&gt;Rotating the vector towards zero&lt;/h2&gt;

&lt;p&gt;Having accomplished the pre-rotation step, it’s now time for the guts of the
algorithm.  The algorithm starts out identical to the last time, with a
generate statement and a for loop across stages.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;genvar	i;
generate for(i=0; i&amp;lt;NSTAGES; i=i+1) begin : TOPOLARloop
	always @(posedge i_clk)&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;When you get to the actual implementation of the
&lt;a href=&quot;https://en.wikipedia.org/wiki/CORDIC&quot;&gt;CORDIC&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Rotation_matrix&quot;&gt;rotations&lt;/a&gt;
themselves, the big difference between this section of code and the previous
one is the dependence upon the sign of &lt;code class=&quot;highlighter-rouge&quot;&gt;yv&lt;/code&gt; rather than the sign of the
remaining
&lt;a href=&quot;/dsp/2017/06/15/no-pi-for-you.html&quot;&gt;phase angle&lt;/a&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;ph&lt;/code&gt;.  If the sign is negative, apply the
&lt;a href=&quot;https://en.wikipedia.org/wiki/CORDIC&quot;&gt;CORDIC&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Rotation_matrix&quot;&gt;rotation&lt;/a&gt;
in the CCW direction,
otherwise rotate CW.  In both cases, we’ll accumulate the rotation amount
in the
&lt;a href=&quot;/dsp/2017/06/15/no-pi-for-you.html&quot;&gt;phase&lt;/a&gt;
variable, &lt;code class=&quot;highlighter-rouge&quot;&gt;ph&lt;/code&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	if (i_ce)
	begin
		if (yv[i][(WW-1)]) // Below the axis
		begin
			// If the vector is below the x-axis, rotate by
			// the CORDIC angle in a positive direction.
			xv[i+1] &amp;lt;= xv[i] - (yv[i]&amp;gt;&amp;gt;&amp;gt;(i+1));
			yv[i+1] &amp;lt;= yv[i] + (xv[i]&amp;gt;&amp;gt;&amp;gt;(i+1));
			ph[i+1] &amp;lt;= ph[i] - cordic_angle[i];
		end else begin
			// On the other hand, if the vector is above the
			// x-axis, then rotate in the other direction
			xv[i+1] &amp;lt;= xv[i] + (yv[i]&amp;gt;&amp;gt;&amp;gt;(i+1));
			yv[i+1] &amp;lt;= yv[i] - (xv[i]&amp;gt;&amp;gt;&amp;gt;(i+1));
			ph[i+1] &amp;lt;= ph[i] + cordic_angle[i];
		end
	end
end endgenerate&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;When we are all done, the amount of
&lt;a href=&quot;/dsp/2017/06/15/no-pi-for-you.html&quot;&gt;phase&lt;/a&gt;
rotation that we’ve applied can be
found in &lt;code class=&quot;highlighter-rouge&quot;&gt;ph&lt;/code&gt;, while the magnitude of the resulting vector can be found in
&lt;code class=&quot;highlighter-rouge&quot;&gt;xv&lt;/code&gt;.  The y-value, &lt;code class=&quot;highlighter-rouge&quot;&gt;yv&lt;/code&gt;, for the final stage should also be zero or nearly
so, making it irrelevant.  Our next step will be to round this value to the
desired number of output bits, and return the result.&lt;/p&gt;

&lt;h2 id=&quot;rounding-the-result&quot;&gt;Rounding the result&lt;/h2&gt;

&lt;p&gt;Some time back, we discussed the &lt;a href=&quot;/dsp/2017/07/22/rounding.html&quot;&gt;serious problems that can be associated
with truncation&lt;/a&gt;.  Ever
since, &lt;a href=&quot;/dsp/2017/07/22/rounding.html&quot;&gt;I’ve recommended convergent
convergent rounding&lt;/a&gt;
whenever the number of bits in a value needs to be lowered.  Therefore, as a
last step, we’ll apply
convergent rounding
to our magnitude value, &lt;code class=&quot;highlighter-rouge&quot;&gt;xv&lt;/code&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;assign	pre_mag = xv[NSTAGES] + { {(OW){1&#39;b0} },
			xv[NSTAGES][(WW-OW)],
			{(WW-OW-1){!xv[NSTAGES][WW-OW]}}};

always @(posedge i_clk)
if (i_ce)
begin
	o_mag   &amp;lt;= pre_mag[(WW-1):(WW-OW)];
	o_phase &amp;lt;= ph[NSTAGES];
end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Notice that we didn’t apply any
&lt;a href=&quot;/dsp/2017/07/22/rounding.html&quot;&gt;rounding&lt;/a&gt;
to our
&lt;a href=&quot;/dsp/2017/06/15/no-pi-for-you.html&quot;&gt;phase angle&lt;/a&gt;
result.  That’s because we’ve never dropped bits in the
&lt;a href=&quot;/dsp/2017/06/15/no-pi-for-you.html&quot;&gt;phase angle&lt;/a&gt;.
Indeed, the number of
&lt;a href=&quot;/dsp/2017/06/15/no-pi-for-you.html&quot;&gt;phase&lt;/a&gt;
bits has been constant at &lt;code class=&quot;highlighter-rouge&quot;&gt;PW&lt;/code&gt; throughout the algorithm.&lt;/p&gt;

&lt;p&gt;This is the last of the three differences between today’s development and the
&lt;a href=&quot;/dsp/2017/08/30/cordic.html&quot;&gt;CORDIC agorithm&lt;/a&gt;
we presented last time.  At this point, our development is complete.
As with the basic
&lt;a href=&quot;/dsp/2017/08/30/cordic.html&quot;&gt;CORDIC agorithm&lt;/a&gt;,
this one will also use a
&lt;a href=&quot;https://github.com/ZipCPU/cordic/tree/master/sw&quot;&gt;core generator&lt;/a&gt;–however
the changes necessary to make that
&lt;a href=&quot;https://github.com/ZipCPU/cordic/tree/master/sw&quot;&gt;core generator&lt;/a&gt;–however
work were just presented above.&lt;/p&gt;

&lt;p&gt;Feel free to check out the
&lt;a href=&quot;https://github.com/ZipCPU/cordic/tree/master/sw&quot;&gt;core generator&lt;/a&gt;
as well as the &lt;a href=&quot;https://github.com/ZipCPU/cordic/tree/master/rtl&quot;&gt;examples of the code it
produces&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;Now that we’ve gone through and explained the differences between
the &lt;a href=&quot;/dsp/2017/08/30/cordic.html&quot;&gt;CORDIC rotation agorithm&lt;/a&gt;
and this rectangular to polar converter,
we’ve now finished presenting the basic uses of the
&lt;a href=&quot;https://en.wikipedia.org/wiki/CORDIC&quot;&gt;CORDIC&lt;/a&gt;
algorithm.&lt;/p&gt;

&lt;p&gt;While we haven’t discussed the code generator for this rectangular to polar
converter, it follows from the discussion above.  You can find the &lt;a href=&quot;https://github.com/ZipCPU/cordic/blob/master/sw/topolar.cpp&quot;&gt;completed
core generator on
github&lt;/a&gt;, as
part of the &lt;a href=&quot;https://github.com/ZipCPU/cordic&quot;&gt;CORDIC repository&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;If you refer back to
&lt;a href=&quot;http://www.andraka.com/files/crdcsrvy.pdf&quot;&gt;Ray Andraka’s paper&lt;/a&gt;,
Andraka shows several other uses for a basic
&lt;a href=&quot;https://en.wikipedia.org/wiki/CORDIC&quot;&gt;CORDIC&lt;/a&gt;
algorithmic approach: 
arcsine and arccosine generation, calculating hyperbolic trigonometric
functions and more.  Feel free to do some research should you need algorithms
for any of these other functions.&lt;/p&gt;

&lt;p&gt;Our development, though, is by no means complete.  Our next step in this
development will be to build a test bench for these routines.  We may even
go as far as to connect our sine/cosine generator to an
&lt;a href=&quot;https://store.digilentinc.com/pmod-amp2-audio-amplifier&quot;&gt;audio amplifier&lt;/a&gt;,
but we’ll see how the direction works out.  Our eventual goal, though, is
going to be to use the
&lt;a href=&quot;/dsp/2017/08/30/cordic.html&quot;&gt;sine and cosine generation&lt;/a&gt;
capability of the
&lt;a href=&quot;https://en.wikipedia.org/wiki/CORDIC&quot;&gt;CORDIC&lt;/a&gt;
as part of a test bench for the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;digital filter&lt;/a&gt;s
I’d like to present and demonstrate.&lt;/p&gt;
&lt;hr /&gt;&lt;p&gt;&lt;em&gt;For the eyes of the LORD run to and fro throughout the whole earth, to shew himself strong in the behalf of them whose heart is perfect toward him. Herein thou hast done foolishly: therefore from henceforth thou shalt have wars. (1 Chron 16:9)&lt;/em&gt;</description>
        <pubDate>Fri, 01 Sep 2017 00:00:00 -0400</pubDate>
        <link>http://zipcpu.com/dsp/2017/09/01/topolar.html</link>
        <guid isPermaLink="true">http://zipcpu.com/dsp/2017/09/01/topolar.html</guid>
        
        
        <category>dsp</category>
        
      </item>
    
      <item>
        <title>Using a CORDIC to calculate sines and cosines in an FPGA</title>
        <description>&lt;p&gt;We’ve now presented two separate algorithms that can be used for calculating
a sine wave: a &lt;a href=&quot;/dsp/2017/07/11/simplest-sinewave-generator.html&quot;&gt;very simple sinewave table
lookup&lt;/a&gt;,
and a &lt;a href=&quot;/dsp/2017/08/26/quarterwave.html&quot;&gt;more complicated quarter-wave table lookup
method&lt;/a&gt;.  Both of these
approaches used only a minimum number of clocks, although their precision
was somewhat limited.&lt;/p&gt;

&lt;p&gt;Today, let’s look at how to implement a
&lt;a href=&quot;https://en.wikipedia.org/wiki/CORDIC&quot;&gt;&lt;strong&gt;CO&lt;/strong&gt;ordinate &lt;strong&gt;R&lt;/strong&gt;otation &lt;strong&gt;DI&lt;/strong&gt;gital &lt;strong&gt;C&lt;/strong&gt;omputer
(CORDIC)&lt;/a&gt;
algorithm within an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;.&lt;/p&gt;

&lt;table style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 1: The CORDIC problem description&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/cordic-problem-setup.svg&quot; alt=&quot;Setting up a CORDIC&quot; width=&quot;320&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;If you’ve never worked with a
&lt;a href=&quot;https://en.wikipedia.org/wiki/CORDIC&quot;&gt;CORDIC&lt;/a&gt;
algorithm before, the algorithms are all
based around specific
&lt;a href=&quot;https://en.wikipedia.org/wiki/Rotation_matrix&quot;&gt;rotation matrices&lt;/a&gt;
which we will explain first.  These rotation matrices can be strung together
to accomplish many digital logic purposes.  For today’s discussion, though,
we will be rotating a two-dimensional vector by a requested counter-clockwise
angle.  Thus, the inputs will be x and y values, &lt;code class=&quot;highlighter-rouge&quot;&gt;i_xval&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;i_yval&lt;/code&gt;,
together with a requested phase rotation, &lt;code class=&quot;highlighter-rouge&quot;&gt;i_phase&lt;/code&gt;, whereas the outputs
will just be a rotated x and y value, &lt;code class=&quot;highlighter-rouge&quot;&gt;o_xval&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;o_yval&lt;/code&gt;–as shown in
Fig 1.&lt;/p&gt;

&lt;h1 id=&quot;the-cordic-rotation&quot;&gt;The CORDIC rotation&lt;/h1&gt;

&lt;p&gt;But, just what is a
&lt;a href=&quot;https://en.wikipedia.org/wiki/CORDIC&quot;&gt;CORDIC&lt;/a&gt;
rotation?  Well, since all of these algorithms are built around a
&lt;a href=&quot;https://en.wikipedia.org/wiki/CORDIC&quot;&gt;CORDIC&lt;/a&gt;
rotation, let’s start by answering that question.  We’ll start with the
concept of a simple two-dimensional
&lt;a href=&quot;https://en.wikipedia.org/wiki/Rotation_matrix&quot;&gt;rotation matrix&lt;/a&gt;,
and then work from there to how that can be turned into a
&lt;a href=&quot;https://en.wikipedia.org/wiki/CORDIC&quot;&gt;CORDIC&lt;/a&gt;
rotation.&lt;/p&gt;

&lt;p&gt;A simple two-dimensional
&lt;a href=&quot;https://en.wikipedia.org/wiki/Rotation_matrix&quot;&gt;rotation matrix&lt;/a&gt;
is given by:&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/eqn-2d-rotation.png&quot; alt=&quot;Equation for a 2D rotation&quot; width=&quot;302&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;This rotation can be used to rotate a complex vector &lt;code class=&quot;highlighter-rouge&quot;&gt;exp(j*phi)&lt;/code&gt; and turn it
into another one, &lt;code class=&quot;highlighter-rouge&quot;&gt;exp(j*(phi+theta))&lt;/code&gt;, if the real value is the first value
in the given vector, and the would-be imaginary value the second (i.e. strip off
the &lt;code class=&quot;highlighter-rouge&quot;&gt;j&lt;/code&gt;).  Further, if the original vector is
simply the real number one, &lt;code class=&quot;highlighter-rouge&quot;&gt;1+j0&lt;/code&gt;, then we will have just created
&lt;code class=&quot;highlighter-rouge&quot;&gt;sin(theta)&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;cos(theta)&lt;/code&gt; in this process.&lt;/p&gt;

&lt;p&gt;This is what we are going to try to do: apply a rotation like this one.&lt;/p&gt;

&lt;p&gt;We could apply this rotation using &lt;a href=&quot;/dsp/2017/06/15/no-pi-for-you.html&quot;&gt;angles more
suited&lt;/a&gt;
for an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;,&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/eqn-no-pi-rotation.png&quot; alt=&quot;Eqn for a 2D rotation in FPGA units&quot; width=&quot;364&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;but this still leaves us with the problem that the sine and cosine aren’t
easy to calculate, leaving this rotation difficult to accomplish.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 1: CORDIC Rotation Vectors&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/cordic-rotations.svg&quot; alt=&quot;Cordic rotation vectors&quot; width=&quot;240&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;The
&lt;a href=&quot;https://en.wikipedia.org/wiki/CORDIC&quot;&gt;CORDIC&lt;/a&gt;
approach is to replace the cosine portion of this rotation matrix with a &lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt;,
and the sine portion with a &lt;code class=&quot;highlighter-rouge&quot;&gt;2^-k&lt;/code&gt;.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/eqn-bare-cordic-transform.png&quot; alt=&quot;EQN for a bare cordic stage&quot; width=&quot;281&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;You can think of this as a series of complex rotation vectors,
indexed by &lt;code class=&quot;highlighter-rouge&quot;&gt;k&lt;/code&gt;, such as those are shown in Fig 1.  Notice from the figure
that these vectors are not on the unit circle, but rather just outside the
unit circle, and they get closer and closer to the unit circle the higher
&lt;code class=&quot;highlighter-rouge&quot;&gt;k&lt;/code&gt; becomes.&lt;/p&gt;

&lt;p&gt;In other words, &lt;code class=&quot;highlighter-rouge&quot;&gt;T&lt;/code&gt; is approximately a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Rotation_matrix&quot;&gt;rotation matrix&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;T&lt;/code&gt; is also something that is easy to calculate within an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;.
It requires only adds, subtracts, and shifts.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/eqn-cordic-eqns.png&quot; alt=&quot;Cordic equations&quot; width=&quot;350&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;This can all be done with simple integer math–no multiplies or divides are
required.&lt;/p&gt;

&lt;p&gt;Of course, this transform is not a true rotation matrix.  Instead, it is a
scaled &lt;a href=&quot;https://en.wikipedia.org/wiki/Rotation_matrix&quot;&gt;rotation matrix&lt;/a&gt;.
To see this, first calculate the angles of the vectors in Fig 1 above:&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/eqn-cordic-phase.png&quot; alt=&quot;Cordic rotation phase&quot; width=&quot;168&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Then also calculate and normalize by their their lengths.  The resulting
transform, &lt;code class=&quot;highlighter-rouge&quot;&gt;T&lt;/code&gt;, is shown below:&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/eqn-cordic-transform-simplified.png&quot; alt=&quot;Eqn for the cordic stage, after simplification&quot; width=&quot;459&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;From here you can see that this is most definitely a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Rotation_matrix&quot;&gt;rotation matrix&lt;/a&gt;
with an amplitude increase associated with it.&lt;/p&gt;

&lt;p&gt;Further, as you may have guessed from Fig 1 above, we can apply a similar
rotation going in the opposite direction:&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/eqn-cordic-negative-transform.png&quot; alt=&quot;Eqn for the cordic stage, negated angle, after simplification&quot; width=&quot;459&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;These two (nearly) &lt;a href=&quot;https://en.wikipedia.org/wiki/Rotation_matrix&quot;&gt;rotation
matrices&lt;/a&gt;
form the basis of the
&lt;a href=&quot;https://en.wikipedia.org/wiki/CORDIC&quot;&gt;CORDIC&lt;/a&gt;
algorithm.&lt;/p&gt;

&lt;p&gt;The basic idea behind the
&lt;a href=&quot;https://en.wikipedia.org/wiki/CORDIC&quot;&gt;CORDIC&lt;/a&gt;
algorithm is that we can string many of these
&lt;a href=&quot;https://en.wikipedia.org/wiki/Rotation_matrix&quot;&gt;rotation matrices&lt;/a&gt;
together–either rotating by a positive &lt;code class=&quot;highlighter-rouge&quot;&gt;theta_k&lt;/code&gt; or a
negative &lt;code class=&quot;highlighter-rouge&quot;&gt;theta_k&lt;/code&gt; in each matrix.  As an example, suppose you rotated
[1, 0] by +26.57 degrees (k=1), then by 14.03 degrees (k=2), then backwards
by 7.12 degrees (k=3).  You would then
have a vector that has been rotated by 30.48 degrees.  Other than
the slight amplitude increase, that means that your resulting vector now
approximates a thirty degree phasor–and you didn’t have to do anything that
significant to get there.&lt;/p&gt;

&lt;p&gt;Further, the more of these rotation matrices you string together, the smaller
the remaining rotation becomes, and hence the closer the result will come
(in angular distance) to any desired rotation.&lt;/p&gt;

&lt;p&gt;This is what we are going to try to build today.&lt;/p&gt;

&lt;h2 id=&quot;rotating-into-range&quot;&gt;Rotating into range&lt;/h2&gt;

&lt;p&gt;The first step in building this rotation, though, is that massage the problem
so that the rotation desired is less than 45 degrees.  This comes from the
fact that the largest rotation the
&lt;a href=&quot;https://en.wikipedia.org/wiki/CORDIC&quot;&gt;CORDIC&lt;/a&gt;
rotation above can accomplish is a 45 degree rotation.  Angles beyond
45 degrees just get smaller.  Therefore, the
&lt;a href=&quot;https://en.wikipedia.org/wiki/CORDIC&quot;&gt;CORDIC&lt;/a&gt;
rotation requires an initial angular request, &lt;code class=&quot;highlighter-rouge&quot;&gt;i_phase&lt;/code&gt;, to be less than 45
degrees.  Our first problem, therefore is going to be rotating our incoming
vector so that any remaining rotation amount is 45 degrees or less.&lt;/p&gt;

&lt;p&gt;As a preliminary step, we’ll start our algorithm off by expanding the two
input values from their initial width, &lt;code class=&quot;highlighter-rouge&quot;&gt;IW&lt;/code&gt;, to a wider working width, &lt;code class=&quot;highlighter-rouge&quot;&gt;WW&lt;/code&gt;.
Because the
&lt;a href=&quot;https://en.wikipedia.org/wiki/CORDIC&quot;&gt;CORDIC&lt;/a&gt;
algorithm will also increase the magnitude of the input, this process adds one
more bit on the left–to allow for a touch of width expansion.  It also adds
a user selectable number of bits (captured as part of &lt;code class=&quot;highlighter-rouge&quot;&gt;WW&lt;/code&gt;) to the right so as
to minimize any distortion’s caused by
&lt;a href=&quot;/dsp/2017/07/22/rounding.html&quot;&gt;truncation effects&lt;/a&gt;
within the rotation.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;wire	signed [(WW-1):0]	e_xval, e_yval;
assign	e_xval = { {i_xval[(IW-1)]}, i_xval, {(WW-IW-1){1&#39;b0}} };
assign	e_yval = { {i_yval[(IW-1)]}, i_yval, {(WW-IW-1){1&#39;b0}} };&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Further, we’re going to declare our intermediate values
to be an array of &lt;code class=&quot;highlighter-rouge&quot;&gt;WW&lt;/code&gt; bits each for the intermediate &lt;code class=&quot;highlighter-rouge&quot;&gt;xv&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;yv&lt;/code&gt; values,
and an array of phase width, &lt;code class=&quot;highlighter-rouge&quot;&gt;PW&lt;/code&gt;, number of bits for the phase.  Since the
&lt;a href=&quot;https://en.wikipedia.org/wiki/CORDIC&quot;&gt;CORDIC&lt;/a&gt;
operation takes place in stages, we’ll declare &lt;code class=&quot;highlighter-rouge&quot;&gt;NSTAGES+1&lt;/code&gt; of these
values–that will create variables to hold not only the input values,
but the outputs as well.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;// Declare variables for all of the separate stages
reg	signed	[(WW-1):0]	xv	[0:(NSTAGES)];
reg	signed	[(WW-1):0]	yv	[0:(NSTAGES)];
reg		[(PW-1):0]	ph	[0:(NSTAGES)];&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The beginner needs to understand that this is not the definition of a memory,
although it might look very similar to a block RAM definition.  Rather, this
is a simplified definition of &lt;code class=&quot;highlighter-rouge&quot;&gt;NSTAGES&lt;/code&gt; of values in flip-flops.&lt;/p&gt;

&lt;p&gt;Declarations aside, that brings us to the actual logic of the
pre-&lt;a href=&quot;https://en.wikipedia.org/wiki/CORDIC&quot;&gt;CORDIC&lt;/a&gt;
section.  The goal of this section is to rotate the input by some number
of ninety-degree intervals until the remaining phase is between -45 and 45.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 2: Initial rotation&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/cordic-prerotation.svg&quot; alt=&quot;Result of the pre-CORDIC rotation&quot; width=&quot;420&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Since this is a signal processing algorithm, the “global CE” &lt;a href=&quot;/blog/2017/08/14/strategies-for-pipelining.html&quot;&gt;pipeline
strategy&lt;/a&gt;
may make the most sense.  We’ll also create logic for the &lt;a href=&quot;/blog/2017/08/14/strategies-for-pipelining.html&quot;&gt;traveling CE strategy
strategy&lt;/a&gt;
later.  For now, remember that the global CE strategy requires that nothing
changes unless a CE line is true.  Therefore, our transform begins by
checking the &lt;code class=&quot;highlighter-rouge&quot;&gt;i_ce&lt;/code&gt; line.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
if (i_ce)&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Next, we’ll want to walk through the actual rotations.&lt;/p&gt;

&lt;table style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 3: Rotation by quadrant&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/cordic-prequadrants.svg&quot; alt=&quot;Split the pre-rotation up by quadrant&quot; width=&quot;280&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;In order to get 
everything into +/- 45 degrees, we’ll want to check not only which quadrant
our phase request is within, but also which 45 degree segment of that quadrant
the angle is in, as shown in Fig 3.
Hence, we’ll check the top three bits of &lt;code class=&quot;highlighter-rouge&quot;&gt;i_phase&lt;/code&gt;, and apply a rotation
based upon them.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	case(i_phase[(PW-1):(PW-3)])&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Each rotation opportunity will set &lt;code class=&quot;highlighter-rouge&quot;&gt;xv[0]&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;yv[0]&lt;/code&gt;, and &lt;code class=&quot;highlighter-rouge&quot;&gt;ph[0]&lt;/code&gt;.  These are
the initial values of x, y, and the remaining phase to rotate through.  The
options for &lt;code class=&quot;highlighter-rouge&quot;&gt;xv[0]&lt;/code&gt; are &lt;code class=&quot;highlighter-rouge&quot;&gt;+/- e_xval&lt;/code&gt; or &lt;code class=&quot;highlighter-rouge&quot;&gt;+/- e_yval&lt;/code&gt; and likewise for &lt;code class=&quot;highlighter-rouge&quot;&gt;yv[0]&lt;/code&gt;.
Further, because these rotations are all by multiples of ninety degrees,
there’s no need to do any additions.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	3&#39;b000: begin	// 0 .. 45, No change
		xv[0] &amp;lt;= e_xval;
		yv[0] &amp;lt;= e_yval;
		ph[0] &amp;lt;= i_phase;
		end
	3&#39;b001: begin	// 45 .. 90
		xv[0] &amp;lt;= -e_yval;
		yv[0] &amp;lt;= e_xval;
		ph[0] &amp;lt;= i_phase - 18&#39;h10000;
		end
	3&#39;b010: begin	// 90 .. 135
		xv[0] &amp;lt;= -e_yval;
		yv[0] &amp;lt;= e_xval;
		ph[0] &amp;lt;= i_phase - 18&#39;h10000;
		end
	3&#39;b011: begin	// 135 .. 180
		xv[0] &amp;lt;= -e_xval;
		yv[0] &amp;lt;= -e_yval;
		ph[0] &amp;lt;= i_phase - 18&#39;h20000;
		end
	3&#39;b100: begin	// 180 .. 225
		xv[0] &amp;lt;= -e_xval;
		yv[0] &amp;lt;= -e_yval;
		ph[0] &amp;lt;= i_phase - 18&#39;h20000;
		end
	3&#39;b101: begin	// 225 .. 270
		xv[0] &amp;lt;= e_yval;
		yv[0] &amp;lt;= -e_xval;
		ph[0] &amp;lt;= i_phase - 18&#39;h30000;
		end
	3&#39;b110: begin	// 270 .. 315
		xv[0] &amp;lt;= e_yval;
		yv[0] &amp;lt;= -e_xval;
		ph[0] &amp;lt;= i_phase - 18&#39;h30000;
		end
	3&#39;b111: begin	// 315 .. 360, No change
		xv[0] &amp;lt;= e_xval;
		yv[0] &amp;lt;= e_yval;
		ph[0] &amp;lt;= i_phase;
		end
	endcase&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Remember: we are rotating the &lt;code class=&quot;highlighter-rouge&quot;&gt;xv&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;yv&lt;/code&gt; vector counter-clockwise, so
that the rotation remaining, &lt;code class=&quot;highlighter-rouge&quot;&gt;ph&lt;/code&gt;, is less than &lt;code class=&quot;highlighter-rouge&quot;&gt;+/- 45&lt;/code&gt; degrees.  Hence we
are rotating &lt;code class=&quot;highlighter-rouge&quot;&gt;xv&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;yv&lt;/code&gt; in a counter-clockwise direction, while the
remaining phase angle will decrease in what will look like a clock-wise
direction.&lt;/p&gt;

&lt;p&gt;This sets up the actual
&lt;a href=&quot;https://en.wikipedia.org/wiki/CORDIC&quot;&gt;CORDIC&lt;/a&gt;:
&lt;code class=&quot;highlighter-rouge&quot;&gt;xv[0]&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;yv[0]&lt;/code&gt; now need to be rotated
through &lt;code class=&quot;highlighter-rouge&quot;&gt;ph[0]&lt;/code&gt; remaining &lt;a href=&quot;/dsp/2017/06/15/no-pi-for-you.html&quot;&gt;angular
units&lt;/a&gt;.  We’ve also
guaranteed that &lt;code class=&quot;highlighter-rouge&quot;&gt;|ph[0]|&lt;/code&gt; is less than or equal to 45 degrees.&lt;/p&gt;

&lt;h2 id=&quot;rotating-to-zero&quot;&gt;Rotating to zero&lt;/h2&gt;

&lt;p&gt;The next step is to rotate the &lt;code class=&quot;highlighter-rouge&quot;&gt;xv[0]&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;yv[0]&lt;/code&gt; values through the remaining
phase angle, &lt;code class=&quot;highlighter-rouge&quot;&gt;ph[0]&lt;/code&gt;.  To do this, we’re going to check whether or not the
remaining phase is negative or positive.  If the phase is negative, we’ll
rotate by a positive &lt;code class=&quot;highlighter-rouge&quot;&gt;cordic_angle[i]&lt;/code&gt;.  If the remaining phase is positive,
we’ll rotate in the opposite direction but by the same amount.&lt;/p&gt;

&lt;p&gt;Software programmers like to look at &lt;code class=&quot;highlighter-rouge&quot;&gt;for&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;while&lt;/code&gt; loops in Verilog and
think of them like their &lt;code class=&quot;highlighter-rouge&quot;&gt;for&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;while&lt;/code&gt; counterparts in software.  HDL
loops, however, are &lt;em&gt;nothing&lt;/em&gt; like software loops.  Software loops repeat the
same instruction, one after another in time.  HDL loops on the other hand
repeat the instruction in space on the chip by creating multiple copies of
the same logic, all of which will be executed in parallel.&lt;/p&gt;

&lt;p&gt;This is one of those rare cases where a &lt;code class=&quot;highlighter-rouge&quot;&gt;for&lt;/code&gt; loop makes sense in Verilog.  The
&lt;a href=&quot;https://en.wikipedia.org/wiki/CORDIC&quot;&gt;CORDIC&lt;/a&gt;
algorithm repeats nearly the same logic &lt;code class=&quot;highlighter-rouge&quot;&gt;NSTAGES&lt;/code&gt; times over.  Hence, this
loop generates &lt;code class=&quot;highlighter-rouge&quot;&gt;NSTAGES&lt;/code&gt; pieces of logic, each of which advances the
prior stage by one clock.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;genvar	i;
generate for(i=0; i&amp;lt;NSTAGES; i=i+1) begin : CORDICops&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Within this for loop, we’ll create several always blocks.  Each block
first makes sure that nothing changes, except when the global CE signal, &lt;code class=&quot;highlighter-rouge&quot;&gt;i_ce&lt;/code&gt;
is high.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(posedge i_clk)
	// Reset logic can be placed here, but it isnt required
	if (i_ce)
	begin&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Once these last preliminaries have been taken care of, we can finally apply the
&lt;a href=&quot;https://en.wikipedia.org/wiki/CORDIC&quot;&gt;CORDIC&lt;/a&gt;
rotation/transform.
Note that we first check the sign of the remaining phase to know which
direction to rotate, but otherwise the operations you see here should match
the transform we discussed earlier.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;		// You can check for cord[i] == 0 here if you would like
		if (ph[i][(PW-1)]) // Negative phase
		begin
			// If the phase is negative, rotate by the
			// CORDIC angle in a clockwise direction.
			xv[i+1] &amp;lt;= xv[i] + (yv[i]&amp;gt;&amp;gt;&amp;gt;(i+1));
			yv[i+1] &amp;lt;= yv[i] - (xv[i]&amp;gt;&amp;gt;&amp;gt;(i+1));
			ph[i+1] &amp;lt;= ph[i] + cordic_angle[i];

		end else begin
			// On the other hand, if the phase is
			// positive ... rotate in the
			// counter-clockwise direction
			xv[i+1] &amp;lt;= xv[i] - (yv[i]&amp;gt;&amp;gt;&amp;gt;(i+1));
			yv[i+1] &amp;lt;= yv[i] + (xv[i]&amp;gt;&amp;gt;&amp;gt;(i+1));
			ph[i+1] &amp;lt;= ph[i] - cordic_angle[i];

		end
	end
endgenerate&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;While this is the core of the
&lt;a href=&quot;https://en.wikipedia.org/wiki/CORDIC&quot;&gt;CORDIC&lt;/a&gt;
algorithm, now that we have put it together we are by no means done.  We still
need to generate the &lt;a href=&quot;https://en.wikipedia.org/wiki/CORDIC&quot;&gt;CORDIC&lt;/a&gt;
angles, listed as array elements of &lt;code class=&quot;highlighter-rouge&quot;&gt;cordic_angle&lt;/code&gt; above, any traveling
CE &lt;a href=&quot;/blog/2017/08/14/strategies-for-pipelining.html&quot;&gt;pipeline
logic&lt;/a&gt;,
&lt;a href=&quot;/dsp/2017/07/22/rounding.html&quot;&gt;drop any excess bits&lt;/a&gt;
we’ve accumulated,
and figure out what the gain of the algorithm is in case we wish to compensate
for it.&lt;/p&gt;

&lt;h2 id=&quot;using-a-core-generator-in-c-to-get-the-angles&quot;&gt;Using a core-generator in C++ to get the angles&lt;/h2&gt;

&lt;p&gt;One difficulty associated with building a “generic”
&lt;a href=&quot;https://en.wikipedia.org/wiki/CORDIC&quot;&gt;CORDIC&lt;/a&gt;
HDL core is that some of the components of the core cannot be generalized
very easily.  A good example of this problem is the VHDL
&lt;a href=&quot;https://en.wikipedia.org/wiki/CORDIC&quot;&gt;CORDIC&lt;/a&gt;
&lt;a href=&quot;http://github.com/freecores/cordic/blob/master/polar2rect/p2r_Cordic_pipe.vhd&quot;&gt;core&lt;/a&gt; found on
&lt;a href=&quot;http://opencores.org/project,cordic&quot;&gt;OpenCores&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://github.com/freecores/cordic/blob/master/polar2rect/p2r_Cordic_pipe.vhd&quot;&gt;This open-cores
core&lt;/a&gt;
is built with a fixed precision.  While the data width can ostensibly be
adjusted, there are a fixed number of internal arc-tangent results, each created
with a fixed width and a fixed value.  (Well, that and you can’t &lt;a href=&quot;/blog/2017/06/21/looking-at-verilator.html&quot;&gt;simulate the
core&lt;/a&gt; within
&lt;a href=&quot;https://www.veripool.org/wiki/verilator&quot;&gt;Verilator&lt;/a&gt; because someone chose to
write it within &lt;em&gt;VHDL&lt;/em&gt;.)  The only way to prevent this bit-width problem
associated with a one-size fits all solution is to
use a software program, sometimes called a core generator or
&lt;a href=&quot;https://www.xilinx.com/products/design-tools/coregen.html&quot;&gt;coregen&lt;/a&gt;, to
tailor the &lt;a href=&quot;https://en.wikipedia.org/wiki/CORDIC&quot;&gt;CORDIC&lt;/a&gt;
to a specifically requested precision.  This piece of software needs to
calculate the phase rotation angles.  We’ll also use the software to calculate
the required number of stages, the number of input or output bits required,
the number of phase bits, etc., etc.&lt;/p&gt;

&lt;p&gt;Such a core generator will be our approach
&lt;a href=&quot;https://github.com/ZipCPU/cordic/tree/master/sw&quot;&gt;here&lt;/a&gt;.  You can find the
basic &lt;a href=&quot;https://github.com/ZipCPU/cordic/blob/master/sw/basiccordic.v&quot;&gt;core generator
here&lt;/a&gt;,
within my &lt;a href=&quot;https://github.com/ZipCPU/cordic&quot;&gt;cordic repository&lt;/a&gt;.
For now, let’s discuss calculating the
&lt;a href=&quot;https://en.wikipedia.org/wiki/CORDIC&quot;&gt;CORDIC&lt;/a&gt;
angles.&lt;/p&gt;

&lt;p&gt;Starting from above, the cordic angles are defined as&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/eqn-cordic-phase.png&quot; alt=&quot;Cordic rotation phase&quot; width=&quot;168&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;but in our &lt;a href=&quot;/dsp/2017/06/15/no-pi-for-you.html&quot;&gt;normalized integer units of
phase&lt;/a&gt;,
the value we will want is going to be&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/eqn-cordic-tblangle.png&quot; alt=&quot;Cordic rotation phase&quot; width=&quot;342&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;This value can easily be computed in C++ or any other higher level language
for that matter.  We’ll use C++ for this exercise.&lt;/p&gt;

&lt;p&gt;We’ll need to calculate one angle for each of the
&lt;a href=&quot;https://en.wikipedia.org/wiki/CORDIC&quot;&gt;CORDIC&lt;/a&gt;
stages.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;for(unsigned k=0; k&amp;lt;(unsigned)nstages; k++) {
	double		x, deg;
	unsigned	phase_value;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The angle is given by the arctangent of our rotation vector, &lt;code class=&quot;highlighter-rouge&quot;&gt;1+j2^-k&lt;/code&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	x = atan2(1., pow(2,k));&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;(Remember, atan2 accepts the y argument first.  Hence our arguments of
&lt;code class=&quot;highlighter-rouge&quot;&gt;x=2^k&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;y=1&lt;/code&gt; represent an equivalent representation to our angle of
interest.)&lt;/p&gt;

&lt;p&gt;We’ll keep track of the value of this angle in degrees as well as
&lt;a href=&quot;/dsp/2017/06/15/no-pi-for-you.html&quot;&gt;FPGA units&lt;/a&gt;,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	deg = x * 180.0 / M_PI;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;For all other purposes, though, we’ll convert our angle to a &lt;a href=&quot;/dsp/2017/06/15/no-pi-for-you.html&quot;&gt;normalized
integer phase&lt;/a&gt;,
value we can use in an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
algorithm,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	x *= (4.0 * (1ul&amp;lt;&amp;lt;(phase_bits-2))) / (M_PI * 2.0);
	phase_value = (unsigned)x;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;We can then print this value to our resulting Verilog file.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	fprintf(fp, &quot;\tassign\tcordic_angle[%2d] = %2d\&#39;h%0*x; //%11.6f deg\n&quot;,
		k, phase_bits, (phase_bits+3)/4, phase_value,
		deg);
}&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;(I know this is the old-style C I/O — while I’ve used the C++ I/O, I’ve
never really fallen in-love with it.)&lt;/p&gt;

&lt;p&gt;After applying this calculation to a problem set with an &lt;code class=&quot;highlighter-rouge&quot;&gt;18-bit&lt;/code&gt; phase
requirement, the code above generated the following table,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;assign	cordic_angle[ 0] = 18&#39;h0_4b90; //  26.565051 deg
assign	cordic_angle[ 1] = 18&#39;h0_27ec; //  14.036243 deg
assign	cordic_angle[ 2] = 18&#39;h0_1444; //   7.125016 deg
assign	cordic_angle[ 3] = 18&#39;h0_0a2c; //   3.576334 deg
assign	cordic_angle[ 4] = 18&#39;h0_0517; //   1.789911 deg
assign	cordic_angle[ 5] = 18&#39;h0_028b; //   0.895174 deg
assign	cordic_angle[ 6] = 18&#39;h0_0145; //   0.447614 deg
assign	cordic_angle[ 7] = 18&#39;h0_00a2; //   0.223811 deg
assign	cordic_angle[ 8] = 18&#39;h0_0051; //   0.111906 deg
assign	cordic_angle[ 9] = 18&#39;h0_0028; //   0.055953 deg
assign	cordic_angle[10] = 18&#39;h0_0014; //   0.027976 deg
assign	cordic_angle[11] = 18&#39;h0_000a; //   0.013988 deg
assign	cordic_angle[12] = 18&#39;h0_0005; //   0.006994 deg
assign	cordic_angle[13] = 18&#39;h0_0002; //   0.003497 deg&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The number of stages and the number of bits in each stage can both be defined
based upon arguments to the &lt;a href=&quot;https://github.com/ZipCPU/cordic/blob/master/sw/main.cpp&quot;&gt;core generator
program&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;We still have several steps remaining.  In particular, we need to set up the
“traveling CE” &lt;a href=&quot;/blog/2017/08/14/strategies-for-pipelining.html&quot;&gt;pipeline strategy
logic&lt;/a&gt;,
&lt;a href=&quot;/dsp/2017/07/22/rounding.html&quot;&gt;round&lt;/a&gt;
the final result, and discuss on how to deal with
the amplitude distortion produced by the
&lt;a href=&quot;https://en.wikipedia.org/wiki/CORDIC&quot;&gt;CORDIC&lt;/a&gt;
algorithm.&lt;/p&gt;

&lt;h2 id=&quot;auxiliary-logic&quot;&gt;Auxiliary Logic&lt;/h2&gt;

&lt;p&gt;I mentioned earlier that we could use the “traveling CE” &lt;a href=&quot;/blog/2017/08/14/strategies-for-pipelining.html&quot;&gt;pipeline
strategy&lt;/a&gt;
if desired.  That strategy requires that for every strobe input, the output
associated with that input also needs to have a high strobe output.&lt;/p&gt;

&lt;p&gt;We’ll use our C++ code to build this as well, since in C++ we have control
over when to place this logic into the code, as well as how much of this
logic needs to be placed into
&lt;a href=&quot;https://github.com/ZipCPU/cordic/blob/master/rtl/cordic.v&quot;&gt;our core&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;To do this, we’ll teach the &lt;a href=&quot;https://github.com/ZipCPU/cordic/blob/master/sw/main.cpp&quot;&gt;main core generator
program&lt;/a&gt;
to accept a &lt;code class=&quot;highlighter-rouge&quot;&gt;-a&lt;/code&gt; option.  We’ll then use this to create an &lt;code class=&quot;highlighter-rouge&quot;&gt;aux&lt;/code&gt;iliary bit
to contain the “traveling CE” bit.&lt;/p&gt;

&lt;p&gt;The actual logic required to implement this “traveling CE” is just a simple
shift register:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	if (i_reset)
		ax &amp;lt;= {(NSTAGES+1){1&#39;b0}};
	else if (i_ce)
		ax &amp;lt;= { ax[(NSTAGES-1):0], i_aux };

always @(posedge i_clk)
	o_aux &amp;lt;= ax[NSTAGES];&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Were we to get rid of the reset, then all of this logic could fit within
one shift register logic block on a 7-Series Xilinx
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;.
With the reset, this will require 1-FF per stage.&lt;/p&gt;

&lt;p&gt;Placing this logic within the core generator makes certain that no matter
what logic takes place within the core, the output &lt;code class=&quot;highlighter-rouge&quot;&gt;o_aux&lt;/code&gt; bit remains lined
up with the output data associated with any input data that had the &lt;code class=&quot;highlighter-rouge&quot;&gt;i_aux&lt;/code&gt;
bit.&lt;/p&gt;

&lt;h2 id=&quot;dropping-the-last-number-of-bits&quot;&gt;Dropping the last number of bits&lt;/h2&gt;

&lt;p&gt;When we get to the end, we’ll want to drop some bits.  We
&lt;a href=&quot;/dsp/2017/07/22/rounding.html&quot;&gt;discussed some time ago&lt;/a&gt;
how to go about this via
&lt;a href=&quot;/dsp/2017/07/22/rounding.html&quot;&gt;rounding&lt;/a&gt;.  We also discussed
several different types of
&lt;a href=&quot;/dsp/2017/07/22/rounding.html&quot;&gt;rounding&lt;/a&gt; at that same time.
Here, we follow the convergent rounding approach to drop any excess bits.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	// Round our result towards even
	wire	[(WW-1):0]	pre_xval, pre_yval;

	assign	pre_xval = xv[NSTAGES] + ,
				xv[NSTAGES][(WW-OW)],
				{(WW-OW-1){!xv[NSTAGES][WW-OW]}}};
	assign	pre_yval = yv[NSTAGES] + ,
				yv[NSTAGES][(WW-OW)],
				{(WW-OW-1){!yv[NSTAGES][WW-OW]}}};

	always @(posedge i_clk)
	begin
		o_xval &amp;lt;= pre_xval[(WW-1):(WW-OW)];
		o_yval &amp;lt;= pre_yval[(WW-1):(WW-OW)];
	end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;That marks the end of our basic
&lt;a href=&quot;https://en.wikipedia.org/wiki/CORDIC&quot;&gt;CORDIC&lt;/a&gt;
algorithm.  We still need to discuss what to do about the amplitude
gain we’ve accumulated, so that will be next.&lt;/p&gt;

&lt;h2 id=&quot;dealing-with-amplitude&quot;&gt;Dealing with Amplitude&lt;/h2&gt;

&lt;p&gt;As you’ll recall from the beginning of our discussion, the
&lt;a href=&quot;https://en.wikipedia.org/wiki/CORDIC&quot;&gt;CORDIC&lt;/a&gt;
algorithm has a gain associated with it.  Our task here will be to calculate
that gain.  We’ll do this within our C++ generator program, since it has
all the details and capability to do so.&lt;/p&gt;

&lt;p&gt;Below is a copy of the &lt;a href=&quot;https://github.com/ZipCPU/cordic/blob/master/sw/cordiclib.cpp&quot;&gt;C++ code used to calculate the cordic
gain&lt;/a&gt;.
It basically calculates the product of all of the gains of the various
stages in our algorithm.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt;	&lt;span class=&quot;nf&quot;&gt;cordic_gain&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nstages&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;phase_bits&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;gain&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;1.0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

	&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nstages&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt;		&lt;span class=&quot;n&quot;&gt;dgain&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

		&lt;span class=&quot;n&quot;&gt;dgain&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;1.0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pow&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;2.0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;2.&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;dgain&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sqrt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dgain&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;gain&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;gain&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dgain&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

	&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;gain&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This, however, only tells us how much gain will be applied to our input.  That
is, it quantifies our amplitude distortion.  We’ll capture this with a
comment line added to the end of the list of &lt;code class=&quot;highlighter-rouge&quot;&gt;cordic_angles&lt;/code&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;// Gain is 1.646760&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Not all applications need gain compensation.  Some can ignore the
gain.  In the case of those applications, the task is done.&lt;/p&gt;

&lt;p&gt;Other applications use a
CORDIC
for calculating sines and cosines.  These applications would nominally send
&lt;code class=&quot;highlighter-rouge&quot;&gt;(1,0)&lt;/code&gt; into the algorithm as an input.  For these applications, the way to
compensate for the gain is to send a different number as an input.  Instead
of &lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt; (or really &lt;code class=&quot;highlighter-rouge&quot;&gt;2^n&lt;/code&gt; for an &lt;code class=&quot;highlighter-rouge&quot;&gt;n&lt;/code&gt;-bit input), these algorithms will want
to send one divided by the gain into the algorithm.  If we calculate the
right constant to replace the &lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt; with, then we still won’t need any
multiplies.  To help you figure this out, the algorithm calculates
&lt;code class=&quot;highlighter-rouge&quot;&gt;2^32/cordic_gain&lt;/code&gt;, and places this into the comments following the
calculation of the &lt;code class=&quot;highlighter-rouge&quot;&gt;cordic_angle&lt;/code&gt;s as well.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;// You can annihilate this gain by multiplying by 32&#39;h9b74edae
// and right shifting by 32 bits.&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;That allows you to pick the number of most-significant bits that you need,
for the precision you want.&lt;/p&gt;

&lt;p&gt;Other applications use the
CORDIC
to actually rotate the input vector.  For these applications, the same
32-bit value can be used as an annihilator, post
CORDIC
application.  If you multiply by this annihilator, and shift right, then the
CORDIC
gain will be removed.&lt;/p&gt;

&lt;h2 id=&quot;conclusions&quot;&gt;Conclusions&lt;/h2&gt;

&lt;p&gt;Now that you’ve seen what goes into making a working
&lt;a href=&quot;https://en.wikipedia.org/wiki/CORDIC&quot;&gt;CORDIC&lt;/a&gt;
core, perhaps you are as amazed as I am at how many parts and pieces this
&lt;em&gt;simple&lt;/em&gt; sine and cosine wave generator has.  We started out by discussing the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Rotation_matrix&quot;&gt;rotation matrices&lt;/a&gt;
used by the
&lt;a href=&quot;https://en.wikipedia.org/wiki/CORDIC&quot;&gt;CORDIC&lt;/a&gt;
algorithm.  This is usually where most academic
&lt;a href=&quot;https://en.wikipedia.org/wiki/CORDIC&quot;&gt;CORDIC&lt;/a&gt;
development’s stop.&lt;/p&gt;

&lt;p&gt;However, when you want to make a working
&lt;a href=&quot;https://en.wikipedia.org/wiki/CORDIC&quot;&gt;CORDIC&lt;/a&gt;
core, you have to go further.  You need to rotate the original vector by
some multiple of ninety degree angles until the remaining rotation angle is
less than forty five degrees.  Only then can you apply the
&lt;a href=&quot;https://en.wikipedia.org/wiki/CORDIC&quot;&gt;CORDIC&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Rotation_matrix&quot;&gt;rotation&lt;/a&gt;.
Doing so, though, requires the
&lt;a href=&quot;https://en.wikipedia.org/wiki/CORDIC&quot;&gt;CORDIC&lt;/a&gt;
angles, which we needed to calculate based upon the desired precision of the
output.  As a final step, we calculated both the
&lt;a href=&quot;https://en.wikipedia.org/wiki/CORDIC&quot;&gt;CORDIC&lt;/a&gt;
gain and it’s associated annihilator (inverse).&lt;/p&gt;

&lt;p&gt;If only this were all that was required of a
&lt;a href=&quot;https://en.wikipedia.org/wiki/CORDIC&quot;&gt;CORDIC&lt;/a&gt;
core.  It’s not.  We still need to build a test bench for this core–so our
work isn’t over yet.
Before doing so, however, I think we’ll present the
&lt;a href=&quot;/dsp/2017/09/01/topolar.md&quot;&gt;other basic type&lt;/a&gt;
of &lt;a href=&quot;https://en.wikipedia.org/wiki/CORDIC&quot;&gt;CORDIC&lt;/a&gt;
algorithm:
the &lt;a href=&quot;/dsp/2017/09/01/topolar.html&quot;&gt;CORDIC arctan&lt;/a&gt;
arctan, sometimes called the &lt;a href=&quot;/dsp/2017/09/01/topolar.html&quot;&gt;rectangular to polar
conversion&lt;/a&gt;,
before diving into the bench test.&lt;/p&gt;

&lt;p&gt;If you are interested in further reading on the topic,
Ray Andraka has written an excellent &lt;a href=&quot;http://www.andraka.com/files/crdcsrvy.pdf&quot;&gt;survey of CORDIC
algorithms&lt;/a&gt; that you might find
valuable.&lt;/p&gt;
&lt;hr /&gt;&lt;p&gt;&lt;em&gt;O ye simple, understand wisdom: and, ye fools, be ye of an understanding heart.  (Prov 8:5)&lt;/em&gt;</description>
        <pubDate>Wed, 30 Aug 2017 00:00:00 -0400</pubDate>
        <link>http://zipcpu.com/dsp/2017/08/30/cordic.html</link>
        <guid isPermaLink="true">http://zipcpu.com/dsp/2017/08/30/cordic.html</guid>
        
        
        <category>dsp</category>
        
      </item>
    
      <item>
        <title>Building a quarter sine-wave lookup table</title>
        <description>&lt;p&gt;The last time &lt;a href=&quot;/dsp/2017/07/11/simplest-sinewave-generator.html&quot;&gt;we discussed how to create a
sinewave&lt;/a&gt;,
we discussed the way to make a very simple
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sine_wave&quot;&gt;sinewave&lt;/a&gt;.
from a &lt;a href=&quot;/blog/2017/06/12/minimizing-luts.html&quot;&gt;LUT&lt;/a&gt;-based
table lookup.  We limited that
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sine_wave&quot;&gt;sinewave&lt;/a&gt;.
to an 8-bit table for simplicity, although it could easily be extended to a
much larger table.&lt;/p&gt;

&lt;p&gt;Today, let’s expand this concept to a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sine_wave&quot;&gt;sinewave&lt;/a&gt;.
that uses a quarter wave table
made from Block &lt;a href=&quot;https://en.wikipedia.org/wiki/Random-access_memory&quot;&gt;RAM&lt;/a&gt;.  Such a table uses only a fourth of the block &lt;a href=&quot;https://en.wikipedia.org/wiki/Random-access_memory&quot;&gt;RAM&lt;/a&gt;
resources required by a full table, although it does require some extra logic
to handle making things look like the full table.&lt;/p&gt;

&lt;p&gt;Let’s also build this as an example of how to create pipelined
&lt;a href=&quot;https://en.wikipedia.org/wiki/Hardware_description_language&quot;&gt;HDL&lt;/a&gt; logic.&lt;/p&gt;

&lt;p&gt;We’ll start by describing the algorithm in general, and then build the
algorithm through a series of stages.&lt;/p&gt;

&lt;h2 id=&quot;the-algorithm&quot;&gt;The Algorithm&lt;/h2&gt;

&lt;p&gt;The first step is always stepping back and assessing the problem.
If you look at a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sine_wave&quot;&gt;sinewave&lt;/a&gt;,
such as Fig 1. below, you can separate the full
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sine_wave&quot;&gt;sinewave&lt;/a&gt;
period into four sections, one quarter wavelength each.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 1: Sinewave Symmetry&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/sin-symmetry.png&quot; alt=&quot;Sinewave symmetry&quot; width=&quot;580&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;We’ll leave the first section alone.  This will become our quarter-wave
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sine_wave&quot;&gt;sinewave&lt;/a&gt;
table.
The second section is identical to the first, only in a backwards order.
Hence, if we reverse our index, we should be able to recover anything from
this quarter wave of the table.  The third and fourth sections are identical
to the first two, only their results will need to be negated afterwards.&lt;/p&gt;

&lt;p&gt;Since we are splitting the full wavelength into four sections, the top two
&lt;a href=&quot;/dsp/2017/06/15/no-pi-for-you.html&quot;&gt;phase&lt;/a&gt; bits can be
used to determine which of the four sections we are in.  If the most significant
bit is set, then we’ll want to negate the result.  If the next significant bit
is set, we’ll want to read backwards out of the table.&lt;/p&gt;

&lt;p&gt;This quarter wave table runs into a bit of a problem with
&lt;a href=&quot;/dsp/2017/06/15/no-pi-for-you.html&quot;&gt;phase&lt;/a&gt;
quantization, though.  Consider a
&lt;a href=&quot;/dsp/2017/06/15/no-pi-for-you.html&quot;&gt;phase&lt;/a&gt;
quantized table with only 16 entries, such as shown in Fig 2.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 2: Sampled Sinewave&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/sin-qtrbroken.png&quot; alt=&quot;Sinewave symmetry broken by sampling&quot; width=&quot;580&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;This table has lost the symmetry that was originally present in the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sine_wave&quot;&gt;sinewave&lt;/a&gt;.
In particular, table[4]’s value is not present in table[0:3].
If we were to use table[3] to represent the missing table[4] value, we
might get a &lt;a href=&quot;https://en.wikipedia.org/wiki/Sine_wave&quot;&gt;sinewave&lt;/a&gt;
looking like Fig 3. below.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 3: Symmetry can be broken by quantization&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/sin-qtrmisshapen.png&quot; alt=&quot;Fixing the broken symmetry by shifting a half a sample in phase&quot; width=&quot;580&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Notice how flat the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sine_wave&quot;&gt;sinewave&lt;/a&gt;
is every time it crosses zero.  It’s not
supposed to be this flat.  The slope of a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sine_wave&quot;&gt;sinewave&lt;/a&gt;
is supposed to be at
a maximum when it crosses zero–not flat. This shape distortion will create
harmonics that we are not expecting if we don’t fix it.&lt;/p&gt;

&lt;p&gt;If we instead advance the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sine_wave&quot;&gt;sinewave&lt;/a&gt;
table entries by a half of a sample of phase each, the result
will have less harmonic distortion. (i.e., it’ll be closer to the right shape,
even if shifted left a touch).  The result would then look like Fig 4.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 4: Fixing Symmetry by slipping a half a sample in phase&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/sin-qtrfixed.png&quot; alt=&quot;Fixing the broken symmetry by shifting a half a sample in phase&quot; width=&quot;580&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;The resulting equation for this table is also shown in Fig 4.&lt;/p&gt;

&lt;p&gt;The algorithm we want to build will take the first quarter of this
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sine_wave&quot;&gt;sinewave&lt;/a&gt;,
place it into a table, and then use that same table to generate
the other four quarters of the wavelength.&lt;/p&gt;

&lt;h2 id=&quot;building-the-algorithm&quot;&gt;Building the Algorithm&lt;/h2&gt;

&lt;p&gt;It’s now time to build this algorithm.  Although the algorithm itself is
quite simple, I’m going to build it in stages and use this as an opportunity
to discuss how to build a pipelined algorithm in general.  This will allow us
to compare several different implementations, and judge between good an bad
approaches.&lt;/p&gt;

&lt;p&gt;Our first draft for this algorithm uses a giant case statement:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
begin
	case({ i_phase[(PW-1):PW-2] })
	2&#39;b00:	o_val &amp;lt;=  tbl[ i_phase[(PW-3):0]];
	2&#39;b01:	o_val &amp;lt;=  tbl[~i_phase[(PW-3):0]];
	2&#39;b10:	o_val &amp;lt;= -tbl[ i_phase[(PW-3):0]];
	2&#39;b11:	o_val &amp;lt;= -tbl[~i_phase[(PW-3):0]];
	endcase
end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;In this piece of code, &lt;code class=&quot;highlighter-rouge&quot;&gt;i_phase&lt;/code&gt; is the input
&lt;a href=&quot;/dsp/2017/06/15/no-pi-for-you.html&quot;&gt;phase&lt;/a&gt;
request, &lt;code class=&quot;highlighter-rouge&quot;&gt;tbl&lt;/code&gt; is the quarter wave
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sine_wave&quot;&gt;sinewave&lt;/a&gt;
table, and &lt;code class=&quot;highlighter-rouge&quot;&gt;o_val&lt;/code&gt; is the output
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sine_wave&quot;&gt;sinewave&lt;/a&gt;.
PW is the
&lt;a href=&quot;/dsp/2017/06/15/no-pi-for-you.html&quot;&gt;phase&lt;/a&gt;
width, or equivalently the number of bits in &lt;code class=&quot;highlighter-rouge&quot;&gt;i_phase&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;You may notice that I haven’t used &lt;code class=&quot;highlighter-rouge&quot;&gt;TBLLEN/4-1-i_phase&lt;/code&gt; at all when reversing
the table entries.  Instead, &lt;code class=&quot;highlighter-rouge&quot;&gt;~i_phase&lt;/code&gt; accomplishes the same effect.  To know
why this is relevant, remember the two steps to negating a two’s complement
number: invert all the bits and add one.  In this case, we’d subtract one
after adding one, so we can just invert the bits.  As an example, then, if
&lt;code class=&quot;highlighter-rouge&quot;&gt;i_phase&lt;/code&gt; counts from 0 to 15, &lt;code class=&quot;highlighter-rouge&quot;&gt;~i_phase&lt;/code&gt; would count from 15 back down to 0.&lt;/p&gt;

&lt;p&gt;The problem with this big case statement approach is that most block &lt;a href=&quot;https://en.wikipedia.org/wiki/Random-access_memory&quot;&gt;RAM&lt;/a&gt;’s
are &lt;a href=&quot;https://www.xilinx.com/support/documentation/white_papers/wp231.pdf&quot;&gt;very particular about how they are
accessed&lt;/a&gt;.
Extra logic on the index is not allowed, neither is extra logic on the output.
Adding logic in either place can interfere with the synthesis tool and keep
it from recognizing your table as a block &lt;a href=&quot;https://en.wikipedia.org/wiki/Random-access_memory&quot;&gt;RAM&lt;/a&gt; (or &lt;a href=&quot;https://en.wikipedia.org/wiki/Read-only_memory&quot;&gt;ROM&lt;/a&gt; in this case).
When dealing with this, I have found the following form to be reliable
among the various hardware’s I have worked with.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	if (i_ce)
		tblvalue &amp;lt;= tbl[index];&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Perhaps this is simpler than it needs to be, but it does work across
vendors’ tool-suites.&lt;/p&gt;

&lt;p&gt;This may also be the time to discuss our pipeline strategy.  Looking over the
&lt;a href=&quot;/blog/2017/08/14/strategies-for-pipelining.html&quot;&gt;various pipeline
strategies&lt;/a&gt;
we posted about earlier, this already looks like the beginning of the
“global CE” approach.  If we look up the examples of where the “global CE”
pipeline strategy makes the most sense, you may recall that
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_signal_processing&quot;&gt;DSP&lt;/a&gt;
logic was one of the common applications of this approach.  Since that’s what
we are building today, we’ll keep the &lt;code class=&quot;highlighter-rouge&quot;&gt;i_ce&lt;/code&gt;
line, and add it into the rest of our logic.&lt;/p&gt;

&lt;p&gt;Working the simplicity of this block
&lt;a href=&quot;https://en.wikipedia.org/wiki/Random-access_memory&quot;&gt;RAM&lt;/a&gt; access into our
logic, though, will take some work.  We’ll need to spend a clock to calculate
the index, and another clock after that to deal with the negation.&lt;/p&gt;

&lt;p&gt;This brings us to our second approach to our logic.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
if (i_ce)
begin
	// First, calculate the table index
	if (i_phase[(PW-2)])
		index &amp;lt;= ~i_phase[(PW-3):0];
	else
		index &amp;lt;=  i_phase[(PW-3):0];

	// Use the index to access Block RAM
	tblvalue &amp;lt;= table[index];

	// Handle the negation afterwards
	if (i_phase[(PW-1)])
		o_val &amp;lt;= -tblvalue;
	else
		o_val &amp;lt;=  tblvalue;
end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This approach still has some hazards to it.  Perhaps if we drew a data
flow diagram, such as Fig 5 below, these hazards will become be more apparent.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 5: Initial Data Flow Diagram&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/qtrwave-preschedule.svg&quot; alt=&quot;Initial data flow diagram&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Let’s work with this flow diagram for a moment.  First, it helps to
separate the data flow variables into clock transitions regions.  (We’ll
show this in Fig 6 below in a moment.)
&lt;code class=&quot;highlighter-rouge&quot;&gt;i_phase&lt;/code&gt; would be in the first clock.  We’ll call this the input clock.
&lt;code class=&quot;highlighter-rouge&quot;&gt;index&lt;/code&gt; is in the next clock, etc.  Once you separate these variables, then
you can see the problem with the negation logic.  This negation flag
needs to come from the
high bit of &lt;code class=&quot;highlighter-rouge&quot;&gt;i_phase[(PW-1)]&lt;/code&gt;, but it has to be available after the table
look up.  To make this problem more apparent, draw vertical lines through
the diagram, dilineating the processing clocks.  Data flows should not cross
through such lines, without being clocked into a new register–else you’ll
have a pipeline bug.&lt;/p&gt;

&lt;p&gt;The solution to this problem is to &lt;em&gt;schedule&lt;/em&gt; the pipeline logic.
Specifically, we’ll create a register to hold &lt;code class=&quot;highlighter-rouge&quot;&gt;i_phase[(PW-1)]&lt;/code&gt; while
the table index is calculated and the table value is looked up.  We can
implement this with a two stage shift register, captured by &lt;code class=&quot;highlighter-rouge&quot;&gt;negate[0]&lt;/code&gt; and
&lt;code class=&quot;highlighter-rouge&quot;&gt;negate[1]&lt;/code&gt;:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
if (i_ce)
begin
	negate[0] &amp;lt;= i_phase[(PW-1)];
	// ...
	negate[1] &amp;lt;= negate[0];
	if (negate[1])
		// ...
end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;A new data flow diagram for this modified algorithm might look like Fig 6.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 6: Scheduled data flow&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/qtrwave-scheduled.svg&quot; alt=&quot;Data flow diagram, with all logic scheduled&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Notice how each variable is now associated with a clock period in the pipeline.&lt;/p&gt;

&lt;p&gt;Written out, our logic now looks like:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;// Initialize the quarter-wave table
initial	$readmemh(&quot;quarterwav.hex&quot;, quartertable);

always @(posedge i_clk)
	if (i_ce)
	begin
		// Clock one
		negate[0] &amp;lt;= i_phase[(PW-1)];
		index  &amp;lt;= i_phase[(PW-2)]
				? ~i_phase[(PW-3):0]
				:  i_phase[(PW-3):0];

		// Clock two
		negate[1] &amp;lt;= negate[0];
		tblvalue &amp;lt;= table[index];

		// Output clock
		if (negate[1])
			o_val &amp;lt;= -tblvalue;
		else
			o_val &amp;lt;=  tblvalue;
	end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;You can also find a &lt;a href=&quot;https://github.com/ZipCPU/cordic/blob/master/rtl/quarterwav.v&quot;&gt;full example of this logic
here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;At this point, we are almost done.  All that’s left is to create a hex
file to be used to crate this table.  This can be done from a simple
&lt;a href=&quot;https://github.com/ZipCPU/cordic/blob/master/sw/sintable.cpp&quot;&gt;C++ program&lt;/a&gt;,
where the relevant portion is shown below:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;tbl_entries&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lgtable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;maxv&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ow&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tbl_entries&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;dv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ph&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;ph&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;2.0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;M_PI&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tbl_entries&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;ph&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt;       &lt;span class=&quot;n&quot;&gt;M_PI&lt;/span&gt;             &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tbl_entries&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;dv&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;maxv&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ph&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;8&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;fprintf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;hexfp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;%s@%08x &quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;?&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;fprintf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;hexfp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;%0*x &quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ow&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ow&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fprintf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;hexfp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Well, not quite.  The problem with this approach is that the table generator
is closely associtated with the Verilog code itself.  In particular, you
can’t change the number of table entries, or for that matter the width of
the table entries, without also adjusting the &lt;a href=&quot;https://github.com/ZipCPU/cordic/blob/master/rtl/quarterwav.v&quot;&gt;Verilog
code&lt;/a&gt;.
For this reason, the
&lt;a href=&quot;https://github.com/ZipCPU/cordic/blob/master/sw/sintable.cpp&quot;&gt;C++ generator&lt;/a&gt;
program creates both the
&lt;a href=&quot;https://github.com/ZipCPU/cordic/blob/master/rtl/quarterwav.v&quot;&gt;Verilog code&lt;/a&gt;
and the
&lt;a href=&quot;https://github.com/ZipCPU/cordic/blob/master/rtl/quarterwav.hex&quot;&gt;hex table&lt;/a&gt;
at the same time.&lt;/p&gt;

&lt;p&gt;That’s it!  We’ve now made a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sine_wave&quot;&gt;sinewave&lt;/a&gt;
generator from just a quarter wave
table.  We’re still going to need to come back to test this table, to build
a test bench and prove that it works, but that’s the basics of the algorithm.&lt;/p&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;This post is one in a small series of posts discussing how to generate a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sine_wave&quot;&gt;sinewave&lt;/a&gt;.
We’ve already discussed a &lt;a href=&quot;/dsp/2017/07/11/simplest-sinewave-generator.md&quot;&gt;very simple sinewave
generator&lt;/a&gt;,
and we are well on our way to creating and explaining a full blown
&lt;a href=&quot;https://en.wikipedia.org/wiki/CORDIC&quot;&gt;CORDIC&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sine_wave&quot;&gt;sinewave&lt;/a&gt; implementation.&lt;/p&gt;

&lt;p&gt;These &lt;a href=&quot;https://en.wikipedia.org/wiki/Sine_wave&quot;&gt;sinewave&lt;/a&gt;
generators will then form the basis for testing the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;digital filters&lt;/a&gt;
that I intend to discuss and demonstrate as well.&lt;/p&gt;

&lt;p&gt;So, while this is the end of this post, in many ways it is only one step
forward in building &lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_signal_processing&quot;&gt;Digital Signal
Proccessing&lt;/a&gt;
algorithms within an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;.
Stick around, there’s a lot you can do with a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sine_wave&quot;&gt;sinewave&lt;/a&gt;.&lt;/p&gt;
&lt;hr /&gt;&lt;p&gt;&lt;em&gt;But he went out, and began to publish it much, and to blaze abroad the matter, insomuch that Jesus could no more openly enter into the city, but was without in desert places: and they came to him from every quarter.  (Mark 1:45)&lt;/em&gt;</description>
        <pubDate>Sat, 26 Aug 2017 00:00:00 -0400</pubDate>
        <link>http://zipcpu.com/dsp/2017/08/26/quarterwave.html</link>
        <guid isPermaLink="true">http://zipcpu.com/dsp/2017/08/26/quarterwave.html</guid>
        
        
        <category>dsp</category>
        
      </item>
    
      <item>
        <title>Debugging your soft-core CPU within an FPGA</title>
        <description>&lt;p&gt;We’ve already looked at the requirements for &lt;a href=&quot;/zipcpu/2017/07/14/cpu-debugging-needs.thml&quot;&gt;debugging a CPU in
general&lt;/a&gt;, as
well as &lt;a href=&quot;/zipcpu/2017/07/26/cpu-sim-debugger.html&quot;&gt;how to debug a CPU within a Verilator based
simulation&lt;/a&gt;. 
Let’s now return to this topic and take a look at how to modify your
&lt;a href=&quot;https://en.wikipedia.org/wiki/Soft_microprocessor&quot;&gt;soft-core CPU&lt;/a&gt;
so that you can debug it once it is placed within an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;.&lt;/p&gt;

&lt;table style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 1: Soft-Core CPU H/W Debugging Needs&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/cpu-dbg-inhw.svg&quot; alt=&quot;Needs of a Soft-Core Hardware Debugger&quot; width=&quot;320&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;When we discussed the &lt;a href=&quot;/zipcpu/2017/07/14/cpu-debugging-needs.thml&quot;&gt;general needs of a
debugger&lt;/a&gt;,
we used a figure similar to Fig 1. to describe a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;’s
debugging needs.
The left column, debugging the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;’s
while in simulation, we address &lt;a href=&quot;/zipcpu/2017/07/26/cpu-sim-debugger.html&quot;&gt;in a
previous post&lt;/a&gt;.
Today, the figure at the right has been modified to highlight todays
discussion and focus: how to add the necessary logic into a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Soft_microprocessor&quot;&gt;soft-core CPU&lt;/a&gt;
to support debugging.&lt;/p&gt;

&lt;p&gt;As shown in the diagram, the basic operations we’re going to need to support
are resetting, starting, halting, and stepping a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;,
as well as examining
and changing
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;,
state
&lt;a href=&quot;https://en.wikipedia.org/wiki/Processor_register&quot;&gt;registers&lt;/a&gt;.
You may wish to review how the &lt;a href=&quot;/zipcpu/2017/08/23/cpu-pipeline.md&quot;&gt;ZipCPU handles pipeline
control&lt;/a&gt;,
since the logic we shall discuss today needs to fit nicely into that context.&lt;/p&gt;

&lt;h2 id=&quot;that-hw-debugging-interface&quot;&gt;That H/W Debugging Interface&lt;/h2&gt;

&lt;p&gt;If you’ve never done this before, please don’t start by trying to implement
&lt;a href=&quot;https://www.gnu.org/software/gdb&quot;&gt;GDB&lt;/a&gt;’s &lt;a href=&quot;https://sourceware.org/gdb/onlinedocs/gdb/Remote-Protocol.html&quot;&gt;remote serial
protocol&lt;/a&gt;
within Verilog.  The protocol is very powerful, and we’ll discuss how to use
it later to connect your
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;
to &lt;a href=&quot;https://www.gnu.org/software/gdb&quot;&gt;GDB&lt;/a&gt;. 
The problem is that the protocol is complex, and it will take a lot of work to
process it within hardware.  Keep reading, there’s an easier way.&lt;/p&gt;

&lt;p&gt;As a first step, think for a moment about what &lt;a href=&quot;/zipcpu/2017/07/14/cpu-debugging-needs.html&quot;&gt;debugging your CPU
will require&lt;/a&gt;.
In particular, you’ll want to be able to read and write both
&lt;a href=&quot;https://en.wikipedia.org/wiki/Processor_register&quot;&gt;registers&lt;/a&gt;
and memory.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;/digilent/2017/05/22/moving-to-memory.html&quot;&gt;Reading from
memory&lt;/a&gt;
requires the address you wish to read from as well as a strobe signal to
indicate your desire to read&lt;/p&gt;

    &lt;p&gt;If your address space is big enough, this &lt;a href=&quot;https://en.wikipedia.org/wiki/Memory-mapped_I/O&quot;&gt;same sort of command and
interface&lt;/a&gt; can work for
reading 
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt; 
&lt;a href=&quot;https://en.wikipedia.org/wiki/Processor_register&quot;&gt;registers&lt;/a&gt;
just like it does for memory.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;/zipcpu/2017/05/23/simplebus.html&quot;&gt;Writing to memory&lt;/a&gt;
requires an address, a value, and a strobe to tell you
when to write the value to the given address.&lt;/p&gt;

    &lt;p&gt;As with reading, if you can allocate an address for each
&lt;a href=&quot;https://en.wikipedia.org/wiki/Processor_register&quot;&gt;register&lt;/a&gt; within your
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;,
the same interface you used for reading
&lt;a href=&quot;https://en.wikipedia.org/wiki/Processor_register&quot;&gt;registers&lt;/a&gt;
could also work to writing
&lt;a href=&quot;https://en.wikipedia.org/wiki/Processor_register&quot;&gt;registers&lt;/a&gt; within your
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;.&lt;/p&gt;

    &lt;p&gt;The approach can even be expanded to include not only
&lt;a href=&quot;https://en.wikipedia.org/wiki/Processor_register&quot;&gt;registers&lt;/a&gt;
values, but also internal (debugging) state variables from within your
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;As a third example, a control register could also be used to tell the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt; when
to execute an instruction, and when to hold in reset.&lt;/p&gt;

&lt;table style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 2: Placing a CPU on the Debugging Bus&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/hw-debug-structure.svg&quot; alt=&quot;Block diagram of a CPU placed on a Debugging Bus&quot; width=&quot;320&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;All of these interactions, therefore, are easily understood as things that
could take place across a
“&lt;a href=&quot;/zipcpu/2017/05/23/simplebus.html&quot;&gt;bus&lt;/a&gt;”
with both memory and &lt;a href=&quot;https://en.wikipedia.org/wiki/Memory-mapped_I/O&quot;&gt;memory mapped
peripherals&lt;/a&gt; on it. 
Therefore, one might consider giving the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt; a &lt;a href=&quot;/zipcpu/2017/05/29/simple-wishbone.html&quot;&gt;bus slave
interface&lt;/a&gt;, and 
hooking it up to the &lt;a href=&quot;https://github.com/ZipCPU/dbgbus&quot;&gt;debugging
bus&lt;/a&gt; we’ve been working with (or something
similar) as shown in Fig 2.&lt;/p&gt;

&lt;p&gt;This approach has a couple of advantages.  First, the
&lt;a href=&quot;https://github.com/ZipCPU/dbgbus&quot;&gt;debugging bus&lt;/a&gt;
can be used to &lt;a href=&quot;/zipcpu/2017/05/20/which-came-first.html&quot;&gt;debug both the peripherals and the
memory&lt;/a&gt;
the &lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;
will need to work with later.  Second, if the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;
and &lt;a href=&quot;https://github.com/ZipCPU/dbgbus&quot;&gt;debugging
bus&lt;/a&gt; are each given the same view of the
peripheral set, then no separate address map and decoder needs to be created.
Third, this approach creates a means, independent of the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;,
of reading and writing to memory.  This could be very important later when
building a
program loader for the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;,
since it would then allow you to load the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;’s
program into memory and test it, without relying on any internal
&lt;a href=&quot;https://en.wikipedia.org/wiki/Read-only_memory&quot;&gt;ROM&lt;/a&gt;
within the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;
that would cause the design to need to be resynthesized anytime
something changes.&lt;/p&gt;

&lt;p&gt;The downside of this approach is that, depending upon your implementation, the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/aux/wbpriarb.v&quot;&gt;bus arbiter&lt;/a&gt;
may slow the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;’s
access to memory by a clock (or two).&lt;/p&gt;

&lt;table style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 3: ZipCPU&#39;s debugging interface&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/bare-cpu-debug-iface.svg&quot; alt=&quot;ZipCPU&#39;s bare debugging interface&quot; width=&quot;320&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;This was the approach taken by the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;, as shown in Fig 3, so we’ll use the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;
as our example of this approach in our discussion below.  The
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt; was
given two address locations on the debugging bus: a control and data
location.  (These are both discussed and defined in the 
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt; &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/doc/spec.pdf&quot;&gt;specification
document&lt;/a&gt;.)
A small wrapper around the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;ZipCPU
proper&lt;/a&gt;, called
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/zipbones.v&quot;&gt;ZipBones&lt;/a&gt;,
connects to the control register of the debug slave port and controls the
reset and halt lines into the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.com&quot;&gt;CPU&lt;/a&gt;.
These are used to implement reset, halt,
start, and step operations as we’ll see shortly.&lt;/p&gt;

&lt;p&gt;The &lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;
also has a second wrapper with more functionality to it, called
the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/zipsystem.v&quot;&gt;ZipSystem&lt;/a&gt;,
but since the logic within the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/zipbones.v&quot;&gt;ZipBones&lt;/a&gt;
is simpler, we’ll focus on it.&lt;/p&gt;

&lt;p&gt;Our discussion will focus on the reads and writes of these two locations,
the control and data ports, although you may wish to give your own
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;
more registers than just these two.&lt;/p&gt;

&lt;h2 id=&quot;reseting-halting-and-stepping-the-cpu&quot;&gt;Reseting, halting, and stepping the CPU&lt;/h2&gt;

&lt;p&gt;Let’s look at the control register for the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt; for a moment.  Writes to
this control register have the side-effect of controlling the
&lt;code class=&quot;highlighter-rouge&quot;&gt;i_halt&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;i_rst&lt;/code&gt; (reset) lines within the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;.
These side effects will cause the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;ZipCPU&lt;/a&gt;
to run, halt, step, or even reset as requested.&lt;/p&gt;

&lt;p&gt;The first side effect to be discussed is the reset.  Like many digital
logic cores, the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;ZipCPU&lt;/a&gt;
has a reset line going into it.  Controlling this reset is also quite
possibly the simplest interaction with the bus.  Specifically, any time
the control register is written with the reset bit set, the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
is reset.  Further, this reset line into the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
is initialized high, to make sure
that the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
always starts from a reset state.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;initial	cmd_reset = 1&#39;b1;
always @(posedge i_clk)
	cmd_reset &amp;lt;= ((dbg_cmd_write)&amp;amp;&amp;amp;(i_dbg_data[`RESET_BIT]));&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Inside the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;ZipCPU&lt;/a&gt;,
this reset line causes the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;ZipCPU&lt;/a&gt;
to reboot.  While it only (re-)initializes a minimum of variables, it is
enough to get the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
start from (nearly) known conditions.
In particular, all error conditions, cache valid indications, and pipeline
valid flags are cleared on reset.  Further, the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
is sent to a pre-programmed address.  What doesn’t happen is that the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Processor_register&quot;&gt;registers&lt;/a&gt;
are not re-initialized (the program counter and flags registers are though).
This allows some amount of fault recovery in software, if desired, prior to
setting all of the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Processor_register&quot;&gt;registers&lt;/a&gt;
to known conditions.&lt;/p&gt;

&lt;p&gt;The second control line going into the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
is a master halt line, &lt;code class=&quot;highlighter-rouge&quot;&gt;i_halt&lt;/code&gt;.  This line, if set, will cause the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
to halt in such a way that no instructions will go
into the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/cpuops.v&quot;&gt;ALU&lt;/a&gt;,
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/memops.v&quot;&gt;memory&lt;/a&gt;
or &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/div.v&quot;&gt;divide&lt;/a&gt;
units, but instructions that have already
entered these units will be allowed to finish.  It does this by setting the
stall logic associated with units, as we discussed during our
&lt;a href=&quot;/zipcpu/2017/08/23/cpu-pipeline.html&quot;&gt;CPU pipeline signaling
post&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The neat thing about the master halt line concept is that the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
is designed to halt at a stopping point between instructions when using it. 
Instructions that have entered the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/cpuops.v&quot;&gt;ALU&lt;/a&gt;,
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/memops.v&quot;&gt;memory&lt;/a&gt;
or &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/div.v&quot;&gt;divide&lt;/a&gt;
stages are allowed to complete, but further instructions are not allowed
to enter these stages.  As a result, the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
can be started, stepped, or halted by adjusting this master enable (i.e.
&lt;code class=&quot;highlighter-rouge&quot;&gt;i_halt&lt;/code&gt;) line.&lt;/p&gt;

&lt;p&gt;This &lt;code class=&quot;highlighter-rouge&quot;&gt;i_halt&lt;/code&gt; line into the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
is calculated from a couple of pieces of logic in the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/zipbones.v&quot;&gt;ZipBones&lt;/a&gt;
wrapper.  The first is the &lt;code class=&quot;highlighter-rouge&quot;&gt;cmd_halt&lt;/code&gt; register which is controlled by writes
to the control register.  On a reset, the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
will start in a halted mode (if the boolean parameter &lt;code class=&quot;highlighter-rouge&quot;&gt;START_HALTED&lt;/code&gt; is set to
true).  Ever afterwards, any write to the halt bit in the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/zipbones.v&quot;&gt;ZipBones&lt;/a&gt;
status register will set or clear this bit with two exceptions:
&lt;code class=&quot;highlighter-rouge&quot;&gt;cmd_step&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;cpu_break&lt;/code&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;`define	STEP_BIT	8
`define	HALT_BIT	10

always @(posedge i_clk)
	if ((i_rst)||(cmd_reset))
		cmd_halt &amp;lt;= (START_HALTED);
	else if (dbg_cmd_write)
		cmd_halt &amp;lt;= ((i_dbg_data[`HALT_BIT])&amp;amp;&amp;amp;(!i_dbg_data[`STEP_BIT]));
	else if ((cmd_step)||(cpu_break))
		cmd_halt &amp;lt;= 1&#39;b1;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The first exception is the &lt;code class=&quot;highlighter-rouge&quot;&gt;cmd_step&lt;/code&gt; logic.  If the halt bit is set
at the same time the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
is instructed to step forward by one clock, then the halt request is ignored
until the &lt;code class=&quot;highlighter-rouge&quot;&gt;cmd_step&lt;/code&gt; has been true for one cock.  We’ll come back to this
exception in a moment.&lt;/p&gt;

&lt;p&gt;The second exception is the &lt;code class=&quot;highlighter-rouge&quot;&gt;cpu_break&lt;/code&gt; signal.  This is shown in Fig. 3 as
the hardware break signal.  This is the signal the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
creates when it has encountered an unrecoverable fault–such as trying
to execute an unimplemented instruction while in the supervisor
(i.e. interrupt) state.  Other faults within the supervisor state
will also cause the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
to fault as well, such as the break instruction, a divide by zero fault from
within supervisor mode, or a
&lt;a href=&quot;/doc/wbspec_b4.pdf&quot;&gt;wishbone bus&lt;/a&gt;
error.  This &lt;code class=&quot;highlighter-rouge&quot;&gt;cmd_halt&lt;/code&gt; state captures that fault, and then holds the 
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
in a halted state for the debugger to come by and examine it.  (Alternatively,
the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
could be programmed to just reboot.)&lt;/p&gt;

&lt;p&gt;On that note, let’s return to looking at the step bit.  If the step bit is ever
set, the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/zipbones.v&quot;&gt;ZipBones&lt;/a&gt;
wrapper will release the halt line for one clock and then set it immediately
again.  This will cause one instruction to enter the
&lt;a href=&quot;/zipcpu/08/11/simple-alu.html&quot;&gt;ALU&lt;/a&gt;/memory pipeline stage.
It works in conjunction with the &lt;code class=&quot;highlighter-rouge&quot;&gt;cmd_halt&lt;/code&gt; bit above, so that if the step
register is ever true, the &lt;code class=&quot;highlighter-rouge&quot;&gt;cmd_halt&lt;/code&gt; register will get set on the next
instruction.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;initial	cmd_step  = 1&#39;b0;
always @(posedge i_clk)
	cmd_step &amp;lt;= (dbg_cmd_write)&amp;amp;&amp;amp;(i_dbg_data[`STEP_BIT]);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;While this description may sound simple, the devil is in the details.
For example, what happens when the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
is in the middle of an atomic operation?
What if an interrupt comes in while the debugger has the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
halted?  (It gets ignored.) What if the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
is in the middle of executing a pair of instructions from a compressed
instruction set word?  (The &lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;
has no ability to restart a compressed instruction word mid-way through …)
What if the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
is loading a cache line, and the memory is slow to respond? (i.e. broken)&lt;/p&gt;

&lt;p&gt;All of these details can make this halt line difficult to implement.&lt;/p&gt;

&lt;h2 id=&quot;clearing-the-cache&quot;&gt;Clearing the Cache&lt;/h2&gt;

&lt;p&gt;Before we move on to gaining access to
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Processor_register&quot;&gt;registers&lt;/a&gt;,
the control register offers one more big capability–that of
clearing the cache.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;initial	cmd_clear_pf_cache = 1&#39;b0;
always @(posedge i_clk)
	cmd_clear_pf_cache &amp;lt;= (dbg_cmd_write)&amp;amp;&amp;amp;(i_dbg_data[`CLEAR_CACHE_BIT];&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This is one of those annoying details that you may not think of initially.
If the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
is halted, the debugger is free to change memory, right?  Hence,
the debugger might wish to swap a normal instruction for a &lt;code class=&quot;highlighter-rouge&quot;&gt;BREAK&lt;/code&gt;
instruction or vice versa.  The problem lies in whether the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
has already read that instruction into its cache.  If the instruction the
debugger wishes to change is already in the cache, then the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
might not notice the fact that the debugger has changed that memory.
(The &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;ZipCPU&lt;/a&gt;
cache has no bus snooping capability … yet.)&lt;/p&gt;

&lt;p&gt;This command also clears the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;’s
pipeline for essentially the same reason–lest the instruction the debugger
wished to change was also within the pipeline already and just waiting to
execute.  We discussed how this was done earlier, when we discussed how
the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;
implemented its
&lt;a href=&quot;/zipcpu/2017/08/23/cpu-pipeline.md&quot;&gt;pipeline logic&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;reading-and-setting-registers&quot;&gt;Reading and Setting Registers&lt;/h2&gt;

&lt;p&gt;While a proper bus protocol makes sense for reading from
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Processor_register&quot;&gt;registers&lt;/a&gt;,
as we discussed above,
the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;’s
debug implementation isn’t quite a full bus implementation. Perhaps this
interaction is ready for redesign.  For now, I’ll just explain it as it is.&lt;/p&gt;

&lt;p&gt;The &lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt; control register contains a
set of six address bits.  Writes to the control register can be used to set
these six address bits as well other flags such as those we discussed above.
These then become the
&lt;a href=&quot;/doc/wbspec_b4.pdf&quot;&gt;wishbone&lt;/a&gt;
address of a register within the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;.
Ever after, reads from (or writes to) the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;
data register will adjust the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;.
&lt;a href=&quot;https://en.wikipedia.org/wiki/Processor_register&quot;&gt;register&lt;/a&gt;,
addressed by these six address bits.&lt;/p&gt;

&lt;p&gt;Remember how &lt;a href=&quot;/zipcpu/2017/05/23/simplebus.html&quot;&gt;we discussed
earlier&lt;/a&gt;
that a register read from a bus is just a big case statement?  The same is true
of the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;.
The only difference within the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;
is that 28 of the 32 &lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Processor_register&quot;&gt;registers&lt;/a&gt;,
are stored in an on-chip RAM while the other four are collected from a
set of control and status bits, and the two program counters.  Reading from
the bus, therefore, is almost the same as the big case statement
&lt;a href=&quot;/zipcpu/2017/05/23/simplebus.html&quot;&gt;we discussed earlier&lt;/a&gt;:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
begin
	// 28 registers are normal, and can be read from a memory
	o_dbg_reg &amp;lt;= regset[i_dbg_reg];

	// The PC is a bit different
	if (i_dbg_reg[3:0] == `CPU_PC_REG)
		o_dbg_reg &amp;lt;= w_debug_pc;
	else if (i_dbg_reg[3:0] == `CPU_CC_REG)
	begin
		// As is the flags register
		o_dbg_reg[14:0] &amp;lt;= (i_dbg_reg[4])?w_uflags:w_iflags;
		o_dbg_reg[15] &amp;lt;= 1&#39;b0;
		o_dbg_reg[31:23] &amp;lt;= w_cpu_info;
		o_dbg_reg[`CPU_GIE_BIT] &amp;lt;= gie;
	end
end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Writes are a touch more difficult, since the debugger needs to insert any
register writes into the processing chain of the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The &lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;.
handles such writes by creating a module parallel with the
&lt;a href=&quot;/zipcpu/08/11/simple-alu.html&quot;&gt;ALU&lt;/a&gt;
and &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/memops.v&quot;&gt;memory&lt;/a&gt;.
This module (really only a register and about 4 lines of code) is only active
if the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
is halted.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	dbgv &amp;lt;= (!i_rst)&amp;amp;&amp;amp;(i_halt)&amp;amp;&amp;amp;(i_dbg_we)&amp;amp;&amp;amp;(r_halted);
always @(posedge i_clk)
	dbg_val &amp;lt;= i_dbg_data;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Likewise, the register (and value) the
&lt;a href=&quot;/zipcpu/08/11/simple-alu.html&quot;&gt;ALU&lt;/a&gt; would’ve written
upon completion is modified during a halt as well:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	if (adf_ce_unconditional)
		// A normal register write, if the CPU is running
		alu_reg &amp;lt;= op_R
	else if ((i_halt)&amp;amp;&amp;amp;(i_dbg_we))
		// A debug register write, requiring the CPU to be halted
		alu_reg &amp;lt;= i_dbg_reg&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This then sets the write values on the clock before writeback.  (The
&lt;code class=&quot;highlighter-rouge&quot;&gt;adf_ce_unconditional&lt;/code&gt; flag is a piece of the 
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;’s
pipeline logic that we may come back and address in more detail later in
a post on pipelining.)&lt;/p&gt;

&lt;p&gt;Finally, so that the debugger can know that this write has occurred, the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt; holds the stall register high
any time it the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
hasn’t completely halted.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;assign	o_dbg_stall = !r_halted;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;You may notice, if you look at the code, that there’s no acknowledgement line.
Indeed, the acknowledgement line is generated at the bottom of the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/zipbones.v&quot;&gt;ZipBones&lt;/a&gt;
file based upon the fact that any request made to the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;, as long
as the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
isn’t stalled, is successful.&lt;/p&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;You may notice that the logic above only depends upon a couple of wires,
and that these wires have a very simple amount of logic assicated with them.
This is how digital design should be.  The trick to every problem is knowing
how to make the problem simple.&lt;/p&gt;

&lt;p&gt;In our case, this problem is simplified by first creating some form of
&lt;a href=&quot;https://github.com/ZipCPU/dbgbus/tree/master/hexbus&quot;&gt;debugging bus&lt;/a&gt;
to get a bus access point to our hardware and peripherals, as well as
understanding several various &lt;a href=&quot;/blog/2017/08/14/strategies-for-pipelining.html&quot;&gt;pipeline
strategies&lt;/a&gt;,
and then second understanding how a simple &lt;a href=&quot;/zipcpu/2017/08/23/cpu-pipeline.html&quot;&gt;CPU can use such a
strategy&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;This still leaves us with many more
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;
topics to discuss, such as how to add or remove peripherals by simply
adding or removing parameters from an
&lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt;
command line.
However, we are going to postpone that discussion until after I have the
opportunity to discuss
&lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt;
at &lt;a href=&quot;http://www.orconf.org&quot;&gt;ORCONF&lt;/a&gt; this year.&lt;/p&gt;

&lt;p&gt;In the meantime, then, I’d like to turn this blog’s attention to the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_signal_processing&quot;&gt;DSP&lt;/a&gt;
topics of both sine wave generation and
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;digital filtering&lt;/a&gt;.
We’ll come back to the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;
later–if for no other reason than I’ve been asked to discuss how to modify
&lt;a href=&quot;https://www.gcc.org&quot;&gt;GCC&lt;/a&gt;
to support a new
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt; 
backend.&lt;/p&gt;

&lt;hr /&gt;&lt;p&gt;&lt;em&gt;No man can serve two masters: for either he will hate the one, and love the other; or else he will hold to the one, and despise the other. Ye cannot serve God and mammon.  (Matt 6:24)&lt;/em&gt;</description>
        <pubDate>Fri, 25 Aug 2017 00:00:00 -0400</pubDate>
        <link>http://zipcpu.com/zipcpu/2017/08/25/hw-debugging.html</link>
        <guid isPermaLink="true">http://zipcpu.com/zipcpu/2017/08/25/hw-debugging.html</guid>
        
        
        <category>zipcpu</category>
        
      </item>
    
      <item>
        <title>The ZipCPU&#39;s pipeline logic</title>
        <description>&lt;p&gt;Now that we’ve discussed some &lt;a href=&quot;/blog/2017/08/14/strategies-for-pipelining.html&quot;&gt;general pipeline
strategies&lt;/a&gt;,
it’s time to take a look at how pipelining can work within a simple, in order,
pipelined &lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;.
Let’s take a look, therefore, at the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;
and see how it handles its pipeline logic.
What you’ll see is that the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;
uses a variant of the &lt;a href=&quot;/blog/2017/08/14/strategies-for-pipelining.html&quot;&gt;handshaking strategy we discussed
earlier&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;If you are unfamiliar with the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;, the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;
has five pipeline stages, as shown in Fig 1.&lt;/p&gt;

&lt;table style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 1: The ZipCPU Pipeline Structure&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/zipcpu.png&quot; alt=&quot;ZipCPU Pipeline Structurre&quot; width=&quot;380&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;There’s the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/pfcache.v&quot;&gt;prefetch and instruction
cache&lt;/a&gt;
stage, an &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/idecode.v&quot;&gt;instruction
decode&lt;/a&gt; stage,
a read operands stage, an
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/cpuops.v&quot;&gt;ALU&lt;/a&gt;
stage and a writeback stage.  The
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/cpuops.v&quot;&gt;ALU&lt;/a&gt;
stage is also placed parallel to a &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/pipemem.v&quot;&gt;memory operations
unit&lt;/a&gt;, a
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/div.v&quot;&gt;divide&lt;/a&gt; unit,
and a space for (a still undefined) floating point unit.&lt;/p&gt;

&lt;p&gt;As currently built, the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;
is an in-order processor.  It’s pipeline structure requires that
values going into the write-back unit be strictly in order.&lt;/p&gt;

&lt;p&gt;If you choose to look through the main
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt; &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;processor’s
code&lt;/a&gt;,
you may find it not as simple to read.  That’s because the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;
was written to thread a fine line between two separate purposes.  The first,
stated purpose, is to be a simple
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;–as
measured by the amount of logic used by the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;.
The second purpose is to be a fast
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;.
These two purposes are often in conflict.  Therefore, the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt; implementation allows you to
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/cpudefs.v&quot;&gt;select the performance you
want&lt;/a&gt;, and
adjust as necessary to fit the amount of logic you have available for a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;
within your
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Let’s use this as an example, though, in how a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;
pipeline can be created within an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;instruction-overview&quot;&gt;Instruction Overview&lt;/h2&gt;

&lt;p&gt;In order to make the following examples make sense, it might help to
understand how the various pipeline stages are supposed to interact.
This will make examples easier to understand.&lt;/p&gt;

&lt;p&gt;First, almost all
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;
instructions have the form:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-assembly&quot; data-lang=&quot;assembly&quot;&gt;   OP.C Ra,Rb+I&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;In this example, &lt;code class=&quot;highlighter-rouge&quot;&gt;OP&lt;/code&gt; is the operation.  It’s a 5-bit field identifying
which instruction is described by this instruction.  Think of this as &lt;em&gt;what&lt;/em&gt;
the &lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;
is being asked to do.  Indeed, four of the five &lt;code class=&quot;highlighter-rouge&quot;&gt;OP&lt;/code&gt; bits form the
multiplexer selection input within the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/cpuops.v&quot;&gt;ALU&lt;/a&gt; as
&lt;a href=&quot;/zipcpu/2017/08/11/simple-alu.html&quot;&gt;we discussed earlier&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The &lt;code class=&quot;highlighter-rouge&quot;&gt;C&lt;/code&gt; term is the condition.  This controls whether or not any value
is written back from the instruction.  For example, the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;
supports a &lt;code class=&quot;highlighter-rouge&quot;&gt;Z&lt;/code&gt; condition which will cause the instruction to only write back
its results if the &lt;code class=&quot;highlighter-rouge&quot;&gt;Z&lt;/code&gt; flag is set.  The other seven supported conditions are
discussed within the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/doc/spec.pdf&quot;&gt;ZipCPU
specification&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The &lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;
is primarily a two operand machine.  It has no three operand instructions.
Hence, every
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/cpuops.v&quot;&gt;ALU&lt;/a&gt;
instruction provides two inputs to the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/cpuops.v&quot;&gt;ALU&lt;/a&gt;,
&lt;code class=&quot;highlighter-rouge&quot;&gt;Ra&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;Rb+I&lt;/code&gt; and the output gets written back into register &lt;code class=&quot;highlighter-rouge&quot;&gt;Ra&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Finally, and this becomes important for the following discussion, almost
all instructions allow an immediate, usually 14-bits, to be added
to the second register, &lt;code class=&quot;highlighter-rouge&quot;&gt;Rb&lt;/code&gt;.  Alternatively, an 18-bit immediate value, &lt;code class=&quot;highlighter-rouge&quot;&gt;I&lt;/code&gt;,
may replace the ALU’s &lt;code class=&quot;highlighter-rouge&quot;&gt;Rb&lt;/code&gt; input so that &lt;code class=&quot;highlighter-rouge&quot;&gt;Rb&lt;/code&gt; is not used at all.&lt;/p&gt;

&lt;p&gt;So, how does this impact pipelining?&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;In the first stage, &lt;strong&gt;prefetch&lt;/strong&gt;, an instruction is read from memory.&lt;/p&gt;

    &lt;p&gt;The &lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;
can run with one of several prefetch modules.
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/prefetch.v&quot;&gt;[1]&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/dblfetch.v&quot;&gt;[2]&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/pipefetch.v&quot;&gt;[3]&lt;/a&gt;,
and
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/pfcache.v&quot;&gt;[4]&lt;/a&gt;.
Each of these modules has roughly the same interface, although the logic
within them can differ greatly.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;In the second stage, the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/idecode.v&quot;&gt;instruction
decode&lt;/a&gt;
stage, the parts of the instruction are drawn from from the instruction word
produced by the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/pfcache.v&quot;&gt;prefetch&lt;/a&gt;
stage.&lt;/p&gt;

    &lt;p&gt;As an example, this stage determines whether or not the instruction even has
registers &lt;code class=&quot;highlighter-rouge&quot;&gt;Ra&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;Rb&lt;/code&gt; encoded within it that need to be read from the
register set.  At the end of this stage the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;,
knows:&lt;/p&gt;

    &lt;p&gt;a. what registers it needs to read (&lt;code class=&quot;highlighter-rouge&quot;&gt;dcd_A&lt;/code&gt;, and &lt;code class=&quot;highlighter-rouge&quot;&gt;dcd_B&lt;/code&gt;),&lt;/p&gt;

    &lt;p&gt;b. if it needs to read from any register (&lt;code class=&quot;highlighter-rouge&quot;&gt;dcd_rA&lt;/code&gt;, and &lt;code class=&quot;highlighter-rouge&quot;&gt;dcd_rB&lt;/code&gt;)&lt;/p&gt;

    &lt;p&gt;c. what the immediate value is (&lt;code class=&quot;highlighter-rouge&quot;&gt;dcd_I&lt;/code&gt;), and if that value is zero
   (&lt;code class=&quot;highlighter-rouge&quot;&gt;dcd_Iz&lt;/code&gt;)&lt;/p&gt;

    &lt;p&gt;d. etc.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The third stage, the read operands stage, not only reads &lt;code class=&quot;highlighter-rouge&quot;&gt;Ra&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;Rb&lt;/code&gt; from
the register file, but also adds &lt;code class=&quot;highlighter-rouge&quot;&gt;I&lt;/code&gt; to &lt;code class=&quot;highlighter-rouge&quot;&gt;Rb&lt;/code&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The fourth stage calculates the &lt;code class=&quot;highlighter-rouge&quot;&gt;OP&lt;/code&gt; function on the values from &lt;code class=&quot;highlighter-rouge&quot;&gt;Ra&lt;/code&gt; and
&lt;code class=&quot;highlighter-rouge&quot;&gt;Rb+I&lt;/code&gt;.&lt;/p&gt;

    &lt;p&gt;If this is an
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/cpuops.v&quot;&gt;ALU&lt;/a&gt;,
instruction, the &lt;code class=&quot;highlighter-rouge&quot;&gt;OP&lt;/code&gt; field controls which potential output from the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/cpuops.v&quot;&gt;ALU&lt;/a&gt;,
&lt;a href=&quot;/zipcpu/2017/08/11/simple-alu.html&quot;&gt;will be selected&lt;/a&gt;.&lt;/p&gt;

    &lt;p&gt;If this is a &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/pipemem.v&quot;&gt;memory
operation&lt;/a&gt;,
a store will place the value &lt;code class=&quot;highlighter-rouge&quot;&gt;Ra&lt;/code&gt; into
memory location &lt;code class=&quot;highlighter-rouge&quot;&gt;Rb+I&lt;/code&gt;.  A load will read from memory
&lt;code class=&quot;highlighter-rouge&quot;&gt;Rb+I&lt;/code&gt; and present the result to the writeback unit.&lt;/p&gt;

    &lt;p&gt;Memory accesses, divides, and multiplies may all take longer than a single
clock in this stage.  We’ll need to come back and discuss how to handle
this later.&lt;/p&gt;

    &lt;p&gt;If done well, the outputs of this stage, whether from the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/cpuops.v&quot;&gt;ALU&lt;/a&gt;
or the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/memops.v&quot;&gt;memory
unit&lt;/a&gt;
can go directly back into this stage as inputs if so desired, as shown
in Fig 2.&lt;/p&gt;

    &lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 2: Answers go back into the ALU&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/cpu-bypass.svg&quot; alt=&quot;Answers go back into the ALU&quot; width=&quot;580&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

    &lt;p&gt;This will take place any time the output of the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/cpuops.v&quot;&gt;ALU&lt;/a&gt;
stage forms the input for the next instruction.  Indeed, this is a key
requirement for a high speed
pipelined &lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;.&lt;/p&gt;

    &lt;p&gt;However, if the output of the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/cpuops.v&quot;&gt;ALU&lt;/a&gt;
gets placed into the &lt;code class=&quot;highlighter-rouge&quot;&gt;Rb&lt;/code&gt; register input of the next instruction, &lt;em&gt;and&lt;/em&gt;
if that instruction
has an immediate, &lt;code class=&quot;highlighter-rouge&quot;&gt;I&lt;/code&gt;, that needs to be added to it (&lt;code class=&quot;highlighter-rouge&quot;&gt;dcd_zI&lt;/code&gt; is non-zero),
then the output cannot go directly back into the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/cpuops.v&quot;&gt;ALU&lt;/a&gt;.
It will instead need to go back to the read operands stage, causing
a pipeline bubble in the process.  This other path is shown by the dotted
line in Fig 2.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Finally, in the writeback unit, if the &lt;code class=&quot;highlighter-rouge&quot;&gt;C&lt;/code&gt; condition matches, the result
is written back into the register set.&lt;/p&gt;

    &lt;p&gt;Conditional branches are detected in this stage.  We’ll have to come back
and discuss how to handle this within the pipeline later as well.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;This is nominally how the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;
handles and uses its pipeline.  This simple pipeline, though, has all kinds
of hazards—many of which we’ll discuss below.&lt;/p&gt;

&lt;h2 id=&quot;pipeline-stalls-and-bubbles&quot;&gt;Pipeline Stalls and Bubbles&lt;/h2&gt;

&lt;p&gt;Before diving into pipeline specifics, let’s define a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bubble_(computing)&quot;&gt;pipeline stall&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;According to &lt;a href=&quot;https://en.wikipedia.org/wiki/Bubble_(computing)&quot;&gt;wikipedia&lt;/a&gt;,
a &lt;a href=&quot;https://en.wikipedia.org/wiki/Bubble_(computing)&quot;&gt;pipeline stall&lt;/a&gt;
is a condition where there’s no valid instruction within a particular pipeline
stage.  &lt;a href=&quot;https://en.wikipedia.org&quot;&gt;Wikipedia&lt;/a&gt; declares a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bubble_(computing)&quot;&gt;pipeline stall&lt;/a&gt;
to be synonymous with a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bubble_(computing)&quot;&gt;pipeline bubble&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;As the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt; uses the term, a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bubble_(computing)&quot;&gt;pipeline stall&lt;/a&gt;
takes place when there &lt;em&gt;is&lt;/em&gt; a valid instruction within a particular pipeline
stage, but when that instruction cannot move forward.&lt;/p&gt;

&lt;p&gt;For example, the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/div.v&quot;&gt;divide&lt;/a&gt;
takes roughly 32-clocks to complete.  During these 32-clocks, instructions in
the prior stage, the read operands stage, will be stuck there until the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/div.v&quot;&gt;divide&lt;/a&gt;
completes.   Likewise, the writeback stage will be idle during this time,
being reserved for writing back the results of the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/div.v&quot;&gt;divide&lt;/a&gt;
instruction.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org&quot;&gt;Wikipedia&lt;/a&gt;’s definition declares the condition
where no valid data is within a pipeline stage to be called a stall.  This
seems to me to be more of a consequence of a stall, than a stall itself.
The &lt;strong&gt;pipeline bubble&lt;/strong&gt; term describes this better, although
&lt;a href=&quot;https://en.wikipedia.org&quot;&gt;Wikipedia&lt;/a&gt; declares the two terms to be synonymous.&lt;/p&gt;

&lt;p&gt;If you watch the pipeline, such as within the demonstration we’ll discuss
later, you can visually see &lt;strong&gt;bubble&lt;/strong&gt;s form within it where there are no valid
instructions.&lt;/p&gt;

&lt;h2 id=&quot;unique-pipeline-needs&quot;&gt;Unique Pipeline Needs&lt;/h2&gt;

&lt;p&gt;There are two basic goals that a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;
has with respect to pipelining.  These two goals are common among
many pipeline systems:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Keep every stage filled.&lt;/p&gt;

    &lt;p&gt;For example, the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;
is capable of completing and retiring one
&lt;a href=&quot;/zipcpu/2017/08/11/simple-alu.html&quot;&gt;ALU&lt;/a&gt;
instruction per clock.  All of the pipeline logic within the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;CPU&lt;/a&gt;
has been designed so as to keep one instruction completing on every clock.&lt;/p&gt;

    &lt;p&gt;This is a common goal of any high speed pipeline.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Satisfy any pre-requisites for instruction operations.&lt;/p&gt;

    &lt;p&gt;An &lt;a href=&quot;/zipcpu/2017/08/11/simple-alu.html&quot;&gt;ALU&lt;/a&gt;
operation cannot complete if its values haven’t finished being produced
from other parts of the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;CPU&lt;/a&gt;.
For example, if
register &lt;code class=&quot;highlighter-rouge&quot;&gt;R0&lt;/code&gt;  is read from slow memory in one instruction and then
immediately used on the next instruction, the pipeline logic will need to
stall the second instruction, waiting for the
&lt;a href=&quot;/zipcpu/2017/08/11/simple-alu.html&quot;&gt;ALU&lt;/a&gt;,
until &lt;code class=&quot;highlighter-rouge&quot;&gt;R0&lt;/code&gt; is available.&lt;/p&gt;

    &lt;p&gt;This problem is even worse if an immediate is to be added to the value
read from memory prior to heading into the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/cpuops.v&quot;&gt;ALU&lt;/a&gt;.
In that case, it’s not just the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/cpuops.v&quot;&gt;ALU&lt;/a&gt;
that needs to stall, but the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;
also needs to stall the read operands stage where that immediate addition
takes place.  (We discussed this with Fig 2 above)&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;A &lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;,
though, has some other pipeline needs beyond the more traditional data flow
processing pipeline.  Specifically,
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;’s
need to be able to jump from one instruction in memory to another.  This
creates some unusual pipeline requirements.&lt;/p&gt;

&lt;p&gt;At its most basic level, a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;
needs be able to flush or clear its pipeline any time a branch renders
the work done in a prior stage irrelevant.
The worst case scenario is when a branch takes place that can’t be
caught prior to the writeback stage.  In that case, the whole pipeline will
need to be flushed, costing the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;
one clock per pipeline stage that cannot be completed.
The &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;ZipCPU&lt;/a&gt;
captures this logic with the &lt;code class=&quot;highlighter-rouge&quot;&gt;clear_pipeline&lt;/code&gt; signal.&lt;/p&gt;

&lt;p&gt;Other things can cause sudden pipeline changes as well.  For example, what
happens on an interrupt (peripheral initiated), a trap (user initiated), or
a fault?  The
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;
will need to start processing instructions from a new location in the
instruction stream–that of the interrupt service routine (ISR).
The &lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;
handles this condition by flushing the pipeline on any change of interrupt
status.
The &lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt; is also unique in that the
interrupt address is kept within an alternate register set.  (See the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/doc/spec.pdf&quot;&gt;ZipCPU
specification&lt;/a&gt;
for details.&lt;/p&gt;

&lt;p&gt;Indeed, lots of things need to change within the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;
every time it switches to an interrupt context, or back again.
If you want to trace this logic, feel free to
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;look for&lt;/a&gt;
the &lt;code class=&quot;highlighter-rouge&quot;&gt;w_switch_to_interrupt&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;w_release_from_interrupt&lt;/code&gt; wires.  The first
will be true any time the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;
switches to an interrupt context, the second will be true anytime the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;
switches back.&lt;/p&gt;

&lt;p&gt;Now, with all that as background, we can discuss the logic necessary to handle
a pipeline handshake.&lt;/p&gt;

&lt;h2 id=&quot;cpu-handshake&quot;&gt;CPU Handshake&lt;/h2&gt;

&lt;table style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 3: ZipCPU Pipeline Signals&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/pipeline-blocks-cpu.svg&quot; alt=&quot;ZipCPU Pipeline Signals&quot; width=&quot;380&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;The
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;
pipeline is controlled primarily with three logic signals per stage:
&lt;code class=&quot;highlighter-rouge&quot;&gt;stalled&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;valid&lt;/code&gt;, and &lt;code class=&quot;highlighter-rouge&quot;&gt;CE&lt;/code&gt;, as shown in Fig 3 to the right.  The logic is
designed around the idea of processing the data from the previous stage any
time a &lt;code class=&quot;highlighter-rouge&quot;&gt;CE&lt;/code&gt; line is set.  The basic logic is this: if a stage is not stalled,
and if the previous stage is valid, then the &lt;code class=&quot;highlighter-rouge&quot;&gt;CE&lt;/code&gt; line will be set.  The &lt;code class=&quot;highlighter-rouge&quot;&gt;CE&lt;/code&gt;
control signal is used to determine when to clock the data from the last stage
forward.&lt;/p&gt;

&lt;p&gt;Let’s walk though that for a moment.&lt;/p&gt;

&lt;p&gt;First, each stage has a condition (or set of conditions) that might stall the
prior stage from entering this stage.  This is the stall logic for this stage.&lt;/p&gt;

&lt;p&gt;For example, the read operands stage will stall any time the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/cpuops.v&quot;&gt;ALU&lt;/a&gt;
is already busy, the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/memops.v&quot;&gt;memory
unit&lt;/a&gt; is busy
with a read, or the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/div.v&quot;&gt;divide&lt;/a&gt; is busy.
The lines &lt;code class=&quot;highlighter-rouge&quot;&gt;alu_busy&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;mem_busy&lt;/code&gt;, and &lt;code class=&quot;highlighter-rouge&quot;&gt;div_busy&lt;/code&gt; are used to capture these
conditions.  An exception is made if the memory unit is busy &lt;em&gt;writing&lt;/em&gt; a value
over the bus.  In this case, &lt;code class=&quot;highlighter-rouge&quot;&gt;mem_rdbusy&lt;/code&gt; captures the idea that the memory
is busy with a read and not a write.  Likewise, the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/cpuops.v&quot;&gt;ALU&lt;/a&gt;
will also stall if the external halt request line is true.  (We’ll come back and
discuss this when discussing how to debug a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt; later.)
Another, less common, example is that the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/cpuops.v&quot;&gt;ALU&lt;/a&gt;
will stall any time the condition codes are written to manually–lest the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/cpuops.v&quot;&gt;ALU&lt;/a&gt;
write a value back according to the wrong conditions.&lt;/p&gt;

&lt;p&gt;In general, though, the stall logic looks like:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;assign	stage[n]_stalled = (stage[n]_valid)&amp;amp;&amp;amp;((stage[n+1]_stalled)
		||(things that would stall this stage));&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;In this case, I’m using &lt;code class=&quot;highlighter-rouge&quot;&gt;stage[n]_stalled&lt;/code&gt; to describe the &lt;code class=&quot;highlighter-rouge&quot;&gt;stalled&lt;/code&gt; variable
for this stage.  If you look within the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;,
you’ll find variables named &lt;code class=&quot;highlighter-rouge&quot;&gt;pf_stalled&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;dcd_stalled&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;op_stalled&lt;/code&gt;,
&lt;code class=&quot;highlighter-rouge&quot;&gt;alu_stalled&lt;/code&gt;, and &lt;code class=&quot;highlighter-rouge&quot;&gt;mem_stalled&lt;/code&gt;.  These variables capture this
logic, together with all of the more obscure reasons why the &lt;code class=&quot;highlighter-rouge&quot;&gt;stalled&lt;/code&gt; line
might be made true as well–such as on a debugging &lt;code class=&quot;highlighter-rouge&quot;&gt;BREAK&lt;/code&gt; instruction.&lt;/p&gt;

&lt;p&gt;Second, if any stage is not stalled, and if the prior stage has valid data
within it, then we can step that stage forward.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;assign	stage[n]_ce = (stage[n-1]_valid)&amp;amp;&amp;amp;(!stage[n]_stalled);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;If you pay close attention, you might find this looks a lot like the
handshake signal, &lt;code class=&quot;highlighter-rouge&quot;&gt;(i_ce)&amp;amp;&amp;amp;(!o_busy)&lt;/code&gt;, that we discussed in our &lt;a href=&quot;/blog/2017/08/14/strategies-for-pipelining.html&quot;&gt;last post on
pipelining&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Inside the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;,
these various pipeline variables are named
&lt;code class=&quot;highlighter-rouge&quot;&gt;dcd_ce&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;op_ce&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;alu_ce&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;mem_ce&lt;/code&gt;, and &lt;code class=&quot;highlighter-rouge&quot;&gt;div_ce&lt;/code&gt;.  There’s also a similar
&lt;code class=&quot;highlighter-rouge&quot;&gt;master_ce&lt;/code&gt; which is controlled from the external debugging interface–something
we’ll get to later.&lt;/p&gt;

&lt;p&gt;With these signals out of the way, we can start working through the pipeline
signals.  The first registered signal is the &lt;code class=&quot;highlighter-rouge&quot;&gt;valid&lt;/code&gt; signal.  This signal
indicates whether or not a particular stage has valid data within it.
To get valid data into a stage, the prior stage must have valid data, and
this stage cannot be stalled.  Hence, we have the following logic:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	// On any reset or clear pipeline, we clear the stage valid
	// register
	if ((i_reset)||(clear_pipeline))
	begin
		stage[n]_valid &amp;lt;= 1&#39;b0;
	end if (stage[n]_ce)
	begin
		// Otherwise, we accept the data from the previous
		// stage, and operate upon it if necessary.
		stage[n]_valid &amp;lt;= stage[n-1]_valid;
	end else if (stage[n+1]_ce)
		// If there&#39;s nothing valid to come in, but the next stage
		// has taken our data, then we are no longer valid here anymore.
		stage[n]_valid &amp;lt;= 1&#39;b0;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Within the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;,
the basic valid registers are called &lt;code class=&quot;highlighter-rouge&quot;&gt;pf_valid&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;dcd_valid&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;op_valid&lt;/code&gt;.
The &lt;code class=&quot;highlighter-rouge&quot;&gt;op_valid&lt;/code&gt; signal is also broken into three separate signals, depending
upon which stage the read operands stage moves to next:
&lt;code class=&quot;highlighter-rouge&quot;&gt;op_valid_alu&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;op_valid_mem&lt;/code&gt;, and  &lt;code class=&quot;highlighter-rouge&quot;&gt;op_valid_div&lt;/code&gt;.  Finally, the output
of the ALU/MEM/DIV stage is captured by the &lt;code class=&quot;highlighter-rouge&quot;&gt;alu_valid&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;mem_valid&lt;/code&gt;, and
&lt;code class=&quot;highlighter-rouge&quot;&gt;div_valid&lt;/code&gt; signals.  Indeed, these signals are used to determine whether
or not valid data is ready to be written back.&lt;/p&gt;

&lt;p&gt;One particular difficulty with this language is the idea of an illegal
instruction.  Within the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;,
a stage containing an illegal instruction has the &lt;code class=&quot;highlighter-rouge&quot;&gt;valid&lt;/code&gt; line set high.
This is because an illegal instruction needs to be processed like any other
instruction, and the &lt;code class=&quot;highlighter-rouge&quot;&gt;valid&lt;/code&gt; line controls when processing moves forward.
The alternative, moving instructions forward any time &lt;code class=&quot;highlighter-rouge&quot;&gt;valid&lt;/code&gt; &lt;em&gt;or&lt;/em&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;illegal&lt;/code&gt; were true, just costs more logic than required.&lt;/p&gt;

&lt;p&gt;Each stage has many more logic lines beyond the ones we just discussed.
These can often be treated in a much simpler fashion, though.  As a result,
these other signals are often sate based upon the simple &lt;code class=&quot;highlighter-rouge&quot;&gt;stage[n]_ce&lt;/code&gt; signal:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	if (stage[n]_ce)
		stage[n]_data &amp;lt;= ... // function of stage[n-1]_data&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Those are the basics of how the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;
handles pipelining.  Be aware, though, &lt;em&gt;the devil is in the details&lt;/em&gt;.
There are all kinds of pipeline hazards that you may not expect when first
building a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;My best advice for others, when trying to find these pipeline problems, is
to methodically debug your
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;
using
&lt;a href=&quot;https://www.veripool.org/wiki/verilator&quot;&gt;Verilator&lt;/a&gt; and some small programs.
Use &lt;a href=&quot;https://gcc.gnu.org&quot;&gt;GCC&lt;/a&gt;
both all optimizations turned on, as well as with all
optimizations turned off.  The two environments create very different pipeline
environments, and programs working in the one may not work in the other.  My
second piece of advice would be to create a program containing every pipeline
hazard you can think of, and to turn this program into a test program for the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;.
You can find the &lt;a href=&quot;https://github.com/ZipCPU/zipcu&quot;&gt;ZipCPU&lt;/a&gt;’s
&lt;a href=&quot;https://github.com/ZipCPU/openarty/blob/master/sw/board/cputest.c&quot;&gt;CPU testing
program&lt;/a&gt;
within the &lt;a href=&quot;https://github.com/ZipCPU/openarty&quot;&gt;OpenArty&lt;/a&gt; distribution.&lt;/p&gt;

&lt;h2 id=&quot;demonstration&quot;&gt;Demonstration&lt;/h2&gt;

&lt;p&gt;I have a wonderful demonstration of all of this that I would like to post, but
to see it I may need some help from my readers.&lt;/p&gt;

&lt;p&gt;Specifically, the demonstration involves building the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt; distribution, and then running the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/bench/asm/simtest.s&quot;&gt;simtest&lt;/a&gt;
program within the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/sim/verilated/zipcpu_tb.cpp&quot;&gt;simulator&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/sim/verilated/zipcpu_tb.cpp&quot;&gt;simulator&lt;/a&gt;
allows you to watch how well the pipeline is filled at any given clock, as
well as the ability to “watch” the signals discussed above.  Further, by
adjusting the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/cpudefs.v&quot;&gt;pipeline
parameters&lt;/a&gt;,
you can see how the pipeline and
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
are affected as the logic within the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;,
is increased or decreased.  Indeed, you can watch the &lt;code class=&quot;highlighter-rouge&quot;&gt;valid&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;CE&lt;/code&gt;, and
&lt;code class=&quot;highlighter-rouge&quot;&gt;stall&lt;/code&gt; lines as they get set and adjusted on a clock by clock basis.&lt;/p&gt;

&lt;p&gt;Nominally, the instructions to do this would require something like:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span class=&quot;c&quot;&gt;# Install packages necessary to build the simulator&lt;/span&gt;
sudo apt-get install bc verilator
&lt;span class=&quot;c&quot;&gt;# Install packages necessary to build GCC&lt;/span&gt;
sudo apt-get install flex bison libncurses5-dev
sudo apt-get install libmpfr-dev libmpc-dev libgmp-dev libmpfr-doc
&lt;span class=&quot;c&quot;&gt;# Install libelf.  libelf is used to load executable files into both&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;# the simulator and onto any actual FPGA H/W&lt;/span&gt;
sudo apt-get install libelf-dev
&lt;span class=&quot;c&quot;&gt;#&lt;/span&gt;
git clone https://github.com/ZipCPU/zipcpu
&lt;span class=&quot;nb&quot;&gt;cd &lt;/span&gt;zipcpu
make
&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[[&lt;/span&gt; ! -x sw/install/cross-tools/bin/zip-gcc &lt;span class=&quot;o&quot;&gt;]]&lt;/span&gt;;
&lt;span class=&quot;k&quot;&gt;then
  &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;GCC failed to build&quot;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;else
  if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[[&lt;/span&gt; ! -x sim/verilator/zipsys_tb &lt;span class=&quot;o&quot;&gt;]]&lt;/span&gt;;
  &lt;span class=&quot;k&quot;&gt;then
    &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;The simulator failed to build&quot;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;else
    &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;PATH&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$PATH&lt;/span&gt;:&lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;pwd&lt;/span&gt;&lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;/sw/install/cross-tools/bin
    &lt;span class=&quot;nb&quot;&gt;cd &lt;/span&gt;bench/asm
    make simtest
    &lt;span class=&quot;nb&quot;&gt;cd&lt;/span&gt; ../../sim/verilator
    &lt;span class=&quot;c&quot;&gt;# Run the demo&lt;/span&gt;
    ./zipsys_tb ../../bench/asm/simtest
    &lt;span class=&quot;c&quot;&gt;# Press the &#39;t&#39; key to create a system clock &#39;tick&#39;s until things stop&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;#   changing&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;#   Watch how instructions work their way through the various pipeline&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;#   stages at the bottom of the screen&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;# &#39;q&#39; can be used to quit.&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;# &#39;r&#39; can be used to &#39;reboot&#39; the computer, and start the simulation over&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;fi
fi&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This is notional only, the above script has not been “tested” … but I think
it captures the idea of what I would have you do.&lt;/p&gt;

&lt;p&gt;My specific problem is that, while the design works nicely on my own system,
I’d love to have some help from others who would like to try running the
design on their own systems–so as to get some redundance across operating
systems and version differences.  If you are interested in trying this,
please write be at the address below if you have problems, or perhaps
just to tell me of your success.  Enough successes, and I’ll write a more
complete post about how to watch the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;
pipeline in action.&lt;/p&gt;

&lt;p&gt;(Instructions for installing the prerequisites on a Windows machine, using
&lt;a href=&quot;https://cygwin.com&quot;&gt;Cygwin&lt;/a&gt;, can be found
&lt;a href=&quot;/blog/2017/07/28/cygwin-fpga.html&quot;&gt;here&lt;/a&gt;)&lt;/p&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;That’s it!  The
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;
basically uses the &lt;a href=&quot;/blog/2017/08/14/strategies-for-pipelining.html&quot;&gt;handshake
approach&lt;/a&gt;
to handling pipeline stalls that &lt;a href=&quot;/blog/2017/08/14/strategies-for-pipelining.html&quot;&gt;we discussed
earlier&lt;/a&gt;.
A couple extra variables for logic expression allow the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;
to be able to detect and respond appropriately to pipeline hazards, stalling the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;.
anytime it is necessary to do so.&lt;/p&gt;

&lt;p&gt;Now that we’ve gone through this example, I’d like to come back and discuss
how to debug a &lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;
running within an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
in general.  That post has been mostly written for some time, but has been
waiting for this background beneath it to be explained.&lt;/p&gt;

&lt;p&gt;I’d also like to post more complete instructions for the pipeline demonstration
above, outlining how data moves through the
various stages of the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;
pipeline.  I’ll hold off on the demonstration, post, until I have some
confidence that it will work on the greatest number of computers.&lt;/p&gt;

&lt;hr /&gt;&lt;p&gt;&lt;em&gt;For I know that my redeemer liveth, and that he shall stand at the latter day upon the earth (Job 19:25)&lt;/em&gt;</description>
        <pubDate>Wed, 23 Aug 2017 00:00:00 -0400</pubDate>
        <link>http://zipcpu.com/zipcpu/2017/08/23/cpu-pipeline.html</link>
        <guid isPermaLink="true">http://zipcpu.com/zipcpu/2017/08/23/cpu-pipeline.html</guid>
        
        
        <category>zipcpu</category>
        
      </item>
    
      <item>
        <title>Rules for new FPGA designers</title>
        <description>&lt;p&gt;It’s a new school year!&lt;/p&gt;

&lt;p&gt;For all you new students out there, please accept
my welcome to the wonderful world of digital design.  I am neither a student
nor a professor, and yet I have helped many students through their projects
on the &lt;a href=&quot;https://forum.digilentinc.com&quot;&gt;Digilent forum&lt;/a&gt;, as well as on
&lt;a href=&quot;https://webchat.freenode.net&quot;&gt;freenode IRC&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;This post is an outgrowth of my own experience counseling beginners on
&lt;a href=&quot;https://forum.digilentinc.com&quot;&gt;Digilent’s forums&lt;/a&gt;.  Indeed, sometimes I
feel like I’m a broken record there repeating over and over the same rules
for newbies.&lt;/p&gt;

&lt;p&gt;So, before you ask for help, here are a couple rules to keep you from
running into the same trouble others have gotten stuck within:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Build your design with only one clock.&lt;/p&gt;

    &lt;p&gt;If the clock that comes into your chip is the wrong speed for your one
clock, then use a &lt;a href=&quot;https://www.xilinx.com/support/documentation/user_guides/ug472_7Series_Clocking.pdf&quot;&gt;PLL/MMCM&lt;/a&gt; to create the speed you want/need.&lt;/p&gt;

    &lt;p&gt;&lt;a href=&quot;/blog/2017/06/02/generating-timing.html&quot;&gt;This post&lt;/a&gt;
discusses a variety of alternative timing approaches, done within clocked
logic, that don’t require additional clocks to work.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Do &lt;em&gt;not&lt;/em&gt; transition on any negative (falling) edges.&lt;/p&gt;

    &lt;p&gt;Falling edge clocks should be considered a violation of the one
clock principle, as they act like separate clocks.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Do &lt;em&gt;not&lt;/em&gt; transition on the positive (rising) edge of anything other than
your system clock.&lt;/p&gt;

    &lt;p&gt;Lot’s of students seem to want to &lt;a href=&quot;/blog/2017/08/04/debouncing.html&quot;&gt;treat a button like a
clock&lt;/a&gt;, for example.
They then struggle to understand why their design isn’t working.
&lt;a href=&quot;/blog/2017/08/04/debouncing.html&quot;&gt;Here&lt;/a&gt; are some
better approaches that actually work with buttons.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Synchronize all external wire inputs by passing them through two clocked
flip-flops before using them.&lt;/p&gt;

    &lt;p&gt;This helps to avoid problems with
&lt;a href=&quot;https://en.wikipedia.org/wiki/Metastability_in_electronics&quot;&gt;metastability&lt;/a&gt;.
We discussed &lt;a href=&quot;/blog/2017/08/04/debouncing.html&quot;&gt;how to synchronize inputs
here&lt;/a&gt; when dealing with
buttons.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Do &lt;em&gt;not&lt;/em&gt; use an asynchronous reset within your design.&lt;/p&gt;

    &lt;p&gt;Test for any reset within an always block on the positive edge of your system
clock like everything else.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Simulate everything before placing it onto your hardware&lt;/p&gt;

    &lt;p&gt;The unique thing about simulation is that a good simulator will allow you
to see and examine &lt;em&gt;every&lt;/em&gt; piece of logic on &lt;em&gt;every&lt;/em&gt; simulated clock.
A good simulator will also allow you to simulate any external peripherals,
so that you don’t need your hardware to run your simulator.&lt;/p&gt;

    &lt;p&gt;You can read about &lt;a href=&quot;/blog//2017/06/23/my-dbg-philosophy.html&quot;&gt;my own debugging philosophy
here&lt;/a&gt;.&lt;/p&gt;

    &lt;p&gt;You can also read about &lt;a href=&quot;/blog/2017/06/21/looking-at-verilator.html&quot;&gt;how to simulate hardware together with your design
here&lt;/a&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Build unit tests that can “prove” your components work, via a simulator,
so that when you later make changes to “improve” the component, you will
know that the improvements haven’t broken anything.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Build simulations that will support not only unit test, but also full up
integration testing&lt;/p&gt;

    &lt;p&gt;This was also discussed in the post about &lt;a href=&quot;/blog/2017/06/23/my-dbg-philosophy.html&quot;&gt;my own debugging
philosophy&lt;/a&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Make sure you simulate whatever means you will use for debugging your design
before you transition to hardware.&lt;/p&gt;

    &lt;p&gt;An &lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt; can
be a very difficult black box to get debugging information out of.  Before
you transition your design into an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;, I
recommend having some means of getting debugging information back out.  This
means needs to be simulated and proven along with everything else.&lt;/p&gt;

    &lt;p&gt;If you’ve read much of my blog, you’ll know that I highly recommend
&lt;a href=&quot;/blog/2017/06/16/dbg-bus-forest.html&quot;&gt;using a debugging
bus&lt;/a&gt; that
controls your
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt; over
&lt;a href=&quot;https://en.wikipedia.org/wiki/Transmission_Control_Protocol&quot;&gt;TCP&lt;/a&gt;/&lt;a href=&quot;https://en.wikipedia.org/wiki/Internet_protocol_suite&quot;&gt;IP&lt;/a&gt;.  That allows you &lt;a href=&quot;/blog/2017/06/17/why-network-debugging.html&quot;&gt;to
control&lt;/a&gt;
your &lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
simulation, or your
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt; itself,
from the same software.&lt;/p&gt;

    &lt;p&gt;While there are proprietary solutions to this problem that do not require a
&lt;a href=&quot;/blog/2017/06/16/dbg-bus-forest.html&quot;&gt;debugging bus&lt;/a&gt;,
you may struggle to integrate your
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
interaction software with them.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Don’t use &lt;a href=&quot;https://en.wikipedia.org/wiki/Magic_number_(programming)&quot;&gt;magic numbers&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;A &lt;a href=&quot;https://en.wikipedia.org/wiki/Magic_number_(programming)&quot;&gt;magic number&lt;/a&gt;
is a number that shows up without explanation or dependency within your code.&lt;/p&gt;

    &lt;p&gt;This one is so important, that &lt;a href=&quot;https://twitter.com/dEnergy_dTime&quot;&gt;Marcus
Muller&lt;/a&gt; chose to echo this sentiment
as well in the twitter section down below.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Never write the same code twice.&lt;/p&gt;

    &lt;p&gt;Write it once, write it well, and then reuse it.  Fix it, if you must fix
it, just don’t rewrite it over and over again for every project.   If done
well, this will give you a jump start on any future projects.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;rules-for-software-engineers&quot;&gt;Rules for software engineers&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Hardware design is &lt;em&gt;not&lt;/em&gt; like software design&lt;/p&gt;

    &lt;p&gt;In software, you can use &lt;code class=&quot;highlighter-rouge&quot;&gt;printf()&lt;/code&gt; or a debugger to &lt;em&gt;see&lt;/em&gt; every variable in
your algorithm.  In an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;, you
will struggle to &lt;em&gt;see&lt;/em&gt; anything.&lt;/p&gt;

    &lt;p&gt;Even if you could &lt;em&gt;see&lt;/em&gt; everything in an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;, you
wouldn’t be able to stop the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt; to
&lt;em&gt;see&lt;/em&gt; any high speed interactions like you can stop a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt; in a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Debugger&quot;&gt;debugger&lt;/a&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Simulation first.&lt;/p&gt;

    &lt;p&gt;The only time you will be able to &lt;em&gt;see&lt;/em&gt; everything is in simulation.  Start
your debugging process there.
&lt;a href=&quot;/blog//2017/06/21/looking-at-verilator.html&quot;&gt;This post&lt;/a&gt;
discusses how you can continue debugging by &lt;code class=&quot;highlighter-rouge&quot;&gt;printf()&lt;/code&gt;–but
only in simulation, should you wish to do so.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Get familiar with a logic analyzer on your first project&lt;/p&gt;

    &lt;p&gt;While you can’t &lt;em&gt;see&lt;/em&gt; everything in an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;, and
especially not when you are running at speed, you can get a trace from a
running &lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
showing how logic transitions over time.&lt;/p&gt;

    &lt;p&gt;Such a trace can come from an external logic analyzer.  Many of these are
available for purchase.  For example, I’ve used the &lt;a href=&quot;https://store.digilentinc.com/digital-discovery-portable-logic-analyzer-and-digital-pattern-generator/&quot;&gt;Digital
Discovery&lt;/a&gt;
to find bugs in &lt;a href=&quot;https://github.com/ZipCPU/icozip&quot;&gt;one of my projects&lt;/a&gt;.  I’m
hoping to blog about my experiences with it soon as well.  I also have the
&lt;a href=&quot;http://dangerousprototypes.com/docs/Open_Bench_Logic_Sniffer&quot;&gt;Open Bench Logic
Sniffer&lt;/a&gt;
on my desk waiting to be tried and tested.&lt;/p&gt;

    &lt;p&gt;We’ve also discussed using an internal scope many times on this blog.
Such scope’s are &lt;a href=&quot;/blog/2017/06/08/simple-scope.html&quot;&gt;not hard to
build&lt;/a&gt;, and can be
&lt;em&gt;very&lt;/em&gt; useful when trying to figure out what’s going on.  I personally use a
&lt;a href=&quot;https://github.com/ZipCPU/wbscope&quot;&gt;wishbone scope&lt;/a&gt;.  We’ve discussed how to
set that up
&lt;a href=&quot;/blog/2017/07/08/getting-started-with-wbscope.html&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Teach your
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
to do some of your debugging for you.&lt;/p&gt;

    &lt;p&gt;Learn to &lt;a href=&quot;/blog/2017/05/24/serial-port.html&quot;&gt;set an LED when error conditions take
place&lt;/a&gt;.&lt;/p&gt;

    &lt;p&gt;Learn to trigger your “trace” generation on error conditions, so you can
read back logic leading up to those “error conditions.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;just-for-students&quot;&gt;Just for students&lt;/h2&gt;

&lt;p&gt;I’ve seen a lot of &lt;a href=&quot;/blog/2017/06/10/lost-college-student.html&quot;&gt;students get
burned&lt;/a&gt;.  While
some might say that this is a normal part of the learning process, don’t let
it be your process.  Learn from those who have gone before you.  Specific
lessons I would share include:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Success is measured by the number of failures.  Plan for failure.&lt;/p&gt;

    &lt;p&gt;&lt;em&gt;Every&lt;/em&gt; student tends to come across some “impossible”
problem in his design that he cannot figure out.  He may get stuck at this
point for days or even weeks.  This is common.  &lt;em&gt;Plan&lt;/em&gt; on getting stuck,
put some time into your schedule in case this happens,
and then plan before hand on how you are going to get yourself unstuck.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Don’t start your project at the last minute.&lt;/p&gt;

    &lt;p&gt;Good engineering takes time to do, and to do right.  You cannot control
when things will go wrong, or how long it will take to fix things when it
does.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Plan on debugging from the beginning.  Build yourself the infrastructure
you need for that task first, then build your design.&lt;/p&gt;

    &lt;p&gt;o All of my designs include both one or more  &lt;a href=&quot;https://github.com/ZipCPU/wbscope&quot;&gt;wishbone
  scopes&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;o All of my designs include a &lt;a href=&quot;https://github.com/ZipCPU/openarty/blob/master/rtl/wbubus.v&quot;&gt;wishbone to
  UART&lt;/a&gt;
  &lt;a href=&quot;/blog/2017/06/05/wb-bridge-overview.html&quot;&gt;debugging bus&lt;/a&gt;
  giving me access to my &lt;a href=&quot;https://github.com/ZipCPU/wbscope&quot;&gt;wishbone scopes&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Consider &lt;a href=&quot;/blog/2017/06/02/design-process.html&quot;&gt;this
discussion&lt;/a&gt;
on the &lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
design process, and learn what both instructors and experts often overlook
when they teach you how to do the task.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;rules-from-twitter&quot;&gt;Rules from Twitter&lt;/h2&gt;

&lt;p&gt;Many thanks to those who know &lt;a href=&quot;https://twitter.com/zipcpu&quot;&gt;me on twitter&lt;/a&gt;!
They also offered the following pieces of advice for new students: (some edits
applied)&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;My boss would tell me “Think in hardware” #parallel execution of code,
not serial. &lt;a href=&quot;https://twitter.com/sachin_bhutada&quot;&gt;sachin_bhutada&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Thank you, &lt;a href=&quot;https://twitter.com/sachin_bhutada&quot;&gt;sachin_bhutada&lt;/a&gt;,
this may be one of the most common struggles software students have.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Use the right device for your job.  Need to do 100kOps/s of multiplications?
Pah, you cheapest MCU can do that.  Remember: designing in HDL is hard,
programming in C is easy.  &lt;a href=&quot;https://twitter.com/dEnergy_dTime&quot;&gt;Marcus Muller&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;I think &lt;a href=&quot;https://twitter.com/dEnergy_dTime&quot;&gt;Marcus Muller&lt;/a&gt; meant to say that
programming in C++ is easy …&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;One week of aimless development can easily save you two hours of writing
specifications.  &lt;a href=&quot;https://twitter.com/dEnergy_dTime&quot;&gt;Marcus Muller&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;Use build-time parameters instead of
&lt;a href=&quot;https://en.wikipedia.org/wiki/Magic_number_(programming)&quot;&gt;magic constants&lt;/a&gt;;
you’ll thank me later.  &lt;a href=&quot;https://twitter.com/dEnergy_dTime&quot;&gt;Marcus Muller&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;When working in a team, beat others with a stuck until they learn to
properly use &lt;a href=&quot;https://en.wikipedia.org/wiki/Git&quot;&gt;git&lt;/a&gt;
&lt;a href=&quot;https://twitter.com/dEnergy_dTime&quot;&gt;Marcus Muller&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;Don’t believe hypes.  &lt;a href=&quot;https://twitter.com/dEnergy_dTime&quot;&gt;Marcus Muller&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;If it’s complicated, make a drawing.  &lt;a href=&quot;https://twitter.com/dEnergy_dTime&quot;&gt;Marcus Muller&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;Get a good book.  The online tutorials you find are … spotty, at best.  Learn the basics first.  &lt;a href=&quot;https://twitter.com/dEnergy_dTime&quot;&gt;Marcus Muller&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;I often recommend &lt;a href=&quot;http://www.asic-world.com/verilog/veritut.html&quot;&gt;asic-world’s online
tutorials&lt;/a&gt;, but
&lt;a href=&quot;https://twitter.com/dEnergy_dTime&quot;&gt;Marcus Muller&lt;/a&gt;’s advice still rings
true.  “Learn the basics first.”  &lt;a href=&quot;&quot;&gt;This blog&lt;/a&gt;
cannot cover all of the basics.&lt;/p&gt;

&lt;p&gt;Indeed, his comments hit the nail on the head so well, I’ve struggled here to
figure out anything to add to them.&lt;/p&gt;

&lt;p&gt;As for &lt;a href=&quot;&quot;&gt;this blog&lt;/a&gt; and what you will find here, I’m just
going to go back and underline &lt;a href=&quot;https://twitter.com/dEnergy_dTime&quot;&gt;Marcus
Muller&lt;/a&gt;’s advice to “Learn the basics
first.”
Thank you, &lt;a href=&quot;https://twitter.com/dEnergy_dTime&quot;&gt;Marcus Muller&lt;/a&gt;!&lt;/p&gt;

&lt;p&gt;Indeed, thank you again to all who responded!&lt;/p&gt;

&lt;h2 id=&quot;rules-are-made-to-be-broken&quot;&gt;Rules are made to be broken&lt;/h2&gt;

&lt;p&gt;Please notice how I titled this post as “Rules for new FPGA designers”.  These rules are
for &lt;em&gt;beginners&lt;/em&gt;.  Those who have worked with
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;s for a
longer period of time will understand that there are times and places for all
of these rules to be broken.&lt;/p&gt;

&lt;p&gt;To those who are contemplating breaking these rules, who may be at the point of
moving from a beginning &lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt; designer to a more intermediate one, my advice is
this:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Carefully consider your steps.  Do you really need to break the rule?  My
twitter friends and I
shared these rules for a reason.  Don’t break them unless you absolutely
need to.  Further, if you do absolutely need to break the rule, do your
research first so that you know how to do so safely and reliably.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;this-isnt-the-last-word&quot;&gt;This isn’t the last word&lt;/h2&gt;

&lt;p&gt;I expect I’ll come back to this post many times to update my rules for
beginners.  So, if you’ve read this once, don’t be surprised if it changes
again later as I add to these rules.&lt;/p&gt;

&lt;p&gt;Have I missed anything?  Feel free to let me know at the address below,
and thank you for everyone who has contributed so far.&lt;/p&gt;

&lt;p&gt;Finally good luck, have some fun, and stay out of
&lt;a href=&quot;/blog/2017/05/19/fpga-hell.html&quot;&gt;FPGA Hell&lt;/a&gt;!&lt;/p&gt;
&lt;hr /&gt;&lt;p&gt;&lt;em&gt;I have fed you with milk, and not with meat: for hitherto ye were not able to bear it, neither yet now are ye able (1Cor 3:2)&lt;/em&gt;</description>
        <pubDate>Mon, 21 Aug 2017 00:00:00 -0400</pubDate>
        <link>http://zipcpu.com/blog/2017/08/21/rules-for-newbies.html</link>
        <guid isPermaLink="true">http://zipcpu.com/blog/2017/08/21/rules-for-newbies.html</guid>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>Two of the Simplest Digital filters</title>
        <description>&lt;p&gt;I’d like to spend some time discussing
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;Digital Filtering&lt;/a&gt; on
&lt;a href=&quot;&quot;&gt;this blog&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;This is going to be a bit of a difficult topic, however, in that
I don’t intend to discuss &lt;a href=&quot;https://en.wikipedia.org/wiki/Parks-McClellan_filter_design_algorithm&quot;&gt;how to
design&lt;/a&gt;
a &lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;Digital Filter&lt;/a&gt;,
nor do I intend to discuss
&lt;a href=&quot;https://en.wikipedia.org/wiki/Discrete_Fourier_transform&quot;&gt;how to evaluate&lt;/a&gt;
the design of a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;digital filter&lt;/a&gt;,
nor do I intend to discuss
&lt;a href=&quot;https://en.wikipedia.org/wiki/Aliasing&quot;&gt;aliasing&lt;/a&gt;.  These are all vital
topics necessary for understanding what a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;digital filter&lt;/a&gt; is,
as well as understanding whether or not
a &lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;digital filter&lt;/a&gt; even works.
They are also vital topics to understand when comparing the performance of one
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;digital filter&lt;/a&gt;
with that of another.  However, these are really topics for a different course.&lt;/p&gt;

&lt;p&gt;For now, it’s worth understanding that a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;digital filter&lt;/a&gt;
implements a &lt;a href=&quot;https://en.wikipedia.org/wiki/Convolution&quot;&gt;discrete convolution&lt;/a&gt;,
and that such
&lt;a href=&quot;https://en.wikipedia.org/wiki/Convolution&quot;&gt;discrete convolution&lt;/a&gt;s
are provably the &lt;em&gt;only&lt;/em&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_signal_processing&quot;&gt;signal processing&lt;/a&gt;
operations that are both &lt;a href=&quot;https://en.wikipedia.org/wiki/Linear_system&quot;&gt;linear&lt;/a&gt;
and &lt;a href=&quot;https://en.wikipedia.org/wiki/Shfit-invariant_system&quot;&gt;shift invariant&lt;/a&gt;.
This makes them a very important part of any discussion of &lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_signal_processing&quot;&gt;digital signal
processing (DSP)&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;It’s also worth noting that any student of &lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_signal_processing&quot;&gt;digital signal
processing&lt;/a&gt;
should be able to recognize when a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;digital filter&lt;/a&gt;
is
&lt;a href=&quot;https://en.wikipedia.org/wiki/Causal_filter&quot;&gt;causal&lt;/a&gt;,
&lt;a href=&quot;https://en.wikipedia.org/wiki/BIBO_stability&quot;&gt;stable&lt;/a&gt;,
when it has &lt;a href=&quot;https://en.wikipedia.org/wiki/Linear_phase&quot;&gt;linear phase&lt;/a&gt;,
and when it has a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Finite_impulse_response&quot;&gt;finite (FIR)&lt;/a&gt;
or an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Infinite_impulse_response&quot;&gt;infinite (IIR)&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Impulse_response&quot;&gt;impulse response&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Our focus in this blog is going to be on how to debug a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;digital filter&lt;/a&gt;
so that you can know it works.  To get there, though, we are going to have
to describe some
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filters&lt;/a&gt;
so that we have something to debug.  Filters we discuss, together with any
test or debugging logic, will be placed on
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters&quot;&gt;GitHub here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;For today, let’s just look at two &lt;em&gt;very&lt;/em&gt; simple
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;s:
the simplest non-trivial
&lt;a href=&quot;https://en.wikipedia.org/wiki/Finite_impulse_response&quot;&gt;FIR&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;
that I know of, and a simple recursive averager (a type of
&lt;a href=&quot;https://en.wikipedia.org/wiki/Infinite_impulse_response&quot;&gt;IIR&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;)
that I have found to be very useful.&lt;/p&gt;

&lt;h1 id=&quot;simple-fir-filter&quot;&gt;Simple FIR Filter&lt;/h1&gt;

&lt;p&gt;The first
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;
we are going to look at may well be the &lt;em&gt;simplest&lt;/em&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Finite_impulse_response&quot;&gt;FIR&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;
you will ever come across.  It simply averages adjacent samples together.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/eqn-simplfir.png&quot; alt=&quot;Equation for a very simple FIR filter&quot; width=&quot;242&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;The &lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/smplfir.v&quot;&gt;code to implement this
equation&lt;/a&gt;
is likewise just as simple:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;initial	delayed = 0;
always @(posedge i_clk)
	if (i_ce)
		delayed &amp;lt;= i_val;
always @(posedge i_clk)
	if (i_ce)
		o_val &amp;lt;= i_val + delayed;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/smplfir.v&quot;&gt;This filter&lt;/a&gt;
is useful for many reasons.  For example, unlike many other
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;s
that you may study,
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/smplfir.v&quot;&gt;this filter&lt;/a&gt;
requires no multiply (DSP) resources within the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;.
The output only
&lt;a href=&quot;/dsp/2017/07/21/bit-growth.html&quot;&gt;grows by one bit&lt;/a&gt;.
Further,
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/smplfir.v&quot;&gt;this filter&lt;/a&gt;
can also handle incoming samples at up to the full system clock rate for the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;.
Those are the good qualities of
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/smplfir.v&quot;&gt;this filter&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;It is also, however, a very difficult filter to use successfully simply because
its &lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency_response&quot;&gt;frequency response&lt;/a&gt;
rarely describes the performance that you want.  It doesn’t have a
sharp cut off.  Its taps and length are fixed.  Indeed, you might find
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/smplfir.v&quot;&gt;this filter&lt;/a&gt;
that we’ve just implemented to be quite useless.&lt;/p&gt;

&lt;p&gt;Before you give up on &lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/smplfir.v&quot;&gt;this simplest
filter&lt;/a&gt;,
consider what would happen if
you cascaded several of
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/smplfir.v&quot;&gt;these filters&lt;/a&gt;
together–one right after the other.  For example, suppose you ran your signal
through ten of
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/smplfir.v&quot;&gt;these filters&lt;/a&gt;
in succession.  You would get a filter with a much deeper stopband.&lt;/p&gt;

&lt;p&gt;This is the comparison shown in Fig 1 below.  In it, you can see the
predicted &lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency_response&quot;&gt;frequency
response&lt;/a&gt;
of our &lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/smplfir.v&quot;&gt;original simple
filter&lt;/a&gt;
above, as well as a similar predicted
&lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency_response&quot;&gt;frequency response&lt;/a&gt;
for the filter that would result from applying that
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/smplfir.v&quot;&gt;same filter&lt;/a&gt;
ten times in a row.  Both filters have been normalized so as to have a unity
response to anything at zero frequency.&lt;/p&gt;

&lt;table style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 1: &lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/smplfir.png&quot; alt=&quot;Performance of a very simple FIR filter&quot; width=&quot;772&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;We’ll need come back to this later, when it’s time to determine whether either
filter actually achieves this predicted
&lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency_response&quot;&gt;frequency response&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;While this new cascaded filter is starting to have a nicely acceptable
stop band, nothing remains that might be considered a flat “pass” band
anymore.  Still, the cascaded filter is
easy enough to build and costs so few resources that whenever a cascaded
filter of this type can be used, even if as only a component of other
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filters&lt;/a&gt;, it
is often very valuable to do so.  Therefore, &lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/smplfir.v&quot;&gt;this simple
filter&lt;/a&gt;
finds its best and greatest application in being a component of other,
more powerful, &lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filters&lt;/a&gt;.&lt;/p&gt;

&lt;h1 id=&quot;simple-iir-filter&quot;&gt;Simple IIR Filter&lt;/h1&gt;

&lt;p&gt;The next super-simple filter that I’m going to present is an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Infinite_impulse_response&quot;&gt;IIR&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;.
Specifically, let’s look at a recursive averager.  A recursive
averager keeps an average value at all times, and only adjusts that value
with any input.  Specifically, I like to think of it as a weighted sum of
some percentage of the new input sample plus the remaining percentage of
the last average.&lt;/p&gt;

&lt;p&gt;Perhaps an equation will help.  In symbology, a recursive averager is
just:&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/eqn-iiravg-defn.png&quot; alt=&quot;EQN for a simple recursive averager&quot; width=&quot;328&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Where we keep to the standard conventions of &lt;code class=&quot;highlighter-rouge&quot;&gt;n&lt;/code&gt; being the sample number,
&lt;code class=&quot;highlighter-rouge&quot;&gt;x[n]&lt;/code&gt; being our input and &lt;code class=&quot;highlighter-rouge&quot;&gt;y[n]&lt;/code&gt; being our output.  The new variable here,
alpha, is our means of adjusting how deep or sharp this filter is.  This is
a value between zero and one.  If alpha is one, no averaging takes place.
The closer alpha is to zero, however, the more the filter will average the
input and the longer it will take to converge to an average.  Likewise, the
closer alpha is to zero the less noise the filter will admit to the
average estimate.&lt;/p&gt;

&lt;p&gt;With a little manipulation, we can rearrange this filter into something
that’s really easy to compute.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/eqn-iiravg-implementation.png&quot; alt=&quot;EQN used to implement a simple recursive averager&quot; width=&quot;381&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Then, if we insist that alpha be a negative power of two, we can
replace the multiply above with a right shift:&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/eqn-iir-alpha-defn.png&quot; alt=&quot;Alpha = 2^{-LGALPHA}&quot; width=&quot;168&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;You’ll want to use an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Arithmetic_shift&quot;&gt;arithmetic shift&lt;/a&gt; here,
to mak certain the sign propagates in the case where the difference is
negative.&lt;/p&gt;

&lt;p&gt;This leads us to our first design choice: How many clocks can we use to
calculate an answer?  In particular, this recursive averager is going to
require a subtraction followed by an addition.  Both of these operations
&lt;em&gt;need to complete&lt;/em&gt; before the next sample.  You can either try to place
this all within a single system tick, or split it between two separate ticks.&lt;/p&gt;

&lt;p&gt;If you have new data samples present on every clock tick, you will need
to try the combinational approach I’m going to present below, stuffing all of
the logic into a single clock tick.  This has the unfortunate consequence of
limiting your system clock speed.&lt;/p&gt;

&lt;p&gt;On the other hand, if your data samples will always have at least one
unused clock between them, then you could take one clock tick to calculate
the difference, &lt;code class=&quot;highlighter-rouge&quot;&gt;x[n]-y[n-1]&lt;/code&gt;, and another to update the running average,
&lt;code class=&quot;highlighter-rouge&quot;&gt;y[n]&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;If we suppose that we must do this all within a single clock tick, the
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/iiravg.v&quot;&gt;following code&lt;/a&gt;
will implement this recursive averager.  In the code below, &lt;code class=&quot;highlighter-rouge&quot;&gt;AW&lt;/code&gt;
is the number of bits in the averager, and &lt;code class=&quot;highlighter-rouge&quot;&gt;IW&lt;/code&gt; is the bit-width of the input.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;wire	signed	[(AW-1):0]	difference, adjustment;

// The difference is given by x[n] - y[n-1]
assign	difference = { i_data, {(AW-IW){1&#39;b0}} } - r_average;

// The adjustment is the difference times alpha
assign	adjustment = { {(LGALPHA){(difference[(AW-1)])}},
			difference[(AW-1):(AW-LGALPHA)] };
always @(posedge i_clk)
	r_average &amp;lt;= r_average + adjustment;

assign	o_data = r_average;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;You may notice that I could have used the Verilog shift operator and did
not.  Had I done so, then the &lt;code class=&quot;highlighter-rouge&quot;&gt;adjustment&lt;/code&gt; value could have been set with:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;assign	adjustment = difference &amp;gt;&amp;gt;&amp;gt; LGALPHA;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;So, how did we do?  We’ll need to come back and test this later to know
for certain.  That in itself is going to need to take some thought.  Just
what is the best way to test a filter?  For now, you can see in Fig 2.
how good we &lt;em&gt;should&lt;/em&gt; be doing—if we had truly infinite precision
arithmetic.&lt;/p&gt;

&lt;table style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 2: &lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/iiravg.png&quot; alt=&quot;Performance of a recursive averager&quot; width=&quot;772&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Later, it would be nice to come back and generate this
&lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency_response&quot;&gt;frequency response&lt;/a&gt; curve
as a result of measuring how well the filter actually does.  Parameters that
will impact this measurement include not only how many bits are allocated
to the input and output (averager) values, but also how big the input value
truly is.&lt;/p&gt;

&lt;p&gt;Unlike the
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/smplfir.v&quot;&gt;simple&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Finite_impulse_response&quot;&gt;FIR&lt;/a&gt;
filter above, applications for this
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/iiravg.v&quot;&gt;simple&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Infinite_impulse_response&quot;&gt;IIR&lt;/a&gt;
recursive averaging filter abound just about everywhere.&lt;/p&gt;

&lt;p&gt;Want to measure a histogram?  Set this up to be an unsigned recursive
averager and then place a &lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt; into this filter every time your
data is within the bin of interest.&lt;/p&gt;

&lt;p&gt;Want to drive an automatic gain control circuit?  Compare the absolute
value of your signal against a fixed threshold.  Set the averager for unsigned
values, and then if your signal’s amplitude is too high you can average a
&lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt; into this averager.  If the result is too low, average a &lt;code class=&quot;highlighter-rouge&quot;&gt;0&lt;/code&gt; into this
averager. You can then use the result to know if you should turn the gain
in your circuitry up or down.&lt;/p&gt;

&lt;p&gt;You could also use this to remove any fixed gain in your circuitry.&lt;/p&gt;

&lt;p&gt;Indeed, you could even use this circuit coupled with a
&lt;a href=&quot;http://andraka.com/files/crdcsrvy.pdf&quot;&gt;CORDIC&lt;/a&gt;
to measure a single bin (or more) of the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency_response&quot;&gt;frequency response&lt;/a&gt;
of your system.&lt;/p&gt;

&lt;p&gt;This filter is exceptionally versatile as a cheap
&lt;a href=&quot;https://en.wikipedia.org/wiki/Low-pass_filter&quot;&gt;low-pass filter&lt;/a&gt;.  As an
example of that versatility, it also finds applications in &lt;a href=&quot;https://en.wikipedia.org/wiki/Phase-locked_loop&quot;&gt;phase lock
loops&lt;/a&gt;!&lt;/p&gt;

&lt;p&gt;These are all other topics, though, that we’ll need to come back to another
time.&lt;/p&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;Yes, those are the two simplest (non-trivial) filters I know.&lt;/p&gt;

&lt;p&gt;Sadly, though, we’re not yet in a position to test these filters to know that
they work.  As a result, we’ll need to come back to the topic of
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;digital filtering&lt;/a&gt;
once we discuss how to properly test a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;digital filter&lt;/a&gt;.
Some of those techniques will depend upon being able to use a
&lt;a href=&quot;http://andraka.com/files/crdcsrvy.pdf&quot;&gt;CORDIC&lt;/a&gt;–something
we have yet to present on this blog.  We’re also going to need to have
a thorough understanding of &lt;a href=&quot;https://en.wikipedia.org/wiki/Quantization_(signal_processing)&quot;&gt;quantization
noise&lt;/a&gt;,
another thing we’ll have to come back and discuss.&lt;/p&gt;

&lt;p&gt;This is by no means our final
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;digital filtering&lt;/a&gt;,
discussion either!  Many, many other
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
filtering topics remain.  These include:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;How to estimate a filter’s logic resource usage&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;How to build the cadillac of all filters: a dynamic filter whose filter
taps can be set at run time.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;And then how to build more realistic filters that will actually fit within
your &lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;’s
logic resources.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Do you get the feeling that
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;digital filtering&lt;/a&gt;
is a complex topic?  Since it is the most basic
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_signal_processing&quot;&gt;DSP&lt;/a&gt; operation,
we’ll need to spend some time going through it.  Perhaps some well written
examples will help to make this complex topic make more sense.&lt;/p&gt;

&lt;hr /&gt;&lt;p&gt;&lt;em&gt;To give subtilty to the simple, to the young man knowledge and discretion. (Prov 1:4)&lt;/em&gt;</description>
        <pubDate>Sat, 19 Aug 2017 00:00:00 -0400</pubDate>
        <link>http://zipcpu.com/dsp/2017/08/19/simple-filter.html</link>
        <guid isPermaLink="true">http://zipcpu.com/dsp/2017/08/19/simple-filter.html</guid>
        
        
        <category>dsp</category>
        
      </item>
    
  </channel>
</rss>
