<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>The ZipCPU by Gisselquist Technology</title>
    <description>The ZipCPU blog, featuring how to discussions of FPGA and soft-core CPU design.  This site will be focused on Verilog solutions, using exclusively OpenSource IP products for FPGA design.  Particular focus areas include topics often left out of more mainstreeam FPGA design courses such as how to debug an FPGA design.
</description>
    <link>http://zipcpu.com/</link>
    <atom:link href="http://zipcpu.com/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Fri, 25 Aug 2017 13:51:58 -0400</pubDate>
    <lastBuildDate>Fri, 25 Aug 2017 13:51:58 -0400</lastBuildDate>
    <generator>Jekyll v3.0.1</generator>
    <image>
      <url>http://zipcpu.com/img/gt-rss.png</url>
      <title></title>
      <link></link>
    </image>
    
      <item>
        <title>Debugging your soft-core CPU within an FPGA</title>
        <description>&lt;p&gt;We’ve already looked at the requirements for &lt;a href=&quot;/zipcpu/2017/07/14/cpu-debugging-needs.thml&quot;&gt;debugging a CPU in
general&lt;/a&gt;, as
well as &lt;a href=&quot;/zipcpu/2017/07/26/cpu-sim-debugger.html&quot;&gt;how to debug a CPU within a Verilator based
simulation&lt;/a&gt;. 
Let’s now return to this topic and take a look at how to modify your
&lt;a href=&quot;https://en.wikipedia.org/wiki/Soft_microprocessor&quot;&gt;soft-core CPU&lt;/a&gt;
so that you can debug it once it is placed within an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;.&lt;/p&gt;

&lt;table style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 1: Soft-Core CPU H/W Debugging Needs&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/cpu-dbg-inhw.svg&quot; alt=&quot;Needs of a Soft-Core Hardware Debugger&quot; width=&quot;320&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;When we discussed the &lt;a href=&quot;/zipcpu/2017/07/14/cpu-debugging-needs.thml&quot;&gt;general needs of a
debugger&lt;/a&gt;,
we used a figure similar to Fig 1. to describe a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;’s
debugging needs.
The left column, debugging the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;’s
while in simulation, we address &lt;a href=&quot;/zipcpu/2017/07/26/cpu-sim-debugger.html&quot;&gt;in a
previous post&lt;/a&gt;.
Today, the figure at the right has been modified to highlight todays
discussion and focus: how to add the necessary logic into a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Soft_microprocessor&quot;&gt;soft-core CPU&lt;/a&gt;
to support debugging.&lt;/p&gt;

&lt;p&gt;As shown in the diagram, the basic operations we’re going to need to support
are resetting, starting, halting, and stepping a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;,
as well as examining
and changing
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;,
state
&lt;a href=&quot;https://en.wikipedia.org/wiki/Processor_register&quot;&gt;registers&lt;/a&gt;.
You may wish to review how the &lt;a href=&quot;/zipcpu/2017/08/23/cpu-pipeline.md&quot;&gt;ZipCPU handles pipeline
control&lt;/a&gt;,
since the logic we shall discuss today needs to fit nicely into that context.&lt;/p&gt;

&lt;h2 id=&quot;that-hw-debugging-interface&quot;&gt;That H/W Debugging Interface&lt;/h2&gt;

&lt;p&gt;If you’ve never done this before, please don’t start by trying to implement
&lt;a href=&quot;https://www.gnu.org/software/gdb&quot;&gt;GDB&lt;/a&gt;’s &lt;a href=&quot;https://sourceware.org/gdb/onlinedocs/gdb/Remote-Protocol.html&quot;&gt;remote serial
protocol&lt;/a&gt;
within Verilog.  The protocol is very powerful, and we’ll discuss how to use
it later to connect your
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;
to &lt;a href=&quot;https://www.gnu.org/software/gdb&quot;&gt;GDB&lt;/a&gt;. 
The problem is that the protocol is complex, and it will take a lot of work to
process it within hardware.  Keep reading, there’s an easier way.&lt;/p&gt;

&lt;p&gt;As a first step, think for a moment about what &lt;a href=&quot;/zipcpu/2017/07/14/cpu-debugging-needs.html&quot;&gt;debugging your CPU
will require&lt;/a&gt;.
In particular, you’ll want to be able to read and write both
&lt;a href=&quot;https://en.wikipedia.org/wiki/Processor_register&quot;&gt;registers&lt;/a&gt;
and memory.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;/digilent/2017/05/22/moving-to-memory.html&quot;&gt;Reading from
memory&lt;/a&gt;
requires the address you wish to read from as well as a strobe signal to
indicate your desire to read&lt;/p&gt;

    &lt;p&gt;If your address space is big enough, this &lt;a href=&quot;https://en.wikipedia.org/wiki/Memory-mapped_I/O&quot;&gt;same sort of command and
interface&lt;/a&gt; can work for
reading 
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt; 
&lt;a href=&quot;https://en.wikipedia.org/wiki/Processor_register&quot;&gt;registers&lt;/a&gt;
just like it does for memory.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;/zipcpu/2017/05/23/simplebus.html&quot;&gt;Writing to memory&lt;/a&gt;
requires an address, a value, and a strobe to tell you
when to write the value to the given address.&lt;/p&gt;

    &lt;p&gt;As with reading, if you can allocate an address for each
&lt;a href=&quot;https://en.wikipedia.org/wiki/Processor_register&quot;&gt;register&lt;/a&gt; within your
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;,
the same interface you used for reading
&lt;a href=&quot;https://en.wikipedia.org/wiki/Processor_register&quot;&gt;registers&lt;/a&gt;
could also work to writing
&lt;a href=&quot;https://en.wikipedia.org/wiki/Processor_register&quot;&gt;registers&lt;/a&gt; within your
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;.&lt;/p&gt;

    &lt;p&gt;The approach can even be expanded to include not only
&lt;a href=&quot;https://en.wikipedia.org/wiki/Processor_register&quot;&gt;registers&lt;/a&gt;
values, but also internal (debugging) state variables from within your
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;As a third example, a control register could also be used to tell the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt; when
to execute an instruction, and when to hold in reset.&lt;/p&gt;

&lt;table style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 2: Placing a CPU on the Debugging Bus&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/hw-debug-structure.svg&quot; alt=&quot;Block diagram of a CPU placed on a Debugging Bus&quot; width=&quot;320&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;All of these interactions, therefore, are easily understood as things that
could take place across a
“&lt;a href=&quot;/zipcpu/2017/05/23/simplebus.html&quot;&gt;bus&lt;/a&gt;”
with both memory and &lt;a href=&quot;https://en.wikipedia.org/wiki/Memory-mapped_I/O&quot;&gt;memory mapped
peripherals&lt;/a&gt; on it. 
Therefore, one might consider giving the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt; a &lt;a href=&quot;/zipcpu/2017/05/29/simple-wishbone.html&quot;&gt;bus slave
interface&lt;/a&gt;, and 
hooking it up to the &lt;a href=&quot;https://github.com/ZipCPU/dbgbus&quot;&gt;debugging
bus&lt;/a&gt; we’ve been working with (or something
similar) as shown in Fig 2.&lt;/p&gt;

&lt;p&gt;This approach has a couple of advantages.  First, the
&lt;a href=&quot;https://github.com/ZipCPU/dbgbus&quot;&gt;debugging bus&lt;/a&gt;
can be used to &lt;a href=&quot;/zipcpu/2017/05/20/which-came-first.html&quot;&gt;debug both the peripherals and the
memory&lt;/a&gt;
the &lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;
will need to work with later.  Second, if the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;
and &lt;a href=&quot;https://github.com/ZipCPU/dbgbus&quot;&gt;debugging
bus&lt;/a&gt; are each given the same view of the
peripheral set, then no separate address map and decoder needs to be created.
Third, this approach creates a means, independent of the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;,
of reading and writing to memory.  This could be very important later when
building a
program loader for the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;,
since it would then allow you to load the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;’s
program into memory and test it, without relying on any internal
&lt;a href=&quot;https://en.wikipedia.org/wiki/Read-only_memory&quot;&gt;ROM&lt;/a&gt;
within the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;
that would cause the design to need to be resynthesized anytime
something changes.&lt;/p&gt;

&lt;p&gt;The downside of this approach is that, depending upon your implementation, the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/aux/wbpriarb.v&quot;&gt;bus arbiter&lt;/a&gt;
may slow the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;’s
access to memory by a clock (or two).&lt;/p&gt;

&lt;table style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 3: ZipCPU&#39;s debugging interface&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/bare-cpu-debug-iface.svg&quot; alt=&quot;ZipCPU&#39;s bare debugging interface&quot; width=&quot;320&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;This was the approach taken by the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;, as shown in Fig 3, so we’ll use the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;
as our example of this approach in our discussion below.  The
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt; was
given two address locations on the debugging bus: a control and data
location.  (These are both discussed and defined in the 
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt; &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/doc/spec.pdf&quot;&gt;specification
document&lt;/a&gt;.)
A small wrapper around the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;ZipCPU
proper&lt;/a&gt;, called
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/zipbones.v&quot;&gt;ZipBones&lt;/a&gt;,
connects to the control register of the debug slave port and controls the
reset and halt lines into the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.com&quot;&gt;CPU&lt;/a&gt;.
These are used to implement reset, halt,
start, and step operations as we’ll see shortly.&lt;/p&gt;

&lt;p&gt;The &lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;
also has a second wrapper with more functionality to it, called
the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/zipsystem.v&quot;&gt;ZipSystem&lt;/a&gt;,
but since the logic within the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/zipbones.v&quot;&gt;ZipBones&lt;/a&gt;
is simpler, we’ll focus on it.&lt;/p&gt;

&lt;p&gt;Our discussion will focus on the reads and writes of these two locations,
the control and data ports, although you may wish to give your own
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;
more registers than just these two.&lt;/p&gt;

&lt;h2 id=&quot;reseting-halting-and-stepping-the-cpu&quot;&gt;Reseting, halting, and stepping the CPU&lt;/h2&gt;

&lt;p&gt;Let’s look at the control register for the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt; for a moment.  Writes to
this control register have the side-effect of controlling the
&lt;code class=&quot;highlighter-rouge&quot;&gt;i_halt&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;i_rst&lt;/code&gt; (reset) lines within the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;.
These side effects will cause the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;ZipCPU&lt;/a&gt;
to run, halt, step, or even reset as requested.&lt;/p&gt;

&lt;p&gt;The first side effect to be discussed is the reset.  Like many digital
logic cores, the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;ZipCPU&lt;/a&gt;
has a reset line going into it.  Controlling this reset is also quite
possibly the simplest interaction with the bus.  Specifically, any time
the control register is written with the reset bit set, the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
is reset.  Further, this reset line into the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
is initialized high, to make sure
that the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
always starts from a reset state.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;initial	cmd_reset = 1&#39;b1;
always @(posedge i_clk)
	cmd_reset &amp;lt;= ((dbg_cmd_write)&amp;amp;&amp;amp;(i_dbg_data[`RESET_BIT]));&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Inside the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;ZipCPU&lt;/a&gt;,
this reset line causes the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;ZipCPU&lt;/a&gt;
to reboot.  While it only (re-)initializes a minimum of variables, it is
enough to get the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
start from (nearly) known conditions.
In particular, all error conditions, cache valid indications, and pipeline
valid flags are cleared on reset.  Further, the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
is sent to a pre-programmed address.  What doesn’t happen is that the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Processor_register&quot;&gt;registers&lt;/a&gt;
are not re-initialized (the program counter and flags registers are though).
This allows some amount of fault recovery in software, if desired, prior to
setting all of the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Processor_register&quot;&gt;registers&lt;/a&gt;
to known conditions.&lt;/p&gt;

&lt;p&gt;The second control line going into the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
is a master halt line, &lt;code class=&quot;highlighter-rouge&quot;&gt;i_halt&lt;/code&gt;.  This line, if set, will cause the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
to halt in such a way that no instructions will go
into the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/cpuops.v&quot;&gt;ALU&lt;/a&gt;,
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/memops.v&quot;&gt;memory&lt;/a&gt;
or &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/div.v&quot;&gt;divide&lt;/a&gt;
units, but instructions that have already
entered these units will be allowed to finish.  It does this by setting the
stall logic associated with units, as we discussed during our
&lt;a href=&quot;/zipcpu/2017/08/23/cpu-pipeline.html&quot;&gt;CPU pipeline signaling
post&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The neat thing about the master halt line concept is that the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
is designed to halt at a stopping point between instructions when using it. 
Instructions that have entered the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/cpuops.v&quot;&gt;ALU&lt;/a&gt;,
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/memops.v&quot;&gt;memory&lt;/a&gt;
or &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/div.v&quot;&gt;divide&lt;/a&gt;
stages are allowed to complete, but further instructions are not allowed
to enter these stages.  As a result, the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
can be started, stepped, or halted by adjusting this master enable (i.e.
&lt;code class=&quot;highlighter-rouge&quot;&gt;i_halt&lt;/code&gt;) line.&lt;/p&gt;

&lt;p&gt;This &lt;code class=&quot;highlighter-rouge&quot;&gt;i_halt&lt;/code&gt; line into the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
is calculated from a couple of pieces of logic in the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/zipbones.v&quot;&gt;ZipBones&lt;/a&gt;
wrapper.  The first is the &lt;code class=&quot;highlighter-rouge&quot;&gt;cmd_halt&lt;/code&gt; register which is controlled by writes
to the control register.  On a reset, the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
will start in a halted mode (if the boolean parameter &lt;code class=&quot;highlighter-rouge&quot;&gt;START_HALTED&lt;/code&gt; is set to
true).  Ever afterwards, any write to the halt bit in the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/zipbones.v&quot;&gt;ZipBones&lt;/a&gt;
status register will set or clear this bit with two exceptions:
&lt;code class=&quot;highlighter-rouge&quot;&gt;cmd_step&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;cpu_break&lt;/code&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;`define	STEP_BIT	8
`define	HALT_BIT	10

always @(posedge i_clk)
	if ((i_rst)||(cmd_reset))
		cmd_halt &amp;lt;= (START_HALTED);
	else if (dbg_cmd_write)
		cmd_halt &amp;lt;= ((i_dbg_data[`HALT_BIT])&amp;amp;&amp;amp;(!i_dbg_data[`STEP_BIT]));
	else if ((cmd_step)||(cpu_break))
		cmd_halt &amp;lt;= 1&#39;b1;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The first exception is the &lt;code class=&quot;highlighter-rouge&quot;&gt;cmd_step&lt;/code&gt; logic.  If the halt bit is set
at the same time the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
is instructed to step forward by one clock, then the halt request is ignored
until the &lt;code class=&quot;highlighter-rouge&quot;&gt;cmd_step&lt;/code&gt; has been true for one cock.  We’ll come back to this
exception in a moment.&lt;/p&gt;

&lt;p&gt;The second exception is the &lt;code class=&quot;highlighter-rouge&quot;&gt;cpu_break&lt;/code&gt; signal.  This is shown in Fig. 3 as
the hardware break signal.  This is the signal the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
creates when it has encountered an unrecoverable fault–such as trying
to execute an unimplemented instruction while in the supervisor
(i.e. interrupt) state.  Other faults within the supervisor state
will also cause the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
to fault as well, such as the break instruction, a divide by zero fault from
within supervisor mode, or a
&lt;a href=&quot;https://opencores.org/cdn/downloads/wbspec_b4.pdf&quot;&gt;wishbone bus&lt;/a&gt;
error.  This &lt;code class=&quot;highlighter-rouge&quot;&gt;cmd_halt&lt;/code&gt; state captures that fault, and then holds the 
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
in a halted state for the debugger to come by and examine it.  (Alternatively,
the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
could be programmed to just reboot.)&lt;/p&gt;

&lt;p&gt;On that note, let’s return to looking at the step bit.  If the step bit is ever
set, the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/zipbones.v&quot;&gt;ZipBones&lt;/a&gt;
wrapper will release the halt line for one clock and then set it immediately
again.  This will cause one instruction to enter the
&lt;a href=&quot;/zipcpu/08/11/simple-alu.html&quot;&gt;ALU&lt;/a&gt;/memory pipeline stage.
It works in conjunction with the &lt;code class=&quot;highlighter-rouge&quot;&gt;cmd_halt&lt;/code&gt; bit above, so that if the step
register is ever true, the &lt;code class=&quot;highlighter-rouge&quot;&gt;cmd_halt&lt;/code&gt; register will get set on the next
instruction.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;initial	cmd_step  = 1&#39;b0;
always @(posedge i_clk)
	cmd_step &amp;lt;= (dbg_cmd_write)&amp;amp;&amp;amp;(i_dbg_data[`STEP_BIT]);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;While this description may sound simple, the devil is in the details.
For example, what happens when the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
is in the middle of an atomic operation?
What if an interrupt comes in while the debugger has the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
halted?  (It gets ignored.) What if the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
is in the middle of executing a pair of instructions from a compressed
instruction set word?  (The &lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;
has no ability to restart a compressed instruction word mid-way through …)
What if the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
is loading a cache line, and the memory is slow to respond? (i.e. broken)&lt;/p&gt;

&lt;p&gt;All of these details can make this halt line difficult to implement.&lt;/p&gt;

&lt;h2 id=&quot;clearing-the-cache&quot;&gt;Clearing the Cache&lt;/h2&gt;

&lt;p&gt;Before we move on to gaining access to
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Processor_register&quot;&gt;registers&lt;/a&gt;,
the control register offers one more big capability–that of
clearing the cache.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;initial	cmd_clear_pf_cache = 1&#39;b0;
always @(posedge i_clk)
	cmd_clear_pf_cache &amp;lt;= (dbg_cmd_write)&amp;amp;&amp;amp;(i_dbg_data[`CLEAR_CACHE_BIT];&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This is one of those annoying details that you may not think of initially.
If the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
is halted, the debugger is free to change memory, right?  Hence,
the debugger might wish to swap a normal instruction for a &lt;code class=&quot;highlighter-rouge&quot;&gt;BREAK&lt;/code&gt;
instruction or vice versa.  The problem lies in whether the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
has already read that instruction into its cache.  If the instruction the
debugger wishes to change is already in the cache, then the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
might not notice the fact that the debugger has changed that memory.
(The &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;ZipCPU&lt;/a&gt;
cache has no bus snooping capability … yet.)&lt;/p&gt;

&lt;p&gt;This command also clears the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;’s
pipeline for essentially the same reason–lest the instruction the debugger
wished to change was also within the pipeline already and just waiting to
execute.  We discussed how this was done earlier, when we discussed how
the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;
implemented its
&lt;a href=&quot;/zipcpu/2017/08/23/cpu-pipeline.md&quot;&gt;pipeline logic&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;reading-and-setting-registers&quot;&gt;Reading and Setting Registers&lt;/h2&gt;

&lt;p&gt;While a proper bus protocol makes sense for reading from
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Processor_register&quot;&gt;registers&lt;/a&gt;,
as we discussed above,
the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;’s
debug implementation isn’t quite a full bus implementation. Perhaps this
interaction is ready for redesign.  For now, I’ll just explain it as it is.&lt;/p&gt;

&lt;p&gt;The &lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt; control register contains a
set of six address bits.  Writes to the control register can be used to set
these six address bits as well other flags such as those we discussed above.
These then become the
&lt;a href=&quot;https://opencores.org/cdn/downloads/wbspec_b4.pdf&quot;&gt;wishbone&lt;/a&gt;
address of a register within the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;.
Ever after, reads from (or writes to) the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;
data register will adjust the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;.
&lt;a href=&quot;https://en.wikipedia.org/wiki/Processor_register&quot;&gt;register&lt;/a&gt;,
addressed by these six address bits.&lt;/p&gt;

&lt;p&gt;Remember how &lt;a href=&quot;/zipcpu/2017/05/23/simplebus.html&quot;&gt;we discussed
earlier&lt;/a&gt;
that a register read from a bus is just a big case statement?  The same is true
of the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;.
The only difference within the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;
is that 28 of the 32 &lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Processor_register&quot;&gt;registers&lt;/a&gt;,
are stored in an on-chip RAM while the other four are collected from a
set of control and status bits, and the two program counters.  Reading from
the bus, therefore, is almost the same as the big case statement
&lt;a href=&quot;/zipcpu/2017/05/23/simplebus.html&quot;&gt;we discussed earlier&lt;/a&gt;:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
begin
	// 28 registers are normal, and can be read from a memory
	o_dbg_reg &amp;lt;= regset[i_dbg_reg];

	// The PC is a bit different
	if (i_dbg_reg[3:0] == `CPU_PC_REG)
		o_dbg_reg &amp;lt;= w_debug_pc;
	else if (i_dbg_reg[3:0] == `CPU_CC_REG)
	begin
		// As is the flags register
		o_dbg_reg[14:0] &amp;lt;= (i_dbg_reg[4])?w_uflags:w_iflags;
		o_dbg_reg[15] &amp;lt;= 1&#39;b0;
		o_dbg_reg[31:23] &amp;lt;= w_cpu_info;
		o_dbg_reg[`CPU_GIE_BIT] &amp;lt;= gie;
	end
end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Writes are a touch more difficult, since the debugger needs to insert any
register writes into the processing chain of the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The &lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;.
handles such writes by creating a module parallel with the
&lt;a href=&quot;/zipcpu/08/11/simple-alu.html&quot;&gt;ALU&lt;/a&gt;
and &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/memops.v&quot;&gt;memory&lt;/a&gt;.
This module (really only a register and about 4 lines of code) is only active
if the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
is halted.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	dbgv &amp;lt;= (!i_rst)&amp;amp;&amp;amp;(i_halt)&amp;amp;&amp;amp;(i_dbg_we)&amp;amp;&amp;amp;(r_halted);
always @(posedge i_clk)
	dbg_val &amp;lt;= i_dbg_data;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Likewise, the register (and value) the
&lt;a href=&quot;/zipcpu/08/11/simple-alu.html&quot;&gt;ALU&lt;/a&gt; would’ve written
upon completion is modified during a halt as well:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	if (adf_ce_unconditional)
		// A normal register write, if the CPU is running
		alu_reg &amp;lt;= op_R
	else if ((i_halt)&amp;amp;&amp;amp;(i_dbg_we))
		// A debug register write, requiring the CPU to be halted
		alu_reg &amp;lt;= i_dbg_reg&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This then sets the write values on the clock before writeback.  (The
&lt;code class=&quot;highlighter-rouge&quot;&gt;adf_ce_unconditional&lt;/code&gt; flag is a piece of the 
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;’s
pipeline logic that we may come back and address in more detail later in
a post on pipelining.)&lt;/p&gt;

&lt;p&gt;Finally, so that the debugger can know that this write has occurred, the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt; holds the stall register high
any time it the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
hasn’t completely halted.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;assign	o_dbg_stall = !r_halted;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;You may notice, if you look at the code, that there’s no acknowledgement line.
Indeed, the acknowledgement line is generated at the bottom of the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/zipbones.v&quot;&gt;ZipBones&lt;/a&gt;
file based upon the fact that any request made to the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;, as long
as the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
isn’t stalled, is successful.&lt;/p&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;You may notice that the logic above only depends upon a couple of wires,
and that these wires have a very simple amount of logic assicated with them.
This is how digital design should be.  The trick to every problem is knowing
how to make the problem simple.&lt;/p&gt;

&lt;p&gt;In our case, this problem is simplified by first creating some form of
&lt;a href=&quot;https://github.com/ZipCPU/dbgbus/tree/master/hexbus&quot;&gt;debugging bus&lt;/a&gt;
to get a bus access point to our hardware and peripherals, as well as
understanding several various &lt;a href=&quot;/blog/2017/08/14/strategies-for-pipelining.html&quot;&gt;pipeline
strategies&lt;/a&gt;,
and then second understanding how a simple &lt;a href=&quot;/zipcpu/2017/08/23/cpu-pipeline.html&quot;&gt;CPU can use such a
strategy&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;This still leaves us with many more
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;
topics to discuss, such as how to add or remove peripherals by simply
adding or removing parameters from an
&lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt;
command line.
However, we are going to postpone that discussion until after I have the
opportunity to discuss
&lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt;
at &lt;a href=&quot;http://www.orconf.org&quot;&gt;ORCONF&lt;/a&gt; this year.&lt;/p&gt;

&lt;p&gt;In the meantime, then, I’d like to turn this blog’s attention to the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_signal_processing&quot;&gt;DSP&lt;/a&gt;
topics of both sine wave generation and
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;digital filtering&lt;/a&gt;.
We’ll come back to the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;
later–if for no other reason than I’ve been asked to discuss how to modify
&lt;a href=&quot;https://www.gcc.org&quot;&gt;GCC&lt;/a&gt;
to support a new
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt; 
backend.&lt;/p&gt;

&lt;hr /&gt;&lt;p&gt;&lt;em&gt;No man can serve two masters: for either he will hate the one, and love the other; or else he will hold to the one, and despise the other. Ye cannot serve God and mammon.  (Matt 6:24)&lt;/em&gt;</description>
        <pubDate>Fri, 25 Aug 2017 00:00:00 -0400</pubDate>
        <link>http://zipcpu.com/zipcpu/2017/08/25/hw-debugging.html</link>
        <guid isPermaLink="true">http://zipcpu.com/zipcpu/2017/08/25/hw-debugging.html</guid>
        
        
        <category>zipcpu</category>
        
      </item>
    
      <item>
        <title>The ZipCPU&#39;s pipeline logic</title>
        <description>&lt;p&gt;Now that we’ve discussed some &lt;a href=&quot;/blog/2017/08/14/strategies-for-pipelining.html&quot;&gt;general pipeline
strategies&lt;/a&gt;,
it’s time to take a look at how pipelining can work within a simple, in order,
pipelined &lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;.
Let’s take a look, therefore, at the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;
and see how it handles its pipeline logic.
What you’ll see is that the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;
uses a variant of the &lt;a href=&quot;/blog/2017/08/14/strategies-for-pipelining.html&quot;&gt;handshaking strategy we discussed
earlier&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;If you are unfamiliar with the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;, the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;
has five pipeline stages, as shown in Fig 1.&lt;/p&gt;

&lt;table style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 1: The ZipCPU Pipeline Structure&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/zipcpu.png&quot; alt=&quot;ZipCPU Pipeline Structurre&quot; width=&quot;380&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;There’s the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/pfcache.v&quot;&gt;prefetch and instruction
cache&lt;/a&gt;
stage, an &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/idecode.v&quot;&gt;instruction
decode&lt;/a&gt; stage,
a read operands stage, an
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/cpuops.v&quot;&gt;ALU&lt;/a&gt;
stage and a writeback stage.  The
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/cpuops.v&quot;&gt;ALU&lt;/a&gt;
stage is also placed parallel to a &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/pipemem.v&quot;&gt;memory operations
unit&lt;/a&gt;, a
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/div.v&quot;&gt;divide&lt;/a&gt; unit,
and a space for (a still undefined) floating point unit.&lt;/p&gt;

&lt;p&gt;As currently built, the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;
is an in-order processor.  It’s pipeline structure requires that
values going into the write-back unit be strictly in order.&lt;/p&gt;

&lt;p&gt;If you choose to look through the main
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt; &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;processor’s
code&lt;/a&gt;,
you may find it not as simple to read.  That’s because the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;
was written to thread a fine line between two separate purposes.  The first,
stated purpose, is to be a simple
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;–as
measured by the amount of logic used by the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;.
The second purpose is to be a fast
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;.
These two purposes are often in conflict.  Therefore, the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt; implementation allows you to
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/cpudefs.v&quot;&gt;select the performance you
want&lt;/a&gt;, and
adjust as necessary to fit the amount of logic you have available for a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;
within your
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Let’s use this as an example, though, in how a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;
pipeline can be created within an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;instruction-overview&quot;&gt;Instruction Overview&lt;/h2&gt;

&lt;p&gt;In order to make the following examples make sense, it might help to
understand how the various pipeline stages are supposed to interact.
This will make examples easier to understand.&lt;/p&gt;

&lt;p&gt;First, almost all
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;
instructions have the form:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-assembly&quot; data-lang=&quot;assembly&quot;&gt;   OP.C Ra,Rb+I&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;In this example, &lt;code class=&quot;highlighter-rouge&quot;&gt;OP&lt;/code&gt; is the operation.  It’s a 5-bit field identifying
which instruction is described by this instruction.  Think of this as &lt;em&gt;what&lt;/em&gt;
the &lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;
is being asked to do.  Indeed, four of the five &lt;code class=&quot;highlighter-rouge&quot;&gt;OP&lt;/code&gt; bits form the
multiplexer selection input within the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/cpuops.v&quot;&gt;ALU&lt;/a&gt; as
&lt;a href=&quot;/zipcpu/2017/08/11/simple-alu.html&quot;&gt;we discussed earlier&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The &lt;code class=&quot;highlighter-rouge&quot;&gt;C&lt;/code&gt; term is the condition.  This controls whether or not any value
is written back from the instruction.  For example, the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;
supports a &lt;code class=&quot;highlighter-rouge&quot;&gt;Z&lt;/code&gt; condition which will cause the instruction to only write back
its results if the &lt;code class=&quot;highlighter-rouge&quot;&gt;Z&lt;/code&gt; flag is set.  The other seven supported conditions are
discussed within the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/doc/spec.pdf&quot;&gt;ZipCPU
specification&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The &lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;
is primarily a two operand machine.  It has no three operand instructions.
Hence, every
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/cpuops.v&quot;&gt;ALU&lt;/a&gt;
instruction provides two inputs to the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/cpuops.v&quot;&gt;ALU&lt;/a&gt;,
&lt;code class=&quot;highlighter-rouge&quot;&gt;Ra&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;Rb+I&lt;/code&gt; and the output gets written back into register &lt;code class=&quot;highlighter-rouge&quot;&gt;Ra&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Finally, and this becomes important for the following discussion, almost
all instructions allow an immediate, usually 14-bits, to be added
to the second register, &lt;code class=&quot;highlighter-rouge&quot;&gt;Rb&lt;/code&gt;.  Alternatively, an 18-bit immediate value, &lt;code class=&quot;highlighter-rouge&quot;&gt;I&lt;/code&gt;,
may replace the ALU’s &lt;code class=&quot;highlighter-rouge&quot;&gt;Rb&lt;/code&gt; input so that &lt;code class=&quot;highlighter-rouge&quot;&gt;Rb&lt;/code&gt; is not used at all.&lt;/p&gt;

&lt;p&gt;So, how does this impact pipelining?&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;In the first stage, &lt;strong&gt;prefetch&lt;/strong&gt;, an instruction is read from memory.&lt;/p&gt;

    &lt;p&gt;The &lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;
can run with one of several prefetch modules.
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/prefetch.v&quot;&gt;[1]&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/dblfetch.v&quot;&gt;[2]&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/pipefetch.v&quot;&gt;[3]&lt;/a&gt;,
and
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/pfcache.v&quot;&gt;[4]&lt;/a&gt;.
Each of these modules has roughly the same interface, although the logic
within them can differ greatly.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;In the second stage, the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/idecode.v&quot;&gt;instruction
decode&lt;/a&gt;
stage, the parts of the instruction are drawn from from the instruction word
produced by the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/pfcache.v&quot;&gt;prefetch&lt;/a&gt;
stage.&lt;/p&gt;

    &lt;p&gt;As an example, this stage determines whether or not the instruction even has
registers &lt;code class=&quot;highlighter-rouge&quot;&gt;Ra&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;Rb&lt;/code&gt; encoded within it that need to be read from the
register set.  At the end of this stage the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;,
knows:&lt;/p&gt;

    &lt;p&gt;a. what registers it needs to read (&lt;code class=&quot;highlighter-rouge&quot;&gt;dcd_A&lt;/code&gt;, and &lt;code class=&quot;highlighter-rouge&quot;&gt;dcd_B&lt;/code&gt;),&lt;/p&gt;

    &lt;p&gt;b. if it needs to read from any register (&lt;code class=&quot;highlighter-rouge&quot;&gt;dcd_rA&lt;/code&gt;, and &lt;code class=&quot;highlighter-rouge&quot;&gt;dcd_rB&lt;/code&gt;)&lt;/p&gt;

    &lt;p&gt;c. what the immediate value is (&lt;code class=&quot;highlighter-rouge&quot;&gt;dcd_I&lt;/code&gt;), and if that value is zero
   (&lt;code class=&quot;highlighter-rouge&quot;&gt;dcd_Iz&lt;/code&gt;)&lt;/p&gt;

    &lt;p&gt;d. etc.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The third stage, the read operands stage, not only reads &lt;code class=&quot;highlighter-rouge&quot;&gt;Ra&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;Rb&lt;/code&gt; from
the register file, but also adds &lt;code class=&quot;highlighter-rouge&quot;&gt;I&lt;/code&gt; to &lt;code class=&quot;highlighter-rouge&quot;&gt;Rb&lt;/code&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The fourth stage calculates the &lt;code class=&quot;highlighter-rouge&quot;&gt;OP&lt;/code&gt; function on the values from &lt;code class=&quot;highlighter-rouge&quot;&gt;Ra&lt;/code&gt; and
&lt;code class=&quot;highlighter-rouge&quot;&gt;Rb+I&lt;/code&gt;.&lt;/p&gt;

    &lt;p&gt;If this is an
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/cpuops.v&quot;&gt;ALU&lt;/a&gt;,
instruction, the &lt;code class=&quot;highlighter-rouge&quot;&gt;OP&lt;/code&gt; field controls which potential output from the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/cpuops.v&quot;&gt;ALU&lt;/a&gt;,
&lt;a href=&quot;/zipcpu/2017/08/11/simple-alu.html&quot;&gt;will be selected&lt;/a&gt;.&lt;/p&gt;

    &lt;p&gt;If this is a &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/pipemem.v&quot;&gt;memory
operation&lt;/a&gt;,
a store will place the value &lt;code class=&quot;highlighter-rouge&quot;&gt;Ra&lt;/code&gt; into
memory location &lt;code class=&quot;highlighter-rouge&quot;&gt;Rb+I&lt;/code&gt;.  A load will read from memory
&lt;code class=&quot;highlighter-rouge&quot;&gt;Rb+I&lt;/code&gt; and present the result to the writeback unit.&lt;/p&gt;

    &lt;p&gt;Memory accesses, divides, and multiplies may all take longer than a single
clock in this stage.  We’ll need to come back and discuss how to handle
this later.&lt;/p&gt;

    &lt;p&gt;If done well, the outputs of this stage, whether from the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/cpuops.v&quot;&gt;ALU&lt;/a&gt;
or the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/memops.v&quot;&gt;memory
unit&lt;/a&gt;
can go directly back into this stage as inputs if so desired, as shown
in Fig 2.&lt;/p&gt;

    &lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 2: Answers go back into the ALU&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/cpu-bypass.svg&quot; alt=&quot;Answers go back into the ALU&quot; width=&quot;580&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

    &lt;p&gt;This will take place any time the output of the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/cpuops.v&quot;&gt;ALU&lt;/a&gt;
stage forms the input for the next instruction.  Indeed, this is a key
requirement for a high speed
pipelined &lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;.&lt;/p&gt;

    &lt;p&gt;However, if the output of the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/cpuops.v&quot;&gt;ALU&lt;/a&gt;
gets placed into the &lt;code class=&quot;highlighter-rouge&quot;&gt;Rb&lt;/code&gt; register input of the next instruction, &lt;em&gt;and&lt;/em&gt;
if that instruction
has an immediate, &lt;code class=&quot;highlighter-rouge&quot;&gt;I&lt;/code&gt;, that needs to be added to it (&lt;code class=&quot;highlighter-rouge&quot;&gt;dcd_zI&lt;/code&gt; is non-zero),
then the output cannot go directly back into the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/cpuops.v&quot;&gt;ALU&lt;/a&gt;.
It will instead need to go back to the read operands stage, causing
a pipeline bubble in the process.  This other path is shown by the dotted
line in Fig 2.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Finally, in the writeback unit, if the &lt;code class=&quot;highlighter-rouge&quot;&gt;C&lt;/code&gt; condition matches, the result
is written back into the register set.&lt;/p&gt;

    &lt;p&gt;Conditional branches are detected in this stage.  We’ll have to come back
and discuss how to handle this within the pipeline later as well.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;This is nominally how the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;
handles and uses its pipeline.  This simple pipeline, though, has all kinds
of hazards—many of which we’ll discuss below.&lt;/p&gt;

&lt;h2 id=&quot;pipeline-stalls-and-bubbles&quot;&gt;Pipeline Stalls and Bubbles&lt;/h2&gt;

&lt;p&gt;Before diving into pipeline specifics, let’s define a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bubble_(computing)&quot;&gt;pipeline stall&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;According to &lt;a href=&quot;https://en.wikipedia.org/wiki/Bubble_(computing)&quot;&gt;wikipedia&lt;/a&gt;,
a &lt;a href=&quot;https://en.wikipedia.org/wiki/Bubble_(computing)&quot;&gt;pipeline stall&lt;/a&gt;
is a condition where there’s no valid instruction within a particular pipeline
stage.  &lt;a href=&quot;https://en.wikipedia.org&quot;&gt;Wikipedia&lt;/a&gt; declares a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bubble_(computing)&quot;&gt;pipeline stall&lt;/a&gt;
to be synonymous with a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bubble_(computing)&quot;&gt;pipeline bubble&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;As the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt; uses the term, a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bubble_(computing)&quot;&gt;pipeline stall&lt;/a&gt;
takes place when there &lt;em&gt;is&lt;/em&gt; a valid instruction within a particular pipeline
stage, but when that instruction cannot move forward.&lt;/p&gt;

&lt;p&gt;For example, the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/div.v&quot;&gt;divide&lt;/a&gt;
takes roughly 32-clocks to complete.  During these 32-clocks, instructions in
the prior stage, the read operands stage, will be stuck there until the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/div.v&quot;&gt;divide&lt;/a&gt;
completes.   Likewise, the writeback stage will be idle during this time,
being reserved for writing back the results of the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/div.v&quot;&gt;divide&lt;/a&gt;
instruction.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org&quot;&gt;Wikipedia&lt;/a&gt;’s definition declares the condition
where no valid data is within a pipeline stage to be called a stall.  This
seems to me to be more of a consequence of a stall, than a stall itself.
The &lt;strong&gt;pipeline bubble&lt;/strong&gt; term describes this better, although
&lt;a href=&quot;https://en.wikipedia.org&quot;&gt;Wikipedia&lt;/a&gt; declares the two terms to be synonymous.&lt;/p&gt;

&lt;p&gt;If you watch the pipeline, such as within the demonstration we’ll discuss
later, you can visually see &lt;strong&gt;bubble&lt;/strong&gt;s form within it where there are no valid
instructions.&lt;/p&gt;

&lt;h2 id=&quot;unique-pipeline-needs&quot;&gt;Unique Pipeline Needs&lt;/h2&gt;

&lt;p&gt;There are two basic goals that a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;
has with respect to pipelining.  These two goals are common among
many pipeline systems:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Keep every stage filled.&lt;/p&gt;

    &lt;p&gt;For example, the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;
is capable of completing and retiring one
&lt;a href=&quot;/zipcpu/2017/08/11/simple-alu.html&quot;&gt;ALU&lt;/a&gt;
instruction per clock.  All of the pipeline logic within the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;CPU&lt;/a&gt;
has been designed so as to keep one instruction completing on every clock.&lt;/p&gt;

    &lt;p&gt;This is a common goal of any high speed pipeline.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Satisfy any pre-requisites for instruction operations.&lt;/p&gt;

    &lt;p&gt;An &lt;a href=&quot;/zipcpu/2017/08/11/simple-alu.html&quot;&gt;ALU&lt;/a&gt;
operation cannot complete if its values haven’t finished being produced
from other parts of the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;CPU&lt;/a&gt;.
For example, if
register &lt;code class=&quot;highlighter-rouge&quot;&gt;R0&lt;/code&gt;  is read from slow memory in one instruction and then
immediately used on the next instruction, the pipeline logic will need to
stall the second instruction, waiting for the
&lt;a href=&quot;/zipcpu/2017/08/11/simple-alu.html&quot;&gt;ALU&lt;/a&gt;,
until &lt;code class=&quot;highlighter-rouge&quot;&gt;R0&lt;/code&gt; is available.&lt;/p&gt;

    &lt;p&gt;This problem is even worse if an immediate is to be added to the value
read from memory prior to heading into the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/cpuops.v&quot;&gt;ALU&lt;/a&gt;.
In that case, it’s not just the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/cpuops.v&quot;&gt;ALU&lt;/a&gt;
that needs to stall, but the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;
also needs to stall the read operands stage where that immediate addition
takes place.  (We discussed this with Fig 2 above)&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;A &lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;,
though, has some other pipeline needs beyond the more traditional data flow
processing pipeline.  Specifically,
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;’s
need to be able to jump from one instruction in memory to another.  This
creates some unusual pipeline requirements.&lt;/p&gt;

&lt;p&gt;At its most basic level, a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;
needs be able to flush or clear its pipeline any time a branch renders
the work done in a prior stage irrelevant.
The worst case scenario is when a branch takes place that can’t be
caught prior to the writeback stage.  In that case, the whole pipeline will
need to be flushed, costing the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;
one clock per pipeline stage that cannot be completed.
The &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;ZipCPU&lt;/a&gt;
captures this logic with the &lt;code class=&quot;highlighter-rouge&quot;&gt;clear_pipeline&lt;/code&gt; signal.&lt;/p&gt;

&lt;p&gt;Other things can cause sudden pipeline changes as well.  For example, what
happens on an interrupt (peripheral initiated), a trap (user initiated), or
a fault?  The
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;
will need to start processing instructions from a new location in the
instruction stream–that of the interrupt service routine (ISR).
The &lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;
handles this condition by flushing the pipeline on any change of interrupt
status.
The &lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt; is also unique in that the
interrupt address is kept within an alternate register set.  (See the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/doc/spec.pdf&quot;&gt;ZipCPU
specification&lt;/a&gt;
for details.&lt;/p&gt;

&lt;p&gt;Indeed, lots of things need to change within the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;
every time it switches to an interrupt context, or back again.
If you want to trace this logic, feel free to
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;look for&lt;/a&gt;
the &lt;code class=&quot;highlighter-rouge&quot;&gt;w_switch_to_interrupt&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;w_release_from_interrupt&lt;/code&gt; wires.  The first
will be true any time the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;
switches to an interrupt context, the second will be true anytime the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;
switches back.&lt;/p&gt;

&lt;p&gt;Now, with all that as background, we can discuss the logic necessary to handle
a pipeline handshake.&lt;/p&gt;

&lt;h2 id=&quot;cpu-handshake&quot;&gt;CPU Handshake&lt;/h2&gt;

&lt;table style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 3: ZipCPU Pipeline Signals&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/pipeline-blocks-cpu.svg&quot; alt=&quot;ZipCPU Pipeline Signals&quot; width=&quot;380&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;The
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;
pipeline is controlled primarily with three logic signals per stage:
&lt;code class=&quot;highlighter-rouge&quot;&gt;stalled&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;valid&lt;/code&gt;, and &lt;code class=&quot;highlighter-rouge&quot;&gt;CE&lt;/code&gt;, as shown in Fig 3 to the right.  The logic is
designed around the idea of processing the data from the previous stage any
time a &lt;code class=&quot;highlighter-rouge&quot;&gt;CE&lt;/code&gt; line is set.  The basic logic is this: if a stage is not stalled,
and if the previous stage is valid, then the &lt;code class=&quot;highlighter-rouge&quot;&gt;CE&lt;/code&gt; line will be set.  The &lt;code class=&quot;highlighter-rouge&quot;&gt;CE&lt;/code&gt;
control signal is used to determine when to clock the data from the last stage
forward.&lt;/p&gt;

&lt;p&gt;Let’s walk though that for a moment.&lt;/p&gt;

&lt;p&gt;First, each stage has a condition (or set of conditions) that might stall the
prior stage from entering this stage.  This is the stall logic for this stage.&lt;/p&gt;

&lt;p&gt;For example, the read operands stage will stall any time the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/cpuops.v&quot;&gt;ALU&lt;/a&gt;
is already busy, the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/memops.v&quot;&gt;memory
unit&lt;/a&gt; is busy
with a read, or the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/div.v&quot;&gt;divide&lt;/a&gt; is busy.
The lines &lt;code class=&quot;highlighter-rouge&quot;&gt;alu_busy&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;mem_busy&lt;/code&gt;, and &lt;code class=&quot;highlighter-rouge&quot;&gt;div_busy&lt;/code&gt; are used to capture these
conditions.  An exception is made if the memory unit is busy &lt;em&gt;writing&lt;/em&gt; a value
over the bus.  In this case, &lt;code class=&quot;highlighter-rouge&quot;&gt;mem_rdbusy&lt;/code&gt; captures the idea that the memory
is busy with a read and not a write.  Likewise, the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/cpuops.v&quot;&gt;ALU&lt;/a&gt;
will also stall if the external halt request line is true.  (We’ll come back and
discuss this when discussing how to debug a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt; later.)
Another, less common, example is that the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/cpuops.v&quot;&gt;ALU&lt;/a&gt;
will stall any time the condition codes are written to manually–lest the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/cpuops.v&quot;&gt;ALU&lt;/a&gt;
write a value back according to the wrong conditions.&lt;/p&gt;

&lt;p&gt;In general, though, the stall logic looks like:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;assign	stage[n]_stalled = (stage[n]_valid)&amp;amp;&amp;amp;((stage[n+1]_stalled)
		||(things that would stall this stage));&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;In this case, I’m using &lt;code class=&quot;highlighter-rouge&quot;&gt;stage[n]_stalled&lt;/code&gt; to describe the &lt;code class=&quot;highlighter-rouge&quot;&gt;stalled&lt;/code&gt; variable
for this stage.  If you look within the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;,
you’ll find variables named &lt;code class=&quot;highlighter-rouge&quot;&gt;pf_stalled&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;dcd_stalled&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;op_stalled&lt;/code&gt;,
&lt;code class=&quot;highlighter-rouge&quot;&gt;alu_stalled&lt;/code&gt;, and &lt;code class=&quot;highlighter-rouge&quot;&gt;mem_stalled&lt;/code&gt;.  These variables capture this
logic, together with all of the more obscure reasons why the &lt;code class=&quot;highlighter-rouge&quot;&gt;stalled&lt;/code&gt; line
might be made true as well–such as on a debugging &lt;code class=&quot;highlighter-rouge&quot;&gt;BREAK&lt;/code&gt; instruction.&lt;/p&gt;

&lt;p&gt;Second, if any stage is not stalled, and if the prior stage has valid data
within it, then we can step that stage forward.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;assign	stage[n]_ce = (stage[n-1]_valid)&amp;amp;&amp;amp;(!stage[n]_stalled);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;If you pay close attention, you might find this looks a lot like the
handshake signal, &lt;code class=&quot;highlighter-rouge&quot;&gt;(i_ce)&amp;amp;&amp;amp;(!o_busy)&lt;/code&gt;, that we discussed in our &lt;a href=&quot;/blog/2017/08/14/strategies-for-pipelining.html&quot;&gt;last post on
pipelining&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Inside the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;,
these various pipeline variables are named
&lt;code class=&quot;highlighter-rouge&quot;&gt;dcd_ce&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;op_ce&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;alu_ce&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;mem_ce&lt;/code&gt;, and &lt;code class=&quot;highlighter-rouge&quot;&gt;div_ce&lt;/code&gt;.  There’s also a similar
&lt;code class=&quot;highlighter-rouge&quot;&gt;master_ce&lt;/code&gt; which is controlled from the external debugging interface–something
we’ll get to later.&lt;/p&gt;

&lt;p&gt;With these signals out of the way, we can start working through the pipeline
signals.  The first registered signal is the &lt;code class=&quot;highlighter-rouge&quot;&gt;valid&lt;/code&gt; signal.  This signal
indicates whether or not a particular stage has valid data within it.
To get valid data into a stage, the prior stage must have valid data, and
this stage cannot be stalled.  Hence, we have the following logic:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	// On any reset or clear pipeline, we clear the stage valid
	// register
	if ((i_reset)||(clear_pipeline))
	begin
		stage[n]_valid &amp;lt;= 1&#39;b0;
	end if (stage[n]_ce)
	begin
		// Otherwise, we accept the data from the previous
		// stage, and operate upon it if necessary.
		stage[n]_valid &amp;lt;= stage[n-1]_valid;
	end else if (stage[n+1]_ce)
		// If there&#39;s nothing valid to come in, but the next stage
		// has taken our data, then we are no longer valid here anymore.
		stage[n]_valid &amp;lt;= 1&#39;b0;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Within the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;,
the basic valid registers are called &lt;code class=&quot;highlighter-rouge&quot;&gt;pf_valid&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;dcd_valid&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;op_valid&lt;/code&gt;.
The &lt;code class=&quot;highlighter-rouge&quot;&gt;op_valid&lt;/code&gt; signal is also broken into three separate signals, depending
upon which stage the read operands stage moves to next:
&lt;code class=&quot;highlighter-rouge&quot;&gt;op_valid_alu&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;op_valid_mem&lt;/code&gt;, and  &lt;code class=&quot;highlighter-rouge&quot;&gt;op_valid_div&lt;/code&gt;.  Finally, the output
of the ALU/MEM/DIV stage is captured by the &lt;code class=&quot;highlighter-rouge&quot;&gt;alu_valid&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;mem_valid&lt;/code&gt;, and
&lt;code class=&quot;highlighter-rouge&quot;&gt;div_valid&lt;/code&gt; signals.  Indeed, these signals are used to determine whether
or not valid data is ready to be written back.&lt;/p&gt;

&lt;p&gt;One particular difficulty with this language is the idea of an illegal
instruction.  Within the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;,
a stage containing an illegal instruction has the &lt;code class=&quot;highlighter-rouge&quot;&gt;valid&lt;/code&gt; line set high.
This is because an illegal instruction needs to be processed like any other
instruction, and the &lt;code class=&quot;highlighter-rouge&quot;&gt;valid&lt;/code&gt; line controls when processing moves forward.
The alternative, moving instructions forward any time &lt;code class=&quot;highlighter-rouge&quot;&gt;valid&lt;/code&gt; &lt;em&gt;or&lt;/em&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;illegal&lt;/code&gt; were true, just costs more logic than required.&lt;/p&gt;

&lt;p&gt;Each stage has many more logic lines beyond the ones we just discussed.
These can often be treated in a much simpler fashion, though.  As a result,
these other signals are often sate based upon the simple &lt;code class=&quot;highlighter-rouge&quot;&gt;stage[n]_ce&lt;/code&gt; signal:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	if (stage[n]_ce)
		stage[n]_data &amp;lt;= ... // function of stage[n-1]_data&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Those are the basics of how the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;
handles pipelining.  Be aware, though, &lt;em&gt;the devil is in the details&lt;/em&gt;.
There are all kinds of pipeline hazards that you may not expect when first
building a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;My best advice for others, when trying to find these pipeline problems, is
to methodically debug your
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;
using
&lt;a href=&quot;https://www.veripool.org/wiki/verilator&quot;&gt;Verilator&lt;/a&gt; and some small programs.
Use &lt;a href=&quot;https://gcc.gnu.org&quot;&gt;GCC&lt;/a&gt;
both all optimizations turned on, as well as with all
optimizations turned off.  The two environments create very different pipeline
environments, and programs working in the one may not work in the other.  My
second piece of advice would be to create a program containing every pipeline
hazard you can think of, and to turn this program into a test program for the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;.
You can find the &lt;a href=&quot;https://github.com/ZipCPU/zipcu&quot;&gt;ZipCPU&lt;/a&gt;’s
&lt;a href=&quot;https://github.com/ZipCPU/openarty/blob/master/sw/board/cputest.c&quot;&gt;CPU testing
program&lt;/a&gt;
within the &lt;a href=&quot;https://github.com/ZipCPU/openarty&quot;&gt;OpenArty&lt;/a&gt; distribution.&lt;/p&gt;

&lt;h2 id=&quot;demonstration&quot;&gt;Demonstration&lt;/h2&gt;

&lt;p&gt;I have a wonderful demonstration of all of this that I would like to post, but
to see it I may need some help from my readers.&lt;/p&gt;

&lt;p&gt;Specifically, the demonstration involves building the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt; distribution, and then running the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/bench/asm/simtest.s&quot;&gt;simtest&lt;/a&gt;
program within the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/sim/verilated/zipcpu_tb.cpp&quot;&gt;simulator&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/sim/verilated/zipcpu_tb.cpp&quot;&gt;simulator&lt;/a&gt;
allows you to watch how well the pipeline is filled at any given clock, as
well as the ability to “watch” the signals discussed above.  Further, by
adjusting the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/cpudefs.v&quot;&gt;pipeline
parameters&lt;/a&gt;,
you can see how the pipeline and
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
are affected as the logic within the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;,
is increased or decreased.  Indeed, you can watch the &lt;code class=&quot;highlighter-rouge&quot;&gt;valid&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;CE&lt;/code&gt;, and
&lt;code class=&quot;highlighter-rouge&quot;&gt;stall&lt;/code&gt; lines as they get set and adjusted on a clock by clock basis.&lt;/p&gt;

&lt;p&gt;Nominally, the instructions to do this would require something like:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span class=&quot;c&quot;&gt;# Install packages necessary to build the simulator&lt;/span&gt;
sudo apt-get install bc verilator
&lt;span class=&quot;c&quot;&gt;# Install packages necessary to build GCC&lt;/span&gt;
sudo apt-get install flex bison libncurses5-dev
sudo apt-get install libmpfr-dev libmpc-dev libgmp-dev libmpfr-doc
&lt;span class=&quot;c&quot;&gt;# Install libelf.  libelf is used to load executable files into both&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;# the simulator and onto any actual FPGA H/W&lt;/span&gt;
sudo apt-get install libelf-dev
&lt;span class=&quot;c&quot;&gt;#&lt;/span&gt;
git clone https://github.com/ZipCPU/zipcpu
&lt;span class=&quot;nb&quot;&gt;cd &lt;/span&gt;zipcpu
make
&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[[&lt;/span&gt; ! -x sw/install/cross-tools/bin/zip-gcc &lt;span class=&quot;o&quot;&gt;]]&lt;/span&gt;;
&lt;span class=&quot;k&quot;&gt;then
  &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;GCC failed to build&quot;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;else
  if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[[&lt;/span&gt; ! -x sim/verilator/zipsys_tb &lt;span class=&quot;o&quot;&gt;]]&lt;/span&gt;;
  &lt;span class=&quot;k&quot;&gt;then
    &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;The simulator failed to build&quot;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;else
    &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;PATH&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$PATH&lt;/span&gt;:&lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;pwd&lt;/span&gt;&lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;/sw/install/cross-tools/bin/zip-gcc
    &lt;span class=&quot;nb&quot;&gt;cd &lt;/span&gt;bench/asm
    make simtest
    &lt;span class=&quot;nb&quot;&gt;cd&lt;/span&gt; ../../sim/verilator
    &lt;span class=&quot;c&quot;&gt;# Run the demo&lt;/span&gt;
    zipsys_tb ../../bench/asm/simtest
    &lt;span class=&quot;c&quot;&gt;# Press the &#39;t&#39; key to create a system clock &#39;tick&#39;s until things stop&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;#   changing&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;#   Watch how instructions work their way through the various pipeline&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;#   stages at the bottom of the screen&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;# &#39;q&#39; can be used to quit.&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;# &#39;r&#39; can be used to &#39;reboot&#39; the computer, and start the simulation over&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;fi
fi&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This is notional only, the above script has not been “tested” … but I think
it captures the idea of what I would have you do.&lt;/p&gt;

&lt;p&gt;My specific problem is that, while the design works nicely on my own system,
I’d love to have some help from others who would like to try running the
design on their own systems–so as to get some redundance across operating
systems and version differences.  If you are interested in trying this,
please write be at the address below if you have problems, or perhaps
just to tell me of your success.  Enough successes, and I’ll write a more
complete post about how to watch the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;
pipeline in action.&lt;/p&gt;

&lt;p&gt;(Instructions for installing the prerequisites on a Windows machine, using
&lt;a href=&quot;https://cygwin.com&quot;&gt;Cygwin&lt;/a&gt;, can be found
&lt;a href=&quot;/blog/2017/07/28/cygwin-fpga.html&quot;&gt;here&lt;/a&gt;)&lt;/p&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;That’s it!  The
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;
basically uses the &lt;a href=&quot;/blog/2017/08/14/strategies-for-pipelining.html&quot;&gt;handshake
approach&lt;/a&gt;
to handling pipeline stalls that &lt;a href=&quot;/blog/2017/08/14/strategies-for-pipelining.html&quot;&gt;we discussed
earlier&lt;/a&gt;.
A couple extra variables for logic expression allow the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;
to be able to detect and respond appropriately to pipeline hazards, stalling the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;.
anytime it is necessary to do so.&lt;/p&gt;

&lt;p&gt;Now that we’ve gone through this example, I’d like to come back and discuss
how to debug a &lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;
running within an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
in general.  That post has been mostly written for some time, but has been
waiting for this background beneath it to be explained.&lt;/p&gt;

&lt;p&gt;I’d also like to post more complete instructions for the pipeline demonstration
above, outlining how data moves through the
various stages of the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;
pipeline.  I’ll hold off on the demonstration, post, until I have some
confidence that it will work on the greatest number of computers.&lt;/p&gt;

&lt;hr /&gt;&lt;p&gt;&lt;em&gt;For I know that my redeemer liveth, and that he shall stand at the latter day upon the earth (Job 19:25)&lt;/em&gt;</description>
        <pubDate>Wed, 23 Aug 2017 00:00:00 -0400</pubDate>
        <link>http://zipcpu.com/zipcpu/2017/08/23/cpu-pipeline.html</link>
        <guid isPermaLink="true">http://zipcpu.com/zipcpu/2017/08/23/cpu-pipeline.html</guid>
        
        
        <category>zipcpu</category>
        
      </item>
    
      <item>
        <title>Rules for new FPGA designers</title>
        <description>&lt;p&gt;It’s a new school year!&lt;/p&gt;

&lt;p&gt;For all you new students out there, please accept
my welcome to the wonderful world of digital design.  I am neither a student
nor a professor, and yet I have helped many students through their projects
on the &lt;a href=&quot;https://forum.digilentinc.com&quot;&gt;Digilent forum&lt;/a&gt;, as well as on
&lt;a href=&quot;https://webchat.freenode.net&quot;&gt;freenode IRC&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;This post is an outgrowth of my own experience counseling beginners on
&lt;a href=&quot;https://forum.digilentinc.com&quot;&gt;Digilent’s forums&lt;/a&gt;.  Indeed, sometimes I
feel like I’m a broken record there repeating over and over the same rules
for newbies.&lt;/p&gt;

&lt;p&gt;So, before you ask for help, here are a couple rules to keep you from
running into the same trouble others have gotten stuck within:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Build your design with only one clock.&lt;/p&gt;

    &lt;p&gt;If the clock that comes into your chip is the wrong speed for your one
clock, then use a &lt;a href=&quot;https://www.xilinx.com/support/documentation/user_guides/ug472_7Series_Clocking.pdf&quot;&gt;PLL/MMCM&lt;/a&gt; to create the speed you want/need.&lt;/p&gt;

    &lt;p&gt;&lt;a href=&quot;/blog/2017/06/02/generating-timing.html&quot;&gt;This post&lt;/a&gt;
discusses a variety of alternative timing approaches, done within clocked
logic, that don’t require additional clocks to work.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Do &lt;em&gt;not&lt;/em&gt; transition on any negative (falling) edges.&lt;/p&gt;

    &lt;p&gt;Falling edge clocks should be considered a violation of the one
clock principle, as they act like separate clocks.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Do &lt;em&gt;not&lt;/em&gt; transition on the positive (rising) edge of anything other than
your system clock.&lt;/p&gt;

    &lt;p&gt;Lot’s of students seem to want to &lt;a href=&quot;/blog/2017/08/04/debouncing.html&quot;&gt;treat a button like a
clock&lt;/a&gt;, for example.
They then struggle to understand why their design isn’t working.
&lt;a href=&quot;/blog/2017/08/04/debouncing.html&quot;&gt;Here&lt;/a&gt; are some
better approaches that actually work with buttons.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Synchronize all external wire inputs by passing them through two clocked
flip-flops before using them.&lt;/p&gt;

    &lt;p&gt;This helps to avoid problems with
&lt;a href=&quot;https://en.wikipedia.org/wiki/Metastability_in_electronics&quot;&gt;metastability&lt;/a&gt;.
We discussed &lt;a href=&quot;/blog/2017/08/04/debouncing.html&quot;&gt;how to synchronize inputs
here&lt;/a&gt; when dealing with
buttons.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Do &lt;em&gt;not&lt;/em&gt; use an asynchronous reset within your design.&lt;/p&gt;

    &lt;p&gt;Test for any reset within an always block on the positive edge of your system
clock like everything else.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Simulate everything before placing it onto your hardware&lt;/p&gt;

    &lt;p&gt;The unique thing about simulation is that a good simulator will allow you
to see and examine &lt;em&gt;every&lt;/em&gt; piece of logic on &lt;em&gt;every&lt;/em&gt; simulated clock.
A good simulator will also allow you to simulate any external peripherals,
so that you don’t need your hardware to run your simulator.&lt;/p&gt;

    &lt;p&gt;You can read about &lt;a href=&quot;/blog//2017/06/23/my-dbg-philosophy.html&quot;&gt;my own debugging philosophy
here&lt;/a&gt;.&lt;/p&gt;

    &lt;p&gt;You can also read about &lt;a href=&quot;/blog/2017/06/21/looking-at-verilator.html&quot;&gt;how to simulate hardware together with your design
here&lt;/a&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Build unit tests that can “prove” your components work, via a simulator,
so that when you later make changes to “improve” the component, you will
know that the improvements haven’t broken anything.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Build simulations that will support not only unit test, but also full up
integration testing&lt;/p&gt;

    &lt;p&gt;This was also discussed in the post about &lt;a href=&quot;/blog/2017/06/23/my-dbg-philosophy.html&quot;&gt;my own debugging
philosophy&lt;/a&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Make sure you simulate whatever means you will use for debugging your design
before you transition to hardware.&lt;/p&gt;

    &lt;p&gt;An &lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt; can
be a very difficult black box to get debugging information out of.  Before
you transition your design into an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;, I
recommend having some means of getting debugging information back out.  This
means needs to be simulated and proven along with everything else.&lt;/p&gt;

    &lt;p&gt;If you’ve read much of my blog, you’ll know that I highly recommend
&lt;a href=&quot;/blog/2017/06/16/dbg-bus-forest.html&quot;&gt;using a debugging
bus&lt;/a&gt; that
controls your
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt; over
&lt;a href=&quot;https://en.wikipedia.org/wiki/Transmission_Control_Protocol&quot;&gt;TCP&lt;/a&gt;/&lt;a href=&quot;https://en.wikipedia.org/wiki/Internet_protocol_suite&quot;&gt;IP&lt;/a&gt;.  That allows you &lt;a href=&quot;/blog/2017/06/17/why-network-debugging.html&quot;&gt;to
control&lt;/a&gt;
your &lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
simulation, or your
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt; itself,
from the same software.&lt;/p&gt;

    &lt;p&gt;While there are proprietary solutions to this problem that do not require a
&lt;a href=&quot;/blog/2017/06/16/dbg-bus-forest.html&quot;&gt;debugging bus&lt;/a&gt;,
you may struggle to integrate your
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
interaction software with them.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Don’t use &lt;a href=&quot;https://en.wikipedia.org/wiki/Magic_number_(programming)&quot;&gt;magic numbers&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;A &lt;a href=&quot;https://en.wikipedia.org/wiki/Magic_number_(programming)&quot;&gt;magic number&lt;/a&gt;
is a number that shows up without explanation or dependency within your code.&lt;/p&gt;

    &lt;p&gt;This one is so important, that &lt;a href=&quot;https://twitter.com/dEnergy_dTime&quot;&gt;Marcus
Muller&lt;/a&gt; chose to echo this sentiment
as well in the twitter section down below.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Never write the same code twice.&lt;/p&gt;

    &lt;p&gt;Write it once, write it well, and then reuse it.  Fix it, if you must fix
it, just don’t rewrite it over and over again for every project.   If done
well, this will give you a jump start on any future projects.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;rules-for-software-engineers&quot;&gt;Rules for software engineers&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Hardware design is &lt;em&gt;not&lt;/em&gt; like software design&lt;/p&gt;

    &lt;p&gt;In software, you can use &lt;code class=&quot;highlighter-rouge&quot;&gt;printf()&lt;/code&gt; or a debugger to &lt;em&gt;see&lt;/em&gt; every variable in
your algorithm.  In an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;, you
will struggle to &lt;em&gt;see&lt;/em&gt; anything.&lt;/p&gt;

    &lt;p&gt;Even if you could &lt;em&gt;see&lt;/em&gt; everything in an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;, you
wouldn’t be able to stop the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt; to
&lt;em&gt;see&lt;/em&gt; any high speed interactions like you can stop a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt; in a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Debugger&quot;&gt;debugger&lt;/a&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Simulation first.&lt;/p&gt;

    &lt;p&gt;The only time you will be able to &lt;em&gt;see&lt;/em&gt; everything is in simulation.  Start
your debugging process there.
&lt;a href=&quot;/blog//2017/06/21/looking-at-verilator.html&quot;&gt;This post&lt;/a&gt;
discusses how you can continue debugging by &lt;code class=&quot;highlighter-rouge&quot;&gt;printf()&lt;/code&gt;–but
only in simulation, should you wish to do so.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Get familiar with a logic analyzer on your first project&lt;/p&gt;

    &lt;p&gt;While you can’t &lt;em&gt;see&lt;/em&gt; everything in an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;, and
especially not when you are running at speed, you can get a trace from a
running &lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
showing how logic transitions over time.&lt;/p&gt;

    &lt;p&gt;Such a trace can come from an external logic analyzer.  Many of these are
available for purchase.  For example, I’ve used the &lt;a href=&quot;https://store.digilentinc.com/digital-discovery-portable-logic-analyzer-and-digital-pattern-generator/&quot;&gt;Digital
Discovery&lt;/a&gt;
to find bugs in &lt;a href=&quot;https://github.com/ZipCPU/icozip&quot;&gt;one of my projects&lt;/a&gt;.  I’m
hoping to blog about my experiences with it soon as well.  I also have the
&lt;a href=&quot;http://dangerousprototypes.com/docs/Open_Bench_Logic_Sniffer&quot;&gt;Open Bench Logic
Sniffer&lt;/a&gt;
on my desk waiting to be tried and tested.&lt;/p&gt;

    &lt;p&gt;We’ve also discussed using an internal scope many times on this blog.
Such scope’s are &lt;a href=&quot;/blog/2017/06/08/simple-scope.html&quot;&gt;not hard to
build&lt;/a&gt;, and can be
&lt;em&gt;very&lt;/em&gt; useful when trying to figure out what’s going on.  I personally use a
&lt;a href=&quot;https://github.com/ZipCPU/wbscope&quot;&gt;wishbone scope&lt;/a&gt;.  We’ve discussed how to
set that up
&lt;a href=&quot;/blog/2017/07/08/getting-started-with-wbscope.html&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Teach your
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
to do some of your debugging for you.&lt;/p&gt;

    &lt;p&gt;Learn to &lt;a href=&quot;/blog/2017/05/24/serial-port.html&quot;&gt;set an LED when error conditions take
place&lt;/a&gt;.&lt;/p&gt;

    &lt;p&gt;Learn to trigger your “trace” generation on error conditions, so you can
read back logic leading up to those “error conditions.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;just-for-students&quot;&gt;Just for students&lt;/h2&gt;

&lt;p&gt;I’ve seen a lot of &lt;a href=&quot;/blog/2017/06/10/lost-college-student.html&quot;&gt;students get
burned&lt;/a&gt;.  While
some might say that this is a normal part of the learning process, don’t let
it be your process.  Learn from those who have gone before you.  Specific
lessons I would share include:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Success is measured by the number of failures.  Plan for failure.&lt;/p&gt;

    &lt;p&gt;&lt;em&gt;Every&lt;/em&gt; student tends to come across some “impossible”
problem in his design that he cannot figure out.  He may get stuck at this
point for days or even weeks.  This is common.  &lt;em&gt;Plan&lt;/em&gt; on getting stuck,
put some time into your schedule in case this happens,
and then plan before hand on how you are going to get yourself unstuck.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Don’t start your project at the last minute.&lt;/p&gt;

    &lt;p&gt;Good engineering takes time to do, and to do right.  You cannot control
when things will go wrong, or how long it will take to fix things when it
does.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Plan on debugging from the beginning.  Build yourself the infrastructure
you need for that task first, then build your design.&lt;/p&gt;

    &lt;p&gt;o All of my designs include both one or more  &lt;a href=&quot;https://github.com/ZipCPU/wbscope&quot;&gt;wishbone
  scopes&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;o All of my designs include a &lt;a href=&quot;https://github.com/ZipCPU/openarty/blob/master/rtl/wbubus.v&quot;&gt;wishbone to
  UART&lt;/a&gt;
  &lt;a href=&quot;/blog/2017/06/05/wb-bridge-overview.html&quot;&gt;debugging bus&lt;/a&gt;
  giving me access to my &lt;a href=&quot;https://github.com/ZipCPU/wbscope&quot;&gt;wishbone scopes&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Consider &lt;a href=&quot;/blog/2017/06/02/design-process.html&quot;&gt;this
discussion&lt;/a&gt;
on the &lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
design process, and learn what both instructors and experts often overlook
when they teach you how to do the task.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;rules-from-twitter&quot;&gt;Rules from Twitter&lt;/h2&gt;

&lt;p&gt;Many thanks to those who know &lt;a href=&quot;https://twitter.com/zipcpu&quot;&gt;me on twitter&lt;/a&gt;!
They also offered the following pieces of advice for new students: (some edits
applied)&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;My boss would tell me “Think in hardware” #parallel execution of code,
not serial. &lt;a href=&quot;https://twitter.com/sachin_bhutada&quot;&gt;sachin_bhutada&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Thank you, &lt;a href=&quot;https://twitter.com/sachin_bhutada&quot;&gt;sachin_bhutada&lt;/a&gt;,
this may be one of the most common struggles software students have.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Use the right device for your job.  Need to do 100kOps/s of multiplications?
Pah, you cheapest MCU can do that.  Remember: designing in HDL is hard,
programming in C is easy.  &lt;a href=&quot;https://twitter.com/dEnergy_dTime&quot;&gt;Marcus Muller&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;I think &lt;a href=&quot;https://twitter.com/dEnergy_dTime&quot;&gt;Marcus Muller&lt;/a&gt; meant to say that
programming in C++ is easy …&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;One week of aimless development can easily save you two hours of writing
specifications.  &lt;a href=&quot;https://twitter.com/dEnergy_dTime&quot;&gt;Marcus Muller&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;Use build-time parameters instead of
&lt;a href=&quot;https://en.wikipedia.org/wiki/Magic_number_(programming)&quot;&gt;magic constants&lt;/a&gt;;
you’ll thank me later.  &lt;a href=&quot;https://twitter.com/dEnergy_dTime&quot;&gt;Marcus Muller&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;When working in a team, beat others with a stuck until they learn to
properly use &lt;a href=&quot;https://en.wikipedia.org/wiki/Git&quot;&gt;git&lt;/a&gt;
&lt;a href=&quot;https://twitter.com/dEnergy_dTime&quot;&gt;Marcus Muller&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;Don’t believe hypes.  &lt;a href=&quot;https://twitter.com/dEnergy_dTime&quot;&gt;Marcus Muller&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;If it’s complicated, make a drawing.  &lt;a href=&quot;https://twitter.com/dEnergy_dTime&quot;&gt;Marcus Muller&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;Get a good book.  The online tutorials you find are … spotty, at best.  Learn the basics first.  &lt;a href=&quot;https://twitter.com/dEnergy_dTime&quot;&gt;Marcus Muller&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;I often recommend &lt;a href=&quot;http://asic-world/verilog/veritut.html&quot;&gt;asic-world’s online
tutorials&lt;/a&gt;, but
&lt;a href=&quot;https://twitter.com/dEnergy_dTime&quot;&gt;Marcus Muller&lt;/a&gt;’s advice still rings
true.  “Learn the basics first.”  &lt;a href=&quot;&quot;&gt;This blog&lt;/a&gt;
cannot cover all of the basics.&lt;/p&gt;

&lt;p&gt;Indeed, his comments hit the nail on the head so well, I’ve struggled here to
figure out anything to add to them.&lt;/p&gt;

&lt;p&gt;As for &lt;a href=&quot;&quot;&gt;this blog&lt;/a&gt; and what you will find here, I’m just
going to go back and underline &lt;a href=&quot;https://twitter.com/dEnergy_dTime&quot;&gt;Marcus
Muller&lt;/a&gt;’s advice to “Learn the basics
first.”
Thank you, &lt;a href=&quot;https://twitter.com/dEnergy_dTime&quot;&gt;Marcus Muller&lt;/a&gt;!&lt;/p&gt;

&lt;p&gt;Indeed, thank you again to all who responded!&lt;/p&gt;

&lt;h2 id=&quot;rules-are-made-to-be-broken&quot;&gt;Rules are made to be broken&lt;/h2&gt;

&lt;p&gt;Please notice how I titled this post as “Rules for new FPGA designers”.  These rules are
for &lt;em&gt;beginners&lt;/em&gt;.  Those who have worked with
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;s for a
longer period of time will understand that there are times and places for all
of these rules to be broken.&lt;/p&gt;

&lt;p&gt;To those who are contemplating breaking these rules, who may be at the point of
moving from a beginning &lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt; designer to a more intermediate one, my advice is
this:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Carefully consider your steps.  Do you really need to break the rule?  My
twitter friends and I
shared these rules for a reason.  Don’t break them unless you absolutely
need to.  Further, if you do absolutely need to break the rule, do your
research first so that you know how to do so safely and reliably.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;this-isnt-the-last-word&quot;&gt;This isn’t the last word&lt;/h2&gt;

&lt;p&gt;I expect I’ll come back to this post many times to update my rules for
beginners.  So, if you’ve read this once, don’t be surprised if it changes
again later as I add to these rules.&lt;/p&gt;

&lt;p&gt;Have I missed anything?  Feel free to let me know at the address below,
and thank you for everyone who has contributed so far.&lt;/p&gt;

&lt;p&gt;Finally good luck, have some fun, and stay out of
&lt;a href=&quot;/blog/2017/05/19/fpga-hell.html&quot;&gt;FPGA Hell&lt;/a&gt;!&lt;/p&gt;
&lt;hr /&gt;&lt;p&gt;&lt;em&gt;I have fed you with milk, and not with meat: for hitherto ye were not able to bear it, neither yet now are ye able (1Cor 3:2)&lt;/em&gt;</description>
        <pubDate>Mon, 21 Aug 2017 00:00:00 -0400</pubDate>
        <link>http://zipcpu.com/blog/2017/08/21/rules-for-newbies.html</link>
        <guid isPermaLink="true">http://zipcpu.com/blog/2017/08/21/rules-for-newbies.html</guid>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>Two of the Simplest Digital filters</title>
        <description>&lt;p&gt;I’d like to spend some time discussing
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;Digital Filtering&lt;/a&gt; on
&lt;a href=&quot;&quot;&gt;this blog&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;This is going to be a bit of a difficult topic, however, in that
I don’t intend to discuss &lt;a href=&quot;https://en.wikipedia.org/wiki/Parks-McClellan_filter_design_algorithm&quot;&gt;how to
design&lt;/a&gt;
a &lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;Digital Filter&lt;/a&gt;,
nor do I intend to discuss
&lt;a href=&quot;https://en.wikipedia.org/wiki/Discrete_Fourier_transform&quot;&gt;how to evaluate&lt;/a&gt;
the design of a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;digital filter&lt;/a&gt;,
nor do I intend to discuss
&lt;a href=&quot;https://en.wikipedia.org/wiki/Aliasing&quot;&gt;aliasing&lt;/a&gt;.  These are all vital
topics necessary for understanding what a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;digital filter&lt;/a&gt; is,
as well as understanding whether or not
a &lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;digital filter&lt;/a&gt; even works.
They are also vital topics to understand when comparing the performance of one
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;digital filter&lt;/a&gt;
with that of another.  However, these are really topics for a different course.&lt;/p&gt;

&lt;p&gt;For now, it’s worth understanding that a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;digital filter&lt;/a&gt;
implements a &lt;a href=&quot;https://en.wikipedia.org/wiki/Convolution&quot;&gt;discrete convolution&lt;/a&gt;,
and that such
&lt;a href=&quot;https://en.wikipedia.org/wiki/Convolution&quot;&gt;discrete convolution&lt;/a&gt;s
are provably the &lt;em&gt;only&lt;/em&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_signal_processing&quot;&gt;signal processing&lt;/a&gt;
operations that are both &lt;a href=&quot;https://en.wikipedia.org/wiki/Linear_system&quot;&gt;linear&lt;/a&gt;
and &lt;a href=&quot;https://en.wikipedia.org/wiki/Shfit-invariant_system&quot;&gt;shift invariant&lt;/a&gt;.
This makes them a very important part of any discussion of &lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_signal_processing&quot;&gt;digital signal
processing (DSP)&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;It’s also worth noting that any student of &lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_signal_processing&quot;&gt;digital signal
processing&lt;/a&gt;
should be able to recognize when a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;digital filter&lt;/a&gt;
is
&lt;a href=&quot;https://en.wikipedia.org/wiki/Causal_filter&quot;&gt;causal&lt;/a&gt;,
&lt;a href=&quot;https://en.wikipedia.org/wiki/BIBO_stability&quot;&gt;stable&lt;/a&gt;,
when it has &lt;a href=&quot;https://en.wikipedia.org/wiki/Linear_phase&quot;&gt;linear phase&lt;/a&gt;,
and when it has a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Finite_impulse_response&quot;&gt;finite (FIR)&lt;/a&gt;
or an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Infinite_impulse_response&quot;&gt;infinite (IIR)&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Impulse_response&quot;&gt;impulse response&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Our focus in this blog is going to be on how to debug a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;digital filter&lt;/a&gt;
so that you can know it works.  To get there, though, we are going to have
to describe some
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filters&lt;/a&gt;
so that we have something to debug.  Filters we discuss, together with any
test or debugging logic, will be placed on
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters&quot;&gt;GitHub here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;For today, let’s just look at two &lt;em&gt;very&lt;/em&gt; simple
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;s:
the simplest non-trivial
&lt;a href=&quot;https://en.wikipedia.org/wiki/Finite_impulse_response&quot;&gt;FIR&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;
that I know of, and a simple recursive averager (a type of
&lt;a href=&quot;https://en.wikipedia.org/wiki/Infinite_impulse_response&quot;&gt;IIR&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;)
that I have found to be very useful.&lt;/p&gt;

&lt;h1 id=&quot;simple-fir-filter&quot;&gt;Simple FIR Filter&lt;/h1&gt;

&lt;p&gt;The first
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;
we are going to look at may well be the &lt;em&gt;simplest&lt;/em&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Finite_impulse_response&quot;&gt;FIR&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;
you will ever come across.  It simply averages adjacent samples together.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/eqn-simplfir.png&quot; alt=&quot;Equation for a very simple FIR filter&quot; width=&quot;242&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;The &lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/smplfir.v&quot;&gt;code to implement this
equation&lt;/a&gt;
is likewise just as simple:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;initial	delayed = 0;
always @(posedge i_clk)
	if (i_ce)
		delayed &amp;lt;= i_val;
always @(posedge i_clk)
	if (i_ce)
		o_val &amp;lt;= i_val + delayed;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/smplfir.v&quot;&gt;This filter&lt;/a&gt;
is useful for many reasons.  For example, unlike many other
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;s
that you may study,
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/smplfir.v&quot;&gt;this filter&lt;/a&gt;
requires no multiply (DSP) resources within the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;.
The output only
&lt;a href=&quot;/dsp/2017/07/21/bit-growth.html&quot;&gt;grows by one bit&lt;/a&gt;.
Further,
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/smplfir.v&quot;&gt;this filter&lt;/a&gt;
can also handle incoming samples at up to the full system clock rate for the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;.
Those are the good qualities of
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/smplfir.v&quot;&gt;this filter&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;It is also, however, a very difficult filter to use successfully simply because
its &lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency_response&quot;&gt;frequency response&lt;/a&gt;
rarely describes the performance that you want.  It doesn’t have a
sharp cut off.  Its taps and length are fixed.  Indeed, you might find
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/smplfir.v&quot;&gt;this filter&lt;/a&gt;
that we’ve just implemented to be quite useless.&lt;/p&gt;

&lt;p&gt;Before you give up on &lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/smplfir.v&quot;&gt;this simplest
filter&lt;/a&gt;,
consider what would happen if
you cascaded several of
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/smplfir.v&quot;&gt;these filters&lt;/a&gt;
together–one right after the other.  For example, suppose you ran your signal
through ten of
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/smplfir.v&quot;&gt;these filters&lt;/a&gt;
in succession.  You would get a filter with a much deeper stopband.&lt;/p&gt;

&lt;p&gt;This is the comparison shown in Fig 1 below.  In it, you can see the
predicted &lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency_response&quot;&gt;frequency
response&lt;/a&gt;
of our &lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/smplfir.v&quot;&gt;original simple
filter&lt;/a&gt;
above, as well as a similar predicted
&lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency_response&quot;&gt;frequency response&lt;/a&gt;
for the filter that would result from applying that
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/smplfir.v&quot;&gt;same filter&lt;/a&gt;
ten times in a row.  Both filters have been normalized so as to have a unity
response to anything at zero frequency.&lt;/p&gt;

&lt;table style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 1: &lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/smplfir.png&quot; alt=&quot;Performance of a very simple FIR filter&quot; width=&quot;772&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;We’ll need come back to this later, when it’s time to determine whether either
filter actually achieves this predicted
&lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency_response&quot;&gt;frequency response&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;While this new cascaded filter is starting to have a nicely acceptable
stop band, nothing remains that might be considered a flat “pass” band
anymore.  Still, the cascaded filter is
easy enough to build and costs so few resources that whenever a cascaded
filter of this type can be used, even if as only a component of other
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filters&lt;/a&gt;, it
is often very valuable to do so.  Therefore, &lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/smplfir.v&quot;&gt;this simple
filter&lt;/a&gt;
finds its best and greatest application in being a component of other,
more powerful, &lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filters&lt;/a&gt;.&lt;/p&gt;

&lt;h1 id=&quot;simple-iir-filter&quot;&gt;Simple IIR Filter&lt;/h1&gt;

&lt;p&gt;The next super-simple filter that I’m going to present is an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Infinite_impulse_response&quot;&gt;IIR&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;.
Specifically, let’s look at a recursive averager.  A recursive
averager keeps an average value at all times, and only adjusts that value
with any input.  Specifically, I like to think of it as a weighted sum of
some percentage of the new input sample plus the remaining percentage of
the last average.&lt;/p&gt;

&lt;p&gt;Perhaps an equation will help.  In symbology, a recursive averager is
just:&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/eqn-iiravg-defn.png&quot; alt=&quot;EQN for a simple recursive averager&quot; width=&quot;328&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Where we keep to the standard conventions of &lt;code class=&quot;highlighter-rouge&quot;&gt;n&lt;/code&gt; being the sample number,
&lt;code class=&quot;highlighter-rouge&quot;&gt;x[n]&lt;/code&gt; being our input and &lt;code class=&quot;highlighter-rouge&quot;&gt;y[n]&lt;/code&gt; being our output.  The new variable here,
alpha, is our means of adjusting how deep or sharp this filter is.  This is
a value between zero and one.  If alpha is one, no averaging takes place.
The closer alpha is to zero, however, the more the filter will average the
input and the longer it will take to converge to an average.  Likewise, the
closer alpha is to zero the less noise the filter will admit to the
average estimate.&lt;/p&gt;

&lt;p&gt;With a little manipulation, we can rearrange this filter into something
that’s really easy to compute.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/eqn-iiravg-implementation.png&quot; alt=&quot;EQN used to implement a simple recursive averager&quot; width=&quot;381&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Then, if we insist that alpha be a negative power of two, we can
replace the multiply above with a right shift:&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/eqn-iir-alpha-defn.png&quot; alt=&quot;Alpha = 2^{-LGALPHA}&quot; width=&quot;168&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;You’ll want to use an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Arithmetic_shift&quot;&gt;arithmetic shift&lt;/a&gt; here,
to mak certain the sign propagates in the case where the difference is
negative.&lt;/p&gt;

&lt;p&gt;This leads us to our first design choice: How many clocks can we use to
calculate an answer?  In particular, this recursive averager is going to
require a subtraction followed by an addition.  Both of these operations
&lt;em&gt;need to complete&lt;/em&gt; before the next sample.  You can either try to place
this all within a single system tick, or split it between two separate ticks.&lt;/p&gt;

&lt;p&gt;If you have new data samples present on every clock tick, you will need
to try the combinational approach I’m going to present below, stuffing all of
the logic into a single clock tick.  This has the unfortunate consequence of
limiting your system clock speed.&lt;/p&gt;

&lt;p&gt;On the other hand, if your data samples will always have at least one
unused clock between them, then you could take one clock tick to calculate
the difference, &lt;code class=&quot;highlighter-rouge&quot;&gt;x[n]-y[n-1]&lt;/code&gt;, and another to update the running average,
&lt;code class=&quot;highlighter-rouge&quot;&gt;y[n]&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;If we suppose that we must do this all within a single clock tick, the
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/iiravg.v&quot;&gt;following code&lt;/a&gt;
will implement this recursive averager.  In the code below, &lt;code class=&quot;highlighter-rouge&quot;&gt;AW&lt;/code&gt;
is the number of bits in the averager, and &lt;code class=&quot;highlighter-rouge&quot;&gt;IW&lt;/code&gt; is the bit-width of the input.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;wire	signed	[(AW-1):0]	difference, adjustment;

// The difference is given by x[n] - y[n-1]
assign	difference = { i_data, {(AW-IW){1&#39;b0}} } - r_average;

// The adjustment is the difference times alpha
assign	adjustment = { {(LGALPHA){(difference[(AW-1)])}},
			difference[(AW-1):(AW-LGALPHA)] };
always @(posedge i_clk)
	r_average &amp;lt;= r_average + adjustment;

assign	o_data = r_average;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;You may notice that I could have used the Verilog shift operator and did
not.  Had I done so, then the &lt;code class=&quot;highlighter-rouge&quot;&gt;adjustment&lt;/code&gt; value could have been set with:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;assign	adjustment = difference &amp;gt;&amp;gt;&amp;gt; LGALPHA;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;So, how did we do?  We’ll need to come back and test this later to know
for certain.  That in itself is going to need to take some thought.  Just
what is the best way to test a filter?  For now, you can see in Fig 2.
how good we &lt;em&gt;should&lt;/em&gt; be doing—if we had truly infinite precision
arithmetic.&lt;/p&gt;

&lt;table style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 2: &lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/iiravg.png&quot; alt=&quot;Performance of a recursive averager&quot; width=&quot;772&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Later, it would be nice to come back and generate this
&lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency_response&quot;&gt;frequency response&lt;/a&gt; curve
as a result of measuring how well the filter actually does.  Parameters that
will impact this measurement include not only how many bits are allocated
to the input and output (averager) values, but also how big the input value
truly is.&lt;/p&gt;

&lt;p&gt;Unlike the
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/smplfir.v&quot;&gt;simple&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Finite_impulse_response&quot;&gt;FIR&lt;/a&gt;
filter above, applications for this
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/iiravg.v&quot;&gt;simple&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Infinite_impulse_response&quot;&gt;IIR&lt;/a&gt;
recursive averaging filter abound just about everywhere.&lt;/p&gt;

&lt;p&gt;Want to measure a histogram?  Set this up to be an unsigned recursive
averager and then place a &lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt; into this filter every time your
data is within the bin of interest.&lt;/p&gt;

&lt;p&gt;Want to drive an automatic gain control circuit?  Compare the absolute
value of your signal against a fixed threshold.  Set the averager for unsigned
values, and then if your signal’s amplitude is too high you can average a
&lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt; into this averager.  If the result is too low, average a &lt;code class=&quot;highlighter-rouge&quot;&gt;0&lt;/code&gt; into this
averager. You can then use the result to know if you should turn the gain
in your circuitry up or down.&lt;/p&gt;

&lt;p&gt;You could also use this to remove any fixed gain in your circuitry.&lt;/p&gt;

&lt;p&gt;Indeed, you could even use this circuit coupled with a
&lt;a href=&quot;http://andraka.com/files/crdcsrvy.pdf&quot;&gt;CORDIC&lt;/a&gt;
to measure a single bin (or more) of the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency_response&quot;&gt;frequency response&lt;/a&gt;
of your system.&lt;/p&gt;

&lt;p&gt;This filter is exceptionally versatile as a cheap
&lt;a href=&quot;https://en.wikipedia.org/wiki/Low-pass_filter&quot;&gt;low-pass filter&lt;/a&gt;.  As an
example of that versatility, it also finds applications in &lt;a href=&quot;https://en.wikipedia.org/wiki/Phase-locked_loop&quot;&gt;phase lock
loops&lt;/a&gt;!&lt;/p&gt;

&lt;p&gt;These are all other topics, though, that we’ll need to come back to another
time.&lt;/p&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;Yes, those are the two simplest (non-trivial) filters I know.&lt;/p&gt;

&lt;p&gt;Sadly, though, we’re not yet in a position to test these filters to know that
they work.  As a result, we’ll need to come back to the topic of
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;digital filtering&lt;/a&gt;
once we discuss how to properly test a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;digital filter&lt;/a&gt;.
Some of those techniques will depend upon being able to use a
&lt;a href=&quot;http://andraka.com/files/crdcsrvy.pdf&quot;&gt;CORDIC&lt;/a&gt;–something
we have yet to present on this blog.  We’re also going to need to have
a thorough understanding of &lt;a href=&quot;https://en.wikipedia.org/wiki/Quantization_(signal_processing)&quot;&gt;quantization
noise&lt;/a&gt;,
another thing we’ll have to come back and discuss.&lt;/p&gt;

&lt;p&gt;This is by no means our final
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;digital filtering&lt;/a&gt;,
discussion either!  Many, many other
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
filtering topics remain.  These include:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;How to estimate a filter’s logic resource usage&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;How to build the cadillac of all filters: a dynamic filter whose filter
taps can be set at run time.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;And then how to build more realistic filters that will actually fit within
your &lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;’s
logic resources.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Do you get the feeling that
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;digital filtering&lt;/a&gt;
is a complex topic?  Since it is the most basic
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_signal_processing&quot;&gt;DSP&lt;/a&gt; operation,
we’ll need to spend some time going through it.  Perhaps some well written
examples will help to make this complex topic make more sense.&lt;/p&gt;

&lt;hr /&gt;&lt;p&gt;&lt;em&gt;To give subtilty to the simple, to the young man knowledge and discretion. (Prov 1:4)&lt;/em&gt;</description>
        <pubDate>Sat, 19 Aug 2017 00:00:00 -0400</pubDate>
        <link>http://zipcpu.com/dsp/2017/08/19/simple-filter.html</link>
        <guid isPermaLink="true">http://zipcpu.com/dsp/2017/08/19/simple-filter.html</guid>
        
        
        <category>dsp</category>
        
      </item>
    
      <item>
        <title>Strategies for pipelining logic</title>
        <description>&lt;p&gt;One of the things that new
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
students struggle with is the fact that
&lt;em&gt;everything&lt;/em&gt; in digital logic takes place in parallel.&lt;/p&gt;

&lt;p&gt;Many of these students come from a computer science background. 
They understand how an algorithm works, and how one thing must take place
after another in a specific sequence.  They tend to struggle, though, with
the idea that every step in an algorithm occupies a piece of digital logic
that will act on &lt;em&gt;every&lt;/em&gt; clock tick–whether used or not.&lt;/p&gt;

&lt;p&gt;One solution to sequencing operations is to create a giant state machine.
The reality, though, is that an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
tends to create all the logic for
every state at once, and then only select the correct answer at the end of
each clock tick.  In this fashion, a state machine can be very much like
the &lt;a href=&quot;/zipcpu/2017/08/11/simple-alu.html&quot;&gt;simple ALU&lt;/a&gt;
we’ve discussed.&lt;/p&gt;

&lt;p&gt;On the other hand, if the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
is going to implement all of the logic for the
operation anyway, why not arrange each of those operations into a sequence,
where each stage does something useful?  This approach rearranges the
algorithm into a pipeline.
&lt;a href=&quot;https://en.wikipedia.org/wiki/Pipelining_(DSP_implementation)&quot;&gt;Pipelining&lt;/a&gt;
tends to be faster than the state machine approach for
accomplishing the same algorithm, and it can even be more resource efficient,
although it isn’t necessarily so.&lt;/p&gt;

&lt;p&gt;The difficult part of a digital logic pipeline is that the pipeline runs and
produces outputs even when the inputs to the pipeline are not (yet) valid.&lt;/p&gt;

&lt;p&gt;So, let’s discuss several different strategies for handling the signaling
associated with pipeline logic.  In general, there’s no one size fits all
strategy.  The strategy you pick will depend upon the needs of your algorithm,
and its data source (input) and destination (output).&lt;/p&gt;

&lt;p&gt;We’ll work our way through several different strategies from the simplest
to most complex.&lt;/p&gt;

&lt;h2 id=&quot;the-global-valid-signal-for-sampled-data&quot;&gt;The global valid signal for sampled data&lt;/h2&gt;

&lt;p&gt;The first strategy for handling pipelining that we’ll discuss is to use a
global valid signal.
At each stage, the data coming into the pipeline is valid when the 
global valid signal is true.  Likewise, each stage may take no more clocks
to finish then there are between valid signals.  I like to use the &lt;code class=&quot;highlighter-rouge&quot;&gt;CE&lt;/code&gt; or
“clock enable” signal to represent this valid logic.  Hence,
Fig 1 shows a block diagram of this sort communication.&lt;/p&gt;

&lt;table style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 1: Pipelining with a global valid signal&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/pipeline-blocks-global-ce.svg&quot; alt=&quot;Pipelining with a global valid signal&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;The basic rules are this:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;There is a global &lt;code class=&quot;highlighter-rouge&quot;&gt;CE&lt;/code&gt; line, synchronous with the clock.  This line is
true anytime new data is ready.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Logic is allowed to transition &lt;em&gt;only&lt;/em&gt; when this &lt;code class=&quot;highlighter-rouge&quot;&gt;CE&lt;/code&gt; line is true&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;This leads to a trace diagram similar to Fig 2 below.&lt;/p&gt;

&lt;table style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 1: Pipelining with a global valid signal&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/pipeline-global-ce.svg&quot; alt=&quot;Pipelining with a global valid signal&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;The neat thing about this approach is that there’s no real pipelining logic
required per se.  Each stage just waits for the global valid signal to be true,
and then applies its logic.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	if (i_ce)
	begin
		output &amp;lt;= (some function of)(i_input);
	end // else *NOTHING*.  Nothing is allowed to change without CE=1&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;You may find very quickly, though, that this approach doesn’t handle all
pipelining needs.  However, while it doesn’t handle all pipelining needs,
it does handle the needs of a crucial problem set:
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_signal_processing&quot;&gt;&lt;em&gt;signal processing&lt;/em&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;In a typical
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_signal_processing&quot;&gt;signal processing&lt;/a&gt;
application, data either comes into an 
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
from an analog to digital (A/D) converter, or it goes out of the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
to a digital to analog (D/A) converter, or perhaps it does both.  The sample
rate defines when the &lt;code class=&quot;highlighter-rouge&quot;&gt;CE&lt;/code&gt; signal needs to be high, and any transient
states are flushed through the system.
The digital logic engineer’s job is to manipulate the samples along the way.&lt;/p&gt;

&lt;p&gt;Because the data moves through the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
at a fixed rate, and because it never suddenly changes speeds, the global
valid signal works quite well for it.&lt;/p&gt;

&lt;p&gt;Applications include
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;digital filtering&lt;/a&gt;,
digital &lt;a href=&quot;https://en.wikipedia.org/wiki/Phase-locked_loop&quot;&gt;phase lock loops&lt;/a&gt;,
&lt;a href=&quot;/dsp/2017/07/11/simplest-sinewave-generator.html&quot;&gt;numerically controlled oscillators&lt;/a&gt;,
and more. 
Indeed, anything that works at a &lt;em&gt;fixed data rate&lt;/em&gt; is usually
a good candidate for this method of pipelining.&lt;/p&gt;

&lt;p&gt;Why, even our resamplers have worked off of the concept of a global valid
signal, they’ve just had to deal with two different valid signals: one that
holds for one clock per input sample, and another that holds for one clock
for every output sample.
&lt;a href=&quot;/dsp/2017/06/06/simple-interpolator.html&quot;&gt;[1]&lt;/a&gt;
&lt;a href=&quot;/dsp/2017/07/29/series-linear-interpolation.html&quot;&gt;[2]&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;the-traveling-ce-to-reduce-latency&quot;&gt;The traveling CE to reduce latency&lt;/h2&gt;

&lt;p&gt;The global valid signal we discussed above, though, has two basic problems.
The first problem is that there’s no way to know if an output sample is
“valid” or not”.
The second is that the whole operation depends upon a uniform clock creating
the &lt;code class=&quot;highlighter-rouge&quot;&gt;CE&lt;/code&gt; signal.  What
happens if the data is produced in a bursty fashion, and you want to know
not only &lt;em&gt;when&lt;/em&gt; the output is valid but also &lt;em&gt;if&lt;/em&gt; the output is valid?  In
this case, another approach is required.&lt;/p&gt;

&lt;p&gt;I’m going to call this second approach the “traveling CE” approach.  Basically,
each stage in the pipeline propagates the CE forward, as in Fig 3.&lt;/p&gt;

&lt;table style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 3: Pipelining with a traveling CE&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/pipeline-blocks-traveling-ce.svg&quot; alt=&quot;Pipeline block diagram of a traveling CE&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;The basic rules to this approach are:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Whenever the &lt;code class=&quot;highlighter-rouge&quot;&gt;CE&lt;/code&gt; signal is true, the data associated with it must also be
valid.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;At the end of every stage of processing, a &lt;code class=&quot;highlighter-rouge&quot;&gt;CE&lt;/code&gt; signal must be produced,
together with the output data for that stage.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The &lt;code class=&quot;highlighter-rouge&quot;&gt;CE&lt;/code&gt; signal &lt;em&gt;must&lt;/em&gt; be initialized to zero.  Further, if any reset is
to be used, the &lt;code class=&quot;highlighter-rouge&quot;&gt;CE&lt;/code&gt; &lt;em&gt;must&lt;/em&gt; be set to zero on any reset.  (The data is a
don’t care on reset, but the &lt;code class=&quot;highlighter-rouge&quot;&gt;CE&lt;/code&gt; line &lt;em&gt;must&lt;/em&gt; be set to zero.)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Nothing is allowed to change &lt;em&gt;except&lt;/em&gt; on a &lt;code class=&quot;highlighter-rouge&quot;&gt;CE&lt;/code&gt; signal.  Hence, the only
time the incoming data is referenced is when &lt;code class=&quot;highlighter-rouge&quot;&gt;i_ce&lt;/code&gt; (the input &lt;code class=&quot;highlighter-rouge&quot;&gt;CE&lt;/code&gt; line
to a pipeline stage) is high.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Finally, every piece of logic must be ready, at all times, for a new value
to enter into the pipeline.  This particular pipeline strategy cannot handle
stalls.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;A trace of this type of logic might look like Fig 4.&lt;/p&gt;

&lt;table style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 4: Pipelining with a traveling CE&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/pipeline-traveling-ce.svg&quot; alt=&quot;Pipelining with a traveling CE&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;In Verilog, the approach looks like:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;initial	o_ce = 1&#39;b0;
always @(posedge i_clk)
	if (i_reset)
		o_ce &amp;lt;= 1&#39;b0;
	else
		o_ce &amp;lt;= i_ce;
always @(posedge i_clk)
	if (i_ce)
		o_output &amp;lt;= ... // some function of i_input;
	// else *NOTHING*.  Nothing is allowed to change except on
	// a reset or an i_ce&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This approach works very well when the pipeline can be separated into stages
that take no more than a single input valid signal.  Likewise, it works well
when none
of the stages depends upon any feedback from future results.  In other words,
if nothing ever needs to wait, then this approach to pipelining works fairly
well.&lt;/p&gt;

&lt;p&gt;Applications of this pipelining approach include
&lt;a href=&quot;https://en.wikipedia.org/wiki/Multiplication_algorithm&quot;&gt;logic multiplies&lt;/a&gt;,
&lt;a href=&quot;https://en.wikipedia.org/wiki/Fourier_transform&quot;&gt;Fourier transform&lt;/a&gt;
processing (&lt;a href=&quot;https://github.com/ZipCPU/dblclockfft&quot;&gt;example&lt;/a&gt;),
video processing, gear-boxes, and more.  Indeed, we used this approach
within our &lt;a href=&quot;https://github.com/ZipCPU/dbgbus/blob/master/hexbus/rtl/hbbus.v&quot;&gt;hexbus debugging
bus&lt;/a&gt;
to hook the input processing chain together.  You may notice, however, that
this approach didn’t work on the output processing chain.  The problem
there was that the &lt;a href=&quot;https://en.wikipedia.org/wiki/Universal_asynchronous_receiver/transmitter&quot;&gt;UART&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/wbuart32/blob/master/rtl/txuartlite.v&quot;&gt;transmitter&lt;/a&gt;
took longer than a single clock to transmit a character, and so another
pipeline signaling approach was needed–one that allowed the end of the
pipeline to control the rate of the pipeline.&lt;/p&gt;

&lt;h2 id=&quot;the-simple-handshake&quot;&gt;The simple handshake&lt;/h2&gt;

&lt;p&gt;The biggest problem with the travelling CE approach to pipelining is
that there’s no way to handle the case where the listener isn’t ready.  To
use a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Universal_asynchronous_receiver/transmitter&quot;&gt;UART&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/wbuart32/blob/master/rtl/txuartlite.v&quot;&gt;transmitter&lt;/a&gt;
as an example, you can create a pipeline to fill the
&lt;a href=&quot;https://github.com/ZipCPU/wbuart32/blob/master/rtl/txuartlite.v&quot;&gt;transmitter&lt;/a&gt;,
but what do you do when the
&lt;a href=&quot;https://github.com/ZipCPU/wbuart32/blob/master/rtl/txuartlite.v&quot;&gt;transmitter&lt;/a&gt;
is busy?  This requires a simple
handshake approach, one that I will describe here in this section.&lt;/p&gt;

&lt;p&gt;The basic hand shake relies on a pair of signals–one from the current
device and another from the next one in the pipeline.  We’ll call these
signals &lt;code class=&quot;highlighter-rouge&quot;&gt;STB&lt;/code&gt; (or valid) and &lt;code class=&quot;highlighter-rouge&quot;&gt;BUSY&lt;/code&gt;, although the wires go by a variety of
other names depending upon the interface.  Fig 5 shows a simple pipeline,
having only two stages, with the handshaking signals working through it.&lt;/p&gt;

&lt;table style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 5: Block diagram of a simple handshake&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/pipeline-blocks-handshake.svg&quot; alt=&quot;A simple handshake pipeline signal&quot; width=&quot;380&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;The basic rules associated with the simple handshake are:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;A transaction takes place any time the &lt;code class=&quot;highlighter-rouge&quot;&gt;STB&lt;/code&gt; line is true and the
&lt;code class=&quot;highlighter-rouge&quot;&gt;BUSY&lt;/code&gt; line is false.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The receiving pipeline stage needs to be careful &lt;em&gt;not&lt;/em&gt; to ever lower the
&lt;code class=&quot;highlighter-rouge&quot;&gt;BUSY&lt;/code&gt; line, unless it is ready to receive data on the next clock.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The &lt;code class=&quot;highlighter-rouge&quot;&gt;STB&lt;/code&gt; line should be raised any time data is ready to send. 
The data source &lt;em&gt;must not&lt;/em&gt; wait for &lt;code class=&quot;highlighter-rouge&quot;&gt;BUSY&lt;/code&gt; to be false before raising
the &lt;code class=&quot;highlighter-rouge&quot;&gt;STB&lt;/code&gt; line.&lt;/p&gt;

    &lt;p&gt;The issue with not waiting for &lt;code class=&quot;highlighter-rouge&quot;&gt;BUSY&lt;/code&gt; to be true has to do with avoiding
deadlocks.  By setting &lt;code class=&quot;highlighter-rouge&quot;&gt;STB&lt;/code&gt; independent of &lt;code class=&quot;highlighter-rouge&quot;&gt;BUSY&lt;/code&gt;, the dependence between
the two is removed.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Likewise, the &lt;code class=&quot;highlighter-rouge&quot;&gt;BUSY&lt;/code&gt; line &lt;em&gt;should&lt;/em&gt; &lt;em&gt;idle&lt;/em&gt; in the not busy condition.&lt;/p&gt;

    &lt;p&gt;While many AXI demonstration implementations idle with
the &lt;code class=&quot;highlighter-rouge&quot;&gt;AXI_*READY&lt;/code&gt; line false (their equivalent of a &lt;code class=&quot;highlighter-rouge&quot;&gt;BUSY&lt;/code&gt; line being true),
this will only slow down your interaction by an unnecessary clock. 
Remember, one of the goals of pipelining logic is speed.  Making &lt;code class=&quot;highlighter-rouge&quot;&gt;BUSY&lt;/code&gt; true
when it doesn’t need to be will slow down the pipeline.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Once &lt;code class=&quot;highlighter-rouge&quot;&gt;STB&lt;/code&gt; is raised, the data being transferred cnanot be changed until
the clock after the transaction takes place.  That is, use &lt;code class=&quot;highlighter-rouge&quot;&gt;(STB)&amp;amp;&amp;amp;(!BUSY)&lt;/code&gt;
to determine if things need to change.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The data lines are in a “don’t care” condition any time &lt;code class=&quot;highlighter-rouge&quot;&gt;STB&lt;/code&gt; is false.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The &lt;code class=&quot;highlighter-rouge&quot;&gt;STB&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;BUSY&lt;/code&gt; lines must be initialized to zero.  If you have a need
for a reset or a clear pipeline operation, these signals need to be returned
to zero on either of these signals.&lt;/p&gt;

    &lt;p&gt;Since the data lines will be placed into a “don’t care” condition, they
don’t need to have any value on reset.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;If you look at this handshake from the standpoint of the logic involved,
a trace would look like Fig 6.&lt;/p&gt;

&lt;table style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 6: A simple handshake pipeline signal&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/pipeline-handshake.svg&quot; alt=&quot;A simple handshake pipeline signal&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Pay close attention to the “(Transaction)” line.  This line is the key
to understanding the trace.  It is formed from the combinational
result of &lt;code class=&quot;highlighter-rouge&quot;&gt;(STB)&amp;amp;&amp;amp;(!BUSY)&lt;/code&gt;.  This line is the analog of the &lt;code class=&quot;highlighter-rouge&quot;&gt;CE&lt;/code&gt; line in the
traveling &lt;code class=&quot;highlighter-rouge&quot;&gt;CE&lt;/code&gt; approach from before.  When the (Transaction) line is high, the
data is valid (since &lt;code class=&quot;highlighter-rouge&quot;&gt;STB&lt;/code&gt; was high), and the processing can step forward one
further step.&lt;/p&gt;

&lt;p&gt;I’ve used this approach many times when building controllers for slow
hardware.  In those cases, the receiver generally looks like:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;initial o_busy = 1&#39;b0;
always @(posedge i_clk)
	if (i_reset)
	begin
		o_busy &amp;lt;= 1&#39;b0;
		state &amp;lt;= IDLE_STATE;
	end if ((i_ce)&amp;amp;&amp;amp;(!o_busy)) begin
		// We just accepted an input sample into this controller
		// Turn o_busy on, and start processing this input.
		o_busy &amp;lt;= 1&#39;b1;
		state &amp;lt;= START_STATE;
		data &amp;lt;= i_data;
		// etc.
	end else case(state)
		// A state machine is used to handle an interaction
		// with the hardware now that a request has been made.
		// ....
		FINAL_STATE: begin
			o_busy &amp;lt;= 1&#39;b0;
			state  &amp;lt;= IDLE_STATE;
			// ... other logic
			end
		// default:
		endcase&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;As you might have guessed by now, my
&lt;a href=&quot;https://en.wikipedia.org/wiki/Universal_asynchronous_receiver/transmitter&quot;&gt;UART&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/wbuart32/blob/master/rtl/txuartlite.v&quot;&gt;transmitter&lt;/a&gt;
uses this approach.  You can also find several examples of interacting
with such a transmitter among the &lt;a href=&quot;https://github.com/ZipCPU/wbuart32/tree/master/bench/verilog&quot;&gt;bench
tests&lt;/a&gt; for the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Universal_asynchronous_receiver/transmitter&quot;&gt;UART&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/wbuart32/blob/master/rtl/txuartlite.v&quot;&gt;transmitter&lt;/a&gt;.
Perhaps closer to home, you may find this approach to pipelining used
by the transmit half of the &lt;a href=&quot;https://github.com/ZipCPU/dbgbus/blob/master/hexbus/rtl/hbbus.v&quot;&gt;hexbus
module&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The problem with the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Universal_asynchronous_receiver/transmitter&quot;&gt;UART&lt;/a&gt;
example is that it doesn’t really capture the logic required in any mid-point
pipeline stage, only the final stage.&lt;/p&gt;

&lt;p&gt;At the midpoint, there are two choices for how to handle things.  You can
either register the &lt;code class=&quot;highlighter-rouge&quot;&gt;BUSY&lt;/code&gt; signal and suffer a pipeline stall in between
any two transactions, or you can create a &lt;code class=&quot;highlighter-rouge&quot;&gt;BUSY&lt;/code&gt; signal using combinational
logic.  The combinational &lt;code class=&quot;highlighter-rouge&quot;&gt;BUSY&lt;/code&gt; (shown in the example code below) has the
problem that the time required for &lt;code class=&quot;highlighter-rouge&quot;&gt;BUSY&lt;/code&gt; determination accumulates as you
move backwards through the pipeline.  This can slow down your logic, so
when this combinational path approaches your clock period it becomes
undesirable.  On the other hand, if it’s a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Universal_asynchronous_receiver/transmitter&quot;&gt;UART&lt;/a&gt;
or any other slow peripheral at the end of the logic pipeline
(&lt;a href=&quot;https://opencores.org/project,qspiflash&quot;&gt;flash&lt;/a&gt;,
&lt;a href=&quot;https://github.com/ZipCPU/wbicapetwo&quot;&gt;ICAPE2&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/openarty/blob/master/rtl/wboled.v&quot;&gt;OLEDrgb&lt;/a&gt;, etc),
then you might not care about any clocks lost in the &lt;code class=&quot;highlighter-rouge&quot;&gt;BUSY&lt;/code&gt; signal calculation.&lt;/p&gt;

&lt;p&gt;All that is to say, here’s an example of how to build a pipeline component
with this handshake as both the input and the output to the component:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;initial	r_busy = 1&#39;b0;
initial	o_stb  = 1&#39;b0;
always @(posedge i_clk)
	if (i_reset)
	begin
		// busy and stb must be cleared on any reset
		// Data is a don&#39;t care
		r_busy &amp;lt;= 1&#39;b0;
		o_stb  &amp;lt;= 1&#39;b0;
	end if (!o_busy)
	begin
		if (i_stb)
		begin
			// An incoming transaction has just taken place
			r_busy &amp;lt;= 1&#39;b1;
			// begin your logic here ...
			//
		end
		// else we remain in an idle condition
	end else if ((o_stb)&amp;amp;&amp;amp;(!i_busy))
	begin
		// An output transaction just took place
		r_busy &amp;lt;= 1&#39;b0;
		o_stb  &amp;lt;= 1&#39;b0;
	end else if (!o_stb) begin
		// o_busy is true, so you can perform any necessary logic here
		if (your logic is complete)
			o_stb &amp;lt;= 1&#39;b1;
	end // else we have to wait for our output data to be accepted
	// by the next stage before we can move on.&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The final step is to set the output busy line, &lt;code class=&quot;highlighter-rouge&quot;&gt;o_busy&lt;/code&gt;.  We use &lt;code class=&quot;highlighter-rouge&quot;&gt;r_busy&lt;/code&gt;
to record any time our own component is busy.  The final busy is set up so
that no empty delay cycles will be necessary, even though it requires some
combinational logic (i.e. borrowed clock time) to do.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;assign	o_busy = (i_busy)&amp;amp;&amp;amp;(o_stb)||(r_busy);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This example is easily modified to to remove the combinational accumulation
by simply setting the &lt;code class=&quot;highlighter-rouge&quot;&gt;o_busy&lt;/code&gt; line via the &lt;code class=&quot;highlighter-rouge&quot;&gt;r_busy&lt;/code&gt; logic.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;assign	o_busy = r_busy;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This will create an idle cycle between pipeline stages, but it will also fix
the combinational time accumulation problem.&lt;/p&gt;

&lt;p&gt;Examples of this type of handshaking abound.  For example, the
&lt;a href=&quot;https://opencores.org/cdn/downloads/wbspec_b4.pdf&quot;&gt;Wishbone bus&lt;/a&gt;
has a form of interaction that uses this form of handshaking, although it
changes the signal names a touch.  While the &lt;code class=&quot;highlighter-rouge&quot;&gt;STB&lt;/code&gt; name remains the same, the
&lt;a href=&quot;https://opencores.org/cdn/downloads/wbspec_b4.pdf&quot;&gt;Wishbone bus&lt;/a&gt;
uses &lt;code class=&quot;highlighter-rouge&quot;&gt;STALL&lt;/code&gt; as the name for its &lt;code class=&quot;highlighter-rouge&quot;&gt;BUSY&lt;/code&gt; line.  Likewise, the
&lt;a href=&quot;http://www.gstitt.ece.ufl.edu/courses/fall15/eel4720_5721/labs/refs/AXI4_specification.pdf&quot;&gt;AXI bus specification&lt;/a&gt;
uses this form of handshaking.  Indeed, it uses this form across
&lt;em&gt;five separate&lt;/em&gt; hand-shaking channels.  AXI uses the terms
&lt;code class=&quot;highlighter-rouge&quot;&gt;*AXI_*VALID&lt;/code&gt; for &lt;code class=&quot;highlighter-rouge&quot;&gt;STB&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;*AXI_*READY&lt;/code&gt; instead of &lt;code class=&quot;highlighter-rouge&quot;&gt;!BUSY&lt;/code&gt;.
We’ve also already discussed the transmit half, i.e. return processing
chain, of the main &lt;a href=&quot;https://github.com/ZipCPU/dbgbus&quot;&gt;dbgbus&lt;/a&gt; module as
another example.&lt;/p&gt;

&lt;h2 id=&quot;the-buffered-handshake&quot;&gt;The buffered handshake&lt;/h2&gt;

&lt;p&gt;If you are trying to go for high speed, for example if you wished to run the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt; at 200MHz instead of its more
natural 100MHz speed, then the simple handshake method can suffer from severe
timing problems as the pipeline grows in length.  This problem is twofold.
First, any time a &lt;code class=&quot;highlighter-rouge&quot;&gt;BUSY&lt;/code&gt; signal needs to pass combinationally from the &lt;code class=&quot;highlighter-rouge&quot;&gt;N&lt;/code&gt;th
stage back to the first stage,
the time required increases at each stage.  This can slow down your logic.
The logic chain line can cross large sections of digital logic, incurring
timing delays from one end of the chip to another, while the logic elements
along the way that this signal needs to pass through just contribute to
the pain.  Second, while it is
possible to slow the &lt;code class=&quot;highlighter-rouge&quot;&gt;BUSY&lt;/code&gt; signals down, by inserting a stall between
pipeline stages, this can slow the pipeline down by a factor of two.&lt;/p&gt;

&lt;p&gt;Another approach is needed.&lt;/p&gt;

&lt;p&gt;The way to mitigate this problem to set the &lt;code class=&quot;highlighter-rouge&quot;&gt;BUSY&lt;/code&gt; value with a clocked
register.  This means that when a subsequent pipeline stage isn’t ready
(a pipeline stall), it will cost a clock until the &lt;code class=&quot;highlighter-rouge&quot;&gt;BUSY&lt;/code&gt; line can be true.
To avoid losing any data, the data that arrived before the &lt;code class=&quot;highlighter-rouge&quot;&gt;BUSY&lt;/code&gt; signal
could go high will need to be stored in a buffer.&lt;/p&gt;

&lt;p&gt;For this reason, I’m going to call this a “buffered handshake”.&lt;/p&gt;

&lt;p&gt;The “buffered handshake” is going to use the exact same signals as
we showed in Fig 5 above.  Further, although Fig 6 shows what the signaling
might look like, it doesn’t capture the concept of the &lt;code class=&quot;highlighter-rouge&quot;&gt;BUSY&lt;/code&gt; signal
propagating from the end to the beginning, with the data bunching up in the
middle like an accordion.&lt;/p&gt;

&lt;p&gt;Perhaps some pictures would help this explanation.  Consider a four stage
pipeline, such as the one shown in Fig. 7.&lt;/p&gt;

&lt;table style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 7: A four stage pipeline using a buffered handshake&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/pipeline-blocks-dbl-1.svg&quot; alt=&quot;Block diagram of a 4-stage pipeline using a buffered handshake.  Sequence #1&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;This figure shows four separate pipeline stages, from the data source or
generator, to the ultimate consumer of the data.  The pipeline in this
figure is currently full, with each stage having a payload value within it.
As a result, each of the &lt;code class=&quot;highlighter-rouge&quot;&gt;STB&lt;/code&gt; signals is valid going into the next block.&lt;/p&gt;

&lt;p&gt;Fig 8 shows what happens if the final stage in this pipeline stalls on the
next clock.&lt;/p&gt;

&lt;table style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 8: Final pipeline stage stalls&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/pipeline-blocks-dbl-2.svg&quot; alt=&quot;Block diagram of a 4-stage pipeline using a buffered handshake.  Sequence #2--stall starts&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Were this the simple handshake we discussed above, all of the &lt;code class=&quot;highlighter-rouge&quot;&gt;BUSY&lt;/code&gt; flags
would go true at once.&lt;/p&gt;

&lt;p&gt;In the case of the buffered handshake, only one &lt;code class=&quot;highlighter-rouge&quot;&gt;BUSY&lt;/code&gt; flag becomes true.&lt;/p&gt;

&lt;p&gt;This means that &lt;code class=&quot;highlighter-rouge&quot;&gt;Stage[2]&lt;/code&gt; hasn’t had an opportunity to set it’s &lt;code class=&quot;highlighter-rouge&quot;&gt;BUSY&lt;/code&gt; flag.
It has no choice but to ingest &lt;code class=&quot;highlighter-rouge&quot;&gt;payload #4&lt;/code&gt; or risk dropping it (this would
be bad).  Therefore, &lt;code class=&quot;highlighter-rouge&quot;&gt;Stage[2]&lt;/code&gt; has a buffer which it uses to store
&lt;code class=&quot;highlighter-rouge&quot;&gt;payload #4&lt;/code&gt; on the next clock, as shown in Fig 9.&lt;/p&gt;

&lt;table style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 9: The stall propagates&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/pipeline-blocks-dbl-3.svg&quot; alt=&quot;Block diagram of a 4-stage pipeline using a buffered handshake.  Sequence #3--stall propagates&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;This leaves &lt;code class=&quot;highlighter-rouge&quot;&gt;Stage[1]&lt;/code&gt; in the position &lt;code class=&quot;highlighter-rouge&quot;&gt;Stage[2]&lt;/code&gt; was in on the last clock.
It cannot push &lt;code class=&quot;highlighter-rouge&quot;&gt;payload #5&lt;/code&gt; forward, and yet it hasn’t had the opportunity to
set its &lt;code class=&quot;highlighter-rouge&quot;&gt;BUSY&lt;/code&gt; line.  It &lt;em&gt;must&lt;/em&gt; accept &lt;code class=&quot;highlighter-rouge&quot;&gt;payload #6&lt;/code&gt;.  It does so by placing it
into its buffer.&lt;/p&gt;

&lt;p&gt;If at this time the data sink now becomes available, it will
lower its busy line, yielding an image looking like Fig 10.&lt;/p&gt;

&lt;table style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 10: The pipeline starts to clear&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/pipeline-blocks-dbl-4.svg&quot; alt=&quot;Block diagram of a 4-stage pipeline using a buffered handshake.  Sequence #4--initial stall clears&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;As this pipeline clears, &lt;code class=&quot;highlighter-rouge&quot;&gt;Stage[2]&lt;/code&gt; transmits &lt;code class=&quot;highlighter-rouge&quot;&gt;payload #3&lt;/code&gt; and clears its
&lt;code class=&quot;highlighter-rouge&quot;&gt;BUSY&lt;/code&gt; flag.  It’s now ready to transmit &lt;code class=&quot;highlighter-rouge&quot;&gt;payload #4&lt;/code&gt; on the next clock,
as well as to received &lt;code class=&quot;highlighter-rouge&quot;&gt;payload #5&lt;/code&gt; on that same clock, as in Fig 11.&lt;/p&gt;

&lt;table style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 11: The pipeline continues to clear&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/pipeline-blocks-dbl-5.svg&quot; alt=&quot;Block diagram of a 4-stage pipeline using a buffered handshake.  Sequence #5--Continues to clear&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;At this point, &lt;code class=&quot;highlighter-rouge&quot;&gt;Stage[1]&lt;/code&gt; can now flush its buffer and the pipeline is clear
again as in Fig 12.&lt;/p&gt;

&lt;table style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 12: The pipeline finally clears&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/pipeline-blocks-dbl-6.svg&quot; alt=&quot;Block diagram of a 4-stage pipeline using a buffered handshake.  Sequence #6--Stall has cleared&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;You may notice that this pipeline uses the same &lt;code class=&quot;highlighter-rouge&quot;&gt;STB&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;BUSY&lt;/code&gt; signals
that we’ve used for the simple handshaking approach to pipelining.  The
difference with this approach is that the &lt;code class=&quot;highlighter-rouge&quot;&gt;BUSY&lt;/code&gt; signal is registered,
and must wait on a clock to propagate.&lt;/p&gt;

&lt;p&gt;The rules defining this behavior are very similar to those for the simple
handshake above:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;A data transfer takes place any time &lt;code class=&quot;highlighter-rouge&quot;&gt;(STB)&amp;amp;&amp;amp;(!BUSY)&lt;/code&gt; whether the given
pipeline stage is ready for it or not.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;If the output &lt;code class=&quot;highlighter-rouge&quot;&gt;(STB)&amp;amp;&amp;amp;(BUSY)&lt;/code&gt; are true, but the input &lt;code class=&quot;highlighter-rouge&quot;&gt;(STB)&amp;amp;&amp;amp;(!BUSY)&lt;/code&gt; is
true, the data must be stored into a buffer.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;If &lt;code class=&quot;highlighter-rouge&quot;&gt;BUSY&lt;/code&gt; is true on the input, but &lt;code class=&quot;highlighter-rouge&quot;&gt;BUSY&lt;/code&gt; isn’t true on the output, then
the buffer’s values can be released and sent forwards and we can set
&lt;code class=&quot;highlighter-rouge&quot;&gt;BUSY&lt;/code&gt; for the incoming data to be false.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;So, now that you know the concept, how shall we set up the logic necessary
to implement this?  We’ll look at how to design the logic for one stage
in this pipeline only, since the other stages will use similar logic.&lt;/p&gt;

&lt;p&gt;The following logic is rather confusing when it comes to naming, since both
input and output ports share names.  I’ll use the &lt;code class=&quot;highlighter-rouge&quot;&gt;i_&lt;/code&gt; prefix to reference
a wire coming into a stage, whether the &lt;code class=&quot;highlighter-rouge&quot;&gt;i_stb&lt;/code&gt; line coming from the previous
stage or the &lt;code class=&quot;highlighter-rouge&quot;&gt;i_busy&lt;/code&gt; line coming from the subsequent stage.  In a similar
manner, I’ll use the &lt;code class=&quot;highlighter-rouge&quot;&gt;o_&lt;/code&gt; prefix to reference logic leaving this stage,
whether the &lt;code class=&quot;highlighter-rouge&quot;&gt;o_stb&lt;/code&gt; sent to the subsequent pipeline stage to indicate that
this stage has something to pass on, or the &lt;code class=&quot;highlighter-rouge&quot;&gt;o_busy&lt;/code&gt; line to send to the
previous stage to indicate that this stage is now busy.  We’ll also use the
&lt;code class=&quot;highlighter-rouge&quot;&gt;r_&lt;/code&gt; prefix to reference values within our register, both &lt;code class=&quot;highlighter-rouge&quot;&gt;r_stb&lt;/code&gt; to indicate
that something valid is in it as well as &lt;code class=&quot;highlighter-rouge&quot;&gt;r_data&lt;/code&gt; to indicate the value of
what’s in it.&lt;/p&gt;

&lt;p&gt;The first requirement is that the pipeline be empty on any reset.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;initial	r_stb  = 1&#39;b0;
initial	o_stb  = 1&#39;b0;
initial	o_busy = 1&#39;b0;
always @(posedge i_clk)
begin
	if (i_reset)
	begin
		r_stb = 1&#39;b0;
		o_stb = 1&#39;b0;
		o_busy = 1&#39;b0;
		// Data is a don&#39;t care
	end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Next, let’s deal with the case where the next or subsequent stage isn’t &lt;code class=&quot;highlighter-rouge&quot;&gt;BUSY&lt;/code&gt;.
This should be the normal pipeline flow case.
Under normal flow, we’ll want to copy the input strobe &lt;code class=&quot;highlighter-rouge&quot;&gt;i_stb&lt;/code&gt; to the output
strobe, &lt;code class=&quot;highlighter-rouge&quot;&gt;o_stb&lt;/code&gt;.  Further, some data may need to be applied to &lt;code class=&quot;highlighter-rouge&quot;&gt;i_data&lt;/code&gt; to
create the output &lt;code class=&quot;highlighter-rouge&quot;&gt;o_data&lt;/code&gt;.  We’ll use the notation &lt;code class=&quot;highlighter-rouge&quot;&gt;logic(i_data)&lt;/code&gt; to
indicate this.  The &lt;code class=&quot;highlighter-rouge&quot;&gt;logic()&lt;/code&gt; function is not intended to be valid verilog,
but rather to convey the concept of what’s taking place.&lt;/p&gt;

&lt;p&gt;If, on the other hand, some data was in the buffer, then &lt;code class=&quot;highlighter-rouge&quot;&gt;o_busy&lt;/code&gt; must
also have been true on this clock.  &lt;code class=&quot;highlighter-rouge&quot;&gt;o_stb&lt;/code&gt; must also be true and &lt;code class=&quot;highlighter-rouge&quot;&gt;o_data&lt;/code&gt;
valid.  Since &lt;code class=&quot;highlighter-rouge&quot;&gt;(o_stb)&amp;amp;&amp;amp;(!i_busy)&lt;/code&gt;, a transaction has taken place and &lt;code class=&quot;highlighter-rouge&quot;&gt;r_stb&lt;/code&gt;
can be copied to &lt;code class=&quot;highlighter-rouge&quot;&gt;o_stb&lt;/code&gt;, and &lt;code class=&quot;highlighter-rouge&quot;&gt;r_data&lt;/code&gt; to &lt;code class=&quot;highlighter-rouge&quot;&gt;o_data&lt;/code&gt;–flushing our buffer.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;// Always block continued ... (i_reset) is false
	else if (!i_busy) // the next stage is not busy
	begin
		if (!r_stb)
		begin
			// Nothing is in the buffer, so send the input
			// directly to the output.
			o_stb   &amp;lt;= i_stb;

			// This logic() function is arbitrary, and specific
			// the what this stage is supposed to do.
			o_data  &amp;lt;= logic(i_data);
		end else begin
			// o_busy is true and something is in our buffer.
			// Flush the buffer to the output port.
			o_stb  &amp;lt;= 1&#39;b1;
			o_data &amp;lt;= r_data; // This is the buffered data

			// We can ignore the input in this case, since
			// we&#39;ll only be here if `o_busy` is also true.
		end

		// We can also clear any stall condition
		o_busy  &amp;lt;= 1&#39;b0;

		// And declare the register to be empty.
		r_stb   &amp;lt;= 1&#39;b0;
	end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The next case is the case where &lt;code class=&quot;highlighter-rouge&quot;&gt;o_stb&lt;/code&gt; is false (and &lt;code class=&quot;highlighter-rouge&quot;&gt;i_busy&lt;/code&gt; is true).  This
case wasn’t shown in
the diagram series above.  It’s basically the case where a pipeline stage
has no data payload within it at all.  In that case, we’ll keep &lt;code class=&quot;highlighter-rouge&quot;&gt;o_busy&lt;/code&gt; false,
we’ll accept any data, and then set the output &lt;code class=&quot;highlighter-rouge&quot;&gt;o_stb&lt;/code&gt; value to indicate to
the next stage that we have something ready to be read.  Who knows, the
&lt;code class=&quot;highlighter-rouge&quot;&gt;i_busy&lt;/code&gt; flag might be de–asserted on the next clock and we might not need
to stall.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;// Always block continued ... (i_reset) is false, (i_busy) is true
//
	else if (!o_stb)
	begin
		o_stb  &amp;lt;= i_stb;
		o_busy &amp;lt;= 1&#39;b0;

		// Keep the buffer empty
		r_stb &amp;lt;= 1&#39;b0;

		// Apply the logic to the input data, and set the output data
		o_data &amp;lt;= logic(i_data);
	end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The last case to deal with is the case where &lt;code class=&quot;highlighter-rouge&quot;&gt;i_busy&lt;/code&gt; is true, &lt;code class=&quot;highlighter-rouge&quot;&gt;o_stb&lt;/code&gt;
indicates we have a payload loaded, and we now need to store our input into
our buffer.  Hence, we’ll set &lt;code class=&quot;highlighter-rouge&quot;&gt;r_stb&lt;/code&gt; and mark this stage of the pipeline
as &lt;code class=&quot;highlighter-rouge&quot;&gt;BUSY&lt;/code&gt; with &lt;code class=&quot;highlighter-rouge&quot;&gt;o_busy&lt;/code&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;// Always block continued ... (i_reset) is false, (i_busy) and (o_stb) are both
// true.
	else if ((i_stb)&amp;amp;&amp;amp;(!o_busy))
	begin
		// If the next stage *is* busy, though, and we haven&#39;t
		// stalled yet, then we need to accept the requested value
		// from the input.  We&#39;ll place it into a termporary
		// location.
		r_stb  &amp;lt;= (i_stb)&amp;amp;&amp;amp;(o_stb);
		o_busy &amp;lt;= (i_stb)&amp;amp;&amp;amp;(o_stb);
		if (!o_stb)
			o_data &amp;lt;= i_data;
	end
end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;That ends our giant always block, but we still have one value that we haven’t
set: &lt;code class=&quot;highlighter-rouge&quot;&gt;r_data&lt;/code&gt;.  &lt;code class=&quot;highlighter-rouge&quot;&gt;r_data&lt;/code&gt; needs to be set based upon the input data, &lt;code class=&quot;highlighter-rouge&quot;&gt;i_data&lt;/code&gt;.
If you need to apply a &lt;code class=&quot;highlighter-rouge&quot;&gt;logic()&lt;/code&gt; transform to &lt;code class=&quot;highlighter-rouge&quot;&gt;i_data&lt;/code&gt;, you can do that here to
&lt;code class=&quot;highlighter-rouge&quot;&gt;r_data&lt;/code&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	if (!o_busy)
		r_data &amp;lt;= logic(i_data);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;That was a lot harder than the simple handshake, now, wasn’t it?&lt;/p&gt;

&lt;p&gt;Be aware, the code above hasn’t been tested.  Although I copied it from a
(working) data width bus translation module, I found some bugs and made some
changes along the way.  Hence, if you try this and find any bugs, then please
please write me at the e-mail address in the postscript below.&lt;/p&gt;

&lt;p&gt;You may also notice that &lt;code class=&quot;highlighter-rouge&quot;&gt;r_stb&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;o_busy&lt;/code&gt; above are the same signal.  I’ve
kept them separate for conceptual understanding, but these two can be
combined into a single signal.&lt;/p&gt;

&lt;p&gt;The overall approach, though, is a clear example of how
&lt;a href=&quot;https://en.wikipedia.org/wiki/Logic_block&quot;&gt;logic resources&lt;/a&gt;
can be traded
to achieve pipeline speed and throughput.  Indeed, it is only one of many
examples, but its a worthwhile lesson to take away from this exercise. 
While I haven’t done so, I think that if you &lt;a href=&quot;/blog/2017/06/12/minimizing-luts.html&quot;&gt;count the
LUTs&lt;/a&gt;
used by this routine, you’ll find that all this extra logic has at least
doubled the number of
&lt;a href=&quot;https://en.wikipedia.org/wiki/Logic_block&quot;&gt;LUTs&lt;/a&gt; required.&lt;/p&gt;

&lt;p&gt;Although this is a useful approach to pipelining, it may easily be more
logic than your problem requires.  Indeed, very few of my own routines
have ever needed to use this buffered handshaking approach.  The routines
that have needed to use it tend to be &lt;a href=&quot;/zipcpu/2017/05/29/simple-wishbone.html&quot;&gt;wishbone
peripherals&lt;/a&gt;
with complex logic within them–such as my &lt;a href=&quot;https://github.com/ZipCPU/xulalx25soc/blob/master/rtl/wbsdram.v&quot;&gt;SDRAM
controller&lt;/a&gt;,
my attempt at a &lt;a href=&quot;https://opencores.org/project,wbddr3&quot;&gt;DDR3 SDRAM controller&lt;/a&gt;,
or a wishbone bus width expansion module that I put together for an
HDMI video project.&lt;/p&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;We’ve now walked through several examples of the signaling associated with
pipeline logic.  These examples have gone from the simple global &lt;code class=&quot;highlighter-rouge&quot;&gt;CE&lt;/code&gt; approach,
all the way to a buffered handshake approach.  Which type of pipeline signaling
you use will be specific to your problem and your needs.  However, these
approaches should handle most of the problems you might have.&lt;/p&gt;

&lt;p&gt;Let’s come back to this topic of pipelining at least one more time, though,
and look at how the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt; handles
its pipeline signaling within the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU proper&lt;/a&gt;.
This is a more complicated environment, as lots of events can stall the 
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
along the way.  Indeed, handling the pipeline needs of a
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
can be quite a challenge.&lt;/p&gt;

&lt;p&gt;That will then be our next post on this topic.&lt;/p&gt;

&lt;hr /&gt;&lt;p&gt;&lt;em&gt;For the time is come that judgment must begin at the house of God: and if it first begin at us, what shall the end be of them that obey not the gospel of God? (1Pet 4:17)&lt;/em&gt;</description>
        <pubDate>Mon, 14 Aug 2017 00:00:00 -0400</pubDate>
        <link>http://zipcpu.com/blog/2017/08/14/strategies-for-pipelining.html</link>
        <guid isPermaLink="true">http://zipcpu.com/blog/2017/08/14/strategies-for-pipelining.html</guid>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>What would cause you to lie?</title>
        <description>&lt;p&gt;Integrity should not need to be discussed on any engineering forum.  The
honesty of every engineer should be assumed.  That this is not the case, and
that this needs to be discussed is unfortunate.  It is, however reality.&lt;/p&gt;

&lt;p&gt;Let’s start the discussion with a quick survey.  You don’t need to answer,
but just think these questions through:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Would you &lt;em&gt;lie&lt;/em&gt; to get a good grade in school?&lt;/p&gt;

    &lt;p&gt;Imagine you are in a science class.  You’ve struggled to learn the material,
but you are sitting next to someone who has done very well in the class so
far.  You realize you can see, and therefore copy his answers.&lt;/p&gt;

    &lt;p&gt;Your grade is poor, his is wonderful.  If you copied from him, you would get
a much better grade.&lt;/p&gt;

    &lt;p&gt;Would you do it?&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Would you ever get someone else to do the work on your project, and then
&lt;em&gt;lie&lt;/em&gt; when turning it in about who had done it?&lt;/p&gt;

    &lt;p&gt;Imagine you are in an engineering class.  It’s the end of the semester.
The final project is due in a week or so, and your project doesn’t work.  You
realize that, given the state of your project and what you know and
understand about the engineering you’ve been learning, that there is no
way you will be successful.&lt;/p&gt;

    &lt;p&gt;Would you be willing to ask a professional to do your work for you, to get
your design to work, so you could turn in a working design?&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Would you &lt;em&gt;lie&lt;/em&gt; to win an award?&lt;/p&gt;

    &lt;p&gt;Imagine you are a member of a competitive collegiate engineering team.&lt;/p&gt;

    &lt;p&gt;You can &lt;em&gt;lie&lt;/em&gt; to improve your chances of winning a world championship, but
you also realize that if you tell the truth you will never win.  Perhaps
you are only lying to other teams you are competing against–not even the
officials.&lt;/p&gt;

    &lt;p&gt;Would you do it?&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Would you &lt;em&gt;lie&lt;/em&gt; on a resume?&lt;/p&gt;

    &lt;p&gt;Imagine you are looking for a job.  As you look over your resume, you realize
you don’t really have the engineering experience necessary to qualify for
the job.  You’ve been out of work now, though, for 6+ months and you are
worried whether or not the bank will come and take your house.  You know
that without the experience you don’t have, you won’t get the job.&lt;/p&gt;

    &lt;p&gt;Would you be willing to &lt;em&gt;lie&lt;/em&gt;, and tell the hiring officer you had
experiences that you never had?&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Would you &lt;em&gt;lie&lt;/em&gt; to get a contract?&lt;/p&gt;

    &lt;p&gt;Imagine now that you are the engineering lead on a team bidding for a
multi-billion dollar contract.  If you win the contract, you will be
gainfully employed for many years to come.  If you lose the contract, you
and many others will likely lose your jobs.&lt;/p&gt;

    &lt;p&gt;Now, if I told you that you would win the contract if you &lt;em&gt;lied&lt;/em&gt;, and lose
the contract if you told the truth, would you &lt;em&gt;lie&lt;/em&gt;?&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;In a similar line to the last question, Would you &lt;em&gt;lie&lt;/em&gt; to keep a contract?
Would you lie to keep your contract funded?&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;These are very real questions.&lt;/p&gt;

&lt;p&gt;If you’ve never considered these sorts of questions before, you might wish to
take the time to do so now.&lt;/p&gt;

&lt;p&gt;Sadly, they are also questions that I think every engineer will encounter at
some point in his career.&lt;/p&gt;

&lt;p&gt;Sure, they start out simple and easy.  I mean, who cares if you cheat on an
exam?  The professor?  How long will he be a part of your life?  However, by
the time you get to the end of the list, you will find the livelihood’s of not
only yourself but many others as well suddenly depend upon your actions.&lt;/p&gt;

&lt;p&gt;So let me ask, under what condition would you be willing to &lt;em&gt;lie&lt;/em&gt;?&lt;/p&gt;

&lt;h2 id=&quot;the-reality-of-lies&quot;&gt;The Reality of Lies&lt;/h2&gt;

&lt;p&gt;History is filled with examples of people who have made the wrong decisions
when confronted by the question above.  Some end up disgraced, others end up in
prison.  These are the lucky ones.  They at least know they need to repent.
Those that don’t get caught end up believing that lying is beneficial.  They
are then drawn to nurse a wounded conscience and do it again.&lt;/p&gt;

&lt;p&gt;This leads to the sad reality: lie’s are addictive.  If you do it once, 
circumstances will command you to lie again and again.  If you start down
the path, you will quickly find yourself trapped within it.&lt;/p&gt;

&lt;p&gt;I would know, I’ve been there.  I was once trapped in my own web of lies and
deceit.  I once thought that lies were the easiest and sometimes the only way
to get out of my problems.&lt;/p&gt;

&lt;p&gt;I have since learned painfully, though, that if you lie once, you will be
&lt;em&gt;compelled&lt;/em&gt; to lie again and again.  (Prov 13:19)&lt;/p&gt;

&lt;p&gt;Eventually, lying will rule your life. (Prov 14:12)  At one time, it ruled
mine.&lt;/p&gt;

&lt;p&gt;I also know that Christ is still in the business of rescuing individuals
trapped by lies.  (Rom 6:16)  I know this personally because he rescued me.&lt;/p&gt;

&lt;p&gt;While this isn’t the main topic of this blog, and while I have many other
things I wish to discuss, integrity is sadly a topic that must come up from
time to time again.  Without integrity, sound engineering is impossible.&lt;/p&gt;
&lt;hr /&gt;&lt;p&gt;&lt;em&gt;Better is the poor that walketh in his integrity, than he that is perverse in his lips, and is a fool.&lt;/em&gt;</description>
        <pubDate>Sat, 12 Aug 2017 00:00:00 -0400</pubDate>
        <link>http://zipcpu.com/blog/2017/08/12/caused-to-lie.html</link>
        <guid isPermaLink="true">http://zipcpu.com/blog/2017/08/12/caused-to-lie.html</guid>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>A Simple ALU, drawn from the ZipCPU</title>
        <description>&lt;p&gt;Many digital logic design courses end with a discussion of how to build a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;.
The common lesson tends to focus on the &lt;a href=&quot;https://en.wikipedia.org/wiki/Arithmetic_logic_unit&quot;&gt;arithmetic logic unit
(ALU)&lt;/a&gt; as the work horse
within the center of the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Since &lt;a href=&quot;https://en.wikipedia.org/wiki/Arithmetic_logic_unit&quot;&gt;ALU&lt;/a&gt;’s
tend to be very simple, they are easy to look at and examine.&lt;/p&gt;

&lt;p&gt;For this post, we’ll look at the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/cpuops.v&quot;&gt;ALU&lt;/a&gt;
found within the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;.
Unlike many of the “classroom”
&lt;a href=&quot;https://en.wikipedia.org/wiki/Arithmetic_logic_unit&quot;&gt;ALU&lt;/a&gt;’s
you may have come across, this simple
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/cpuops.v&quot;&gt;ALU&lt;/a&gt;
is also complete enough to support the
&lt;a href=&quot;https://sourceware.org/newlib&quot;&gt;newlib C library&lt;/a&gt;.
As a result, you might find a couple of features within this
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/cpuops.v&quot;&gt;ALU&lt;/a&gt;
that you are not expecting.&lt;/p&gt;

&lt;h2 id=&quot;a-basic-alu&quot;&gt;A Basic ALU&lt;/h2&gt;

&lt;p&gt;If you’ve never seen how to build an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Arithmetic_logic_unit&quot;&gt;ALU&lt;/a&gt;
before, the logic to build one is actually very simple.  It’s basically
a big huge case statement that selects from among several possible outputs.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;case(i_op[3:0])
	4&#39;b0000:{c,o_c } &amp;lt;= {1&#39;b0,i_a}-{1&#39;b0,i_b};// SUB
	4&#39;b0001:   o_c   &amp;lt;= i_a &amp;amp; i_b;		// And
	4&#39;b0010:{c,o_c } &amp;lt;= i_a + i_b;		// Add
	4&#39;b0011:   o_c   &amp;lt;= i_a | i_b;		// Or
	4&#39;b0100:   o_c   &amp;lt;= i_a ^ i_b;		// Xor
	// ....
	default:   o_c   &amp;lt;= i_b;		// MOV, LDI&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;In this example, taken from the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;’s
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/cpuops.v&quot;&gt;ALU&lt;/a&gt;, the
two inputs, &lt;code class=&quot;highlighter-rouge&quot;&gt;i_a&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;i_b&lt;/code&gt;, are both 32-bit values.  The input to the
routine also includes a number, &lt;code class=&quot;highlighter-rouge&quot;&gt;i_op&lt;/code&gt;, identifying the operation that
needs to be calculated.  The result is placed into an output register, &lt;code class=&quot;highlighter-rouge&quot;&gt;o_c&lt;/code&gt;.
The &lt;code class=&quot;highlighter-rouge&quot;&gt;c&lt;/code&gt; bit you see above is associated with the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;’s carry logic–something we’ll
come back to later in this post.&lt;/p&gt;

&lt;p&gt;Structurally, within an FPGA, the logic looks like Fig 1 below.&lt;/p&gt;

&lt;table style=&quot;float: left&quot;&gt;&lt;caption&gt;Fig 1: ALU Hardware Structure&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/alu-simple.svg&quot; alt=&quot;ALU Structure&quot; width=&quot;400&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Each of the blocks in this figure takes up logic when implemented within
hardware.  As a result, even if &lt;code class=&quot;highlighter-rouge&quot;&gt;i_op&lt;/code&gt; requests that the two values be
subtracted, all of the other operations (addition, and, or, xor, etc.) will
still be calculated.  These other results, though, are just ignored.  Thus,
on the final clock of the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/cpuops.v&quot;&gt;ALU&lt;/a&gt;,
&lt;em&gt;all&lt;/em&gt; of the operations have been calculated, but &lt;em&gt;only&lt;/em&gt; the result of
the selected operation is stored into the output register.&lt;/p&gt;

&lt;p&gt;So that’s what an &lt;a href=&quot;https://en.wikipedia.org/wiki/Arithmetic_logic_unit&quot;&gt;ALU&lt;/a&gt;
looks liike in general.  Let’s now turn our attention to the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;’s
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/cpuops.v&quot;&gt;ALU&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;the-zipcpu-alu&quot;&gt;The ZipCPU ALU&lt;/h2&gt;

&lt;p&gt;The actual case statement within the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;’s
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/cpuops.v&quot;&gt;ALU&lt;/a&gt;
has sixteen operations that the instruction selects from among, not just the
six shown above.  In this section,
we’ll look at all of that logic save the multiply.  (Although the multiply
takes up most of the code space within the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/cpuops.v&quot;&gt;cpuops.v&lt;/a&gt;
file, it doesn’t fit into this lesson very well.)  Put together, the full
case statement for the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;’s
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/cpuops.v&quot;&gt;ALU&lt;/a&gt;
looks like:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
if (i_ce)
begin
	c &amp;lt;= 1&#39;b0;
	casez(i_op)
	4&#39;b0000:{c,o_c } &amp;lt;= {1&#39;b0,i_a}-{1&#39;b0,i_b};// CMP/SUB
	4&#39;b0001:   o_c   &amp;lt;= i_a &amp;amp; i_b;		// BTST/And
	4&#39;b0010:{c,o_c } &amp;lt;= i_a + i_b;		// Add
	4&#39;b0011:   o_c   &amp;lt;= i_a | i_b;		// Or
	4&#39;b0100:   o_c   &amp;lt;= i_a ^ i_b;		// Xor
	4&#39;b0101:{o_c,c } &amp;lt;= w_lsr_result[32:0];	// LSR
	4&#39;b0110:{c,o_c } &amp;lt;= w_lsl_result[32:0]; // LSL
	4&#39;b0111:{o_c,c } &amp;lt;= w_asr_result[32:0];	// ASR
	4&#39;b1000:   o_c   &amp;lt;= w_brev_result;	// BREV
	4&#39;b1001:   o_c   &amp;lt;= { i_a[31:16], i_b[15:0] }; // LODILO
	4&#39;b1010:   o_c   &amp;lt;= mpy_result[63:32];	// MPYHU
	4&#39;b1011:   o_c   &amp;lt;= mpy_result[63:32];	// MPYHS
	4&#39;b1100:   o_c   &amp;lt;= mpy_result[31:0];	// MPY
	default:   o_c   &amp;lt;= i_b;		// MOV, LDI
	endcase
end else // if (mpydone)
	// set the carry based upon a multiply result
	o_c &amp;lt;= (mpyhi)?mpy_result[63:32]:mpy_result[31:0];&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Let’s walk through each of these operations.&lt;/p&gt;

&lt;p&gt;The first operation, &lt;code class=&quot;highlighter-rouge&quot;&gt;4&#39;h0&lt;/code&gt; supports either a compare or a subtract
instruction.  This instruction subtracts two numbers in order to produce its
result.  The difference between the &lt;code class=&quot;highlighter-rouge&quot;&gt;CMP&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;SUB&lt;/code&gt; instructions is that the
compare doesn’t write the results back to any registers in the end while the
subtract does–but since that’s external to the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/cpuops.v&quot;&gt;ALU&lt;/a&gt;
implementation, you won’t see that difference here.&lt;/p&gt;

&lt;p&gt;You may notice that the subtract that is taking place is a 33-bit subtract
rather than a 32-bit subtract.  The reason for this is the carry, &lt;code class=&quot;highlighter-rouge&quot;&gt;c&lt;/code&gt;, bit.
In the case of a subtract, this bit will be true if &lt;code class=&quot;highlighter-rouge&quot;&gt;i_b&lt;/code&gt; had to &lt;em&gt;borrow&lt;/em&gt;
from the (unspecified) high order bit in order to complete.  We’ll discuss
this flag in more detail further down.&lt;/p&gt;

&lt;p&gt;The &lt;code class=&quot;highlighter-rouge&quot;&gt;TST&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;AND&lt;/code&gt; instructions are similar to the &lt;code class=&quot;highlighter-rouge&quot;&gt;CMP&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;SUB&lt;/code&gt;
instructions.  If the operation is an &lt;code class=&quot;highlighter-rouge&quot;&gt;AND&lt;/code&gt;, then both the result
and the flags will be set during writeback, whereas only the flags are set in
the case of the &lt;code class=&quot;highlighter-rouge&quot;&gt;TST&lt;/code&gt; operation.  Again, this difference is external to the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/cpuops.v&quot;&gt;ALU&lt;/a&gt;
implementation itself.&lt;/p&gt;

&lt;p&gt;The &lt;code class=&quot;highlighter-rouge&quot;&gt;ADD&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;OR&lt;/code&gt;, and &lt;code class=&quot;highlighter-rouge&quot;&gt;XOR&lt;/code&gt; instructions should need no further explanation.
(&lt;a href=&quot;https://en.wikipedia.org/wiki/Exclusive_or#Bitwise_operation&quot;&gt;XOR Ref&lt;/a&gt;)
The &lt;code class=&quot;highlighter-rouge&quot;&gt;c&lt;/code&gt; bit is set on the &lt;code class=&quot;highlighter-rouge&quot;&gt;ADD&lt;/code&gt;, though, if the result of adding unsigned
&lt;code class=&quot;highlighter-rouge&quot;&gt;i_a&lt;/code&gt; to &lt;code class=&quot;highlighter-rouge&quot;&gt;i_b&lt;/code&gt; overflows 32-bits.  This bit then makes it possible to string
32-bit additions together to create a 64-bit or larger operation.&lt;/p&gt;

&lt;p&gt;The shift instruction(s) needs some additional discussion.  The &lt;a href=&quot;https://en.wikipedia.org/wiki/Logical_shift&quot;&gt;logical
shift&lt;/a&gt; left, or &lt;code class=&quot;highlighter-rouge&quot;&gt;LSL&lt;/code&gt;, is
what the compiler creates from an &lt;code class=&quot;highlighter-rouge&quot;&gt;A = B &amp;lt;&amp;lt; C&lt;/code&gt; instruction.  The result is
created by shifting all of the bits in &lt;code class=&quot;highlighter-rouge&quot;&gt;B&lt;/code&gt; to the left by one and filling
the results in with zeros.
The &lt;a href=&quot;https://en.wikipedia.org/wiki/Logical_shift&quot;&gt;logical shift&lt;/a&gt;
right, or &lt;code class=&quot;highlighter-rouge&quot;&gt;LSR&lt;/code&gt;, comes from an &lt;code class=&quot;highlighter-rouge&quot;&gt;A = B &amp;gt;&amp;gt; C&lt;/code&gt; instruction in C, but only when
&lt;code class=&quot;highlighter-rouge&quot;&gt;B&lt;/code&gt; is unsigned.  In this case, all the bits shift to the right and the
upper bits are filled in with zeros.&lt;/p&gt;

&lt;p&gt;If &lt;code class=&quot;highlighter-rouge&quot;&gt;B&lt;/code&gt; is signed, however, the compiler will create an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Arithmetic_shift&quot;&gt;arithmetic shift&lt;/a&gt;
right, &lt;code class=&quot;highlighter-rouge&quot;&gt;ASR&lt;/code&gt;, instruction instead.  The &lt;code class=&quot;highlighter-rouge&quot;&gt;ASR&lt;/code&gt; is similar to the &lt;code class=&quot;highlighter-rouge&quot;&gt;LSR&lt;/code&gt;
instruction with one exception: the &lt;code class=&quot;highlighter-rouge&quot;&gt;ASR&lt;/code&gt; instruction propagates the high order
bit during the shift.  Hence the incoming &lt;code class=&quot;highlighter-rouge&quot;&gt;i_a[31]&lt;/code&gt; will always set the
outgoing &lt;code class=&quot;highlighter-rouge&quot;&gt;o_c[31]&lt;/code&gt; bit.  So while
&lt;a href=&quot;https://en.wikipedia.org/wiki/Logical_shift&quot;&gt;logically shifting&lt;/a&gt; a
&lt;code class=&quot;highlighter-rouge&quot;&gt;32&#39;hffff_fffe&lt;/code&gt; to the right by one bit will create a &lt;code class=&quot;highlighter-rouge&quot;&gt;32&#39;7fff_ffff&lt;/code&gt;,
&lt;a href=&quot;https://en.wikipedia.org/wiki/Arithmetic_shift&quot;&gt;arithmetically shifting&lt;/a&gt; a
&lt;code class=&quot;highlighter-rouge&quot;&gt;32&#39;hffff_fffe&lt;/code&gt; to the right by one bit will create a &lt;code class=&quot;highlighter-rouge&quot;&gt;32&#39;hffff_ffff&lt;/code&gt;.
The sign bit, &lt;code class=&quot;highlighter-rouge&quot;&gt;i_a[31]&lt;/code&gt; propagates on an &lt;code class=&quot;highlighter-rouge&quot;&gt;ASR&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Where things get interesting is what happens when you shift farther than
the number of bits in a register.  For example, what should be the result of
&lt;code class=&quot;highlighter-rouge&quot;&gt;32&#39;h0000_ffff&lt;/code&gt; when shifted left by 32?  &lt;code class=&quot;highlighter-rouge&quot;&gt;32&#39;h0000_0000&lt;/code&gt;, right?  Sure.  Now
what happens when you shift left by 34 bits?  Some
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;’s
examine only the lower 5 bits of the shift amount, and require the compiler
to make certain the shift is within bounds.  The
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;,
however, examines all 32-bits of the shift request contained in &lt;code class=&quot;highlighter-rouge&quot;&gt;i_b&lt;/code&gt;.
Hence, any attempt to logically shift more than 32-bits on the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt; results in a zero.&lt;/p&gt;

&lt;p&gt;The &lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;
handles shifts with one further difference that isn’t necessarily
used by the compiler: the carry bit is set to the last bit shifted off the
register.&lt;/p&gt;

&lt;p&gt;Now that all that is said, the &lt;code class=&quot;highlighter-rouge&quot;&gt;LSR&lt;/code&gt; logic is given by:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;assign  w_lsr_result =
	// Check if the shift amount will overflow, return 33&#39;h00 if it does
	((|i_b[31:6])||(i_b[5]&amp;amp;&amp;amp;(i_b[4:0]!=0)))? 33&#39;h00
	// On a shift of 32 exactly, keep i_a[31] in the carry
				:((i_b[5])?{32&#39;h0,i_a[31]}
	// Otherwise just shift the results by i_b
				: ( { i_a, 1&#39;b0 } &amp;gt;&amp;gt; (i_b[4:0]) ));// LSR&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The logic for the &lt;code class=&quot;highlighter-rouge&quot;&gt;LSL&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;ASR&lt;/code&gt; instructions is quite similar.&lt;/p&gt;

&lt;p&gt;A second unique
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;
instruction is the &lt;a href=&quot;https://en.wikipedia.org/wiki/Bit-reversal_permutation&quot;&gt;bit
reverse&lt;/a&gt; instruction,
&lt;code class=&quot;highlighter-rouge&quot;&gt;BREV&lt;/code&gt;.  This is a zero cost instruction that does nothing but re-order the
wires from the &lt;code class=&quot;highlighter-rouge&quot;&gt;i_b&lt;/code&gt; input:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;genvar	k; generate
for(k=0; k&amp;lt;32; k=k+1)
begin : bit_reversal_cpuop
	assign w_brev_result[k] = i_b[31-k];
end endgenerate&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This particular instruction is not found in other
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;’s.
It was placed into the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt; in order to support the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bit-reversal_permutation&quot;&gt;bit reversed&lt;/a&gt;
addressing required by a &lt;a href=&quot;https://en.wikipedia.org/Cooley-Tukey_FFT_algorithm&quot;&gt;Fast Fourier
transform&lt;/a&gt;.  It has since
become integral to the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;’s instruction set.  Here’s why:&lt;/p&gt;

&lt;p&gt;Every &lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;
needs an ability to load a value with as many bits as a register into
a register.  That is to say, a 32-bit
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;
needs the ability to load a 32-bit immediate value into a 32-bit
register–&lt;a href=&quot;https://www.gnu.org/software/binutils&quot;&gt;binutils&lt;/a&gt;, and particularly
the linker within
it, requires this capability.  Since instructions are 32-bits wide, you can’t
fit both an instruction and a 32’bit value into the same instruction.  While
the &lt;a href=&quot;https://en.wikipedia.org/wiki/X86&quot;&gt;x86&lt;/a&gt; solved this problem by storing
the 32’bit value directly in the instruction stream following this instruction,
this risks mis-aligning the instruction stream and therefore adding
complication to the instruction decoder.  To avoid this extra complication,
&lt;a href=&quot;https://en.wikipedia.org/wiki/Reduced_instruction_set_computer&quot;&gt;RISC&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;s
tend to handle this problem with a two instruction load: the first instruction
loads the upper half of the register, while the second instruction loads
the lower half of the register.&lt;/p&gt;

&lt;p&gt;In the case of the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;,
the &lt;code class=&quot;highlighter-rouge&quot;&gt;BREV&lt;/code&gt; instruction is the first instruction in this pair–it can be used to
load the upper 18-bits of a register.  The other instruction, shown in the
code above as &lt;code class=&quot;highlighter-rouge&quot;&gt;LDILO&lt;/code&gt; (load immediate into lower 16-bits), loads the lower
16-bits of any 32-bit value.  &lt;a href=&quot;https://gcc.gnu.org&quot;&gt;GCC&lt;/a&gt; requires that neither
of these operations affect the flags, something we can come back and discuss
another time.  Together, these two instructions allow the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;
to load &lt;em&gt;any&lt;/em&gt; 32-bit immediate value into a register.  Since the extra cost
of &lt;a href=&quot;https://en.wikipedia.org/wiki/Bit-reversal_permutation&quot;&gt;bit reversing&lt;/a&gt;
a 32-bit value is handled by the
&lt;a href=&quot;https://www.gnu.org/software/binutils&quot;&gt;assembler and linker&lt;/a&gt; (there’s no
hardware cost for doing this), there’s no performance penalty to the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt; for having this instruction.&lt;/p&gt;

&lt;p&gt;That leaves two pieces of logic we haven’t discussed within the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/cpuops.v&quot;&gt;ALU&lt;/a&gt;.
The first is the flag generation logic which we will come to next.  The
other piece of logic within the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/cpuops.v&quot;&gt;ALU&lt;/a&gt;
that we haven’t discussed is the multiply.  The multiply logic in the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;’s
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/cpuops.v&quot;&gt;cpuops.v&lt;/a&gt;
file is particularly complicated for the sole reason that the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;
can support a 32x32-bit multiply across a wide variety of hardware
architectures.  Some of these architectures can do a multiply in a single
clock, while other FPGA’s require two, three, or even four clocks to execute a
multiply.&lt;/p&gt;

&lt;p&gt;Let’s look at calculating the flags next.&lt;/p&gt;

&lt;h2 id=&quot;the-flags-results&quot;&gt;The Flags Results&lt;/h2&gt;

&lt;p&gt;The &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/cpuops.v&quot;&gt;ALU&lt;/a&gt;
creates and outputs a set of flags from the operation.  Many instructions will
cause these to be placed into the &lt;a href=&quot;https://en.wikipedia.org/wiki/Status_register&quot;&gt;condition codes
register&lt;/a&gt;.
The &lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;
supports all four of the common condition codes, or flags as we’ll call them
here: &lt;code class=&quot;highlighter-rouge&quot;&gt;Z&lt;/code&gt; (zero), &lt;code class=&quot;highlighter-rouge&quot;&gt;C&lt;/code&gt; (carry), &lt;code class=&quot;highlighter-rouge&quot;&gt;N&lt;/code&gt; (negative) and &lt;code class=&quot;highlighter-rouge&quot;&gt;V&lt;/code&gt; (overflow).&lt;/p&gt;

&lt;p&gt;The &lt;code class=&quot;highlighter-rouge&quot;&gt;Z&lt;/code&gt; flag is set whenever the result is zero:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;assign	z = (o_c == 32&#39;h0000);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The compiler uses this flag whenever two numbers need to be tested and compared
for equality.&lt;/p&gt;

&lt;p&gt;The &lt;code class=&quot;highlighter-rouge&quot;&gt;C&lt;/code&gt; or “carry” flag was set above whenever an addition or subtraction
required a carry.  I also mentioned above how the carry flag on the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;
is also set for shift operations.  All other operations clear the carry flag.&lt;/p&gt;

&lt;p&gt;The compiler uses this flag whenever two numbers need to be tested and compared
for an unsigned &lt;em&gt;less than&lt;/em&gt;, or whenever an extended 64-bit addition (or
subtraction) needs to be carried out.  (Unlike many other CPU’s, the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;
doesn’t have either “add with carry” or “subtract with carry” instructions.)&lt;/p&gt;

&lt;p&gt;The &lt;code class=&quot;highlighter-rouge&quot;&gt;N&lt;/code&gt; flag is perhaps the simplest to discuss.  This is set whenever the
sign bit is set on the output:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;assign	n = (o_c[31]);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Well, not quite.&lt;/p&gt;

&lt;p&gt;It turns out that there’s an ugly problem associated with setting the &lt;code class=&quot;highlighter-rouge&quot;&gt;N&lt;/code&gt;
flag to the outgoing sign bit.  Specifically,
if you wish to compare whether or not &lt;code class=&quot;highlighter-rouge&quot;&gt;A&amp;lt;B&lt;/code&gt; when &lt;code class=&quot;highlighter-rouge&quot;&gt;A&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;B&lt;/code&gt; are large and
signed then &lt;code class=&quot;highlighter-rouge&quot;&gt;o_c[31]&lt;/code&gt; isn’t sufficient.  To do this comparison, the &lt;code class=&quot;highlighter-rouge&quot;&gt;CMP&lt;/code&gt;
instruction will enter the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/cpuops.v&quot;&gt;ALU&lt;/a&gt;
via a subtract, &lt;code class=&quot;highlighter-rouge&quot;&gt;A-B&lt;/code&gt;.  The result of this subtraction will then be checked
to determine whether or not the result is less than zero.  However, if the
result overflows the sign bit, then you still want to continue to set the
&lt;code class=&quot;highlighter-rouge&quot;&gt;N&lt;/code&gt; flag appropriately.  If you don’t, then &lt;code class=&quot;highlighter-rouge&quot;&gt;32&#39;h8000_0000&lt;/code&gt; won’t be less
than &lt;code class=&quot;highlighter-rouge&quot;&gt;32&#39;h7fff_ffff&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;As proof, consider what happens on a subtraction overflow:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;  32&#39;h7fff_ffff ( 2^(31)-1)
- 32&#39;h8000_0000 (-2^(31)  )
---------------
= 32`hffff_ffff&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The result of this subtraction &lt;em&gt;should&lt;/em&gt; be a positive &lt;code class=&quot;highlighter-rouge&quot;&gt;2^(32)-1&lt;/code&gt;.  However,
since an overflow took place, the MSB no longer reflects the correct sign.
We’re going to need to adjust &lt;code class=&quot;highlighter-rouge&quot;&gt;N&lt;/code&gt; therefore to reflect that this result is
positive and not negative.&lt;/p&gt;

&lt;p&gt;While there may be a simpler way, the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/cpuops.v&quot;&gt;ALU&lt;/a&gt;
solves this problem in three steps.  The first is to keep track of
the original sign of &lt;code class=&quot;highlighter-rouge&quot;&gt;i_a&lt;/code&gt; in a register called &lt;code class=&quot;highlighter-rouge&quot;&gt;pre_sign&lt;/code&gt;.  The second part
is to determine if that sign needs to be kept on an overflow.
Then, on any overflow, the sign is flipped when determining &lt;code class=&quot;highlighter-rouge&quot;&gt;N&lt;/code&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	if (i_ce) // 1 LUT
	begin
		pre_sign &amp;lt;= (i_a[31]);
		keep_sgn_on_ovfl&amp;lt;=
			(((i_op==4&#39;h0)&amp;amp;&amp;amp;(i_a[31] != i_b[31]))//SUB&amp;amp;CMP
			||((i_op==4&#39;h2)&amp;amp;&amp;amp;(i_a[31] == i_b[31]))); // ADD
	end

assign n = (o_c[31])
	^ ((keep_sgn_on_ovfl)&amp;amp;&amp;amp;(pre_sign != o_c[31]));&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;When to keep a sign on overflow needs a touch more explanation:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;If you add two values with the same sign, then the result should also
have the same sign regardless of any overflow.  Hence, two positive numbers
should yield a positive result in spite of any overflow.  In this case,
the sign should be given by &lt;code class=&quot;highlighter-rouge&quot;&gt;i_a&lt;/code&gt;’s sign, captured here in &lt;code class=&quot;highlighter-rouge&quot;&gt;pre_sign&lt;/code&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The same is true of subtract, save only that the sign needs to be
preserved any time the initial values have opposite signs.  In particular,
if you negate the second value, a subtract becomes the same as an addition,
and then the addition rule above applies again.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Now, if the sign changes but yet was supposed to be kept, then the resulting
&lt;code class=&quot;highlighter-rouge&quot;&gt;N&lt;/code&gt; flag needs to be swapped–hence the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Exclusive_or&quot;&gt;exclusive OR&lt;/a&gt;
in the code above.&lt;/p&gt;

&lt;p&gt;The &lt;code class=&quot;highlighter-rouge&quot;&gt;N&lt;/code&gt; bit is used by the compiler to test whether or not &lt;code class=&quot;highlighter-rouge&quot;&gt;i_a &amp;lt; i_b&lt;/code&gt; when
both numbers are signed.  By preserving the meaning of this bit in spite
of overflow, the compiler does what you would expect it to do–even when
comparing large numbers.&lt;/p&gt;

&lt;p&gt;The final flag bit, the overflow or &lt;code class=&quot;highlighter-rouge&quot;&gt;V&lt;/code&gt; bit, requires a touch more logic
as well.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	if (i_ce) // 1 LUT
		set_ovfl&amp;lt;=(((i_op==4&#39;h0)&amp;amp;&amp;amp;(i_a[31] != i_b[31]))//SUB&amp;amp;CMP
			||((i_op==4&#39;h2)&amp;amp;&amp;amp;(i_a[31] == i_b[31])) // ADD
			||(i_op == 4&#39;h6) // LSL
			||(i_op == 4&#39;h5)); // LSR&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The &lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;
sets the overflow flag on one of four conditions:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;If this is an addition, and the signs of both operands are the same, then
the result should be positive and the overflow bit will be set if the
signs don’t match.&lt;/p&gt;

    &lt;p&gt;This alone is almost identical to the &lt;code class=&quot;highlighter-rouge&quot;&gt;N&lt;/code&gt; logic above.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The second case is the case for the subtract.  If the incoming signs are
identical, and the outgoing sign is different, then the overflow bit
needs to be set.  This is also very similar to the &lt;code class=&quot;highlighter-rouge&quot;&gt;N&lt;/code&gt; logic above.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The last two cases regard shifts.  In particular, the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;
sets the overflow if either of the &lt;a href=&quot;https://en.wikipedia.org/wiki/Logical_shift&quot;&gt;logical
shift&lt;/a&gt;
instructions changes the sign of the output.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Put together, this yields the following logic for the &lt;code class=&quot;highlighter-rouge&quot;&gt;V&lt;/code&gt; bit:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;assign	v = (set_ovfl)&amp;amp;&amp;amp;(pre_sign != o_c[31]);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Since the C language doesn’t have a way to test for overflow within the
language, this flag has gone largely unused.  Further, the compiler support
for overflow checking for those other languages that do use it hasn’t
been implemented yet.&lt;/p&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;That’s basically how an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Arithmetic_logic_unit&quot;&gt;ALU&lt;/a&gt;
works: it’s a series of operations whose output is selected via a case
statement.  While every
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;
will support different instructions, at some level all
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;’s
will have a case statement selecting between various operations within them.&lt;/p&gt;

&lt;p&gt;In the case of a &lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;
with a &lt;a href=&quot;https://en.wikipedia.org/wiki/Status_register&quot;&gt;condition codes
register&lt;/a&gt;.
such as the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;, these codes are also
easily calculated within the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/cpuops.v&quot;&gt;ALU&lt;/a&gt; as well.&lt;/p&gt;

&lt;p&gt;Turning a simple &lt;a href=&quot;https://en.wikipedia.org/wiki/Arithmetic_logic_unit&quot;&gt;ALU&lt;/a&gt;
into a full blown &lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;,
such as the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;,
takes a bit more work than we presented above.  In fact, it takes a &lt;em&gt;lot&lt;/em&gt;
more work.  Let’s consider that a good thing, though, because it will give
us something to learn on another day.&lt;/p&gt;

&lt;hr /&gt;&lt;p&gt;&lt;em&gt;In all thy ways acknowledge him, and he shall direct thy paths. (Prov 3:6)&lt;/em&gt;</description>
        <pubDate>Fri, 11 Aug 2017 00:00:00 -0400</pubDate>
        <link>http://zipcpu.com/zipcpu/2017/08/11/simple-alu.html</link>
        <guid isPermaLink="true">http://zipcpu.com/zipcpu/2017/08/11/simple-alu.html</guid>
        
        
        <category>zipcpu</category>
        
      </item>
    
      <item>
        <title>Series: Debouncing in Digital Logic</title>
        <description>&lt;p&gt;This ends our series on contact bounce.  We started out by demonstrating that
&lt;a href=&quot;/blog/2017/08/02/debounce-teaser.html&quot;&gt;button’s do indeed bounce&lt;/a&gt;.
This initial post presented a series of images, collected from tests that
measured button bouncing across multiple devices.&lt;/p&gt;

&lt;p&gt;We then demonstrated how, using digital logic, &lt;a href=&quot;/blog/2017/08/04/debouncing.html&quot;&gt;extraneous bounces could be
removed&lt;/a&gt; from a button’s
signal.&lt;/p&gt;

&lt;p&gt;We also showed &lt;a href=&quot;/blog/2017/08/05/bounce-metric.html&quot;&gt;how to measure how much and how often a button
bounces&lt;/a&gt;.  This will
be useful to us later should we ever wish to tune the timer within our
debouncer.&lt;/p&gt;

&lt;p&gt;The final article discussed &lt;a href=&quot;/blog/2017/08/07/bounce-dbgbus.html&quot;&gt;how to modify our debugging bus to get a button
bouncing trace&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Unlike other debouncing developments, we’ve also discussed how to
synchronize the button inputs along the way,
and the consequences of metastability should the inputs not be synchronized.
We’ve also presented a debouncer that will return the debounced data
with minimal latency, vice the uncontrolled latency many other approaches
share.&lt;/p&gt;

&lt;p&gt;Further, unlike any other debouncing development I’ve seen, using the
&lt;a href=&quot;https://github.com/ZipCPU/debouncer&quot;&gt;sample code&lt;/a&gt; provided you can see
bouncing for yourself, or even test your own debouncing code.&lt;/p&gt;
&lt;hr /&gt;&lt;p&gt;&lt;em&gt;While the earth remaineth, seedtime and harvest, and cold and heat, and summer and winter, and day and night shall not cease. (Gen 8:22)&lt;/em&gt;</description>
        <pubDate>Wed, 09 Aug 2017 00:00:00 -0400</pubDate>
        <link>http://zipcpu.com/blog/2017/08/09/series-debouncing.html</link>
        <guid isPermaLink="true">http://zipcpu.com/blog/2017/08/09/series-debouncing.html</guid>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>Using a debug-bus to Measure Bouncing</title>
        <description>&lt;p&gt;As we’ve discussed in our two previous posts,
buttons and switches on
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;’s
can be very useful to work with.  They can be
very useful tools when debugging as well.  The problem is that these forms of
inputs often “&lt;a href=&quot;https://en.wikipedia.org/wiki/Switch#Contact_bounce&quot;&gt;bounce&lt;/a&gt;”,
and produce multiple edges when only one is desired.  This can be a problem
when you wish to depend or rely upon these inputs as being a dependable
part of a debugging solution–before you’ve managed to ensure their
dependability.&lt;/p&gt;

&lt;p&gt;Making &lt;a href=&quot;https://en.wikipedia.org/wiki/Switch#Contact_bounce&quot;&gt;contact bounce&lt;/a&gt;
particularly problematic is the fact that it is difficult to simulate, since
the bounces tend to appear quite random.&lt;/p&gt;

&lt;p&gt;Our &lt;a href=&quot;/blog/2017/08/02/debounce-teaser.html&quot;&gt;first post&lt;/a&gt;
on this topic looked into how this sort of bouncing manifested, showing
several examples and traces of contact bounces.  The pictures weren’t very
pretty, as many buttons from several different boards and even a keypad all
manifested this problem.&lt;/p&gt;

&lt;p&gt;Our &lt;a href=&quot;/blog/2017/08/04/debouncing.html&quot;&gt;second post&lt;/a&gt;
discussed how to create the digital logic necessary to debounce a user
input.&lt;/p&gt;

&lt;p&gt;We then &lt;a href=&quot;/blog/2017/08/05/bounce-metric.html&quot;&gt;created some simple test
points&lt;/a&gt; that could
be used to measure button press duration and the number of times a particular
button press bounced.&lt;/p&gt;

&lt;p&gt;Today, our discussion is going to focus on how to connect these two
components to the &lt;a href=&quot;https://opencores.org/cdn/downloads/wbspec_b4.pdf&quot;&gt;wishbone
bus&lt;/a&gt; present within our
&lt;a href=&quot;https://github.com/ZipCPU/dbgbus/blob/master/rtl/testbus.v&quot;&gt;debugging-bus testing
logic&lt;/a&gt;.
We’re also going to add a
&lt;a href=&quot;https://github.com/ZipCPU/wbscope&quot;&gt;compressed wishbone scope&lt;/a&gt;
to the design in order to get the traces out of our design such as were
presented in the &lt;a href=&quot;/blog/2017/08/02/debounce-teaser.html&quot;&gt;initial
post&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;instantiating-the-two-components&quot;&gt;Instantiating the two components&lt;/h2&gt;

&lt;p&gt;Over the course of the last two posts, we’ve created two components that
we would now like to test: 
a &lt;a href=&quot;https://github.com/ZipCPU/debouncer/blob/master/rtl/debouncer.v&quot;&gt;debouncer&lt;/a&gt;,
and an
&lt;a href=&quot;https://github.com/ZipCPU/debouncer/blob/master/rtl/unbounced.v&quot;&gt;unbounced&lt;/a&gt;
module.  We are going to test these two components by pressing a button, and
then reading the results produced by these two components as registers on a
bus.  Once read, we’ll use the bus to reset these components.&lt;/p&gt;

&lt;p&gt;We’ll start by assuming we have &lt;code class=&quot;highlighter-rouge&quot;&gt;NBTNS&lt;/code&gt; buttons, in a vector named &lt;code class=&quot;highlighter-rouge&quot;&gt;i_button&lt;/code&gt;
coming into our top level design.  This vector, together with our system
clock, can then be used as inputs to these two modules, as in:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;debouncer	#(NBTNS) thedebouncer(i_clk, i_button,
				debounced, debounce_dbg);
unbounced	#(NBTNS) theunbouncer(i_clk, unbounce_reset,
				i_button, transitions, max_clock);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The result of the
&lt;a href=&quot;https://github.com/ZipCPU/debouncer/blob/master/rtl/debouncer.v&quot;&gt;debouncer&lt;/a&gt;
is a &lt;code class=&quot;highlighter-rouge&quot;&gt;NBTNS&lt;/code&gt;-bit vector &lt;code class=&quot;highlighter-rouge&quot;&gt;debounced&lt;/code&gt;.  This vector is a copy of &lt;code class=&quot;highlighter-rouge&quot;&gt;i_button&lt;/code&gt;,
save only that it has been both synchronized to the clock and any bounces
have been removed.&lt;/p&gt;

&lt;p&gt;The two results of the
&lt;a href=&quot;https://github.com/ZipCPU/debouncer/blob/master/rtl/unbounced.v&quot;&gt;unbounced&lt;/a&gt;
vector are two 31-bit vectors: &lt;code class=&quot;highlighter-rouge&quot;&gt;transitions&lt;/code&gt; which holds the number of
transitions, and &lt;code class=&quot;highlighter-rouge&quot;&gt;max_clock&lt;/code&gt; which holds the number of clock ticks from the
first transition to the last.&lt;/p&gt;

&lt;p&gt;The other two items are the &lt;code class=&quot;highlighter-rouge&quot;&gt;unbounce_reset&lt;/code&gt; and the &lt;code class=&quot;highlighter-rouge&quot;&gt;debounce_dbg&lt;/code&gt;.
The &lt;code class=&quot;highlighter-rouge&quot;&gt;unbounce_reset&lt;/code&gt; line clears the counters.  We’ll hook that up in the
next section.  The &lt;code class=&quot;highlighter-rouge&quot;&gt;debounce_dbg&lt;/code&gt; lines, however, we’ll come back to when
we discuss hooking the debouncer up to the &lt;a href=&quot;https://github.com/ZipCPU/wbscope&quot;&gt;wishbone
scope&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;connecting-the-components-to-the-debugging-bus&quot;&gt;Connecting the components to the debugging bus&lt;/h2&gt;

&lt;p&gt;We’d like to hook these two peripherals to our wishbone debugging bus,
&lt;a href=&quot;https://github.com/ZipCPU/dbgbus/blob/master/bench/rtl/testbus.v&quot;&gt;testbus.v&lt;/a&gt;.
In particular, we’d like to be able to read these three values from an
external UART.  Since reading the values requires no logic handshake with
the modules, they can be hooked up just as simply as any of the other
simple registers within the
&lt;a href=&quot;https://github.com/ZipCPU/dbgbus/blob/master/bench/rtl/testbus.v&quot;&gt;testbus.v&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;To hook this new peripheral up, just assign it an address among our
simple data peripheral’s address map:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	case(wb_addr[3:0])
	...
	4&#39;h6:    smpl_data &amp;lt;= transitions;
	4&#39;h7:    smpl_data &amp;lt;= max_clock;
	4&#39;h8:    smpl_data &amp;lt;= { {(32-NBTNS){1&#39;b0}}, debounced };
	...
	defult: smpl_data &amp;lt;= 32&#39;h0;
	endcase&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Don’t forget when using these addresses, that each address references a
32-bit quantity, and hence they need to be multiplied by four to get the
offset into the address map.
Hence, address offsets of 24, 28, and 32 from the simple data peripheral
now contain our new values.  Given that we placed our simple data peripheral
at an address offset of &lt;code class=&quot;highlighter-rouge&quot;&gt;0x2040&lt;/code&gt;, that means these new registers will have
final addresses &lt;code class=&quot;highlighter-rouge&quot;&gt;0x2058&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;0x205c&lt;/code&gt;, and &lt;code class=&quot;highlighter-rouge&quot;&gt;0x2060&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;One other change is required to the bus, we need to create our reset signal,
&lt;code class=&quot;highlighter-rouge&quot;&gt;unbounce_reset&lt;/code&gt;.  We’re going to set this reset signal up so that any time
we write to either of these registers, either the &lt;code class=&quot;highlighter-rouge&quot;&gt;transitions&lt;/code&gt; or the
&lt;code class=&quot;highlighter-rouge&quot;&gt;max_clock&lt;/code&gt; register, we reset our counters:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;assign	unbounce_reset = (wb_stb)&amp;amp;&amp;amp;(wb_we)&amp;amp;&amp;amp;(smpl_sel)
				&amp;amp;&amp;amp;(wb_addr[3:1]==3&#39;b011);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;That’s it!  That’s all the changes that are necessary in order to connect
these two new peripherals to our bus.  Gosh, if it’s that easy, why not
try your own peripherals?&lt;/p&gt;

&lt;p&gt;Before moving to the next section, there’s one other difference.  If you
compare this &lt;a href=&quot;https://github.com/ZipCPU/debouncer/blob/master/bench/rtl/testbus.v&quot;&gt;new top level
design&lt;/a&gt;
with the &lt;a href=&quot;https://github.com/ZipCPU/dbgbus/blob/master/bench/rtl/testbus.v&quot;&gt;initial top level
design&lt;/a&gt;,
you’ll notice that the block RAM has been removed.  This was to provide
extra block RAM space for the wishbone scope—space that was never
really needed in the end.&lt;/p&gt;

&lt;h2 id=&quot;switching-to-a-compressed-wishbone-scope&quot;&gt;Switching to a compressed wishbone scope&lt;/h2&gt;

&lt;p&gt;There are three RTL steps to setting up a wishbone scope within your design.&lt;/p&gt;

&lt;p&gt;The first step is to create a trigger.  You can find the trigger I
created in the
&lt;a href=&quot;https://github.com/ZipCPU/dbgbus/blob/master/rtl/debouncer.v&quot;&gt;debouncer&lt;/a&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	trigger &amp;lt;= (!ztimer)&amp;amp;&amp;amp;(!different)&amp;amp;&amp;amp;(!(|i_in))
			&amp;amp;&amp;amp;(timer[(LGWAIT-1):2]==0)&amp;amp;&amp;amp;(timer[1]);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This trigger is designed to stop the scope any time the debouncing logic
is complete, &lt;em&gt;and&lt;/em&gt; the button’s logic value(s) has returned to zero.  In
practice, it didn’t work very well for testing the keypad, since the keypad
uses negative logic (a button release sends the signal high, not low).
The end result was that I often needed to trigger the scope manually from the
debugging bus, but we’ll come back to this in a moment.&lt;/p&gt;

&lt;p&gt;The next step in connecting the scope is to select the data lines you wish
to record.  Here, let’s connect to our synchronized inputs, the debounced
result, as well as the &lt;code class=&quot;highlighter-rouge&quot;&gt;ztimer&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;trigger&lt;/code&gt; logic from within the design.
Because buttons take place over a very long period of time, we’ll need
to use the compressed wishbone scope.  That’s going to limit our debugging
width to 31-bits instead of 32.  (The last bit is used for run length
encoding.)&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;//	debug[31] is used for RLE encoding, and thus not available to us here
assign	debug[30] = ztimer;
assign	debug[29] = trigger;
assign	debug[28] = 1&#39;b0;
// Bits 27:14 are assigned to the output of the debouncer
assign	debug[27 :(14+NIN)] = 0;
assign	debug[(14+NIN-1):14] = o_debounced;
// Bottom 14 bits are assigned to our synchronized input(s)
assign	debug[13 :NIN] = 0;
assign	debug[(NIN-1):0] = r_in;

assign	o_debug = debug;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;While this approach limits the number of inputs to 13-bits in a 14-bit
field, the logic within the actual &lt;a href=&quot;https://github.com/ZipCPU/debouncer/blob/master/rtl/debouncer.v&quot;&gt;debouncer
code&lt;/a&gt;
makes it possible to record up to 14-bits, and to process any number of
buttons up to an arbitrary width.&lt;/p&gt;

&lt;p&gt;The final change is to adjust the scope itself.  Switching from an
&lt;a href=&quot;https://github.com/ZipCPU/wbscope/blob/master/rtl/wbscope.v&quot;&gt;uncompressed wishbone scope&lt;/a&gt; to a
&lt;a href=&quot;https://github.com/ZipCPU/wbscope/blob/master/rtl/wbscope.v&quot;&gt;compressed wishbone scope&lt;/a&gt;
is almost as easy as changing &lt;code class=&quot;highlighter-rouge&quot;&gt;wbscope&lt;/code&gt; to &lt;code class=&quot;highlighter-rouge&quot;&gt;wbscopc&lt;/code&gt;.  Indeed, the two share
an almost identical interface standard.  The only more substantial change
beyond changing the name is adjusting the input data width from 32-bits down
to the 31-bits of the compressed scope.  We’ll also pull the &lt;code class=&quot;highlighter-rouge&quot;&gt;scope_trigger&lt;/code&gt;
from its bit position within the &lt;code class=&quot;highlighter-rouge&quot;&gt;debug&lt;/code&gt; vector coming from the &lt;a href=&quot;https://github.com/ZipCPU/debouncer/blob/master/rtl/debouncer.v&quot;&gt;debouncer
code&lt;/a&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	assign	scope_trigger = debounce_dbg[29];
	wire	[30:0]	debug_data;
	assign	debug_data    = debounce_dbg;
	wbscopc	#(5&#39;d9) thescope(i_clk, 1&#39;b1, scope_trigger, debug_data,&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Setting up the design for this purpose is really just that easy.&lt;/p&gt;

&lt;h2 id=&quot;adjusting-the-register-definition-files&quot;&gt;Adjusting the register definition files&lt;/h2&gt;

&lt;p&gt;Finally, I adjusted the
&lt;a href=&quot;https://github.com/ZipCPU/debouncer/blob/master/sw/regdefs.h&quot;&gt;regdefs.h&lt;/a&gt; and
&lt;a href=&quot;https://github.com/ZipCPU/debouncer/blob/master/sw/regdefs.cpp&quot;&gt;regdefs.cpp&lt;/a&gt;
files to reflect that there are two new registers
in our design, giving them names that I can use to access them both from
my own C code
(&lt;a href=&quot;https://github.com/ZipCPU/debouncer/blob/master/sw/regdefs.h&quot;&gt;regdefs.h&lt;/a&gt;),
as well as from the &lt;code class=&quot;highlighter-rouge&quot;&gt;wbregs&lt;/code&gt; command line
(&lt;a href=&quot;https://github.com/ZipCPU/debouncer/blob/master/sw/regdefs.cpp&quot;&gt;regdefs.cpp&lt;/a&gt;).&lt;/p&gt;

&lt;p&gt;The first change was to
&lt;a href=&quot;https://github.com/ZipCPU/debouncer/blob/master/sw/regdefs.h&quot;&gt;regdefs.h&lt;/a&gt;,
where we needed to define our three new registers:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;cp&quot;&gt;#define	R_TRANSITIONS	0x00002058
#define	R_MAXCLOCKS	0x0000205c
#define	R_DEBOUNCED	0x00002060&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;You may remember from our discussion above that these are the addresses
of these three new registers within our simple data peripheral’s address space.&lt;/p&gt;

&lt;p&gt;I then gave these registers user-friendly names by modifying
&lt;a href=&quot;https://github.com/ZipCPU/debouncer/blob/master/sw/regdefs.cpp&quot;&gt;regdefs.cpp&lt;/a&gt;:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;R_DEBOUNCED&lt;/span&gt;	  &lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;	&lt;span class=&quot;s&quot;&gt;&quot;DEBOUNCED&quot;&lt;/span&gt;	&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;R_TRANSITIONS&lt;/span&gt;	  &lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;	&lt;span class=&quot;s&quot;&gt;&quot;BOUNCES&quot;&lt;/span&gt;	&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;R_TRANSITIONS&lt;/span&gt;	  &lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;	&lt;span class=&quot;s&quot;&gt;&quot;TRANSITIONS&quot;&lt;/span&gt;	&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;R_MAXCLOCKS&lt;/span&gt;	  &lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;	&lt;span class=&quot;s&quot;&gt;&quot;DURATION&quot;&lt;/span&gt;	&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;R_MAXCLOCKS&lt;/span&gt;	  &lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;	&lt;span class=&quot;s&quot;&gt;&quot;MAXCLOCKS&quot;&lt;/span&gt;	&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This only modifies a structure providing a mapping from register values
to user register names.&lt;/p&gt;

&lt;p&gt;The final change was to create a piece of C++ code to read from the
wishbone scope.  You can see what this new scope code looks like
&lt;a href=&quot;https://github.com/ZipCPU/debouncer/blob/master/sw/btnscope.cpp&quot;&gt;here&lt;/a&gt;,
although how to develop this code is discussed in general
&lt;a href=&quot;/blog/2017/07/08/getting-started-with-wbscope.html&quot;&gt;here&lt;/a&gt;.
Build and run this new
&lt;a href=&quot;https://github.com/ZipCPU/debouncer/blob/master/sw/btnscope.cpp&quot;&gt;btnscope&lt;/a&gt;
program, and you’ll have a &lt;a href=&quot;/blog/2017/07/31/vcd.html&quot;&gt;VCD
file&lt;/a&gt; that you can then use with
&lt;a href=&quot;http://gtkwave.sourceforge.net&quot;&gt;GTKWave&lt;/a&gt; to view traces showing how your own
buttons bounce–just like the &lt;a href=&quot;/blog/2017/08/02/debounce-teaser.html&quot;&gt;traces I presented when we first
started&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;That’s it!  We can now grab two registers from our button press, and read
their results via &lt;code class=&quot;highlighter-rouge&quot;&gt;wbregs duration&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;wbregs bounces&lt;/code&gt;.  We can also reset
our count by writing to either of these registers via something like
&lt;code class=&quot;highlighter-rouge&quot;&gt;wbregs duration 0&lt;/code&gt;.  Using
&lt;a href=&quot;https://github.com/ZipCPU/debouncer/blob/master/sw/btnscope.cpp&quot;&gt;btnscope&lt;/a&gt;,
we can also read and create &lt;a href=&quot;/blog/2017/07/31/vcd.html&quot;&gt;VCD
files&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;scripts-to-access-the-design&quot;&gt;Scripts to access the design&lt;/h2&gt;

&lt;p&gt;After using this design over and over several times, I got tired of typing
the same commands over and over.  As a result, I wrote two scripts to
make things easier.&lt;/p&gt;

&lt;p&gt;The first script,
&lt;a href=&quot;https://github.com/ZipCPU/debouncer/blob/master/sw/getinfo.sh&quot;&gt;getinfo.sh&lt;/a&gt;,
simple reads the two registers and dumps them into a file record for later
analysis.  It also manually triggers the
&lt;a href=&quot;https://github.com/ZipCPU/wbscope&quot;&gt;wishbone scope&lt;/a&gt; in case it hadn’t
triggered yet.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span class=&quot;c&quot;&gt;#!/bin/bash&lt;/span&gt;

wbregs bounces  | tee -a btndata.txt
wbregs duration | tee -a btndata.txt
wbregs scope 0x88000020&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The second script,
&lt;a href=&quot;https://github.com/ZipCPU/debouncer/blob/master/sw/reset.sh&quot;&gt;reset.sh&lt;/a&gt;,
resets the logic for another button press.  Specifically, it resets the
scope (i.e. writes to it with the high data clear), and then attempts to
write to the bounce count.  As with any write to either of the
&lt;a href=&quot;https://github.com/ZipCPU/debouncer/blob/master/rtl/unbounced.v&quot;&gt;unbounced&lt;/a&gt;
registers, this will set the reset line to the
&lt;a href=&quot;https://github.com/ZipCPU/debouncer/blob/master/rtl/unbounced.v&quot;&gt;unbounced&lt;/a&gt;
module for one clock, and thus reset the counters.  Finally, just to be
certain that the two registers actually cleared as desired, they are read
after reset.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span class=&quot;c&quot;&gt;#!/bin/bash&lt;/span&gt;

wbregs scope 0x020 &lt;span class=&quot;c&quot;&gt;# Reset the scope&lt;/span&gt;
wbregs bounces 0   &lt;span class=&quot;c&quot;&gt;# Reset the unbounced code&lt;/span&gt;
wbregs bounces     &lt;span class=&quot;c&quot;&gt;# Verify that the two counts have returned to zero&lt;/span&gt;
wbregs duration&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;That’s it!  You now have all the information you need to either build and
measure your own debouncer, or to just measure the bounces on your own
device.  Further, all of the debouncing logic, design, and software files
have been placed into their own
&lt;a href=&quot;https://github.com/ZipCPU/debouncer&quot;&gt;GitHub repo&lt;/a&gt; for your own reference.&lt;/p&gt;

&lt;hr /&gt;&lt;p&gt;&lt;em&gt;As cold waters to a thirsty soul, so is good news from a far country.  (Prov 25:25)&lt;/em&gt;</description>
        <pubDate>Mon, 07 Aug 2017 00:00:00 -0400</pubDate>
        <link>http://zipcpu.com/blog/2017/08/07/bounce-dbgbus.html</link>
        <guid isPermaLink="true">http://zipcpu.com/blog/2017/08/07/bounce-dbgbus.html</guid>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>Measuring Contact Bounce</title>
        <description>&lt;p&gt;Buttons and switches on
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;’s
can be very useful to work with.  This extra
user I/O on a development board can make life easier when trying to direct
what is going on within it, or when trying to debug logic within the board.
The problem is that these forms of inputs often
“&lt;a href=&quot;https://en.wikipedia.org/wiki/Switch#Contact_bounce&quot;&gt;bounce&lt;/a&gt;”,
and produce multiple transitions when only one was directed.&lt;/p&gt;

&lt;p&gt;This problem is particularly problematic in the fact that it is difficult
to simulate hardware
&lt;a href=&quot;https://en.wikipedia.org/wiki/Switch#Contact_bounce&quot;&gt;bounces&lt;/a&gt;,
since they tend to be quite random.&lt;/p&gt;

&lt;p&gt;Our &lt;a href=&quot;/blog/2017/08/02/debounce-teaser.html&quot;&gt;first post&lt;/a&gt;
on this topic looked into how this sort of
&lt;a href=&quot;https://en.wikipedia.org/wiki/Switch#Contact_bounce&quot;&gt;bouncing&lt;/a&gt;
manifested.  It wasn’t pretty, as many buttons from several different
boards and even a keypad all demonstrated this problem.&lt;/p&gt;

&lt;p&gt;Our &lt;a href=&quot;/blog/2017/08/04/debouncing.html&quot;&gt;second post&lt;/a&gt;
discussed how to create the &lt;a href=&quot;https://github.com/ZipCPU/debouce/trunk/blob/master/rtl/debounce.html&quot;&gt;digital logic necessary to
debounce&lt;/a&gt;
a user input.&lt;/p&gt;

&lt;p&gt;Today, we’ll discuss how to measure the effect
&lt;a href=&quot;https://en.wikipedia.org/wiki/Switch#Contact_bounce&quot;&gt;bouncing&lt;/a&gt;
has on your input logic.&lt;/p&gt;

&lt;h1 id=&quot;measuring-the-reality-of-buttons-bouncing&quot;&gt;Measuring the Reality of Buttons: Bouncing&lt;/h1&gt;

&lt;p&gt;To try to capture this phenomena, let’s look at two things in particular.&lt;/p&gt;

&lt;p&gt;First, we’ll count the number of state transitions as in Fig 1 below.  In
the case of a button,
the first transition should be when the button is pressed, and the second
transition when the button is released.  In the case of a switch, only
one transition should ever take place.  It either of the two
&lt;a href=&quot;https://en.wikipedia.org/wiki/Switch#Contact_bounce&quot;&gt;bounces&lt;/a&gt;, we should be
able to tell.  In particular, the number of transitions would be
something other than two for a button or one for a switch.&lt;/p&gt;

&lt;table style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 1: Measuring Transitions&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/button-transitions.svg&quot; alt=&quot;Counting how many transitions a button creates&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;The second thing we we might wish to measure is how many clocks it takes
for the transitions to take place.  For example, with a button, this will
be the number of clocks from the first press to the last bounce on release,
as shown in Fig 2 below.  It won’t tell us as much about
&lt;a href=&quot;https://en.wikipedia.org/wiki/Switch#Contact_bounce&quot;&gt;bouncing&lt;/a&gt;, though, since
the bounces will have settled long before this measurement is concluded.
It might still tell us something about the nature and character of a button
press in general.  We can then use this information to understand how to
tune our &lt;a href=&quot;/blog/2017/08/04/debouncing.html&quot;&gt;debouncing
logic&lt;/a&gt;.&lt;/p&gt;

&lt;table style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 2: Measuring Button Press Duration&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/button-duration.svg&quot; alt=&quot;Counting a button press duration&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;h1 id=&quot;building-the-code-the-unbouncer&quot;&gt;Building the code: The Unbouncer&lt;/h1&gt;

&lt;p&gt;We’ll handle the first two measurements in a routine I’m going to call
&lt;a href=&quot;https://github.com/ZipCPU/debouncer/blog/master/rtl/unbounced.v&quot;&gt;unbounced&lt;/a&gt;.
This &lt;em&gt;unbouncer&lt;/em&gt; will help to tell us what has been going on within our
design.&lt;/p&gt;

&lt;p&gt;As we discussed during our discussion on
&lt;a href=&quot;/blog/2017/08/04/debouncing.html&quot;&gt;debouncing logic&lt;/a&gt;,
the first step of necessity is going to be to synchronize our inputs.
This synchronization is our approach to take the incoming button logic
signal, and make sure that any logic depending upon this information has
its &lt;a href=&quot;https://en.wikipedia.org/wiki/Flip-flop_(electronics)#Timing_considerations&quot;&gt;setup and
hold&lt;/a&gt;
requirements met.  It also helps us avoid any issues with
&lt;a href=&quot;https://en.wikipedia.org/wiki/Metastability_in_electronics&quot;&gt;metastability&lt;/a&gt;,
lest our logic act in an unpredictable (and incomprehensible) manner later.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
begin
	// Two clocks to synchronize asynchronous data
	q_in   &amp;lt;= i_in;
	r_in   &amp;lt;= q_in; // SYNCHRONIZED!
	// Keep track of last value, so we can find changes
	r_last &amp;lt;= r_in;
end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Once the inputs have been synchronized, we can then count the number of
times they change.  We’ll reset our count upon any reset request, but ever
afterwards we can just increment our counter on any changes:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	if (i_reset)
		o_transitions &amp;lt;= 0;
	else if (r_last != r_in)
		o_transitions &amp;lt;= o_transitions + 1&#39;b1;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;As we mentioned above, a button press should produce two transitions: one
when the button is pressed, and one when it is released.  Anything else is
an indication of
&lt;a href=&quot;https://en.wikipedia.org/wiki/Switch#Contact_bounce&quot;&gt;bouncing&lt;/a&gt;.
This simple counter can be used to test whether there was a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Switch#Contact_bounce&quot;&gt;bounce&lt;/a&gt; or not.&lt;/p&gt;

&lt;p&gt;The other thing we’re going to want to do is count how much time it takes
from the initial change (button press) until the final change (button release).
We’ll use the &lt;code class=&quot;highlighter-rouge&quot;&gt;triggered&lt;/code&gt; signal to determine when to run our counter, and
so run the counter any time after the button was &lt;code class=&quot;highlighter-rouge&quot;&gt;triggered&lt;/code&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	if (i_reset)
		triggered &amp;lt;= 1&#39;b0;
	else if (r_last != r_in)
		triggered &amp;lt;= 1&#39;b1;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Let’s just remember that we’re going to need to reset our logic
between events, so we can re-trigger on the next event.&lt;/p&gt;

&lt;p&gt;Next, we’ll keep track of the time since the last trigger:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	if (i_reset)
		counter &amp;lt;= 0;
	else if ((triggered)&amp;amp;&amp;amp;(!clock[31]))
		counter &amp;lt;= counter + 1&#39;b1;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Note that this “counter” measure will saturate once the top bit sets.  This
will give us about 21~seconds of measurement before losing track of what’s
going on (assuming a 100MHz clock).  That should be plenty for our purposes.&lt;/p&gt;

&lt;p&gt;Once we have this “time-since-event” above, we can then measure the maximum
amount of time that takes place between the initial button press and the
last change.  We’ll set this to zero upon an external reset, and ever
afterwards if our button input &lt;code class=&quot;highlighter-rouge&quot;&gt;r_in&lt;/code&gt; doesn’t match what it was once clock
ago, we’ll update our maximum clock duration value.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	if (i_reset)
		o_max_clock &amp;lt;= 0;
	else if (r_last != r_in)
		o_max_clock &amp;lt;= counter;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This &lt;code class=&quot;highlighter-rouge&quot;&gt;o_max_clock&lt;/code&gt; value will therefore capture the number of clocks between
a trigger and the last transition.&lt;/p&gt;

&lt;h2 id=&quot;coming-back-to-the-debug-bus&quot;&gt;Coming back to the Debug Bus&lt;/h2&gt;

&lt;p&gt;At this point, many students would turn to a
&lt;a href=&quot;https://store.digilentinc.com/pmod-ssd-seven-segment-display/&quot;&gt;7-segment display&lt;/a&gt;,
&lt;a href=&quot;https://store.digilentinc.com/pmod-8ld-eight-high-brightness-leds&quot;&gt;LED’s&lt;/a&gt;,
an &lt;a href=&quot;https://store.digilentinc.com/pmodclp-character-lcd-with-parallel-interface&quot;&gt;LCD&lt;/a&gt;,
or another &lt;a href=&quot;https://store.digilentinc.com/pmod-oledrgb-96-x-64-rgb-oled-display-with-16-bit-color-resolution/&quot;&gt;display output&lt;/a&gt;
to return these numbers.  This becomes a trap for
the student, though, because the problems associated with displaying these
values (particularly the &lt;a href=&quot;https://store.digilentinc.com/pmod-ssd-seven-segment-display/&quot;&gt;7-segment
display&lt;/a&gt;
or &lt;a href=&quot;https://store.digilentinc.com/pmodclp-character-lcd-with-parallel-interface&quot;&gt;LCD&lt;/a&gt;) can be just as complicated,
if not more so, than the simple button pressing logic we’ve presented above.
When this student then wants to isolate the bug he is getting to be either
the debouncing module or the display module, he can’t tell which is causing
the problem.&lt;/p&gt;

&lt;p&gt;Let’s avoid this mistake by integrating our
&lt;a href=&quot;https://github.com/ZipCPU/debouncer/trunk/rtl/deboucer.v&quot;&gt;debouncing&lt;/a&gt;
and &lt;a href=&quot;https://github.com/ZipCPU/debouncer/trunk/rtl/unbounced.v&quot;&gt;unbouncing&lt;/a&gt;
logic into a &lt;a href=&quot;https://github.com/ZipCPU/dbgbus&quot;&gt;debugging bus&lt;/a&gt;, such as
the &lt;a href=&quot;https://github.com/ZipCPU/dbgbus/tree/master/hexbus&quot;&gt;one we built together
earlier&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;This will be our next step: How to integrate our
&lt;a href=&quot;https://github.com/ZipCPU/debouncer/blob/master/rtl/debouncer.v&quot;&gt;debouncer&lt;/a&gt;
together with
&lt;a href=&quot;https://github.com/ZipCPU/debouncer/blob/master/rtl/unbounced.v&quot;&gt;today’s unbounced logic&lt;/a&gt;
and the &lt;a href=&quot;https://github.com/ZipCPU/dbgbus&quot;&gt;debugging bus&lt;/a&gt;, so that we can get
bounce information from within an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;.
Even better, if we include a
&lt;a href=&quot;http://github.com/ZipCPU/wbscope/blob/master/rtl/wbscopc.v&quot;&gt;compressed&lt;/a&gt;
&lt;a href=&quot;http://github.com/ZipCPU/wbscope&quot;&gt;wishbone scope&lt;/a&gt; into that project, you’ll
be able to generate your own button bouncing traces.&lt;/p&gt;

&lt;hr /&gt;&lt;p&gt;&lt;em&gt;And this is the fashion which thou shalt make it of: The length of the ark shall be three hundred cubits, the breadth of it fifty cubits, and the height of it thirty cubits. (Genesis 6:15)&lt;/em&gt;</description>
        <pubDate>Sat, 05 Aug 2017 00:00:00 -0400</pubDate>
        <link>http://zipcpu.com/blog/2017/08/05/bounce-metric.html</link>
        <guid isPermaLink="true">http://zipcpu.com/blog/2017/08/05/bounce-metric.html</guid>
        
        
        <category>blog</category>
        
      </item>
    
  </channel>
</rss>
