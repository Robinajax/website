<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>The ZipCPU by Gisselquist Technology</title>
    <description>The ZipCPU blog, featuring how to discussions of FPGA and CPU design. This site will be focused on Verilog solutions, using exclusively OpenSource IP products for FPGA design.
</description>
    <link>http://zipcpu.com/</link>
    <atom:link href="http://zipcpu.com/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Mon, 26 Jun 2017 09:05:47 -0400</pubDate>
    <lastBuildDate>Mon, 26 Jun 2017 09:05:47 -0400</lastBuildDate>
    <generator>Jekyll v3.0.1</generator>
    
      <item>
        <title>Simulating an FPGA through the debugging interface</title>
        <description>&lt;p&gt;Today, let’s put some things together.  We’ve already built a debugging bus
approach that we can use to interact with an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
and draw information out of it.
&lt;a href=&quot;/blog/2017/06/05/wb-bridge-overview.html&quot;&gt;[1]&lt;/a&gt;
&lt;a href=&quot;/blog/2017/06/08/simple-wb-master.html&quot;&gt;[2]&lt;/a&gt;
&lt;a href=&quot;/blog/2017/06/14/creating-words-from-bytes.html&quot;&gt;[3]&lt;/a&gt;
&lt;a href=&quot;/blog/2017/06/15/words-back-to-bytes.html&quot;&gt;[4]&lt;/a&gt;
&lt;a href=&quot;/blog/2017/06/16/adding-ints.html&quot;&gt;[5]&lt;/a&gt;
&lt;a href=&quot;/blog/2017/06/16/dbg-bus-forest.html&quot;&gt;[6]&lt;/a&gt;
&lt;a href=&quot;/blog/2017/06/19/debug-idles.html&quot;&gt;[7]&lt;/a&gt;
&lt;a href=&quot;/blog/2017/06/20/dbg-put-together.html&quot;&gt;[8]&lt;/a&gt;
&lt;a href=&quot;/blog/2017/06/22/simple-wb-interconnect.html&quot;&gt;[9]&lt;/a&gt;
We’ve also talked about 
&lt;a href=&quot;https://www.veripool.org/wiki/verilator&quot;&gt;Verilator&lt;/a&gt;
and what 
&lt;a href=&quot;https://www.veripool.org/wiki/verilator&quot;&gt;Verilator&lt;/a&gt;
allows us to do in simulation.&lt;/p&gt;

&lt;p&gt;Suppose we spend the time today to build a
&lt;a href=&quot;https://www.veripool.org/wiki/verilator&quot;&gt;Verilator&lt;/a&gt;
based simulation of our
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
design that can be controlled via this debugging
bus interface?&lt;/p&gt;

&lt;p&gt;While most of the difficult parts have already been accomplished, there are
still there are three basic components that we are going to need to work on to
do this.  The first is the
&lt;a href=&quot;https://github.com/ZipCPU/dbgbus/blob/master/bench/rtl/Makefile&quot;&gt;Makefile for our&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/dbgbus/blob/master/bench/rtl/testbus.v&quot;&gt;top level Verilog design&lt;/a&gt;.
The second is the &lt;a href=&quot;https://github.com/ZipCPU/dbgbus/blob/master/bench/cpp/testbus_tb.cpp&quot;&gt;C++ driver&lt;/a&gt; for our test bench.  We already discussed how to
generate a &lt;a href=&quot;https://github.com/ZipCPU/dbgbus/blob/master/bench/cpp/testb.h&quot;&gt;generic
driver&lt;/a&gt;
&lt;a href=&quot;/blog/2017/06/21/looking-at-verilator.html&quot;&gt;here&lt;/a&gt; and our
debugging philosophy in general
&lt;a href=&quot;/blog/2017/06/23/my-dbg-philosophy.html&quot;&gt;here&lt;/a&gt;,
so this discussion will only describe the differences between a &lt;a href=&quot;https://github.com/ZipCPU/dbgbus/blob/master/bench/cpp/testb.h&quot;&gt;generic test
bench driver&lt;/a&gt;
and the &lt;a href=&quot;https://github.com/ZipCPU/dbgbus/blob/master/bench/cpp/testbus_tb.cpp&quot;&gt;one we’re
building&lt;/a&gt;
for this project.
The last item we’ll need to figure out is how to build all the pieces
together–i.e. the final &lt;a href=&quot;https://github.com/ZipCPU/dbgbus/blob/master/bench/cpp/Makefile&quot;&gt;simulation
Makefile&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;When we finish, let’s run some tests on our “hardware” and see how it works!&lt;/p&gt;

&lt;h2 id=&quot;the-rtl-makefile&quot;&gt;The RTL Makefile&lt;/h2&gt;

&lt;p&gt;The RTL makefile needs to handle two things.  First, it needs to convert our
our &lt;a href=&quot;/blog/2017/06/22/simple-wb-interconnect.html&quot;&gt;Verilog test
bench&lt;/a&gt;
into a C++ class using
&lt;a href=&quot;https://www.veripool.org/wiki/verilator&quot;&gt;Verilator&lt;/a&gt;.  Then, the second step
directed by the RTL makefile will be to build that C++ class into a library
that can be linked with our &lt;a href=&quot;https://github.com/ZipCPU/dbgbus/blob/master/bench/cpp/testbus_tb.cpp&quot;&gt;C++
testbench&lt;/a&gt;
to create a fully functional simulation.&lt;/p&gt;

&lt;p&gt;We’ve &lt;a href=&quot;/blog/2017/06/21/looking-at-verilator.html&quot;&gt;already
discussed&lt;/a&gt;
the basics of how to run
&lt;a href=&quot;https://www.veripool.org/wiki/verilator&quot;&gt;Verilator&lt;/a&gt;.
In quick sum here, you can run
&lt;a href=&quot;https://www.veripool.org/wiki/verilator&quot;&gt;Verilator&lt;/a&gt; on a top level Verilog
file as in:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;verilate -Wall -trace -cc testbus.v&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Today, let’s just highlight some of the neat things that can be placed into
our rtl/Makefile in order to do it well.&lt;/p&gt;

&lt;p&gt;For example, I’d like to be able to use the test bench in the 
&lt;a href=&quot;https://github.com/ZipCPU/dbgbus&quot;&gt;dbgbus&lt;/a&gt; repository to test several
different debugging busses.  For this reason, I’m going to add,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-makefile&quot; data-lang=&quot;makefile&quot;&gt;&lt;span class=&quot;nv&quot;&gt;BUS&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt;&lt;span class=&quot;err&quot;&gt; hexbus&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;to the Makefile, and -y “../../$(BUS)/rtl” to the
&lt;a href=&quot;https://www.veripool.org/wiki/verilator&quot;&gt;Verilator&lt;/a&gt; command line.
That’ll cause Verilator to look for our sources in the
&lt;a href=&quot;https://github.com/ZipCPU/dbgbus/tree/master/hexbus/rtl&quot;&gt;hexbus&lt;/a&gt;
project subdirectory for any bus sources.&lt;/p&gt;

&lt;p&gt;Our top level Verilog file
&lt;a href=&quot;https://github.com/ZipCPU/dbgbus/blob/master/bench/rtl/testbench.v&quot;&gt;testbench.v&lt;/a&gt;
includes references to multiple files.  We’d like
to only re-run Verilator any time these files change.  Is there a way
to get dependency information for Verilog code in a fashion similar to
C++ code?  Yes, there is.  For this, we’ll add “–MMD” to the
&lt;a href=&quot;https://www.veripool.org/wiki/verilator&quot;&gt;Verilator&lt;/a&gt; command line,
and include the dependency file it generates at the end of
our Makefile:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-makefile&quot; data-lang=&quot;makefile&quot;&gt;&lt;span class=&quot;nv&quot;&gt;DEPS&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;wildcard &lt;span class=&quot;nv&quot;&gt;$(VDIRFB)&lt;/span&gt;/&lt;span class=&quot;se&quot;&gt;\*&lt;/span&gt;.d&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;err&quot;&gt;ifndeq&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;($(DEPS),)&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;$(DEPS)&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;endif&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;We’ll also set two more Makefile variables before we call Verilator.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-makefile&quot; data-lang=&quot;makefile&quot;&gt;&lt;span class=&quot;nv&quot;&gt;VERILATOR&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;?=&lt;/span&gt; verilator
&lt;span class=&quot;nv&quot;&gt;VFLAGS&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; -Wall --MMD -trace -y ../../&lt;span class=&quot;nv&quot;&gt;$(BUS)&lt;/span&gt;/rtl --Mdir &lt;span class=&quot;nv&quot;&gt;$(VDIRFB)&lt;/span&gt;&lt;span class=&quot;err&quot;&gt; -cc&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This will do two things.  First, it will allow you to run make with your
VERILATOR version defined in an environment variable.  Second, it will
simplify our Verilator call later.&lt;/p&gt;

&lt;p&gt;Now that we have these variables defined, we can create the “verilate”
target.  This target will build the C++ code.  Since the actual name of the
C++ code is somewhat obtuse, we’ll rename what we are building to “verilate”
and then forward that to what needs to be built.  Finally, we’ll actually
run our Verilator call–simplified by the VFLAGS we defined above.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-makefile&quot; data-lang=&quot;makefile&quot;&gt;&lt;span class=&quot;nl&quot;&gt;.PHONY&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;verilate&lt;/span&gt;
&lt;span class=&quot;nl&quot;&gt;verilate&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;$(VDIRFB)/Vtestbus.h&lt;/span&gt;
&lt;span class=&quot;nl&quot;&gt;$(VDIRFB)/Vtestbus.h&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
	&lt;span class=&quot;nv&quot;&gt;$(VERILATOR)&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$(VFLAGS)&lt;/span&gt;&lt;span class=&quot;err&quot;&gt; testbus.v&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The last step is to build the library.  This step is somewhat anticlimactic,
since
&lt;a href=&quot;https://www.veripool.org/wiki/verilator&quot;&gt;Verilator&lt;/a&gt;
did most of the work for us.  Building the library depends
upon the source files
&lt;a href=&quot;https://www.veripool.org/wiki/verilator&quot;&gt;Verilator&lt;/a&gt;
just built for us.  Making things even easier,
&lt;a href=&quot;https://www.veripool.org/wiki/verilator&quot;&gt;Verilator&lt;/a&gt;
just generated its own make file.  Hence,
we’ll just recursively call make on that make file to build all that’s left.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-makefile&quot; data-lang=&quot;makefile&quot;&gt;&lt;span class=&quot;nl&quot;&gt;.PHONY&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;library&lt;/span&gt;
&lt;span class=&quot;nl&quot;&gt;library&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;$(VDIRFB)/Vtestbus.h&lt;/span&gt;
	&lt;span class=&quot;nv&quot;&gt;$(SUBMAKE)&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$(VDIRFB)&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;/ -f Vtestbus.mk&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This recursively calls make in the $(VDIRFB) subdirectory, and it does so
with the “-f” argument specifying that it should use as its make file
$(VDIRFB)/Vtestbus.mk.&lt;/p&gt;

&lt;p&gt;That’s about it.  The &lt;a href=&quot;https://github.com/ZipCPU/dbgbus/blob/master/bench/rtl/Makefile&quot;&gt;RTL
Makefile&lt;/a&gt;
also contains a clean target, but in general that’s all that it takes to create
a Makefile that will run
&lt;a href=&quot;https://www.veripool.org/wiki/verilator&quot;&gt;Verilator&lt;/a&gt;
to build a simulatable library.&lt;/p&gt;

&lt;h2 id=&quot;the-cpp-testbench&quot;&gt;The CPP Testbench&lt;/h2&gt;

&lt;p&gt;As &lt;a href=&quot;/blog/2017/06/21/looking-at-verilator.html&quot;&gt;we discussed when
presenting&lt;/a&gt;
&lt;a href=&quot;https://www.veripool.org/wiki/verilator&quot;&gt;Verilator&lt;/a&gt;,
&lt;a href=&quot;https://www.veripool.org/wiki/verilator&quot;&gt;Verilator&lt;/a&gt;
needs a small C++ driver program to run the simulation.&lt;/p&gt;

&lt;p&gt;The driver we are going to use for this simulation, both the
&lt;a href=&quot;https://github.com/ZipCPU/dbgbus/blob/master/bench/cpp/testb.h&quot;&gt;generic one&lt;/a&gt;
and the &lt;a href=&quot;https://github.com/ZipCPU/dbgbus/blob/master/bench/cpp/testbus_tb.cpp&quot;&gt;specific simulation
one&lt;/a&gt;,
should look very similar to the ones we built during our &lt;a href=&quot;/blog/2017/06/21/looking-at-verilator.html&quot;&gt;prior
discussion&lt;/a&gt;.
Here, we’ll look at two differences.&lt;/p&gt;

&lt;p&gt;The first is that we have made the termination criteria a touch more
general than before.  For this test bench, we’ll terminate our simulation
either whenever the $final Verilog instruction is reached (which we didn’t
use in our Verilog code), or whenever the &lt;strong&gt;o_halt&lt;/strong&gt; GPIO is asserted.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;n&quot;&gt;bool&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;TESTBUS_TB&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;done&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_done&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Verilated&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;gotFinish&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;m_done&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_core&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;o_halt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;m_done&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m_done&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;That’ll allow us to control things from within the simulation (such as by
CPU software instruction) if we’d like.&lt;/p&gt;

&lt;p&gt;The other changes are the necessary parts of putting a UART interface
onto this test bench.  We’ll do that using the
&lt;a href=&quot;https://github.com/ZipCPU/dbgbus/blob/master/bench/cpp/uartsim.cpp&quot;&gt;uartsim&lt;/a&gt;
simulator found in the
&lt;a href=&quot;https://github.com/ZipCPU/wbuart32&quot;&gt;wbuart&lt;/a&gt; repository.  There just a couple
of steps there.&lt;/p&gt;

&lt;p&gt;First, we initialize the UART component module with a zero, indicating that
we want the UART to interact with us using stdin/stdout.  We’ll adjust that
later so that we can interact over TCP/IP.&lt;/p&gt;

&lt;p&gt;Second, the UART simulator needs to know the baud rate we are using to
communicate with.  This needs to be the same as the UART configuration
parameter found within our
&lt;a href=&quot;https://github.com/ZipCPU/dbgbus/blob/master/bench/rtl/testbus.v&quot;&gt;testbus.v&lt;/a&gt;.
If you wish to run this on your hardware, you may need to
adjust the parameter in the
&lt;a href=&quot;https://github.com/ZipCPU/dbgbus/blob/master/bench/rtl/testbus.v&quot;&gt;testbus.v&lt;/a&gt;
top level file, as well as in this file–to make sure you are communicating
at a common baud rate.  Otherwise, we’ll just assume that one baud is 25 clock
ticks.  You can check the &lt;a href=&quot;https://github.com/ZipCPU/wbuart32/blob/master/doc/spec.pdf&quot;&gt;UART component specification
document&lt;/a&gt; for more
information on how to understand this setup value.&lt;/p&gt;

&lt;p&gt;That’s it for setting up the C++ portion of the simulation!  All that’s left
is to build it and test it.&lt;/p&gt;

&lt;h2 id=&quot;the-cpp-makefile&quot;&gt;The CPP Makefile&lt;/h2&gt;

&lt;p&gt;For building our simulation executable, we return to the Makefile necessary
to do it.  What we want to do is really quite simple.  We’d like to issue
a command such as,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-makefile&quot; data-lang=&quot;makefile&quot;&gt;&lt;span class=&quot;nl&quot;&gt;testbus_tb&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
	&lt;span class=&quot;nv&quot;&gt;$(CXX)&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$(CFLAGS)&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$(OBJECTS)&lt;/span&gt;&lt;span class=&quot;err&quot;&gt; -o $@&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;where $(OBJECTS) are the object files we need, and $(CFLAGS) are whatever
flags we wish to build with.  Our final solution will be just about that simple.&lt;/p&gt;

&lt;p&gt;The questions remaining are, what flags, what objects, and how do we build
those objects.  The
&lt;a href=&quot;https://github.com/ZipCPU/dbgbus/blob/master/bench/cpp/Makefile&quot;&gt;Makefile&lt;/a&gt;
itself includes dependency generation, but we can leave that as a topic for
another day or perhaps even for another blog.&lt;/p&gt;

&lt;p&gt;For the first question, which flags shall we use, its in many ways up to you.
We’ll use the “-Og” flag to turn on the optimizer, although any optimizations
should really also be a flag to
&lt;a href=&quot;https://www.veripool.org/wiki/verilator&quot;&gt;Verilator&lt;/a&gt;
as well.  Here, we’ll also use the 
“-Wall” flag as well to see if we can encourage g++ to find any bugs in our
code.  We’ll also need to tell
the C++ compiler to look for the include files found both in our RTL/obj_dir
directory, as well as those found in the
&lt;a href=&quot;https://www.veripool.org/wiki/verilator&quot;&gt;Verilator&lt;/a&gt;
root include directory.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-makefile&quot; data-lang=&quot;makefile&quot;&gt;&lt;span class=&quot;c&quot;&gt;# Show make how to find our compiled verilated output
&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;RTLD&lt;/span&gt;  &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; ../rtl
&lt;span class=&quot;nv&quot;&gt;VOBJDR&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$(RTLD)&lt;/span&gt;/obj_dir
&lt;span class=&quot;c&quot;&gt;# Show make how to find Verilators support files
&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;VROOT&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$(VERILATOR_ROOT)&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;VINCD&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$(VROOT)&lt;/span&gt;/include
&lt;span class=&quot;c&quot;&gt;# Generate a full include list
&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;INCS&lt;/span&gt;  &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; -I&lt;span class=&quot;nv&quot;&gt;$(VINCD)&lt;/span&gt; -I&lt;span class=&quot;nv&quot;&gt;$(VOBJDR)&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;# Build our C-Flags
&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;CFLAGS&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; -Og -g -Wall &lt;span class=&quot;nv&quot;&gt;$(INCS)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;You might also wish to set the VERILATOR_ROOT directory.  On my system, this
is found in “/usr/share/verilator”, but that’s not the same among all systems.
At the encouragement of others who’ve tried my code, I’ve switched to:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-makefile&quot; data-lang=&quot;makefile&quot;&gt;&lt;span class=&quot;nv&quot;&gt;VERILATOR_ROOT&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;?=&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;$(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;shell&lt;/span&gt; bash -c &lt;span class=&quot;s1&quot;&gt;&#39;verilator -V|grep VERILATOR_ROOT | head -1 | sed -e &quot; s/^.*=\s*//&quot;&#39;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This will call a shell script, which will run “verilator -V” (try it!).  The
output is then searched for VERILATOR_ROOT.  Since
&lt;a href=&quot;https://www.veripool.org/wiki/verilator&quot;&gt;Verilator&lt;/a&gt;
produces two lines with this value within it, we
grab the first one and use it.  Further, we’ll only do so if VERILATOR_ROOT
isn’t already set–perhaps from a parent make file (that’s what the ?= does).&lt;/p&gt;

&lt;p&gt;The next question is, what objects do we need to include?  First, there’s
the obvious one, we’ll need to include testbus_tb.o.  We’ll also want to 
include the
&lt;a href=&quot;https://www.veripool.org/wiki/verilator&quot;&gt;Verilator&lt;/a&gt;
class definition library from Vtestbus__ALL.a.
Going one step further, we’ll want to include our &lt;a href=&quot;https://github.com/ZipCPU/dbgbus/blob/master/bench/cpp/uartsim.cpp&quot;&gt;UART
simulation&lt;/a&gt;
object file, uartsim.o.  Finally, we’ll want to include the tw
&lt;a href=&quot;https://www.veripool.org/wiki/verilator&quot;&gt;Verilator&lt;/a&gt;
files, verilated.cpp and verilated_vcd_c.cpp once compiled to object files.
This is as easy as:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-makefile&quot; data-lang=&quot;makefile&quot;&gt;&lt;span class=&quot;nv&quot;&gt;VSRCRAW&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; verilated.cpp verilated_vcd_c.cpp
&lt;span class=&quot;nv&quot;&gt;VSRC&lt;/span&gt;    &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;addprefix &lt;span class=&quot;nv&quot;&gt;$(VINCD)&lt;/span&gt;/,&lt;span class=&quot;nv&quot;&gt;$(VSRCRAW)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;VOBJ&lt;/span&gt;    &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;addprefix &lt;span class=&quot;nv&quot;&gt;$(OBJDIR)&lt;/span&gt;/,&lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;subst .cpp,.o,&lt;span class=&quot;nv&quot;&gt;$(VSRCRAW)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;SOURCES&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; testbus_tb.cpp uartsim.cpp
&lt;span class=&quot;nv&quot;&gt;OBJECTS&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;addprefix &lt;span class=&quot;nv&quot;&gt;$(OBJDIR)&lt;/span&gt;/,&lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;subst .cpp,.o,&lt;span class=&quot;nv&quot;&gt;$(SOURCES)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$(VOBJ)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;To build the sources into object files, we’ll add two generic build rules.
The first will apply for the objects built from this directory.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-makefile&quot; data-lang=&quot;makefile&quot;&gt;&lt;span class=&quot;nl&quot;&gt;$(OBJDIR)/%.o&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;%.cpp&lt;/span&gt;
	&lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;mk-objdir&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;nv&quot;&gt;$(CXX)&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$(CFLAGS)&lt;/span&gt;&lt;span class=&quot;err&quot;&gt; -c $&amp;lt; -o $@&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;If you are not as familiar with make files, the first line specifies a generic
pattern: files within the current directory and ending with .cpp can be
turned into object files in the $(OBJDIR)/ directory having the same name but
the .o suffix instead.&lt;/p&gt;

&lt;p&gt;The second line, $(mk-objdir), calls a function
that we’ll define elsewhere in our makefile that builds our object file
directory, $(OBJDIR).  While it’s not necessary to place your build products
in a separate object file directory, I find that it both cleans up the
main source directory, and it also provides options later in case you need
to build on multiple systems.&lt;/p&gt;

&lt;p&gt;The third line is used to call your C++ compiler,
to give it the CFLAGS variable, and to ask it to produce an object file (-c)
rather than a completed program.  Other make file variables include the name
of the source file that tripped the rule, $&amp;lt;, and tell it to place the output
(-o) into $@–the result the rule is supposed to produce.&lt;/p&gt;

&lt;p&gt;We repeat this for the
&lt;a href=&quot;https://www.veripool.org/wiki/verilator&quot;&gt;Verilator&lt;/a&gt;
source files in the
&lt;a href=&quot;https://www.veripool.org/wiki/verilator&quot;&gt;Verilator&lt;/a&gt;
include directory,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-makefile&quot; data-lang=&quot;makefile&quot;&gt;&lt;span class=&quot;nl&quot;&gt;$(OBJDIR)/%.o&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;$(VIND)/%.cpp&lt;/span&gt;
	&lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;mk-objdir&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;nv&quot;&gt;$(CXX)&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$(CFLAGS)&lt;/span&gt;&lt;span class=&quot;err&quot;&gt; -c $&amp;lt; -o $@&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Since we’ve already presented the final rule, that’s about all there is to
the makefile necessary to generate this simulation.&lt;/p&gt;

&lt;p&gt;Should you need to build a make file of your own, you might wish to start
from this one and just change the names of the files necessary to run your
simulation.&lt;/p&gt;

&lt;h2 id=&quot;simple-tests&quot;&gt;Simple Tests&lt;/h2&gt;

&lt;p&gt;We now have a
&lt;a href=&quot;https://github.com/ZipCPU/dbgbus/blob/master/bench/rtl/Makefile&quot;&gt;Makefile&lt;/a&gt; in
&lt;a href=&quot;https://github.com/ZipCPU/dbgbus/tree/master/bench/rtl&quot;&gt;bench/rtl&lt;/a&gt;
that will compile our debug bus and a test wishbone interconnect into
a C++ class.  We also have a
&lt;a href=&quot;https://github.com/ZipCPU/dbgbus/blob/master/bench/cpp/Makefile&quot;&gt;Makefile&lt;/a&gt; in
&lt;a href=&quot;https://github.com/ZipCPU/dbgbus/tree/master/bench/cpp&quot;&gt;bench/cpp&lt;/a&gt; that can
then be used to build the project into an executable.  Shall we run our
executable?&lt;/p&gt;

&lt;p&gt;Let’s try it out.  The only caution before starting is that this program as
written will generate megabytes of trace information very quickly.  That trace
file, if you aren’t careful, may very well fill up your hard drive.  So, don’t
leave the simulator running at the end of each test.&lt;/p&gt;

&lt;p&gt;With all that said, let’s run the program:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;./testbus_tb&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Now that it’s running, it’s waiting for an input.  So, let’s
try reading our constant address.  If you type,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;A2040R&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;your design will return “A00002040R20170622”.  The first number, A00002040,
indicates the address that we just changed the interface to.
The second number (starting with the R)
indicates the value we just read: 0x20170622.&lt;/p&gt;

&lt;p&gt;Let’s try another.  Let’s try reading that counter, and let’s do it
a couple of times.  The counter itself is at address 0x204c.  However, if you
remember from &lt;a href=&quot;/blog/2017/06/08/simple-wb-master.html&quot;&gt;when we built our simple bus
master&lt;/a&gt;
we chose to use the LSB as indication of whether or not the address should
increment between reads.  By setting it to zero, we’ll keep the address
constant between subsequent read commands.  For this reason, we can issue
an address command, followed by several read commands and they’ll all read
from the same address:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;A204dR
R
R
R&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Make sure you type the newlines between the R’s!  This bus isn’t yet robust
enough to handle more than one command given to it at once.  (It needs FIFO
support.)  Still, I get the response:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;A0000204dR000485b4
0005234b
0005cbf1
00068df3&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Not bad.  Looks like we’ve got something working.&lt;/p&gt;

&lt;p&gt;Can we trigger an interrupt?  You may remember that we had an interrupt
tied to the LSB of address 0x2050.  So, let’s write to 0x2051 to trigger,
clear, and then trigger this interrupt again
I’ll prefix the commands I typed with a “&amp;lt; “, so you can see the responses
in line.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&amp;lt; A2051RW1
A00002051R00000000K00000000I
&amp;lt; W0
K00000000
&amp;lt; W1
I
K00000000
&amp;lt; W0
K00000000&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Did you see the “I” response?  That tells us we triggered our interrupt
as desired.&lt;/p&gt;

&lt;p&gt;How about the
&lt;a href=&quot;https://github.com/ZipCPU/dbgbus/blob/master/bench/rtl/wbscope.v&quot;&gt;scope&lt;/a&gt;
we put &lt;a href=&quot;https://github.com/ZipCPU/dbgbus/blob/master/bench/rtl/testbus.v&quot;&gt;on
board&lt;/a&gt;?  Can
we trigger the scope?  Let’s first
read the scope’s control register, then write to a &lt;a href=&quot;https://github.com/ZipCPU/dbgbus/master/bench/rtl/memdev.v&quot;&gt;block
RAM&lt;/a&gt; memory address
(triggering the scope), and then read the
&lt;a href=&quot;https://github.com/ZipCPU/dbgbus/blob/master/bench/rtl/wbscope.v&quot;&gt;scope&lt;/a&gt;’s
control register again:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&amp;lt; A02080R
A00002080R12a001fc
&amp;lt; A4000Wdeadbeef
A00004000K00000000I
&amp;lt; A2080R
Z
A00002080R72a001fc
&amp;lt; A4000R
A00004000Rdeadbeef&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The first command (A02080R) reads from the scopes control register.  If you
look up 0x12a001fc in the &lt;a href=&quot;https://github.com/ZipCPU/wbscope/blob/master/doc/spec.pdf&quot;&gt;wishbone scope specification
document&lt;/a&gt;, you’ll
learn several things about the scope’s state as given by this number.  First,
the high order nibble of ‘1’ indicates that the scope is primed but hasn’t
triggered yet.  Second, the ‘2’ indicates that the DATA pointer within the
scope is set to the beginning of the scope’s memory (where we’d expect it). 
Third, the ‘a’ indicates that the scope has been configured for 2^10 samples of
memory.  Last, the ending 0x01fc tells us that the scope will wait 0x01fc
samples after the trigger, placing our event roughly within the center of
its collection window.&lt;/p&gt;

&lt;p&gt;The second command, A4000Wdeadbeef, writes 0xdeadbeef to the first location
in block RAM (address 0x4000).  Since we are also using wishbone accesses to
that location to
trigger our scope, an “I” is also returned together with the acknowledgement
(‘K’).  Incidentally, we’ll need to reset the scope in order for this interrupt
to clear, so don’t expect any more interrupt indications for a while.&lt;/p&gt;

&lt;p&gt;The third command, “A2080R” reads from the scope control register again.
It now has a value of 0x72a001fc.  Looking at the top nibble, the ‘7’
indicates that the scope has not only been triggered, but that it has also
stopped collecting.&lt;/p&gt;

&lt;p&gt;Shall we read from the scope as well?  Let’s read from address 0x2084, with
the increment bit set to prohibit address increments between reads (i.e.,
addres 0x2085):&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&amp;lt; A2080R
A00002080R12a001fc
&amp;lt; A4000Wdeadbeef
A00004000K00000000I
&amp;lt; A2080R
A00002080R72a001fc
&amp;lt; A2085R
A00002085R001b6c00
&amp;lt; R
R001b6c00
&amp;lt; R
R001b6c00
&amp;lt; R
R001b6c00
&amp;lt; R
R001b6c00&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;We’ve now read our first several values out of the scope!  All three values
were 0x1b6c00.  Sure, there’s more interesting information within the scope,
but we’ll have to dig further into the scope to get it.  The big problem
with getting there, though, is that typing 1024 “R”s to get through all the
values in this scope is going to get old &lt;em&gt;real fast&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;We’ve also found some annoying features in the protocol as well.  For example,
there’s no reason why a write acknowledgement should produce 8-zeros,
or why an address response to address 0x2080 should produce the extra four
leading zeros.  Another &lt;em&gt;really&lt;/em&gt; annoying feature of not having a FIFO is that
we can’t cut/copy/paste into our interface–that would be a nice feature. 
Still, having valid answers is a good first start!&lt;/p&gt;

&lt;p&gt;You can also look in your directory and find a trace.vcd file containing the
trace information we made.  Feel free to run “gtkwave trace.vcd” and explore
what took place after each interaction.&lt;/p&gt;

&lt;h2 id=&quot;next-in-the-series&quot;&gt;Next in the Series&lt;/h2&gt;

&lt;p&gt;As with many FPGA capabilities, building it just the way you want it can take
several iterations.  We’ve got some more iterations yet left in this design.&lt;/p&gt;

&lt;p&gt;We’re still missing two final capabilities before we put this series to rest
and move on to other topics.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;We’d like to have a &lt;a href=&quot;/blog/2017/06/16/dbg-bus-forest.html&quot;&gt;software
interface&lt;/a&gt;
to debug both our FPGA and our simulation.&lt;/p&gt;

    &lt;p&gt;If you haven’t noticed, typing hexadecimal commands and values, and
interpreting hexadecimal results isn’t very intuitive.  Indeed, it’s
out right &lt;em&gt;cryptic&lt;/em&gt;!  We’ll fix this by switching from this by-hand interface
to a software interface.&lt;/p&gt;

    &lt;p&gt;That software interface has been written, though not yet posted at this time.
(Any &lt;a href=&quot;https://www.patreon.com/ZipCPU&quot;&gt;Patreon supporters&lt;/a&gt; want to try an
early version?) You’ll find it a whole lot easier to interact with large
amounts of data over a software driven interface.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;We want to be able to debug our simulation just like we would debug the
hardware, by using a &lt;a href=&quot;/blog/why-network-debugging&quot;&gt;network enabled
interface&lt;/a&gt;.  The
&lt;a href=&quot;https://github.com/ZipCPU/dbgbus/blob/master/bench/cpp/uartsim.cpp&quot;&gt;UART simulator&lt;/a&gt; has this capability within it already.  Our hardware does not.
Hence, we’d like to take a program like the
&lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/sw/host/netuart.cpp&quot;&gt;netuart&lt;/a&gt;
from the &lt;a href=&quot;https://github.com/ZipCPU/zbasic&quot;&gt;basic ZipCPU&lt;/a&gt; repository and
incorporate it into this debugging bus.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;It may now be time to go back and consider the difference between the
&lt;a href=&quot;/blog/2017/06/02/design-process.html&quot;&gt;student’s design process and the expert’s design
process&lt;/a&gt;.  Consider
how much work it has taken to build this design, and then consider the typical
student project.  The difference helps to illustrate why what we are building
is a tool that a professional might use.  The reason is simply that building it
takes time.  In the case of the professional, the time is spent once, and the
tool used many times over.  In the case of the student who is trying to build
a design from start to finish within a semester, the student often doesn’t
realize the value of the tool he doesn’t have.&lt;/p&gt;
</description>
        <pubDate>Mon, 26 Jun 2017 00:00:00 -0400</pubDate>
        <link>http://zipcpu.com/blog/2017/06/26/dbgbus-verilator.html</link>
        <guid isPermaLink="true">http://zipcpu.com/blog/2017/06/26/dbgbus-verilator.html</guid>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>My own FPGA debugging philosophy</title>
        <description>&lt;p&gt;Many individuals have read my previous posts and have wondered what my debugging
philosophy actually is.  They’ve asked me how I would recommend debugging
a design.  This post attempts to outline the general approaches
I used to debug &lt;a href=&quot;https://github.com/ZipCPU&quot;&gt;my own FPGA designs&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;In quick sum:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Simulation&lt;/strong&gt;: I recommend using a simulator that allows allows you to
simulate all of the external components of your design in a fully
integrated fashion&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Hardware testing&lt;/strong&gt;: I recommend including some form of
integrated logic analyzer or scope within your design when you move
into hardware.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;While I tend to use open source products, I have nothing against commercial
products that will help a designer accomplish his purpose.&lt;/p&gt;

&lt;p&gt;That said, let’s take a look at my own debugging philosophy in more detail.&lt;/p&gt;

&lt;h2 id=&quot;simulation&quot;&gt;Simulation&lt;/h2&gt;

&lt;p&gt;Because implementing logic on an FPGA can take so long to do, I am a firm
believer in using a simulation.&lt;/p&gt;

&lt;table style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 1: Simulation&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/dbg-by-sim.svg&quot; alt=&quot;Parts of Debugging an FPGA via Simulation&quot; width=&quot;360&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;FPGA’s often need to communicate with external devices, though, and those
external devices need to respond to the simulated logic and the test designer
as though they were present in hardware.&lt;/p&gt;

&lt;p&gt;I recommend, therefore, for those components of an FPGA design that need to
interact with an external device, that the simulation facility provide an
external component simulator and interface validator &lt;em&gt;for each external
component&lt;/em&gt; the digital logic needs to interact with.  By component simulator,
I mean something that creates inputs and treats outputs like the real hardware
component would.  By interface validator, I mean something that will quickly
draw the developer’s attention to any violations in the interface protocol.&lt;/p&gt;

&lt;p&gt;This means that the minimum capability I would require of any simulation
capability is the ability to simulate &lt;em&gt;all&lt;/em&gt; of the external components on my design.
Were this a commercial capability, I would want to be able to integrate
my own external component simulations as well as any external component
simulations produced by multiple (possibly competing) vendors.&lt;/p&gt;

&lt;table style=&quot;float: left; padding: 15px&quot;&gt;&lt;caption&gt;Fig 2: Integrated Simulation&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/dbg-by-integrated-sim.svg&quot; alt=&quot;Integrating Sim Components into a Fullblown Simulator&quot; width=&quot;360&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;This minimum capability would allow me to simulate my entire, integrated design,
as shown in Fig 2.  That is, I should be able to integrate all of these
component simulators into an integrated design simulation.&lt;/p&gt;

&lt;p&gt;Does your design have a &lt;em&gt;UART&lt;/em&gt; within it?  Your simulation should then be able
to &lt;a href=&quot;https://github.com/ZipCPU/wbuart32/blob/master/bench/cpp/uartsim.cpp&quot;&gt;simulate a
UART&lt;/a&gt;. 
Your design should be able to create a UART waveform, and your external
component simulator should be able to process it and perhaps place the result
on your simulation terminal.  You should be able to type into that simulation
terminal anything and have it sent to your external UART simulator. 
The external component simulator should then translate anything it reads, and
send it into your design as a proper UART signal.&lt;/p&gt;

&lt;p&gt;Does your design have a flash component within it?  You should be able to start
up, erase, program, and read from that flash as a &lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/sim/verilated/qspiflashsim.cpp&quot;&gt;part of your
simulation&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Does your design include &lt;em&gt;buttons or switches&lt;/em&gt;?  You should be able to simulate
buttons and switches, and your simulations should be good enough to test any
debouncing capability you might have.&lt;/p&gt;

&lt;p&gt;Does your design have an &lt;em&gt;SD card&lt;/em&gt; within it?  You should be able to
communicate with the &lt;a href=&quot;https://github.com/ZipCPU/sdspi/blob/master/sdspisim.cpp&quot;&gt;simulated SD card&lt;/a&gt;, and even have a simulation that can match the
SD card you wish to use in your design.&lt;/p&gt;

&lt;p&gt;Does your design have a &lt;em&gt;VGA&lt;/em&gt; within it?  Your simulation should then be able
decode your VGA output, to prove that you are producing the correct
synchronization signals, and then to draw the pixels to the screen in a way
that you can verify that your VGA code works.&lt;/p&gt;

&lt;p&gt;Does your design have an &lt;em&gt;EDID component&lt;/em&gt; to it?  Your simulator should &lt;a href=&quot;https://github.com/ZipCPU/wbi2c/blob/master/bench/cpp/i2csim.cpp&quot;&gt;be
able to communicate EDID
information&lt;/a&gt;
to your design over a proper I2C port.&lt;/p&gt;

&lt;p&gt;Does your design have &lt;em&gt;(DDRx) SDRAM&lt;/em&gt; within it?  Your simulator should be able
to match the &lt;a href=&quot;https://github.com/ZipCPU/openarty/blob/master/sim/verilated/memsim.cpp&quot;&gt;SDRAM’s
capability&lt;/a&gt; in a clock for clock fashion.  You might even wish to
debug any &lt;a href=&quot;http://opencores.org/project,wbddr3&quot;&gt;DDR3 SDRAM in detail&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Does your design have a &lt;em&gt;CPU&lt;/em&gt; within it?  Your simulator should be able to
simulate the CPU, it’s booting process (using flash, if that’s what you have),
and it should allow you to see what’s going inside the CPU as it boots.
You should be able to trace the instructions your CPU executes, together with
any logic used within your design.
Do you want to be able to run a program on your CPU?  You should be able to
do that within the CPU, and it should be able to interact with its environment
in a manner similar to its real environment.&lt;/p&gt;

&lt;p&gt;This is my philosophy on simulation.&lt;/p&gt;

&lt;p&gt;As you can see, I am a firm believer in simulating your &lt;em&gt;whole design&lt;/em&gt;, not
just the components.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.veripool.org/wiki/verilator/&quot;&gt;Verilator&lt;/a&gt; meets these requirements.
Do you know of any other capability that can?  Please feel free to comment
about it in the discussion at the end of this post.&lt;/p&gt;

&lt;h2 id=&quot;hardware-testing&quot;&gt;Hardware Testing&lt;/h2&gt;

&lt;p&gt;I’m also not so naive as to believe that a design will work the first time it’s
placed in an actual FPGA.  For this reason, I am a firm believer in testing
on the actual hardware as well.&lt;/p&gt;

&lt;table style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 3: Hardware in the Loop Testing&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/dbg-by-hitl.svg&quot; alt=&quot;Parts of Debugging an FPGA via Simulation&quot; width=&quot;360&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Hardware testing includes both component testing (externally
directed, often without the CPU), as well as integrated design testing.&lt;/p&gt;

&lt;p&gt;Using your hardware, you should be able to test components by:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Issuing individual commands to them, and verifying that individual
interactions work&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Then issuing more complex strings of commands&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;In both cases, you should be able to start from a (roughly) known condition,
command the hardware to begin the test, and then be able to measure the
results of the test.  Doing this necessitates some form of internal logic
analyzer, such as the &lt;a href=&quot;https://github.com/ZipCPU/wbscope&quot;&gt;wishbone scope&lt;/a&gt; that
I use.&lt;/p&gt;

&lt;p&gt;I like to issue commands over some form of debugging bus, such as the
&lt;a href=&quot;https://github.com/ZipCPU/tree/master/hexbus/rtl&quot;&gt;hexbus debugging bus&lt;/a&gt;
we’ve &lt;a href=&quot;/topics.html&quot;&gt;just built together&lt;/a&gt;.  This allows me
to command various tests, and to read information and status back out of the
FPGA.  If you have a CPU on board, such as the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;, you may wish to
command your tests in a faster and more coordinated fashion from software.&lt;/p&gt;

&lt;p&gt;Trace data itself can be drawn from something as simple as your own
&lt;a href=&quot;/blog/2017/06/08/simple-scope.html&quot;&gt;user designed scope&lt;/a&gt;, or
&lt;a href=&quot;/about/gisselquist-technology.html&quot;&gt;Gisselquist Technology&lt;/a&gt;’s
&lt;a href=&quot;https://github.com/ZipCPU/wbscope&quot;&gt;wishbone scope&lt;/a&gt;.  We’ll be discussing
in the near future how you can add the capability to create a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Value_change_dump&quot;&gt;VCD&lt;/a&gt; file to your scope.
That will finish off the discussion on how to build your own debugging
facility.&lt;/p&gt;

&lt;p&gt;Commercial products exist that can record trace information from within your
chip.  &lt;a href=&quot;https://xilinx.com&quot;&gt;Xilinx&lt;/a&gt;, for example, includes their
&lt;a href=&quot;https://www.xilinx.com/support/documentation/ip_documentation/ila/v6_2/pg172-ila.pdf&quot;&gt;Integrated Logic Analyzer (ILA)&lt;/a&gt;
as part of the &lt;a href=&quot;https://www.xilinx.com/products/design-tools/vivado.html&quot;&gt;Vivado Design
Suite&lt;/a&gt;.
You’ll &lt;a href=&quot;https://forums.xilinx.com/t5/Installation-and-Licensing/WebPACK-and-ILA/td-p/558110&quot;&gt;need more than the free webpack
license&lt;/a&gt;,
though, in order to use it.  Given how easy such an analyzer is to build,
it’s probably not work the $3k necessary to pay for a full
&lt;a href=&quot;https://www.xilinx.com/products/design-tools/vivado.html&quot;&gt;Design Suite&lt;/a&gt;
license just to use this capability.&lt;/p&gt;

&lt;p&gt;One of the benefits of rolling your own, is that integrating your own logic
analyzer into your own logic can be done with your favorite interface.
For example, I’ve often used the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt; to trigger the scope or to examine
the outputs of it.  Further, unlike a commercial scope which may be restricted
to using the JTAG for control and output, I can get the outputs via whatever
debugging bus I’m already using.&lt;/p&gt;

&lt;h2 id=&quot;your-own-choices&quot;&gt;Your own choices&lt;/h2&gt;

&lt;p&gt;These two components outline the philosophy I use to debug my own FPGA
designs.&lt;/p&gt;

&lt;p&gt;I am a firm believer in simulation.&lt;/p&gt;

&lt;p&gt;I grew up testing on the hardware itself, and see no problems with it &lt;em&gt;as long
as you can get an internal trace from your hardware&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Do you have a different debugging philosophy?  Do you know of other or better
tools?  Feel free to post and discuss them below.&lt;/p&gt;
</description>
        <pubDate>Fri, 23 Jun 2017 00:00:00 -0400</pubDate>
        <link>http://zipcpu.com/blog/2017/06/23/my-dbg-philosophy.html</link>
        <guid isPermaLink="true">http://zipcpu.com/blog/2017/06/23/my-dbg-philosophy.html</guid>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>Building a very simple wishbone interconnect</title>
        <description>&lt;p&gt;Want to build a scope?  Seriously!  Want to turn your FPGA into a scope that
can measure anything internal to your logic, and then make that information
available to you upon request?  Even better, you could use this scope to
capture samples from an external analog to digital converter if you wanted to.&lt;/p&gt;

&lt;p&gt;It’s time to do build the Verilog to do it!&lt;/p&gt;

&lt;table style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 1: WB-UART Overview&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/wb-uart-smpl-2.svg&quot; alt=&quot;Block Diagram of a Simpler Wishbone to UART converter&quot; width=&quot;360&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Ok, here’s where we are at in this process: We now have all of the components
necessary to build a debugging bus interface.  We’ve now built &lt;em&gt;all&lt;/em&gt; of the
components outlined in Fig 1 to the right.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;We’ve presented an &lt;a href=&quot;/blog/2017/06/05/wb-bridge-overview.html&quot;&gt;overview of a UART to wishbone
bridge&lt;/a&gt;, that
can be used for debugging.  This overview presented not only how to
build such a bridge, but also showed examples from a working one that I use.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;We then jumped to the end to discuss how to build a &lt;a href=&quot;/blog/2017/06/08/simple-wb-master.html&quot;&gt;Simple Wishbone
Master&lt;/a&gt;.  While the
principles there can be applied to creating any
&lt;a href=&quot;https://opencores.org/opencores,wishbone&quot;&gt;Wishbone&lt;/a&gt; master interface,
we’ve shown how to use the &lt;a href=&quot;https://github.com/ZipCPU/dbgbus/blob/master/hexbus/rtl/hbexec.v&quot;&gt;code presented
there&lt;/a&gt;
as part of our own debugging interface.  In particular, it’s the
&lt;a href=&quot;https://opencores.org/opencores,wishbone&quot;&gt;Wishbone&lt;/a&gt; master
we’ll use today.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;We showed how you can use the inputs from a serial port to &lt;a href=&quot;/blog/2017/06/14/creating-words-from-bytes.html&quot;&gt;create bus
command words&lt;/a&gt;.  That finished out our discussion of the input to this bus.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;We then showed how to &lt;a href=&quot;/blog/2017/06/15/words-back-to-bytes.html&quot;&gt;turn the bus master responses back into a serial
stream&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Before we finished, we added &lt;a href=&quot;/blog/2017/06/16/adding-ints.html&quot;&gt;interrupt notifications to our
interface&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;And then we &lt;a href=&quot;/blog/2017/06/16/adding-ints.html&quot;&gt;added an idle indication&lt;/a&gt; to the interface as well, so that we can have some confidence
that the interface is running on any given serial port / transport.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The final post in the building the bus master interface was a post
describing &lt;a href=&quot;/blog/2017/06/20/dbg-put-together.html&quot;&gt;how to put it all
together&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Today, we’re going to build something that this interface can interact with.
When we’re done, the result won’t (yet) look like something a professional
tool might produce, but it’ll be enough for a demonstration.  We’ll
save the professional looking part for another lesson.&lt;/p&gt;

&lt;h2 id=&quot;our-components&quot;&gt;Our Components&lt;/h2&gt;

&lt;p&gt;If we want to build a bus that connects things together, the first step is going
to be collecting the components together that we want to interface with.
So, I’ve pulled several components from other designs that I have.
I’ve also adjusted their copyright so that, as part of this project, you can
have access to these components under the
&lt;a href=&quot;https://www.gnu.org/licenses/lgpl-3.0.en.html&quot;&gt;LGPL&lt;/a&gt;.  These
components include:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;A &lt;a href=&quot;https://github.com/ZipCPU/dbgbus/blob/master/bench/rtl/memdev.v&quot;&gt;block
RAM&lt;/a&gt;
  &lt;a href=&quot;https://opencores.org/opencores,wishbone&quot;&gt;Wishbone&lt;/a&gt; memory slave
drawn from the &lt;a href=&quot;https://github.com/ZipCPU/zbasic&quot;&gt;zbasic&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt; repository.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;A &lt;a href=&quot;https://github.com/ZipCPU/dbgbus/blob/master/bench/rtl/wbscope.v&quot;&gt;wishbone scope&lt;/a&gt;.
drawn from the &lt;a href=&quot;https://github.com/ZipCPU/wbscope&quot;&gt;wbscope&lt;/a&gt; repository.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;A simplified UART
&lt;a href=&quot;https://github.com/ZipCPU/dbgbus/blob/master/bench/rtl/txuartlite.v&quot;&gt;transmitter&lt;/a&gt; and
&lt;a href=&quot;https://github.com/ZipCPU/dbgbus/blob/master/bench/rtl/rxuartlite.v&quot;&gt;receiver&lt;/a&gt;,
drawn from the &lt;a href=&quot;https://github.com/ZipCPU/wbuart32&quot;&gt;wbaurt32&lt;/a&gt; repository.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;As a legal note, the RTL designs these examples were taken from still remain
firmly under the &lt;a href=&quot;https://www.gnu.org/licenses/gpl-3.0.en.html&quot;&gt;GPL&lt;/a&gt;, only
these specific component files have been given a new copyright.&lt;/p&gt;

&lt;table style=&quot;float: left; padding: 15px&quot;&gt;&lt;caption&gt;Fig 2: System Diagram&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/sample-interconnect.svg&quot; alt=&quot;An example WB interconnect&quot; width=&quot;420&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Of course, we’ll also be using the &lt;a href=&quot;https://github.com/ZipCPU/dbgbus/tree/master/hexbus&quot;&gt;hexbus debugging
interface&lt;/a&gt; we’ve just
developed and presented as part of this blog.&lt;/p&gt;

&lt;p&gt;The basic design is going to be similar to Fig 1, but with the new components
added in as part of the bus, as shown in Fig 2.&lt;/p&gt;

&lt;p&gt;Of these new components, the only one we haven’t discussed is a simple
ad hoc component that we’ll discuss below, and that you can use to get access
to arbitrary values within your design, and so that you have a little bit of
an example of some of the things that can be done.&lt;/p&gt;

&lt;h2 id=&quot;connecting-the-components&quot;&gt;Connecting the components&lt;/h2&gt;

&lt;p&gt;There are three parts to connecting components to a
&lt;a href=&quot;https://opencores.org/opencores,wishbone&quot;&gt;Wishbone&lt;/a&gt; bus.
First, you must decode the components’ address, so that only the proper
component is addressed.
Second, you must merge the three basic
&lt;a href=&quot;https://opencores.org/opencores,wishbone&quot;&gt;Wishbone&lt;/a&gt;
slave outputs back into one
response to be returned to the master.  These include the &lt;strong&gt;_ack&lt;/strong&gt; line,
the &lt;strong&gt;_stall&lt;/strong&gt; line, and the return &lt;strong&gt;_data&lt;/strong&gt; line.
Third, although not required, painful prior errors have taught me to always
create a &lt;strong&gt;wb_err&lt;/strong&gt; return line, and to set that any time a non-existent
component is addressed.  Further, along those same lines, we’re going to
make sure that no components occupy the NULL address.&lt;/p&gt;

&lt;h3 id=&quot;wiring-up-the-bus-master&quot;&gt;Wiring up the bus master&lt;/h3&gt;

&lt;p&gt;Prior to the first step, though, we’ll need to wire up our UART receiver, our
debugging bus
&lt;a href=&quot;https://opencores.org/opencores,wishbone&quot;&gt;Wishbone&lt;/a&gt;
master, and our UART transmitter.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;rxuartlite #(UARTSETUP) rxtransport(i_clk,
				i_uart, rx_stb, rx_data);

hbbus	genbus(i_clk,
	// The receive transport wires
	rx_stb, rx_data,
	// The bus control output wires
	wb_cyc, wb_stb, wb_we, wb_addr, wb_odata, wb_sel,
	//	The return bus wires
	  wb_ack, wb_stall, wb_err, wb_idata,
	// An interrupt line
	bus_interrupt,
	// The return transport wires
	tx_stb, tx_data, tx_busy);

txuartlite #(UARTSETUP) txtransport(i_clk,
				tx_stb, tx_data, o_uart, tx_busy);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This is primarily an exercise in wire management: the outputs of the
&lt;a href=&quot;https://github.com/ZipCPU/wbuart32/blob/master/rtl/rxuartlite.v&quot;&gt;receiver&lt;/a&gt;
go into the &lt;a href=&quot;https://github.com/ZipCPU/dbgbus/tree/master/hexbus&quot;&gt;hexbus&lt;/a&gt;,
and the outputs from the
&lt;a href=&quot;https://github.com/ZipCPU/dbgbus/tree/master/hexbus&quot;&gt;hexbus&lt;/a&gt; decoder
go into the
&lt;a href=&quot;https://github.com/ZipCPU/wbuart32/blob/master/rtl/txuartlite.v&quot;&gt;transmitter&lt;/a&gt;
and control the wishbone bus. Still, one particular
parameter needs some attention: the &lt;strong&gt;UARTSETUP&lt;/strong&gt;.  This parameter is
defined within the &lt;a href=&quot;https://github.com/ZipCPU/wbuart32&quot;&gt;wbuart32&lt;/a&gt; project.
If we want to communicate using 8-bits per baud, no parity, and one
stop bit, (8N1) then we can set this parameter simply to the number of clocks
per baud.  Hence, if we want to run our interface at 4MBaud with a
100MHz clock, we should set this to (100MHz/4MBaud) or 25.&lt;/p&gt;

&lt;h3 id=&quot;the-address-select-lines&quot;&gt;The address select lines&lt;/h3&gt;

&lt;p&gt;Next, let’s handle our address select lines.  We’ll support three basic
components, and we’ll use the prefixes of &lt;strong&gt;smpl_&lt;/strong&gt; (for our ad-hoc
registers), &lt;strong&gt;mem_&lt;/strong&gt; (for our block RAM) and &lt;strong&gt;scop_&lt;/strong&gt; to describe them.
Handling address selection is done in two parts.  For the first part,
we just test whether or not the
&lt;a href=&quot;https://opencores.org/opencores,wishbone&quot;&gt;Wishbone&lt;/a&gt;
address matches the address we’ve given to this component:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;// Nothing should be assigned to the null page
assign	smpl_sel = (wb_addr[29:4] == 26&#39;h081);	// 0x00002040
assign	scop_sel = (wb_addr[29:4] == 26&#39;h082);	// 0x00002080
assign	mem_sel  = (wb_addr[29:12] ==18&#39;h1);	// 0x00004000&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;One caution is in order: our bus address lines reference 32-bit words, not
octets.   Address 0x810 above references one 32-bit word, while address
0x811 references
another 32-bit word.  Most people are more familiar with accessing a bus where
the address is in units of octets.  For this reason, we’ve written out the
octet equivalent of each address in the comment to the right.  This equivalent
is given by shifting the address up by two, as well as by the number of
unspecified bits (4 or 12) in the address.&lt;/p&gt;

&lt;p&gt;This is actually a good time to point out that there’s really a &lt;em&gt;lot&lt;/em&gt; more
work to be done to do address assignment properly than just these simple
decode lines above.
A specification document needs to be written outlining what addresses are
being used for what, the addresses need to be turned into C/C++ address
references for the &lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/sw/host/wbregs.cpp&quot;&gt;peek/poke by name
interface&lt;/a&gt; and
the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;CPU&lt;/a&gt;, and more.
Here, we’re just going to wave our hands and assign these three address groups
to peripherals.&lt;/p&gt;

&lt;p&gt;We’ll probably have to come back and fix this lack in the near future.&lt;/p&gt;

&lt;h3 id=&quot;bus-errors&quot;&gt;Bus Errors&lt;/h3&gt;

&lt;p&gt;I usually define a
&lt;a href=&quot;https://opencores.org/opencores,wishbone&quot;&gt;Wishbone&lt;/a&gt;
bus error as one of three things.  First, it is an error if &lt;em&gt;nothing is
selected&lt;/em&gt; during a
&lt;a href=&quot;https://opencores.org/opencores,wishbone&quot;&gt;Wishbone&lt;/a&gt;
operation.  Second, it is an
error if &lt;em&gt;more than one&lt;/em&gt; thing is ever selected.  Finally, it is an error if
&lt;em&gt;more than one acknowledgement&lt;/em&gt; is returned on any given clock.  For our
example purposes here, we’ll only set the error is nothing is selected.
That is, if the &lt;strong&gt;wb_stb&lt;/strong&gt; signal is high indicating a
&lt;a href=&quot;https://opencores.org/opencores,wishbone&quot;&gt;Wishbone&lt;/a&gt;
request, and yet the address in &lt;strong&gt;wb_addr&lt;/strong&gt; doesn’t reference any of our
components, then a bus error should be returned.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;// This will be true if nothing is selected
assign	none_sel = (!smpl_sel)&amp;amp;&amp;amp;(!scop_sel)&amp;amp;&amp;amp;(!mem_sel);

// The wishbone error signal is true for one clock only, and then it
// resets itself
always @(posedge i_clk)
	wb_err &amp;lt;= (wb_stb)&amp;amp;&amp;amp;(none_sel);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The &lt;a href=&quot;https://opencores.org/opencores,wishbone&quot;&gt;Wishbone&lt;/a&gt;
&lt;a href=&quot;https://opencores.org/cdn/downloads/wbspec_b4.pdf&quot;&gt;spec&lt;/a&gt;,
though, isn’t as particular regarding what constitutes a
bus error, and many masters want any error detected to be aligned with where
the acknowledgement would’ve come back–so that every request ends in either
an error or an acknowledgement.  That approach allows both slaves and the
interconnect to generate errors.  The interconnect we are building today,
though is simpler, and doesn’t do that.&lt;/p&gt;

&lt;p&gt;We’ll do one more thing with the bus error: we’ll grab a copy of any bus
error address, so we can report back later the bus address associated with
any error (if necessary):&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	if (wb_err)
		bus_err_address &amp;lt;= wb_addr;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;We’ll come back to logic required of the interconnect later, once we handle
the slave produced signals.&lt;/p&gt;

&lt;h3 id=&quot;slave-response-the-stall-line&quot;&gt;Slave response: The stall line&lt;/h3&gt;

&lt;p&gt;The first slave response logic we’ll look at is the stall logic.
The &lt;a href=&quot;https://opencores.org/opencores,wishbone&quot;&gt;Wishbone&lt;/a&gt;
&lt;a href=&quot;https://opencores.org/cdn/downloads/wbspec_b4.pdf&quot;&gt;spec&lt;/a&gt;,
recommends that this logic not be clocked, and that it be only combinatorial
in nature.  In particular, you’ll want to stall the bus any time you are
trying to make a request of a component whose stall line is high.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;assign	wb_stall = ((smpl_sel)&amp;amp;&amp;amp;(smpl_stall))
		||((scop_sel)&amp;amp;&amp;amp;(scop_stall))
		||((mem_sel)&amp;amp;&amp;amp;(mem_stall));&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;For this particular bus implementation, the stall lines are just a formality.
None of these &lt;a href=&quot;https://opencores.org/opencores,wishbone&quot;&gt;Wishbone&lt;/a&gt;
slave’s will ever stall the bus.  This line is therefore 
ripe for being removed by the optimizer within your toolflow.  Here, we keep
it in case we need to add components later that might stall the bus.&lt;/p&gt;

&lt;h3 id=&quot;slave-response-the-acknowledgement&quot;&gt;Slave response: The Acknowledgement&lt;/h3&gt;

&lt;p&gt;The second slave response line is the acknowledgement line.  This is the line
that the slave uses to indicate that the data it is providing on its data line
is valid.  We’ll handle this by creating a clocked line that is simply the &lt;em&gt;or&lt;/em&gt;
of all the acknowledgement lines.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	wb_ack &amp;lt;= (smpl_ack)||(scop_ack)||(mem_ack);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;If we use a clock while assigning our data, the two resulting responses,
both acknowledgement and data, will align as required.&lt;/p&gt;

&lt;h3 id=&quot;slave-response-return-data&quot;&gt;Slave response: Return data&lt;/h3&gt;

&lt;p&gt;The final slave responses are the data lines.  These are valid any time the
acknowledgement is valid.  Indeed, we’ll use the various slave acknowledgement
lines to know which slave has produced valid data, and thus to know what data
to return to the
&lt;a href=&quot;https://opencores.org/opencores,wishbone&quot;&gt;Wishbone&lt;/a&gt; master.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	if (smpl_ack)
		wb_idata &amp;lt;= smpl_data;
	else if (scop_ack)
		wb_idata &amp;lt;= scop_data;
	else if (mem_ack)
		wb_idata &amp;lt;= mem_data;
	else
		wb_idata &amp;lt;= 32&#39;h0;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;As a touch of flair, we’ll respond with all zeros if nothing acknowledges our
bus read, although this isn’t required and it can be removed if necessary
if you are struggling to &lt;a href=&quot;/blog/2017/06/12/minimizing-luts.html&quot;&gt;minimize your
logic&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&quot;slave-response-interrupts&quot;&gt;Slave response: Interrupts&lt;/h3&gt;

&lt;p&gt;Although it’s not really a part of connecting a device to a
&lt;a href=&quot;https://opencores.org/opencores,wishbone&quot;&gt;&lt;em&gt;Wishbone&lt;/em&gt; bus&lt;/a&gt;,
many bus slaves have interrupt lines.  We’ll create an interrupt
to send back to our debugging bus controller that is simply the &lt;em&gt;or&lt;/em&gt; of our
two interrupt producing components.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;assign	bus_interrupt = (smpl_interrupt) | (scop_int);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Given the way we implemented interrupts within our controller, this will
trigger on any positive edge–so it’ll need to be reset prior to being
able to trip again.  While it’s not necessarily the optimal or the best
approach, it may be sufficient for our purposes here.&lt;/p&gt;

&lt;h3 id=&quot;connecting-the-pre-existing-components&quot;&gt;Connecting the pre-existing components&lt;/h3&gt;

&lt;p&gt;We have three components to connect our interface to.  Two of these components
already exist and only need to be referenced from here as sub-modules.  These
are the &lt;a href=&quot;https://github.com/ZipCPU/dbgbus/blob/master/bench/rtl/memdev.v&quot;&gt;block
RAM&lt;/a&gt;
interface, and the &lt;a href=&quot;https://github.com/ZipCPU/dbgbus/blob/master/bench/rtl/wbscope.v&quot;&gt;wishbone
scope&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The &lt;a href=&quot;https://github.com/ZipCPU/dbgbus/blob/master/bench/rtl/memdev.v&quot;&gt;block RAM&lt;/a&gt;
needs very little additional configuration beyond what we’ve
already done, but it does need to to be told how big its memory area will be. 
We’ll create our
&lt;a href=&quot;https://github.com/ZipCPU/dbgbus/blob/master/bench/rtl/memdev.v&quot;&gt;block RAM&lt;/a&gt;
to have 2^14 octets, hence the &lt;strong&gt;14&lt;/strong&gt; parameter below.  We’ll
also use the select line, that we set above, &lt;strong&gt;mem_sel&lt;/strong&gt;, to modify the
slaves strobe line, so the memory knows that it has been selected–without
needing to have any more knowledge of any other peripherals that might be
on the bus.  This is different from the &lt;strong&gt;wb_sel&lt;/strong&gt; line which we’ve &lt;a href=&quot;/zipcpu/2017/05/29/select-lines.html&quot;&gt;used to
determine which octets in a word will be set in any
operation&lt;/a&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;memdev	#(14) blkram(i_clk,
	wb_cyc, (wb_stb)&amp;amp;&amp;amp;(mem_sel), wb_we, wb_addr[11:0],
		wb_odata, wb_sel,
	mem_ack, mem_stall, mem_data);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The next item we’ll want to place onto our bus is the
&lt;a href=&quot;https://github.com/ZipCPU/wbscope&quot;&gt;wishbone scope&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;To use the scope, you must decide on what you wish to examine, and then
what you want to use to trigger the scope.  In our case, let’s trigger
off of any &lt;a href=&quot;https://opencores.org/opencores,wishbone&quot;&gt;Wishbone&lt;/a&gt;
accesses to our block RAM.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;assign	scope_trigger = (mem_sel)&amp;amp;&amp;amp;(wb_stb);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;We’ll also select for our scope’s data several of the bus lines.  We’ll save
for a later date how to turn these wires into a proper VCD file.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;assign	debug_data    = { wb_cyc, wb_stb, wb_we, wb_ack, wb_stall,
		wb_addr[5:0], 1&#39;b1,
			wb_odata[9:0],
			wb_idata[9:0] };&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The scope has one more capability: it can sample data based upon a “when data
is valid” flag.  The flag can be &lt;em&gt;really&lt;/em&gt; useful if you are processing a
signal that isn’t valid on every clock–such as the output of a digitizer as
an example.  Today, we’ll just set that flag to one so that we can capture
on every clock.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;assign	scope_ce = 1&#39;b1;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Now that all of the preliminaries have been taken care of, you can now place
the scope within our file, and connect it to the bus as well.  As with the
memory, the biggest part of “hooking it up” is adjusting the strobe line by
&lt;em&gt;and&lt;/em&gt;ing it with the scope select line.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;wbscope	thescope(i_clk, scope_ce, scope_trigger, debug_data,
	i_clk, wb_cyc, (wb_stb)&amp;amp;&amp;amp;(scop_sel), wb_we, wb_addr[0],wb_odata,
	scop_ack, scop_stall, scop_data,
	scop_int);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Other things you might notice are the fact that this scope requires
two clocks, one for the data and one for the bus.  In this example
thee two are the same.  It
also requires the lowest of the address lines.  The result is that address
&lt;strong&gt;0x02080&lt;/strong&gt; will reference the scope control and status register, while
address &lt;strong&gt;0x2084&lt;/strong&gt; will reference the scope data register.&lt;/p&gt;

&lt;h3 id=&quot;building-an-ad-hoc-slave&quot;&gt;Building an Ad-Hoc Slave&lt;/h3&gt;

&lt;p&gt;You will very often find that you need to be able to report some logic result
back up the bus to your debug interface–something that is ad-hoc, and not
necessarily the part of any well-defined, prebuilt component.  In many ways,
this seems to be one of the most common requests: how to I get access to
(whatever) to see what my design has done?  Therefore, let’s make a simple
ad-hoc slave that does just that.&lt;/p&gt;

&lt;p&gt;Our slave will have six registers, although it occupies enough bus space
that it could have a full sixteen–so there’s plenty of room should you wish
to expand it.  Any more than that and you’ll need to adjust the address
decoding logic above.  Laying these registers out, we’ll have:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;A read only date register&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;A simple register that you can set and read back&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The address of the last bus error&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;A counter that starts from zero on startup&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;An experimental interrupt line, that you can use to turn an interrupt on or
off, so you can see how our interface deals with an interrupt&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;A GPIO output that you can use to communicate with the
&lt;a href=&quot;https://www.veripool.org/wiki/verilator/&quot;&gt;Verilator&lt;/a&gt; simulation.
In this case, we’ll use an &lt;strong&gt;o_halt&lt;/strong&gt; flag to indicate that its time for
the simulation to halt.  You can set that as part of the LSB of this
register.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Let’s first handle the write request.  On a write, to this peripheral,
we’ll:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Handle setting the simple register to whatever input was given&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Create (or clear) an interrupt depending on the low order bit if writing
to register four&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Adjust our &lt;strong&gt;o_halt&lt;/strong&gt; GPIO value with the LSB of anything written
to register five.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Since the other registers are read only, we can ignore them on any write
request.&lt;/p&gt;

&lt;p&gt;This is therefore our write request logic:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	// Determine if a write to this peripheral is taking place
	if ((wb_stb)&amp;amp;&amp;amp;(smpl_sel)&amp;amp;&amp;amp;(wb_we))
	begin // Split our logic between the registers
		case(wb_addr[3:0])
		4&#39;h1: smpl_register  &amp;lt;= wb_odata;
		4&#39;h4: smpl_interrupt &amp;lt;= wb_odata[0];
		4&#39;h5: o_halt         &amp;lt;= wb_odata[0];
		default: begin end
		endcase
	end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;In this case, pay close attention to the if at the top, and the case below.
These should match up with our &lt;a href=&quot;/blog/2017/06/21/simple-wb-interconnect.html&quot;&gt;lesson on how to build a simple wishbone
slave&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Before reading back from this interface, let’s deal with the “clocks since
power up” counter.  We’re going to use the initial command to set this
register to zero, then while running it will count up.  Once the MSB gets set,
we’ll leave it set so that we can tell if we’ve ever rolled over.  This will
give us an ever changing counter that we can use for relative timing, or
absolute timing if near when the chip starts up.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;// Start our clocks since power up counter from zero
initial power_counter = 0;
always @(posedge i_clk)
	// Count up from zero until the top bit is set
	if (!power_counter[31])
		power_counter &amp;lt;= power_counter + 1&#39;b1;
	else // once the top bit is set, keep it set forever
		power_counter[30:0] &amp;lt;= power_counter[30:0] + 1&#39;b1;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Now that we’ve created that logic, everything is ready for us to read.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	case(wb_addr[3:0])
	4&#39;h0:    smpl_data &amp;lt;= 32&#39;h20170622;
	4&#39;h1:    smpl_data &amp;lt;= smpl_register;
	4&#39;h2:    smpl_data &amp;lt;= { bus_err_address, 2&#39;b00 };
	4&#39;h3:    smpl_data &amp;lt;= power_counter;
	4&#39;h4:    smpl_data &amp;lt;= { 31&#39;h0, smpl_interrupt };
	default: smpl_data &amp;lt;= 32&#39;h00;
	endcase&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Notice that read logic doesn’t depend upon any bus lines other than the
address.  Indeed, the fact that a read of this device has taken place is in
many ways irrelevant–only the data being produced is relevant.  We can
produce the right result for any address in our register space regardless. 
(This isn’t true for all peripherals.)  The zero address of our peripheral
returns a constant value (of the day when I posted this).  The first address
(address 4, really) just returns the register we set above.  The second
address gives us the address of the last bus error.  The third gives us the
value of our ticks since startup counter.  The final register, at address
position four (0x2050), just returns an LSB indicating whether or not our
interrupt is set.&lt;/p&gt;

&lt;p&gt;Since the last address in our interface only contains a halt request
indicator, it will never read anything but zero, so we’re not going to
include any special logic to read it.&lt;/p&gt;

&lt;p&gt;As a final and required part of our interface, we’ll need to acknowledge the
response from the bus, and create a stall line to indicate that this ad-hoc
interface never stalls.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;// Decoding an address takes one clock, so set the ACK to be true
// on the next clock
always @(posedge i_clk)
	smpl_ack &amp;lt;= ((wb_stb)&amp;amp;&amp;amp;(smpl_sel));

// This simple interface never stalls
assign smpl_stall &amp;lt;= 1&#39;b0;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;That’s it!  You just connected a (very) simple peripheral to our debugging
bus!  Indeed, if you wanted, you could now use this approach to
&lt;a href=&quot;/blog/2017/05/29/fft-debugging.html&quot;&gt;debug an FFT&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&quot;coming-up&quot;&gt;Coming up&lt;/h1&gt;

&lt;p&gt;The &lt;a href=&quot;https://github.com/ZipCPU/dbgbus&quot;&gt;full design&lt;/a&gt;, as we’ve now built it
should run on any FPGA.  A quick test, by giving the device an address and
read request,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;A2040R&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;or similarly a hex address and a write request,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;A4000Wdeadbeef&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;should work to read or write from your device using this interface.  Further,
if nothing is going on, you should be able to see “Z”s getting sent to your
screen.&lt;/p&gt;

&lt;p&gt;Not bad.&lt;/p&gt;

&lt;p&gt;We could even read from the scope’s control and status register with a
simple read command:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;A2080R&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Another read command, such as&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;A2085R&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;will return one data value from our scope.  You might wish to notice that we
set the LSB in this address.  As a result, subsequent R’s typed into the
interface will interpreted as read commands from &lt;em&gt;the same&lt;/em&gt; 
“scope data register” address.&lt;/p&gt;

&lt;p&gt;Ok, so … this works.  But it’s still really hard to use.  This, then, gives
us our roadmap forward:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Building a
&lt;a href=&quot;https://www.veripool.org/wiki/verilator/&quot;&gt;Verilator&lt;/a&gt;
&lt;a href=&quot;/blog/2017/06/26/dbgbus-verilator.html&quot;&gt;test bench&lt;/a&gt;
to use to experiment with this bus apart from any hardware&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Building a software software interface to our debugging bus, so we can use
the host CPU to our advantage when working with the design&lt;/p&gt;

    &lt;p&gt;This software interface will also make it easier for us to get the results
of any scope interactions out of our debugging harness and into a VCD
type of format that we can then use to examine what was going on within the
FPGA.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;These then will be the topics we will queue up for a later day.&lt;/p&gt;

</description>
        <pubDate>Thu, 22 Jun 2017 00:00:00 -0400</pubDate>
        <link>http://zipcpu.com/blog/2017/06/22/simple-wb-interconnect.html</link>
        <guid isPermaLink="true">http://zipcpu.com/blog/2017/06/22/simple-wb-interconnect.html</guid>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>Taking a New Look at Verilator</title>
        <description>&lt;p&gt;I’d like to discuss a very profound simulation capability, one that I have
found to be &lt;em&gt;amazingly&lt;/em&gt; useful when building and understanding my own
software.  In particular, I’d like to discuss
&lt;a href=&quot;https://www.veripool.org/wiki/verilator/&quot;&gt;Verilator&lt;/a&gt;.  No, not &lt;em&gt;just&lt;/em&gt;
&lt;a href=&quot;https://www.veripool.org/wiki/verilator/&quot;&gt;Verilator&lt;/a&gt;.  I’d like to discuss how
&lt;a href=&quot;https://www.veripool.org/wiki/verilator/&quot;&gt;Verilator&lt;/a&gt;
can be incorporated into your designs to provide you with a simulation tool
that, to my knowledge, is not matched elsewhere.&lt;/p&gt;

&lt;p&gt;If you are a Verilog programmer and you are not familiar with
&lt;a href=&quot;https://www.veripool.org/wiki/verilator/&quot;&gt;Verilator&lt;/a&gt;, then
let this be my opportunity to call this wonderful tool to your attention.&lt;/p&gt;

&lt;p&gt;If you are a VHDL programmer, you may be disappointed to learn that
&lt;a href=&quot;https://www.veripool.org/wiki/verilator/&quot;&gt;Verilator&lt;/a&gt; only works with Verilog,
not with VHDL.  Perhaps I can use this opportunity to show you some of what
you are missing.&lt;/p&gt;

&lt;p&gt;According to the &lt;a href=&quot;https://www.veripool.org/wiki/verilator/&quot;&gt;Verilator&lt;/a&gt;
&lt;a href=&quot;https://www.veripool.org/projects/verilator/wiki/Manual-verilator#NAME&quot;&gt;manual&lt;/a&gt;,
&lt;a href=&quot;https://www.veripool.org/wiki/verilator/&quot;&gt;Verilator&lt;/a&gt; is used to
“Convert Verilog code to C++/System C”.  For the purpose of this
article, we’ll consider only the Verilog to C++ converter part.  Further, we’re
going to discuss what can be done with such a capability, and why it is so
amazingly valuable.&lt;/p&gt;

&lt;h2 id=&quot;basic-verilator-testbench&quot;&gt;Basic Verilator Testbench&lt;/h2&gt;

&lt;p&gt;If you’ve never used
&lt;a href=&quot;https://www.veripool.org/wiki/verilator/&quot;&gt;Verilator&lt;/a&gt;
before, and you wish to try it out, the first
step is the same as with any other program you’d like to try on your computer.
You’ll need to download
&lt;a href=&quot;https://www.veripool.org/projects/verilator/wiki/Installing&quot;&gt;download&lt;/a&gt;
&lt;a href=&quot;https://www.veripool.org/wiki/verilator/&quot;&gt;Verilator&lt;/a&gt;
and &lt;a href=&quot;https://www.veripool.org/projects/verilator/wiki/Installing&quot;&gt;install&lt;/a&gt; it.
For me, this was as simple as “sudo apt-get install verilator”, but other
approaches exist as well.&lt;/p&gt;

&lt;p&gt;Once you have it installed, let’s walk through how you might use it.
Specifically, we’ll walk through an example of what it takes to set your
project up to use it.&lt;/p&gt;

&lt;p&gt;This first step discussion for how to use
&lt;a href=&quot;https://www.veripool.org/wiki/verilator/&quot;&gt;Verilator&lt;/a&gt;
will follow closely with the quick
&lt;a href=&quot;https://www.veripool.org/projects/verilator/wiki/Manual-verilator#EXAMPLE-C-EXECUTION&quot;&gt;example code&lt;/a&gt;
found in the
&lt;a href=&quot;https://www.veripool.org/wiki/verilator/&quot;&gt;Verilator&lt;/a&gt;
&lt;a href=&quot;https://www.veripool.org/projects/verilator/wiki/Manual-verilator&quot;&gt;Manual&lt;/a&gt;.
This will show us what we need to know in order to use
&lt;a href=&quot;https://www.veripool.org/wiki/verilator/&quot;&gt;Verilator&lt;/a&gt; with any project.&lt;/p&gt;

&lt;p&gt;You will start by running the
&lt;a href=&quot;https://www.veripool.org/wiki/verilator/&quot;&gt;Verilator&lt;/a&gt;
command line program on your top level Verilog file.  For the purposes of this
discussion, let’s assume that top level file is a very generic “module.v”.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;verilator -Wall -cc module.v&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Assuming your design has no syntax errors, this
will create a directory, obj_dir, and a C++ class definition for
Vmodule in the files obj_dir/Vmodule.h and obj_dir/Vmodule.cpp.
Another file in that directory, obj_dir/Vmodule.mk, can be used to “make”
these files into the library that you will need to link your C++ driver
program to.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;cd obj_dir; make -f Vmodule.mk ; cd ..&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;We’re going to spend most of our time in this post looking at how to drive this
C++ code to simulate your design.&lt;/p&gt;

&lt;p&gt;If you look through the &lt;a href=&quot;https://www.veripool.org/projects/verilator/wiki/Manual-verilator&quot;&gt;Verilator
manual&lt;/a&gt;,
you’ll find an &lt;a href=&quot;https://www.veripool.org/projects/verilator/wiki/Manual-verilator#EXAMPLE-C-EXECUTION&quot;&gt;example&lt;/a&gt;
test bench driver that looks similar to the following:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;cp&quot;&gt;#include &amp;lt;stdlib.h&amp;gt;
#include &quot;Vmodule.h&quot;
#include &quot;verilated.h&quot;
&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;argc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;**&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;argv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;// Initialize Verilators variables
&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;Verilated&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;commandArgs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;argc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;argv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

	&lt;span class=&quot;c1&quot;&gt;// Create an instance of our module under test
&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;Vmodule&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tb&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Vmodule&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

	&lt;span class=&quot;c1&quot;&gt;// Tick the clock until we are done
&lt;/span&gt;	&lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Verilated&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;gotFinish&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;tb&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i_clk&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;top&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;eval&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;tb&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i_clk&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;top&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;eval&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;exit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;EXIT_SUCCESS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;We’ll walk through this example from the top.&lt;/p&gt;

&lt;p&gt;The &lt;a href=&quot;http://en.cppreference.com/w/cpp/language/main_function&quot;&gt;main()&lt;/a&gt; program that uses
&lt;a href=&quot;https://www.veripool.org/wiki/verilator/&quot;&gt;Verilator&lt;/a&gt;
must initialize
&lt;a href=&quot;https://www.veripool.org/wiki/verilator/&quot;&gt;Verilator&lt;/a&gt; with
any arguments (argc and argv), and then it needs to create a new object of the
class Vmodule–where module.v is the name of the design we applied the
Verilator program to above.&lt;/p&gt;

&lt;p&gt;Before we get to that next step, you need to know that the Vmodule class that
&lt;a href=&quot;https://www.veripool.org/wiki/verilator/&quot;&gt;Verilator&lt;/a&gt;
created for you exposes all of your inputs and outputs as variables.
Hence you can set the &lt;strong&gt;i_clk&lt;/strong&gt; input to your module.  Changing this value
from a 0 to a 1 will also cause any &lt;strong&gt;@(posedge i_clk)&lt;/strong&gt; logic to trip as well.&lt;/p&gt;

&lt;p&gt;Hence, our job when simulating is just to run a tight loop where we set the
clock, evaluate everything, set the clock again, and evaluate everything again.
The loop stops when
&lt;a href=&quot;https://www.veripool.org/wiki/verilator/&quot;&gt;Verilator&lt;/a&gt;
comes across a &lt;a href=&quot;http://users.ece.utexas.edu/~patt/14s.382N/tools/verilog_manual.html#finish&quot;&gt;$finish&lt;/a&gt; statement within the
Verilog code, or when you type a Ctrl-C.  (I hardly ever use the $finish
statement, so Ctrl-C is one of the main ways I terminate a simulation.)&lt;/p&gt;

&lt;p&gt;This sounds simple enough, but let’s see if we can’t simplify it a touch more.&lt;/p&gt;

&lt;p&gt;I’d like to create, from this outline, a test bench module that incorporates
all of this information.  We’ll call it
TESTBENCH, and you can see an example of how I’ve used a very similar
capability within the ZipCPU project
&lt;a href=&quot;https://github.com/ZipCPU/blob/master/sim/verilated/testb.h&quot;&gt;here&lt;/a&gt;.
Our TESTBENCH calss will provide
two functions: reset() and tick(), and we want to be able to check any time
&lt;a href=&quot;https://www.veripool.org/wiki/verilator/&quot;&gt;Verilator&lt;/a&gt;’s
code has encountered a
&lt;a href=&quot;http://users.ece.utexas.edu/~patt/14s.382N/tools/verilog_manual.html#finish&quot;&gt;$finish&lt;/a&gt; statement.
To do this, we can wrap the above code in a class, as in:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;k&quot;&gt;template&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;MODULE&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;	&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;TESTBENCH&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;m_tickcount&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;MODULE&lt;/span&gt;	&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_core&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

	&lt;span class=&quot;n&quot;&gt;TESTBENCH&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;m_core&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Vmodule&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;m_tickcount&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0l&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

	&lt;span class=&quot;k&quot;&gt;virtual&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;~&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;TESTBENCH&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;delete&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m_core&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;m_core&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

	&lt;span class=&quot;k&quot;&gt;virtual&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;reset&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;m_core&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i_reset&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;c1&quot;&gt;// Make sure any inheritance gets applied
&lt;/span&gt;		&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tick&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;m_core&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i_reset&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

	&lt;span class=&quot;k&quot;&gt;virtual&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;tick&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;c1&quot;&gt;// Increment our own internal time reference
&lt;/span&gt;		&lt;span class=&quot;n&quot;&gt;m_tickcount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

		&lt;span class=&quot;c1&quot;&gt;// Make sure any combinatorial logic depending upon
&lt;/span&gt;		&lt;span class=&quot;c1&quot;&gt;// inputs that may have changed before we called tick()
&lt;/span&gt;		&lt;span class=&quot;c1&quot;&gt;// has settled before the rising edge of the clock.
&lt;/span&gt;		&lt;span class=&quot;n&quot;&gt;m_core&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i_clk&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;m_core&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;eval&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;

		&lt;span class=&quot;c1&quot;&gt;// Toggle the clock
&lt;/span&gt;
		&lt;span class=&quot;c1&quot;&gt;// Rising edge
&lt;/span&gt;		&lt;span class=&quot;n&quot;&gt;m_core&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i_clk&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;m_core&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;eval&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;

		&lt;span class=&quot;c1&quot;&gt;// Falling edge
&lt;/span&gt;		&lt;span class=&quot;n&quot;&gt;m_core&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i_clk&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;m_core&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;eval&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

	&lt;span class=&quot;k&quot;&gt;virtual&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bool&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;done&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Verilated&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;gotFinish&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;());&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The main program likewise needs to change, but it primarily just gets
simplified:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;cp&quot;&gt;#include &quot;testbench.h&quot;
&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;argc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;**&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;argv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;Verilated&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;commandArgs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;argc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;argv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;TESTBENCH&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tb&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TESTBENCH&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;

	&lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tb&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;done&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;tb&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tick&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;exit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;EXIT_SUCCESS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;At this point, we’ve just reworded things.  We haven’t really created any
new features.  We have, however, insisted that any module.v using this
test harness must have inputs &lt;strong&gt;i_clk&lt;/strong&gt; and &lt;strong&gt;i_reset&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;One more step is required before we can use this program.  We need
to compile our program, and we need to point the compiler to any include
files that were created in our obj_dir directory, as well as adding some
&lt;a href=&quot;https://www.veripool.org/wiki/verilator/&quot;&gt;Verilator&lt;/a&gt;
specific components:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;g++ -I obj_dir -I/usr/share/verilator/include module.cpp /usr/share/verilator/include/verilated.cpp -o module&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Your actual Verilator components may not be in the /usr/share/verilator directory, depending upon how your distribution installed
&lt;a href=&quot;https://www.veripool.org/wiki/verilator/&quot;&gt;Verilator&lt;/a&gt;.
You can find out the correct directory by looking for &lt;strong&gt;$VERILATOR_ROOT&lt;/strong&gt;
in the output of&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;verilator -V&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;At this point we have a program, module, that we can run that will simulate
our Verilog module.&lt;/p&gt;

&lt;p&gt;You can see an example of one such test bench I use
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/sim/verilated/testb.h&quot;&gt;here&lt;/a&gt;.
If you look a bit harder, you may even find several versions of this module
wandering around other projects found in
&lt;a href=&quot;https://github.com/ZipCPU&quot;&gt;ZipCPU’s github&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Ok, so now we can simulate our design–much like any other simulator.
You might argue at this point that Verilator is less than the other
simulation design programs.  While it can simulate our design, it’s not as
simple to set up.&lt;/p&gt;

&lt;p&gt;Don’t worry, we’re not done yet.&lt;/p&gt;

&lt;p&gt;Let’s go a step further.  Let’s start using
&lt;a href=&quot;https://www.veripool.org/wiki/verilator/&quot;&gt;Verilator&lt;/a&gt;
to perform some simple magic for us.&lt;/p&gt;

&lt;h2 id=&quot;debugging-verilog-via-printf&quot;&gt;Debugging Verilog via Printf&lt;/h2&gt;

&lt;p&gt;The first thing we are going to do with
&lt;a href=&quot;https://www.veripool.org/wiki/verilator/&quot;&gt;Verilator&lt;/a&gt; is to describe how you
can print out values from within your simulation.  This will turn Verilog
simulation debugging into something very akin to software debugging.&lt;/p&gt;

&lt;p&gt;When I debug software, I tend to use two approaches:
&lt;a href=&quot;http://www.cplusplus.com/reference/cstdio/printf/&quot;&gt;printf&lt;/a&gt;
and &lt;a href=&quot;https://www.gnu.org/software/gdb/&quot;&gt;gdb&lt;/a&gt;.
By using the two of these, I tend to stay of of the realm of
“Voodoo computing” (my personal term for the software equivalent of
&lt;a href=&quot;/fpga-hell.html&quot;&gt;FPGA Hell&lt;/a&gt;–when you have no idea what is
going wrong with your software).  If a piece of software
I am working with creates a core dump, my first approach to finding the bug
is usually to use &lt;a href=&quot;https://www.gnu.org/software/gdb/&quot;&gt;gdb&lt;/a&gt;.  In all other
cases, such as when I am just trying to understand what is going on, I’ll use
&lt;a href=&quot;http://www.cplusplus.com/reference/cstdio/printf/&quot;&gt;printf&lt;/a&gt;
and I’ll just dump any piece of
relevant data to the standard output stream.  As a last resort, I’ll pull
up &lt;a href=&quot;https://www.gnu.org/software/ddd/&quot;&gt;ddd&lt;/a&gt; and step through my code and any
library code I’m using.&lt;/p&gt;

&lt;p&gt;One of the big problems with debugging FPGA’s, though, is that there are no
&lt;a href=&quot;http://www.cplusplus.com/reference/cstdio/printf/&quot;&gt;printf&lt;/a&gt;
capabilities within FPGA’s.  Hence, software engineers trying to program
FPGA’s often find themselves stuck when things don’t work.  Their favorite
tool is missing.&lt;/p&gt;

&lt;p&gt;While the official Verilog answer to this is the &lt;a href=&quot;http://www.referencedesigner.com/tutorials/verilog/verilog_09.php&quot;&gt;$monitor
command&lt;/a&gt;
within Verilog, I’d like to demonstrate a different approach using
&lt;a href=&quot;https://www.veripool.org/wiki/verilator/&quot;&gt;Verilator&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The first thing we are going to do to create this debug by
&lt;a href=&quot;http://www.cplusplus.com/reference/cstdio/printf/&quot;&gt;printf&lt;/a&gt;
capability
is to subclass our TESTBENCH class.  We’ll create a new class, called
MODULE_TB, that inherits from the TESTBENCH.  This will allow us to maintain
a generic TESTBENCH across many projects, but yet still add functionality
to it that is specific to the module we are testing.&lt;/p&gt;

&lt;p&gt;The next thing we are going to do is to override the method we just created
above for requesting a clock tick.  We’re going to replace that method with
another method that first calls the original tick method, and then outputs
whatever logic we’d like to know about.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt;	&lt;span class=&quot;nc&quot;&gt;MODULE&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_TB&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TESTBENCH&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Vmodule&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;

	&lt;span class=&quot;k&quot;&gt;virtual&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;tick&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;c1&quot;&gt;// Request that the testbench toggle the clock within
&lt;/span&gt;		&lt;span class=&quot;c1&quot;&gt;// Verilator
&lt;/span&gt;		&lt;span class=&quot;n&quot;&gt;TESTBENCH&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Vmodule&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tick&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;

		&lt;span class=&quot;c1&quot;&gt;// Now we&#39;ll debug by printf&#39;s and examine the
&lt;/span&gt;		&lt;span class=&quot;c1&quot;&gt;// internals of m_core
&lt;/span&gt;		&lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;%8ld: %s %s ...&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m_tickcount&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
			&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_core&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v__DOT__wb_cyc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;?&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;CYC&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;   &quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
			&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_core&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v__DOT__wb_stb&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;?&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;STB&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;   &quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
			&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;As a result, we just added a
&lt;a href=&quot;http://www.cplusplus.com/reference/cstdio/printf/&quot;&gt;printf&lt;/a&gt;
capability to Verilog via
&lt;a href=&quot;https://www.veripool.org/wiki/verilator/&quot;&gt;Verilator&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Did you notice the values “&lt;strong&gt;v__DOT__wb_cyc&lt;/strong&gt;” and
“&lt;strong&gt;v__DOT__wb_stb&lt;/strong&gt;”?
These are local registers within the Vmodule construct that
&lt;a href=&quot;https://www.veripool.org/wiki/verilator/&quot;&gt;Verilator&lt;/a&gt;.
created for us.  They are being used to hold the values of the &lt;strong&gt;wb_cyc&lt;/strong&gt; and
&lt;strong&gt;wb_stb&lt;/strong&gt; registers used to run an internal wishbone bus.  Indeed, all of
your registers should be visible to you
from the &lt;strong&gt;m_core&lt;/strong&gt; structure we have created.  While the naming tends to be
roughly consistent, if you struggle finding a variable you would like to print
then just look through the obj_dir/Vmodule.h file.  If you are still
struggling, take a look at how a known variable in obj_dir/Vmodule.cpp is
being set, and you should be able to figure out the internal variable name.&lt;/p&gt;

&lt;p&gt;I should also point out: &lt;a href=&quot;https://www.veripool.org/wiki/verilator/&quot;&gt;Verilator&lt;/a&gt;’s
variable naming convention has changed over time.  While my version of
&lt;a href=&quot;https://www.veripool.org/wiki/verilator/&quot;&gt;Verilator&lt;/a&gt;
works with a “v__DOT__” preceding any top
level register name, and the “__DOT__” substrings indicate hierarchical
transitions between
components, you may have to look within your own module to find how your
variables are named.  It’s for this reason that, in any new designs, I start
the design with a series of #define’s indicating the
&lt;a href=&quot;https://www.veripool.org/wiki/verilator/&quot;&gt;Verilator&lt;/a&gt;
to C++ mapping, so I know how to get access to any variables of interest.&lt;/p&gt;

&lt;p&gt;As an example, &lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/sim/verilated/main_tb.cpp&quot;&gt;this
file&lt;/a&gt;
begins with a set of #define’s that I use to simplify access to various
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt; internal variable names.&lt;/p&gt;

&lt;p&gt;Remember, this is for debugging–so a little cheating is allowed.&lt;/p&gt;

&lt;p&gt;We’re not done yet, though.&lt;/p&gt;

&lt;p&gt;That &lt;a href=&quot;http://www.cplusplus.com/reference/cstdio/printf/&quot;&gt;printf&lt;/a&gt;
capability can print an enormous amount of information to the screen–Gigabytes
even!  It can print information that we are interested in, but it can
also print so much irrelevant information that it can be a struggle to find
the relevant information we are interested in.&lt;/p&gt;

&lt;p&gt;For this reason, I often add a boolean “writeout” variable prior to any
&lt;a href=&quot;http://www.cplusplus.com/reference/cstdio/printf/&quot;&gt;printf&lt;/a&gt;’s,
which I then use to gate whether or not I
&lt;a href=&quot;http://www.cplusplus.com/reference/cstdio/printf/&quot;&gt;printf&lt;/a&gt; any values.  I can
then use this value to look for whatever conditions I find useful for debugging
that day.  For example, the code below will write out the relevant portions
of any internal wishbone transaction.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt;	&lt;span class=&quot;nc&quot;&gt;MODULE&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_TB&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TESTBENCH&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Vmodule&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;

	&lt;span class=&quot;k&quot;&gt;virtual&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;tick&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;c1&quot;&gt;// Request that the testbench toggle the clock within
&lt;/span&gt;		&lt;span class=&quot;c1&quot;&gt;// Verilator
&lt;/span&gt;		&lt;span class=&quot;n&quot;&gt;TESTBENCH&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Vmodule&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tick&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;

		&lt;span class=&quot;n&quot;&gt;bool&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;writeout&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;c1&quot;&gt;// Check for debugging conditions
&lt;/span&gt;		&lt;span class=&quot;c1&quot;&gt;//
&lt;/span&gt;		&lt;span class=&quot;c1&quot;&gt;// For example:
&lt;/span&gt;		&lt;span class=&quot;c1&quot;&gt;//
&lt;/span&gt;		&lt;span class=&quot;c1&quot;&gt;//   1. We might be interested any time a wishbone master
&lt;/span&gt;		&lt;span class=&quot;c1&quot;&gt;//	command is accepted
&lt;/span&gt;		&lt;span class=&quot;c1&quot;&gt;//
&lt;/span&gt;		&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_core&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v__DOT__wb_stb&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_core&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v__DOT__wb_stall&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;writeout&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;c1&quot;&gt;//
&lt;/span&gt;		&lt;span class=&quot;c1&quot;&gt;//   2. as well as when the slave finally responds
&lt;/span&gt;		&lt;span class=&quot;c1&quot;&gt;//
&lt;/span&gt;		&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_core&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v__DOT__wb_ack&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;writeout&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

		&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;writeout&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
			&lt;span class=&quot;c1&quot;&gt;// Now we&#39;ll debug by printf&#39;s and examine the
&lt;/span&gt;			&lt;span class=&quot;c1&quot;&gt;// internals of m_core
&lt;/span&gt;			&lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;%8ld: %s %s ...&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m_tickcount&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
				&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_core&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v__DOT__wb_cyc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;?&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;CYC&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;   &quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
				&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_core&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v__DOT__wb_stb&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;?&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;STB&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;   &quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
				&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
		&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Others who have looked at this approach consider it very “textual”.  It is.&lt;/p&gt;

&lt;p&gt;If you find “textual” to be old fashioned, then please consider that I maintain
a very old fashioned hammer in my garage for when I need such a tool.
Like my hammer, this old fashioned approach to debugging is still very
valuable.  When I was debugging the
&lt;a href=&quot;https://github.com/ZipCPU/openarty/blob/master/sw/board/hello.c&quot;&gt;Hello World&lt;/a&gt;
program in the &lt;a href=&quot;https://github.com/ZipCPU/openarty&quot;&gt;OpenArty&lt;/a&gt; project, as part
of both the first time the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;
supported the
C library as well as the first time it supported 8-bit bytes, this was the
approach I used when things weren’t working.  When I traced the problem down
to a value in memory that had the wrong value within it, I was then able to look
backwards through the massive textual output to find the exact memory operation
that had set the value erroneously.  I was then able to quickly find the
broken logic and fix the bug.&lt;/p&gt;

&lt;p&gt;This debug by &lt;a href=&quot;http://www.cplusplus.com/reference/cstdio/printf/&quot;&gt;printf&lt;/a&gt;
approach should satisfy most of the software programmers
out there who are used to finding bugs in this manner.&lt;/p&gt;

&lt;p&gt;Many hardware designers are going to look for something more.  Hence,
let’s look at how to use a graphical waveform viewer such as
&lt;a href=&quot;https://gtkwave.sourceforge.net&quot;&gt;GTKWave&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;debugging-verilog-via-gtkwave&quot;&gt;Debugging Verilog via GTKWave&lt;/h2&gt;

&lt;p&gt;If you’ve never used a waveform viewer, such as
&lt;a href=&quot;https://gtkwave.sourceforge.net&quot;&gt;GTKWave&lt;/a&gt;
before, then you are in for a treat.  Such graphical viewers are really an
essential part of any HDL designers toolkit.  Using
&lt;a href=&quot;https://gtkwave.sourceforge.net&quot;&gt;GTKWave&lt;/a&gt;, you can view and inspect
&lt;em&gt;every&lt;/em&gt; variable within your design on &lt;em&gt;every&lt;/em&gt; clock.&lt;/p&gt;

&lt;p&gt;Let’s rebuild our module so that it creates a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Value_change_dump&quot;&gt;VCD&lt;/a&gt; output file that can
then be read by &lt;a href=&quot;https://gtkwave.sourceforge.net&quot;&gt;GTKWave&lt;/a&gt;.  This will allow
us to examine our design using it.&lt;/p&gt;

&lt;p&gt;The first change we are going to need to make is to change how we call
&lt;a href=&quot;https://www.veripool.org/wiki/verilator/&quot;&gt;Verilator&lt;/a&gt;.
Specifically, we’ll add the “-trace” option to the command line.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;verilator -Wall -trace -cc module.v&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This will turn our module into a C++ class, found within obj_dir/Vmodule.h
and .cpp as before, but this time it can support tracing.  We can turn this
C++ class definition into a library in the same fashion as before.&lt;/p&gt;

&lt;p&gt;The next step in this process is going to be transforming the TESTBENCH wrapper
of our &lt;a href=&quot;https://www.veripool.org/wiki/verilator/&quot;&gt;Verilated&lt;/a&gt;
module.  If you want, you can follow along on how to do this from the
&lt;a href=&quot;https://www.veripool.org/wiki/verilator/&quot;&gt;Verilator&lt;/a&gt;
&lt;a href=&quot;https://www.veripool.org/projects/verilator/wiki/Manual-verilator#FREQUENTLY-ASKED-QUESTIONS&quot;&gt;FAQ&lt;/a&gt;, although I think you’ll find we go into a touch more
detail here.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;cp&quot;&gt;#include &amp;lt;verilated_vcd_c.h&amp;gt;
&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;template&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;MODULE&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;TESTBENCH&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;// Need to add a new class variable
&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;VerilatedVcdC&lt;/span&gt;	&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_trace&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;

	&lt;span class=&quot;n&quot;&gt;TESTBENCH&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;c1&quot;&gt;// According to the Verilator spec, you *must* call
&lt;/span&gt;		&lt;span class=&quot;c1&quot;&gt;// traceEverOn before calling any of the tracing functions
&lt;/span&gt;		&lt;span class=&quot;c1&quot;&gt;// within Verilator.
&lt;/span&gt;		&lt;span class=&quot;n&quot;&gt;Verilated&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;traceEverOn&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
		&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Everything else can stay like it was before
&lt;/span&gt;	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

	&lt;span class=&quot;c1&quot;&gt;// Open/create a trace file
&lt;/span&gt;	&lt;span class=&quot;k&quot;&gt;virtual&lt;/span&gt;	&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;opentrace&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vcdname&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_trace&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;m_trace&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;VerilatedVcdC&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;m_core&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;trace&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_trace&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;99&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;m_trace&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;open&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vcdname&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
		&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

	&lt;span class=&quot;c1&quot;&gt;// Close a trace file
&lt;/span&gt;	&lt;span class=&quot;k&quot;&gt;virtual&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;close&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_trace&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;m_trace&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;close&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;m_trace&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

	&lt;span class=&quot;k&quot;&gt;virtual&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;tick&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;c1&quot;&gt;// Make sure the tickcount is greater than zero before
&lt;/span&gt;		&lt;span class=&quot;c1&quot;&gt;// we do this
&lt;/span&gt;		&lt;span class=&quot;n&quot;&gt;m_tickcount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

		&lt;span class=&quot;c1&quot;&gt;// Allow any combinatorial logic to settle before we tick
&lt;/span&gt;		&lt;span class=&quot;c1&quot;&gt;// the clock.  This becomes necessary in the case where
&lt;/span&gt;		&lt;span class=&quot;c1&quot;&gt;// we may have modified or adjusted the inputs prior to
&lt;/span&gt;		&lt;span class=&quot;c1&quot;&gt;// coming into here, since we need all combinatorial logic
&lt;/span&gt;		&lt;span class=&quot;c1&quot;&gt;// to be settled before we call for a clock tick.
&lt;/span&gt;		&lt;span class=&quot;c1&quot;&gt;//
&lt;/span&gt;		&lt;span class=&quot;n&quot;&gt;m_core&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i_clk&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;m_core&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;eval&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;

		&lt;span class=&quot;c1&quot;&gt;//
&lt;/span&gt;		&lt;span class=&quot;c1&quot;&gt;// Here&#39;s the new item:
&lt;/span&gt;		&lt;span class=&quot;c1&quot;&gt;//
&lt;/span&gt;		&lt;span class=&quot;c1&quot;&gt;//	Dump values to our trace file
&lt;/span&gt;		&lt;span class=&quot;c1&quot;&gt;//
&lt;/span&gt;		&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;trace&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m_trace&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dump&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_tickcount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

		&lt;span class=&quot;c1&quot;&gt;// Repeat for the positive edge of the clock
&lt;/span&gt;		&lt;span class=&quot;n&quot;&gt;m_core&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i_clk&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;m_core&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;eval&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;trace&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m_trace&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dump&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_tickcount&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

		&lt;span class=&quot;c1&quot;&gt;// Now the negative edge
&lt;/span&gt;		&lt;span class=&quot;n&quot;&gt;m_core&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i_clk&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;m_core&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;eval&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_trace&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
			&lt;span class=&quot;c1&quot;&gt;// This portion, though, is a touch different.
&lt;/span&gt;			&lt;span class=&quot;c1&quot;&gt;// After dumping our values as they exist on the
&lt;/span&gt;			&lt;span class=&quot;c1&quot;&gt;// negative clock edge ...
&lt;/span&gt;			&lt;span class=&quot;n&quot;&gt;m_trace&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dump&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_tickcount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
			&lt;span class=&quot;c1&quot;&gt;//
&lt;/span&gt;			&lt;span class=&quot;c1&quot;&gt;// We&#39;ll also need to make sure we flush any I/O to
&lt;/span&gt;			&lt;span class=&quot;c1&quot;&gt;// the trace file, so that we can use the assert()
&lt;/span&gt;			&lt;span class=&quot;c1&quot;&gt;// function between now and the next tick if we want to.
&lt;/span&gt;			&lt;span class=&quot;n&quot;&gt;m_trace&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;flush&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
		&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Further, within our
&lt;a href=&quot;http://en.cppreference.com/w/cpp/language/main_function&quot;&gt;main()&lt;/a&gt;
function, we’ll add a line,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;n&quot;&gt;tb&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;opentrace&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;trace.vcd&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;any time we want to create a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Value_change_dump&quot;&gt;VCD&lt;/a&gt; output file.&lt;/p&gt;

&lt;p&gt;Building this new program is a touch more difficult than it was before.  You
are going to need to include the verilated_vcd_c.cpp file, but in all other
cases the build is the same.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;g++ -I obj_dir -I/usr/share/verilator/include module.cpp /usr/share/verilator/include/verilated.cpp /usr/share/verilator/include/verilated_vcd_c.cpp -o module&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;After you run your “module” file, you should now find a “trace.vcd” file
in your current directory.  Running “gtkwave trace.vcd” should give you a
chance to view all of the variables within your trace.  In other words, after
you finish a simulation, you can now view all of your internal register values,
at &lt;em&gt;every&lt;/em&gt; simulation clock tick.&lt;/p&gt;

&lt;h2 id=&quot;simulating-peripherals-with-verilator&quot;&gt;Simulating Peripherals with Verilator&lt;/h2&gt;

&lt;p&gt;At this point, we haven’t really done anything any other simulator cannot do.
We’ve simulated our program, &lt;em&gt;and&lt;/em&gt; we’ve created both a
&lt;a href=&quot;http://www.cplusplus.com/reference/cstdio/printf/&quot;&gt;printf&lt;/a&gt;
based dump of the program as well as trace.&lt;/p&gt;

&lt;p&gt;Where &lt;a href=&quot;https://www.veripool.org/wiki/verilator/&quot;&gt;Verilator&lt;/a&gt; really shines,
though, is in the ability to add simulated peripherals to the design.  Let’s
consider three peripherals as part of an example:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;A &lt;a href=&quot;https://github.com/ZipCPU/wbuart32/blob/master/bench/cpp/uartsim.cpp&quot;&gt;UART simulator&lt;/a&gt;
that allows you to connect the UART to either a file, or a TCP/IP stream.&lt;/p&gt;

    &lt;p&gt;The importance of this type of simulator cannot be overstated, as it allows
you to create a debugging interface to your board–an interface that you
can also access when running your simulator.&lt;/p&gt;

    &lt;p&gt;Many students have struggled to get their first UART up and running.  Having
a UART simulator, which would check their outputs and verify it’s validity
while acting &lt;em&gt;like&lt;/em&gt; a true UART would be valuable for them.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;A &lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/sim/verilated/qspiflashsim.cpp&quot;&gt;QSPI Flash simulator&lt;/a&gt;.  I’ve used this simulator many, many times to
not only verify that the core I am testing properly interacts with the
on-board flash, but also to know and understand how that flash interaction
impacts the rest of my design.&lt;/p&gt;

    &lt;p&gt;For example, using the
&lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/sim/verilated/qspiflashsim.cpp&quot;&gt;QSPI Flash simulator&lt;/a&gt;
together with the &lt;a href=&quot;https://github.com/ZipCPU/wbuart32/blob/master/bench/cpp/uartsim.cpp&quot;&gt;UART simulator&lt;/a&gt;, I
can start the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt; from a hard
reset and run all the way through &lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/sw/board/hello.c&quot;&gt;Hello
World&lt;/a&gt;
without leaving the simulation.&lt;/p&gt;

    &lt;p&gt;The other day, I had the chance to then compare how long it takes to do
this when using a
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/wbdmac.v&quot;&gt;DMA&lt;/a&gt;
based &lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/sw/zlib/crt0.c&quot;&gt;bootloader&lt;/a&gt;
approach, given that the simulations are &lt;em&gt;cycle accurate&lt;/em&gt;.
(The DMA approach is almost 2x as fast–but feel free to try it yourself
to find out.)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;An unpublished VGA simulator I used to process the VGA signal on my
&lt;a href=&quot;https://store.digilentinc.com/basys-3-artix-7-fpga-trainer-board-recommended-for-introductory-users&quot;&gt;Basys3&lt;/a&gt;
board.  Using this simulator, I was not only able to verify the
functionality of my VGA outputs, but I was also able to display the pixels
that would be displayed on any VGA screen within an X-window on my own
development workstation.&lt;/p&gt;

    &lt;p&gt;Who knows?  I may have the opportunity to present this simulator as part of
this blog.&lt;/p&gt;

    &lt;p&gt;Compare this simulator, though, to &lt;a href=&quot;http://vgasim.sourceforge.net&quot;&gt;an
alternative&lt;/a&gt; that works with your more
commercial simulation products.  Unlike that approach, if you had a
simulator integrated into
&lt;a href=&quot;https://www.veripool.org/wiki/verilator/&quot;&gt;Verilator&lt;/a&gt;,
you could then interact with your VGA display in real simulation time–even
if it is a slower (realtime) than the actual hardware would’ve provided.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;To incorporate these changes into our module’s simulation, we only need to
make some minor adjustments to our overloaded tick() method.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;c1&quot;&gt;// Include the files defining our various simulation components
&lt;/span&gt;&lt;span class=&quot;cp&quot;&gt;#include &amp;lt;uartsim.h&amp;gt;
#include &amp;lt;qspiflashsim.h&amp;gt;
#include &amp;lt;vgasim.h&amp;gt;
&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;MODULE&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_TB&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TESTBENCH&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Vmodule&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;// Add the simulation components to the variables used by our module&#39;s
&lt;/span&gt;	&lt;span class=&quot;c1&quot;&gt;// test bench
&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;UARTSIM&lt;/span&gt;		&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_uart&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;QSPIFLASHSIM&lt;/span&gt;	&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_flash&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;VGASIM&lt;/span&gt;		&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_vga&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

	&lt;span class=&quot;n&quot;&gt;MODULE_TB&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;c1&quot;&gt;// Initialize as before
&lt;/span&gt;		&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;
		&lt;span class=&quot;c1&quot;&gt;// Then make sure we create our simulation components
&lt;/span&gt;		&lt;span class=&quot;n&quot;&gt;m_uart&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;UARTSIM&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;m_qspi&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;QSPIFLASHSIM&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;m_vga&lt;/span&gt;  &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;VGASIM&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

	&lt;span class=&quot;k&quot;&gt;virtual&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;tick&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;c1&quot;&gt;// Simulation instructions
&lt;/span&gt;		&lt;span class=&quot;c1&quot;&gt;//
&lt;/span&gt;		&lt;span class=&quot;c1&quot;&gt;// Prior to actually ticking the clock, call any simulation
&lt;/span&gt;		&lt;span class=&quot;c1&quot;&gt;// functions
&lt;/span&gt;
		&lt;span class=&quot;c1&quot;&gt;// Simulate a UART
&lt;/span&gt;		&lt;span class=&quot;n&quot;&gt;m_core&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i_uart&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m_uart&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_core&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;o_uart&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

		&lt;span class=&quot;c1&quot;&gt;// Simulate a QSPI Flash
&lt;/span&gt;		&lt;span class=&quot;n&quot;&gt;m_core&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i_qspi_data&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;qspi_flash_simulator&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_core&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;o_qspi_clk&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;m_core&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;o_qspi_cs_n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m_core&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;o_qspi_data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;m_core&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;o_qspi_output_mode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

		&lt;span class=&quot;c1&quot;&gt;// Simulate a VGA
&lt;/span&gt;		&lt;span class=&quot;n&quot;&gt;m_vga&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_core&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;o_vga_vsync&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;m_core&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;o_vga_hsync&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;m_core&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;o_vga_red&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;m_core&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;o_vga_grn&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;m_core&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;o_vga_blue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

		&lt;span class=&quot;c1&quot;&gt;//
&lt;/span&gt;		&lt;span class=&quot;c1&quot;&gt;// Now that we have our simulation inputs/outputs handled,
&lt;/span&gt;		&lt;span class=&quot;c1&quot;&gt;// let&#39;s actually toggle our clock
&lt;/span&gt;		&lt;span class=&quot;c1&quot;&gt;//
&lt;/span&gt;		&lt;span class=&quot;n&quot;&gt;TESTBENCH&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Vmodule&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tick&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;

		&lt;span class=&quot;c1&quot;&gt;// This is the code we had before
&lt;/span&gt;		&lt;span class=&quot;n&quot;&gt;bool&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;writeout&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Here, you can see how our overloaded tick() method first called the update
methods of any simulators we had introduced.
This guarantees that such simulators can handle data on a clock by clock basis,
verifying the outputs of your design, and providing whatever capability is
necessary on every clock tick.  Once any simulation inputs or outputs have
been handled, we then call the test bench’s tick method, so as to handle
toggling the clock, keeping track of simulation time, and writing anything to
the trace file.&lt;/p&gt;

&lt;p&gt;Let’s pause for a moment at this point and let what we’ve just done sink
in.&lt;/p&gt;

&lt;p&gt;Perhaps some examples will help.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;I’ve used this approach to debug my
&lt;a href=&quot;http://opencores.org/project,qspiflash&quot;&gt;QSPIFLASH&lt;/a&gt; controller.  Yes, I did
this using the debug by
&lt;a href=&quot;http://www.cplusplus.com/reference/cstdio/printf/&quot;&gt;printf&lt;/a&gt;
method to find problems.  I also placed assert statements within the QSPI
flash decoding logic of the simulator.  This would cause the QSPI flash
controller to &lt;em&gt;halt&lt;/em&gt; the simulation any time it detected an error in the
protocol.  For example, I could detect whether or not I waited enough
clocks on startup before issuing the first command.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;I’ve used this approach to debug the &lt;a href=&quot;https://github.com/ZipCPU/xulalx25soc/blob/master/rtl/wbsdram.v&quot;&gt;SDRAM
controller&lt;/a&gt;
that I built for the XuLA2-LX25 board.  Because the &lt;a href=&quot;https://github.com/ZipCPU/xulalx25soc/blob/master/bench/cpp/sdramsim.cpp&quot;&gt;SDRAM
simulation&lt;/a&gt;
I built was cycle accurate, I could then run performance and bench testing
programs on the board later, and know just how well the board would perform.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The VGA simulator on my
&lt;a href=&quot;https://store.digilentinc.com/basys-3-artix-7-fpga-trainer-board-recommended-for-introductory-users&quot;&gt;Basys3&lt;/a&gt;
board might be worth discussing for a moment.&lt;/p&gt;

    &lt;p&gt;Because the
&lt;a href=&quot;https://store.digilentinc.com/basys-3-artix-7-fpga-trainer-board-recommended-for-introductory-users&quot;&gt;Basys3&lt;/a&gt;
didn’t have enough RAM for a frame buffer, I had to place
the video data into the QSPI flash memory.  To make matters worse, I needed
to compress
the flash (run length encoding) to get the data so that I could load it
fast enough to support the VGA frame rate I was working with.&lt;/p&gt;

    &lt;p&gt;When I tried the algorithm out on the real hardware, the initial result was
quite jumbled–as one might expect from the first time you try to build and
test &lt;em&gt;any&lt;/em&gt; decompression algorithm.  However, by simulating the video
hardware, I could find and pinpoint where the run-length decoding went bad,
and therefore fix my algorithm.&lt;/p&gt;

    &lt;p&gt;Further, because I was using a cycle accurate QSPI flash simulator (from
above), I could make certain that I was meeting the timing I needed to meet
to make this VGA run without data loss.&lt;/p&gt;

    &lt;p&gt;I expect to need to build an HDMI simulator in the near future as well–both
for input as well as output.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;I also used this approach to debug an &lt;a href=&quot;https://github.com/ZipCPU/sdspi&quot;&gt;SD-card
controller&lt;/a&gt; that controls an SD card via a
SPI interface.&lt;/p&gt;

    &lt;p&gt;Given the opportunity, I’ll likely use the same method to build and debug
a similar controller using the SDIO interface instead of the SPI interface
in the future.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Other things I’ve simulated include a PS/2 mouse connected to my
&lt;a href=&quot;https://store.digilentinc.com/basys-3-artix-7-fpga-trainer-board-recommended-for-introductory-users&quot;&gt;Basys3&lt;/a&gt;
board, the ethernet controller on my
&lt;a href=&quot;http://store.digilentinc.com/arty-artix-7-fpga-development-board-for-makers-and-hobbyists&quot;&gt;Arty&lt;/a&gt; board,
the GPS PPS signal from a &lt;a href=&quot;http://store.digilentinc.com/pmod-gps-gps-receiver&quot;&gt;PMod GPS&lt;/a&gt;,
and even a &lt;a href=&quot;http://store.digilentinc.com/pmod-oledrgb-96-x-64-rgb-oled-display-with-16-bit-color-resolution&quot;&gt;PMod OLEDrgb board&lt;/a&gt;.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Here’s another neat fact in all of this: because these simulations are built
from independent source code modules, we can link them together to create
intregrated simulations as well.  As an example, I can now simulate the
&lt;a href=&quot;https://github.com/ZipCPU/&quot;&gt;ZipCPU&lt;/a&gt; in an
&lt;a href=&quot;https://github.com/ZipCPU/zbasic&quot;&gt;environment&lt;/a&gt; where the CPU has
access not not only a UART, but also an SD-Card.&lt;/p&gt;

&lt;h2 id=&quot;only-one-clock&quot;&gt;Only one clock&lt;/h2&gt;

&lt;p&gt;While this approach is very powerful, what I’ve demonstrated above only
demonstrates applying
&lt;a href=&quot;https://www.veripool.org/wiki/verilator/&quot;&gt;Verilator&lt;/a&gt;
to a design with a single clock.&lt;/p&gt;

&lt;p&gt;I’m currently working on a design of a Video driver that will read HDMI
signals at one rate, write HDMI signals back out at (perhaps) another rate,
interact
with the CPU at a fourth rate, and interact with DDR3 SDRAM memory at a fifth
rate.  While &lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt; can currently build
a test harness for such a simulation, the work to handle all of these clocks
and to display the resulting video is far from complete.
This may even include &lt;a href=&quot;https://www.veripool.org/wiki/verilator/&quot;&gt;Verilator&lt;/a&gt;
support for having one of those clocks have an adjustable period–but we’ll
see what is required for actually making all of that work.&lt;/p&gt;

&lt;p&gt;In other words, should you find the amazing
&lt;a href=&quot;https://www.veripool.org/wiki/verilator/&quot;&gt;Verilator&lt;/a&gt;
capabilities outlined above valuable when using a single clock, then
please consider yourself invited to contact the author of
&lt;a href=&quot;https://www.veripool.org/wiki/verilator/&quot;&gt;Verilator&lt;/a&gt; and support his work.&lt;/p&gt;

&lt;p&gt;If you would like to help fund my own work of creating a test harness that will
support multiple clocks, and even HDMI video, please feel free to &lt;a href=&quot;https://www.patreon.com/ZipCPU&quot;&gt;support 
this blog on Patreon&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;other-benefits&quot;&gt;Other Benefits&lt;/h2&gt;

&lt;p&gt;Before I leave off discussing the value of
&lt;a href=&quot;https://www.veripool.org/wiki/verilator/&quot;&gt;Verilator&lt;/a&gt;
to discuss its limitations,
let me add one more item to my list of its benefits: It’s a &lt;em&gt;lot&lt;/em&gt; faster to
compile a Verilog module using Verilator than it is to compile and build it
using a more traditional synthesis tool and design flow.&lt;/p&gt;

&lt;p&gt;What I mean by this is, if I start a Vivado design build and a
&lt;a href=&quot;https://www.veripool.org/wiki/verilator/&quot;&gt;Verilator&lt;/a&gt;
design build at the same time, then I will have found any synthesis bugs
with
&lt;a href=&quot;https://www.veripool.org/wiki/verilator/&quot;&gt;Verilator&lt;/a&gt;
long before Vivado completes.&lt;/p&gt;

&lt;p&gt;Further,
&lt;a href=&quot;https://www.veripool.org/wiki/verilator/&quot;&gt;Verilator&lt;/a&gt;
finds many bugs that Vivado either does not find, or that it buries in a long
list of useless warnings.&lt;/p&gt;

&lt;p&gt;Put together, these facts provide me with the motivation I need to build my
projects within &lt;a href=&quot;https://www.veripool.org/wiki/verilator/&quot;&gt;Verilator&lt;/a&gt;
before trying to build it with a commercial synthesis tool.  Finding and
fixing bugs is just so much faster and easier with
Verilator.&lt;/p&gt;

&lt;p&gt;On the other hand, &lt;a href=&quot;https://www.veripool.org/wiki/verilator/&quot;&gt;Verilator&lt;/a&gt;
tends to run my 100MHz clock at about 300kHz (without optimization),
so there does come a transition point where using the real hardware becomes
faster/better/cheaper than using
&lt;a href=&quot;https://www.veripool.org/wiki/verilator/&quot;&gt;Verilator&lt;/a&gt;’s simulation capability.&lt;/p&gt;

&lt;h2 id=&quot;verilators-limitations&quot;&gt;Verilator’s Limitations&lt;/h2&gt;

&lt;p&gt;While I have very much grown to love using the
&lt;a href=&quot;https://www.veripool.org/wiki/verilator/&quot;&gt;Verilator&lt;/a&gt;
approach I just outlined above, there are a couple of limitations I’ve come
across when using it:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;You can only design components for which you have all of the Verilog
logic in hand.&lt;/p&gt;

    &lt;p&gt;For example, while there exist proprietary &lt;a href=&quot;https://www.xilinx.com/support/documentation/ip_documentation/xfft/v9_0/pg109-xfft.pdf&quot;&gt;vendor supplied
FFT’s&lt;/a&gt;,
you will struggle to use them within
&lt;a href=&quot;https://www.veripool.org/wiki/verilator/&quot;&gt;Verilator&lt;/a&gt;.&lt;/p&gt;

    &lt;p&gt;This will force you to either abandon
&lt;a href=&quot;https://www.veripool.org/wiki/verilator/&quot;&gt;Verilator&lt;/a&gt;, to look for
an open source &lt;a href=&quot;https://github.com/ZipCPU/dblclockfft&quot;&gt;alternative to their
FFT&lt;/a&gt;s,
or to simulate every portion of your design &lt;em&gt;except&lt;/em&gt; for the proprietary
component.&lt;/p&gt;

    &lt;p&gt;As a second example, while both Xilinx and Altera will provide you with
a soft core CPU and toolchain, you will struggle to test such a CPU within
&lt;a href=&quot;https://www.veripool.org/wiki/verilator/&quot;&gt;Verilator&lt;/a&gt;.&lt;/p&gt;

    &lt;p&gt;On the other hand, you could still verify your design using
&lt;a href=&quot;https://www.veripool.org/wiki/verilator/&quot;&gt;Verilator&lt;/a&gt;
if you were using a &lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;.
Gosh, even the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt; debugger can run
within &lt;a href=&quot;https://www.veripool.org/wiki/verilator/&quot;&gt;verilator&lt;/a&gt;, using the same
serial port interface it would have were it running on an FPGA.  Hence, as
with the FFT, open source alternative’s exist.  (I’ve also managed to run
the &lt;a href=&quot;https://openrisc.io&quot;&gt;OpenRISC CPU&lt;/a&gt; within
&lt;a href=&quot;https://www.veripool.org/wiki/verilator/&quot;&gt;Verilator&lt;/a&gt; as well, so
the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt; is by no means
unique–although I did need to add a &lt;a href=&quot;https://github.com/ZipCPU/wbuart32/blob/master/bench/cpp/uartsim.cpp&quot;&gt;UART
simulation&lt;/a&gt;
to the &lt;a href=&quot;https://openrisc.io&quot;&gt;OpenRISC CPU&lt;/a&gt; to do it.)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://www.veripool.org/wiki/verilator/&quot;&gt;Verilator&lt;/a&gt;
only works with Verilog, not VHDL.  Perhaps you would like to write or
contribute to a VHDL extension to
&lt;a href=&quot;https://www.veripool.org/wiki/verilator/&quot;&gt;Verilator&lt;/a&gt;?  That’s the beauty
of open source, right?&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://www.veripool.org/wiki/verilator/&quot;&gt;Verilator&lt;/a&gt;
has only limited support for tri-state busses, and absolutely no support
for vendor specific things such as clock modules or SERDES capabilities.&lt;/p&gt;

    &lt;p&gt;I get around this by placing all of my logic within a vendor-independent
module.  This is my “main” module beneath the top level file containing any
vendor dependent capabilities.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://www.veripool.org/wiki/verilator/&quot;&gt;Verilator&lt;/a&gt;
has no support for handling ‘x’ (unknown) values or ‘z’ (high impedence)
values.  Neither does &lt;a href=&quot;https://www.veripool.org/wiki/verilator/&quot;&gt;Verilator&lt;/a&gt;
recognize or comment on any potential clock transition conflicts, or
&lt;a href=&quot;https://en.wikipedia.org/wiki/Metastability_in_electronics&quot;&gt;metastability&lt;/a&gt;
issues.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Synthesizing a project with
&lt;a href=&quot;https://www.veripool.org/wiki/verilator/&quot;&gt;Verilator&lt;/a&gt;
will provide you no feedback regarding whether or not your design will fit
within a particular device, neither whether or not your design would meet
the timing requirements of a particular device.  You still need a fullblown
FPGA tool chain to find out these things.&lt;/p&gt;

    &lt;p&gt;While I recommend &lt;a href=&quot;https://www.veripool.org/wiki/verilator/&quot;&gt;Verilator&lt;/a&gt; as
an approach for young engineers just learning to program in Verilog for
the first time, this is the biggest limitation.  The reality is that,
at some time, you will need to convert your design into a physical
reality, and at that time you’re going to want to know if it will work
on your target device.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Still, with all its limitations,
&lt;a href=&quot;https://www.veripool.org/wiki/verilator/&quot;&gt;Verilator&lt;/a&gt; has been a fundamental
component of every one of my designs.&lt;/p&gt;

&lt;h2 id=&quot;my-personal-experience&quot;&gt;My Personal Experience&lt;/h2&gt;

&lt;p&gt;If you look across the &lt;a href=&quot;https://github.com/ZipCPU&quot;&gt;various projects I’ve posted on
GitHub&lt;/a&gt;, you may notice that almost all of them use
&lt;a href=&quot;https://www.veripool.org/wiki/verilator/&quot;&gt;Verilator&lt;/a&gt; for simulation.
Even the &lt;a href=&quot;https://github.com/ZipCPU/tttt&quot;&gt;4x4x4 Tic-tac-toe program&lt;/a&gt; that I
posted to test the C-library on my devices can run on the
&lt;a href=&quot;https://github.com/ZipCPU&quot;&gt;ZipCPU&lt;/a&gt; using
&lt;a href=&quot;https://www.veripool.org/wiki/verilator/&quot;&gt;Verilator&lt;/a&gt;.
Perhaps the best recommendation I can give for
&lt;a href=&quot;https://www.veripool.org/wiki/verilator/&quot;&gt;Verilator&lt;/a&gt;, therefore, is simply
the facts that 1) these projects work, 2) some of them are both quite
capable and complex, and 3) they have all been debugged with
&lt;a href=&quot;https://www.veripool.org/wiki/verilator/&quot;&gt;Verilator&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;How about your experience?  I’d love to hear some of your comments below.&lt;/p&gt;

</description>
        <pubDate>Wed, 21 Jun 2017 00:00:00 -0400</pubDate>
        <link>http://zipcpu.com/blog/2017/06/21/looking-at-verilator.html</link>
        <guid isPermaLink="true">http://zipcpu.com/blog/2017/06/21/looking-at-verilator.html</guid>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>Putting our Debugging Bus RTL Components Together</title>
        <description>&lt;p&gt;We’ve slowly but surely now built up all of the pieces necessary to build a
debugging bus to provide wishbone master access into an FPGA.&lt;/p&gt;

&lt;table style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 1: WB-UART Overview&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/wb-uart-smpl-2.svg&quot; alt=&quot;Block Diagram of a Simpler Wishbone to UART converter&quot; width=&quot;360&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;As we’ve done so, we’ve gone through several posts to get here describing all
of the various components.  Here’s a list of those previous posts in this
series, in case you wish to start at the beginning and go through this
development.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;/blog/2017/06/05/wb-bridge-overview.html&quot;&gt;An overview of a UART to wishbone
bridge&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;How to build a &lt;a href=&quot;/blog/2017/06/08/simple-wb-master.html&quot;&gt;Simple Wishbone Master&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;How to &lt;a href=&quot;/blog/2017/06/14/creating-words-from-bytes.html&quot;&gt;create bus command words from a 7-bit data stream&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;How to &lt;a href=&quot;/blog/2017/06/15/words-back-to-bytes.html&quot;&gt;turn the bus master responses back into a serial stream&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;How to &lt;a href=&quot;/blog/2017/06/16/adding-ints.html&quot;&gt;add interrupts to our interface&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;/blog/2017/06/16/adding-ints.html&quot;&gt;Adding idles to our interface&lt;/a&gt;, to help recognize that it is up and running on a given serial port.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Today’s post is about putting all of these components together.  When we are
done, we’ll have a working debug bus that you can use to read and write from
a &lt;a href=&quot;https://opencores.org/opencores,wishbone&quot;&gt;wishbone bus&lt;/a&gt; within your design.&lt;/p&gt;

&lt;p&gt;In this design, we have very few module level requirements.  Our big goal
is little more than that we put all the pieces together, as outlined in 
Fig. 1 above.  Hence we’ll jump right into putting the pieces together.&lt;/p&gt;

&lt;h2 id=&quot;putting-the-pieces-together&quot;&gt;Putting the Pieces Together&lt;/h2&gt;

&lt;p&gt;You can find our various pieces so far
&lt;a href=&quot;https://github.com/ZipCPU/dbgbus/tree/master/hexbus&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;As we put these components together, we’ll skip for discussion purposes the
register and wire definitions, as well as the module interface definition.
If you’d like to see all of the pieces, including these definitions,
please feel free to examine the final module code 
&lt;a href=&quot;https://github.com/ZipCPU/dbgbus/blob/master/hexbus/rtl/hbbus.v&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The &lt;a href=&quot;https://github.com/ZipCPU/dbgbus/blob/master/rtl/hbdechex.v&quot;&gt;first
component&lt;/a&gt; will
take our incoming stream and turn it into 5-bit data words having a binary
representation.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;hbdechex dechxi(i_clk, i_rx_stb, i_rx_byte,
		dec_stb, w_reset, dec_bits);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Note that it takes a module level input, &lt;strong&gt;i_rx_byte&lt;/strong&gt;,
containing the received byte, together with a strobe, &lt;strong&gt;i_rx_stb&lt;/strong&gt;, which
will be true for the one clock when &lt;strong&gt;i_rx_byte&lt;/strong&gt; is true.  In a similar
fashion, the outputs bits will be placed into &lt;strong&gt;dec_bits&lt;/strong&gt;, which will be
valid any time &lt;strong&gt;dec_stb&lt;/strong&gt; is true.&lt;/p&gt;

&lt;p&gt;One unique feature of this component is the &lt;strong&gt;w_reset&lt;/strong&gt; signal that will be
true for one clock, on the clock after ‘T’ was received.  We’ll use this
signal to reset all of our processing components.&lt;/p&gt;

&lt;p&gt;The &lt;a href=&quot;https://github.com/ZipCPU/dbgbus/blob/master/rtl/hbpack.v&quot;&gt;next
component&lt;/a&gt; will
then pack our 4-bit values into a 32-bit word.  It will also keep track of
word transitions, and note when any new word begins.  Upon the beginning of a
word, or for that matter any unknown character, the interface will push
forward any command currently within its buffer.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;hbpack	packxi(i_clk, w_reset,
	dec_stb, dec_bits, iw_stb, iw_word);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;You may have noticed by now that I like to differentiate things by
prefix.  The ouputs of this module have the &lt;strong&gt;iw_&lt;/strong&gt; prefix, indicating
that they are the incoming words.&lt;/p&gt;

&lt;p&gt;Had you tried to jump into this whole process at the beginning, without the
experience of having done all of our work so far, you might’ve thought that
the &lt;a href=&quot;https://github.com/ZipCPU/dbgbus/blob/master/rtl/hbexec.v&quot;&gt;bus master&lt;/a&gt;
component would be the primary component.  The reality is that thus bus master
function wouldn’t be able to function apart from the other components around it.
The reason is that &lt;em&gt;something&lt;/em&gt; needs to tell it what addresses to read and
write from the bus.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;hbexec	wbexec(i_clk, w_reset, iw_stb, iw_word, wb_busy,
		ow_stb, ow_word,
		o_wb_cyc, o_wb_stb, o_wb_we, o_wb_addr, o_wb_data,
			o_wb_sel, i_wb_ack, i_wb_stall, i_wb_err,
			i_wb_data);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Here, it takes its inputs from the &lt;strong&gt;iw_word&lt;/strong&gt;, initiates a bus command, and
returns its results in the &lt;strong&gt;ow_word&lt;/strong&gt;.  Both of these words will be true
on the one clock with their &lt;strong&gt;_stb&lt;/strong&gt; line is true.  The actual bus master
wires are prefixed with &lt;strong&gt;o_wb_&lt;/strong&gt; if they go from the master to the slave, and
&lt;strong&gt;i_wb_&lt;/strong&gt; if they are returning values from the slave.  Further, because these
have the &lt;strong&gt;i_&lt;/strong&gt; and &lt;strong&gt;o_&lt;/strong&gt; prefixes, you can tell (from my own notation
convention) that these particular values are module level inputs and outputs.&lt;/p&gt;

&lt;p&gt;At this point, our interface changes somewhat.  Prior to this part of our
design, subsequent modules were required to be prepared for an input that
could take place at any clock.  The serial port transmitter, however, at the
other end of this stream cannot handle data at &lt;em&gt;any&lt;/em&gt; rate given to it.  So,
we’re going to need to slow things down.  We’ll do this with the &lt;strong&gt;_busy&lt;/strong&gt;
signal.  Each unit in this return chain will accept a &lt;strong&gt;_stb&lt;/strong&gt; word indicating
that it’s next input word is valid and ready, and it will produce a &lt;strong&gt;_stb&lt;/strong&gt;
word indicating that it’s output word is valid and ready.  However, to keep
the interface from moving faster than our resulting transmit transport can
handle, we’ll insist that transactions only take place when the &lt;strong&gt;_stb&lt;/strong&gt; is
valid &lt;em&gt;and&lt;/em&gt; the &lt;strong&gt;_busy&lt;/strong&gt; associated with that stage is false.  Hence, once
the &lt;strong&gt;_stb&lt;/strong&gt; signal is raised, it must remain so and the &lt;strong&gt;_word&lt;/strong&gt; value
must not change until the &lt;strong&gt;_busy&lt;/strong&gt; line from the receiving entity has dropped.&lt;/p&gt;

&lt;p&gt;This is actually a fairly common protocol, used by busses ranging from
&lt;a href=&quot;http://www.gstitt.ece.ufl.edu/courses/fall15/eel4720_5721/labs/refs/AXI4_specification.pdf&quot;&gt;AXI&lt;/a&gt;
to &lt;a href=&quot;https://opencores.org/cdn/downloads/wbspec_b4.pdf&quot;&gt;Wishbone&lt;/a&gt; and more.&lt;/p&gt;

&lt;p&gt;The &lt;a href=&quot;https://github.com/ZipCPU/dbgbus/blob/master/rtl/addints.v&quot;&gt;first
component&lt;/a&gt;
to use this new interface approach is the 
&lt;a href=&quot;https://github.com/ZipCPU/dbgbus/blob/master/rtl/addints.v&quot;&gt;addints&lt;/a&gt;
module that adds interrupt notifications into our stream.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;hbints	addints(i_clk, w_reset, i_interrupt,
		ow_stb,  ow_word,  int_busy,
		int_stb, int_word, idl_busy);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This stage also acts like a one-stage FIFO, giving us a little bit of a buffer
should responses come from the master too fast for us to deal with them.&lt;/p&gt;

&lt;p&gt;You can see the &lt;strong&gt;_busy&lt;/strong&gt; line coming from the next stage on the third
line, together with the output lines &lt;strong&gt;int_stb&lt;/strong&gt; and &lt;strong&gt;int_word&lt;/strong&gt;.
The first line contains the &lt;strong&gt;int_busy&lt;/strong&gt; line which would’ve gone to the
prior stage, had we had one that accepted it.  We’ll leave it here unconnected
so that we can grab it when we add a FIFO in to this interface later.&lt;/p&gt;

&lt;p&gt;The &lt;a href=&quot;https://github.com/ZipCPU/dbgbus/blob/master/rtl/addints.v&quot;&gt;addints&lt;/a&gt;
module is followed by the &lt;a href=&quot;https://github.com/ZipCPU/dbgbus/blob/master/rtl/addidles.v&quot;&gt;debug
idles&lt;/a&gt; component
that adds idle words into the output stream.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	hbidle	addidles(i_clk, w_reset,
			int_stb, int_word, idl_busy,
			idl_stb, idl_word, hb_busy);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;We then &lt;a href=&quot;https://github.com/ZipCPU/dbgbus/blob/master/rtl/hbdeword.v&quot;&gt;unpack
our words&lt;/a&gt; back
into the five-bit components that had composed them originally on input.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;hbdeword unpackx(i_clk, w_reset,
		idl_stb, idl_word, hb_busy,
		hb_stb, hb_bits, hx_busy);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;These 5-bit components then &lt;a href=&quot;https://github.com/ZipCPU/dbgbus/blob/master/rtl/hbdeword.v&quot;&gt;get
converted&lt;/a&gt; into
bytes for the transport.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	hbgenhex genhex(i_clk, hb_stb, hb_bits, hx_busy,
			hx_stb, hx_byte, nl_busy);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;If the transport ever clears and becomes idle, we’ll &lt;a href=&quot;https://github.com/ZipCPU/dbgbus/blob/master/rtl/hbnewline.v&quot;&gt;add a carriage return
linefeed pair&lt;/a&gt;
to the interface.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;hbnewline addnl(i_clk, w_reset, hx_stb, hx_byte, nl_busy,
		o_tx_stb, o_tx_byte, i_tx_busy);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;That way any line-based stream logic will know to flush its buffer, since any
partial response would’ve now been completed.&lt;/p&gt;

&lt;h2 id=&quot;future-posts&quot;&gt;Future Posts&lt;/h2&gt;

&lt;p&gt;Although this concludes the Verilog development of the debug bus we’ve been
working through, the task isn’t over.  If you have a wishbone bus
that you would like to experiment with commanding, feel free to fire this up
and give it a try.  At this point, you have the basics of a capability.&lt;/p&gt;

&lt;p&gt;The basics.  In otherwords, while it’s an RTL bus, it doesn’t do anything yet.
We can use it to gain access into a system, but we don’t (yet) have any system
built that we might use this to gain access to.  So, we’re not done yet.&lt;/p&gt;

&lt;p&gt;The next items in this series will discuss:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;/blog/2017/06/22/simple-wb-interconnect.html&quot;&gt;How to create a simple wishbone interconnect&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;This will consist of some “interesting” things that we can put together and
test.  We’ll use a block RAM component and a &lt;a href=&quot;https://github.com/ZipCPU/wbscope&quot;&gt;Wishbone
scope&lt;/a&gt; for this purpose, as well as a
fairly generic set of simple registers.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Creating a &lt;a href=&quot;/blog/2017/06/26/dbgbus-verilator.html&quot;&gt;hand-controlled test
bench&lt;/a&gt; to prove
this works&lt;/p&gt;

    &lt;p&gt;This will be about building a test bench that we can use to run this whole
package in Verilator.&lt;/p&gt;

    &lt;p&gt;Once you get this far, you have an example of something that you can put
in your hardware and try.  But … we’re still not done.  While you may find
the interface somewhat usable, a software controller would make it much
easier to use.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Creating a software bus controller&lt;/p&gt;

    &lt;p&gt;That hand-typed interface is going to get old.  We’ll build a software
interface when we get to this point.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Still, this simple debugging bus is now our first design component, and almost
a first design.&lt;/p&gt;

</description>
        <pubDate>Tue, 20 Jun 2017 00:00:00 -0400</pubDate>
        <link>http://zipcpu.com/blog/2017/06/20/dbg-put-together.html</link>
        <guid isPermaLink="true">http://zipcpu.com/blog/2017/06/20/dbg-put-together.html</guid>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>Sending bus idle notifications down the line</title>
        <description>&lt;p&gt;If you haven’t been paying attention to how we’ve built our debug bus master
access into a wishbone device, you might wish to look at some of the other
posts in this series:&lt;/p&gt;

&lt;table style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 1: WB-UART Overview&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/wb-uart-smpl-2.svg&quot; alt=&quot;Block Diagram of a Simpler Wishbone to UART converter&quot; width=&quot;360&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;/blog/2017/06/05/wb-bridge-overview.html&quot;&gt;An overview of a UART to wishbone
bridge&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;How to build a &lt;a href=&quot;/blog/2017/06/08/simple-wb-master.html&quot;&gt;Simple Wishbone Master&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;How to &lt;a href=&quot;/blog/2017/06/14/creating-words-from-bytes.html&quot;&gt;create bus command words from a 7-bit data stream&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;How to &lt;a href=&quot;/blog/2017/06/15/words-back-to-bytes.html&quot;&gt;turn the bus master responses back into a serial stream&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;How to &lt;a href=&quot;/blog/2017/06/16/adding-ints.html&quot;&gt;add interrupts to our interface&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Today, we’re going to add idle notifications to our stream.  These notifications
will help to identify this stream to you any time it is idle.  The result is
that, when you connect to one of these busses, you should know you have a valid
connection once you see the idle character passing through the stream.&lt;/p&gt;

&lt;h2 id=&quot;idle-requirements&quot;&gt;Idle Requirements&lt;/h2&gt;

&lt;p&gt;We want to keep this idle capability simple.  If we draw out the idea of this
idle capability a little bit, we’ll discover we want the following capabilities
in this idle component:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;There should never be any idle characters while the interface is busy.  That
way the idle character won’t slow down any valid transactions.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;An idle character should be sent in the stream somewhere between every
one and ten seconds, yet at regular intervals.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The first idle following any activity shouldn’t show up until one time
interval’s distance from the last valid piece of information.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;If the interface is stopped, such as if the bus is commanded via a SPI slave
port, we shouldn’t accumulate more than a single idle character to be
returned.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;In sum, if you watch this stream, you should be able to identify this
stream as a debug controller within a short number of seconds.&lt;/p&gt;

&lt;h2 id=&quot;the-idle-stream-processor&quot;&gt;The idle stream processor&lt;/h2&gt;

&lt;p&gt;This section will walk through an example idle stream processor, showing you
how to add idle characters (“Z”) into our response stream.&lt;/p&gt;

&lt;p&gt;The first step in any protocol handling is to define the protocol words.
In this case, we’ll be sending an &lt;strong&gt;IDLE_WORD&lt;/strong&gt; down the line.  This
will turn into a “Z” when received with the strobe high.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;`define	IDLE_SUB_WORD	5&#39;b11011
`define	IDLE_WORD	{ `IDLE_SUB_WORD, {(34-5){1&#39;b0}} }&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Knowing when to insert an idle character is pretty simple.  By using the &lt;a href=&quot;/blog/2017/06/02/generating-timing.html&quot;&gt;timing
techniques shared
here&lt;/a&gt;, we can
create a strobe every 2^28 clocks, or about every two and a half seconds.
By clearing our idle counter on every input command or reset, we’ll guarantee
that the next idle will be at least two and a half seconds after any
activity.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;initial	idle_stb      = 0;
initial	idle_counter  = 0;
always @(posedge i_clk)
	if ((i_reset)||(i_cmd_stb))
		idle_counter &amp;lt;= 0;
	else
		{ idle_stb, idle_counter } &amp;lt;= idle_counter + 1&#39;b1;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Now that we know when we wish to insert an idle, the next step is to know
when to output an idle character.  In our case, we’ll output a character,
whether idle or not, any time the indication above takes place or any
time an incoming word takes place.  As a result, this will be a pass-through
component–and only change the input when nothing’s there.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	initial	o_idl_stb = 1&#39;b0;
	always @(posedge i_clk)
		if (i_reset)
			o_idl_stb &amp;lt;= 1&#39;b0;
		else if ((i_cmd_stb)&amp;amp;&amp;amp;(!o_idl_busy))
			o_idl_stb &amp;lt;= 1&#39;b1;
		else if ((idle_stb)&amp;amp;&amp;amp;(!o_idl_stb))
			o_idl_stb &amp;lt;= 1&#39;b1;
		else if (!i_busy)
			o_idl_stb &amp;lt;= 1&#39;b0;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The final component is to settle which word we wish to output.  On any incoming
request to transmit, we’ll send the incoming word out.  We’ll also need to
ensure that any incoming word is not over-written until the next word goes
out.  Finally, if nothing is coming in to go out, we’ll just set our output
to be the IDLE_WORD.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;initial	o_idl_word = IDLE_WORD;
always @(posedge i_clk)
	if ((i_cmd_stb)&amp;amp;&amp;amp;(!o_idl_busy))
		o_idl_word &amp;lt;= i_cmd_word;
	else if (!i_busy)
		o_idl_word &amp;lt;= IDLE_WORD;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The logic is fairly simple.&lt;/p&gt;

&lt;p&gt;Ok, I’ll admit it, I got this super-simple interface wrong at first.  Worse,
I had more than one bug within this component.  It got so bad I started to get
very frustrated with the simulator until I finally found the bug.
What was it you ask?  I defined the &lt;strong&gt;IDLE_SUB_WORD&lt;/strong&gt; as 5’h11011 instead
of 5’b11011.  See the difference?  If it hadn’t been for the simulator, I’m
not sure I ever would’ve found my mistake.&lt;/p&gt;

&lt;h2 id=&quot;future-posts&quot;&gt;Future Posts&lt;/h2&gt;

&lt;p&gt;As with the
&lt;a href=&quot;/blog/2017/06/16/adding-ints.html&quot;&gt;interrupt capability&lt;/a&gt;,
adding an idle identifier into our debug
protocol was fairly easy to do.  Our next post will put the whole interface
together.  Further posts will include:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;/blog/2017/06/20/dbg-put-together.html&quot;&gt;Composing the rest of the debug controller&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;/blog/2017/06/22/simple-wb-interconnect.html&quot;&gt;Creating a simple wishbone interconnect&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Creating a &lt;a href=&quot;/blog/2017/06/26/dbgbus-verilator.html&quot;&gt;hand-controlled test
bench&lt;/a&gt;
to prove this works&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Creating a software bus controller&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Adding in FIFO support&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;While we’re going to do better, this simple debugging bus should be enough
to help you debug quite a few designs.&lt;/p&gt;

</description>
        <pubDate>Mon, 19 Jun 2017 00:00:00 -0400</pubDate>
        <link>http://zipcpu.com/blog/2017/06/19/debug-idles.html</link>
        <guid isPermaLink="true">http://zipcpu.com/blog/2017/06/19/debug-idles.html</guid>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>Why Use a Network Interface to your FPGA</title>
        <description>&lt;p&gt;Most FPGA board’s come with some sort of interface port that you can use to
interact with them.  &lt;a href=&quot;http://store.digilentinc.com&quot;&gt;Digilent&lt;/a&gt;’s
&lt;a href=&quot;https://store.digilentinc.com/nexys-video-artix-7-fpga-trainer-board-for-multimedia-applications/&quot;&gt;Nexys-Video&lt;/a&gt;,
&lt;a href=&quot;http://store.digilentinc.com/arty-artix-7-fpga-development-board-for-makers-and-hobbyists&quot;&gt;Arty&lt;/a&gt;
and &lt;a href=&quot;https://store.digilentinc.com/basys-3-artix-7-fpga-trainer-board-recommended-for-introductory-users&quot;&gt;Basys-3&lt;/a&gt;
boards each have a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Universal_asynchonous_receiver/transmitter&quot;&gt;UART&lt;/a&gt;
connection that can be used to interact with the board–as do many of their
other boards.  As a result, the host side interaction can be done using an old
fashioned &lt;a href=&quot;https://en.wikipedia.org/wiki/Serial_port&quot;&gt;serial port&lt;/a&gt; interface. 
The &lt;a href=&quot;http://www.latticesemi.com/en/Products/DevelopmentBoardsAndKits/iCEstick.aspx&quot;&gt;iCEstick&lt;/a&gt; also has a similar interface.&lt;/p&gt;

&lt;p&gt;Xess’s &lt;a href=&quot;http://xess.com&quot;&gt;XuLA2&lt;/a&gt; board is a little bit different, in that it
has a &lt;a href=&quot;https://en.wikipedia.org/wiki/JTAG&quot;&gt;JTAG&lt;/a&gt; port that can be commanded
from a small PIC over a USB port.  However, if you use the
&lt;a href=&quot;https://en.wikipedia.org/wiki/JTAG&quot;&gt;JTAG&lt;/a&gt;
USER command, this port can be turned into
&lt;a href=&quot;https://github.com/ZipCPU/xulalx25soc/blob/master/rtl/jtagser.v&quot;&gt;something that looks, feels, and acts like a serial
port&lt;/a&gt;, with
only a touch of &lt;a href=&quot;http://libusb.org&quot;&gt;libUSB&lt;/a&gt; work required.  While I don’t have
any &lt;a href=&quot;http://www.terasic.com.tw/en/&quot;&gt;Terasic&lt;/a&gt; boards&lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;, I’m sure you could use
a similar approach to driving JTAG over USB.&lt;/p&gt;

&lt;p&gt;Other boards, such as &lt;a href=&quot;https://store.digilentinc.com&quot;&gt;Digilent&lt;/a&gt;’s
&lt;a href=&quot;https://store.digilentinc.com/cmod-s6-breadboardable-spartan-6-fpga-module&quot;&gt;CMod-S6&lt;/a&gt;
or the &lt;a href=&quot;http://www.icoboard.org&quot;&gt;ICO board&lt;/a&gt;, have a parallel type of interface.
While this interface can be turned into a serial stream, and while I have done
this for both interfaces, it takes a bit more work to get going than a
plain &lt;a href=&quot;https://en.wikipedia.org/wiki/Serial_port&quot;&gt;serial port&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;My point is twofold.  First, all of these interfaces will require some work
with the hardware to figure out how to how to send information to the
interface, and how to receive data back from it.  Second, reading and writing
a character stream is the easiest paradigm to consider when interacting with
such a port.  In the case of a &lt;a href=&quot;https://en.wikipedia.org/wiki/Serial_port&quot;&gt;serial
port&lt;/a&gt;, this may have the most O/S
support, since reading from and writing to “/dev/ttyUSBx” is pretty easy.
Other ports that aren’t of the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Serial_port&quot;&gt;serial port&lt;/a&gt;
variety can still be made to look, feel, and act like a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Serial_port&quot;&gt;serial port&lt;/a&gt;
even though the underlying transport itself is &lt;em&gt;very&lt;/em&gt; different.&lt;/p&gt;

&lt;p&gt;My recommendation, which we’ll discuss below, is that you interact with any
character stream-type of interface over a TCP/IP link.&lt;/p&gt;

&lt;h2 id=&quot;a-networked-interface&quot;&gt;A Networked Interface&lt;/h2&gt;

&lt;p&gt;If this is your first FPGA project, you might look at what’s available to you
and consider the simplest interface: from your CPU to the device, as in Fig 1.&lt;/p&gt;

&lt;table style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 1: Serial Port Controller&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/raw-dbg.svg&quot; alt=&quot;A Serial Port Debugging Controller&quot; width=&quot;360&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Your first task will be to figure out how to interact with your board.
While proprietary developer software, with all the nice GUI’s that it comes
with, may be the first solution you find, such software usually doesn’t have
the flexibility you’ll need to to do your project.  If your board has a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Serial_port&quot;&gt;serial port&lt;/a&gt;, then you have
a generic port you can work with.  If not, feel free to make something
similar.&lt;/p&gt;

&lt;p&gt;If your board does have a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Serial_port&quot;&gt;serial port&lt;/a&gt;,
you may be able to interact with it using either a
&lt;a href=&quot;http://www.putty.org&quot;&gt;putty&lt;/a&gt; or
&lt;a href=&quot;https://en.wikipedia.org/wiki/Minicom&quot;&gt;minicom&lt;/a&gt; terminal.  While this can be
pretty fun, if you ever want to do anything requiring serious communication
with your device (image processing, camera interaction, etc), then you’ll want
a capability that goes beyond what these can provide.  Indeed, even if you have
another interface for handling image transmission, it will help to be able
to get that interface going with a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Serial_port&quot;&gt;serial port&lt;/a&gt;, that you can use as
a back up.&lt;/p&gt;

&lt;p&gt;In particular, if you want to read &lt;a href=&quot;https://github.com/ZipCPU/wbscope&quot;&gt;scope&lt;/a&gt;
information from a design, you are
going to want to run some software to read this data out.  While you &lt;em&gt;might&lt;/em&gt;
manage to do it by hand using a &lt;a href=&quot;https://en.wikipedia.org/wiki/Minicom&quot;&gt;minicom&lt;/a&gt;
terminal for a 64-element scope, but you could), doing it for a 2048 element
scope (or more) &lt;em&gt;really&lt;/em&gt; calls for a software solution.  Seriously–let the
computer do the hard work for you.&lt;/p&gt;

&lt;p&gt;Other things you might wish to do with your board might include starting or
stopping your on-board logic, reading state registers from the board, initially
loading the memory of your FPGA board, debugging a
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;soft-CPU&lt;/a&gt; implemented on your board,
or even reading the results of an
&lt;a href=&quot;https://store.digilentinc.com/pmod-mic3-mems-microphone-with-adjustable-gain/&quot;&gt;analog microphone&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;All of these means of interacting with your board need some kind of software
interface.&lt;/p&gt;

&lt;p&gt;While all of this may be sound straight forward so far, the problem you will
run into is &lt;em&gt;simulation&lt;/em&gt;.  Specifically, it’d be nice to be able to write our
control programs once and have them work both when we are interacting with the
hardware itself, as well as when we are interacting with the simulator.&lt;/p&gt;

&lt;p&gt;We’ll create this approach by using TCP/IP, as in Fig 2 below.&lt;/p&gt;

&lt;table style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 2: A Network Based Controller&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/netdbg.svg&quot; alt=&quot;A Network Based FPGA Controller&quot; width=&quot;720&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Lest you misunderstand the figure, the server need not be a separate computer.
It’s just the other end of the TCP/IP interface.  I often run both ends of
this network link on the same computer.  Further, if you bind the IP address
to “localhost”, then your computer will not open up any external TCP/IP ports
that might be visible to the big internet.  On the other hand, I tend to run
it wide open, so I can work on my laptop just as easily as on my desktop, and
then I port at the firewall.&lt;/p&gt;

&lt;p&gt;Somewhere about now I can also hear several students groaning.  Debugging
an FPGA is hard enough, and now I’m recommending that a &lt;em&gt;network&lt;/em&gt; debugging
port needs to be added to the FPGA?&lt;/p&gt;

&lt;p&gt;Relax–it’s not that bad.&lt;/p&gt;

&lt;p&gt;First, the networking debug capability isn’t something you’ll be
graded on.  Therefore I don’t think your instructor will have a problem if you
use someone else’s capabilities, but feel free to check with him/her if you
aren’t sure.&lt;/p&gt;

&lt;p&gt;Second, the software you’ll need is all available under the
&lt;a href=&quot;https://www.gnu.org/licenses/gpl-3.0.en.html&quot;&gt;GPL&lt;/a&gt; already.  You don’t
need to do much more.  If you improve upon it, though, please be kind enough
to the other poor souls out there to share your improvements.  Further, if you
wish to legally give me any of those improvements, I’ll be glad to share them
with the rest of the world as well.&lt;/p&gt;

&lt;p&gt;In general, three basic components are required in order to connect a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Serial_port&quot;&gt;serial port&lt;/a&gt; to a TCP/IP port,
as shown in Fig 3.&lt;/p&gt;

&lt;table style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 3: Network S/W Components&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/netcomponents.svg&quot; alt=&quot;Network Components Diagram&quot; width=&quot;480&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;You’ll need a piece of software to forward your physical
&lt;a href=&quot;https://en.wikipedia.org/wiki/Serial_port&quot;&gt;serial port&lt;/a&gt;
serial port onto a network port.  You can find an example of that
&lt;a href=&quot;https://github.com/ZipCPU/dbgbus/blob/master/sw/netuart.cpp&quot;&gt;here&lt;/a&gt;.
You’ll like this piece.  It lets you watch what’s going over the interface,
in case things aren’t working, and so you can debug that interface
in the same window its running in.&lt;/p&gt;

    &lt;p&gt;If you are using the parallel port of the &lt;a href=&quot;http://www.icoboard.org&quot;&gt;ICO
board&lt;/a&gt;, you can find an example of what it would
take to make this interface work with &lt;a href=&quot;http://wiringpi.com&quot;&gt;wiringPi&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/icozip/blob/master/sw/host/netpport.cpp&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;You’ll also need a piece of software to connect your FPGA control
software to.  You can find that piece
&lt;a href=&quot;https://github.com/ZipCPU/dbgbus/blob/master/sw/llcomms.h&quot;&gt;here&lt;/a&gt;.
You might find right now that this is nothing more than a bare interface.
Don’t worry, it’s the end we are going to connect our software controller
to when we build it.&lt;/p&gt;

    &lt;p&gt;If you don’t have this portion of your interface built yet, don’t worry.
As long as you have the
&lt;a href=&quot;https://github.com/ZipCPU/dbgbus/blob/master/sw/netuart.cpp&quot;&gt;network forwarding piece&lt;/a&gt;.
listed above, you can build use
telnet.  As in, &lt;strong&gt;telnet localhost &amp;lt;portnum&amp;gt;&lt;/strong&gt;.  This will replace
your need for &lt;a href=&quot;http://www.putty.org&quot;&gt;putty&lt;/a&gt; or
&lt;a href=&quot;https://en.wikipedia.org/wiki/Minicom&quot;&gt;minicom&lt;/a&gt;—although if you stick
around, we’ll create a command line approach to interfacing with your board.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The third piece of software you will need, assuming you can interact with
your device over a serial port, you can find as part of the
&lt;a href=&quot;https://github.com/ZipCPU/wbuart32&quot;&gt;wbuart32&lt;/a&gt; package
&lt;a href=&quot;https://github.com/ZipCPU/wbuart/blob/master/bench/cpp/uartsim.cpp&quot;&gt;here&lt;/a&gt;.
This piece turns the simulation end of the TCP/IP port into a
serial interface that you can process on your simulated board.&lt;/p&gt;

    &lt;p&gt;If you have an &lt;a href=&quot;http://www.icoboard.org&quot;&gt;ICO board&lt;/a&gt; with a parallel
interface, you can find an equivalent software component
&lt;a href=&quot;https://github.com/ZipCPU/icozip/blob/master/sim/verilated/dblpipecmdr.h&quot;&gt;here&lt;/a&gt;.
In this case, while this software provides the same capability, it does it
in a different fashion.  You can look within it to see some of the details.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;We’ll discuss how all of these pieces work later and in detail.  For now,
just know that the software is available for you to do this should you have
a &lt;a href=&quot;https://en.wikipedia.org/wiki/Serial_port&quot;&gt;serial port&lt;/a&gt;-type of interface
to your board.&lt;/p&gt;

&lt;p&gt;What does this infrastructure allow you to do?  Why is it to your advantage?
It allows you to test your control software in such a manner
that the control software might never know whether the other end of the link
is an FPGA, as in Fig 2. above, or a simulator–as in Fig 4 below.&lt;/p&gt;

&lt;table style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 4: Network Based Simulation&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/netsim.svg&quot; alt=&quot;A Network Based FPGA Controller&quot; width=&quot;720&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;If you can control your simulator over the network, and not know the
difference, then you know your control programs and your simulator work.&lt;/p&gt;

&lt;p&gt;That’s where we are headed.&lt;/p&gt;

&lt;h2 id=&quot;next-time&quot;&gt;Next Time&lt;/h2&gt;

&lt;p&gt;We’ll come back to these software pieces later to describe how they work in
detail.&lt;/p&gt;

&lt;p&gt;For now, we’re going to continue focusing on what it takes to get an initial
debugging interface up and running.  We can debug more complicated interfaces
from there if we need to.&lt;/p&gt;

&lt;p&gt;If you’ve never tried using a networking debug interface before, think about it.
As we go over the pieces, give them a try.  My bet is that once you find your
first bug using &lt;a href=&quot;https://www.veripool.org/wiki/verilator&quot;&gt;Verilator&lt;/a&gt; and
&lt;a href=&quot;http://gtkwave.sourceforge.net&quot;&gt;GTKWave&lt;/a&gt; that you’ll become a quick
believer in this method.&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;Footnotes:&lt;/p&gt;

&lt;div class=&quot;footnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:1&quot;&gt;
      &lt;p&gt;While I have several FPGA development boards, I do not have any &lt;a href=&quot;https://www.terasic.com.tw/en/&quot;&gt;Terasic&lt;/a&gt; (&lt;a href=&quot;https://www.altera.com/&quot;&gt;Altera&lt;/a&gt;) boards.  As a result, while I know these techniques would work in general on any board, I have not had the opportunity to try any of them on any &lt;a href=&quot;https://www.altera.com/&quot;&gt;Altera&lt;/a&gt; board’s. &lt;a href=&quot;#fnref:1&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;
</description>
        <pubDate>Sat, 17 Jun 2017 00:00:00 -0400</pubDate>
        <link>http://zipcpu.com/blog/2017/06/17/why-network-debugging.html</link>
        <guid isPermaLink="true">http://zipcpu.com/blog/2017/06/17/why-network-debugging.html</guid>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>Support me on Patreon</title>
        <description>&lt;p&gt;The &lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt; blog now has a
&lt;a href=&quot;https://www.patreon.com/ZipCPU&quot;&gt;Patreon support&lt;/a&gt; page!&lt;/p&gt;

&lt;p&gt;If you like this blog, and you’d like to see it continue, please consider
donating to this effort via &lt;a href=&quot;https://www.patreon.com/ZipCPU&quot;&gt;Patreon&lt;/a&gt;.  That
support will go a &lt;em&gt;long&lt;/em&gt; way towards helping me finish blogging about all of
the &lt;a href=&quot;/topics.html&quot;&gt;topics&lt;/a&gt; I have lined up.&lt;/p&gt;

&lt;p&gt;Thank you!&lt;/p&gt;
</description>
        <pubDate>Sat, 17 Jun 2017 00:00:00 -0400</pubDate>
        <link>http://zipcpu.com/blog/2017/06/17/patreon.html</link>
        <guid isPermaLink="true">http://zipcpu.com/blog/2017/06/17/patreon.html</guid>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>The debugging bus: a goal for FPGA interaction</title>
        <description>&lt;p&gt;It’s been a while since I presented the &lt;a href=&quot;/blog/2017/05/22/a-vision-for-controlling-fpgas.html&quot;&gt;vision for controlling FPGA
logic&lt;/a&gt;.
Since that time, we’ve put a lot of work into building an FPGA controller
that we can use for debugging logic running within our FPGA.
&lt;a href=&quot;/blog/2017/06/05/wb-bridge-overview.html&quot;&gt;[1]&lt;/a&gt;
&lt;a href=&quot;/blog/2017/06/14/creating-words-from-bytes.html&quot;&gt;[2]&lt;/a&gt;
&lt;a href=&quot;/blog/2017/06/08/simple-wb-master.html&quot;&gt;[3]&lt;/a&gt;
&lt;a href=&quot;/blog/2017/06/15/words-back-to-bytes.html&quot;&gt;[4]&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Our goal over all is to provide the student, or any other junior FPGA
designer for that matter, with a tool, similar to what an &lt;a href=&quot;/blog/2017/06/02/design-process.html&quot;&gt;expert might
use&lt;/a&gt;, that he can use to figure out what
is going on within his design.&lt;/p&gt;

&lt;p&gt;Today, let’s take a look at what that the software side of communicating
with an FPGA might look like.  In other words, once we connect to our FPGA,
how will we control that FPGA from software?&lt;/p&gt;

&lt;h2 id=&quot;a-simple-fpga-software-controller&quot;&gt;A Simple FPGA Software Controller&lt;/h2&gt;

&lt;p&gt;The simplest FPGA control program that I’ve built is the one I call 
&lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/sw/host/wbregs.cpp&quot;&gt;wbregs&lt;/a&gt;.
This program just reads (or writes) a single register within the FPGA.  The
&lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/sw/host/wbregs.cpp&quot;&gt;source code&lt;/a&gt;
for this program makes it look more complicated than it is though.  That’s
really nothing more than the fact that it’s been lying around long enough to be
&lt;em&gt;improved upon&lt;/em&gt; one too many times … but I digress.&lt;/p&gt;

&lt;p&gt;Lets trim this program down to its bare minimum details, and see what it
would take to control an FPGA using this sort of controller.&lt;/p&gt;

&lt;p&gt;The first step in my idealized world would be to declare a global value
   to hold a pointer to my FPGA’s interface:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;n&quot;&gt;FPGA&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;\&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_fpga&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Then, somewhere within my main program file, I’d want to connect to my FPGA.
If the FPGA talks to the computer via a serial port, I might wish to
say something like:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SERIAL_PORT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;/dev/ttyUSB0&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;m_fpga&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;FPGA&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SERIAL_PORT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;We may need to come back to the name later, in case we have more than one USB
serial port connector, but for now let’s just move on.&lt;/p&gt;

&lt;p&gt;I’d really rather connect to my FPGA from any one of my computers via a
network port, as in:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;FPGASERVER&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;fpgahost.name&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Could be 192.168.7.1 ...
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;FPGAPORT&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2853&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Some random number, known to you
//
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_fpga&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;FPGA&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;FPGASERVER&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;FPGAPORT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Wouldn’t it be nice if that was all it took to connect to an FPGA?&lt;/p&gt;

&lt;p&gt;How about reading the a status register from the FPGA?  For example, we
might wish to read from the erase control register of the &lt;a href=&quot;http://opencores.org/project,qspiflash&quot;&gt;flash
controller&lt;/a&gt; to see if it is still
busy.  In that case, it might be nice to write something as simple as:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_fpga&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;readio&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;R_FLASH_EREG&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;FLASH_BUSY&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The same could be said about writing to the erase control register, in order
to command the flash to erase a segment of flash memory–but that’s a topic
for a later day.&lt;/p&gt;

&lt;p&gt;For now, what about that &lt;a href=&quot;https://github.com/ZipCPU/wbscope&quot;&gt;scope&lt;/a&gt;?  Wouldn’t
it be nice to be able to reset the &lt;a href=&quot;https://github.com/ZipCPU/wbscope&quot;&gt;scope&lt;/a&gt;
for another capture?  The easiest way I can think of doing that would be
to write the new hold off to the &lt;a href=&quot;https://github.com/ZipCPU/wbscope&quot;&gt;scope&lt;/a&gt;
control register, as in:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;n&quot;&gt;m_fpga&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;writeio&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;R_SCOPE_CONTROL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;25&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;//&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;New&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;holdoff&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;is&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;25&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;clocks&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Or to read from the internal FPGA &lt;a href=&quot;https://github.com/ZipCPU/wbscope&quot;&gt;scope&lt;/a&gt;,
wouldn’t it be nice to just simply … read?&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;scope_len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;m_scope_memory&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m_fpga&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;readio&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;R_SCOPE_DATA&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;You do remember how, in our &lt;a href=&quot;/blog/2017/06/08/simple-scope.html&quot;&gt;example scope
design&lt;/a&gt;, we placed
all of the &lt;a href=&quot;https://github.com/ZipCPU/wbscope&quot;&gt;scope&lt;/a&gt;’s data at the same
register address, right?&lt;/p&gt;

&lt;p&gt;We might even manage to optimize successive reads, making a similar command
that could capture any optimizations associated with many reads in a row.
If so, we could write our for loop that read’s from the FPGA into something
that could be optimized, such as:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;n&quot;&gt;m_fpga&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;readz&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;R_SCOPE_DATA&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;scope_len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m_scope_memory&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Working on Video?  One of the hardest parts of working on Video is getting
that video information in and out of the computer.  Unlike the scope,
your video information is going to occupy successive addresses, rather
than a single data address.&lt;/p&gt;

&lt;p&gt;Wouldn’t it be nice if you could read from your video RAM area exactly what
was being transmitted, as in:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;kt&quot;&gt;uint32_t&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;m_video_image&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NUMBER_OF_PIXELS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;video_size&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NUMBER_OF_PIXELS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;m_fpga&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;readi&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;R_VIDEO_RAM&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;video_size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m_video_image&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Then, when we are done, we should close our FPGA interface via a C++ destructor
such as:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;k&quot;&gt;delete&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m_fpga&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Could we make controlling an FPGA that easy?  The answer is, Yes.  Yes, we can.
Not only can this be done, but
&lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/sw/host/wbregs.cpp&quot;&gt;wbregs&lt;/a&gt;
does it.  Sure, 
&lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/sw/host/wbregs.cpp&quot;&gt;wbregs&lt;/a&gt;
has a lot more code for error handling, and I just added code to look address
names up from linker map files, but simply reading and writing from an
FPGA is what it was designed to do.&lt;/p&gt;

&lt;h2 id=&quot;this-will-only-hurt-once&quot;&gt;This will only hurt once&lt;/h2&gt;

&lt;p&gt;Even better, after you go through the pain of building just one debugging
controller for your FPGA, you can then use it for &lt;em&gt;every one&lt;/em&gt; of your FPGA
projects.&lt;/p&gt;

&lt;p&gt;Think this one over: the debugging interface isn’t going to be graded.
(Ask your instructor if you aren’t sure of that.)  If that’s a problem,
then pull it out of your code before you turn it in.  Either way, if you
use a debugging bus in your design you will have a leg up over all of your
classmates who do not.&lt;/p&gt;

&lt;p&gt;Now, consider this sort of interface from the standpoint of the &lt;a href=&quot;/blog/2017/06/02/design-process.html&quot;&gt;FPGA expert’s
design process&lt;/a&gt;.
He’s going to build this sort of interface once, and then he’s going to use it
in all of his projects.  Some time later, he may come back and add a little
bit of capability to it, but he’ll still be using it with every project.&lt;/p&gt;

&lt;p&gt;Perhaps an example from my experience would help.  My first design was for
a &lt;a href=&quot;https://store.digilentinc.com/basys-3-artix-7-fpga-trainer-board-recommended-for-introductory-users&quot;&gt;Basys-3&lt;/a&gt; development board.  That’s where
I build the first version of my own &lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/rtl/wbubus.v&quot;&gt;FPGA debugging
interface&lt;/a&gt;.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;After I built that first interface (it was similar to the &lt;a href=&quot;https://github.com/ZipCPU/dbgbus/tree/master/hexbus&quot;&gt;hexbus
interface&lt;/a&gt; we are
building here) I became frustrated with how slow it was–particularly
when I was using it to read and write new configurations to the flash.&lt;/p&gt;

    &lt;p&gt;So, I added compression to the interface: both
&lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/rtl/wbucompress.v&quot;&gt;encoding&lt;/a&gt;
and
&lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/rtl/wbudecompress.v&quot;&gt;decoding&lt;/a&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;More recently, I got frustrated with the fact that my interface used up
a serial port, preventing my CPU from printing to the same serial port.&lt;/p&gt;

    &lt;p&gt;In this case, I restricted the debugging interface to 7-bits, and used
the high order ASCII bit to determine if the interface was communicating
printable ASCII (such as the CPU with a printf), or unprintable characters
(such as the debugging interface).  Since I was only ever using 7-bit
bytes for the debugging interface in the first place, this change was easy
to do, and it then gave me two channels of data that I could run through
my serial port.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;My point is simply this: You need to pay for your tools.  Pay the time and
energy to build them once and build them well.  Now that they are built,
use them in all of your projects.&lt;/p&gt;

&lt;p&gt;Let’s even go one step farther: I’m going to license &lt;a href=&quot;https://github.com/ZipCPU/dbgbus/tree/master/hexbus&quot;&gt;this hexbus student
interface&lt;/a&gt; that we are
building under the &lt;a href=&quot;https://www.gnu.org/licenses/lgpl-3.0.en.html&quot;&gt;LGPL&lt;/a&gt;. 
What that means is that I’ll let you copy it into your project, without being
required to post the rest of the code for your project.  If you improve upon
it, post your improvements.  If you are willing to assign ownership of those
improvements to me, then I’ll post them back into the directory for others to
use.&lt;/p&gt;

&lt;p&gt;Once we’re finished, then you, as a student, can play the role of the
expert.  You too can come to the FPGA design problem with a debugging
tool suite under your belt.&lt;/p&gt;

&lt;p&gt;This is why I &lt;a href=&quot;/blog/2017/06/02/design-process.html&quot;&gt;pointed
out&lt;/a&gt;, when
discussing how an Expert &lt;em&gt;really&lt;/em&gt; does FPGA design, that he comes to the
problem with a lot of tools already in his toolbox.&lt;/p&gt;

&lt;h2 id=&quot;just-a-simple-vision&quot;&gt;Just a simple vision&lt;/h2&gt;

&lt;p&gt;All of our work here is simply towards one single goal: to build an interface
to your FPGA that will then simplify all of your interactions with that FPGA.
Such an interface allows us to write commands to the FPGA and to read status
back out of the FPGA.  It will allow us to develop and prove that peripherals
work, and it will help us to find out why they do not work when they do not
work.&lt;/p&gt;

&lt;p&gt;This is the component most students don’t realize they are missing within their
design.&lt;/p&gt;
</description>
        <pubDate>Fri, 16 Jun 2017 00:00:00 -0400</pubDate>
        <link>http://zipcpu.com/blog/2017/06/16/dbg-bus-forest.html</link>
        <guid isPermaLink="true">http://zipcpu.com/blog/2017/06/16/dbg-bus-forest.html</guid>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>Adding interrupt reporting to our debugging bus</title>
        <description>&lt;p&gt;This post starts to complete the design of a very elementary debug port that
can be used to command an internal, on-board, wishbone bus.  Other posts in
this series include:&lt;/p&gt;

&lt;table style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 1: WB-UART Overview&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/wb-uart-smpl-2.svg&quot; alt=&quot;Block Diagram of a Simpler Wishbone to UART converter&quot; width=&quot;360&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;/blog/2017/06/05/wb-bridge-overview.html&quot;&gt;An overview of a UART to wishbone
bridge&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;How to build a &lt;a href=&quot;/blog/2017/06/08/simple-wb-master.html&quot;&gt;Simple Wishbone Master&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;How to &lt;a href=&quot;/blog/2017/06/14/creating-words-from-bytes.html&quot;&gt;create bus command words from a 7-bit data stream&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;How to &lt;a href=&quot;/blog/2017/06/14/words-back-to-bytes.html&quot;&gt;turn the bus master responses back into a serial stream&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;We’ve now just about got a fully functional wishbone master controlled from a
serial stream that can now be used as a debugging bus. 
We’ve worked out how to get a serial port up and running,
how to &lt;a href=&quot;/blog/2017/06/14/creating-words-from-bytes.html&quot;&gt;create words from the serial
stream&lt;/a&gt;, and
&lt;a href=&quot;/blog/2017/06/08/simple-wb-master.html&quot;&gt;how to control a simple wishbone bus
master&lt;/a&gt;
from the command words running through this stream, and then &lt;a href=&quot;/blog/2017/06/14/words-back-to-bytes.html&quot;&gt;how to send
the response words back down the serial port&lt;/a&gt;.  The result is a &lt;em&gt;very simple&lt;/em&gt; debugging capability.&lt;/p&gt;

&lt;p&gt;While simple, nothing keeps this capability from being very successful within
someone’s design.  This lesson is about adding interrupt notification to the
output stream of our debugging port.&lt;/p&gt;

&lt;h2 id=&quot;interrupt-requirements&quot;&gt;Interrupt Requirements&lt;/h2&gt;

&lt;p&gt;For our purposes, we’ll define an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interrupt&quot;&gt;interrupt&lt;/a&gt; as the notification of an
event having taken place.  Example interrupts might be that the wishbone scope
has tripped, or that the flash controller has finished erasing or programming
flash.  Either way, some sort of notification has taken place, and you’d like
to be notified of it.&lt;/p&gt;

&lt;p&gt;We’ll require this of our interrupt processing:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;When an interrupt takes place, we’d like to be informed.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;We don’t want to be informed twice for the same interrupt.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;We don’t want to need to control the bus interface, but rather the FPGA.
Hence, any internal interrupt state within the bus interface should be self
clearing.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The interrupt notification should only get inserted into the stream when
the stream is idle.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Hence, whenever the interrupt line is raised, we’ll consider that an
interrupt condition has taken place.  We’ll send an interrupt character (“I”)
across the channel.  No more interrupt notifications will be sent across the
channel until the “I” has been committed to, and the interrupt line has gone
low.&lt;/p&gt;

&lt;p&gt;Sound simple enough?&lt;/p&gt;

&lt;h2 id=&quot;the-interrupt-stream-processor&quot;&gt;The interrupt stream processor&lt;/h2&gt;

&lt;p&gt;This processor is almost simplicity itself.&lt;/p&gt;

&lt;p&gt;We’ll start with the definition of the interrupt command word that we will be
inserting into our stream.  It is a &lt;em&gt;special&lt;/em&gt; word, and so it begins with
2’b11.  After that, it is the 2nd special word, so we have a prefix of
5’h11010.  The rest of the interrupt word we set to zero.  That allows us to
extend our protocol later, should we wish to, with 29 bits of information or
zeros to indicate no information.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;`define	INT_PREFIX	5&#39;b11010
`define	INT_WORD	{ `INT_PREFIX, {(34-5){1&#39;b0}} }&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;I should mention, at this point, a quick lesson in programming practice.  The
first time I built this controller, I didn’t define these values at the top
of the file.  Then, when I needed to change them, I missed changing all of them.
By having `define statements at the top, one change to this definition
will changes all of its uses later.&lt;/p&gt;

&lt;p&gt;Our processing will focus around two primary registers: &lt;strong&gt;int_state&lt;/strong&gt; and
&lt;strong&gt;pending_interrupt&lt;/strong&gt;.  The idea is basically this: when an interrupt takes
place, we’ll go into our interrupt state, and set the interrupt to be pending.
In other words, we are waiting to send the value out the port.  Once the
value has been sent, the pending register will clear, but we’ll stay in our
interrupt state until the interrupt itself clears.&lt;/p&gt;

&lt;p&gt;Here you can see that logic below.  First, for the &lt;strong&gt;int_state&lt;/strong&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;initial	int_state = 1&#39;b0;
always @(posedge i_clk)
	if (i_reset)
		int_state &amp;lt;= 1&#39;b0;
	else if ((i_interrupt)&amp;amp;&amp;amp;(!int_state))
		int_state &amp;lt;= 1&#39;b1;
	else if ((!pending_interrupt)&amp;amp;&amp;amp;(!i_interrupt))
		int_state &amp;lt;= 1&#39;b0;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Note that this state register is only cleared when the interrupt line goes
low &lt;strong&gt;and&lt;/strong&gt; the pending line has gone low, indicating that both we have sent
the interrupt word forward, and that the interrupt has cleared itself.&lt;/p&gt;

&lt;p&gt;Then, here’s the same logic but for the &lt;strong&gt;pending_int&lt;/strong&gt;.  Note that this
one is cleared whenever the interrupt word is actually sent down stream.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;initial	pending_interrupt = 1&#39;b0;
always @(posedge i_clk)
	if (i_reset)
		pending_interrupt &amp;lt;= 1&#39;b0;
	else if ((i_interrupt)&amp;amp;&amp;amp;(!int_state))
		pending_interrupt &amp;lt;= 1&#39;b1;
	else if ((o_int_stb)&amp;amp;&amp;amp;(!i_busy)
			&amp;amp;&amp;amp;(o_int_word[33:29] == `INT_PREFIX))
		pending_interrupt &amp;lt;= 1&#39;b0;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The rest of our logic is mostly stream processing.&lt;/p&gt;

&lt;p&gt;For example, we’d like to know when we have a valid word loaded into our
output register, so that the interrupt never slows down our communications
stream, but only inserts itself when we are idle.  If a word is loaded, and
waiting to be sent, then we won’t insert an interrupt into the stream.&lt;/p&gt;

&lt;p&gt;We’ll consider a response word to be loaded any time the incoming strobe
is true, and we’ll clear the condition whenever that word gets written our
the output port.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;initial	loaded = 1&#39;b0;
always @(posedge i_clk)
	if (i_reset)
		loaded &amp;lt;= 1&#39;b0;
	else if (i_stb)
		loaded &amp;lt;= 1&#39;b1;
	else if ((o_int_stb)&amp;amp;&amp;amp;(!i_busy))
		loaded &amp;lt;= 1&#39;b0;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;But when do we have something to write?  Obviously we have something to write
when something is given to us, as in whenever &lt;strong&gt;i_stb&lt;/strong&gt; is true.  But we
also want to make certain we have something to write anytime we have a 
&lt;strong&gt;pending_interrupt&lt;/strong&gt;.  We’ll clear our output request upon a write, as
long as we don’t have a pending interrupt request.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;initial	o_int_stb = 1&#39;b0;
always @(posedge i_clk)
	if (i_reset)
		o_int_stb &amp;lt;= 1&#39;b0;
	else if (i_stb)
		o_int_stb &amp;lt;= 1&#39;b1;
	else if (pending_interrupt)
		o_int_stb &amp;lt;= 1&#39;b1;
	else if ((!loaded)||(!i_busy))
		o_int_stb &amp;lt;= 1&#39;b0;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The consequence of this logic is that once there is an interrupt waiting to
be inserted into the output stream, &lt;strong&gt;o_int_stb&lt;/strong&gt; will remain high until
it is sent.  Likewise, any time there is a word requested, &lt;strong&gt;o_int_stb&lt;/strong&gt;
will also remain high.  It’s not going to dip low anytime something moves
in the downstream direction.&lt;/p&gt;

&lt;p&gt;Finally, what word shall be sent?  Whenever a request is made, we’ll send
the incoming word.  So that we wait for the request, we’ll wait until the
request is made &lt;strong&gt;and&lt;/strong&gt; we don’t have a valid request loaded into our
outgoing register.  If there is no incoming request, then we’ll automatically
load our interrupt word.  This will get ignored, though, unless the
&lt;strong&gt;o_int_stb&lt;/strong&gt; line is also high.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	if ((i_stb)&amp;amp;&amp;amp;(!loaded))
		o_int_word &amp;lt;= i_word;
	else if ((pending_interrupt)&amp;amp;&amp;amp;(!loaded))
		// Send an interrupt
		o_int_word &amp;lt;= `INT_WORD;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h2 id=&quot;future-posts&quot;&gt;Future Posts&lt;/h2&gt;

&lt;p&gt;Adding this one simple capability into our response stream was very easily
done.  We’ll add idles into this stream next to identify our stream as being
used for this purpose.  I think you’ll find, when we add the idles in, that
the idles are just about as easy as the interrupts are.&lt;/p&gt;

&lt;p&gt;After we add idle’s, all of the Verilog will be in place.  The next step
will be to create a simple wishbone interconnect, and then the Verilator
test bench necessary to try this out before deploying it on an actual FPGA.&lt;/p&gt;

&lt;p&gt;This means we still have the following topics to come:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;/blog/2017/06/19/debug-idles.html&quot;&gt;Adding idle notifications&lt;/a&gt; to let you know you are connected to the right
stream&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;/blog/2017/06/20/dbg-put-together.html&quot;&gt;Connecting the bus streaming components together&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;/blog/2017/06/22/simple-wb-interconnect.html&quot;&gt;Creating a simple wishbone interconnect&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Creating a &lt;a href=&quot;/blog/2017/06/26/dbgbus-verilator.html&quot;&gt;hand-controlled test
bench&lt;/a&gt;
to prove this works&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Creating a software bus controller&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Indeed, if you wanted to try this controller out, it’s far enough along that
you could probably start working with it today.  Just be aware–it doesn’t
have any FIFO support.  If you try to read from this bus too fast, or write
to it too fast, you may find either your commands or their responses getting
lost.  Perhaps we should add a FIFO to our additional topics list as well, then.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Adding in FIFO support&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Sound interesting?  Write me if you try this, and let me know how it goes.&lt;/p&gt;

</description>
        <pubDate>Fri, 16 Jun 2017 00:00:00 -0400</pubDate>
        <link>http://zipcpu.com/blog/2017/06/16/adding-ints.html</link>
        <guid isPermaLink="true">http://zipcpu.com/blog/2017/06/16/adding-ints.html</guid>
        
        
        <category>blog</category>
        
      </item>
    
  </channel>
</rss>
