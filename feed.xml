<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>The ZipCPU by Gisselquist Technology</title>
    <description>The ZipCPU blog, featuring how to discussions of FPGA and soft-core CPU design.  This site will be focused on Verilog solutions, using exclusively OpenSource IP products for FPGA design.  Particular focus areas include topics often left out of more mainstreeam FPGA design courses such as how to debug an FPGA design.
</description>
    <link>http://zipcpu.com/</link>
    <atom:link href="http://zipcpu.com/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Sat, 30 Dec 2017 13:16:41 -0500</pubDate>
    <lastBuildDate>Sat, 30 Dec 2017 13:16:41 -0500</lastBuildDate>
    <generator>Jekyll v3.0.1</generator>
    <image>
      <url>http://zipcpu.com/img/gt-rss.png</url>
      <title></title>
      <link></link>
    </image>
    
      <item>
        <title>A better filter implementation for slower signals</title>
        <description>&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 1. A Generic filter implementation&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/fir-form.svg&quot; alt=&quot;&quot; width=&quot;480&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;We’ve slowly been working through several
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_signal_processing&quot;&gt;DSP&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/tree/master/rtl&quot;&gt;implementations&lt;/a&gt; on
&lt;a href=&quot;http://zipcpu.com/&quot;&gt;this blog&lt;/a&gt;.  Each of these
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/tree/master/rtl&quot;&gt;implementations&lt;/a&gt;
includes the logic necessary to evaluate a typical
&lt;a href=&quot;https://en.wikipedia.org/wiki/Convolution&quot;&gt;convolution&lt;/a&gt;,
such as the one shown in Fig 1 on the right.&lt;/p&gt;

&lt;p&gt;We’ve presented both a
&lt;a href=&quot;/dsp/2017/09/15/fastfir.html&quot;&gt;fairly generic FIR filter implementation&lt;/a&gt;
for high rate data signals, as well as a
&lt;a href=&quot;/dsp/2017/09/29/cheaper-fast-fir.html&quot;&gt;simple modification to that implementation&lt;/a&gt;
that uses fewer resources but has a higher fanout.  We’ve also discussed a
&lt;a href=&quot;/dsp/2017/11/04/genfil-tb.html&quot;&gt;generic test harness&lt;/a&gt;
that can be used to test and prove some of
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters&quot;&gt;these filters&lt;/a&gt;,
and even showed &lt;a href=&quot;/dsp/2017/12/06/fastfir-tb.html&quot;&gt;how that harness might be
applied&lt;/a&gt;.
Further, we’ve discussed the usefulness of a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;’s
&lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency_response&quot;&gt;frequency response&lt;/a&gt;,
as well as
&lt;a href=&quot;/dsp/2017/11/22/fltr-response.html&quot;&gt;how to measure it&lt;/a&gt;
using the
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/bench/cpp/filtertb.cpp&quot;&gt;same test harness&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;However, if you want to try any of these initial filter implementations
on signals with a slower sample rate, such as audio signals, you’ll
quickly find these &lt;em&gt;faster&lt;/em&gt; filtering implementations to be very resource
intensive.&lt;/p&gt;

&lt;p&gt;For example, if you want to apply a 2047 tap filter to a 48kHz audio
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;,
while running your
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
at a 100MHz system clock, then the
&lt;a href=&quot;/dsp/2017/09/15/fastfir.html&quot;&gt;generic filter implementation&lt;/a&gt;
will cost you 2047 hardware multiplies.  This will force you to the most
expensive and feature rich Virtex-7 FPGA, the
&lt;a href=&quot;https://www.digikey.com/product-detail/en/xilinx-inc/XC7VH870T-1FLG1932C/XC7VH870T-1FLG1932C-ND/5247347&quot;&gt;XC7VH870T&lt;/a&gt;–a chip that will cost
you a minimum of $18k USD today on
&lt;a href=&quot;https://www.digikey.com&quot;&gt;Digikey&lt;/a&gt;.  On the other hand, if you used the
implementation presented below, you might still be able to use an
&lt;a href=&quot;https://www.digikey.com/product-detail/en/xilinx-inc/XC7A15T-1FTG256C/122-1930-ND/5248117&quot;&gt;Artix-7 priced at less than $26&lt;/a&gt; on
&lt;a href=&quot;https://www.digikey.com&quot;&gt;Digikey&lt;/a&gt;, and available as part of many hobby
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
boards for fairly reasonable prices (about $100USD).
&lt;a href=&quot;https://store.digilentinc.com/basys-3-artix-7-fpga-trainer-board-recommended-for-introductory-users/&quot;&gt;[1]&lt;/a&gt;
&lt;a href=&quot;https://store.digilentinc.com/arty-artix-7-fpga-development-board-for-makers-and-hobbyists/&quot;&gt;[2]&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;For all of these reasons, it’s important to know how to build a
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/slowfil.v&quot;&gt;filter&lt;/a&gt;
that re-uses its hardware multiplies to the maximum extent possible.  The
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/slowfil.v&quot;&gt;filter&lt;/a&gt;
that we’ll present below, for example, uses only one hardware
multiply–although that will limit the number of coefficients this
&lt;a href=&quot;https://en.wikipedia.org/wiki/Finite_impulse_response&quot;&gt;FIR&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/slowfil.v&quot;&gt;implementation&lt;/a&gt;
can handle.&lt;/p&gt;

&lt;p&gt;Let’s take a look at what how this
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;
will need to operate, and then look at how to
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/slowfil.v&quot;&gt;implement&lt;/a&gt;
it.  Once implemented, we’ll show how easy it is
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/bench/cpp/slowfil_tb.cpp&quot;&gt;to test&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/slowfil.v&quot;&gt;this filter&lt;/a&gt;
using the
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/bench/cpp/filtertb.cpp&quot;&gt;test harness&lt;/a&gt;
we built some time ago.&lt;/p&gt;

&lt;h2 id=&quot;the-operation&quot;&gt;The Operation&lt;/h2&gt;

&lt;p&gt;If you’ve gone through the posts above, then you are already aware that a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;digital filter&lt;/a&gt;
evaluates a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Convolution&quot;&gt;convolution&lt;/a&gt;.
For example, if &lt;code class=&quot;highlighter-rouge&quot;&gt;x[n]&lt;/code&gt; were our input, &lt;code class=&quot;highlighter-rouge&quot;&gt;y[n]&lt;/code&gt; our output, and &lt;code class=&quot;highlighter-rouge&quot;&gt;h[n]&lt;/code&gt; a
series of coefficients, then we might write that,&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/fir-convolution.png&quot; alt=&quot;&quot; width=&quot;255&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Pictorially, this equation describes the operation shown in Fig 1 above.&lt;/p&gt;

&lt;p&gt;Today’s &lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/slowfil.v&quot;&gt;filter
implementation&lt;/a&gt;
will follow directly from a straight-forward evaluation of the summation
in the equation above.  In other words, we’ll start by setting an
accumulator to the first value,&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/fir-slowfil-acc-zero.png&quot; alt=&quot;&quot; width=&quot;205&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Then, on each subsequent clock we’ll add the next value to it,&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/fir-slowfil-acc-step.png&quot; alt=&quot;&quot; width=&quot;409&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 2. A Time Multiplexed filter implementation&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/fir-slow-form.svg&quot; alt=&quot;&quot; width=&quot;480&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Fig 2 on the right shows a diagram of how this approach might look.
Basically, at every step we’ll read both an &lt;code class=&quot;highlighter-rouge&quot;&gt;h[k]&lt;/code&gt; value and an &lt;code class=&quot;highlighter-rouge&quot;&gt;x[n-k]&lt;/code&gt;
value from separate memories, multiply the two together, and add the product
together with the value from an accumulator.  Once all the values have
been added together, we’ll use this accumulated result as our output.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/fir-slowfil-acc-done.png&quot; alt=&quot;&quot; width=&quot;204&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;In Verilog, this might look something like the following.  On the first
clock, we’d read one tap from the tap (coefficient) memory, and multiply
it by our incoming data sample, &lt;code class=&quot;highlighter-rouge&quot;&gt;i_sample&lt;/code&gt;.  The result of that product
could then be used to initialize an accumulator, &lt;code class=&quot;highlighter-rouge&quot;&gt;r_acc&lt;/code&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
if (i_ce)
begin
	// first clock
	tap &amp;lt;= tapmem[0];

	// second clock
	product &amp;lt;= tap * i_sample;

	// third clock
	r_acc &amp;lt;= product;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Sounds simple so far, right?  Okay, so we’ve ignored any pipeline scheduling
(&lt;code class=&quot;highlighter-rouge&quot;&gt;i_ce&lt;/code&gt; will only be true for one clock in &lt;code class=&quot;highlighter-rouge&quot;&gt;N&lt;/code&gt;), but let’s come back to that
in a moment.&lt;/p&gt;

&lt;p&gt;Further, we’re going to need to read from block RAM memory on every clock
following.  This means we’ll need to place this new sample value into
memory, and then increment the write pointer.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	// Write the new data to memory, then increment the memory pointer
	dmem[dwidx] &amp;lt;= i_sample;
	dwidx &amp;lt;= dwidx + 1&#39;b1;	// increment the memory write pointer&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;We’re also going to want to be able to read the coefficient index pointer
and the data index pointer on the next clock, so let’s set these as part
of the same clock that the new data shows in on.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	// Still on i_ce
	tidx &amp;lt;= 1;
	didx &amp;lt;= dwidx;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;After the accumulator has been given an initial value, we’ll then need to read
both the coefficient values and the data values from an on-chip block RAM
memory.  Placing
the data into a data memory to make this happen will require a memory write
and some memory address manipulation.  That means that the second part of
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/slowfil.v&quot;&gt;this algorithm&lt;/a&gt;
might look like:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;end else if (!done)
begin
	// Now, between clocks, we&#39;ll need to read the data and the coefficient
	data &amp;lt;= dmem[didx];	// Read data from the sample memory, x[n-k]
	tap &amp;lt;= tapmem[tidx];	// Read from the coefficient memory, h[k]

	// Update the pointers to each.  Notice that the coefficient index,
	// tidx increases while the data index decreases--just as we have
	// above.
	didx &amp;lt;= didx - 1&#39;b1;
	tidx &amp;lt;= tidx + 1&#39;b1;

	// and calculate the product
	product &amp;lt;= tap * data;

	// Use the product to update the accumulator
	r_acc &amp;lt;= r_acc + product&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Once we are done with all of the above, we’ll set the &lt;a href=&quot;/blog/2017/08/14/strategies-for-pipelining.html&quot;&gt;traveling
CE&lt;/a&gt;
values associated with the output, &lt;code class=&quot;highlighter-rouge&quot;&gt;o_ce&lt;/code&gt;, and set the output 
value according to the last &lt;code class=&quot;highlighter-rouge&quot;&gt;r_acc&lt;/code&gt; value.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;end else // if (done)
begin
	o_ce &amp;lt;= 1&#39;b1;
	o_result &amp;lt;= r_acc;
end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;That’s the general gist of what we need to do.  Sadly, however, the code above
has multiple timing errors and pipeline scheduling conflicts within it.
For example, there should
be a clock delay between reading from memory and using the result, and another
clock delay between multiplying two numbers together and using that result.
As a result, the logic above will never work, but as a simple first draft
it should be able to convey (roughly) what it is we hope to do.&lt;/p&gt;

&lt;h2 id=&quot;the-basic-filter-written-in-c&quot;&gt;The basic filter, written in C++&lt;/h2&gt;

&lt;p&gt;Perhaps if you have a software background, you might appreciate seeing this
code written out in C++.  The following is an excerpt from an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Finite_impulse_response&quot;&gt;FIR&lt;/a&gt;
implementation found in my own personal signal processing library.  The code
uses double’s instead of fixed point, but it’s still basically the same thing.&lt;/p&gt;

&lt;p&gt;This C++ algorithm depends upon an array of &lt;code class=&quot;highlighter-rouge&quot;&gt;m_len&lt;/code&gt; coefficients, &lt;code class=&quot;highlighter-rouge&quot;&gt;m_coeff&lt;/code&gt;.
This array will be initialized with the coefficients associated with the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;
before starting.&lt;/p&gt;

&lt;p&gt;It also needs an array of data, &lt;code class=&quot;highlighter-rouge&quot;&gt;m_data&lt;/code&gt;, of the same length.  Rather than
moving all the data through the array at every point in time, we’ll just
keep track of the address of the last data element in the tapped delay line,
&lt;code class=&quot;highlighter-rouge&quot;&gt;m_loc&lt;/code&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt;	&lt;span class=&quot;nc&quot;&gt;FIR&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;m_len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;	&lt;span class=&quot;c1&quot;&gt;// Number of taps in the filter
&lt;/span&gt;	&lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt;	&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_coeff&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

	&lt;span class=&quot;c1&quot;&gt;// ...
&lt;/span&gt;	&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;m_loc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;		&lt;span class=&quot;c1&quot;&gt;// Location of the last sample in the buffer
&lt;/span&gt;	&lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt;	&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;	&lt;span class=&quot;c1&quot;&gt;// Data buffer, double[m_len]
&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;// ...
&lt;/span&gt;	&lt;span class=&quot;c1&quot;&gt;// Declare our operator
&lt;/span&gt;	&lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;apply&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i_sample&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Were this written in Verilog, such as we will do in the next section, these two
arrays would be captured in block RAMs.&lt;/p&gt;

&lt;p&gt;To evaluate the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Convolution&quot;&gt;convolution&lt;/a&gt; via the
equation above, we’ll run the following code when given a new sample,
&lt;code class=&quot;highlighter-rouge&quot;&gt;i_sample&lt;/code&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;FIR&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;apply&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i_sample&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;             &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ln&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;acc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Our first step will be to record the new sample into the data memory.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;	&lt;span class=&quot;n&quot;&gt;m_data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_loc&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dat&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_loc&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m_len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;m_loc&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;After this point, we’ll enter a loop whereby we grab one sample from
data memory and one coefficient from the coefficient memory, multiply the
two together, and accumulate the result into an accumulator, &lt;code class=&quot;highlighter-rouge&quot;&gt;acc&lt;/code&gt;.  We’ll
start the accumulator at zero.  Further, after each sample,
we’ll increase the address in coefficient memory, and decrease the address
in data memory–just as the formula above indicated.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;	&lt;span class=&quot;n&quot;&gt;acc&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;d&lt;/span&gt;   &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_loc&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;   &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_coeff&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;ln&lt;/span&gt;  &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m_loc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ln&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;acc&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The fact that the data memory isn’t centered makes this a touch more
complicated.  What that means is that if you start reading backwards
from the middle of memory (where the most recent sample was), you
will eventually run off the beginning of the memory.  Fig 3 shows this below.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 3. Data memory contains both old and new data&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/fir-slow-memory.svg&quot; alt=&quot;&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;In this figure, you can see the location &lt;code class=&quot;highlighter-rouge&quot;&gt;m_loc&lt;/code&gt; (just right of the center
of the figure) which is one past where
the new data, &lt;code class=&quot;highlighter-rouge&quot;&gt;i_sample&lt;/code&gt;, has just been written.  You can also see how
the &lt;code class=&quot;highlighter-rouge&quot;&gt;x[n-k]&lt;/code&gt; sequence extends to the left of this location.  Once this
data sequence runs off the end of memory to the left, a second pass is
required to get the rest of the data coming from the far end on the right.
This second pass continues back to where we started, making sure every data
sample in memory, and every coefficient value, is used exactly once.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;	&lt;span class=&quot;n&quot;&gt;d&lt;/span&gt;   &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m_data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_len&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;ln&lt;/span&gt;  &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ln&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_loc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ln&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;acc&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Once all of the multiplies have been completed, the result is returned.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;	&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;acc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This is the basic algorithm we will write in Verilog below.  There will be
some differences though.  The first and most obvious difference is the fact
that several parts of this algorithm will run in parallel–this is &lt;a href=&quot;/blog/2017/09/18/clocks-for-sw-engineers.html&quot;&gt;running in
hardware&lt;/a&gt;
after all.  The next, not
quite so obvious difference, is that if the memory address is limited to
some finite number of bits, then we won’t need to pay any attention to the
memory break shown above in Fig 3.  Finally, the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;
algorithm &lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/slowfil.v&quot;&gt;implemented in
Verilog&lt;/a&gt;
will be written using fixed point numbers instead of the &lt;code class=&quot;highlighter-rouge&quot;&gt;double&lt;/code&gt;-precision
floating point numbers that are so easy to use in the C++ above.&lt;/p&gt;

&lt;p&gt;Before moving on, I should make one point about the code above.  This C/C++
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;
implementation is only practical for
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;s
with &lt;a href=&quot;https://en.wikipedia.org/wiki/Impulse_response&quot;&gt;impulse responses&lt;/a&gt;
shorter than about 64 samples.  Anything more than 64 samples and you’ll
want to use an &lt;a href=&quot;https://en.wikipedia.org/wiki/Fast_Fourier_transform&quot;&gt;FFT&lt;/a&gt;
based
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filtering&lt;/a&gt;
approach.  The differences between the two approaches will become
particularly stark after double the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;
length only a few times.&lt;/p&gt;

&lt;h2 id=&quot;verilog&quot;&gt;Verilog&lt;/h2&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 4. Test Harness Filter Interface&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/fir-ports.svg&quot; alt=&quot;&quot; width=&quot;240&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;You may remember from our
&lt;a href=&quot;/dsp/2017/11/04/genfil-tb.html&quot;&gt;test harness discussion&lt;/a&gt;
that as long as a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;
implementation has the ports we discussed then, and shown again here in
Fig 4 at the right, that we can continue using our &lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/bench/cpp/filtertb.cpp&quot;&gt;generic filtering test
harness&lt;/a&gt;.
While we’ll be able to
&lt;a href=&quot;https://en.wikipedia.org/wiki/Inheritance_(object-oriented_programming)&quot;&gt;inherit&lt;/a&gt;
and modify
the &lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/bench/cpp/filtertb.cpp&quot;&gt;test harness&lt;/a&gt;
with additional functionality in the next section, we’ll 
need to start out this section by remembering that our
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;
implementation will need to have a reset, and the ability to load
taps, in addition to samples coming in and going out.&lt;/p&gt;

&lt;p&gt;We’ll start with the ability to set our
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;
coefficients.  As with many of our
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/tree/master/rtl&quot;&gt;other filters&lt;/a&gt;,
we’ll allow a parameter &lt;code class=&quot;highlighter-rouge&quot;&gt;FIXED_TAPS&lt;/code&gt; to express whether or not this
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;
has a tap-update capability at all.  If the coefficients are fixed, then
we’ll &lt;code class=&quot;highlighter-rouge&quot;&gt;$readmemh&lt;/code&gt; them from a &lt;code class=&quot;highlighter-rouge&quot;&gt;.hex&lt;/code&gt; file whose name is given in
&lt;code class=&quot;highlighter-rouge&quot;&gt;INITIAL_COEFFS&lt;/code&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	generate if (FIXED_TAPS)
	begin
		initial $readmemh(INITIAL_COEFFS, tapmem);
		// ...
	end else begin&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;On the other hand, if our
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;
coefficients are not fixed, &lt;code class=&quot;highlighter-rouge&quot;&gt;FIXED_TAPS&lt;/code&gt; will be false, and we’ll need
to load our coefficients into memory.  To do this, we’ll start with a
memory index, &lt;code class=&quot;highlighter-rouge&quot;&gt;tapwidx&lt;/code&gt;, or tap writing index.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;		reg	[(LGNTAPS-1):0]	tapwidx;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;We’ll set this index to zero initially, and to return to zero upon any reset.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;		initial	tapwidx = 0;
		always @(posedge i_clk)
			if(i_reset)
				tapwidx &amp;lt;= 0;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Otherwise, anytime the &lt;code class=&quot;highlighter-rouge&quot;&gt;i_tap_wr&lt;/code&gt; signal is high, a new coefficient is present
in &lt;code class=&quot;highlighter-rouge&quot;&gt;i_tap&lt;/code&gt; which we’ll write to coefficient memory.  We’ll also need to
increment this index.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;			else if (i_tap_wr)
				tapwidx &amp;lt;= tapwidx + 1&#39;b1;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Here’s where we actually use the tap (coefficient) writing index, &lt;code class=&quot;highlighter-rouge&quot;&gt;tapwidx&lt;/code&gt;
to write into the coefficient memory, &lt;code class=&quot;highlighter-rouge&quot;&gt;tapmem&lt;/code&gt;.  This is also the section
of the code to specify any memory initialization, so we’ll initialize the
memory if the &lt;code class=&quot;highlighter-rouge&quot;&gt;INITIAL_COEFFS&lt;/code&gt; file name is empty.  Note that the &lt;code class=&quot;highlighter-rouge&quot;&gt;if&lt;/code&gt;
statement is &lt;em&gt;outside&lt;/em&gt; of the &lt;code class=&quot;highlighter-rouge&quot;&gt;initial&lt;/code&gt; block.  That will keep the
synthesizer from looking for this file if the name hasn’t been given.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;		if (INITIAL_COEFFS != 0)
			initial $readmemh(INITIAL_COEFFS, tapmem);
		always @(posedge i_clk)
			if (i_tap_wr)
				tapmem[tapwidx] &amp;lt;= i_tap;
	end endgenerate&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;That’s all that’s required for dynamically setting or adjusting coefficient
memory.  We started with an &lt;code class=&quot;highlighter-rouge&quot;&gt;i_reset&lt;/code&gt; signal to clear the index, and then
wrote one coefficient and stepped the index on any clock where &lt;code class=&quot;highlighter-rouge&quot;&gt;i_tap_wr&lt;/code&gt; was
true.&lt;/p&gt;

&lt;p&gt;So let’s now turn our attention to the &lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/slowfil.v&quot;&gt;filter
implementation&lt;/a&gt;
itself.&lt;/p&gt;

&lt;p&gt;We’ll start with updating the data memory, herein called &lt;code class=&quot;highlighter-rouge&quot;&gt;dmem&lt;/code&gt;.  We’ll
use a data memory write index, &lt;code class=&quot;highlighter-rouge&quot;&gt;dwidx&lt;/code&gt; to do this.  Hence, on every &lt;code class=&quot;highlighter-rouge&quot;&gt;i_ce&lt;/code&gt;
value, we’ll increment the data memory write index,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	initial	dwidx = 0;
	always @(posedge i_clk)
		if (i_ce)
			dwidx &amp;lt;= dwidx + 1&#39;b1;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;and write the new sample into the data memory.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(posedge i_clk)
		if (i_ce)
			dmem[dwidx] &amp;lt;= i_sample;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;That may be about as simple as any logic could get!&lt;/p&gt;

&lt;p&gt;That said, there is a subtlety associated with this approach.
Notice in this process how the data memory update process is &lt;em&gt;independent&lt;/em&gt;
of the &lt;code class=&quot;highlighter-rouge&quot;&gt;i_reset&lt;/code&gt; signal.  It is dependent upon new sample data
only.  Further, this will allow the
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/slowfil.v&quot;&gt;filter&lt;/a&gt;
to immediately start with valid data following any reset.&lt;/p&gt;

&lt;p&gt;This &lt;em&gt;feature&lt;/em&gt;, however, will become a thorn in our side when we build our
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/bench/cpp/slowfil_tb.cpp&quot;&gt;test bench&lt;/a&gt;.
The basic problem is that we’ll want to apply test vectors to the
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/slowfil.v&quot;&gt;filter&lt;/a&gt;
that assume the memory is clear (all zeros).  While the preferred solution
might be to clear all memory elements any time &lt;code class=&quot;highlighter-rouge&quot;&gt;i_reset&lt;/code&gt; is asserted, this
isn’t how most memories are built.  That means that, when we wish to clear
this memory later, we’ll need to write as many zeros to it as are necessary
to fill it with zeros.&lt;/p&gt;

&lt;p&gt;Those two parts, loading tap coefficients and incoming data, are the easy
parts of the algorithm, though.  The next step is to calculate
the indices to be used for both reading from coefficient and data memories.
Since this gets into scheduling, let’s take a moment to start scribbling
a draft pipeline schedule.&lt;/p&gt;

&lt;p&gt;Usually, when I build a pipeline schedule, I start by writing out my code and
marking each line with the appropriate clock.  Doing this might result in
pseudocode looking something like the following.&lt;/p&gt;

&lt;p&gt;The first clock would set the memory reading indexes.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	// Clock 1 -- i_ce and i_sample are true, tidx and didx are set
	if (i_ce)
	begin
		tidx &amp;lt;= 0;
		didx &amp;lt;= dwidx;
	end else begin
		tidx &amp;lt;= tidx + 1&#39;b1;
		didx &amp;lt;= didx - 1&#39;b1;
	end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Notice how we are using the &lt;code class=&quot;highlighter-rouge&quot;&gt;i_ce&lt;/code&gt; signal as an indication of when to reset
the indices for the data and coefficient memories, &lt;code class=&quot;highlighter-rouge&quot;&gt;didx&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;tidx&lt;/code&gt;,
to the beginning of our run.  At the same time, we’ll write the new data
sample into memory–we discussed that above.  That’s the first clock.&lt;/p&gt;

&lt;p&gt;The second clock would read from memory,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	// Clock 2.
	tap &amp;lt;= tapmem[tidx];
	data &amp;lt;= dmem[didx];&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This will give us the information we need to calculate &lt;code class=&quot;highlighter-rouge&quot;&gt;h[k][x[n-k]&lt;/code&gt;, hence
we can multiply these two values together on the third clock cycle,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	// Clock 3.
	product &amp;lt;= tap * data;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Once the product is available, we’d add it to our accumulator.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	// Clock 4.
	if (new_product_data)
		acc &amp;lt;= product;
	else if (subsequent_product_data)
		acc &amp;lt;= acc + product;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The final step would be to create our output.  This will need to take place
some time into the future–at a time we’ll need to come back to and determine
later.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	// Clock ... some distance into the future
	if (new_product_data)
	begin
		o_ce &amp;lt;= 1&#39;b1;
		o_result &amp;lt;= acc;
	end else
		o_ce &amp;lt;= 1&#39;b0;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Before moving on, I tried to draw this basic pipeline schedule out in Fig 5
below for reference.  You should know, though, that whenever
I build an algorithm like this I usually just start by writing
the clock numbers in my code as we just did above.  I find these diagrams,
like Fig 5 below, are most useful to me when telling someone else about one
of my designs, such as I am doing now, then they are when I write them.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 5. Initial draft pipeline schedule&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/fir-slow-schedule-one.svg&quot; alt=&quot;&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;If you aren’t familiar with this sort of table, I use it to communicate
when variables are &lt;em&gt;valid&lt;/em&gt; within a design.  In this case, on the clock that
any new data is present, i.e.  &lt;a href=&quot;/blog/2017/08/14/strategies-for-pipelining.html&quot;&gt;the clock where &lt;code class=&quot;highlighter-rouge&quot;&gt;i_ce&lt;/code&gt; is
high&lt;/a&gt;,
the write
index for the data memory will also be valid.  These clock numbers are off by
one from the ones above, simply because variables set on one clock (as shown
in the code above) will be valid on the next clock–as shown in Fig 5.&lt;/p&gt;

&lt;p&gt;So, that’s generally what we wish to do.  To make this happen, though, let’s
add some
&lt;a href=&quot;/blog/2017/08/14/strategies-for-pipelining.html&quot;&gt;traveling valid flags&lt;/a&gt;
to this pipeline.  Specifically, we are going to want to know when to reset
the accumulator with a new product, and when to add other products into the
accumulator.  We’re also going to need to know when to set &lt;code class=&quot;highlighter-rouge&quot;&gt;o_ce&lt;/code&gt; and
&lt;code class=&quot;highlighter-rouge&quot;&gt;o_result.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;The first &lt;a href=&quot;/blog/2017/08/14/strategies-for-pipelining.html&quot;&gt;traveling valid
flag&lt;/a&gt;
we’ll call &lt;code class=&quot;highlighter-rouge&quot;&gt;pre_acc_ce&lt;/code&gt;–or the pre clock
enable for the accumulator.  We’ll use a shift register for this purpose.
Hence, on the first clock we’ll set &lt;code class=&quot;highlighter-rouge&quot;&gt;pre_acc_ce[0]&lt;/code&gt; to let us know that the
indices will be valid on the next clock.  On that next clock, we’ll set
&lt;code class=&quot;highlighter-rouge&quot;&gt;pre_acc_ce[1]&lt;/code&gt; to indicate that the memory reads are valid.  Finally, we’ll
set &lt;code class=&quot;highlighter-rouge&quot;&gt;pre_acc_ce[2]&lt;/code&gt; to indicate that the product is valid.  Further, we’ll
clear &lt;code class=&quot;highlighter-rouge&quot;&gt;pre_acc_ce[0]&lt;/code&gt; as soon as the last tap has been read.  This will then
be the indicator needed to know when to stop accumulating values.&lt;/p&gt;

&lt;p&gt;The only real trick in this logic chain is knowing when to shut &lt;code class=&quot;highlighter-rouge&quot;&gt;pre_acc_ce[0]&lt;/code&gt;
off.  In particular, it needs to be shut off once we have exhausted all of the
coefficients in the
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/slowfil.v&quot;&gt;filter&lt;/a&gt;.
We’ll come back to this in a moment, but for now
we are talking about a simple piece of scheduling logic such as,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	wire	last_tap_index;
	// ...
	reg	[2:0]	pre_acc_ce;
	initial	pre_acc_ce = 3&#39;h0;
	always @(posedge i_clk)
		if (i_reset)
			pre_acc_ce[0] &amp;lt;= 1&#39;b0;
		else if (i_ce)
			pre_acc_ce[0] &amp;lt;= 1&#39;b1;
		else if ((pre_acc_ce[0])&amp;amp;&amp;amp;(last_tap_index))
			pre_acc_ce[0] &amp;lt;= 1&#39;b1;
		else
			pre_acc_ce[0] &amp;lt;= 1&#39;b0;
	// ...

	always @(posedge i_clk)
		if (i_reset)
			pre_acc_ce[2:1] &amp;lt;= 2&#39;b0;
		else
			pre_acc_ce[2:1] &amp;lt;= pre_acc_ce[1:0];&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Once &lt;code class=&quot;highlighter-rouge&quot;&gt;i_ce&lt;/code&gt; is valid, the memory index will be valid on the next clock–so
we’ll set &lt;code class=&quot;highlighter-rouge&quot;&gt;pre_ce_acc[0]&lt;/code&gt; to true.  We’ll leave it true until we get to the
last tap index.  Likewise the values will flow through this structure just
like a shift register.&lt;/p&gt;

&lt;p&gt;But when shall we cut it off?  It needs to be cut off such that, when
the coefficient index, &lt;code class=&quot;highlighter-rouge&quot;&gt;tidx&lt;/code&gt;, is referencing the last coefficient,
&lt;code class=&quot;highlighter-rouge&quot;&gt;pre_acc_ce[0]&lt;/code&gt; will be false on the next clock.  Since our coefficient index
is counting from &lt;code class=&quot;highlighter-rouge&quot;&gt;0&lt;/code&gt; to &lt;code class=&quot;highlighter-rouge&quot;&gt;NTAPS-1&lt;/code&gt;, this can be expressed as,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	assign	last_tap_index = (NTAPS[LGNTAPS-1:0]-tidx &amp;lt;= 1);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The neat thing about this piece of logic, as you’ll see as we move forward,
is that it keeps the
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/slowfil.v&quot;&gt;filter&lt;/a&gt;
from outputting an invalid answer any time
too many clocks are given between &lt;code class=&quot;highlighter-rouge&quot;&gt;i_ce&lt;/code&gt; values.  Hence, if you have a
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/slowfil.v&quot;&gt;filter&lt;/a&gt;
with &lt;code class=&quot;highlighter-rouge&quot;&gt;NTAPS&lt;/code&gt; coefficients, yet there are more than &lt;code class=&quot;highlighter-rouge&quot;&gt;NTAPS&lt;/code&gt; clocks between
samples, then the accumulator will only pay attention to the first
&lt;code class=&quot;highlighter-rouge&quot;&gt;NTAPS&lt;/code&gt; products.&lt;/p&gt;

&lt;p&gt;This brings us to our next step: the block RAM read indices.  Upon any new
value, the
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/slowfil.v&quot;&gt;filter&lt;/a&gt;
starts accumulating from the product of coefficient zero
and the most recent data sample.  Coefficients then work forwards in their
array, while the data indexes work backwards–just like they did in the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Convolution&quot;&gt;convolution&lt;/a&gt;
formula we started with.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	initial	didx = 0;
	initial	tidx = 0;
	always @(posedge i_clk)
		if (i_ce)
		begin
			didx &amp;lt;= dwidx;
			tidx &amp;lt;= 0;
		end else begin
			didx &amp;lt;= didx - 1&#39;b1;
			tidx &amp;lt;= tidx + 1&#39;b1;
		end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Indeed, this logic is essentially identical to our last draft.&lt;/p&gt;

&lt;p&gt;We’ll also follow the clocks through the pipeline with a second
&lt;a href=&quot;/blog/2017/08/14/strategies-for-pipelining.html&quot;&gt;traveling CE&lt;/a&gt;
approach that will use a &lt;a href=&quot;/blog/2017/08/14/strategies-for-pipelining.html&quot;&gt;couple of other CE
signals&lt;/a&gt;.
The first of these, &lt;code class=&quot;highlighter-rouge&quot;&gt;m_ce&lt;/code&gt; is memory
index valid signal,
indicating that the first indices is valid.  As you follow through the code,
you’ll see other similar CE signals, such as the &lt;code class=&quot;highlighter-rouge&quot;&gt;d_ce&lt;/code&gt; signal to indicate
the first set of data and coefficient values are valid and &lt;code class=&quot;highlighter-rouge&quot;&gt;p_ce&lt;/code&gt; to indicate
the first product is valid.  We’ll use these in a moment to determine when to
load the accumulator vs adding a new value to it.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	// m_ce is valid when the first index is valid
	initial	m_ce = 1&#39;b0;
	always @(posedge i_clk)
		m_ce &amp;lt;= (i_ce)&amp;amp;&amp;amp;(!i_reset);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;On every clock cycle, we’ll read two values from block RAM–a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Impulse_response&quot;&gt;coefficient value&lt;/a&gt;
and a data value.  Note how the block RAM reading code below is explicitly
kept very simple.  This is to make certain that the tools recognize these as
reads from block RAM’s, rather than more complex logic such as one would need
to implement via a
&lt;a href=&quot;/blog/2017/06/12/minimizing-luts.html&quot;&gt;look-up-tables&lt;/a&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	initial	tap = 0;
	always @(posedge i_clk)
		tap &amp;lt;= tapmem[tidx[(LGNTAPS-1):0]];

	initial	data = 0;
	always @(posedge i_clk)
		data &amp;lt;= dmem[didx];&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Once read, we’ll set a data CE, or &lt;code class=&quot;highlighter-rouge&quot;&gt;d_ce&lt;/code&gt;, to indicate that the first data
value is now valid.  This will follow the first memory indices are valid
CE, &lt;code class=&quot;highlighter-rouge&quot;&gt;m_ce&lt;/code&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	initial	d_ce = 0;
	always @(posedge i_clk)
		d_ce &amp;lt;= (m_ce)&amp;amp;&amp;amp;(!i_reset);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;After all this work, we
can now calculate the product of &lt;code class=&quot;highlighter-rouge&quot;&gt;h[k]x[n-k]&lt;/code&gt;, herein referenced as just
&lt;code class=&quot;highlighter-rouge&quot;&gt;tap * data&lt;/code&gt;.  Another &lt;a href=&quot;/blog/2017/08/14/strategies-for-pipelining.html&quot;&gt;traveling CE
value&lt;/a&gt;,
this time &lt;code class=&quot;highlighter-rouge&quot;&gt;p_ce&lt;/code&gt;, denotes when this first product is valid.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	initial	p_ce = 1&#39;b0;
	always @(posedge i_clk)
		p_ce &amp;lt;= (d_ce)&amp;amp;&amp;amp;(!i_reset);

	initial	product = 0;
	always @(posedge i_clk)
		product &amp;lt;= tap * data;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Only now can we can finally get to the accumulator at the penultimate
stage of this chain.  On the first value given to it, that is
any time &lt;code class=&quot;highlighter-rouge&quot;&gt;p_ce&lt;/code&gt; is true–which will be true with the first product value,
&lt;code class=&quot;highlighter-rouge&quot;&gt;h[0]x[n]&lt;/code&gt;, the accumulator is set to the result of that first product.
Otherwise, any time a subsequent product is valid–as noted by
&lt;code class=&quot;highlighter-rouge&quot;&gt;pre_acc_ce[2]&lt;/code&gt; being high, the accumulator value is increased
by that clock’s &lt;code class=&quot;highlighter-rouge&quot;&gt;h[k]x[n-k]&lt;/code&gt; value.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	initial	r_acc = 0;
	always @(posedge i_clk)
		if (p_ce)
			r_acc &amp;lt;={ {(OW-(IW+TW)){product[(IW+TW-1)]}}, product };
		else if (pre_acc_ce[2])
			r_acc &amp;lt;= r_acc + { {(OW-(IW+TW)){product[(IW+TW-1)]}},
						product };&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This almost looks like the draft code we created to work out pipeline
scheduling.  The biggest difference is that we’ve done some sign extension
work above to make sure this works across multiple synthesis tools and
lint checkers.&lt;/p&gt;

&lt;p&gt;On the same clock we place a new value into the accumulator, we can also read
the last value out.  Hence we set &lt;code class=&quot;highlighter-rouge&quot;&gt;o_result&lt;/code&gt; to the output of the accumulator
on that same clock, and &lt;code class=&quot;highlighter-rouge&quot;&gt;o_ce&lt;/code&gt; to indicate this result is valid.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	initial	o_result = 0;
	always @(posedge i_clk)
		if (p_ce)
			o_result &amp;lt;= r_acc;

	initial	o_ce = 1&#39;b0;
	always @(posedge i_clk)
		o_ce &amp;lt;= (p_ce)&amp;amp;&amp;amp;(!i_reset);
endmodule&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Note that, as a consequence of this approach, &lt;code class=&quot;highlighter-rouge&quot;&gt;o_ce&lt;/code&gt; will always be true a
fixed number of clock ticks from &lt;code class=&quot;highlighter-rouge&quot;&gt;i_ce&lt;/code&gt;.  Hence, if the data stops coming, the
last accumulator value will not be read out.  Likewise, if the &lt;code class=&quot;highlighter-rouge&quot;&gt;i_ce&lt;/code&gt; values
come with fewer than &lt;code class=&quot;highlighter-rouge&quot;&gt;NTAPS&lt;/code&gt; steps between them, then the &lt;code class=&quot;highlighter-rouge&quot;&gt;o_ce&lt;/code&gt; values will
only report partial
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;
products.  There is no error detection or correction here–but you can feel
free to add it if you would like.&lt;/p&gt;

&lt;p&gt;Still, that’s what it takes to generate a
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/slowfil.v&quot;&gt;slow&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Finite_impulse_response&quot;&gt;FIR&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;
in Verilog for an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;.  Sadly,
though, the code is complex enough that we are going to lean heavily on our
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/bench/cpp/slowfil_tb.cpp&quot;&gt;test bench&lt;/a&gt;
code to know if it works or not.&lt;/p&gt;

&lt;h2 id=&quot;test-bench&quot;&gt;Test bench&lt;/h2&gt;

&lt;p&gt;When it comes time to building a
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/bench/cpp/slowfil_tb.cpp&quot;&gt;test bench&lt;/a&gt; for
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/slowfil.v&quot;&gt;this filter&lt;/a&gt;,
we’ve really already done most of the work in the &lt;a href=&quot;/dsp/2017/11/04/genfil-tb.html&quot;&gt;generic filtering
test harness&lt;/a&gt;
we built for the
&lt;a href=&quot;/dsp/2017/09/15/fastfir.html&quot;&gt;generic filter&lt;/a&gt;’s
&lt;a href=&quot;/dsp/2017/12/06/fastfir-tb.html&quot;&gt;test bench&lt;/a&gt;.
As a result, testing
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/slowfil.v&quot;&gt;this filter&lt;/a&gt;
only requires making a couple of small changes.  Indeed, if you run a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Diff_utility&quot;&gt;diff&lt;/a&gt;
between the original
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/bench/cpp/genericfir_tb.cpp&quot;&gt;test bench for a generic filter&lt;/a&gt;
and the
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/bench/cpp/slowfil_tb.cpp&quot;&gt;test bench&lt;/a&gt; for
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/slowfil.v&quot;&gt;this filter&lt;/a&gt;,
you’ll see the changes we are about to discuss below.  You might even be
surprised at how much code is in common between the two.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/slowfil.v&quot;&gt;This&lt;/a&gt;
will, however, be the first
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;
that will test the fixed number of clocks
per input clock enable, &lt;code class=&quot;highlighter-rouge&quot;&gt;i_ce&lt;/code&gt;  associated with the sample value.  As it
turns out, we did a good job
&lt;a href=&quot;/dsp/2017/11/04/genfil-tb.html&quot;&gt;building the initial&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/bench/cpp/filtertb.cpp&quot;&gt;test harness&lt;/a&gt;,
so there’s not much that needs to be changed there.&lt;/p&gt;

&lt;p&gt;Second, unlike the
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/bench/cpp/genfil_tb.cpp&quot;&gt;prior filter&lt;/a&gt;, resetting this one so that all the memory is
zero requires more work than just setting the reset flag.  In particular,
the way block RAM’s are built, they cannot be cleared in a single clock.
As a result, we’ll need to write a routine to explicitly write zero samples to
the filter’s internal memory so that any test vector generator can start
from a known state.&lt;/p&gt;

&lt;p&gt;With those two caveats aside, let’s start looking at the code.&lt;/p&gt;

&lt;p&gt;As with any code using our &lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/bench/cpp/filtertb.cpp&quot;&gt;basic filtering test
bench&lt;/a&gt;,
it starts out be declaring constants shared between the
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/bench/cpp/filtertb.cpp&quot;&gt;test bench code&lt;/a&gt;
and the
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/slowfil.v&quot;&gt;filter&lt;/a&gt;
itself.  These include the number of bits in the input, the
coefficients, the output, the number of coefficients, the delay between
input and the first output resulting from that input, and the number of
clocks per input sample.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt;	&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;IW&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;16&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;TW&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;16&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;OW&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;IW&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;TW&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;7&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;NTAPS&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;110&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;DELAY&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;CKPCE&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NTAPS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;These values are not only declared as constants at the beginning of the
test bench, but they are also used to when initializing our test bench
class.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt;	&lt;span class=&quot;nc&quot;&gt;SLOWFIL&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_TB&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;FILTERTB&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Vslowfil&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;bool&lt;/span&gt;		&lt;span class=&quot;n&quot;&gt;m_done&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

	&lt;span class=&quot;n&quot;&gt;SLOWFIL_TB&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;IW&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;IW&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;TW&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;TW&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;OW&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;OW&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;NTAPS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NTAPS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;DELAY&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;DELAY&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;CKPCE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CKPCE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This is just normal setup though.  Now we need to get into the actual
details of the test bench changes.&lt;/p&gt;

&lt;p&gt;The first change that needs to be made is to the &lt;code class=&quot;highlighter-rouge&quot;&gt;test()&lt;/code&gt; routine.  This
routine, as you &lt;a href=&quot;/dsp/2017/11/04/genfil-tb.html&quot;&gt;may
remember&lt;/a&gt;,
takes an input data stream, applies the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;,
and returns the result.  It also depends upon the filter having a zero
internal state.  Since clearing the state in this
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/bench/cpp/filtertb.cpp&quot;&gt;test bench&lt;/a&gt;
is a little more awkward, we’ll make certain to call a function to make
certain the state is cleared before calling the &lt;code class=&quot;highlighter-rouge&quot;&gt;test()&lt;/code&gt; function in the
&lt;a href=&quot;/dsp/2017/11/04/genfil-tb.html&quot;&gt;test harness&lt;/a&gt;
itself.  The neat part of this change, though, is that by
&lt;a href=&quot;https://en.wikipedia.org/wiki/Method_overriding&quot;&gt;overloading&lt;/a&gt;,
this &lt;code class=&quot;highlighter-rouge&quot;&gt;test()&lt;/code&gt; operator and using
&lt;a href=&quot;https://en.wikipedia.org/wiki/Inheritance_(object-oriented_programming)&quot;&gt;inheritance&lt;/a&gt;,
this change only requires the following four lines of code.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;	&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;	&lt;span class=&quot;nf&quot;&gt;test&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nlen&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;clear_filter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;FILTERTB&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Vslowfil&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;test&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nlen&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Unlike the
&lt;a href=&quot;/dsp/2017/12/06/fastfir-tb.html&quot;&gt;other filters&lt;/a&gt;
we’ve tested, this one requires a reset prior to loading any
new &lt;a href=&quot;https://en.wikipedia.org/wiki/Impulse_response&quot;&gt;coefficients&lt;/a&gt;.  As
you may recall from above, resetting
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/slowfil.v&quot;&gt;this filter&lt;/a&gt;
sets the index into the coefficient memory back to zero, so it is an
important part of loading a new set of
&lt;a href=&quot;https://en.wikipedia.org/wiki/Impulse_response&quot;&gt;coefficients&lt;/a&gt;.  Just a
slight modification to the
&lt;a href=&quot;/dsp/2017/11/04/genfil-tb.html&quot;&gt;test bench&lt;/a&gt;,
and this change has now been made as well.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;	&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;	&lt;span class=&quot;nf&quot;&gt;load&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nlen&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;reset&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;FILTERTB&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Vslowfil&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;load&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nlen&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Perhaps the most important change, though, is the function that we need to
write to clear the data memory within
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/slowfil.v&quot;&gt;this filter&lt;/a&gt;.
We’ll call this function &lt;code class=&quot;highlighter-rouge&quot;&gt;clear_filter()&lt;/code&gt;.  It will work by
providing one clock with &lt;code class=&quot;highlighter-rouge&quot;&gt;i_ce&lt;/code&gt; high and &lt;code class=&quot;highlighter-rouge&quot;&gt;i_sample&lt;/code&gt; set to zero per element
in the memory array.  Since the array will always be a length given by a power
of two, the internal memory may also be longer than the number of
taps, &lt;code class=&quot;highlighter-rouge&quot;&gt;NTAPS()&lt;/code&gt; in
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/slowfil.v&quot;&gt;this filter&lt;/a&gt;.
For this reason, we’ll round up to the next power of two using &lt;code class=&quot;highlighter-rouge&quot;&gt;nextlg()&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;What may surprise you, though, is that we are going to hit
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/slowfil.v&quot;&gt;this filter&lt;/a&gt;
with one new sample per clock, while ignoring the output.  The result of this
will be that the output of this run will be invalid, although the new data will
loaded into he memory as desired.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;	&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;	&lt;span class=&quot;nf&quot;&gt;clear_filter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;m_core&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i_tap_wr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

		&lt;span class=&quot;c1&quot;&gt;// ..
&lt;/span&gt;		&lt;span class=&quot;n&quot;&gt;m_core&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i_ce&lt;/span&gt;     &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;m_core&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i_sample&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nextlg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NTAPS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;());&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;tick&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;As one final step, once the memory has been loaded, we’ll let the last sample
propagate through
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/slowfil.v&quot;&gt;the filter&lt;/a&gt;,
so as to make certain
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/slowfil.v&quot;&gt;the filter&lt;/a&gt;
is in a usable state when we apply our test vectors.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;		&lt;span class=&quot;n&quot;&gt;m_core&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i_ce&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CKPCE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;tick&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;At this point, all we need to do is switch our main program to running the
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/bench/cpp/slowfil_tb.cpp&quot;&gt;test bench&lt;/a&gt;
created for this new code, and everything is roughly the same as before.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;n&quot;&gt;SLOWFIL_TB&lt;/span&gt;	&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tb&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;	&lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;argc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;**&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;argv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;Verilated&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;commandArgs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;argc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;argv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;tb&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SLOWFIL_TB&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;How’s that for fairly simple?  Indeed, implementing the
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/slowfil.v&quot;&gt;filter itself&lt;/a&gt;
was harder than this
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/bench/cpp/slowfil_tb.cpp&quot;&gt;test bench&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Of course, it’s only that simple because of the work we’ve already done,
but that just underscores the power of
&lt;a href=&quot;https://en.wikipedia.org/wiki/Object-oriented_programming&quot;&gt;Object Oriented Programming (OOP)&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;example-traces&quot;&gt;Example Traces&lt;/h2&gt;

&lt;p&gt;If you’d like to see a trace of how this all works, there’s a commented line
in the
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/bench/cpp/slowfil_tb.cpp&quot;&gt;test bench&lt;/a&gt;,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;	&lt;span class=&quot;o&quot;&gt;//&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tb&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;opentrace&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;trace.vcd&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;which, if uncommented, will create a
&lt;a href=&quot;/blog/2017/07/31/vcd.html&quot;&gt;VCD file&lt;/a&gt;
containing a trace of what
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/slowfil.v&quot;&gt;this filter&lt;/a&gt;
does in response to the
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/bench/cpp/slowfil_tb.cpp&quot;&gt;test bench&lt;/a&gt;’s
stimulus.  Be careful–the trace can quickly
become hundreds of megabytes, if not several gigabytes, in length.&lt;/p&gt;

&lt;p&gt;Still, let’s turn that on to see if we can get a feel for how
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/slowfil.v&quot;&gt;this filter&lt;/a&gt;
works.  We’ll stop the
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/bench/cpp/slowfil_tb.cpp&quot;&gt;test bench&lt;/a&gt;
after the
&lt;a href=&quot;/blog/2017/07/31/vcd.html&quot;&gt;trace file&lt;/a&gt;
gets to about 28MB–which is still more than we need for this demo.  We
can then use
&lt;a href=&quot;https://gtkwave.sourceforge.net&quot;&gt;GTKwave&lt;/a&gt;
to display the results.  You can see a screen capture of the result
in Fig 6 below.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 6. Trace of the First Impulse Test&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/fir-slowfil-trace.png&quot; alt=&quot;&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;The figure shows several key steps in the
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/bench/cpp/slowfil_tb.cpp&quot;&gt;test bench&lt;/a&gt;.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;First, at the far left, &lt;code class=&quot;highlighter-rouge&quot;&gt;i_tap_wr&lt;/code&gt; is high for many clocks as the
coefficients (&lt;code class=&quot;highlighter-rouge&quot;&gt;i_tap&lt;/code&gt;) are loaded into the
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/slowfil.v&quot;&gt;filter&lt;/a&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The &lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/slowfil.v&quot;&gt;filter&lt;/a&gt;
is then &lt;em&gt;cleared&lt;/em&gt; by writing a series of (roughly) &lt;code class=&quot;highlighter-rouge&quot;&gt;NTAPS()&lt;/code&gt;
zeros into the memory.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The &lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/bench/cpp/slowfil_tb.cpp&quot;&gt;test bench&lt;/a&gt;
then applies an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Kronecker_delta&quot;&gt;impulse&lt;/a&gt; to the
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/slowfil.v&quot;&gt;filter&lt;/a&gt;,
to verify the &lt;a href=&quot;https://en.wikipedia.org/wiki/Impulse_response&quot;&gt;response&lt;/a&gt;.
Both &lt;a href=&quot;https://en.wikipedia.org/wiki/Kronecker_delta&quot;&gt;impulse&lt;/a&gt;
and coefficient value are negative maximums, to see if the
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/slowfil.v&quot;&gt;filter&lt;/a&gt;
will overflow as a result.  What that means, though, is that the
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/slowfil.v&quot;&gt;filter&lt;/a&gt;’s
output given these coefficients and this input will be a
single positive
&lt;a href=&quot;https://en.wikipedia.org/wiki/Kronecker_delta&quot;&gt;impulse&lt;/a&gt;,
as shown in the figure above.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Suppose we zoomed in some more on how
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/slowfil.v&quot;&gt;this filter&lt;/a&gt;
operated?  In this case, see Fig 7 below.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 7. Zooming in on the first test vector&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/fir-slowfil-trace-zoom.png&quot; alt=&quot;&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;At this zoom level, you can see how the various &lt;code class=&quot;highlighter-rouge&quot;&gt;CE&lt;/code&gt;s (really misnamed
valid signals) make their way through the system until the final &lt;code class=&quot;highlighter-rouge&quot;&gt;o_ce&lt;/code&gt; and
&lt;code class=&quot;highlighter-rouge&quot;&gt;o_result&lt;/code&gt; are valid.  You can also see the &lt;code class=&quot;highlighter-rouge&quot;&gt;pre_acc_ce[2:0]&lt;/code&gt; shift register
note when the tap index and data index became valid, &lt;code class=&quot;highlighter-rouge&quot;&gt;m_ce&lt;/code&gt;, when the memory
reads were valid, &lt;code class=&quot;highlighter-rouge&quot;&gt;d_ce&lt;/code&gt;, and when the products became valid, &lt;code class=&quot;highlighter-rouge&quot;&gt;p_ce&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The point here is, even if you are struggling to understand the code itself
above, sometimes a trace becomes easier to make sense of.&lt;/p&gt;

&lt;h2 id=&quot;conclusions&quot;&gt;Conclusions&lt;/h2&gt;

&lt;p&gt;This filtering approach is really quite powerful.  Not only were we able
to reduce the number of multiplies required in order to implement
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/slowfil.v&quot;&gt;this filter&lt;/a&gt;,
but we were also able to prove it using little more than the &lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/bench/cpp/filtertb.cpp&quot;&gt;test harness
code&lt;/a&gt;
we’ve already built.&lt;/p&gt;

&lt;p&gt;Remember the discussion we started out with regarding a 2047 tap
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;?
Such a &lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;
would be sufficient to generate a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Low-pass_filter&quot;&gt;lowpass&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;
with a 480Hz
&lt;a href=&quot;https://en.wikipedia.org/wiki/Passband&quot;&gt;passband&lt;/a&gt;,
a 176Hz transition band, and a 70dB stop band.  That’s probably
good enough for any audio work you might wish to do.&lt;/p&gt;

&lt;p&gt;That doesn’t mean
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/slowfil.v&quot;&gt;this&lt;/a&gt;
is the best (or worst)
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;
out there, just one to place into your tool box.  It has a purpose, and it
works well in its own niche.&lt;/p&gt;

&lt;p&gt;What other approaches might we have tried?&lt;/p&gt;

&lt;p&gt;I’ve mentioned for some time that I’d like to build and demonstrate a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Linear_phase&quot;&gt;symmetrical filter&lt;/a&gt;.
At high speed, that filter is now built and just waiting
for a good blog post.  Similarly, a fun challenge might be to modify
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/slowfil.v&quot;&gt;this filter&lt;/a&gt;
to handle
&lt;a href=&quot;https://en.wikipedia.org/wiki/Linear_phase&quot;&gt;symmetric coefficients&lt;/a&gt;,
something that would allow it to run twice as many coefficients at once.&lt;/p&gt;

&lt;p&gt;Another future
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;
that will be fun to present is what I’m going to call
a cascaded
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;.
By cascaded
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;, I mean one that
is basically identical to
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/slowfil.v&quot;&gt;this filter&lt;/a&gt;,
except that it allows multiple
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;s
of this type to be cascaded together in order to effectively create a &lt;em&gt;much&lt;/em&gt;
longer &lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;.
In many ways, this may seem like the holy grail of generic
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;
implementation–a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;
that can be adjusted to use only as many hardware multiplies
as it is required to use given the incoming data rate.&lt;/p&gt;

&lt;p&gt;Perhaps the ultimate
&lt;a href=&quot;https://en.wikipedia.org/wiki/Low-pass_filter&quot;&gt;lowpass&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;,
however, is the multirate implementation of a 
&lt;a href=&quot;https://en.wikipedia.org/wiki/Low-pass_filter&quot;&gt;lowpass&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;.
Using multirate techniques, it should be possible to apply a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Low-pass_filter&quot;&gt;lowpass&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt; of
any bandwidth to full speed data for a cost of only 10-12 multiplies.&lt;/p&gt;

&lt;p&gt;But these are all topics for another day.&lt;/p&gt;
&lt;hr /&gt;&lt;p&gt;&lt;em&gt;Then took Mary a pound of ointment of spikenard, very costly, and anointed the feet of Jesus, and wiped his feet with her hair: and the house was filled with the odour of the ointment. (John 12:3)&lt;/em&gt;</description>
        <pubDate>Sat, 30 Dec 2017 00:00:00 -0500</pubDate>
        <link>http://zipcpu.com/dsp/2017/12/30/slowfil.html</link>
        <guid isPermaLink="true">http://zipcpu.com/dsp/2017/12/30/slowfil.html</guid>
        
        
        <category>dsp</category>
        
      </item>
    
      <item>
        <title>Mystery post: The ugliest bug I&#39;ve ever encountered</title>
        <description>&lt;p&gt;I’ve been working with software most of my life–since long before I ever
went to &lt;a href=&quot;https://wp.stolaf.edu&quot;&gt;college&lt;/a&gt;.  Now, after several decades of
working with software, I’d like to think I may have learned something about
fixing bugs in software.&lt;/p&gt;

&lt;p&gt;I’ve learned to debug bugs by their patterns, and the more often I see the
same error lead to the same bug the more these patters are enforced in my mind.
Hence, any time the symptoms of a bug match a pattern I’ve seen before, I know
exactly where to look for the bug.  When younger programmers ask me why
their code isn’t working, I just match what’s going on to a pattern I’ve seen
in the past, and I can usually find any problem they might have quite quickly.&lt;/p&gt;

&lt;p&gt;I’ve got to believe I’m not alone in this approach, and that others have also
used this approach to debugging software as well.&lt;/p&gt;

&lt;p&gt;While this approach has served me well over time, there was one bug I
encountered recently that didn’t match &lt;em&gt;any&lt;/em&gt; of the patterns I’ve learned over
my many decades.&lt;/p&gt;

&lt;h2 id=&quot;the-symptoms&quot;&gt;The Symptoms&lt;/h2&gt;

&lt;p&gt;Are you ready to see if you can recognize this bug?  Think you can do it?
Here’s what I was looking at.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 1. Writing past the end of memory&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/past-end-of-memory.svg&quot; alt=&quot;&quot; width=&quot;320&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;The code crashed with a
  &lt;em&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_error&quot;&gt;bus error&lt;/a&gt;&lt;/em&gt;,
created by trying to access a non-existent memory address using the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Stack_register&quot;&gt;stack pointer&lt;/a&gt;.&lt;/p&gt;

    &lt;p&gt;This isn’t the first time I’ve ever had a computer program do the wrong
thing.  As a result, I design my
&lt;a href=&quot;/blog/2017/06/22/simple-wb-interconnect.html&quot;&gt;wishbone interconnects&lt;/a&gt;
to both return an &lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_error&quot;&gt;error&lt;/a&gt;
upon any attempt to read from a non-existent address, as well as to
record the address created the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_error&quot;&gt;error&lt;/a&gt;.
For this reason, I knew the address the
&lt;a href=&quot;/blog/2017/06/22/simple-wb-interconnect.html&quot;&gt;interconnect&lt;/a&gt;
was seeing–and it was indeed beyond the end of memory.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;If you looked through and followed the code, there should never have been a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_error&quot;&gt;bus error&lt;/a&gt;.
&lt;a href=&quot;http://www.gcc.org&quot;&gt;GCC&lt;/a&gt; had put the proper logic into the
code to calculate the correct address.  For some reason, the correct
address wasn’t getting calculated.  Indeed, if you examined the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt; state following the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_error&quot;&gt;bus error&lt;/a&gt;, the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Stack_register&quot;&gt;stack pointer&lt;/a&gt; wasn’t
pointing to the right value.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;If I used the
&lt;a href=&quot;/zipcpu/2017/08/25/hw-debugging.html&quot;&gt;debugger&lt;/a&gt;
to step through the code, there would be no error.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Any attempt to add a debugging statement prior to the bug would keep the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt; from getting a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_error&quot;&gt;bus error&lt;/a&gt; at that instruction.&lt;/p&gt;

    &lt;p&gt;This includes both the &lt;code class=&quot;highlighter-rouge&quot;&gt;BREAK&lt;/code&gt; instruction as well any instructions which
might have been used to trigger the
&lt;a href=&quot;https://github.com/ZipCPU/wbscope&quot;&gt;wishbone scope&lt;/a&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;In my frustration at one point while I was trying to figure out what the
problem was, I decided to try Voodoo computing.&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;Defn: Voodoo computing, verb: The process of fixing what isn’t broken in 
an attempt to fix what is.  It is similar to &lt;a href=&quot;https://en.wikipedia.org/wiki/Cargo_cult&quot;&gt;Cargo
Cult&lt;/a&gt; programming.&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;p&gt;So I restarted the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; from
the beginning of the program.  (This was a warm reboot, not a cold one from
no power.)  On this second program start, the code executed as designed and
the program failed elsewhere.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Confused yet?  I certainly was.  Let me show you what the code looked like.&lt;/p&gt;

&lt;h2 id=&quot;the-software-in-question&quot;&gt;The Software in Question&lt;/h2&gt;

&lt;p&gt;The code that failed was the very first function call following a reboot.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 2. Initial stack pointer&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/initial-stack-pointer.svg&quot; alt=&quot;&quot; width=&quot;240&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;The &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; would start
at the reset address and it would load the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Stack_register&quot;&gt;stack pointer&lt;/a&gt;
with a reference to the end of memory.  While both of these are configurable
addresses within the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; infrastructure, inspecting
the code confirmed that the &lt;a href=&quot;http://www.gnu.org/software/binutils/&quot;&gt;assembler and
linker&lt;/a&gt; had done their jobs correctly.
After a couple of other instructions upon
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt; startup, the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt; would then jump to this
&lt;code class=&quot;highlighter-rouge&quot;&gt;first_subroutine&lt;/code&gt; and quickly fail.&lt;/p&gt;

&lt;p&gt;Here’s what those first few instructions looked like,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-assembly&quot; data-lang=&quot;assembly&quot;&gt;reset_address:
	; Load the stack pointer with the address of the very last location
	; in memory.  (LDI = load immediate, SP = stack pointer)
	LDI	#end_of_memory,SP
	; ... some other setup lines
	JSR	first_subroutine
	; ... code continues&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The &lt;code class=&quot;highlighter-rouge&quot;&gt;LDI&lt;/code&gt; instruction within the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
can load an arbitrary value into any register over the course of up to two
instructions.  Specifically, it takes one instruction for anything up to
23-bits, and two instructions for anything longer.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 3. The first Stack Frame&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/initial-stack-frame.svg&quot; alt=&quot;&quot; width=&quot;240&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;The program then jumped to a subroutine.  This involves copying the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Program_counter&quot;&gt;program counter&lt;/a&gt;,
&lt;code class=&quot;highlighter-rouge&quot;&gt;PC&lt;/code&gt;, into the &lt;code class=&quot;highlighter-rouge&quot;&gt;R0&lt;/code&gt; general purpose register, and then jumping to the address
given–in this case the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt;
jumped to &lt;code class=&quot;highlighter-rouge&quot;&gt;first_subroutine&lt;/code&gt;.  (I’ve since forgotten the subroutine’s actual
name.)&lt;/p&gt;

&lt;p&gt;The first several instructions in the &lt;code class=&quot;highlighter-rouge&quot;&gt;first_subroutine&lt;/code&gt; were much like any
other subroutine.  They created a stack frame by subtracting a value from the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Stack_register&quot;&gt;stack pointer&lt;/a&gt;–adjusting
it to point earlier in memory.  This creates an area in memory where the
program can hold local variables, commonly called
a &lt;a href=&quot;https://en.wikipedia.org/wiki/Call_stack&quot;&gt;stack frame&lt;/a&gt;.  The program
then attempted to save some registers to this new
&lt;a href=&quot;https://en.wikipedia.org/wiki/Call_stack&quot;&gt;stack frame&lt;/a&gt;.
In assembly, this looked like,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;first_subroutine:
	SUB	16,SP	; Create a stack fromm, subtracting 16 from SP
	SW	R0,(SP)	; Store R0 into the first position in the stack frame
	SW	R1,4(SP); BUS ERROR HERE!!!!&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;If you’ve never seen
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
assembly before, it reads from left to right, with the destination of the
instruction on the right.  Hence &lt;code class=&quot;highlighter-rouge&quot;&gt;SUB 16,SP&lt;/code&gt; subtracts sixteen from the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Stack_register&quot;&gt;stack pointer&lt;/a&gt;
and places the result back into the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Stack_register&quot;&gt;stack pointer&lt;/a&gt;.
Likewise &lt;code class=&quot;highlighter-rouge&quot;&gt;SW R0,(SP)&lt;/code&gt; stores the value of &lt;code class=&quot;highlighter-rouge&quot;&gt;R0&lt;/code&gt; into the address given by the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Stack_register&quot;&gt;stack pointer&lt;/a&gt;,
and &lt;code class=&quot;highlighter-rouge&quot;&gt;SW R1,4(SP)&lt;/code&gt; does roughly the same thing, with the
exception that &lt;code class=&quot;highlighter-rouge&quot;&gt;R1&lt;/code&gt; is saved into the location four bytes later.  Of these
three instructions, only the &lt;code class=&quot;highlighter-rouge&quot;&gt;SUB&lt;/code&gt;tract instruction modifies the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Stack_register&quot;&gt;stack pointer&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;If I pulled the code up in a
&lt;a href=&quot;/zipcpu/2017/08/25/hw-debugging.html&quot;&gt;debugger&lt;/a&gt; following
this &lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_error&quot;&gt;bus error&lt;/a&gt;,
the &lt;a href=&quot;https://en.wikipedia.org/wiki/Stack_register&quot;&gt;stack pointer&lt;/a&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;SP&lt;/code&gt;
would have the value given by the &lt;code class=&quot;highlighter-rouge&quot;&gt;end_of_memory&lt;/code&gt; value it was initially
loaded with.  It was as though the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Call_stack&quot;&gt;stack frame&lt;/a&gt;
was never created, despite the &lt;code class=&quot;highlighter-rouge&quot;&gt;SUB 16,SP&lt;/code&gt; instruction.&lt;/p&gt;

&lt;p&gt;When the 
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; then tried to write into this
&lt;a href=&quot;https://en.wikipedia.org/wiki/Call_stack&quot;&gt;stack frame&lt;/a&gt;,
it would write past the end of memory.
Depending on whether &lt;code class=&quot;highlighter-rouge&quot;&gt;end_of_memory&lt;/code&gt; pointed to the last address
in memory (where I commonly set it), or just past the end of memory would
then determine whether storing &lt;code class=&quot;highlighter-rouge&quot;&gt;R0&lt;/code&gt; to the location in the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Stack_register&quot;&gt;stack pointer&lt;/a&gt;
caused the &lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_error&quot;&gt;bus error&lt;/a&gt;
or whether it was storing &lt;code class=&quot;highlighter-rouge&quot;&gt;R1&lt;/code&gt; to the location 4 bytes later
that caused the &lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_error&quot;&gt;bus error&lt;/a&gt;.
Either way, the code caused a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_error&quot;&gt;bus error&lt;/a&gt;
and none of it made any sense to me.&lt;/p&gt;

&lt;p&gt;Before reading any further, think about the description above, and then ask
yourself: does this match any bug pattern you’ve ever seen before?  The program
fails the first time it is tried, but not the second–but then it would fail
on the third time.  Any attempt to add debugging code kept this error from
happening.&lt;/p&gt;

&lt;p&gt;Oh, and let me give you a hint: I was running my own code, on my own
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;, within an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Any ideas?&lt;/p&gt;

&lt;h2 id=&quot;what-was-it&quot;&gt;What was it?&lt;/h2&gt;

&lt;p&gt;In many ways, I was at a loss to figure out the problem until I started
up the program in a &lt;a href=&quot;https://www.veripool.org/wiki/verilator&quot;&gt;Verilator&lt;/a&gt;
&lt;a href=&quot;/blog/2017/06/21/looking-at-verilator.html&quot;&gt;based&lt;/a&gt;
&lt;a href=&quot;/zipcpu/2017/07/26/cpu-sim-debugger.html&quot;&gt;simulation&lt;/a&gt;.
(Yes, I know, I was running code that I hadn’t &lt;a href=&quot;/blog/2017/06/23/my-dbg-philosophy.html&quot;&gt;simulated first&lt;/a&gt;–&lt;a href=&quot;/blog/2017/06/02/design-process.html&quot;&gt;shame
on me&lt;/a&gt;.)  Once
I saw the bug take place within the
&lt;a href=&quot;/zipcpu/2017/07/26/cpu-sim-debugger.html&quot;&gt;simulator&lt;/a&gt;,
I knew I could find it quickly.&lt;/p&gt;

&lt;p&gt;As it turned out, the problem lied in the &lt;a href=&quot;https://github.com/ZipCPU/blob/master/rtl/core/pfcache.html&quot;&gt;prefetch and instruction cache
module&lt;/a&gt;.  This
module was declaring that an
&lt;a href=&quot;/zipcpu/2017/11/18/wb-prefetch.html&quot;&gt;instruction was valid&lt;/a&gt;
one clock cycle before the cache logic had finished writing that instruction
into the cache.  In this case, there was often a &lt;code class=&quot;highlighter-rouge&quot;&gt;NOOP&lt;/code&gt; in the cache
instead of the &lt;code class=&quot;highlighter-rouge&quot;&gt;SUB 16,SP&lt;/code&gt; instruction.  Hence, when the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt; was erroneously given the
&lt;code class=&quot;highlighter-rouge&quot;&gt;NOOP&lt;/code&gt; instruction, the &lt;a href=&quot;https://en.wikipedia.org/wiki/Stack_register&quot;&gt;stack
pointer&lt;/a&gt;,
&lt;code class=&quot;highlighter-rouge&quot;&gt;SP&lt;/code&gt;, remained where it was–pointing to the end of memory.  The subsequent
&lt;code class=&quot;highlighter-rouge&quot;&gt;SW&lt;/code&gt; (store word) instruction then wrote past the end of memory, which then
triggered the &lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_error&quot;&gt;bus error&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;I’ve tried to draw this in Fig 4 below.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 4. Reading from the cache one clock too early&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/ugliest-bug.svg&quot; alt=&quot;&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;The figure shows a single
&lt;a href=&quot;https://en.wikipedia.org/wiki/CPU_cache#CACHE-LINES&quot;&gt;cache line&lt;/a&gt;.  The
&lt;a href=&quot;https://github.com/ZipCPU/blob/master/rtl/core/pfcache.html&quot;&gt;prefetch/i-cache&lt;/a&gt;
module was filling that cache line with valid instructions.  It had filled
all but the last instruction, when it then declared the instruction was
valid.  Then, as it filled that last instruction with &lt;code class=&quot;highlighter-rouge&quot;&gt;SUB 16,SP&lt;/code&gt;, the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt;
read the &lt;code class=&quot;highlighter-rouge&quot;&gt;NOOP&lt;/code&gt; instruction that had been there one clock earlier, hence
leading to the bug.&lt;/p&gt;

&lt;p&gt;Had the subroutine’s first instruction landed anywhere else in the cache line,
being one clock early wouldn’t have mattered–since those locations would’ve
already been filled by the cache logic at that point.  This particular location
in the cache line made this appear to be one of those “phantom” bugs–bugs
that manifest at some times but not at others.  It also made it harder to
discover–as discussed above.&lt;/p&gt;

&lt;p&gt;So let’s go back through those symptoms and explain what happened, shall we?&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;We just explained why the 
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_error&quot;&gt;bus error&lt;/a&gt; took place–the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Stack_register&quot;&gt;stack pointer&lt;/a&gt; never
got updated, and so the program tried to write off the end of memory.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Although the &lt;code class=&quot;highlighter-rouge&quot;&gt;SUB 16,SP&lt;/code&gt; instruction was present in the code, the
&lt;a href=&quot;https://github.com/ZipCPU/blob/master/rtl/core/pfcache.html&quot;&gt;prefetch&lt;/a&gt;
returned a no operation instruction (&lt;code class=&quot;highlighter-rouge&quot;&gt;NOOP&lt;/code&gt;) to the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt;,
so this subtract was never executed–leaving the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Stack_register&quot;&gt;stack pointer&lt;/a&gt; pointing
to the end of memory.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The &lt;a href=&quot;/zipcpu/2017/08/25/hw-debugging.html&quot;&gt;debugger&lt;/a&gt; never
had a problem because it it operated at a much slower speed than the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt; was capable of operating.  This
gave the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt; in single stepping
mode enough time to load the cache before trying to read from the last
address in the
&lt;a href=&quot;https://en.wikipedia.org/wiki/CPU_cache#CACHE-LINES&quot;&gt;cache line&lt;/a&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;If I placed another instruction anywhere before the subtract in the
program’s instruction stream, then the &lt;code class=&quot;highlighter-rouge&quot;&gt;SUB 16,SP&lt;/code&gt; instruction would no
longer be the last element in a
&lt;a href=&quot;https://en.wikipedia.org/wiki/CPU_cache#CACHE-LINES&quot;&gt;cache line&lt;/a&gt;,
and there wouldn’t be any timing error.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;If I restarted the computer after this failure, the &lt;code class=&quot;highlighter-rouge&quot;&gt;SUB 16,SP&lt;/code&gt; instruction
would already be in the cache.  Hence, when the
&lt;a href=&quot;https://github.com/ZipCPU/blob/master/rtl/core/pfcache.html&quot;&gt;prefetch&lt;/a&gt;
declared the instruction to be valid one clock too early, it would still
read what was in the cache from the last time, i.e. the &lt;code class=&quot;highlighter-rouge&quot;&gt;SUB 16,SP&lt;/code&gt;
instruction.&lt;/p&gt;

    &lt;p&gt;That the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt; then failed somewhere
else should come as no surprise, when there is a bug of this type within
its code.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;This bug was so strange, and so different, that I though it would be fun to
share here.  I hope you enjoyed it.&lt;/p&gt;

&lt;h2 id=&quot;lessons-learned&quot;&gt;Lessons Learned&lt;/h2&gt;

&lt;p&gt;So what are some of the lessons I learned from this bug?&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;I learned the value of the
&lt;a href=&quot;/zipcpu/2017/07/26/cpu-sim-debugger.html&quot;&gt;simulator&lt;/a&gt;.
&lt;a href=&quot;/blog/2017/07/08/getting-started-with-wbscope.html&quot;&gt;Traces&lt;/a&gt;
taken using the
&lt;a href=&quot;https://github.com/ZipCPU/wbscope&quot;&gt;wishbone scope&lt;/a&gt;
just didn’t have enough information within them to permit me to recognize
the bug quickly.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;I (re)learned the fact that &lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;not all test benches will
catch all bugs&lt;/a&gt;..
This bug was not caught by my &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/sim/verilator/pfcache_tb.cpp&quot;&gt;prefetch testbench&lt;/a&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;I learned to place several cache testing pieces of code into my
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt; &lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/sw/board/cputest.c&quot;&gt;testing
program&lt;/a&gt;.
As a result, were this bug ever to show again, I’d detect it early on.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Even after all of this, I never quite trusted my &lt;a href=&quot;https://github.com/ZipCPU/blob/master/rtl/core/pfcache.html&quot;&gt;prefetch and cache
code&lt;/a&gt;
until some time later when I formally proved that it worked.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Perhaps you’d like to see that formal proof?  I’d love to share it!  However,
that will have to wait for another day and another post.&lt;/p&gt;
&lt;hr /&gt;&lt;p&gt;&lt;em&gt;Be thou diligent to know the state of thy flocks, and look well to thy herds.  (Prov 27:23)&lt;/em&gt;</description>
        <pubDate>Thu, 28 Dec 2017 00:00:00 -0500</pubDate>
        <link>http://zipcpu.com/zipcpu/2017/12/28/ugliest-bug.html</link>
        <guid isPermaLink="true">http://zipcpu.com/zipcpu/2017/12/28/ugliest-bug.html</guid>
        
        
        <category>zipcpu</category>
        
      </item>
    
      <item>
        <title>Arrow&#39;s Max-1000: A gem for all the wrong reasons</title>
        <description>&lt;p&gt;I’ll have to admit, I can be jealous of the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;
world.  When I consider the fact that I can purchase a
&lt;a href=&quot;https://www.pjrc.com/store/teensylc.html&quot;&gt;Teensy LC&lt;/a&gt; board with an
&lt;a href=&quot;https://en.wikipedia.org/wiki/ARM_architecture&quot;&gt;ARM Cortex-M0+&lt;/a&gt;
processor running at 48MHz, 62K of flash and 8K of RAM for
&lt;a href=&quot;https://www.pjrc.com/store/teensylc.html&quot;&gt;for only $12&lt;/a&gt;
from my &lt;a href=&quot;http://www.microcenter.com/product/449970/Teensy_LC_-_Low_Cost&quot;&gt;local hardware convenience
store&lt;/a&gt;,
it makes me wonder at times why I am working in an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
world where the cheapest
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
designs sell for &lt;a href=&quot;http://store.digilentinc.com/cmod-a7-breadboardable-artix-7-fpga-module/&quot;&gt;around
$75&lt;/a&gt;
or so.  Ok, so the &lt;a href=&quot;https://hackaday.io/project/12930-blackice-low-cost-open-hardware-fpga-dev-board&quot;&gt;Black ICE&lt;/a&gt;
board is a touch cheaper at $50, but this is still a far cry from the
&lt;a href=&quot;https://www.pjrc.com/store/teensylc.html&quot;&gt;$12 Teensy&lt;/a&gt;.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 1. The Max 1000&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/max1k-picture.png&quot; alt=&quot;&quot; width=&quot;320&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;Well, now there’s a new player in the ultra low-cost market.  You can now
purchase an &lt;a href=&quot;https://www.arrow.com/en/products/max1000/arrow-development-tools&quot;&gt;Arrow FPGA IoT Maker Board, the
MAX1000&lt;/a&gt;
for just $30.&lt;/p&gt;

&lt;p&gt;As I was recently asked to do some work with the
&lt;a href=&quot;https://www.arrow.com/en/products/max1000/arrow-development-tools&quot;&gt;MAX1000&lt;/a&gt;,
I thought I might share some of my first experiences and impressions with you
here.&lt;/p&gt;

&lt;p&gt;Before I get started though, you should know that I am not getting paid by
either &lt;a href=&quot;https://www.arrow.com&quot;&gt;Arrow&lt;/a&gt; or
&lt;a href=&quot;https://www.trenz-electronic.de&quot;&gt;Trenz&lt;/a&gt; to write this review.
Neither am I getting paid by &lt;a href=&quot;https://www.digilentinc.com&quot;&gt;Digilent&lt;/a&gt; for that
matter.  Rather, I’ve been asked to demonstrate that
&lt;a href=&quot;http://www.clifford.at/yosys&quot;&gt;yosys&lt;/a&gt; can be used to build a design on an
&lt;a href=&quot;httpss://www.altera.com&quot;&gt;Intel (Altera)&lt;/a&gt; platform—something I’m still
working on.&lt;/p&gt;

&lt;h2 id=&quot;the-good&quot;&gt;The Good&lt;/h2&gt;

&lt;p&gt;If you are looking for a low-priced
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
board to get started with, the
&lt;a href=&quot;https://www.arrow.com/en/products/max1000/arrow-development-tools&quot;&gt;MAX1000&lt;/a&gt;
&lt;em&gt;should&lt;/em&gt; fit the bill nicely.  Indeed, it has just about all of the basic
components within it that you should need to do
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt; work.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 2. Max 1000 peripherals&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/max-1000.svg&quot; alt=&quot;&quot; width=&quot;480&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;It has an
&lt;a href=&quot;https://www.winbond.com/resource-files/w74m64fv%20revb.pdf&quot;&gt;8MB flash&lt;/a&gt;
and, unlike the &lt;a href=&quot;https://store.digilentinc.com/cmod-s6-breadboardable-spartan-6-fpga-module&quot;&gt;CMod
S6&lt;/a&gt;
I worked with before, the
&lt;a href=&quot;https://www.arrow.com/en/products/max1000/arrow-development-tools&quot;&gt;MAX1000&lt;/a&gt;
actually has some decent RAM to work with – an
&lt;a href=&quot;https://www.winbond.com/resource-files/w9864g6jt_a03_20170331.pdf&quot;&gt;8MB SDRAM&lt;/a&gt;.
These two items are the basics you will need for any
&lt;a href=&quot;https://en.wikipedia.org/wiki/Soft_microprocessor&quot;&gt;soft CPU&lt;/a&gt;
work you wish to do.  Of course, you’ll also need an LED or two, and the
&lt;a href=&quot;https://www.arrow.com/en/products/max1000/arrow-development-tools&quot;&gt;MAX1000&lt;/a&gt;
has a nice complement of eight of them.  The
&lt;a href=&quot;http://www.st.com/content/ccc/resource/technical/document/datasheet/3c/ae/50/85/d6/b1/46/fe/CD00274221.pdf/files/CD00274221.pdf/jcr:content/translations/en.CD00274221.pdf&quot;&gt;motion sensor&lt;/a&gt;
on top is also fun bonus not normally found on most
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
boards.  Further, the 
&lt;a href=&quot;http://www.st.com/content/ccc/resource/technical/document/datasheet/3c/ae/50/85/d6/b1/46/fe/CD00274221.pdf/files/CD00274221.pdf/jcr:content/translations/en.CD00274221.pdf&quot;&gt;motion sensor&lt;/a&gt;
also contains an
&lt;a href=&quot;http://www.st.com/content/ccc/resource/technical/document/datasheet/3c/ae/50/85/d6/b1/46/fe/CD00274221.pdf/files/CD00274221.pdf/jcr:content/translations/en.CD00274221.pdf&quot;&gt;accelerometer&lt;/a&gt;
capability, so a fun project might be to create an electronic level.
Even better, the
&lt;a href=&quot;http://www.st.com/content/ccc/resource/technical/document/datasheet/3c/ae/50/85/d6/b1/46/fe/CD00274221.pdf/files/CD00274221.pdf/jcr:content/translations/en.CD00274221.pdf&quot;&gt;auxilliary A/D&lt;/a&gt;
that comes as a part of this
&lt;a href=&quot;http://www.st.com/content/ccc/resource/technical/document/datasheet/3c/ae/50/85/d6/b1/46/fe/CD00274221.pdf/files/CD00274221.pdf/jcr:content/translations/en.CD00274221.pdf&quot;&gt;MEMS motion sensor&lt;/a&gt;
 chip will spare a lot of designers the need to integrate their own
digitizer onto board.&lt;/p&gt;

&lt;p&gt;While I’m not too excited about the 12MHz oscillator, an on-board PLL
turns this nicely into a 100MHz clock for whatever your application might
require.&lt;/p&gt;

&lt;p&gt;You can even connect your own power supply to the board through its through-hole
connectors, in case you wish to run from something other than USB.&lt;/p&gt;

&lt;p&gt;Nice, huh?&lt;/p&gt;

&lt;p&gt;So what’s missing?  Your application.  That’s why I said this has &lt;em&gt;just about&lt;/em&gt;
all of the basic components you will need.  However, it has a nice host
of GPIO through-holes, and even a place where you might solder in a PMod or
perhaps just a PMod header.&lt;/p&gt;

&lt;p&gt;What makes this even nicer?  The price is &lt;em&gt;only&lt;/em&gt; $30.  This will make the board
a nice entry board for hobbyists who aren’t sure they want to do more, and
for classroom instructors who need to purchase a large number of boards to
teach with.  (You may need to teach soldering at the same time, since the board
has only through hole connectors, however.)&lt;/p&gt;

&lt;p&gt;The final item that I like about the board is the form factor.  I don’t know,
maybe it’s just me, but I tend to like &lt;em&gt;really small&lt;/em&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
boards.  Perhaps
its because they are easier to integrate into other applications.  Perhaps
it is some other reason.  Either way, I love the form factor.  Even if you
don’t like small thin boards like I do, though, you will like the fact that
there are very few bulky components to get caught on things and ripped off of
the board.&lt;/p&gt;

&lt;p&gt;Indeed, this board has the makings of being a very nice entry level
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt; board.
No, you aren’t going to learn how to process video with this board.  However,
the possibilities of what you might do with the board remain limited more
by your imagination and the size of the MAX-10
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
than anything else.  What would you like to do with it?&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 3. The ZipCPU&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/zipcpu.png&quot; alt=&quot;The ZipCPU&#39;s pipelined architecture&quot; width=&quot;320&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Personally? I might like to place a
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
onto this board.  I think I already have just about every thing I need for that.
I’ve got a full featured &lt;a href=&quot;https://opencores.org/project,qspiflash&quot;&gt;QSPI flash
controller&lt;/a&gt;, and even an &lt;a href=&quot;https://github.com/ZipCPU/xulalx25soc/blob/master/rtl/wbsdram.v&quot;&gt;SDRAM
controller&lt;/a&gt;
from &lt;a href=&quot;https://github.com/ZipCPU/xulalx25soc/blob/master/rtl/wbsdram.v&quot;&gt;another
project&lt;/a&gt;.  I
should be good to go, right?&lt;/p&gt;

&lt;h2 id=&quot;the-bad&quot;&gt;The Bad&lt;/h2&gt;

&lt;p&gt;While I love the
&lt;a href=&quot;https://www.arrow.com/en/products/max1000/arrow-development-tools&quot;&gt;MAX1000&lt;/a&gt;’s
design and the opportunities built into the circuit board,
and while the sales sheet looks beautiful, building with
this board has already taken more work than I had expected.  The primary
difficulty I’ve had so far, other than the &lt;em&gt;Ugly&lt;/em&gt; section below, has been
finding the documentation.&lt;/p&gt;

&lt;p&gt;The first part of working with any circuit board is always finding the
documentation.  This means finding a board’s
&lt;a href=&quot;https://www.trenz-electronic.de/fileadmin/docs/Trenz_Electronic/TEI0001/REV02/Documents/SCH-TEI0001-02-08-C8.PDF&quot;&gt;schematic&lt;/a&gt;,
its &lt;a href=&quot;https://www.trenz-electronic.de/fileadmin/docs/Trenz_Electronic/TEI0001/User_Guide/MAX1000%20User%20Guide.pdf&quot;&gt;User Guide&lt;/a&gt;,
and any data sheets for the parts on the board.
In this regard, I may be spoiled by
&lt;a href=&quot;https://www.digilentinc.com&quot;&gt;Digilent&lt;/a&gt;–their documentation is always found
from a link on the sales page, and it is usually quite complete.
For the
&lt;a href=&quot;https://www.arrow.com/en/products/max1000/arrow-development-tools&quot;&gt;MAX1000&lt;/a&gt;,
however, I had to struggle for quite some time to find its documentation.
I couldn’t find it linked anywhere from &lt;a href=&quot;https://www.arrow.com/en/products/max1000/arrow-development-tools&quot;&gt;Arrow’s sales
page&lt;/a&gt;,
nor was their &lt;a href=&quot;https://www.arrow.com/en/products/max1000/arrow-development-tools&quot;&gt;sales documentation&lt;/a&gt;
anything I could build with.  To make matters worse, searching
&lt;a href=&quot;https://www.arrow.com/en/products/max1000/arrow-development-tools&quot;&gt;Arrow’s&lt;/a&gt;
data sheets was quite fruitless–and yet they are selling this board.&lt;/p&gt;

&lt;p&gt;To spare you the trouble, I’ll post the links I finally found below.
(Thank you &lt;a href=&quot;https://google.com&quot;&gt;Google&lt;/a&gt;.) The support for the
&lt;a href=&quot;https://www.arrow.com/en/products/max1000/arrow-development-tools&quot;&gt;MAX1000&lt;/a&gt;
comes from 
&lt;a href=&quot;https://forum.trenz-electronic.de/&quot;&gt;Trenz Electronic&lt;/a&gt;, who has built both a
&lt;a href=&quot;https://shop.trenz-electronic.de/en/path?=Trenz_Electronic/TE10001&quot;&gt;wiki&lt;/a&gt;
page for the board, as well as hosting a
&lt;a href=&quot;https://forum.trenz-electronic.de/&quot;&gt;forum&lt;/a&gt; for any problems you might have.
Indeed, you can find these links from &lt;a href=&quot;https://shop.trenz-electronic.de/en/TEI0001-02-08-C8-MAX1000-IoT-Maker-Board&quot;&gt;Trenz’s sales
page&lt;/a&gt;
for the
&lt;a href=&quot;https://www.arrow.com/en/products/max1000/arrow-development-tools&quot;&gt;MAX1000&lt;/a&gt;.
(Well done &lt;a href=&quot;https://shop.trenz-electronic.de&quot;&gt;Trenz&lt;/a&gt;!)&lt;/p&gt;

&lt;p&gt;Hence, with a little work I was able to find the
&lt;a href=&quot;https://www.trenz-electronic.de/fileadmin/docs/Trenz_Electronic/TEI0001/REV02/Documents/SCH-TEI0001-02-08-C8.PDF&quot;&gt;schematic&lt;/a&gt;
and even a &lt;a href=&quot;https://www.trenz-electronic.de/fileadmin/docs/Trenz_Electronic/TEI0001/User_Guide/MAX1000%20User%20Guide.pdf&quot;&gt;User Guide&lt;/a&gt;.  From the
&lt;a href=&quot;https://www.trenz-electronic.de/fileadmin/docs/Trenz_Electronic/TEI0001/REV02/Documents/SCH-TEI0001-02-08-C8.PDF&quot;&gt;schematic&lt;/a&gt;
I could google the data sheet for any part on the board.  Indeed, you’ll
find many of the links within this article point to the data sheets that
I was able to find.&lt;/p&gt;

&lt;p&gt;The &lt;a href=&quot;https://shop.trenz-electronic.de/en/path?=Trenz_Electronic/TE10001&quot;&gt;wiki&lt;/a&gt;
also offered several example designs that I might use.  However, as I looked
through each of them, none of them had any HDL code–whether Verilog or VHDL.&lt;/p&gt;

&lt;p&gt;Worse, although the
&lt;a href=&quot;https://www.trenz-electronic.de/fileadmin/docs/Trenz_Electronic/TEI0001/REV02/Documents/SCH-TEI0001-02-08-C8.PDF&quot;&gt;schematic&lt;/a&gt;
described what pins were connected to which part, and even described which
pins were available for external connections, it offered nothing to tell me
which pins corresponded to which GPIO’s.&lt;/p&gt;

&lt;p&gt;For example, consider what the
&lt;a href=&quot;https://www.trenz-electronic.de/fileadmin/docs/Trenz_Electronic/TEI0001/REV02/Documents/SCH-TEI0001-02-08-C8.PDF&quot;&gt;schematic&lt;/a&gt;
has to say about the GPIO’s on the
left and right sides of the board, shown in Fig 3.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 3. GPIO&#39;s&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/max1k-schematic-gpio.png&quot; alt=&quot;GPIO picture from the Schematic&quot; width=&quot;615&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Now, looking at that figure, can you tell me which pins will be which?  Are the
pins on “top” the ones closest to the USB connector on the board?  Are both
rows organized in the same fashion?  It doesn’t say.  This means that I will
need to spend time probing and reverse engineering just to orient the
&lt;a href=&quot;https://www.trenz-electronic.de/fileadmin/docs/Trenz_Electronic/TEI0001/REV02/Documents/SCH-TEI0001-02-08-C8.PDF&quot;&gt;schematic&lt;/a&gt;
to the board.&lt;/p&gt;

&lt;p&gt;The problem isn’t limited to the two rows of GPIO pins.  The
&lt;a href=&quot;https://www.trenz-electronic.de/fileadmin/docs/Trenz_Electronic/TEI0001/REV02/Documents/SCH-TEI0001-02-08-C8.PDF&quot;&gt;schematic&lt;/a&gt;
also has the same problem when describing the PMod port.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 4. GPIO&#39;s&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/max1k-schematic-pmod.png&quot; alt=&quot;PMod picture from the Schematic&quot; width=&quot;450&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;In both examples, the schematic
makes it clear that the pins are available for use, but still leaves a lot
for granted in how these pins are mapped to the actual device.  For example,
is pin 1 closer to the USB port, or is pin 5?  Which side are the 3.3V and
ground pins on, left or right?  And which way constitutes “left” or “right”?&lt;/p&gt;

&lt;p&gt;Perhaps I’m spoiled.  I was considering connecting the
&lt;a href=&quot;https://www.arrow.com/en/products/max1000/arrow-development-tools&quot;&gt;MAX1000&lt;/a&gt;
to a &lt;a href=&quot;http://www.microcenter.com/product/449970/Teensy_LC_-_Low_Cost&quot;&gt;Teensy
LC&lt;/a&gt;,
and looking at the &lt;a href=&quot;https://www.pjrc.com/teenhttps://www.pjrc.com/teensy/teensylc_front_pinout.pngsy/teensyLC.html&quot;&gt;Teensy
LC’s&lt;/a&gt;
&lt;a href=&quot;https://www.pjrc.com/teensy/teensylc_front_pinout.png&quot;&gt;I/O diagrams&lt;/a&gt; it was
easy to correlate their physical I/O pins to both their I/O pin numbers and
their associated functionality.&lt;/p&gt;

&lt;p&gt;Unfortunately, the
&lt;a href=&quot;https://www.arrow.com/en/products/max1000/arrow-development-tools&quot;&gt;MAX1000&lt;/a&gt;
doesn’t have a simple picture showing how the pins are connected.&lt;/p&gt;

&lt;p&gt;While such a diagram should be easy enough to create, I couldn’t find
anything mapping pins to I/O’s on the board.  The closest I could find were
the (in order) pin numbers on the
&lt;a href=&quot;https://www.trenz-electronic.de/fileadmin/docs/Trenz_Electronic/TEI0001/REV02/Documents/SCH-TEI0001-02-08-C8.PDF&quot;&gt;schematic&lt;/a&gt;
for each of the headers.  However, this wasn’t enough for me to determine
header orientation, etc.&lt;/p&gt;

&lt;p&gt;So while I like the hardware design and build, I’d strike a mark from the board
for its (currently) poor documentation set.&lt;/p&gt;

&lt;h2 id=&quot;the-ugly&quot;&gt;The ugly&lt;/h2&gt;

&lt;p&gt;Okay, now for the really ugly part: I bought my 
&lt;a href=&quot;https://www.arrow.com/en/products/max1000/arrow-development-tools&quot;&gt;MAX1000&lt;/a&gt;
only to discover on the 
&lt;a href=&quot;https://shop.trenz-electronic.de/en/path?=Trenz_Electronic/TE10001&quot;&gt;wiki&lt;/a&gt;
that they hadn’t finished building their Linux driver yet, so they hadn’t
yet posted it for download.&lt;/p&gt;

&lt;p&gt;Please, guys, can’t you hold off selling an item until the driver’s needed to
support it are built and tested?&lt;/p&gt;

&lt;p&gt;A month later, now, they finally have a
&lt;a href=&quot;https://shop.trenz-electronic.de/en/Download/?path=Trenz_Electronic/TEI0001/Driver/Arrow_USB_Blaster&quot;&gt;Linux driver posted&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The problem is … it doesn’t work.&lt;/p&gt;

&lt;p&gt;Sure, they have directions for installing their driver, directions which
clearly tell you how to set it up.  These directions have two problems.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;First, they tell me that I need to disable (blacklist) the linux
&lt;code class=&quot;highlighter-rouge&quot;&gt;ftdi_sio&lt;/code&gt; kernel module.  This is the very same kernel module that I am
using quite successfully and extensively with my other
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
projects.  Blacklisting this kernel module will likely impact my other work
in a negative fashion.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;If this wasn’t unworkable enough on its own, the second problem is that even
after following their instructions I still couldn’t get Quartus’s JTAG
loader to acknowledge that my hardware even existed.
(See section 6.1.4 of the &lt;a href=&quot;https://www.trenz-electronic.de/fileadmin/docs/Trenz_Electronic/TEI0001/User_Guide/MAX1000%20User%20Guide.pdf&quot;&gt;User Guide&lt;/a&gt;
to know where this first failed for me.)&lt;/p&gt;

    &lt;p&gt;To make matters worse, neither the &lt;a href=&quot;https://www.trenz-electronic.de/fileadmin/docs/Trenz_Electronic/TEI0001/User_Guide/MAX1000%20User%20Guide.pdf&quot;&gt;User
Guide&lt;/a&gt;
nor the &lt;a href=&quot;https://shop.trenz-electronic.de/en/Download/?path=Trenz_Electronic/TEI0001/Driver/Arrow_USB_Blaster&quot;&gt;Linux driver installation
instructions&lt;/a&gt;
offer any help in troubleshooting any potential problems.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;My best guess is that there’s something missing in their instructions that
they’ve overlooked, but I’m not sure what it might be.  Perhaps they sold
the device with the wrong
&lt;a href=&quot;http://www.st.com/resource/en/datasheet/CD00001142.pdf&quot;&gt;EEPROM&lt;/a&gt;
settings for the “USB blaster” (i.e. the
&lt;a href=&quot;http://www.ftdichip.com/Support/Documents/DataSheets/ICs/DS_FT2232H.pdf&quot;&gt;FT2232&lt;/a&gt;).&lt;/p&gt;

&lt;h2 id=&quot;the-redeeming&quot;&gt;The Redeeming&lt;/h2&gt;

&lt;p&gt;Here’s the really neat and redeeming part to this whole story: while the
&lt;a href=&quot;https://shop.trenz-electronic.de/en/Download/?path=Trenz_Electronic/TEI0001/Driver/Arrow_USB_Blaster&quot;&gt;Trenz driver&lt;/a&gt;
doesn’t work (yet), I can still configure my
&lt;a href=&quot;https://www.arrow.com/en/products/max1000/arrow-development-tools&quot;&gt;MAX1000&lt;/a&gt;
just fine using the open source &lt;a href=&quot;http://www.clifford.at/libxsvf&quot;&gt;libxvsf&lt;/a&gt;
driver.  No, it’s not point-and-click.  No, I haven’t (yet)
tried it with more than one device on my system–I need to experiment
with that still.  However, I didn’t need to blacklist my working
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
serial port driver to use it.&lt;/p&gt;

&lt;p&gt;To use this tool, you’ll want to download
&lt;a href=&quot;https://en.wikipedia.org/wiki/Universal_asynchronous_receiver/transmitter&quot;&gt;libxsvf&lt;/a&gt;
and build it.  I know there’s got to be an easier way to clone an svn
repository, but I ended up just copying the files in the repository one by
one to my computer.  I then built the package using &lt;code class=&quot;highlighter-rouge&quot;&gt;make all&lt;/code&gt;.  In hindsight,
this is a bit of overkill since i only needed the &lt;code class=&quot;highlighter-rouge&quot;&gt;xsvftool-ft232h&lt;/code&gt; program.
You will need to have the &lt;a href=&quot;https://www.intra2net.com/en/developer/libftdi/&quot;&gt;open source FTDI
library&lt;/a&gt;
and &lt;code class=&quot;highlighter-rouge&quot;&gt;pthreads&lt;/code&gt; installed on your system.&lt;/p&gt;

&lt;p&gt;I was a little concerned about whether this would work with the device I was
using or not, so I then proceeded slowly for the next several steps—just
to make sure I knew what I was doing (and so I didn’t destroy any of my
hardware).&lt;/p&gt;

&lt;p&gt;Hence the first thing I did was to unplug all of my other USB controlled
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
devices.  This probably isn’t technically required, but it does limit the
number of things can go wrong.&lt;/p&gt;

&lt;p&gt;I then issued a command to check the JTAG chain.  I did this to get some
assurance that the tool worked as advertised.  Since I already knew that my
&lt;a href=&quot;https://www.arrow.com/en/products/max1000/arrow-development-tools&quot;&gt;MAX1000&lt;/a&gt;
had a USB ID of &lt;code class=&quot;highlighter-rouge&quot;&gt;0403:6010&lt;/code&gt;, this command was:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;xsvftool-ft232h -D i:0x403:0x6010 -C A -c&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The result was a rather cryptic error that &lt;code class=&quot;highlighter-rouge&quot;&gt;xsvftool-ft2232h&lt;/code&gt; couldn’t open my
device.  Hence, I quickly peppered the &lt;code class=&quot;highlighter-rouge&quot;&gt;xsvftool-ft2232h.c&lt;/code&gt; code with
&lt;a href=&quot;http://www.cplusplus.com/reference/cstdio/perror&quot;&gt;perror()&lt;/a&gt;
statements anytime an O/S call might fail.  (Don’t you just love
open source?)  As a result, I learned that I didn’t have the permission
to execute this command.&lt;/p&gt;

&lt;p&gt;Next, I tried:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;sudo xsvftool-ft232h -D i:0x403:0x6010 -C A -c&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;and this seemed to work.  The result was the simple line,&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;idcode=0x031820dd, revision=0x0, part=0x3182, manufactor=0x06e&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;After looking up the manufacturer’s ID code, I confirmed that &lt;code class=&quot;highlighter-rouge&quot;&gt;6e&lt;/code&gt; is indeed
the manufacturer code for
&lt;a href=&quot;httpss://www.altera.com&quot;&gt;Altera&lt;/a&gt;.  Further, &lt;a href=&quot;httpss://www.altera.com&quot;&gt;Altera&lt;/a&gt;’s
JTAG documentation identifies that the &lt;code class=&quot;highlighter-rouge&quot;&gt;0x031820dd&lt;/code&gt; device is indeed the MAX-10
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
I am working with.&lt;/p&gt;

&lt;p&gt;Ok, so now I know I’m talking to the right chip.&lt;/p&gt;

&lt;p&gt;I then tried reading the
&lt;a href=&quot;http://www.ftdichip.com/Support/Documents/DataSheets/ICs/DS_FT2232H.pdf&quot;&gt;FT2232&lt;/a&gt;’s
&lt;a href=&quot;http://www.st.com/resource/en/datasheet/CD00001142.pdf&quot;&gt;EEPROM&lt;/a&gt;
from the device.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;sudo xsvftool-ft232h -D i:0x403:0x6010 -C A -R ftdi.eeprom&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The result was an error that the
&lt;a href=&quot;http://www.st.com/resource/en/datasheet/CD00001142.pdf&quot;&gt;EEPROM&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Cyclic_redundancy_check&quot;&gt;CRC&lt;/a&gt;
didn’t match.  (I may have to look into that some more.)  However, the
command also produced a file that, when dumped in hex, looked like:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;0000000 01 08 03 04 10 60 00 07 80 fa 08 00 41 44 9a 0c
0000020 a6 24 ca 12 00 00 00 00 66 00 00 00 00 00 00 00
0000040 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
*
0000200&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The third through sixth bytes of this file, &lt;code class=&quot;highlighter-rouge&quot;&gt;03 04 10 60&lt;/code&gt;, caught my
attention.  Knowing that
&lt;a href=&quot;http://www.ftdichip.com/Support/Documents/DataSheets/ICs/DS_FT2232H.pdf&quot;&gt;FT2232&lt;/a&gt;
chips keep their USB identifiers in their
&lt;a href=&quot;http://www.st.com/resource/en/datasheet/CD00001142.pdf&quot;&gt;EEPROM&lt;/a&gt;
memory, I immediately recognized these bytes as the
USB ID of &lt;code class=&quot;highlighter-rouge&quot;&gt;0403:6010&lt;/code&gt;–exactly what I expected from &lt;code class=&quot;highlighter-rouge&quot;&gt;lsusb&lt;/code&gt;, the udev
configuration file I was told to install, and more.&lt;/p&gt;

&lt;p&gt;The next task was to load my
&lt;a href=&quot;https://www.arrow.com/en/products/max1000/arrow-development-tools&quot;&gt;MAX1000&lt;/a&gt;
with my just-built configuration.  For this, I opened up the “Program Device”
dialog, and clicked on “Create JAM, JBC, SVF or ISC File…” from the file
menu.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 3. Quartus Programming Tool Dialog&#39;s File Menu Option&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/quartus-pgm-file-menu.png&quot; alt=&quot;Creating an SVF file in Quartus&quot; width=&quot;320&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;From here, I could save my design in the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Serial_Vector_Format&quot;&gt;Serial Vector Format (SVF)&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Universal_asynchronous_receiver/transmitter&quot;&gt;libxsvf&lt;/a&gt;
required.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 4. Max 1000 peripherals&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/quartus-svf-dialog.png&quot; alt=&quot;Creating an SVF file in Quartus&quot; width=&quot;320&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;I then ran,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;sudo xsvftool-ft232h  -D i:0x403:0x6010 -C A -s quartus/toplevel.svf&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;and &lt;em&gt;my design loaded and worked&lt;/em&gt;!!&lt;/p&gt;

&lt;p&gt;But perhaps I haven’t made clear the significance of this.&lt;/p&gt;

&lt;p&gt;One common question on the
&lt;a href=&quot;https://www.digilentinc.com&quot;&gt;Digilent&lt;/a&gt;
&lt;a href=&quot;https://forum.digilentinc.com&quot;&gt;forum&lt;/a&gt;
is how to do things with the &lt;a href=&quot;http://www.ftdichip.com/Support/Documents/DataSheets/ICs/DS_FT2232H.pdf&quot;&gt;FT2232H FTDI
chip&lt;/a&gt;
on &lt;a href=&quot;https://www.digilentinc.com&quot;&gt;their&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt; boards.
&lt;a href=&quot;https://www.digilentinc.com&quot;&gt;Digilent&lt;/a&gt;’s
answer has always been that the circuitry and configurations associated with the
&lt;a href=&quot;http://www.ftdichip.com/Support/Documents/DataSheets/ICs/DS_FT2232H.pdf&quot;&gt;FT2232&lt;/a&gt;
JTAG loader is a proprietary part of the board.
For those who “accidentally” erase the firmware on their board, the issue
is taken off forum and the poster is quietly given instructions (and software)
to reload the firmware (i.e. the
&lt;a href=&quot;http://www.ftdichip.com/Support/Documents/DataSheets/ICs/DS_FT2232H.pdf&quot;&gt;FT2232&lt;/a&gt;’s
&lt;a href=&quot;http://www.st.com/resource/en/datasheet/CD00001142.pdf&quot;&gt;EEPROM&lt;/a&gt;).&lt;/p&gt;

&lt;p&gt;However, using &lt;a href=&quot;http://www.clifford.at/libxsvf&quot;&gt;libxvsf&lt;/a&gt;,
you can both read the firmware before playing with it, and you can
(or at least should be able to) reconfigure it yourself.  Want to see what
the &lt;a href=&quot;https://www.digilentinc.com&quot;&gt;Digilent&lt;/a&gt;
&lt;a href=&quot;https://store.digilentinc.com/arty-artix-7-fpga-development-board-for-makers-and-hobbyists/&quot;&gt;Arty&lt;/a&gt;
&lt;a href=&quot;http://www.ftdichip.com/Support/Documents/DataSheets/ICs/DS_FT2232H.pdf&quot;&gt;FT2232H&lt;/a&gt;
configuration looks like?&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;0000000 01 08 03 04 10 60 00 07 80 fa 08 00 00 00 9a 12
0000020 ac 28 d4 1a 00 00 00 00 56 00 01 00 c7 92 6a 35
0000040 51 01 00 02 41 72 74 79 00 00 00 00 00 00 00 00
0000060 00 00 00 00 00 44 69 67 69 6c 65 6e 74 20 41 72
0000100 74 79 00 00 00 00 00 00 00 00 00 00 00 00 00 00
0000120 00 00 01 00 00 00 00 00 00 00 00 00 00 00 00 00
0000140 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
*
0000200&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;If you do an &lt;code class=&quot;highlighter-rouge&quot;&gt;od -c&lt;/code&gt; instead of an &lt;code class=&quot;highlighter-rouge&quot;&gt;od -t x1&lt;/code&gt; on the
&lt;a href=&quot;https://store.digilentinc.com/arty-artix-7-fpga-development-board-for-makers-and-hobbyists/&quot;&gt;Arty&lt;/a&gt;’s configuration file,
you get the following:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;0000000 001  \b 003 004 020 140  \0  \a 200 372  \b  \0  \0  \0 232 022
0000020 254   ( 324 032  \0  \0  \0  \0   V  \0 001  \0 307 222   j   5
0000040   Q 001  \0 002   A   r   t   y  \0  \0  \0  \0  \0  \0  \0  \0
0000060  \0  \0  \0  \0  \0   D   i   g   i   l   e   n   t       A   r
0000100   t   y  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0
0000120  \0  \0 001  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0
0000140  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0
*
0000200&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;So, if I want to try my own
&lt;a href=&quot;http://www.ftdichip.com/Support/Documents/DataSheets/ICs/DS_FT2232H.pdf&quot;&gt;FT2232H&lt;/a&gt;
configuration and things don’t work out, I just need to return the device
to this configuration.&lt;/p&gt;

&lt;p&gt;It gets better.&lt;/p&gt;

&lt;p&gt;Should you wish to build your own own design using the
&lt;a href=&quot;http://www.ftdichip.com/Support/Documents/DataSheets/ICs/DS_FT2232H.pdf&quot;&gt;FT2232H&lt;/a&gt;
chip, the
&lt;a href=&quot;https://www.arrow.com/en/products/max1000/arrow-development-tools&quot;&gt;MAX1000&lt;/a&gt;
&lt;a href=&quot;https://www.trenz-electronic.de/fileadmin/docs/Trenz_Electronic/TEI0001/REV02/Documents/SCH-TEI0001-02-08-C8.PDF&quot;&gt;schematic&lt;/a&gt;
offers an example design, showing how to hook it up.  As a result, there’s no
need to ask for the proprietary portion of any
&lt;a href=&quot;https://www.digilentinc.com&quot;&gt;Digilent&lt;/a&gt; schematic if you want an example.
It’s already published for the
&lt;a href=&quot;https://www.arrow.com/en/products/max1000/arrow-development-tools&quot;&gt;MAX1000&lt;/a&gt;
as part of their &lt;a href=&quot;https://www.trenz-electronic.de/fileadmin/docs/Trenz_Electronic/TEI0001/REV02/Documents/SCH-TEI0001-02-08-C8.PDF&quot;&gt;schematic&lt;/a&gt; (see page 5).&lt;/p&gt;

&lt;p&gt;This is all kind of nice and rather neat, but we aren’t done yet.&lt;/p&gt;

&lt;p&gt;The &lt;a href=&quot;http://www.ftdichip.com/Support/Documents/DataSheets/ICs/DS_FT2232H.pdf&quot;&gt;FT2232H FTDI
chip&lt;/a&gt;
found on so many
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
boards offers more than just a USB to
&lt;a href=&quot;https://en.wikipedia.org/wiki/Universal_asynchronous_receiver-transmitter&quot;&gt;UART&lt;/a&gt;
interface mode.  It also offers a USB to
“&lt;a href=&quot;http://www.ftdichip.com/Support/Documents/DataSheets/ICs/DS_FT2232H.pdf&quot;&gt;Fast Serial Interface&lt;/a&gt;”
mode.  This is a simplex, bidirectional interface–with one direction of that
interface shown in Fig 5 below.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 5. Outgoing Fast Serial Data using the FT2232 chip&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/ftdi-fast-serial.png&quot; alt=&quot;&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;As you can see from the figure, this mode works much like a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Universal_asynchronous_receiver-transmitter&quot;&gt;UART&lt;/a&gt;,
with the exception of a clock that can run at up to 50MHz.  That means that
it should be possible to communicate to/from your board
at 5MBps (that’s mega-&lt;em&gt;BYTES&lt;/em&gt; per second), rather than the maximum
&lt;a href=&quot;https://en.wikipedia.org/wiki/Universal_asynchronous_receiver-transmitter&quot;&gt;UART&lt;/a&gt;
rate which is about 200kBps (2MBaud).
Even better, should you wish to play with this mode, the
&lt;a href=&quot;http://www.ftdichip.com/Support/Documents/DataSheets/ICs/DS_FT2232H.pdf&quot;&gt;FT2232 datasheet&lt;/a&gt;
provides all the information you need: from pin assignments to configuration
and more.&lt;/p&gt;

&lt;p&gt;Interested in a 25x speed increase anyone?&lt;/p&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;I suppose at the end of any review I should offer a recommendation: should
someone buy this board or not?  To that question I would answer that it depends
upon the someone.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;If you are willing to do some soldering, and you aren’t afraid of
working without the best documentation then you might find this a nicely
built, well-designed
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
board to work with.&lt;/p&gt;

    &lt;p&gt;It certainly offers more capabilities than the 
&lt;a href=&quot;https://store.digilentinc.com/cmod-s6-breadboardable-spartan-6-fpga-module&quot;&gt;CMod S6&lt;/a&gt;,
at a much lower price point, although you will need to do some soldering
if you want to connect the
&lt;a href=&quot;https://www.arrow.com/en/products/max1000/arrow-development-tools&quot;&gt;MAX1000&lt;/a&gt;
to a breadboard.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;In a similar fashion, if you want to do some experimentation with the
&lt;a href=&quot;http://www.ftdichip.com/Support/Documents/DataSheets/ICs/DS_FT2232H.pdf&quot;&gt;FT2232&lt;/a&gt;
interface found on many
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
boards, the documentation and
&lt;a href=&quot;http://www.clifford.at/libxsvf&quot;&gt;libxvsf&lt;/a&gt;
should give you a clear enough starting point.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;On the other hand, if you’ve never done any
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
design before and just want a beginner’s board, this probably isn’t (yet)
the board you want to start out with.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;As for me, finding an open source
&lt;a href=&quot;http://www.ftdichip.com/Support/Documents/DataSheets/ICs/DS_FT2232H.pdf&quot;&gt;FT2232&lt;/a&gt;
interface and
&lt;a href=&quot;https://www.trenz-electronic.de/fileadmin/docs/Trenz_Electronic/TEI0001/REV02/Documents/SCH-TEI0001-02-08-C8.PDF&quot;&gt;schematic&lt;/a&gt;
makes it all worth while.  Indeed, I’m still drooling over the opportunity
to fire up and test that 5MBps fast serial I/O link.&lt;/p&gt;
&lt;hr /&gt;&lt;p&gt;&lt;em&gt;He that withholdeth corn, the people shall curse him: but blessing shall be upon the head of him that selleth it.  (Prov 11:26)&lt;/em&gt;</description>
        <pubDate>Sat, 16 Dec 2017 00:00:00 -0500</pubDate>
        <link>http://zipcpu.com/blog/2017/12/16/max1k.html</link>
        <guid isPermaLink="true">http://zipcpu.com/blog/2017/12/16/max1k.html</guid>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>Building a Simple Logic PLL</title>
        <description>&lt;p&gt;There’s one signal processing component that has always felt like a black
art to me, and that is a &lt;a href=&quot;https://en.wikipedia.org/wiki/Phase-locked_loop&quot;&gt;Phase Locked Loop or
PLL&lt;/a&gt;.
If you aren’t familiar with
&lt;a href=&quot;https://en.wikipedia.org/wiki/Phase-locked_loop&quot;&gt;PLL&lt;/a&gt;s, a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Phase-locked_loop&quot;&gt;PLL&lt;/a&gt; is a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Feedback&quot;&gt;closed loop&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Control_system&quot;&gt;control system&lt;/a&gt;
designed to match an incoming
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sine_wave&quot;&gt;sine wave&lt;/a&gt; with a reconstructed
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sine_wave&quot;&gt;sine wave&lt;/a&gt; that tracks both the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Instantaneous_phase&quot;&gt;phase&lt;/a&gt; and (optionally) the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency&quot;&gt;frequency&lt;/a&gt;
of an incoming
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sine_wave&quot;&gt;sine wave&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Phase-locked_loop&quot;&gt;PLL&lt;/a&gt;s are important parts
of many
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_signal_processing&quot;&gt;Digital Signal Processing
(DSP)&lt;/a&gt;
systems, including (but not limited to):&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Recovering the implicit (or explicit) clock from an incoming signal.
Inside digital logic, clock recovery
becomes very important when you are trying to transfer data between two
components.  Even components that have two independent clocks, each supposedly
tuned to “the same” clock
&lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency&quot;&gt;frequency&lt;/a&gt;,
will likely have their clocks wander in
&lt;a href=&quot;https://en.wikipedia.org/wiki/Instantaneous_phase&quot;&gt;phase&lt;/a&gt;
with respect to each other.&lt;/p&gt;

    &lt;p&gt;You may be familiar
with the hard &lt;a href=&quot;https://en.wikipedia.org/wiki/Phase-locked_loop&quot;&gt;PLL&lt;/a&gt;
components on your board which are used to do this exact thing.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;New clock signal generation.  For example, a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Phase-locked_loop&quot;&gt;PLL&lt;/a&gt; can often be used
to create a clock &lt;code class=&quot;highlighter-rouge&quot;&gt;N&lt;/code&gt; times faster or slower than an incoming reference
clock.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;In a commercial &lt;a href=&quot;https://en.wikipedia.org/wiki/FM_broadcasting&quot;&gt;broadcast FM
signal&lt;/a&gt;,
a &lt;a href=&quot;https://en.wikipedia.org/wiki/Phase-locked_loop&quot;&gt;PLL&lt;/a&gt; is often used
to undo the &lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency_modulation&quot;&gt;FM
modulation&lt;/a&gt;.  This may
also include a separate
&lt;a href=&quot;https://en.wikipedia.org/wiki/Phase-locked_loop&quot;&gt;PLL&lt;/a&gt; component used to
lock onto the stereo component of the signal–and even to determine if
it is present.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Amplitude_modulation&quot;&gt;AM demodulation&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Of course, my favorite use for a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Phase-locked_loop&quot;&gt;PLL&lt;/a&gt;
is to lock onto the &lt;a href=&quot;https://en.wikipedia.org/wiki/Baud&quot;&gt;baud rate&lt;/a&gt;
and &lt;a href=&quot;https://en.wikipedia.org/wiki/Carrier_recovery&quot;&gt;carrier phase&lt;/a&gt;
of a &lt;a href=&quot;https://en.wikipedia.org/wiki/Data_transmission&quot;&gt;digital communications
waveform&lt;/a&gt;.
The &lt;a href=&quot;https://en.wikipedia.org/wiki/Baud&quot;&gt;baud&lt;/a&gt;
clock recovery portion of this circuit in the receiver is used to determine
the sampling point (the middle) of any received bits.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;My own first experience with
&lt;a href=&quot;https://en.wikipedia.org/wiki/Phase-locked_loop&quot;&gt;PLL&lt;/a&gt;s came as part of
an “Everything you need to know about
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_signal_processing&quot;&gt;DSP&lt;/a&gt;”
type of course offered at my workplace.  In this course, the instructor
presented two very simple
&lt;a href=&quot;https://en.wikipedia.org/wiki/Phase-locked_loop&quot;&gt;PLL&lt;/a&gt; structures that have
served me well ever since.&lt;/p&gt;

&lt;p&gt;If &lt;a href=&quot;https://www.blueletterbible.org/kjv/jas/4/15&quot;&gt;the Lord permits&lt;/a&gt;, I
may have the opportunity to share some of these same fundamental
&lt;a href=&quot;https://en.wikipedia.org/wiki/Phase-locked_loop&quot;&gt;PLL&lt;/a&gt; structures here
with you here on &lt;a href=&quot;http://zipcpu.com/&quot;&gt;this blog&lt;/a&gt;.  I’ll try
to keep them as simple as I can.  For example, the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Phase-locked_loop&quot;&gt;PLL&lt;/a&gt;
I’ll present below has only about 84 lines of logic to its implementation.
Sound simple enough?&lt;/p&gt;

&lt;p&gt;Since that first class, though, I decided that I didn’t know enough about this
black art, and that I wanted to learn more about
&lt;a href=&quot;https://en.wikipedia.org/wiki/Phase-locked_loop&quot;&gt;PLL&lt;/a&gt;s.  After a bit of
browsing on &lt;a href=&quot;https://www.amazon.com&quot;&gt;Amazon&lt;/a&gt;, I came across
&lt;a href=&quot;https://www.amazon.com/Phaselock-Techniques-Floyd-M-Gardner/dp/0471430633/&quot;&gt;Floyd M. Gardner’s book, &lt;em&gt;Phaselock Techniques&lt;/em&gt;&lt;/a&gt;.
One particular comment in his introductory chapter caught my eye, and I’d
like to repeat it for you here:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Every &lt;a href=&quot;https://en.wikipedia.org/wiki/Phase-locked_loop&quot;&gt;PLL&lt;/a&gt; is
&lt;a href=&quot;https://en.wikipedia.org/wiki/Nonlinear_system&quot;&gt;nonlinear&lt;/a&gt;.
Tools for analysis of
&lt;a href=&quot;https://en.wikipedia.org/wiki/Nonlinear_system&quot;&gt;nonlinear system&lt;/a&gt;s are
exceedingly cumbersome and provide meager benefits compared to the powerful
analytical tools available for
&lt;a href=&quot;https://en.wikipedia.org/wiki/Linear_system&quot;&gt;linear system&lt;/a&gt;s.  Fortunately,
most (but not all) &lt;a href=&quot;https://en.wikipedia.org/wiki/Phase-locked_loop&quot;&gt;PLL&lt;/a&gt;s
of interest can be analyzed by
&lt;a href=&quot;https://en.wikipedia.org/wiki/Linear_system&quot;&gt;linear&lt;/a&gt; techniques
when in their locked condition.  This book argues throughout that
&lt;a href=&quot;https://en.wikipedia.org/wiki/Linear_system&quot;&gt;linear&lt;/a&gt; methods are
sufficient for the bulk of the analysis and initial design of most
&lt;a href=&quot;https://en.wikipedia.org/wiki/Phase-locked_loop&quot;&gt;PLL&lt;/a&gt;s.
Therefore, linear approximations are employed wherever feasible.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;I was instantly sold!  I’ve not regretted this purchase since then, for Mr.
Gardner was true to his word and I have learned much from &lt;a href=&quot;https://www.amazon.com/Phaselock-Techniques-Floyd-M-Gardner/dp/0471430633/&quot;&gt;his
book&lt;/a&gt;.
That said, I’ve never taken any academic classes studying
&lt;a href=&quot;https://en.wikipedia.org/wiki/Phase-locked_loop&quot;&gt;PLL&lt;/a&gt; design or analysis,
so I can’t really comment on whether or not other books are better or worse
than &lt;a href=&quot;https://www.amazon.com/Phaselock-Techniques-Floyd-M-Gardner/dp/0471430633/&quot;&gt;Gardner’s&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;So today let’s talk about how to build a really simple
&lt;a href=&quot;https://en.wikipedia.org/wiki/Phase-locked_loop&quot;&gt;PLL&lt;/a&gt;.  I’m going to call
this a &lt;a href=&quot;https://github.com/ZipCPU/dpll/blob/master/rtl/sdpll.v&quot;&gt;logic PLL&lt;/a&gt;
for the simple reason that it will take as an input a logical
(&lt;a href=&quot;https://en.wikipedia.org/wiki/Boolean_algebra&quot;&gt;boolean&lt;/a&gt;)
clock signal (&lt;code class=&quot;highlighter-rouge&quot;&gt;0&lt;/code&gt; or &lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt;).  Internally, the
&lt;a href=&quot;https://github.com/ZipCPU/dpll/blob/master/rtl/sdpll.v&quot;&gt;logic PLL&lt;/a&gt;
will use only simple &lt;a href=&quot;https://en.wikipedia.org/wiki/Boolean_algebra&quot;&gt;boolean&lt;/a&gt;
logic–there will be no &lt;code class=&quot;highlighter-rouge&quot;&gt;N&lt;/code&gt;-bit samples or even
any &lt;a href=&quot;https://en.wikipedia.org/wiki/Sine_wave&quot;&gt;sine wave&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/cordic&quot;&gt;generation&lt;/a&gt;
within the logic below.  Indeed, you might need to look carefully if you want
to find the multiplies.&lt;/p&gt;

&lt;h2 id=&quot;components-of-a-pll&quot;&gt;Components of a PLL&lt;/h2&gt;

&lt;p&gt;The basic form of a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Phase-locked_loop&quot;&gt;PLL&lt;/a&gt;
is that of a &lt;a href=&quot;https://en.wikipedia.org/wiki/Feedback&quot;&gt;control loop&lt;/a&gt;.  The
input to this loop is a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sine_wave&quot;&gt;sine wave&lt;/a&gt;.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 1. PLL feedback&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/dpll-block-diagram.svg&quot; alt=&quot;Components of a PLL&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Outputs can be taken from any number of locations, depending upon the purpose
of the &lt;a href=&quot;https://en.wikipedia.org/wiki/Phase-locked_loop&quot;&gt;PLL&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The loop begins with an incoming &lt;a href=&quot;https://en.wikipedia.org/wiki/Sine_wave&quot;&gt;sine
wave&lt;/a&gt; that is passed into a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Phase_detector&quot;&gt;phase detector&lt;/a&gt;.
The &lt;a href=&quot;https://en.wikipedia.org/wiki/Phase_detector&quot;&gt;phase detector&lt;/a&gt;
is used to compare the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Instantaneous_phase&quot;&gt;phase&lt;/a&gt;
of the incoming &lt;a href=&quot;https://en.wikipedia.org/wiki/Sine_wave&quot;&gt;sine
wave&lt;/a&gt; against a reconstructed
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sine_wave&quot;&gt;sine wave&lt;/a&gt;
produced internally.  The output of this
&lt;a href=&quot;https://en.wikipedia.org/wiki/Phase_detector&quot;&gt;phase detector&lt;/a&gt;
is an error signal.  This error signal is then optionally filtered, and fed
into two portions of the circuit: one to track
&lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency&quot;&gt;frequency&lt;/a&gt;
and the other to track
&lt;a href=&quot;https://en.wikipedia.org/wiki/Instantaneous_phase&quot;&gt;phase&lt;/a&gt;.
These two portions combine within a
&lt;a href=&quot;/dsp/2017/12/09/nco.html&quot;&gt;Numerically Controlled Oscillator (NCO)&lt;/a&gt;
to create a new
&lt;a href=&quot;https://en.wikipedia.org/wiki/Instantaneous_phase&quot;&gt;phase&lt;/a&gt; for the reconstructed
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sine_wave&quot;&gt;sine wave&lt;/a&gt;.
That &lt;a href=&quot;https://en.wikipedia.org/wiki/Instantaneous_phase&quot;&gt;phase&lt;/a&gt; is then used
as an input to a &lt;a href=&quot;https://en.wikipedia.org/wiki/Sine_wave&quot;&gt;sine wave&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/cordic&quot;&gt;generator&lt;/a&gt; to create a reconstructed
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sine_wave&quot;&gt;sine wave&lt;/a&gt;, which is then used as the
second input to the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Phase_detector&quot;&gt;phase detector&lt;/a&gt;
and the loop repeats.&lt;/p&gt;

&lt;p&gt;The &lt;a href=&quot;https://github.com/ZipCPU/dpll/blob/master/rtl/sdpll.v&quot;&gt;PLL presented
below&lt;/a&gt;
will contain all of these basic components, with the exception that
the incoming &lt;a href=&quot;https://en.wikipedia.org/wiki/Sine_wave&quot;&gt;sine wave&lt;/a&gt; will be
represented by a 1-bit clock signal, and the reconstructed
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sine_wave&quot;&gt;sine wave&lt;/a&gt; will have only a
1-bit amplitude.  Put together, these two changes will allow us to keep the
&lt;a href=&quot;/blog/2017/06/12/minimizing-luts.html&quot;&gt;logic count&lt;/a&gt;
of this “logic &lt;a href=&quot;https://en.wikipedia.org/wiki/Phase-locked_loop&quot;&gt;PLL&lt;/a&gt;”
quite low.  Since low
&lt;a href=&quot;/blog/2017/06/12/minimizing-luts.html&quot;&gt;logic count&lt;/a&gt;
often correlates with high
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
speed, these two changes should allow this
&lt;a href=&quot;https://en.wikipedia.org/wiki/Phase-locked_loop&quot;&gt;PLL&lt;/a&gt;
to run at a high internal speed within an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;a-basic-pll-interface&quot;&gt;A Basic PLL interface&lt;/h2&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 2. PLL interface&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/pll-block-component.svg&quot; alt=&quot;Components of a PLL&quot; width=&quot;360&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;A typical &lt;a href=&quot;https://en.wikipedia.org/wiki/Phase-locked_loop&quot;&gt;PLL&lt;/a&gt;
component might have a component I/O diagram like the one in Fig 2 to the right.
Indeed, today’s &lt;a href=&quot;https://github.com/ZipCPU/dpll/blob/master/rtl/sdpll.v&quot;&gt;logic
PLL&lt;/a&gt;
will implement most of this interface–with the exception of the lock indicator
output.&lt;/p&gt;

&lt;p&gt;The basic signals are:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;An incoming clock signal, &lt;code class=&quot;highlighter-rouge&quot;&gt;i_clk&lt;/code&gt;.  While not shown in Fig 2, today’s logic
is going to be
&lt;a href=&quot;https://en.wikipedia.org/wiki/Synchronous_circuit&quot;&gt;synchronous&lt;/a&gt;,
and hence everything will take place on clock edges.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;A means of setting the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency&quot;&gt;frequency&lt;/a&gt;
of the internal &lt;a href=&quot;/dsp/2017/12/09/nco.html&quot;&gt;NCO&lt;/a&gt;
component.  In this case, any time the &lt;em&gt;load new frequency&lt;/em&gt; flag is true,
we’ll call this &lt;code class=&quot;highlighter-rouge&quot;&gt;i_ld&lt;/code&gt; below, the internal
&lt;a href=&quot;https://en.wikipedia.org/wiki/Instantaneous_phase&quot;&gt;phase&lt;/a&gt;
increment of the
&lt;a href=&quot;/dsp/2017/12/09/nco.html&quot;&gt;NCO&lt;/a&gt;
will be forced to the &lt;em&gt;frequency control&lt;/em&gt; value, &lt;code class=&quot;highlighter-rouge&quot;&gt;i_step&lt;/code&gt;.  While &lt;code class=&quot;highlighter-rouge&quot;&gt;i_ld&lt;/code&gt; is
high, the &lt;a href=&quot;https://github.com/ZipCPU/dpll/blob/master/rtl/sdpll.v&quot;&gt;logic PLL&lt;/a&gt;
will not track any &lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency&quot;&gt;frequency&lt;/a&gt;
changes.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The bandwidth of this control loop will be set via the &lt;em&gt;loop bandwidth
control&lt;/em&gt; input, &lt;code class=&quot;highlighter-rouge&quot;&gt;i_lgcoeff&lt;/code&gt; which I may reference as &lt;code class=&quot;highlighter-rouge&quot;&gt;LGCOEFF&lt;/code&gt; below, so that
the internal loop gain is set to &lt;code class=&quot;highlighter-rouge&quot;&gt;2^(-LGCOEFF)&lt;/code&gt;.  This will control how
fast the loop locks on to an incoming clock signal.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;This leaves the incoming
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sine_wave&quot;&gt;sine wave&lt;/a&gt;,
&lt;code class=&quot;highlighter-rouge&quot;&gt;i_input&lt;/code&gt;.  We’ll assume this is either on
or off, much like any logical clock signal.  We’ll also use the &lt;a href=&quot;/blog/2017/08/14/strategies-for-pipelining.html&quot;&gt;“global CE”
strategy&lt;/a&gt;,
captured by the clock enable (CE) line, referenced below as &lt;code class=&quot;highlighter-rouge&quot;&gt;i_ce&lt;/code&gt;.  Under
this
&lt;a href=&quot;/blog/2017/08/14/strategies-for-pipelining.html&quot;&gt;strategy&lt;/a&gt;,
both &lt;code class=&quot;highlighter-rouge&quot;&gt;i_input&lt;/code&gt; and the outputs &lt;code class=&quot;highlighter-rouge&quot;&gt;o_phase&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;o_err&lt;/code&gt; will need to be valid
any time &lt;code class=&quot;highlighter-rouge&quot;&gt;i_ce&lt;/code&gt; is true, and should only change at that time.&lt;/p&gt;

    &lt;p&gt;From a timing standpoint, we’ll want to be able to handle the case where
&lt;code class=&quot;highlighter-rouge&quot;&gt;i_ce&lt;/code&gt; is held at one, so as to make this a high speed
&lt;a href=&quot;https://en.wikipedia.org/wiki/Phase-locked_loop&quot;&gt;PLL&lt;/a&gt;
implementation.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;There are two basic outputs of
&lt;a href=&quot;https://github.com/ZipCPU/dpll/blob/master/rtl/sdpll.v&quot;&gt;this PLL&lt;/a&gt;:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;The error signal coming out of the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Phase_detector&quot;&gt;phase detector&lt;/a&gt;.&lt;/p&gt;

    &lt;p&gt;Changes in this
&lt;a href=&quot;https://en.wikipedia.org/wiki/Instantaneous_phase&quot;&gt;phase&lt;/a&gt;
error signal, since they will be proportional to
&lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency&quot;&gt;frequency&lt;/a&gt;, are often used within an
&lt;a href=&quot;https://en.wikipedia.org/wiki/FM_broadcasting&quot;&gt;FM&lt;/a&gt; demodulator.&lt;/p&gt;

    &lt;p&gt;You could also use this error signal to create a locked indication if you
wanted.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;We’ll also produce the basic
&lt;a href=&quot;https://en.wikipedia.org/wiki/Instantaneous_phase&quot;&gt;phase&lt;/a&gt;
of the internal oscillator, &lt;code class=&quot;highlighter-rouge&quot;&gt;o_phase&lt;/code&gt;.
This signal is the same as the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Instantaneous_phase&quot;&gt;phase&lt;/a&gt;
counter we used in our
&lt;a href=&quot;/dsp/2017/12/09/nco.html&quot;&gt;NCO&lt;/a&gt; discussion.&lt;/p&gt;

    &lt;p&gt;Because this
&lt;a href=&quot;https://en.wikipedia.org/wiki/Instantaneous_phase&quot;&gt;phase&lt;/a&gt;
tracks the incoming signal, it can also be used as an indication of when
to sample an incoming data bit.&lt;/p&gt;

    &lt;p&gt;Further, since we’ll be matching the most-significant bit of this
&lt;a href=&quot;https://en.wikipedia.org/wiki/Instantaneous_phase&quot;&gt;phase&lt;/a&gt;
value to the incoming clock signal, this also creates a stable clock output.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Put together, you can see the prototype for our
&lt;a href=&quot;https://github.com/ZipCPU/dpll/blob/master/rtl/sdpll.v&quot;&gt;logic PLL&lt;/a&gt;
written out in Verilog below.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;module	sdpll(i_clk, i_ld, i_step, i_ce, i_input, i_lgcoeff, o_phase, o_err);
	parameter		PHASE_BITS = 32;
	parameter	[0:0]	OPT_TRACK_FREQUENCY = 1&#39;b1;
	localparam		MSB=PHASE_BITS-1;
	//
	input	wire	i_clk;
	//
	input	wire			i_ld;
	input	wire	[(MSB-1):0]	i_step;
	//
	input	wire			i_ce;
	input	wire			i_input;
	input	wire	[4:0]		i_lgcoeff;
	output	wire	[PHASE_BITS-1:0] o_phase;
	output	reg	[1:0]		o_err;
	//&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;One item to note is that 
&lt;a href=&quot;https://github.com/ZipCPU/dpll/blob/master/rtl/sdpll.v&quot;&gt;this PLL&lt;/a&gt; design can
be set to optionally track
&lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency&quot;&gt;frequency&lt;/a&gt;, as well as
&lt;a href=&quot;https://en.wikipedia.org/wiki/Instantaneous_phase&quot;&gt;phase&lt;/a&gt;,
by just setting the &lt;code class=&quot;highlighter-rouge&quot;&gt;OPT_TRACK_FREQUENCY&lt;/code&gt; flag above.&lt;/p&gt;

&lt;p&gt;As discussed above, the goal of
&lt;a href=&quot;https://github.com/ZipCPU/dpll/blob/master/rtl/sdpll.v&quot;&gt;this PLL&lt;/a&gt;
is to track the incoming signal, &lt;code class=&quot;highlighter-rouge&quot;&gt;i_input&lt;/code&gt;, and to produce a reconstructed clock
signal.  This reconstructed clock signal will be captured by the most
significant bit of the output, &lt;code class=&quot;highlighter-rouge&quot;&gt;o_phase&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Further, while we are not creating a &lt;em&gt;lock&lt;/em&gt; signal today, we could easily
create one later by using the &lt;code class=&quot;highlighter-rouge&quot;&gt;o_err&lt;/code&gt; signal if we wanted to.  Indeed, such
a &lt;em&gt;lock&lt;/em&gt; signal isn’t really all that hard to create: just pass the
&lt;code class=&quot;highlighter-rouge&quot;&gt;(o_err == 2&#39;b00)&lt;/code&gt; signal into a &lt;a href=&quot;/dsp/2017-08-19-simple-filter.html&quot;&gt;recursive
average&lt;/a&gt;.
Once the output of such a &lt;a href=&quot;/dsp/2017-08-19-simple-filter.html&quot;&gt;recursive
average&lt;/a&gt;
falls below a threshold, the loop may be assumed to be &lt;em&gt;locked&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;These, though, are the basic components of any
&lt;a href=&quot;https://en.wikipedia.org/wiki/Phase-locked_loop&quot;&gt;PLL&lt;/a&gt;, and specifically the
components we will implement as part of &lt;a href=&quot;https://github.com/ZipCPU/dpll/blob/master/rtl/sdpll.v&quot;&gt;our
module&lt;/a&gt; today.&lt;/p&gt;

&lt;h2 id=&quot;the-logic-based-nco&quot;&gt;The Logic Based NCO&lt;/h2&gt;

&lt;p&gt;We discussed &lt;a href=&quot;/dsp/2017/12/09/nco.html&quot;&gt;how to build an
NCO&lt;/a&gt; in an
&lt;a href=&quot;/dsp/2017/12/09/nco.html&quot;&gt;earlier article&lt;/a&gt;.
Today, we are going to use nearly the same logic to create a clock signal,
and we’ll then approximate the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sine_wave&quot;&gt;sine wave&lt;/a&gt;
generator with the most significant bit of the
&lt;a href=&quot;/dsp/2017/12/09/nco.html&quot;&gt;NCO&lt;/a&gt;’s
&lt;a href=&quot;https://en.wikipedia.org/wiki/Instantaneous_phase&quot;&gt;phase&lt;/a&gt;
accumulator.&lt;/p&gt;

&lt;p&gt;This is also the same logic used by the &lt;em&gt;fractional counter&lt;/em&gt; timing approach
&lt;a href=&quot;/blog/2017/06/02/generating-timing.html&quot;&gt;we discussed
earlier&lt;/a&gt;.
As you may recall from
&lt;a href=&quot;/blog/2017/06/02/generating-timing.html&quot;&gt;that discussion&lt;/a&gt;,
a clock of an arbitrary
&lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency&quot;&gt;frequency&lt;/a&gt;
may be generated by just examining the most significant bit of a counter.&lt;/p&gt;

&lt;p&gt;That means we’ll be starting with logic that looks like the following.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	initial	ctr = 0;
	always @(posedge i_clk)
		if (i_ce)
			ctr &amp;lt;= ctr + r_step;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;In this case, the &lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency&quot;&gt;frequency&lt;/a&gt; of the
clock generated by this counter will be given by the product of the counter’s
&lt;a href=&quot;/dsp/2017/12/09/nco.html&quot;&gt;phase step&lt;/a&gt; (divided by
&lt;code class=&quot;highlighter-rouge&quot;&gt;2^(PHASE_BITS)&lt;/code&gt;) times the overall clock rate.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/dpll-frequency-step.png&quot; alt=&quot;f = r_step * f_clk / 2^(PHASE_BITS)&quot; width=&quot;228&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Feel free to reference the
&lt;a href=&quot;/dsp/2017/12/09/nco.html&quot;&gt;NCO&lt;/a&gt; article if any of this
doesn’t look familiar to you here.&lt;/p&gt;

&lt;p&gt;Setting the &lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency&quot;&gt;frequency&lt;/a&gt; of this
&lt;a href=&quot;/dsp/2017/12/09/nco.html&quot;&gt;phase accumulator&lt;/a&gt;
(really a &lt;em&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Instantaneous_phase&quot;&gt;phase&lt;/a&gt;
step&lt;/em&gt;) is as simple as setting the &lt;code class=&quot;highlighter-rouge&quot;&gt;r_step&lt;/code&gt; value any time the user
wishes to adjust the &lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency&quot;&gt;frequency&lt;/a&gt;
of the basic &lt;a href=&quot;/dsp/2017/12/09/nco.html&quot;&gt;NCO&lt;/a&gt;,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(posedge i_clk)
		if (i_ld)
			r_step &amp;lt;= { 1&#39;b0, i_step };&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This is just our starting point, however, as both of these blocks will need
some adjustment if we wish to track the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Instantaneous_phase&quot;&gt;phase&lt;/a&gt; and (optionally) the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency&quot;&gt;frequency&lt;/a&gt;
of an incoming &lt;a href=&quot;https://en.wikipedia.org/wiki/Sine_wave&quot;&gt;sine wave&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;As we work through the logic of
&lt;a href=&quot;https://github.com/ZipCPU/dpll/blob/master/rtl/sdpll.v&quot;&gt;this&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Phase-locked_loop&quot;&gt;PLL&lt;/a&gt;,
you’ll find this
&lt;a href=&quot;https://en.wikipedia.org/wiki/Instantaneous_phase&quot;&gt;phase&lt;/a&gt;
&lt;a href=&quot;/dsp/2017/12/09/nco.html&quot;&gt;accumulator&lt;/a&gt; value,
&lt;code class=&quot;highlighter-rouge&quot;&gt;ctr&lt;/code&gt;, comes back again and again.&lt;/p&gt;

&lt;h2 id=&quot;a-logic-phase-detector&quot;&gt;A Logic Phase Detector&lt;/h2&gt;

&lt;p&gt;The goal of the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Phase_detector&quot;&gt;phase detector&lt;/a&gt;
is to create a signal that is proportional to how far the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Phase-locked_loop&quot;&gt;PLL&lt;/a&gt;
needs to be made faster or slowed down.  Traditionally, a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Phase_detector&quot;&gt;phase detector&lt;/a&gt;
is created by taking a product of the input
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sine_wave&quot;&gt;(co)sine wave&lt;/a&gt;
with a reconstructed
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sine_wave&quot;&gt;sine wave&lt;/a&gt;
separated by ninety degrees.  The resulting
&lt;a href=&quot;https://en.wikipedia.org/wiki/Instantaneous_phase&quot;&gt;phase&lt;/a&gt;
error signal is then proportional to how far the
&lt;a href=&quot;/dsp/2017/12/09/nco.html&quot;&gt;phase accumulator&lt;/a&gt;
is from the incoming signal.&lt;/p&gt;

&lt;p&gt;This is not going to be our chosen approach today.  Instead, we’ll use an
&lt;em&gt;ad-hoc&lt;/em&gt; approach–one that generates a two-bit
&lt;a href=&quot;https://en.wikipedia.org/wiki/Instantaneous_phase&quot;&gt;phase&lt;/a&gt;
error signal indicating not
only the presence of an error but also the direction the internal counter
needs to be adjusted.  This will not be proportional, since we are only going to
capture a two bit
&lt;a href=&quot;https://en.wikipedia.org/wiki/Instantaneous_phase&quot;&gt;phase&lt;/a&gt;
error signal, but rather somewhat
nonlinear–perfect, though, for
a &lt;a href=&quot;https://en.wikipedia.org/wiki/Boolean_algebra&quot;&gt;boolean&lt;/a&gt;
logic implementation.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: left&quot;&gt;&lt;caption&gt;Fig 3. The regenerated clock leads the input&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/dpll-lead.svg&quot; alt=&quot;The regenerated clock leads the incoming clock&quot; width=&quot;360&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Let’s consider how this
&lt;a href=&quot;https://en.wikipedia.org/wiki/Phase_detector&quot;&gt;phase detector&lt;/a&gt;
needs to work.  If the regenerated
clock changes before the incoming clock, as shown in Fig 3, then we’ll say
that this regenerated clock &lt;em&gt;leads&lt;/em&gt; the input.  Such a &lt;em&gt;leading&lt;/em&gt; situation
will create a negative
&lt;a href=&quot;https://en.wikipedia.org/wiki/Instantaneous_phase&quot;&gt;phase&lt;/a&gt; error,
indicating that we will want to slow down
&lt;a href=&quot;https://github.com/ZipCPU/dpll/blob/master/rtl/sdpll.v&quot;&gt;our PLL&lt;/a&gt;.
Further, any time the two signals, both the incoming clock and the
regenerated one, are identical we’ll design our
&lt;a href=&quot;https://en.wikipedia.org/wiki/Phase_detector&quot;&gt;phase detector&lt;/a&gt;
to indicate zero
&lt;a href=&quot;https://en.wikipedia.org/wiki/Instantaneous_phase&quot;&gt;phase&lt;/a&gt; error.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 4. The regenerated clock lags (doesn&#39;t lead) the input&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/dpll-lag.svg&quot; alt=&quot;The regenerated clock lags behind the incoming clock&quot; width=&quot;360&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;On the other hand, if the regenerated clock changes &lt;em&gt;after&lt;/em&gt; the incoming clock,
such as is shown in Fig 4, then our reconstructed clock isn’t transitioning
fast enough.  We’ll say in this case that the regenerated clock &lt;em&gt;lags&lt;/em&gt; the
input.  To correct this, we’ll want to speed up our internal clock to “catch
up” to the incoming clock, hence we want to create a &lt;em&gt;positive&lt;/em&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Instantaneous_phase&quot;&gt;phase&lt;/a&gt; error in this case.
As before, though, any time the two signals agree we’ll want to keep the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Instantaneous_phase&quot;&gt;phase&lt;/a&gt; error at zero.&lt;/p&gt;

&lt;p&gt;But how shall we tell whether we are leading or lagging?&lt;/p&gt;

&lt;p&gt;We’ll start by keeping track of the input sign from the last time the input
and reconstructed signal agree.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	initial	agreed_output = 0;
	always @(posedge i_clk)
	if (i_ce)
	begin
		if ((i_input)&amp;amp;&amp;amp;(ctr[MSB]))
			agreed_output &amp;lt;= 1&#39;b1;
		else if ((!i_input)&amp;amp;&amp;amp;(!ctr[MSB]))
			agreed_output &amp;lt;= 1&#39;b0;
	end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Whether or not we are &lt;em&gt;leading&lt;/em&gt; the incoming clock, can then be determined
with respsct to this last agreed upon output.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(*)
		if (agreed_output)
			// We were last high.  Lead is true now
			// if the counter goes low before the input
			lead = (!ctr[MSB])&amp;amp;&amp;amp;(i_input);
		else
			// The last time we agreed, both the counter
			// and the input were low.   This will be
			// true if the counter goes high before the input
			lead = (ctr[MSB])&amp;amp;&amp;amp;(!i_input);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Since the above logic didn’t capture whether or not the current regenerated
bit, &lt;code class=&quot;highlighter-rouge&quot;&gt;ctr[MSB]&lt;/code&gt; matched the &lt;code class=&quot;highlighter-rouge&quot;&gt;i_input&lt;/code&gt;, we’ll capture that in an internal
&lt;code class=&quot;highlighter-rouge&quot;&gt;phase_err&lt;/code&gt; exists signal.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	// Any disagreement between the high order counter bit and the input
	// is a phase error that we will need to correct
	assign	phase_err = (ctr[MSB] != i_input);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;We can put these two values together, &lt;code class=&quot;highlighter-rouge&quot;&gt;phase_err&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;lead&lt;/code&gt;, to create a
2-bit output error value, representing either &lt;code class=&quot;highlighter-rouge&quot;&gt;-1&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;0&lt;/code&gt;, or &lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	initial	o_err = 2&#39;h0;
	always @(posedge i_clk)
	if (i_ce)
		o_err &amp;lt;= (!phase_err) ? 2&#39;b00 : ((lead) ? 2&#39;b11 : 2&#39;b01);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;We won’t actually use this value internally, but rather the &lt;code class=&quot;highlighter-rouge&quot;&gt;phase_err&lt;/code&gt; and
&lt;code class=&quot;highlighter-rouge&quot;&gt;lead&lt;/code&gt; signals.  However, the &lt;code class=&quot;highlighter-rouge&quot;&gt;o_err&lt;/code&gt; signal should make it easier to understand
the &lt;code class=&quot;highlighter-rouge&quot;&gt;phase_err&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;lead&lt;/code&gt; signals.&lt;/p&gt;

&lt;h2 id=&quot;a-logic-pll-type-1&quot;&gt;A Logic PLL: Type 1&lt;/h2&gt;

&lt;p&gt;A “Type 1”
&lt;a href=&quot;https://en.wikipedia.org/wiki/Phase-locked_loop&quot;&gt;PLL&lt;/a&gt;
is one that tracks &lt;a href=&quot;https://en.wikipedia.org/wiki/Instantaneous_phase&quot;&gt;phase&lt;/a&gt;,
but not &lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency&quot;&gt;frequency&lt;/a&gt;.  This portion of a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Phase-locked_loop&quot;&gt;PLL&lt;/a&gt;
accepts as an input the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Instantaneous_phase&quot;&gt;phase&lt;/a&gt;
error, (optionally) &lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filters&lt;/a&gt;
it, and then corrects the internal
&lt;a href=&quot;/dsp/2017/12/09/nco.html&quot;&gt;phase accumulator&lt;/a&gt;,
&lt;code class=&quot;highlighter-rouge&quot;&gt;ctr&lt;/code&gt;, based upon the result.  In general, this involves applying some sort
of linear operator to the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Instantaneous_phase&quot;&gt;phase&lt;/a&gt;
error signal, and then adding the result of that operator to the
&lt;a href=&quot;/dsp/2017/12/09/nco.html&quot;&gt;phase accumulator&lt;/a&gt;.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 5. The type-1 open loop transform&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/pll-type-1-open-loop.svg&quot; alt=&quot;The open loop transform function of a type-1 system&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Today’s
&lt;a href=&quot;https://github.com/ZipCPU/dpll/blob/master/rtl/sdpll.v&quot;&gt;logic PLL&lt;/a&gt;
is no different.  In this case, though, we’ll skip the optional
&lt;a href=&quot;https://en.wikipedia.org/wiki/Low-pass_filter&quot;&gt;lowpass filter&lt;/a&gt;
and just multiply our incoming
&lt;a href=&quot;https://en.wikipedia.org/wiki/Instantaneous_phase&quot;&gt;phase&lt;/a&gt;
error by a constant before adding it to our
&lt;a href=&quot;/dsp/2017/12/09/nco.html&quot;&gt;phase accumulator&lt;/a&gt;.
Even better, because the incoming error was either -1, 0, or 1, no real
multiplication is required–we can use a nested &lt;code class=&quot;highlighter-rouge&quot;&gt;if&lt;/code&gt; instead.&lt;/p&gt;

&lt;p&gt;As for the constant, what constant shall we use?  As we suggested above, we’ll
use the absolutely simplest constant we can pick: &lt;code class=&quot;highlighter-rouge&quot;&gt;2^(-LGCOEFF)&lt;/code&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	initial	phase_correction = 0;
	always @(posedge i_clk)
		phase_correction &amp;lt;= {1&#39;b1,{(MSB){1&#39;b0}}} &amp;gt;&amp;gt; i_lgcoeff;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;We’ll show some charts later on illustrating how this coefficient changes
things.  In general, the larger &lt;code class=&quot;highlighter-rouge&quot;&gt;2^(-LGCOEFF)&lt;/code&gt; is,
the faster the loop will track any changes.  At the same time, larger values of
&lt;code class=&quot;highlighter-rouge&quot;&gt;2^(-LGCOEFF)&lt;/code&gt; will also cause the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Phase-locked_loop&quot;&gt;PLL&lt;/a&gt;
to pass any jitters in the incoming clock directly into the reconstructed
signal.&lt;/p&gt;

&lt;p&gt;Now with this information, we can adjust our
&lt;a href=&quot;https://en.wikipedia.org/wiki/Instantaneous_phase&quot;&gt;phase&lt;/a&gt;
value, &lt;code class=&quot;highlighter-rouge&quot;&gt;ctr&lt;/code&gt;, using what we now know.&lt;/p&gt;

&lt;p&gt;First, if there is no
&lt;a href=&quot;https://en.wikipedia.org/wiki/Instantaneous_phase&quot;&gt;phase&lt;/a&gt;
error, then all we need to do is to continue to step our
&lt;a href=&quot;https://en.wikipedia.org/wiki/Instantaneous_phase&quot;&gt;phase&lt;/a&gt;
forward at the &lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency&quot;&gt;frequency&lt;/a&gt; rate
&lt;a href=&quot;/dsp/2017/12/09/nco.html&quot;&gt;set by &lt;code class=&quot;highlighter-rouge&quot;&gt;r_step&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	initial	ctr = 0;
	always @(posedge i_clk)
		if (i_ce)
		begin
			// ...
			if (!phase_err)
				ctr &amp;lt;= ctr + r_step;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Otherwise, if &lt;code class=&quot;highlighter-rouge&quot;&gt;phase_err != 0&lt;/code&gt;, then the incoming and regenerated clocks didn’t
match.  In this case we’ll need to bump our counter a little more forward than
just a normal
&lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency&quot;&gt;frequency&lt;/a&gt;
step, or slow it down by a little less than the normal
&lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency&quot;&gt;frequency&lt;/a&gt;
step.  The difference between these two is going to be
based upon whether or not the &lt;code class=&quot;highlighter-rouge&quot;&gt;lead&lt;/code&gt; flag is true–as we discussed above.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;			else if (lead)
				ctr &amp;lt;= ctr + r_step - phase_correction;
			// ...
			else
				ctr &amp;lt;= ctr + r_step + phase_correction;
		end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;As a final step, we’ll place this counter on the output for examination
and/or re-use as desired.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	assign	o_phase = ctr;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;That’s all there is to the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Instantaneous_phase&quot;&gt;phase&lt;/a&gt;
correction step!  There’s no more black magic to it than the logic above.
Indeed, if you wanted to we could stop here and have a fully functional
&lt;a href=&quot;https://en.wikipedia.org/wiki/Phase-locked_loop&quot;&gt;PLL&lt;/a&gt;.
If the &lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency&quot;&gt;frequency&lt;/a&gt;
step, &lt;code class=&quot;highlighter-rouge&quot;&gt;r_step&lt;/code&gt;,
of that &lt;a href=&quot;https://en.wikipedia.org/wiki/Phase-locked_loop&quot;&gt;PLL&lt;/a&gt;
was close enough to the right value, then nothing more would need to be
done–this &lt;a href=&quot;https://en.wikipedia.org/wiki/Phase-locked_loop&quot;&gt;PLL&lt;/a&gt; would track
the &lt;a href=&quot;https://en.wikipedia.org/wiki/Instantaneous_phase&quot;&gt;phase&lt;/a&gt;
an incoming 1-bit clock signal.&lt;/p&gt;

&lt;p&gt;On the other hand, if you need (or want) to discover what
&lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency&quot;&gt;frequency&lt;/a&gt;
&lt;a href=&quot;/dsp/2017/12/09/nco.html&quot;&gt;step&lt;/a&gt;
to use (within reason, from a good initial guess), then you’ll want to add the
type-2 &lt;a href=&quot;https://en.wikipedia.org/wiki/Phase-locked_loop&quot;&gt;PLL&lt;/a&gt;
logic in the next section to the logic we just discussed above.&lt;/p&gt;

&lt;h2 id=&quot;a-logic-pll-type-2&quot;&gt;A Logic PLL: Type 2&lt;/h2&gt;

&lt;p&gt;In many cases when using a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Phase-locked_loop&quot;&gt;PLL&lt;/a&gt;,
you will want to track both the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency&quot;&gt;frequency&lt;/a&gt;
of the incoming signal as well as its
&lt;a href=&quot;https://en.wikipedia.org/wiki/Instantaneous_phase&quot;&gt;phase&lt;/a&gt;.
As we discussed in our
&lt;a href=&quot;/dsp/2017/12/09/nco.html&quot;&gt;NCO&lt;/a&gt;
article,
&lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency&quot;&gt;frequency&lt;/a&gt;
is represented as a regular change of
&lt;a href=&quot;https://en.wikipedia.org/wiki/Instantaneous_phase&quot;&gt;phase&lt;/a&gt;.
You may have noticed how we kept track of this above in &lt;code class=&quot;highlighter-rouge&quot;&gt;r_step&lt;/code&gt;.  If you want
to track
&lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency&quot;&gt;frequency&lt;/a&gt;
as well as
&lt;a href=&quot;https://en.wikipedia.org/wiki/Instantaneous_phase&quot;&gt;phase&lt;/a&gt;,
then you’ll want to adjust this &lt;code class=&quot;highlighter-rouge&quot;&gt;r_step&lt;/code&gt; value based upon the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Instantaneous_phase&quot;&gt;phase&lt;/a&gt;
error as well.  Such a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Phase-locked_loop&quot;&gt;PLL&lt;/a&gt;
that tracks
&lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency&quot;&gt;frequency&lt;/a&gt;
as well as
&lt;a href=&quot;https://en.wikipedia.org/wiki/Instantaneous_phase&quot;&gt;phase&lt;/a&gt;
is called a type-2
&lt;a href=&quot;https://en.wikipedia.org/wiki/Phase-locked_loop&quot;&gt;PLL&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The basic means of extending the type-1
&lt;a href=&quot;https://en.wikipedia.org/wiki/Phase-locked_loop&quot;&gt;PLL&lt;/a&gt;
into a type-2
&lt;a href=&quot;https://en.wikipedia.org/wiki/Phase-locked_loop&quot;&gt;PLL&lt;/a&gt;
is to multiply the
(optionally) &lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filtered&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Instantaneous_phase&quot;&gt;phase&lt;/a&gt;
error by a constant and then adjust the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Instantaneous_phase&quot;&gt;phase&lt;/a&gt;
step due to &lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency&quot;&gt;frequency&lt;/a&gt;, i.e.
the &lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency&quot;&gt;frequency&lt;/a&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;r_step&lt;/code&gt;, by that amount.  This basic logic is shown below in addition
to the type-1 logic we developed above.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 6. The additional type-2 frequency tracking logic&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/pll-type-2-open-loop.svg&quot; alt=&quot;&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Up until this point, there hasn’t been much black magic.  We’ve just pushed
a counter forward or backwards by some nominal amount based upon the sign of
a measured &lt;a href=&quot;https://en.wikipedia.org/wiki/Instantaneous_phase&quot;&gt;phase&lt;/a&gt;
error.  Here, though, I’m going to introduce the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency&quot;&gt;frequency&lt;/a&gt;
adjustment coefficient, &lt;code class=&quot;highlighter-rouge&quot;&gt;1/4 2^(-2LGCOEFF)&lt;/code&gt;, that I’m not going to derive
today.  This particular coefficient is designed to make sure this
&lt;a href=&quot;https://en.wikipedia.org/wiki/Phase-locked_loop&quot;&gt;PLL&lt;/a&gt;
is &lt;a href=&quot;https://en.wikipedia.org/wiki/Damping_ratio&quot;&gt;critically damped&lt;/a&gt;.
Practically, this just means that this
&lt;a href=&quot;https://en.wikipedia.org/wiki/Phase-locked_loop&quot;&gt;PLL&lt;/a&gt;
will converge faster than any other
&lt;a href=&quot;https://en.wikipedia.org/wiki/Phase-locked_loop&quot;&gt;PLL&lt;/a&gt;
having a &lt;a href=&quot;https://en.wikipedia.org/wiki/Instantaneous_phase&quot;&gt;phase&lt;/a&gt;
correction coefficient of &lt;code class=&quot;highlighter-rouge&quot;&gt;2^(-LGCOEFF)&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;That’s a good thing.&lt;/p&gt;

&lt;p&gt;Hence, our &lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency&quot;&gt;frequency&lt;/a&gt;
correction constant is given by,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	initial	freq_correction = 0;
	always @(posedge i_clk)
		freq_correction &amp;lt;= { 3&#39;b001, {(MSB-2){1&#39;b0}} } &amp;gt;&amp;gt; (2*i_lgcoeff);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;So, how shall we update our step?  First, we’ll allow this number to be
loaded–so that you can set what
&lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency&quot;&gt;frequency&lt;/a&gt;
you expect
&lt;a href=&quot;https://github.com/ZipCPU/dpll/blob/master/rtl/sdpll.v&quot;&gt;this PLL&lt;/a&gt;
to converge around.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(posedge i_clk)
		if (i_ld)
			r_step &amp;lt;= { 1&#39;b0, i_step };&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Likewise, we’ll use the parameter,
&lt;code class=&quot;highlighter-rouge&quot;&gt;OPT_TRACK_FREQUENCY&lt;/code&gt;, to control whether or not
&lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency&quot;&gt;frequency&lt;/a&gt;
tracking is enabled.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;		else if ((OPT_TRACK_FREQUENCY)&amp;amp;&amp;amp;(phase_err))
		begin&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Beyond that, any time we need to slow down, we’ll subtract this
&lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency&quot;&gt;frequency&lt;/a&gt;
correction value and any time we need to speed up we’ll add this
&lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency&quot;&gt;frequency&lt;/a&gt;
correction value.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;			if (lead)
				r_step &amp;lt;= r_step - freq_correction;
			else
				r_step &amp;lt;= r_step + freq_correction;
		end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;You can find all of this code in the
&lt;a href=&quot;https://github.com/ZipCPU/dpll/blob/master/rtl/sdpll.v&quot;&gt;sdpll.v&lt;/a&gt;
file within my new repository holding demonstration
&lt;a href=&quot;https://en.wikipedia.org/wiki/Phase-locked_loop&quot;&gt;PLL&lt;/a&gt;
implementations.&lt;/p&gt;

&lt;h2 id=&quot;performance&quot;&gt;Performance&lt;/h2&gt;

&lt;p&gt;Shall we see how well
&lt;a href=&quot;https://github.com/ZipCPU/dpll/blob/master/rtl/sdpll.v&quot;&gt;this PLL&lt;/a&gt;
performs?&lt;/p&gt;

&lt;p&gt;You can find a
&lt;a href=&quot;https://veripool.org/wiki/verilator&quot;&gt;Verilator&lt;/a&gt;
based
&lt;a href=&quot;/blog/2017/06/21/looking-at-verilator.html&quot;&gt;test bench&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/dpll/blob/master/bench/cpp/sdpll_tb.cpp&quot;&gt;here, called sdpll_tb.cpp&lt;/a&gt;.
This &lt;a href=&quot;https://github.com/ZipCPU/dpll/blob/master/bench/cpp/sdpll_tb.cpp&quot;&gt;test bench
code&lt;/a&gt;
primarily
works by starting with a set of initial conditions and then running the
&lt;a href=&quot;https://github.com/ZipCPU/dpll/blob/master/rtl/sdpll.v&quot;&gt;PLL&lt;/a&gt;
to see what happens.  Unlike most of my test benches, there’s no &lt;code class=&quot;highlighter-rouge&quot;&gt;SUCCESS&lt;/code&gt;
output at the end of
&lt;a href=&quot;https://github.com/ZipCPU/dpll/blob/master/bench/cpp/sdpll_tb.cpp&quot;&gt;this test bench&lt;/a&gt;
to indicate that it &lt;em&gt;worked&lt;/em&gt;.  Instead, the
&lt;a href=&quot;https://github.com/ZipCPU/dpll/blob/master/bench/cpp/sdpll_tb.cpp&quot;&gt;test bench&lt;/a&gt;
will print &lt;code class=&quot;highlighter-rouge&quot;&gt;Simulation complete&lt;/code&gt; to indicate that it
to completion–you’ll still need to check the results produced by &lt;a href=&quot;https://github.com/ZipCPU/dpll/blob/master/bench/cpp/sdpll_tb.cpp&quot;&gt;the
simulation&lt;/a&gt;
to know if it worked.&lt;/p&gt;

&lt;p&gt;For our purpose today, I’ve chosen to use a random
&lt;a href=&quot;https://en.wikipedia.org/wiki/Instantaneous_phase&quot;&gt;phase&lt;/a&gt;.
for our initial condition, together with a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency&quot;&gt;frequency&lt;/a&gt;
that’s about five system clocks per input clock.  Where the
test setup gets interesting is the fact that we’ll start by loading the
&lt;a href=&quot;https://github.com/ZipCPU/dpll/blob/master/rtl/sdpll.v&quot;&gt;PLL&lt;/a&gt;
with a &lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency&quot;&gt;frequency&lt;/a&gt;
that’s too fast by about 12%.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;	&lt;span class=&quot;n&quot;&gt;tb&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i_lgcoeff&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;6&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;lclphase&lt;/span&gt;     &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rand&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;lclstep&lt;/span&gt;      &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x31415928&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;tb&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i_step&lt;/span&gt;    &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lclstep&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lclstep&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Too fast
&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;tb&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i_ld&lt;/span&gt;      &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;tb&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i_clk&lt;/span&gt;     &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;tb&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i_ce&lt;/span&gt;      &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Then, within the
&lt;a href=&quot;https://veripool.org/wiki/verilator&quot;&gt;Verilator&lt;/a&gt;
per-clock loop,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;	&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;65536&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;32&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;tb&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;eval&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;tfp&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dump&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;8&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;tb&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i_clk&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;tb&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;eval&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;tfp&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dump&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;tb&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i_clk&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;tb&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;eval&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;tfp&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dump&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;15&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;we’ll record several performance numbers.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;		&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
			&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;od&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;6&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;od&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lclphase&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;od&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tb&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v__DOT__r_step&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;od&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tb&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i_input&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;od&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tb&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;o_err&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
			&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;od&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
				&lt;span class=&quot;n&quot;&gt;od&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;od&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tb&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v__DOT__ctr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;od&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tb&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v__DOT__ctr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lclphase&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;od&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;6&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tb&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;o_dbg&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;32&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;od&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;6&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;32&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

			&lt;span class=&quot;n&quot;&gt;fwrite&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;od&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;7&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;intfp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;These are …&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;The local simulation
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sine_wave&quot;&gt;sine wave&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Instantaneous_phase&quot;&gt;phase&lt;/a&gt;
that’s driving &lt;a href=&quot;https://github.com/ZipCPU/dpll/blob/master/bench/cpp/sdpll_tb.cpp&quot;&gt;the
test&lt;/a&gt;,
&lt;code class=&quot;highlighter-rouge&quot;&gt;lclphase&lt;/code&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The &lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency&quot;&gt;frequency&lt;/a&gt;
step from within the
&lt;a href=&quot;https://github.com/ZipCPU/dpll/blob/master/rtl/sdpll.v&quot;&gt;the PLL&lt;/a&gt;,
&lt;code class=&quot;highlighter-rouge&quot;&gt;r_step&lt;/code&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The incoming input signal to
&lt;a href=&quot;https://github.com/ZipCPU/dpll/blob/master/rtl/sdpll.v&quot;&gt;the PLL&lt;/a&gt;,
&lt;code class=&quot;highlighter-rouge&quot;&gt;i_input&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The error signal, &lt;code class=&quot;highlighter-rouge&quot;&gt;o_err&lt;/code&gt;, created by
&lt;a href=&quot;https://github.com/ZipCPU/dpll/blob/master/rtl/sdpll.v&quot;&gt;the PLL&lt;/a&gt;,
and interpreted here as a signed value&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The internal
&lt;a href=&quot;https://github.com/ZipCPU/dpll/blob/master/rtl/sdpll.v&quot;&gt;PLL&lt;/a&gt;
counter, &lt;code class=&quot;highlighter-rouge&quot;&gt;ctr&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The difference between the internal
&lt;a href=&quot;https://github.com/ZipCPU/dpll/blob/master/rtl/sdpll.v&quot;&gt;PLL&lt;/a&gt;
counter, &lt;code class=&quot;highlighter-rouge&quot;&gt;ctr&lt;/code&gt; and the
&lt;a href=&quot;https://github.com/ZipCPU/dpll/blob/master/bench/cpp/sdpll_tb.cpp&quot;&gt;simulation&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Instantaneous_phase&quot;&gt;phase&lt;/a&gt;,
&lt;code class=&quot;highlighter-rouge&quot;&gt;lclphase&lt;/code&gt;, truncated to the number of
&lt;a href=&quot;https://en.wikipedia.org/wiki/Instantaneous_phase&quot;&gt;phase&lt;/a&gt;
error bits (32)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Finally, a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filtered&lt;/a&gt;
error output signal, &lt;code class=&quot;highlighter-rouge&quot;&gt;o_dbg&lt;/code&gt;.  This signal isn’t really part of our
&lt;a href=&quot;https://github.com/ZipCPU/dpll/blob/master/rtl/sdpll.v&quot;&gt;PLL&lt;/a&gt;
implementation, but since I already had
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/boxcar.v&quot;&gt;the filter&lt;/a&gt;
lying around from a
&lt;a href=&quot;/dsp/2017/10/16/boxcar.html&quot;&gt;previous post&lt;/a&gt;
it made sense to re-use it here.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;At the end of the loop, and so once per clock, we’ll update our
&lt;a href=&quot;https://github.com/ZipCPU/dpll/blob/master/bench/cpp/sdpll_tb.cpp&quot;&gt;simulation&lt;/a&gt;
&lt;a href=&quot;/dsp/2017/12/09/nco.html&quot;&gt;phase accumulator&lt;/a&gt;,
&lt;code class=&quot;highlighter-rouge&quot;&gt;lclphase&lt;/code&gt;, and create the next input for &lt;a href=&quot;https://github.com/ZipCPU/dpll/blob/master/rtl/sdpll.v&quot;&gt;the
PLL&lt;/a&gt;
to act upon.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;		&lt;span class=&quot;n&quot;&gt;tb&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i_ld&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;tb&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i_clk&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;lclphase&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lclstep&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;tb&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i_input&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lclphase&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;31&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Now that we have 
&lt;a href=&quot;https://github.com/ZipCPU/dpll/blob/master/rtl/sdpll.v&quot;&gt;this PLL&lt;/a&gt;
instrumented, we can answer the question of,
how well does &lt;a href=&quot;https://github.com/ZipCPU/dpll/blob/master/rtl/sdpll.v&quot;&gt;this PLL&lt;/a&gt;
work?&lt;/p&gt;

&lt;p&gt;While we could look at the error output of the PLL, as shown in Fig 7,&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 7. Output phase error&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/dpll-chart-oerr.png&quot; alt=&quot;&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;the result isn’t really all that meaningful.&lt;/p&gt;

&lt;p&gt;Sadly, because the error is a discretized signal of -1, 0, or 1, it’s rather
difficult to get a good feel for what is going on.  Clearly there’s more
error on the left side, but by how much?&lt;/p&gt;

&lt;p&gt;So, instead, let’s compare the difference between the
&lt;a href=&quot;https://github.com/ZipCPU/dpll/blob/master/bench/cpp/sdpll_tb.cpp&quot;&gt;simulation&lt;/a&gt;’s
internal &lt;code class=&quot;highlighter-rouge&quot;&gt;lclphase&lt;/code&gt; variable and the
&lt;a href=&quot;https://github.com/ZipCPU/dpll/blob/master/rtl/sdpll.v&quot;&gt;reconstructed&lt;/a&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;ctr&lt;/code&gt; value.  This is shown in Fig 8 as the &lt;em&gt;actual phase error&lt;/em&gt;.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 8. Actual phase error&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/dpll-chart-actual-perr.png&quot; alt=&quot;&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;This is more revealing.  Here we can see that the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Instantaneous_phase&quot;&gt;phase&lt;/a&gt; difference on the
left side of the chart is wandering all over the place.  Why?  Because
&lt;a href=&quot;https://github.com/ZipCPU/dpll/blob/master/rtl/sdpll.v&quot;&gt;the PLL&lt;/a&gt;
has yet to lock.  Eventually, it comes to a locked position and then the
error settles out into a steady state.&lt;/p&gt;

&lt;p&gt;Where this gets fascinating, though, is if you evaluate the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Instantaneous_phase&quot;&gt;phase&lt;/a&gt;
error of
&lt;a href=&quot;https://github.com/ZipCPU/dpll/blob/master/rtl/sdpll.v&quot;&gt;the PLL&lt;/a&gt;
across multiple coefficient choices.  We’ll try
&lt;code class=&quot;highlighter-rouge&quot;&gt;i_lgcoeff&lt;/code&gt; ranging from &lt;code class=&quot;highlighter-rouge&quot;&gt;4&lt;/code&gt; to &lt;code class=&quot;highlighter-rouge&quot;&gt;6&lt;/code&gt;, and plot the results in Fig 9.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 9. Actual phase error&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/dpll-chart-actual-perr2.png&quot; alt=&quot;&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;There’s a couple of things to notice in Fig 9.  First, the larger the
coefficient (i.e. the smaller &lt;code class=&quot;highlighter-rouge&quot;&gt;i_lgcoeff&lt;/code&gt;), the faster
&lt;a href=&quot;https://github.com/ZipCPU/dpll/blob/master/rtl/sdpll.v&quot;&gt;the PLL&lt;/a&gt;
converges.  However,
&lt;a href=&quot;https://github.com/ZipCPU/dpll/blob/master/rtl/sdpll.v&quot;&gt;the PLL&lt;/a&gt;
doesn’t settle as nicely when &lt;code class=&quot;highlighter-rouge&quot;&gt;i_lgcoeff&lt;/code&gt; is &lt;code class=&quot;highlighter-rouge&quot;&gt;4&lt;/code&gt; compared to how it settles
when &lt;code class=&quot;highlighter-rouge&quot;&gt;i_lgcoeff&lt;/code&gt; is &lt;code class=&quot;highlighter-rouge&quot;&gt;6&lt;/code&gt;.  On the other hand, even though the smaller
values of &lt;code class=&quot;highlighter-rouge&quot;&gt;2^(-i_lgcoeff)&lt;/code&gt; take longer to converge, once they do converge
the remaining residual error is much smaller.&lt;/p&gt;

&lt;p&gt;We can also return to
&lt;a href=&quot;https://github.com/ZipCPU/dpll/blob/master/rtl/sdpll.v&quot;&gt;the PLL&lt;/a&gt;’s
&lt;a href=&quot;https://en.wikipedia.org/wiki/Instantaneous_phase&quot;&gt;phase&lt;/a&gt;
error output and average it using a 3839 point
&lt;a href=&quot;/dsp/2017/10/16/boxcar.html&quot;&gt;boxcar filter&lt;/a&gt;.
(There is no particular significance to this number, 3839.  Feel free to
try other amounts if you would like.)
This will help to accumulate the errors long enough to draw a conclusion
from them.  You can see this result in Fig 10.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 10. Filtered Phase Error&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/dpll-chart-averr2.png&quot; alt=&quot;&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;The first conclusion to draw from Fig 10 is that we
&lt;a href=&quot;/dsp/2017/10/16/boxcar.html&quot;&gt;averaged&lt;/a&gt;
too many sample points together for &lt;code class=&quot;highlighter-rouge&quot;&gt;i_lgcoeff=4&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;i_lgcoeff=5&lt;/code&gt;.  This is
seen by the fact that the filtered error signals appear like negative rectangle
functions.  In spite of this artifact, you can see that the
&lt;code class=&quot;highlighter-rouge&quot;&gt;i_lgcoeff=6&lt;/code&gt; trace accumulates a much larger error before it finally locks.
Further, when each of these traces gets to the locked condition, they &lt;em&gt;suddenly&lt;/em&gt;
go to zero.  Finally, as before with the residual error, the &lt;code class=&quot;highlighter-rouge&quot;&gt;i_lgcoeff=6&lt;/code&gt; ends
up with smaller residual error.  (This is harder to see on the chart.)&lt;/p&gt;

&lt;p&gt;The last variable to consider is the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency&quot;&gt;frequency&lt;/a&gt;
step size.  Remember, we started
&lt;a href=&quot;https://github.com/ZipCPU/dpll/blob/master/rtl/sdpll.v&quot;&gt;this PLL&lt;/a&gt;
with a &lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency&quot;&gt;frequency&lt;/a&gt;
value that was about 12% too fast.  Hence, the step size
needs to come down a bit.  In Fig 11, you can see the step size, &lt;code class=&quot;highlighter-rouge&quot;&gt;r_step&lt;/code&gt;,
coming down for all three traces until the respective
&lt;a href=&quot;https://github.com/ZipCPU/dpll/blob/master/rtl/sdpll.v&quot;&gt;PLL&lt;/a&gt;’s
lock.  Once lock has been achieved, the traces appear to flatten out.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 11. Frequency Step&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/dpll-chart-fstep2.png&quot; alt=&quot;&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;However, as before, the &lt;code class=&quot;highlighter-rouge&quot;&gt;i_lgcoeff=4&lt;/code&gt; trace has the most noise on it following
convergence, whereas the &lt;code class=&quot;highlighter-rouge&quot;&gt;i_lgcoeff=6&lt;/code&gt; trace has less noise.&lt;/p&gt;

&lt;p&gt;Together, these charts should be sufficient to not only demonstrate that
&lt;a href=&quot;https://github.com/ZipCPU/dpll/blob/master/rtl/sdpll.v&quot;&gt;this PLL&lt;/a&gt;
implementation “works”, but also to give you an indication as to &lt;em&gt;how well&lt;/em&gt;
it works.&lt;/p&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;Building a &lt;a href=&quot;https://en.wikipedia.org/wiki/Phase-locked_loop&quot;&gt;PLL&lt;/a&gt; doesn’t
need to be the black art I once thought it was.  All of the parts and pieces
have fairly simple definitions, and
&lt;a href=&quot;https://github.com/ZipCPU/dpll/blob/master/rtl/sdpll.v&quot;&gt;the implementation&lt;/a&gt;
of this simple
&lt;a href=&quot;https://en.wikipedia.org/wiki/Phase-locked_loop&quot;&gt;PLL&lt;/a&gt;
really wasn’t all that complex.  Even better, since I’ve posted
&lt;a href=&quot;https://github.com/ZipCPU/dpll/blob/master/rtl/sdpll.v&quot;&gt;this code&lt;/a&gt;
on &lt;a href=&quot;https://github.com/ZipCPU&quot;&gt;GitHub&lt;/a&gt;, you are welcome to try it out yourself
to see how well (or poorly) it works for your problem set.&lt;/p&gt;

&lt;p&gt;Of course, I haven’t exhausted the topic of
either &lt;a href=&quot;https://en.wikipedia.org/wiki/Phase-locked_loop&quot;&gt;PLL&lt;/a&gt; design or
analysis–I’ve just presented a single 
&lt;a href=&quot;https://en.wikipedia.org/wiki/Phase-locked_loop&quot;&gt;PLL&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/dpll/blob/master/rtl/sdpll.v&quot;&gt;implementation&lt;/a&gt;
that has worked well for me over many years.  As examples of some of the things
we haven’t discussed:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;There’s a real reason and theory behind why we chose the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency&quot;&gt;frequency&lt;/a&gt;
correction value we did.  Perhaps if someone is interested, I could go
through this theory.  Be prepared, though, it depends upon a solid
understanding of &lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency&quot;&gt;&lt;em&gt;Z&lt;/em&gt; transforms&lt;/a&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;You may also remember that I skipped the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Instantaneous_phase&quot;&gt;phase&lt;/a&gt; error
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;s
in this implementation.  While a simple
&lt;a href=&quot;/dsp/2017/08/19/simple-filter.html&quot;&gt;recursive average&lt;/a&gt;
filter works nicely, the
&lt;a href=&quot;/dsp/2017/08/19/simple-filter.html&quot;&gt;recursive average&lt;/a&gt;
coefficient couples with the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Instantaneous_phase&quot;&gt;phase&lt;/a&gt;
and &lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency&quot;&gt;frequency&lt;/a&gt;
correction coefficients of the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Phase-locked_loop&quot;&gt;PLL&lt;/a&gt;,
necessitating a change to how these coefficients need to be calculated
should you go this route.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The actual study and analysis of
&lt;a href=&quot;https://en.wikipedia.org/wiki/Phase-locked_loop&quot;&gt;PLL&lt;/a&gt;s
includes a study of how to predict many of the charts I presented above
in Figures 7-11.  While it’s a valuable study that I would commend to anyone
interested, it’s not required to understand any of the figures.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Further, I know I said
that &lt;a href=&quot;https://en.wikipedia.org/wiki/Phase-locked_loop&quot;&gt;PLL&lt;/a&gt;s could be used for
clock recovery.  While
&lt;a href=&quot;https://github.com/ZipCPU/dpll/blob/master/rtl/sdpll.v&quot;&gt;today’s logic PLL&lt;/a&gt;
implements a valuable circuit that can handle that task,
you may find that the hardware implemented 
&lt;a href=&quot;https://en.wikipedia.org/wiki/Phase-locked_loop&quot;&gt;PLL&lt;/a&gt;s within your
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
are much more appropriate for this purpose than the
&lt;a href=&quot;https://github.com/ZipCPU/dpll/blob/master/rtl/sdpll.v&quot;&gt;PLL we designed today&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Finally, this isn’t the last word on
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Phase-locked_loop&quot;&gt;PLL&lt;/a&gt; implementation.
Other &lt;a href=&quot;https://en.wikipedia.org/wiki/Phase-locked_loop&quot;&gt;PLL&lt;/a&gt; implementations
are also valuable, such as the more traditional
(non-&lt;a href=&quot;https://en.wikipedia.org/wiki/Boolean_algebra&quot;&gt;binary&lt;/a&gt;)
&lt;a href=&quot;https://en.wikipedia.org/wiki/Phase-locked_loop&quot;&gt;PLL&lt;/a&gt; implementations,
or even logic &lt;a href=&quot;https://en.wikipedia.org/wiki/Phase-locked_loop&quot;&gt;PLL&lt;/a&gt;s
designed to run at many samples per clock.  These will need to remain a
topic for future posts.&lt;/p&gt;
&lt;hr /&gt;&lt;p&gt;&lt;em&gt;But the men marvelled, saying, What manner of man is this, that even the winds and the sea obey him! (Matt 8:24)&lt;/em&gt;</description>
        <pubDate>Thu, 14 Dec 2017 00:00:00 -0500</pubDate>
        <link>http://zipcpu.com/dsp/2017/12/14/logic-pll.html</link>
        <guid isPermaLink="true">http://zipcpu.com/dsp/2017/12/14/logic-pll.html</guid>
        
        
        <category>dsp</category>
        
      </item>
    
      <item>
        <title>Building a Numerically Controlled Oscillator</title>
        <description>&lt;p&gt;Many &lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_signal_processing&quot;&gt;signal
processing&lt;/a&gt;
applications require a &lt;a href=&quot;https://en.wikipedia.org/wiki/Sine_wave&quot;&gt;sine wave&lt;/a&gt;
at some point.  If the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Instantaneous_phase&quot;&gt;phase&lt;/a&gt;
or
&lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency&quot;&gt;frequency&lt;/a&gt;
of this
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sine_wave&quot;&gt;sine wave&lt;/a&gt;
is controlled within the design, then it is often called a &lt;a href=&quot;https://en.wikipedia.org/wiki/Numerically_controlled_oscillator&quot;&gt;Numerically
Controlled Oscillator
(NCO)&lt;/a&gt;. 
Let’s spend some time today looking into how you might build
one of these within an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;.  We’ll
also present a C++ implementation at the end as well, which may be used
in embedded &lt;a href=&quot;https://en.wikipedia.org/wiki/Embedded_system&quot;&gt;embedded&lt;/a&gt;
applications.&lt;/p&gt;

&lt;p&gt;Since we’ve already studied how to generate a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sine_wave&quot;&gt;sine wave&lt;/a&gt;
on an &lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;,
most of our work is already done: We’ve discussed a &lt;a href=&quot;/dsp/2017/07/11/simplest-sinewave-generator.html&quot;&gt;table lookup
method&lt;/a&gt;,
a &lt;a href=&quot;/dsp/2017/08/26/quarterwave.html&quot;&gt;quarter wave table
lookup&lt;/a&gt;,
method, and even how to generate both
a &lt;a href=&quot;https://en.wikipedia.org/wiki/Sine_wave&quot;&gt;sine wave&lt;/a&gt; and a cosine wave using a
&lt;a href=&quot;/dsp/2017/08/30/cordic.html&quot;&gt;CORDIC&lt;/a&gt;.
The subtle difference to describe to day is really how to turn such a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sine_wave&quot;&gt;sine wave&lt;/a&gt;
generator into a 
&lt;a href=&quot;https://en.wikipedia.org/wiki/Numerically_controlled_oscillator&quot;&gt;NCO&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Before we dive into the details, though, let’s spend a moment thinking about
how you might use such an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Numerically_controlled_oscillator&quot;&gt;NCO&lt;/a&gt;.
My own reason for presenting this today is twofold.  First, I know of a student
struggling to understand how to build something like this as part of a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Data_transmission&quot;&gt;digital communications&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Demodulation&quot;&gt;demodulator&lt;/a&gt;.
There is a small trick involved–one that appears to be well known among those
who do this sort of thing for a living, but not so well known among students and
I’d like to share it here.  Indeed, I think we might even build a better
&lt;a href=&quot;https://en.wikipedia.org/wiki/Numerically_controlled_oscillator&quot;&gt;NCO&lt;/a&gt; below
than &lt;a href=&quot;https://stackoverflow.com/questions/13466623/how-to-look-up-sine-of-different-frequencies-from-a-fixed-size-lookup-table&quot;&gt;this stackoverflow article&lt;/a&gt;
recommends.  My second reason for writing today is that I’d like to write about
how to build a &lt;a href=&quot;https://en.wikipedia.org/wiki/Phase-locked_loop&quot;&gt;Phase Locked Loop
(PLL)&lt;/a&gt;
within an &lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
on &lt;a href=&quot;http://zipcpu.com/&quot;&gt;this blog&lt;/a&gt;,
and every &lt;a href=&quot;https://en.wikipedia.org/wiki/Phase-locked_loop&quot;&gt;PLL&lt;/a&gt;
I’ve ever built has always included the basic
&lt;a href=&quot;https://en.wikipedia.org/wiki/Numerically_controlled_oscillator&quot;&gt;NCO&lt;/a&gt;
logic as part of &lt;a href=&quot;https://github.com/ZipCPU/dpll/blob/master/rtl/sdpll.v&quot;&gt;its
implementation&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;But this hardly scratches the surface of what you might do with an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Numerically_controlled_oscillator&quot;&gt;NCO&lt;/a&gt;.
Consider as an example that …&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Any linear signal processing system is completely characterized by its
&lt;a href=&quot;/dsp/2017/11/22/fltr-response.html&quot;&gt;frequency response&lt;/a&gt;.
As a result, I’ve used an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Numerically_controlled_oscillator&quot;&gt;NCO&lt;/a&gt;
in time past, together with a scope of some type, to evaluate whether the
digital input to a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_signal_processing&quot;&gt;signal processing&lt;/a&gt;
algorithm was being handled properly.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;We used an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Numerically_controlled_oscillator&quot;&gt;NCO&lt;/a&gt;
earlier as part of
&lt;a href=&quot;/dsp/2017/09/16/pwm-demo.html&quot;&gt;our demonstration&lt;/a&gt;
that the &lt;a href=&quot;/dsp/2017/09/04/pwm-reinvention.html&quot;&gt;improved PWM
generator&lt;/a&gt;
worked better than a traditional
&lt;a href=&quot;https://en.wikipedia.org/wiki/Pulse-width_modulation&quot;&gt;PWM&lt;/a&gt; for audio
signal generation.  While we didn’t discuss the details of the tone generator
at the time, we’ll explain many of those details today.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;You can also use an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Numerically_controlled_oscillator&quot;&gt;NCO&lt;/a&gt;
to move a signal around in
&lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency&quot;&gt;frequency&lt;/a&gt;–either bringing it
down from some
&lt;a href=&quot;https://en.wikipedia.org/wiki/Intermediate_frequency&quot;&gt;intermediate frequency (IF)&lt;/a&gt;
to a &lt;a href=&quot;https://en.wikipedia.org/wiki/Baseband&quot;&gt;baseband&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency&quot;&gt;frequency&lt;/a&gt;
where you can process it in
a &lt;a href=&quot;https://en.wikipedia.org/wiki/Radio_receiver&quot;&gt;receiver&lt;/a&gt;,
or the same in the other direction as part of a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Transmitter&quot;&gt;transmission&lt;/a&gt; algorithm.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;You can also use an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Numerically_controlled_oscillator&quot;&gt;NCO&lt;/a&gt;
as part of either a digital communications
&lt;a href=&quot;https://en.wikipedia.org/wiki/Modulation&quot;&gt;modulator&lt;/a&gt;
or &lt;a href=&quot;https://en.wikipedia.org/wiki/Demodulation&quot;&gt;demodulator&lt;/a&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;You can use an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Numerically_controlled_oscillator&quot;&gt;NCO&lt;/a&gt; to
create an &lt;a href=&quot;https://en.wikipedia.org/wiki/Amplitude_modulation&quot;&gt;Amplitude
Modulated (AM)&lt;/a&gt;
signal, or even a &lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency_modulation&quot;&gt;Frequency
Modulated (FM)&lt;/a&gt; signal.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Another common use is to generate musical notes via
an &lt;a href=&quot;https://en.wikipedia.org/wiki/Synthesizer&quot;&gt;additive synthesizer&lt;/a&gt;.  Indeed,
the &lt;a href=&quot;https://en.wikipedia.org/wiki/Instantaneous_phase&quot;&gt;phase&lt;/a&gt; accumulator
portion of the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Numerically_controlled_oscillator&quot;&gt;NCO&lt;/a&gt;
we’ll develop below can even be used in
&lt;a href=&quot;https://en.wikipedia.org/wiki/Synthesizer&quot;&gt;subtractive synthesis&lt;/a&gt;–it’s quite
generic.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Finally, because you as the designer have &lt;em&gt;complete&lt;/em&gt; control over the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency&quot;&gt;frequency&lt;/a&gt; output of the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Numerically_controlled_oscillator&quot;&gt;NCO&lt;/a&gt;,
you can even do some more exotic things–such as building a &lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency-hopping_spread_spectrum&quot;&gt;frequency
hopping&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Spread_spectrum&quot;&gt;spread spectrum&lt;/a&gt;
signal–should this be what you wish to do.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Indeed, &lt;a href=&quot;https://en.wikipedia.org/wiki/Numerically_controlled_oscillator&quot;&gt;NCO&lt;/a&gt;s
are such fundamental components of &lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_signal_processing&quot;&gt;Digital Signal Processing
(DSP)&lt;/a&gt;
algorithms that it is difficult to enumerate &lt;em&gt;all&lt;/em&gt; the things they can
be used for here.&lt;/p&gt;

&lt;h2 id=&quot;what-is-an-nco&quot;&gt;What is an NCO?&lt;/h2&gt;

&lt;table style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 1. NCO&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/nco-block.svg&quot; alt=&quot;NCO transforms a frequency input into a sinewave&quot; width=&quot;360&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;For our purpose today, a &lt;a href=&quot;https://en.wikipedia.org/wiki/Numerically_controlled_oscillator&quot;&gt;Numerically Controlled
Oscillator&lt;/a&gt;
is simply an oscillator created from digital logic that you have complete
control over digitally.
Nominally, such an oscillator will receive as an input the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency&quot;&gt;frequency&lt;/a&gt;
you wish to produce and it will produce a digitally sampled
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sine_wave&quot;&gt;sine wave&lt;/a&gt;
at that &lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency&quot;&gt;frequency&lt;/a&gt;.
Should you choose to use an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Numerically_controlled_oscillator&quot;&gt;NCO&lt;/a&gt;
within a &lt;a href=&quot;https://en.wikipedia.org/wiki/Phase-locked_loop&quot;&gt;PLL&lt;/a&gt;,
then you will also be adjusting the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Instantaneous_phase&quot;&gt;phase&lt;/a&gt;
of this &lt;a href=&quot;https://en.wikipedia.org/wiki/Sine_wave&quot;&gt;sine wave&lt;/a&gt;
generator.  For now, however, consider an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Numerically_controlled_oscillator&quot;&gt;NCO&lt;/a&gt;
to be a simple digital logic circuit that takes a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency&quot;&gt;frequency&lt;/a&gt;
input and produces a sampled
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sine_wave&quot;&gt;sine wave&lt;/a&gt;
as an output.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 2. Block Diagram&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/nco-components.svg&quot; alt=&quot;The components of a basic NCO&quot; width=&quot;540&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Internally, the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Numerically_controlled_oscillator&quot;&gt;NCO&lt;/a&gt;
keeps track of the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Instantaneous_phase&quot;&gt;phase&lt;/a&gt; of the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sine_wave&quot;&gt;sine wave&lt;/a&gt;
it produces, and it increments this
&lt;a href=&quot;https://en.wikipedia.org/wiki/Instantaneous_phase&quot;&gt;phase&lt;/a&gt;
at each sample point.&lt;/p&gt;

&lt;p&gt;Let’s walk through a little bit of trigonometry, to see how this works.&lt;/p&gt;

&lt;p&gt;We’ll start with the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sine_wave&quot;&gt;sine wave&lt;/a&gt;
that we want to produce, such as the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sine_wave&quot;&gt;sine wave&lt;/a&gt;
shown in Fig 3,&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 3. A pure sinewave&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/nco-pure-tone.png&quot; alt=&quot;Picture of x(t) = sine(2pi ft)&quot; width=&quot;540&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;and is given by the equation,&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/eqn-sinewave-xt.png&quot; alt=&quot;x(t) = sin(2pi ft)&quot; width=&quot;189&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Since digital implementations can only work on
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;sampled signals&lt;/a&gt;,
we’ll need to sample this &lt;a href=&quot;https://en.wikipedia.org/wiki/Sine_wave&quot;&gt;sine wave&lt;/a&gt;
every &lt;code class=&quot;highlighter-rouge&quot;&gt;Ts&lt;/code&gt; seconds.  To keep our notation straight,
we’ll now index this &lt;a href=&quot;https://en.wikipedia.org/wiki/Sine_wave&quot;&gt;sine wave&lt;/a&gt;
output by &lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;sample&lt;/a&gt;
number, &lt;code class=&quot;highlighter-rouge&quot;&gt;n&lt;/code&gt;, rather than by time, &lt;code class=&quot;highlighter-rouge&quot;&gt;t&lt;/code&gt;.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/eqn-sinewave-xnts.png&quot; alt=&quot;x[n] = sin(2pi (nTs) f)&quot; width=&quot;241&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;I personally find it easier to work with the &lt;em&gt;sample rate&lt;/em&gt; of the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital-to-analog_converter&quot;&gt;digitizer&lt;/a&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;fs&lt;/code&gt;
rather than the &lt;em&gt;time between samples&lt;/em&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;Ts&lt;/code&gt;.  &lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency&quot;&gt;These are reciprocals of each
other&lt;/a&gt;, so &lt;code class=&quot;highlighter-rouge&quot;&gt;fs = 1/Ts&lt;/code&gt;.  We can then
express this same equation as,&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/eqn-sinewave-xnffs.png&quot; alt=&quot;x[n] = sin(2pi n f/fs)&quot; width=&quot;218&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;and plot the sampled function in Fig 4.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 4. A sampled sinewave&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/nco-sampled-tone.png&quot; alt=&quot;Picture of x[n] = sine(2pi f/fs n)&quot; width=&quot;540&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;In this figure, the samples are shown in circles.  They are each separated by
a phase of &lt;code class=&quot;highlighter-rouge&quot;&gt;2pi f/fs&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Our entire focus in this algorithm, though, is going to be on the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Instantaneous_phase&quot;&gt;phase&lt;/a&gt;
of this expression–the argument of the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sine_wave&quot;&gt;sine wave&lt;/a&gt;.  In the expression
above, this
&lt;a href=&quot;https://en.wikipedia.org/wiki/Instantaneous_phase&quot;&gt;phase&lt;/a&gt;
is given by &lt;code class=&quot;highlighter-rouge&quot;&gt;n&lt;/code&gt; times the &lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency&quot;&gt;frequency&lt;/a&gt;
ratio, &lt;code class=&quot;highlighter-rouge&quot;&gt;f/fs&lt;/code&gt;, times &lt;code class=&quot;highlighter-rouge&quot;&gt;2pi&lt;/code&gt;.  We’ll call this changing
&lt;a href=&quot;https://en.wikipedia.org/wiki/Instantaneous_phase&quot;&gt;phase&lt;/a&gt;
value &lt;code class=&quot;highlighter-rouge&quot;&gt;phi[n]&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;To build an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Numerically_controlled_oscillator&quot;&gt;NCO&lt;/a&gt;,
we are going to need to transform this
&lt;a href=&quot;https://en.wikipedia.org/wiki/Instantaneous_phase&quot;&gt;phase&lt;/a&gt; value, &lt;code class=&quot;highlighter-rouge&quot;&gt;phi[n]&lt;/code&gt;,
into an input our &lt;a href=&quot;https://en.wikipedia.org/wiki/Sine_wave&quot;&gt;sine wave&lt;/a&gt;
generator can handle.&lt;/p&gt;

&lt;p&gt;We’ll start by rewriting our
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sine_wave&quot;&gt;sine wave&lt;/a&gt; using this
&lt;a href=&quot;https://en.wikipedia.org/wiki/Instantaneous_phase&quot;&gt;phase&lt;/a&gt; value, &lt;code class=&quot;highlighter-rouge&quot;&gt;phi[n]&lt;/code&gt;,
so that it captures the internals of this
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sine_wave&quot;&gt;sine wave&lt;/a&gt;–with
the exception of the &lt;code class=&quot;highlighter-rouge&quot;&gt;2pi&lt;/code&gt; portion.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/eqn-sinewave-xphi.png&quot; alt=&quot;x[n] = sin(2pi phi[n])&quot; width=&quot;210&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Specifically, this
&lt;a href=&quot;https://en.wikipedia.org/wiki/Instantaneous_phase&quot;&gt;phase&lt;/a&gt;
value is defined by,&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/eqn-sinewave-phi.png&quot; alt=&quot;phi[n] = n(f/fs)&quot; width=&quot;136&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;table style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 5. Unit circle rotations&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/dphase-unit-circle.svg&quot; alt=&quot;A picture of the unit circle&quot; width=&quot;180&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;It represents the number of times our
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sine_wave&quot;&gt;sine wave&lt;/a&gt;
has gone around the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Unit_circle&quot;&gt;unit circle&lt;/a&gt;–the number of
rotations if you will.  For example, a &lt;code class=&quot;highlighter-rouge&quot;&gt;phi[n]&lt;/code&gt; of 1.0, applied internally
to our &lt;a href=&quot;https://en.wikipedia.org/wiki/Sine_wave&quot;&gt;sine wave&lt;/a&gt;,
would lead to a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Instantaneous_phase&quot;&gt;phase&lt;/a&gt; argument to our
sine function of &lt;code class=&quot;highlighter-rouge&quot;&gt;2pi&lt;/code&gt;–suggesting we had gone around the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Unit_circle&quot;&gt;unit circle&lt;/a&gt;
once.  A &lt;code class=&quot;highlighter-rouge&quot;&gt;phi[n]&lt;/code&gt; of 2.0 would yield the same value, but represent
instead that the &lt;a href=&quot;https://en.wikipedia.org/wiki/Instantaneous_phase&quot;&gt;phase&lt;/a&gt;
had traveled around the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Unit_circle&quot;&gt;unit circle&lt;/a&gt;
twice.  Fractions then will indicate partial angles from the x-axis around
the &lt;a href=&quot;https://en.wikipedia.org/wiki/Unit_circle&quot;&gt;unit circle&lt;/a&gt;,
hence a &lt;code class=&quot;highlighter-rouge&quot;&gt;phi[n]&lt;/code&gt; of &lt;code class=&quot;highlighter-rouge&quot;&gt;0.5&lt;/code&gt; would represent going halfway round
this &lt;a href=&quot;https://en.wikipedia.org/wiki/Unit_circle&quot;&gt;circle&lt;/a&gt;,
while &lt;code class=&quot;highlighter-rouge&quot;&gt;0.25&lt;/code&gt; would represent a quarter of the way around the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Unit_circle&quot;&gt;circle&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Let’s keep working with this value for a bit.  We can define this
&lt;a href=&quot;https://en.wikipedia.org/wiki/Instantaneous_phase&quot;&gt;phase&lt;/a&gt;
recursively based upon the prior
&lt;a href=&quot;https://en.wikipedia.org/wiki/Instantaneous_phase&quot;&gt;phase&lt;/a&gt;.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/eqn-sinewave-phibyphi.png&quot; alt=&quot;phi[n]=phi[n-1]+f/fs&quot; width=&quot;226&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;This simple modification accomplishes two purposes.  First, it allows us to
avoid a multiply by &lt;code class=&quot;highlighter-rouge&quot;&gt;n&lt;/code&gt;, turning the calculation of the next
&lt;a href=&quot;https://en.wikipedia.org/wiki/Instantaneous_phase&quot;&gt;phase&lt;/a&gt;
from the past
&lt;a href=&quot;https://en.wikipedia.org/wiki/Instantaneous_phase&quot;&gt;phase&lt;/a&gt;
into an operation requiring an addition alone.  Second, because this newer
version is no longer tied to the distance from &lt;code class=&quot;highlighter-rouge&quot;&gt;n=0&lt;/code&gt;, this subtle change
allows us to maintain any accumulated
&lt;a href=&quot;https://en.wikipedia.org/wiki/Instantaneous_phase&quot;&gt;phase&lt;/a&gt;
offsets in our
&lt;a href=&quot;https://en.wikipedia.org/wiki/Numerically_controlled_oscillator&quot;&gt;NCO&lt;/a&gt;
as well–not just
&lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency&quot;&gt;frequencies&lt;/a&gt;
with zero phase at zero time.&lt;/p&gt;

&lt;p&gt;This sounds fairly straight-forward so far.  What’s the trick?&lt;/p&gt;

&lt;h2 id=&quot;the-trick-to-building-an-nco&quot;&gt;The “Trick” to building an NCO&lt;/h2&gt;

&lt;p&gt;The “trick” in building an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Numerically_controlled_oscillator&quot;&gt;NCO&lt;/a&gt;
lies in the units of &lt;code class=&quot;highlighter-rouge&quot;&gt;phi[n]&lt;/code&gt;.  The units of &lt;code class=&quot;highlighter-rouge&quot;&gt;phi[n]&lt;/code&gt;, presented above, are
a number of cycles (or rotations) around the &lt;a href=&quot;https://en.wikipedia.org/wiki/Unit_circle&quot;&gt;unit
circle&lt;/a&gt;.  As a result, a
&lt;code class=&quot;highlighter-rouge&quot;&gt;phi[n]&lt;/code&gt; of 1.0 represents once around the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Unit_circle&quot;&gt;unit circle&lt;/a&gt;,
and a &lt;code class=&quot;highlighter-rouge&quot;&gt;phi[n]&lt;/code&gt; of 2.0 represents twice around the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Unit_circle&quot;&gt;unit circle&lt;/a&gt;, etc.&lt;/p&gt;

&lt;p&gt;However, within most
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_signal_processing&quot;&gt;signal processing&lt;/a&gt;
logic (&lt;a href=&quot;/dsp/2017/07/19/linear-upsampling.html&quot;&gt;not
quite all&lt;/a&gt;),
you don’t care how many &lt;em&gt;integer&lt;/em&gt; times a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sine_wave&quot;&gt;sine wave&lt;/a&gt; goes around the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Unit_circle&quot;&gt;unit circle&lt;/a&gt;,
you only care about the angular fraction.
Let’s therefore examine this number in terms of both it’s integer and
fractional portions.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/eqn-sinewave-phi-fraction.png&quot; alt=&quot;phi[n]=INT.FRACTION(...)&quot; width=&quot;258&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Specifically, let’s separate it into an integer portion, and the first
&lt;code class=&quot;highlighter-rouge&quot;&gt;W&lt;/code&gt; bits past the decimal point as shown below.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/phase-bits.svg&quot; alt=&quot;phi[n] separates into integer components and W fractional components&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Pictorially, dropping the integer portion might look like Fig 6 below.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 6. Phase function&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/nco-sampled-phase.png&quot; alt=&quot;A picture of the sampled phase function&quot; width=&quot;540&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Notice how the phase jumps back to zero in Fig 6 at the same point as where the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sine_wave&quot;&gt;sine wave&lt;/a&gt;
starts to repeat.  Sure, you didn’t need to bring this value back down
to zero, but doing so creates a limited range in &lt;code class=&quot;highlighter-rouge&quot;&gt;y&lt;/code&gt; that we can then
split among a fixed number of bits, &lt;code class=&quot;highlighter-rouge&quot;&gt;W&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Since we didn’t care about the integer number of times we’ve gone around the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Unit_circle&quot;&gt;unit circle&lt;/a&gt;,
we can subtract from &lt;code class=&quot;highlighter-rouge&quot;&gt;phi[n]&lt;/code&gt; its integer portion to recover the
fraction alone–just like we did in Fig 6 above.  We can then multiply the
result by &lt;code class=&quot;highlighter-rouge&quot;&gt;2^W&lt;/code&gt;, so as to get a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Fixed_point_(mathematics)&quot;&gt;fixed-point&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Instantaneous_phase&quot;&gt;phase&lt;/a&gt;
representation that will fit within a word of &lt;code class=&quot;highlighter-rouge&quot;&gt;W&lt;/code&gt; bits long.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/eqn-sinewave-usable-phi-defn.png&quot; alt=&quot;PHI[n]=2^W (phi[n] - floor(phi[n]))&quot; width=&quot;299&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Just to finish this off, we’ll only keep the integer portion of this
value, representing the top &lt;code class=&quot;highlighter-rouge&quot;&gt;W&lt;/code&gt; bits of our fractional
&lt;a href=&quot;https://en.wikipedia.org/wiki/Instantaneous_phase&quot;&gt;phase&lt;/a&gt;,
and we’ll ignore any further bits beyond the decimal point.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/eqn-sinewave-usable-fraction.png&quot; alt=&quot;PHI[n]~=FRACTION&quot; width=&quot;212&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Hence &lt;code class=&quot;highlighter-rouge&quot;&gt;PHI[n]&lt;/code&gt; is now a number between &lt;code class=&quot;highlighter-rouge&quot;&gt;0&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;2^W-1&lt;/code&gt; representing a fractional
rotation around the &lt;a href=&quot;https://en.wikipedia.org/wiki/Unit_circle&quot;&gt;unit circle&lt;/a&gt;,
a value between &lt;code class=&quot;highlighter-rouge&quot;&gt;0&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;That’s the first part of our “trick.”&lt;/p&gt;

&lt;p&gt;For the second part of this “trick”, let’s use the top &lt;code class=&quot;highlighter-rouge&quot;&gt;P&lt;/code&gt; bits of our
&lt;a href=&quot;https://en.wikipedia.org/wiki/Instantaneous_phase&quot;&gt;phase&lt;/a&gt;,
&lt;code class=&quot;highlighter-rouge&quot;&gt;PHI[n]&lt;/code&gt;, as the input to our
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sine_wave&quot;&gt;sine wave&lt;/a&gt;
generator, whether a
&lt;a href=&quot;/dsp/2017/07/11/simplest-sinewave-generator.html&quot;&gt;table lookup&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sine_wave&quot;&gt;sine wave&lt;/a&gt; generator, or even the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Instantaneous_phase&quot;&gt;phase&lt;/a&gt;
input phase value of a 
&lt;a href=&quot;/dsp/2017/08/30/cordic.html&quot;&gt;CORDIC&lt;/a&gt; algorithm.&lt;/p&gt;

&lt;p&gt;But what about the rest of the &lt;code class=&quot;highlighter-rouge&quot;&gt;W&lt;/code&gt; bits of our
&lt;a href=&quot;https://en.wikipedia.org/wiki/Fixed_point_(mathematics)&quot;&gt;fixed-point&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Instantaneous_phase&quot;&gt;phase&lt;/a&gt;
representation?&lt;/p&gt;

&lt;p&gt;These can be used for one of two purposes.  First, they can be used as a
fractional table index, accumulating over time to adjust our table index.
An example of this is shown below in Fig 7.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 7. Fractional phase accumulation&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/phase-tbl-index.svg&quot; alt=&quot;phi[n] separates into integer components and W fractional components&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;If you look carefully at this figure, you can see how the phase pointer
moves a little bit more than one table position at a time.  Eventually this
extra accumulated fraction causes the table index to
skip a table position entirely (position 6).&lt;/p&gt;

&lt;p&gt;This will allow you to represent and create 
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sine_wave&quot;&gt;sine wave&lt;/a&gt;s at
&lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency&quot;&gt;frequencies&lt;/a&gt;
not formed by integer steps through your table.  Such
&lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency&quot;&gt;frequencies&lt;/a&gt;
may involve jumping across table entries, as shown above in Fig 7, or even
repeating entries if necessary.  Yes, jumping entries will likely cause a
distortion in your output, but it will also help you maintain better
&lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency&quot;&gt;frequency&lt;/a&gt;
resolution than the first &lt;code class=&quot;highlighter-rouge&quot;&gt;P&lt;/code&gt; bits alone would allow.&lt;/p&gt;

&lt;p&gt;A second use for the bottom &lt;code class=&quot;highlighter-rouge&quot;&gt;W-P&lt;/code&gt; bits would be as part of an
interpolation
scheme to reduce the &lt;a href=&quot;https://en.wikipedia.org/wiki/Phase_noise&quot;&gt;phase noise&lt;/a&gt;
associated with any table representation.
This is such an important possibility that we may have
to come back to it and write about it more in a later article.&lt;/p&gt;

&lt;p&gt;But, what about overflow?&lt;/p&gt;

&lt;p&gt;This is an important question, so let’s walk through an example and see what
happens.  Consider what would happen if we were keeping track of
&lt;a href=&quot;https://en.wikipedia.org/wiki/Instantaneous_phase&quot;&gt;phase&lt;/a&gt;
in an 8-bit word, and one of our additions overflowed.  For example,
suppose you wanted to take four steps to go around a circle, starting at
&lt;code class=&quot;highlighter-rouge&quot;&gt;PHI[n]=8&#39;h20&lt;/code&gt; (45 degrees).  You’d then add to it &lt;code class=&quot;highlighter-rouge&quot;&gt;8&#39;h40&lt;/code&gt; (90 degrees) on
each clock.  The resulting sequence would then be, &lt;code class=&quot;highlighter-rouge&quot;&gt;8&#39;h20&lt;/code&gt; (45 degrees),
&lt;code class=&quot;highlighter-rouge&quot;&gt;8&#39;h60&lt;/code&gt; (135 degrees), &lt;code class=&quot;highlighter-rouge&quot;&gt;8&#39;ha0&lt;/code&gt; (225 degrees), &lt;code class=&quot;highlighter-rouge&quot;&gt;8&#39;he0&lt;/code&gt; (315 degrees),
&lt;code class=&quot;highlighter-rouge&quot;&gt;8&#39;h20&lt;/code&gt; (45 degrees).&lt;/p&gt;

&lt;p&gt;Did you catch what just happened?  The
&lt;a href=&quot;https://en.wikipedia.org/wiki/Instantaneous_phase&quot;&gt;phase&lt;/a&gt;
accumulator just overflowed between 315 degrees and 45 degrees, and yet the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Instantaneous_phase&quot;&gt;phase&lt;/a&gt;
representation just “did the right thing”!  What that means is that you can
ignore any overflow in your
&lt;a href=&quot;https://en.wikipedia.org/wiki/Instantaneous_phase&quot;&gt;phase&lt;/a&gt;–it’s
just going to wrap around the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Unit_circle&quot;&gt;unit circle&lt;/a&gt;
anyway, and the &lt;a href=&quot;https://en.wikipedia.org/wiki/Sine_wave&quot;&gt;sine wave&lt;/a&gt;
generator is only interested in the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Instantaneous_phase&quot;&gt;phase&lt;/a&gt;
fraction anyway.&lt;/p&gt;

&lt;h2 id=&quot;example-source-code&quot;&gt;Example Source Code&lt;/h2&gt;

&lt;p&gt;So, how would this look in practice?  Let’s look at an example of what this
would look like in both C++ and Verilog.&lt;/p&gt;

&lt;p&gt;We’ll start with a C++ example.  We’ll make a C++
&lt;a href=&quot;https://en.wikipedia.org/wiki/Numerically_controlled_oscillator&quot;&gt;NCO&lt;/a&gt;
class incorporating these principles.  There are three basic parts
to this class.  The first is the class declaration and table generation.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;NCO&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
	&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;m_lglen&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m_len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m_mask&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m_phase&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m_dphase&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;kt&quot;&gt;float&lt;/span&gt;		&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_table&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

	&lt;span class=&quot;n&quot;&gt;NCO&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lgtblsize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;c1&quot;&gt;// We&#39;ll use a table 2^(lgtblize) in length.  This is
&lt;/span&gt;		&lt;span class=&quot;c1&quot;&gt;// non-negotiable, as the rest of this algorithm depends upon
&lt;/span&gt;		&lt;span class=&quot;c1&quot;&gt;// this property.
&lt;/span&gt;		&lt;span class=&quot;n&quot;&gt;m_lglen&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lgtblsize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;m_len&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lgtblsize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

		&lt;span class=&quot;c1&quot;&gt;// m_mask is 1 for any bit used in the index, zero otherwise
&lt;/span&gt;		&lt;span class=&quot;n&quot;&gt;m_mask&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m_len&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;We’ll build the table itself with the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sine_wave&quot;&gt;sine wave&lt;/a&gt;
values at the left-edge of any interval.  This isn’t optimal, since it will
force the error to zero on the left edge and likely make it a maximum on the
right side of the interval, but it will yield us a decent capability quickly.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;		&lt;span class=&quot;n&quot;&gt;m_table&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;float&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;m_table&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;2.&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;M_PI&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;We may come back to this in a later post to minimize the maximum error
in this lookup.&lt;/p&gt;

&lt;p&gt;The last part of this initialization is to provide initial values for our
&lt;a href=&quot;https://en.wikipedia.org/wiki/Instantaneous_phase&quot;&gt;phase&lt;/a&gt;
accumulator  (&lt;code class=&quot;highlighter-rouge&quot;&gt;PHI[n]&lt;/code&gt;) and the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Instantaneous_phase&quot;&gt;phase&lt;/a&gt;
step necessary to create a known
&lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency&quot;&gt;frequency&lt;/a&gt; output.
In this case, we’ll initialize this step so that it will produce a zero
&lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency&quot;&gt;frequency&lt;/a&gt;–not
very exciting, but fixing that will be our next step.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;		&lt;span class=&quot;c1&quot;&gt;// m_phase is the variable holding our PHI[n] function from
&lt;/span&gt;		&lt;span class=&quot;c1&quot;&gt;// above.
&lt;/span&gt;		&lt;span class=&quot;c1&quot;&gt;// We&#39;ll initialize our initial phase and frequency to zero
&lt;/span&gt;		&lt;span class=&quot;n&quot;&gt;m_phase&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;m_dphase&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

	&lt;span class=&quot;c1&quot;&gt;// On any object deletion, make sure we delete the table as well
&lt;/span&gt;	&lt;span class=&quot;o&quot;&gt;~&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NCO&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;delete&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m_table&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The second part of this implementation is the function that sets the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency&quot;&gt;frequency&lt;/a&gt;.
This is captured within the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Numerically_controlled_oscillator&quot;&gt;NCO&lt;/a&gt; object
by the &lt;a href=&quot;https://en.wikipedia.org/wiki/Instantaneous_phase&quot;&gt;phase&lt;/a&gt;
step, &lt;code class=&quot;highlighter-rouge&quot;&gt;m_dphase&lt;/code&gt;.  As discussed above, this is the difference between &lt;code class=&quot;highlighter-rouge&quot;&gt;PHI[n]&lt;/code&gt;
and &lt;code class=&quot;highlighter-rouge&quot;&gt;PHI[n-1]&lt;/code&gt;.  Further, if you create a &lt;code class=&quot;highlighter-rouge&quot;&gt;SAMPLE_RATE&lt;/code&gt; value in
&lt;a href=&quot;https://en.wikipedia.org/wiki/Hertz&quot;&gt;Hertz&lt;/a&gt;,
then &lt;code class=&quot;highlighter-rouge&quot;&gt;f&lt;/code&gt; can be given to this routine in
&lt;a href=&quot;https://en.wikipedia.org/wiki/Hertz&quot;&gt;Hertz&lt;/a&gt;.  Otherwise, you can keep
&lt;code class=&quot;highlighter-rouge&quot;&gt;SAMPLE_RATE&lt;/code&gt; set to &lt;code class=&quot;highlighter-rouge&quot;&gt;1.0&lt;/code&gt; and then the &lt;code class=&quot;highlighter-rouge&quot;&gt;f&lt;/code&gt; value accepted by this routine will 
be set in terms of a normalized
&lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency&quot;&gt;frequency&lt;/a&gt; ranging from &lt;code class=&quot;highlighter-rouge&quot;&gt;0.0&lt;/code&gt; to the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Nyquist_frequency&quot;&gt;Nyquist frequency&lt;/a&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;0.5&lt;/code&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;	&lt;span class=&quot;c1&quot;&gt;// Adjust the sample rate for your implementation as necessary
&lt;/span&gt;	&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt;	&lt;span class=&quot;kt&quot;&gt;float&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;SAMPLE_RATE&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;1.0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt;	&lt;span class=&quot;kt&quot;&gt;float&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;ONE_ROTATION&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;2.0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1u&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;8&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;

	&lt;span class=&quot;kt&quot;&gt;float&lt;/span&gt;	&lt;span class=&quot;nf&quot;&gt;frequency&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;float&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;c1&quot;&gt;// Convert the frequency to a fractional difference in phase
&lt;/span&gt;		&lt;span class=&quot;n&quot;&gt;m_dphase&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ONE_ROTATION&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SAMPLE_RATE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;As a matter of personal practice, I never make the &lt;code class=&quot;highlighter-rouge&quot;&gt;SAMPLE_RATE&lt;/code&gt; a part of
my &lt;a href=&quot;https://en.wikipedia.org/wiki/Numerically_controlled_oscillator&quot;&gt;NCO&lt;/a&gt;
implementations.  That way one
&lt;a href=&quot;https://en.wikipedia.org/wiki/Numerically_controlled_oscillator&quot;&gt;NCO&lt;/a&gt;
implementation can work across multiple projects.&lt;/p&gt;

&lt;p&gt;You may find that the most confusing part of the logic above is the
&lt;code class=&quot;highlighter-rouge&quot;&gt;ONE_ROTATION&lt;/code&gt; value.  This is the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Instantaneous_phase&quot;&gt;phase&lt;/a&gt;
value representing once around the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Unit_circle&quot;&gt;unit circle&lt;/a&gt;.  It is given by
&lt;code class=&quot;highlighter-rouge&quot;&gt;2^W&lt;/code&gt;.  We have to go through a bit of a hoop to set this value, though, since
the &lt;code class=&quot;highlighter-rouge&quot;&gt;ONE_ROTATION&lt;/code&gt; value doesn’t fit within the &lt;code class=&quot;highlighter-rouge&quot;&gt;unsigned&lt;/code&gt; integer we are using
to hold &lt;code class=&quot;highlighter-rouge&quot;&gt;PHI[n]&lt;/code&gt; (&lt;code class=&quot;highlighter-rouge&quot;&gt;m_phase&lt;/code&gt;).  Alternatively, we might’ve set &lt;code class=&quot;highlighter-rouge&quot;&gt;ONE_ROTATION&lt;/code&gt; to
&lt;code class=&quot;highlighter-rouge&quot;&gt;pow(2,sizeof(unsigned)*8)&lt;/code&gt;, but the approach above makes it easier for the
compiler to recognize that this value is a constant, rather than needing to
call the &lt;code class=&quot;highlighter-rouge&quot;&gt;pos()&lt;/code&gt; math library function.&lt;/p&gt;

&lt;p&gt;The final part of this class steps the index into the table forward by one
step, and then returns the value of the table at the index given by the top
&lt;code class=&quot;highlighter-rouge&quot;&gt;P&lt;/code&gt; bits in the &lt;code class=&quot;highlighter-rouge&quot;&gt;m_phase&lt;/code&gt; word.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;	&lt;span class=&quot;kt&quot;&gt;float&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;operator&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;()(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

		&lt;span class=&quot;c1&quot;&gt;// Increment the phase by an amount dictated by our frequency
&lt;/span&gt;		&lt;span class=&quot;c1&quot;&gt;// m_phase was our PHI[n] value above
&lt;/span&gt;		&lt;span class=&quot;n&quot;&gt;m_phase&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m_dphase&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// PHI[n] = PHI[n-1] + (2^32 * f/fs)
&lt;/span&gt;
		&lt;span class=&quot;c1&quot;&gt;// Grab the top m_lglen bits of this phase word
&lt;/span&gt;		&lt;span class=&quot;n&quot;&gt;index&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m_phase&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;8&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_lglen&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

		&lt;span class=&quot;c1&quot;&gt;// Insist that this index be found within 0... (m_len-1)
&lt;/span&gt;		&lt;span class=&quot;n&quot;&gt;index&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m_mask&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

		&lt;span class=&quot;c1&quot;&gt;// Finally return the table lookup value
&lt;/span&gt;		&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m_table&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;You may notice that I’ve chosen to use single precision &lt;code class=&quot;highlighter-rouge&quot;&gt;float&lt;/code&gt;s, rather
than &lt;code class=&quot;highlighter-rouge&quot;&gt;double&lt;/code&gt; precision floating point numbers.  I did this for 
two reasons.&lt;/p&gt;

&lt;p&gt;First, I wanted to encourage you to ask the question of just how much precision
do you actually need?&lt;/p&gt;

&lt;p&gt;Second, I wanted to point out that the single precision &lt;code class=&quot;highlighter-rouge&quot;&gt;float&lt;/code&gt; representation
only has a 24-bit mantissa.  Most
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;s
today allow integers of 32-bits.  As a result, the integer
&lt;a href=&quot;https://en.wikipedia.org/wiki/Instantaneous_phase&quot;&gt;phase&lt;/a&gt;
accumulator &lt;em&gt;has more precision than a &lt;code class=&quot;highlighter-rouge&quot;&gt;float&lt;/code&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Instantaneous_phase&quot;&gt;phase&lt;/a&gt;
accumulator&lt;/em&gt;.  You can see this pictorially in Fig 8.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 8. Floating vs Fixed point phase&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/nco-fixed-v-float.svg&quot; alt=&quot;Comparing Fixed vs Floating point phase representations&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;If you are not familiar with single precision IEEE floats, the first bit,
&lt;code class=&quot;highlighter-rouge&quot;&gt;S&lt;/code&gt;, is a sign bit, and the next seven, &lt;code class=&quot;highlighter-rouge&quot;&gt;E&lt;/code&gt;, are exponent bits.  The final
24-bits, &lt;code class=&quot;highlighter-rouge&quot;&gt;M&lt;/code&gt;, are mantissa bits.  Put together, these items represent a
number sort of like, &lt;code class=&quot;highlighter-rouge&quot;&gt;(-1)^S * 2^E * M&lt;/code&gt;.  (Yes, I’m skipping some details
here.)&lt;/p&gt;

&lt;p&gt;Unlike IEEE floats, our fixed point
&lt;a href=&quot;https://en.wikipedia.org/wiki/Instantaneous_phase&quot;&gt;phase&lt;/a&gt;
representation is simply &lt;code class=&quot;highlighter-rouge&quot;&gt;32&lt;/code&gt; mantissa bits,
having a value ranging from &lt;code class=&quot;highlighter-rouge&quot;&gt;0&lt;/code&gt; to &lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Which one do you think will have more precision?&lt;/p&gt;

&lt;p&gt;In a similar fashion, if you were to use an &lt;code class=&quot;highlighter-rouge&quot;&gt;unsigned long&lt;/code&gt; for your
accumulator instead of an &lt;code class=&quot;highlighter-rouge&quot;&gt;unsigned&lt;/code&gt; value, then the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Instantaneous_phase&quot;&gt;phase&lt;/a&gt;
accumulator would have more precision than a &lt;code class=&quot;highlighter-rouge&quot;&gt;double&lt;/code&gt; precision float would
allow.&lt;/p&gt;

&lt;p&gt;In both cases the reason why this
&lt;a href=&quot;https://en.wikipedia.org/wiki/Instantaneous_phase&quot;&gt;phase&lt;/a&gt;
accumulator out-performs a floating point
&lt;a href=&quot;https://en.wikipedia.org/wiki/Instantaneous_phase&quot;&gt;phase&lt;/a&gt;
accumulator is simple because our representation has a fixed
decimal location, rather than a &lt;em&gt;floating&lt;/em&gt; decimal point.  That allows
more bits per word to be allocated to the mantissa, since the floating
point representation needed to allocate extra bits for both a sign
bit and the exponent.&lt;/p&gt;

&lt;p&gt;Were you to build an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Numerically_controlled_oscillator&quot;&gt;NCO&lt;/a&gt;
implementation within Verilog, the code is almost identical.
The biggest differences are first the fact that we require the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency&quot;&gt;frequency&lt;/a&gt;
given to be already be converted into the appropriate units, and second that
the bit select is simpler than before.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;module	nco(i_clk, i_ld, i_dphase, o_val);
	parameter	LGTBL = 9, // Log, base two, of the table size
			W = 32, // Word-size
			OW = 8; // Output width
	localparam	P = LGTBL;
	//
	input	wire		i_clk;
	//
	input	wire		i_ld;
	input	wire		i_dphase;
	//
	input	wire		i_ce
	output	wire [OW-1:0]	o_val;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Any time a new
&lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency&quot;&gt;frequency&lt;/a&gt;
is requested, the &lt;code class=&quot;highlighter-rouge&quot;&gt;i_ld&lt;/code&gt; signal will be set high
and the new frequency placed into &lt;code class=&quot;highlighter-rouge&quot;&gt;i_dphase&lt;/code&gt;.  This
&lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency&quot;&gt;frequency&lt;/a&gt;
value is in the units of &lt;code class=&quot;highlighter-rouge&quot;&gt;m_dphase&lt;/code&gt; in the C++ code above.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	reg	[W-1:0]	r_step;

	initial	r_step = 0;
	always @(posedge i_clk)
	if (i_ld)
		r_step &amp;lt;= i_dphase; // = 2^W * f/fs&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Likewise, on any clock where &lt;a href=&quot;/blog/2017/08/14/strategies-for-pipelining.html&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;i_ce&lt;/code&gt; is
high&lt;/a&gt;,
we’ll step the &lt;a href=&quot;https://en.wikipedia.org/wiki/Instantaneous_phase&quot;&gt;phase&lt;/a&gt;
forward by this same frequency-dependent amount.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	reg	[W-1:0]	r_phase;

	initial	r_phase = 0;
	always @(posedge i_clk)
	if (i_ce)
		// PHI[n] = PHI[n-1] + 2^W * f / fs
		r_phase &amp;lt;= r_phase + r_step;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Finally, the top &lt;code class=&quot;highlighter-rouge&quot;&gt;P&lt;/code&gt; bits of &lt;code class=&quot;highlighter-rouge&quot;&gt;r_phase&lt;/code&gt; are used in our &lt;a href=&quot;/dsp/2017/07/11/simplest-sinewave-generator.html&quot;&gt;table
lookup&lt;/a&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	sintable // #(.PW(P), .OW(OW))
		stbl(i_clk, 1&#39;b0, i_ce, 1&#39;b0, r_phase[(W-1):(W-P)],
		o_val, ignored);
endmodule&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;You may notice that both the C++ and Verilog implementations are quite similar.
They are both low logic implementations showing the basics of what is required
to create an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Numerically_controlled_oscillator&quot;&gt;NCO&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;future-posts&quot;&gt;Future Posts&lt;/h2&gt;

&lt;p&gt;We’ve just presented the logic behind building a basic
&lt;a href=&quot;https://en.wikipedia.org/wiki/Numerically_controlled_oscillator&quot;&gt;NCO&lt;/a&gt;.
While the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sine_wave&quot;&gt;sine wave&lt;/a&gt;
generated by this approach isn’t perfect, it may well be &lt;em&gt;good enough&lt;/em&gt;
for your project.  Should you need a higher quality
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sine_wave&quot;&gt;sine wave&lt;/a&gt;,
you may wish to know that there &lt;em&gt;are&lt;/em&gt; other/better
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sine_wave&quot;&gt;sine wave&lt;/a&gt;
generators out there beyond the &lt;a href=&quot;/dsp/2017/07/11/simplest-sinewave-generator.html&quot;&gt;simple table
lookup&lt;/a&gt;
method we’ve discussed before.&lt;/p&gt;

&lt;p&gt;As one example of doing better, you may wish to note that we’ve done nothing
to minimize the maximum error for any given table index.&lt;/p&gt;

&lt;p&gt;In a similar manner, we’ve done nothing with the rest of the &lt;code class=&quot;highlighter-rouge&quot;&gt;W-P&lt;/code&gt; fractional
bits in our &lt;code class=&quot;highlighter-rouge&quot;&gt;W&lt;/code&gt; bit
&lt;a href=&quot;https://en.wikipedia.org/wiki/Instantaneous_phase&quot;&gt;phase&lt;/a&gt;
accumulator.  These bits can be used to
&lt;a href=&quot;https://github.com/ZipCPU/interpolation/blob/master/tutorial.pdf&quot;&gt;interpolate&lt;/a&gt;
between table entries, either
&lt;a href=&quot;/dsp/2017/07/29/series-linear-interpolation.html&quot;&gt;linearly&lt;/a&gt;,
quadratically, or more as desired for better performance.&lt;/p&gt;

&lt;p&gt;These, however, will need to be left for discussions on some other day.&lt;/p&gt;
&lt;hr /&gt;&lt;p&gt;&lt;em&gt;And said, Hitherto shalt thou come, but no further: and here shall thy proud waves be stayed?  Job 38:11&lt;/em&gt;</description>
        <pubDate>Sat, 09 Dec 2017 00:00:00 -0500</pubDate>
        <link>http://zipcpu.com/dsp/2017/12/09/nco.html</link>
        <guid isPermaLink="true">http://zipcpu.com/dsp/2017/12/09/nco.html</guid>
        
        
        <category>dsp</category>
        
      </item>
    
      <item>
        <title>Testing the fast, generic FIR filter</title>
        <description>&lt;p&gt;It’s been some time now since we introduced the implementation of a pair
of generic &lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;s.
The first was a fairly &lt;a href=&quot;/dsp/2017/09/15/fastfir.html&quot;&gt;generic FIR filter
implementation&lt;/a&gt;, and the
second was a &lt;a href=&quot;/dsp/2017/09/29/cheaper-fast-fir.html&quot;&gt;“cheaper” implementation of the same
logic&lt;/a&gt;.  Both filters
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;s
were presented as though they worked, but without any test bench to prove it.
Further, these prior posts hinted at other
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;s
which might be better, but I haven’t come back to present them (yet).
(As an example, I’ve got a nice &lt;a href=&quot;https://en.wikipedia.org/wiki/Linear_phase&quot;&gt;symmetric
filter&lt;/a&gt;
implementation waiting to be present in due time.)&lt;/p&gt;

&lt;p&gt;Since that time, we’ve presented a
&lt;a href=&quot;/dsp/2017/11/04/genfil-tb.html&quot;&gt;test harness&lt;/a&gt;
that can be used to prove whether a
&lt;a href=&quot;/dsp/2017/09/15/fastfir.html&quot;&gt;generic FIR filter&lt;/a&gt; even
works.  We’ve also &lt;a href=&quot;/dsp/2017/11/22/fltr-response.html&quot;&gt;presented a component of that
harness&lt;/a&gt;
which measures the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency_response&quot;&gt;frequency response&lt;/a&gt;
of any given
&lt;a href=&quot;https://en.wikipedia.org/wiki/Finite_impulse_response&quot;&gt;FIR&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;.
Both of these were designed to demonstrate how easy it could be to determine
if an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Hardware_description_language&quot;&gt;HDL&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;
“works” when using &lt;a href=&quot;https://www.veripool.org/wiki/verilator&quot;&gt;Verilator&lt;/a&gt; as our
simulator.&lt;/p&gt;

&lt;p&gt;Today, let’s take a quick look at our
&lt;a href=&quot;/dsp/2017/09/15/fastfir.html&quot;&gt;generic filter&lt;/a&gt;
and see if this
&lt;a href=&quot;/dsp/2017/11/04/genfil-tb.html&quot;&gt;test harness&lt;/a&gt;
can make it testing any easier.  We’ll apply four basic tests:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Given all coefficients of zero save one, is the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Impulse_response&quot;&gt;impulse response&lt;/a&gt;
appropriate?&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Given all maximally valued coefficients and maximally valued inputs, will
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/genericfir.v&quot;&gt;the filter under
test&lt;/a&gt;
overflow?&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Given a set of identical and maximal coefficients, does the
&lt;a href=&quot;/dsp/2017/11/22/fltr-response.html&quot;&gt;frequency response&lt;/a&gt;
cutoff where we expect?&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Given a more &lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/bench/cpp/twelvebfltr.h&quot;&gt;practical set of
coefficients&lt;/a&gt;,
does the &lt;a href=&quot;/dsp/2017/11/22/fltr-response.html&quot;&gt;filter’s frequency
response&lt;/a&gt; function
look like it should?&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;These will be the question’s we’ll try to answer in the next section.&lt;/p&gt;

&lt;h2 id=&quot;testing-the-generic-filter&quot;&gt;Testing the Generic filter&lt;/h2&gt;

&lt;p&gt;We’ll start by working through the
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/bench/cpp/genericfir_tb.cpp&quot;&gt;test bench&lt;/a&gt;
for &lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/genericfir.v&quot;&gt;this
filter&lt;/a&gt;.
We’ve already &lt;a href=&quot;/dsp/2017/11/04/genfil-tb.html&quot;&gt;presented most of the difficult
logic&lt;/a&gt;
(&lt;a href=&quot;/dsp/2017/11/22/fltr-response.html&quot;&gt;here too&lt;/a&gt;),
so all that remains now is to create a
series of tests and apply them to
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/genericfir.v&quot;&gt;the filter&lt;/a&gt;
through our
&lt;a href=&quot;/dsp/2017/11/04/genfil-tb.html&quot;&gt;generic test harness&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The first step, though, is to define the constant parameters that
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/genericfir.v&quot;&gt;the filter&lt;/a&gt;
was &lt;a href=&quot;https://www.veripool.org/wiki/verilator&quot;&gt;verilated&lt;/a&gt;
with.  We’ve touched on the fact, over time, that I haven’t found a good way
to get module parameters into our test bench.  Instead, we’ll declare them
up top and require the user to remember to keep them in synch with &lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/genericfir.v&quot;&gt;the verilog
filter&lt;/a&gt;’s
synthesized parameters.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt;	&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;NTAPS&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;128&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt;	&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;IW&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;12&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt;	&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;TW&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;IW&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt;	&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;OW&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;IW&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;TW&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;7&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt;	&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;DELAY&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NTAPS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;//&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bits&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;These parameters are: the number of taps in implemented within &lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/genericfir.v&quot;&gt;the
filter&lt;/a&gt;,
&lt;code class=&quot;highlighter-rouge&quot;&gt;NTAPS&lt;/code&gt;, the number of bits in an inputs sample, &lt;code class=&quot;highlighter-rouge&quot;&gt;IW&lt;/code&gt;, the number of bits in
each &lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt; coefficient,
&lt;code class=&quot;highlighter-rouge&quot;&gt;TW&lt;/code&gt;, and the number of output bits.  The last parameter, &lt;code class=&quot;highlighter-rouge&quot;&gt;DELAY&lt;/code&gt;, is the number
of clocks that need to take place from the time an input is presented to
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/genericfir.v&quot;&gt;the filter&lt;/a&gt;
until the first response due to &lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/genericfir.v&quot;&gt;the
filter&lt;/a&gt;’s
&lt;a href=&quot;https://en.wikipedia.org/wiki/Impulse_response&quot;&gt;impulse response&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The next step is to set up the
&lt;a href=&quot;https://www.veripool.org/wiki/verilator&quot;&gt;Verilator&lt;/a&gt; based &lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/bench/cpp/genericfir_tb.cpp&quot;&gt;test
bench&lt;/a&gt;,
and create a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;
subclassed from the
&lt;a href=&quot;/dsp/2017/11/04/genfil-tb.html&quot;&gt;generic filter test harness&lt;/a&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;n&quot;&gt;GENERICFIR_TB&lt;/span&gt;	&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tb&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;	&lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;argc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;**&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;argv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;Verilated&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;commandArgs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;argc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;argv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;tb&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GENERICFIR_TB&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;We’ll want to test below whether or not &lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/genericfir.v&quot;&gt;the
filter&lt;/a&gt;’s
&lt;a href=&quot;https://en.wikipedia.org/wiki/Impulse_response&quot;&gt;impulse response&lt;/a&gt; is
as we think it should be.  To do this, we’ll pick values that are the absolute
maximum values.  We’ll also attempt to turn &lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/genericfir.v&quot;&gt;this
filter&lt;/a&gt;
into a
&lt;a href=&quot;/dsp/2017/10/16/boxcar.html&quot;&gt;moving averaging filter&lt;/a&gt;
later to see if we can overflow it.  Both of these require maximum constant
values.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;	&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;TAPVALUE&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;TW&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;IMPULSE&lt;/span&gt;  &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;  &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;IW&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;As a last step before beginning, we’ll allocate some memory for test vectors,
and for &lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;
coefficients we might wish to apply as part of a test.
We’ll also (optionally) open a
&lt;a href=&quot;/blog/2017/07/31/vcd.html&quot;&gt;VCD file&lt;/a&gt;
to record the internals of anything that happens.  As a final step before
beginning, we’ll issue a reset to the unit under test.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;	&lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;tapvec&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NTAPS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
	&lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;ivec&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NTAPS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;

	&lt;span class=&quot;c1&quot;&gt;// tb-&amp;gt;trace(&quot;trace.vcd&quot;);
&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;tb&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;reset&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Now for our first test set: let’s walk through all coefficients, setting a
single coefficient to &lt;code class=&quot;highlighter-rouge&quot;&gt;TAPVALUE&lt;/code&gt; at a time, and let’s see if we get the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Impulse_response&quot;&gt;impulse response&lt;/a&gt;
we are expecting.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;	&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NTAPS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;c1&quot;&gt;//
&lt;/span&gt;		&lt;span class=&quot;c1&quot;&gt;// Create a new coefficient vector
&lt;/span&gt;		&lt;span class=&quot;c1&quot;&gt;//
&lt;/span&gt;		&lt;span class=&quot;c1&quot;&gt;// Initialize it with all zeros
&lt;/span&gt;		&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NTAPS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;tapvec&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;c1&quot;&gt;// Then set one value to non-zero
&lt;/span&gt;		&lt;span class=&quot;n&quot;&gt;tapvec&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TAPVALUE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

		&lt;span class=&quot;c1&quot;&gt;// Test whether or not this coefficient vector
&lt;/span&gt;		&lt;span class=&quot;c1&quot;&gt;// loads properly into the filter
&lt;/span&gt;		&lt;span class=&quot;n&quot;&gt;tb&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;testload&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NTAPS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tapvec&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

		&lt;span class=&quot;c1&quot;&gt;// Then test whether or not the filter overflows
&lt;/span&gt;		&lt;span class=&quot;n&quot;&gt;tb&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;test_overflow&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;You may remember from
&lt;a href=&quot;/dsp/2017/11/04/genfil-tb.html&quot;&gt;when we built our&lt;/a&gt;
&lt;a href=&quot;/dsp/2017/11/04/genfil-tb.html&quot;&gt;test harness&lt;/a&gt;,
that the &lt;code class=&quot;highlighter-rouge&quot;&gt;testload&lt;/code&gt; function not only loads coefficients into &lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/genericfir.v&quot;&gt;the
filter&lt;/a&gt;,
but it also applies sufficient test vectors to
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/genericfir.v&quot;&gt;the filter&lt;/a&gt;
to know whether or not the coefficients were validly loaded as desired.  In a
similar fashion, the &lt;code class=&quot;highlighter-rouge&quot;&gt;test_overflow()&lt;/code&gt; method runs maximum (negative) values
into &lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/genericfir.v&quot;&gt;the
filter&lt;/a&gt;
to see if it can be caused to overflow.  Both routines will end in an &lt;code class=&quot;highlighter-rouge&quot;&gt;assert()&lt;/code&gt;
if something fails.&lt;/p&gt;

&lt;p&gt;For our second test, let’s set all of the coefficients to a maximum value.
This will create a
&lt;a href=&quot;/dsp/2017/10/16/boxcar.html&quot;&gt;block average filter&lt;/a&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;	&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NTAPS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;tapvec&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TAPVALUE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;We can then set &lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/genericfir.v&quot;&gt;our
filter&lt;/a&gt;’s
coefficients to be these values, and &lt;a href=&quot;/dsp/2017/11/04/genfil-tb.html&quot;&gt;double check that what we loaded
was what we wanted&lt;/a&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;	&lt;span class=&quot;n&quot;&gt;tb&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;testload&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NTAPS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tapvec&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;One of the neat parts of using a
&lt;a href=&quot;/dsp/2017/10/16/boxcar.html&quot;&gt;block filter&lt;/a&gt;
is that the filter’s response is easy to predict.  Let’s apply a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Rectangular_function&quot;&gt;rectangle function&lt;/a&gt;
to the input of
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/genericfir.v&quot;&gt;this filter&lt;/a&gt;
and verify that we get the response we are expecting.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;	&lt;span class=&quot;c1&quot;&gt;// Set every element of an array to the same value
&lt;/span&gt;	&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NTAPS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;ivec&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;IMPULSE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

	&lt;span class=&quot;c1&quot;&gt;// Now apply this vector to the filter
&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;tb&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;test&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NTAPS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ivec&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

	&lt;span class=&quot;c1&quot;&gt;// And check that it has the right response
&lt;/span&gt;	&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NTAPS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;assert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ivec&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;IMPULSE&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;TAPVALUE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;These
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;
coefficients are also the &lt;em&gt;most&lt;/em&gt; likely coefficients to overflow–since they are
all maximum valued integers for their bit-widths.  Let’s see if we can cause
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/genericfir.v&quot;&gt;this filter&lt;/a&gt;
to overflow by using these same maximal coefficients as inputs.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;	&lt;span class=&quot;n&quot;&gt;assert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tb&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;test_overflow&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;());&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;a href=&quot;/dsp/2017/11/04/genfil-tb.html&quot;&gt;As you may recall, the overflow
test&lt;/a&gt;
places inputs into
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/genericfir.v&quot;&gt;the filter&lt;/a&gt;
with maximum integer values.  It returns true if
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/genericfir.v&quot;&gt;the filter&lt;/a&gt;
passes, or false otherwise.  (Actually, it fails on an assert error if the
filter doesn’t pass here.)&lt;/p&gt;

&lt;p&gt;A &lt;a href=&quot;/dsp/2017/10/16/boxcar.html&quot;&gt;block average filter&lt;/a&gt;
should act like a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Low-pass_filter&quot;&gt;lowpass filter&lt;/a&gt;.
Let’s evaluate its
&lt;a href=&quot;/dsp/2017/11/22/fltr-response.html&quot;&gt;frequency response&lt;/a&gt;,
and see whether it matches what we might expect.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;	&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;      &lt;span class=&quot;c1&quot;&gt;// Passband frequency cutoff
&lt;/span&gt;			&lt;span class=&quot;n&quot;&gt;fs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;     &lt;span class=&quot;c1&quot;&gt;// Stopband frequency cutoff,
&lt;/span&gt;			&lt;span class=&quot;n&quot;&gt;depth&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// Depth of the stopband
&lt;/span&gt;			&lt;span class=&quot;n&quot;&gt;ripple&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Maximum deviation within the passband
&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;tb&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;measure_lowpass&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;depth&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ripple&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;FP     = %f&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;FS     = %f&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;DEPTH  = %6.2f dB&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;depth&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;RIPPLE = %.2g&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ripple&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

		&lt;span class=&quot;c1&quot;&gt;// The depth of the filter should be between -14 and -13.
&lt;/span&gt;		&lt;span class=&quot;c1&quot;&gt;// assert() that here.
&lt;/span&gt;		&lt;span class=&quot;n&quot;&gt;assert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;depth&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;13&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;assert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;depth&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;14&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;A quick check of the results, shows us that we are in the range we are
expecting.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;FP     = 0.002441
FS     = 0.006592
DEPTH  = -13.26 dB
RIPPLE = 0.34&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;In particular, a &lt;code class=&quot;highlighter-rouge&quot;&gt;13 dB&lt;/code&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Stopband&quot;&gt;stopband&lt;/a&gt;
is about as much as we might expect from any
&lt;a href=&quot;/dsp/2017/10/16/boxcar.html&quot;&gt;moving average filter&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;For a final test, let’s load
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/genericfir.v&quot;&gt;our filter&lt;/a&gt;
with a set of &lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/bench/cpp/twelvebfltr.h&quot;&gt;pre-calculated
coefficients&lt;/a&gt;
so as to implement a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Half-band_filter&quot;&gt;half-band&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Low-pass_filter&quot;&gt;lowpass filter&lt;/a&gt;.  The first
step is to load
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/bench/cpp/twelvebfltr.h&quot;&gt;these coefficients&lt;/a&gt;
into an array.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;	&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NCOEFFS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;tapvec&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;icoeffs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;

	&lt;span class=&quot;c1&quot;&gt;// In case the filter is longer than the number of taps we have,
&lt;/span&gt;	&lt;span class=&quot;c1&quot;&gt;// we&#39;ll load zero any taps beyond the filters length.
&lt;/span&gt;	&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NCOEFFS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NTAPS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;tapvec&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/bench/cpp/twelvebfltr.h&quot;&gt;This array&lt;/a&gt;
can then be loaded into
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/genericfir.v&quot;&gt;the filter&lt;/a&gt;.
Once done, we can then &lt;a href=&quot;/dsp/2017/11/04/genfil-tb.html&quot;&gt;test and verify
that&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/bench/cpp/twelvebfltr.h&quot;&gt;the coefficients&lt;/a&gt;
were loaded properly.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;	&lt;span class=&quot;n&quot;&gt;tb&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;testload&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NTAPS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tapvec&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Now that
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/genericfir.v&quot;&gt;the filter&lt;/a&gt;
has a &lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/bench/cpp/twelvebfltr.h&quot;&gt;more practical set of
coefficients&lt;/a&gt;
loaded into it, how well did we do?
Let’s &lt;a href=&quot;/dsp/2017/11/22/fltr-response.html&quot;&gt;measure&lt;/a&gt; &lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/genericfir.v&quot;&gt;the
filter&lt;/a&gt;’s
&lt;a href=&quot;/dsp/2017/11/22/fltr-response.html&quot;&gt;frequency response&lt;/a&gt;, and
report some statistics from it.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;	&lt;span class=&quot;c1&quot;&gt;// And let&#39;s check that it works by measuring its frequency response
&lt;/span&gt;	&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;      &lt;span class=&quot;c1&quot;&gt;// Passband frequency cutoff
&lt;/span&gt;			&lt;span class=&quot;n&quot;&gt;fs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;     &lt;span class=&quot;c1&quot;&gt;// Stopband frequency cutoff,
&lt;/span&gt;			&lt;span class=&quot;n&quot;&gt;depth&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// Depth of the stopband
&lt;/span&gt;			&lt;span class=&quot;n&quot;&gt;ripple&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Maximum deviation within the passband
&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;tb&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;measure_lowpass&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;depth&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ripple&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;FP     = %f&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;FS     = %f&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;DEPTH  = %6.2f dB&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;depth&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;RIPPLE = %.2g&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ripple&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

		&lt;span class=&quot;c1&quot;&gt;// The depth of this stopband should be between -55 and -54 dB
&lt;/span&gt;		&lt;span class=&quot;n&quot;&gt;assert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;depth&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;54&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;assert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;depth&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;55&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;SUCCESS&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

	&lt;span class=&quot;n&quot;&gt;exit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This will lead to the output,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;FP     = 0.232910
FS     = 0.267090
DEPTH  = -54.14 dB
RIPPLE = 0.0064&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;among other outputs.&lt;/p&gt;

&lt;p&gt;This looks much better than our prior set of coefficients, and indeed it is.
We now have about a &lt;code class=&quot;highlighter-rouge&quot;&gt;54 dB&lt;/code&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Stopband&quot;&gt;stopband&lt;/a&gt;
depth.  Further, our
&lt;a href=&quot;https://en.wikipedia.org/wiki/Passband&quot;&gt;passband&lt;/a&gt;
and
&lt;a href=&quot;https://en.wikipedia.org/wiki/Stopband&quot;&gt;stopband&lt;/a&gt; frequencies
are both centered around 1/4, just as you would expect for any
&lt;a href=&quot;https://en.wikipedia.org/wiki/Half-band_filter&quot;&gt;half-band&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;digital filter&lt;/a&gt;.
Even better, the distance from the middle of the band to the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Passband&quot;&gt;passband&lt;/a&gt;
cutoff frequency,&lt;code class=&quot;highlighter-rouge&quot;&gt;0.25-0.232910&lt;/code&gt;,
is exactly the same as the distance from the middle of the band to the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Stopband&quot;&gt;stopband&lt;/a&gt;
start, or &lt;code class=&quot;highlighter-rouge&quot;&gt;0.267090-0.25&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;You can see the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency_response&quot;&gt;frequency response&lt;/a&gt;
measured by
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/bench/cpp/filtertb.cpp&quot;&gt;this routine&lt;/a&gt;
in the charts within our &lt;a href=&quot;/dsp/2017/11/22/fltr-response.html&quot;&gt;last post on measuring the
frequency response&lt;/a&gt;
of a &lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;,
or below in Fig 1 showing the &lt;a href=&quot;/dsp/2017/11/22/fltr-response.html&quot;&gt;frequency
response&lt;/a&gt; in linear
units,&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 1. Frequency response function&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/freq-resp.png&quot; alt=&quot;A Chart of the Measured vs Calculated frequency response&quot; width=&quot;801&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;while Fig 2 below shows the
&lt;a href=&quot;/dsp/2017/11/22/fltr-response.html&quot;&gt;response&lt;/a&gt; of
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/genericfir.v&quot;&gt;this filter&lt;/a&gt;
in &lt;a href=&quot;https://en.wikipedia.org/wiki/Decibel&quot;&gt;Decibels&lt;/a&gt;.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 2. Examining a filter&#39;s frequency response in Decibel&#39;s&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/freq-resp-dB.png&quot; alt=&quot;A Chart of the Measured vs Calculated frequency response, in decibel&#39;s&quot; width=&quot;793&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;In both examples, the calculated &lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency_response&quot;&gt;frequency
response&lt;/a&gt; and our
&lt;a href=&quot;/dsp/2017/11/04/genfil-tb.html&quot;&gt;test harness&lt;/a&gt;
&lt;a href=&quot;/dsp/2017/11/22/fltr-response.html&quot;&gt;estimated frequency response&lt;/a&gt;
lie on top of each other–giving us reason to believe that our
&lt;a href=&quot;/dsp/2017/09/15/fastfir.html&quot;&gt;filter&lt;/a&gt;
performs as desired.&lt;/p&gt;

&lt;h2 id=&quot;time-for-more-filters&quot;&gt;Time for more filters!&lt;/h2&gt;

&lt;p&gt;Now that we’ve finished discussing how to test/verify a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;digital filter&lt;/a&gt;,
it’s time to build some more!  Let’s see … I’ve wanted to demonstrate a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Linear_phase&quot;&gt;symmetric filter&lt;/a&gt;
that’s been waiting on this post, the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Hilbert_transform&quot;&gt;Hilbert transform&lt;/a&gt;
should be trivial following the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Linear_phase&quot;&gt;symmetric filter&lt;/a&gt;, I’ve got a few
slower &lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;s
(fewer multiplies) that I can demo … indeed, this might only be the beginning.&lt;/p&gt;

&lt;p&gt;On the other hand, there are other CPU based topics that I’ve been ignoring,
so it might still take us some time to get to all of these new
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;digital filter&lt;/a&gt;
implementations.&lt;/p&gt;

&lt;hr /&gt;&lt;p&gt;&lt;em&gt;When your fathers tempted me, proved me, and saw my work.  (Ps 95:9)&lt;/em&gt;</description>
        <pubDate>Wed, 06 Dec 2017 00:00:00 -0500</pubDate>
        <link>http://zipcpu.com/dsp/2017/12/06/fastfir-tb.html</link>
        <guid isPermaLink="true">http://zipcpu.com/dsp/2017/12/06/fastfir-tb.html</guid>
        
        
        <category>dsp</category>
        
      </item>
    
      <item>
        <title>Thank you!</title>
        <description>&lt;p&gt;While I’d love to share with you some of the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Thanksgiving&quot;&gt;history of Thanksgiving&lt;/a&gt; here
in the U.S., I think the quote below just about sums up all I need to know
about the Thanksgiving holiday.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;In every thing give thanks: for this is the will of God in Christ Jesus
concerning you (&lt;a href=&quot;https://www.blueletterbible.org/kjv/1th/5/18&quot;&gt;1Thess 5:18&lt;/a&gt;)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;One of the Thanksgiving traditions in our family is to spend some time sharing
with others those things we are thankful for.  If you’ll permit, I’ll share
some of those things with you:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;I thank God for sending His message (the Gospel) to us by His son Jesus,
who is truly the Christ.
(&lt;a href=&quot;https://www.blueletterbible.org/kjv/heb/1/1&quot;&gt;Heb 1:1-2&lt;/a&gt;, &lt;a href=&quot;https://www.blueletterbible.org/kjv/rom/1/16&quot;&gt;Rom 1:16&lt;/a&gt;)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;I thank God for choosing to give me the grace to trust His message.
(&lt;a href=&quot;https://www.blueletterbible.org/kjv/eph/2/18&quot;&gt;Eph 2:18&lt;/a&gt;)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;I thank God for the grace He has since given me, which has
transformed me from a man who was trapped by my own sin
(&lt;a href=&quot;https://www.blueletterbible.org/kjv/jhn/8/34&quot;&gt;John 8:34&lt;/a&gt;,
&lt;a href=&quot;https://www.blueletterbible.org/kjv/rom/6/14&quot;&gt;Rom 6:14&lt;/a&gt;),
forced to sin again and again 
(&lt;a href=&quot;https://www.blueletterbible.org/kjv/rom/7/23&quot;&gt;Rom 7:23&lt;/a&gt;),
now into a man who is being transformed into His image
(&lt;a href=&quot;https://www.blueletterbible.org/kjv/2co/3/18&quot;&gt;2Cor 3:18&lt;/a&gt;).&lt;/p&gt;

    &lt;p&gt;Perhaps this needs to be understood in context.  For those who know the
&lt;a href=&quot;https://www.blueletterbible.org/kjv/ex/20/1&quot;&gt;ten commandments&lt;/a&gt;,
I have violated many if not most of them.
(&lt;a href=&quot;https://www.blueletterbible.org/kjv/mat/19/17&quot;&gt;Matt 19:17&lt;/a&gt;)
Having broken
the commandments once, I then found myself compelled to break them again
and again.  For example, once I lied to get myself out of a difficult
situation, I then found myself lying again and again–compelled to lie to
cover my last lie.  Indeed, before I found His Gospel,
I was condemned to death and an eternity of hell fire and my wicked
actions declared this to me.
(&lt;a href=&quot;https://www.blueletterbible.org/kjv/luk/13/5&quot;&gt;Luke 13:5&lt;/a&gt;)&lt;/p&gt;

    &lt;p&gt;I was once condemned by my own sin, and I knew it.&lt;/p&gt;

    &lt;p&gt;Since finding His Gospel, I have been changed
(&lt;a href=&quot;https://www.blueletterbible.org/kjv/2co/5/17&quot;&gt;2Cor 5:17&lt;/a&gt;).
I am no longer the liar that I was.  I no longer steal
(&lt;a href=&quot;https://www.blueletterbible.org/kjv/1co/6/11&quot;&gt;1Cor 6:11&lt;/a&gt;).
Instead, He has filled me with peace, with
patience, with love, joy and more.  Many of these &lt;a href=&quot;https://www.blueletterbible.org/kjv/gal/5/22&quot;&gt;unspeakable
gifts&lt;/a&gt; I never knew
I was missing.&lt;/p&gt;

    &lt;p&gt;For this, I am thankful.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;I am thankful that I even have a family.  Were it not for God’s word,
my wife and I would’ve split many years ago–long before we ever had our
first child.&lt;/p&gt;

    &lt;p&gt;If you are struggling in your marriage, may I recommend that Jesus
is a wonderful marital counselor?  Obedience to His word is what kept
my wife and I together.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;I am thankful to the God who has given me the opportunity to work on
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;s,
even when I started with a &lt;em&gt;very&lt;/em&gt; limited budget.&lt;/p&gt;

    &lt;p&gt;It’s often said that it takes money to make money.  Yet if God is
characterized as a Lord who can make money from nothing, and accepts
this description of Himself, then there’s something for
the poor to learn from Him.
(&lt;a href=&quot;https://www.blueletterbible.org/kjv/mat/25/24&quot;&gt;Matt 25:24&lt;/a&gt;)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;I am thankful to have met so many wonderful people while working on the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;,
and posting on the &lt;a href=&quot;http://zipcpu.com/&quot;&gt;ZipCPU blog&lt;/a&gt;.&lt;/p&gt;

    &lt;p&gt;Thank you to my supporters.&lt;/p&gt;

    &lt;p&gt;Thank you to everyone who has corresponded with me and encouraged me in
this endeavor.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Indeed, I have much to be thankful for.&lt;/p&gt;

&lt;h1 id=&quot;thank-you&quot;&gt;Thank you!&lt;/h1&gt;

&lt;p&gt;May I suggest you also take a moment to consider what you are thankful for?&lt;/p&gt;

&lt;p&gt;Happy Thanksgiving!&lt;/p&gt;
&lt;hr /&gt;&lt;p&gt;&lt;em&gt;O give thanks unto the LORD; for He is good: for His mercy endureth forever (Ps 136:1)&lt;/em&gt;</description>
        <pubDate>Thu, 23 Nov 2017 00:00:00 -0500</pubDate>
        <link>http://zipcpu.com/blog/2017/11/23/thankyou.html</link>
        <guid isPermaLink="true">http://zipcpu.com/blog/2017/11/23/thankyou.html</guid>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>Measuring the frequency response of a filter under test</title>
        <description>&lt;p&gt;We’ve slowly been building several
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;digital filtering&lt;/a&gt;
Verilog implementations on
&lt;a href=&quot;http://zipcpu.com/&quot;&gt;this blog&lt;/a&gt;.  For example, we’ve
&lt;a href=&quot;/dsp/2017/09/15/fastfir.html&quot;&gt;presented a generic&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Finite_impulse_response&quot;&gt;Finite Impulse Response (FIR)&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipcPU/dspfilters/blob/master/rtl/genericfir.v&quot;&gt;implementation&lt;/a&gt;,
and even a
&lt;a href=&quot;/dsp/2017/09/29/cheaper-fast-fir.html&quot;&gt;cheaper version&lt;/a&gt;
of the same.  I’d like to move forward and present some other
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;
implementations as well, but I haven’t finished presenting the test bench for
the &lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filters&lt;/a&gt;
I have presented.  Therefore, we’ve also been slowly building
up to a test bench by building a
&lt;a href=&quot;/dsp/2017/11/04/genfil-tb.html&quot;&gt;test harness&lt;/a&gt;
that we can use to prove that not only these two
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;
designs work as designed, but also that other
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;
designs we might build later work as designed.&lt;/p&gt;

&lt;p&gt;In our &lt;a href=&quot;/dsp/2017/11/04/genfil-tb.html&quot;&gt;last post discussing&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;digital filtering&lt;/a&gt;,
we presented a &lt;a href=&quot;https://github.com/ZipcPU/dspfilters/blob/master/bench/cpp/filtertb.h&quot;&gt;generic test
harness&lt;/a&gt;
that can be used when building test benches for various
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;digital logic filters&lt;/a&gt;.
&lt;a href=&quot;/dsp/2017/11/04/genfil-tb.html&quot;&gt;This test harness&lt;/a&gt;
verified a number of things regarding a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;,
to include measuring the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;’s
&lt;a href=&quot;https://en.wikipedia.org/wiki/Impulse_response&quot;&gt;impulse response&lt;/a&gt;
as well as making sure that the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;’s
internal implementation didn’t overflow.&lt;/p&gt;

&lt;p&gt;For the verification engineer, this isn’t enough.&lt;/p&gt;

&lt;p&gt;Why not?&lt;/p&gt;

&lt;table style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 1. Lowpass FIR requirements&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/fir-lpf-design.png&quot; alt=&quot;Design requirements of an LPF filter&quot; width=&quot;480&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Well simply because the &lt;em&gt;requirements&lt;/em&gt; for a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;,
such as might be shown in Fig 1,
are specified in terms of the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;’s
&lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency_response&quot;&gt;frequency response&lt;/a&gt;–&lt;em&gt;not&lt;/em&gt;
its &lt;a href=&quot;https://en.wikipedia.org/wiki/Impulse_response&quot;&gt;impulse response&lt;/a&gt;.
If you want to answer the question of whether or not a particular
implementation meets your criteria, then you need to &lt;em&gt;measure&lt;/em&gt; the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency_response&quot;&gt;frequency response&lt;/a&gt;
of the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;
you are creating.
Otherwise how will you be certain that your
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;
works as advertised?  That it accomplishes the function it was designed to
perform?&lt;/p&gt;

&lt;p&gt;Today, therefore, let’s spend some time discussing what the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency_response&quot;&gt;frequency response&lt;/a&gt; of a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;
is, why it is important, and then examine how one might go about measuring it.&lt;/p&gt;

&lt;h2 id=&quot;the-frequency-response-function&quot;&gt;The Frequency Response Function&lt;/h2&gt;

&lt;p&gt;There’s really some wonderful math underpinning
&lt;a href=&quot;https://en.wikipedia.org/wiki/Finite_impulse_response&quot;&gt;FIR&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filters&lt;/a&gt;
in general.  Perhaps you remember some of this from our earlier
&lt;a href=&quot;/dsp/2017/09/15/fastfir.html&quot;&gt;“What is a Filter” discussion&lt;/a&gt;.
Today, we’ll just outline that math, and then show how it naturally leads to
this concept of a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency_response&quot;&gt;frequency response&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The roots of an &lt;a href=&quot;https://en.wikipedia.org/wiki/Finite_impulse_response&quot;&gt;FIR&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;
lie within the concept of a &lt;a href=&quot;https://en.wikipedia.org/wiki/Linear_system&quot;&gt;linear
operation&lt;/a&gt;
on a data stream.  If that &lt;a href=&quot;https://en.wikipedia.org/wiki/Linear_system&quot;&gt;linear
operation&lt;/a&gt;,
whatever it is, also happens to be &lt;a href=&quot;https://en.wikipedia.org/wiki/Shfit-invariant_system&quot;&gt;shift
invariant&lt;/a&gt;
then the operation can be described by a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Convolution&quot;&gt;convolution&lt;/a&gt;
between the input, &lt;code class=&quot;highlighter-rouge&quot;&gt;x[n]&lt;/code&gt; and the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;’s
&lt;a href=&quot;https://en.wikipedia.org/wiki/Impulse_response&quot;&gt;impulse response&lt;/a&gt;
function, &lt;code class=&quot;highlighter-rouge&quot;&gt;h[n]&lt;/code&gt;.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/eqn-convolution-raw.png&quot; alt=&quot;Formula for an FIR Convolution&quot; width=&quot;254&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;When dealing with the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filters&lt;/a&gt;
that digital logic can create, reality lays two additional constraints onto
these &lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filters&lt;/a&gt;.
First, &lt;code class=&quot;highlighter-rouge&quot;&gt;h[k]&lt;/code&gt; for &lt;code class=&quot;highlighter-rouge&quot;&gt;k&amp;lt;0&lt;/code&gt; must be zero.  This is another way of saying that the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filters&lt;/a&gt; is
&lt;em&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Causal_filter&quot;&gt;causal&lt;/a&gt;&lt;/em&gt;–it doesn’t
know anything about inputs that haven’t yet been received.  The second
criteria is that &lt;code class=&quot;highlighter-rouge&quot;&gt;h[k]&lt;/code&gt; must be an integer (i.e.
&lt;a href=&quot;https://en.wikipedia.org/wiki/Quantization_(signal_processing)&quot;&gt;quantized&lt;/a&gt;).&lt;/p&gt;

&lt;p&gt;We’re also going to assume a third criteria for today’s discussion, which is
that &lt;code class=&quot;highlighter-rouge&quot;&gt;h[k]&lt;/code&gt; must be zero for &lt;code class=&quot;highlighter-rouge&quot;&gt;k&amp;gt;= N&lt;/code&gt; samples.  This is another way of saying
that &lt;code class=&quot;highlighter-rouge&quot;&gt;h[k]&lt;/code&gt; must only be non-zero for a &lt;em&gt;finite&lt;/em&gt; number of samples, from
&lt;code class=&quot;highlighter-rouge&quot;&gt;k=0&lt;/code&gt; to &lt;code class=&quot;highlighter-rouge&quot;&gt;k=N-1&lt;/code&gt;.  For this reason, this type of
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;
is called a &lt;a href=&quot;https://en.wikipedia.org/wiki/Finite_impulse_response&quot;&gt;Finite Impulse Response
(FIR)&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;All of this is just a quick background refresher regarding the properties
of the types of
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filters&lt;/a&gt;
we are looking at.  These properties lead into the development of the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;’s
&lt;em&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency_response&quot;&gt;frequency response&lt;/a&gt;&lt;/em&gt;
function.&lt;/p&gt;

&lt;p&gt;The idea of the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency_response&quot;&gt;frequency response&lt;/a&gt;
of a &lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;
is fairly simple: what response does the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt; return when a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Euler&#39;s_formula&quot;&gt;complex exponential&lt;/a&gt;
is fed to the &lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;
as its input.&lt;/p&gt;

&lt;p&gt;By &lt;a href=&quot;https://en.wikipedia.org/wiki/Euler&#39;s_formula&quot;&gt;complex exponential&lt;/a&gt;,
I mean more than the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Euler&#39;s_formula&quot;&gt;Euler’s formula&lt;/a&gt; Wikipedia
discusses under that term.  Instead, I am referring to a function such as&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/eqn-complex-expn.png&quot; alt=&quot;f[n] = e^{j(2pi fn + theta)}, formula for a complex exponential of unit magnitude&quot; width=&quot;189&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;This function has a unit magnitude and it steps forward by a constant phase
shift between samples.  It expands, via
&lt;a href=&quot;https://en.wikipedia.org/wiki/Euler&#39;s_formula&quot;&gt;Euler’s formula&lt;/a&gt;,
into &lt;a href=&quot;https://en.wikipedia.org/wiki/Sine_wave&quot;&gt;sine&lt;/a&gt;
and cosine components–we’ll use this property later on.&lt;/p&gt;

&lt;p&gt;So let’s find out what happens to an input of this type when our
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;
is applied to it.&lt;/p&gt;

&lt;p&gt;We’ll start with the equation for a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Linear_system&quot;&gt;linear&lt;/a&gt;,
&lt;a href=&quot;https://en.wikipedia.org/wiki/Shfit-invariant_system&quot;&gt;shift-invariant&lt;/a&gt;
system: a &lt;a href=&quot;https://en.wikipedia.org/wiki/Convolution&quot;&gt;convolution&lt;/a&gt;.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/eqn-convolution-raw.png&quot; alt=&quot;Formula for an FIR Convolution&quot; width=&quot;254&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;We’ll then replace &lt;code class=&quot;highlighter-rouge&quot;&gt;x[n]&lt;/code&gt; with a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Euler&#39;s_formula&quot;&gt;complex exponential&lt;/a&gt; function,
&lt;code class=&quot;highlighter-rouge&quot;&gt;exp(-j 2pi fn)&lt;/code&gt;, for some frequency &lt;code class=&quot;highlighter-rouge&quot;&gt;-1/2 &amp;lt; f &amp;lt; 1/2&lt;/code&gt;,&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/eqn-convolve-cpxexpn-a.png&quot; alt=&quot;Convolution with a complex exponential&quot; width=&quot;293&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;and then we’ll simplify and rearrange terms,&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/eqn-convolve-cpxexpn-b.png&quot; alt=&quot;Convolution with a complex exponential&quot; width=&quot;307&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Did you notice how, after we rearranged the terms, the summation no longer
depends upon time, &lt;code class=&quot;highlighter-rouge&quot;&gt;n&lt;/code&gt;, anymore?
Instead, the internal part of the summation depends only upon &lt;code class=&quot;highlighter-rouge&quot;&gt;k&lt;/code&gt;–the index
variable for the summation.  In other words, the value within the summation
depends upon the frequency, &lt;code class=&quot;highlighter-rouge&quot;&gt;f&lt;/code&gt;, and the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;’s
coefficients (it’s
&lt;a href=&quot;https://en.wikipedia.org/wiki/Impulse_response&quot;&gt;impulse response&lt;/a&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;h[k]&lt;/code&gt;)
alone, and once summed the value is a constant for all time, &lt;code class=&quot;highlighter-rouge&quot;&gt;n&lt;/code&gt;.  We’ll use
&lt;code class=&quot;highlighter-rouge&quot;&gt;H(e^{j2pi f})&lt;/code&gt; to represent this constant,&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/eqn-defn-frequency-response.png&quot; alt=&quot;H(e^j2pif)=sum h[k] e^-j2pi f&quot; width=&quot;307&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;This &lt;code class=&quot;highlighter-rouge&quot;&gt;H(e^{j2pi f})&lt;/code&gt; function is called the
&lt;em&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency_response&quot;&gt;frequency response&lt;/a&gt;&lt;/em&gt;
function of our
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;,
&lt;code class=&quot;highlighter-rouge&quot;&gt;h[k]&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;This &lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency_response&quot;&gt;frequency response&lt;/a&gt;
function allows us to represent the output of our
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;,
whenever the input is a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Euler&#39;s_formula&quot;&gt;complex exponential&lt;/a&gt;,
by that same input
&lt;a href=&quot;https://en.wikipedia.org/wiki/Euler&#39;s_formula&quot;&gt;complex exponential&lt;/a&gt;
times the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency_response&quot;&gt;frequency response&lt;/a&gt;
function, or&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/eqn-convolve-cpxexpn-c.png&quot; alt=&quot;Convolution with a complex exponential results in a complex exponential times the frequency response&quot; width=&quot;249&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;But, why is this so important?&lt;/p&gt;

&lt;p&gt;It’s important simply because we now have a way of describing how our
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;
interacts with its inputs in a fashion that is &lt;em&gt;independent&lt;/em&gt; of the input.
Further, the operation is a straight multiply–much simpler than the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Convolution&quot;&gt;convolution&lt;/a&gt;
we started with.  Hence, any input that can be described as a sum of
&lt;a href=&quot;https://en.wikipedia.org/wiki/Euler&#39;s_formula&quot;&gt;complex exponentials&lt;/a&gt;
(that’s all of them), will have an output which is also described by a sum of
&lt;a href=&quot;https://en.wikipedia.org/wiki/Euler&#39;s_formula&quot;&gt;complex exponentials&lt;/a&gt;–only
those exponentials will now have a weighting given by &lt;code class=&quot;highlighter-rouge&quot;&gt;H(e^{j2pi f})&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Indeed, this representation is so important that
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filters&lt;/a&gt;
are most often specified by the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency_response&quot;&gt;frequency response&lt;/a&gt;
they are required to achieve.  Determining the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency_response&quot;&gt;frequency response&lt;/a&gt;
&lt;a href=&quot;/dsp/2017/09/15/fastfir.html&quot;&gt;our filter&lt;/a&gt;
actually implements, and hence whether or not it has achieved its
design requirements, is the purpose of the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency_response&quot;&gt;frequency response&lt;/a&gt;
measurement function of our &lt;a href=&quot;/dsp/2017/11/04/genfil-tb.html&quot;&gt;generic filter test
harness&lt;/a&gt;–the
topic for today’s discussion.&lt;/p&gt;

&lt;h2 id=&quot;how-shall-we-calculate-it&quot;&gt;How shall we calculate it?&lt;/h2&gt;

&lt;p&gt;The common means of calculating the &lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency_response&quot;&gt;frequency
response&lt;/a&gt;
of a &lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt; is to take a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Fourier_transform&quot;&gt;Fourier transform&lt;/a&gt;
of its &lt;a href=&quot;https://en.wikipedia.org/wiki/Impulse_response&quot;&gt;impulse response&lt;/a&gt;.
This follows directly from the discussion above developing what a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency_response&quot;&gt;frequency response&lt;/a&gt;
is in the first place.  The &lt;a href=&quot;https://en.wikipedia.org/wiki/Fast_Fourier_transform&quot;&gt;Fast Fourier Transform
(FFT)&lt;/a&gt;
is a computationally efficient means of evaluating a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency_response&quot;&gt;frequency response&lt;/a&gt;
from an &lt;a href=&quot;https://en.wikipedia.org/wiki/Impulse_response&quot;&gt;impulse response&lt;/a&gt;.
Chances are you will need to do this as part of your
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;
design process.&lt;/p&gt;

&lt;p&gt;When you do so, you’ll want to make certain that your
&lt;a href=&quot;https://en.wikipedia.org/wiki/Fast_Fourier_transform&quot;&gt;FFT&lt;/a&gt; size is about 8-16x
greater than the number of taps
(&lt;a href=&quot;https://en.wikipedia.org/wiki/Impulse_response&quot;&gt;coefficients&lt;/a&gt;) in your
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;.
More than 16x usually doesn’t buy you anything, and anything less than 4x
hides details.  No &lt;a href=&quot;https://en.wikipedia.org/wiki/Window_function&quot;&gt;window
function&lt;/a&gt;
is required, and indeed no
&lt;a href=&quot;https://en.wikipedia.org/wiki/Window_function&quot;&gt;window function&lt;/a&gt;
should be used in this process.  The
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Impulse_response&quot;&gt;coefficients&lt;/a&gt;
themselves should have any necessary
&lt;a href=&quot;https://en.wikipedia.org/wiki/Window_function&quot;&gt;window&lt;/a&gt;
built into them.&lt;/p&gt;

&lt;p&gt;This common method works great until you want to know whether or not your
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;
as implemented achieves the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency_response&quot;&gt;frequency response&lt;/a&gt;
you are expecting.  To actually &lt;em&gt;measure&lt;/em&gt; the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency_response&quot;&gt;frequency response&lt;/a&gt; a 
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt; produces requires
actually placing a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Euler&#39;s_formula&quot;&gt;complex exponential&lt;/a&gt;
input into the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;,
and then plotting the output that you receive as a result.  The details of
how to do this using
&lt;a href=&quot;https://www.veripool.org/wiki/verilator&quot;&gt;Verilator&lt;/a&gt;
will be discussed in our next section.&lt;/p&gt;

&lt;h2 id=&quot;filter-harness-code-for-measuring-the-frequency-response-of-a-filter&quot;&gt;Filter Harness Code for measuring the Frequency Response of a Filter&lt;/h2&gt;

&lt;p&gt;At this point, we’ve now explained both what a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;’s
&lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency_response&quot;&gt;frequency response&lt;/a&gt;
function is, as well as how it is commonly calculated (not measured).  Let’s
now look into how we might actually &lt;em&gt;measure&lt;/em&gt; this
&lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency_response&quot;&gt;frequency response&lt;/a&gt;
given a particular &lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;’s
implementation that may, or may not, be working.&lt;/p&gt;

&lt;p&gt;Since the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;
implementations we are working with are all
&lt;a href=&quot;https://en.wikipedia.org/wiki/Real_number&quot;&gt;real&lt;/a&gt;
implementations, then we’ll have to do a touch of pre-work in order to estimate
their &lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency_response&quot;&gt;frequency response&lt;/a&gt;
to a &lt;a href=&quot;https://en.wikipedia.org/wiki/Euler&#39;s_formula&quot;&gt;complex exponential&lt;/a&gt;
input.&lt;/p&gt;

&lt;p&gt;The first part of this pre-work will be to deal with the phase of our
measurement.  You may recall from above that if&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/eqn-x-is-cpxexpn.png&quot; alt=&quot;x[n] = exp^j2pi fn&quot; width=&quot;127&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;then&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/eqn-convolve-cpxexpn-c.png&quot; alt=&quot;Recap eqns above&quot; width=&quot;249&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;For our testing below, we’ll define &lt;code class=&quot;highlighter-rouge&quot;&gt;x[0]&lt;/code&gt; to be the first sample in any
individual test.  Yes, I know, this redefines time zero from one test input
to the next, but it does make a good reference for developing the inputs.
What this means, though, is that &lt;code class=&quot;highlighter-rouge&quot;&gt;y[n]&lt;/code&gt; isn’t defined entirely by our new
values until &lt;code class=&quot;highlighter-rouge&quot;&gt;y[N-1]&lt;/code&gt;
since anything earlier would reference an &lt;code class=&quot;highlighter-rouge&quot;&gt;x[n]&lt;/code&gt; with &lt;code class=&quot;highlighter-rouge&quot;&gt;n&amp;lt;0&lt;/code&gt; that might have
been part of our last test vector.  Worse,
the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency_response&quot;&gt;response&lt;/a&gt;
at &lt;code class=&quot;highlighter-rouge&quot;&gt;y[N-1]&lt;/code&gt; has a phase term within it in addition to the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency_response&quot;&gt;frequency response&lt;/a&gt;
term we want.&lt;/p&gt;

&lt;p&gt;This initial phase term needs to be removed if we want to measure &lt;code class=&quot;highlighter-rouge&quot;&gt;H(e^j2pi f)&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;So let’s suppose we instead provided an input of&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/eqn-x-is-cpxexpn-w-phase.png&quot; alt=&quot;x=e^j2pifn + phi&quot; width=&quot;184&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Our output at &lt;code class=&quot;highlighter-rouge&quot;&gt;y[N-1]&lt;/code&gt; would then be&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/eqn-convolve-cpxexpn-f.png&quot; alt=&quot;y[n]=e^j2pifn e^jphi H()&quot; width=&quot;375&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;If we define &lt;code class=&quot;highlighter-rouge&quot;&gt;phi&lt;/code&gt; to be&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/eqn-phi-cancels-cpxexpn.png&quot; alt=&quot;phi=-j2pif(N-1)&quot; width=&quot;211&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;then&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/eqn-y-is-freq-response.png&quot; alt=&quot;y[N-1]=H()&quot; width=&quot;246&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;as desired.&lt;/p&gt;

&lt;p&gt;The next problem to deal with is the fact that our filter is only
&lt;a href=&quot;https://en.wikipedia.org/wiki/Real_number&quot;&gt;real&lt;/a&gt;
valued: both the inputs, the coefficients, and the multiplies only
work on
&lt;a href=&quot;https://en.wikipedia.org/wiki/Real_number&quot;&gt;real&lt;/a&gt;
numbers.  How then shall we get the results from a complex operation?
In this case, we need to break &lt;code class=&quot;highlighter-rouge&quot;&gt;H(e^{j2pi f})&lt;/code&gt; into it’s
&lt;a href=&quot;https://en.wikipedia.org/wiki/Real_number&quot;&gt;real&lt;/a&gt;
and
&lt;a href=&quot;https://en.wikipedia.org/wiki/Imaginary_number&quot;&gt;imaginary&lt;/a&gt;
components using
&lt;a href=&quot;https://en.wikipedia.org/wiki/Euler&#39;s_formula&quot;&gt;Euler’s formula&lt;/a&gt;:&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/eqn-y-is-freq-response-split.png&quot; alt=&quot;y[N-1]=RH()+IH()&quot; width=&quot;482&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;These two terms contain only &lt;a href=&quot;https://en.wikipedia.org/wiki/Real_number&quot;&gt;real&lt;/a&gt;
numbers and &lt;a href=&quot;https://en.wikipedia.org/wiki/Real_number&quot;&gt;real&lt;/a&gt;
operators, even though the measured result will be complex.  The first term
has a cosine wave as an input, the second a &lt;a href=&quot;https://en.wikipedia.org/wiki/Sine_wave&quot;&gt;sine
wave&lt;/a&gt;.
The second term needs to be multiplied by &lt;code class=&quot;highlighter-rouge&quot;&gt;j&lt;/code&gt;, the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Imaginary_number&quot;&gt;square root of negative one&lt;/a&gt;,
upon completion.  However, by splitting this filter into two parts, one for
the &lt;a href=&quot;https://en.wikipedia.org/wiki/Real_number&quot;&gt;real&lt;/a&gt;
part of the input and one for the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Imaginary_number&quot;&gt;imaginary&lt;/a&gt;
part of the input, we can now generate this complex value with two
test vectors–both of which are
&lt;a href=&quot;https://en.wikipedia.org/wiki/Real_number&quot;&gt;real&lt;/a&gt; and so both of which
&lt;a href=&quot;/dsp/2017/09/15/fastfir.html&quot;&gt;our implementation&lt;/a&gt;
can process.&lt;/p&gt;

&lt;p&gt;Hence, for every frequency we are interested in (except zero), we’ll apply
two test vectors to our input and examine the resulting output.&lt;/p&gt;

&lt;p&gt;Now that we have a vision for how to proceed, it’s now time to build our
&lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency_response&quot;&gt;frequency response&lt;/a&gt;
estimation function.  This will be part of the
&lt;a href=&quot;https://www.veripool.org/wiki/verilator&quot;&gt;Verilator&lt;/a&gt; based &lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/bench/cpp/filtertb.cpp&quot;&gt;test
harness&lt;/a&gt;
&lt;a href=&quot;/dsp/2017/11/04/genfil-tb.html&quot;&gt;we discussed earlier&lt;/a&gt;.
As such, it is a C++ function (not a Verilog module),
but yet we will use it to evaluate our &lt;a href=&quot;https://github.com/ZipCPU/dspfilters/tree/master/rtl&quot;&gt;various Verilog filter
implementations&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Further, we’ll build this response estimator using the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;
&lt;a href=&quot;/dsp/2017/11/04/genfil-tb.html&quot;&gt;test harness&lt;/a&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;apply()&lt;/code&gt; function–a function that returns the response of the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;
to a given test input.  As
&lt;a href=&quot;/dsp/2017/11/04/genfil-tb.html&quot;&gt;we discussed last time&lt;/a&gt;,
this function differs from the similar &lt;code class=&quot;highlighter-rouge&quot;&gt;test()&lt;/code&gt; function in some critical ways.
First, the &lt;code class=&quot;highlighter-rouge&quot;&gt;test()&lt;/code&gt; function resets the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;
to a known initial state, whereas &lt;code class=&quot;highlighter-rouge&quot;&gt;apply()&lt;/code&gt; just uses the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;
in the state it was last left in.  Second, the &lt;code class=&quot;highlighter-rouge&quot;&gt;test()&lt;/code&gt; function quietly adds
input samples to compensate for any delay internal to the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;,
whereas the &lt;code class=&quot;highlighter-rouge&quot;&gt;apply()&lt;/code&gt; function does not.  As a result, we’ll need to add these
extra samples ourselves below.  Still, using the &lt;code class=&quot;highlighter-rouge&quot;&gt;apply()&lt;/code&gt; function will give
us some confidence that the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;
will properly and naturally flush its state from one input to the
next–something the rest of the
&lt;a href=&quot;/dsp/2017/11/04/genfil-tb.html&quot;&gt;test harness&lt;/a&gt;
has yet to verify.&lt;/p&gt;

&lt;p&gt;The parameters to this function are much as you might expect.  There’s the
number of frequencies, &lt;code class=&quot;highlighter-rouge&quot;&gt;nfreq&lt;/code&gt;, that you’d like to use to cover the frequency
band from &lt;code class=&quot;highlighter-rouge&quot;&gt;0&lt;/code&gt; to the &lt;a href=&quot;https://en.wikipedia.org/wiki/Nyquist_frequency&quot;&gt;Nyquist
frequency&lt;/a&gt;,
&lt;code class=&quot;highlighter-rouge&quot;&gt;1/2&lt;/code&gt;.  As I mentiond above, this number should be between 8x and 16x the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;’s
length.  There’s also a
&lt;a href=&quot;http://en.cppreference.com/w/cpp/numeric/complex&quot;&gt;complex&lt;/a&gt;
array pointer, &lt;code class=&quot;highlighter-rouge&quot;&gt;rvec&lt;/code&gt;, to hold the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency_response&quot;&gt;frequency response&lt;/a&gt;
once it’s been estimated.
Those are both straightforward.  Likewise the optional filename, &lt;code class=&quot;highlighter-rouge&quot;&gt;fname&lt;/code&gt;, to
save any results into is also straightforward.  Perhaps the only remarkable
item is the magnitude of the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sine_wave&quot;&gt;sine wave&lt;/a&gt;,
captured in &lt;code class=&quot;highlighter-rouge&quot;&gt;mag&lt;/code&gt;.  A &lt;code class=&quot;highlighter-rouge&quot;&gt;mag&lt;/code&gt; of &lt;code class=&quot;highlighter-rouge&quot;&gt;1.0&lt;/code&gt; will cause us to create a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sine_wave&quot;&gt;sine wave&lt;/a&gt;
having the maximum integer magnitude the number of input bits, &lt;code class=&quot;highlighter-rouge&quot;&gt;IW&lt;/code&gt;, will
allow.  Anything less than one will scale the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sine_wave&quot;&gt;sine&lt;/a&gt;
and cosine waves proportionally.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;k&quot;&gt;template&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;VFLTR&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;FILTERTB&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;VFLTR&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;response&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nfreq&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;COMPLEX&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rvec&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mag&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fname&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;We’ll need to declare some variables to make this happen.  The first,
&lt;code class=&quot;highlighter-rouge&quot;&gt;nlen&lt;/code&gt; is the number of coefficients in our
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;.
The next, &lt;code class=&quot;highlighter-rouge&quot;&gt;dlen&lt;/code&gt;,
is the same but captures the number of data samples we’ll need to send to
&lt;code class=&quot;highlighter-rouge&quot;&gt;apply()&lt;/code&gt; and so it requires the number of delay cycles between
any input sample and the first associated output from the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;.
We’ll use the &lt;code class=&quot;highlighter-rouge&quot;&gt;data&lt;/code&gt; pointer to point to an
array into which we can store both our outgoing data (test vectors to be sent
to the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;),
and incoming data (the response from the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;
to the test vector).  Finally, &lt;code class=&quot;highlighter-rouge&quot;&gt;df&lt;/code&gt; will hold the value of our frequency step
size.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;	&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;nlen&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NTAPS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dlen&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NTAPS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NDELAY&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
	&lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt;	&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dlen&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
	&lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;df&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;1.&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nfreq&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;2.&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;As we discussed above, &lt;code class=&quot;highlighter-rouge&quot;&gt;mag&lt;/code&gt; is the requested magnitude of the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sine_wave&quot;&gt;sine wave&lt;/a&gt;
test vector, running from 0.0 to 1.0.  We’ll use that number here to scale the
actual magnitude we’ll use for our
&lt;a href=&quot;https://en.wikipedia.org/wiki/Euler&#39;s_formula&quot;&gt;complex exponential&lt;/a&gt;
input vectors.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;	&lt;span class=&quot;n&quot;&gt;mag&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mag&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;IW&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;At this point, we can start walking through frequencies and making measurements.
As I mentioned above, this isn’t the most efficient means of &lt;em&gt;calculating&lt;/em&gt; a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;’s
&lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency_response&quot;&gt;frequency response&lt;/a&gt;,
but this will be a means of &lt;em&gt;measuring&lt;/em&gt; it.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;dtheta&lt;/code&gt; is the phase difference from one
&lt;a href=&quot;https://en.wikipedia.org/wiki/Euler&#39;s_formula&quot;&gt;complex exponential&lt;/a&gt;
sample to the next.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;	&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nfreq&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;dtheta&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;2.0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;M_PI&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;df&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;theta&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;0.&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;We’ll begin our
&lt;a href=&quot;https://en.wikipedia.org/wiki/Euler&#39;s_formula&quot;&gt;complex exponential&lt;/a&gt;
sample sequence at the phase we calculated above.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;		&lt;span class=&quot;n&quot;&gt;theta&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NTAPS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dtheta&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Then we’ll walk through the input vector and set it based upon a cosine
function.  This test vector should give us one
&lt;a href=&quot;https://en.wikipedia.org/wiki/Real_number&quot;&gt;real&lt;/a&gt;
component of the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;’s
&lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency_response&quot;&gt;frequency response&lt;/a&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;		&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dlen&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
			&lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;dv&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mag&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cos&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;theta&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

			&lt;span class=&quot;n&quot;&gt;theta&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dtheta&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Once we &lt;code class=&quot;highlighter-rouge&quot;&gt;apply()&lt;/code&gt; the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt; to this
test vector, we’ll know the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Real_number&quot;&gt;real&lt;/a&gt;
component of the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency_response&quot;&gt;frequency response&lt;/a&gt;
at this particular frequency.  Note how we remove the magnitude scale
factor below as well.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;		&lt;span class=&quot;n&quot;&gt;apply&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dlen&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;real&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rvec&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;  &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dlen&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mag&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;We can then repeat this same process for the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sine_wave&quot;&gt;sine wave&lt;/a&gt; input
in order to get
the &lt;a href=&quot;https://en.wikipedia.org/wiki/Imaginary_number&quot;&gt;imaginary&lt;/a&gt;
component of our measured
&lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency_response&quot;&gt;frequency response&lt;/a&gt;.
We’ll do this for all but the zero frequency, which
is already known to be zero for any
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt; with
&lt;a href=&quot;https://en.wikipedia.org/wiki/Real_number&quot;&gt;real&lt;/a&gt;
coefficients.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;		&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
			&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;debug&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;cm&quot;&gt;/* ... */&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

			&lt;span class=&quot;n&quot;&gt;theta&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NTAPS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dtheta&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
			&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dlen&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
				&lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;dv&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mag&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;theta&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

				&lt;span class=&quot;n&quot;&gt;theta&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dtheta&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
				&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
			&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

			&lt;span class=&quot;n&quot;&gt;apply&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dlen&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;imag&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rvec&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;  &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dlen&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mag&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;imag&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rvec&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Once we finish our loop across frequencies, all that’s left is to close up,
free any data we’ve allocated, and we’re done.  This includes writing the
measured
&lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency_response&quot;&gt;frequency response&lt;/a&gt;
out to a file–but that section is &lt;a href=&quot;/dsp/2017/07/24/dsp-debugging.html&quot;&gt;simple enough that we can skip any
discussion&lt;/a&gt;
of that part.  See the &lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/bench/cpp/filtertb.cpp&quot;&gt;code for the overall test harness&lt;/a&gt;,
or the &lt;a href=&quot;/dsp/2017/07/24/dsp-debugging.html&quot;&gt;discussion of how to debug a DSP
algorithm&lt;/a&gt;
should you have any questions about this step.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;		&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;debug&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;cm&quot;&gt;/* ... */&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

	&lt;span class=&quot;k&quot;&gt;delete&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;// ...
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h2 id=&quot;how-well-does-this-approach-work&quot;&gt;How well does this approach work?&lt;/h2&gt;

&lt;p&gt;Fig 2 below compares three
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency_response&quot;&gt;frequency response&lt;/a&gt;
functions against each other.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 2. An example estimated frequency response&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/freq-resp.png&quot; alt=&quot;A Chart of the Measured vs Calculated frequency response&quot; width=&quot;801&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;All three are measures of the same
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt; coefficients,
only measured in different fashions.  The first, the estimated response, is the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency_response&quot;&gt;frequency response&lt;/a&gt;
derived from the &lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency_response&quot;&gt;frequency
response&lt;/a&gt; &lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/bench/cpp/filtertb.cpp&quot;&gt;estimation
code&lt;/a&gt;
we just presented above.  The second is the result of an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Fast_Fourier_transform&quot;&gt;FFT&lt;/a&gt;
applied to the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;’s
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/bench/cpp/twelvebfltr.m&quot;&gt;coefficients&lt;/a&gt;.  The third line above shows the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;,
as designed, but before we truncated any of the coefficients
to twelve bits.&lt;/p&gt;

&lt;p&gt;Perhaps a more revealing chart, however, would be Fig 3 below, which compares the same functions in
&lt;a href=&quot;https://en.wikipedia.org/wiki/Decibel&quot;&gt;Decibels&lt;/a&gt;.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 3. Examining a filter&#39;s frequency response in Decibel&#39;s&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/freq-resp-dB.png&quot; alt=&quot;A Chart of the Measured vs Calculated frequency response, in decibel&#39;s&quot; width=&quot;793&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;In this example, you can see the effect that truncating the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;’s
coefficients had on our initial design.&lt;/p&gt;

&lt;p&gt;In both examples, however, the calculated and the estimated charts lie on
top of each other–giving us reason to believe that our &lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/bench/cpp/filtertb.cpp&quot;&gt;method
above&lt;/a&gt;
is trustworthy.&lt;/p&gt;

&lt;p&gt;However, we’ll need to come back to this another day to discuss how to
actually implement and test this on a particular
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;.
In particular, we’ll apply this &lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/bench/cpp/filtertb.cpp&quot;&gt;generic test harness&lt;/a&gt;
to our &lt;a href=&quot;/dsp/2017/09/15/fastfir.html&quot;&gt;generic filter&lt;/a&gt;.
Indeed, that’s been our whole purpose all along: generating the testing
infrastructure we’ll need to know that an implemented
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;
will work as designed.&lt;/p&gt;

&lt;p&gt;Until that point, let me quickly ask, did you notice how our test vectors
above used &lt;em&gt;quantized&lt;/em&gt; sine and cosine’s?  Given that the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;
itself is
&lt;a href=&quot;/dsp/2017/09/27/quantization.html&quot;&gt;quantized&lt;/a&gt;, it really
only makes sense that we would provide it with
&lt;a href=&quot;/dsp/2017/09/27/quantization.html&quot;&gt;quantized&lt;/a&gt;
inputs.  Be aware that, as a result, the measured
&lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency_response&quot;&gt;frequency response&lt;/a&gt;
may differ from the predicted or calculated
&lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency_response&quot;&gt;frequency response&lt;/a&gt;–even
though it didn’t clearly differ in Figures 2 or 3 above.&lt;/p&gt;

&lt;p&gt;Once we’ve proven that our
&lt;a href=&quot;/dsp/2017/09/15/fastfir.html&quot;&gt;generic filter&lt;/a&gt;
does indeed work as designed, we can then move on and develop some of the
more complicated filters.&lt;/p&gt;
&lt;hr /&gt;&lt;p&gt;&lt;em&gt;Lest haply, after he hath laid the foundation, and is not able to finish it, all that behold it begin to mock him (Luke 14:29)&lt;/em&gt;</description>
        <pubDate>Wed, 22 Nov 2017 00:00:00 -0500</pubDate>
        <link>http://zipcpu.com/dsp/2017/11/22/fltr-response.html</link>
        <guid isPermaLink="true">http://zipcpu.com/dsp/2017/11/22/fltr-response.html</guid>
        
        
        <category>dsp</category>
        
      </item>
    
      <item>
        <title>Building a prefetch module for the ZipCPU</title>
        <description>&lt;table style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 1: Fundamental CPU loop&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/cpu-basic-loop.svg&quot; alt=&quot;CPU Loop: Read instruction, do instruction, repeat&quot; width=&quot;240&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;At its most basic level, any
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;
works by fetching instructions from memory,
acting upon those instructions, and repeating the process over and over
again as shown in Fig 1.  The &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
is no different.  It also needs to fetch instructions from memory and then act
upon them in a tight loop.&lt;/p&gt;

&lt;p&gt;However, while the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; accomplishes
this same basic loop, the
&lt;a href=&quot;/zipcpu/2017/08/23/cpu-pipeline.html&quot;&gt;pipelining&lt;/a&gt;
within the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt; might render these steps
a touch more difficult to recognize.  Indeed, the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; splits up the “do-instruction”
into multiple pipeline steps,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;while (!halted)
	Fetch instruction
	Decode instruction
	Read operand registers
	Do instruction
	Write results to registers&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;as illustrated in Fig 2.&lt;/p&gt;

&lt;table style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 2: The ZipCPU Pipeline Structure&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/zipcpu.png&quot; alt=&quot;ZipCPU Pipeline Structurre&quot; width=&quot;380&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;We’ve &lt;a href=&quot;/zipcpu/2017/08/11/simple-alu.html&quot;&gt;already discussed&lt;/a&gt;
how the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
handles the &lt;em&gt;do instruction&lt;/em&gt; stage within its &lt;a href=&quot;/zipcpu/2017/08/11/simple-alu.html&quot;&gt;arithmetic logic
unit&lt;/a&gt;.
We’ve also discussed how the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
handles the &lt;a href=&quot;/zipcpu/2017/08/23/cpu-pipeline.html&quot;&gt;signaling between its pipeline
stages&lt;/a&gt;.
What we haven’t discussed is how the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
reads instructions from memory.  This is accomplished by the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Prefetching&quot;&gt;prefetch&lt;/a&gt; unit.&lt;/p&gt;

&lt;p&gt;The &lt;a href=&quot;https://en.wikipedia.org/wiki/Prefetching&quot;&gt;prefetch&lt;/a&gt; is that portion of a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt; that reads
instructions from memory and presents those instructions to the rest of the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt; for
execution.  While today’s &lt;a href=&quot;https://en.wikipedia.org/wiki/Prefetching&quot;&gt;Wikipedia&lt;/a&gt;
author’s argue that there’s a difference between an instruction fetch, which
gets the next instruction from memory, and a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Prefetching&quot;&gt;prefetch&lt;/a&gt;, which fetches an
instruction before it is needed, I’m going to equate the two terms under the
single name &lt;a href=&quot;https://en.wikipedia.org/wiki/Prefetching&quot;&gt;prefetch&lt;/a&gt; for
simplicity.  The result of this abuse of terminology will be that I can describe
all instruction fetch modules with the same term, but also that this subtle
difference in meaning will be lost.&lt;/p&gt;

&lt;p&gt;Using this common term, the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Prefetching&quot;&gt;prefetch&lt;/a&gt; is a critical
component of any &lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;
because the &lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;
can only run as fast as it has instructions.  A good
&lt;a href=&quot;https://en.wikipedia.org/wiki/Prefetching&quot;&gt;prefetch&lt;/a&gt;
unit, therefore, is optimized to keep the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;’s
pipeline filled with instructions.&lt;/p&gt;

&lt;p&gt;The &lt;a href=&quot;https://en.wikipedia.org/wiki/Prefetching&quot;&gt;prefetch&lt;/a&gt; is so important to
how the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; runs that the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; has had four
&lt;a href=&quot;https://en.wikipedia.org/wiki/Prefetching&quot;&gt;prefetch&lt;/a&gt;
units over time.  The first of these,
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/dev/rtl/core/prefetch.v&quot;&gt;prefetch.v&lt;/a&gt;,
simply fetches a single instruction and waits for the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;
to ask for the next instruction.  This is the code we shall discuss below.
The &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/dev/rtl/core/pipefetch.v&quot;&gt;next prefetch
version&lt;/a&gt;
tried to keep the
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;Wishbone&lt;/a&gt;
pipeline full with memory requests while
&lt;a href=&quot;https://en.wikipedia.org/wiki/Cache_(computing)&quot;&gt;caching&lt;/a&gt;
a window of memory.  This
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/dev/rtl/core/pipefetch.v&quot;&gt;prefetch&lt;/a&gt;
has since been abandoned in favor of a more traditional
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/dev/rtl/core/pfcache.v&quot;&gt;combined prefetch and instruction cache
version&lt;/a&gt;.
(The &lt;a href=&quot;https://en.wikipedia.org/wiki/Dhrystone&quot;&gt;Dhrystone&lt;/a&gt;
benchmark was part of the motivation for this change.) The &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/dev/rtl/core/dblfetch.v&quot;&gt;fourth
version&lt;/a&gt;,
one that fetches two instructions at a time, was written
recently for a &lt;a href=&quot;https://github.com/ZipCPU/s6soc&quot;&gt;low logic application&lt;/a&gt;.
It improves upon the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/dev/rtl/core/prefetch.v&quot;&gt;simple
prefetch&lt;/a&gt;
by fetching two instructions back to back.&lt;/p&gt;

&lt;p&gt;Today, though, we’re going to discuss the first of these
&lt;a href=&quot;https://en.wikipedia.org/wiki/Prefetching&quot;&gt;prefetch&lt;/a&gt;
units–the one that fetches only a single instruction at a time.
The &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; can be caused to use this
&lt;a href=&quot;https://en.wikipedia.org/wiki/Prefetching&quot;&gt;prefetch&lt;/a&gt;
routine by defining the &lt;code class=&quot;highlighter-rouge&quot;&gt;OPT_SINGLE_FETCH&lt;/code&gt; option within the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/dev/rtl/cpudefs.v&quot;&gt;cpudefs.h&lt;/a&gt;
file.
Going from this &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/dev/rtl/core/prefetch.v&quot;&gt;simple
prefetch&lt;/a&gt;
to a &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/dev/rtl/core/pfcache.v&quot;&gt;better
prefetch&lt;/a&gt;
requires adding a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Cache_(computing)&quot;&gt;cache&lt;/a&gt;
and some other things–but it’s still built upon the basis of how to build a
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/dev/rtl/core/prefetch.v&quot;&gt;single-instruction prefetch
unit&lt;/a&gt;
in the first place.  For these reasons, the simple
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/dev/rtl/core/prefetch.v&quot;&gt;single-instruction
prefetch&lt;/a&gt;
is well worth studying and understanding.&lt;/p&gt;

&lt;p&gt;Further, since the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;’s
&lt;a href=&quot;https://en.wikipedia.org/wiki/Prefetching&quot;&gt;prefetch&lt;/a&gt; module is a
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;Wishbone master&lt;/a&gt;,
this will be another opportunity to discuss how to build a
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;Wishbone master&lt;/a&gt;
interface.  While the &lt;a href=&quot;/zipcpu/2017/05/29/simple-wishbone.html&quot;&gt;Wishbone slave
interface&lt;/a&gt;
is fairly simple, the
&lt;a href=&quot;/blog/2017/06/08/simple-wb-master.html&quot;&gt;master interface&lt;/a&gt;
can be a touch more complicated.  When we’re done, we’ll even
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formally prove&lt;/a&gt;
that this interface works, thus showing you how to build a more generic
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;Wishbone master&lt;/a&gt;.
(We presented another version of
&lt;a href=&quot;/blog/2017/06/08/simple-wb-master.html&quot;&gt;how to build a Wishbone
master&lt;/a&gt;
earlier, as part of our
&lt;a href=&quot;https://github.com/ZipCPU/dbgbus/tree/master/hexbus&quot;&gt;debugging bus&lt;/a&gt;
discussion.)&lt;/p&gt;

&lt;h2 id=&quot;the-cpu-interface&quot;&gt;The CPU Interface&lt;/h2&gt;

&lt;p&gt;Any &lt;a href=&quot;https://en.wikipedia.org/wiki/Prefetching&quot;&gt;prefetch&lt;/a&gt; module
must support two interfaces: both an interface to memory, as well as
an interface to the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;.
Both of these interfaces are shown in Fig 3.&lt;/p&gt;

&lt;table style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 3: The two interfaces to a prefetch&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/prefetch-interface.svg&quot; alt=&quot;A prefetch must support both an interface to a CPU and an interface to memory&quot; width=&quot;380&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;We discussed the
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;Wishbone interface&lt;/a&gt;
at length in an earlier article.  Today, we’ll introduce the interface with the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;.
If you remember our prior discussion on &lt;a href=&quot;/blog/2017/08/14/strategies-for-pipelining.html&quot;&gt;pipeline
strategies&lt;/a&gt;,
then you will probably recognize several examples of handshaking
between pipeline stages as we go along.&lt;/p&gt;

&lt;p&gt;Internally, a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;
keeps track of the address of the next instruction in a register known as the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Program_counter&quot;&gt;program counter&lt;/a&gt;.  This
counter normally changes in a one-up fashion from one instruction to the next.
The common exception to this rule is when a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Branch_(computer_science)&quot;&gt;branch&lt;/a&gt;
takes place.  Such a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Branch_(computer_science)&quot;&gt;branch&lt;/a&gt;
may be the result of a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Branch_(computer_science)&quot;&gt;branch&lt;/a&gt;
instruction, a jump to an &lt;a href=&quot;https://en.wikipedia.org/wiki/Interrupt_handler&quot;&gt;interrupt service routine
(ISR)&lt;/a&gt;,
or even a &lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;
reset request.  In all of these examples, the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;
needs to command a memory read from a brand-new address of the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Prefetching&quot;&gt;prefetch&lt;/a&gt; unit.&lt;/p&gt;

&lt;p&gt;Well, not quite.  If you look through the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;’s
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;source code&lt;/a&gt;,
you’ll find the address of the “current” instruction wandering
through the various pipeline stages as one of several registers:
&lt;code class=&quot;highlighter-rouge&quot;&gt;pf_pc&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;pf_instruction_pc&lt;/code&gt;,
&lt;code class=&quot;highlighter-rouge&quot;&gt;dcd_pc&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;op_pc&lt;/code&gt;, and &lt;code class=&quot;highlighter-rouge&quot;&gt;alu_pc&lt;/code&gt;.  The actual register that stores the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Program_counter&quot;&gt;PC&lt;/a&gt; upon instruction
completion is either the &lt;code class=&quot;highlighter-rouge&quot;&gt;ipc&lt;/code&gt; (supervisor 
&lt;a href=&quot;https://en.wikipedia.org/wiki/Program_counter&quot;&gt;PC&lt;/a&gt; register) or the
&lt;code class=&quot;highlighter-rouge&quot;&gt;upc&lt;/code&gt; (user &lt;a href=&quot;https://en.wikipedia.org/wiki/Program_counter&quot;&gt;PC&lt;/a&gt; register).
Inside the prefetch, the &lt;code class=&quot;highlighter-rouge&quot;&gt;pf_pc&lt;/code&gt; is renamed as the 
&lt;a href=&quot;https://en.wikipedia.org/wiki/Program_counter&quot;&gt;PC&lt;/a&gt; address request, &lt;code class=&quot;highlighter-rouge&quot;&gt;i_pc&lt;/code&gt;,
and the address of the returned instruction, &lt;code class=&quot;highlighter-rouge&quot;&gt;o_pc&lt;/code&gt;, is relabeled within
the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
as &lt;code class=&quot;highlighter-rouge&quot;&gt;pf_instruction_pc&lt;/code&gt;.&lt;/p&gt;

&lt;table style=&quot;float: left&quot;&gt;&lt;caption&gt;Fig 4: The Prefetch State Machine&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/prefetch-single-flowchart.svg&quot; alt=&quot;The simple one instruction prefetch state diagram&quot; width=&quot;320&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;From the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/dev/rtl/core/prefetch.v&quot;&gt;prefetch&lt;/a&gt;’s
side of this interaction, nothing begins until the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
raises the &lt;code class=&quot;highlighter-rouge&quot;&gt;i_new_pc&lt;/code&gt; signal.  When this signal is valid, the address of
the instruction that the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
wants is captured in the &lt;code class=&quot;highlighter-rouge&quot;&gt;i_pc&lt;/code&gt; input.  The
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/dev/rtl/core/prefetch.v&quot;&gt;prefetch&lt;/a&gt;
must respond to this input by fetching the instruction from the memory
address given by this &lt;code class=&quot;highlighter-rouge&quot;&gt;i_pc&lt;/code&gt; input.&lt;/p&gt;

&lt;p&gt;Once the new instruction has been read, the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/dev/rtl/core/prefetch.v&quot;&gt;prefetch&lt;/a&gt;
needs to do several things.  First, it places that new instruction in the
&lt;code class=&quot;highlighter-rouge&quot;&gt;o_insn&lt;/code&gt; output.  Second, it places the instruction’s address into the &lt;code class=&quot;highlighter-rouge&quot;&gt;o_pc&lt;/code&gt;
register.  Finally, it sets the &lt;code class=&quot;highlighter-rouge&quot;&gt;o_valid&lt;/code&gt; flag to let the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
know that there’s a valid instruction ready for it.  This flag is part of
a &lt;a href=&quot;/zipcpu/2017/08/23/cpu-pipeline.html&quot;&gt;simple handshake&lt;/a&gt;
with the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;.
As a result, it needs to be held high until the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
also raises the &lt;code class=&quot;highlighter-rouge&quot;&gt;i_stall_n&lt;/code&gt; line (a ready signal) to indicate that it is
ready to read an instruction.&lt;/p&gt;

&lt;p&gt;Once &lt;code class=&quot;highlighter-rouge&quot;&gt;(o_valid)&amp;amp;&amp;amp;(i_stall_n)&lt;/code&gt; are both true, the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/dev/rtl/core/prefetch.v&quot;&gt;prefetch&lt;/a&gt;
needs to drop the &lt;code class=&quot;highlighter-rouge&quot;&gt;o_valid&lt;/code&gt; signal and fetch the next instruction from the
address given by &lt;code class=&quot;highlighter-rouge&quot;&gt;o_pc+1&lt;/code&gt; (counting in 32-bit words).&lt;/p&gt;

&lt;p&gt;This continues until another
&lt;a href=&quot;https://en.wikipedia.org/wiki/Branch_(computer_science)&quot;&gt;branch&lt;/a&gt;
takes place.  When that happens, the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
will communicate this to the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/dev/rtl/core/prefetch.v&quot;&gt;prefetch&lt;/a&gt;
by raising the &lt;code class=&quot;highlighter-rouge&quot;&gt;i_new_pc&lt;/code&gt; signal.  In response, the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/dev/rtl/core/prefetch.v&quot;&gt;prefetch&lt;/a&gt;
will drop the &lt;code class=&quot;highlighter-rouge&quot;&gt;o_valid&lt;/code&gt; line
(even before &lt;code class=&quot;highlighter-rouge&quot;&gt;i_stall_n&lt;/code&gt; is true), and fetch the next instruction and so the
cycle continues.&lt;/p&gt;

&lt;p&gt;This is the basics of how this &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/dev/rtl/core/prefetch.v&quot;&gt;simple
prefetch&lt;/a&gt;
works.  As with any
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
project, however, we’ll need to pay close attention to the details.&lt;/p&gt;

&lt;p&gt;For example, what happens when the
&lt;a href=&quot;/doc/wbspec_b4.pdf&quot;&gt;Wishbone bus&lt;/a&gt;
returns an &lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_error&quot;&gt;error&lt;/a&gt;?
Suppose, for example, that the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
tried to &lt;a href=&quot;https://en.wikipedia.org/wiki/Branch_(computer_science)&quot;&gt;branch&lt;/a&gt;
to a non-existent memory address.  In this case, the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_(computing)&quot;&gt;bus&lt;/a&gt;
would return an &lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_error&quot;&gt;error&lt;/a&gt;, and so the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/dev/rtl/core/prefetch.v&quot;&gt;prefetch&lt;/a&gt;
needs to return everything as before, only in this case it also sets an
&lt;code class=&quot;highlighter-rouge&quot;&gt;o_illegal&lt;/code&gt; flag so that the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
can recognize and properly respond to the invalid instruction.&lt;/p&gt;

&lt;p&gt;Another corner case might seem more relevant for a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Prefetching&quot;&gt;prefetch&lt;/a&gt;/&lt;a href=&quot;https://en.wikipedia.org/wiki/Cache_(computing)&quot;&gt;cache&lt;/a&gt;
interaction than &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/dev/rtl/core/prefetch.v&quot;&gt;this simple
prefetch&lt;/a&gt;,
but it’s actually still relevant.  In this example, the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
instructs (or is instructed) to clear its
&lt;a href=&quot;https://en.wikipedia.org/wiki/Cache_(computing)&quot;&gt;cache&lt;/a&gt;.
It may be, for example, that the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
is halted and under the control of the debugger.  The debugger may have
rewritten the memory the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
is about to execute–but the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
needs to know that the instruction that it has already read is no longer valid.
This is the purpose of the &lt;code class=&quot;highlighter-rouge&quot;&gt;i_clear_cache&lt;/code&gt; line for even this &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/dev/rtl/core/prefetch.v&quot;&gt;simple prefetch
module&lt;/a&gt;.
When raised, the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
is telling the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/dev/rtl/core/prefetch.v&quot;&gt;prefetch&lt;/a&gt;
that any instruction that has been read and is waiting for the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
to issue is invalid, and thus needs to be read again.&lt;/p&gt;

&lt;p&gt;Finally, what happens when the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/dev/rtl/core/prefetch.v&quot;&gt;prefetch&lt;/a&gt;
is given a new address while it is in the middle of requesting another
address?  In that example, the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
needs to abandon (abort) its current transaction and initiate a new read to
get the newly requested address.&lt;/p&gt;

&lt;p&gt;These subtle details help to describe some of the more interesting cases when
dealing with this (otherwise) &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/dev/rtl/core/prefetch.v&quot;&gt;simple
prefetch&lt;/a&gt;.
However, the operation is still simple enough that we might try to build
it in a straightforward fashion–the topic of our next section.&lt;/p&gt;

&lt;h2 id=&quot;initial-attempt&quot;&gt;Initial Attempt&lt;/h2&gt;

&lt;p&gt;Now that we know how this
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/dev/rtl/core/prefetch.v&quot;&gt;prefetch&lt;/a&gt;
module is supposed to interact with both the
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;
and the rest of the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;,
let’s outline some of the detailed basics of how this might take place.&lt;/p&gt;

&lt;p&gt;The process starts out with the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_(computing)&quot;&gt;bus&lt;/a&gt;
idle.  Similarly, on any reset request we’ll want to bring the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_(computing)&quot;&gt;bus&lt;/a&gt;
back to this idle state again.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;initial	o_wb_cyc &amp;lt;= 1&#39;b0;
initial	o_wb_stb &amp;lt;= 1&#39;b0;
initial	o_valid &amp;lt;= 1&#39;b0;
always @(posedge i_clk)
if (i_reset)
	o_wb_cyc &amp;lt;= 1&#39;b0;
	o_wb_stb &amp;lt;= 1&#39;b0;
	o_valid &amp;lt;= 1&#39;b0;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Since these two lines qualify all of the other
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus output lines&lt;/a&gt;
(prefixed herein with &lt;code class=&quot;highlighter-rouge&quot;&gt;o_wb_*&lt;/code&gt;), all it takes to
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;end a bus cycle&lt;/a&gt;
is to lower these two wires.&lt;/p&gt;

&lt;p&gt;What about any
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_(computing)&quot;&gt;bus&lt;/a&gt;
transaction in process when this reset is received?  That was part of our
discussion when we worked through a
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;formal description&lt;/a&gt;
of the
&lt;a href=&quot;/doc/wbspec_b4.pdf&quot;&gt;Wishbone bus&lt;/a&gt;.
Our conclusion, from that discussion, was that it is important
to be able to abort a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_(computing)&quot;&gt;bus&lt;/a&gt;
transaction at any stage in that transaction.  Were we in the middle of a
transaction, the logic above would simply abort that transaction as we’ve
discussed.&lt;/p&gt;

&lt;p&gt;The &lt;code class=&quot;highlighter-rouge&quot;&gt;o_valid&lt;/code&gt; line initialized above isn’t part of the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_(computing)&quot;&gt;bus&lt;/a&gt;
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;interaction&lt;/a&gt;.
As we discussed in the last section, this is the signal to the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
that a valid instruction is ready to be read from the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/dev/rtl/core/prefetch.v&quot;&gt;prefetch&lt;/a&gt;.
This signal also needs to be reset, along with the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_(computing)&quot;&gt;bus&lt;/a&gt;
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;interaction&lt;/a&gt;, so we
reset the &lt;code class=&quot;highlighter-rouge&quot;&gt;o_valid&lt;/code&gt; at the same time above.&lt;/p&gt;

&lt;p&gt;The next step is to recognize when a new transaction needs to begin.  There
are three basic conditions indicating that we want to start a new
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_(computing)&quot;&gt;bus&lt;/a&gt;
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;interaction&lt;/a&gt;.
The first is if the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
wants us to &lt;a href=&quot;https://en.wikipedia.org/wiki/Branch_(computer_science)&quot;&gt;branch&lt;/a&gt;
to a new address.  In this case, the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt; will
have raised the &lt;code class=&quot;highlighter-rouge&quot;&gt;i_new_pc&lt;/code&gt; signal and placed the new address in the &lt;code class=&quot;highlighter-rouge&quot;&gt;i_pc&lt;/code&gt;
input.  A new transaction also needs to begin any time the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
accepts the instruction the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/dev/rtl/core/prefetch.v&quot;&gt;prefetch&lt;/a&gt;
presented to it.  This condition is indicated by both an instruction being
valid, &lt;code class=&quot;highlighter-rouge&quot;&gt;o_valid&lt;/code&gt;, at the same time the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
is not stalled, &lt;code class=&quot;highlighter-rouge&quot;&gt;i_stall_n&lt;/code&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;end else if (!o_wb_cyc)
begin
	if ((i_new_pc)||((o_valid)&amp;amp;&amp;amp;(i_stall_n)))
	begin
		o_wb_cyc &amp;lt;= 1&#39;b1;
		o_wb_stb &amp;lt;= 1&#39;b1;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The address appropriate for this new
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_(computing)&quot;&gt;bus&lt;/a&gt;
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;request&lt;/a&gt;.
depends upon the reason for the request.  If the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
gives us a new instruction address, indicated by &lt;code class=&quot;highlighter-rouge&quot;&gt;i_new_pc&lt;/code&gt;, then that
address is the memory address we need to fetch.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;		if (i_new_pc)
			o_wb_addr &amp;lt;= i_pc;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;On the other hand, if the last instruction was just accepted, then we want to
grab the next instruction–found one address later.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;		else if ((o_valid)&amp;amp;&amp;amp;(i_stall_n))
			o_wb_addr &amp;lt;= o_wb_addr+1&#39;b1;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;In each of these cases, the output instruction needs to be marked as
no longer valid.  If this were a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Branch_(computer_science)&quot;&gt;branch&lt;/a&gt;,
every other stage in the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
&lt;a href=&quot;/zipcpu/2017/08/23/cpu-pipeline.html&quot;&gt;pipeline&lt;/a&gt;.
would be marking their data as invalid as well.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;		o_valid &amp;lt;= 1&#39;b0;
	end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The final section of this overview pseudocode discussion involves how the
controller should respond while a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_(computing)&quot;&gt;bus&lt;/a&gt;
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;interaction&lt;/a&gt;
is taking place.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;end else begin // if (o_wb_cyc)&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The first item to pay attention to during a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_(computing)&quot;&gt;bus&lt;/a&gt;
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;transaction&lt;/a&gt;
is to insure that only one transaction request is issued.  (Other
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
prefetches issue multiple requests in quick succession, &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/dev/rtl/core/prefetch.v&quot;&gt;this
prefetch&lt;/a&gt;
only issues the one request at a time.)  From the
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus definition&lt;/a&gt;,
we know that a transaction request has been accepted any time the master’s
&lt;code class=&quot;highlighter-rouge&quot;&gt;STB&lt;/code&gt; signal is high and the slave’s &lt;code class=&quot;highlighter-rouge&quot;&gt;STALL&lt;/code&gt; signal is low, or
&lt;code class=&quot;highlighter-rouge&quot;&gt;(o_wb_stb)&amp;amp;&amp;amp;(!i_wb_stall)&lt;/code&gt;.  We can short-circuit this full test in this
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/dev/rtl/core/prefetch.v&quot;&gt;simple implementation&lt;/a&gt;
by just setting &lt;code class=&quot;highlighter-rouge&quot;&gt;o_wb_stb&lt;/code&gt; low anytime &lt;code class=&quot;highlighter-rouge&quot;&gt;i_wb_stall&lt;/code&gt; is
low during a bus transaction.  Should &lt;code class=&quot;highlighter-rouge&quot;&gt;i_wb_stall&lt;/code&gt; be low when &lt;code class=&quot;highlighter-rouge&quot;&gt;o_wb_stb&lt;/code&gt;
is already zero, then this statement will have no effect–as desired.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	if (!i_wb_stall)
		o_wb_stb &amp;lt;= 1&#39;b0;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The second item to deal with is when to end our request.  In this
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/dev/rtl/core/prefetch.v&quot;&gt;single item&lt;/a&gt;
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;Wishbone master&lt;/a&gt;
the transaction ends on the first
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_(computing)&quot;&gt;bus&lt;/a&gt;
return.  Hence &lt;code class=&quot;highlighter-rouge&quot;&gt;o_wb_cyc&lt;/code&gt; is returned to zero following any &lt;code class=&quot;highlighter-rouge&quot;&gt;i_wb_ack&lt;/code&gt; signal
from the memory slave peripheral.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	if (i_wb_ack)
	begin
		o_wb_cyc &amp;lt;= 1&#39;b0;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;On this same clock, we can set the value of the instruction, &lt;code class=&quot;highlighter-rouge&quot;&gt;o_insn&lt;/code&gt;, to be
sent to the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;,
as well as the valid flag, &lt;code class=&quot;highlighter-rouge&quot;&gt;o_valid&lt;/code&gt;, to indicate this instruction is valid.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;		o_insn &amp;lt;= i_wb_data;
		o_valid &amp;lt;= 1&#39;b1;
	end
end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This is the basic outline of how this &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/dev/rtl/core/prefetch.v&quot;&gt;prefetch
module&lt;/a&gt;
works.  When we get into the details below, you will likely find them very
similar to this discussion above.  However, because breaking this one
giant “always” block into multiple processes can &lt;a href=&quot;/blog/2017/06/12/minimizing-luts.html&quot;&gt;reduce our logic
requirements&lt;/a&gt;,
you may not necessarily recognize the code above in the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/dev/rtl/core/prefetch.v&quot;&gt;code&lt;/a&gt;
presented below.&lt;/p&gt;

&lt;p&gt;You’ll also see another difference below, associated with having to deal with
some of the subtle details of the corner cases–things you may not expect
unless you’ve had your
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;
fail because you haven’t dealt with them.  These will be the topic of
the next section.&lt;/p&gt;

&lt;h2 id=&quot;the-actual-prefetch-code&quot;&gt;The Actual Prefetch Code&lt;/h2&gt;

&lt;p&gt;At this point, we’ve outlined how this &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/dev/rtl/core/prefetch.v&quot;&gt;prefetch
module&lt;/a&gt;
needs to interact with both the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;,
and the &lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;Wishbone bus&lt;/a&gt;.
We’ve also outlined the basics of the module we’d like to
implement above.  The task left before us now is to finally implement the
details of this module, and then to prove that it works below.  In other words,
it’s now time to get specific about those corner cases.&lt;/p&gt;

&lt;p&gt;Since any
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/dev/rtl/core/prefetch.v&quot;&gt;prefetch&lt;/a&gt;
is a read-only structure, we’ll set the
bus wires associated with writing to the bus to zeros, although only
the &lt;code class=&quot;highlighter-rouge&quot;&gt;o_wb_we&lt;/code&gt; signal will be relevant since &lt;code class=&quot;highlighter-rouge&quot;&gt;o_wb_data&lt;/code&gt; is ignored unless
we are within a write transaction and &lt;code class=&quot;highlighter-rouge&quot;&gt;(o_wb_stb)&amp;amp;&amp;amp;(o_wb_we)&lt;/code&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	assign	o_wb_we = 1&#39;b0;
	assign	o_wb_data = 32&#39;h0000;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Having dealt with the constants, we can now
turn our focus to the actual implementation of the logic
above.  We’ll start with what’s left of the giant always block controlling
the bus wires &lt;code class=&quot;highlighter-rouge&quot;&gt;o_wb_cyc&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;o_wb_stb&lt;/code&gt;.  As before, we’ll start by
initializing ourselves into an idle state.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	initial	o_wb_cyc = 1&#39;b0;
	initial	o_wb_stb = 1&#39;b0;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Unlike before, we’ll also return to this idle state upon any bus
acknowledgement or
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_error&quot;&gt;error&lt;/a&gt;.
These two signals need to be qualified by the &lt;code class=&quot;highlighter-rouge&quot;&gt;o_wb_cyc&lt;/code&gt; line, since in our
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;last wishbone discussion&lt;/a&gt;,
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;we discussed&lt;/a&gt;
how either the &lt;code class=&quot;highlighter-rouge&quot;&gt;i_wb_ack&lt;/code&gt; or the &lt;code class=&quot;highlighter-rouge&quot;&gt;i_wb_err&lt;/code&gt; signal might be true on the clock
cycle after &lt;code class=&quot;highlighter-rouge&quot;&gt;o_wb_cyc&lt;/code&gt; is dropped as part of an abort.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(posedge i_clk)
		if ((i_reset)||((o_wb_cyc)&amp;amp;&amp;amp;((i_wb_ack)||(i_wb_err))))
		begin
			// End any bus cycle on a reset, or a return ACK
			// or error.
			o_wb_cyc &amp;lt;= 1&#39;b0;
			o_wb_stb &amp;lt;= 1&#39;b0;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The next task is to start a new bus request.  There are several reasons for
starting a new bus request:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;If the last instruction was accepted, &lt;em&gt;and&lt;/em&gt; it wasn’t the result of a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_(computing)&quot;&gt;bus&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_error&quot;&gt;error&lt;/a&gt;.&lt;/p&gt;

    &lt;p&gt;There should only be two ways out of a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_(computing)&quot;&gt;bus&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_error&quot;&gt;error&lt;/a&gt;
condition.&lt;/p&gt;

    &lt;p&gt;The first way out of a 
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_(computing)&quot;&gt;bus&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_error&quot;&gt;error&lt;/a&gt;
condition is by the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Branch_(computer_science)&quot;&gt;branching&lt;/a&gt;
to a new instruction.  Two examples will help illustrate this.  The
first example would be if the pipeline has gotten ahead of the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;
and read past the end of the memory device, but while the
software program itself has not.  Perhaps the last item of memory
is a &lt;a href=&quot;https://en.wikipedia.org/wiki/Branch_(computer_science)&quot;&gt;branch&lt;/a&gt;
statement and the software hasn’t gotten that far, even though the
pipeline is beyond it.  The second example is that of a
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Branch_(computer_science)&quot;&gt;branch&lt;/a&gt;
in response to an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_error&quot;&gt;error&lt;/a&gt;
condition.  This would be the case if the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
actually tried to execute the instruction at the address that caused the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_(computing)&quot;&gt;bus&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_error&quot;&gt;error&lt;/a&gt;.
In this case, we’d get a new request for an instruction, on an
&lt;code class=&quot;highlighter-rouge&quot;&gt;i_new_pc&lt;/code&gt;, only the instruction address requested, &lt;code class=&quot;highlighter-rouge&quot;&gt;i_pc&lt;/code&gt;, would be the
address of the instruction error handler.&lt;/p&gt;

    &lt;p&gt;The second way out of a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_(computing)&quot;&gt;bus&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_error&quot;&gt;error&lt;/a&gt;
condition is via the &lt;code class=&quot;highlighter-rouge&quot;&gt;i_reset&lt;/code&gt; signal above.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;We’ll want to start a new transaction if the last transaction was aborted.
In this case, we’ll use an &lt;code class=&quot;highlighter-rouge&quot;&gt;invalid&lt;/code&gt; flag to indicate that the last
bus transaction ended in an invalid manner—such as if the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
issued us an &lt;code class=&quot;highlighter-rouge&quot;&gt;i_new_pc&lt;/code&gt; signal during a memory transaction.  In this
case, the &lt;code class=&quot;highlighter-rouge&quot;&gt;invalid&lt;/code&gt; flag is our memory that we need to start a new
transaction to get that updated address.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;We’ll also start a new transaction following any
&lt;a href=&quot;https://en.wikipedia.org/wiki/Branch_(computer_science)&quot;&gt;branch&lt;/a&gt;
to a new address, indicated by the &lt;code class=&quot;highlighter-rouge&quot;&gt;i_new_pc&lt;/code&gt; signal.  This differs from
the &lt;code class=&quot;highlighter-rouge&quot;&gt;invalid&lt;/code&gt; version above in that this request may take place while
the bus is already idle.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;In all three of these cases, a new
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_(computing)&quot;&gt;bus&lt;/a&gt;
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;transaction&lt;/a&gt;
is initiated by raising both &lt;code class=&quot;highlighter-rouge&quot;&gt;o_wb_cyc&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;o_wb_stb&lt;/code&gt; lines high.
We’ll also need to adjust &lt;code class=&quot;highlighter-rouge&quot;&gt;o_wb_addr&lt;/code&gt; at this time as well, but we’ll
come back to that later as part of its own &lt;code class=&quot;highlighter-rouge&quot;&gt;always&lt;/code&gt; block.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;		end else if ((!o_wb_cyc)&amp;amp;&amp;amp;(
				// 1.
				((i_stalled_n)&amp;amp;&amp;amp;(!o_illegal))
				// 2.
				||(invalid)
				// 3.
				||(i_new_pc)))
		begin
			// Initiate a bus transaction
			o_wb_cyc &amp;lt;= 1&#39;b1;
			o_wb_stb &amp;lt;= 1&#39;b1;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The next question is how to handle an ongoing
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_(computing)&quot;&gt;bus&lt;/a&gt;
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;transaction&lt;/a&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;		end else if (o_wb_cyc)
		begin&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;We already dealt with any
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_(computing)&quot;&gt;bus&lt;/a&gt;
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;transaction&lt;/a&gt;
aborts due to
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_(computing)&quot;&gt;bus&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_error&quot;&gt;error&lt;/a&gt;’s above in the
reset logic, so that leaves only two items to deal with.  The first
is dropping the strobe line once our request has been accepted,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;			if (!i_wb_stall)
				o_wb_stb &amp;lt;= 1&#39;b0;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;and the second is aborting the transaction any time a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Branch_(computer_science)&quot;&gt;branch&lt;/a&gt;
request is received during the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_(computing)&quot;&gt;bus&lt;/a&gt;
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;transaction&lt;/a&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;			if (i_new_pc)
			begin
				o_wb_cyc &amp;lt;= 1&#39;b0;
				o_wb_stb &amp;lt;= 1&#39;b0;
			end
		end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;In this latter case, &lt;code class=&quot;highlighter-rouge&quot;&gt;invalid&lt;/code&gt; will be true on the next cycle to let us
know that we need to restart our
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_(computing)&quot;&gt;bus&lt;/a&gt;
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;transaction&lt;/a&gt; with a
new address.  Here’s the logic associated with letting us know that an
aborted
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_(computing)&quot;&gt;bus&lt;/a&gt;
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;transaction&lt;/a&gt;
needs to be restarted.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	initial	invalid = 1&#39;b0;
	always @(posedge i_clk)
		if ((i_reset)||(!o_wb_cyc))
			invalid &amp;lt;= 1&#39;b0;
		else if (i_new_pc)
			invalid &amp;lt;= 1&#39;b1;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The next value of interest is the address of the instruction we are
interested in.  This address is set any time the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
issues a new address via &lt;code class=&quot;highlighter-rouge&quot;&gt;i_new_pc&lt;/code&gt;.  In all other respects it is incremented
any time a valid instruction is accepted by the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;–with
the one exception to this choice
being the case of an illegal instruction resulting from a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_(computing)&quot;&gt;bus&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_error&quot;&gt;error&lt;/a&gt;.
In that case, the instruction address doesn’t change–and we don’t issue new
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_(computing)&quot;&gt;bus&lt;/a&gt;
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;requests&lt;/a&gt;
either.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	initial	o_wb_addr= 0;
	always @(posedge i_clk)
		if (i_new_pc)
			o_wb_addr  &amp;lt;= i_pc;
		else if ((o_valid)&amp;amp;&amp;amp;(i_stalled_n)&amp;amp;&amp;amp;(!o_illegal))
			o_wb_addr  &amp;lt;= o_wb_addr + 1&#39;b1;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Since this is just a simple &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/dev/rtl/core/prefetch.v&quot;&gt;prefetch
module&lt;/a&gt;,
one that only returns a single instruction, we can re-use the
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;Wishbone address&lt;/a&gt;
lines, &lt;code class=&quot;highlighter-rouge&quot;&gt;o_wb_addr&lt;/code&gt;, as instruction address lines when sending them to the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	assign	o_pc = o_wb_addr;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;As for the instruction passed to the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;,
that’s one of the simpler things we need to do–especially since &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/dev/rtl/core/prefetch.v&quot;&gt;this
prefetch&lt;/a&gt;
version only requests one instruction at a time.  We’ll set this value on any
valid &lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_(computing)&quot;&gt;bus&lt;/a&gt;
return, found in the &lt;code class=&quot;highlighter-rouge&quot;&gt;i_wb_data&lt;/code&gt; word, and indicated by both the fact that
we are in a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_(computing)&quot;&gt;bus&lt;/a&gt;
cycle (&lt;code class=&quot;highlighter-rouge&quot;&gt;o_wb_cyc&lt;/code&gt; is high), and by the acknowledgement flag, &lt;code class=&quot;highlighter-rouge&quot;&gt;i_wb_ack&lt;/code&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(posedge i_clk)
		if ((o_wb_cyc)&amp;amp;&amp;amp;(i_wb_ack))
			o_insn &amp;lt;= i_wb_data;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The last step is to handle the two flags, &lt;code class=&quot;highlighter-rouge&quot;&gt;o_valid&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;o_illegal&lt;/code&gt;, sent to the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
to let it know if the instruction presented in the &lt;code class=&quot;highlighter-rouge&quot;&gt;o_insn&lt;/code&gt; register is a valid
instruction or not.&lt;/p&gt;

&lt;p&gt;Initially, the instruction wires will &lt;em&gt;always&lt;/em&gt; be invalid.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	initial o_valid   = 1&#39;b0;
	initial o_illegal = 1&#39;b0;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Likewise, following any reset,
&lt;a href=&quot;https://en.wikipedia.org/wiki/Branch_(computer_science)&quot;&gt;branch&lt;/a&gt;,
or clear cache request, we’ll need to mark the instruction as invalid as well.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(posedge i_clk)
		if ((i_reset)||(i_new_pc)||(i_clear_cache))
		begin
			// ....
			o_valid   &amp;lt;= 1&#39;b0;
			o_illegal &amp;lt;= 1&#39;b0;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;We’ll also want to mark the instruction, &lt;code class=&quot;highlighter-rouge&quot;&gt;o_insn&lt;/code&gt;, as valid immediately
following any bus acknowledgement, &lt;code class=&quot;highlighter-rouge&quot;&gt;i_wb_ack&lt;/code&gt;.  Since this acknowledgement flag
is only valid during a bus cycle (and may accidentally show up after a bus
cycle, as the result of an abort), we’ll have to check &lt;code class=&quot;highlighter-rouge&quot;&gt;o_wb_cyc&lt;/code&gt; as well
to know if we need to set this.&lt;/p&gt;

&lt;p&gt;Further, as we mentioned above, the &lt;code class=&quot;highlighter-rouge&quot;&gt;!o_illegal&lt;/code&gt; signal is being used as an
indicator that the result of the bus request is a valid instruction versus
just being a valid response.  Hence, if this was the result of a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_(computing)&quot;&gt;bus&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_error&quot;&gt;error&lt;/a&gt;,
we need to set &lt;code class=&quot;highlighter-rouge&quot;&gt;o_illegal&lt;/code&gt; at the same time we set &lt;code class=&quot;highlighter-rouge&quot;&gt;o_valid&lt;/code&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;		end else if ((o_wb_cyc)&amp;amp;&amp;amp;((i_wb_ack)||(i_wb_err)))
		begin
			// ...
			o_valid   &amp;lt;= 1&#39;b1;
			o_illegal &amp;lt;= ( i_wb_err);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Once the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
accepts our instruction, that is once &lt;code class=&quot;highlighter-rouge&quot;&gt;(o_valid)&amp;amp;&amp;amp;(i_stalled_n)&lt;/code&gt; are both
true, then we need to clear the &lt;code class=&quot;highlighter-rouge&quot;&gt;o_valid&lt;/code&gt; flag, lest the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
accidentally read the same instructions twice.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;		end else if (i_stalled_n)
		begin
			// ---
			o_valid &amp;lt;= 1&#39;b0;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;While you might be tempted to clear the &lt;code class=&quot;highlighter-rouge&quot;&gt;o_illegal&lt;/code&gt; flag as well, doing so
would be a mistake.  In particular, you want to keep the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/dev/rtl/core/prefetch.v&quot;&gt;prefetch&lt;/a&gt;
from trying to fetch, refetch, and refetch again, any response that was returned
in &lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_error&quot;&gt;error&lt;/a&gt;.
Hence, we’ll leave &lt;code class=&quot;highlighter-rouge&quot;&gt;o_illegal&lt;/code&gt; flag true following any
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_(computing)&quot;&gt;bus&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_error&quot;&gt;error&lt;/a&gt;,
and use it as a flag (above) to keep us from re-initiating a new
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_(computing)&quot;&gt;bus&lt;/a&gt;
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;request&lt;/a&gt;
prior to a new &lt;a href=&quot;https://en.wikipedia.org/wiki/Program_counter&quot;&gt;PC&lt;/a&gt;
being given to us to recover from this error condition.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;			// o_illegal &amp;lt;= (!i_stalled_n);
		end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;One item worth noting about the code above, is that the giant &lt;code class=&quot;highlighter-rouge&quot;&gt;always&lt;/code&gt; blocks
that remain only control a small number of signals.  The largest groups of
signals within this design are associated with the
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;Wishbone address&lt;/a&gt;,
&lt;code class=&quot;highlighter-rouge&quot;&gt;o_wb_addr&lt;/code&gt;, and the
output instruction, &lt;code class=&quot;highlighter-rouge&quot;&gt;o_insn&lt;/code&gt;.  These two groups of signals depend upon only
a minimum number of inputs, helping to &lt;a href=&quot;/blog/2017/06/12/minimizing-luts.html&quot;&gt;keep our logic to a
minimum&lt;/a&gt;.  The
registers that require complex logic, such as &lt;code class=&quot;highlighter-rouge&quot;&gt;o_wb_cyc&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;o_wb_stb&lt;/code&gt;,
&lt;code class=&quot;highlighter-rouge&quot;&gt;o_illegal&lt;/code&gt; or even &lt;code class=&quot;highlighter-rouge&quot;&gt;o_valid&lt;/code&gt;, are all single registers–minimizing the
impact of any difficult logic on our overall core.&lt;/p&gt;

&lt;h2 id=&quot;formal-verification&quot;&gt;Formal Verification&lt;/h2&gt;

&lt;p&gt;Now that we know how this &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/dev/rtl/core/prefetch.v&quot;&gt;prefetch
component&lt;/a&gt;
interacts with the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;ZipCPU&lt;/a&gt;,
and now that we’ve presented the how’s and the why’s of the logic within it,
it’s now time to take a look at formally proving whether or not it does what
we are expecting.  We’ll separate this section into four subsections below:
&lt;em&gt;assumptions&lt;/em&gt; about logic coming from the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;,
&lt;em&gt;assumptions&lt;/em&gt; about logic coming from the
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;Wishbone bus&lt;/a&gt;,
&lt;em&gt;assertions&lt;/em&gt; about logic controlling the
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;Wishbone bus&lt;/a&gt;,
and then &lt;em&gt;assertions&lt;/em&gt; about or logic used to communicate with the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;,
As before, the &lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;basic rule of formal
verification&lt;/a&gt; remains:
&lt;em&gt;assume properties of inputs, assert properties
of outputs.&lt;/em&gt;&lt;/p&gt;

&lt;h4 id=&quot;assumptions-about-logic-coming-from-the-cpu&quot;&gt;Assumptions about logic coming from the CPU&lt;/h4&gt;

&lt;p&gt;There are four basic control lines coming from the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
that the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/dev/rtl/core/prefetch.v&quot;&gt;prefetch&lt;/a&gt;
needs to interact with: the reset line, &lt;code class=&quot;highlighter-rouge&quot;&gt;i_reset&lt;/code&gt;, the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Branch_(computer_science)&quot;&gt;branch&lt;/a&gt;
indicator line, &lt;code class=&quot;highlighter-rouge&quot;&gt;i_new_pc&lt;/code&gt;, the request for us to clear our cache,
&lt;code class=&quot;highlighter-rouge&quot;&gt;i_clear_cache&lt;/code&gt;, and the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;’s
ready (not stalled) line, &lt;code class=&quot;highlighter-rouge&quot;&gt;i_stall_n&lt;/code&gt;.  The fifth input from the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;i_pc&lt;/code&gt;, is only relevant when &lt;code class=&quot;highlighter-rouge&quot;&gt;i_new_pc&lt;/code&gt; is valid.&lt;/p&gt;

&lt;p&gt;We’ll start out with a standard assumption: Everything begins in a reset
state.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	initial	`ASSUME(i_reset);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;You may remember the &lt;code class=&quot;highlighter-rouge&quot;&gt;ASSUME&lt;/code&gt; macro from &lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;my first experiences with
formal methods&lt;/a&gt;.  This
macro is set to &lt;code class=&quot;highlighter-rouge&quot;&gt;assume&lt;/code&gt; inputs from another part of the design only when
we are tested in isolation, and to &lt;code class=&quot;highlighter-rouge&quot;&gt;assert&lt;/code&gt; those same properties any time
we are tested as a component of a larger interaction.  The macro itself
is defined within the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/dev/rtl/core/prefetch.v&quot;&gt;prefetch&lt;/a&gt;
source code.&lt;/p&gt;

&lt;p&gt;Moving on, we also know that, following any reset request from the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;,
the first thing the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
will do will send us an &lt;code class=&quot;highlighter-rouge&quot;&gt;i_new_pc&lt;/code&gt; command–requesting a read from the
reset address.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(posedge i_clk)
		if ((f_past_valid)&amp;amp;&amp;amp;($past(i_reset)))
			`ASSUME(i_new_pc);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The same is true of the &lt;code class=&quot;highlighter-rouge&quot;&gt;i_clear_cache&lt;/code&gt; signal.  The
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
will &lt;em&gt;always&lt;/em&gt; follow this signal by an &lt;code class=&quot;highlighter-rouge&quot;&gt;i_new_pc&lt;/code&gt; request.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(posedge i_clk)
		if ((f_past_valid)&amp;amp;&amp;amp;($past(i_clear_cache)))
			`ASSUME(i_new_pc);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Now let’s look at the &lt;code class=&quot;highlighter-rouge&quot;&gt;i_stalled_n&lt;/code&gt; signal.  This signal comes from the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
and tells us when the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
is not stalled.  This is a handshake signal, much like the &lt;code class=&quot;highlighter-rouge&quot;&gt;!busy&lt;/code&gt; signal
we discussed when we discussed &lt;a href=&quot;/blog/2017/08/14/strategies-for-pipelining.html&quot;&gt;pipeline
strategies&lt;/a&gt;.
Hence, the only time this signal matters to us is when &lt;code class=&quot;highlighter-rouge&quot;&gt;o_valid&lt;/code&gt; is true.  We
can still constrain it however.&lt;/p&gt;

&lt;p&gt;The first constraint on this signal is that following any reset, the rest of the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
will be idle.  Stages beyond this one &lt;em&gt;cannot&lt;/em&gt; be busy following a reset.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(posedge i_clk)
		if ((f_past_valid)&amp;amp;&amp;amp;($past(i_reset)))
			`ASSUME(i_stalled_n);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The next constraint on this signal is that the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
cannot suddenly become stalled without being given an instruction.  Stalls
only take place when there’s an instruction in the following stage that is
taking more than one clock to execute–they can’t happen without an
instruction.  Hence, if the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
wasn’t stalled on the last clock, &lt;em&gt;and&lt;/em&gt; we didn’t pass the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
an instruction on the last clock, then it cannot be stalled on this clock.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(posedge i_clk)
		if ((f_past_valid)&amp;amp;&amp;amp;($past(!o_valid))&amp;amp;&amp;amp;($past(i_stalled_n)))
			`ASSUME(i_stalled_n);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Our last criteria isn’t so much a characteristic of the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;,
but rather one required by the proof.  In order for induction to be successful,
all of the various states need to be flushed within a given number of clocks.
To make certain this happens, we’ll insist that the CPU can only be stalled
for less than four clocks.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	localparam	F_CPU_DELAY = 4;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;In practice, the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;,
can be stalled for much longer.  Divide instructions, for
example, will stall the entire pipeline for 32+ clocks.  This is just about
speeding things up enough so that the solver can prove a solution.&lt;/p&gt;

&lt;p&gt;To make this limit, we’ll first count the number of clocks we need to wait for
the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;,
to be receptive to our instruction.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(posedge i_clk)
		// If no instruction is ready, then keep our counter at zero
		if ((i_reset)||(!o_valid)||(i_stalled_n))
			f_cpu_delay &amp;lt;= 0;
		else
			// Otherwise, count the clocks the CPU takes to respond
			f_cpu_delay &amp;lt;= f_cpu_delay + 1&#39;b1;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Finally, we’ll assume that this number remains less than the
parameterized (but fixed) delay above.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(posedge i_clk)
		assume(f_cpu_delay &amp;lt; F_CPU_DELAY);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Further, we’ll caveat this last test so that it will only take place if the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/dev/rtl/core/prefetch.v&quot;&gt;prefetch&lt;/a&gt;
is being tested in isolation, and not require it any time the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/dev/rtl/core/prefetch.v&quot;&gt;prefetch&lt;/a&gt;
is being tested as part of the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Those are the assumptions we need to make regarding how the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
controls this &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/dev/rtl/core/prefetch.v&quot;&gt;prefetch
module&lt;/a&gt;.
In many ways, these assumptions form the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;’s
side of a contract: the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/dev/rtl/core/prefetch.v&quot;&gt;prefetch&lt;/a&gt;
will work as long as the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;,
and the
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;Wishbone bus&lt;/a&gt;
which we’ll discuss next,
keeps its end of the contract.&lt;/p&gt;

&lt;h4 id=&quot;assumptions-about-logic-coming-from-the-wishbone-bus&quot;&gt;Assumptions about logic coming from the Wishbone bus&lt;/h4&gt;

&lt;p&gt;Making assumptions about the
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;Wishbone bus&lt;/a&gt;,
however, is now really easy.  Because &lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;we put
together&lt;/a&gt; a
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/dev/rtl/aux/fwb_master.v&quot;&gt;module&lt;/a&gt;
describing the
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;properties&lt;/a&gt; of the
&lt;a href=&quot;/doc/wbspec_b4.pdf&quot;&gt;Wishbone bus&lt;/a&gt;,
we only need to include
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/dev/rtl/aux/fwb_master.v&quot;&gt;that module&lt;/a&gt;
to get a copy of all of the various
assumptions (and assertions) associated with interacting with
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;this bus&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Once included, and given that our proof succeeds, we will then &lt;em&gt;know&lt;/em&gt; that we
are interacting validly with any peripheral on the
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;Wishbone bus&lt;/a&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	fwb_master #(.AW(AW), .DW(DW),.F_LGDEPTH(F_LGDEPTH),
			.F_MAX_REQUESTS(1), .F_OPT_SOURCE(1),
			.F_OPT_RMW_BUS_OPTION(0),
			.F_OPT_DISCONTINUOUS(0))
		f_wbm(i_clk, i_reset,
			o_wb_cyc, o_wb_stb, o_wb_we, o_wb_addr, o_wb_data, 4&#39;h0,
			i_wb_ack, i_wb_stall, i_wb_data, i_wb_err,
			f_nreqs, f_nacks, f_outstanding);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;There are a couple of options we set above, however.  These include the size
of the address bus and data bus, as well as the log (based two) of the length of
any interaction (&lt;code class=&quot;highlighter-rouge&quot;&gt;F_LGDEPTH=2&lt;/code&gt;).  We also indicated that this would be a source
controller (&lt;code class=&quot;highlighter-rouge&quot;&gt;CYC&amp;amp;STB&lt;/code&gt; go high together), and that we will only ever make one
request of the bus (&lt;code class=&quot;highlighter-rouge&quot;&gt;F_MAX_REQUESTS(1)&lt;/code&gt;.  Since the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/dev/rtl/core/prefetch.v&quot;&gt;prefetch&lt;/a&gt;
isn’t involved in writes, we can leave
the read-modify-write option off (&lt;code class=&quot;highlighter-rouge&quot;&gt;F_OPT_RMW_BUS_OPTION&lt;/code&gt;).  We’re also
not going to be restarting requests while &lt;code class=&quot;highlighter-rouge&quot;&gt;CYC&lt;/code&gt; is high, so we can leave
the &lt;code class=&quot;highlighter-rouge&quot;&gt;F_OPT_DISCONTINUOUS&lt;/code&gt; option low.&lt;/p&gt;

&lt;p&gt;This part is just that easy: include assertions and assumptions from
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/dev/rtl/aux/fwb_master.v&quot;&gt;elsewhere&lt;/a&gt;
and we’re done.  Well … almost.  We still need to make certain that the
number of requests and acknowledgements counted by this
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/dev/rtl/aux/fwb_master.v&quot;&gt;formal description of a Wishbone
master&lt;/a&gt;
match the logic within our &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/dev/rtl/core/prefetch.v&quot;&gt;prefetch
module&lt;/a&gt;.
That’s coming up in the next section.&lt;/p&gt;

&lt;h4 id=&quot;assertions-about-logic-controlling-the-wishbone-bus&quot;&gt;Assertions about logic controlling the Wishbone bus&lt;/h4&gt;

&lt;p&gt;We’ve now finished with the &lt;em&gt;assumptions&lt;/em&gt; about our inputs.  It’s now time
to turn to look at any &lt;em&gt;assertions&lt;/em&gt; we wish to make about our outputs.
We’ll start with the assertions about the
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;Wishbone bus&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Our first assertion is that we are &lt;em&gt;reading only&lt;/em&gt; from the bus.  This may seem
silly, but … a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Prefetching&quot;&gt;prefetch&lt;/a&gt;
should never do more than read from a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_(computing)&quot;&gt;bus&lt;/a&gt;.
It’s worth knowing that that’s all we are going to do.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(posedge i_clk)
		if (o_wb_stb)
			assert(!o_wb_we);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;We’re also going to assert that, two clocks after an &lt;code class=&quot;highlighter-rouge&quot;&gt;i_clear_cache&lt;/code&gt; request,
we’ve abandoned any ongoing
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;Wishbone&lt;/a&gt;
transaction.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(posedge i_clk)
		if ((f_past_valid)&amp;amp;&amp;amp;($past(f_past_valid))
				&amp;amp;&amp;amp;($past(i_clear_cache,2))
				&amp;amp;&amp;amp;($past(o_wb_cyc,2)))
			// ...
			assert((!$past(o_wb_cyc))||(!o_wb_cyc));&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Why two clocks?  Well, the first clock should be the &lt;code class=&quot;highlighter-rouge&quot;&gt;i_clear_cache&lt;/code&gt; request.
The second clock should be the &lt;code class=&quot;highlighter-rouge&quot;&gt;i_new_pc&lt;/code&gt; signal.  Then, on the third clock,
the &lt;code class=&quot;highlighter-rouge&quot;&gt;o_wb_cyc&lt;/code&gt; should be indicating that we are within a transaction.&lt;/p&gt;

&lt;p&gt;Once we have a valid result (instruction) to present to the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;,
then the address of this result shouldn’t change, neither should the instruction
itself–as long as we are holding &lt;code class=&quot;highlighter-rouge&quot;&gt;o_valid&lt;/code&gt; high.  Since this address is our
reference for the next instruction address, we can’t allow this to change
until the next &lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_(computing)&quot;&gt;bus&lt;/a&gt; cycle.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(posedge i_clk)
		if ((f_past_valid)&amp;amp;&amp;amp;($past(o_valid))&amp;amp;&amp;amp;(o_valid))
			assert($stable(o_wb_addr));&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;We’re also going to assert that we start a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_(computing)&quot;&gt;bus&lt;/a&gt; cycle
following any abort.  Since &lt;code class=&quot;highlighter-rouge&quot;&gt;invalid&lt;/code&gt; will be true following any abort based
upon a new &lt;a href=&quot;https://en.wikipedia.org/wiki/Program_counter&quot;&gt;PC&lt;/a&gt;,
this assertion captures the logic in question.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(posedge i_clk)
		if ((f_past_valid)&amp;amp;&amp;amp;($past(!i_reset))&amp;amp;&amp;amp;($past(invalid)))
			assert(o_wb_cyc);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Those are the things we need to assert regarding our
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_(computing)&quot;&gt;bus&lt;/a&gt;
interaction–things specific to this
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/dev/rtl/core/prefetch.v&quot;&gt;prefetch&lt;/a&gt;.&lt;/p&gt;

&lt;h4 id=&quot;assertions-about-logic-responding-to-the-cpu&quot;&gt;Assertions about logic responding to the CPU&lt;/h4&gt;

&lt;p&gt;The last set of assertions are those associated with our responses to the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;.
These are primarily about the integrity of our return signals.&lt;/p&gt;

&lt;p&gt;Since this is a &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/dev/rtl/core/prefetch.v&quot;&gt;single instruction prefetch
module&lt;/a&gt;,
after the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
accepts an instruction we’ll have to go get a new instruction.
This means that the &lt;code class=&quot;highlighter-rouge&quot;&gt;o_valid&lt;/code&gt; line must immediately drop–at least until the
next instruction is received.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(posedge i_clk)
		if ((f_past_valid)&amp;amp;&amp;amp;($past(o_valid))&amp;amp;&amp;amp;($past(i_stalled_n)))
			assert(!o_valid);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;We can go further and insist that any time we are within a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_(computing)&quot;&gt;bus&lt;/a&gt;
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;cycle&lt;/a&gt;,
the &lt;code class=&quot;highlighter-rouge&quot;&gt;o_valid&lt;/code&gt; line must also be low.  Consider the consequences if this weren’t
the case: if the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/dev/rtl/core/prefetch.v&quot;&gt;prefetch&lt;/a&gt;
were allowed to present a valid instruction to the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;,
and a new instruction was received from the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_(computing)&quot;&gt;bus&lt;/a&gt;,
where should it be stored?&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(*)
		if (o_wb_cyc)
			assert(!o_valid);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Further, any time we get an instruction from the
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;Wishbone bus&lt;/a&gt;,
we need to assert that we are telling the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
that we have a valid instruction on the next clock cycle–the first cycle
that &lt;code class=&quot;highlighter-rouge&quot;&gt;o_insn&lt;/code&gt; is valid.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(posedge i_clk)
		if ((f_past_valid)&amp;amp;&amp;amp;(!$past(i_reset))
			&amp;amp;&amp;amp;($past(o_wb_cyc))
			&amp;amp;&amp;amp;($past(!i_clear_cache))
			&amp;amp;&amp;amp;($past(i_wb_ack))&amp;amp;&amp;amp;(!$past(i_wb_err)))
		begin
			if (!invalid)
				assert(o_valid);
		end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Of course, following an &lt;code class=&quot;highlighter-rouge&quot;&gt;i_new_pc&lt;/code&gt; or &lt;code class=&quot;highlighter-rouge&quot;&gt;i_clear_cache&lt;/code&gt; request, we’ll need
to make sure that the instruction presented &lt;em&gt;isn’t&lt;/em&gt; valid.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(posedge i_clk)
		if ((f_past_valid)&amp;amp;&amp;amp;($past(i_clear_cache)))
			assert(!o_valid);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Not only that but two clocks following an &lt;code class=&quot;highlighter-rouge&quot;&gt;i_clear_cache&lt;/code&gt; request we want
to make certain we are still invalid.  This makes sure we don’t abort
a &lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_(computing)&quot;&gt;bus&lt;/a&gt; cycle
and somehow turn on the &lt;code class=&quot;highlighter-rouge&quot;&gt;o_valid&lt;/code&gt; signal.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(posedge i_clk)
		if ((f_past_valid)&amp;amp;&amp;amp;($past(f_past_valid))
				&amp;amp;&amp;amp;($past(i_clear_cache,2))
				&amp;amp;&amp;amp;($past(o_wb_cyc,2)))
			// ...
			assert(!o_valid);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;You may remember the discussion regarding two clocks past the &lt;code class=&quot;highlighter-rouge&quot;&gt;i_clear_cache&lt;/code&gt;
signal above, having to do with the &lt;code class=&quot;highlighter-rouge&quot;&gt;o_wb_cyc&lt;/code&gt; output.  This is really just
an assertion of (roughly) the same thing.&lt;/p&gt;

&lt;p&gt;Now let’s start looking at the content of what we are returning to the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;.
As long as we are presenting a valid instruction to the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;,
and the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
is stalled and not ready for the instruction, then we need to continue
presenting our valid instruction.
Exceptions to this rule include the clock following any &lt;code class=&quot;highlighter-rouge&quot;&gt;i_reset&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;i_new_pc&lt;/code&gt;,
or &lt;code class=&quot;highlighter-rouge&quot;&gt;i_clear_cache&lt;/code&gt; request.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(posedge i_clk)
	if ((f_past_valid)&amp;amp;&amp;amp;(!$past(i_reset))
			&amp;amp;&amp;amp;(!$past(i_new_pc))&amp;amp;&amp;amp;(!$past(i_clear_cache))
			&amp;amp;&amp;amp;($past(o_valid))&amp;amp;&amp;amp;(!$past(i_stalled_n)))
		assert($stable(o_valid));&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Further, any time we present a valid instruction for two clocks in a row,
none of the information associated with that instruction should be able
to change.  This goes for not only the instruction itself, &lt;code class=&quot;highlighter-rouge&quot;&gt;o_insn&lt;/code&gt;, but
also the address of the instruction, &lt;code class=&quot;highlighter-rouge&quot;&gt;o_pc&lt;/code&gt;, and the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_(computing)&quot;&gt;bus&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_error&quot;&gt;error&lt;/a&gt;
indication signal &lt;code class=&quot;highlighter-rouge&quot;&gt;o_illegal&lt;/code&gt;.  Another way to say this would be to say that
these lines shouldn’t change until the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
acknowledges them.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(posedge i_clk)
	if ((f_past_valid)&amp;amp;&amp;amp;($past(o_valid))&amp;amp;&amp;amp;(o_valid))
	begin
		assert($stable(o_pc));
		assert($stable(o_insn));
		assert($stable(o_illegal));
	end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The &lt;code class=&quot;highlighter-rouge&quot;&gt;o_illegal&lt;/code&gt; line needs to remain valid even after the instruction has
been accepted–at least until the next &lt;code class=&quot;highlighter-rouge&quot;&gt;i_new_pc&lt;/code&gt; command, since we are using
it as an indication &lt;em&gt;not&lt;/em&gt; to refetch an instruction that is no longer
&lt;code class=&quot;highlighter-rouge&quot;&gt;o_valid&lt;/code&gt;.  Indeed, as long as &lt;code class=&quot;highlighter-rouge&quot;&gt;o_wb_cyc&lt;/code&gt; remains low (with exceptions),
&lt;code class=&quot;highlighter-rouge&quot;&gt;o_illegal&lt;/code&gt; needs to remain unchanging.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(posedge i_clk)
	if ((f_past_valid)&amp;amp;&amp;amp;(!$past(i_reset))
			&amp;amp;&amp;amp;(!$past(i_new_pc))&amp;amp;&amp;amp;(!$past(i_clear_cache))
			&amp;amp;&amp;amp;($past(!o_wb_cyc)))
		assert($stable(o_illegal));&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;That leaves us with two more assertions, both about the returned address,
&lt;code class=&quot;highlighter-rouge&quot;&gt;o_pc&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The first of these address assertions is that, unless the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
tells us otherwise, we need to walk through the instruction stream one
address at a time.  There are a couple parts to making this assertion.
We’ll need to keep track of anytime we have a valid past
&lt;a href=&quot;https://en.wikipedia.org/wiki/Program_counter&quot;&gt;PC&lt;/a&gt;
address to compare against.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	initial	f_last_pc_valid = 1&#39;b0;
	always @(posedge i_clk)
		if ((i_reset)||(i_clear_cache)||(i_new_pc)||(invalid))
			f_last_pc_valid &amp;lt;= 1&#39;b0;
		else if (o_valid)
			f_last_pc_valid &amp;lt;= (!o_illegal);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;On any &lt;code class=&quot;highlighter-rouge&quot;&gt;o_valid&lt;/code&gt; signal, we have a valid
&lt;a href=&quot;https://en.wikipedia.org/wiki/Program_counter&quot;&gt;PC&lt;/a&gt; to load into our
comparison register.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(posedge i_clk)
		if (o_valid)
			f_last_pc  &amp;lt;= o_pc;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;There’s a trick to making this work, though, and that is that we can’t allow
the &lt;code class=&quot;highlighter-rouge&quot;&gt;f_last_pc&lt;/code&gt; register to be just anything–even when it isn’t being
referenced.  This is a requirement of the formal induction step which will start
in any random (valid) state.  Without the assertion below, the induction
step might start with an unreasonable &lt;code class=&quot;highlighter-rouge&quot;&gt;f_last_pc&lt;/code&gt; value, and then conclude that
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/dev/rtl/core/prefetch.v&quot;&gt;our code&lt;/a&gt;
was in error.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;		else if (f_last_pc_valid)
			assert(o_pc == f_last_pc + 1&#39;b1);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Finally, we’ll make this first assertion associated with the output
address, that following any valid instruction and without an intervening
&lt;code class=&quot;highlighter-rouge&quot;&gt;i_new_pc&lt;/code&gt;, the next address must be one more than the last address.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(posedge i_clk)
		if ((f_past_valid)&amp;amp;&amp;amp;(o_valid)
				&amp;amp;&amp;amp;(!$past(o_valid))&amp;amp;&amp;amp;(f_last_pc_valid))
			assert(o_pc == (f_last_pc + 1&#39;b1));&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;That’s the first of the two address based assertions.&lt;/p&gt;

&lt;p&gt;The second of these two assertions is a more complete assertion, this time
dealing with the address of the next request.  In this case, we keep track of
the last address requested by the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
in &lt;code class=&quot;highlighter-rouge&quot;&gt;f_req_addr&lt;/code&gt; and increment it on any
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_(computing)&quot;&gt;bus&lt;/a&gt;
acknowledgement.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	initial	f_req_addr = 0;
	always @(posedge i_clk)
		if (i_new_pc)
			f_req_addr &amp;lt;= i_pc;
		else if ((!invalid)&amp;amp;&amp;amp;(o_wb_cyc)&amp;amp;&amp;amp;(i_wb_ack)&amp;amp;&amp;amp;(!i_wb_err))
			f_req_addr &amp;lt;= f_req_addr + 1&#39;b1;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Now, any time a value is being requested from the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_(computing)&quot;&gt;bus&lt;/a&gt;,
it should be the value found within &lt;code class=&quot;highlighter-rouge&quot;&gt;f_req_addr&lt;/code&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(posedge i_clk)
		if (o_wb_cyc)
			assert((invalid)||(f_req_addr == o_wb_addr));&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This is the last assertion we need to test &lt;code class=&quot;highlighter-rouge&quot;&gt;o_wb_addr&lt;/code&gt;, but as with the last
address assertion, this assertion isn’t sufficient.  In particular, if we don’t
constrain it further, the induction step might assume that the &lt;code class=&quot;highlighter-rouge&quot;&gt;f_req_addr&lt;/code&gt;
has a random value (since we haven’t told it otherwise), and then draw
an invalid conclusion as a result.  Hence we’ll need to assert that if the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_(computing)&quot;&gt;bus&lt;/a&gt;
isn’t active, then the &lt;code class=&quot;highlighter-rouge&quot;&gt;f_req_addr&lt;/code&gt; must be the same as the bus address.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;		else if ((!o_valid)&amp;amp;&amp;amp;(!i_new_pc)&amp;amp;&amp;amp;(!i_reset))
			assert(f_req_addr == o_wb_addr);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;As a last assertion, we’ll insist that the &lt;code class=&quot;highlighter-rouge&quot;&gt;invalid&lt;/code&gt; signal only ever be
true for a single clock.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(posedge i_clk)
		if ((f_past_valid)&amp;amp;&amp;amp;($past(invalid)))
			assert(!invalid);
`endif
endmodule&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This ends the list of assertions used to prove that the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/dev/rtl/core/prefetch.v&quot;&gt;single instruction prefetch&lt;/a&gt;
works as designed.&lt;/p&gt;

&lt;h2 id=&quot;minimizing-logic&quot;&gt;Minimizing Logic&lt;/h2&gt;

&lt;p&gt;If you are not familiar with the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;,
you should know that one of the reasons why I built the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
was to allow me to experiment with
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;
design on &lt;em&gt;really&lt;/em&gt; &lt;em&gt;cheap&lt;/em&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
hardware (Ex [&lt;a href=&quot;https://store.digilentinc.com/cmod-s6-breadboardable-spartan-6-fpga-module&quot;&gt;1&lt;/a&gt;]
[&lt;a href=&quot;http://www.icoboard.org&quot;&gt;2&lt;/a&gt;]
[&lt;a href=&quot;https://hackaday.io/project/12930-blackice-low-cost-open-hardware-fpga-dev-board&quot;&gt;3&lt;/a&gt;]
[&lt;a href=&quot;http://www.xess.com/shop/product/xula2-lx25/&quot;&gt;4&lt;/a&gt;]
[&lt;a href=&quot;https://store.digilentinc.com/basys-3-artix-7-fpga-trainer-board-recommended-for-introductory-users&quot;&gt;5&lt;/a&gt;]
[&lt;a href=&quot;https://store.digilentinc.com/arty-artix-7-fpga-development-board-for-makers-and-hobbyists/&quot;&gt;6&lt;/a&gt;]).
Achieving this goal required me to pay a lot of attention to
&lt;a href=&quot;/blog/2017/06/12/minimizing-luts.html&quot;&gt;logic minimization&lt;/a&gt;.
It also means that any time I walk through my own code,
I am forever asking myself, “is this wire needed?”  “Can I remove the dependence
of this &lt;a href=&quot;https://en.wikipedia.org/wiki/Flip-flop_(electronics)&quot;&gt;flip-flops&lt;/a&gt;
on this logical condition?”  Doing this, though, requires
two specific capabilities from my tool set.&lt;/p&gt;

&lt;p&gt;First, I need to be able to know, of a certainty, any time I adjust
a piece of logic, that the module will continue to work as designed.
This is the purpose of the formal model checks above, and/or any
test benches I might use.&lt;/p&gt;

&lt;p&gt;Second, I also need to be able to know how many
&lt;a href=&quot;https://en.wikipedia.org/wiki/Logic_block&quot;&gt;LUTs&lt;/a&gt;,
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flip-flop_(electronics)&quot;&gt;flip-flops&lt;/a&gt;,
and so forth my logic uses.  Traditionally, I have been using
&lt;a href=&quot;https://www.xilinx.com&quot;&gt;Xilinx&lt;/a&gt;’s
&lt;a href=&quot;https://www.xilinx.com/products/design-tools/ise-design-suite.html&quot;&gt;ISE&lt;/a&gt;
or &lt;a href=&quot;https://www.xilinx.com/products/design-tools/vivado.html&quot;&gt;Vivado&lt;/a&gt;
to build my entire design and then to report to me the logic used by the
design.  This can take a long time time (10+ minutes).  On the other hand, as
part of putting this post together, I discovered that I can use
&lt;a href=&quot;http://www.clifford.at/yosys&quot;&gt;yosys&lt;/a&gt; with either the &lt;code class=&quot;highlighter-rouge&quot;&gt;synth_xilinx&lt;/code&gt; (for
7-series &lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;s),
&lt;code class=&quot;highlighter-rouge&quot;&gt;synth_ice40&lt;/code&gt;, or (hopefully soon) the &lt;code class=&quot;highlighter-rouge&quot;&gt;synth_intel&lt;/code&gt; (for
&lt;a href=&quot;https://www.altera.com&quot;&gt;Altera&lt;/a&gt; chips) command to then be able to
estimate the logic required.  Below, for example, is the
&lt;a href=&quot;http://www.clifford.at/yosys&quot;&gt;yosys&lt;/a&gt;
output from processing the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/dev/rtl/core/prefetch.v&quot;&gt;prefetch.v&lt;/a&gt;
file above with &lt;code class=&quot;highlighter-rouge&quot;&gt;synth_xilinx&lt;/code&gt; enabled.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;   Number of wires:                 63
   Number of wire bits:            301
   Number of public wires:          20
   Number of public wire bits:     200
   Number of memories:               0
   Number of memory bits:            0
   Number of processes:              0
   Number of cells:                167
     FDRE                           67
     LUT1                            1
     LUT2                            1
     LUT3                           32
     LUT4                            4
     LUT5                            1
     LUT6                            2
     MUXCY                          29
     XORCY                          30&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Indeed, I was pleased to discover that the number of
&lt;a href=&quot;https://en.wikipedia.org/wiki/Logic_block&quot;&gt;LUT&lt;/a&gt;s
required by &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/dev/rtl/core/prefetch.v&quot;&gt;this
prefetch&lt;/a&gt;
went &lt;em&gt;down&lt;/em&gt; as a result of building a formal proof of &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/dev/rtl/core/prefetch.v&quot;&gt;this
prefetch&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;this-prefetch-only-fetches-one-instruction&quot;&gt;This prefetch only fetches one instruction&lt;/h2&gt;

&lt;p&gt;The presentation above demonstrated how &lt;em&gt;one&lt;/em&gt; of the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/dev/rtl/core/prefetch.v&quot;&gt;prefetch&lt;/a&gt;
modules was put together.  As I mentioned above, the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;’s
has three other
&lt;a href=&quot;https://en.wikipedia.org/wiki/Prefetching&quot;&gt;prefetch&lt;/a&gt;
modules (although only two are actively maintained).  This is also the first,
and in many ways the simplest, of the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Prefetching&quot;&gt;prefetch&lt;/a&gt; module’s the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; has had.&lt;/p&gt;

&lt;p&gt;Why did I switch?&lt;/p&gt;

&lt;p&gt;I switched from &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/dev/rtl/core/prefetch.v&quot;&gt;this prefetch
module&lt;/a&gt; to
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/pipefetch.v&quot;&gt;another&lt;/a&gt;
when I watched how fast the pipelined
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
performed when using &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/dev/rtl/core/prefetch.v&quot;&gt;this prefetch
module&lt;/a&gt;.
Indeed, the performance was so pitiful it was almost unbearable to watch the
instructions flow through the pipeline–with never more than one instruction
in the pipeline at any given time.  Eventually, I measured the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;’s performance against the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Dhrystone&quot;&gt;Dhrystone&lt;/a&gt; benchmark.  Using a
prior version of &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/dev/rtl/core/prefetch.v&quot;&gt;this prefetch
module&lt;/a&gt;,
the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; managed to achieve
0.128 DMIPS/MHz–a pitiful score.  The score, however, should be compared with
the 0.95 DMIPS/MHz score the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
achieved when fully pipelined.
[&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/doc/orconf.pdf&quot;&gt;Ref&lt;/a&gt;]&lt;/p&gt;

&lt;p&gt;Since that comparison, however, the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; has been extensively
modified–to include adjusting this
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/dev/rtl/core/prefetch.v&quot;&gt;prefetch&lt;/a&gt;.
As a result of one of those changes, this
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/dev/rtl/core/prefetch.v&quot;&gt;prefetch&lt;/a&gt;.
will now start fetching a new instruction a new instruction as soon as the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
has accepted the last one, rather than waiting for the 
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
to flush the last instruction through the pipeline before starting the next
fetch.  As a result, while it’s still painful to watch &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/dev/rtl/core/prefetch.v&quot;&gt;this
prefetch&lt;/a&gt;
operate, it’s not nearly as bad as it was originally.&lt;/p&gt;

&lt;p&gt;If you like &lt;a href=&quot;http://zipcpu.com&quot;&gt;this blog&lt;/a&gt;, please consider supporting it on
&lt;a href=&quot;https://www.patreon.com/ZipCPU&quot;&gt;Patreon&lt;/a&gt;.  Thank you!&lt;/p&gt;
&lt;hr /&gt;&lt;p&gt;&lt;em&gt;And now I have told you before it come to pass, that, when it is come to pass, ye might believe.  (John 14:29)&lt;/em&gt;</description>
        <pubDate>Sat, 18 Nov 2017 00:00:00 -0500</pubDate>
        <link>http://zipcpu.com/zipcpu/2017/11/18/wb-prefetch.html</link>
        <guid isPermaLink="true">http://zipcpu.com/zipcpu/2017/11/18/wb-prefetch.html</guid>
        
        
        <category>zipcpu</category>
        
      </item>
    
      <item>
        <title>Generating more than one bit at a time with an LFSR</title>
        <description>&lt;p&gt;This is now our third post on
&lt;a href=&quot;https://wikipedia.org/wiki/Linear-feedback_shift_register&quot;&gt;Linear Feedback Shift Registers
(LFSRs)&lt;/a&gt;.
Our
&lt;a href=&quot;/dsp/2017/10/27/lfsr.html&quot;&gt;first post&lt;/a&gt;
examined how to generate a
&lt;a href=&quot;https://wikipedia.org/wiki/Linear-feedback_shift_register&quot;&gt;Linear Feedback Shift Register
(LFSR)&lt;/a&gt;
in Verilog, and our
second post
walked through an example of a 5-bit
&lt;a href=&quot;https://wikipedia.org/wiki/Linear-feedback_shift_register&quot;&gt;LFSR&lt;/a&gt;.
However, neither of these developments have solved the problem I had
initially.&lt;/p&gt;

&lt;table style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 1: System Identification Setup&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/chanid.svg&quot; alt=&quot;System setup for System ID: one FPGA creates a noise source, the other examines it&quot; width=&quot;320&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;As you may recall, I wanted to use an
&lt;a href=&quot;https://wikipedia.org/wiki/Linear-feedback_shift_register&quot;&gt;LFSR&lt;/a&gt;
to do &lt;a href=&quot;https://en.wikipedia.org/wiki/System_identification&quot;&gt;channel
estimation&lt;/a&gt;.
My intention was to use a setup like Fig 1 to the right.  My plan is to
transmit &lt;a href=&quot;https://en.wikipedia.org/wiki/Pseudorandomness&quot;&gt;pseudorandom bits&lt;/a&gt;
out of an &lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
output pin at the fastest speed I can:
&lt;a href=&quot;https://www.xilinx.com/support/documentation/data_sheets/ds181_Artix_7_Data_Sheet.pdf&quot;&gt;950 Mbps&lt;/a&gt;
on my
&lt;a href=&quot;https://www.xilinx.com/support/documentation/data_sheets/ds180_7Series_Overview.pdf&quot;&gt;Artix-7&lt;/a&gt;
&lt;a href=&quot;https://store.digilentinc.com/arty-artix-7-fpga-development-board-for-makers-and-hobbyists/&quot;&gt;Arty&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt; board.
I’ll then receive the bits at the other end of a
&lt;a href=&quot;https://store.digilentinc.com/pmod-cable-kit-12-pin&quot;&gt;12” pmod cable&lt;/a&gt;
representing my channel, and examine the waveform at the other end to get
an &lt;a href=&quot;https://en.wikipedia.org/wiki/System_identification&quot;&gt;estimate of the channel throughput and
distortion&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Indeed, if all goes well I should be able to apply &lt;a href=&quot;https://en.wikipedia.org/wiki/Channel_capacity&quot;&gt;Shannon’s Capacity
theorem&lt;/a&gt; to determine the
maximum speed of &lt;a href=&quot;https://store.digilentinc.com/pmod-cable-kit-12-pin&quot;&gt;the
channel&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;To do this, though, I need a source of
&lt;a href=&quot;https://en.wikipedia.org/wiki/Pseudorandomness&quot;&gt;pseudorandom bits&lt;/a&gt;.
Worse, &lt;a href=&quot;/dsp/2017/10/27/lfsr.html&quot;&gt;our last attempt&lt;/a&gt;
at generating
&lt;a href=&quot;https://en.wikipedia.org/wiki/Pseudorandomness&quot;&gt;pseudorandom bits&lt;/a&gt; only
generated one bit per clock, and I will need several bits per clock in order
to drive an output serializer at high speed.&lt;/p&gt;

&lt;p&gt;So let’s return to our &lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/lfsr_fib.v&quot;&gt;Fibonacci LFSR
generator&lt;/a&gt;
and see if we can &lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/lfsr.v&quot;&gt;modify it to produce more than one output per clock
period&lt;/a&gt;.
We’ll keep the setup identical to
&lt;a href=&quot;/dsp/2017/10/27/lfsr.html&quot;&gt;our first post&lt;/a&gt;,
so the only thing that needs to change today is the number of outputs
bits we need to generate.  We’ll start with describing how we’ll go about
getting these extra bits, and then discuss the code that implements this.
We’ll also do one more: let’s &lt;em&gt;formally prove&lt;/em&gt; at the end of our development,
that our resulting implementation actually works.&lt;/p&gt;

&lt;h2 id=&quot;getting-that-next-bit&quot;&gt;Getting that next bit&lt;/h2&gt;

&lt;p&gt;Our task is create an
&lt;a href=&quot;https://wikipedia.org/wiki/Linear-feedback_shift_register&quot;&gt;LFSR&lt;/a&gt;
that produces &lt;code class=&quot;highlighter-rouge&quot;&gt;WS&lt;/code&gt; bits at a time–rather than just one.  (&lt;code class=&quot;highlighter-rouge&quot;&gt;WS&lt;/code&gt;= Word Size)
The question, though, is how shall we do this?&lt;/p&gt;

&lt;table style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 2: Example LFSR&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/lfsr-fib5.svg&quot; alt=&quot;An example 5-tap LFSR&quot; width=&quot;360&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;We’ll use the
&lt;a href=&quot;/dsp/2017/11/11/lfsr-example.html&quot;&gt;example&lt;/a&gt;
&lt;a href=&quot;https://wikipedia.org/wiki/Linear-feedback_shift_register&quot;&gt;LFSR&lt;/a&gt;
&lt;a href=&quot;/dsp/2017/11/11/lfsr-example.html&quot;&gt;we presented earlier&lt;/a&gt;
for discussion and as an example along the way.  You can see
&lt;a href=&quot;/dsp/2017/11/11/lfsr-example.html&quot;&gt;this example&lt;/a&gt;
in Fig 2 at the right.  It’s a simple five stage
&lt;a href=&quot;https://wikipedia.org/wiki/Linear-feedback_shift_register&quot;&gt;LFSR&lt;/a&gt;,
with a feedback equation defined by &lt;code class=&quot;highlighter-rouge&quot;&gt;TAPS=5&#39;b00101&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Let’s begin our development by imagining an infinite stream of (constant)
bits in our shift register, &lt;code class=&quot;highlighter-rouge&quot;&gt;sreg&lt;/code&gt;.  Each of these bits satisfies the
relationship given by the Fibonacci
&lt;a href=&quot;https://en.wikipedia.org/wiki/Finite_field&quot;&gt;GF(2)&lt;/a&gt; equation
we started with.  When we presented this equation, we had bits &lt;code class=&quot;highlighter-rouge&quot;&gt;MSB:0&lt;/code&gt; defined
and we just needed to calculate the next bit, &lt;code class=&quot;highlighter-rouge&quot;&gt;MSB+1&lt;/code&gt;,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;sreg[MSB+1] = ^(sreg[MSB:0] &amp;amp; TAPS);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;You may also remember, from the discussion of an
&lt;a href=&quot;/dsp/2017/11/11/lfsr-example.html&quot;&gt;example&lt;/a&gt;
&lt;a href=&quot;https://wikipedia.org/wiki/Linear-feedback_shift_register&quot;&gt;LFSR&lt;/a&gt;, that these
&lt;code class=&quot;highlighter-rouge&quot;&gt;MSB:0&lt;/code&gt; bits have no required relationship between them–save that they cannot
all be zero.&lt;/p&gt;

&lt;p&gt;Now let’s see what it will take to calculate bit &lt;code class=&quot;highlighter-rouge&quot;&gt;MSB+2&lt;/code&gt;.  We can start with
our equation for the next bit, and apply it to bits &lt;code class=&quot;highlighter-rouge&quot;&gt;[MSB+1:1]&lt;/code&gt; to get bit
&lt;code class=&quot;highlighter-rouge&quot;&gt;MSB+2&lt;/code&gt;,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;sreg[MSB+2]     = ^(sreg[MSB+1:1] &amp;amp; TAPS);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;We’ll have to get rid of the reference to &lt;code class=&quot;highlighter-rouge&quot;&gt;sreg[MSB+1]&lt;/code&gt;, though, before this
equation will be useful for us.&lt;/p&gt;

&lt;p&gt;To get there, let’s split this new equation into two parts.&lt;/p&gt;

&lt;table style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 3: One more bit&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/lfsr-fib5-x1.svg&quot; alt=&quot;Getting one extra bit from a 5-tap LFSR&quot; width=&quot;420&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;The first part will be due to the bits in &lt;code class=&quot;highlighter-rouge&quot;&gt;sreg[MSB:1]&lt;/code&gt;.  We can represent
this part as &lt;code class=&quot;highlighter-rouge&quot;&gt;sreg[MSB:0]&amp;amp;(TAPS&amp;lt;&amp;lt;1)&lt;/code&gt;.  This represents the bits that we already
know.  You can see this how this would affect our
&lt;a href=&quot;/dsp/2017/11/11/lfsr-example.html&quot;&gt;example&lt;/a&gt;
&lt;a href=&quot;https://wikipedia.org/wiki/Linear-feedback_shift_register&quot;&gt;LFSR&lt;/a&gt;
in Fig 3.  If you compare Fig 3 with Fig 2, you can see how the taps to
generate the next bit are the same as the ones shown in Fig 2, save only that
they’ve been moved one stage to the left.&lt;/p&gt;

&lt;p&gt;The &lt;a href=&quot;/dsp/2017/11/11/lfsr-example.html&quot;&gt;LFSR in our example&lt;/a&gt;
is simple enough that we can apply this same technique
to even get a second bit from the taps we were given, as Fig 4 below shows.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 4: Two more bits&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/lfsr-fib5-x2.svg&quot; alt=&quot;The second extra bit&quot; width=&quot;480&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Where the &lt;a href=&quot;/dsp/2017/11/11/lfsr-example.html&quot;&gt;example&lt;/a&gt;
falls apart is when you need to reference a bit that isn’t present in the
original shift register.  For that, we need to move to the second part of
our equation.&lt;/p&gt;

&lt;p&gt;This second part, &lt;code class=&quot;highlighter-rouge&quot;&gt;sreg[MSB+1]&amp;amp;TAPS[MSB]&lt;/code&gt; will
need some work.  In this case, though, we already have an equation for
&lt;code class=&quot;highlighter-rouge&quot;&gt;sreg[MSB+1]&lt;/code&gt; (above).  Therefore we can substitute that equation for
&lt;code class=&quot;highlighter-rouge&quot;&gt;sreg[MSB+1]&lt;/code&gt; into our equation for &lt;code class=&quot;highlighter-rouge&quot;&gt;sreg[MSB+2]&lt;/code&gt; in order to get a new
expression for &lt;code class=&quot;highlighter-rouge&quot;&gt;sreg[MSB+2]&lt;/code&gt; that depends only upon &lt;code class=&quot;highlighter-rouge&quot;&gt;sreg[MSB:0]&lt;/code&gt;,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;sreg[MSB+2]     = ^(sreg &amp;amp; (TAPS&amp;lt;&amp;lt;1)) ^ (TAPS[MSB]&amp;amp;(sreg &amp;amp; TAPS));&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Perhaps a picture will explain this better.  Consider Fig 5 below.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 5: Getting a third bit&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/lfsr-fib5-x3.svg&quot; alt=&quot;Getting a bit not described by the initial register taps&quot; width=&quot;540&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;In this figure, you can see the remains of the taps that were being shifted
to the left, and a broken reference to a bit that isn’t in our set from
&lt;code class=&quot;highlighter-rouge&quot;&gt;MSB:0&lt;/code&gt;.  However, instead of adding the bit we don’t have, we instead
add the equation for that bit.  The result is that our new bit, in this
&lt;a href=&quot;/dsp/2017/11/11/lfsr-example.html&quot;&gt;example&lt;/a&gt;
&lt;a href=&quot;https://wikipedia.org/wiki/Linear-feedback_shift_register&quot;&gt;LFSR&lt;/a&gt;
depends upon three bits from our shift register, instead of just the two.&lt;/p&gt;

&lt;p&gt;Let’s simplify this expression a touch further, though.
If we take another look at the equation above, we can now use the &lt;a href=&quot;https://en.wikipedia.org/wiki/Distributive_property&quot;&gt;distributive
property&lt;/a&gt;
to collect our terms.  Specifically, we’ll factor out the &lt;code class=&quot;highlighter-rouge&quot;&gt;sreg&lt;/code&gt; term to the
left, and the values multiplied by the &lt;code class=&quot;highlighter-rouge&quot;&gt;sreg&lt;/code&gt; vector together into a new
term on the right,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;sreg[MSB+2]     = ^(sreg &amp;amp; ( (TAPS&amp;lt;&amp;lt;1) ^ (TAPS[MSB] ? TAPS : 0)));&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;In this equation, the portion of our expression to the right of
the &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;amp;&lt;/code&gt; looks very much like an expression similar to our expression for
&lt;code class=&quot;highlighter-rouge&quot;&gt;sreg[MSB+1]&lt;/code&gt;.  Specifically, this right half expression looks like a vector
that, when taken as an inner product with &lt;code class=&quot;highlighter-rouge&quot;&gt;sreg&lt;/code&gt;, produces our result–just
like the &lt;code class=&quot;highlighter-rouge&quot;&gt;TAPS&lt;/code&gt; vector did for &lt;code class=&quot;highlighter-rouge&quot;&gt;sreg[MSB+1]&lt;/code&gt;.  Even better, this vector
is a constant–depending only upon the &lt;code class=&quot;highlighter-rouge&quot;&gt;TAPS&lt;/code&gt; parameter.  Let’s use this.
We’ll define &lt;code class=&quot;highlighter-rouge&quot;&gt;tapv[0]&lt;/code&gt; to be our &lt;code class=&quot;highlighter-rouge&quot;&gt;TAPS&lt;/code&gt;, and then &lt;code class=&quot;highlighter-rouge&quot;&gt;tapv[1]&lt;/code&gt; to be this value.&lt;/p&gt;

&lt;p&gt;We can then repeat this derivation.  Doing so will reveal a formula for
&lt;code class=&quot;highlighter-rouge&quot;&gt;tapv[k+1]&lt;/code&gt; based upon &lt;code class=&quot;highlighter-rouge&quot;&gt;tapv[k]&lt;/code&gt;.  In particular,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;tapv[k+1] = (tapv[k] &amp;lt;&amp;lt;1) ^ (tapv[k][MSB] ? TAPS : 0)));&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This &lt;code class=&quot;highlighter-rouge&quot;&gt;tapv&lt;/code&gt; array is the key we need to build our code below.&lt;/p&gt;

&lt;h2 id=&quot;a-multi-step-lfsr-implementation&quot;&gt;A Multi-Step LFSR Implementation&lt;/h2&gt;

&lt;p&gt;Now that we have an equation for future output bits, it’s time to
build our multi-step shift register.  Feel free to
follow along in the &lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/lfsr.v&quot;&gt;code we’re creating
here&lt;/a&gt;, as
we’ll only discuss the basic highlights below.&lt;/p&gt;

&lt;p&gt;Our goal is to extend &lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/lfsr_fib.v&quot;&gt;our origianal
Fibonacci&lt;/a&gt;
&lt;a href=&quot;https://wikipedia.org/wiki/Linear-feedback_shift_register&quot;&gt;LFSR&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/lfsr_fib.v&quot;&gt;code&lt;/a&gt;
to output &lt;code class=&quot;highlighter-rouge&quot;&gt;WS&lt;/code&gt; bits per clock, where &lt;code class=&quot;highlighter-rouge&quot;&gt;WS&lt;/code&gt; is given by a parameter.
This means we’ll need to calculate &lt;code class=&quot;highlighter-rouge&quot;&gt;WS-1&lt;/code&gt; more bits than we did the
&lt;a href=&quot;/dsp/2017/10/27/lfsr.html&quot;&gt;last time&lt;/a&gt;.  It also means
that our shift register, which only used to be &lt;code class=&quot;highlighter-rouge&quot;&gt;LN&lt;/code&gt; bits long, will now need
to have &lt;code class=&quot;highlighter-rouge&quot;&gt;LN+(WS-1)&lt;/code&gt; elements in it.  Of these, we’ll use the bottom &lt;code class=&quot;highlighter-rouge&quot;&gt;WS&lt;/code&gt; bits
as our output bits.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	assign	o_word=sreg[WS-1:0];&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;But I’m getting ahead of myself.  Before we can get to &lt;code class=&quot;highlighter-rouge&quot;&gt;o_word&lt;/code&gt;, there’s a
lot of other work to be done first.&lt;/p&gt;

&lt;p&gt;We’ll start with the equations we just worked out in the last section.  We’ll
place these &lt;code class=&quot;highlighter-rouge&quot;&gt;tapv[]&lt;/code&gt; values into an array of &lt;code class=&quot;highlighter-rouge&quot;&gt;WS&lt;/code&gt; elements, each as
wide as our underlying
&lt;a href=&quot;https://wikipedia.org/wiki/Linear-feedback_shift_register&quot;&gt;LFSR&lt;/a&gt;,
or &lt;code class=&quot;highlighter-rouge&quot;&gt;LN&lt;/code&gt; bits long.&lt;/p&gt;

&lt;p&gt;The first of these equations is the one we’ve used before, &lt;code class=&quot;highlighter-rouge&quot;&gt;tapv[0]&lt;/code&gt;,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	assign	tapv[0] = TAPS;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;From here we can use the recursive equation derived above to get the rest,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	genvar	k;
	generate for(k=1; k&amp;lt;WS; k=k+1)
	begin : PRECALCULATING_TAP_VALUE
		assign	tapv[k] = (tapv[k-1]&amp;lt;&amp;lt;1)^((tapv[k-1][(LN-1)])?TAPS:0);
	end endgenerate&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;If you didn’t manage to follow the development of these equations above,
don’t worry.  We’ll
“&lt;a href=&quot;https://en.wikipedia.org/wiki/Formal_verification&quot;&gt;prove&lt;/a&gt;”
these equations work below in the next section.&lt;/p&gt;

&lt;p&gt;The next trick is the reset value.&lt;/p&gt;

&lt;p&gt;You may remember before, when we had one new bit per time step, that we set
our state space to an &lt;code class=&quot;highlighter-rouge&quot;&gt;INITIAL_FILL&lt;/code&gt; value.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	assign	reset_value[(LN-1):0] = INITIAL_FILL;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This reset value then dictated the first &lt;code class=&quot;highlighter-rouge&quot;&gt;LN&lt;/code&gt; bits out of our device.&lt;/p&gt;

&lt;p&gt;This won’t quite work for our multi-step core.  First, the &lt;code class=&quot;highlighter-rouge&quot;&gt;INITIAL_FILL&lt;/code&gt;
vector needs to have &lt;code class=&quot;highlighter-rouge&quot;&gt;WS-1&lt;/code&gt; additional elements to it.  Then, to make matters
worse, all of those bits need to maintain the
&lt;a href=&quot;https://wikipedia.org/wiki/Linear-feedback_shift_register&quot;&gt;LFSR&lt;/a&gt;
relationship between them.  So while the statement above works for the first
&lt;code class=&quot;highlighter-rouge&quot;&gt;LN&lt;/code&gt; bits, we’ll still need to determine the next &lt;code class=&quot;highlighter-rouge&quot;&gt;WS-1&lt;/code&gt; bits.&lt;/p&gt;

&lt;p&gt;We can get these next several bits of the &lt;code class=&quot;highlighter-rouge&quot;&gt;reset_value&lt;/code&gt; by running the first
several bits of the &lt;code class=&quot;highlighter-rouge&quot;&gt;reset_value&lt;/code&gt; through &lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/lfsr_fib.v&quot;&gt;our
Fibonacci&lt;/a&gt;
&lt;a href=&quot;https://wikipedia.org/wiki/Linear-feedback_shift_register&quot;&gt;LFSR&lt;/a&gt;
equation.  This is a zero cost operation: every part of this equation
is known and constant.  Therefore the synthesizer can simplify the code
before our core ever gets mapped to logic.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	generate
	for(k=0; k&amp;lt;WS-1; k=k+1)
	begin : CALC_RESET
		assign	reset_value[(LN+k)] = ^(reset_value[ k +: LN]&amp;amp;TAPS);
	end endgenerate&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;While this works well to develop &lt;code class=&quot;highlighter-rouge&quot;&gt;reset_value&lt;/code&gt;, it doesn’t work as well
as an initial value for our &lt;code class=&quot;highlighter-rouge&quot;&gt;sreg&lt;/code&gt;.  We’d like to say,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;initial	sreg = reset_value;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;However, this only works with some synthesizers, such as
&lt;a href=&quot;http://www.clifford.at/yosys&quot;&gt;yosys&lt;/a&gt;,
and not with others, like
&lt;a href=&quot;https://www.veripool.org/wiki/verilator&quot;&gt;Verilator&lt;/a&gt;.
For those others, we’ll set &lt;code class=&quot;highlighter-rouge&quot;&gt;sreg&lt;/code&gt; initially to
&lt;code class=&quot;highlighter-rouge&quot;&gt;INITIAL_FILL &amp;lt;&amp;lt; (WS-1)&lt;/code&gt;, and then
use &lt;code class=&quot;highlighter-rouge&quot;&gt;reset_value&lt;/code&gt; for any subsequent resets.  This will still give us the
same sequence, with the only problem being that the first &lt;code class=&quot;highlighter-rouge&quot;&gt;WS-1&lt;/code&gt; values
will be zero instead of those associated with the fill.&lt;/p&gt;

&lt;p&gt;Now that we have our tap equations, &lt;code class=&quot;highlighter-rouge&quot;&gt;tapv[]&lt;/code&gt;, and our &lt;code class=&quot;highlighter-rouge&quot;&gt;reset_value&lt;/code&gt;, we can
now move on to the state register itself.  In the
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/lfsr_fib.v&quot;&gt;typical&lt;/a&gt;
&lt;a href=&quot;https://wikipedia.org/wiki/Linear-feedback_shift_register&quot;&gt;LFSR&lt;/a&gt;,
all but one bit of the new state register is known.  These known bits are
given by shifting the register one step to the right, whereas the last bit
is generated by the &lt;code class=&quot;highlighter-rouge&quot;&gt;TAPS&lt;/code&gt; equation.&lt;/p&gt;

&lt;p&gt;Let’s do the same thing here and shift these known bits first,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(posedge i_clk)
		if (i_reset)
			sreg[(LN-2):0] &amp;lt;= reset_value[(LN-2):0];
		else if (i_ce)
			sreg[(LN-2):0] &amp;lt;= sreg[(LN+WS-2):WS];&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Those are the easy bits.&lt;/p&gt;

&lt;p&gt;After those easy bits, our first next bit is determined by the
original Fibonacci
&lt;a href=&quot;https://wikipedia.org/wiki/Linear-feedback_shift_register&quot;&gt;LFSR&lt;/a&gt;
equation.  That’s the one we built into our first &lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/lfsr_fib.v&quot;&gt;Fibonacci
LFSR&lt;/a&gt; module.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;sreg[MSB] &amp;lt;= ^(sreg &amp;amp; TAPS);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The rest of the bits are calculated in the same fashion, with the exception
that the equation for them, in particular the &lt;code class=&quot;highlighter-rouge&quot;&gt;tapv[k]&lt;/code&gt; coefficients,
is different from one bit to the next.  So, our next step is then to
walk through those extra bits applying the &lt;code class=&quot;highlighter-rouge&quot;&gt;tapv[k]&lt;/code&gt; equations as appropriate
to generate each new bit.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	generate
	for(k=0; k&amp;lt;WS; k = k+1)
	begin : RUN_LFSR
		always @(posedge i_clk)
			if (i_reset)
				sreg[LN+k-1] &amp;lt;= reset_value[LN+k-1];
			else if (i_ce)
				sreg[(LN+k-1)] &amp;lt;=
					^(sreg[(LN+WS-2):(WS-1)]&amp;amp;tapv[k]);
	end endgenerate&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Did you notice how we also cycled through the various &lt;code class=&quot;highlighter-rouge&quot;&gt;tapv[k]&lt;/code&gt; expressions?
This is just implementing the equations we calculated above.&lt;/p&gt;

&lt;p&gt;That’s it.  It’s still simple, but there is just a little more simple involved
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/lfsr.v&quot;&gt;in this version&lt;/a&gt;
over the &lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/lfsr_fib.v&quot;&gt;last
version&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Put together, we just calculated &lt;code class=&quot;highlighter-rouge&quot;&gt;LN+WS-1&lt;/code&gt; bits.  &lt;code class=&quot;highlighter-rouge&quot;&gt;LN-1&lt;/code&gt; of these are
calculated the same as before–by shifting the shift register.  The next bit
is still calculated by our original &lt;code class=&quot;highlighter-rouge&quot;&gt;TAPS&lt;/code&gt; equation, just like we did with
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/lfsr_fib.v&quot;&gt;our initial Fibonacci implementation&lt;/a&gt;.
The last &lt;code class=&quot;highlighter-rouge&quot;&gt;WS-1&lt;/code&gt; bits were then calculated in the
exact same way with the only exception being that the equation, &lt;code class=&quot;highlighter-rouge&quot;&gt;tapv[k]&lt;/code&gt;,
changed on a bit-by-bit basis.&lt;/p&gt;

&lt;p&gt;But, let’s come back to our earlier question, will this really “work”?  Will
all these equations really produce the sequence we want?&lt;/p&gt;

&lt;p&gt;To answer that question, let’s see if we can get the computer to
“&lt;a href=&quot;https://en.wikipedia.org/wiki/Formal_verification&quot;&gt;prove&lt;/a&gt;”
that &lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/lfsr.v&quot;&gt;this new
form&lt;/a&gt; works.&lt;/p&gt;

&lt;h2 id=&quot;applying-formal-methods&quot;&gt;Applying Formal Methods&lt;/h2&gt;

&lt;p&gt;I discussed the basics of using
&lt;a href=&quot;https://en.wikipedia.org/wiki/Formal_verification&quot;&gt;formal methods&lt;/a&gt;
using &lt;a href=&quot;https://www.clifford.at/yosys&quot;&gt;yosys-smtbmc&lt;/a&gt; in a
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;previous post&lt;/a&gt;.
The basic idea behind
&lt;a href=&quot;https://en.wikipedia.org/wiki/Formal_verification&quot;&gt;formal methods&lt;/a&gt;
is to define a state space, and within it the space of invalid states.
The state space is initially defined by all of the register values within
your design.  It is restricted further, made smaller that is, with &lt;code class=&quot;highlighter-rouge&quot;&gt;assume&lt;/code&gt;
statements as necessary.  Invalid states are defined as well, but this time
using the &lt;code class=&quot;highlighter-rouge&quot;&gt;assert&lt;/code&gt; statement.  We’ll use these two statements, &lt;code class=&quot;highlighter-rouge&quot;&gt;assume&lt;/code&gt; and
&lt;code class=&quot;highlighter-rouge&quot;&gt;assert&lt;/code&gt; with the ultimate goal of
&lt;a href=&quot;https://en.wikipedia.org/wiki/Formal_verification&quot;&gt;proving&lt;/a&gt;
that the logic above will &lt;em&gt;never&lt;/em&gt; enter into an illegal state.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Formal_verification&quot;&gt;These formal methods&lt;/a&gt;
are particularly appropriate for this multi-bit
&lt;a href=&quot;https://wikipedia.org/wiki/Linear-feedback_shift_register&quot;&gt;LFSR&lt;/a&gt;
design, since
&lt;a href=&quot;https://wikipedia.org/wiki/Linear-feedback_shift_register&quot;&gt;LFSR&lt;/a&gt;s
are so mathematically based.  In particular, the output of the
&lt;a href=&quot;https://wikipedia.org/wiki/Linear-feedback_shift_register&quot;&gt;LFSR&lt;/a&gt;
needs to strictly satisfy a mathematical equation–one that the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Formal_verification&quot;&gt;formal equation solver&lt;/a&gt;
can verify for us.&lt;/p&gt;

&lt;p&gt;As &lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;before&lt;/a&gt;,
we’ll use &lt;a href=&quot;https://www.clifford.at/yosys&quot;&gt;yosys&lt;/a&gt;
to generate a list of properties in a
&lt;a href=&quot;http://stp.github.io/smt-input-language/&quot;&gt;format&lt;/a&gt; that
&lt;a href=&quot;http://yices.csl.sri.com&quot;&gt;yices&lt;/a&gt; can understand.  When processing a file in
this manner, &lt;a href=&quot;https://www.clifford.at/yosys&quot;&gt;yosys&lt;/a&gt; will define the &lt;code class=&quot;highlighter-rouge&quot;&gt;FORMAL&lt;/code&gt;
pre-processor directive for us.  That allows us to begin our &lt;code class=&quot;highlighter-rouge&quot;&gt;FORMAL&lt;/code&gt;
verification section with an &lt;code class=&quot;highlighter-rouge&quot;&gt;ifdef&lt;/code&gt;,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;`ifdef	FORMAL&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Our plan will be to then use &lt;a href=&quot;https://www.clifford.at/yosys&quot;&gt;yosys-smtbmc&lt;/a&gt;
to then drive the &lt;a href=&quot;http://yices.csl.sri.com&quot;&gt;yices&lt;/a&gt; theorem prover to prove
that our
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/lfsr.v&quot;&gt;multi-step&lt;/a&gt;
&lt;a href=&quot;https://wikipedia.org/wiki/Linear-feedback_shift_register&quot;&gt;LFSR&lt;/a&gt; actually
works.&lt;/p&gt;

&lt;p&gt;The first step is to restrict the search state space.&lt;/p&gt;

&lt;p&gt;We’ll use the &lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;approach
we presented before&lt;/a&gt;
to create a clock, and an &lt;code class=&quot;highlighter-rouge&quot;&gt;f_past_valid&lt;/code&gt; flag.  This latter flag will tell
us whenever the &lt;code class=&quot;highlighter-rouge&quot;&gt;$past()&lt;/code&gt; directive will yield valid results.&lt;/p&gt;

&lt;p&gt;Now using that assumed clock, our first
&lt;a href=&quot;https://wikipedia.org/wiki/Linear-feedback_shift_register&quot;&gt;LFSR&lt;/a&gt;
specific step will restrict the space of all possibilities by
simply assuming that &lt;code class=&quot;highlighter-rouge&quot;&gt;i_reset&lt;/code&gt; is true on startup.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	initial	assume(i_reset);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Next, we’ll assert that the bottom &lt;code class=&quot;highlighter-rouge&quot;&gt;LN&lt;/code&gt; bits are equal to the &lt;code class=&quot;highlighter-rouge&quot;&gt;INITIAL_FILL&lt;/code&gt;
on the clock following any reset.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(posedge i_clk)
		if ((f_past_valid)&amp;amp;&amp;amp;($past(i_reset)))
			assert(sreg[(LN-1):0] == INITIAL_FILL);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Now that we’ve dealt with the &lt;code class=&quot;highlighter-rouge&quot;&gt;i_reset&lt;/code&gt; case, we can move on to the regular
register bits.&lt;/p&gt;

&lt;p&gt;The first test is whether or not the first of the new register bits,
bit &lt;code class=&quot;highlighter-rouge&quot;&gt;LN-1&lt;/code&gt;, is valid.  This bit is the one produced via the
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/lfsr_fib.v&quot;&gt;original Fibonacci
configuration&lt;/a&gt;
&lt;a href=&quot;/dsp/2017/10/27/lfsr.html&quot;&gt;we presented before&lt;/a&gt;.
Here we’ll just apply it to the values left in our
shift register, plus the one we just shifted out–the one still found in
&lt;code class=&quot;highlighter-rouge&quot;&gt;$past(sreg[WS-1])&lt;/code&gt;.  Note that this wouldve been &lt;code class=&quot;highlighter-rouge&quot;&gt;$past(sreg[0])&lt;/code&gt; in our
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/lfsr_fib.v&quot;&gt;previous
version&lt;/a&gt;, but
since we are now generating another &lt;code class=&quot;highlighter-rouge&quot;&gt;WS-1&lt;/code&gt; bits, that last bit shifted out
is no longer the &lt;code class=&quot;highlighter-rouge&quot;&gt;0&lt;/code&gt; bit from before.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(posedge i_clk)
		if ((f_past_valid)&amp;amp;&amp;amp;(!$past(i_reset))&amp;amp;&amp;amp;($past(i_ce)))
			assert(sreg[LN-1]
				== ^({sreg[(LN-2):0], $past(sreg[WS-1])}
					&amp;amp; TAPS));&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Our new implementation also defines another &lt;code class=&quot;highlighter-rouge&quot;&gt;WS-1&lt;/code&gt; bits that we want to
validate.  Because this is a very mathematically defined
&lt;a href=&quot;https://wikipedia.org/wiki/Linear-feedback_shift_register&quot;&gt;LFSR&lt;/a&gt;,
there’s a mathematical relationship between all of these bits.  All we
need to do to
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formally validate&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/lfsr.v&quot;&gt;this code&lt;/a&gt;
is to check our current state bits against the equation that was supposed
to generate them one at a time.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;generate
	for(k=0; k&amp;lt;WS-1; k=k+1)
		always @(posedge i_clk)
			if ((f_past_valid)&amp;amp;&amp;amp;(!$past(i_reset)))
			assert(sreg[LN+k] == ^(sreg[(LN-1+k):k]&amp;amp;TAPS));
	endgenerate&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This is the majority of the proof.  If this works, all of our &lt;code class=&quot;highlighter-rouge&quot;&gt;tapv[]&lt;/code&gt; work
will be verified.&lt;/p&gt;

&lt;p&gt;There is one more vital part to our proof: we need to prove that &lt;code class=&quot;highlighter-rouge&quot;&gt;sreg&lt;/code&gt;
will never be equal to zero.  You may recall when we
&lt;a href=&quot;/dsp/2017/10/27/lfsr.html&quot;&gt;last discussed&lt;/a&gt;
&lt;a href=&quot;https://wikipedia.org/wiki/Linear-feedback_shift_register&quot;&gt;LFSR&lt;/a&gt;s
that we highlighted the problem with a
zero register: once the register &lt;code class=&quot;highlighter-rouge&quot;&gt;sreg&lt;/code&gt; becomes zero (if ever) then it will
cease to produce
&lt;a href=&quot;https://en.wikipedia.org/wiki/Pseudorandomness&quot;&gt;pseudorandom&lt;/a&gt;
numbers.  We’ll allow the &lt;a href=&quot;http://yices.csl.sri.com&quot;&gt;theorem prover&lt;/a&gt;
to verify that this never happens.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(*)
		assert(sreg[(LN+WS-2):(WS-1)] != 0);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;That’s the last of the file, and the last of the proof.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;`endif	// FORMAL
endmodule&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;All that’s left is to run the
&lt;a href=&quot;https://www.clifford.at/yosys&quot;&gt;theorem prover&lt;/a&gt;
and see how we did!&lt;/p&gt;

&lt;p&gt;In case you haven’t been following along, you can find the example file we
just created
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/lfsr.v&quot;&gt;here&lt;/a&gt;.  You
can also find the &lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/bench/formal/Makefile&quot;&gt;Makefile&lt;/a&gt;
and other files associated with driving the
&lt;a href=&quot;http://yices.csl.sri.com&quot;&gt;formal theorem prover&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/tree/master/bench/formal&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;Now that I have an
&lt;a href=&quot;https://wikipedia.org/wiki/Linear-feedback_shift_register&quot;&gt;LFSR&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/lfsr.v&quot;&gt;implementation&lt;/a&gt;
that I can step 8-14 times per clock, I should be able to create a high speed
data stream from one
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
and send it to another.  The difference between what the second
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
observes and what was actually sent will be any channel effects.  In other
words, I’m now ready to move my
&lt;a href=&quot;https://en.wikipedia.org/wiki/System_identification&quot;&gt;channel identification&lt;/a&gt;
problem forward one step to measure just how much information can be reasonably
stuffed through this
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
&lt;a href=&quot;https://store.digilentinc.com/pmod-cable-kit-12-pin&quot;&gt;I/O channel&lt;/a&gt;.&lt;/p&gt;
&lt;hr /&gt;&lt;p&gt;&lt;em&gt;For man also knoweth not his time: as the fishes that are taken in an evil net, and as the birds that are caught in the snare; so are the sons of men snared in an evil time, when it falleth suddenly upon them. (Eccl 9:12)&lt;/em&gt;</description>
        <pubDate>Mon, 13 Nov 2017 00:00:00 -0500</pubDate>
        <link>http://zipcpu.com/dsp/2017/11/13/lfsr-multi.html</link>
        <guid isPermaLink="true">http://zipcpu.com/dsp/2017/11/13/lfsr-multi.html</guid>
        
        
        <category>dsp</category>
        
      </item>
    
  </channel>
</rss>
