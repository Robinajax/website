<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>The ZipCPU by Gisselquist Technology</title>
    <description>The ZipCPU blog, featuring how to discussions of FPGA and soft-core CPU design.  This site will be focused on Verilog solutions, using exclusively OpenSource IP products for FPGA design.  Particular focus areas include topics often left out of more mainstreeam FPGA design courses such as how to debug an FPGA design.
</description>
    <link>http://zipcpu.com/</link>
    <atom:link href="http://zipcpu.com/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Thu, 31 Aug 2017 08:31:46 -0400</pubDate>
    <lastBuildDate>Thu, 31 Aug 2017 08:31:46 -0400</lastBuildDate>
    <generator>Jekyll v3.0.1</generator>
    <image>
      <url>http://zipcpu.com/img/gt-rss.png</url>
      <title></title>
      <link></link>
    </image>
    
      <item>
        <title>Using a CORDIC to calculate sines and cosines in an FPGA</title>
        <description>&lt;p&gt;We’ve now presented two separate algorithms that can be used for calculating
a sine wave: a &lt;a href=&quot;/dsp/2017/07/11/simplest-sinewave-generator.html&quot;&gt;very simple sinewave table
lookup&lt;/a&gt;,
and a &lt;a href=&quot;/dsp/2017/08/26/quarterwave.html&quot;&gt;more complicated quarter-wave table lookup
method&lt;/a&gt;.  Both of these
approaches used only a minimum number of clocks, although their precision
was somewhat limited.&lt;/p&gt;

&lt;p&gt;Today, let’s look at how to implement a
&lt;a href=&quot;https://en.wikipedia.org/wiki/CORDIC&quot;&gt;&lt;strong&gt;CO&lt;/strong&gt;ordinate &lt;strong&gt;R&lt;/strong&gt;otation &lt;strong&gt;DI&lt;/strong&gt;gital &lt;strong&gt;C&lt;/strong&gt;omputer
(CORDIC)&lt;/a&gt;
algorithm within an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;.&lt;/p&gt;

&lt;table style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 1: The CORDIC problem description&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/cordic-problem-setup.svg&quot; alt=&quot;Setting up a CORDIC&quot; width=&quot;320&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;If you’ve never worked with a
&lt;a href=&quot;https://en.wikipedia.org/wiki/CORDIC&quot;&gt;CORDIC&lt;/a&gt;
algorithm before, the algorithms are all
based around specific
&lt;a href=&quot;https://en.wikipedia.org/wiki/Rotation_matrix&quot;&gt;rotation matrices&lt;/a&gt;
which we will explain first.  These rotation matrices can be strung together
to accomplish many digital logic purposes.  For today’s discussion, though,
we will be rotating a two-dimensional vector by a requested counter-clockwise
angle.  Thus, the inputs will be x and y values, &lt;code class=&quot;highlighter-rouge&quot;&gt;i_xval&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;i_yval&lt;/code&gt;,
together with a requested phase rotation, &lt;code class=&quot;highlighter-rouge&quot;&gt;i_phase&lt;/code&gt;, whereas the outputs
will just be a rotated x and y value, &lt;code class=&quot;highlighter-rouge&quot;&gt;o_xval&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;o_yval&lt;/code&gt;–as shown in
Fig 1.&lt;/p&gt;

&lt;h1 id=&quot;the-cordic-rotation&quot;&gt;The CORDIC rotation&lt;/h1&gt;

&lt;p&gt;But, just what is a
&lt;a href=&quot;https://en.wikipedia.org/wiki/CORDIC&quot;&gt;CORDIC&lt;/a&gt;
rotation?  Well, since all of these algorithms are built around a
&lt;a href=&quot;https://en.wikipedia.org/wiki/CORDIC&quot;&gt;CORDIC&lt;/a&gt;
rotation, let’s start by answering that question.  We’ll start with the
concept of a simple two-dimensional
&lt;a href=&quot;https://en.wikipedia.org/wiki/Rotation_matrix&quot;&gt;rotation matrix&lt;/a&gt;,
and then work from there to how that can be turned into a
&lt;a href=&quot;https://en.wikipedia.org/wiki/CORDIC&quot;&gt;CORDIC&lt;/a&gt;
rotation.&lt;/p&gt;

&lt;p&gt;A simple two-dimensional
&lt;a href=&quot;https://en.wikipedia.org/wiki/Rotation_matrix&quot;&gt;rotation matrix&lt;/a&gt;
is given by:&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/eqn-2d-rotation.png&quot; alt=&quot;Equation for a 2D rotation&quot; width=&quot;302&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;This rotation can be used to rotate a complex vector &lt;code class=&quot;highlighter-rouge&quot;&gt;exp(j*phi)&lt;/code&gt; and turn it
into another one, &lt;code class=&quot;highlighter-rouge&quot;&gt;exp(j*(phi+theta))&lt;/code&gt;, if the real value is the first value
in the given vector, and the would-be imaginary value the second (i.e. strip off
the &lt;code class=&quot;highlighter-rouge&quot;&gt;j&lt;/code&gt;).  Further, if the original vector is
simply the real number one, &lt;code class=&quot;highlighter-rouge&quot;&gt;1+j0&lt;/code&gt;, then we will have just created
&lt;code class=&quot;highlighter-rouge&quot;&gt;sin(theta)&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;cos(theta)&lt;/code&gt; in this process.&lt;/p&gt;

&lt;p&gt;This is what we are going to try to do: apply a rotation like this one.&lt;/p&gt;

&lt;p&gt;We could apply this rotation using &lt;a href=&quot;/dsp/2017/06/15/no-pi-for-you.html&quot;&gt;angles more
suited&lt;/a&gt;
for an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;,&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/eqn-no-pi-rotation.png&quot; alt=&quot;Eqn for a 2D rotation in FPGA units&quot; width=&quot;364&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;but this still leaves us with the problem that the sine and cosine aren’t
easy to calculate, leaving this rotation difficult to accomplish.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 1: CORDIC Rotation Vectors&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/cordic-rotations.svg&quot; alt=&quot;Cordic rotation vectors&quot; width=&quot;240&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;The
&lt;a href=&quot;https://en.wikipedia.org/wiki/CORDIC&quot;&gt;CORDIC&lt;/a&gt;
approach is to replace the cosine portion of this rotation matrix with a &lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt;,
and the sine portion with a &lt;code class=&quot;highlighter-rouge&quot;&gt;2^-k&lt;/code&gt;.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/eqn-bare-cordic-transform.png&quot; alt=&quot;EQN for a bare cordic stage&quot; width=&quot;281&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;You can think of this as a series of complex rotation vectors,
indexed by &lt;code class=&quot;highlighter-rouge&quot;&gt;k&lt;/code&gt;, such as those are shown in Fig 1.  Notice from the figure
that these vectors are not on the unit circle, but rather just outside the
unit circle, and they get closer and closer to the unit circle the higher
&lt;code class=&quot;highlighter-rouge&quot;&gt;k&lt;/code&gt; becomes.&lt;/p&gt;

&lt;p&gt;In other words, &lt;code class=&quot;highlighter-rouge&quot;&gt;T&lt;/code&gt; is approximately a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Rotation_matrix&quot;&gt;rotation matrix&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;T&lt;/code&gt; is also something that is easy to calculate within an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;.
It requires only adds, subtracts, and shifts.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/eqn-cordic-eqns.png&quot; alt=&quot;Cordic equations&quot; width=&quot;350&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;This can all be done with simple integer math–no multiplies or divides are
required.&lt;/p&gt;

&lt;p&gt;Of course, this transform is not a true rotation matrix.  Instead, it is a
scaled &lt;a href=&quot;https://en.wikipedia.org/wiki/Rotation_matrix&quot;&gt;rotation matrix&lt;/a&gt;.
To see this, first calculate the angles of the vectors in Fig 1 above:&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/eqn-cordic-phase.png&quot; alt=&quot;Cordic rotation phase&quot; width=&quot;168&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Then also calculate and normalize by their their lengths.  The resulting
transform, &lt;code class=&quot;highlighter-rouge&quot;&gt;T&lt;/code&gt;, is shown below:&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/eqn-cordic-transform-simplified.png&quot; alt=&quot;Eqn for the cordic stage, after simplification&quot; width=&quot;459&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;From here you can see that this is most definitely a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Rotation_matrix&quot;&gt;rotation matrix&lt;/a&gt;
with an amplitude increase associated with it.&lt;/p&gt;

&lt;p&gt;Further, as you may have guessed from Fig 1 above, we can apply a similar
rotation going in the opposite direction:&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/eqn-cordic-negative-transform.png&quot; alt=&quot;Eqn for the cordic stage, negated angle, after simplification&quot; width=&quot;459&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;These two (nearly) &lt;a href=&quot;https://en.wikipedia.org/wiki/Rotation_matrix&quot;&gt;rotation
matrices&lt;/a&gt;
form the basis of the
&lt;a href=&quot;https://en.wikipedia.org/wiki/CORDIC&quot;&gt;CORDIC&lt;/a&gt;
algorithm.&lt;/p&gt;

&lt;p&gt;The basic idea behind the
&lt;a href=&quot;https://en.wikipedia.org/wiki/CORDIC&quot;&gt;CORDIC&lt;/a&gt;
algorithm is that we can string many of these
&lt;a href=&quot;https://en.wikipedia.org/wiki/Rotation_matrix&quot;&gt;rotation matrices&lt;/a&gt;
together–either rotating by a positive &lt;code class=&quot;highlighter-rouge&quot;&gt;theta_k&lt;/code&gt; or a
negative &lt;code class=&quot;highlighter-rouge&quot;&gt;theta_k&lt;/code&gt; in each matrix.  As an example, suppose you rotated
[1, 0] by +26.57 degrees (k=1), then by 14.03 degrees (k=2), then backwards
by 7.12 degrees (k=3).  You would then
have a vector that has been rotated by 30.48 degrees.  Other than
the slight amplitude increase, that means that your resulting vector now
approximates a thirty degree phasor–and you didn’t have to do anything that
significant to get there.&lt;/p&gt;

&lt;p&gt;Further, the more of these rotation matrices you string together, the smaller
the remaining rotation becomes, and hence the closer the result will come
(in angular distance) to any desired rotation.&lt;/p&gt;

&lt;p&gt;This is what we are going to try to build today.&lt;/p&gt;

&lt;h2 id=&quot;rotating-into-range&quot;&gt;Rotating into range&lt;/h2&gt;

&lt;p&gt;The first step in building this rotation, though, is that massage the problem
so that the rotation desired is less than 45 degrees.  This comes from the
fact that the largest rotation the
&lt;a href=&quot;https://en.wikipedia.org/wiki/CORDIC&quot;&gt;CORDIC&lt;/a&gt;
rotation above can accomplish is a 45 degree rotation.  Angles beyond
45 degrees just get smaller.  Therefore, the
&lt;a href=&quot;https://en.wikipedia.org/wiki/CORDIC&quot;&gt;CORDIC&lt;/a&gt;
rotation requires an initial angular request, &lt;code class=&quot;highlighter-rouge&quot;&gt;i_phase&lt;/code&gt;, to be less than 45
degrees.  Our first problem, therefore is going to be rotating our incoming
vector so that any remaining rotation amount is 45 degrees or less.&lt;/p&gt;

&lt;p&gt;As a preliminary step, we’ll start our algorithm off by expanding the two
input values from their initial width, &lt;code class=&quot;highlighter-rouge&quot;&gt;IW&lt;/code&gt;, to a wider working width, &lt;code class=&quot;highlighter-rouge&quot;&gt;WW&lt;/code&gt;.
Because the
&lt;a href=&quot;https://en.wikipedia.org/wiki/CORDIC&quot;&gt;CORDIC&lt;/a&gt;
algorithm will also increase the magnitude of the input, this process adds one
more bit on the left–to allow for a touch of width expansion.  It also adds
a user selectable number of bits (captured as part of &lt;code class=&quot;highlighter-rouge&quot;&gt;WW&lt;/code&gt;) to the right so as
to minimize any distortion’s caused by
&lt;a href=&quot;/dsp/2017/07/22/rounding.html&quot;&gt;truncation effects&lt;/a&gt;
within the rotation.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;wire	signed [(WW-1):0]	e_xval, e_yval;
assign	e_xval = { {i_xval[(IW-1)]}, i_xval, {(WW-IW-1){1&#39;b0}} };
assign	e_yval = { {i_yval[(IW-1)]}, i_yval, {(WW-IW-1){1&#39;b0}} };&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Further, we’re going to declare our intermediate values
to be an array of &lt;code class=&quot;highlighter-rouge&quot;&gt;WW&lt;/code&gt; bits each for the intermediate &lt;code class=&quot;highlighter-rouge&quot;&gt;xv&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;yv&lt;/code&gt; values,
and an array of phase width, &lt;code class=&quot;highlighter-rouge&quot;&gt;PW&lt;/code&gt;, number of bits for the phase.  Since the
&lt;a href=&quot;https://en.wikipedia.org/wiki/CORDIC&quot;&gt;CORDIC&lt;/a&gt;
operation takes place in stages, we’ll declare &lt;code class=&quot;highlighter-rouge&quot;&gt;NSTAGES+1&lt;/code&gt; of these
values–that will create variables to hold not only the input values,
but the outputs as well.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;// Declare variables for all of the separate stages
reg	signed	[(WW-1):0]	xv	[0:(NSTAGES)];
reg	signed	[(WW-1):0]	yv	[0:(NSTAGES)];
reg		[(PW-1):0]	ph	[0:(NSTAGES)];&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The beginner needs to understand that this is not the definition of a memory,
although it might look very similar to a block RAM definition.  Rather, this
is a simplified definition of &lt;code class=&quot;highlighter-rouge&quot;&gt;NSTAGES&lt;/code&gt; of values in flip-flops.&lt;/p&gt;

&lt;p&gt;Declarations aside, that brings us to the actual logic of the
pre-&lt;a href=&quot;https://en.wikipedia.org/wiki/CORDIC&quot;&gt;CORDIC&lt;/a&gt;
section.  The goal of this section is to rotate the input by some number
of ninety-degree intervals until the remaining phase is between -45 and 45.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 2: Initial rotation&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/cordic-prerotation.svg&quot; alt=&quot;Result of the pre-CORDIC rotation&quot; width=&quot;420&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Since this is a signal processing algorithm, the “global CE” &lt;a href=&quot;/blog/2017/08/14/strategies-for-pipelining.html&quot;&gt;pipeline
strategy&lt;/a&gt;
may make the most sense.  We’ll also create logic for the &lt;a href=&quot;/blog/2017/08/14/strategies-for-pipelining.html&quot;&gt;traveling CE strategy
strategy&lt;/a&gt;
later.  For now, remember that the global CE strategy requires that nothing
changes unless a CE line is true.  Therefore, our transform begins by
checking the &lt;code class=&quot;highlighter-rouge&quot;&gt;i_ce&lt;/code&gt; line.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
if (i_ce)&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Next, we’ll want to walk through the actual rotations.&lt;/p&gt;

&lt;table style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 3: Rotation by quadrant&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/cordic-prequadrants.svg&quot; alt=&quot;Split the pre-rotation up by quadrant&quot; width=&quot;280&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;In order to get 
everything into +/- 45 degrees, we’ll want to check not only which quadrant
our phase request is within, but also which 45 degree segment of that quadrant
the angle is in, as shown in Fig 3.
Hence, we’ll check the top three bits of &lt;code class=&quot;highlighter-rouge&quot;&gt;i_phase&lt;/code&gt;, and apply a rotation
based upon them.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	case(i_phase[(PW-1):(PW-3)])&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Each rotation opportunity will set &lt;code class=&quot;highlighter-rouge&quot;&gt;xv[0]&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;yv[0]&lt;/code&gt;, and &lt;code class=&quot;highlighter-rouge&quot;&gt;ph[0]&lt;/code&gt;.  These are
the initial values of x, y, and the remaining phase to rotate through.  The
options for &lt;code class=&quot;highlighter-rouge&quot;&gt;xv[0]&lt;/code&gt; are &lt;code class=&quot;highlighter-rouge&quot;&gt;+/- e_xval&lt;/code&gt; or &lt;code class=&quot;highlighter-rouge&quot;&gt;+/- e_yval&lt;/code&gt; and likewise for &lt;code class=&quot;highlighter-rouge&quot;&gt;yv[0]&lt;/code&gt;.
Further, because these rotations are all by multiples of ninety degrees,
there’s no need to do any additions.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	3&#39;b000: begin	// 0 .. 45, No change
		xv[0] &amp;lt;= e_xval;
		yv[0] &amp;lt;= e_yval;
		ph[0] &amp;lt;= i_phase;
		end
	3&#39;b001: begin	// 45 .. 90
		xv[0] &amp;lt;= -e_yval;
		yv[0] &amp;lt;= e_xval;
		ph[0] &amp;lt;= i_phase - 30&#39;h10000000;
		end
	3&#39;b010: begin	// 90 .. 135
		xv[0] &amp;lt;= -e_yval;
		yv[0] &amp;lt;= e_xval;
		ph[0] &amp;lt;= i_phase - 30&#39;h10000000;
		end
	3&#39;b011: begin	// 135 .. 180
		xv[0] &amp;lt;= -e_xval;
		yv[0] &amp;lt;= -e_yval;
		ph[0] &amp;lt;= i_phase - 30&#39;h20000000;
		end
	3&#39;b100: begin	// 180 .. 225
		xv[0] &amp;lt;= -e_xval;
		yv[0] &amp;lt;= -e_yval;
		ph[0] &amp;lt;= i_phase - 30&#39;h20000000;
		end
	3&#39;b101: begin	// 225 .. 270
		xv[0] &amp;lt;= e_yval;
		yv[0] &amp;lt;= -e_xval;
		ph[0] &amp;lt;= i_phase - 30&#39;h30000000;
		end
	3&#39;b110: begin	// 270 .. 315
		xv[0] &amp;lt;= e_yval;
		yv[0] &amp;lt;= -e_xval;
		ph[0] &amp;lt;= i_phase - 30&#39;h30000000;
		end
	3&#39;b111: begin	// 315 .. 360, No change
		xv[0] &amp;lt;= e_xval;
		yv[0] &amp;lt;= e_yval;
		ph[0] &amp;lt;= i_phase;
		end
	endcase&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Remember: we are rotating the &lt;code class=&quot;highlighter-rouge&quot;&gt;xv&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;yv&lt;/code&gt; vector counter-clockwise, so
that the rotation remaining, &lt;code class=&quot;highlighter-rouge&quot;&gt;ph&lt;/code&gt;, is less than &lt;code class=&quot;highlighter-rouge&quot;&gt;+/- 45&lt;/code&gt; degrees.  Hence we
are rotating &lt;code class=&quot;highlighter-rouge&quot;&gt;xv&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;yv&lt;/code&gt; in a counter-clockwise direction, while the
remaining phase angle will decrease in what will look like a clock-wise
direction.&lt;/p&gt;

&lt;p&gt;This sets up the actual
&lt;a href=&quot;https://en.wikipedia.org/wiki/CORDIC&quot;&gt;CORDIC&lt;/a&gt;:
&lt;code class=&quot;highlighter-rouge&quot;&gt;xv[0]&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;yv[0]&lt;/code&gt; now need to be rotated
through &lt;code class=&quot;highlighter-rouge&quot;&gt;ph[0]&lt;/code&gt; remaining &lt;a href=&quot;/dsp/2017/06/15/no-pi-for-you.html&quot;&gt;angular
units&lt;/a&gt;.  We’ve also
guaranteed that &lt;code class=&quot;highlighter-rouge&quot;&gt;|ph[0]|&lt;/code&gt; is less than or equal to 45 degrees.&lt;/p&gt;

&lt;h2 id=&quot;rotating-to-zero&quot;&gt;Rotating to zero&lt;/h2&gt;

&lt;p&gt;The next step is to rotate the &lt;code class=&quot;highlighter-rouge&quot;&gt;xv[0]&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;yv[0]&lt;/code&gt; values through the remaining
phase angle, &lt;code class=&quot;highlighter-rouge&quot;&gt;ph[0]&lt;/code&gt;.  To do this, we’re going to check whether or not the
remaining phase is negative or positive.  If the phase is negative, we’ll
rotate by a positive &lt;code class=&quot;highlighter-rouge&quot;&gt;cordic_angle[i]&lt;/code&gt;.  If the remaining phase is positive,
we’ll rotate in the opposite direction but by the same amount.&lt;/p&gt;

&lt;p&gt;Software programmers like to look at &lt;code class=&quot;highlighter-rouge&quot;&gt;for&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;while&lt;/code&gt; loops in Verilog and
think of them like their &lt;code class=&quot;highlighter-rouge&quot;&gt;for&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;while&lt;/code&gt; counterparts in software.  HDL
loops, however, are &lt;em&gt;nothing&lt;/em&gt; like software loops.  Software loops repeat the
same instruction, one after another in time.  HDL loops on the other hand
repeat the instruction in space on the chip by creating multiple copies of
the same logic, all of which will be executed in parallel.&lt;/p&gt;

&lt;p&gt;This is one of those rare cases where a &lt;code class=&quot;highlighter-rouge&quot;&gt;for&lt;/code&gt; loop makes sense in Verilog.  The
&lt;a href=&quot;https://en.wikipedia.org/wiki/CORDIC&quot;&gt;CORDIC&lt;/a&gt;
algorithm repeats nearly the same logic &lt;code class=&quot;highlighter-rouge&quot;&gt;NSTAGES&lt;/code&gt; times over.  Hence, this
loop generates &lt;code class=&quot;highlighter-rouge&quot;&gt;NSTAGES&lt;/code&gt; pieces of logic, each of which advances the
prior stage by one clock.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;genvar	i;
generate for(i=0; i&amp;lt;NSTAGES; i=i+1) begin : CORDICops&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Within this for loop, we’ll create several always blocks.  Each block
first makes sure that nothing changes, except when the global CE signal, &lt;code class=&quot;highlighter-rouge&quot;&gt;i_ce&lt;/code&gt;
is high.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(posedge i_clk)
	// Reset logic can be placed here, but it isnt required
	if (i_ce)
	begin&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Once these last preliminaries have been taken care of, we can finally apply the
&lt;a href=&quot;https://en.wikipedia.org/wiki/CORDIC&quot;&gt;CORDIC&lt;/a&gt;
rotation/transform.
Note that we first check the sign of the remaining phase to know which
direction to rotate, but otherwise the operations you see here should match
the transform we discussed earlier.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;		// You can check for cord[i] == 0 here if you would like
		if (ph[i][(PW-1)]) // Negative phase
		begin
			// If the phase is negative, rotate by the
			// CORDIC angle in a clockwise direction.
			xv[i+1] &amp;lt;= xv[i] + (yv[i]&amp;gt;&amp;gt;&amp;gt;(i));
			yv[i+1] &amp;lt;= yv[i] - (xv[i]&amp;gt;&amp;gt;&amp;gt;(i));
			ph[i+1] &amp;lt;= ph[i] + cordic_angle[i];
		end else begin
			// On the other hand, if the phase is
			// positive ... rotate in the
			// counter-clockwise direction
			xv[i+1] &amp;lt;= xv[i] - (yv[i]&amp;gt;&amp;gt;&amp;gt;(i));
			yv[i+1] &amp;lt;= yv[i] + (xv[i]&amp;gt;&amp;gt;&amp;gt;(i));
			ph[i+1] &amp;lt;= ph[i] - cordic_angle[i];
		end
	end
endgenerate&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;While this is the core of the
&lt;a href=&quot;https://en.wikipedia.org/wiki/CORDIC&quot;&gt;CORDIC&lt;/a&gt;
algorithm, now that we have put it together we are by no means done.  We still
need to generate the &lt;a href=&quot;https://en.wikipedia.org/wiki/CORDIC&quot;&gt;CORDIC&lt;/a&gt;
angles, listed as array elements of &lt;code class=&quot;highlighter-rouge&quot;&gt;cordic_angle&lt;/code&gt; above, any traveling
CE &lt;a href=&quot;/blog/2017/08/14/strategies-for-pipelining.html&quot;&gt;pipeline
logic&lt;/a&gt;,
&lt;a href=&quot;/dsp/2017/07/22/rounding.html&quot;&gt;drop any excess bits&lt;/a&gt;
we’ve accumulated,
and figure out what the gain of the algorithm is in case we wish to compensate
for it.&lt;/p&gt;

&lt;h2 id=&quot;using-a-core-generator-in-c-to-get-the-angles&quot;&gt;Using a core-generator in C++ to get the angles&lt;/h2&gt;

&lt;p&gt;One difficulty associated with building a “generic”
&lt;a href=&quot;https://en.wikipedia.org/wiki/CORDIC&quot;&gt;CORDIC&lt;/a&gt;
HDL core is that some of the components of the core cannot be generalized
very easily.  A good example of this problem is the VHDL
&lt;a href=&quot;https://en.wikipedia.org/wiki/CORDIC&quot;&gt;CORDIC&lt;/a&gt;
&lt;a href=&quot;http://github.com/freecores/cordic/blob/master/polar2rect/p2r_Cordic_pipe.vhd&quot;&gt;core&lt;/a&gt; found on
&lt;a href=&quot;http://opencores.org/project,cordic&quot;&gt;OpenCores&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://github.com/freecores/cordic/blob/master/polar2rect/p2r_Cordic_pipe.vhd&quot;&gt;This open-cores
core&lt;/a&gt;
is built with a fixed precision.  While the data width can ostensibly be
adjusted, there are a fixed number of internal arc-tangent results, each created
with a fixed width and a fixed value.  (Well, that and you can’t &lt;a href=&quot;/blog/2017/06/21/looking-at-verilator.html&quot;&gt;simulate the
core&lt;/a&gt; within
&lt;a href=&quot;https://www.veripool.org/wiki/verilator&quot;&gt;Verilator&lt;/a&gt; because someone chose to
write it within &lt;em&gt;VHDL&lt;/em&gt;.)  The only way to prevent this bit-width problem
associated with a one-size fits all solution is to
use a software program, sometimes called a core generator or
&lt;a href=&quot;https://www.xilinx.com/products/design-tools/coregen.html&quot;&gt;coregen&lt;/a&gt;, to
tailor the &lt;a href=&quot;https://en.wikipedia.org/wiki/CORDIC&quot;&gt;CORDIC&lt;/a&gt;
to a specifically requested precision.  This piece of software needs to
calculate the phase rotation angles.  We’ll also use the software to calculate
the required number of stages, the number of input or output bits required,
the number of phase bits, etc., etc.&lt;/p&gt;

&lt;p&gt;Such a core generator will be our approach
&lt;a href=&quot;https://github.com/ZipCPU/cordic/tree/master/sw&quot;&gt;here&lt;/a&gt;.  You can find the
basic &lt;a href=&quot;https://github.com/ZipCPU/cordic/blob/master/sw/basiccordic.v&quot;&gt;core generator
here&lt;/a&gt;,
within my &lt;a href=&quot;https://github.com/ZipCPU/cordic&quot;&gt;cordic repository&lt;/a&gt;.
For now, let’s discuss calculating the
&lt;a href=&quot;https://en.wikipedia.org/wiki/CORDIC&quot;&gt;CORDIC&lt;/a&gt;
angles.&lt;/p&gt;

&lt;p&gt;Starting from above, the cordic angles are defined as&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/eqn-cordic-phase.png&quot; alt=&quot;Cordic rotation phase&quot; width=&quot;168&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;but in our &lt;a href=&quot;/dsp/2017/06/15/no-pi-for-you.html&quot;&gt;normalized integer units of
phase&lt;/a&gt;,
the value we will want is going to be&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/eqn-cordic-tblangle.png&quot; alt=&quot;Cordic rotation phase&quot; width=&quot;342&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;This value can easily be computed in C++ or any other higher level language
for that matter.  We’ll use C++ for this exercise.&lt;/p&gt;

&lt;p&gt;We’ll need to calculate one angle for each of the
&lt;a href=&quot;https://en.wikipedia.org/wiki/CORDIC&quot;&gt;CORDIC&lt;/a&gt;
stages.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;for(unsigned k=0; k&amp;lt;(unsigned)nstages; k++) {
	double		x, deg;
	unsigned	phase_value;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The angle is given by the arctangent of our rotation vector, &lt;code class=&quot;highlighter-rouge&quot;&gt;1+j2^-k&lt;/code&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	x = atan2(1., pow(2,k));&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;(Remember, atan2 accepts the y argument first.  Hence our arguments of
&lt;code class=&quot;highlighter-rouge&quot;&gt;x=2^k&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;y=1&lt;/code&gt; represent an equivalent representation to our angle of
interest.)&lt;/p&gt;

&lt;p&gt;We’ll keep track of the value of this angle in degrees as well as
&lt;a href=&quot;/dsp/2017/06/15/no-pi-for-you.html&quot;&gt;FPGA units&lt;/a&gt;,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	deg = x * 180.0 / M_PI;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;For all other purposes, though, we’ll convert our angle to a &lt;a href=&quot;/dsp/2017/06/15/no-pi-for-you.html&quot;&gt;normalized
integer phase&lt;/a&gt;,
value we can use in an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
algorithm,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	x *= (4.0 * (1ul&amp;lt;&amp;lt;(phase_bits-2))) / (M_PI * 2.0);
	phase_value = (unsigned)x;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;We can then print this value to our resulting Verilog file.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	fprintf(fp, &quot;\tassign\tcordic_angle[%2d] = %2d\&#39;h%0*x; //%11.6f deg\n&quot;,
		k, phase_bits, (phase_bits+3)/4, phase_value,
		deg);
}&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;(I know this is the old-style C I/O — while I’ve used the C++ I/O, I’ve
never really fallen in-love with it.)&lt;/p&gt;

&lt;p&gt;After applying this calculation to a problem set with an &lt;code class=&quot;highlighter-rouge&quot;&gt;18-bit&lt;/code&gt; phase
requirement, the code above generated the following table,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;assign	cordic_angle[ 0] = 18&#39;h0_8000; //  45.000000 deg
assign	cordic_angle[ 1] = 18&#39;h0_4b90; //  26.565051 deg
assign	cordic_angle[ 2] = 18&#39;h0_27ec; //  14.036243 deg
assign	cordic_angle[ 3] = 18&#39;h0_1444; //   7.125016 deg
assign	cordic_angle[ 4] = 18&#39;h0_0a2c; //   3.576334 deg
assign	cordic_angle[ 5] = 18&#39;h0_0517; //   1.789911 deg
assign	cordic_angle[ 6] = 18&#39;h0_028b; //   0.895174 deg
assign	cordic_angle[ 7] = 18&#39;h0_0145; //   0.447614 deg
assign	cordic_angle[ 8] = 18&#39;h0_00a2; //   0.223811 deg
assign	cordic_angle[ 9] = 18&#39;h0_0051; //   0.111906 deg
assign	cordic_angle[10] = 18&#39;h0_0028; //   0.055953 deg
assign	cordic_angle[11] = 18&#39;h0_0014; //   0.027976 deg
assign	cordic_angle[12] = 18&#39;h0_000a; //   0.013988 deg
assign	cordic_angle[13] = 18&#39;h0_0005; //   0.006994 deg&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The number of stages and the number of bits in each stage can both be defined
based upon arguments to the &lt;a href=&quot;https://github.com/ZipCPU/cordic/blob/master/sw/main.cpp&quot;&gt;core generator
program&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;We still have several steps remaining.  In particular, we need to set up the
“traveling CE” &lt;a href=&quot;/blog/2017/08/14/strategies-for-pipelining.html&quot;&gt;pipeline strategy
logic&lt;/a&gt;,
&lt;a href=&quot;/dsp/2017/07/22/rounding.html&quot;&gt;round&lt;/a&gt;
the final result, and discuss on how to deal with
the amplitude distortion produced by the
&lt;a href=&quot;https://en.wikipedia.org/wiki/CORDIC&quot;&gt;CORDIC&lt;/a&gt;
algorithm.&lt;/p&gt;

&lt;h2 id=&quot;auxiliary-logic&quot;&gt;Auxiliary Logic&lt;/h2&gt;

&lt;p&gt;I mentioned earlier that we could use the “traveling CE” &lt;a href=&quot;/blog/2017/08/14/strategies-for-pipelining.html&quot;&gt;pipeline
strategy&lt;/a&gt;
if desired.  That strategy requires that for every strobe input, the output
associated with that input also needs to have a high strobe output.&lt;/p&gt;

&lt;p&gt;We’ll use our C++ code to build this as well, since in C++ we have control
over when to place this logic into the code, as well as how much of this
logic needs to be placed into
&lt;a href=&quot;https://github.com/ZipCPU/cordic/blob/master/rtl/cordic.v&quot;&gt;our core&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;To do this, we’ll teach the &lt;a href=&quot;https://github.com/ZipCPU/cordic/blob/master/sw/main.cpp&quot;&gt;main core generator
program&lt;/a&gt;
to accept a &lt;code class=&quot;highlighter-rouge&quot;&gt;-a&lt;/code&gt; option.  We’ll then use this to create an &lt;code class=&quot;highlighter-rouge&quot;&gt;aux&lt;/code&gt;iliary bit
to contain the “traveling CE” bit.&lt;/p&gt;

&lt;p&gt;The actual logic required to implement this “traveling CE” is just a simple
shift register:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	if (i_reset)
		ax &amp;lt;= {(NSTAGES+1){1&#39;b0}};
	else if (i_ce)
		ax &amp;lt;= { ax[(NSTAGES-1):0], i_aux };

always @(posedge i_clk)
	o_aux &amp;lt;= ax[NSTAGES];&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Were we to get rid of the reset, then all of this logic could fit within
one shift register logic block on a 7-Series Xilinx
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;.
With the reset, this will require 1-FF per stage.&lt;/p&gt;

&lt;p&gt;Placing this logic within the core generator makes certain that no matter
what logic takes place within the core, the output &lt;code class=&quot;highlighter-rouge&quot;&gt;o_aux&lt;/code&gt; bit remains lined
up with the output data associated with any input data that had the &lt;code class=&quot;highlighter-rouge&quot;&gt;i_aux&lt;/code&gt;
bit.&lt;/p&gt;

&lt;h2 id=&quot;dropping-the-last-number-of-bits&quot;&gt;Dropping the last number of bits&lt;/h2&gt;

&lt;p&gt;When we get to the end, we’ll want to drop some bits.  We
&lt;a href=&quot;/dsp/2017/07/22/rounding.html&quot;&gt;discussed some time ago&lt;/a&gt;
how to go about this via
&lt;a href=&quot;/dsp/2017/07/22/rounding.html&quot;&gt;rounding&lt;/a&gt;.  We also discussed
several different types of
&lt;a href=&quot;/dsp/2017/07/22/rounding.html&quot;&gt;rounding&lt;/a&gt; at that same time.
Here, we follow the convergent rounding approach to drop any excess bits.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	// Round our result towards even
	wire	[(WW-1):0]	pre_xval, pre_yval;

	assign	pre_xval = xv[NSTAGES] + ,
				xv[NSTAGES][(WW-OW)],
				{(WW-OW-1){!xv[NSTAGES][WW-OW]}}};
	assign	pre_yval = yv[NSTAGES] + ,
				yv[NSTAGES][(WW-OW)],
				{(WW-OW-1){!yv[NSTAGES][WW-OW]}}};

	always @(posedge i_clk)
	begin
		o_xval &amp;lt;= pre_xval[(WW-1):(WW-OW)];
		o_yval &amp;lt;= pre_yval[(WW-1):(WW-OW)];
	end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;That marks the end of our basic
&lt;a href=&quot;https://en.wikipedia.org/wiki/CORDIC&quot;&gt;CORDIC&lt;/a&gt;
algorithm.  We still need to discuss what to do about the amplitude
gain we’ve accumulated, so that will be next.&lt;/p&gt;

&lt;h2 id=&quot;dealing-with-amplitude&quot;&gt;Dealing with Amplitude&lt;/h2&gt;

&lt;p&gt;As you’ll recall from the beginning of our discussion, the
&lt;a href=&quot;https://en.wikipedia.org/wiki/CORDIC&quot;&gt;CORDIC&lt;/a&gt;
algorithm has a gain associated with it.  Our task here will be to calculate
that gain.  We’ll do this within our C++ generator program, since it has
all the details and capability to do so.&lt;/p&gt;

&lt;p&gt;Below is a copy of the &lt;a href=&quot;https://github.com/ZipCPU/cordic/blob/master/sw/cordiclib.cpp&quot;&gt;C++ code used to calculate the cordic
gain&lt;/a&gt;.
It basically calculates the product of all of the gains of the various
stages in our algorithm.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt;	&lt;span class=&quot;nf&quot;&gt;cordic_gain&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nstages&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;phase_bits&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;gain&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;1.0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

	&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nstages&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt;		&lt;span class=&quot;n&quot;&gt;dgain&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

		&lt;span class=&quot;n&quot;&gt;dgain&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;1.0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pow&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;2.0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;2.&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;dgain&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sqrt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dgain&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;gain&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;gain&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dgain&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

	&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;gain&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This, however, only tells us how much gain will be applied to our input.  That
is, it quantifies our amplitude distortion.  We’ll capture this with a
comment line added to the end of the list of &lt;code class=&quot;highlighter-rouge&quot;&gt;cordic_angles&lt;/code&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;// Gain is 1.646760&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Not all applications need gain compensation.  Some can ignore the
gain.  In the case of those applications, the task is done.&lt;/p&gt;

&lt;p&gt;Other applications use a
CORDIC
for calculating sines and cosines.  These applications would nominally send
&lt;code class=&quot;highlighter-rouge&quot;&gt;(1,0)&lt;/code&gt; into the algorithm as an input.  For these applications, the way to
compensate for the gain is to send a different number as an input.  Instead
of &lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt; (or really &lt;code class=&quot;highlighter-rouge&quot;&gt;2^n&lt;/code&gt; for an &lt;code class=&quot;highlighter-rouge&quot;&gt;n&lt;/code&gt;-bit input), these algorithms will want
to send one divided by the gain into the algorithm.  If we calculate the
right constant to replace the &lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt; with, then we still won’t need any
multiplies.  To help you figure this out, the algorithm calculates
&lt;code class=&quot;highlighter-rouge&quot;&gt;2^32/cordic_gain&lt;/code&gt;, and places this into the comments following the
calculation of the &lt;code class=&quot;highlighter-rouge&quot;&gt;cordic_angle&lt;/code&gt;s as well.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;// You can annihilate this gain by multiplying by 32&#39;h9b74edae
// and right shifting by 32 bits.&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;That allows you to pick the number of most-significant bits that you need,
for the precision you want.&lt;/p&gt;

&lt;p&gt;Other applications use the
CORDIC
to actually rotate the input vector.  For these applications, the same
32-bit value can be used as an annihilator, post
CORDIC
application.  If you multiply by this annihilator, and shift right, then the
CORDIC
gain will be removed.&lt;/p&gt;

&lt;h2 id=&quot;conclusions&quot;&gt;Conclusions&lt;/h2&gt;

&lt;p&gt;Now that you’ve seen what goes into making a working
&lt;a href=&quot;https://en.wikipedia.org/wiki/CORDIC&quot;&gt;CORDIC&lt;/a&gt;
core, perhaps you are as amazed as I am at how many parts and pieces this
&lt;em&gt;simple&lt;/em&gt; sine and cosine wave generator has.  We started out by discussing the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Rotation_matrix&quot;&gt;rotation matrices&lt;/a&gt;
used by the
&lt;a href=&quot;https://en.wikipedia.org/wiki/CORDIC&quot;&gt;CORDIC&lt;/a&gt;
algorithm.  This is usually where most academic
&lt;a href=&quot;https://en.wikipedia.org/wiki/CORDIC&quot;&gt;CORDIC&lt;/a&gt;
development’s stop.&lt;/p&gt;

&lt;p&gt;However, when you want to make a working
&lt;a href=&quot;https://en.wikipedia.org/wiki/CORDIC&quot;&gt;CORDIC&lt;/a&gt;
core, you have to go further.  You need to rotate the original vector by
some multiple of ninety degree angles until the remaining rotation angle is
less than forty five degrees.  Only then can you apply the
&lt;a href=&quot;https://en.wikipedia.org/wiki/CORDIC&quot;&gt;CORDIC&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Rotation_matrix&quot;&gt;rotation&lt;/a&gt;.
Doing so, though, requires the
&lt;a href=&quot;https://en.wikipedia.org/wiki/CORDIC&quot;&gt;CORDIC&lt;/a&gt;
angles, which we needed to calculate based upon the desired precision of the
output.  As a final step, we calculated both the
&lt;a href=&quot;https://en.wikipedia.org/wiki/CORDIC&quot;&gt;CORDIC&lt;/a&gt;
gain and it’s associated annihilator (inverse).&lt;/p&gt;

&lt;p&gt;If only this were all that was required of a
&lt;a href=&quot;https://en.wikipedia.org/wiki/CORDIC&quot;&gt;CORDIC&lt;/a&gt;
core.  It’s not.  We still need to build a test bench for this core–so our
work isn’t over yet.
Before doing so, however, I think we’ll present the other basic type of
&lt;a href=&quot;https://en.wikipedia.org/wiki/CORDIC&quot;&gt;CORDIC&lt;/a&gt;
algorithm: the
&lt;a href=&quot;https://en.wikipedia.org/wiki/CORDIC&quot;&gt;CORDIC&lt;/a&gt;
arctan, sometimes called the rectangular to polar conversion, before diving
into the bench test.&lt;/p&gt;

&lt;p&gt;If you are interested in further reading on the topic,
Ray Andraka has written an excellent &lt;a href=&quot;http://www.andraka.com/files/crdcsrvy.pdf&quot;&gt;survey of CORDIC
algorithms&lt;/a&gt; that you might find
valuable.&lt;/p&gt;
&lt;hr /&gt;&lt;p&gt;&lt;em&gt;O ye simple, understand wisdom: and, ye fools, be ye of an understanding heart.  (Prov 8:5)&lt;/em&gt;</description>
        <pubDate>Wed, 30 Aug 2017 00:00:00 -0400</pubDate>
        <link>http://zipcpu.com/dsp/2017/08/30/cordic.html</link>
        <guid isPermaLink="true">http://zipcpu.com/dsp/2017/08/30/cordic.html</guid>
        
        
        <category>dsp</category>
        
      </item>
    
      <item>
        <title>Building a quarter sine-wave lookup table</title>
        <description>&lt;p&gt;The last time &lt;a href=&quot;/dsp/2017/07/11/simplest-sinewave-generator.html&quot;&gt;we discussed how to create a
sinewave&lt;/a&gt;,
we discussed the way to make a very simple
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sine_wave&quot;&gt;sinewave&lt;/a&gt;.
from a &lt;a href=&quot;/blog/2017/06/12/minimizing-luts.html&quot;&gt;LUT&lt;/a&gt;-based
table lookup.  We limited that
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sine_wave&quot;&gt;sinewave&lt;/a&gt;.
to an 8-bit table for simplicity, although it could easily be extended to a
much larger table.&lt;/p&gt;

&lt;p&gt;Today, let’s expand this concept to a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sine_wave&quot;&gt;sinewave&lt;/a&gt;.
that uses a quarter wave table
made from Block &lt;a href=&quot;https://en.wikipedia.org/wiki/Random-access_memory&quot;&gt;RAM&lt;/a&gt;.  Such a table uses only a fourth of the block &lt;a href=&quot;https://en.wikipedia.org/wiki/Random-access_memory&quot;&gt;RAM&lt;/a&gt;
resources required by a full table, although it does require some extra logic
to handle making things look like the full table.&lt;/p&gt;

&lt;p&gt;Let’s also build this as an example of how to create pipelined
&lt;a href=&quot;https://en.wikipedia.org/wiki/Hardware_description_language&quot;&gt;HDL&lt;/a&gt; logic.&lt;/p&gt;

&lt;p&gt;We’ll start by describing the algorithm in general, and then build the
algorithm through a series of stages.&lt;/p&gt;

&lt;h2 id=&quot;the-algorithm&quot;&gt;The Algorithm&lt;/h2&gt;

&lt;p&gt;The first step is always stepping back and assessing the problem.
If you look at a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sine_wave&quot;&gt;sinewave&lt;/a&gt;,
such as Fig 1. below, you can separate the full
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sine_wave&quot;&gt;sinewave&lt;/a&gt;
period into four sections, one quarter wavelength each.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 1: Sinewave Symmetry&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/sin-symmetry.png&quot; alt=&quot;Sinewave symmetry&quot; width=&quot;580&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;We’ll leave the first section alone.  This will become our quarter-wave
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sine_wave&quot;&gt;sinewave&lt;/a&gt;
table.
The second section is identical to the first, only in a backwards order.
Hence, if we reverse our index, we should be able to recover anything from
this quarter wave of the table.  The third and fourth sections are identical
to the first two, only their results will need to be negated afterwards.&lt;/p&gt;

&lt;p&gt;Since we are splitting the full wavelength into four sections, the top two
&lt;a href=&quot;/dsp/2017/06/15/no-pi-for-you.html&quot;&gt;phase&lt;/a&gt; bits can be
used to determine which of the four sections we are in.  If the most significant
bit is set, then we’ll want to negate the result.  If the next significant bit
is set, we’ll want to read backwards out of the table.&lt;/p&gt;

&lt;p&gt;This quarter wave table runs into a bit of a problem with
&lt;a href=&quot;/dsp/2017/06/15/no-pi-for-you.html&quot;&gt;phase&lt;/a&gt;
quantization, though.  Consider a
&lt;a href=&quot;/dsp/2017/06/15/no-pi-for-you.html&quot;&gt;phase&lt;/a&gt;
quantized table with only 16 entries, such as shown in Fig 2.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 2: Sampled Sinewave&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/sin-qtrbroken.png&quot; alt=&quot;Sinewave symmetry broken by sampling&quot; width=&quot;580&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;This table has lost the symmetry that was originally present in the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sine_wave&quot;&gt;sinewave&lt;/a&gt;.
In particular, table[4]’s value is not present in table[0:3].
If we were to use table[3] to represent the missing table[4] value, we
might get a &lt;a href=&quot;https://en.wikipedia.org/wiki/Sine_wave&quot;&gt;sinewave&lt;/a&gt;
looking like Fig 3. below.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 3: Symmetry can be broken by quantization&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/sin-qtrmisshapen.png&quot; alt=&quot;Fixing the broken symmetry by shifting a half a sample in phase&quot; width=&quot;580&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Notice how flat the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sine_wave&quot;&gt;sinewave&lt;/a&gt;
is every time it crosses zero.  It’s not
supposed to be this flat.  The slope of a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sine_wave&quot;&gt;sinewave&lt;/a&gt;
is supposed to be at
a maximum when it crosses zero–not flat. This shape distortion will create
harmonics that we are not expecting if we don’t fix it.&lt;/p&gt;

&lt;p&gt;If we instead advance the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sine_wave&quot;&gt;sinewave&lt;/a&gt;
table entries by a half of a sample of phase each, the result
will have less harmonic distortion. (i.e., it’ll be closer to the right shape,
even if shifted left a touch).  The result would then look like Fig 4.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 4: Fixing Symmetry by slipping a half a sample in phase&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/sin-qtrfixed.png&quot; alt=&quot;Fixing the broken symmetry by shifting a half a sample in phase&quot; width=&quot;580&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;The resulting equation for this table is also shown in Fig 4.&lt;/p&gt;

&lt;p&gt;The algorithm we want to build will take the first quarter of this
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sine_wave&quot;&gt;sinewave&lt;/a&gt;,
place it into a table, and then use that same table to generate
the other four quarters of the wavelength.&lt;/p&gt;

&lt;h2 id=&quot;building-the-algorithm&quot;&gt;Building the Algorithm&lt;/h2&gt;

&lt;p&gt;It’s now time to build this algorithm.  Although the algorithm itself is
quite simple, I’m going to build it in stages and use this as an opportunity
to discuss how to build a pipelined algorithm in general.  This will allow us
to compare several different implementations, and judge between good an bad
approaches.&lt;/p&gt;

&lt;p&gt;Our first draft for this algorithm uses a giant case statement:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
begin
	case({ i_phase[(PW-1):PW-2] })
	2&#39;b00:	o_val &amp;lt;=  tbl[ i_phase[(PW-3):0]];
	2&#39;b01:	o_val &amp;lt;=  tbl[~i_phase[(PW-3):0]];
	2&#39;b10:	o_val &amp;lt;= -tbl[ i_phase[(PW-3):0]];
	2&#39;b11:	o_val &amp;lt;= -tbl[~i_phase[(PW-3):0]];
	endcase
end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;In this piece of code, &lt;code class=&quot;highlighter-rouge&quot;&gt;i_phase&lt;/code&gt; is the input
&lt;a href=&quot;/dsp/2017/06/15/no-pi-for-you.html&quot;&gt;phase&lt;/a&gt;
request, &lt;code class=&quot;highlighter-rouge&quot;&gt;tbl&lt;/code&gt; is the quarter wave
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sine_wave&quot;&gt;sinewave&lt;/a&gt;
table, and &lt;code class=&quot;highlighter-rouge&quot;&gt;o_val&lt;/code&gt; is the output
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sine_wave&quot;&gt;sinewave&lt;/a&gt;.
PW is the
&lt;a href=&quot;/dsp/2017/06/15/no-pi-for-you.html&quot;&gt;phase&lt;/a&gt;
width, or equivalently the number of bits in &lt;code class=&quot;highlighter-rouge&quot;&gt;i_phase&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;You may notice that I haven’t used &lt;code class=&quot;highlighter-rouge&quot;&gt;TBLLEN/4-1-i_phase&lt;/code&gt; at all when reversing
the table entries.  Instead, &lt;code class=&quot;highlighter-rouge&quot;&gt;~i_phase&lt;/code&gt; accomplishes the same effect.  To know
why this is relevant, remember the two steps to negating a two’s complement
number: invert all the bits and add one.  In this case, we’d subtract one
after adding one, so we can just invert the bits.  As an example, then, if
&lt;code class=&quot;highlighter-rouge&quot;&gt;i_phase&lt;/code&gt; counts from 0 to 15, &lt;code class=&quot;highlighter-rouge&quot;&gt;~i_phase&lt;/code&gt; would count from 15 back down to 0.&lt;/p&gt;

&lt;p&gt;The problem with this big case statement approach is that most block &lt;a href=&quot;https://en.wikipedia.org/wiki/Random-access_memory&quot;&gt;RAM&lt;/a&gt;’s
are &lt;a href=&quot;https://www.xilinx.com/support/documentation/white_papers/wp231.pdf&quot;&gt;very particular about how they are
accessed&lt;/a&gt;.
Extra logic on the index is not allowed, neither is extra logic on the output.
Adding logic in either place can interfere with the synthesis tool and keep
it from recognizing your table as a block &lt;a href=&quot;https://en.wikipedia.org/wiki/Random-access_memory&quot;&gt;RAM&lt;/a&gt; (or &lt;a href=&quot;https://en.wikipedia.org/wiki/Read-only_memory&quot;&gt;ROM&lt;/a&gt; in this case).
When dealing with this, I have found the following form to be reliable
among the various hardware’s I have worked with.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	if (i_ce)
		tblvalue &amp;lt;= tbl[index];&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Perhaps this is simpler than it needs to be, but it does work across
vendors’ tool-suites.&lt;/p&gt;

&lt;p&gt;This may also be the time to discuss our pipeline strategy.  Looking over the
&lt;a href=&quot;/blog/2017/08/14/strategies-for-pipelining.html&quot;&gt;various pipeline
strategies&lt;/a&gt;
we posted about earlier, this already looks like the beginning of the
“global CE” approach.  If we look up the examples of where the “global CE”
pipeline strategy makes the most sense, you may recall that
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_signal_processing&quot;&gt;DSP&lt;/a&gt;
logic was one of the common applications of this approach.  Since that’s what
we are building today, we’ll keep the &lt;code class=&quot;highlighter-rouge&quot;&gt;i_ce&lt;/code&gt;
line, and add it into the rest of our logic.&lt;/p&gt;

&lt;p&gt;Working the simplicity of this block
&lt;a href=&quot;https://en.wikipedia.org/wiki/Random-access_memory&quot;&gt;RAM&lt;/a&gt; access into our
logic, though, will take some work.  We’ll need to spend a clock to calculate
the index, and another clock after that to deal with the negation.&lt;/p&gt;

&lt;p&gt;This brings us to our second approach to our logic.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
if (i_ce)
begin
	// First, calculate the table index
	if (i_phase[(PW-2)])
		index &amp;lt;= ~i_phase[(PW-3):0];
	else
		index &amp;lt;=  i_phase[(PW-3):0];

	// Use the index to access Block RAM
	tblvalue &amp;lt;= table[index];

	// Handle the negation afterwards
	if (i_phase[(PW-1)])
		o_val &amp;lt;= -tblvalue;
	else
		o_val &amp;lt;=  tblvalue;
end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This approach still has some hazards to it.  Perhaps if we drew a data
flow diagram, such as Fig 5 below, these hazards will become be more apparent.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 5: Initial Data Flow Diagram&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/qtrwave-preschedule.svg&quot; alt=&quot;Initial data flow diagram&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Let’s work with this flow diagram for a moment.  First, it helps to
separate the data flow variables into clock transitions regions.  (We’ll
show this in Fig 6 below in a moment.)
&lt;code class=&quot;highlighter-rouge&quot;&gt;i_phase&lt;/code&gt; would be in the first clock.  We’ll call this the input clock.
&lt;code class=&quot;highlighter-rouge&quot;&gt;index&lt;/code&gt; is in the next clock, etc.  Once you separate these variables, then
you can see the problem with the negation logic.  This negation flag
needs to come from the
high bit of &lt;code class=&quot;highlighter-rouge&quot;&gt;i_phase[(PW-1)]&lt;/code&gt;, but it has to be available after the table
look up.  To make this problem more apparent, draw vertical lines through
the diagram, dilineating the processing clocks.  Data flows should not cross
through such lines, without being clocked into a new register–else you’ll
have a pipeline bug.&lt;/p&gt;

&lt;p&gt;The solution to this problem is to &lt;em&gt;schedule&lt;/em&gt; the pipeline logic.
Specifically, we’ll create a register to hold &lt;code class=&quot;highlighter-rouge&quot;&gt;i_phase[(PW-1)]&lt;/code&gt; while
the table index is calculated and the table value is looked up.  We can
implement this with a two stage shift register, captured by &lt;code class=&quot;highlighter-rouge&quot;&gt;negate[0]&lt;/code&gt; and
&lt;code class=&quot;highlighter-rouge&quot;&gt;negate[1]&lt;/code&gt;:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
if (i_ce)
begin
	negate[0] &amp;lt;= i_phase[(PW-1)];
	// ...
	negate[1] &amp;lt;= negate[0];
	if (negate[1])
		// ...
end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;A new data flow diagram for this modified algorithm might look like Fig 6.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 6: Scheduled data flow&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/qtrwave-scheduled.svg&quot; alt=&quot;Data flow diagram, with all logic scheduled&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Notice how each variable is now associated with a clock period in the pipeline.&lt;/p&gt;

&lt;p&gt;Written out, our logic now looks like:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;// Initialize the quarter-wave table
initial	$readmemh(&quot;quarterwav.hex&quot;, quartertable);

always @(posedge i_clk)
	if (i_ce)
	begin
		// Clock one
		negate[0] &amp;lt;= i_phase[(PW-1)];
		index  &amp;lt;= i_phase[(PW-2)]
				? ~i_phase[(PW-3):0]
				:  i_phase[(PW-3):0];

		// Clock two
		negate[1] &amp;lt;= negate[0];
		tblvalue &amp;lt;= table[index];

		// Output clock
		if (negate[1])
			o_val &amp;lt;= -tblvalue;
		else
			o_val &amp;lt;=  tblvalue;
	end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;You can also find a &lt;a href=&quot;https://github.com/ZipCPU/cordic/blob/master/rtl/quarterwav.v&quot;&gt;full example of this logic
here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;At this point, we are almost done.  All that’s left is to create a hex
file to be used to crate this table.  This can be done from a simple
&lt;a href=&quot;https://github.com/ZipCPU/cordic/blob/master/sw/sintable.cpp&quot;&gt;C++ program&lt;/a&gt;,
where the relevant portion is shown below:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;tbl_entries&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lgtable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;maxv&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ow&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tbl_entries&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;dv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ph&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;ph&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;2.0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;M_PI&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tbl_entries&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;ph&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt;       &lt;span class=&quot;n&quot;&gt;M_PI&lt;/span&gt;             &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tbl_entries&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;dv&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;maxv&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ph&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;8&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;fprintf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;hexfp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;%s@%08x &quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;?&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;fprintf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;hexfp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;%0*x &quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ow&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ow&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fprintf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;hexfp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Well, not quite.  The problem with this approach is that the table generator
is closely associtated with the Verilog code itself.  In particular, you
can’t change the number of table entries, or for that matter the width of
the table entries, without also adjusting the &lt;a href=&quot;https://github.com/ZipCPU/cordic/blob/master/rtl/quarterwav.v&quot;&gt;Verilog
code&lt;/a&gt;.
For this reason, the
&lt;a href=&quot;https://github.com/ZipCPU/cordic/blob/master/sw/sintable.cpp&quot;&gt;C++ generator&lt;/a&gt;
program creates both the
&lt;a href=&quot;https://github.com/ZipCPU/cordic/blob/master/rtl/quarterwav.v&quot;&gt;Verilog code&lt;/a&gt;
and the
&lt;a href=&quot;https://github.com/ZipCPU/cordic/blob/master/rtl/quarterwav.hex&quot;&gt;hex table&lt;/a&gt;
at the same time.&lt;/p&gt;

&lt;p&gt;That’s it!  We’ve now made a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sine_wave&quot;&gt;sinewave&lt;/a&gt;
generator from just a quarter wave
table.  We’re still going to need to come back to test this table, to build
a test bench and prove that it works, but that’s the basics of the algorithm.&lt;/p&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;This post is one in a small series of posts discussing how to generate a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sine_wave&quot;&gt;sinewave&lt;/a&gt;.
We’ve already discussed a &lt;a href=&quot;/dsp/2017/07/11/simplest-sinewave-generator.md&quot;&gt;very simple sinewave
generator&lt;/a&gt;,
and we are well on our way to creating and explaining a full blown
&lt;a href=&quot;https://en.wikipedia.org/wiki/CORDIC&quot;&gt;CORDIC&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sine_wave&quot;&gt;sinewave&lt;/a&gt; implementation.&lt;/p&gt;

&lt;p&gt;These &lt;a href=&quot;https://en.wikipedia.org/wiki/Sine_wave&quot;&gt;sinewave&lt;/a&gt;
generators will then form the basis for testing the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;digital filters&lt;/a&gt;
that I intend to discuss and demonstrate as well.&lt;/p&gt;

&lt;p&gt;So, while this is the end of this post, in many ways it is only one step
forward in building &lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_signal_processing&quot;&gt;Digital Signal
Proccessing&lt;/a&gt;
algorithms within an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;.
Stick around, there’s a lot you can do with a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sine_wave&quot;&gt;sinewave&lt;/a&gt;.&lt;/p&gt;
&lt;hr /&gt;&lt;p&gt;&lt;em&gt;But he went out, and began to publish it much, and to blaze abroad the matter, insomuch that Jesus could no more openly enter into the city, but was without in desert places: and they came to him from every quarter.  (Mark 1:45)&lt;/em&gt;</description>
        <pubDate>Sat, 26 Aug 2017 00:00:00 -0400</pubDate>
        <link>http://zipcpu.com/dsp/2017/08/26/quarterwave.html</link>
        <guid isPermaLink="true">http://zipcpu.com/dsp/2017/08/26/quarterwave.html</guid>
        
        
        <category>dsp</category>
        
      </item>
    
      <item>
        <title>Debugging your soft-core CPU within an FPGA</title>
        <description>&lt;p&gt;We’ve already looked at the requirements for &lt;a href=&quot;/zipcpu/2017/07/14/cpu-debugging-needs.thml&quot;&gt;debugging a CPU in
general&lt;/a&gt;, as
well as &lt;a href=&quot;/zipcpu/2017/07/26/cpu-sim-debugger.html&quot;&gt;how to debug a CPU within a Verilator based
simulation&lt;/a&gt;. 
Let’s now return to this topic and take a look at how to modify your
&lt;a href=&quot;https://en.wikipedia.org/wiki/Soft_microprocessor&quot;&gt;soft-core CPU&lt;/a&gt;
so that you can debug it once it is placed within an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;.&lt;/p&gt;

&lt;table style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 1: Soft-Core CPU H/W Debugging Needs&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/cpu-dbg-inhw.svg&quot; alt=&quot;Needs of a Soft-Core Hardware Debugger&quot; width=&quot;320&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;When we discussed the &lt;a href=&quot;/zipcpu/2017/07/14/cpu-debugging-needs.thml&quot;&gt;general needs of a
debugger&lt;/a&gt;,
we used a figure similar to Fig 1. to describe a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;’s
debugging needs.
The left column, debugging the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;’s
while in simulation, we address &lt;a href=&quot;/zipcpu/2017/07/26/cpu-sim-debugger.html&quot;&gt;in a
previous post&lt;/a&gt;.
Today, the figure at the right has been modified to highlight todays
discussion and focus: how to add the necessary logic into a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Soft_microprocessor&quot;&gt;soft-core CPU&lt;/a&gt;
to support debugging.&lt;/p&gt;

&lt;p&gt;As shown in the diagram, the basic operations we’re going to need to support
are resetting, starting, halting, and stepping a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;,
as well as examining
and changing
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;,
state
&lt;a href=&quot;https://en.wikipedia.org/wiki/Processor_register&quot;&gt;registers&lt;/a&gt;.
You may wish to review how the &lt;a href=&quot;/zipcpu/2017/08/23/cpu-pipeline.md&quot;&gt;ZipCPU handles pipeline
control&lt;/a&gt;,
since the logic we shall discuss today needs to fit nicely into that context.&lt;/p&gt;

&lt;h2 id=&quot;that-hw-debugging-interface&quot;&gt;That H/W Debugging Interface&lt;/h2&gt;

&lt;p&gt;If you’ve never done this before, please don’t start by trying to implement
&lt;a href=&quot;https://www.gnu.org/software/gdb&quot;&gt;GDB&lt;/a&gt;’s &lt;a href=&quot;https://sourceware.org/gdb/onlinedocs/gdb/Remote-Protocol.html&quot;&gt;remote serial
protocol&lt;/a&gt;
within Verilog.  The protocol is very powerful, and we’ll discuss how to use
it later to connect your
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;
to &lt;a href=&quot;https://www.gnu.org/software/gdb&quot;&gt;GDB&lt;/a&gt;. 
The problem is that the protocol is complex, and it will take a lot of work to
process it within hardware.  Keep reading, there’s an easier way.&lt;/p&gt;

&lt;p&gt;As a first step, think for a moment about what &lt;a href=&quot;/zipcpu/2017/07/14/cpu-debugging-needs.html&quot;&gt;debugging your CPU
will require&lt;/a&gt;.
In particular, you’ll want to be able to read and write both
&lt;a href=&quot;https://en.wikipedia.org/wiki/Processor_register&quot;&gt;registers&lt;/a&gt;
and memory.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;/digilent/2017/05/22/moving-to-memory.html&quot;&gt;Reading from
memory&lt;/a&gt;
requires the address you wish to read from as well as a strobe signal to
indicate your desire to read&lt;/p&gt;

    &lt;p&gt;If your address space is big enough, this &lt;a href=&quot;https://en.wikipedia.org/wiki/Memory-mapped_I/O&quot;&gt;same sort of command and
interface&lt;/a&gt; can work for
reading 
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt; 
&lt;a href=&quot;https://en.wikipedia.org/wiki/Processor_register&quot;&gt;registers&lt;/a&gt;
just like it does for memory.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;/zipcpu/2017/05/23/simplebus.html&quot;&gt;Writing to memory&lt;/a&gt;
requires an address, a value, and a strobe to tell you
when to write the value to the given address.&lt;/p&gt;

    &lt;p&gt;As with reading, if you can allocate an address for each
&lt;a href=&quot;https://en.wikipedia.org/wiki/Processor_register&quot;&gt;register&lt;/a&gt; within your
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;,
the same interface you used for reading
&lt;a href=&quot;https://en.wikipedia.org/wiki/Processor_register&quot;&gt;registers&lt;/a&gt;
could also work to writing
&lt;a href=&quot;https://en.wikipedia.org/wiki/Processor_register&quot;&gt;registers&lt;/a&gt; within your
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;.&lt;/p&gt;

    &lt;p&gt;The approach can even be expanded to include not only
&lt;a href=&quot;https://en.wikipedia.org/wiki/Processor_register&quot;&gt;registers&lt;/a&gt;
values, but also internal (debugging) state variables from within your
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;As a third example, a control register could also be used to tell the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt; when
to execute an instruction, and when to hold in reset.&lt;/p&gt;

&lt;table style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 2: Placing a CPU on the Debugging Bus&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/hw-debug-structure.svg&quot; alt=&quot;Block diagram of a CPU placed on a Debugging Bus&quot; width=&quot;320&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;All of these interactions, therefore, are easily understood as things that
could take place across a
“&lt;a href=&quot;/zipcpu/2017/05/23/simplebus.html&quot;&gt;bus&lt;/a&gt;”
with both memory and &lt;a href=&quot;https://en.wikipedia.org/wiki/Memory-mapped_I/O&quot;&gt;memory mapped
peripherals&lt;/a&gt; on it. 
Therefore, one might consider giving the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt; a &lt;a href=&quot;/zipcpu/2017/05/29/simple-wishbone.html&quot;&gt;bus slave
interface&lt;/a&gt;, and 
hooking it up to the &lt;a href=&quot;https://github.com/ZipCPU/dbgbus&quot;&gt;debugging
bus&lt;/a&gt; we’ve been working with (or something
similar) as shown in Fig 2.&lt;/p&gt;

&lt;p&gt;This approach has a couple of advantages.  First, the
&lt;a href=&quot;https://github.com/ZipCPU/dbgbus&quot;&gt;debugging bus&lt;/a&gt;
can be used to &lt;a href=&quot;/zipcpu/2017/05/20/which-came-first.html&quot;&gt;debug both the peripherals and the
memory&lt;/a&gt;
the &lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;
will need to work with later.  Second, if the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;
and &lt;a href=&quot;https://github.com/ZipCPU/dbgbus&quot;&gt;debugging
bus&lt;/a&gt; are each given the same view of the
peripheral set, then no separate address map and decoder needs to be created.
Third, this approach creates a means, independent of the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;,
of reading and writing to memory.  This could be very important later when
building a
program loader for the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;,
since it would then allow you to load the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;’s
program into memory and test it, without relying on any internal
&lt;a href=&quot;https://en.wikipedia.org/wiki/Read-only_memory&quot;&gt;ROM&lt;/a&gt;
within the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;
that would cause the design to need to be resynthesized anytime
something changes.&lt;/p&gt;

&lt;p&gt;The downside of this approach is that, depending upon your implementation, the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/aux/wbpriarb.v&quot;&gt;bus arbiter&lt;/a&gt;
may slow the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;’s
access to memory by a clock (or two).&lt;/p&gt;

&lt;table style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 3: ZipCPU&#39;s debugging interface&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/bare-cpu-debug-iface.svg&quot; alt=&quot;ZipCPU&#39;s bare debugging interface&quot; width=&quot;320&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;This was the approach taken by the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;, as shown in Fig 3, so we’ll use the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;
as our example of this approach in our discussion below.  The
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt; was
given two address locations on the debugging bus: a control and data
location.  (These are both discussed and defined in the 
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt; &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/doc/spec.pdf&quot;&gt;specification
document&lt;/a&gt;.)
A small wrapper around the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;ZipCPU
proper&lt;/a&gt;, called
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/zipbones.v&quot;&gt;ZipBones&lt;/a&gt;,
connects to the control register of the debug slave port and controls the
reset and halt lines into the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.com&quot;&gt;CPU&lt;/a&gt;.
These are used to implement reset, halt,
start, and step operations as we’ll see shortly.&lt;/p&gt;

&lt;p&gt;The &lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;
also has a second wrapper with more functionality to it, called
the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/zipsystem.v&quot;&gt;ZipSystem&lt;/a&gt;,
but since the logic within the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/zipbones.v&quot;&gt;ZipBones&lt;/a&gt;
is simpler, we’ll focus on it.&lt;/p&gt;

&lt;p&gt;Our discussion will focus on the reads and writes of these two locations,
the control and data ports, although you may wish to give your own
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;
more registers than just these two.&lt;/p&gt;

&lt;h2 id=&quot;reseting-halting-and-stepping-the-cpu&quot;&gt;Reseting, halting, and stepping the CPU&lt;/h2&gt;

&lt;p&gt;Let’s look at the control register for the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt; for a moment.  Writes to
this control register have the side-effect of controlling the
&lt;code class=&quot;highlighter-rouge&quot;&gt;i_halt&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;i_rst&lt;/code&gt; (reset) lines within the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;.
These side effects will cause the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;ZipCPU&lt;/a&gt;
to run, halt, step, or even reset as requested.&lt;/p&gt;

&lt;p&gt;The first side effect to be discussed is the reset.  Like many digital
logic cores, the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;ZipCPU&lt;/a&gt;
has a reset line going into it.  Controlling this reset is also quite
possibly the simplest interaction with the bus.  Specifically, any time
the control register is written with the reset bit set, the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
is reset.  Further, this reset line into the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
is initialized high, to make sure
that the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
always starts from a reset state.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;initial	cmd_reset = 1&#39;b1;
always @(posedge i_clk)
	cmd_reset &amp;lt;= ((dbg_cmd_write)&amp;amp;&amp;amp;(i_dbg_data[`RESET_BIT]));&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Inside the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;ZipCPU&lt;/a&gt;,
this reset line causes the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;ZipCPU&lt;/a&gt;
to reboot.  While it only (re-)initializes a minimum of variables, it is
enough to get the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
start from (nearly) known conditions.
In particular, all error conditions, cache valid indications, and pipeline
valid flags are cleared on reset.  Further, the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
is sent to a pre-programmed address.  What doesn’t happen is that the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Processor_register&quot;&gt;registers&lt;/a&gt;
are not re-initialized (the program counter and flags registers are though).
This allows some amount of fault recovery in software, if desired, prior to
setting all of the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Processor_register&quot;&gt;registers&lt;/a&gt;
to known conditions.&lt;/p&gt;

&lt;p&gt;The second control line going into the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
is a master halt line, &lt;code class=&quot;highlighter-rouge&quot;&gt;i_halt&lt;/code&gt;.  This line, if set, will cause the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
to halt in such a way that no instructions will go
into the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/cpuops.v&quot;&gt;ALU&lt;/a&gt;,
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/memops.v&quot;&gt;memory&lt;/a&gt;
or &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/div.v&quot;&gt;divide&lt;/a&gt;
units, but instructions that have already
entered these units will be allowed to finish.  It does this by setting the
stall logic associated with units, as we discussed during our
&lt;a href=&quot;/zipcpu/2017/08/23/cpu-pipeline.html&quot;&gt;CPU pipeline signaling
post&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The neat thing about the master halt line concept is that the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
is designed to halt at a stopping point between instructions when using it. 
Instructions that have entered the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/cpuops.v&quot;&gt;ALU&lt;/a&gt;,
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/memops.v&quot;&gt;memory&lt;/a&gt;
or &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/div.v&quot;&gt;divide&lt;/a&gt;
stages are allowed to complete, but further instructions are not allowed
to enter these stages.  As a result, the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
can be started, stepped, or halted by adjusting this master enable (i.e.
&lt;code class=&quot;highlighter-rouge&quot;&gt;i_halt&lt;/code&gt;) line.&lt;/p&gt;

&lt;p&gt;This &lt;code class=&quot;highlighter-rouge&quot;&gt;i_halt&lt;/code&gt; line into the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
is calculated from a couple of pieces of logic in the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/zipbones.v&quot;&gt;ZipBones&lt;/a&gt;
wrapper.  The first is the &lt;code class=&quot;highlighter-rouge&quot;&gt;cmd_halt&lt;/code&gt; register which is controlled by writes
to the control register.  On a reset, the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
will start in a halted mode (if the boolean parameter &lt;code class=&quot;highlighter-rouge&quot;&gt;START_HALTED&lt;/code&gt; is set to
true).  Ever afterwards, any write to the halt bit in the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/zipbones.v&quot;&gt;ZipBones&lt;/a&gt;
status register will set or clear this bit with two exceptions:
&lt;code class=&quot;highlighter-rouge&quot;&gt;cmd_step&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;cpu_break&lt;/code&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;`define	STEP_BIT	8
`define	HALT_BIT	10

always @(posedge i_clk)
	if ((i_rst)||(cmd_reset))
		cmd_halt &amp;lt;= (START_HALTED);
	else if (dbg_cmd_write)
		cmd_halt &amp;lt;= ((i_dbg_data[`HALT_BIT])&amp;amp;&amp;amp;(!i_dbg_data[`STEP_BIT]));
	else if ((cmd_step)||(cpu_break))
		cmd_halt &amp;lt;= 1&#39;b1;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The first exception is the &lt;code class=&quot;highlighter-rouge&quot;&gt;cmd_step&lt;/code&gt; logic.  If the halt bit is set
at the same time the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
is instructed to step forward by one clock, then the halt request is ignored
until the &lt;code class=&quot;highlighter-rouge&quot;&gt;cmd_step&lt;/code&gt; has been true for one cock.  We’ll come back to this
exception in a moment.&lt;/p&gt;

&lt;p&gt;The second exception is the &lt;code class=&quot;highlighter-rouge&quot;&gt;cpu_break&lt;/code&gt; signal.  This is shown in Fig. 3 as
the hardware break signal.  This is the signal the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
creates when it has encountered an unrecoverable fault–such as trying
to execute an unimplemented instruction while in the supervisor
(i.e. interrupt) state.  Other faults within the supervisor state
will also cause the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
to fault as well, such as the break instruction, a divide by zero fault from
within supervisor mode, or a
&lt;a href=&quot;https://opencores.org/cdn/downloads/wbspec_b4.pdf&quot;&gt;wishbone bus&lt;/a&gt;
error.  This &lt;code class=&quot;highlighter-rouge&quot;&gt;cmd_halt&lt;/code&gt; state captures that fault, and then holds the 
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
in a halted state for the debugger to come by and examine it.  (Alternatively,
the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
could be programmed to just reboot.)&lt;/p&gt;

&lt;p&gt;On that note, let’s return to looking at the step bit.  If the step bit is ever
set, the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/zipbones.v&quot;&gt;ZipBones&lt;/a&gt;
wrapper will release the halt line for one clock and then set it immediately
again.  This will cause one instruction to enter the
&lt;a href=&quot;/zipcpu/08/11/simple-alu.html&quot;&gt;ALU&lt;/a&gt;/memory pipeline stage.
It works in conjunction with the &lt;code class=&quot;highlighter-rouge&quot;&gt;cmd_halt&lt;/code&gt; bit above, so that if the step
register is ever true, the &lt;code class=&quot;highlighter-rouge&quot;&gt;cmd_halt&lt;/code&gt; register will get set on the next
instruction.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;initial	cmd_step  = 1&#39;b0;
always @(posedge i_clk)
	cmd_step &amp;lt;= (dbg_cmd_write)&amp;amp;&amp;amp;(i_dbg_data[`STEP_BIT]);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;While this description may sound simple, the devil is in the details.
For example, what happens when the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
is in the middle of an atomic operation?
What if an interrupt comes in while the debugger has the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
halted?  (It gets ignored.) What if the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
is in the middle of executing a pair of instructions from a compressed
instruction set word?  (The &lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;
has no ability to restart a compressed instruction word mid-way through …)
What if the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
is loading a cache line, and the memory is slow to respond? (i.e. broken)&lt;/p&gt;

&lt;p&gt;All of these details can make this halt line difficult to implement.&lt;/p&gt;

&lt;h2 id=&quot;clearing-the-cache&quot;&gt;Clearing the Cache&lt;/h2&gt;

&lt;p&gt;Before we move on to gaining access to
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Processor_register&quot;&gt;registers&lt;/a&gt;,
the control register offers one more big capability–that of
clearing the cache.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;initial	cmd_clear_pf_cache = 1&#39;b0;
always @(posedge i_clk)
	cmd_clear_pf_cache &amp;lt;= (dbg_cmd_write)&amp;amp;&amp;amp;(i_dbg_data[`CLEAR_CACHE_BIT];&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This is one of those annoying details that you may not think of initially.
If the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
is halted, the debugger is free to change memory, right?  Hence,
the debugger might wish to swap a normal instruction for a &lt;code class=&quot;highlighter-rouge&quot;&gt;BREAK&lt;/code&gt;
instruction or vice versa.  The problem lies in whether the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
has already read that instruction into its cache.  If the instruction the
debugger wishes to change is already in the cache, then the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
might not notice the fact that the debugger has changed that memory.
(The &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;ZipCPU&lt;/a&gt;
cache has no bus snooping capability … yet.)&lt;/p&gt;

&lt;p&gt;This command also clears the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;’s
pipeline for essentially the same reason–lest the instruction the debugger
wished to change was also within the pipeline already and just waiting to
execute.  We discussed how this was done earlier, when we discussed how
the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;
implemented its
&lt;a href=&quot;/zipcpu/2017/08/23/cpu-pipeline.md&quot;&gt;pipeline logic&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;reading-and-setting-registers&quot;&gt;Reading and Setting Registers&lt;/h2&gt;

&lt;p&gt;While a proper bus protocol makes sense for reading from
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Processor_register&quot;&gt;registers&lt;/a&gt;,
as we discussed above,
the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;’s
debug implementation isn’t quite a full bus implementation. Perhaps this
interaction is ready for redesign.  For now, I’ll just explain it as it is.&lt;/p&gt;

&lt;p&gt;The &lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt; control register contains a
set of six address bits.  Writes to the control register can be used to set
these six address bits as well other flags such as those we discussed above.
These then become the
&lt;a href=&quot;https://opencores.org/cdn/downloads/wbspec_b4.pdf&quot;&gt;wishbone&lt;/a&gt;
address of a register within the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;.
Ever after, reads from (or writes to) the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;
data register will adjust the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;.
&lt;a href=&quot;https://en.wikipedia.org/wiki/Processor_register&quot;&gt;register&lt;/a&gt;,
addressed by these six address bits.&lt;/p&gt;

&lt;p&gt;Remember how &lt;a href=&quot;/zipcpu/2017/05/23/simplebus.html&quot;&gt;we discussed
earlier&lt;/a&gt;
that a register read from a bus is just a big case statement?  The same is true
of the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;.
The only difference within the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;
is that 28 of the 32 &lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Processor_register&quot;&gt;registers&lt;/a&gt;,
are stored in an on-chip RAM while the other four are collected from a
set of control and status bits, and the two program counters.  Reading from
the bus, therefore, is almost the same as the big case statement
&lt;a href=&quot;/zipcpu/2017/05/23/simplebus.html&quot;&gt;we discussed earlier&lt;/a&gt;:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
begin
	// 28 registers are normal, and can be read from a memory
	o_dbg_reg &amp;lt;= regset[i_dbg_reg];

	// The PC is a bit different
	if (i_dbg_reg[3:0] == `CPU_PC_REG)
		o_dbg_reg &amp;lt;= w_debug_pc;
	else if (i_dbg_reg[3:0] == `CPU_CC_REG)
	begin
		// As is the flags register
		o_dbg_reg[14:0] &amp;lt;= (i_dbg_reg[4])?w_uflags:w_iflags;
		o_dbg_reg[15] &amp;lt;= 1&#39;b0;
		o_dbg_reg[31:23] &amp;lt;= w_cpu_info;
		o_dbg_reg[`CPU_GIE_BIT] &amp;lt;= gie;
	end
end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Writes are a touch more difficult, since the debugger needs to insert any
register writes into the processing chain of the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The &lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;.
handles such writes by creating a module parallel with the
&lt;a href=&quot;/zipcpu/08/11/simple-alu.html&quot;&gt;ALU&lt;/a&gt;
and &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/memops.v&quot;&gt;memory&lt;/a&gt;.
This module (really only a register and about 4 lines of code) is only active
if the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
is halted.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	dbgv &amp;lt;= (!i_rst)&amp;amp;&amp;amp;(i_halt)&amp;amp;&amp;amp;(i_dbg_we)&amp;amp;&amp;amp;(r_halted);
always @(posedge i_clk)
	dbg_val &amp;lt;= i_dbg_data;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Likewise, the register (and value) the
&lt;a href=&quot;/zipcpu/08/11/simple-alu.html&quot;&gt;ALU&lt;/a&gt; would’ve written
upon completion is modified during a halt as well:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	if (adf_ce_unconditional)
		// A normal register write, if the CPU is running
		alu_reg &amp;lt;= op_R
	else if ((i_halt)&amp;amp;&amp;amp;(i_dbg_we))
		// A debug register write, requiring the CPU to be halted
		alu_reg &amp;lt;= i_dbg_reg&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This then sets the write values on the clock before writeback.  (The
&lt;code class=&quot;highlighter-rouge&quot;&gt;adf_ce_unconditional&lt;/code&gt; flag is a piece of the 
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;’s
pipeline logic that we may come back and address in more detail later in
a post on pipelining.)&lt;/p&gt;

&lt;p&gt;Finally, so that the debugger can know that this write has occurred, the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt; holds the stall register high
any time it the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
hasn’t completely halted.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;assign	o_dbg_stall = !r_halted;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;You may notice, if you look at the code, that there’s no acknowledgement line.
Indeed, the acknowledgement line is generated at the bottom of the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/zipbones.v&quot;&gt;ZipBones&lt;/a&gt;
file based upon the fact that any request made to the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;, as long
as the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
isn’t stalled, is successful.&lt;/p&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;You may notice that the logic above only depends upon a couple of wires,
and that these wires have a very simple amount of logic assicated with them.
This is how digital design should be.  The trick to every problem is knowing
how to make the problem simple.&lt;/p&gt;

&lt;p&gt;In our case, this problem is simplified by first creating some form of
&lt;a href=&quot;https://github.com/ZipCPU/dbgbus/tree/master/hexbus&quot;&gt;debugging bus&lt;/a&gt;
to get a bus access point to our hardware and peripherals, as well as
understanding several various &lt;a href=&quot;/blog/2017/08/14/strategies-for-pipelining.html&quot;&gt;pipeline
strategies&lt;/a&gt;,
and then second understanding how a simple &lt;a href=&quot;/zipcpu/2017/08/23/cpu-pipeline.html&quot;&gt;CPU can use such a
strategy&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;This still leaves us with many more
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;
topics to discuss, such as how to add or remove peripherals by simply
adding or removing parameters from an
&lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt;
command line.
However, we are going to postpone that discussion until after I have the
opportunity to discuss
&lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt;
at &lt;a href=&quot;http://www.orconf.org&quot;&gt;ORCONF&lt;/a&gt; this year.&lt;/p&gt;

&lt;p&gt;In the meantime, then, I’d like to turn this blog’s attention to the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_signal_processing&quot;&gt;DSP&lt;/a&gt;
topics of both sine wave generation and
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;digital filtering&lt;/a&gt;.
We’ll come back to the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;
later–if for no other reason than I’ve been asked to discuss how to modify
&lt;a href=&quot;https://www.gcc.org&quot;&gt;GCC&lt;/a&gt;
to support a new
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt; 
backend.&lt;/p&gt;

&lt;hr /&gt;&lt;p&gt;&lt;em&gt;No man can serve two masters: for either he will hate the one, and love the other; or else he will hold to the one, and despise the other. Ye cannot serve God and mammon.  (Matt 6:24)&lt;/em&gt;</description>
        <pubDate>Fri, 25 Aug 2017 00:00:00 -0400</pubDate>
        <link>http://zipcpu.com/zipcpu/2017/08/25/hw-debugging.html</link>
        <guid isPermaLink="true">http://zipcpu.com/zipcpu/2017/08/25/hw-debugging.html</guid>
        
        
        <category>zipcpu</category>
        
      </item>
    
      <item>
        <title>The ZipCPU&#39;s pipeline logic</title>
        <description>&lt;p&gt;Now that we’ve discussed some &lt;a href=&quot;/blog/2017/08/14/strategies-for-pipelining.html&quot;&gt;general pipeline
strategies&lt;/a&gt;,
it’s time to take a look at how pipelining can work within a simple, in order,
pipelined &lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;.
Let’s take a look, therefore, at the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;
and see how it handles its pipeline logic.
What you’ll see is that the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;
uses a variant of the &lt;a href=&quot;/blog/2017/08/14/strategies-for-pipelining.html&quot;&gt;handshaking strategy we discussed
earlier&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;If you are unfamiliar with the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;, the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;
has five pipeline stages, as shown in Fig 1.&lt;/p&gt;

&lt;table style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 1: The ZipCPU Pipeline Structure&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/zipcpu.png&quot; alt=&quot;ZipCPU Pipeline Structurre&quot; width=&quot;380&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;There’s the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/pfcache.v&quot;&gt;prefetch and instruction
cache&lt;/a&gt;
stage, an &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/idecode.v&quot;&gt;instruction
decode&lt;/a&gt; stage,
a read operands stage, an
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/cpuops.v&quot;&gt;ALU&lt;/a&gt;
stage and a writeback stage.  The
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/cpuops.v&quot;&gt;ALU&lt;/a&gt;
stage is also placed parallel to a &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/pipemem.v&quot;&gt;memory operations
unit&lt;/a&gt;, a
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/div.v&quot;&gt;divide&lt;/a&gt; unit,
and a space for (a still undefined) floating point unit.&lt;/p&gt;

&lt;p&gt;As currently built, the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;
is an in-order processor.  It’s pipeline structure requires that
values going into the write-back unit be strictly in order.&lt;/p&gt;

&lt;p&gt;If you choose to look through the main
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt; &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;processor’s
code&lt;/a&gt;,
you may find it not as simple to read.  That’s because the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;
was written to thread a fine line between two separate purposes.  The first,
stated purpose, is to be a simple
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;–as
measured by the amount of logic used by the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;.
The second purpose is to be a fast
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;.
These two purposes are often in conflict.  Therefore, the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt; implementation allows you to
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/cpudefs.v&quot;&gt;select the performance you
want&lt;/a&gt;, and
adjust as necessary to fit the amount of logic you have available for a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;
within your
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Let’s use this as an example, though, in how a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;
pipeline can be created within an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;instruction-overview&quot;&gt;Instruction Overview&lt;/h2&gt;

&lt;p&gt;In order to make the following examples make sense, it might help to
understand how the various pipeline stages are supposed to interact.
This will make examples easier to understand.&lt;/p&gt;

&lt;p&gt;First, almost all
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;
instructions have the form:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-assembly&quot; data-lang=&quot;assembly&quot;&gt;   OP.C Ra,Rb+I&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;In this example, &lt;code class=&quot;highlighter-rouge&quot;&gt;OP&lt;/code&gt; is the operation.  It’s a 5-bit field identifying
which instruction is described by this instruction.  Think of this as &lt;em&gt;what&lt;/em&gt;
the &lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;
is being asked to do.  Indeed, four of the five &lt;code class=&quot;highlighter-rouge&quot;&gt;OP&lt;/code&gt; bits form the
multiplexer selection input within the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/cpuops.v&quot;&gt;ALU&lt;/a&gt; as
&lt;a href=&quot;/zipcpu/2017/08/11/simple-alu.html&quot;&gt;we discussed earlier&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The &lt;code class=&quot;highlighter-rouge&quot;&gt;C&lt;/code&gt; term is the condition.  This controls whether or not any value
is written back from the instruction.  For example, the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;
supports a &lt;code class=&quot;highlighter-rouge&quot;&gt;Z&lt;/code&gt; condition which will cause the instruction to only write back
its results if the &lt;code class=&quot;highlighter-rouge&quot;&gt;Z&lt;/code&gt; flag is set.  The other seven supported conditions are
discussed within the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/doc/spec.pdf&quot;&gt;ZipCPU
specification&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The &lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;
is primarily a two operand machine.  It has no three operand instructions.
Hence, every
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/cpuops.v&quot;&gt;ALU&lt;/a&gt;
instruction provides two inputs to the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/cpuops.v&quot;&gt;ALU&lt;/a&gt;,
&lt;code class=&quot;highlighter-rouge&quot;&gt;Ra&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;Rb+I&lt;/code&gt; and the output gets written back into register &lt;code class=&quot;highlighter-rouge&quot;&gt;Ra&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Finally, and this becomes important for the following discussion, almost
all instructions allow an immediate, usually 14-bits, to be added
to the second register, &lt;code class=&quot;highlighter-rouge&quot;&gt;Rb&lt;/code&gt;.  Alternatively, an 18-bit immediate value, &lt;code class=&quot;highlighter-rouge&quot;&gt;I&lt;/code&gt;,
may replace the ALU’s &lt;code class=&quot;highlighter-rouge&quot;&gt;Rb&lt;/code&gt; input so that &lt;code class=&quot;highlighter-rouge&quot;&gt;Rb&lt;/code&gt; is not used at all.&lt;/p&gt;

&lt;p&gt;So, how does this impact pipelining?&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;In the first stage, &lt;strong&gt;prefetch&lt;/strong&gt;, an instruction is read from memory.&lt;/p&gt;

    &lt;p&gt;The &lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;
can run with one of several prefetch modules.
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/prefetch.v&quot;&gt;[1]&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/dblfetch.v&quot;&gt;[2]&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/pipefetch.v&quot;&gt;[3]&lt;/a&gt;,
and
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/pfcache.v&quot;&gt;[4]&lt;/a&gt;.
Each of these modules has roughly the same interface, although the logic
within them can differ greatly.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;In the second stage, the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/idecode.v&quot;&gt;instruction
decode&lt;/a&gt;
stage, the parts of the instruction are drawn from from the instruction word
produced by the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/pfcache.v&quot;&gt;prefetch&lt;/a&gt;
stage.&lt;/p&gt;

    &lt;p&gt;As an example, this stage determines whether or not the instruction even has
registers &lt;code class=&quot;highlighter-rouge&quot;&gt;Ra&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;Rb&lt;/code&gt; encoded within it that need to be read from the
register set.  At the end of this stage the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;,
knows:&lt;/p&gt;

    &lt;p&gt;a. what registers it needs to read (&lt;code class=&quot;highlighter-rouge&quot;&gt;dcd_A&lt;/code&gt;, and &lt;code class=&quot;highlighter-rouge&quot;&gt;dcd_B&lt;/code&gt;),&lt;/p&gt;

    &lt;p&gt;b. if it needs to read from any register (&lt;code class=&quot;highlighter-rouge&quot;&gt;dcd_rA&lt;/code&gt;, and &lt;code class=&quot;highlighter-rouge&quot;&gt;dcd_rB&lt;/code&gt;)&lt;/p&gt;

    &lt;p&gt;c. what the immediate value is (&lt;code class=&quot;highlighter-rouge&quot;&gt;dcd_I&lt;/code&gt;), and if that value is zero
   (&lt;code class=&quot;highlighter-rouge&quot;&gt;dcd_Iz&lt;/code&gt;)&lt;/p&gt;

    &lt;p&gt;d. etc.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The third stage, the read operands stage, not only reads &lt;code class=&quot;highlighter-rouge&quot;&gt;Ra&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;Rb&lt;/code&gt; from
the register file, but also adds &lt;code class=&quot;highlighter-rouge&quot;&gt;I&lt;/code&gt; to &lt;code class=&quot;highlighter-rouge&quot;&gt;Rb&lt;/code&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The fourth stage calculates the &lt;code class=&quot;highlighter-rouge&quot;&gt;OP&lt;/code&gt; function on the values from &lt;code class=&quot;highlighter-rouge&quot;&gt;Ra&lt;/code&gt; and
&lt;code class=&quot;highlighter-rouge&quot;&gt;Rb+I&lt;/code&gt;.&lt;/p&gt;

    &lt;p&gt;If this is an
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/cpuops.v&quot;&gt;ALU&lt;/a&gt;,
instruction, the &lt;code class=&quot;highlighter-rouge&quot;&gt;OP&lt;/code&gt; field controls which potential output from the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/cpuops.v&quot;&gt;ALU&lt;/a&gt;,
&lt;a href=&quot;/zipcpu/2017/08/11/simple-alu.html&quot;&gt;will be selected&lt;/a&gt;.&lt;/p&gt;

    &lt;p&gt;If this is a &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/pipemem.v&quot;&gt;memory
operation&lt;/a&gt;,
a store will place the value &lt;code class=&quot;highlighter-rouge&quot;&gt;Ra&lt;/code&gt; into
memory location &lt;code class=&quot;highlighter-rouge&quot;&gt;Rb+I&lt;/code&gt;.  A load will read from memory
&lt;code class=&quot;highlighter-rouge&quot;&gt;Rb+I&lt;/code&gt; and present the result to the writeback unit.&lt;/p&gt;

    &lt;p&gt;Memory accesses, divides, and multiplies may all take longer than a single
clock in this stage.  We’ll need to come back and discuss how to handle
this later.&lt;/p&gt;

    &lt;p&gt;If done well, the outputs of this stage, whether from the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/cpuops.v&quot;&gt;ALU&lt;/a&gt;
or the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/memops.v&quot;&gt;memory
unit&lt;/a&gt;
can go directly back into this stage as inputs if so desired, as shown
in Fig 2.&lt;/p&gt;

    &lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 2: Answers go back into the ALU&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/cpu-bypass.svg&quot; alt=&quot;Answers go back into the ALU&quot; width=&quot;580&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

    &lt;p&gt;This will take place any time the output of the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/cpuops.v&quot;&gt;ALU&lt;/a&gt;
stage forms the input for the next instruction.  Indeed, this is a key
requirement for a high speed
pipelined &lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;.&lt;/p&gt;

    &lt;p&gt;However, if the output of the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/cpuops.v&quot;&gt;ALU&lt;/a&gt;
gets placed into the &lt;code class=&quot;highlighter-rouge&quot;&gt;Rb&lt;/code&gt; register input of the next instruction, &lt;em&gt;and&lt;/em&gt;
if that instruction
has an immediate, &lt;code class=&quot;highlighter-rouge&quot;&gt;I&lt;/code&gt;, that needs to be added to it (&lt;code class=&quot;highlighter-rouge&quot;&gt;dcd_zI&lt;/code&gt; is non-zero),
then the output cannot go directly back into the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/cpuops.v&quot;&gt;ALU&lt;/a&gt;.
It will instead need to go back to the read operands stage, causing
a pipeline bubble in the process.  This other path is shown by the dotted
line in Fig 2.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Finally, in the writeback unit, if the &lt;code class=&quot;highlighter-rouge&quot;&gt;C&lt;/code&gt; condition matches, the result
is written back into the register set.&lt;/p&gt;

    &lt;p&gt;Conditional branches are detected in this stage.  We’ll have to come back
and discuss how to handle this within the pipeline later as well.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;This is nominally how the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;
handles and uses its pipeline.  This simple pipeline, though, has all kinds
of hazards—many of which we’ll discuss below.&lt;/p&gt;

&lt;h2 id=&quot;pipeline-stalls-and-bubbles&quot;&gt;Pipeline Stalls and Bubbles&lt;/h2&gt;

&lt;p&gt;Before diving into pipeline specifics, let’s define a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bubble_(computing)&quot;&gt;pipeline stall&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;According to &lt;a href=&quot;https://en.wikipedia.org/wiki/Bubble_(computing)&quot;&gt;wikipedia&lt;/a&gt;,
a &lt;a href=&quot;https://en.wikipedia.org/wiki/Bubble_(computing)&quot;&gt;pipeline stall&lt;/a&gt;
is a condition where there’s no valid instruction within a particular pipeline
stage.  &lt;a href=&quot;https://en.wikipedia.org&quot;&gt;Wikipedia&lt;/a&gt; declares a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bubble_(computing)&quot;&gt;pipeline stall&lt;/a&gt;
to be synonymous with a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bubble_(computing)&quot;&gt;pipeline bubble&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;As the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt; uses the term, a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bubble_(computing)&quot;&gt;pipeline stall&lt;/a&gt;
takes place when there &lt;em&gt;is&lt;/em&gt; a valid instruction within a particular pipeline
stage, but when that instruction cannot move forward.&lt;/p&gt;

&lt;p&gt;For example, the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/div.v&quot;&gt;divide&lt;/a&gt;
takes roughly 32-clocks to complete.  During these 32-clocks, instructions in
the prior stage, the read operands stage, will be stuck there until the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/div.v&quot;&gt;divide&lt;/a&gt;
completes.   Likewise, the writeback stage will be idle during this time,
being reserved for writing back the results of the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/div.v&quot;&gt;divide&lt;/a&gt;
instruction.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org&quot;&gt;Wikipedia&lt;/a&gt;’s definition declares the condition
where no valid data is within a pipeline stage to be called a stall.  This
seems to me to be more of a consequence of a stall, than a stall itself.
The &lt;strong&gt;pipeline bubble&lt;/strong&gt; term describes this better, although
&lt;a href=&quot;https://en.wikipedia.org&quot;&gt;Wikipedia&lt;/a&gt; declares the two terms to be synonymous.&lt;/p&gt;

&lt;p&gt;If you watch the pipeline, such as within the demonstration we’ll discuss
later, you can visually see &lt;strong&gt;bubble&lt;/strong&gt;s form within it where there are no valid
instructions.&lt;/p&gt;

&lt;h2 id=&quot;unique-pipeline-needs&quot;&gt;Unique Pipeline Needs&lt;/h2&gt;

&lt;p&gt;There are two basic goals that a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;
has with respect to pipelining.  These two goals are common among
many pipeline systems:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Keep every stage filled.&lt;/p&gt;

    &lt;p&gt;For example, the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;
is capable of completing and retiring one
&lt;a href=&quot;/zipcpu/2017/08/11/simple-alu.html&quot;&gt;ALU&lt;/a&gt;
instruction per clock.  All of the pipeline logic within the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;CPU&lt;/a&gt;
has been designed so as to keep one instruction completing on every clock.&lt;/p&gt;

    &lt;p&gt;This is a common goal of any high speed pipeline.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Satisfy any pre-requisites for instruction operations.&lt;/p&gt;

    &lt;p&gt;An &lt;a href=&quot;/zipcpu/2017/08/11/simple-alu.html&quot;&gt;ALU&lt;/a&gt;
operation cannot complete if its values haven’t finished being produced
from other parts of the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;CPU&lt;/a&gt;.
For example, if
register &lt;code class=&quot;highlighter-rouge&quot;&gt;R0&lt;/code&gt;  is read from slow memory in one instruction and then
immediately used on the next instruction, the pipeline logic will need to
stall the second instruction, waiting for the
&lt;a href=&quot;/zipcpu/2017/08/11/simple-alu.html&quot;&gt;ALU&lt;/a&gt;,
until &lt;code class=&quot;highlighter-rouge&quot;&gt;R0&lt;/code&gt; is available.&lt;/p&gt;

    &lt;p&gt;This problem is even worse if an immediate is to be added to the value
read from memory prior to heading into the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/cpuops.v&quot;&gt;ALU&lt;/a&gt;.
In that case, it’s not just the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/cpuops.v&quot;&gt;ALU&lt;/a&gt;
that needs to stall, but the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;
also needs to stall the read operands stage where that immediate addition
takes place.  (We discussed this with Fig 2 above)&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;A &lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;,
though, has some other pipeline needs beyond the more traditional data flow
processing pipeline.  Specifically,
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;’s
need to be able to jump from one instruction in memory to another.  This
creates some unusual pipeline requirements.&lt;/p&gt;

&lt;p&gt;At its most basic level, a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;
needs be able to flush or clear its pipeline any time a branch renders
the work done in a prior stage irrelevant.
The worst case scenario is when a branch takes place that can’t be
caught prior to the writeback stage.  In that case, the whole pipeline will
need to be flushed, costing the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;
one clock per pipeline stage that cannot be completed.
The &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;ZipCPU&lt;/a&gt;
captures this logic with the &lt;code class=&quot;highlighter-rouge&quot;&gt;clear_pipeline&lt;/code&gt; signal.&lt;/p&gt;

&lt;p&gt;Other things can cause sudden pipeline changes as well.  For example, what
happens on an interrupt (peripheral initiated), a trap (user initiated), or
a fault?  The
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;
will need to start processing instructions from a new location in the
instruction stream–that of the interrupt service routine (ISR).
The &lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;
handles this condition by flushing the pipeline on any change of interrupt
status.
The &lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt; is also unique in that the
interrupt address is kept within an alternate register set.  (See the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/doc/spec.pdf&quot;&gt;ZipCPU
specification&lt;/a&gt;
for details.&lt;/p&gt;

&lt;p&gt;Indeed, lots of things need to change within the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;
every time it switches to an interrupt context, or back again.
If you want to trace this logic, feel free to
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;look for&lt;/a&gt;
the &lt;code class=&quot;highlighter-rouge&quot;&gt;w_switch_to_interrupt&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;w_release_from_interrupt&lt;/code&gt; wires.  The first
will be true any time the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;
switches to an interrupt context, the second will be true anytime the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;
switches back.&lt;/p&gt;

&lt;p&gt;Now, with all that as background, we can discuss the logic necessary to handle
a pipeline handshake.&lt;/p&gt;

&lt;h2 id=&quot;cpu-handshake&quot;&gt;CPU Handshake&lt;/h2&gt;

&lt;table style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 3: ZipCPU Pipeline Signals&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/pipeline-blocks-cpu.svg&quot; alt=&quot;ZipCPU Pipeline Signals&quot; width=&quot;380&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;The
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;
pipeline is controlled primarily with three logic signals per stage:
&lt;code class=&quot;highlighter-rouge&quot;&gt;stalled&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;valid&lt;/code&gt;, and &lt;code class=&quot;highlighter-rouge&quot;&gt;CE&lt;/code&gt;, as shown in Fig 3 to the right.  The logic is
designed around the idea of processing the data from the previous stage any
time a &lt;code class=&quot;highlighter-rouge&quot;&gt;CE&lt;/code&gt; line is set.  The basic logic is this: if a stage is not stalled,
and if the previous stage is valid, then the &lt;code class=&quot;highlighter-rouge&quot;&gt;CE&lt;/code&gt; line will be set.  The &lt;code class=&quot;highlighter-rouge&quot;&gt;CE&lt;/code&gt;
control signal is used to determine when to clock the data from the last stage
forward.&lt;/p&gt;

&lt;p&gt;Let’s walk though that for a moment.&lt;/p&gt;

&lt;p&gt;First, each stage has a condition (or set of conditions) that might stall the
prior stage from entering this stage.  This is the stall logic for this stage.&lt;/p&gt;

&lt;p&gt;For example, the read operands stage will stall any time the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/cpuops.v&quot;&gt;ALU&lt;/a&gt;
is already busy, the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/memops.v&quot;&gt;memory
unit&lt;/a&gt; is busy
with a read, or the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/div.v&quot;&gt;divide&lt;/a&gt; is busy.
The lines &lt;code class=&quot;highlighter-rouge&quot;&gt;alu_busy&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;mem_busy&lt;/code&gt;, and &lt;code class=&quot;highlighter-rouge&quot;&gt;div_busy&lt;/code&gt; are used to capture these
conditions.  An exception is made if the memory unit is busy &lt;em&gt;writing&lt;/em&gt; a value
over the bus.  In this case, &lt;code class=&quot;highlighter-rouge&quot;&gt;mem_rdbusy&lt;/code&gt; captures the idea that the memory
is busy with a read and not a write.  Likewise, the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/cpuops.v&quot;&gt;ALU&lt;/a&gt;
will also stall if the external halt request line is true.  (We’ll come back and
discuss this when discussing how to debug a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt; later.)
Another, less common, example is that the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/cpuops.v&quot;&gt;ALU&lt;/a&gt;
will stall any time the condition codes are written to manually–lest the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/cpuops.v&quot;&gt;ALU&lt;/a&gt;
write a value back according to the wrong conditions.&lt;/p&gt;

&lt;p&gt;In general, though, the stall logic looks like:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;assign	stage[n]_stalled = (stage[n]_valid)&amp;amp;&amp;amp;((stage[n+1]_stalled)
		||(things that would stall this stage));&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;In this case, I’m using &lt;code class=&quot;highlighter-rouge&quot;&gt;stage[n]_stalled&lt;/code&gt; to describe the &lt;code class=&quot;highlighter-rouge&quot;&gt;stalled&lt;/code&gt; variable
for this stage.  If you look within the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;,
you’ll find variables named &lt;code class=&quot;highlighter-rouge&quot;&gt;pf_stalled&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;dcd_stalled&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;op_stalled&lt;/code&gt;,
&lt;code class=&quot;highlighter-rouge&quot;&gt;alu_stalled&lt;/code&gt;, and &lt;code class=&quot;highlighter-rouge&quot;&gt;mem_stalled&lt;/code&gt;.  These variables capture this
logic, together with all of the more obscure reasons why the &lt;code class=&quot;highlighter-rouge&quot;&gt;stalled&lt;/code&gt; line
might be made true as well–such as on a debugging &lt;code class=&quot;highlighter-rouge&quot;&gt;BREAK&lt;/code&gt; instruction.&lt;/p&gt;

&lt;p&gt;Second, if any stage is not stalled, and if the prior stage has valid data
within it, then we can step that stage forward.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;assign	stage[n]_ce = (stage[n-1]_valid)&amp;amp;&amp;amp;(!stage[n]_stalled);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;If you pay close attention, you might find this looks a lot like the
handshake signal, &lt;code class=&quot;highlighter-rouge&quot;&gt;(i_ce)&amp;amp;&amp;amp;(!o_busy)&lt;/code&gt;, that we discussed in our &lt;a href=&quot;/blog/2017/08/14/strategies-for-pipelining.html&quot;&gt;last post on
pipelining&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Inside the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;,
these various pipeline variables are named
&lt;code class=&quot;highlighter-rouge&quot;&gt;dcd_ce&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;op_ce&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;alu_ce&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;mem_ce&lt;/code&gt;, and &lt;code class=&quot;highlighter-rouge&quot;&gt;div_ce&lt;/code&gt;.  There’s also a similar
&lt;code class=&quot;highlighter-rouge&quot;&gt;master_ce&lt;/code&gt; which is controlled from the external debugging interface–something
we’ll get to later.&lt;/p&gt;

&lt;p&gt;With these signals out of the way, we can start working through the pipeline
signals.  The first registered signal is the &lt;code class=&quot;highlighter-rouge&quot;&gt;valid&lt;/code&gt; signal.  This signal
indicates whether or not a particular stage has valid data within it.
To get valid data into a stage, the prior stage must have valid data, and
this stage cannot be stalled.  Hence, we have the following logic:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	// On any reset or clear pipeline, we clear the stage valid
	// register
	if ((i_reset)||(clear_pipeline))
	begin
		stage[n]_valid &amp;lt;= 1&#39;b0;
	end if (stage[n]_ce)
	begin
		// Otherwise, we accept the data from the previous
		// stage, and operate upon it if necessary.
		stage[n]_valid &amp;lt;= stage[n-1]_valid;
	end else if (stage[n+1]_ce)
		// If there&#39;s nothing valid to come in, but the next stage
		// has taken our data, then we are no longer valid here anymore.
		stage[n]_valid &amp;lt;= 1&#39;b0;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Within the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;,
the basic valid registers are called &lt;code class=&quot;highlighter-rouge&quot;&gt;pf_valid&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;dcd_valid&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;op_valid&lt;/code&gt;.
The &lt;code class=&quot;highlighter-rouge&quot;&gt;op_valid&lt;/code&gt; signal is also broken into three separate signals, depending
upon which stage the read operands stage moves to next:
&lt;code class=&quot;highlighter-rouge&quot;&gt;op_valid_alu&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;op_valid_mem&lt;/code&gt;, and  &lt;code class=&quot;highlighter-rouge&quot;&gt;op_valid_div&lt;/code&gt;.  Finally, the output
of the ALU/MEM/DIV stage is captured by the &lt;code class=&quot;highlighter-rouge&quot;&gt;alu_valid&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;mem_valid&lt;/code&gt;, and
&lt;code class=&quot;highlighter-rouge&quot;&gt;div_valid&lt;/code&gt; signals.  Indeed, these signals are used to determine whether
or not valid data is ready to be written back.&lt;/p&gt;

&lt;p&gt;One particular difficulty with this language is the idea of an illegal
instruction.  Within the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;,
a stage containing an illegal instruction has the &lt;code class=&quot;highlighter-rouge&quot;&gt;valid&lt;/code&gt; line set high.
This is because an illegal instruction needs to be processed like any other
instruction, and the &lt;code class=&quot;highlighter-rouge&quot;&gt;valid&lt;/code&gt; line controls when processing moves forward.
The alternative, moving instructions forward any time &lt;code class=&quot;highlighter-rouge&quot;&gt;valid&lt;/code&gt; &lt;em&gt;or&lt;/em&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;illegal&lt;/code&gt; were true, just costs more logic than required.&lt;/p&gt;

&lt;p&gt;Each stage has many more logic lines beyond the ones we just discussed.
These can often be treated in a much simpler fashion, though.  As a result,
these other signals are often sate based upon the simple &lt;code class=&quot;highlighter-rouge&quot;&gt;stage[n]_ce&lt;/code&gt; signal:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	if (stage[n]_ce)
		stage[n]_data &amp;lt;= ... // function of stage[n-1]_data&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Those are the basics of how the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;
handles pipelining.  Be aware, though, &lt;em&gt;the devil is in the details&lt;/em&gt;.
There are all kinds of pipeline hazards that you may not expect when first
building a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;My best advice for others, when trying to find these pipeline problems, is
to methodically debug your
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;
using
&lt;a href=&quot;https://www.veripool.org/wiki/verilator&quot;&gt;Verilator&lt;/a&gt; and some small programs.
Use &lt;a href=&quot;https://gcc.gnu.org&quot;&gt;GCC&lt;/a&gt;
both all optimizations turned on, as well as with all
optimizations turned off.  The two environments create very different pipeline
environments, and programs working in the one may not work in the other.  My
second piece of advice would be to create a program containing every pipeline
hazard you can think of, and to turn this program into a test program for the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;.
You can find the &lt;a href=&quot;https://github.com/ZipCPU/zipcu&quot;&gt;ZipCPU&lt;/a&gt;’s
&lt;a href=&quot;https://github.com/ZipCPU/openarty/blob/master/sw/board/cputest.c&quot;&gt;CPU testing
program&lt;/a&gt;
within the &lt;a href=&quot;https://github.com/ZipCPU/openarty&quot;&gt;OpenArty&lt;/a&gt; distribution.&lt;/p&gt;

&lt;h2 id=&quot;demonstration&quot;&gt;Demonstration&lt;/h2&gt;

&lt;p&gt;I have a wonderful demonstration of all of this that I would like to post, but
to see it I may need some help from my readers.&lt;/p&gt;

&lt;p&gt;Specifically, the demonstration involves building the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt; distribution, and then running the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/bench/asm/simtest.s&quot;&gt;simtest&lt;/a&gt;
program within the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/sim/verilated/zipcpu_tb.cpp&quot;&gt;simulator&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/sim/verilated/zipcpu_tb.cpp&quot;&gt;simulator&lt;/a&gt;
allows you to watch how well the pipeline is filled at any given clock, as
well as the ability to “watch” the signals discussed above.  Further, by
adjusting the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/cpudefs.v&quot;&gt;pipeline
parameters&lt;/a&gt;,
you can see how the pipeline and
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
are affected as the logic within the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;,
is increased or decreased.  Indeed, you can watch the &lt;code class=&quot;highlighter-rouge&quot;&gt;valid&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;CE&lt;/code&gt;, and
&lt;code class=&quot;highlighter-rouge&quot;&gt;stall&lt;/code&gt; lines as they get set and adjusted on a clock by clock basis.&lt;/p&gt;

&lt;p&gt;Nominally, the instructions to do this would require something like:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span class=&quot;c&quot;&gt;# Install packages necessary to build the simulator&lt;/span&gt;
sudo apt-get install bc verilator
&lt;span class=&quot;c&quot;&gt;# Install packages necessary to build GCC&lt;/span&gt;
sudo apt-get install flex bison libncurses5-dev
sudo apt-get install libmpfr-dev libmpc-dev libgmp-dev libmpfr-doc
&lt;span class=&quot;c&quot;&gt;# Install libelf.  libelf is used to load executable files into both&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;# the simulator and onto any actual FPGA H/W&lt;/span&gt;
sudo apt-get install libelf-dev
&lt;span class=&quot;c&quot;&gt;#&lt;/span&gt;
git clone https://github.com/ZipCPU/zipcpu
&lt;span class=&quot;nb&quot;&gt;cd &lt;/span&gt;zipcpu
make
&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[[&lt;/span&gt; ! -x sw/install/cross-tools/bin/zip-gcc &lt;span class=&quot;o&quot;&gt;]]&lt;/span&gt;;
&lt;span class=&quot;k&quot;&gt;then
  &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;GCC failed to build&quot;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;else
  if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[[&lt;/span&gt; ! -x sim/verilator/zipsys_tb &lt;span class=&quot;o&quot;&gt;]]&lt;/span&gt;;
  &lt;span class=&quot;k&quot;&gt;then
    &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;The simulator failed to build&quot;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;else
    &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;PATH&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$PATH&lt;/span&gt;:&lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;pwd&lt;/span&gt;&lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;/sw/install/cross-tools/bin/zip-gcc
    &lt;span class=&quot;nb&quot;&gt;cd &lt;/span&gt;bench/asm
    make simtest
    &lt;span class=&quot;nb&quot;&gt;cd&lt;/span&gt; ../../sim/verilator
    &lt;span class=&quot;c&quot;&gt;# Run the demo&lt;/span&gt;
    zipsys_tb ../../bench/asm/simtest
    &lt;span class=&quot;c&quot;&gt;# Press the &#39;t&#39; key to create a system clock &#39;tick&#39;s until things stop&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;#   changing&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;#   Watch how instructions work their way through the various pipeline&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;#   stages at the bottom of the screen&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;# &#39;q&#39; can be used to quit.&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;# &#39;r&#39; can be used to &#39;reboot&#39; the computer, and start the simulation over&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;fi
fi&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This is notional only, the above script has not been “tested” … but I think
it captures the idea of what I would have you do.&lt;/p&gt;

&lt;p&gt;My specific problem is that, while the design works nicely on my own system,
I’d love to have some help from others who would like to try running the
design on their own systems–so as to get some redundance across operating
systems and version differences.  If you are interested in trying this,
please write be at the address below if you have problems, or perhaps
just to tell me of your success.  Enough successes, and I’ll write a more
complete post about how to watch the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;
pipeline in action.&lt;/p&gt;

&lt;p&gt;(Instructions for installing the prerequisites on a Windows machine, using
&lt;a href=&quot;https://cygwin.com&quot;&gt;Cygwin&lt;/a&gt;, can be found
&lt;a href=&quot;/blog/2017/07/28/cygwin-fpga.html&quot;&gt;here&lt;/a&gt;)&lt;/p&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;That’s it!  The
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;
basically uses the &lt;a href=&quot;/blog/2017/08/14/strategies-for-pipelining.html&quot;&gt;handshake
approach&lt;/a&gt;
to handling pipeline stalls that &lt;a href=&quot;/blog/2017/08/14/strategies-for-pipelining.html&quot;&gt;we discussed
earlier&lt;/a&gt;.
A couple extra variables for logic expression allow the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;
to be able to detect and respond appropriately to pipeline hazards, stalling the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;.
anytime it is necessary to do so.&lt;/p&gt;

&lt;p&gt;Now that we’ve gone through this example, I’d like to come back and discuss
how to debug a &lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;
running within an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
in general.  That post has been mostly written for some time, but has been
waiting for this background beneath it to be explained.&lt;/p&gt;

&lt;p&gt;I’d also like to post more complete instructions for the pipeline demonstration
above, outlining how data moves through the
various stages of the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;
pipeline.  I’ll hold off on the demonstration, post, until I have some
confidence that it will work on the greatest number of computers.&lt;/p&gt;

&lt;hr /&gt;&lt;p&gt;&lt;em&gt;For I know that my redeemer liveth, and that he shall stand at the latter day upon the earth (Job 19:25)&lt;/em&gt;</description>
        <pubDate>Wed, 23 Aug 2017 00:00:00 -0400</pubDate>
        <link>http://zipcpu.com/zipcpu/2017/08/23/cpu-pipeline.html</link>
        <guid isPermaLink="true">http://zipcpu.com/zipcpu/2017/08/23/cpu-pipeline.html</guid>
        
        
        <category>zipcpu</category>
        
      </item>
    
      <item>
        <title>Rules for new FPGA designers</title>
        <description>&lt;p&gt;It’s a new school year!&lt;/p&gt;

&lt;p&gt;For all you new students out there, please accept
my welcome to the wonderful world of digital design.  I am neither a student
nor a professor, and yet I have helped many students through their projects
on the &lt;a href=&quot;https://forum.digilentinc.com&quot;&gt;Digilent forum&lt;/a&gt;, as well as on
&lt;a href=&quot;https://webchat.freenode.net&quot;&gt;freenode IRC&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;This post is an outgrowth of my own experience counseling beginners on
&lt;a href=&quot;https://forum.digilentinc.com&quot;&gt;Digilent’s forums&lt;/a&gt;.  Indeed, sometimes I
feel like I’m a broken record there repeating over and over the same rules
for newbies.&lt;/p&gt;

&lt;p&gt;So, before you ask for help, here are a couple rules to keep you from
running into the same trouble others have gotten stuck within:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Build your design with only one clock.&lt;/p&gt;

    &lt;p&gt;If the clock that comes into your chip is the wrong speed for your one
clock, then use a &lt;a href=&quot;https://www.xilinx.com/support/documentation/user_guides/ug472_7Series_Clocking.pdf&quot;&gt;PLL/MMCM&lt;/a&gt; to create the speed you want/need.&lt;/p&gt;

    &lt;p&gt;&lt;a href=&quot;/blog/2017/06/02/generating-timing.html&quot;&gt;This post&lt;/a&gt;
discusses a variety of alternative timing approaches, done within clocked
logic, that don’t require additional clocks to work.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Do &lt;em&gt;not&lt;/em&gt; transition on any negative (falling) edges.&lt;/p&gt;

    &lt;p&gt;Falling edge clocks should be considered a violation of the one
clock principle, as they act like separate clocks.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Do &lt;em&gt;not&lt;/em&gt; transition on the positive (rising) edge of anything other than
your system clock.&lt;/p&gt;

    &lt;p&gt;Lot’s of students seem to want to &lt;a href=&quot;/blog/2017/08/04/debouncing.html&quot;&gt;treat a button like a
clock&lt;/a&gt;, for example.
They then struggle to understand why their design isn’t working.
&lt;a href=&quot;/blog/2017/08/04/debouncing.html&quot;&gt;Here&lt;/a&gt; are some
better approaches that actually work with buttons.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Synchronize all external wire inputs by passing them through two clocked
flip-flops before using them.&lt;/p&gt;

    &lt;p&gt;This helps to avoid problems with
&lt;a href=&quot;https://en.wikipedia.org/wiki/Metastability_in_electronics&quot;&gt;metastability&lt;/a&gt;.
We discussed &lt;a href=&quot;/blog/2017/08/04/debouncing.html&quot;&gt;how to synchronize inputs
here&lt;/a&gt; when dealing with
buttons.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Do &lt;em&gt;not&lt;/em&gt; use an asynchronous reset within your design.&lt;/p&gt;

    &lt;p&gt;Test for any reset within an always block on the positive edge of your system
clock like everything else.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Simulate everything before placing it onto your hardware&lt;/p&gt;

    &lt;p&gt;The unique thing about simulation is that a good simulator will allow you
to see and examine &lt;em&gt;every&lt;/em&gt; piece of logic on &lt;em&gt;every&lt;/em&gt; simulated clock.
A good simulator will also allow you to simulate any external peripherals,
so that you don’t need your hardware to run your simulator.&lt;/p&gt;

    &lt;p&gt;You can read about &lt;a href=&quot;/blog//2017/06/23/my-dbg-philosophy.html&quot;&gt;my own debugging philosophy
here&lt;/a&gt;.&lt;/p&gt;

    &lt;p&gt;You can also read about &lt;a href=&quot;/blog/2017/06/21/looking-at-verilator.html&quot;&gt;how to simulate hardware together with your design
here&lt;/a&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Build unit tests that can “prove” your components work, via a simulator,
so that when you later make changes to “improve” the component, you will
know that the improvements haven’t broken anything.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Build simulations that will support not only unit test, but also full up
integration testing&lt;/p&gt;

    &lt;p&gt;This was also discussed in the post about &lt;a href=&quot;/blog/2017/06/23/my-dbg-philosophy.html&quot;&gt;my own debugging
philosophy&lt;/a&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Make sure you simulate whatever means you will use for debugging your design
before you transition to hardware.&lt;/p&gt;

    &lt;p&gt;An &lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt; can
be a very difficult black box to get debugging information out of.  Before
you transition your design into an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;, I
recommend having some means of getting debugging information back out.  This
means needs to be simulated and proven along with everything else.&lt;/p&gt;

    &lt;p&gt;If you’ve read much of my blog, you’ll know that I highly recommend
&lt;a href=&quot;/blog/2017/06/16/dbg-bus-forest.html&quot;&gt;using a debugging
bus&lt;/a&gt; that
controls your
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt; over
&lt;a href=&quot;https://en.wikipedia.org/wiki/Transmission_Control_Protocol&quot;&gt;TCP&lt;/a&gt;/&lt;a href=&quot;https://en.wikipedia.org/wiki/Internet_protocol_suite&quot;&gt;IP&lt;/a&gt;.  That allows you &lt;a href=&quot;/blog/2017/06/17/why-network-debugging.html&quot;&gt;to
control&lt;/a&gt;
your &lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
simulation, or your
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt; itself,
from the same software.&lt;/p&gt;

    &lt;p&gt;While there are proprietary solutions to this problem that do not require a
&lt;a href=&quot;/blog/2017/06/16/dbg-bus-forest.html&quot;&gt;debugging bus&lt;/a&gt;,
you may struggle to integrate your
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
interaction software with them.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Don’t use &lt;a href=&quot;https://en.wikipedia.org/wiki/Magic_number_(programming)&quot;&gt;magic numbers&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;A &lt;a href=&quot;https://en.wikipedia.org/wiki/Magic_number_(programming)&quot;&gt;magic number&lt;/a&gt;
is a number that shows up without explanation or dependency within your code.&lt;/p&gt;

    &lt;p&gt;This one is so important, that &lt;a href=&quot;https://twitter.com/dEnergy_dTime&quot;&gt;Marcus
Muller&lt;/a&gt; chose to echo this sentiment
as well in the twitter section down below.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Never write the same code twice.&lt;/p&gt;

    &lt;p&gt;Write it once, write it well, and then reuse it.  Fix it, if you must fix
it, just don’t rewrite it over and over again for every project.   If done
well, this will give you a jump start on any future projects.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;rules-for-software-engineers&quot;&gt;Rules for software engineers&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Hardware design is &lt;em&gt;not&lt;/em&gt; like software design&lt;/p&gt;

    &lt;p&gt;In software, you can use &lt;code class=&quot;highlighter-rouge&quot;&gt;printf()&lt;/code&gt; or a debugger to &lt;em&gt;see&lt;/em&gt; every variable in
your algorithm.  In an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;, you
will struggle to &lt;em&gt;see&lt;/em&gt; anything.&lt;/p&gt;

    &lt;p&gt;Even if you could &lt;em&gt;see&lt;/em&gt; everything in an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;, you
wouldn’t be able to stop the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt; to
&lt;em&gt;see&lt;/em&gt; any high speed interactions like you can stop a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt; in a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Debugger&quot;&gt;debugger&lt;/a&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Simulation first.&lt;/p&gt;

    &lt;p&gt;The only time you will be able to &lt;em&gt;see&lt;/em&gt; everything is in simulation.  Start
your debugging process there.
&lt;a href=&quot;/blog//2017/06/21/looking-at-verilator.html&quot;&gt;This post&lt;/a&gt;
discusses how you can continue debugging by &lt;code class=&quot;highlighter-rouge&quot;&gt;printf()&lt;/code&gt;–but
only in simulation, should you wish to do so.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Get familiar with a logic analyzer on your first project&lt;/p&gt;

    &lt;p&gt;While you can’t &lt;em&gt;see&lt;/em&gt; everything in an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;, and
especially not when you are running at speed, you can get a trace from a
running &lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
showing how logic transitions over time.&lt;/p&gt;

    &lt;p&gt;Such a trace can come from an external logic analyzer.  Many of these are
available for purchase.  For example, I’ve used the &lt;a href=&quot;https://store.digilentinc.com/digital-discovery-portable-logic-analyzer-and-digital-pattern-generator/&quot;&gt;Digital
Discovery&lt;/a&gt;
to find bugs in &lt;a href=&quot;https://github.com/ZipCPU/icozip&quot;&gt;one of my projects&lt;/a&gt;.  I’m
hoping to blog about my experiences with it soon as well.  I also have the
&lt;a href=&quot;http://dangerousprototypes.com/docs/Open_Bench_Logic_Sniffer&quot;&gt;Open Bench Logic
Sniffer&lt;/a&gt;
on my desk waiting to be tried and tested.&lt;/p&gt;

    &lt;p&gt;We’ve also discussed using an internal scope many times on this blog.
Such scope’s are &lt;a href=&quot;/blog/2017/06/08/simple-scope.html&quot;&gt;not hard to
build&lt;/a&gt;, and can be
&lt;em&gt;very&lt;/em&gt; useful when trying to figure out what’s going on.  I personally use a
&lt;a href=&quot;https://github.com/ZipCPU/wbscope&quot;&gt;wishbone scope&lt;/a&gt;.  We’ve discussed how to
set that up
&lt;a href=&quot;/blog/2017/07/08/getting-started-with-wbscope.html&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Teach your
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
to do some of your debugging for you.&lt;/p&gt;

    &lt;p&gt;Learn to &lt;a href=&quot;/blog/2017/05/24/serial-port.html&quot;&gt;set an LED when error conditions take
place&lt;/a&gt;.&lt;/p&gt;

    &lt;p&gt;Learn to trigger your “trace” generation on error conditions, so you can
read back logic leading up to those “error conditions.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;just-for-students&quot;&gt;Just for students&lt;/h2&gt;

&lt;p&gt;I’ve seen a lot of &lt;a href=&quot;/blog/2017/06/10/lost-college-student.html&quot;&gt;students get
burned&lt;/a&gt;.  While
some might say that this is a normal part of the learning process, don’t let
it be your process.  Learn from those who have gone before you.  Specific
lessons I would share include:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Success is measured by the number of failures.  Plan for failure.&lt;/p&gt;

    &lt;p&gt;&lt;em&gt;Every&lt;/em&gt; student tends to come across some “impossible”
problem in his design that he cannot figure out.  He may get stuck at this
point for days or even weeks.  This is common.  &lt;em&gt;Plan&lt;/em&gt; on getting stuck,
put some time into your schedule in case this happens,
and then plan before hand on how you are going to get yourself unstuck.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Don’t start your project at the last minute.&lt;/p&gt;

    &lt;p&gt;Good engineering takes time to do, and to do right.  You cannot control
when things will go wrong, or how long it will take to fix things when it
does.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Plan on debugging from the beginning.  Build yourself the infrastructure
you need for that task first, then build your design.&lt;/p&gt;

    &lt;p&gt;o All of my designs include both one or more  &lt;a href=&quot;https://github.com/ZipCPU/wbscope&quot;&gt;wishbone
  scopes&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;o All of my designs include a &lt;a href=&quot;https://github.com/ZipCPU/openarty/blob/master/rtl/wbubus.v&quot;&gt;wishbone to
  UART&lt;/a&gt;
  &lt;a href=&quot;/blog/2017/06/05/wb-bridge-overview.html&quot;&gt;debugging bus&lt;/a&gt;
  giving me access to my &lt;a href=&quot;https://github.com/ZipCPU/wbscope&quot;&gt;wishbone scopes&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Consider &lt;a href=&quot;/blog/2017/06/02/design-process.html&quot;&gt;this
discussion&lt;/a&gt;
on the &lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
design process, and learn what both instructors and experts often overlook
when they teach you how to do the task.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;rules-from-twitter&quot;&gt;Rules from Twitter&lt;/h2&gt;

&lt;p&gt;Many thanks to those who know &lt;a href=&quot;https://twitter.com/zipcpu&quot;&gt;me on twitter&lt;/a&gt;!
They also offered the following pieces of advice for new students: (some edits
applied)&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;My boss would tell me “Think in hardware” #parallel execution of code,
not serial. &lt;a href=&quot;https://twitter.com/sachin_bhutada&quot;&gt;sachin_bhutada&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Thank you, &lt;a href=&quot;https://twitter.com/sachin_bhutada&quot;&gt;sachin_bhutada&lt;/a&gt;,
this may be one of the most common struggles software students have.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Use the right device for your job.  Need to do 100kOps/s of multiplications?
Pah, you cheapest MCU can do that.  Remember: designing in HDL is hard,
programming in C is easy.  &lt;a href=&quot;https://twitter.com/dEnergy_dTime&quot;&gt;Marcus Muller&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;I think &lt;a href=&quot;https://twitter.com/dEnergy_dTime&quot;&gt;Marcus Muller&lt;/a&gt; meant to say that
programming in C++ is easy …&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;One week of aimless development can easily save you two hours of writing
specifications.  &lt;a href=&quot;https://twitter.com/dEnergy_dTime&quot;&gt;Marcus Muller&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;Use build-time parameters instead of
&lt;a href=&quot;https://en.wikipedia.org/wiki/Magic_number_(programming)&quot;&gt;magic constants&lt;/a&gt;;
you’ll thank me later.  &lt;a href=&quot;https://twitter.com/dEnergy_dTime&quot;&gt;Marcus Muller&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;When working in a team, beat others with a stuck until they learn to
properly use &lt;a href=&quot;https://en.wikipedia.org/wiki/Git&quot;&gt;git&lt;/a&gt;
&lt;a href=&quot;https://twitter.com/dEnergy_dTime&quot;&gt;Marcus Muller&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;Don’t believe hypes.  &lt;a href=&quot;https://twitter.com/dEnergy_dTime&quot;&gt;Marcus Muller&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;If it’s complicated, make a drawing.  &lt;a href=&quot;https://twitter.com/dEnergy_dTime&quot;&gt;Marcus Muller&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;Get a good book.  The online tutorials you find are … spotty, at best.  Learn the basics first.  &lt;a href=&quot;https://twitter.com/dEnergy_dTime&quot;&gt;Marcus Muller&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;I often recommend &lt;a href=&quot;http://www.asic-world.com/verilog/veritut.html&quot;&gt;asic-world’s online
tutorials&lt;/a&gt;, but
&lt;a href=&quot;https://twitter.com/dEnergy_dTime&quot;&gt;Marcus Muller&lt;/a&gt;’s advice still rings
true.  “Learn the basics first.”  &lt;a href=&quot;&quot;&gt;This blog&lt;/a&gt;
cannot cover all of the basics.&lt;/p&gt;

&lt;p&gt;Indeed, his comments hit the nail on the head so well, I’ve struggled here to
figure out anything to add to them.&lt;/p&gt;

&lt;p&gt;As for &lt;a href=&quot;&quot;&gt;this blog&lt;/a&gt; and what you will find here, I’m just
going to go back and underline &lt;a href=&quot;https://twitter.com/dEnergy_dTime&quot;&gt;Marcus
Muller&lt;/a&gt;’s advice to “Learn the basics
first.”
Thank you, &lt;a href=&quot;https://twitter.com/dEnergy_dTime&quot;&gt;Marcus Muller&lt;/a&gt;!&lt;/p&gt;

&lt;p&gt;Indeed, thank you again to all who responded!&lt;/p&gt;

&lt;h2 id=&quot;rules-are-made-to-be-broken&quot;&gt;Rules are made to be broken&lt;/h2&gt;

&lt;p&gt;Please notice how I titled this post as “Rules for new FPGA designers”.  These rules are
for &lt;em&gt;beginners&lt;/em&gt;.  Those who have worked with
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;s for a
longer period of time will understand that there are times and places for all
of these rules to be broken.&lt;/p&gt;

&lt;p&gt;To those who are contemplating breaking these rules, who may be at the point of
moving from a beginning &lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt; designer to a more intermediate one, my advice is
this:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Carefully consider your steps.  Do you really need to break the rule?  My
twitter friends and I
shared these rules for a reason.  Don’t break them unless you absolutely
need to.  Further, if you do absolutely need to break the rule, do your
research first so that you know how to do so safely and reliably.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;this-isnt-the-last-word&quot;&gt;This isn’t the last word&lt;/h2&gt;

&lt;p&gt;I expect I’ll come back to this post many times to update my rules for
beginners.  So, if you’ve read this once, don’t be surprised if it changes
again later as I add to these rules.&lt;/p&gt;

&lt;p&gt;Have I missed anything?  Feel free to let me know at the address below,
and thank you for everyone who has contributed so far.&lt;/p&gt;

&lt;p&gt;Finally good luck, have some fun, and stay out of
&lt;a href=&quot;/blog/2017/05/19/fpga-hell.html&quot;&gt;FPGA Hell&lt;/a&gt;!&lt;/p&gt;
&lt;hr /&gt;&lt;p&gt;&lt;em&gt;I have fed you with milk, and not with meat: for hitherto ye were not able to bear it, neither yet now are ye able (1Cor 3:2)&lt;/em&gt;</description>
        <pubDate>Mon, 21 Aug 2017 00:00:00 -0400</pubDate>
        <link>http://zipcpu.com/blog/2017/08/21/rules-for-newbies.html</link>
        <guid isPermaLink="true">http://zipcpu.com/blog/2017/08/21/rules-for-newbies.html</guid>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>Two of the Simplest Digital filters</title>
        <description>&lt;p&gt;I’d like to spend some time discussing
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;Digital Filtering&lt;/a&gt; on
&lt;a href=&quot;&quot;&gt;this blog&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;This is going to be a bit of a difficult topic, however, in that
I don’t intend to discuss &lt;a href=&quot;https://en.wikipedia.org/wiki/Parks-McClellan_filter_design_algorithm&quot;&gt;how to
design&lt;/a&gt;
a &lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;Digital Filter&lt;/a&gt;,
nor do I intend to discuss
&lt;a href=&quot;https://en.wikipedia.org/wiki/Discrete_Fourier_transform&quot;&gt;how to evaluate&lt;/a&gt;
the design of a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;digital filter&lt;/a&gt;,
nor do I intend to discuss
&lt;a href=&quot;https://en.wikipedia.org/wiki/Aliasing&quot;&gt;aliasing&lt;/a&gt;.  These are all vital
topics necessary for understanding what a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;digital filter&lt;/a&gt; is,
as well as understanding whether or not
a &lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;digital filter&lt;/a&gt; even works.
They are also vital topics to understand when comparing the performance of one
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;digital filter&lt;/a&gt;
with that of another.  However, these are really topics for a different course.&lt;/p&gt;

&lt;p&gt;For now, it’s worth understanding that a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;digital filter&lt;/a&gt;
implements a &lt;a href=&quot;https://en.wikipedia.org/wiki/Convolution&quot;&gt;discrete convolution&lt;/a&gt;,
and that such
&lt;a href=&quot;https://en.wikipedia.org/wiki/Convolution&quot;&gt;discrete convolution&lt;/a&gt;s
are provably the &lt;em&gt;only&lt;/em&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_signal_processing&quot;&gt;signal processing&lt;/a&gt;
operations that are both &lt;a href=&quot;https://en.wikipedia.org/wiki/Linear_system&quot;&gt;linear&lt;/a&gt;
and &lt;a href=&quot;https://en.wikipedia.org/wiki/Shfit-invariant_system&quot;&gt;shift invariant&lt;/a&gt;.
This makes them a very important part of any discussion of &lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_signal_processing&quot;&gt;digital signal
processing (DSP)&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;It’s also worth noting that any student of &lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_signal_processing&quot;&gt;digital signal
processing&lt;/a&gt;
should be able to recognize when a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;digital filter&lt;/a&gt;
is
&lt;a href=&quot;https://en.wikipedia.org/wiki/Causal_filter&quot;&gt;causal&lt;/a&gt;,
&lt;a href=&quot;https://en.wikipedia.org/wiki/BIBO_stability&quot;&gt;stable&lt;/a&gt;,
when it has &lt;a href=&quot;https://en.wikipedia.org/wiki/Linear_phase&quot;&gt;linear phase&lt;/a&gt;,
and when it has a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Finite_impulse_response&quot;&gt;finite (FIR)&lt;/a&gt;
or an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Infinite_impulse_response&quot;&gt;infinite (IIR)&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Impulse_response&quot;&gt;impulse response&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Our focus in this blog is going to be on how to debug a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;digital filter&lt;/a&gt;
so that you can know it works.  To get there, though, we are going to have
to describe some
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filters&lt;/a&gt;
so that we have something to debug.  Filters we discuss, together with any
test or debugging logic, will be placed on
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters&quot;&gt;GitHub here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;For today, let’s just look at two &lt;em&gt;very&lt;/em&gt; simple
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;s:
the simplest non-trivial
&lt;a href=&quot;https://en.wikipedia.org/wiki/Finite_impulse_response&quot;&gt;FIR&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;
that I know of, and a simple recursive averager (a type of
&lt;a href=&quot;https://en.wikipedia.org/wiki/Infinite_impulse_response&quot;&gt;IIR&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;)
that I have found to be very useful.&lt;/p&gt;

&lt;h1 id=&quot;simple-fir-filter&quot;&gt;Simple FIR Filter&lt;/h1&gt;

&lt;p&gt;The first
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;
we are going to look at may well be the &lt;em&gt;simplest&lt;/em&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Finite_impulse_response&quot;&gt;FIR&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;
you will ever come across.  It simply averages adjacent samples together.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/eqn-simplfir.png&quot; alt=&quot;Equation for a very simple FIR filter&quot; width=&quot;242&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;The &lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/smplfir.v&quot;&gt;code to implement this
equation&lt;/a&gt;
is likewise just as simple:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;initial	delayed = 0;
always @(posedge i_clk)
	if (i_ce)
		delayed &amp;lt;= i_val;
always @(posedge i_clk)
	if (i_ce)
		o_val &amp;lt;= i_val + delayed;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/smplfir.v&quot;&gt;This filter&lt;/a&gt;
is useful for many reasons.  For example, unlike many other
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;s
that you may study,
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/smplfir.v&quot;&gt;this filter&lt;/a&gt;
requires no multiply (DSP) resources within the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;.
The output only
&lt;a href=&quot;/dsp/2017/07/21/bit-growth.html&quot;&gt;grows by one bit&lt;/a&gt;.
Further,
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/smplfir.v&quot;&gt;this filter&lt;/a&gt;
can also handle incoming samples at up to the full system clock rate for the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;.
Those are the good qualities of
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/smplfir.v&quot;&gt;this filter&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;It is also, however, a very difficult filter to use successfully simply because
its &lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency_response&quot;&gt;frequency response&lt;/a&gt;
rarely describes the performance that you want.  It doesn’t have a
sharp cut off.  Its taps and length are fixed.  Indeed, you might find
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/smplfir.v&quot;&gt;this filter&lt;/a&gt;
that we’ve just implemented to be quite useless.&lt;/p&gt;

&lt;p&gt;Before you give up on &lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/smplfir.v&quot;&gt;this simplest
filter&lt;/a&gt;,
consider what would happen if
you cascaded several of
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/smplfir.v&quot;&gt;these filters&lt;/a&gt;
together–one right after the other.  For example, suppose you ran your signal
through ten of
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/smplfir.v&quot;&gt;these filters&lt;/a&gt;
in succession.  You would get a filter with a much deeper stopband.&lt;/p&gt;

&lt;p&gt;This is the comparison shown in Fig 1 below.  In it, you can see the
predicted &lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency_response&quot;&gt;frequency
response&lt;/a&gt;
of our &lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/smplfir.v&quot;&gt;original simple
filter&lt;/a&gt;
above, as well as a similar predicted
&lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency_response&quot;&gt;frequency response&lt;/a&gt;
for the filter that would result from applying that
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/smplfir.v&quot;&gt;same filter&lt;/a&gt;
ten times in a row.  Both filters have been normalized so as to have a unity
response to anything at zero frequency.&lt;/p&gt;

&lt;table style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 1: &lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/smplfir.png&quot; alt=&quot;Performance of a very simple FIR filter&quot; width=&quot;772&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;We’ll need come back to this later, when it’s time to determine whether either
filter actually achieves this predicted
&lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency_response&quot;&gt;frequency response&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;While this new cascaded filter is starting to have a nicely acceptable
stop band, nothing remains that might be considered a flat “pass” band
anymore.  Still, the cascaded filter is
easy enough to build and costs so few resources that whenever a cascaded
filter of this type can be used, even if as only a component of other
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filters&lt;/a&gt;, it
is often very valuable to do so.  Therefore, &lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/smplfir.v&quot;&gt;this simple
filter&lt;/a&gt;
finds its best and greatest application in being a component of other,
more powerful, &lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filters&lt;/a&gt;.&lt;/p&gt;

&lt;h1 id=&quot;simple-iir-filter&quot;&gt;Simple IIR Filter&lt;/h1&gt;

&lt;p&gt;The next super-simple filter that I’m going to present is an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Infinite_impulse_response&quot;&gt;IIR&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;.
Specifically, let’s look at a recursive averager.  A recursive
averager keeps an average value at all times, and only adjusts that value
with any input.  Specifically, I like to think of it as a weighted sum of
some percentage of the new input sample plus the remaining percentage of
the last average.&lt;/p&gt;

&lt;p&gt;Perhaps an equation will help.  In symbology, a recursive averager is
just:&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/eqn-iiravg-defn.png&quot; alt=&quot;EQN for a simple recursive averager&quot; width=&quot;328&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Where we keep to the standard conventions of &lt;code class=&quot;highlighter-rouge&quot;&gt;n&lt;/code&gt; being the sample number,
&lt;code class=&quot;highlighter-rouge&quot;&gt;x[n]&lt;/code&gt; being our input and &lt;code class=&quot;highlighter-rouge&quot;&gt;y[n]&lt;/code&gt; being our output.  The new variable here,
alpha, is our means of adjusting how deep or sharp this filter is.  This is
a value between zero and one.  If alpha is one, no averaging takes place.
The closer alpha is to zero, however, the more the filter will average the
input and the longer it will take to converge to an average.  Likewise, the
closer alpha is to zero the less noise the filter will admit to the
average estimate.&lt;/p&gt;

&lt;p&gt;With a little manipulation, we can rearrange this filter into something
that’s really easy to compute.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/eqn-iiravg-implementation.png&quot; alt=&quot;EQN used to implement a simple recursive averager&quot; width=&quot;381&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Then, if we insist that alpha be a negative power of two, we can
replace the multiply above with a right shift:&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/eqn-iir-alpha-defn.png&quot; alt=&quot;Alpha = 2^{-LGALPHA}&quot; width=&quot;168&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;You’ll want to use an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Arithmetic_shift&quot;&gt;arithmetic shift&lt;/a&gt; here,
to mak certain the sign propagates in the case where the difference is
negative.&lt;/p&gt;

&lt;p&gt;This leads us to our first design choice: How many clocks can we use to
calculate an answer?  In particular, this recursive averager is going to
require a subtraction followed by an addition.  Both of these operations
&lt;em&gt;need to complete&lt;/em&gt; before the next sample.  You can either try to place
this all within a single system tick, or split it between two separate ticks.&lt;/p&gt;

&lt;p&gt;If you have new data samples present on every clock tick, you will need
to try the combinational approach I’m going to present below, stuffing all of
the logic into a single clock tick.  This has the unfortunate consequence of
limiting your system clock speed.&lt;/p&gt;

&lt;p&gt;On the other hand, if your data samples will always have at least one
unused clock between them, then you could take one clock tick to calculate
the difference, &lt;code class=&quot;highlighter-rouge&quot;&gt;x[n]-y[n-1]&lt;/code&gt;, and another to update the running average,
&lt;code class=&quot;highlighter-rouge&quot;&gt;y[n]&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;If we suppose that we must do this all within a single clock tick, the
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/iiravg.v&quot;&gt;following code&lt;/a&gt;
will implement this recursive averager.  In the code below, &lt;code class=&quot;highlighter-rouge&quot;&gt;AW&lt;/code&gt;
is the number of bits in the averager, and &lt;code class=&quot;highlighter-rouge&quot;&gt;IW&lt;/code&gt; is the bit-width of the input.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;wire	signed	[(AW-1):0]	difference, adjustment;

// The difference is given by x[n] - y[n-1]
assign	difference = { i_data, {(AW-IW){1&#39;b0}} } - r_average;

// The adjustment is the difference times alpha
assign	adjustment = { {(LGALPHA){(difference[(AW-1)])}},
			difference[(AW-1):(AW-LGALPHA)] };
always @(posedge i_clk)
	r_average &amp;lt;= r_average + adjustment;

assign	o_data = r_average;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;You may notice that I could have used the Verilog shift operator and did
not.  Had I done so, then the &lt;code class=&quot;highlighter-rouge&quot;&gt;adjustment&lt;/code&gt; value could have been set with:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;assign	adjustment = difference &amp;gt;&amp;gt;&amp;gt; LGALPHA;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;So, how did we do?  We’ll need to come back and test this later to know
for certain.  That in itself is going to need to take some thought.  Just
what is the best way to test a filter?  For now, you can see in Fig 2.
how good we &lt;em&gt;should&lt;/em&gt; be doing—if we had truly infinite precision
arithmetic.&lt;/p&gt;

&lt;table style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 2: &lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/iiravg.png&quot; alt=&quot;Performance of a recursive averager&quot; width=&quot;772&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Later, it would be nice to come back and generate this
&lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency_response&quot;&gt;frequency response&lt;/a&gt; curve
as a result of measuring how well the filter actually does.  Parameters that
will impact this measurement include not only how many bits are allocated
to the input and output (averager) values, but also how big the input value
truly is.&lt;/p&gt;

&lt;p&gt;Unlike the
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/smplfir.v&quot;&gt;simple&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Finite_impulse_response&quot;&gt;FIR&lt;/a&gt;
filter above, applications for this
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/iiravg.v&quot;&gt;simple&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Infinite_impulse_response&quot;&gt;IIR&lt;/a&gt;
recursive averaging filter abound just about everywhere.&lt;/p&gt;

&lt;p&gt;Want to measure a histogram?  Set this up to be an unsigned recursive
averager and then place a &lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt; into this filter every time your
data is within the bin of interest.&lt;/p&gt;

&lt;p&gt;Want to drive an automatic gain control circuit?  Compare the absolute
value of your signal against a fixed threshold.  Set the averager for unsigned
values, and then if your signal’s amplitude is too high you can average a
&lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt; into this averager.  If the result is too low, average a &lt;code class=&quot;highlighter-rouge&quot;&gt;0&lt;/code&gt; into this
averager. You can then use the result to know if you should turn the gain
in your circuitry up or down.&lt;/p&gt;

&lt;p&gt;You could also use this to remove any fixed gain in your circuitry.&lt;/p&gt;

&lt;p&gt;Indeed, you could even use this circuit coupled with a
&lt;a href=&quot;http://andraka.com/files/crdcsrvy.pdf&quot;&gt;CORDIC&lt;/a&gt;
to measure a single bin (or more) of the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency_response&quot;&gt;frequency response&lt;/a&gt;
of your system.&lt;/p&gt;

&lt;p&gt;This filter is exceptionally versatile as a cheap
&lt;a href=&quot;https://en.wikipedia.org/wiki/Low-pass_filter&quot;&gt;low-pass filter&lt;/a&gt;.  As an
example of that versatility, it also finds applications in &lt;a href=&quot;https://en.wikipedia.org/wiki/Phase-locked_loop&quot;&gt;phase lock
loops&lt;/a&gt;!&lt;/p&gt;

&lt;p&gt;These are all other topics, though, that we’ll need to come back to another
time.&lt;/p&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;Yes, those are the two simplest (non-trivial) filters I know.&lt;/p&gt;

&lt;p&gt;Sadly, though, we’re not yet in a position to test these filters to know that
they work.  As a result, we’ll need to come back to the topic of
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;digital filtering&lt;/a&gt;
once we discuss how to properly test a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;digital filter&lt;/a&gt;.
Some of those techniques will depend upon being able to use a
&lt;a href=&quot;http://andraka.com/files/crdcsrvy.pdf&quot;&gt;CORDIC&lt;/a&gt;–something
we have yet to present on this blog.  We’re also going to need to have
a thorough understanding of &lt;a href=&quot;https://en.wikipedia.org/wiki/Quantization_(signal_processing)&quot;&gt;quantization
noise&lt;/a&gt;,
another thing we’ll have to come back and discuss.&lt;/p&gt;

&lt;p&gt;This is by no means our final
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;digital filtering&lt;/a&gt;,
discussion either!  Many, many other
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
filtering topics remain.  These include:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;How to estimate a filter’s logic resource usage&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;How to build the cadillac of all filters: a dynamic filter whose filter
taps can be set at run time.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;And then how to build more realistic filters that will actually fit within
your &lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;’s
logic resources.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Do you get the feeling that
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;digital filtering&lt;/a&gt;
is a complex topic?  Since it is the most basic
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_signal_processing&quot;&gt;DSP&lt;/a&gt; operation,
we’ll need to spend some time going through it.  Perhaps some well written
examples will help to make this complex topic make more sense.&lt;/p&gt;

&lt;hr /&gt;&lt;p&gt;&lt;em&gt;To give subtilty to the simple, to the young man knowledge and discretion. (Prov 1:4)&lt;/em&gt;</description>
        <pubDate>Sat, 19 Aug 2017 00:00:00 -0400</pubDate>
        <link>http://zipcpu.com/dsp/2017/08/19/simple-filter.html</link>
        <guid isPermaLink="true">http://zipcpu.com/dsp/2017/08/19/simple-filter.html</guid>
        
        
        <category>dsp</category>
        
      </item>
    
      <item>
        <title>Strategies for pipelining logic</title>
        <description>&lt;p&gt;One of the things that new
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
students struggle with is the fact that
&lt;em&gt;everything&lt;/em&gt; in digital logic takes place in parallel.&lt;/p&gt;

&lt;p&gt;Many of these students come from a computer science background. 
They understand how an algorithm works, and how one thing must take place
after another in a specific sequence.  They tend to struggle, though, with
the idea that every step in an algorithm occupies a piece of digital logic
that will act on &lt;em&gt;every&lt;/em&gt; clock tick–whether used or not.&lt;/p&gt;

&lt;p&gt;One solution to sequencing operations is to create a giant state machine.
The reality, though, is that an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
tends to create all the logic for
every state at once, and then only select the correct answer at the end of
each clock tick.  In this fashion, a state machine can be very much like
the &lt;a href=&quot;/zipcpu/2017/08/11/simple-alu.html&quot;&gt;simple ALU&lt;/a&gt;
we’ve discussed.&lt;/p&gt;

&lt;p&gt;On the other hand, if the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
is going to implement all of the logic for the
operation anyway, why not arrange each of those operations into a sequence,
where each stage does something useful?  This approach rearranges the
algorithm into a pipeline.
&lt;a href=&quot;https://en.wikipedia.org/wiki/Pipelining_(DSP_implementation)&quot;&gt;Pipelining&lt;/a&gt;
tends to be faster than the state machine approach for
accomplishing the same algorithm, and it can even be more resource efficient,
although it isn’t necessarily so.&lt;/p&gt;

&lt;p&gt;The difficult part of a digital logic pipeline is that the pipeline runs and
produces outputs even when the inputs to the pipeline are not (yet) valid.&lt;/p&gt;

&lt;p&gt;So, let’s discuss several different strategies for handling the signaling
associated with pipeline logic.  In general, there’s no one size fits all
strategy.  The strategy you pick will depend upon the needs of your algorithm,
and its data source (input) and destination (output).&lt;/p&gt;

&lt;p&gt;We’ll work our way through several different strategies from the simplest
to most complex.&lt;/p&gt;

&lt;h2 id=&quot;the-global-valid-signal-for-sampled-data&quot;&gt;The global valid signal for sampled data&lt;/h2&gt;

&lt;p&gt;The first strategy for handling pipelining that we’ll discuss is to use a
global valid signal.
At each stage, the data coming into the pipeline is valid when the 
global valid signal is true.  Likewise, each stage may take no more clocks
to finish then there are between valid signals.  I like to use the &lt;code class=&quot;highlighter-rouge&quot;&gt;CE&lt;/code&gt; or
“clock enable” signal to represent this valid logic.  Hence,
Fig 1 shows a block diagram of this sort communication.&lt;/p&gt;

&lt;table style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 1: Pipelining with a global valid signal&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/pipeline-blocks-global-ce.svg&quot; alt=&quot;Pipelining with a global valid signal&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;The basic rules are this:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;There is a global &lt;code class=&quot;highlighter-rouge&quot;&gt;CE&lt;/code&gt; line, synchronous with the clock.  This line is
true anytime new data is ready.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Logic is allowed to transition &lt;em&gt;only&lt;/em&gt; when this &lt;code class=&quot;highlighter-rouge&quot;&gt;CE&lt;/code&gt; line is true&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;This leads to a trace diagram similar to Fig 2 below.&lt;/p&gt;

&lt;table style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 1: Pipelining with a global valid signal&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/pipeline-global-ce.svg&quot; alt=&quot;Pipelining with a global valid signal&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;The neat thing about this approach is that there’s no real pipelining logic
required per se.  Each stage just waits for the global valid signal to be true,
and then applies its logic.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	if (i_ce)
	begin
		output &amp;lt;= (some function of)(i_input);
	end // else *NOTHING*.  Nothing is allowed to change without CE=1&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;You may find very quickly, though, that this approach doesn’t handle all
pipelining needs.  However, while it doesn’t handle all pipelining needs,
it does handle the needs of a crucial problem set:
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_signal_processing&quot;&gt;&lt;em&gt;signal processing&lt;/em&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;In a typical
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_signal_processing&quot;&gt;signal processing&lt;/a&gt;
application, data either comes into an 
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
from an analog to digital (A/D) converter, or it goes out of the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
to a digital to analog (D/A) converter, or perhaps it does both.  The sample
rate defines when the &lt;code class=&quot;highlighter-rouge&quot;&gt;CE&lt;/code&gt; signal needs to be high, and any transient
states are flushed through the system.
The digital logic engineer’s job is to manipulate the samples along the way.&lt;/p&gt;

&lt;p&gt;Because the data moves through the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
at a fixed rate, and because it never suddenly changes speeds, the global
valid signal works quite well for it.&lt;/p&gt;

&lt;p&gt;Applications include
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;digital filtering&lt;/a&gt;,
digital &lt;a href=&quot;https://en.wikipedia.org/wiki/Phase-locked_loop&quot;&gt;phase lock loops&lt;/a&gt;,
&lt;a href=&quot;/dsp/2017/07/11/simplest-sinewave-generator.html&quot;&gt;numerically controlled oscillators&lt;/a&gt;,
and more. 
Indeed, anything that works at a &lt;em&gt;fixed data rate&lt;/em&gt; is usually
a good candidate for this method of pipelining.&lt;/p&gt;

&lt;p&gt;Why, even our resamplers have worked off of the concept of a global valid
signal, they’ve just had to deal with two different valid signals: one that
holds for one clock per input sample, and another that holds for one clock
for every output sample.
&lt;a href=&quot;/dsp/2017/06/06/simple-interpolator.html&quot;&gt;[1]&lt;/a&gt;
&lt;a href=&quot;/dsp/2017/07/29/series-linear-interpolation.html&quot;&gt;[2]&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;the-traveling-ce-to-reduce-latency&quot;&gt;The traveling CE to reduce latency&lt;/h2&gt;

&lt;p&gt;The global valid signal we discussed above, though, has two basic problems.
The first problem is that there’s no way to know if an output sample is
“valid” or not”.
The second is that the whole operation depends upon a uniform clock creating
the &lt;code class=&quot;highlighter-rouge&quot;&gt;CE&lt;/code&gt; signal.  What
happens if the data is produced in a bursty fashion, and you want to know
not only &lt;em&gt;when&lt;/em&gt; the output is valid but also &lt;em&gt;if&lt;/em&gt; the output is valid?  In
this case, another approach is required.&lt;/p&gt;

&lt;p&gt;I’m going to call this second approach the “traveling CE” approach.  Basically,
each stage in the pipeline propagates the CE forward, as in Fig 3.&lt;/p&gt;

&lt;table style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 3: Pipelining with a traveling CE&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/pipeline-blocks-traveling-ce.svg&quot; alt=&quot;Pipeline block diagram of a traveling CE&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;The basic rules to this approach are:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Whenever the &lt;code class=&quot;highlighter-rouge&quot;&gt;CE&lt;/code&gt; signal is true, the data associated with it must also be
valid.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;At the end of every stage of processing, a &lt;code class=&quot;highlighter-rouge&quot;&gt;CE&lt;/code&gt; signal must be produced,
together with the output data for that stage.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The &lt;code class=&quot;highlighter-rouge&quot;&gt;CE&lt;/code&gt; signal &lt;em&gt;must&lt;/em&gt; be initialized to zero.  Further, if any reset is
to be used, the &lt;code class=&quot;highlighter-rouge&quot;&gt;CE&lt;/code&gt; &lt;em&gt;must&lt;/em&gt; be set to zero on any reset.  (The data is a
don’t care on reset, but the &lt;code class=&quot;highlighter-rouge&quot;&gt;CE&lt;/code&gt; line &lt;em&gt;must&lt;/em&gt; be set to zero.)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Nothing is allowed to change &lt;em&gt;except&lt;/em&gt; on a &lt;code class=&quot;highlighter-rouge&quot;&gt;CE&lt;/code&gt; signal.  Hence, the only
time the incoming data is referenced is when &lt;code class=&quot;highlighter-rouge&quot;&gt;i_ce&lt;/code&gt; (the input &lt;code class=&quot;highlighter-rouge&quot;&gt;CE&lt;/code&gt; line
to a pipeline stage) is high.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Finally, every piece of logic must be ready, at all times, for a new value
to enter into the pipeline.  This particular pipeline strategy cannot handle
stalls.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;A trace of this type of logic might look like Fig 4.&lt;/p&gt;

&lt;table style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 4: Pipelining with a traveling CE&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/pipeline-traveling-ce.svg&quot; alt=&quot;Pipelining with a traveling CE&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;In Verilog, the approach looks like:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;initial	o_ce = 1&#39;b0;
always @(posedge i_clk)
	if (i_reset)
		o_ce &amp;lt;= 1&#39;b0;
	else
		o_ce &amp;lt;= i_ce;
always @(posedge i_clk)
	if (i_ce)
		o_output &amp;lt;= ... // some function of i_input;
	// else *NOTHING*.  Nothing is allowed to change except on
	// a reset or an i_ce&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This approach works very well when the pipeline can be separated into stages
that take no more than a single input valid signal.  Likewise, it works well
when none
of the stages depends upon any feedback from future results.  In other words,
if nothing ever needs to wait, then this approach to pipelining works fairly
well.&lt;/p&gt;

&lt;p&gt;Applications of this pipelining approach include
&lt;a href=&quot;https://en.wikipedia.org/wiki/Multiplication_algorithm&quot;&gt;logic multiplies&lt;/a&gt;,
&lt;a href=&quot;https://en.wikipedia.org/wiki/Fourier_transform&quot;&gt;Fourier transform&lt;/a&gt;
processing (&lt;a href=&quot;https://github.com/ZipCPU/dblclockfft&quot;&gt;example&lt;/a&gt;),
video processing, gear-boxes, and more.  Indeed, we used this approach
within our &lt;a href=&quot;https://github.com/ZipCPU/dbgbus/blob/master/hexbus/rtl/hbbus.v&quot;&gt;hexbus debugging
bus&lt;/a&gt;
to hook the input processing chain together.  You may notice, however, that
this approach didn’t work on the output processing chain.  The problem
there was that the &lt;a href=&quot;https://en.wikipedia.org/wiki/Universal_asynchronous_receiver/transmitter&quot;&gt;UART&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/wbuart32/blob/master/rtl/txuartlite.v&quot;&gt;transmitter&lt;/a&gt;
took longer than a single clock to transmit a character, and so another
pipeline signaling approach was needed–one that allowed the end of the
pipeline to control the rate of the pipeline.&lt;/p&gt;

&lt;h2 id=&quot;the-simple-handshake&quot;&gt;The simple handshake&lt;/h2&gt;

&lt;p&gt;The biggest problem with the travelling CE approach to pipelining is
that there’s no way to handle the case where the listener isn’t ready.  To
use a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Universal_asynchronous_receiver/transmitter&quot;&gt;UART&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/wbuart32/blob/master/rtl/txuartlite.v&quot;&gt;transmitter&lt;/a&gt;
as an example, you can create a pipeline to fill the
&lt;a href=&quot;https://github.com/ZipCPU/wbuart32/blob/master/rtl/txuartlite.v&quot;&gt;transmitter&lt;/a&gt;,
but what do you do when the
&lt;a href=&quot;https://github.com/ZipCPU/wbuart32/blob/master/rtl/txuartlite.v&quot;&gt;transmitter&lt;/a&gt;
is busy?  This requires a simple
handshake approach, one that I will describe here in this section.&lt;/p&gt;

&lt;p&gt;The basic hand shake relies on a pair of signals–one from the current
device and another from the next one in the pipeline.  We’ll call these
signals &lt;code class=&quot;highlighter-rouge&quot;&gt;STB&lt;/code&gt; (or valid) and &lt;code class=&quot;highlighter-rouge&quot;&gt;BUSY&lt;/code&gt;, although the wires go by a variety of
other names depending upon the interface.  Fig 5 shows a simple pipeline,
having only two stages, with the handshaking signals working through it.&lt;/p&gt;

&lt;table style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 5: Block diagram of a simple handshake&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/pipeline-blocks-handshake.svg&quot; alt=&quot;A simple handshake pipeline signal&quot; width=&quot;380&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;The basic rules associated with the simple handshake are:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;A transaction takes place any time the &lt;code class=&quot;highlighter-rouge&quot;&gt;STB&lt;/code&gt; line is true and the
&lt;code class=&quot;highlighter-rouge&quot;&gt;BUSY&lt;/code&gt; line is false.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The receiving pipeline stage needs to be careful &lt;em&gt;not&lt;/em&gt; to ever lower the
&lt;code class=&quot;highlighter-rouge&quot;&gt;BUSY&lt;/code&gt; line, unless it is ready to receive data on the next clock.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The &lt;code class=&quot;highlighter-rouge&quot;&gt;STB&lt;/code&gt; line should be raised any time data is ready to send. 
The data source &lt;em&gt;must not&lt;/em&gt; wait for &lt;code class=&quot;highlighter-rouge&quot;&gt;BUSY&lt;/code&gt; to be false before raising
the &lt;code class=&quot;highlighter-rouge&quot;&gt;STB&lt;/code&gt; line.&lt;/p&gt;

    &lt;p&gt;The issue with not waiting for &lt;code class=&quot;highlighter-rouge&quot;&gt;BUSY&lt;/code&gt; to be true has to do with avoiding
deadlocks.  By setting &lt;code class=&quot;highlighter-rouge&quot;&gt;STB&lt;/code&gt; independent of &lt;code class=&quot;highlighter-rouge&quot;&gt;BUSY&lt;/code&gt;, the dependence between
the two is removed.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Likewise, the &lt;code class=&quot;highlighter-rouge&quot;&gt;BUSY&lt;/code&gt; line &lt;em&gt;should&lt;/em&gt; &lt;em&gt;idle&lt;/em&gt; in the not busy condition.&lt;/p&gt;

    &lt;p&gt;While many AXI demonstration implementations idle with
the &lt;code class=&quot;highlighter-rouge&quot;&gt;AXI_*READY&lt;/code&gt; line false (their equivalent of a &lt;code class=&quot;highlighter-rouge&quot;&gt;BUSY&lt;/code&gt; line being true),
this will only slow down your interaction by an unnecessary clock. 
Remember, one of the goals of pipelining logic is speed.  Making &lt;code class=&quot;highlighter-rouge&quot;&gt;BUSY&lt;/code&gt; true
when it doesn’t need to be will slow down the pipeline.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Once &lt;code class=&quot;highlighter-rouge&quot;&gt;STB&lt;/code&gt; is raised, the data being transferred cnanot be changed until
the clock after the transaction takes place.  That is, use &lt;code class=&quot;highlighter-rouge&quot;&gt;(STB)&amp;amp;&amp;amp;(!BUSY)&lt;/code&gt;
to determine if things need to change.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The data lines are in a “don’t care” condition any time &lt;code class=&quot;highlighter-rouge&quot;&gt;STB&lt;/code&gt; is false.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The &lt;code class=&quot;highlighter-rouge&quot;&gt;STB&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;BUSY&lt;/code&gt; lines must be initialized to zero.  If you have a need
for a reset or a clear pipeline operation, these signals need to be returned
to zero on either of these signals.&lt;/p&gt;

    &lt;p&gt;Since the data lines will be placed into a “don’t care” condition, they
don’t need to have any value on reset.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;If you look at this handshake from the standpoint of the logic involved,
a trace would look like Fig 6.&lt;/p&gt;

&lt;table style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 6: A simple handshake pipeline signal&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/pipeline-handshake.svg&quot; alt=&quot;A simple handshake pipeline signal&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Pay close attention to the “(Transaction)” line.  This line is the key
to understanding the trace.  It is formed from the combinational
result of &lt;code class=&quot;highlighter-rouge&quot;&gt;(STB)&amp;amp;&amp;amp;(!BUSY)&lt;/code&gt;.  This line is the analog of the &lt;code class=&quot;highlighter-rouge&quot;&gt;CE&lt;/code&gt; line in the
traveling &lt;code class=&quot;highlighter-rouge&quot;&gt;CE&lt;/code&gt; approach from before.  When the (Transaction) line is high, the
data is valid (since &lt;code class=&quot;highlighter-rouge&quot;&gt;STB&lt;/code&gt; was high), and the processing can step forward one
further step.&lt;/p&gt;

&lt;p&gt;I’ve used this approach many times when building controllers for slow
hardware.  In those cases, the receiver generally looks like:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;initial o_busy = 1&#39;b0;
always @(posedge i_clk)
	if (i_reset)
	begin
		o_busy &amp;lt;= 1&#39;b0;
		state &amp;lt;= IDLE_STATE;
	end if ((i_ce)&amp;amp;&amp;amp;(!o_busy)) begin
		// We just accepted an input sample into this controller
		// Turn o_busy on, and start processing this input.
		o_busy &amp;lt;= 1&#39;b1;
		state &amp;lt;= START_STATE;
		data &amp;lt;= i_data;
		// etc.
	end else case(state)
		// A state machine is used to handle an interaction
		// with the hardware now that a request has been made.
		// ....
		FINAL_STATE: begin
			o_busy &amp;lt;= 1&#39;b0;
			state  &amp;lt;= IDLE_STATE;
			// ... other logic
			end
		// default:
		endcase&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;As you might have guessed by now, my
&lt;a href=&quot;https://en.wikipedia.org/wiki/Universal_asynchronous_receiver/transmitter&quot;&gt;UART&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/wbuart32/blob/master/rtl/txuartlite.v&quot;&gt;transmitter&lt;/a&gt;
uses this approach.  You can also find several examples of interacting
with such a transmitter among the &lt;a href=&quot;https://github.com/ZipCPU/wbuart32/tree/master/bench/verilog&quot;&gt;bench
tests&lt;/a&gt; for the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Universal_asynchronous_receiver/transmitter&quot;&gt;UART&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/wbuart32/blob/master/rtl/txuartlite.v&quot;&gt;transmitter&lt;/a&gt;.
Perhaps closer to home, you may find this approach to pipelining used
by the transmit half of the &lt;a href=&quot;https://github.com/ZipCPU/dbgbus/blob/master/hexbus/rtl/hbbus.v&quot;&gt;hexbus
module&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The problem with the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Universal_asynchronous_receiver/transmitter&quot;&gt;UART&lt;/a&gt;
example is that it doesn’t really capture the logic required in any mid-point
pipeline stage, only the final stage.&lt;/p&gt;

&lt;p&gt;At the midpoint, there are two choices for how to handle things.  You can
either register the &lt;code class=&quot;highlighter-rouge&quot;&gt;BUSY&lt;/code&gt; signal and suffer a pipeline stall in between
any two transactions, or you can create a &lt;code class=&quot;highlighter-rouge&quot;&gt;BUSY&lt;/code&gt; signal using combinational
logic.  The combinational &lt;code class=&quot;highlighter-rouge&quot;&gt;BUSY&lt;/code&gt; (shown in the example code below) has the
problem that the time required for &lt;code class=&quot;highlighter-rouge&quot;&gt;BUSY&lt;/code&gt; determination accumulates as you
move backwards through the pipeline.  This can slow down your logic, so
when this combinational path approaches your clock period it becomes
undesirable.  On the other hand, if it’s a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Universal_asynchronous_receiver/transmitter&quot;&gt;UART&lt;/a&gt;
or any other slow peripheral at the end of the logic pipeline
(&lt;a href=&quot;https://opencores.org/project,qspiflash&quot;&gt;flash&lt;/a&gt;,
&lt;a href=&quot;https://github.com/ZipCPU/wbicapetwo&quot;&gt;ICAPE2&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/openarty/blob/master/rtl/wboled.v&quot;&gt;OLEDrgb&lt;/a&gt;, etc),
then you might not care about any clocks lost in the &lt;code class=&quot;highlighter-rouge&quot;&gt;BUSY&lt;/code&gt; signal calculation.&lt;/p&gt;

&lt;p&gt;All that is to say, here’s an example of how to build a pipeline component
with this handshake as both the input and the output to the component:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;initial	r_busy = 1&#39;b0;
initial	o_stb  = 1&#39;b0;
always @(posedge i_clk)
	if (i_reset)
	begin
		// busy and stb must be cleared on any reset
		// Data is a don&#39;t care
		r_busy &amp;lt;= 1&#39;b0;
		o_stb  &amp;lt;= 1&#39;b0;
	end if (!o_busy)
	begin
		if (i_stb)
		begin
			// An incoming transaction has just taken place
			r_busy &amp;lt;= 1&#39;b1;
			// begin your logic here ...
			//
		end
		// else we remain in an idle condition
	end else if ((o_stb)&amp;amp;&amp;amp;(!i_busy))
	begin
		// An output transaction just took place
		r_busy &amp;lt;= 1&#39;b0;
		o_stb  &amp;lt;= 1&#39;b0;
	end else if (!o_stb) begin
		// o_busy is true, so you can perform any necessary logic here
		if (your logic is complete)
			o_stb &amp;lt;= 1&#39;b1;
	end // else we have to wait for our output data to be accepted
	// by the next stage before we can move on.&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The final step is to set the output busy line, &lt;code class=&quot;highlighter-rouge&quot;&gt;o_busy&lt;/code&gt;.  We use &lt;code class=&quot;highlighter-rouge&quot;&gt;r_busy&lt;/code&gt;
to record any time our own component is busy.  The final busy is set up so
that no empty delay cycles will be necessary, even though it requires some
combinational logic (i.e. borrowed clock time) to do.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;assign	o_busy = (i_busy)&amp;amp;&amp;amp;(o_stb)||(r_busy);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This example is easily modified to to remove the combinational accumulation
by simply setting the &lt;code class=&quot;highlighter-rouge&quot;&gt;o_busy&lt;/code&gt; line via the &lt;code class=&quot;highlighter-rouge&quot;&gt;r_busy&lt;/code&gt; logic.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;assign	o_busy = r_busy;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This will create an idle cycle between pipeline stages, but it will also fix
the combinational time accumulation problem.&lt;/p&gt;

&lt;p&gt;Examples of this type of handshaking abound.  For example, the
&lt;a href=&quot;https://opencores.org/cdn/downloads/wbspec_b4.pdf&quot;&gt;Wishbone bus&lt;/a&gt;
has a form of interaction that uses this form of handshaking, although it
changes the signal names a touch.  While the &lt;code class=&quot;highlighter-rouge&quot;&gt;STB&lt;/code&gt; name remains the same, the
&lt;a href=&quot;https://opencores.org/cdn/downloads/wbspec_b4.pdf&quot;&gt;Wishbone bus&lt;/a&gt;
uses &lt;code class=&quot;highlighter-rouge&quot;&gt;STALL&lt;/code&gt; as the name for its &lt;code class=&quot;highlighter-rouge&quot;&gt;BUSY&lt;/code&gt; line.  Likewise, the
&lt;a href=&quot;http://www.gstitt.ece.ufl.edu/courses/fall15/eel4720_5721/labs/refs/AXI4_specification.pdf&quot;&gt;AXI bus specification&lt;/a&gt;
uses this form of handshaking.  Indeed, it uses this form across
&lt;em&gt;five separate&lt;/em&gt; hand-shaking channels.  AXI uses the terms
&lt;code class=&quot;highlighter-rouge&quot;&gt;*AXI_*VALID&lt;/code&gt; for &lt;code class=&quot;highlighter-rouge&quot;&gt;STB&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;*AXI_*READY&lt;/code&gt; instead of &lt;code class=&quot;highlighter-rouge&quot;&gt;!BUSY&lt;/code&gt;.
We’ve also already discussed the transmit half, i.e. return processing
chain, of the main &lt;a href=&quot;https://github.com/ZipCPU/dbgbus&quot;&gt;dbgbus&lt;/a&gt; module as
another example.&lt;/p&gt;

&lt;h2 id=&quot;the-buffered-handshake&quot;&gt;The buffered handshake&lt;/h2&gt;

&lt;p&gt;If you are trying to go for high speed, for example if you wished to run the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt; at 200MHz instead of its more
natural 100MHz speed, then the simple handshake method can suffer from severe
timing problems as the pipeline grows in length.  This problem is twofold.
First, any time a &lt;code class=&quot;highlighter-rouge&quot;&gt;BUSY&lt;/code&gt; signal needs to pass combinationally from the &lt;code class=&quot;highlighter-rouge&quot;&gt;N&lt;/code&gt;th
stage back to the first stage,
the time required increases at each stage.  This can slow down your logic.
The logic chain line can cross large sections of digital logic, incurring
timing delays from one end of the chip to another, while the logic elements
along the way that this signal needs to pass through just contribute to
the pain.  Second, while it is
possible to slow the &lt;code class=&quot;highlighter-rouge&quot;&gt;BUSY&lt;/code&gt; signals down, by inserting a stall between
pipeline stages, this can slow the pipeline down by a factor of two.&lt;/p&gt;

&lt;p&gt;Another approach is needed.&lt;/p&gt;

&lt;p&gt;The way to mitigate this problem to set the &lt;code class=&quot;highlighter-rouge&quot;&gt;BUSY&lt;/code&gt; value with a clocked
register.  This means that when a subsequent pipeline stage isn’t ready
(a pipeline stall), it will cost a clock until the &lt;code class=&quot;highlighter-rouge&quot;&gt;BUSY&lt;/code&gt; line can be true.
To avoid losing any data, the data that arrived before the &lt;code class=&quot;highlighter-rouge&quot;&gt;BUSY&lt;/code&gt; signal
could go high will need to be stored in a buffer.&lt;/p&gt;

&lt;p&gt;For this reason, I’m going to call this a “buffered handshake”.&lt;/p&gt;

&lt;p&gt;The “buffered handshake” is going to use the exact same signals as
we showed in Fig 5 above.  Further, although Fig 6 shows what the signaling
might look like, it doesn’t capture the concept of the &lt;code class=&quot;highlighter-rouge&quot;&gt;BUSY&lt;/code&gt; signal
propagating from the end to the beginning, with the data bunching up in the
middle like an accordion.&lt;/p&gt;

&lt;p&gt;Perhaps some pictures would help this explanation.  Consider a four stage
pipeline, such as the one shown in Fig. 7.&lt;/p&gt;

&lt;table style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 7: A four stage pipeline using a buffered handshake&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/pipeline-blocks-dbl-1.svg&quot; alt=&quot;Block diagram of a 4-stage pipeline using a buffered handshake.  Sequence #1&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;This figure shows four separate pipeline stages, from the data source or
generator, to the ultimate consumer of the data.  The pipeline in this
figure is currently full, with each stage having a payload value within it.
As a result, each of the &lt;code class=&quot;highlighter-rouge&quot;&gt;STB&lt;/code&gt; signals is valid going into the next block.&lt;/p&gt;

&lt;p&gt;Fig 8 shows what happens if the final stage in this pipeline stalls on the
next clock.&lt;/p&gt;

&lt;table style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 8: Final pipeline stage stalls&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/pipeline-blocks-dbl-2.svg&quot; alt=&quot;Block diagram of a 4-stage pipeline using a buffered handshake.  Sequence #2--stall starts&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Were this the simple handshake we discussed above, all of the &lt;code class=&quot;highlighter-rouge&quot;&gt;BUSY&lt;/code&gt; flags
would go true at once.&lt;/p&gt;

&lt;p&gt;In the case of the buffered handshake, only one &lt;code class=&quot;highlighter-rouge&quot;&gt;BUSY&lt;/code&gt; flag becomes true.&lt;/p&gt;

&lt;p&gt;This means that &lt;code class=&quot;highlighter-rouge&quot;&gt;Stage[2]&lt;/code&gt; hasn’t had an opportunity to set it’s &lt;code class=&quot;highlighter-rouge&quot;&gt;BUSY&lt;/code&gt; flag.
It has no choice but to ingest &lt;code class=&quot;highlighter-rouge&quot;&gt;payload #4&lt;/code&gt; or risk dropping it (this would
be bad).  Therefore, &lt;code class=&quot;highlighter-rouge&quot;&gt;Stage[2]&lt;/code&gt; has a buffer which it uses to store
&lt;code class=&quot;highlighter-rouge&quot;&gt;payload #4&lt;/code&gt; on the next clock, as shown in Fig 9.&lt;/p&gt;

&lt;table style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 9: The stall propagates&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/pipeline-blocks-dbl-3.svg&quot; alt=&quot;Block diagram of a 4-stage pipeline using a buffered handshake.  Sequence #3--stall propagates&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;This leaves &lt;code class=&quot;highlighter-rouge&quot;&gt;Stage[1]&lt;/code&gt; in the position &lt;code class=&quot;highlighter-rouge&quot;&gt;Stage[2]&lt;/code&gt; was in on the last clock.
It cannot push &lt;code class=&quot;highlighter-rouge&quot;&gt;payload #5&lt;/code&gt; forward, and yet it hasn’t had the opportunity to
set its &lt;code class=&quot;highlighter-rouge&quot;&gt;BUSY&lt;/code&gt; line.  It &lt;em&gt;must&lt;/em&gt; accept &lt;code class=&quot;highlighter-rouge&quot;&gt;payload #6&lt;/code&gt;.  It does so by placing it
into its buffer.&lt;/p&gt;

&lt;p&gt;If at this time the data sink now becomes available, it will
lower its busy line, yielding an image looking like Fig 10.&lt;/p&gt;

&lt;table style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 10: The pipeline starts to clear&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/pipeline-blocks-dbl-4.svg&quot; alt=&quot;Block diagram of a 4-stage pipeline using a buffered handshake.  Sequence #4--initial stall clears&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;As this pipeline clears, &lt;code class=&quot;highlighter-rouge&quot;&gt;Stage[2]&lt;/code&gt; transmits &lt;code class=&quot;highlighter-rouge&quot;&gt;payload #3&lt;/code&gt; and clears its
&lt;code class=&quot;highlighter-rouge&quot;&gt;BUSY&lt;/code&gt; flag.  It’s now ready to transmit &lt;code class=&quot;highlighter-rouge&quot;&gt;payload #4&lt;/code&gt; on the next clock,
as well as to received &lt;code class=&quot;highlighter-rouge&quot;&gt;payload #5&lt;/code&gt; on that same clock, as in Fig 11.&lt;/p&gt;

&lt;table style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 11: The pipeline continues to clear&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/pipeline-blocks-dbl-5.svg&quot; alt=&quot;Block diagram of a 4-stage pipeline using a buffered handshake.  Sequence #5--Continues to clear&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;At this point, &lt;code class=&quot;highlighter-rouge&quot;&gt;Stage[1]&lt;/code&gt; can now flush its buffer and the pipeline is clear
again as in Fig 12.&lt;/p&gt;

&lt;table style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 12: The pipeline finally clears&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/pipeline-blocks-dbl-6.svg&quot; alt=&quot;Block diagram of a 4-stage pipeline using a buffered handshake.  Sequence #6--Stall has cleared&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;You may notice that this pipeline uses the same &lt;code class=&quot;highlighter-rouge&quot;&gt;STB&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;BUSY&lt;/code&gt; signals
that we’ve used for the simple handshaking approach to pipelining.  The
difference with this approach is that the &lt;code class=&quot;highlighter-rouge&quot;&gt;BUSY&lt;/code&gt; signal is registered,
and must wait on a clock to propagate.&lt;/p&gt;

&lt;p&gt;The rules defining this behavior are very similar to those for the simple
handshake above:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;A data transfer takes place any time &lt;code class=&quot;highlighter-rouge&quot;&gt;(STB)&amp;amp;&amp;amp;(!BUSY)&lt;/code&gt; whether the given
pipeline stage is ready for it or not.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;If the output &lt;code class=&quot;highlighter-rouge&quot;&gt;(STB)&amp;amp;&amp;amp;(BUSY)&lt;/code&gt; are true, but the input &lt;code class=&quot;highlighter-rouge&quot;&gt;(STB)&amp;amp;&amp;amp;(!BUSY)&lt;/code&gt; is
true, the data must be stored into a buffer.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;If &lt;code class=&quot;highlighter-rouge&quot;&gt;BUSY&lt;/code&gt; is true on the input, but &lt;code class=&quot;highlighter-rouge&quot;&gt;BUSY&lt;/code&gt; isn’t true on the output, then
the buffer’s values can be released and sent forwards and we can set
&lt;code class=&quot;highlighter-rouge&quot;&gt;BUSY&lt;/code&gt; for the incoming data to be false.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;So, now that you know the concept, how shall we set up the logic necessary
to implement this?  We’ll look at how to design the logic for one stage
in this pipeline only, since the other stages will use similar logic.&lt;/p&gt;

&lt;p&gt;The following logic is rather confusing when it comes to naming, since both
input and output ports share names.  I’ll use the &lt;code class=&quot;highlighter-rouge&quot;&gt;i_&lt;/code&gt; prefix to reference
a wire coming into a stage, whether the &lt;code class=&quot;highlighter-rouge&quot;&gt;i_stb&lt;/code&gt; line coming from the previous
stage or the &lt;code class=&quot;highlighter-rouge&quot;&gt;i_busy&lt;/code&gt; line coming from the subsequent stage.  In a similar
manner, I’ll use the &lt;code class=&quot;highlighter-rouge&quot;&gt;o_&lt;/code&gt; prefix to reference logic leaving this stage,
whether the &lt;code class=&quot;highlighter-rouge&quot;&gt;o_stb&lt;/code&gt; sent to the subsequent pipeline stage to indicate that
this stage has something to pass on, or the &lt;code class=&quot;highlighter-rouge&quot;&gt;o_busy&lt;/code&gt; line to send to the
previous stage to indicate that this stage is now busy.  We’ll also use the
&lt;code class=&quot;highlighter-rouge&quot;&gt;r_&lt;/code&gt; prefix to reference values within our register, both &lt;code class=&quot;highlighter-rouge&quot;&gt;r_stb&lt;/code&gt; to indicate
that something valid is in it as well as &lt;code class=&quot;highlighter-rouge&quot;&gt;r_data&lt;/code&gt; to indicate the value of
what’s in it.&lt;/p&gt;

&lt;p&gt;The first requirement is that the pipeline be empty on any reset.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;initial	r_stb  = 1&#39;b0;
initial	o_stb  = 1&#39;b0;
initial	o_busy = 1&#39;b0;
always @(posedge i_clk)
begin
	if (i_reset)
	begin
		r_stb = 1&#39;b0;
		o_stb = 1&#39;b0;
		o_busy = 1&#39;b0;
		// Data is a don&#39;t care
	end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Next, let’s deal with the case where the next or subsequent stage isn’t &lt;code class=&quot;highlighter-rouge&quot;&gt;BUSY&lt;/code&gt;.
This should be the normal pipeline flow case.
Under normal flow, we’ll want to copy the input strobe &lt;code class=&quot;highlighter-rouge&quot;&gt;i_stb&lt;/code&gt; to the output
strobe, &lt;code class=&quot;highlighter-rouge&quot;&gt;o_stb&lt;/code&gt;.  Further, some data may need to be applied to &lt;code class=&quot;highlighter-rouge&quot;&gt;i_data&lt;/code&gt; to
create the output &lt;code class=&quot;highlighter-rouge&quot;&gt;o_data&lt;/code&gt;.  We’ll use the notation &lt;code class=&quot;highlighter-rouge&quot;&gt;logic(i_data)&lt;/code&gt; to
indicate this.  The &lt;code class=&quot;highlighter-rouge&quot;&gt;logic()&lt;/code&gt; function is not intended to be valid verilog,
but rather to convey the concept of what’s taking place.&lt;/p&gt;

&lt;p&gt;If, on the other hand, some data was in the buffer, then &lt;code class=&quot;highlighter-rouge&quot;&gt;o_busy&lt;/code&gt; must
also have been true on this clock.  &lt;code class=&quot;highlighter-rouge&quot;&gt;o_stb&lt;/code&gt; must also be true and &lt;code class=&quot;highlighter-rouge&quot;&gt;o_data&lt;/code&gt;
valid.  Since &lt;code class=&quot;highlighter-rouge&quot;&gt;(o_stb)&amp;amp;&amp;amp;(!i_busy)&lt;/code&gt;, a transaction has taken place and &lt;code class=&quot;highlighter-rouge&quot;&gt;r_stb&lt;/code&gt;
can be copied to &lt;code class=&quot;highlighter-rouge&quot;&gt;o_stb&lt;/code&gt;, and &lt;code class=&quot;highlighter-rouge&quot;&gt;r_data&lt;/code&gt; to &lt;code class=&quot;highlighter-rouge&quot;&gt;o_data&lt;/code&gt;–flushing our buffer.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;// Always block continued ... (i_reset) is false
	else if (!i_busy) // the next stage is not busy
	begin
		if (!r_stb)
		begin
			// Nothing is in the buffer, so send the input
			// directly to the output.
			o_stb   &amp;lt;= i_stb;

			// This logic() function is arbitrary, and specific
			// the what this stage is supposed to do.
			o_data  &amp;lt;= logic(i_data);
		end else begin
			// o_busy is true and something is in our buffer.
			// Flush the buffer to the output port.
			o_stb  &amp;lt;= 1&#39;b1;
			o_data &amp;lt;= r_data; // This is the buffered data

			// We can ignore the input in this case, since
			// we&#39;ll only be here if `o_busy` is also true.
		end

		// We can also clear any stall condition
		o_busy  &amp;lt;= 1&#39;b0;

		// And declare the register to be empty.
		r_stb   &amp;lt;= 1&#39;b0;
	end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The next case is the case where &lt;code class=&quot;highlighter-rouge&quot;&gt;o_stb&lt;/code&gt; is false (and &lt;code class=&quot;highlighter-rouge&quot;&gt;i_busy&lt;/code&gt; is true).  This
case wasn’t shown in
the diagram series above.  It’s basically the case where a pipeline stage
has no data payload within it at all.  In that case, we’ll keep &lt;code class=&quot;highlighter-rouge&quot;&gt;o_busy&lt;/code&gt; false,
we’ll accept any data, and then set the output &lt;code class=&quot;highlighter-rouge&quot;&gt;o_stb&lt;/code&gt; value to indicate to
the next stage that we have something ready to be read.  Who knows, the
&lt;code class=&quot;highlighter-rouge&quot;&gt;i_busy&lt;/code&gt; flag might be de–asserted on the next clock and we might not need
to stall.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;// Always block continued ... (i_reset) is false, (i_busy) is true
//
	else if (!o_stb)
	begin
		o_stb  &amp;lt;= i_stb;
		o_busy &amp;lt;= 1&#39;b0;

		// Keep the buffer empty
		r_stb &amp;lt;= 1&#39;b0;

		// Apply the logic to the input data, and set the output data
		o_data &amp;lt;= logic(i_data);
	end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The last case to deal with is the case where &lt;code class=&quot;highlighter-rouge&quot;&gt;i_busy&lt;/code&gt; is true, &lt;code class=&quot;highlighter-rouge&quot;&gt;o_stb&lt;/code&gt;
indicates we have a payload loaded, and we now need to store our input into
our buffer.  Hence, we’ll set &lt;code class=&quot;highlighter-rouge&quot;&gt;r_stb&lt;/code&gt; and mark this stage of the pipeline
as &lt;code class=&quot;highlighter-rouge&quot;&gt;BUSY&lt;/code&gt; with &lt;code class=&quot;highlighter-rouge&quot;&gt;o_busy&lt;/code&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;// Always block continued ... (i_reset) is false, (i_busy) and (o_stb) are both
// true.
	else if ((i_stb)&amp;amp;&amp;amp;(!o_busy))
	begin
		// If the next stage *is* busy, though, and we haven&#39;t
		// stalled yet, then we need to accept the requested value
		// from the input.  We&#39;ll place it into a termporary
		// location.
		r_stb  &amp;lt;= (i_stb)&amp;amp;&amp;amp;(o_stb);
		o_busy &amp;lt;= (i_stb)&amp;amp;&amp;amp;(o_stb);
		if (!o_stb)
			o_data &amp;lt;= i_data;
	end
end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;That ends our giant always block, but we still have one value that we haven’t
set: &lt;code class=&quot;highlighter-rouge&quot;&gt;r_data&lt;/code&gt;.  &lt;code class=&quot;highlighter-rouge&quot;&gt;r_data&lt;/code&gt; needs to be set based upon the input data, &lt;code class=&quot;highlighter-rouge&quot;&gt;i_data&lt;/code&gt;.
If you need to apply a &lt;code class=&quot;highlighter-rouge&quot;&gt;logic()&lt;/code&gt; transform to &lt;code class=&quot;highlighter-rouge&quot;&gt;i_data&lt;/code&gt;, you can do that here to
&lt;code class=&quot;highlighter-rouge&quot;&gt;r_data&lt;/code&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	if (!o_busy)
		r_data &amp;lt;= logic(i_data);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;That was a lot harder than the simple handshake, now, wasn’t it?&lt;/p&gt;

&lt;p&gt;Be aware, the code above hasn’t been tested.  Although I copied it from a
(working) data width bus translation module, I found some bugs and made some
changes along the way.  Hence, if you try this and find any bugs, then please
please write me at the e-mail address in the postscript below.&lt;/p&gt;

&lt;p&gt;You may also notice that &lt;code class=&quot;highlighter-rouge&quot;&gt;r_stb&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;o_busy&lt;/code&gt; above are the same signal.  I’ve
kept them separate for conceptual understanding, but these two can be
combined into a single signal.&lt;/p&gt;

&lt;p&gt;The overall approach, though, is a clear example of how
&lt;a href=&quot;https://en.wikipedia.org/wiki/Logic_block&quot;&gt;logic resources&lt;/a&gt;
can be traded
to achieve pipeline speed and throughput.  Indeed, it is only one of many
examples, but its a worthwhile lesson to take away from this exercise. 
While I haven’t done so, I think that if you &lt;a href=&quot;/blog/2017/06/12/minimizing-luts.html&quot;&gt;count the
LUTs&lt;/a&gt;
used by this routine, you’ll find that all this extra logic has at least
doubled the number of
&lt;a href=&quot;https://en.wikipedia.org/wiki/Logic_block&quot;&gt;LUTs&lt;/a&gt; required.&lt;/p&gt;

&lt;p&gt;Although this is a useful approach to pipelining, it may easily be more
logic than your problem requires.  Indeed, very few of my own routines
have ever needed to use this buffered handshaking approach.  The routines
that have needed to use it tend to be &lt;a href=&quot;/zipcpu/2017/05/29/simple-wishbone.html&quot;&gt;wishbone
peripherals&lt;/a&gt;
with complex logic within them–such as my &lt;a href=&quot;https://github.com/ZipCPU/xulalx25soc/blob/master/rtl/wbsdram.v&quot;&gt;SDRAM
controller&lt;/a&gt;,
my attempt at a &lt;a href=&quot;https://opencores.org/project,wbddr3&quot;&gt;DDR3 SDRAM controller&lt;/a&gt;,
or a wishbone bus width expansion module that I put together for an
HDMI video project.&lt;/p&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;We’ve now walked through several examples of the signaling associated with
pipeline logic.  These examples have gone from the simple global &lt;code class=&quot;highlighter-rouge&quot;&gt;CE&lt;/code&gt; approach,
all the way to a buffered handshake approach.  Which type of pipeline signaling
you use will be specific to your problem and your needs.  However, these
approaches should handle most of the problems you might have.&lt;/p&gt;

&lt;p&gt;Let’s come back to this topic of pipelining at least one more time, though,
and look at how the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt; handles
its pipeline signaling within the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU proper&lt;/a&gt;.
This is a more complicated environment, as lots of events can stall the 
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
along the way.  Indeed, handling the pipeline needs of a
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
can be quite a challenge.&lt;/p&gt;

&lt;p&gt;That will then be our next post on this topic.&lt;/p&gt;

&lt;hr /&gt;&lt;p&gt;&lt;em&gt;For the time is come that judgment must begin at the house of God: and if it first begin at us, what shall the end be of them that obey not the gospel of God? (1Pet 4:17)&lt;/em&gt;</description>
        <pubDate>Mon, 14 Aug 2017 00:00:00 -0400</pubDate>
        <link>http://zipcpu.com/blog/2017/08/14/strategies-for-pipelining.html</link>
        <guid isPermaLink="true">http://zipcpu.com/blog/2017/08/14/strategies-for-pipelining.html</guid>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>What would cause you to lie?</title>
        <description>&lt;p&gt;Integrity should not need to be discussed on any engineering forum.  The
honesty of every engineer should be assumed.  That this is not the case, and
that this needs to be discussed is unfortunate.  It is, however reality.&lt;/p&gt;

&lt;p&gt;Let’s start the discussion with a quick survey.  You don’t need to answer,
but just think these questions through:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Would you &lt;em&gt;lie&lt;/em&gt; to get a good grade in school?&lt;/p&gt;

    &lt;p&gt;Imagine you are in a science class.  You’ve struggled to learn the material,
but you are sitting next to someone who has done very well in the class so
far.  You realize you can see, and therefore copy his answers.&lt;/p&gt;

    &lt;p&gt;Your grade is poor, his is wonderful.  If you copied from him, you would get
a much better grade.&lt;/p&gt;

    &lt;p&gt;Would you do it?&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Would you ever get someone else to do the work on your project, and then
&lt;em&gt;lie&lt;/em&gt; when turning it in about who had done it?&lt;/p&gt;

    &lt;p&gt;Imagine you are in an engineering class.  It’s the end of the semester.
The final project is due in a week or so, and your project doesn’t work.  You
realize that, given the state of your project and what you know and
understand about the engineering you’ve been learning, that there is no
way you will be successful.&lt;/p&gt;

    &lt;p&gt;Would you be willing to ask a professional to do your work for you, to get
your design to work, so you could turn in a working design?&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Would you &lt;em&gt;lie&lt;/em&gt; to win an award?&lt;/p&gt;

    &lt;p&gt;Imagine you are a member of a competitive collegiate engineering team.&lt;/p&gt;

    &lt;p&gt;You can &lt;em&gt;lie&lt;/em&gt; to improve your chances of winning a world championship, but
you also realize that if you tell the truth you will never win.  Perhaps
you are only lying to other teams you are competing against–not even the
officials.&lt;/p&gt;

    &lt;p&gt;Would you do it?&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Would you &lt;em&gt;lie&lt;/em&gt; on a resume?&lt;/p&gt;

    &lt;p&gt;Imagine you are looking for a job.  As you look over your resume, you realize
you don’t really have the engineering experience necessary to qualify for
the job.  You’ve been out of work now, though, for 6+ months and you are
worried whether or not the bank will come and take your house.  You know
that without the experience you don’t have, you won’t get the job.&lt;/p&gt;

    &lt;p&gt;Would you be willing to &lt;em&gt;lie&lt;/em&gt;, and tell the hiring officer you had
experiences that you never had?&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Would you &lt;em&gt;lie&lt;/em&gt; to get a contract?&lt;/p&gt;

    &lt;p&gt;Imagine now that you are the engineering lead on a team bidding for a
multi-billion dollar contract.  If you win the contract, you will be
gainfully employed for many years to come.  If you lose the contract, you
and many others will likely lose your jobs.&lt;/p&gt;

    &lt;p&gt;Now, if I told you that you would win the contract if you &lt;em&gt;lied&lt;/em&gt;, and lose
the contract if you told the truth, would you &lt;em&gt;lie&lt;/em&gt;?&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;In a similar line to the last question, Would you &lt;em&gt;lie&lt;/em&gt; to keep a contract?
Would you lie to keep your contract funded?&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;These are very real questions.&lt;/p&gt;

&lt;p&gt;If you’ve never considered these sorts of questions before, you might wish to
take the time to do so now.&lt;/p&gt;

&lt;p&gt;Sadly, they are also questions that I think every engineer will encounter at
some point in his career.&lt;/p&gt;

&lt;p&gt;Sure, they start out simple and easy.  I mean, who cares if you cheat on an
exam?  The professor?  How long will he be a part of your life?  However, by
the time you get to the end of the list, you will find the livelihood’s of not
only yourself but many others as well suddenly depend upon your actions.&lt;/p&gt;

&lt;p&gt;So let me ask, under what condition would you be willing to &lt;em&gt;lie&lt;/em&gt;?&lt;/p&gt;

&lt;h2 id=&quot;the-reality-of-lies&quot;&gt;The Reality of Lies&lt;/h2&gt;

&lt;p&gt;History is filled with examples of people who have made the wrong decisions
when confronted by the question above.  Some end up disgraced, others end up in
prison.  These are the lucky ones.  They at least know they need to repent.
Those that don’t get caught end up believing that lying is beneficial.  They
are then drawn to nurse a wounded conscience and do it again.&lt;/p&gt;

&lt;p&gt;This leads to the sad reality: lie’s are addictive.  If you do it once, 
circumstances will command you to lie again and again.  If you start down
the path, you will quickly find yourself trapped within it.&lt;/p&gt;

&lt;p&gt;I would know, I’ve been there.  I was once trapped in my own web of lies and
deceit.  I once thought that lies were the easiest and sometimes the only way
to get out of my problems.&lt;/p&gt;

&lt;p&gt;I have since learned painfully, though, that if you lie once, you will be
&lt;em&gt;compelled&lt;/em&gt; to lie again and again.  (Prov 13:19)&lt;/p&gt;

&lt;p&gt;Eventually, lying will rule your life. (Prov 14:12)  At one time, it ruled
mine.&lt;/p&gt;

&lt;p&gt;I also know that Christ is still in the business of rescuing individuals
trapped by lies.  (Rom 6:16)  I know this personally because he rescued me.&lt;/p&gt;

&lt;p&gt;While this isn’t the main topic of this blog, and while I have many other
things I wish to discuss, integrity is sadly a topic that must come up from
time to time again.  Without integrity, sound engineering is impossible.&lt;/p&gt;
&lt;hr /&gt;&lt;p&gt;&lt;em&gt;Better is the poor that walketh in his integrity, than he that is perverse in his lips, and is a fool.&lt;/em&gt;</description>
        <pubDate>Sat, 12 Aug 2017 00:00:00 -0400</pubDate>
        <link>http://zipcpu.com/blog/2017/08/12/caused-to-lie.html</link>
        <guid isPermaLink="true">http://zipcpu.com/blog/2017/08/12/caused-to-lie.html</guid>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>A Simple ALU, drawn from the ZipCPU</title>
        <description>&lt;p&gt;Many digital logic design courses end with a discussion of how to build a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;.
The common lesson tends to focus on the &lt;a href=&quot;https://en.wikipedia.org/wiki/Arithmetic_logic_unit&quot;&gt;arithmetic logic unit
(ALU)&lt;/a&gt; as the work horse
within the center of the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Since &lt;a href=&quot;https://en.wikipedia.org/wiki/Arithmetic_logic_unit&quot;&gt;ALU&lt;/a&gt;’s
tend to be very simple, they are easy to look at and examine.&lt;/p&gt;

&lt;p&gt;For this post, we’ll look at the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/cpuops.v&quot;&gt;ALU&lt;/a&gt;
found within the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;.
Unlike many of the “classroom”
&lt;a href=&quot;https://en.wikipedia.org/wiki/Arithmetic_logic_unit&quot;&gt;ALU&lt;/a&gt;’s
you may have come across, this simple
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/cpuops.v&quot;&gt;ALU&lt;/a&gt;
is also complete enough to support the
&lt;a href=&quot;https://sourceware.org/newlib&quot;&gt;newlib C library&lt;/a&gt;.
As a result, you might find a couple of features within this
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/cpuops.v&quot;&gt;ALU&lt;/a&gt;
that you are not expecting.&lt;/p&gt;

&lt;h2 id=&quot;a-basic-alu&quot;&gt;A Basic ALU&lt;/h2&gt;

&lt;p&gt;If you’ve never seen how to build an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Arithmetic_logic_unit&quot;&gt;ALU&lt;/a&gt;
before, the logic to build one is actually very simple.  It’s basically
a big huge case statement that selects from among several possible outputs.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;case(i_op[3:0])
	4&#39;b0000:{c,o_c } &amp;lt;= {1&#39;b0,i_a}-{1&#39;b0,i_b};// SUB
	4&#39;b0001:   o_c   &amp;lt;= i_a &amp;amp; i_b;		// And
	4&#39;b0010:{c,o_c } &amp;lt;= i_a + i_b;		// Add
	4&#39;b0011:   o_c   &amp;lt;= i_a | i_b;		// Or
	4&#39;b0100:   o_c   &amp;lt;= i_a ^ i_b;		// Xor
	// ....
	default:   o_c   &amp;lt;= i_b;		// MOV, LDI&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;In this example, taken from the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;’s
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/cpuops.v&quot;&gt;ALU&lt;/a&gt;, the
two inputs, &lt;code class=&quot;highlighter-rouge&quot;&gt;i_a&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;i_b&lt;/code&gt;, are both 32-bit values.  The input to the
routine also includes a number, &lt;code class=&quot;highlighter-rouge&quot;&gt;i_op&lt;/code&gt;, identifying the operation that
needs to be calculated.  The result is placed into an output register, &lt;code class=&quot;highlighter-rouge&quot;&gt;o_c&lt;/code&gt;.
The &lt;code class=&quot;highlighter-rouge&quot;&gt;c&lt;/code&gt; bit you see above is associated with the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;’s carry logic–something we’ll
come back to later in this post.&lt;/p&gt;

&lt;p&gt;Structurally, within an FPGA, the logic looks like Fig 1 below.&lt;/p&gt;

&lt;table style=&quot;float: left&quot;&gt;&lt;caption&gt;Fig 1: ALU Hardware Structure&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/alu-simple.svg&quot; alt=&quot;ALU Structure&quot; width=&quot;400&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Each of the blocks in this figure takes up logic when implemented within
hardware.  As a result, even if &lt;code class=&quot;highlighter-rouge&quot;&gt;i_op&lt;/code&gt; requests that the two values be
subtracted, all of the other operations (addition, and, or, xor, etc.) will
still be calculated.  These other results, though, are just ignored.  Thus,
on the final clock of the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/cpuops.v&quot;&gt;ALU&lt;/a&gt;,
&lt;em&gt;all&lt;/em&gt; of the operations have been calculated, but &lt;em&gt;only&lt;/em&gt; the result of
the selected operation is stored into the output register.&lt;/p&gt;

&lt;p&gt;So that’s what an &lt;a href=&quot;https://en.wikipedia.org/wiki/Arithmetic_logic_unit&quot;&gt;ALU&lt;/a&gt;
looks liike in general.  Let’s now turn our attention to the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;’s
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/cpuops.v&quot;&gt;ALU&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;the-zipcpu-alu&quot;&gt;The ZipCPU ALU&lt;/h2&gt;

&lt;p&gt;The actual case statement within the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;’s
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/cpuops.v&quot;&gt;ALU&lt;/a&gt;
has sixteen operations that the instruction selects from among, not just the
six shown above.  In this section,
we’ll look at all of that logic save the multiply.  (Although the multiply
takes up most of the code space within the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/cpuops.v&quot;&gt;cpuops.v&lt;/a&gt;
file, it doesn’t fit into this lesson very well.)  Put together, the full
case statement for the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;’s
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/cpuops.v&quot;&gt;ALU&lt;/a&gt;
looks like:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
if (i_ce)
begin
	c &amp;lt;= 1&#39;b0;
	casez(i_op)
	4&#39;b0000:{c,o_c } &amp;lt;= {1&#39;b0,i_a}-{1&#39;b0,i_b};// CMP/SUB
	4&#39;b0001:   o_c   &amp;lt;= i_a &amp;amp; i_b;		// BTST/And
	4&#39;b0010:{c,o_c } &amp;lt;= i_a + i_b;		// Add
	4&#39;b0011:   o_c   &amp;lt;= i_a | i_b;		// Or
	4&#39;b0100:   o_c   &amp;lt;= i_a ^ i_b;		// Xor
	4&#39;b0101:{o_c,c } &amp;lt;= w_lsr_result[32:0];	// LSR
	4&#39;b0110:{c,o_c } &amp;lt;= w_lsl_result[32:0]; // LSL
	4&#39;b0111:{o_c,c } &amp;lt;= w_asr_result[32:0];	// ASR
	4&#39;b1000:   o_c   &amp;lt;= w_brev_result;	// BREV
	4&#39;b1001:   o_c   &amp;lt;= { i_a[31:16], i_b[15:0] }; // LODILO
	4&#39;b1010:   o_c   &amp;lt;= mpy_result[63:32];	// MPYHU
	4&#39;b1011:   o_c   &amp;lt;= mpy_result[63:32];	// MPYHS
	4&#39;b1100:   o_c   &amp;lt;= mpy_result[31:0];	// MPY
	default:   o_c   &amp;lt;= i_b;		// MOV, LDI
	endcase
end else // if (mpydone)
	// set the carry based upon a multiply result
	o_c &amp;lt;= (mpyhi)?mpy_result[63:32]:mpy_result[31:0];&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Let’s walk through each of these operations.&lt;/p&gt;

&lt;p&gt;The first operation, &lt;code class=&quot;highlighter-rouge&quot;&gt;4&#39;h0&lt;/code&gt; supports either a compare or a subtract
instruction.  This instruction subtracts two numbers in order to produce its
result.  The difference between the &lt;code class=&quot;highlighter-rouge&quot;&gt;CMP&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;SUB&lt;/code&gt; instructions is that the
compare doesn’t write the results back to any registers in the end while the
subtract does–but since that’s external to the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/cpuops.v&quot;&gt;ALU&lt;/a&gt;
implementation, you won’t see that difference here.&lt;/p&gt;

&lt;p&gt;You may notice that the subtract that is taking place is a 33-bit subtract
rather than a 32-bit subtract.  The reason for this is the carry, &lt;code class=&quot;highlighter-rouge&quot;&gt;c&lt;/code&gt;, bit.
In the case of a subtract, this bit will be true if &lt;code class=&quot;highlighter-rouge&quot;&gt;i_b&lt;/code&gt; had to &lt;em&gt;borrow&lt;/em&gt;
from the (unspecified) high order bit in order to complete.  We’ll discuss
this flag in more detail further down.&lt;/p&gt;

&lt;p&gt;The &lt;code class=&quot;highlighter-rouge&quot;&gt;TST&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;AND&lt;/code&gt; instructions are similar to the &lt;code class=&quot;highlighter-rouge&quot;&gt;CMP&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;SUB&lt;/code&gt;
instructions.  If the operation is an &lt;code class=&quot;highlighter-rouge&quot;&gt;AND&lt;/code&gt;, then both the result
and the flags will be set during writeback, whereas only the flags are set in
the case of the &lt;code class=&quot;highlighter-rouge&quot;&gt;TST&lt;/code&gt; operation.  Again, this difference is external to the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/cpuops.v&quot;&gt;ALU&lt;/a&gt;
implementation itself.&lt;/p&gt;

&lt;p&gt;The &lt;code class=&quot;highlighter-rouge&quot;&gt;ADD&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;OR&lt;/code&gt;, and &lt;code class=&quot;highlighter-rouge&quot;&gt;XOR&lt;/code&gt; instructions should need no further explanation.
(&lt;a href=&quot;https://en.wikipedia.org/wiki/Exclusive_or#Bitwise_operation&quot;&gt;XOR Ref&lt;/a&gt;)
The &lt;code class=&quot;highlighter-rouge&quot;&gt;c&lt;/code&gt; bit is set on the &lt;code class=&quot;highlighter-rouge&quot;&gt;ADD&lt;/code&gt;, though, if the result of adding unsigned
&lt;code class=&quot;highlighter-rouge&quot;&gt;i_a&lt;/code&gt; to &lt;code class=&quot;highlighter-rouge&quot;&gt;i_b&lt;/code&gt; overflows 32-bits.  This bit then makes it possible to string
32-bit additions together to create a 64-bit or larger operation.&lt;/p&gt;

&lt;p&gt;The shift instruction(s) needs some additional discussion.  The &lt;a href=&quot;https://en.wikipedia.org/wiki/Logical_shift&quot;&gt;logical
shift&lt;/a&gt; left, or &lt;code class=&quot;highlighter-rouge&quot;&gt;LSL&lt;/code&gt;, is
what the compiler creates from an &lt;code class=&quot;highlighter-rouge&quot;&gt;A = B &amp;lt;&amp;lt; C&lt;/code&gt; instruction.  The result is
created by shifting all of the bits in &lt;code class=&quot;highlighter-rouge&quot;&gt;B&lt;/code&gt; to the left by one and filling
the results in with zeros.
The &lt;a href=&quot;https://en.wikipedia.org/wiki/Logical_shift&quot;&gt;logical shift&lt;/a&gt;
right, or &lt;code class=&quot;highlighter-rouge&quot;&gt;LSR&lt;/code&gt;, comes from an &lt;code class=&quot;highlighter-rouge&quot;&gt;A = B &amp;gt;&amp;gt; C&lt;/code&gt; instruction in C, but only when
&lt;code class=&quot;highlighter-rouge&quot;&gt;B&lt;/code&gt; is unsigned.  In this case, all the bits shift to the right and the
upper bits are filled in with zeros.&lt;/p&gt;

&lt;p&gt;If &lt;code class=&quot;highlighter-rouge&quot;&gt;B&lt;/code&gt; is signed, however, the compiler will create an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Arithmetic_shift&quot;&gt;arithmetic shift&lt;/a&gt;
right, &lt;code class=&quot;highlighter-rouge&quot;&gt;ASR&lt;/code&gt;, instruction instead.  The &lt;code class=&quot;highlighter-rouge&quot;&gt;ASR&lt;/code&gt; is similar to the &lt;code class=&quot;highlighter-rouge&quot;&gt;LSR&lt;/code&gt;
instruction with one exception: the &lt;code class=&quot;highlighter-rouge&quot;&gt;ASR&lt;/code&gt; instruction propagates the high order
bit during the shift.  Hence the incoming &lt;code class=&quot;highlighter-rouge&quot;&gt;i_a[31]&lt;/code&gt; will always set the
outgoing &lt;code class=&quot;highlighter-rouge&quot;&gt;o_c[31]&lt;/code&gt; bit.  So while
&lt;a href=&quot;https://en.wikipedia.org/wiki/Logical_shift&quot;&gt;logically shifting&lt;/a&gt; a
&lt;code class=&quot;highlighter-rouge&quot;&gt;32&#39;hffff_fffe&lt;/code&gt; to the right by one bit will create a &lt;code class=&quot;highlighter-rouge&quot;&gt;32&#39;7fff_ffff&lt;/code&gt;,
&lt;a href=&quot;https://en.wikipedia.org/wiki/Arithmetic_shift&quot;&gt;arithmetically shifting&lt;/a&gt; a
&lt;code class=&quot;highlighter-rouge&quot;&gt;32&#39;hffff_fffe&lt;/code&gt; to the right by one bit will create a &lt;code class=&quot;highlighter-rouge&quot;&gt;32&#39;hffff_ffff&lt;/code&gt;.
The sign bit, &lt;code class=&quot;highlighter-rouge&quot;&gt;i_a[31]&lt;/code&gt; propagates on an &lt;code class=&quot;highlighter-rouge&quot;&gt;ASR&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Where things get interesting is what happens when you shift farther than
the number of bits in a register.  For example, what should be the result of
&lt;code class=&quot;highlighter-rouge&quot;&gt;32&#39;h0000_ffff&lt;/code&gt; when shifted left by 32?  &lt;code class=&quot;highlighter-rouge&quot;&gt;32&#39;h0000_0000&lt;/code&gt;, right?  Sure.  Now
what happens when you shift left by 34 bits?  Some
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;’s
examine only the lower 5 bits of the shift amount, and require the compiler
to make certain the shift is within bounds.  The
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;,
however, examines all 32-bits of the shift request contained in &lt;code class=&quot;highlighter-rouge&quot;&gt;i_b&lt;/code&gt;.
Hence, any attempt to logically shift more than 32-bits on the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt; results in a zero.&lt;/p&gt;

&lt;p&gt;The &lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;
handles shifts with one further difference that isn’t necessarily
used by the compiler: the carry bit is set to the last bit shifted off the
register.&lt;/p&gt;

&lt;p&gt;Now that all that is said, the &lt;code class=&quot;highlighter-rouge&quot;&gt;LSR&lt;/code&gt; logic is given by:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;assign  w_lsr_result =
	// Check if the shift amount will overflow, return 33&#39;h00 if it does
	((|i_b[31:6])||(i_b[5]&amp;amp;&amp;amp;(i_b[4:0]!=0)))? 33&#39;h00
	// On a shift of 32 exactly, keep i_a[31] in the carry
				:((i_b[5])?{32&#39;h0,i_a[31]}
	// Otherwise just shift the results by i_b
				: ( { i_a, 1&#39;b0 } &amp;gt;&amp;gt; (i_b[4:0]) ));// LSR&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The logic for the &lt;code class=&quot;highlighter-rouge&quot;&gt;LSL&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;ASR&lt;/code&gt; instructions is quite similar.&lt;/p&gt;

&lt;p&gt;A second unique
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;
instruction is the &lt;a href=&quot;https://en.wikipedia.org/wiki/Bit-reversal_permutation&quot;&gt;bit
reverse&lt;/a&gt; instruction,
&lt;code class=&quot;highlighter-rouge&quot;&gt;BREV&lt;/code&gt;.  This is a zero cost instruction that does nothing but re-order the
wires from the &lt;code class=&quot;highlighter-rouge&quot;&gt;i_b&lt;/code&gt; input:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;genvar	k; generate
for(k=0; k&amp;lt;32; k=k+1)
begin : bit_reversal_cpuop
	assign w_brev_result[k] = i_b[31-k];
end endgenerate&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This particular instruction is not found in other
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;’s.
It was placed into the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt; in order to support the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bit-reversal_permutation&quot;&gt;bit reversed&lt;/a&gt;
addressing required by a &lt;a href=&quot;https://en.wikipedia.org/Cooley-Tukey_FFT_algorithm&quot;&gt;Fast Fourier
transform&lt;/a&gt;.  It has since
become integral to the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;’s instruction set.  Here’s why:&lt;/p&gt;

&lt;p&gt;Every &lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;
needs an ability to load a value with as many bits as a register into
a register.  That is to say, a 32-bit
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;
needs the ability to load a 32-bit immediate value into a 32-bit
register–&lt;a href=&quot;https://www.gnu.org/software/binutils&quot;&gt;binutils&lt;/a&gt;, and particularly
the linker within
it, requires this capability.  Since instructions are 32-bits wide, you can’t
fit both an instruction and a 32’bit value into the same instruction.  While
the &lt;a href=&quot;https://en.wikipedia.org/wiki/X86&quot;&gt;x86&lt;/a&gt; solved this problem by storing
the 32’bit value directly in the instruction stream following this instruction,
this risks mis-aligning the instruction stream and therefore adding
complication to the instruction decoder.  To avoid this extra complication,
&lt;a href=&quot;https://en.wikipedia.org/wiki/Reduced_instruction_set_computer&quot;&gt;RISC&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;s
tend to handle this problem with a two instruction load: the first instruction
loads the upper half of the register, while the second instruction loads
the lower half of the register.&lt;/p&gt;

&lt;p&gt;In the case of the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;,
the &lt;code class=&quot;highlighter-rouge&quot;&gt;BREV&lt;/code&gt; instruction is the first instruction in this pair–it can be used to
load the upper 18-bits of a register.  The other instruction, shown in the
code above as &lt;code class=&quot;highlighter-rouge&quot;&gt;LDILO&lt;/code&gt; (load immediate into lower 16-bits), loads the lower
16-bits of any 32-bit value.  &lt;a href=&quot;https://gcc.gnu.org&quot;&gt;GCC&lt;/a&gt; requires that neither
of these operations affect the flags, something we can come back and discuss
another time.  Together, these two instructions allow the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;
to load &lt;em&gt;any&lt;/em&gt; 32-bit immediate value into a register.  Since the extra cost
of &lt;a href=&quot;https://en.wikipedia.org/wiki/Bit-reversal_permutation&quot;&gt;bit reversing&lt;/a&gt;
a 32-bit value is handled by the
&lt;a href=&quot;https://www.gnu.org/software/binutils&quot;&gt;assembler and linker&lt;/a&gt; (there’s no
hardware cost for doing this), there’s no performance penalty to the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt; for having this instruction.&lt;/p&gt;

&lt;p&gt;That leaves two pieces of logic we haven’t discussed within the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/cpuops.v&quot;&gt;ALU&lt;/a&gt;.
The first is the flag generation logic which we will come to next.  The
other piece of logic within the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/cpuops.v&quot;&gt;ALU&lt;/a&gt;
that we haven’t discussed is the multiply.  The multiply logic in the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;’s
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/cpuops.v&quot;&gt;cpuops.v&lt;/a&gt;
file is particularly complicated for the sole reason that the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;
can support a 32x32-bit multiply across a wide variety of hardware
architectures.  Some of these architectures can do a multiply in a single
clock, while other FPGA’s require two, three, or even four clocks to execute a
multiply.&lt;/p&gt;

&lt;p&gt;Let’s look at calculating the flags next.&lt;/p&gt;

&lt;h2 id=&quot;the-flags-results&quot;&gt;The Flags Results&lt;/h2&gt;

&lt;p&gt;The &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/cpuops.v&quot;&gt;ALU&lt;/a&gt;
creates and outputs a set of flags from the operation.  Many instructions will
cause these to be placed into the &lt;a href=&quot;https://en.wikipedia.org/wiki/Status_register&quot;&gt;condition codes
register&lt;/a&gt;.
The &lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;
supports all four of the common condition codes, or flags as we’ll call them
here: &lt;code class=&quot;highlighter-rouge&quot;&gt;Z&lt;/code&gt; (zero), &lt;code class=&quot;highlighter-rouge&quot;&gt;C&lt;/code&gt; (carry), &lt;code class=&quot;highlighter-rouge&quot;&gt;N&lt;/code&gt; (negative) and &lt;code class=&quot;highlighter-rouge&quot;&gt;V&lt;/code&gt; (overflow).&lt;/p&gt;

&lt;p&gt;The &lt;code class=&quot;highlighter-rouge&quot;&gt;Z&lt;/code&gt; flag is set whenever the result is zero:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;assign	z = (o_c == 32&#39;h0000);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The compiler uses this flag whenever two numbers need to be tested and compared
for equality.&lt;/p&gt;

&lt;p&gt;The &lt;code class=&quot;highlighter-rouge&quot;&gt;C&lt;/code&gt; or “carry” flag was set above whenever an addition or subtraction
required a carry.  I also mentioned above how the carry flag on the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;
is also set for shift operations.  All other operations clear the carry flag.&lt;/p&gt;

&lt;p&gt;The compiler uses this flag whenever two numbers need to be tested and compared
for an unsigned &lt;em&gt;less than&lt;/em&gt;, or whenever an extended 64-bit addition (or
subtraction) needs to be carried out.  (Unlike many other CPU’s, the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;
doesn’t have either “add with carry” or “subtract with carry” instructions.)&lt;/p&gt;

&lt;p&gt;The &lt;code class=&quot;highlighter-rouge&quot;&gt;N&lt;/code&gt; flag is perhaps the simplest to discuss.  This is set whenever the
sign bit is set on the output:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;assign	n = (o_c[31]);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Well, not quite.&lt;/p&gt;

&lt;p&gt;It turns out that there’s an ugly problem associated with setting the &lt;code class=&quot;highlighter-rouge&quot;&gt;N&lt;/code&gt;
flag to the outgoing sign bit.  Specifically,
if you wish to compare whether or not &lt;code class=&quot;highlighter-rouge&quot;&gt;A&amp;lt;B&lt;/code&gt; when &lt;code class=&quot;highlighter-rouge&quot;&gt;A&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;B&lt;/code&gt; are large and
signed then &lt;code class=&quot;highlighter-rouge&quot;&gt;o_c[31]&lt;/code&gt; isn’t sufficient.  To do this comparison, the &lt;code class=&quot;highlighter-rouge&quot;&gt;CMP&lt;/code&gt;
instruction will enter the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/cpuops.v&quot;&gt;ALU&lt;/a&gt;
via a subtract, &lt;code class=&quot;highlighter-rouge&quot;&gt;A-B&lt;/code&gt;.  The result of this subtraction will then be checked
to determine whether or not the result is less than zero.  However, if the
result overflows the sign bit, then you still want to continue to set the
&lt;code class=&quot;highlighter-rouge&quot;&gt;N&lt;/code&gt; flag appropriately.  If you don’t, then &lt;code class=&quot;highlighter-rouge&quot;&gt;32&#39;h8000_0000&lt;/code&gt; won’t be less
than &lt;code class=&quot;highlighter-rouge&quot;&gt;32&#39;h7fff_ffff&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;As proof, consider what happens on a subtraction overflow:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;  32&#39;h7fff_ffff ( 2^(31)-1)
- 32&#39;h8000_0000 (-2^(31)  )
---------------
= 32`hffff_ffff&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The result of this subtraction &lt;em&gt;should&lt;/em&gt; be a positive &lt;code class=&quot;highlighter-rouge&quot;&gt;2^(32)-1&lt;/code&gt;.  However,
since an overflow took place, the MSB no longer reflects the correct sign.
We’re going to need to adjust &lt;code class=&quot;highlighter-rouge&quot;&gt;N&lt;/code&gt; therefore to reflect that this result is
positive and not negative.&lt;/p&gt;

&lt;p&gt;While there may be a simpler way, the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/cpuops.v&quot;&gt;ALU&lt;/a&gt;
solves this problem in three steps.  The first is to keep track of
the original sign of &lt;code class=&quot;highlighter-rouge&quot;&gt;i_a&lt;/code&gt; in a register called &lt;code class=&quot;highlighter-rouge&quot;&gt;pre_sign&lt;/code&gt;.  The second part
is to determine if that sign needs to be kept on an overflow.
Then, on any overflow, the sign is flipped when determining &lt;code class=&quot;highlighter-rouge&quot;&gt;N&lt;/code&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	if (i_ce) // 1 LUT
	begin
		pre_sign &amp;lt;= (i_a[31]);
		keep_sgn_on_ovfl&amp;lt;=
			(((i_op==4&#39;h0)&amp;amp;&amp;amp;(i_a[31] != i_b[31]))//SUB&amp;amp;CMP
			||((i_op==4&#39;h2)&amp;amp;&amp;amp;(i_a[31] == i_b[31]))); // ADD
	end

assign n = (o_c[31])
	^ ((keep_sgn_on_ovfl)&amp;amp;&amp;amp;(pre_sign != o_c[31]));&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;When to keep a sign on overflow needs a touch more explanation:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;If you add two values with the same sign, then the result should also
have the same sign regardless of any overflow.  Hence, two positive numbers
should yield a positive result in spite of any overflow.  In this case,
the sign should be given by &lt;code class=&quot;highlighter-rouge&quot;&gt;i_a&lt;/code&gt;’s sign, captured here in &lt;code class=&quot;highlighter-rouge&quot;&gt;pre_sign&lt;/code&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The same is true of subtract, save only that the sign needs to be
preserved any time the initial values have opposite signs.  In particular,
if you negate the second value, a subtract becomes the same as an addition,
and then the addition rule above applies again.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Now, if the sign changes but yet was supposed to be kept, then the resulting
&lt;code class=&quot;highlighter-rouge&quot;&gt;N&lt;/code&gt; flag needs to be swapped–hence the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Exclusive_or&quot;&gt;exclusive OR&lt;/a&gt;
in the code above.&lt;/p&gt;

&lt;p&gt;The &lt;code class=&quot;highlighter-rouge&quot;&gt;N&lt;/code&gt; bit is used by the compiler to test whether or not &lt;code class=&quot;highlighter-rouge&quot;&gt;i_a &amp;lt; i_b&lt;/code&gt; when
both numbers are signed.  By preserving the meaning of this bit in spite
of overflow, the compiler does what you would expect it to do–even when
comparing large numbers.&lt;/p&gt;

&lt;p&gt;The final flag bit, the overflow or &lt;code class=&quot;highlighter-rouge&quot;&gt;V&lt;/code&gt; bit, requires a touch more logic
as well.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	if (i_ce) // 1 LUT
		set_ovfl&amp;lt;=(((i_op==4&#39;h0)&amp;amp;&amp;amp;(i_a[31] != i_b[31]))//SUB&amp;amp;CMP
			||((i_op==4&#39;h2)&amp;amp;&amp;amp;(i_a[31] == i_b[31])) // ADD
			||(i_op == 4&#39;h6) // LSL
			||(i_op == 4&#39;h5)); // LSR&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The &lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;
sets the overflow flag on one of four conditions:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;If this is an addition, and the signs of both operands are the same, then
the result should be positive and the overflow bit will be set if the
signs don’t match.&lt;/p&gt;

    &lt;p&gt;This alone is almost identical to the &lt;code class=&quot;highlighter-rouge&quot;&gt;N&lt;/code&gt; logic above.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The second case is the case for the subtract.  If the incoming signs are
identical, and the outgoing sign is different, then the overflow bit
needs to be set.  This is also very similar to the &lt;code class=&quot;highlighter-rouge&quot;&gt;N&lt;/code&gt; logic above.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The last two cases regard shifts.  In particular, the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;
sets the overflow if either of the &lt;a href=&quot;https://en.wikipedia.org/wiki/Logical_shift&quot;&gt;logical
shift&lt;/a&gt;
instructions changes the sign of the output.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Put together, this yields the following logic for the &lt;code class=&quot;highlighter-rouge&quot;&gt;V&lt;/code&gt; bit:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;assign	v = (set_ovfl)&amp;amp;&amp;amp;(pre_sign != o_c[31]);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Since the C language doesn’t have a way to test for overflow within the
language, this flag has gone largely unused.  Further, the compiler support
for overflow checking for those other languages that do use it hasn’t
been implemented yet.&lt;/p&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;That’s basically how an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Arithmetic_logic_unit&quot;&gt;ALU&lt;/a&gt;
works: it’s a series of operations whose output is selected via a case
statement.  While every
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;
will support different instructions, at some level all
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;’s
will have a case statement selecting between various operations within them.&lt;/p&gt;

&lt;p&gt;In the case of a &lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;
with a &lt;a href=&quot;https://en.wikipedia.org/wiki/Status_register&quot;&gt;condition codes
register&lt;/a&gt;.
such as the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;, these codes are also
easily calculated within the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/cpuops.v&quot;&gt;ALU&lt;/a&gt; as well.&lt;/p&gt;

&lt;p&gt;Turning a simple &lt;a href=&quot;https://en.wikipedia.org/wiki/Arithmetic_logic_unit&quot;&gt;ALU&lt;/a&gt;
into a full blown &lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;,
such as the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;,
takes a bit more work than we presented above.  In fact, it takes a &lt;em&gt;lot&lt;/em&gt;
more work.  Let’s consider that a good thing, though, because it will give
us something to learn on another day.&lt;/p&gt;

&lt;hr /&gt;&lt;p&gt;&lt;em&gt;In all thy ways acknowledge him, and he shall direct thy paths. (Prov 3:6)&lt;/em&gt;</description>
        <pubDate>Fri, 11 Aug 2017 00:00:00 -0400</pubDate>
        <link>http://zipcpu.com/zipcpu/2017/08/11/simple-alu.html</link>
        <guid isPermaLink="true">http://zipcpu.com/zipcpu/2017/08/11/simple-alu.html</guid>
        
        
        <category>zipcpu</category>
        
      </item>
    
      <item>
        <title>Series: Debouncing in Digital Logic</title>
        <description>&lt;p&gt;This ends our series on contact bounce.  We started out by demonstrating that
&lt;a href=&quot;/blog/2017/08/02/debounce-teaser.html&quot;&gt;button’s do indeed bounce&lt;/a&gt;.
This initial post presented a series of images, collected from tests that
measured button bouncing across multiple devices.&lt;/p&gt;

&lt;p&gt;We then demonstrated how, using digital logic, &lt;a href=&quot;/blog/2017/08/04/debouncing.html&quot;&gt;extraneous bounces could be
removed&lt;/a&gt; from a button’s
signal.&lt;/p&gt;

&lt;p&gt;We also showed &lt;a href=&quot;/blog/2017/08/05/bounce-metric.html&quot;&gt;how to measure how much and how often a button
bounces&lt;/a&gt;.  This will
be useful to us later should we ever wish to tune the timer within our
debouncer.&lt;/p&gt;

&lt;p&gt;The final article discussed &lt;a href=&quot;/blog/2017/08/07/bounce-dbgbus.html&quot;&gt;how to modify our debugging bus to get a button
bouncing trace&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Unlike other debouncing developments, we’ve also discussed how to
synchronize the button inputs along the way,
and the consequences of metastability should the inputs not be synchronized.
We’ve also presented a debouncer that will return the debounced data
with minimal latency, vice the uncontrolled latency many other approaches
share.&lt;/p&gt;

&lt;p&gt;Further, unlike any other debouncing development I’ve seen, using the
&lt;a href=&quot;https://github.com/ZipCPU/debouncer&quot;&gt;sample code&lt;/a&gt; provided you can see
bouncing for yourself, or even test your own debouncing code.&lt;/p&gt;
&lt;hr /&gt;&lt;p&gt;&lt;em&gt;While the earth remaineth, seedtime and harvest, and cold and heat, and summer and winter, and day and night shall not cease. (Gen 8:22)&lt;/em&gt;</description>
        <pubDate>Wed, 09 Aug 2017 00:00:00 -0400</pubDate>
        <link>http://zipcpu.com/blog/2017/08/09/series-debouncing.html</link>
        <guid isPermaLink="true">http://zipcpu.com/blog/2017/08/09/series-debouncing.html</guid>
        
        
        <category>blog</category>
        
      </item>
    
  </channel>
</rss>
