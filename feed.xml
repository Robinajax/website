<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>The ZipCPU by Gisselquist Technology</title>
    <description>The ZipCPU blog, featuring how to discussions of FPGA and CPU design. This site will be focused on Verilog solutions, using exclusively OpenSource IP products for FPGA design.
</description>
    <link>http://zipcpu.com/</link>
    <atom:link href="http://zipcpu.com/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Thu, 08 Jun 2017 14:46:36 -0400</pubDate>
    <lastBuildDate>Thu, 08 Jun 2017 14:46:36 -0400</lastBuildDate>
    <generator>Jekyll v3.0.1</generator>
    
      <item>
        <title>Building A Simple In-Circuit Logic Analyzer</title>
        <description>&lt;p&gt;If you’ve never built your own &lt;a href=&quot;https://en.wikipedia.org/wiki/Logic_analyzer&quot;&gt;logic
scope&lt;/a&gt; to “see” what’s going
on within an FPGA, it’s not really that hard to do.  There are a couple of
steps required to do it, but not really all that more.&lt;/p&gt;

&lt;p&gt;Over time, I’ve built several logic scopes–each for a different environment
that I’ve been running in.  Somewhere around rebuilding the wheel for the
third time, and for a different customer each time, I decided to build
my own–so that I could have a scope that I legally owned and controlled,
and that I could bring with me to any new FPGA job.&lt;/p&gt;

&lt;p&gt;Here in this post, we’ll walk through all the steps of building a basic
&lt;a href=&quot;https://en.wikipedia.org/wiki/Logic_analyzer&quot;&gt;logic scope&lt;/a&gt;.  We’ll reserve
until later how to go about turning this scope’s results into a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Value_change_dump&quot;&gt;VCD file&lt;/a&gt;
for &lt;a href=&quot;http://gtkwave.sourceforge.net&quot;&gt;GTKWave&lt;/a&gt; viewing–but only because I was
using the scope successfully for many years before I ever even discovered
&lt;a href=&quot;http://gtkwave.sourceforge.net&quot;&gt;GTKWave&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;how-it-works&quot;&gt;How it works&lt;/h2&gt;

&lt;p&gt;Before we get into the Verilog code necessary to build one of these things,
let’s discuss what we want it to do.&lt;/p&gt;

&lt;p&gt;We’d like three capabilities from our scope.  First, whenever something goes
wrong within our design, we’d like to be able to look back into the past and see
what happened, as in Fig. 1.&lt;/p&gt;

&lt;table align=&quot;center&quot;&gt;&lt;caption&gt;Fig. 1: Looking back into the past&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/scope-past.svg&quot; alt=&quot;A scope that looks back in time&quot; width=&quot;400&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Of course, this ability to look back in time will be limited by the size of our
scope’s memory.&lt;/p&gt;

&lt;p&gt;We’d also like the ability to debug an interaction that we are in the
process of designing.  For example, if you want to read from &lt;a href=&quot;http://opencores.org/project,qspiflash&quot;&gt;flash
memory&lt;/a&gt;,
it might be valid to look at the flash data lines together with some of your
internal &lt;a href=&quot;http://opencores.org/project,qspiflash&quot;&gt;flash control&lt;/a&gt; state.  In
this case, you would want to start capturing at the time of your read request. 
This capability would look something like Fig 2.&lt;/p&gt;

&lt;table align=&quot;center&quot;&gt;&lt;caption&gt;Fig. 2: After the trigger&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/scope-now.svg&quot; alt=&quot;Using a scope to see what&#39;s happening now&quot; width=&quot;400&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Continuing the our &lt;a href=&quot;http://opencores.org/project,qspiflash&quot;&gt;flash controller&lt;/a&gt;
example, what if you wanted to know what happened
when the flash finished its program or erase cycle?  You’d then want to know
what was happening some distance from your trigger, often a known amount of
time later in relation to the trigger.  In that case, what you want will look
something like Fig 3.&lt;/p&gt;

&lt;table align=&quot;center&quot;&gt;&lt;caption&gt;Fig. 3: A future event&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/scope-future.svg&quot; alt=&quot;Examining logic lines some time in the future&quot; width=&quot;400&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;We can handle all three of these needs by counting a programmable number
of clock cycles from the scope’s trigger until we stop recording (Fig 4.)&lt;/p&gt;

&lt;table align=&quot;center&quot;&gt;&lt;caption&gt;Fig. 4: Trigger Logic&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/scope-trigger.svg&quot; alt=&quot;How the holdoff works&quot; width=&quot;400&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;There remains one other feature we are going to need and that is that we will
need to ensure our memory is initialized before we ever stop recording.
In particular, you really don’t want to find yourself chasing some “bug” in
your design, something that doesn’t make any sense, only to find out later
that the data you were reading from the scope wasn’t valid.  For this
reason, we need make sure all of the scope’s memory is initialized before it can
be triggered.&lt;/p&gt;

&lt;p&gt;This leads to the rough timing diagram shown in Fig 5.&lt;/p&gt;

&lt;table&gt;&lt;caption&gt;Fig. 5: Scope timing&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/simple-scope.svg&quot; alt=&quot;The stages of a scope&#39;s capture&quot; width=&quot;800&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;In particular, following any scope reset, we’ll insist on setting all of the
values in memory before permitting the scope to be triggered.&lt;/p&gt;

&lt;p&gt;Okay, now that we know what we want to do, let’s look into how to do it.&lt;/p&gt;

&lt;h2 id=&quot;filling-the-scope&quot;&gt;Filling the scope&lt;/h2&gt;

&lt;p&gt;The first step to building a scope is to load your data into the scope.  There
are two parts to this.  The first is keeping track of the address you are
writing within your block RAM, and the second part is actually writing to that
memory.  Both parts are quite simple.&lt;/p&gt;

&lt;p&gt;We’ll use a register, &lt;strong&gt;waddr&lt;/strong&gt; to contain the address we wish to write to.
We’ll insist that this address start at zero only so we can tell if the
scope’s memory was ever fully initialized.  This address will quietly wrap
around the limits of the memory, whatever those limits might be, as we write.
We’ll also increment this address every time we receive a valid data sample
until the scope stops.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	if (i_reset)
		waddr &amp;lt;= 0;
	else if ((i_ce)&amp;amp;&amp;amp;(!stopped))
		waddr &amp;lt;= waddr + 1&#39;b1;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Writing to memory is even simpler: On any clock when we’ve got valid data,
we write to the scope’s memory–up until the point where we stop the scope.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	if ((i_ce)&amp;amp;&amp;amp;(!stopped))
		mem[waddr] &amp;lt;= i_data;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;If you’ve never used block RAM within an FPGA before, the various synthesis
tools can be finicky.  In general, if you have too much logic within the same
always block as the memory write, they won’t recognize the block RAM.  That’s
why we keep our memory write logic &lt;em&gt;simple&lt;/em&gt;.  (Ref
&lt;a href=&quot;https://www.xilinx.com/support/documentation/white_papers/wp231.pdf&quot;&gt;[1]&lt;/a&gt;)&lt;/p&gt;

&lt;p&gt;We also write to our memory on every clock up until we are stopped.  This is
how we guarantee that, when we get a trigger, we can have a valid capture of
whatever it was that lead up to the trigger.&lt;/p&gt;

&lt;p&gt;The final piece to our scope’s write logic is the detection of when the scope
was filled.  Since we started the write address at zero, we’ll know we have
filled the scope on the same clock that we both write to it, and write to it
with the address equal to all ones.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	if (i_reset)
		primed &amp;lt;= 1&#39;b0;
	else if ((i_ce)&amp;amp;&amp;amp;(!primed))
		primed &amp;lt;= &amp;amp;waddr;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;With this simple logic, you’ve now created your first
&lt;a href=&quot;https://en.wikipedia.org/wiki/Logic_analyzer&quot;&gt;scope&lt;/a&gt;.  Now let’s look
at how to stop it, and then how to get the results out of it.&lt;/p&gt;

&lt;h2 id=&quot;triggering-the-scope&quot;&gt;Triggering the scope&lt;/h2&gt;

&lt;p&gt;A quick examination of Fig. 4 above should make plain what we wish to do.&lt;/p&gt;

&lt;p&gt;First, from reset until we’ve been triggered, the scope runs and records
normally.  Once we receive a trigger, and only then, do we move on to the
next step.  Hence, we need to know when we’ve been triggered.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	if (i_reset)
		triggered &amp;lt;= 1&#39;b0;
	else if ((i_trigger)&amp;amp;&amp;amp;(primed))
		triggered &amp;lt;= 1&#39;b0;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;You might notice that this trigger doesn’t depend upon &lt;strong&gt;i_ce&lt;/strong&gt;, even though
all of the data reads and writes do.  This was done on purpose so that
any trigger that takes place between &lt;strong&gt;i_ce&lt;/strong&gt;’s will still get noticed by
the scope.&lt;/p&gt;

&lt;p&gt;The next step is to count some programmable number of clocks from the trigger
until we stop.  We’ll call this counter the &lt;strong&gt;holdoff_counter&lt;/strong&gt;, and
we’ll start it counting as soon as we are triggered.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_ck)
	if ((i_reset)||(!triggered))
		holdoff_counter &amp;lt;= 0;
	else if (i_ce)
		holdoff_counter &amp;lt;= holdoff_counter + 1&#39;b1;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Once the holdoff counter reaches the user holdoff, we then set a flag to
indicate we have stopped.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_ck)
	if ((i_reset)||(!triggered))
		stopped &amp;lt;= 0;
	else if ((i_ce)&amp;amp;&amp;amp;(!stopped))
		stopped &amp;lt;= (holdoff_counter &amp;gt;= user_holdoff);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The only tricky part about all of these controls is lining them all up so that
the last data sample is the sample that produced the trigger.  For now, we’ll
leave as an exercise for the student.&lt;/p&gt;

&lt;p&gt;The last step will be to read the results out of your local
&lt;a href=&quot;http://opencores.org/opencores,wishbone&quot;&gt;wishbone bus&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;reading-the-results&quot;&gt;Reading the results&lt;/h2&gt;

&lt;p&gt;When it comes to reading results, there are just a couple of tricks required. 
Most of these are involved with unwrapping the RAM memory, and the rest of
what is required is straight forward.&lt;/p&gt;

&lt;p&gt;Remember how we just wrote to successive memory locations until we stopped?
We’re going to need to unwrap all of that.&lt;/p&gt;

&lt;p&gt;The first step is to calculate the offset we need into the memory array.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	if (i_reset)
		raddr &amp;lt;= 0;
	else if ((i_wb_stb)&amp;amp;&amp;amp;(!i_wb_we)&amp;amp;&amp;amp;(i_wb_addr))
		raddr &amp;lt;= raddr + 1&#39;b1;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;We’ll then add this offset to the write address to get the address we need from
the scope’s memory.  The trick is that this operation has now taken an
extra clock.  If we want to support a throughput of one read per bus clock,
we’re going to need to add one extra unit to keep up with the bus clock.
In other words, we’ll pre-compute the next read address if we are in the middle
of a read, but otherwise have only the offset plus the last write address.&lt;/p&gt;

&lt;p&gt;Will this address calculation wrap around the end of the memory back to the
beginning?  Most definitely.  We are counting upon that.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	if ((i_wb_stb)&amp;amp;&amp;amp;(!i_wb_we)&amp;amp;&amp;amp;(i_wb_addr))
		this_addr &amp;lt;= raddr + waddr + 1&#39;b1;
	else
		this_addr &amp;lt;= raddr + waddr;
end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Now that we have our read address, referenced from the beginning of memory
rather than from the beginning of of the capture we are reporting, we can
now read from the scope’s memory.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	data &amp;lt;= mem[this_addr];&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;As you examine this, remember that block RAM logic is special, whether read or
write–it must
fit the form of what the synthesizer is expecting, or the memory will be
implemented in logic instead of RAM.  It is for that reason that we keep our
memory read as simple as possible and don’t try to merge it with the
output case statement below.&lt;/p&gt;

&lt;p&gt;The final step is to place this value onto the bus.  We hold onto our address
for one clock, so that we can align our data read with the bus request, and
make certain that we are always returning the right value on the right clock.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	last_bus_addr &amp;lt;= i_wb_addr;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;We do the same thing for our acknowledgement line, delaying it for one clock,
to give us time to actually read from the bus.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	pre_ack &amp;lt;= i_wb_stb;
always @(posedge i_clk)
	o_wb_ack &amp;lt;= pre_ack;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Otherwise reading from this scope is just as simple as reading from any
address from any other simple peripheral.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	case(last_bus_addr)
	1&#39;b0: o_wb_data &amp;lt;= { 1&#39;b0, stopped, triggered, 1&#39;b0,
			3&#39;h0, LGMEMLEN, user_holdoff };

	1&#39;b1: o_wb_data &amp;lt;= data;
	endcase&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;That’s it!  There’s not all that much to it.  A scope requires writing to
memory, stopping based upon some trigger, and then reading the data back
out later.  You’ve now seen all of these pieces.&lt;/p&gt;

&lt;h2 id=&quot;zipcpus-wishbone-scope&quot;&gt;ZipCPU’s Wishbone Scope&lt;/h2&gt;

&lt;p&gt;Now that you know how one of these scopes works, and even better how to build
your own, you might wish to check out my own version of a &lt;a href=&quot;https://github.com/ZipCPU/wbscope&quot;&gt;wishbone
scope&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;There are a couple of differences between that my own &lt;a href=&quot;https://github.com/ZipCPU/wbscope&quot;&gt;wishbone
scope&lt;/a&gt;, name wbscope and found on GitHub,
and the scope we’ve just outlined above, although not that many.  Here’s a
quick list of differences:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/ZipCPU/wbscope&quot;&gt;wbscope&lt;/a&gt; allows you to use two
asynchronous clocks, if you need them: one for the data and another
for the bus.&lt;/p&gt;

    &lt;p&gt;I needed this capability when testing the &lt;a href=&quot;https://github.com/ZipCPU/openarty/blob/master/rtl/enetpackets.v&quot;&gt;RMII ethernet
controller&lt;/a&gt;
within the &lt;a href=&quot;https://github.com/ZipCPU/openarty&quot;&gt;OpenArty project&lt;/a&gt; for the
&lt;a href=&quot;http://store.digilentinc.com/arty-artix-7-fpga-development-board-for-makers-and-hobbyists&quot;&gt;Arty board&lt;/a&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Data capture within our &lt;a href=&quot;https://github.com/ZipCPU/wbscope&quot;&gt;wishbone scope&lt;/a&gt;
has been carefully calibrated so that a hold off of zero will place the
trigger in exactly the last location in memory.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The &lt;a href=&quot;https://github.com/ZipCPU/wbscope&quot;&gt;wishbone scope&lt;/a&gt; in the repo adds
a couple extra bus directed capabilities.  These include&lt;/p&gt;

    &lt;p&gt;o an interrupt output for an on-board CPU,&lt;/p&gt;

    &lt;p&gt;o the ability to manually disable the scope’s trigger, or even&lt;/p&gt;

    &lt;p&gt;o the ability to manually trigger the scope from the bus independent of the
  trigger wired into the scope.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;I’ve also built a &lt;a href=&quot;https://github.com/ZipCPU/wbscope/blob/master/rtl/wbscopc.v&quot;&gt;compressed version of the
scope&lt;/a&gt; that
applies
&lt;a href=&quot;https://en.wikipedia.org/wiki/Run-length_encoding&quot;&gt;run length encoding&lt;/a&gt;
to the data, to allow recording events over a long period of time.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Further, there’s even a &lt;a href=&quot;https://github.com/ZipCPU/wbscope/blob/master/rtl/axi4lscope.v&quot;&gt;AXI-lite version of the
scope&lt;/a&gt;, although
since I don’t use the AXI bus, that version has not been tested very much–so
I can’t assure you that it works.&lt;/p&gt;

&lt;h2 id=&quot;next-steps&quot;&gt;Next Steps&lt;/h2&gt;

&lt;p&gt;We’ll still queue up for later how to actually create a
&lt;a href=&quot;http://opencores.org/opencores,wishbone&quot;&gt;wishbone bus master&lt;/a&gt; that can
be commanded from from a local host PC, as well as instructions for how to
turn these results into a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Value_change_dump&quot;&gt;VCD file&lt;/a&gt;
that you can view with &lt;a href=&quot;http://gtkwave.sourceforge.net&quot;&gt;GTKWave&lt;/a&gt;.&lt;/p&gt;

</description>
        <pubDate>Thu, 08 Jun 2017 00:00:00 -0400</pubDate>
        <link>http://zipcpu.com/blog/2017/06/08/simple-scope.html</link>
        <guid isPermaLink="true">http://zipcpu.com/blog/2017/06/08/simple-scope.html</guid>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>Nearest Neighbor Interpolation</title>
        <description>&lt;p&gt;One of the most common things any DSP implementation needs to do is
interpolation.  Here, let’s just discuss how to handle nearest neighbour
interpolation.&lt;/p&gt;

&lt;p&gt;Among all interpolants, the nearest neighbour interpolator is probably the
worst one you could use with respect to signal quality.  Better interpolators
exist: linear interpolation, quadratic interpolation, etc.  These all require
multiplies, careful attention to detail to avoid overflow, and more.  If you
want to build an interpolator, though, the nearest neighbour interpolator
is the place to start learning.&lt;/p&gt;

&lt;p&gt;As you read below, you’ll see why a nearest neighbour interpolator is the
simplest interpolator you could build.&lt;/p&gt;

&lt;h2 id=&quot;problem-setup&quot;&gt;Problem Setup&lt;/h2&gt;

&lt;p&gt;The first step to interpolation is to set up the problem properly.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Your input is an &lt;strong&gt;i_data&lt;/strong&gt; bus which will be valid any time &lt;strong&gt;i_stb&lt;/strong&gt;
is true.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Your output is an &lt;strong&gt;o_data&lt;/strong&gt; bus, together with an &lt;strong&gt;o_stb&lt;/strong&gt; qualifier.
Whenever the &lt;strong&gt;o_stb&lt;/strong&gt; line is true, the &lt;strong&gt;o_data&lt;/strong&gt; bus will have valid
data within it.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;generating-the-output-clock&quot;&gt;Generating the Output Clock&lt;/h2&gt;

&lt;p&gt;The next step is to handle your clock.  Here, you have two options.  You
can generate a &lt;a href=&quot;/blog/2017/06/02/generating-timing.html&quot;&gt;fractional
clock&lt;/a&gt; based upon
your system clock, or you could do the same based upon the input sampling clock.
The two options will look nearly identical.&lt;/p&gt;

&lt;p&gt;Here’s how you would generate your output timing based upon the system clock:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	{ o_stb, counter } &amp;lt;= counter + fractional_system_clock_divider;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;In this case, the &lt;strong&gt;fractional_system_clock_divider&lt;/strong&gt; is given by
two raised to the clock width, times the output clock rate you would like,
divided by the system clock rate.  The units of the two clock rates don’t
matter, just as long as they are consistent.&lt;/p&gt;

&lt;p&gt;And here’s how you would generate the output clock based upon the incoming
sample clock:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	if (i_stb)
		{ o_stb, counter } &amp;lt;= counter + fractional_sample_clock_divider;
	else
		o_stb &amp;lt;= 1&#39;b0;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;In this case, the clock is set nearly identically, but the fractional divider
is instead calculated with respect to the input clock rate, rather than the
output clock rate.&lt;/p&gt;

&lt;h2 id=&quot;handling-the-data-signals&quot;&gt;Handling the Data Signals&lt;/h2&gt;

&lt;p&gt;On every input clock, we create a copy of the data.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	if (i_stb)
		neighbour &amp;lt;= i_data;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;On every output clock, we copy that data to the output.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	if (o_stb)
		o_data &amp;lt;= neighbour;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Might the incoming data change multiple times between the incoming sample and
the outgoing sample?  Yes.  Won’t this cause a problem?  Yes it will.  The
problem this would create is called
&lt;a href=&quot;https://en.wikipedia.org/wiki/Aliasing&quot;&gt;aliasing&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;You can solve the aliasing problem by filtering your input signal before
it comes into the resampler.&lt;/p&gt;

&lt;h2 id=&quot;does-anyone-really-use-this&quot;&gt;Does anyone really use this?&lt;/h2&gt;

&lt;p&gt;Nearest neighbour interpolators have a lot of problems.  It’s not hard to
find or see these problems.  If they are so poor, are they ever used?&lt;/p&gt;

&lt;p&gt;Yes.&lt;/p&gt;

&lt;p&gt;Have I ever used one?&lt;/p&gt;

&lt;p&gt;Yes.&lt;/p&gt;

&lt;p&gt;I used a nearest neighbour interpolator once when I needed to resample a signal
with an 1024/1023 resampler.  To make it work, though, I first insisted that the
signal was oversampled (8x in my case) at the output of the anti-aliasing
filter.  When I later compared the result with a linear interpolator,
the nearest neighbour interpolator worked “good enough” for my application, and
so I dropped the linear interpolator alternative for this simpler one.&lt;/p&gt;

&lt;p&gt;The other place you may see this getting used is in a waveform transmitter
when the input clock is just slower than the output clock.  In this case,
if a new sample isn’t presented to the transmitter by the next sample clock,
the last sample can be repeated.  You can see this approach used in both the
&lt;a href=&quot;https://github.com/ZipCPU/wbpwmaudio/blob/master/rtl/wbpwmaudio.v&quot;&gt;PWM audio&lt;/a&gt;,
and the &lt;a href=&quot;https://github.com/ZipCPU/wbfmtx/blob/master/rtl/wbfmtxhack.v&quot;&gt;FM transmitter
(hack)&lt;/a&gt;
controllers I’ve put together.&lt;/p&gt;

&lt;h2 id=&quot;for-further-study&quot;&gt;For Further Study&lt;/h2&gt;

&lt;p&gt;If you are interested in knowing more about interpolation, you can find a
document describing how to do arbitrary digital interpolation
&lt;a href=&quot;https://github.com/ZipCPU/interpolation/blob/master/interpolation.pdf&quot;&gt;here&lt;/a&gt;.
In this blog, we’ll focus not on the generics of interpolation, but rather on
how to build an interpolator.&lt;/p&gt;

</description>
        <pubDate>Tue, 06 Jun 2017 00:00:00 -0400</pubDate>
        <link>http://zipcpu.com/dsp/2017/06/06/simple-interpolator.html</link>
        <guid isPermaLink="true">http://zipcpu.com/dsp/2017/06/06/simple-interpolator.html</guid>
        
        
        <category>dsp</category>
        
      </item>
    
      <item>
        <title>An Overview of a Wishbone-UART Bridge</title>
        <description>&lt;p&gt;I’ve now tried to write about how to convert a UART stream to a wishbone master
several times over, and … each time the result has been too complex to
explain within a simple blog post.&lt;/p&gt;

&lt;p&gt;So, in good engineering fashion, let’s decompose the problem.  Instead of
presenting an entire wishbone controller, let me instead present you with an
overview of the RTL side of a &lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/rtl/wbubus.v&quot;&gt;working UART to wishbone
bridge&lt;/a&gt; that I’ve
now used for many of my projects.  When we build a new/simpler on this blog,
we’ll need to include many of these design elements, so it’s worth taking a
look at.&lt;/p&gt;

&lt;p&gt;You can see an outline overview of the parts and pieces I’ve used before
in Fig. 1.&lt;/p&gt;

&lt;table style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 1: WB-UART Overview&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/wb-uart-ovw.svg&quot; alt=&quot;Block Diagram of a Working Wishbone to UART converter&quot; width=&quot;240&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;h2 id=&quot;the-transport-end&quot;&gt;The Transport End&lt;/h2&gt;

&lt;p&gt;At the top of this figure are the receiver and transmitter. In this design, the
transport layer is a generic 8-bit interface.&lt;/p&gt;

&lt;p&gt;Because the transport layer is so generic, it can be provided by either a
&lt;a href=&quot;https://github.com/ZipCPU/openarty/blob/master/rtl/toplevel.v&quot;&gt;serial port&lt;/a&gt;,
&lt;a href=&quot;https://github.com/ZipCPU/xulalx25soc/blob/master/rtl/jtagser.v&quot;&gt;JTAG port&lt;/a&gt;,
or even a &lt;a href=&quot;https://store.digilentinc.com&quot;&gt;Digilent&lt;/a&gt; DEPP channel, such as the
&lt;a href=&quot;https://github.com/ZipCPU/s6soc/blob/master/rtl/deppbyte.v&quot;&gt;S6SoC&lt;/a&gt; uses.
Indeed, even my work on the &lt;a href=&quot;https://github.com/ZipCPU/icozip/blob/master/rtl/pptest/pport.v&quot;&gt;ICO
board&lt;/a&gt; will
use a fairly generic 8-bit parallel port interface.&lt;/p&gt;

&lt;p&gt;There’s one additional requirement to this interface, necessary when the
interface runs over something similar to a SPI port: there must be an idle
character.  That way when a character &lt;em&gt;must&lt;/em&gt; be sent, such as when the SPI port
must transmit in order to receive, the idle character can be sent.  To date,
I’ve used an 8’hff for this purpose–but only if I’ve needed it.  That
character can be generated by the transmitter, or quietly dropped in the
receiver.&lt;/p&gt;

&lt;h2 id=&quot;the-bus-master-end&quot;&gt;The Bus Master End&lt;/h2&gt;

&lt;p&gt;On the other end of the UART to wishbone bridge is the &lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/rtl/wbuexec.v&quot;&gt;wishbone bus
master&lt;/a&gt; that
commands the entire bus interface to the chip.  Any peripheral can be hung off
of such a bus:
&lt;a href=&quot;http://opencores.org/project,qspiflash&quot;&gt;flash&lt;/a&gt;,
&lt;a href=&quot;https://github.com/ZipCPU/xulalx25soc/blob/master/rtl/wbsdram.v&quot;&gt;SDRAM&lt;/a&gt;,
&lt;a href=&quot;https://github.com/ZipCPU/wb2axip&quot;&gt;an AXI bus&lt;/a&gt;,
&lt;a href=&quot;https://github.com/ZipCPU/openarty/blob/master/rtl/enetpackets.v&quot;&gt;network interface&lt;/a&gt;,
an LED/switch/button interface,
&lt;a href=&quot;https://github.com/ZipCPU/rtcclock&quot;&gt;real–time clock&lt;/a&gt;,
GPIO,
&lt;a href=&quot;https://github.com/ZipCPU/openarty/blob/master/rtl/wboled.v&quot;&gt;OLEDRgb controller&lt;/a&gt;,
&lt;a href=&quot;https://github.com/ZipCPU/wbuart32/blob/master/rtl/wbuart.v&quot;&gt;UART controller&lt;/a&gt;,
PS/2 mouse controller, and more.&lt;/p&gt;

&lt;p&gt;In this case, the bus master accepts commands in the form of 36-bit words. 
These 36-bit words specify to the bus:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;What address to use (one word),&lt;/li&gt;
  &lt;li&gt;Whether to write one word,&lt;/li&gt;
  &lt;li&gt;Whether to stop writing, or&lt;/li&gt;
  &lt;li&gt;Whether to read multiple words.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The read/write commands also include a bit indicating whether the address
should increment between bus accesses, or whether all of the accesses will
be to the same bus address.&lt;/p&gt;

&lt;p&gt;Three specific capabilities of that can be hung off of this bus are worth
mentioning.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;The first is the &lt;a href=&quot;http://opencores.org/project,qspiflash&quot;&gt;flash controller&lt;/a&gt;.
Because I can control the flash over
a &lt;a href=&quot;https://github.com/ZipCPU/wbuart32&quot;&gt;UART port&lt;/a&gt;, I can read, erase, and
program the flash.  That means that I can reconfigure the entire FPGA over
&lt;a href=&quot;https://github.com/ZipCPU/wbuart32&quot;&gt;UART&lt;/a&gt;.  Even better, if you connect
one of &lt;a href=&quot;https://github.com/ZipCPU/wbicapetwo&quot;&gt;Xilinx’s ICAPE2 interfaces to the
bus&lt;/a&gt;,
you can then load and reload the FPGA’s configuration–without JTAG access.&lt;/p&gt;

    &lt;p&gt;The flash interface itself creates a unique requirement of this bus:  When
writing to the flash, the flash controller uses the end of the wishbone
cycle (CYC line goes low) as the signal to start programming the flash.  For
this reason, when writing a series of values, we cannot drop the wishbone
cycle line (CYC) until the last value is written.  Dropping the CYC line is
then the indication to the flash chip that it can start programming.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Since I’ve spent much of my time building a
   &lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;CPU&lt;/a&gt;, I’m particularly interested in
   being able to start, step, halt, and reboot the
   &lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;CPU&lt;/a&gt; from a debug port controlled by
   this interface.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Finally, for the purposes of this blog, this wishbone interface is useful
because you can now control a 
&lt;a href=&quot;https://github.com/ZipCPU/wbscope&quot;&gt;Wishbone Scope&lt;/a&gt;, whether it be a
&lt;a href=&quot;https://github.com/ZipCPU/wbscope/blob/master/rtl/wbscope.v&quot;&gt;traditional
scope&lt;/a&gt; or an
&lt;a href=&quot;https://github.com/ZipCPU/wbscope/blob/master/rtl/wbscopc.v&quot;&gt;RLE compressed
scope&lt;/a&gt; which
you can then use to debug any other part of your design.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;That’s how powerful the wishbone bus master is.&lt;/p&gt;

&lt;h2 id=&quot;characters-to-bits&quot;&gt;Characters to Bits&lt;/h2&gt;

&lt;p&gt;Since this was my first interface (although now in its 3rd generation), I
needed to be able to read what was going
on.  To accomplish this, I insisted that the interface run over printable
ASCII characters: 0-9, A-Z, a-z, @ and %.  The result is that, if necessary,
I can read the interface by eye and understand what is being sent–although
it does require a (not so secret) decoder ring to do it.&lt;/p&gt;

&lt;p&gt;Newlines are treated as out of band characters, and used to end writes that may
currently be in progress.  This keeps us from using a 6-bit interface.&lt;/p&gt;

&lt;p&gt;Hence, the first level beneath the transport layer
&lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/rtl/wbutohex.v&quot;&gt;converts printable ASCII into 6-bit
words&lt;/a&gt;
and &lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/rtl/wbusixchar.v&quot;&gt;back again&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;This also slows down the speed of the transport, since the transport
layer can handle 8-bit bytes and we’re only using six of those 8-bit bytes.&lt;/p&gt;

&lt;p&gt;Perhaps we can build a better one on this blog as time progresses?&lt;/p&gt;

&lt;h2 id=&quot;assembling-into-lines&quot;&gt;Assembling into lines&lt;/h2&gt;

&lt;p&gt;While perhaps not required, the interface does &lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/rtl/wbucompactlines.v&quot;&gt;assemble responses into
lines&lt;/a&gt;.
To do this, it inserts line breaks at the end of any response, or any time the
line would otherwise overflow.&lt;/p&gt;

&lt;p&gt;From a user’s standpoint, this makes it a lot easier to synchronize your eyes
to the beginning of commands and responses–especially when/if you need to
debug this interface.&lt;/p&gt;

&lt;h2 id=&quot;packing-bytes-into-words&quot;&gt;Packing Bytes into Words&lt;/h2&gt;

&lt;p&gt;Any wishbone bus command requires first knowing whether you wish to read or
write, a bus address, and possible a 32-bit data word.&lt;/p&gt;

&lt;p&gt;To do all of these things, you need to be able to assemble 8-bit bytes into
words that are at least 32-bits in length.  That length is the minimum to hold
a 32-bit data word that you wish to write, but by itself it’s not enough.  The
interface must also be able to indicate the type of transaction that is being
requested.&lt;/p&gt;

&lt;p&gt;In the example we’ve been following, we &lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/rtl/wbureadcw.v&quot;&gt;convert six 6-bit characters into a
36-bit word&lt;/a&gt; and
&lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/rtl/wbudeword.v&quot;&gt;back again&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;While 36-bits works, it may be overkill for what we need.  Perhaps we can
drop this down to a 35-bit word?&lt;/p&gt;

&lt;h2 id=&quot;compression&quot;&gt;Compression&lt;/h2&gt;

&lt;p&gt;UARTs are slow.  Reading an FPGA’s configuration from a flash, so you know
whether or not it needs to be reflashed, over a slow UART link can be &lt;em&gt;painful&lt;/em&gt;.
To speed things up, I added compression to this example bridge.
For reading and writing, we use a simple compression scheme based upon a
table of the most recently sent values.  Addresses get compressed based
upon either the difference between them and the last address, or perhaps just
the low order bits of the address might be sent.&lt;/p&gt;

&lt;p&gt;You can see the table look up and address decoding logic within the
&lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/wbudecompress.v&quot;&gt;decompression
module&lt;/a&gt;, or the
logic to see if a codeword to be sent can be found within
a table lookup
&lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/wbucompress.v&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;resets-and-interrupts&quot;&gt;Resets and Interrupts&lt;/h2&gt;

&lt;p&gt;As a final step, the bus interface needs to handle a couple extra pieces:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;When the bus is idle, the interface should send something periodically so that  you know the FPGA is active on the other end.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;If ever an interrupt occurs, you want that information inserted into the
data stream&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;This logic is captured in the &lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/wbuidleint.v&quot;&gt;idle-int
module&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Finally, you need some form of fault tolerance, so that if a peripheral
doesn’t respond to the bus, the bus can detect that fact, reset the bus,
and return an error across the channel.  We use the same error code for a bus
time out as any generic bus error coming from the bus itself, although
we can usually tell the difference between them.&lt;/p&gt;

&lt;p&gt;This watchdog capability is handled in the &lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/wbubus.v&quot;&gt;top
level&lt;/a&gt; of the UART
to wishbone bridge.&lt;/p&gt;

&lt;h2 id=&quot;performance&quot;&gt;Performance&lt;/h2&gt;

&lt;p&gt;Since this bus communicates reads and writes of 32–bit words packed into
six 8-bit bytes and transmitted over an 8-bit channel, it takes 60 UART baud
cycles (8N1 encoding) to write one word across the bus (ignoring compression).&lt;/p&gt;

&lt;p&gt;If you switch to 7N1 encoding, you can increase your speed by about 10%,
since we were only ever using 7-bits of an 8-bit interface.&lt;/p&gt;

&lt;p&gt;Stick with us and we’ll try to beat this number.  Specifically, if we abandon a
6-bits within 8-bit interface and switch to a full 8-bit interface, we should
be able to get down to about 46 baud per word–a 30% speed increase.&lt;/p&gt;

&lt;p&gt;On the other hand, if we wish to multiplex a console port onto the channel,
we may need to stick with a 7-bit interface.  In that case, perhaps we can
use all seven bits, instead of only 65 of the 128 values?&lt;/p&gt;

&lt;h2 id=&quot;not-shown&quot;&gt;Not Shown&lt;/h2&gt;

&lt;p&gt;What isn’t shown in this diagram is the structure of the &lt;a href=&quot;https://github.com/ZipCPU/openarty/blob/master/sw/host/ttybus.cpp&quot;&gt;C++
software&lt;/a&gt;
necessary to encode and decode words to send across this bus.&lt;/p&gt;

&lt;p&gt;Still, if we can keep the interface to any redesigned bus as simple as the
&lt;a href=&quot;https://github.com/ZipCPU/openarty/blob/master/sw/host/devbus.h&quot;&gt;devbus
interface&lt;/a&gt;
that all of our interface software uses, then any software we’ve already
written to use that interface will need to be relinked with the new interface
library, but no other changes will be required.&lt;/p&gt;

&lt;h2 id=&quot;a-minimal-interface&quot;&gt;A minimal interface&lt;/h2&gt;

&lt;p&gt;On this blog, we’re going to rebuild this interface.  Our goal will be to
design it in a manner so simple that any college student can build one.
This may mean that we throw out any unused or unnecessary parts and pieces.
We’ll also see if we can’t get our newer, better interface to run faster
than this current one.&lt;/p&gt;

&lt;p&gt;The result should be a simpler WB to UART bridge, such as the one shown in
Fig 2.&lt;/p&gt;

&lt;table style=&quot;float: left&quot;&gt;&lt;caption&gt;Fig 2: WB-UART Simplified&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/wb-uart-smpl.svg&quot; alt=&quot;Block Diagram of a Simpler Wishbone to UART converter&quot; width=&quot;360&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Before we can build one of these, though, we’re going to need to spend some
time learning how to build a wishbone bus master — similar to the &lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/rtl/wbuexec.v&quot;&gt;last
one&lt;/a&gt;,
but simpler.  Simple enough that it can be understood by the student,
and simple enough that it requires very few hardware resources.  That lesson
will then inform the rest our work redesigning the interface itself.&lt;/p&gt;
</description>
        <pubDate>Mon, 05 Jun 2017 00:00:00 -0400</pubDate>
        <link>http://zipcpu.com/blog/2017/06/05/wb-bridge-overview.html</link>
        <guid isPermaLink="true">http://zipcpu.com/blog/2017/06/05/wb-bridge-overview.html</guid>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>Campus Sidewalks and FPGA Design</title>
        <description>&lt;p&gt;I once heard a fascinating answer to the question of where to place sidewalks
on campus after building a new building: Wait a year first.  After a year of
using the new building, the students and faculty will have created paths
to and from your new building.  These dirt paths then tell you where to
build your official sidewalks.&lt;/p&gt;

&lt;p&gt;This has been my experience with the &lt;a href=&quot;https://github.com/ZipCPU/wbscope/blob/master/rtl/wbscopc.v&quot;&gt;compressed wishbone
scope&lt;/a&gt; I built
years ago.&lt;/p&gt;

&lt;p&gt;The &lt;a href=&quot;https://github.com/ZipCPU/wbscope/blob/master/rtl/wbscopc.v&quot;&gt;compressed 
scope&lt;/a&gt;
wasn’t my first bus scope.  The &lt;a href=&quot;https://github.com/ZipCPU/wbscope/blob/master/rtl/wbscope.v&quot;&gt;first
scope&lt;/a&gt; was more of
a traditional scope that captured every sample based upon a trigger.  It’s
designed to be a slave on a &lt;a href=&quot;http://opencores.org/opencores,wishbone&quot;&gt;wishbone
bus&lt;/a&gt;, and so it fits nicely as a
component of a design.&lt;/p&gt;

&lt;p&gt;With just a touch of logic, it wasn’t very hard to add a &lt;a href=&quot;https://en.wikipedia.org/wiki/Run-length_encoding&quot;&gt;run-length
compression&lt;/a&gt;
feature to the front end of the &lt;a href=&quot;https://github.com/ZipCPU/wbscope/blob/master/rtl/wbscope.v&quot;&gt;traditional
scope&lt;/a&gt;.
Although this worked okay, it didn’t handle the trigger properly.  I
ignored this problem, and used the compressed scope anyway.&lt;/p&gt;

&lt;p&gt;I used it to debug a &lt;a href=&quot;http://store.digilentinc.com/pmod-gps-gps-receiver/&quot;&gt;GPS
interface&lt;/a&gt;, looking
for where the PPS signal took place with respect to the UART NMEA stream.&lt;/p&gt;

&lt;p&gt;I used it to debug a &lt;a href=&quot;http://opencores.org/opencores,wishbone&quot;&gt;wishbone bus&lt;/a&gt;,
so I could skip the idle times or even times when the slave I was debugging
wasn’t selected.&lt;/p&gt;

&lt;p&gt;More recently, I used it to debug the &lt;a href=&quot;https://github.com/ZipCPU/wbi2c&quot;&gt;I2C
portion&lt;/a&gt; of an HDMI interface.&lt;/p&gt;

&lt;p&gt;In all of these, the
&lt;a href=&quot;https://github.com/ZipCPU/wbscope/blob/master/rtl/wbscopc.v&quot;&gt;compressed scope&lt;/a&gt;
proved its worth particularly for slow
interfaces where the scope would allow longer snapshots than could fit in block
memory.  Indeed, I’m not sure I could have debugged these interfaces without a
&lt;a href=&quot;https://github.com/ZipCPU/wbscope/blob/master/rtl/wbscopc.v&quot;&gt;compressed scope&lt;/a&gt;.
But, now that I’ve done so, I’ve learned enough to go
back and add in some necessary features.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;The &lt;a href=&quot;https://github.com/ZipCPU/wbscope/blob/master/rtl/wbscopc.v&quot;&gt;scope&lt;/a&gt;
needs to have a known trigger point.  Given the output stream,
and the holdoff you configured the scope with, you should be able to know
exactly where the trigger will be in that output stream.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;If nothing is changing, the
&lt;a href=&quot;https://github.com/ZipCPU/wbscope/blob/master/rtl/wbscopc.v&quot;&gt;scope&lt;/a&gt;
should have a maximum run length, so that
it doesn’t lock up and give you no information.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The last piece of memory within the
&lt;a href=&quot;https://github.com/ZipCPU/wbscope/blob/master/rtl/wbscopc.v&quot;&gt;scope&lt;/a&gt;’s
buffer must be a data point, even if it was part of a run.  It cannot be
left as part of a run.  This is a necessary part of knowing exactly where,
within the buffer, the trigger took place.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;As with the
&lt;a href=&quot;https://github.com/ZipCPU/wbscope/blob/master/rtl/wbscope.v&quot;&gt;regular scope&lt;/a&gt;,
the
&lt;a href=&quot;https://github.com/ZipCPU/wbscope/blob/master/rtl/wbscopc.v&quot;&gt;compressed scope&lt;/a&gt;
should have the option for working off of both a data clock and a bus clock.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Timing is important.  Working at high speed is valuable.  The debugger
(i.e. scope) must be able to keep up with your logic when your logic is at
high speed.  This means that all debug/scope logic should be broken up into
pieces small enough to run at the highest speed necessary.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Hence, I just laid my metaphorical sidewalks, and rebuilt the 
&lt;a href=&quot;https://github.com/ZipCPU/wbscope/blob/master/rtl/wbscopc.v&quot;&gt;compressed scope&lt;/a&gt;
according to my needs–now that I knew what they were.&lt;/p&gt;

&lt;p&gt;If you have a &lt;a href=&quot;http://opencores.org/opencores,wishbone&quot;&gt;wishbone bus&lt;/a&gt; within
your design, then feel free to try it out and let me know how (or if) it works
for you.&lt;/p&gt;

&lt;p&gt;If you don’t have a wishbone bus within your design, then &lt;a href=&quot;/topics.html&quot;&gt;stick
around&lt;/a&gt; and we’ll discuss how to build one.&lt;/p&gt;

</description>
        <pubDate>Sat, 03 Jun 2017 00:00:00 -0400</pubDate>
        <link>http://zipcpu.com/blog/2017/06/03/building-sidewalks.html</link>
        <guid isPermaLink="true">http://zipcpu.com/blog/2017/06/03/building-sidewalks.html</guid>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>Controlling Timing within an FPGA</title>
        <description>&lt;p&gt;Within an FPGA, everything is based upon event based timing.  SPI controllers
require a logic generated clock, I2C controllers have some maximum limit they
can communicate at, UART controllers run at some user defined baud rate …
everything wants to communicate at a carefully controlled speed.&lt;/p&gt;

&lt;p&gt;Here we’ll discuss a couple ways to create the timing you need.&lt;/p&gt;

&lt;h2 id=&quot;the-power-of-two-clock-divider&quot;&gt;The Power of Two Clock Divider&lt;/h2&gt;

&lt;p&gt;The first approach I will use to timing events is usually a clock divider.
It’s just too simple and too easy to build to ignore.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;reg	[(N-1):0]	counter;
always @(posedge i_clk)
	counter &amp;lt;= counter + 1&#39;b1;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Using this approach, your clock will be nicely divided by an even 2^N.
Hence, if you attach an LED to &lt;strong&gt;counter[(N-1)]&lt;/strong&gt; you’ll have the slower clock
you need.&lt;/p&gt;

&lt;h2 id=&quot;the-simple-clock-divider&quot;&gt;The Simple Clock Divider&lt;/h2&gt;

&lt;p&gt;A very common beginners task is to create a 1kHz, 100Hz, or even a 10 Hz clock
from your input clock.  Since these are not the result of dividing your clock
by 2^N, a different approach is necessary.&lt;/p&gt;

&lt;p&gt;Suppose for example that your system clock were at 100MHz.  You’d then need to
divide it by 10M if you wanted to get a 10Hz clock.  This is easily done with
a more generic clock divider circuit.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;reg	[(N-1):0]	counter;
always @(posedge i_clk)
	if (counter &amp;lt; THRESHOLD-1&#39;b1)
		counter &amp;lt;= counter + 1&#39;b1;
	else
		counter &amp;lt;= 0;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;As before, you can then use &lt;strong&gt;counter[N-1]&lt;/strong&gt; as an LED driver, and you will
have divided your clock by whatever value you set THRESHOLD to be.&lt;/p&gt;

&lt;h2 id=&quot;the-strobe-signal&quot;&gt;The Strobe Signal&lt;/h2&gt;

&lt;p&gt;The problem with the simple clock dividers above is that the clock signal is N
bits wide, and the top bit may be one for many clocks and zero for many clocks.
How shall you make your logic work only once in all those clocks?&lt;/p&gt;

&lt;p&gt;As a first rule, &lt;em&gt;do not drive your logic like this&lt;/em&gt;:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge counter[N-1])
	begin
		// DON&#39;T DO THIS
	end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This will cause you all kinds of grief, either leading you to an unreliable
design, or forcing you to deal with multiple clock domains, clock domain
transfers, and worse.  Unless you really know what you are doing … don’t
use this approach.&lt;/p&gt;

&lt;p&gt;When I first started building FPGA designs, I would check for zero within
whatever state machine logic I had that was going to rely upon my new clock.
As a result, I tended to use something like this instead:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	if (counter == 0)
	begin
		// Don&#39;t do this
	end else if (some_other_condition)
	begin
		// Other logic goes here
	end else if ...&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;My problem was that I then needed to come back later and rebuild all this
logic.  While it worked, it required more LUTs than was actually necessary, and
it couldn’t be clocked at any high speed.&lt;/p&gt;

&lt;p&gt;So … don’t do it this way either.&lt;/p&gt;

&lt;p&gt;One way to understand the problem with this approach is to count the cost of
your logic.  This cost may be estimated by
the number of inputs necessary to create any of your logic registers. 
The larger the number of inputs, the more LUTs will be required to implement
it, the slower the logic will take.  Having
an N-bit wide clock driving a lot of logic just adds N-1 unnecessary bits to
complicate things.  As a result, while this approach will work (and did for me
for many years), it’ll only work for FPGA logic with a slow &lt;strong&gt;i_clk&lt;/strong&gt;
frequency.&lt;/p&gt;

&lt;p&gt;The better alternative is even simpler, and there’s no reason not to use it.&lt;/p&gt;

&lt;p&gt;Instead of testing for (counter == 0) within your logic, create a
strobe signal.  We’ll call our strobe signal &lt;strong&gt;ck_stb&lt;/strong&gt;:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	ck_stb &amp;lt;= (counter == THRESHOLD-1&#39;b1);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;What makes this signal so useful is that it will only ever be on for one clock
period at a time, and that one clock period will be the period that you need to
do something.  As a result, you will then only need to check whether or not
&lt;strong&gt;ck_stb&lt;/strong&gt; is true whenever you need to do something, rather than all
&lt;strong&gt;N&lt;/strong&gt; bits of &lt;strong&gt;counter&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;The next step is to build your logic so that it transitions on this strobe:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	if (ck_stb)
	begin
		// Build your logic this way instead
	end else if (some_other_condition)
	begin
	end else if ...&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;You can find an example of this within my &lt;a href=&quot;https://github.com/ZipCPU/wbuart32/tree/master/rtl&quot;&gt;WBUART cores&lt;/a&gt;.  Look for the variables &lt;strong&gt;baud_counter&lt;/strong&gt;
and &lt;strong&gt;zero_baud_counter&lt;/strong&gt; within either the transmitter or receiver
modules.&lt;/p&gt;

&lt;h2 id=&quot;the-fractional-clock-divider&quot;&gt;The Fractional Clock Divider&lt;/h2&gt;

&lt;p&gt;What if you need to divide your clock by 3.1415926535…?  Not a problem.
You can accomplish this using a fractional clock divider.  The result will
look something like:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;reg	[15:0]	counter;
always @(posedge i_clk)
	{ ck_stb, counter } &amp;lt;= counter + 16&#39;h517d;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Ok, so … there’s a couple pieces to doing this that are worth discussing in order to understand it.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;How does this work?  Well, consider what happens after 2^16 clocks … you’ll have 16’h517d transitions.  Hence, you’ve divided your clock by 16’h517d or &lt;em&gt;about&lt;/em&gt; by pi.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The &lt;strong&gt;ck_stb&lt;/strong&gt; signal will be set anytime this counter rolls over.  Because &lt;strong&gt;ck_stb&lt;/strong&gt; isn’t used to calculate the next counter, but only used as the output of this equation, &lt;strong&gt;ck_stb&lt;/strong&gt; becomes a logic signal you can use to drive your logic at the rate you want.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Notice that this clock register is 16 bits wide rather than N-bits wide.  Because of how the clock width couples with the fractional division number, I had to make this width a constant instead of a generic.  You can still change it to whatever you need it to be.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;As for the 16’h517d, this number is given by 2^16 divided by PI.  Where does the 16 come from?  It’s the width of your counter.  Does it need to be 16?  The more bits you have, the closer you’ll get to the actual frequency you wish to create.  I’ve often used 48-bits within my &lt;a href=&quot;https://github.com/ZipCPU/rtcclock&quot;&gt;Real-Time Clock Core&lt;/a&gt;, but what you choose should be a matter of your design needs and choices.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;You can also use the &lt;strong&gt;ck_stb&lt;/strong&gt; signal within your code to do things every 1/pi’th clock, just like we used the &lt;strong&gt;ck_stb&lt;/strong&gt; before.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;What if you need to generate an actual clock signal, and not just a clocked strobe?  You can use the top bit of this counter as a clock signal that you can send to peripherals if you need to.  Just … don’t use it as a clock signal within your own logic unless you really know what you are doing.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;What is the actual clock period of this clock?  Well, because we are dividing by PI, you will find either three or four ticks between &lt;strong&gt;ck_stb&lt;/strong&gt; signals, never more, never less.  This is going to create some &lt;em&gt;phase noise&lt;/em&gt; in your &lt;em&gt;clock&lt;/em&gt;.  It can cause problems with some systems, so make sure you check the spec of whatever system you might be working with in order to know what is acceptable.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;You can find a simple example of this fractional divider in &lt;a href=&quot;https://github.com/ZipCPU/icozip/blob/master/rtl/basic/clktest.v&quot;&gt;this version of
blinky&lt;/a&gt; for
the &lt;a href=&quot;http://icoboard.org&quot;&gt;ICO board&lt;/a&gt;.  I used this code to test and measure the
speed of the input clock to my &lt;a href=&quot;http://icoboard.org&quot;&gt;ICO board&lt;/a&gt;.  By using
this approach, I was able to prove that the incoming clock was 100MHz, as
opposed to the 25MHz oscillator listed in the schematic (Oops!).&lt;/p&gt;

&lt;p&gt;As a fun example, I used this same fractional clock generator approach to
create a &lt;a href=&quot;https://github.com/ZipCPU/wbfmtxhack&quot;&gt;single bit FM signal&lt;/a&gt; that I
then “transmitted” out of my GPIO ports.  Sure, it was an ugly signal, but it
was enough to lock a FM receiver to it and listen to Queen on “the radio”.&lt;/p&gt;

&lt;h2 id=&quot;the-divided-counter&quot;&gt;The Divided Counter&lt;/h2&gt;

&lt;p&gt;If your counter is so long that you can’t meet timing, there’s usually no cost
to splitting the counter into a higher word and a lower word:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;reg	low_stb, ck_stb;
reg	[(N-1):0]	low_counter, hi_counter;
always @(posedge i_clk)
	{ low_stb, low_counter } &amp;lt;= low_counter + 1&#39;b1;
always @(posedge i_clk)
	if (low_stb)
		{ ck_stb, counter } &amp;lt;= counter + 1&#39;b1;
	else
		ck_stb &amp;lt;= 1&#39;b0;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Sure, the two words may not be synchronized, but … this is still a very
doable approach.&lt;/p&gt;

&lt;h2 id=&quot;the-divided-fractional-clock-divider&quot;&gt;The Divided Fractional Clock Divider&lt;/h2&gt;

&lt;p&gt;What if you are using a fractional divider?  If you can’t meet timing with your fractional division clock, you can also divide that one into two words, both upper and lower:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;reg	[(N-1):0]	low_counter, hi_counter;
always @(posedge i_clk)
	{ low_pps, low_counter } &amp;lt;= low_counter + LOW_STEP;
always @(posedge i_clk)
	{ ck_stb, counter } &amp;lt;= counter + HIGH_STEP + low_pps;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;As before, the two counters are not in lock step with each other.  If you want to actually have a synchronized timer, you might need to delay the lower counter ‘till they line up:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;reg	[(N-1):0]	low_counter, hi_counter, dly_counter;
wire	[(2\*N-1):0]	full_counter;
always @(posedge i_clk)
	{ low_pps, low_counter } &amp;lt;= low_counter + LOW_STEP;
always @(posedge i_clk)
	dly_counter &amp;lt;= low_counter;
always @(posedge i_clk)
	{ ck_stb, counter } &amp;lt;= counter + HIGH_STEP + low_pps;
assign	full_counter = { counter, dly_counter };&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;As you can see from the many different examples above, dividing your input clock down to a rate that you can then use for your logic is fairly easy.  Given the many ways of doing this wrong, we have now at least showed you several methods for doing this “right”.&lt;/p&gt;

&lt;p&gt;Try it!  Let me know how these techniques work for you.&lt;/p&gt;
</description>
        <pubDate>Fri, 02 Jun 2017 00:00:00 -0400</pubDate>
        <link>http://zipcpu.com/blog/2017/06/02/generating-timing.html</link>
        <guid isPermaLink="true">http://zipcpu.com/blog/2017/06/02/generating-timing.html</guid>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>The Actual FPGA Design Process</title>
        <description>&lt;p&gt;As I’ve been watching students and others request help on the &lt;a href=&quot;https://forum.digilentinc.com&quot;&gt;Digilent
Forums&lt;/a&gt;, it has become apparent to me that
there’s quite a difference between the design process college students are using
and the one reality has driven me to.&lt;/p&gt;

&lt;p&gt;Perhaps pointing this out will serve as a warning to the young FPGA engineer
to start their task early, and to not underestimate the amount of work
required.&lt;/p&gt;

&lt;h2 id=&quot;the-students-fpga-design-process&quot;&gt;The Student’s FPGA Design Process&lt;/h2&gt;

&lt;p&gt;Most of the student’s I’ve seen on the forum show up about a week before
their project is due.  They want to get things done quickly, and they want
to take the fastest path they can take to get to the goal. 
Indeed, they are following the design process shown in Fig. 1.&lt;/p&gt;

&lt;table style=&quot;float: right&quot;&gt;&lt;caption&gt;Figure 1: The Student&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/student-design-process.svg&quot; alt=&quot;Student FPGA Design Process Figure&quot; width=&quot;140&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;ol&gt;
  &lt;li&gt;The student builds his design in Verilog&lt;/li&gt;
  &lt;li&gt;He then implements it on an FPGA, adjusting his design as necessary to meet
timing and build requirements&lt;/li&gt;
  &lt;li&gt;The design is then placed onto the FPGA for a test, and …&lt;/li&gt;
  &lt;li&gt;The student can’t figure out why it isn’t working.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Perhaps these students are coming from the software world.  When I program
software, I can usually debug a program using the “debug by printf” method.
If things get difficult, moving to the debugger is easy.  Either way, at any
point in my program, I can look at and examine any variable at any time and
understand what is going on within it.&lt;/p&gt;

&lt;p&gt;If you expect to do this with hardware, and particularly with FPGA’s, you are
going to end up with the other students in your class at the end of the semester
wondering what happened.  You just don’t get that much visibility into an FPGA
design.&lt;/p&gt;

&lt;p&gt;Plan for it.&lt;/p&gt;

&lt;h2 id=&quot;the-experts-design-process&quot;&gt;The Expert’s Design Process&lt;/h2&gt;

&lt;p&gt;Now, if you instead turn around and ask an expert about their design process,
they will discuss something like Fig. 2 with you.&lt;/p&gt;

&lt;table style=&quot;float: right&quot;&gt;&lt;caption&gt;Figure 2: The Expert&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img width=&quot;240&quot; src=&quot;/img/expert-design-process.svg&quot; alt=&quot;The Expert&#39;s FPGA Design Process Figure&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;If you don’t have an instructor, you have to find the specifications for
whatever chip you are going to work with.  This applies to both the FPGA’s
you work with, as well as any peripherals.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Once you think you understand how the device you wish to interface with
works, you’ll build your design to interface with that device.&lt;/p&gt;

    &lt;p&gt;I make
a particular point at this stage in my design process to document, at the
top of any Verilog files I build, how that Verilog file is going to connect
to the rest of any design.  While all of my files tend to use the
&lt;a href=&quot;http://opencores.org/opencores,wishbone&quot;&gt;Wishbone Bus&lt;/a&gt;,
I still need to define the various registers on that bus, as well
as what each of the bits within those registers means, whether the registers
are read/write, etc.&lt;/p&gt;

    &lt;p&gt;As I build my design, these become my notes and
reference.  I keep them up to date–especially before any spec sheet is ever
written.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The next step is to build a simulator for the device.  This will allow your
simulated logic to think it is talking to the actual device.&lt;/p&gt;

    &lt;p&gt;Have I skipped this step before?  Absolutely!  What was the result?  I’ve
almost always had to come back, retrace my steps, and build this simulator.
(I’m currently needing to do that with an HDMI interface I’m building.)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Once you have your logic, and a simulator in place, you can now build a test
bench that will exercise your logic against the simulator and see whether
or not your logic works.&lt;/p&gt;

    &lt;p&gt;Have I skipped this step before?  You bet!  The result?  I just got burned
this last week.&lt;/p&gt;

    &lt;p&gt;The story has to do with a &lt;a href=&quot;http://opencores.org/project,qspiflash&quot;&gt;flash
controller&lt;/a&gt; I had built.
I was recently trying to squeeze every last LUT out of my
&lt;a href=&quot;https://github.com/ZipCPU/s6soc&quot;&gt;S6SoC design&lt;/a&gt;, and
made changes to it.  I then changed it in another design, and again, and
eventually I had four different flash controllers and couldn’t tell which
worked and which didn’t.  I needed a test bench to prove that my changes
still left me with a working controller.&lt;/p&gt;

    &lt;p&gt;I had no choice, but to backtrack and build the test bench I should’ve built
in the first place.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Only after things work on the test bench, will the expert place them onto
the FPGA.  Changes made in this process (usually because something just
doesn’t quite meet timing) will still be validated through the
simulator and the test bench.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Then the expert applies his design for its first Hardware in the Loop (HITL)
test.  If the hardware he’s working with doesn’t match his simulation,
he goes back and adjusts the simulation, his design, and the test bench.&lt;/p&gt;

    &lt;p&gt;If I can, I like to use the same software for bench testing as I do for
hardware in the loop testing.  While this is not always possible, it can be
used to save a step … if you can.  That’s actually the reason why I like
to use a &lt;a href=&quot;https://github.com/ZipCPU/openarty/blob/master/sw/host/netuart.cpp&quot;&gt;TCP/IP
connection&lt;/a&gt; to connect to my boards–because you can never
tell, then, whether you are connecting to the real thing or a simulation.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Only after any design passes unit testing, is it fully integrated with the
rest of whatever the expert wishes to do.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Finally, the entire unit is tested as a whole.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The expert will also firmly scold the student for not following this form
exactly.  Sorry, students, it always happens.&lt;/p&gt;

&lt;h2 id=&quot;the-actual-design-process&quot;&gt;The Actual Design Process&lt;/h2&gt;

&lt;p&gt;The problem with this description of the expert’s design process is that the
expert isn’t telling the whole story.&lt;/p&gt;

&lt;table style=&quot;float: right&quot;&gt;&lt;caption&gt;Figure 3: Reality&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img width=&quot;400&quot; src=&quot;/img/actual-design-process.svg&quot; alt=&quot;What the Expert actually does&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Because this isn’t his first design, he has already built up a small library
of routines–most of them surrounding how to communicate with an FPGA and how
to get diagnostics from the FPGA.  Indeed, his design flow is perhaps more
appropriately characterized by Fig 3.&lt;/p&gt;

&lt;p&gt;The result is that the expert can draw values and hence insights from the logic
running within the FPGA, while the student is still stuck wondering what
happened.&lt;/p&gt;

&lt;p&gt;In my case, this scaffolding consists of both my
open source &lt;a href=&quot;https://github.com/ZipCPU/wbscope&quot;&gt;Wishbone Scope&lt;/a&gt; that works 
with &lt;a href=&quot;https://gtkwave.sourceforge.net&quot;&gt;GTK Wave&lt;/a&gt;, and 2) my open source
&lt;a href=&quot;https://github.com/ZipCPU/openarty/blob/master/rtl/wbubus.v&quot;&gt;UART to wishbone&lt;/a&gt;
converter which gives you access to that
&lt;a href=&quot;http://opencores.org/opencores,wishbone&quot;&gt;Wishbone Bus&lt;/a&gt;, to include the 
&lt;a href=&quot;https://github.com/ZipCPU/wbscope&quot;&gt;wishbone scope&lt;/a&gt; that I place on that bus.
Of course, when I first started I didn’t have
&lt;a href=&quot;https://gtkwave.sourceforge.net&quot;&gt;GTK Wave&lt;/a&gt; support–but that just illustrates
how an expert’s toolset can grow to become more useful over time.&lt;/p&gt;

&lt;h2 id=&quot;what-the-student-should-have-done&quot;&gt;What the Student should have done&lt;/h2&gt;

&lt;p&gt;What the student should have done was to take some time, between the simple
&lt;a href=&quot;/blog/2017/05/19/blinky.html&quot;&gt;blinky&lt;/a&gt; and
&lt;a href=&quot;/blog/2017/05/24/serial-port.html&quot;&gt;UART&lt;/a&gt;
projects but before the more complex projects, to build some scaffolding.
Specifically, he needs to build a means of evaluating logic from within the
FPGA, and of learning how to discover whether or not the device he’s working
with responds the way he thinks it should or not.&lt;/p&gt;

&lt;p&gt;The typical curricula doesn’t lead the student to this approach.
Instead, the typical curricula works from
&lt;a href=&quot;/blog/2017/05/19/blinky.html&quot;&gt;blinky&lt;/a&gt; to more and more
complex projects, but never focuses on how to build scaffolding out of these
projects that is necessary to be truly competent at the more complex tasks.&lt;/p&gt;

&lt;p&gt;The problem with this approach is that 1) few students know that this is a
requirement on their road to success, and 2) few students allocate time for
failure along the way.&lt;/p&gt;

&lt;p&gt;This is why student’s stumble on their complex FPGA design projects.&lt;/p&gt;

&lt;p&gt;If this has been your experience, please write to me.  I’d love to share any
lessons you’ve learned from your design projects here on this blog.&lt;/p&gt;
</description>
        <pubDate>Fri, 02 Jun 2017 00:00:00 -0400</pubDate>
        <link>http://zipcpu.com/blog/2017/06/02/design-process.html</link>
        <guid isPermaLink="true">http://zipcpu.com/blog/2017/06/02/design-process.html</guid>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>Building a simple wishbone slave</title>
        <description>&lt;p&gt;If you’ve never written bus logic before, the
&lt;a href=&quot;http://opencores.org/opencores,wishbone&quot;&gt;wishbone bus&lt;/a&gt; is a good place to
start.  Although other busses have more features to them, 
the &lt;a href=&quot;http://opencores.org/opencores,wishbone&quot;&gt;wishbone bus&lt;/a&gt; can be simplified
into an extremely easy bus to work with.&lt;/p&gt;

&lt;p&gt;For our purpose, we’ll be using the
&lt;a href=&quot;http://opencores.org/cdn/downloads/wbspec_b4.pdf&quot;&gt;B4 version of the specification&lt;/a&gt;,
and specifically the pipelined mode within it.&lt;/p&gt;

&lt;h2 id=&quot;wishbone-bus-components&quot;&gt;Wishbone bus components&lt;/h2&gt;

&lt;p&gt;The first step, though, is to simplify the wishbone bus for our discussion.
As with the other logic I have presented, I prefix ports with &lt;strong&gt;i_&lt;/strong&gt; if they
are inputs, and &lt;strong&gt;o_&lt;/strong&gt; if they are outputs.  Further, because these inputs
and outputs to our bus slave are wishbone connected, I’ll adjust their
prefixes to read &lt;strong&gt;i_wb_&lt;/strong&gt; for inputs and &lt;strong&gt;o_wb_&lt;/strong&gt; for outputs.&lt;/p&gt;

&lt;p&gt;Using this notation, the
&lt;a href=&quot;http://opencores.org/cdn/downloads/wbspec_b4.pdf&quot;&gt;wishbone specification&lt;/a&gt;
defines the following wires from the perspective of a slave:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;i_wb_cyc&lt;/strong&gt; is true any time a wishbone transaction is taking place.  It
 needs to become true on (or before) the first &lt;strong&gt;i_wb_stb&lt;/strong&gt; clock,
 and generally stays true until the last &lt;strong&gt;o_wb_ack&lt;/strong&gt;.&lt;/p&gt;

    &lt;p&gt;We’re going to assume that the &lt;strong&gt;i_wb_cyc&lt;/strong&gt; line is high during our
 transaction, and that the logic necessary to insure this has already been
 taken care of within the bus master.  Therefore, we’ll ignore this wire.&lt;/p&gt;

    &lt;p&gt;Incidentally, the &lt;a href=&quot;http://opencores.org/cdn/downloads/wbspec_b4.pdf&quot;&gt;specification&lt;/a&gt;
 isn’t clear regarding whether or not this signal can be ignored by the slave.
 (It cannot be ignored by the interconnect …)  If you
 are dealing with a master you aren’t certain of, you can &lt;em&gt;and&lt;/em&gt; your
 &lt;strong&gt;i_wb_stb&lt;/strong&gt; line with your &lt;strong&gt;i_wb_cyc&lt;/strong&gt; signal and do just as well.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;i_wb_stb&lt;/strong&gt; is true for any bus transaction request.  While &lt;strong&gt;i_wb_stb&lt;/strong&gt;
 is true, the other wishbone slave inputs (&lt;strong&gt;i_wb_we&lt;/strong&gt;, &lt;strong&gt;i_wb_addr&lt;/strong&gt;,
 &lt;strong&gt;i_wb_data&lt;/strong&gt;, and &lt;strong&gt;i_wb_sel&lt;/strong&gt;) are valid and reference the same
 transaction.  The transaction is accepted by the slave any time
 &lt;strong&gt;i_wb_stb&lt;/strong&gt; is true at the same time as &lt;strong&gt;o_wb_stall&lt;/strong&gt; is false.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;i_wb_we&lt;/strong&gt; is true for any write requests&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;i_wb_addr&lt;/strong&gt; contains the address of the request&lt;/p&gt;

    &lt;p&gt;From the perspective of
 the wishbone slave that we are working with, this address contains only the
 address lines of relevance to the slave.  Hence, while the bus may have 32
 address lines, the slave might only be interested in might have anywhere
 between no address lines and all 32 address lines.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;i_wb_data&lt;/strong&gt; contains the data we wish to write.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;o_wb_ack&lt;/strong&gt; is a response from the slave, indicating that the request has
 been completed.  For every request given to the slave, there must be one
 and only one clock cycle with &lt;strong&gt;o_wb_ack&lt;/strong&gt; high&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;o_wb_stall&lt;/strong&gt; is used to control the flow of data into the slave.  It will
 be true on any cycle when the master &lt;em&gt;cannot&lt;/em&gt; accept data from the slave,
 and false any time data can be accepted.  This allows the slave to control
 the flow of requests being given to it.&lt;/p&gt;

    &lt;p&gt;For our simple example, we’ll just set this line to zero.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;o_wb_data&lt;/strong&gt; is the data returned by the slave to the bus master as a 
 result of any read request.  It is valid whenever &lt;strong&gt;o_wb_ack&lt;/strong&gt; is true,
 and it’s value may be ignored any time &lt;strong&gt;o_wb_ack&lt;/strong&gt; is false.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;While &lt;a href=&quot;http://opencores.org/cdn/downloads/wbspec_b4.pdf&quot;&gt;the spec&lt;/a&gt;,
defines other wires that may be a part of this interface, we’ll ignore these
and instead focus on the minimum required logic
necessary to get a simplified demonstration up and running.&lt;/p&gt;

&lt;h2 id=&quot;writes-to-the-slave&quot;&gt;Writes to the slave&lt;/h2&gt;

&lt;p&gt;You may remember from our discussion on how to write to a 
&lt;a href=&quot;/zipcpu/2017/05/23/simplebus.html&quot;&gt;very simple bus&lt;/a&gt; that we based all of
our logic off of an &lt;strong&gt;i_wr&lt;/strong&gt; line.  Whenever this line was true, we would
read from the bus.  As a review,
the &lt;a href=&quot;/zipcpu/2017/05/23/simplebus.html&quot;&gt;simple bus&lt;/a&gt; write logic was written as,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	if (i_wr)
		memory[i_addr] &amp;lt;= i_data;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Moving from this simple example to the wishbone is quite easy.  In particular,
&lt;em&gt;all&lt;/em&gt; we need to do is to adjust the &lt;strong&gt;i_wr&lt;/strong&gt; logic for the wishbone bus.
Once done, the interaction should look identical:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	if ((i_wb_stb)&amp;amp;&amp;amp;(i_wb_we)&amp;amp;&amp;amp;(!o_wb_stall))
	begin
		// Your write logic here, such as
		// memory[i_addr] &amp;lt;= i_data;
	end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Simple, huh?&lt;/p&gt;

&lt;h2 id=&quot;reads-from-the-slave&quot;&gt;Reads from the slave&lt;/h2&gt;

&lt;p&gt;Reading from the port is fairly easy as well.  The first step is to create a
response for every address given to us, as we did before.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	//
	// Basically o_wb_data &amp;lt;= memory[i_wb_addr];
	//
	// If you aren&#39;t implementing a memory, your
	// result will instead look like ...
	case(i_wb_addr)
	4&#39;h0: o_wb_data &amp;lt;= some_register;
	// ...
	default: o_wb_data &amp;lt;= some_default response;
	end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;One more step is required for both reading and writing: we need to return an
acknowledgement back to the bus that this transaction has been completed, and
that the data on the bus is now valid.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	o_wb_ack &amp;lt;= ((i_wb_stb)&amp;amp;&amp;amp;(!o_wb_stall));&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;For some peripherals, the answer is known before you request it.  In that
case, you might just &lt;em&gt;assign&lt;/em&gt; the &lt;strong&gt;o_wb_ack&lt;/strong&gt; signal instead of waiting for
the positive edge of the clock.&lt;/p&gt;

&lt;p&gt;Other peripherals may need to delay the acknowledgement by another clock.  Two examples of this would be the &lt;a href=&quot;https://github.com/ZipCPU/wbscope&quot;&gt;wishbone scope&lt;/a&gt; and the &lt;a href=&quot;https://github.com/ZipCPU/wbuart/blob/master/wbuart.v&quot;&gt;wbuart serial port&lt;/a&gt; controller.  Both of these examples require one clock to calculate an output,
and then another clock to select between possible outputs.&lt;/p&gt;

&lt;p&gt;The other key piece to any wishbone interaction is the stall line.  For our
simple interaction, we’ll just hold this line zero.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;assign	o_wb_stall = 1&#39;b0;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;What that means is that we are able to accept a wishbone request on every
clock cycle, and that our transaction rate will be as fast as the clock rate.
This works well for many peripherals, although some peripherals such as
&lt;a href=&quot;http://opencores.org/project,qspiflash&quot;&gt;flash&lt;/a&gt;
or &lt;a href=&quot;http://github.com/ZipCPU/xulalx25/blob/master/rtl/wbsdram.v&quot;&gt;SDRAM&lt;/a&gt; may
need to adjust this line if they cannot accept a new request every
clock cycle.&lt;/p&gt;

&lt;h2 id=&quot;what-if-you-can-only-accept-requests--sometimes&quot;&gt;What if you can only accept requests … sometimes?&lt;/h2&gt;

&lt;p&gt;So … what if your peripheral cannot accept requests on every clock cycle?&lt;/p&gt;

&lt;p&gt;Here’s an example set of logic where the peripheral starts a state machine
upon any request, and only returns a result once the state machine becomes
idle.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;reg	busy;

always @(posedge i_clk)
	if ((i_wb_stb)&amp;amp;&amp;amp;(!o_wb_stall))
	begin
		state &amp;lt;= SOME_NEW_STATE;
		local_data &amp;lt;= i_wb_data;
		busy &amp;lt;= 1&#39;b1;
	end else case(state)
	SOME_NEW_STATE: begin
		// Your logic here ...
		if (some_condition)
			state &amp;lt;= SOME_NEXT_STATE;
		end
	...
	SOME_FINAL_STATE: begin
		state &amp;lt;= IDLE_STATE;
		busy &amp;lt;= 1&#39;b0;
		ack  &amp;lt;= 1&#39;b1;
		o_data &amp;lt;= any_read_data_response;
	enddcase

assign	o_wb_stall &amp;lt;= busy;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Examples of this in practice include the
&lt;a href=&quot;https://github.com/ZipCPU/wbicapetwo&quot;&gt;wishbone ICAPE2 controller&lt;/a&gt;,
and a &lt;a href=&quot;http://opencores.org/project,qspiflash&quot;&gt;QSPI flash controller&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;what-can-you-use-this-interface-for&quot;&gt;What can you use this interface for?&lt;/h2&gt;

&lt;p&gt;What can you use this for?  Anything!  Feel free to look over our
&lt;a href=&quot;/projects.html&quot;&gt;projects page&lt;/a&gt; for some example peripheral components that
use this simple interaction.&lt;/p&gt;

&lt;p&gt;In particular, I intend to follow up this article with the idea of using a
wishbone interface to create an interface whereby
&lt;a href=&quot;https://github.com/ZipCPU/wbscope&quot;&gt;a scope&lt;/a&gt; may be read for improved
debugging purposes.&lt;/p&gt;
</description>
        <pubDate>Mon, 29 May 2017 00:00:00 -0400</pubDate>
        <link>http://zipcpu.com/zipcpu/2017/05/29/simple-wishbone.html</link>
        <guid isPermaLink="true">http://zipcpu.com/zipcpu/2017/05/29/simple-wishbone.html</guid>
        
        
        <category>zipcpu</category>
        
      </item>
    
      <item>
        <title>Bus Select Lines</title>
        <description>&lt;p&gt;In a previous post, I discussed how to build a &lt;a href=&quot;/zipcpu/2017/05/29/simple-wishbone.html&quot;&gt;simple wishbone bus
slave&lt;/a&gt;.  That post
eliminated a lot of the bus lines so as to make building a simple bus slave
easy.&lt;/p&gt;

&lt;p&gt;As a result, that bus as built could not handle 8-bit bytes.&lt;/p&gt;

&lt;p&gt;This post will describe how to add the appearance of 8-bit addressing to a
wishbone bus slave.&lt;/p&gt;

&lt;h2 id=&quot;bus-word-size&quot;&gt;Bus Word Size&lt;/h2&gt;

&lt;p&gt;The word size of any bus is given by by the number of data lines contained
within that bus.  The speed of the bus is constrained to be one transaction
per clock, at most, and hence any bus design can at most read (or write)
one bus word at a time.  Hence, increasing the width of the bus will increase
the throughput of that bus.&lt;/p&gt;

&lt;p&gt;The consequence of this, though, is that addresses on the bus don’t reference
octets (8-bit bytes), but rather words.  Instead, a wider bus represents an
array of words, not an array of bytes.&lt;/p&gt;

&lt;p&gt;The problem with word references is that most software is built with the
legacy understanding that memory exists as a series of octets (8-bit bytes).&lt;/p&gt;

&lt;p&gt;So … although the bus exists as an array of words, modern computer software
considers it to be an array of octets.&lt;/p&gt;

&lt;p&gt;How shall this illusion be kept?&lt;/p&gt;

&lt;h2 id=&quot;select-lines&quot;&gt;Select lines&lt;/h2&gt;

&lt;p&gt;The answer to the question of how to make an array of words look like an array
of bytes is the bus select lines.&lt;/p&gt;

&lt;p&gt;Remember how we defined how a memory would access a bus &lt;a href=&quot;/zipcpu/2017/05/23/simplebus.html&quot;&gt;earlier&lt;/a&gt;?&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	if (i_wr)
		memory[i_addr] &amp;lt;= i_data;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Or how &lt;a href=&quot;/zipcpu/2017/05/29/simple-wishbone.html&quot;&gt;we discussed&lt;/a&gt; what this would look like for the &lt;a href=&quot;http://opencores.org/cdn/downloads/wbspec_b4.pdf&quot;&gt;wishbone bus&lt;/a&gt;?&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	if ((i_wb_stb)&amp;amp;&amp;amp;(i_wb_we))
		memory[i_addr] &amp;lt;= i_data;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Adding select lines to this transaction is fairly easy.  In particular, the
four select lines indicate which byte on the bus has valid data within it.
What we do, therefore, is to gate each of the individual byte writes by this
select line:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	reg	[(BUS_WIDTH-1):0]	mem	[(0:((1&amp;lt;&amp;lt;(ADDRESS_WIDTH)-1)];
	always @(posedge i_clk)
	begin
		if ((i_wb_stb)&amp;amp;&amp;amp;(i_wb_we)&amp;amp;&amp;amp;(w_sel[3]))
			mem[i_wb_addr][31:24] &amp;lt;= i_wb_data[31:24];
		if ((i_wb_stb)&amp;amp;&amp;amp;(i_wb_we)&amp;amp;&amp;amp;(w_sel[2]))
			mem[i_wb_addr][23:16] &amp;lt;= i_wb_data[23:16];
		if ((i_wb_stb)&amp;amp;&amp;amp;(i_wb_we)&amp;amp;&amp;amp;(w_sel[1]))
			mem[i_wb_addr][15: 8] &amp;lt;= i_wb_data[15:8];
		if ((i_wb_stb)&amp;amp;&amp;amp;(i_wb_we)&amp;amp;&amp;amp;(w_sel[0]))
			mem[i_wb_addr][ 7: 0] &amp;lt;= i_wb_data[7:0];
	end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Format here is important.  Just a subtle change in this formula, and the
synthesis tool may no longer infer a block RAM.  If this happens, your LUT
usage is likely to massively increase.  To deal with this issue, know where
to find the guide that specifies how block RAM’s are inferred.  For example,
&lt;a href=&quot;https://www.xilinx.com/support/documentation/white_papers/wp231.pdf&quot;&gt;here’s a link&lt;/a&gt; to the guide for Xilinx.&lt;/p&gt;

&lt;p&gt;If you can’t get your synthesis tool to recognize a memory with select lines,
you may have to do this final bus decoding yourself:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;reg	[(7-1):0]	mem_a	[(0:((1&amp;lt;&amp;lt;(ADDRESS_WIDTH)-1)];
reg	[(7-1):0]	mem_b	[(0:((1&amp;lt;&amp;lt;(ADDRESS_WIDTH)-1)];
reg	[(7-1):0]	mem_c	[(0:((1&amp;lt;&amp;lt;(ADDRESS_WIDTH)-1)];
reg	[(7-1):0]	mem_d	[(0:((1&amp;lt;&amp;lt;(ADDRESS_WIDTH)-1)];

always @(posedge i_clk)
begin
	if ((i_wb_stb)&amp;amp;&amp;amp;(i_wb_we)&amp;amp;&amp;amp;(w_sel[3]))
		mem_a[i_wb_addr] &amp;lt;= i_wb_data[31:24];
	if ((i_wb_stb)&amp;amp;&amp;amp;(i_wb_we)&amp;amp;&amp;amp;(w_sel[2]))
		mem_b[i_wb_addr] &amp;lt;= i_wb_data[23:16];
	if ((i_wb_stb)&amp;amp;&amp;amp;(i_wb_we)&amp;amp;&amp;amp;(w_sel[1]))
		mem_c[i_wb_addr] &amp;lt;= i_wb_data[15:8];
	if ((i_wb_stb)&amp;amp;&amp;amp;(i_wb_we)&amp;amp;&amp;amp;(w_sel[0]))
		mem_d[i_wb_addr] &amp;lt;= i_wb_data[7:0];
end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;If you have to do this decoding yourself, reading from the bus would also
change to:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	o_wb_data &amp;lt;= { mem_a[i_wb_addr], mem_b[i_wb_addr],
		mem_c[i_wb_addr], mem_d[i_wb_addr] };&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;But I tend to avoid this approach if at all possible–it just seems and feels
messier.&lt;/p&gt;

&lt;h2 id=&quot;what-about-reading-from-the-bus&quot;&gt;What about reading from the bus?&lt;/h2&gt;

&lt;p&gt;The only time you need to worry about the select lines when reading from a 
wishbone bus is when you are the master and you want to decode the result
from the bus.  Hence, the bus master will just read a whole word, and then
grab the byte (or bytes) necessary when the bus request returns its data.&lt;/p&gt;

&lt;p&gt;In other words, nothing changes in the slave when you read less than a word
size from the bus.&lt;/p&gt;

&lt;h2 id=&quot;do-all-peripherals-need-to-offers-8-bit-support&quot;&gt;Do all peripherals need to offers 8-bit support?&lt;/h2&gt;

&lt;p&gt;Not at all.  If you read through device specification sheets, it’s not uncommon
for the designer to say that accesses of less than a word size are not
supported, and that their results are undefined.  This is the hardware
designer’s way of saying that the select lines may not be relied upon.&lt;/p&gt;

&lt;p&gt;In other words: when building your peripheral, you don’t need to provide select
line support.&lt;/p&gt;

&lt;p&gt;However, in order for the various string libraries to work, memory peripherals
&lt;em&gt;must&lt;/em&gt; have select line support.&lt;/p&gt;

&lt;h2 id=&quot;examples&quot;&gt;Examples&lt;/h2&gt;

&lt;p&gt;Few of my generic peripherals support memory byte selection, but all of my
memory peripherals now do.  You can find an example block RAM memory device 
&lt;a href=&quot;https://github.com/ZipCPU/openarty/blob/master/rtl/memdev.v&quot;&gt;here&lt;/a&gt;, showing
all the required pieces of what it takes to interact with a bus slave.&lt;/p&gt;

&lt;p&gt;If this is interesting to you, then stick around: discussing how to build a
wishbone bus master is next!&lt;/p&gt;
</description>
        <pubDate>Mon, 29 May 2017 00:00:00 -0400</pubDate>
        <link>http://zipcpu.com/zipcpu/2017/05/29/select-lines.html</link>
        <guid isPermaLink="true">http://zipcpu.com/zipcpu/2017/05/29/select-lines.html</guid>
        
        
        <category>zipcpu</category>
        
      </item>
    
      <item>
        <title>FFT debugging</title>
        <description>&lt;p&gt;Some time ago, an individual wrote into &lt;a href=&quot;https://forum.digilentinc.com&quot;&gt;Digilent’s forums&lt;/a&gt; asking why their
FFT wasn’t working.  You can read that interchange here
&lt;a href=&quot;https://forum.digilentinc.com/topic/2951-transfer-the-data-from-my-artix-7-board-to-a-txt-file-on-the-pc/&quot;&gt;[1]&lt;/a&gt;
&lt;a href=&quot;https://forum.digilentinc.com/topic/3101-problems-fft-ip-core-v90&quot;&gt;[2]&lt;/a&gt;
&lt;a href=&quot;https://forum.digilentinc.com/topic/3137-fft-problems-doesnt-finish-never&quot;&gt;[3]&lt;/a&gt;
&lt;a href=&quot;https://forum.digilentinc.com/topic/3160-xadc-and-the-fft&quot;&gt;[4]&lt;/a&gt;
&lt;a href=&quot;https://forum.digilentinc.com/topic/3211-back-the-fft-again&quot;&gt;[5]&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;My advice to anyone working on such a problem like this is that you need to
build the debug infrastructure first, before you try to implement an FFT.
Here on this blog, we’ve already discussed most of the pieces describing how
to do just that:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;You start by getting a simple means of communicating with the device working&lt;/p&gt;

    &lt;p&gt;We discussed an example of getting a &lt;a href=&quot;https://github.com/ZipCPU/wbuart32&quot;&gt;basic serial port&lt;/a&gt; up and running &lt;a href=&quot;/blog/2017/05/24/serial-port.html&quot;&gt;here&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;You use that communications channel to get some kind of bus up and running
on your FPGA.  (I prefer &lt;a href=&quot;http://opencores.org/opencores,wishbone&quot;&gt;wishbone&lt;/a&gt;.)
You then use this bus to read from
the internal variables of your FPGA, or set variables within it.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Once built, you can then use one of your peripheral registers to control a
stepping signal, so as to step all of your logic under test by one clock.&lt;/p&gt;

    &lt;p&gt;We discussed how to turn a serial port into such a debug peripheral
&lt;a href=&quot;/blog/2017/05/26/simpledbg.html&quot;&gt;here&lt;/a&gt;.  We’ll discuss
it more in the context of an FFT below.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;This works when debugging the &lt;a href=&quot;https://www.xilinx.com/support/documentation/ip_documentation/xfft/v9_0/pg109-xfft.pdf&quot;&gt;Xilinx FFT&lt;/a&gt;, as well as &lt;a href=&quot;https://github.com/ZipCPU/dblclockfft&quot;&gt;my own FFT&lt;/a&gt;.  Indeed, debugging
any FFT is no more difficult than debugging any other component, as we’ll
discuss in this post.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;why-you-need-to-break-up-the-problem&quot;&gt;Why you need to break up the problem&lt;/h2&gt;

&lt;p&gt;The first step, though, is to break the problem into pieces, and to debug
each piece individually.&lt;/p&gt;

&lt;p&gt;FFT’s are rarely found all alone.  Usually, they are found within a larger
context.  They are often connected to 
a sampling device, there may be other processing in front of them, and the
whole often runs faster than your debug interface.  Put together, a simple
FFT architecture might look like:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/multi-block-fft.svg&quot; /&gt;&lt;/p&gt;

&lt;p&gt;The problem with this simple architecture is that, unless you can isolate the
FFT component by itself, you will never know which of the components in this
processing chain is failing.  This was the problem the
&lt;a href=&quot;https://forum.digilentinc.com/topic/3101-problems-fft-ip-core-v90&quot;&gt;Digilent poster&lt;/a&gt;
had when trying to get his FFT working.&lt;/p&gt;

&lt;p&gt;This post will discuss how to isolate just the FFT.&lt;/p&gt;

&lt;p&gt;Ideally, you could build a simulation which would allow you to simulate how
this FFT works.  However, if you are like me and enjoy building simulations
from open source tools only,
&lt;a href=&quot;https://www.veripool.org/wiki/verilator&quot;&gt;Verilator&lt;/a&gt; for example,
then you’ll be stuck and unable to simulate a proprietary IP core anywhere other
than on the FPGA itself.  Hence, we’re going to run our test benches on the
FPGA hardware itself.&lt;/p&gt;

&lt;p&gt;To do that, we’re going to add a &lt;a href=&quot;http://opencores.org/opencores,wishbone&quot;&gt;wishbone&lt;/a&gt; slave interface to our FFT, so that
you can debug the FFT, and only the FFT, just like you would read and write
from any &lt;a href=&quot;zipcpu/2017/05/29/simple-wishbone.html&quot;&gt;wishbone slave peripheral&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;my-example&quot;&gt;My example&lt;/h2&gt;

&lt;p&gt;The following is an example piece of code, cut from a time when I needed to
debug
&lt;a href=&quot;https://www.xilinx.com/support/documentation/ip_documentation/xfft/v9_0/pg109-xfft.pdf&quot;&gt;Xilinx’s FFT&lt;/a&gt; within one of my designs (I was comparing their
implementation to &lt;a href=&quot;https://github.com/ZipCPU/dblclockfft&quot;&gt;my own&lt;/a&gt; at the time).
Minimal edits have been made to simplify the presentation.&lt;/p&gt;

&lt;p&gt;As with any test, you want to start from known conditions.  This test is no
difference.  Hence, our first step will be to reset the FFT.  We’ll do that by
setting the reset line any time the user writes to the zero address associated
witht he FFT.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;// Writes to the control register reset the FFT.  Note that the reset lasts
// only one clock
always @(posedge i_clk)
	fft_reset&amp;lt;=(i_wb_stb)&amp;amp;&amp;amp;(i_wb_we)&amp;amp;&amp;amp;(i_wb_addr[3:0]== 4&#39;h0);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The register names should
be familiar from either the &lt;a href=&quot;http://opencores.org/opencores,wishbone&quot;&gt;wishbone spec&lt;/a&gt;, or &lt;a href=&quot;zipcpu/2017/05/29/simple-wishbone.html&quot;&gt;our discussion&lt;/a&gt; on how to build a simple wishbone slave.&lt;/p&gt;

&lt;p&gt;The next step is to set up the input value for the each FFT clock.  In our
case, we’ll set one input value any time someone writes to the bus.   Well,
almost.  In my example, I have two input samples because I was testing a
&lt;a href=&quot;https://github.com/ZipCPU/dblclockfft&quot;&gt;two-sample input FFT&lt;/a&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;// Writes to the FFT control logic
always @(posedge i_clk)
	if ((i_wb_stb)&amp;amp;&amp;amp;(i_wb_we))
	begin case(i_wb_addr[3:0])
		// 4&#39;h0:	fft_reset &amp;lt;= 1&#39;b1;
		4&#39;h2:	fft_in_left &amp;lt;= { i_wb_data[31:(32-FFTBITS)],
					i_wb_data[15:(16-FFTBITS)] };
		4&#39;h3:	begin
			fft_in_right&amp;lt;= { i_wb_data[31:(32-FFTBITS)],
					i_wb_data[15:(16-FFTBITS)] };
			end
		default: begin end
	endcase end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Since I was setting the values two at a time, you’ll notice the FFT input values
are name &lt;strong&gt;fft_in_left&lt;/strong&gt; and
&lt;strong&gt;fft_in_right&lt;/strong&gt;—the even and odd inputs to the FFT respectively.
Likewise, you may also notice that I accepted FFTBITS per input.  This allowed
me to experiment with input samples having less than 16-bits each, even though
I was passing two values at a time (real and imaginary) packed into the upper
bits of each half-word.&lt;/p&gt;

&lt;p&gt;Now that the FFT has its inputs given and assigned to it, we then need to
step the clock by one tick, and one tick only.  To do this, we’ll use the
clock enable (ce) line found within each FFT.  We connect this clock enable
line to the bus via a bus write: any time the user writes to address 3 of our
bus, the clock enable line will get set for one clock tick.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;// Writes to register #3 step the FFT
always @(posedge i_clk)
	fft_ce &amp;lt;= (i_wb_stb)&amp;amp;&amp;amp;(i_wb_we)&amp;amp;&amp;amp;(i_wb_addr[3:0] == 4&#39;h3);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;You may notice that this is also the register for one of our inputs
(&lt;strong&gt;fft_in_right&lt;/strong&gt; above).  In this fashion, we only need to set the inputs in
order to have the FFT step forward by one clock tick.&lt;/p&gt;

&lt;p&gt;The last step is to read the results from the FFT.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;// Reads from the FFT control logic
always @(posedge i_clk)
case(i_wb_addr[3:0]) // Read
	// Read from a control register
	4&#39;h0: o_wb_data &amp;lt;= { 28&#39;hff0000, 3&#39;h0,
				fft_sync };
	// Read from the input port for the left channel
	4&#39;h2: o_wb_data &amp;lt;= fft_in_left;
	// Read from the input port for the right channel
	4&#39;h3: o_wb_data &amp;lt;= fft_in_right;
	// Read the FFT outputs, from first the left then the right ports
	4&#39;h4: o_wb_data &amp;lt;= fft_out_left;
	4&#39;h5: o_wb_data &amp;lt;= fft_out_right;
	// And ... set every other register to zero
	default: o_wb_data &amp;lt;= 32&#39;h0000;
endcase&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The first register allowed me to read back the status from the FFT itself.
In particular, the FFT sets a synchronization flag on the first valid
output from the FFT.  In order to align our results with the FFT, we need
to read that flag.&lt;/p&gt;

&lt;p&gt;Reads from addresses two and three allowed us to verify that the bus was
working, by simply reading back the values we’d written to the input channel.&lt;/p&gt;

&lt;p&gt;Reads from addresses four and five allowed us to read the result from the FFT.&lt;/p&gt;

&lt;p&gt;The &lt;strong&gt;o_wb_ack&lt;/strong&gt; and &lt;strong&gt;o_wb_stall&lt;/strong&gt; lines can use the same logic as we
used for our &lt;a href=&quot;zipcpu/2017/05/29/simple-wishbone.html&quot;&gt;simple wishbone slave implementation&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;That’s it!  You can now debug an FFT as a wishbone slave component, feed it
with your test data, and single step it to see what it does and how it works!&lt;/p&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;So, we’ve now discussed how to debug an FFT isolated from everything else.
With a little ingenuity, you should be able to figure out how to debug any
other DSP logic on your FPGA in a similar fashion.  This approach should get
you to the point of being able to debug your processing flow all the way from
the Pre-DSP component through to your reported results.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/fft-almost-there.svg&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Where this approach fails is when you have real–time inputs to your FFT that
you cannot slow down–such as the results from any analog to digital
converter.  There are two approaches to that problem:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;You can copy the outputs of your sampler directly into a buffer, record that
  buffer, and then use the data from that buffer as inputs to your FFT.  That
  will allow you to continue using this debugging approach.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;You can also use some form of a scope to capture a snapshot of the
  real–time data as it runs through the FFT.   This is the approach used by
  the &lt;a href=&quot;https://github.com/ZipCPU/wbscope&quot;&gt;wishbone scope&lt;/a&gt;, and an approach
  we’ll slowly work up to within this blog.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Which solution should you use?  Both!  But … we’ll get back to that in a
later post.&lt;/p&gt;

</description>
        <pubDate>Mon, 29 May 2017 00:00:00 -0400</pubDate>
        <link>http://zipcpu.com/digilent/2017/05/29/fft-debugging.html</link>
        <guid isPermaLink="true">http://zipcpu.com/digilent/2017/05/29/fft-debugging.html</guid>
        
        
        <category>digilent</category>
        
      </item>
    
      <item>
        <title>Debugging an FPGA through the serial port--first steps</title>
        <description>&lt;p&gt;Now that you have a working &lt;a href=&quot;https://github.com/ZipCPU/wbuart32&quot;&gt;serial port&lt;/a&gt;
which you can use to interact with your CPU, and now again that you know how to
&lt;a href=&quot;/zipcpu/2017/05/23/simplebus.html&quot;&gt;respond to simple bus requests&lt;/a&gt;,
let’s examine whether these two be put together to create a simple means of
debugging your FPGA.&lt;/p&gt;

&lt;p&gt;In this post, we’ll build a generic means for both reading registers
internal to an FPGA using a serial port, and then using that approach to
debug your design.&lt;/p&gt;

&lt;h2 id=&quot;an-generic-serial-port-communication-interface&quot;&gt;An generic serial port communication interface&lt;/h2&gt;

&lt;p&gt;For the purpose of this discussion, let’s assume your serial port receiver
produces two outputs:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;rx_stb&lt;/strong&gt; – a logic value that is true any time a value has been received
across the receive port.  It is to be true for one clock cycle, and one clock
cycle only, any time something is received.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;rx_data&lt;/strong&gt; – Eight bits of logic representing the most recently received
data value from the received serial port.  This value has meaning anytime
&lt;strong&gt;rx_data&lt;/strong&gt; is true, and ignored at all other times.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Likewise, we’ll assume that your serial port transmitter has two inputs,
&lt;strong&gt;tx_stb&lt;/strong&gt; and &lt;strong&gt;tx_data&lt;/strong&gt;.  Their meaning will be analogous to that of the
receivers ports.&lt;/p&gt;

&lt;p&gt;The advanced student may notice this interface protocol isn’t complete.
In particular, the transmitter may be busy some time &lt;strong&gt;tx_stb&lt;/strong&gt; is true, and
nothing above allows us to capture that reality.  To be complete, then, you
will need a third wire, this one coming from your transmit interface:
&lt;strong&gt;tx_busy&lt;/strong&gt;.  This wire is true any time the transmitter is busy.  When put
together with the rest of the interface, a character will be accepted into
the transmit interface any time &lt;strong&gt;tx_stb&lt;/strong&gt; is true &lt;em&gt;and&lt;/em&gt; &lt;strong&gt;tx_busy&lt;/strong&gt; is
false.  We’ll ignore this wire for now.  As long as you don’t press this
interface too hard, the approach below will work.&lt;/p&gt;

&lt;p&gt;With that out of the way, we can move on to building our basic debug protocol,
based upon this interface to a serial port.&lt;/p&gt;

&lt;h2 id=&quot;using-a-clock-enable-as-part-of-a-debug-process&quot;&gt;Using a Clock Enable as part of a debug process&lt;/h2&gt;

&lt;p&gt;The first step is a clock enable line.  I’ll call this &lt;strong&gt;logic_ce&lt;/strong&gt; for now,
but you may see me call it &lt;strong&gt;i_ce&lt;/strong&gt; later.
We’ll use this clock enable line to gate all of your logic, such as:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	if (logic_ce)
	begin
		//
		// Your debuggable FPGA logic goes here.
		//

		// You could even stuff a full blown CPU in here, if you
		// wanted to debug it this way.

		// Anything that doesn&#39;t fit in this always block, will
		// still need to have it&#39;s logic gated by the ce line above.
	end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The goal here is to keep &lt;em&gt;any&lt;/em&gt; logic from changing unless the &lt;strong&gt;logic_ce&lt;/strong&gt;
line is true.&lt;/p&gt;

&lt;p&gt;Why are we doing this?  We’re doing this to slow down your logic to the point
where it can be inspected.&lt;/p&gt;

&lt;p&gt;What … how shall this ce line be controlled?&lt;br /&gt;
You can use the serial port to control this clock enable.   For this
example, we’ll set the serial port up so that any time you send an
8’h00 across the serial port channel, you also step all the logic by one clock.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	logic_ce &amp;lt;= (rx_stb)&amp;amp;&amp;amp;(rx_data == 8&#39;h00);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Sure, this will &lt;em&gt;really&lt;/em&gt; slow down your logic, but … you’ll still be running
&lt;em&gt;your&lt;/em&gt; logic on the FPGA.  Where this gets useful is in the next step, reading
data back ouf of the FPGA.&lt;/p&gt;

&lt;h2 id=&quot;reading-data-back-from-within-your-fpga&quot;&gt;Reading data back from within your FPGA&lt;/h2&gt;

&lt;p&gt;What really makes this idea flow work, is that now, because of the &lt;em&gt;ce&lt;/em&gt; line
above, we can step any logic within the FPGA.  We can then read values back
out of the FPGA while everything is stopped.  Using that UART to control your
bus, you can read out any of your data points with code something like this:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	if (rx_stb)
	begin
		tx_stb &amp;lt;= 1&#39;b1;
		case(rx_data)
		8&#39;h00: tx_data &amp;lt;= 8&#39;h00;
		8&#39;h01: tx_data &amp;lt;= one_of_my_registers;
		8&#39;h02: tx_data &amp;lt;= another_of_my_registers;
		8&#39;h03: tx_data &amp;lt;= a_third_set_of_internal_variables;
		...
		8&#39;hff: tx_data &amp;lt;= the_last_result_i_might_return;
		default: tx_data &amp;lt;= 8&#39;h00;
		endcase
	end else
		tx_stb &amp;lt;= 1&#39;b0;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Using this simple approach, you can now read the results of any logic within
your design.  You could also do something similar in the other direction
to set any values within your design if you so wished, but I’ll leave that last
change up to you.&lt;/p&gt;

&lt;h2 id=&quot;this-really-needs-a-software-controller&quot;&gt;This really needs a software controller&lt;/h2&gt;

&lt;p&gt;While reading from addresses ‘0’-‘9’ (i.e. 8’d48 to 8’d57) may be pretty
simple, and may be done within a
simple terminal program, chances are that if you wish to make this work you’ll
want to connect a computer program to that terminal program.   That computer
program will need to send the full set of characters from 8’d0 to 8’d255.&lt;/p&gt;

&lt;p&gt;You can see how I drive my serial port in the
&lt;a href=&quot;https://github.com/ZipCPU/openarty/blob/master/sw/host/netuart.cpp&quot;&gt;netuart&lt;/a&gt;
program I use to
bounce the serial port to a TCP/IP port, but there’s no reason why you couldn’t
use this as an example of how to interact with a serial port.  The commands
would be similar, only the network stuff would need to come out.&lt;/p&gt;

&lt;h2 id=&quot;multi-stepping&quot;&gt;Multi-Stepping&lt;/h2&gt;

&lt;p&gt;There’s no reason why you cannot step several steps at a time using this
approach.  You could also set-up multi-cycle instructions that will start
whenever you write a NULL to the port, and whose data may be read after a
programmable number of clocks.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;reg	counter;
always @(posedge i_clk)
	if ((rx_stb)&amp;amp;&amp;amp;(rx_data == 8&#39;h00))
		counter &amp;lt;= 0;
		logic_ce &amp;lt;= 1&#39;b1;
	else if (counter &amp;lt; NCLOCKS-1)
		counter &amp;lt;= counter + 1&#39;b1;
	else
		logic_ce &amp;lt;= 1&#39;b0;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Indeed, the possibilities of using this approach for debugging are nearly
endless.&lt;/p&gt;

&lt;h2 id=&quot;output-formats&quot;&gt;Output Formats&lt;/h2&gt;

&lt;p&gt;If you’d like, you can take the outputs you get from this debugging interface
and build a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Value_change_dump&quot;&gt;VCD&lt;/a&gt; file for viewing in
&lt;a href=&quot;gtkwave.sourceforge.net&quot;&gt;GTKwave&lt;/a&gt;.  If your not sure how to build a 
&lt;a href=&quot;https://en.wikipedia.org/wiki/Value_change_dump&quot;&gt;VCD&lt;/a&gt; file, then just dump
the results into a pseudo-human readable text file and you can then wait
for a later discussion on how to create
&lt;a href=&quot;https://en.wikipedia.org/wiki/Value_change_dump&quot;&gt;VCD&lt;/a&gt; files.&lt;/p&gt;

&lt;p&gt;Me?  Back when I last used this approach (yes, it was some time ago), I just
created a file that I could view using &lt;a href=&quot;https://www.gnu.org/software/octave&quot;&gt;octave&lt;/a&gt;.  &lt;a href=&quot;https://www.gnu.org/software/octave&quot;&gt;Octave&lt;/a&gt; allowed me to not only read in a set of binary data, but it aso allowed me to create
&lt;a href=&quot;gtkwave.sourceforge.net&quot;&gt;GTKwave&lt;/a&gt; types of graphs of the signals within my
design.  Then again, that was a personal choice and you might wish to view
the results in another fashion..&lt;/p&gt;

&lt;p&gt;Am I still using this approach?  Not really.  I’ve built something better
since.  Stick around, and you’ll hear about it.  For now, …&lt;/p&gt;

&lt;p&gt;Go ahead, take this opportunity to surprise me with your ingenuity.&lt;/p&gt;

</description>
        <pubDate>Fri, 26 May 2017 00:00:00 -0400</pubDate>
        <link>http://zipcpu.com/blog/2017/05/26/simpledbg.html</link>
        <guid isPermaLink="true">http://zipcpu.com/blog/2017/05/26/simpledbg.html</guid>
        
        
        <category>blog</category>
        
      </item>
    
  </channel>
</rss>
