<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>The ZipCPU by Gisselquist Technology</title>
    <description>The ZipCPU blog, featuring how to discussions of FPGA and CPU design. This site will be focused on Verilog solutions, using exclusively OpenSource IP products for FPGA design.
</description>
    <link>http://zipcpu.com/</link>
    <atom:link href="http://zipcpu.com/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Tue, 20 Jun 2017 08:16:36 -0400</pubDate>
    <lastBuildDate>Tue, 20 Jun 2017 08:16:36 -0400</lastBuildDate>
    <generator>Jekyll v3.0.1</generator>
    
      <item>
        <title>Putting our Debugging Bus RTL Components Together</title>
        <description>&lt;p&gt;We’ve slowly but surely now built up all of the pieces necessary to build a
debugging bus to provide wishbone master access into an FPGA.&lt;/p&gt;

&lt;table style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 1: WB-UART Overview&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/wb-uart-smpl-2.svg&quot; alt=&quot;Block Diagram of a Simpler Wishbone to UART converter&quot; width=&quot;360&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;As we’ve done so, we’ve gone through several posts to get here describing all
of the various components.  Here’s a list of those previous posts in this
series, in case you wish to start at the beginning and go through this
development.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;/blog/2017/06/05/wb-bridge-overview.html&quot;&gt;An overview of a UART to wishbone
bridge&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;How to build a &lt;a href=&quot;/blog/2017/06/08/simple-wb-master.html&quot;&gt;Simple Wishbone Master&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;How to &lt;a href=&quot;/blog/2017/06/14/creating-words-from-bytes.html&quot;&gt;create bus command words from a 7-bit data stream&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;How to &lt;a href=&quot;/blog/2017/06/15/words-back-to-bytes.html&quot;&gt;turn the bus master responses back into a serial stream&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;How to &lt;a href=&quot;/blog/2017/06/16/adding-ints.html&quot;&gt;add interrupts to our interface&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;/blog/2017/06/16/adding-ints.html&quot;&gt;Adding idles to our interface&lt;/a&gt;, to help recognize that it is up and running on a given serial port.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Today’s post is about putting all of these components together.  When we are
done, we’ll have a working debug bus that you can use to read and write from
a &lt;a href=&quot;https://opencores.org/opencores,wishbone&quot;&gt;wishbone bus&lt;/a&gt; within your design.&lt;/p&gt;

&lt;p&gt;In this design, we have very few module level requirements.  Our big goal
is little more than that we put all the pieces together, as outlined in 
Fig. 1 above.  Hence we’ll jump right into putting the pieces together.&lt;/p&gt;

&lt;h2 id=&quot;putting-the-pieces-together&quot;&gt;Putting the Pieces Together&lt;/h2&gt;

&lt;p&gt;You can find our various pieces so far
&lt;a href=&quot;https://github.com/ZipCPU/dbgbus/tree/master/hexbus&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;As we put these components together, we’ll skip for discussion purposes the
register and wire definitions, as well as the module interface definition.
If you’d like to see all of the pieces, including these definitions,
please feel free to examine the final module code 
&lt;a href=&quot;https://github.com/ZipCPU/dbgbus/blob/master/hexbus/rtl/hbbus.v&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The &lt;a href=&quot;https://github.com/ZipCPU/dbgbus/blob/master/rtl/hbdechex.v&quot;&gt;first
component&lt;/a&gt; will
take our incoming stream and turn it into 5-bit data words having a binary
representation.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;hbdechex dechxi(i_clk, i_rx_stb, i_rx_byte,
		dec_stb, w_reset, dec_bits);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Note that it takes a module level input, &lt;strong&gt;i_rx_byte&lt;/strong&gt;,
containing the received byte, together with a strobe, &lt;strong&gt;i_rx_stb&lt;/strong&gt;, which
will be true for the one clock when &lt;strong&gt;i_rx_byte&lt;/strong&gt; is true.  In a similar
fashion, the outputs bits will be placed into &lt;strong&gt;dec_bits&lt;/strong&gt;, which will be
valid any time &lt;strong&gt;dec_stb&lt;/strong&gt; is true.&lt;/p&gt;

&lt;p&gt;One unique feature of this component is the &lt;strong&gt;w_reset&lt;/strong&gt; signal that will be
true for one clock, on the clock after ‘T’ was received.  We’ll use this
signal to reset all of our processing components.&lt;/p&gt;

&lt;p&gt;The &lt;a href=&quot;https://github.com/ZipCPU/dbgbus/blob/master/rtl/hbpack.v&quot;&gt;next
component&lt;/a&gt; will
then pack our 4-bit values into a 32-bit word.  It will also keep track of
word transitions, and note when any new word begins.  Upon the beginning of a
word, or for that matter any unknown character, the interface will push
forward any command currently within its buffer.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;hbpack	packxi(i_clk, w_reset,
	dec_stb, dec_bits, iw_stb, iw_word);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;You may have noticed by now that I like to differentiate things by
prefix.  The ouputs of this module have the &lt;strong&gt;iw_&lt;/strong&gt; prefix, indicating
that they are the incoming words.&lt;/p&gt;

&lt;p&gt;Had you tried to jump into this whole process at the beginning, without the
experience of having done all of our work so far, you might’ve thought that
the &lt;a href=&quot;https://github.com/ZipCPU/dbgbus/blob/master/rtl/hbexec.v&quot;&gt;bus master&lt;/a&gt;
component would be the primary component.  The reality is that thus bus master
function wouldn’t be able to function apart from the other components around it.
The reason is that &lt;em&gt;something&lt;/em&gt; needs to tell it what addresses to read and
write from the bus.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;hbexec	wbexec(i_clk, w_reset, iw_stb, iw_word, wb_busy,
		ow_stb, ow_word,
		o_wb_cyc, o_wb_stb, o_wb_we, o_wb_addr, o_wb_data,
			o_wb_sel, i_wb_ack, i_wb_stall, i_wb_err,
			i_wb_data);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Here, it takes its inputs from the &lt;strong&gt;iw_word&lt;/strong&gt;, initiates a bus command, and
returns its results in the &lt;strong&gt;ow_word&lt;/strong&gt;.  Both of these words will be true
on the one clock with their &lt;strong&gt;_stb&lt;/strong&gt; line is true.  The actual bus master
wires are prefixed with &lt;strong&gt;o_wb_&lt;/strong&gt; if they go from the master to the slave, and
&lt;strong&gt;i_wb_&lt;/strong&gt; if they are returning values from the slave.  Further, because these
have the &lt;strong&gt;i_&lt;/strong&gt; and &lt;strong&gt;o_&lt;/strong&gt; prefixes, you can tell (from my own notation
convention) that these particular values are module level inputs and outputs.&lt;/p&gt;

&lt;p&gt;At this point, our interface changes somewhat.  Prior to this part of our
design, subsequent modules were required to be prepared for an input that
could take place at any clock.  The serial port transmitter, however, at the
other end of this stream cannot handle data at &lt;em&gt;any&lt;/em&gt; rate given to it.  So,
we’re going to need to slow things down.  We’ll do this with the &lt;strong&gt;_busy&lt;/strong&gt;
signal.  Each unit in this return chain will accept a &lt;strong&gt;_stb&lt;/strong&gt; word indicating
that it’s next input word is valid and ready, and it will produce a &lt;strong&gt;_stb&lt;/strong&gt;
word indicating that it’s output word is valid and ready.  However, to keep
the interface from moving faster than our resulting transmit transport can
handle, we’ll insist that transactions only take place when the &lt;strong&gt;_stb&lt;/strong&gt; is
valid &lt;em&gt;and&lt;/em&gt; the &lt;strong&gt;_busy&lt;/strong&gt; associated with that stage is false.  Hence, once
the &lt;strong&gt;_stb&lt;/strong&gt; signal is raised, it must remain so and the &lt;strong&gt;_word&lt;/strong&gt; value
must not change until the &lt;strong&gt;_busy&lt;/strong&gt; line from the receiving entity has dropped.&lt;/p&gt;

&lt;p&gt;This is actually a fairly common protocol, used by busses ranging from
&lt;a href=&quot;http://www.gstitt.ece.ufl.edu/courses/fall15/eel4720_5721/labs/refs/AXI4_specification.pdf&quot;&gt;AXI&lt;/a&gt;
to &lt;a href=&quot;https://opencores.org/cdn/downloads/wbspec_b4.pdf&quot;&gt;Wishbone&lt;/a&gt; and more.&lt;/p&gt;

&lt;p&gt;The &lt;a href=&quot;https://github.com/ZipCPU/dbgbus/blob/master/rtl/addints.v&quot;&gt;first
component&lt;/a&gt;
to use this new interface approach is the 
&lt;a href=&quot;https://github.com/ZipCPU/dbgbus/blob/master/rtl/addints.v&quot;&gt;addints&lt;/a&gt;
module that adds interrupt notifications into our stream.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;hbints	addints(i_clk, w_reset, i_interrupt,
		ow_stb,  ow_word,  int_busy,
		int_stb, int_word, idl_busy);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This stage also acts like a one-stage FIFO, giving us a little bit of a buffer
should responses come from the master too fast for us to deal with them.&lt;/p&gt;

&lt;p&gt;You can see the &lt;strong&gt;_busy&lt;/strong&gt; line coming from the next stage on the third
line, together with the output lines &lt;strong&gt;int_stb&lt;/strong&gt; and &lt;strong&gt;int_word&lt;/strong&gt;.
The first line contains the &lt;strong&gt;int_busy&lt;/strong&gt; line which would’ve gone to the
prior stage, had we had one that accepted it.  We’ll leave it here unconnected
so that we can grab it when we add a FIFO in to this interface later.&lt;/p&gt;

&lt;p&gt;The &lt;a href=&quot;https://github.com/ZipCPU/dbgbus/blob/master/rtl/addints.v&quot;&gt;addints&lt;/a&gt;
module is followed by the &lt;a href=&quot;https://github.com/ZipCPU/dbgbus/blob/master/rtl/addidles.v&quot;&gt;debug
idles&lt;/a&gt; component
that adds idle words into the output stream.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	hbidle	addidles(i_clk, w_reset,
			int_stb, int_word, idl_busy,
			idl_stb, idl_word, hb_busy);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;We then &lt;a href=&quot;https://github.com/ZipCPU/dbgbus/blob/master/rtl/hbdeword.v&quot;&gt;unpack
our words&lt;/a&gt; back
into the five-bit components that had composed them originally on input.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;hbdeword unpackx(i_clk, w_reset,
		idl_stb, idl_word, hb_busy,
		hb_stb, hb_bits, hx_busy);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;These 5-bit components then &lt;a href=&quot;https://github.com/ZipCPU/dbgbus/blob/master/rtl/hbdeword.v&quot;&gt;get
converted&lt;/a&gt; into
bytes for the transport.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	hbgenhex genhex(i_clk, hb_stb, hb_bits, hx_busy,
			hx_stb, hx_byte, nl_busy);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;If the transport ever clears and becomes idle, we’ll &lt;a href=&quot;https://github.com/ZipCPU/dbgbus/blob/master/rtl/hbnewline.v&quot;&gt;add a carriage return
linefeed pair&lt;/a&gt;
to the interface.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;hbnewline addnl(i_clk, w_reset, hx_stb, hx_byte, nl_busy,
		o_tx_stb, o_tx_byte, i_tx_busy);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;That way any line-based stream logic will know to flush its buffer, since any
partial response would’ve now been completed.&lt;/p&gt;

&lt;h2 id=&quot;future-posts&quot;&gt;Future Posts&lt;/h2&gt;

&lt;p&gt;Although this concludes the Verilog development of the debug bus we’ve been
working through, the task isn’t over.  If you have a wishbone bus
that you would like to experiment with commanding, feel free to fire this up
and give it a try.  At this point, you have the basics of a capability.&lt;/p&gt;

&lt;p&gt;The basics.  In otherwords, while it’s an RTL bus, it doesn’t do anything yet.
We can use it to gain access into a system, but we don’t (yet) have any system
built that we might use this to gain access to.  So, we’re not done yet.&lt;/p&gt;

&lt;p&gt;The next items in this series will discuss:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;How to create a simple wishbone interconnect&lt;/p&gt;

    &lt;p&gt;This will consist of some “interesting” things that we can put together and
test.  We’ll use a block RAM component and a &lt;a href=&quot;https://github.com/ZipCPU/wbscope&quot;&gt;Wishbone
scope&lt;/a&gt; for this purpose, as well as a
fairly generic set of simple registers.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Creating a hand-controlled test bench to prove this works&lt;/p&gt;

    &lt;p&gt;This will be about building a test bench that we can use to run this whole
package in Verilator.&lt;/p&gt;

    &lt;p&gt;Once you get this far, you have an example of something that you can put
in your hardware and try.  But … we’re still not done.  While you may find
the interface somewhat usable, a software controller would make it much
easier to use.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Creating a software bus controller&lt;/p&gt;

    &lt;p&gt;That hand-typed interface is going to get old.  We’ll build a software
interface when we get to this point.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Still, this simple debugging bus is now our first design component, and almost
a first design.&lt;/p&gt;

</description>
        <pubDate>Tue, 20 Jun 2017 00:00:00 -0400</pubDate>
        <link>http://zipcpu.com/blog/2017/06/20/dbg-put-together.html</link>
        <guid isPermaLink="true">http://zipcpu.com/blog/2017/06/20/dbg-put-together.html</guid>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>Sending bus idle notifications down the line</title>
        <description>&lt;p&gt;If you haven’t been paying attention to how we’ve built our debug bus master
access into a wishbone device, you might wish to look at some of the other
posts in this series:&lt;/p&gt;

&lt;table style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 1: WB-UART Overview&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/wb-uart-smpl-2.svg&quot; alt=&quot;Block Diagram of a Simpler Wishbone to UART converter&quot; width=&quot;360&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;/blog/2017/06/05/wb-bridge-overview.html&quot;&gt;An overview of a UART to wishbone
bridge&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;How to build a &lt;a href=&quot;/blog/2017/06/08/simple-wb-master.html&quot;&gt;Simple Wishbone Master&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;How to &lt;a href=&quot;/blog/2017/06/14/creating-words-from-bytes.html&quot;&gt;create bus command words from a 7-bit data stream&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;How to &lt;a href=&quot;/blog/2017/06/15/words-back-to-bytes.html&quot;&gt;turn the bus master responses back into a serial stream&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;How to &lt;a href=&quot;/blog/2017/06/16/adding-ints.html&quot;&gt;add interrupts to our interface&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Today, we’re going to add idle notifications to our stream.  These notifications
will help to identify this stream to you any time it is idle.  The result is
that, when you connect to one of these busses, you should know you have a valid
connection once you see the idle character passing through the stream.&lt;/p&gt;

&lt;h2 id=&quot;idle-requirements&quot;&gt;Idle Requirements&lt;/h2&gt;

&lt;p&gt;We want to keep this idle capability simple.  If we draw out the idea of this
idle capability a little bit, we’ll discover we want the following capabilities
in this idle component:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;There should never be any idle characters while the interface is busy.  That
way the idle character won’t slow down any valid transactions.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;An idle character should be sent in the stream somewhere between every
one and ten seconds, yet at regular intervals.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The first idle following any activity shouldn’t show up until one time
interval’s distance from the last valid piece of information.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;If the interface is stopped, such as if the bus is commanded via a SPI slave
port, we shouldn’t accumulate more than a single idle character to be
returned.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;In sum, if you watch this stream, you should be able to identify this
stream as a debug controller within a short number of seconds.&lt;/p&gt;

&lt;h2 id=&quot;the-idle-stream-processor&quot;&gt;The idle stream processor&lt;/h2&gt;

&lt;p&gt;This section will walk through an example idle stream processor, showing you
how to add idle characters (“Z”) into our response stream.&lt;/p&gt;

&lt;p&gt;The first step in any protocol handling is to define the protocol words.
In this case, we’ll be sending an &lt;strong&gt;IDLE_WORD&lt;/strong&gt; down the line.  This
will turn into a “Z” when received with the strobe high.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;`define	IDLE_SUB_WORD	5&#39;b11011
`define	IDLE_WORD	{ `IDLE_SUB_WORD, {(34-5){1&#39;b0}} }&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Knowing when to insert an idle character is pretty simple.  By using the &lt;a href=&quot;/blog/2017/06/02/generating-timing.html&quot;&gt;timing
techniques shared
here&lt;/a&gt;, we can
create a strobe every 2^28 clocks, or about every two and a half seconds.
By clearing our idle counter on every input command or reset, we’ll guarantee
that the next idle will be at least two and a half seconds after any
activity.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;initial	idle_stb      = 0;
initial	idle_counter  = 0;
always @(posedge i_clk)
	if ((i_reset)||(i_cmd_stb))
		idle_counter &amp;lt;= 0;
	else
		{ idle_stb, idle_counter } &amp;lt;= idle_counter + 1&#39;b1;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Now that we know when we wish to insert an idle, the next step is to know
when to output an idle character.  In our case, we’ll output a character,
whether idle or not, any time the indication above takes place or any
time an incoming word takes place.  As a result, this will be a pass-through
component–and only change the input when nothing’s there.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	initial	o_idl_stb = 1&#39;b0;
	always @(posedge i_clk)
		if (i_reset)
			o_idl_stb &amp;lt;= 1&#39;b0;
		else if ((i_cmd_stb)&amp;amp;&amp;amp;(!o_idl_busy))
			o_idl_stb &amp;lt;= 1&#39;b1;
		else if ((idle_stb)&amp;amp;&amp;amp;(!o_idl_stb))
			o_idl_stb &amp;lt;= 1&#39;b1;
		else if (!i_busy)
			o_idl_stb &amp;lt;= 1&#39;b0;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The final component is to settle which word we wish to output.  On any incoming
request to transmit, we’ll send the incoming word out.  We’ll also need to
ensure that any incoming word is not over-written until the next word goes
out.  Finally, if nothing is coming in to go out, we’ll just set our output
to be the IDLE_WORD.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;initial	o_idl_word = IDLE_WORD;
always @(posedge i_clk)
	if ((i_cmd_stb)&amp;amp;&amp;amp;(!o_idl_busy))
		o_idl_word &amp;lt;= i_cmd_word;
	else if (!i_busy)
		o_idl_word &amp;lt;= IDLE_WORD;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The logic is fairly simple.&lt;/p&gt;

&lt;p&gt;Ok, I’ll admit it, I got this super-simple interface wrong at first.  Worse,
I had more than one bug within this component.  It got so bad I started to get
very frustrated with the simulator until I finally found the bug.
What was it you ask?  I defined the &lt;strong&gt;IDLE_SUB_WORD&lt;/strong&gt; as 5’h11011 instead
of 5’b11011.  See the difference?  If it hadn’t been for the simulator, I’m
not sure I ever would’ve found my mistake.&lt;/p&gt;

&lt;h2 id=&quot;future-posts&quot;&gt;Future Posts&lt;/h2&gt;

&lt;p&gt;As with the
&lt;a href=&quot;/blog/2017/06/16/adding-ints.html&quot;&gt;interrupt capability&lt;/a&gt;,
adding an idle identifier into our debug
protocol was fairly easy to do.  Our next post will put the whole interface
together.  Further posts will include:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Composing the rest of the debug controller&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Creating a simple wishbone interconnect&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Creating a hand-controlled test bench to prove this works&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Creating a software bus controller&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Adding in FIFO support&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;While we’re going to do better, this simple debugging bus should be enough
to help you debug quite a few designs.&lt;/p&gt;

</description>
        <pubDate>Mon, 19 Jun 2017 00:00:00 -0400</pubDate>
        <link>http://zipcpu.com/blog/2017/06/19/debug-idles.html</link>
        <guid isPermaLink="true">http://zipcpu.com/blog/2017/06/19/debug-idles.html</guid>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>Why Use a Network Interface to your FPGA</title>
        <description>&lt;p&gt;Most FPGA board’s come with some sort of interface port that you can use to
interact with them.  &lt;a href=&quot;http://store.digilentinc.com&quot;&gt;Digilent&lt;/a&gt;’s
&lt;a href=&quot;https://store.digilentinc.com/nexys-video-artix-7-fpga-trainer-board-for-multimedia-applications/&quot;&gt;Nexys-Video&lt;/a&gt;,
&lt;a href=&quot;http://store.digilentinc.com/arty-artix-7-fpga-development-board-for-makers-and-hobbyists&quot;&gt;Arty&lt;/a&gt;
and &lt;a href=&quot;https://store.digilentinc.com/basys-3-artix-7-fpga-trainer-board-recommended-for-introductory-users&quot;&gt;Basys-3&lt;/a&gt;
boards each have a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Universal_asynchonous_receiver/transmitter&quot;&gt;UART&lt;/a&gt;
connection that can be used to interact with the board–as do many of their
other boards.  As a result, the host side interaction can be done using an old
fashioned &lt;a href=&quot;https://en.wikipedia.org/wiki/Serial_port&quot;&gt;serial port&lt;/a&gt; interface. 
The &lt;a href=&quot;http://www.latticesemi.com/en/Products/DevelopmentBoardsAndKits/iCEstick.aspx&quot;&gt;iCEstick&lt;/a&gt; also has a similar interface.&lt;/p&gt;

&lt;p&gt;Xess’s &lt;a href=&quot;http://xess.com&quot;&gt;XuLA2&lt;/a&gt; board is a little bit different, in that it
has a &lt;a href=&quot;https://en.wikipedia.org/wiki/JTAG&quot;&gt;JTAG&lt;/a&gt; port that can be commanded
from a small PIC over a USB port.  However, if you use the
&lt;a href=&quot;https://en.wikipedia.org/wiki/JTAG&quot;&gt;JTAG&lt;/a&gt;
USER command, this port can be turned into
&lt;a href=&quot;https://github.com/ZipCPU/xulalx25soc/blob/master/rtl/jtagser.v&quot;&gt;something that looks, feels, and acts like a serial
port&lt;/a&gt;, with
only a touch of &lt;a href=&quot;http://libusb.org&quot;&gt;libUSB&lt;/a&gt; work required.  While I don’t have
any &lt;a href=&quot;http://www.terasic.com.tw/en/&quot;&gt;Terasic&lt;/a&gt; boards&lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;, I’m sure you could use
a similar approach to driving JTAG over USB.&lt;/p&gt;

&lt;p&gt;Other boards, such as &lt;a href=&quot;https://store.digilentinc.com&quot;&gt;Digilent&lt;/a&gt;’s
&lt;a href=&quot;https://store.digilentinc.com/cmod-s6-breadboardable-spartan-6-fpga-module&quot;&gt;CMod-S6&lt;/a&gt;
or the &lt;a href=&quot;http://www.icoboard.org&quot;&gt;ICO board&lt;/a&gt;, have a parallel type of interface.
While this interface can be turned into a serial stream, and while I have done
this for both interfaces, it takes a bit more work to get going than a
plain &lt;a href=&quot;https://en.wikipedia.org/wiki/Serial_port&quot;&gt;serial port&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;My point is twofold.  First, all of these interfaces will require some work
with the hardware to figure out how to how to send information to the
interface, and how to receive data back from it.  Second, reading and writing
a character stream is the easiest paradigm to consider when interacting with
such a port.  In the case of a &lt;a href=&quot;https://en.wikipedia.org/wiki/Serial_port&quot;&gt;serial
port&lt;/a&gt;, this may have the most O/S
support, since reading from and writing to “/dev/ttyUSBx” is pretty easy.
Other ports that aren’t of the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Serial_port&quot;&gt;serial port&lt;/a&gt;
variety can still be made to look, feel, and act like a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Serial_port&quot;&gt;serial port&lt;/a&gt;
even though the underlying transport itself is &lt;em&gt;very&lt;/em&gt; different.&lt;/p&gt;

&lt;p&gt;My recommendation, which we’ll discuss below, is that you interact with any
character stream-type of interface over a TCP/IP link.&lt;/p&gt;

&lt;h2 id=&quot;a-networked-interface&quot;&gt;A Networked Interface&lt;/h2&gt;

&lt;p&gt;If this is your first FPGA project, you might look at what’s available to you
and consider the simplest interface: from your CPU to the device, as in Fig 1.&lt;/p&gt;

&lt;table style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 1: Serial Port Controller&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/raw-dbg.svg&quot; alt=&quot;A Serial Port Debugging Controller&quot; width=&quot;360&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Your first task will be to figure out how to interact with your board.
While proprietary developer software, with all the nice GUI’s that it comes
with, may be the first solution you find, such software usually doesn’t have
the flexibility you’ll need to to do your project.  If your board has a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Serial_port&quot;&gt;serial port&lt;/a&gt;, then you have
a generic port you can work with.  If not, feel free to make something
similar.&lt;/p&gt;

&lt;p&gt;If your board does have a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Serial_port&quot;&gt;serial port&lt;/a&gt;,
you may be able to interact with it using either a
&lt;a href=&quot;http://www.putty.org&quot;&gt;putty&lt;/a&gt; or
&lt;a href=&quot;https://en.wikipedia.org/wiki/Minicom&quot;&gt;minicom&lt;/a&gt; terminal.  While this can be
pretty fun, if you ever want to do anything requiring serious communication
with your device (image processing, camera interaction, etc), then you’ll want
a capability that goes beyond what these can provide.  Indeed, even if you have
another interface for handling image transmission, it will help to be able
to get that interface going with a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Serial_port&quot;&gt;serial port&lt;/a&gt;, that you can use as
a back up.&lt;/p&gt;

&lt;p&gt;In particular, if you want to read &lt;a href=&quot;https://github.com/ZipCPU/wbscope&quot;&gt;scope&lt;/a&gt;
information from a design, you are
going to want to run some software to read this data out.  While you &lt;em&gt;might&lt;/em&gt;
manage to do it by hand using a &lt;a href=&quot;https://en.wikipedia.org/wiki/Minicom&quot;&gt;minicom&lt;/a&gt;
terminal for a 64-element scope, but you could), doing it for a 2048 element
scope (or more) &lt;em&gt;really&lt;/em&gt; calls for a software solution.  Seriously–let the
computer do the hard work for you.&lt;/p&gt;

&lt;p&gt;Other things you might wish to do with your board might include starting or
stopping your on-board logic, reading state registers from the board, initially
loading the memory of your FPGA board, debugging a
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;soft-CPU&lt;/a&gt; implemented on your board,
or even reading the results of an
&lt;a href=&quot;https://store.digilentinc.com/pmod-mic3-mems-microphone-with-adjustable-gain/&quot;&gt;analog microphone&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;All of these means of interacting with your board need some kind of software
interface.&lt;/p&gt;

&lt;p&gt;While all of this may be sound straight forward so far, the problem you will
run into is &lt;em&gt;simulation&lt;/em&gt;.  Specifically, it’d be nice to be able to write our
control programs once and have them work both when we are interacting with the
hardware itself, as well as when we are interacting with the simulator.&lt;/p&gt;

&lt;p&gt;We’ll create this approach by using TCP/IP, as in Fig 2 below.&lt;/p&gt;

&lt;table style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 2: A Network Based Controller&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/netdbg.svg&quot; alt=&quot;A Network Based FPGA Controller&quot; width=&quot;720&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Lest you misunderstand the figure, the server need not be a separate computer.
It’s just the other end of the TCP/IP interface.  I often run both ends of
this network link on the same computer.  Further, if you bind the IP address
to “localhost”, then your computer will not open up any external TCP/IP ports
that might be visible to the big internet.  On the other hand, I tend to run
it wide open, so I can work on my laptop just as easily as on my desktop, and
then I port at the firewall.&lt;/p&gt;

&lt;p&gt;Somewhere about now I can also hear several students groaning.  Debugging
an FPGA is hard enough, and now I’m recommending that a &lt;em&gt;network&lt;/em&gt; debugging
port needs to be added to the FPGA?&lt;/p&gt;

&lt;p&gt;Relax–it’s not that bad.&lt;/p&gt;

&lt;p&gt;First, the networking debug capability isn’t something you’ll be
graded on.  Therefore I don’t think your instructor will have a problem if you
use someone else’s capabilities, but feel free to check with him/her if you
aren’t sure.&lt;/p&gt;

&lt;p&gt;Second, the software you’ll need is all available under the
&lt;a href=&quot;https://www.gnu.org/licenses/gpl-3.0.en.html&quot;&gt;GPL&lt;/a&gt; already.  You don’t
need to do much more.  If you improve upon it, though, please be kind enough
to the other poor souls out there to share your improvements.  Further, if you
wish to legally give me any of those improvements, I’ll be glad to share them
with the rest of the world as well.&lt;/p&gt;

&lt;p&gt;In general, three basic components are required in order to connect a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Serial_port&quot;&gt;serial port&lt;/a&gt; to a TCP/IP port,
as shown in Fig 3.&lt;/p&gt;

&lt;table style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 3: Network S/W Components&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/netcomponents.svg&quot; alt=&quot;Network Components Diagram&quot; width=&quot;480&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;You’ll need a piece of software to forward your physical
&lt;a href=&quot;https://en.wikipedia.org/wiki/Serial_port&quot;&gt;serial port&lt;/a&gt;
serial port onto a network port.  You can find an example of that
&lt;a href=&quot;https://github.com/ZipCPU/dbgbus/blob/master/sw/netuart.cpp&quot;&gt;here&lt;/a&gt;.
You’ll like this piece.  It lets you watch what’s going over the interface,
in case things aren’t working, and so you can debug that interface
in the same window its running in.&lt;/p&gt;

    &lt;p&gt;If you are using the parallel port of the &lt;a href=&quot;http://www.icoboard.org&quot;&gt;ICO
board&lt;/a&gt;, you can find an example of what it would
take to make this interface work with &lt;a href=&quot;http://wiringpi.com&quot;&gt;wiringPi&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/icozip/blob/master/sw/host/netpport.cpp&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;You’ll also need a piece of software to connect your FPGA control
software to.  You can find that piece
&lt;a href=&quot;https://github.com/ZipCPU/dbgbus/blob/master/sw/llcomms.h&quot;&gt;here&lt;/a&gt;.
You might find right now that this is nothing more than a bare interface.
Don’t worry, it’s the end we are going to connect our software controller
to when we build it.&lt;/p&gt;

    &lt;p&gt;If you don’t have this portion of your interface built yet, don’t worry.
As long as you have the
&lt;a href=&quot;https://github.com/ZipCPU/dbgbus/blob/master/sw/netuart.cpp&quot;&gt;network forwarding piece&lt;/a&gt;.
listed above, you can build use
telnet.  As in, &lt;strong&gt;telnet localhost &amp;lt;portnum&amp;gt;&lt;/strong&gt;.  This will replace
your need for &lt;a href=&quot;http://www.putty.org&quot;&gt;putty&lt;/a&gt; or
&lt;a href=&quot;https://en.wikipedia.org/wiki/Minicom&quot;&gt;minicom&lt;/a&gt;—although if you stick
around, we’ll create a command line approach to interfacing with your board.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The third piece of software you will need, assuming you can interact with
your device over a serial port, you can find as part of the
&lt;a href=&quot;https://github.com/ZipCPU/wbuart32&quot;&gt;wbuart32&lt;/a&gt; package
&lt;a href=&quot;https://github.com/ZipCPU/wbuart/blob/master/bench/cpp/uartsim.cpp&quot;&gt;here&lt;/a&gt;.
This piece turns the simulation end of the TCP/IP port into a
serial interface that you can process on your simulated board.&lt;/p&gt;

    &lt;p&gt;If you have an &lt;a href=&quot;http://www.icoboard.org&quot;&gt;ICO board&lt;/a&gt; with a parallel
interface, you can find an equivalent software component
&lt;a href=&quot;https://github.com/ZipCPU/icozip/blob/master/sim/verilated/dblpipecmdr.h&quot;&gt;here&lt;/a&gt;.
In this case, while this software provides the same capability, it does it
in a different fashion.  You can look within it to see some of the details.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;We’ll discuss how all of these pieces work later and in detail.  For now,
just know that the software is available for you to do this should you have
a &lt;a href=&quot;https://en.wikipedia.org/wiki/Serial_port&quot;&gt;serial port&lt;/a&gt;-type of interface
to your board.&lt;/p&gt;

&lt;p&gt;What does this infrastructure allow you to do?  Why is it to your advantage?
It allows you to test your control software in such a manner
that the control software might never know whether the other end of the link
is an FPGA, as in Fig 2. above, or a simulator–as in Fig 4 below.&lt;/p&gt;

&lt;table style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 4: Network Based Simulation&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/netsim.svg&quot; alt=&quot;A Network Based FPGA Controller&quot; width=&quot;720&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;If you can control your simulator over the network, and not know the
difference, then you know your control programs and your simulator work.&lt;/p&gt;

&lt;p&gt;That’s where we are headed.&lt;/p&gt;

&lt;h2 id=&quot;next-time&quot;&gt;Next Time&lt;/h2&gt;

&lt;p&gt;We’ll come back to these software pieces later to describe how they work in
detail.&lt;/p&gt;

&lt;p&gt;For now, we’re going to continue focusing on what it takes to get an initial
debugging interface up and running.  We can debug more complicated interfaces
from there if we need to.&lt;/p&gt;

&lt;p&gt;If you’ve never tried using a networking debug interface before, think about it.
As we go over the pieces, give them a try.  My bet is that once you find your
first bug using &lt;a href=&quot;https://www.veripool.org/wiki/verilator&quot;&gt;Verilator&lt;/a&gt; and
&lt;a href=&quot;http://gtkwave.sourceforge.net&quot;&gt;GTKWave&lt;/a&gt; that you’ll become a quick
believer in this method.&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;Footnotes:&lt;/p&gt;

&lt;div class=&quot;footnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:1&quot;&gt;
      &lt;p&gt;While I have several FPGA development boards, I do not have any &lt;a href=&quot;https://www.terasic.com.tw/en/&quot;&gt;Terasic&lt;/a&gt; (&lt;a href=&quot;https://www.altera.com/&quot;&gt;Altera&lt;/a&gt;) boards.  As a result, while I know these techniques would work in general on any board, I have not had the opportunity to try any of them on any &lt;a href=&quot;https://www.altera.com/&quot;&gt;Altera&lt;/a&gt; board’s. &lt;a href=&quot;#fnref:1&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;
</description>
        <pubDate>Sat, 17 Jun 2017 00:00:00 -0400</pubDate>
        <link>http://zipcpu.com/blog/2017/06/17/why-network-debugging.html</link>
        <guid isPermaLink="true">http://zipcpu.com/blog/2017/06/17/why-network-debugging.html</guid>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>Support me on Patreon</title>
        <description>&lt;p&gt;The &lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt; blog now has a
&lt;a href=&quot;https://www.patreon.com/ZipCPU&quot;&gt;Patreon support&lt;/a&gt; page!&lt;/p&gt;

&lt;p&gt;If you like this blog, and you’d like to see it continue, please consider
donating to this effort via &lt;a href=&quot;https://www.patreon.com/ZipCPU&quot;&gt;Patreon&lt;/a&gt;.  That
support will go a &lt;em&gt;long&lt;/em&gt; way towards helping me finish blogging about all of
the &lt;a href=&quot;/topics.html&quot;&gt;topics&lt;/a&gt; I have lined up.&lt;/p&gt;

&lt;p&gt;Thank you!&lt;/p&gt;
</description>
        <pubDate>Sat, 17 Jun 2017 00:00:00 -0400</pubDate>
        <link>http://zipcpu.com/blog/2017/06/17/patreon.html</link>
        <guid isPermaLink="true">http://zipcpu.com/blog/2017/06/17/patreon.html</guid>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>The debugging bus: a goal for FPGA interaction</title>
        <description>&lt;p&gt;It’s been a while since I presented the &lt;a href=&quot;/blog/2017/05/22/a-vision-for-controlling-fpgas.html&quot;&gt;vision for controlling FPGA
logic&lt;/a&gt;.
Since that time, we’ve put a lot of work into building an FPGA controller
that we can use for debugging logic running within our FPGA.
&lt;a href=&quot;/blog/2017/06/05/wb-bridge-overview.html&quot;&gt;[1]&lt;/a&gt;
&lt;a href=&quot;/blog/2017/06/14/creating-words-from-bytes.html&quot;&gt;[2]&lt;/a&gt;
&lt;a href=&quot;/blog/2017/06/08/simple-wb-master.html&quot;&gt;[3]&lt;/a&gt;
&lt;a href=&quot;/blog/2017/06/15/words-back-to-bytes.html&quot;&gt;[4]&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Our goal over all is to provide the student, or any other junior FPGA
designer for that matter, with a tool, similar to what an &lt;a href=&quot;/blog/2017/06/02/design-process.html&quot;&gt;expert might
use&lt;/a&gt;, that he can use to figure out what
is going on within his design.&lt;/p&gt;

&lt;p&gt;Today, let’s take a look at what that the software side of communicating
with an FPGA might look like.  In other words, once we connect to our FPGA,
how will we control that FPGA from software?&lt;/p&gt;

&lt;h2 id=&quot;a-simple-fpga-software-controller&quot;&gt;A Simple FPGA Software Controller&lt;/h2&gt;

&lt;p&gt;The simplest FPGA control program that I’ve built is the one I call 
&lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/sw/host/wbregs.cpp&quot;&gt;wbregs&lt;/a&gt;.
This program just reads (or writes) a single register within the FPGA.  The
&lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/sw/host/wbregs.cpp&quot;&gt;source code&lt;/a&gt;
for this program makes it look more complicated than it is though.  That’s
really nothing more than the fact that it’s been lying around long enough to be
&lt;em&gt;improved upon&lt;/em&gt; one too many times … but I digress.&lt;/p&gt;

&lt;p&gt;Lets trim this program down to its bare minimum details, and see what it
would take to control an FPGA using this sort of controller.&lt;/p&gt;

&lt;p&gt;The first step in my idealized world would be to declare a global value
   to hold a pointer to my FPGA’s interface:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;n&quot;&gt;FPGA&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;\&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_fpga&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Then, somewhere within my main program file, I’d want to connect to my FPGA.
If the FPGA talks to the computer via a serial port, I might wish to
say something like:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SERIAL_PORT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;/dev/ttyUSB0&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;m_fpga&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;FPGA&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SERIAL_PORT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;We may need to come back to the name later, in case we have more than one USB
serial port connector, but for now let’s just move on.&lt;/p&gt;

&lt;p&gt;I’d really rather connect to my FPGA from any one of my computers via a
network port, as in:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;FPGASERVER&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;fpgahost.name&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Could be 192.168.7.1 ...
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;FPGAPORT&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2853&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Some random number, known to you
//
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_fpga&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;FPGA&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;FPGASERVER&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;FPGAPORT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Wouldn’t it be nice if that was all it took to connect to an FPGA?&lt;/p&gt;

&lt;p&gt;How about reading the a status register from the FPGA?  For example, we
might wish to read from the erase control register of the &lt;a href=&quot;http://opencores.org/project,qspiflash&quot;&gt;flash
controller&lt;/a&gt; to see if it is still
busy.  In that case, it might be nice to write something as simple as:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_fpga&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;readio&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;R_FLASH_EREG&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;FLASH_BUSY&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The same could be said about writing to the erase control register, in order
to command the flash to erase a segment of flash memory–but that’s a topic
for a later day.&lt;/p&gt;

&lt;p&gt;For now, what about that &lt;a href=&quot;https://github.com/ZipCPU/wbscope&quot;&gt;scope&lt;/a&gt;?  Wouldn’t
it be nice to be able to reset the &lt;a href=&quot;https://github.com/ZipCPU/wbscope&quot;&gt;scope&lt;/a&gt;
for another capture?  The easiest way I can think of doing that would be
to write the new hold off to the &lt;a href=&quot;https://github.com/ZipCPU/wbscope&quot;&gt;scope&lt;/a&gt;
control register, as in:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;n&quot;&gt;m_fpga&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;writeio&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;R_SCOPE_CONTROL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;25&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;//&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;New&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;holdoff&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;is&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;25&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;clocks&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Or to read from the internal FPGA &lt;a href=&quot;https://github.com/ZipCPU/wbscope&quot;&gt;scope&lt;/a&gt;,
wouldn’t it be nice to just simply … read?&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;scope_len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;m_scope_memory&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m_fpga&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;readio&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;R_SCOPE_DATA&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;You do remember how, in our &lt;a href=&quot;/blog/2017/06/08/simple-scope.html&quot;&gt;example scope
design&lt;/a&gt;, we placed
all of the &lt;a href=&quot;https://github.com/ZipCPU/wbscope&quot;&gt;scope&lt;/a&gt;’s data at the same
register address, right?&lt;/p&gt;

&lt;p&gt;We might even manage to optimize successive reads, making a similar command
that could capture any optimizations associated with many reads in a row.
If so, we could write our for loop that read’s from the FPGA into something
that could be optimized, such as:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;n&quot;&gt;m_fpga&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;readz&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;R_SCOPE_DATA&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;scope_len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m_scope_memory&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Working on Video?  One of the hardest parts of working on Video is getting
that video information in and out of the computer.  Unlike the scope,
your video information is going to occupy successive addresses, rather
than a single data address.&lt;/p&gt;

&lt;p&gt;Wouldn’t it be nice if you could read from your video RAM area exactly what
was being transmitted, as in:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;kt&quot;&gt;uint32_t&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;m_video_image&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NUMBER_OF_PIXELS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;video_size&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NUMBER_OF_PIXELS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;m_fpga&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;readi&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;R_VIDEO_RAM&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;video_size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m_video_image&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Then, when we are done, we should close our FPGA interface via a C++ destructor
such as:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;k&quot;&gt;delete&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m_fpga&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Could we make controlling an FPGA that easy?  The answer is, Yes.  Yes, we can.
Not only can this be done, but
&lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/sw/host/wbregs.cpp&quot;&gt;wbregs&lt;/a&gt;
does it.  Sure, 
&lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/sw/host/wbregs.cpp&quot;&gt;wbregs&lt;/a&gt;
has a lot more code for error handling, and I just added code to look address
names up from linker map files, but simply reading and writing from an
FPGA is what it was designed to do.&lt;/p&gt;

&lt;h2 id=&quot;this-will-only-hurt-once&quot;&gt;This will only hurt once&lt;/h2&gt;

&lt;p&gt;Even better, after you go through the pain of building just one debugging
controller for your FPGA, you can then use it for &lt;em&gt;every one&lt;/em&gt; of your FPGA
projects.&lt;/p&gt;

&lt;p&gt;Think this one over: the debugging interface isn’t going to be graded.
(Ask your instructor if you aren’t sure of that.)  If that’s a problem,
then pull it out of your code before you turn it in.  Either way, if you
use a debugging bus in your design you will have a leg up over all of your
classmates who do not.&lt;/p&gt;

&lt;p&gt;Now, consider this sort of interface from the standpoint of the &lt;a href=&quot;/blog/2017/06/02/design-process.html&quot;&gt;FPGA expert’s
design process&lt;/a&gt;.
He’s going to build this sort of interface once, and then he’s going to use it
in all of his projects.  Some time later, he may come back and add a little
bit of capability to it, but he’ll still be using it with every project.&lt;/p&gt;

&lt;p&gt;Perhaps an example from my experience would help.  My first design was for
a &lt;a href=&quot;https://store.digilentinc.com/basys-3-artix-7-fpga-trainer-board-recommended-for-introductory-users&quot;&gt;Basys-3&lt;/a&gt; development board.  That’s where
I build the first version of my own &lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/rtl/wbubus.v&quot;&gt;FPGA debugging
interface&lt;/a&gt;.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;After I built that first interface (it was similar to the &lt;a href=&quot;https://github.com/ZipCPU/dbgbus/tree/master/hexbus&quot;&gt;hexbus
interface&lt;/a&gt; we are
building here) I became frustrated with how slow it was–particularly
when I was using it to read and write new configurations to the flash.&lt;/p&gt;

    &lt;p&gt;So, I added compression to the interface: both
&lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/rtl/wbucompress.v&quot;&gt;encoding&lt;/a&gt;
and
&lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/rtl/wbudecompress.v&quot;&gt;decoding&lt;/a&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;More recently, I got frustrated with the fact that my interface used up
a serial port, preventing my CPU from printing to the same serial port.&lt;/p&gt;

    &lt;p&gt;In this case, I restricted the debugging interface to 7-bits, and used
the high order ASCII bit to determine if the interface was communicating
printable ASCII (such as the CPU with a printf), or unprintable characters
(such as the debugging interface).  Since I was only ever using 7-bit
bytes for the debugging interface in the first place, this change was easy
to do, and it then gave me two channels of data that I could run through
my serial port.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;My point is simply this: You need to pay for your tools.  Pay the time and
energy to build them once and build them well.  Now that they are built,
use them in all of your projects.&lt;/p&gt;

&lt;p&gt;Let’s even go one step farther: I’m going to license &lt;a href=&quot;https://github.com/ZipCPU/dbgbus/tree/master/hexbus&quot;&gt;this hexbus student
interface&lt;/a&gt; that we are
building under the &lt;a href=&quot;https://www.gnu.org/licenses/lgpl-3.0.en.html&quot;&gt;LGPL&lt;/a&gt;. 
What that means is that I’ll let you copy it into your project, without being
required to post the rest of the code for your project.  If you improve upon
it, post your improvements.  If you are willing to assign ownership of those
improvements to me, then I’ll post them back into the directory for others to
use.&lt;/p&gt;

&lt;p&gt;Once we’re finished, then you, as a student, can play the role of the
expert.  You too can come to the FPGA design problem with a debugging
tool suite under your belt.&lt;/p&gt;

&lt;p&gt;This is why I &lt;a href=&quot;/blog/2017/06/02/design-process.html&quot;&gt;pointed
out&lt;/a&gt;, when
discussing how an Expert &lt;em&gt;really&lt;/em&gt; does FPGA design, that he comes to the
problem with a lot of tools already in his toolbox.&lt;/p&gt;

&lt;h2 id=&quot;just-a-simple-vision&quot;&gt;Just a simple vision&lt;/h2&gt;

&lt;p&gt;All of our work here is simply towards one single goal: to build an interface
to your FPGA that will then simplify all of your interactions with that FPGA.
Such an interface allows us to write commands to the FPGA and to read status
back out of the FPGA.  It will allow us to develop and prove that peripherals
work, and it will help us to find out why they do not work when they do not
work.&lt;/p&gt;

&lt;p&gt;This is the component most students don’t realize they are missing within their
design.&lt;/p&gt;
</description>
        <pubDate>Fri, 16 Jun 2017 00:00:00 -0400</pubDate>
        <link>http://zipcpu.com/blog/2017/06/16/dbg-bus-forest.html</link>
        <guid isPermaLink="true">http://zipcpu.com/blog/2017/06/16/dbg-bus-forest.html</guid>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>Adding interrupt reporting to our debugging bus</title>
        <description>&lt;p&gt;This post starts to complete the design of a very elementary debug port that
can be used to command an internal, on-board, wishbone bus.  Other posts in
this series include:&lt;/p&gt;

&lt;table style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 1: WB-UART Overview&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/wb-uart-smpl-2.svg&quot; alt=&quot;Block Diagram of a Simpler Wishbone to UART converter&quot; width=&quot;360&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;/blog/2017/06/05/wb-bridge-overview.html&quot;&gt;An overview of a UART to wishbone
bridge&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;How to build a &lt;a href=&quot;/blog/2017/06/08/simple-wb-master.html&quot;&gt;Simple Wishbone Master&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;How to &lt;a href=&quot;/blog/2017/06/14/creating-words-from-bytes.html&quot;&gt;create bus command words from a 7-bit data stream&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;How to &lt;a href=&quot;/blog/2017/06/14/words-back-to-bytes.html&quot;&gt;turn the bus master responses back into a serial stream&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;We’ve now just about got a fully functional wishbone master controlled from a
serial stream that can now be used as a debugging bus. 
We’ve worked out how to get a serial port up and running,
how to &lt;a href=&quot;/blog/2017/06/14/creating-words-from-bytes.html&quot;&gt;create words from the serial
stream&lt;/a&gt;, and
&lt;a href=&quot;/blog/2017/06/08/simple-wb-master.html&quot;&gt;how to control a simple wishbone bus
master&lt;/a&gt;
from the command words running through this stream, and then &lt;a href=&quot;/blog/2017/06/14/words-back-to-bytes.html&quot;&gt;how to send
the response words back down the serial port&lt;/a&gt;.  The result is a &lt;em&gt;very simple&lt;/em&gt; debugging capability.&lt;/p&gt;

&lt;p&gt;While simple, nothing keeps this capability from being very successful within
someone’s design.  This lesson is about adding interrupt notification to the
output stream of our debugging port.&lt;/p&gt;

&lt;h2 id=&quot;interrupt-requirements&quot;&gt;Interrupt Requirements&lt;/h2&gt;

&lt;p&gt;For our purposes, we’ll define an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interrupt&quot;&gt;interrupt&lt;/a&gt; as the notification of an
event having taken place.  Example interrupts might be that the wishbone scope
has tripped, or that the flash controller has finished erasing or programming
flash.  Either way, some sort of notification has taken place, and you’d like
to be notified of it.&lt;/p&gt;

&lt;p&gt;We’ll require this of our interrupt processing:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;When an interrupt takes place, we’d like to be informed.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;We don’t want to be informed twice for the same interrupt.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;We don’t want to need to control the bus interface, but rather the FPGA.
Hence, any internal interrupt state within the bus interface should be self
clearing.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The interrupt notification should only get inserted into the stream when
the stream is idle.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Hence, whenever the interrupt line is raised, we’ll consider that an
interrupt condition has taken place.  We’ll send an interrupt character (“I”)
across the channel.  No more interrupt notifications will be sent across the
channel until the “I” has been committed to, and the interrupt line has gone
low.&lt;/p&gt;

&lt;p&gt;Sound simple enough?&lt;/p&gt;

&lt;h2 id=&quot;the-interrupt-stream-processor&quot;&gt;The interrupt stream processor&lt;/h2&gt;

&lt;p&gt;This processor is almost simplicity itself.&lt;/p&gt;

&lt;p&gt;We’ll start with the definition of the interrupt command word that we will be
inserting into our stream.  It is a &lt;em&gt;special&lt;/em&gt; word, and so it begins with
2’b11.  After that, it is the 2nd special word, so we have a prefix of
5’h11010.  The rest of the interrupt word we set to zero.  That allows us to
extend our protocol later, should we wish to, with 29 bits of information or
zeros to indicate no information.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;`define	INT_PREFIX	5&#39;b11010
`define	INT_WORD	{ `INT_PREFIX, {(34-5){1&#39;b0}} }&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;I should mention, at this point, a quick lesson in programming practice.  The
first time I built this controller, I didn’t define these values at the top
of the file.  Then, when I needed to change them, I missed changing all of them.
By having `define statements at the top, one change to this definition
will changes all of its uses later.&lt;/p&gt;

&lt;p&gt;Our processing will focus around two primary registers: &lt;strong&gt;int_state&lt;/strong&gt; and
&lt;strong&gt;pending_interrupt&lt;/strong&gt;.  The idea is basically this: when an interrupt takes
place, we’ll go into our interrupt state, and set the interrupt to be pending.
In other words, we are waiting to send the value out the port.  Once the
value has been sent, the pending register will clear, but we’ll stay in our
interrupt state until the interrupt itself clears.&lt;/p&gt;

&lt;p&gt;Here you can see that logic below.  First, for the &lt;strong&gt;int_state&lt;/strong&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;initial	int_state = 1&#39;b0;
always @(posedge i_clk)
	if (i_reset)
		int_state &amp;lt;= 1&#39;b0;
	else if ((i_interrupt)&amp;amp;&amp;amp;(!int_state))
		int_state &amp;lt;= 1&#39;b1;
	else if ((!pending_interrupt)&amp;amp;&amp;amp;(!i_interrupt))
		int_state &amp;lt;= 1&#39;b0;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Note that this state register is only cleared when the interrupt line goes
low &lt;strong&gt;and&lt;/strong&gt; the pending line has gone low, indicating that both we have sent
the interrupt word forward, and that the interrupt has cleared itself.&lt;/p&gt;

&lt;p&gt;Then, here’s the same logic but for the &lt;strong&gt;pending_int&lt;/strong&gt;.  Note that this
one is cleared whenever the interrupt word is actually sent down stream.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;initial	pending_interrupt = 1&#39;b0;
always @(posedge i_clk)
	if (i_reset)
		pending_interrupt &amp;lt;= 1&#39;b0;
	else if ((i_interrupt)&amp;amp;&amp;amp;(!int_state))
		pending_interrupt &amp;lt;= 1&#39;b1;
	else if ((o_int_stb)&amp;amp;&amp;amp;(!i_busy)
			&amp;amp;&amp;amp;(o_int_word[33:29] == `INT_PREFIX))
		pending_interrupt &amp;lt;= 1&#39;b0;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The rest of our logic is mostly stream processing.&lt;/p&gt;

&lt;p&gt;For example, we’d like to know when we have a valid word loaded into our
output register, so that the interrupt never slows down our communications
stream, but only inserts itself when we are idle.  If a word is loaded, and
waiting to be sent, then we won’t insert an interrupt into the stream.&lt;/p&gt;

&lt;p&gt;We’ll consider a response word to be loaded any time the incoming strobe
is true, and we’ll clear the condition whenever that word gets written our
the output port.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;initial	loaded = 1&#39;b0;
always @(posedge i_clk)
	if (i_reset)
		loaded &amp;lt;= 1&#39;b0;
	else if (i_stb)
		loaded &amp;lt;= 1&#39;b1;
	else if ((o_int_stb)&amp;amp;&amp;amp;(!i_busy))
		loaded &amp;lt;= 1&#39;b0;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;But when do we have something to write?  Obviously we have something to write
when something is given to us, as in whenever &lt;strong&gt;i_stb&lt;/strong&gt; is true.  But we
also want to make certain we have something to write anytime we have a 
&lt;strong&gt;pending_interrupt&lt;/strong&gt;.  We’ll clear our output request upon a write, as
long as we don’t have a pending interrupt request.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;initial	o_int_stb = 1&#39;b0;
always @(posedge i_clk)
	if (i_reset)
		o_int_stb &amp;lt;= 1&#39;b0;
	else if (i_stb)
		o_int_stb &amp;lt;= 1&#39;b1;
	else if (pending_interrupt)
		o_int_stb &amp;lt;= 1&#39;b1;
	else if ((!loaded)||(!i_busy))
		o_int_stb &amp;lt;= 1&#39;b0;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The consequence of this logic is that once there is an interrupt waiting to
be inserted into the output stream, &lt;strong&gt;o_int_stb&lt;/strong&gt; will remain high until
it is sent.  Likewise, any time there is a word requested, &lt;strong&gt;o_int_stb&lt;/strong&gt;
will also remain high.  It’s not going to dip low anytime something moves
in the downstream direction.&lt;/p&gt;

&lt;p&gt;Finally, what word shall be sent?  Whenever a request is made, we’ll send
the incoming word.  So that we wait for the request, we’ll wait until the
request is made &lt;strong&gt;and&lt;/strong&gt; we don’t have a valid request loaded into our
outgoing register.  If there is no incoming request, then we’ll automatically
load our interrupt word.  This will get ignored, though, unless the
&lt;strong&gt;o_int_stb&lt;/strong&gt; line is also high.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	if ((i_stb)&amp;amp;&amp;amp;(!loaded))
		o_int_word &amp;lt;= i_word;
	else if ((pending_interrupt)&amp;amp;&amp;amp;(!loaded))
		// Send an interrupt
		o_int_word &amp;lt;= `INT_WORD;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h2 id=&quot;future-posts&quot;&gt;Future Posts&lt;/h2&gt;

&lt;p&gt;Adding this one simple capability into our response stream was very easily
done.  We’ll add idles into this stream next to identify our stream as being
used for this purpose.  I think you’ll find, when we add the idles in, that
the idles are just about as easy as the interrupts are.&lt;/p&gt;

&lt;p&gt;After we add idle’s, all of the Verilog will be in place.  The next step
will be to create a simple wishbone interconnect, and then the Verilator
test bench necessary to try this out before deploying it on an actual FPGA.&lt;/p&gt;

&lt;p&gt;This means we still have the following topics to come:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;/blog/2017/06/19/debug-idles.html&quot;&gt;Adding idle notifications&lt;/a&gt; to let you know you are connected to the right
stream&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Connecting the bus streaming components together&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Creating a simple wishbone interconnect&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Creating a hand-controlled test bench to prove this works&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Creating a software bus controller&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Indeed, if you wanted to try this controller out, it’s far enough along that
you could probably start working with it today.  Just be aware–it doesn’t
have any FIFO support.  If you try to read from this bus too fast, or write
to it too fast, you may find either your commands or their responses getting
lost.  Perhaps we should add a FIFO to our additional topics list as well, then.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Adding in FIFO support&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Sound interesting?  Write me if you try this, and let me know how it goes.&lt;/p&gt;

</description>
        <pubDate>Fri, 16 Jun 2017 00:00:00 -0400</pubDate>
        <link>http://zipcpu.com/blog/2017/06/16/adding-ints.html</link>
        <guid isPermaLink="true">http://zipcpu.com/blog/2017/06/16/adding-ints.html</guid>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>How to send our bus results back out the serial port</title>
        <description>&lt;p&gt;This post starts to complete the design of a very elementary debug port that
can be used to command an internal, on-board, wishbone bus.  Other posts in
this series include:&lt;/p&gt;

&lt;table style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 1: DBG Port Overview&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/wb-uart-smpl-2.svg&quot; alt=&quot;Block Diagram of a Simpler Wishbone to UART converter&quot; width=&quot;360&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;/blog/2017/06/05/wb-bridge-overview.html&quot;&gt;An overview of a UART to wishbone
bridge&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;How to build a &lt;a href=&quot;/blog/2017/06/08/simple-wb-master.html&quot;&gt;Simple Wishbone Master&lt;/a&gt;, and&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;How to &lt;a href=&quot;/blog/2017/06/14/creating-words-from-bytes.html&quot;&gt;create bus command words from a 7-bit data stream&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;We’ve slowly been building up to the implementation of a WB-UART component,
such as that in Fig 1.&lt;/p&gt;

&lt;p&gt;A this point, we’ve now described how to get a serial port up and running,
how to &lt;a href=&quot;/blog/2017/06/14/creating-words-from-bytes.html&quot;&gt;create words from the serial
stream&lt;/a&gt;, and
&lt;a href=&quot;/blog/2017/06/08/simple-wb-master.html&quot;&gt;how to control a simple wishbone bus
master&lt;/a&gt;
from the command words running through this stream.  We are very close to having
a working debug bus–since we can add the FIFOs and interrupts in later if
we have to.&lt;/p&gt;

&lt;p&gt;This lesson is about what it takes to turn the response words from the bus
master into a characters that will be sent out the output transport.  The
output transport, as you will recall, has a functionality similar to a
serial port.  Indeed, it might be a serial port, although it doesn’t need
to be.&lt;/p&gt;

&lt;h2 id=&quot;stream-timing&quot;&gt;Stream timing&lt;/h2&gt;

&lt;p&gt;Before we start, though, let’s examine how to handle stream timing.  Our
problem is that we will be generating words to be sent out of our serial
port at a rate that is much faster than the port can handle.  We’re going to
want to make certain that these response words are not lost–in spite of the
speed differential.&lt;/p&gt;

&lt;p&gt;Earlier, we described &lt;a href=&quot;/blog/2017/06/02/generating-timing.html&quot;&gt;how to build a strobe type of
signal&lt;/a&gt;.  For our purposes here, the
strobe signal was one that was valid for a single clock only.  Here, we are
also going to use a busy signal.  The two signals will work together in the
following way: the strobe will indicate a desire to send a word downstream,
while the busy response from the next component will be used to indicate that
the downstream component is not ready to receive.  To deal with this, once we
set our strobe we will continue to hold it high (request data be sent)
until the downstream components busy but is cleared.&lt;/p&gt;

&lt;p&gt;Conditions for moving forward will therefore look something like …&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;if ((i_stb)&amp;amp;&amp;amp;(!o_dw_busy))
	....&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This condition will be true any time we accept a request to send a word.&lt;/p&gt;

&lt;p&gt;Likewise, there is a similar condition on the downstream side of any stream
component:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;if ((o_dw_stb)&amp;amp;&amp;amp;(!i_tx_busy))
	....&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Prefixes will change depending upon which side of the link we are on, or
which components we are using, but the logic is going to be the same every
time.&lt;/p&gt;

&lt;p&gt;Now, with that out of the way, we can disassemble our words into a serial
port output channel.&lt;/p&gt;

&lt;h2 id=&quot;breaking-words-into-nibbles&quot;&gt;Breaking Words into nibbles&lt;/h2&gt;

&lt;p&gt;The trick to making any stream processing work is to only do a little bit of
processing at each step.  Hence for our first step, we turn our response
word into bytes.&lt;/p&gt;

&lt;p&gt;There are a couple primary variables to make this work.  The first one is
the word buffer, &lt;strong&gt;r_word&lt;/strong&gt;.  This buffer holds what is left of our response
word that has not yet been sent.  The next variable is the &lt;strong&gt;r_len&lt;/strong&gt; word
that holds how many valid nibbles remain in our &lt;strong&gt;r_word&lt;/strong&gt; register.&lt;/p&gt;

&lt;p&gt;Hence, on any new incoming word, as long as we are not busy, we send
a nibble noting the top two bits (Read data, write acknowledgement, etc.), and
we note that the register now has eight
nibbles within it.  In the case of any special words, we instead send the top
five bits of the command word and nothing more.  Other protocols would work
as well, this is just what we are going to choose.&lt;/p&gt;

&lt;p&gt;Here’s the big always blog for what we want to do.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	if (i_reset)
	begin
		// On reset, clear our variables
		r_word &amp;lt;= 0;
		r_len  &amp;lt;= 0;
		o_dw_stb  &amp;lt;= 1&#39;b0;
		o_dw_bits &amp;lt;= 5&#39;h0;
	end else if ((i_stb)&amp;amp;&amp;amp;(!o_dw_busy))
	begin			
		// If we are not busy, then load a new command
		// into our buffer to be sent
		r_word &amp;lt;= i_word[31:0];
		r_len  &amp;lt;= 4&#39;h8;

		o_dw_stb &amp;lt;= 1&#39;b1;
		o_dw_bits &amp;lt;= { 3&#39;b100, i_word[33:32] };
		if (i_word[33:32]==2&#39;b11)
		begin
			// If this is a special command,
			// grab all top 5-bits to output
			// them
			o_dw_bits &amp;lt;= i_word[33:29];
			r_len &amp;lt;= 4&#39;h0;
		end else if (i_word[33:32] == 2&#39;b01)
		begin // On an ACK, print only the &#39;K&#39;
			// and nothing more
			r_len &amp;lt;= 4&#39;h0;
		end
	end else if ((o_dw_stb)&amp;amp;&amp;amp;(!i_tx_busy))
	begin
		// Our last byte was accepted, move to the next one
		if (r_len != 4&#39;h0)
		begin
			o_dw_stb  &amp;lt;= 1&#39;b1;
			o_dw_bits &amp;lt;= { 1&#39;b0, r_word[31:28] };
			r_word &amp;lt;= { r_word[27:0], 4&#39;h0 };
			r_len  &amp;lt;= r_len - 1&#39;b1;
		end else
			o_dw_stb  &amp;lt;= 1&#39;b0;
	end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;We’ll simplify this giant always block by first removing the reset logic
from it.  Indeed, the only things that need reset logic are the &lt;strong&gt;r_len&lt;/strong&gt;
and &lt;strong&gt;o_dw_stb&lt;/strong&gt; registers.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
if (i_reset)
begin
	r_len &amp;lt;= 0;
	o_dw_stb &amp;lt;= 0;
end else if ((i_stb)&amp;amp;&amp;amp;(!o_dw_busy))
begin
	o_dw_stb &amp;lt;= 1&#39;b1;
	if (i_word[33:32]==2&#39;b11)
		r_len &amp;lt;= 4&#39;h0;
	else
		r_len &amp;lt;= 4&#39;h8;
end else if (!i_tx_busy)
begin
	o_dw_stb &amp;lt;= (r_len != 4&#39;h0);
	if (r_len != 4&#39;h0)
		r_len &amp;lt;= r_len - 1&#39;b1;
end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;You should find this logic identical to the big always block above.&lt;/p&gt;

&lt;p&gt;The rest of our logic, to include all the various wires associated with
the word register &lt;strong&gt;r_word&lt;/strong&gt; can then be drastically simplified.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
// No reset logic needed
if ((i_stb)&amp;amp;&amp;amp;(!o_dw_busy))
begin
	// On any new word, set the result
	r_word &amp;lt;= i_word;
end else if (!i_tx_busy)
	// Whenever we aren&#39;t busy, a new nibble is accepted
	// and the word shifts.  If we never set our output
	// strobe, this will never become busy, but if the
	// register isn&#39;t in use, there&#39;s no penalty to clearing
	// it repeatedly.
	r_word &amp;lt;= { r_word[27:0], 4&#39;h0 };&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Even the outputs may be set quite simply.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
if ((i_stb)&amp;amp;&amp;amp;(!o_dw_busy))
begin
	if (i_word[33:32] == 2&#39;b11)
		o_dw_bits &amp;lt;= i_word[33:29];
	else
		o_dw_bits &amp;lt;= { 3&#39;b100, i_word[33:32] };
end else if (i_tx_busy)
	o_dw_bits &amp;lt;= { 1&#39;b0, r_word[31:28] };&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;If you look over the difference between what we started with and where we
ended up, there’s a lot of differences.  All of these differences translate
into fewer resources in our output.  They can basically be summarized by this:
if you don’t care the what the value of a register is under certain conditions,
then don’t make that register depend upon those conditions.  Remember, the
resources used by a piece of logic can be (roughly) calculated by the number
of inputs that piece of logic requires.&lt;/p&gt;

&lt;h2 id=&quot;turning-nibbles-into-characters&quot;&gt;Turning nibbles into characters&lt;/h2&gt;

&lt;p&gt;The next step on the output process is to turn this stream of nibbles into
output characters.  This is almost a pure lookup table, but the stream
logic keeps it from being quite that.&lt;/p&gt;

&lt;p&gt;The stream logic consists of paying attention to the busy and strobe flags
to determine when we have an output to send.  In particular, if we are not
busy and a request is made of us, we’ll forward it down the line.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	if ((i_stb)&amp;amp;&amp;amp;(!o_gx_busy))
		// On a new request, send it forward
		o_gx_stb &amp;lt;= 1&#39;b1;
	else if (!i_busy)
		o_gx_stb &amp;lt;= 1&#39;b0;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Since we don’t have more than a single clock’s worth of processing to do here,
we can just set the busy bit to be the same as our output strobe bit.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;assign	o_gx_busy = o_gx_stb;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The real work is in the lookup table.  When given a value between 5’h0 and
5’hf, we just send the hexadecimal output.  Values with the 5’h10 bit set
indicate we need to send a special character.  You can see the special
characters we support below.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	if ((i_stb)&amp;amp;&amp;amp;(!o_gx_busy))
	begin
		case(i_bits)
		5&#39;h00: o_gx_char &amp;lt;= &quot;0&quot;;
		5&#39;h01: o_gx_char &amp;lt;= &quot;1&quot;;
		5&#39;h02: o_gx_char &amp;lt;= &quot;2&quot;;
		5&#39;h03: o_gx_char &amp;lt;= &quot;3&quot;;
		5&#39;h04: o_gx_char &amp;lt;= &quot;4&quot;;
		5&#39;h05: o_gx_char &amp;lt;= &quot;5&quot;;
		5&#39;h06: o_gx_char &amp;lt;= &quot;6&quot;;
		5&#39;h07: o_gx_char &amp;lt;= &quot;7&quot;;
		5&#39;h08: o_gx_char &amp;lt;= &quot;8&quot;;
		5&#39;h09: o_gx_char &amp;lt;= &quot;9&quot;;
		5&#39;h0a: o_gx_char &amp;lt;= &quot;a&quot;;
		5&#39;h0b: o_gx_char &amp;lt;= &quot;b&quot;;
		5&#39;h0c: o_gx_char &amp;lt;= &quot;c&quot;;
		5&#39;h0d: o_gx_char &amp;lt;= &quot;d&quot;;
		5&#39;h0e: o_gx_char &amp;lt;= &quot;e&quot;;
		5&#39;h0f: o_gx_char &amp;lt;= &quot;f&quot;;
		//
		5&#39;h10: o_gx_char &amp;lt;= &quot;R&quot;;	// Read response w/data
		5&#39;h11: o_gx_char &amp;lt;= &quot;K&quot;;	// Write ACK
		5&#39;h12: o_gx_char &amp;lt;= &quot;A&quot;;	// Address was set
		5&#39;h13: o_gx_char &amp;lt;= &quot;S&quot;;	// Special
		//
		5&#39;h18: o_gx_char &amp;lt;= &quot;T&quot;;	// reseT
		5&#39;h19: o_gx_char &amp;lt;= &quot;E&quot;;	// BUS Error
		5&#39;h1a: o_gx_char &amp;lt;= &quot;I&quot;;	// Interrupt
		5&#39;h1b: o_gx_char &amp;lt;= &quot;Z&quot;;	// I&#39;m here, but slping
		default: o_gx_char &amp;lt;= 8&#39;hd;	// Carriage return
		endcase
	end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Unknown characters just get quietly turned into carriage returns, which
the next module turns into carriage return and newline pairs (CR/NL).&lt;/p&gt;

&lt;h2 id=&quot;adding-carriage-returns-and-newlines-to-the-stream&quot;&gt;Adding Carriage Returns and Newlines to the Stream&lt;/h2&gt;

&lt;p&gt;The final step is to add a carriage return/newline pair to our output stream
any time it becomes idle.  This will assist any buffered software following
that might depend upon the end of a line before forwarding the data received.&lt;/p&gt;

&lt;p&gt;To do this, we’ll create a new stream component in our processing chain.
Any characters given to this stream will just send their characters back
out the port.  But, if the port is idle we’ll insert a carriage return into
the stream.  Then, any time a carriage return is sent out, we’ll set a register
&lt;strong&gt;last_cr&lt;/strong&gt; to indicate that we’ve sent one carriage return, and don’t need
to send it again.  This value will clear upon any new and valid data from
the port.&lt;/p&gt;

&lt;p&gt;The next state variable we’ll use is &lt;strong&gt;cr_state&lt;/strong&gt;.  This variable will be
set at anytime &lt;strong&gt;last_cr&lt;/strong&gt; is set, and we’ll clear it upon sending a newline.&lt;/p&gt;

&lt;p&gt;Put together, any time we enter our newline state, we’ll set &lt;strong&gt;last_cr&lt;/strong&gt; and
set &lt;strong&gt;cr_state&lt;/strong&gt;.  After the carriage return is sent, we’ll send a newline
and clear &lt;strong&gt;cr_state&lt;/strong&gt;.  We’ll then stay in that state until anything
else is sent through the port.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	if (i_reset)
	begin
		// On reset, act as though we&#39;ve already sent
		// a CR/NL pair
		cr_state &amp;lt;= 1&#39;b0;
		last_cr  &amp;lt;= 1&#39;b0;
		o_nl_stb &amp;lt;= 1&#39;b0;
	end else if ((i_stb)&amp;amp;&amp;amp;(!o_nl_busy))
	begin
		// On any input, set the last_cr bit if it was
		// a carriage return, and clear it otherwise. 
		// Clear the cr_state bit either way.
		o_nl_stb  &amp;lt;= i_stb;
		o_nl_byte &amp;lt;= i_byte;
		cr_state &amp;lt;= 1&#39;b0;
		last_cr &amp;lt;= (i_byte[7:0] == 8&#39;hd);
	end else if ((o_nl_busy)&amp;amp;&amp;amp;(!i_busy))
	begin
		// If we&#39;ve just sent something, let&#39;s check
		// if we need to send a cr/newline pair
		if (!last_cr)
		begin
			// We haven&#39;t sent a carriage
			// return.  So, send it if the
			// input is idle.
			cr_state  &amp;lt;= (!i_stb);
			o_nl_byte &amp;lt;= 8&#39;hd;
			last_cr   &amp;lt;= (!i_stb);
			o_nl_stb  &amp;lt;= (!i_stb);
		end else if (cr_state)
		begin
			// We&#39;ve sent the carriage
			// return, but not the newline.
			// Send the newline now.
			cr_state  &amp;lt;= 1&#39;b0;
			o_nl_byte &amp;lt;= 8&#39;ha;
			o_nl_stb  &amp;lt;= 1&#39;b1;
		end else
			// Idle the channel
			o_nl_stb  &amp;lt;= 1&#39;b0;
	end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h2 id=&quot;future-posts&quot;&gt;Future Posts&lt;/h2&gt;

&lt;p&gt;There, that’s all there is to it!  You now know how to take a response word
from the wishbone bus master, and how to send that result back out a serial
port.&lt;/p&gt;

&lt;p&gt;While we’ve just about presented all of the components, and while you almost
have a usable bus at this point, we’re not there yet.  Some particular
functionality remains missing.  This includes:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;/blog/2017/06/16/adding-ints.html&quot;&gt;Adding interrupt notifications&lt;/a&gt; to the response stream&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;/blog/2017/06/19/debug-idles.html&quot;&gt;Adding idle notifications&lt;/a&gt; to let you know you are connected to the right
stream&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Creating a simple wishbone interconnect&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Creating a hand-controlled test bench to prove this works&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Creating a software bus controller&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Now that our controller is nearly complete, though, these will be much simpler
topics.  We’ll come back to them in future posts.&lt;/p&gt;
</description>
        <pubDate>Thu, 15 Jun 2017 00:00:00 -0400</pubDate>
        <link>http://zipcpu.com/blog/2017/06/15/words-back-to-bytes.html</link>
        <guid isPermaLink="true">http://zipcpu.com/blog/2017/06/15/words-back-to-bytes.html</guid>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>No PI for you</title>
        <description>&lt;p&gt;FPGA’s can handle simple things well, and they handle simple things fast.
Other things like &lt;a href=&quot;https://en.wikipedia.org/wiki/Pi&quot;&gt;PI&lt;/a&gt;
(&lt;a href=&quot;https://www.angio.net/pi/digits/100000.txt&quot;&gt;3.141592653…&lt;/a&gt;) are harder to
deal with.  How then shall phase be dealt with within an FPGA, and in what
units?&lt;/p&gt;

&lt;p&gt;The mathematicians will define phase in units of
&lt;a href=&quot;https://en.wikipedia.org/wiki/Radian&quot;&gt;Radians&lt;/a&gt;, with values ranging
between zero and 2PI.  Further, the units are periodic, so anything outside
of the range between zero and 2PI may be brought into the range by adding
as many 2PI values as necessary.&lt;/p&gt;

&lt;p&gt;Others will define phase as a number between 0 and
360 degrees.&lt;/p&gt;

&lt;p&gt;Both refer to the same thing–the measure of time within a
periodic waveform from the beginning of the period.&lt;/p&gt;

&lt;p&gt;While Radians may be the natural units of phase (angles), they are not the
first choice of the FPGA designer.  Why not?&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;FPGA’s need to have a known number of bits to represent something.  If you
allocate enough bits to handle 0 to 8 (containing 0 to 2PI, or 6.28..),
you’ll have a difficult time dealing with 16PI.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Radian&quot;&gt;Radians&lt;/a&gt; have
roll over problems.  While both PI and 3PI/2 are valid angles
between 0 and 2PI, their sum is outside of the
range between 0 and 2PI.  Before you can use this out-of-range value,
and before you can add any more phase increments to it, the number must be
normalized by subtracting 2PI from it to get it back into the range of
0 to 2PI.&lt;/p&gt;

    &lt;p&gt;This will cost you a clock, and slow any algorithm you are building down by
a factor of two.&lt;/p&gt;

    &lt;p&gt;It will also only work if your wander into the range between 2PI and
4PI, but not between 50PI and 52PI.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;FPGA’s can’t really handle numbers between 0 and 1.&lt;/p&gt;

    &lt;p&gt;This problem is so common and the solution so well known that aspiring FPGA
DSP engineers might just multiply the values from 0 to PI by 2^N and consider
that the solution without ever thinking twice.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;While these might seem like viable solutions, a better approach
to dealing with angles exists.&lt;/p&gt;

&lt;h2 id=&quot;a-better-unit-for-angles&quot;&gt;A Better Unit for Angles&lt;/h2&gt;

&lt;p&gt;A simpler and better angular unit choice is simply to map the range from 0
to 2PI onto the integer interval from 0 to 2^N-1.  This can then be represented
with an N-bit number.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;fpga_val = floor( theta * 2^N / (2PI) + 0.5)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;What’s neat about this approach to angles within an FPGA is that rollover
is handled naturally, with no other logic required.&lt;/p&gt;

&lt;p&gt;Consider how one might add PI to 3PI/2.  We’ll use N=8, and so we’ll be
representing angles with to within a degree or two.  Hence,
our expression becomes 8’h80 plus 8’hc0.  If you add these two values together,
and throw out any rollover, you get the value 8’h40.&lt;/p&gt;

&lt;p&gt;Notice from this example how we didn’t need to waste a clock to bring our
results back within limits.  Neither were we restricted to only integer
Radian values, even though we did our calculation with integers.&lt;/p&gt;

&lt;p&gt;Even better, FPGA’s are often optimized for integer arithmetic.  Hence,
angular adjustments made in this fashion become easy and simple.&lt;/p&gt;

&lt;h2 id=&quot;generating-sine-or-cosine&quot;&gt;Generating Sine or Cosine&lt;/h2&gt;

&lt;p&gt;Depending upon your needs, you can easily convert this angle to a sine and
cosine value.&lt;/p&gt;

&lt;p&gt;For example, you could use the top bit as your sine wave value, and get a
square wave out with no more work.  This was the approach used by the &lt;a href=&quot;https://github.com/ZipCPU/wbfmtx&quot;&gt;wishbone
controlled FM transmitter hack&lt;/a&gt; in order
to transmit an FM signal from an FPGA.&lt;/p&gt;

&lt;p&gt;You could also use the top several bits as an index into a table, and so build
a direct digital synthesizer.&lt;/p&gt;

&lt;p&gt;Even slicker is to use your angle as an input to a &lt;a href=&quot;http://www.andraka.com/files/crdcsrvy.pdf&quot;&gt;CORDIC
algorithm&lt;/a&gt;.  In that
case, you can use this angle as an input to generate a sine wave or cosine
wave.  You can also use the &lt;a href=&quot;http://www.andraka.com/files/crdcsrvy.pdf&quot;&gt;CORDIC
algorithm&lt;/a&gt;
to multiply by sine and cosine (at the same time), or take arc-tangents.
If you like this idea, you ought to know that the &lt;a href=&quot;http://www.andraka.com/files/crdcsrvy.pdf&quot;&gt;CORDIC
algorithm&lt;/a&gt; can be pipelined so
as to operate at one input/output per clock–with no throughput loss, such as
you would’ve had were you using either
&lt;a href=&quot;https://en.wikipedia.org/wiki/Radian&quot;&gt;Radians&lt;/a&gt; or
&lt;a href=&quot;https://en.wikipedia.org/wiki/Degree_(angle)&quot;&gt;degrees&lt;/a&gt; as your angular units.&lt;/p&gt;

&lt;p&gt;Gosh, the &lt;a href=&quot;http://www.andraka.com/files/crdcsrvy.pdf&quot;&gt;CORDIC algorithm&lt;/a&gt; is just
&lt;em&gt;so&lt;/em&gt; useful, we might need to write a post on it by itself.&lt;/p&gt;

&lt;p&gt;Coming back to our topic, though, all of these approaches to generating sine
waves work nicely … but only if you use the right angular units.&lt;/p&gt;
</description>
        <pubDate>Thu, 15 Jun 2017 00:00:00 -0400</pubDate>
        <link>http://zipcpu.com/dsp/2017/06/15/no-pi-for-you.html</link>
        <guid isPermaLink="true">http://zipcpu.com/dsp/2017/06/15/no-pi-for-you.html</guid>
        
        
        <category>dsp</category>
        
      </item>
    
      <item>
        <title>How to create bus command words, from a 7-bit data stream</title>
        <description>&lt;p&gt;This is our next post in how to build a
&lt;a href=&quot;http://opencores.org/opencores,wishbone&quot;&gt;wishbone&lt;/a&gt; controlled debugging port
into your design.  Other posts on this topic include:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;/blog/2017/06/05/wb-bridge-overview.html&quot;&gt;An overview of a UART to wishbone
bridge&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;Don’t let the title fool you.  The &lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/rtl/wbubus.v&quot;&gt;UART to wishbone
bridge&lt;/a&gt; was my
first debugging bus.  It was so versatile, that I’ve rebuilt it for many other
platforms–not all of them using a &lt;a href=&quot;https://github.com/ZipCPU/wbuart32&quot;&gt;UART (serial)&lt;/a&gt; port.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;How to build a &lt;a href=&quot;/blog/2017/06/08/simple-wb-master.html&quot;&gt;Simple Wishbone Master&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;table style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 1: WB-UART Overview&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/wb-uart-smpl-2.svg&quot; alt=&quot;Block Diagram of a Simpler Wishbone to UART converter&quot; width=&quot;360&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;These two articles have presented the overview shown in Fig. 1 as a simple
bus overview that we might use.  Using this overview as a guide, we’ve discussed
how to build the
&lt;a href=&quot;/blog/2017/06/08/simple-wb-master.html&quot;&gt;bus master&lt;/a&gt;.
We’ve said nothing (yet) about FIFO’s, resets, interrupts, or converting
response words back to bytes.  Today, though, we’re going to discuss how to
create the command words from the incoming interface.  We’ll also use this
incoming port to generate a reset for the rest of the port.&lt;/p&gt;

&lt;p&gt;We’ll do this in two parts.  The &lt;a href=&quot;https://github.com/ZipCPU/dbgbus/blob/master/rtl/hexbus/wbdechex.v&quot;&gt;first
part&lt;/a&gt; will
turn our 7-bit incoming printable ASCII bytes into a shorter, simpler, 5’bit
values formatted to be used by the next component.  The &lt;a href=&quot;https://github.com/ZipCPU/dbgbus/blob/master/rtl/hexbus/wbpack.v&quot;&gt;second
part&lt;/a&gt; will
actually pack these bits into words and send them to our 
&lt;a href=&quot;https://github.com/ZipCPU/dbgbus/blob/master/rtl/hexbus/wbexec.v&quot;&gt;bus master&lt;/a&gt;
(since we have no FIFO yet …).&lt;/p&gt;

&lt;h2 id=&quot;design-outline&quot;&gt;Design Outline&lt;/h2&gt;

&lt;p&gt;We’d like to turn printable ASCII into command words.  We’re going to
design this ASCII in such a fashion that every command word will begin with
a capitol letter identifying the command, and end with 0-8 nibbles of
hexadecimal characters.  So, let’s look at what that requires:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Addresses will begin with an “A” character.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Read requests will consist of an “R” character alone.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Write requests will consist of an “W” character.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Reset requests consist of a “T” character.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Write requests and address values will be followed by 0-8 nibbles of value.
This value will encode either the value to be written, or the new address
to be set.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Unspecified command word bits will be set to zero, allowing unsigned
extensions of words.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Addresses will end in multiples of four.  If the 2 bit is set on an address,
the value will be added to the last address register.  If the 1 bit is clear,
the address will be incremented (by 4) on every read or write.  Hence,
“A2040RRRR” should read four consecutive values from the 0x02040 address.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Some examples of this coding would be:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Read from address 0x2040.&lt;/li&gt;
&lt;/ul&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;A2040R&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;ul&gt;
  &lt;li&gt;Write 0xdeadbeef to the address 0x2044&lt;/li&gt;
&lt;/ul&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;A2044Wdeadbeef&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;ul&gt;
  &lt;li&gt;Write a 1 to the next four consecutive addresses&lt;/li&gt;
&lt;/ul&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;W1W1W1W1&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Our encoding will need to turn these sorts of commands into 34-bit command
words suitable for the
&lt;a href=&quot;https://github.com/ZipCPU/dbgbus/blob/master/rtl/hexbus/wbexec.v&quot;&gt;bus master&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;transforming-printable-ascii-to-binary-nibbles&quot;&gt;Transforming Printable ASCII to Binary Nibbles&lt;/h2&gt;

&lt;p&gt;As outlined above, we’re going to focus on a hexadecimal encoding format. 
This is simply for the purpose of keeping the encoding simple enough so that
you can either type the value in via a keyboard, or perhaps read and comprehend
it when two pieces of software are talking to each other.  In both cases, you
want the command channel to be comprehensible.&lt;/p&gt;

&lt;p&gt;For this purpose, the values ‘0’-‘9’, and ‘a’-‘f’ will be transformed into
bit values 5’h0 to 5’hf.  Yes, that is a &lt;em&gt;five&lt;/em&gt; bit encoding we’re going to
use to go to the next step.&lt;/p&gt;

&lt;p&gt;Why?  If we are using a hexadecimal encoding, why do we need five bits?&lt;/p&gt;

&lt;p&gt;We’ll use the fifth bit to tell us some extra information: is this a read
request, a write command, a new address or a reset command?  These extra
options will use that extra bit, and we’ll generate it from specific
letters that aren’t part of the hexadecimal encoding.&lt;/p&gt;

&lt;p&gt;For example, if the user types a “T”, we’ll use that as an indication that
we want to reset our entire debugging bus component.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	o_reset &amp;lt;= (i_stb)&amp;amp;&amp;amp;(i_byte[6:0] == 7&#39;h54);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Otherwise, if we receive anything other than an incoming nothing character
7’h7f, we’ll be producing an output.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	o_stb   &amp;lt;= (i_stb)&amp;amp;&amp;amp;(i_byte[6:0] != 7&#39;h7f);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;All that’s left here is to decide what that output value will be.&lt;/p&gt;

&lt;p&gt;We’ll handle that with a giant case statement.  Although this may look complex,
once it gets turned into FPGA logic, this is nothing more than a 7-bit lookup
table per output bit, or about 20 LUTs.  (Remember &lt;a href=&quot;/blog/2017/06/12/minimizing-luts.html&quot;&gt;how to count
LUTs&lt;/a&gt;?)&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
begin
	case(i_byte[6:0])
	// Transform hexadecimal characters &#39;0&#39; to &#39;9&#39; to their
	// binary equivalents, with the out of band flag cleared
	7&#39;h30: o_bits &amp;lt;= 5&#39;h00;
	7&#39;h31: o_bits &amp;lt;= 5&#39;h01;
	7&#39;h32: o_bits &amp;lt;= 5&#39;h02;
	7&#39;h33: o_bits &amp;lt;= 5&#39;h03;
	7&#39;h34: o_bits &amp;lt;= 5&#39;h04;
	7&#39;h35: o_bits &amp;lt;= 5&#39;h05;
	7&#39;h36: o_bits &amp;lt;= 5&#39;h06;
	7&#39;h37: o_bits &amp;lt;= 5&#39;h07;
	7&#39;h38: o_bits &amp;lt;= 5&#39;h08;
	7&#39;h39: o_bits &amp;lt;= 5&#39;h09;
	//
	// Hexadecimal characters &#39;a&#39; through &#39;f&#39;
	//	(Note that &#39;A&#39; is used for &#39;Address&#39; and hence we don&#39;t
	//	support upper case hexadecimal letters here)
	7&#39;h61: o_bits &amp;lt;= 5&#39;h0a;
	7&#39;h62: o_bits &amp;lt;= 5&#39;h0b;
	7&#39;h63: o_bits &amp;lt;= 5&#39;h0c;
	7&#39;h64: o_bits &amp;lt;= 5&#39;h0d;
	7&#39;h65: o_bits &amp;lt;= 5&#39;h0e;
	7&#39;h66: o_bits &amp;lt;= 5&#39;h0f;
	//
	// Other characters set out of band information (o_bits[4])
	// These are primarily the bus command bits
	7&#39;h52: o_bits &amp;lt;= 5&#39;h10;	// &#39;R&#39;, or read command
	7&#39;h57: o_bits &amp;lt;= 5&#39;h11;	// &#39;W&#39;, or write command
	7&#39;h41: o_bits &amp;lt;= 5&#39;h12;	// &#39;A&#39;, set address
	7&#39;h53: o_bits &amp;lt;= 5&#39;h13;	// &#39;S&#39;, &quot;special&quot; ... reserved for later
	7&#39;h54: o_bits &amp;lt;= 5&#39;h16;	// &#39;T&#39; --set for form only
	default: // an &quot;other&quot; character, to be subsequently ignored.
		// Also used as an end of word character, if received
		o_bits &amp;lt;= 5&#39;h1f;
	endcase
end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;But what will we do with this five-bit value result?  That’s the next stage.&lt;/p&gt;

&lt;h2 id=&quot;transforming-binary-nibbles-to-words&quot;&gt;Transforming Binary Nibbles to Words&lt;/h2&gt;

&lt;p&gt;To pack four bits at a time into a 34-bit value is going to take several
steps.&lt;/p&gt;

&lt;p&gt;The first step deals with the upper two bits of the output command word.
These are given by the lower two bits in our five bit word, but only when
the upper bit is set.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;initial	o_word[33:32] = 2&#39;b11;
always @(posedge i_clk)
	if ((i_stb)&amp;amp;&amp;amp;(i_bits[4:2] == 3&#39;b100)) // new command
		o_word[33:32] &amp;lt;= i_bits[1:0];&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;We may wish to add other “special” command words into our dictionary in the
future.  Checking for 3’b100 checks that the high bit is set, but also leaves
room for us to check for other command words later.&lt;/p&gt;

&lt;p&gt;Now, any time we are told what command we are about to do, we’re going to need
to keep track of whether or not our register has a command loaded within it.
We’ll build our command word up from the first letter indicating what command
we are issuing (‘A’, ‘R’, or ‘W’).  On any non-hexadecimal character, we’ll
flush the command through the system.  We’re also going to clear any partial
command on any reset request.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;initial	cmd_loaded = 1&#39;b0;
always @(posedge i_clk)
	if (i_reset)
		cmd_loaded &amp;lt;= 1&#39;b0;
	else if ((i_stb)&amp;amp;&amp;amp;(i_bits[4:2] == 3&#39;b100))
		cmd_loaded &amp;lt;= 1&#39;b1;
	else if ((i_stb)&amp;amp;&amp;amp;(i_bits[4]))
		cmd_loaded &amp;lt;= 1&#39;b0;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Any thing else, any other special command, will just drop on the flow and
the command will go from loaded to unloaded.&lt;/p&gt;

&lt;p&gt;The last piece of logic before we build our word itself is the one to determine
when to send our word to the next stage.  We’ll do that any time we have a
command loaded and a new character comes in with that extra high-bit set.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;initial	o_stb = 1&#39;b0;
always @(posedge i_clk)
	o_stb &amp;lt;= (!i_reset)&amp;amp;&amp;amp;((i_stb)&amp;amp;&amp;amp;(cmd_loaded)&amp;amp;&amp;amp;(i_bits[4]));&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Now, finally, we can build the word that we will output.  At this point,
building this word in a register is quite easy.
On any new value, we just shift the new value into our word and move everything
over by four bits.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;initial	o_word[31:0] = 0;
always @(posedge i_clk)
	if (i_reset)
		r_word[31:0] &amp;lt;= 0;
	else if (i_stb)
	begin
		if (i_bits[4])
		begin
			// Record the command into our buffer
			r_word[33:32] &amp;lt;= i_bits[1:0];
			// Clear our buffer on any new command
			r_word[31:0] &amp;lt;= 0;
		end else
			// Other wise, new hex digits just get
			// placed in the bottom of our shift register,
			// and everything quietly moves over by one
			r_word[31:0] &amp;lt;= { r_word[27:0], i_bits[3:0] };
	end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Sure, we’ll clear our buffer on any new reset command and any time we get a
command word as opposed to a hex digit.  That way, if we want to send any short
unsigned numbers, we have only to give those unsigned digits.  For example,
W5W6\n will write the value five to the bus, and then the value 6.  With this
approach, we don’t need to send all 8-nibbles defining our 32-bit word if we
don’t have to.&lt;/p&gt;

&lt;p&gt;Finally, for timing purposes, we wait for an incoming value before setting
our output word.  Why timing?  Well, because our output strobe is only true
for the immediate clock following the incoming strobe.  &lt;strong&gt;r_word&lt;/strong&gt; has also
changed by then.  Hence, we’ll grab a copy before then of what we wish to
send out.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(posedge i_clk)
		if (i_reset)
			o_word &amp;lt;= 0;
		else if (i_stb)
			o_word &amp;lt;= r_word;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h2 id=&quot;thats-it&quot;&gt;That’s it!&lt;/h2&gt;

&lt;p&gt;That’s all there is to it.  You’ve now seen how simple it can be to compose
an output word from several input bytes.&lt;/p&gt;

&lt;p&gt;Sure, this protocol is simple.  It takes us up to 9-bytes to send a 32-bit
address, and another 9-bytes any time we wish to write a 32-bit value.
In other words, we are sending 72-bits any time we wish to use 34-bits worth
of information.&lt;/p&gt;

&lt;p&gt;Can this be improved upon?  Definitely.  But first, let’s just work through
what it takes to build our entire interface before we try to improve upon it.&lt;/p&gt;

</description>
        <pubDate>Wed, 14 Jun 2017 00:00:00 -0400</pubDate>
        <link>http://zipcpu.com/blog/2017/06/14/creating-words-from-bytes.html</link>
        <guid isPermaLink="true">http://zipcpu.com/blog/2017/06/14/creating-words-from-bytes.html</guid>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>Minimizing FPGA Resource Utilization</title>
        <description>&lt;p&gt;There have now been several projects I’ve worked on where I’ve butted up
against the maximum resource utilization of an FPGA chip.  If you ask a
manager how to deal with this problem, they will think you need a bigger FPGA.
This answer is problematic, though, for two primary reasons:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;If you already have your board designed, built, and tested–perhaps even in
production, and you wish to add features to the board, you will be stuck
with the FPGA resources that you already have.  Building or even just
assembling a new board with a bigger FPGA can be an expensive proposition.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;I’m a hobbyist.  I typically can’t afford a bigger FPGA&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;At times like these, a thorough code scrubbing can often help you squeak that
last Lookup-Table (LUT) out of your FPGA.  To do that, I’ve come up with
several strategies for reducing my LUT count on an FPGA.&lt;/p&gt;

&lt;h2 id=&quot;what-is-a-lut&quot;&gt;What is a LUT?&lt;/h2&gt;

&lt;p&gt;A LUT is a Look-Up Table.  Modern FPGA’s are built out of
large arrays of these lookup tables.  Using a lookup table, you can build
any logic you want–so long as you don’t exceed the number of elements in the
lookup table.&lt;/p&gt;

&lt;p&gt;As an example, the &lt;a href=&quot;https://www.xilinx.com/support/documentation/user_guides/ug474_7Series_CLB.pdf&quot;&gt;7-series Xilinx FPGAs&lt;/a&gt; are composed of
“configurable logic blocks”, each of which contain two “slices”, of
which each of those “slices” contain four 6-input LUTs.  Each of these
LUT’s can handle either one six input lookup, or two five input lookups–as
long as the two share the same inputs.&lt;/p&gt;

&lt;p&gt;The &lt;a href=&quot;https://www.altera.com/content/dam/altera-www/global/en_US/pdfs/literature/hb/cyclone-iv/cyciv-51002.pdf&quot;&gt;Altera Cyclone IV&lt;/a&gt;,
on the other hand, has only 4-input LUTs.&lt;/p&gt;

&lt;p&gt;The point being that every FPGA implements your logic via a combination of
LUTs.&lt;/p&gt;

&lt;p&gt;Chips differ by the capability of their LUTs, as well as by the number of LUTs
on board.  In general, the more LUTs you have, the more logic your chip can do,
but also the more your FPGA chip is going to cost.  It’s all a tradeoff.&lt;/p&gt;

&lt;p&gt;To get the most logic for a given price, the FPGA design engineer needs to be
able to code efficiently, and pack their code into the fewest LUTs possible.&lt;/p&gt;

&lt;h2 id=&quot;the-zipcpu-and-the-s6soc&quot;&gt;The ZipCPU and the S6SoC&lt;/h2&gt;

&lt;p&gt;When the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt; was first built, it only
supported 32-bit
&lt;a href=&quot;https://en.wikipedia.org/wiki/Byte&quot;&gt;bytes&lt;/a&gt;.  This meant that the smallest
unit of individually addressable memory was the full bus size: 32-bits. 
This has all kinds of consequences when you wish to operate on 8-bit values,
or when computer code depends upon 4*sizeof(char)==sizeof(int).&lt;/p&gt;

&lt;p&gt;In my case, the light dawned when I realized that I would need to rewrite the 
entire &lt;a href=&quot;http://sourceware.org/newlib&quot;&gt;C-library&lt;/a&gt; to support 32-bit bytes, that
the &lt;a href=&quot;https://en.wikipedia.org/wiki/Dhrystone&quot;&gt;Dhrystone benchmark&lt;/a&gt; depended upon
8-bit bytes (&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/doc/orconf.pdf&quot;&gt;Ref&lt;/a&gt;),
that &lt;a href=&quot;https://en.wikipedia.org/wiki/Coremark&quot;&gt;Coremark&lt;/a&gt; also depended upon
8-bit bytes.  Figuring that this was only the tip of the iceberg regarding the
problems I was going to have, I then decided to &lt;em&gt;byte&lt;/em&gt; the bullet and add
byte-wise addressing instructions to the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The problem with this was that the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;
already worked and worked well on some very small FPGA’s, and the
Spartan 6/LX4 on the
&lt;a href=&quot;http://store.digilentinc.com/cmod-s6-breadboardable-spartan-6-fpga-module&quot;&gt;CMod S6&lt;/a&gt; was
&lt;a href=&quot;https://github.com/ZipCPU/s6soc&quot;&gt;one of them&lt;/a&gt;.
With only 2400 six-input LUTs to work with in total, and only about 50 to
spare, could
the additional logic necessary to fit the new instructions fit onto the
&lt;a href=&quot;http://store.digilentinc.com/cmod-s6-breadboardable-spartan-6-fpga-module&quot;&gt;S6&lt;/a&gt;?&lt;/p&gt;

&lt;p&gt;I actually set my goals higher.  Not only did I want the new instructions to
fit, but I wanted to make some other upgrades as well.  Most of these other
upgrades surrounded the slow flash speed.  Because the S6/LX4 has hardly
any RAM, almost all of the instructions had to fit within the flash.  Flash
access, however, is &lt;em&gt;slow&lt;/em&gt;.  Hence, when I started my upgrades, the ZipCPU
took 52 clocks per instruction when running from the flash.  Ouch!  Could
something be done about this as well?&lt;/p&gt;

&lt;p&gt;So these were my goals:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;The obvious: I wanted to be able to support the extra 8-bit byte instructions:
LH (load halfword), SH (store halfword), LB (load byte), and SB (store byte).&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;I also wanted to upgrade the &lt;a href=&quot;https://github.com/ZipCPU/s6soc&quot;&gt;S6SoC&lt;/a&gt;
to be able to use the compressed instruction
set extension of the ZipCPU.  Using that extension, the assembler can
(sometimes) pack two instructions into one instruction word.  If the
&lt;a href=&quot;https://github.com/ZipCPU/s6soc&quot;&gt;S6SoC&lt;/a&gt; could be made to handle these
instructions, then I wouldn’t need to compile two versions of the C-library:
one using and one without using these instructions.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;I wanted to upgrade the fetch routine, so that it could handle fetching two
words at a time.&lt;/p&gt;

    &lt;p&gt;Because of the way the QSPI flash is set up, the first word you fetch from
flash
will always cost 22 flash clocks.  The first six of those are for the address,
the next 8 to allow the flash to look up your address, and then another
eight to read the data back out.  Since I was generating a clock signal from
logic, the flash actually ran at half that speed, costing me 
44 clocks every time I wished to fetch an instruction.  At the time, the
&lt;a href=&quot;https://github.com/ZipCPU/s6soc&quot;&gt;S6SoC&lt;/a&gt; had absolutely no pipelining,
so it was always fetching a new instruction after executing every instruction.&lt;/p&gt;

    &lt;p&gt;If I could fetch two instructions at a time, that would
cost only 60 clocks, and yet provide me with two instruction words.
This should raise the instruction speed from one instruction every 52 clocks
to one instruction every 38 clocks or so.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;I wanted to update the flash controller so that it would work off of a
80MHz flash clock instead of a 40MHz flash clock.  Basically, I wanted to
run the flash at the speed of the rest of the FPGA.  Since the flash was
rated for 100MHz, this shouldn’t be a problem, right?&lt;/p&gt;

    &lt;p&gt;This should reduce the number of clocks necessary to load two instructions
from 60 clocks to 30, speeding the instruction issue rate up to about one
instruction every 2 clocks.&lt;/p&gt;

    &lt;p&gt;In the end, supporting the compressed instructions got me down to one
instruction every 18 clocks, but I’m getting ahead of myself.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;As the update went along, things went so well I started to get greedy.  So, I
added more goals to my upgrade:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Now, I wanted to add the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/div.v&quot;&gt;divide
unit&lt;/a&gt; into the
design&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;I wanted a &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/cpuops.v&quot;&gt;full
multiply&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;I also wanted to partially pipeline &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;the CPU
itself&lt;/a&gt;.  I
still wanted to avoid the
expensive collision detection logic, but partially pipelining the CPU would
speed the CPU up another 60% (5 clocks per ALU instruction down to 3)&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;In the end, I got everything I wanted save the LOCK instruction.  (The LOCK
instruction holds the bus cycle line high while reading a value, running one
ALU operation on it, and then writing the value back.  It’s also useful
for atomically reading 64-bit values.)&lt;/p&gt;

&lt;h2 id=&quot;strategies-to-reduce-logic-usage&quot;&gt;Strategies to Reduce Logic Usage&lt;/h2&gt;

&lt;p&gt;Here’s how I managed to fit so many upgrades into 2400 LUTs, given that I was
already using 2345 of them.  (Yes, that’s right, on a device with 2400 LUTs,
I managed to use &lt;em&gt;all&lt;/em&gt; of them.)&lt;/p&gt;

&lt;p&gt;Here are some of the strategies I’ve used over time to keep my LUT usage
down:&lt;/p&gt;

&lt;h3 id=&quot;start-by-counting-your-logic&quot;&gt;Start by counting your logic.&lt;/h3&gt;

&lt;p&gt;Your design tools should be able to tell you how many LUTs you are using.
Some tools will even break this out nicely between design modules, helping
you to focus on the part that needs work.&lt;/p&gt;

&lt;p&gt;Find out how to do this, and then track your work throughout your design.&lt;/p&gt;

&lt;p&gt;While one strategy is to set your sites on the biggest components, I also
got a lot of savings by looking at how many LUTs were consumed by the smaller
components as well.  When you are starting out at 2345 LUTs out of 2400,
&lt;em&gt;every LUT matters&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Now, understand that the synthesizer is going to try to map all of your logic
into LUTs.  Every LUT can handle some number of inputs.  Look up what your
hardware’s definition of a LUT is, and then &lt;em&gt;count&lt;/em&gt; the number of
inputs to every flip-flop in your design.  Count the number of wires to
each flip-flop enable, and the number of alternatives within every block. 
Work to bring that number down to eight or less if possible, and you’ll be
amazed at how well your design will handle both fitting onto your device,
as well as the speed of the logic you can achieve using your logic.&lt;/p&gt;

&lt;p&gt;So, for some simple numbers to think about with respect to &lt;a href=&quot;https://www.xilinx.com/support/documentation/user_guides/ug474_7Series_CLB.pdf&quot;&gt;Xilinx’s CLB
structure&lt;/a&gt;:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;5 inputs: If you can get your logic down to five inputs or less, you might
be able to share a LUT with wires within a group&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;6 inputs: Anything that requires six inputs will require one LUT.  Be aware
of busses of logic all requiring 6-inputs … you are likely to need one
LUT for every input in that bus.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;7 inputs: Requires two LUTs and a 7-Mux.  This still fits within one slice,
so it doesn’t impact your timing (much) yet.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;8 inputs: Requires four LUTs and n 8-input mux.  This still fits within 
one slice&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;9 inputs and more: These don’t fit nicely into a LUT, nor do they fit nicely
into a set of four LUTs, and so the synthesis
tool is going to have to try to figure out how to string LUTs together to
accomplish your logic.  If your logic isn’t an add, subtract, or compare
that can use the carry chain, you may wish to do your best to avoid this
amount of logic.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;As you go through your logic: &lt;em&gt;force every LUT to justify its existence&lt;/em&gt;.&lt;/p&gt;

&lt;h3 id=&quot;use-block-ram-anywhere-you-can&quot;&gt;Use block RAM anywhere you can.&lt;/h3&gt;

&lt;p&gt;Look for memories that are implemented in LUTs, and turn them into block RAMs.
Anywhere you can do this will yield an &lt;em&gt;amazing&lt;/em&gt; savings.
Indeed, switching from LUTs to block RAM has often been the difference between
failure and success in my designs.&lt;/p&gt;

&lt;p&gt;For example, the following logic isn’t likely to make it into block RAM:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	if (A)
		mem[addrA] &amp;lt;= valA;
	else if (B)
		mem[addrB] &amp;lt;= valB;
	else if (C)
		mem[addrC] &amp;lt;= valC;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;However, with a couple simple manipulations, you can often trade a clock of
delay for the capability you need.  The following, for example, will fit in
Block RAM:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;// Capture the logic we need ...
always @(posedge i_clk)
	wr &amp;lt;= ((A)||(B)||(C));
always @(posedge i_clk)
	if (A)
	begin
		wAddr &amp;lt;= addrA;
		wData &amp;lt;= valA;
	end else if (B)
	begin
		wAddr &amp;lt;= addrB;
		wData &amp;lt;= valB;
	end else if (C)
	begin
		wAddr &amp;lt;= addrC;
		wData &amp;lt;= valC;
	end

// So we can implement it with simplicity on the next clock,
// using block RAM.
always @(posedge i_clk)
	if (wr)
		mem[wAddr] &amp;lt;= wData;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This was an important part of getting my
&lt;a href=&quot;https://github.com/ZipCPU/sdspi&quot;&gt;SD-SPI&lt;/a&gt; and
&lt;a href=&quot;https://github.com/ZipCPU/openarty/blob/master/enetpackets.v&quot;&gt;RMII ethernet&lt;/a&gt;
modules to work, although it didn’t help the
&lt;a href=&quot;https://github.com/ZipCPU/s6soc&quot;&gt;S6SoC&lt;/a&gt; in particular.  Still, it allowed
me to run the SD-SPI controller with a 200MHz clock – so lowering your LUT
usage is likely to increase your maximum speed as well.&lt;/p&gt;

&lt;h3 id=&quot;be-very-aware-of-nested-ifs&quot;&gt;Be very aware of nested if’s&lt;/h3&gt;

&lt;p&gt;My first attempt at any design tends to look like a giant if-then-else logic
block handling states and state transitions.  They’re just too easy to
understand and follow.  As an example, the &lt;a href=&quot;/blog/2017/06/08/simple-wb-master.html&quot;&gt;simple wishbone
master&lt;/a&gt;
controller we built the other day started
with a giant always block with several conditions.&lt;/p&gt;

&lt;p&gt;The problem with these large logic blocks is that there are often states where
you don’t care what certain values are for some variables.  In these cases,
you can simplify the logic for those states.&lt;/p&gt;

&lt;p&gt;For example, imagine something like ….&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
if (RESET)
begin
	valid &amp;lt;= 1&#39;b0;
	B &amp;lt;= 0; /// Really a don&#39;t care
end else if (CE)
begin
	valid &amp;lt;= (input is valid);
	B &amp;lt;= (... something of value);
end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Let’s count this logic:  Each of the bits in valid and B depend upon both RESET
and CE, hence a minimum of one LUT each.  Further, the flip-flop clock enable
line also requires a LUT for each flip flop.  So, we’re talking about 2 LUTs
for the valid signal, and another 2 LUTs &lt;em&gt;for every bit in B&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;If the only value that really depends upon the RESET is the valid signal,
which indicates whether or not B contains a valid value, why must B be set
on reset?  In this case, you want to separate your logic into multiple logic
blocks, often one block per variable.  You can then end up with something
like …&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
if (RESET)
	valid &amp;lt;= 1&#39;b0;
else if (CE)
	valid &amp;lt;= (input is valid);

always @(posedge i_clk)
if (CE)
	B &amp;lt;= (... something of value);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;If CE is a simple wire by itself, and not composed of more logic resources,
than it won’t cost any LUTs to calculate.  Likewise if the value you wish to
store in B comes from already calculated logic on your board, then you have
just spared yourself one LUT for every wire in B.  Even if there are several
inputs to the wires in B, if you just managed to drop from 6-inputs to five
for each wire, then you may have dropped the number of LUTs used to calculate
B in half.&lt;/p&gt;

&lt;p&gt;The impact of this can be significant.&lt;/p&gt;

&lt;p&gt;Two examples of updated and simplified logic would be my &lt;a href=&quot;https://github.com/ZipCPU/s6soc/qflashxpress.v&quot;&gt;simplified QSPI
flash controller&lt;/a&gt; when
compared with the giant always block in &lt;a href=&quot;https://github.com/ZipCPU/s6soc/blob/master/rtl/wbqspiflash.v&quot;&gt;basic flash
controller&lt;/a&gt;.
Even though the simplified controller can only handle read requests,
its amazingly light on the logic.&lt;/p&gt;

&lt;p&gt;Likewise, my recent rewrite of my 
&lt;a href=&quot;https://github.com/ZipCPU/wbuart32&quot;&gt;UART&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/wbuart32/blob/master/rtl/txuart.v&quot;&gt;transmitter&lt;/a&gt;
and
&lt;a href=&quot;https://github.com/ZipCPU/wbuart32/blob/master/rtl/rxuart.v&quot;&gt;receiver&lt;/a&gt;
saved me many LUTs by breaking up the logic in that big always block.
Perhaps you might enjoy looking through the
GIT history of this &lt;a href=&quot;https://github.com/ZipCPU/wbuart32&quot;&gt;UART controller&lt;/a&gt;,
to see how easy they were to read &lt;a href=&quot;https://github.com/ZipCPU/wbuart32/commit/e157c6e110e84f418514c7617db80519f5bba6ca&quot;&gt;back when they used a massive state
transition block&lt;/a&gt;, and then to compare that with what they look like today.&lt;/p&gt;

&lt;h3 id=&quot;reduce-your-requirements-if-you-can&quot;&gt;Reduce your requirements if you can&lt;/h3&gt;

&lt;p&gt;Very few UART controllers truly need to handle 5, 6, and 7-bit words, parity,
break setting and detection, parity error and frame error detection, hardware
flow control, and so forth.  If you know your application well, and
you have code in your application that is designed to handle things that will
never happen, then &lt;em&gt;remove that code&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;In my case, the 
&lt;a href=&quot;https://github.com/ZipCPU/wbuart32&quot;&gt;UART&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/wbuart32/blob/master/rtl/txuart.v&quot;&gt;transmitter&lt;/a&gt;
and
&lt;a href=&quot;https://github.com/ZipCPU/wbuart32/blob/master/rtl/rxuart.v&quot;&gt;receiver&lt;/a&gt;
had way more functionality than I needed.  So, I built a lighter UART
&lt;a href=&quot;https://github.com/ZipCPU/wbuart32/blob/master/rtl/txuartlite.v&quot;&gt;transmitter&lt;/a&gt;
and
&lt;a href=&quot;https://github.com/ZipCPU/wbuart32/blob/master/rtl/rxuartlite.v&quot;&gt;receiver&lt;/a&gt;
with only the capabilities I would ever use.
Since I had long since removed the UART
&lt;a href=&quot;https://github.com/ZipCPU/wbuart32/blob/master/rtl/ufifo.v&quot;&gt;FIFO&lt;/a&gt;,
there wasn’t much more I could after that.&lt;/p&gt;

&lt;p&gt;The point being, if you’ve over designed your product–remove the
all that extra, unused, logic when you get tight on resources.&lt;/p&gt;

&lt;h3 id=&quot;avoid-bit-selects-if-you-can&quot;&gt;Avoid bit selects if you can&lt;/h3&gt;

&lt;p&gt;I made a lot of adjustments to the
&lt;a href=&quot;https://github.com/ZipCPU/s6soc/blob/master/rtl/cpu/div.v&quot;&gt;divide unit&lt;/a&gt;
to get it to fit.  Most of these adjustments followed the advice above,
but one very powerful adjustment was also to get rid of a statement like …&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;if (lots_of_conditions)
	o_quotient[current_bit] &amp;lt;= (logic to calculate a bit);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;and, with some understanding that every bit needed to be set anyway, I was
able to rearrange that statement into,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;if (lots of conditions)
	o_quotient &amp;lt;= { o_quotient[30:0], (logic to calculate a bit) };&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Think about the LUT usage required to implement this statement.  The first
statement requires
many LUTs &lt;em&gt;per bit&lt;/em&gt; to determine not only whether that bit is going to be set,
but also what the bit will be set to.  The second example still requires some
LUTs to determine whether or not &lt;em&gt;a&lt;/em&gt; bit is going to be set, but those LUTs
can be shared across all bits.  Further, only the bottom bit has to have the
special set of LUTs to determine what the bit needs to be set to.&lt;/p&gt;

&lt;p&gt;That one optimization by itself saved me many, many LUTs.  In the end, I think
I saved about 100 LUTs out of a 300 LUT component, but you can look at the
&lt;a href=&quot;https://github.com/ZipCPU/s6soc/commits/master/rtl/cpu/div.v&quot;&gt;git log&lt;/a&gt; to see
the details of the other changes that were made along the way.&lt;/p&gt;

&lt;h3 id=&quot;manage-your-reset-logic&quot;&gt;Manage your Reset Logic&lt;/h3&gt;

&lt;p&gt;If you follow &lt;a href=&quot;https://www.xilinx.com/support/documentation/white_papers/wp272.pdf&quot;&gt;Xilinx’s
 guidance&lt;/a&gt;,
they would highly recommend against having
a global reset.  They explain pretty clearly how it impedes all of the logic
within your design.&lt;/p&gt;

&lt;p&gt;In my own implementations, such as within the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;ZipCPU&lt;/a&gt;, I
tend to create _valid lines stating whether or not a group of logic lines
is actually valid.  These lines then get the reset signal, while all the other
logic ignores it.  Indeed, many of my
&lt;a href=&quot;/projects.html&quot;&gt;ZipCPU implementations &lt;/a&gt;
don’t use a global (or even a local) reset at all.  Sure, the CPU has
a reset line … but I usually leave it unconnected, and instead command the
reset from some amount of local logic.  For example, both the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/wbwatchdog.v&quot;&gt;watchdog timer&lt;/a&gt;
and the debug port can command a reset.  Further, on a really small design
with no debug port (i.e., the &lt;a href=&quot;https://github.com/ZipCPU/s6soc&quot;&gt;S6SoC again&lt;/a&gt;),
I used a button for that purpose.&lt;/p&gt;

&lt;h3 id=&quot;application-specific-optimizations&quot;&gt;Application Specific Optimizations&lt;/h3&gt;

&lt;p&gt;Some optimizations, though, are by nature application specific.  A good
example of this is a &lt;a href=&quot;https://en.wikipedia.org/wiki/Finite_impulse_response&quot;&gt;FIR
filter&lt;/a&gt;
I built some time ago in support of my
&lt;a href=&quot;/projects.html&quot;&gt;universal resampling project&lt;/a&gt;.  (Any
rate in, to any lower rate out, out of band rejection greater than 70 dB, etc.)
When building &lt;a href=&quot;https://en.wikipedia.org/wiki/Finite_impulse_response&quot;&gt;the FIR&lt;/a&gt;,
I couldn’t afford to use block RAM’s to hold the coefficients—cause there was
no time for a RAM lookup: every coefficient needed to be used on every clock. 
The entire design, though, needed to run at the full clock rate.&lt;/p&gt;

&lt;p&gt;So, I made each tap settable from a single address that would push
them all through memory–like a giant shift register.  Still, this was too
much logic.&lt;/p&gt;

&lt;p&gt;In the end, even that wasn’t enough: I had to go farther so as to fix the
FIR taps with constant values within the filter.  Because of the nature
and structure of the resampling problem, this approach worked.&lt;/p&gt;

&lt;p&gt;I then managed to reduce the logic required even further by forcing the filter
to be symmetric.  Indeed, the &lt;a href=&quot;https://en.wikipedia.org/wiki/Parks-McClellan_filter_design_algorithm&quot;&gt;Parks-McClellan filter design
algorithm&lt;/a&gt;,
used for designing my lowpass anti-aliasing filters, &lt;em&gt;only&lt;/em&gt; designs
such &lt;a href=&quot;https://en.wikipedia.org/wiki/Linear_phase&quot;&gt;linear phase&lt;/a&gt; (i.e. symmetric)
filters anyway.  Thus, with this trick, I was able to use half as many
hardware multiplies.&lt;/p&gt;

&lt;p&gt;Looking over my taps, I then realized I could do more since some of the taps
were zero, some had only only one bit set in their coefficient, and since the
mid-point was already scaled to (2^N-1) so as to be able to use a subtract
instead of a multiply.&lt;/p&gt;

&lt;p&gt;If DSP usage is an issue, you might wish to consider this approach.&lt;/p&gt;

&lt;h3 id=&quot;keep-large-comparisons-out-of-state-transition-logic&quot;&gt;Keep large comparisons out of state transition logic&lt;/h3&gt;

&lt;p&gt;Don’t place large comparisons in your state transition diagrams if you
don’t need to.&lt;/p&gt;

&lt;p&gt;As an example, the logic below compares A against a 32-bit value, &lt;em&gt;and&lt;/em&gt;
C against a 24-bit value.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	A &amp;lt;= A + 1&#39;b1;
always @(posedge i_clk)
	C &amp;lt;= C + 7;

always @(posedge i_clk)
if (A == 32&#39;h00)
	B &amp;lt;= iB;
else if (C == 24&#39;h084)
	B &amp;lt;= ~B;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;If we are smart about things, we can move the comparison one clock earlier
and calculate intermediate values.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	zA &amp;lt;= &amp;amp;A;
always @(posedge i_clk)
	mC &amp;lt;= (C == 24&#39;h081);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;These two intermediate values then relieve the stress on the set for the
value of B,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
if (zA)
	B &amp;lt;= iB;
else if (mC)
	B &amp;lt;= ~B;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This was another technique that I used when simplifying the onboard
&lt;a href=&quot;https://github.com/ZipCPU/wbuart32&quot;&gt;UART&lt;/a&gt;.
To see how it works, look at the baud counter logic within the
&lt;a href=&quot;https://github.com/ZipCPU/wbuart32/blob/master/rtl/rxuartlite.v&quot;&gt;receiver&lt;/a&gt;,
and pay attention to the &lt;strong&gt;zero_baud_counter&lt;/strong&gt; logic.  At one time, the
state diagram had depended upon tests for whether or not
&lt;strong&gt;baud_counter&lt;/strong&gt; was zero.  You can see from the 
&lt;a href=&quot;https://github.com/ZipCPU/wbuart32/blob/master/rtl/rxuartlite.v&quot;&gt;receiver&lt;/a&gt;
source how not only was the &lt;strong&gt;baud_counter&lt;/strong&gt; logic removed from the main
always loop, but the &lt;strong&gt;zero_baud_counter&lt;/strong&gt; logic was removed as well.
Now, the main loop only references the &lt;strong&gt;zero_baud_counter&lt;/strong&gt; logic
strobe to know when to step the logic forward by one.&lt;/p&gt;

&lt;h3 id=&quot;if-all-else-fails-ask-for-help&quot;&gt;If all else fails, ask for help&lt;/h3&gt;

&lt;p&gt;Finally, if all else fails, ask  someone with more experience to look over
your code.  Perhaps they might see something you are missing?&lt;/p&gt;

&lt;p&gt;On second thought … maybe not.  They might tell me that the way I format my
code is all wrong.&lt;/p&gt;

&lt;h2 id=&quot;testing-the-changes&quot;&gt;Testing the changes&lt;/h2&gt;

&lt;p&gt;Since one focus of this blog is on testing and debugging, how did I manage to
prove that these new changes worked?&lt;/p&gt;

&lt;p&gt;First, all of these changes were tested initially within a simulation. 
My favorite simulation test was to see if I could get the
&lt;a href=&quot;https://github.com/ZipCPU/s6soc&quot;&gt;S6SoC&lt;/a&gt; to
run all the way from boot up to sending &lt;a href=&quot;https://github.com/ZipCPU/s6soc/blob/master/sw/wlibc/hello.c&quot;&gt;Hello
World&lt;/a&gt;
out the serial port.&lt;/p&gt;

&lt;p&gt;Second, the new instruction set also included special NOOP encodings.  These
allow me to place NOOPs into the code that will then cause the simulator
to print to the screen, whether it be characters, strings, register values,
or a full register dump.  The same code, when run within the hardware, would
just ignore these NOOP instructions.  These allowed me, when using the
simulator, to “debug by printf” all over the place.&lt;/p&gt;

&lt;p&gt;Third, the
&lt;a href=&quot;https://github.com/ZipCPU/s6soc/blob/master/sim/verilator/zip_sim.cpp&quot;&gt;simulator&lt;/a&gt;
also printed out a lot of trace information.  This was useful for tracing back
memory values that hadn’t been set appropriately all the way back to when they
were set.  Further, by matching the trace timing with
&lt;a href=&quot;http://gtkwave.sourceforge.net&quot;&gt;GTKwave&lt;/a&gt;’s timing, I was able to look up,
using &lt;a href=&quot;http://gtkwave.sourceforge.net&quot;&gt;GTKwave&lt;/a&gt;,
any values that weren’t printed in the trace to find the problem.&lt;/p&gt;

&lt;p&gt;Finally, for the bugs the first two items didn’t catch, I did have a
&lt;a href=&quot;https://github.com/ZipCPU/wbscope&quot;&gt;wishbone scope&lt;/a&gt; on board.  Since I didn’t
have room on board for my favorite debug interface, I set the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;CPU&lt;/a&gt; up so that
on any reset (button press) it would &lt;a href=&quot;https://github.com/ZipCPU/s6soc/blob/master/sw/dev/resetdump.s&quot;&gt;dump the
values&lt;/a&gt; of the
scope and the register values on startup (these weren’t cleared on reset). 
While the result is that the
&lt;a href=&quot;https://github.com/ZipCPU/s6soc/blob/master/sw/wlibc/hello.c&quot;&gt;Hello World&lt;/a&gt;
program’s output doesn’t start
out looking pretty, I can also use that startup output to find whatever caused
the CPU to halt and need to be restarted manually.&lt;/p&gt;

&lt;p&gt;So, it was all doable and straight forward.  Indeed, even today, if you don’t
have the
&lt;a href=&quot;http://store.digilentinc.com/cmod-s6-breadboardable-spartan-6-fpga-module&quot;&gt;CMod S6&lt;/a&gt;,
you can still test how the &lt;a href=&quot;https://github.com/ZipCPU/s6soc&quot;&gt;S6SoC&lt;/a&gt; would run
on that
&lt;a href=&quot;http://store.digilentinc.com/cmod-s6-breadboardable-spartan-6-fpga-module&quot;&gt;CMod S6&lt;/a&gt;
by using &lt;a href=&quot;https://github.com/ZipCPU/s6soc/trunk/blob/master/sim/verilator/zip_sim.cpp&quot;&gt;the simulator&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;how-did-it-work&quot;&gt;How did it work?&lt;/h2&gt;

&lt;p&gt;The changes outlined above were the difference between success and failure,
between getting the updated &lt;a href=&quot;https://github.com/ZipCPU/s6soc&quot;&gt;S6SoC&lt;/a&gt;
working with the new instruction set
&lt;em&gt;and the compressed instruction extension&lt;/em&gt;, or being able to abandon that
hardware (and my bragging rights) entirely.  Had I not made the optimizations
above, I might never have gotten the CPU to work with 8-bit bytes, and hence
I might’ve never had C-library support.  Now, however, not only does the CPU
run with 8-bit byte support, but it also has a &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/core/div.v&quot;&gt;divide
unit&lt;/a&gt;, and runs 3x
faster than it ever did before.&lt;/p&gt;

&lt;p&gt;What does all this mean?  If I disable illegal instruction detection for the
LOCK instruction, then I can play &lt;a href=&quot;https://github.com/ZipCPU/tttt&quot;&gt;4x4x4 Tic-Tac-Toe&lt;/a&gt; on my &lt;a href=&quot;http://store.digilentinc.com/cmod-s6-breadboardable-spartan-6-fpga-module&quot;&gt;CMod
S6&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;So is minimizing LUT usage important?&lt;/p&gt;

&lt;p&gt;Tell me your experiences!&lt;/p&gt;
</description>
        <pubDate>Mon, 12 Jun 2017 00:00:00 -0400</pubDate>
        <link>http://zipcpu.com/blog/2017/06/12/minimizing-luts.html</link>
        <guid isPermaLink="true">http://zipcpu.com/blog/2017/06/12/minimizing-luts.html</guid>
        
        
        <category>blog</category>
        
      </item>
    
  </channel>
</rss>
