<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>The ZipCPU by Gisselquist Technology</title>
    <description>The ZipCPU blog, featuring how to discussions of FPGA and soft-core CPU design.  This site will be focused on Verilog solutions, using exclusively OpenSource IP products for FPGA design.  Particular focus areas include topics often left out of more mainstreeam FPGA design courses such as how to debug an FPGA design.
</description>
    <link>http://zipcpu.com/</link>
    <atom:link href="http://zipcpu.com/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Thu, 03 May 2018 15:53:29 -0400</pubDate>
    <lastBuildDate>Thu, 03 May 2018 15:53:29 -0400</lastBuildDate>
    <generator>Jekyll v3.0.1</generator>
    <image>
      <url>http://zipcpu.com/img/gt-rss.png</url>
      <title></title>
      <link></link>
    </image>
    
      <item>
        <title>Updated Projects List</title>
        <description>&lt;p&gt;If you haven’t noticed, there’s a
&lt;a href=&quot;/projects.html&quot;&gt;link&lt;/a&gt;
on the left of each page to the
&lt;a href=&quot;/projects.html&quot;&gt;projects&lt;/a&gt;
I’ve been working on.
&lt;a href=&quot;/projects.html&quot;&gt;That page&lt;/a&gt;
doesn’t get updated nearly as often as it should be.  However, I thought I’d
let you know that I updated it today.&lt;/p&gt;

&lt;p&gt;Perhaps the biggest new item is that I’m now teaching a two-day formal
verification course.  If you’d me to come and teach formal verification
at your workplace, please let me know.  I’m also prepared to offer individual
lessons via video teleconferencing.&lt;/p&gt;

&lt;p&gt;Other new projects listed include many of the projects you’ve seen presented
&lt;a href=&quot;http://zipcpu.com/&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Chief among these are the &lt;a href=&quot;/dsp/dsp.html&quot;&gt;DSP posts&lt;/a&gt;.
Hence, the page now lists the
&lt;a href=&quot;https://github.com/ZipCPU/cordic&quot;&gt;sine wave generators&lt;/a&gt; we’ve discussed
on the blog,
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters&quot;&gt;filters&lt;/a&gt;,
and
&lt;a href=&quot;https://github.com/ZipCPU/interpolation&quot;&gt;interpolators&lt;/a&gt;.  Further, the
&lt;a href=&quot;https://github.com/ZipCPU/dblclockfft&quot;&gt;FFT&lt;/a&gt;
is undergoing a
&lt;a href=&quot;https://github.com/ZipCPU/dblclockfft/tree/dev&quot;&gt;fascinating transformation&lt;/a&gt;
to make it more general purpose, but that’s far from complete.&lt;/p&gt;

&lt;p&gt;I also added a desscription to some of the items that had no description
before.  Perhaps the most interesting of these is the GPS schooled clock–a
basic project that can lock an internal FPGA counter to the PPS output of a
PMod GPS.&lt;/p&gt;

&lt;p&gt;Feel free to check out this new and updated project page, and by all means
please write if you find any broken links, have any questions, comments,
or suggestions!&lt;/p&gt;
&lt;hr /&gt;&lt;p&gt;&lt;em&gt;The preacher sought to find out acceptable words: and that which was written was upright, even words of truth. (Eccl 12:10)&lt;/em&gt;</description>
        <pubDate>Mon, 30 Apr 2018 00:00:00 -0400</pubDate>
        <link>http://zipcpu.com/blog/2018/04/30/updated-projects.html</link>
        <guid isPermaLink="true">http://zipcpu.com/blog/2018/04/30/updated-projects.html</guid>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>Aggregating verified modules together</title>
        <description>&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 1. The ZipCPU&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/zipcpu.svg&quot; alt=&quot;Block diagram of the ZipCPU, showing five pipeline stages&quot; width=&quot;360&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;If you’ve been following my work with the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;,
you’ll know that I have formally verified &lt;a href=&quot;/blog/2018/01/22/formal-progress.html&quot;&gt;all of the leaf
modules&lt;/a&gt;,
and that I am now working on verifying
&lt;a href=&quot;https://github.com/ZipCPU/blob/master/rtl/core/zipcpu.v&quot;&gt;the CPU&lt;/a&gt;
&lt;a href=&quot;/blog/2018/04/02/formal-cpu-bugs.html&quot;&gt;as a whole&lt;/a&gt;.
By “leaf module”, I mean a design component that references no other design
components.
You might also remember that &lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;I am rather new to formal
verification&lt;/a&gt;,
having only picked it up within this last year.  Verifying the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
may be the most complex design I’ve tried to verify yet.&lt;/p&gt;

&lt;p&gt;Prior to my attempts at formally verifying the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;,
the most difficult proof I had worked on was for a proprietary block
floating point module.  That module assigned a single exponent for all
of the values within a block of &lt;code class=&quot;highlighter-rouge&quot;&gt;2^N&lt;/code&gt; numbers, and then output the input
numbers sequentially together with their assigned floating point value.  Like
the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;,
it also involved proving a module with a leaf module underneath it.
The alignment was very difficult to get right in that implementation
and so I dependended heavily upon the &lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formally verified
properties&lt;/a&gt;
of those two modules in order to have the assurance that the component
even worked.&lt;/p&gt;

&lt;p&gt;Along the way, I’ve learned that there are some tricks to aggregating
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formally verified&lt;/a&gt;
submodules together in order to prove the whole.  I’ve now learned two
particular techniques, abstraction and invariants, to help
control the complexity of a formal proof.
Today’s discussion will focus on invariants.  If the
&lt;a href=&quot;https://www.blueletterbible.org/kjv/jas/4/15&quot;&gt;Lord is willing&lt;/a&gt;,
we’ll come back and discuss how to use abstraction, and present several
examples of it.&lt;/p&gt;

&lt;p&gt;I would love to declare, before starting out, that I am an expert on these
techniques.  I’m not.  Perhaps if I had found some article
or set of articles describing them I might be able to declare some amount
of expertise.  Sadly, while I found
a small number of articles describing invariants, I struggled to relate the
concepts presented within those articles to the
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal verification&lt;/a&gt;
problems
I was dealing with.  The one source I found to guide me along this road
was a presentation from &lt;a href=&quot;https://www.onespin.com&quot;&gt;OneSpin Solutions&lt;/a&gt; at
&lt;a href=&quot;https://dvcon.org&quot;&gt;DVCon&lt;/a&gt; 2018 in San Jose.&lt;/p&gt;

&lt;p&gt;So with credit to &lt;a href=&quot;https://www.onespin.com&quot;&gt;OneSpin Solutions&lt;/a&gt;, here’s
what I have learned about
invariants and how they apply to
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;Formal Verification&lt;/a&gt;.
More than that, I’ll
try to keep this presentation simple enough to be understandable, and
focused on how these topics apply to the
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal verification&lt;/a&gt;
of complex RTL modules.&lt;/p&gt;

&lt;h2 id=&quot;formal-property-review&quot;&gt;Formal Property Review&lt;/h2&gt;

&lt;p&gt;If you are coming in to the discussion late, then there are two concepts
you must understand in order to follow the discussion below.  These are
the &lt;code class=&quot;highlighter-rouge&quot;&gt;assume()&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;assert()&lt;/code&gt; System Verilog operators.  I like to explain
these with a set of diagrams describing the state of a design at any
given point in time.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 2. Formal regions of relevance&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/formal-bmc.svg&quot; alt=&quot;&quot; width=&quot;360&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;One such example state diagram is shown in Fig 2.  Consider every point in
this image as representing one state of all the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flip-flop_(electronics)&quot;&gt;flip-flops&lt;/a&gt;
in your design.  Any change to one of the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flip-flop_(electronics)&quot;&gt;flip-flops&lt;/a&gt;
in your design will move your system’s state to a new point on the diagram.&lt;/p&gt;

&lt;p&gt;Several parts of this diagram are worth noting.&lt;/p&gt;

&lt;p&gt;First, note that your design starts from an initial state, as defined by the
&lt;code class=&quot;highlighter-rouge&quot;&gt;initial&lt;/code&gt; statements within your design.  From this point, the inputs to your
design together with the logic within your design will cause the design
to move from one state to another.&lt;/p&gt;

&lt;p&gt;Second, note that there are three different types of states you can be in.
The first set of states are the set of “valid” states.  These are all of the
states that may be reached from your initial state without violating any
&lt;code class=&quot;highlighter-rouge&quot;&gt;assert&lt;/code&gt;ions within your design.  These are shown in green.&lt;/p&gt;

&lt;p&gt;The second set of states are those shown in red.  These are the “illegal” or
“invalid” states.  These are defined by all those states that violate an
&lt;code class=&quot;highlighter-rouge&quot;&gt;assert()&lt;/code&gt; statements within your design.
Your goal, using formal methods, will be to prove that you cannot cross from
a point in the set of valid states to one of the invalid states.&lt;/p&gt;

&lt;p&gt;There is a third set of states.  This set is shown by the largest region
containing all of the others.  This is the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Universe_(mathematics)&quot;&gt;universe&lt;/a&gt;
of all possible sets of
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flip-flop_(electronics)&quot;&gt;flip-flop&lt;/a&gt;
(register) combinations of values within your design.  Initially, this set is
defined by every
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flip-flop_(electronics)&quot;&gt;flip-flop&lt;/a&gt;
combination in your design.  Hence if you have &lt;code class=&quot;highlighter-rouge&quot;&gt;N&lt;/code&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flip-flop_(electronics)&quot;&gt;flip-flops&lt;/a&gt;
in your design, then without any further assumptions there are initially
&lt;code class=&quot;highlighter-rouge&quot;&gt;2^N&lt;/code&gt; states in this set.  Not all of these states will be &lt;em&gt;reachable&lt;/em&gt; from
your initial state.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: left&quot;&gt;&lt;caption&gt;Fig 3. The Effect of an Assumption&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/formal-bmc-assume.svg&quot; alt=&quot;&quot; width=&quot;360&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;Within your design, you have two sorts of statements you can make about the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flip-flop_(electronics)&quot;&gt;flip-flops&lt;/a&gt;
within your design.  The first is the &lt;code class=&quot;highlighter-rouge&quot;&gt;assume()&lt;/code&gt; statement.  This reduces the
size of the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Universe_(mathematics)&quot;&gt;universe&lt;/a&gt;
of values your
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flip-flop_(electronics)&quot;&gt;flip-flops&lt;/a&gt;
may be set to.&lt;/p&gt;

&lt;p&gt;To use the &lt;a href=&quot;/zipcpu/2018/04/17/ziptimer.html&quot;&gt;example of a
counter&lt;/a&gt;,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	if (i_reset)
		r_value &amp;lt;= 0;
	else if (i_start)
		r_value &amp;lt;= TIMEOUT;
	else if (r_value != 0)
		r_value &amp;lt;= r_value - 1&#39;b1;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;we might assume that the &lt;code class=&quot;highlighter-rouge&quot;&gt;i_reset&lt;/code&gt; signal is always zero.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(*)
	assume(!i_reset);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This will restrict the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Universe_(mathematics)&quot;&gt;universe&lt;/a&gt;
of possibilities to only those where &lt;code class=&quot;highlighter-rouge&quot;&gt;i_reset&lt;/code&gt; is
always zero.&lt;/p&gt;

&lt;p&gt;The goal of
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal methods&lt;/a&gt;
is to examine &lt;em&gt;every possible&lt;/em&gt; state your design can enter into in order
to prove that your design will never reach an &lt;em&gt;invalid&lt;/em&gt; state.
As I’m sure you can imagine, this task can be a challenge.  In general, this
challenge is &lt;code class=&quot;highlighter-rouge&quot;&gt;NP-hard&lt;/code&gt;–the computational complexity is roughly exponential
in the size of the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Universe_(mathematics)&quot;&gt;universe&lt;/a&gt;
within your design.  Hence, the smaller you can make the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Universe_(mathematics)&quot;&gt;universe&lt;/a&gt;
of possibilities the easier it will be to verify a design.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 4. The Effect of an Assertion&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/formal-bmc-assert.svg&quot; alt=&quot;&quot; width=&quot;360&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;The second basic formal statement is the &lt;code class=&quot;highlighter-rouge&quot;&gt;assert()&lt;/code&gt; statement.  Unlike the
&lt;code class=&quot;highlighter-rouge&quot;&gt;assume()&lt;/code&gt; statement which limits the size of the search space, the &lt;code class=&quot;highlighter-rouge&quot;&gt;assert()&lt;/code&gt;
statement declares particular states within that
&lt;a href=&quot;https://en.wikipedia.org/wiki/Universe_(mathematics)&quot;&gt;universe&lt;/a&gt;
are somehow “illegal” as shown in Fig 4.  When you use
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal methods&lt;/a&gt;,
your goal will be to guarantee your design remains in a legal state.&lt;/p&gt;

&lt;p&gt;If we return to the
&lt;a href=&quot;/zipcpu/2018/04/17/ziptimer.html&quot;&gt;timer example&lt;/a&gt;
above, we might assert that value of the counter is never one greater than
&lt;code class=&quot;highlighter-rouge&quot;&gt;TIMEOUT&lt;/code&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(*)
	assert(r_value != TIMEOUT+1);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;When applying
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal methods&lt;/a&gt;
to this example, the engine will quickly point out that
the initial state may lie within the red or illegal states–since we did nothing
to restrict &lt;code class=&quot;highlighter-rouge&quot;&gt;r_value&lt;/code&gt;s contents initially.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;initial r_value = 0;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;These two operators, &lt;code class=&quot;highlighter-rouge&quot;&gt;assume&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;assert&lt;/code&gt;, alone should be enough to get you
started with
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal methods&lt;/a&gt;,
and there’s a lot you can do with them.  However, if you want to &lt;em&gt;prove&lt;/em&gt; that
your design will work for all time rather than just the first &lt;code class=&quot;highlighter-rouge&quot;&gt;S&lt;/code&gt; time steps,
then you will need to apply the
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal method&lt;/a&gt;
called
&lt;a href=&quot;/blog/2018/03/10/induction-exercise.html&quot;&gt;induction&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/blog/2018/03/10/induction-exercise.html&quot;&gt;Induction&lt;/a&gt;
starts by assuming your design is somewhere among the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Universe_(mathematics)&quot;&gt;universe&lt;/a&gt;
of all possible states, and that the initial state the engine has chosen
is not illegal.  Its first
step is to create &lt;code class=&quot;highlighter-rouge&quot;&gt;S&lt;/code&gt; time steps where your design stays out of the
illegal set of states.  Then, on the &lt;code class=&quot;highlighter-rouge&quot;&gt;S+1&lt;/code&gt; time step, it tries to see if it
is possible to enter into the set of illegal states.&lt;/p&gt;

&lt;p&gt;The difficult part of this
&lt;a href=&quot;/blog/2018/03/10/induction-exercise.html&quot;&gt;inductive step&lt;/a&gt;
is that the formal engine cannot tell the difference between reachable states
and unreachable states.  This can be &lt;a href=&quot;/blog/2018/03/10/induction-exercise.html&quot;&gt;particularly
problematic&lt;/a&gt;
for the new user of
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal methods&lt;/a&gt;
to understand.
A common refrain is, “how did the formal engine put my design into this
state?  There’s no way it can get there!”&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: left&quot;&gt;&lt;caption&gt;Fig 5. The Lesson of Induction&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/formal-induction-soln.svg&quot; alt=&quot;&quot; width=&quot;360&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;Addressing this problem was the subject of a
&lt;a href=&quot;/blog/2018/03/10/induction-exercise.html&quot;&gt;prior article&lt;/a&gt;.
In that article, I explained that you must use either an &lt;code class=&quot;highlighter-rouge&quot;&gt;assume&lt;/code&gt; or an &lt;code class=&quot;highlighter-rouge&quot;&gt;assert&lt;/code&gt;
to keep the formal engine from reaching any unreachable states, or you will
never be able to fully &lt;em&gt;prove&lt;/em&gt; your design meets the properties you have
asserted for all time.&lt;/p&gt;

&lt;p&gt;Following our example of a timer, the formal engine might pick a value for
&lt;code class=&quot;highlighter-rouge&quot;&gt;r_value&lt;/code&gt; that was &lt;code class=&quot;highlighter-rouge&quot;&gt;TIMEOUT+S+2&lt;/code&gt;.  It would then follow &lt;code class=&quot;highlighter-rouge&quot;&gt;r_value&lt;/code&gt; for
&lt;code class=&quot;highlighter-rouge&quot;&gt;S&lt;/code&gt; steps until &lt;code class=&quot;highlighter-rouge&quot;&gt;r_value&lt;/code&gt; was &lt;code class=&quot;highlighter-rouge&quot;&gt;TIMEOUT+2&lt;/code&gt;.  On the next step, our property
that &lt;code class=&quot;highlighter-rouge&quot;&gt;(r_value != TIMEOUT+1)&lt;/code&gt; would be violated.&lt;/p&gt;

&lt;p&gt;To fix this, one would need to assert instead that &lt;code class=&quot;highlighter-rouge&quot;&gt;r_value &amp;lt;= TIMEOUT&lt;/code&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(*)
	assert(r_value &amp;lt;= TIMEOUT);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This makes the size of the “red” area large enough to include the whole
&lt;a href=&quot;https://en.wikipedia.org/wiki/Universe_(mathematics)&quot;&gt;universe&lt;/a&gt;, as shown
in Fig 5.  To follow the consequence of this in our example above,
&lt;code class=&quot;highlighter-rouge&quot;&gt;r_value&lt;/code&gt; would never be allowed to be &lt;code class=&quot;highlighter-rouge&quot;&gt;TIMEOUT+S+2&lt;/code&gt;.  It would only be allowed
to have a valid value.&lt;/p&gt;

&lt;p&gt;To know which of the two, &lt;code class=&quot;highlighter-rouge&quot;&gt;assert&lt;/code&gt; or &lt;code class=&quot;highlighter-rouge&quot;&gt;assume&lt;/code&gt;, is appropriate at any given
time, I’ve always used what I call the &lt;em&gt;master rule of Formal Verification&lt;/em&gt;
shown in Fig 6: &lt;em&gt;assume inputs&lt;/em&gt;, then &lt;em&gt;assert&lt;/em&gt; properties of both
&lt;em&gt;internal states and outputs&lt;/em&gt;.&lt;/p&gt;
&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 6. Master rule of Formal Verification&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/fv-master-rule.svg&quot; alt=&quot;&quot; width=&quot;280&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;This rule has served me well for all of my
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal verification&lt;/a&gt;
efforts to date.  Now that I’ve discovered I need to aggregate modules together,
I’ve had to learn some of the fine nuances of this rule.  These nuances
are the subject of the rest of this article.&lt;/p&gt;

&lt;h2 id=&quot;the-concept-of-an-invariant&quot;&gt;The Concept of an Invariant&lt;/h2&gt;

&lt;p&gt;What the master rule of
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal verification&lt;/a&gt;
doesn’t capture is how you deal
with things that have already been proven.  For example, let’s suppose &lt;code class=&quot;highlighter-rouge&quot;&gt;A&lt;/code&gt;
is a set of assumptions, and &lt;code class=&quot;highlighter-rouge&quot;&gt;B&lt;/code&gt; is a set of assertions.  Once you’ve proven
that &lt;code class=&quot;highlighter-rouge&quot;&gt;A&lt;/code&gt; implies &lt;code class=&quot;highlighter-rouge&quot;&gt;B&lt;/code&gt;, which I shall write as &lt;code class=&quot;highlighter-rouge&quot;&gt;A-&amp;gt;B&lt;/code&gt;, then you shouldn’t need
to prove it again.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: left&quot;&gt;&lt;caption&gt;Fig 7. (Some caption)&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/formal-invariants.svg&quot; alt=&quot;&quot; width=&quot;360&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;This is the concept of an Invariant.  Once you know that &lt;code class=&quot;highlighter-rouge&quot;&gt;A-&amp;gt;B&lt;/code&gt;, then &lt;code class=&quot;highlighter-rouge&quot;&gt;A-&amp;gt;B&lt;/code&gt;
becomes an invariant of your design.  Instead of reproving it, you may now treat
it as an assumption.  This becomes especially useful when trying to deal
with complex proofs. If you can reduce the complexity, you can then verify
larger and larger designs.&lt;/p&gt;

&lt;p&gt;There are two situations where I have found to apply this.  The first is
that of a parent module with a child (or leaf) module underneath it.  The
second place is when the proof of a design can be broken into separate sections.
I’ve encountered both while trying to verify the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;.  We’ll
examine each in turn.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 8. ZipCPU&#39;s module hierarchy&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/files-zipcpu-proved.svg&quot; alt=&quot;&quot; width=&quot;240&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;To explain the first situation, consider the module hierarchy (file structure)
of the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
shown in Fig 8.  The
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; consists of a
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/formal/rtl/core/zipcpu.v&quot;&gt;master CPU&lt;/a&gt;
file, an &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/formal/rtl/core/idecode.v&quot;&gt;instruction
decoder&lt;/a&gt;, an
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/formal/rtl/core/cpuops.v&quot;&gt;ALU&lt;/a&gt; with a
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/formal/rtl/core/mpyop.v&quot;&gt;multiply component&lt;/a&gt;
within it, a &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/formal/rtl/ex/wbdblpriarb.v&quot;&gt;twin bus
arbiter&lt;/a&gt;,
and one of two &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/formal/rtl/core/memops.v&quot;&gt;memory
controllers&lt;/a&gt;.
I use the red bar in Fig 8 to indicate the
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal properties&lt;/a&gt;
within the design.  Normally these properties are found at the end of the
source file.  You’d therefore normally expect this red bar to be at the bottom
of each file within the diagram.  However, since the concept of invariants
turns these properties on end, I show the red bar in this figure at the top
of the file–for illustration purposes.&lt;/p&gt;

&lt;p&gt;The other three components of the 
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; were abstracted.
These were the
&lt;a href=&quot;/zipcpu/2017/11/18/wb-prefetch.html&quot;&gt;prefetch&lt;/a&gt;,
&lt;a href=&quot;https://github.com/ZipCPU/blob/master/rtl/core/div.v&quot;&gt;divide&lt;/a&gt;, and
&lt;a href=&quot;https://github.com/ZipCPU/blob/master/rtl/core/mpyop.v&quot;&gt;multiply&lt;/a&gt;.
These are shown in Fig 8 as empty files with dotted lines around them,
indicating that due to the abstraction they have very little logic remaining
within them.  You can find their abstract representations in
my &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/formal/bench/formal&quot;&gt;bench/formal&lt;/a&gt;
directory.  These also made the proof easier, but for now we’ll leave the
mechanics of this for a topic for a future article.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: left&quot;&gt;&lt;caption&gt;Fig 9. Invariants applied to a parent/leaf module hierarchy&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/invariance-external.svg&quot; alt=&quot;&quot; width=&quot;480&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;To understand how I applied the principle of invariants to this design,
consider Fig 9.  This shows a parent module and a leaf or child module–both
with assertions and assumptions within them.&lt;/p&gt;

&lt;p&gt;In my first step, I verified that the leaf module works.  This is shown in the
left side of Fig 9.  During this step, I ignored the parent module, and only
proved that if the child’s assumptions held then the child would never enter
into an illegal state.&lt;/p&gt;

&lt;p&gt;Once the assumptions and module logic had been used to prove the assertions
within the module, I then switched my focus to the parent.  This is shown
on the right of Fig 9.  In this case, I no longer needed to prove the properties
of the child.  Instead, I needed to prove the properties of the parent.  To do 
this, I asserted that the assumptions of the child held, and then assumed that
the assertions therefore held as well.&lt;/p&gt;

&lt;p&gt;Hmm, that statement was about as confusing as some of the mathematical articles
I’ve read on this topic.  Let me try explaining that again.&lt;/p&gt;

&lt;p&gt;Suppose we let &lt;code class=&quot;highlighter-rouge&quot;&gt;LA&lt;/code&gt; refer to the set of assumptions within the leaf module, and
&lt;code class=&quot;highlighter-rouge&quot;&gt;LB&lt;/code&gt; refer to the set of assertions within the leaf module.  By
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formally verifying&lt;/a&gt;
that module, I’ve now proved that &lt;code class=&quot;highlighter-rouge&quot;&gt;LA -&amp;gt; LB&lt;/code&gt;.
Unwrapping this a touch, this is equivalent to the
statement that either &lt;code class=&quot;highlighter-rouge&quot;&gt;LA&lt;/code&gt; is false, or &lt;code class=&quot;highlighter-rouge&quot;&gt;LB&lt;/code&gt; must be true: &lt;code class=&quot;highlighter-rouge&quot;&gt;(!LA)||(LB)&lt;/code&gt;.
Said another way, either one of the assumptions of this module must be false,
or all the assertions must be true.&lt;/p&gt;

&lt;p&gt;Now I want to move on to the parent module.  In this case, I have the additional
assumptions &lt;code class=&quot;highlighter-rouge&quot;&gt;PA&lt;/code&gt; and assertions &lt;code class=&quot;highlighter-rouge&quot;&gt;PB&lt;/code&gt; from the parent and I would like to prove
that &lt;code class=&quot;highlighter-rouge&quot;&gt;PA-&amp;gt;PB&lt;/code&gt;.
However, I also need to deal with the leaf module.  For the leaf module, I
know that &lt;code class=&quot;highlighter-rouge&quot;&gt;LA-&amp;gt;LB&lt;/code&gt;.  What I don’t know is whether or not &lt;code class=&quot;highlighter-rouge&quot;&gt;LA&lt;/code&gt; holds since
it consists of values provided by the parent module.  Unless and until I know
that &lt;code class=&quot;highlighter-rouge&quot;&gt;LA&lt;/code&gt; holds, I really know nothing about &lt;code class=&quot;highlighter-rouge&quot;&gt;LB&lt;/code&gt;.  Further, since the wires
composing &lt;code class=&quot;highlighter-rouge&quot;&gt;LA&lt;/code&gt; come from the parent, what I really need to do is to &lt;em&gt;assert&lt;/em&gt;
these properties hold in order to guarantee the proper functioning of the leaf.
Hence, I will now assert &lt;code class=&quot;highlighter-rouge&quot;&gt;LA&lt;/code&gt; and assume &lt;code class=&quot;highlighter-rouge&quot;&gt;LB&lt;/code&gt;.  This is backwards from how I
treated these components before.  As a result, I will assume &lt;code class=&quot;highlighter-rouge&quot;&gt;PA&amp;amp;LB&lt;/code&gt; and assert
&lt;code class=&quot;highlighter-rouge&quot;&gt;PB&amp;amp;LA&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The fascinating part of this is that the master rule of
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal verification&lt;/a&gt;
still applies.  We’re still &lt;em&gt;assuming&lt;/em&gt; the inputs to the parent module and
&lt;em&gt;asserting&lt;/em&gt; the properties of the internal state and any outputs.  How can this
be?  It works because the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flip-flop_(electronics)&quot;&gt;flip-flops&lt;/a&gt;
composing the internal state of the parent module are the input
connections to the child.  Hence the assumptions of the child’s inputs
are now outputs from the parent and so they may be asserted.  Likewise the
child’s outputs are now the parent’s inputs, and so it makes sense to make
assumptions about them.&lt;/p&gt;

&lt;p&gt;It this is still confusing, relax, I’ll show some code snippets
to illustrate how I applied this concept in the next section.&lt;/p&gt;

&lt;p&gt;The second way that invariants can be used within a design is within a given
design component (module).  In my case, it was within the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/formal/rtl/core/zipcpu.v&quot;&gt;ZipCPU core&lt;/a&gt;.
In this case, we’ll separate the assertions into groups of increasingly
complex logic, called stages in Fig 10 below.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 10. Invariants applied within a file&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/invariance-internal.svg&quot; alt=&quot;&quot; width=&quot;720&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Let’s call these sets of assertions &lt;code class=&quot;highlighter-rouge&quot;&gt;B0&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;B1&lt;/code&gt;, and &lt;code class=&quot;highlighter-rouge&quot;&gt;B2&lt;/code&gt;.  For the first
formal proof, we’ll prove that the assumptions together with the design
logic prove the &lt;code class=&quot;highlighter-rouge&quot;&gt;B0&lt;/code&gt; property, &lt;code class=&quot;highlighter-rouge&quot;&gt;A-&amp;gt;B0&lt;/code&gt;.  Within the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/formal/rtl/core/zipcpu.v&quot;&gt;ZipCPU core&lt;/a&gt;,
I call these &lt;code class=&quot;highlighter-rouge&quot;&gt;PHASE_ONE_ASSERT&lt;/code&gt;ions.  Once we know that &lt;code class=&quot;highlighter-rouge&quot;&gt;A-&amp;gt;B0&lt;/code&gt;,
we turn our attention to proving &lt;code class=&quot;highlighter-rouge&quot;&gt;B1&lt;/code&gt;.  In that case, we now know that
&lt;code class=&quot;highlighter-rouge&quot;&gt;A&lt;/code&gt; is true by assumption, but we also know that &lt;code class=&quot;highlighter-rouge&quot;&gt;B0&lt;/code&gt; is true by the implication
we just proved.  So for this second stage proof, we assume &lt;code class=&quot;highlighter-rouge&quot;&gt;A&lt;/code&gt; &lt;em&gt;and&lt;/em&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;B0&lt;/code&gt; and
attempt to prove &lt;code class=&quot;highlighter-rouge&quot;&gt;B1&lt;/code&gt;.  We can then repeat this again, assuming
&lt;code class=&quot;highlighter-rouge&quot;&gt;A&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;B0&lt;/code&gt;, and now &lt;code class=&quot;highlighter-rouge&quot;&gt;B1&lt;/code&gt; and proving &lt;code class=&quot;highlighter-rouge&quot;&gt;B2&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;If you’ve examined the (current)
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/formal/rtl/core/zipcpu.v&quot;&gt;formal proof&lt;/a&gt;
of the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; (it’s still a work in
progress), you may have noticed that I am using both of these methods.
First, I am verifying that the component pieces to the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
work as desired.  Then, I am aggregating those into the proof of the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; as a whole.  Second, within the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;, I’ve created two parts to the
proof: &lt;code class=&quot;highlighter-rouge&quot;&gt;B0&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;B1&lt;/code&gt;.  I’m expecting to create a third and possibly fourth
component later.  Currently, I can prove both &lt;code class=&quot;highlighter-rouge&quot;&gt;B0&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;B1&lt;/code&gt; using
&lt;a href=&quot;https://symbiyosys.readthedocs.io/en/latest&quot;&gt;SymbiYosys&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;According to &lt;a href=&quot;https://www.onespin.com&quot;&gt;OneSpin Solutions&lt;/a&gt;, this method can
increase the depth of the proof or rather the number of state transitions that
can be examined in a reasonable amount of time by perhaps a thousand fold.
These are their numbers, though.  In my own experience, I can only say that
formally verifying the second stage of the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; used to take longer than all
night.  (I’m not really sure how long–I never let it finish.)  It now takes
just over an hour.&lt;/p&gt;

&lt;h2 id=&quot;how-this-concept-appears-in-verilog&quot;&gt;How this concept appears in Verilog&lt;/h2&gt;

&lt;p&gt;The previous sections have discussed a lot about
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal verification&lt;/a&gt;
in the abstract.  They’ve
been so far from coded reality that I would imagine I’ve now left several
readers wondering what I’m talking about.  So let’s bring these abstract
concepts to reality, and discuss how they might look within a piece
of Verilog code.&lt;/p&gt;

&lt;p&gt;We’ll start with a fairly plain Verilog module.  Almost all of my modules have
the following rough format.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;// Copyright statement
`default_nettype	none
//
module thismodule( ...);
	// Core logic
`ifdef	FORMAL
	// Formal properties

	always @(*)
		assume(i_some_input);
	always @(*)
		assert(o_some_output);
`endif
endmodule&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;They start with a copyright statement, and then declare the &lt;code class=&quot;highlighter-rouge&quot;&gt;default_nettype&lt;/code&gt;
to be none instead of wire.  (This catches a &lt;em&gt;lot&lt;/em&gt; of bugs.)  The module
definition then follows with the core logic within it.  Following the module
logic, there’s an &lt;code class=&quot;highlighter-rouge&quot;&gt;ifdef FORMAL&lt;/code&gt; delimited section ending just before the
&lt;code class=&quot;highlighter-rouge&quot;&gt;endmodule&lt;/code&gt; on the last line of the file.  Inside that section I
place any assumptions or assertions regarding the logic above.  Indeed,
if you browse through any of the code I’ve formally verified, you’ll find
this to be the common form.&lt;/p&gt;

&lt;p&gt;If it is possible that this might be a leaf or child module to some other
module within a formal proof, then I’ll make some adjustments to the formal
section.  First, I’ll use a synthesis define to indicate &lt;code class=&quot;highlighter-rouge&quot;&gt;THISMODULE&lt;/code&gt; is
the module being verified.  Inside the module’s yosys script, I’ll also
modify the &lt;code class=&quot;highlighter-rouge&quot;&gt;read_verilog&lt;/code&gt; command to include a &lt;code class=&quot;highlighter-rouge&quot;&gt;-D THISMODULE&lt;/code&gt;.  So, for
example, within the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/formal/rtl/core/pipemem.v&quot;&gt;pipelined memory controller
module&lt;/a&gt;,
there’s a check for whether or not &lt;code class=&quot;highlighter-rouge&quot;&gt;PIPEMEM&lt;/code&gt; is defined.  Likewise, you
can see the definition within its &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/formal/bench/formal/pipemem.ys&quot;&gt;its yosys
script&lt;/a&gt;.
Second, I’ll define macros which I can then use to reference either the
&lt;code class=&quot;highlighter-rouge&quot;&gt;assume&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;assert&lt;/code&gt; statements.  If &lt;code class=&quot;highlighter-rouge&quot;&gt;THISMODULE&lt;/code&gt; is defined, these
will refer to &lt;code class=&quot;highlighter-rouge&quot;&gt;assume&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;assert&lt;/code&gt; as expected.  If not, they’ll be
swapped.  Then I rewrite the formal properties to use these macros.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;`ifdef	FORMAL
`ifdef	THISMODULE
`define	ASSUME	assume
`define	ASSERT	assert
`else
`define	ASSUME	assert
`define	ASSERT	assume
`endif
	// Formal properties
	always @(*)
		`ASSUME(i_some_input);
	always @(*)
		`ASSERT(o_some_output);
`endif&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This is how I handle creating the logic pictured in Fig 9 above within any
of the non-abstracted child modules.&lt;/p&gt;

&lt;p&gt;Perhaps the best example of how this might be useful is in the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;’s
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/formal/rtl/core/pipemem.v&quot;&gt;pipelined memory
controller&lt;/a&gt;.
The “contract” the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
has with the user is that it will not
&lt;a href=&quot;https://meltdownattack.com&quot;&gt;speculatively execute memory operations&lt;/a&gt;–since the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
places both memory and peripherals on the same bus.  Bus operations may be
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;pipelined&lt;/a&gt;,
meaning that multiple reads may be ongoing at any given time.  Now consider,
what would happen if one of those reads set the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Program_counter&quot;&gt;program counter&lt;/a&gt;?
There would be no way to undo any of the other reads that might be in
progress by this point.&lt;/p&gt;

&lt;p&gt;For example, consider the following string of loads.  In the
&lt;a href=&quot;/zipcpu/2018/01/01/zipcpu-isa.html&quot;&gt;ZipCPU ISA&lt;/a&gt;,
an &lt;code class=&quot;highlighter-rouge&quot;&gt;LW&lt;/code&gt; instruction loads a word of data from the bus into the register given
as the second argument.  (&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
instructions read left to right.)  The second to the last of these loads reads
a value into the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Program_counter&quot;&gt;program counter&lt;/a&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-asm&quot; data-lang=&quot;asm&quot;&gt;LW (R0),R1	; Load word from the address in R0 into the R1 register
LW 4(R0),R2	; R2 &amp;lt;- Mem[R0+4]
LW 8(R0),R3
LW 12(R0),R4
LW 16(R0),R5
LW 20(R0),PC	; PC &amp;lt;= Mem[R0+20]
LW 24(R0),R6	; Must not issue until the last load has completed&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Any time the &lt;a href=&quot;https://en.wikipedia.org/wiki/Program_counter&quot;&gt;program counter
(PC)&lt;/a&gt;
is set, the
CPU
jumps to a new instruction.  Hence, this memory read into the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Program_counter&quot;&gt;PC&lt;/a&gt;
is really a jump instruction.&lt;/p&gt;

&lt;p&gt;Should the CPU initiate the read into &lt;code class=&quot;highlighter-rouge&quot;&gt;R6&lt;/code&gt;?  No.  Not until the read into the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Program_counter&quot;&gt;PC&lt;/a&gt; completes.&lt;/p&gt;

&lt;p&gt;To check for this, the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/formal/rtl/core/pipemem.v&quot;&gt;memory
controller&lt;/a&gt;
assumes that any read into the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Program_counter&quot;&gt;program counter&lt;/a&gt;
must be the last read in a sequence.  To
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formally prove&lt;/a&gt;
this in an
&lt;a href=&quot;/blog/2018/03/10/induction-exercise.html&quot;&gt;inductive manner&lt;/a&gt;,
I need to check via assertions that the nothing in the
pipeline of ongoing reads contains a read into the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Program_counter&quot;&gt;program counter&lt;/a&gt;.
Once proven, the controller then asserts that if any output is to the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Program_counter&quot;&gt;program counter&lt;/a&gt;
then it must be the last return value in the sequence.  When this
component is aggregated, the “check every FIFO element” code is quietly
removed, being replaced only be the final assertion on the output.  This
final assertion, however, has been replaced by this process with an assumption
that no longer needs to be checked–simplifying the proof of the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
as a whole.&lt;/p&gt;

&lt;p&gt;The second method of applying invariants is the application within a given
file, as shown in Fig 10 above.  In this case, you want to prove several
sets of assertions.  Within the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/formal/rtl/core/zipcpu.v&quot;&gt;core&lt;/a&gt;,
I call these &lt;code class=&quot;highlighter-rouge&quot;&gt;PHASE_ONE&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;PHASE_TWO&lt;/code&gt;, and so on.
Associated with each phase is an assertion macro, &lt;code class=&quot;highlighter-rouge&quot;&gt;PHASE_ONE_ASSERT&lt;/code&gt;,
&lt;code class=&quot;highlighter-rouge&quot;&gt;PHASE_TWO_ASSERT&lt;/code&gt;, etc.  To then verify the component, you’d run it through
the formal engine twice: first as is, to test all of the phase one assertions,
and then again with &lt;code class=&quot;highlighter-rouge&quot;&gt;PHASE_TWO&lt;/code&gt; defined in order to test the phase two
assertions.  The second set of assertions are excluded from being evaluated
during the first set by a synthesis &lt;code class=&quot;highlighter-rouge&quot;&gt;ifdef&lt;/code&gt; directive.&lt;/p&gt;

&lt;p&gt;You can see the
&lt;a href=&quot;https://symbiyosys.readthedocs.io/en/latest&quot;&gt;SymbiYosys&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/formal/bench/formal/zipcpu.sby&quot;&gt;script for this here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The relevant code, shown below, was lifted from the beginning of the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;’s &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/formal/rtl/core/zipcpu.v&quot;&gt;formal properties
section&lt;/a&gt;.
It starts out with a commented list of all of the formal phases supported by
the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/formal/rtl/core/zipcpu.v&quot;&gt;module&lt;/a&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;`ifdef	FORMAL
//
// PHASE_X definitions control our assertion logic below.  They are to be
// defined by the synthesizer
//
// `define PHASE_TWO
// `define PHASE_THREE
// `define PHASE_FOUR
//&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;These aren’t strictly necessary, but they remind me which defines I am
supporting.&lt;/p&gt;

&lt;p&gt;Then each of the phases is given its own assertion macro.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;`define	PHASE_ONE_ASSERT	assert
`define	PHASE_TWO_ASSERT	assert
`define	PHASE_THR_ASSERT	assert
//&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;If &lt;code class=&quot;highlighter-rouge&quot;&gt;PHASE_TWO&lt;/code&gt; is defined, the &lt;code class=&quot;highlighter-rouge&quot;&gt;PHASE_ONE_ASSERT&lt;/code&gt; macro is then redefined as
an assumption.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;`ifdef	PHASE_TWO
`undef	PHASE_ONE_ASSERT
`define	PHASE_ONE_ASSERT	assume&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Likewise, if &lt;code class=&quot;highlighter-rouge&quot;&gt;PHASE_THREE&lt;/code&gt; is also defined then the &lt;code class=&quot;highlighter-rouge&quot;&gt;PHASE_TWO_ASSERT&lt;/code&gt;
is redefined to be an assumption.  This process then repeats for all of the
phases supported by the design.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;`ifdef	PHASE_THREE
`undef	PHASE_TWO_ASSERT
`define	PHASE_TWO_ASSERT	assume

`ifdef	PHASE_FOUR
`undef	PHASE_THR_ASSERT
`define	PHASE_THR_ASSERT	assume
`endif // PHASE_FOUR
`endif // PHASE_THREE
`endif // PHASE_TWO&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;At this point, the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/formal/rtl/core/zipcpu.v&quot;&gt;formal
properties&lt;/a&gt;
can proceed in sections.  The first section makes any input assumptions
necessary.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	// An example assumption
	always @(*)
		assume(i_some_input);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Then the first set of assertions follows these assumptions.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	// An example assertion
	always @(*)
		`PHASE_ONE_ASSERT(o_some_output);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This set of assertions is created
using the &lt;code class=&quot;highlighter-rouge&quot;&gt;PHASE_ONE_ASSERT&lt;/code&gt; macro.  That will allow us to replace these
assertions with assumptions in the next pass–once they’ve been proven
true in a first pass.&lt;/p&gt;

&lt;p&gt;Later, we can split into a second section of assertions–but only after
we’ve used the formal tools to verify the first set of assertions, and only
if &lt;code class=&quot;highlighter-rouge&quot;&gt;PHASE_TWO&lt;/code&gt; is defined.  In this latter section, assertions are created
using the &lt;code class=&quot;highlighter-rouge&quot;&gt;PHASE_TWO_ASSERT&lt;/code&gt; macro.  Further, in order to get into this
section the &lt;code class=&quot;highlighter-rouge&quot;&gt;PHASE_ONE_ASSERT&lt;/code&gt; macro used the previous section will have
been redefined to be an &lt;code class=&quot;highlighter-rouge&quot;&gt;assume&lt;/code&gt; statement instead of the original &lt;code class=&quot;highlighter-rouge&quot;&gt;assert&lt;/code&gt;
statement.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;`ifdef	PHASE_TWO
	always @(*)
		`PHASE_TWO_ASSERT(o_some_other_output);
`endif // PHASE_TWO
`endif // FORMAL&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;In the case of the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;,
the second phase of
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal verification&lt;/a&gt;
includes several free variables (&lt;a href=&quot;http://www.clifford.at/yosys/&quot;&gt;yosys&lt;/a&gt;’s
&lt;code class=&quot;highlighter-rouge&quot;&gt;$anyconst&lt;/code&gt;) used to track an arbitrary instruction from an arbitrary address
working its way through the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;’s
logic.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	assign	f_const_insn    = $anyconst;
	assign	f_const_addr    = $anyconst;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Using this method, I can reconstruct the operands for any operation
before that operation is issued, and verify that they have the right values.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(posedge i_clk)
	if // details
	begin
		if // more details ...
		begin
			// Check that the first operand matches
			if (fc_rA)
				`PHASE_TWO_ASSERT(f_Av == op_Av);
			// Now check the second operand
			`PHASE_TWO_ASSERT(f_Bv == op_Bv);
		end
	end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;If you’ll recall from the article describing the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;’s
&lt;a href=&quot;/zipcpu/2018/01/01/zipcpu-isa.html&quot;&gt;instruction set&lt;/a&gt;,
almost all
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
instructions have the basic form: &lt;code class=&quot;highlighter-rouge&quot;&gt;OP.C Ra,Rb+I&lt;/code&gt;, where &lt;code class=&quot;highlighter-rouge&quot;&gt;Ra&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;Rb&lt;/code&gt; are
arbitrary registers, and &lt;code class=&quot;highlighter-rouge&quot;&gt;I&lt;/code&gt; is some immediate constant.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 11. ZipCPU&#39;s ALU stage in context&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/cpu-bypass.svg&quot; alt=&quot;&quot; width=&quot;640&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Prior to entering the
&lt;a href=&quot;/zipcpu/2017/08/11/simple-alu.html&quot;&gt;ALU&lt;/a&gt;
stage, the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
adds the &lt;code class=&quot;highlighter-rouge&quot;&gt;Rb&lt;/code&gt; register value and &lt;code class=&quot;highlighter-rouge&quot;&gt;I&lt;/code&gt; together.  Then, while waiting for the
&lt;a href=&quot;/zipcpu/2017/08/11/simple-alu.html&quot;&gt;ALU&lt;/a&gt;
stage to become available, any write to either &lt;code class=&quot;highlighter-rouge&quot;&gt;Ra&lt;/code&gt; or &lt;code class=&quot;highlighter-rouge&quot;&gt;Rb&lt;/code&gt; adjusts these
values.&lt;/p&gt;

&lt;p&gt;What makes this difficult is that, in order to keep clock speed high, there’s
no opportunity to re-add the immediate constant &lt;code class=&quot;highlighter-rouge&quot;&gt;I&lt;/code&gt; to &lt;code class=&quot;highlighter-rouge&quot;&gt;Rb&lt;/code&gt;–that would take an
extra clock tick.  Dealing with this requires some careful pipeline stall
logic, and getting this logic right has been
tricky.  By allowing the formal engine to pick an arbitrary pipeline state
and then examine an arbitrary instruction going into the
&lt;a href=&quot;/zipcpu/2017/08/11/simple-alu.html&quot;&gt;ALU&lt;/a&gt;,
I can guarantee that the &lt;code class=&quot;highlighter-rouge&quot;&gt;Ra&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;Rb+I&lt;/code&gt; operands are valid no matter
which instruction precedes them.&lt;/p&gt;

&lt;p&gt;Searching through all of the possibilities of these free variables
can be expensive.  Indeed, this was the phase that was taking many hours
of processing as I was working on verifying
&lt;a href=&quot;https://github.com/ZipCPU/blob/master/rtl/core/zipcpu.v&quot;&gt;this core&lt;/a&gt;
module within the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;.  Now, using this method of
invariants, the entire formal verification of the (still not quite complete
properties of the)
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
takes less than two hours.&lt;/p&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;Invariants are only one method of handling formal complexity when aggregating
multiple modules together.  As I mentioned in the opening, I am by no means
an expert in
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal verification&lt;/a&gt;,
and so this is only my first application of
the principle of invariants to any project–in this case the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;.
However, even in the case of the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;,
the value of using invariants has saved many, many
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal verification&lt;/a&gt;
CPU cycles.&lt;/p&gt;

&lt;p&gt;We’ll have to return to this topic later in order to handle the concept of
abstraction in
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal methods&lt;/a&gt;.
Abstraction may be an even more powerful concept than invariants.
As you may remember from above, I’ve been using abstracted components to
represent the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/formal/bench/formal/abs_prefetch.v&quot;&gt;prefetch&lt;/a&gt;,
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/formal/bench/formal/abs_mpy.v&quot;&gt;multiply&lt;/a&gt;,
and
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/formal/bench/formal/abs_div.v&quot;&gt;divide&lt;/a&gt;
components.  As another illustration, consider this: when
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formally verifying&lt;/a&gt;
any container of the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;,
whether the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/zipsystem.v&quot;&gt;ZipSystem&lt;/a&gt;,
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/zipbones.v&quot;&gt;ZipBones&lt;/a&gt;,
or some yet to be determined container, I’m anticipating being able to
replace the entire complicated
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
core with an abstracted version of it, and then to be able to prove
the formal properties of the wrapper in question.&lt;/p&gt;

&lt;hr /&gt;&lt;p&gt;&lt;em&gt;And that ye study to be quiet, and to do your own business, and to work with your own hands, as we commanded you (1Thes 4:11)&lt;/em&gt;</description>
        <pubDate>Mon, 23 Apr 2018 00:00:00 -0400</pubDate>
        <link>http://zipcpu.com/formal/2018/04/23/invariant.html</link>
        <guid isPermaLink="true">http://zipcpu.com/formal/2018/04/23/invariant.html</guid>
        
        
        <category>formal</category>
        
      </item>
    
      <item>
        <title>ZipTimer: A simple countdown timer</title>
        <description>&lt;p&gt;If you are a beginning
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
designer, the first example you will be given to learn is that of a counter.
It’s sort of a tradition.  Class room exercises all illustrate concepts
with simple counters.  If you ask a question, the instructor will go to the
board and start his explanation with a counter.  At least, that’s what I would
do if I trying to teach an Verilog concept.&lt;/p&gt;

&lt;p&gt;But just how useful is a counter in the end anyway?&lt;/p&gt;

&lt;p&gt;Let’s try examining a
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/ziptimer.v&quot;&gt;counter&lt;/a&gt;
all the way from an irrelevant classroom
discussion to a vital system component.&lt;/p&gt;

&lt;p&gt;How can this be?  Well, one
peripheral necessary to any
&lt;a href=&quot;https://en.wikipedia.org/wiki/Computer_multitasking&quot;&gt;multitasking&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Operating_System&quot;&gt;operating system&lt;/a&gt;, whether
&lt;a href=&quot;http://www.unix.org/what_is_unix.html&quot;&gt;Unix&lt;/a&gt;,
&lt;a href=&quot;https://en.wikipedia.org/wiki/Linux&quot;&gt;Linux&lt;/a&gt;, Windows, or some other
&lt;a href=&quot;https://en.wikipedia.org/wiki/Operating_System&quot;&gt;O/S&lt;/a&gt;, is an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Programmable_interval_timer&quot;&gt;interval timer&lt;/a&gt;.
An &lt;a href=&quot;https://en.wikipedia.org/wiki/Programmable_interval_timer&quot;&gt;interval timer&lt;/a&gt;
is little more than a reconfigurable counter.  All it does is issue an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interrupt&quot;&gt;interrupt&lt;/a&gt;
to the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;
at a periodic interval.&lt;/p&gt;

&lt;p&gt;Embedded systems, such as those found within
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;’s,
have an additional timing
need.  These systems often need to insert known delays between different
operations.  Instead of an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Programmable_interval_timer&quot;&gt;interval timer&lt;/a&gt;,
these systems need what are known as
&lt;a href=&quot;https://en.wikipedia.org/wiki/Programmable_interval_timer&quot;&gt;“one-shot” timers&lt;/a&gt;.
Once programmed, they generate an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interrupt&quot;&gt;interrupt&lt;/a&gt;
after the programmed delay takes place and then they return to idle.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 1. The ZipSystem&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/zipsystem.svg&quot; alt=&quot;&quot; width=&quot;480&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;The 
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; wrapper known as the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/zipsystem.v&quot;&gt;ZipSystem&lt;/a&gt;
has three such timers within it, shown in Fig 1 as “Generic Timers (x3)”.
I call these timers
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/ziptimer.v&quot;&gt;ZipTimers&lt;/a&gt;.
Each of these
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/ziptimer.v&quot;&gt;ZipTimers&lt;/a&gt;
supports generating either a regular
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interrupt&quot;&gt;interrupt&lt;/a&gt;
or a one-shot delay based
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interrupt&quot;&gt;interrupt&lt;/a&gt;.  These
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/ziptimer.v&quot;&gt;ZipTimers&lt;/a&gt;
have been a part of the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/zipsystem.v&quot;&gt;ZipSystem&lt;/a&gt;
since I started.  Their simplicity makes them perfect
candidates for beginner exercises, and even better candidates for learning
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal verification&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/ziptimer.v&quot;&gt;ZipTimer&lt;/a&gt;
has two capabilities beyond the traditional beginner’s counter
exercise.  These are first the ability to be programmed over a &lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;wishbone
bus&lt;/a&gt;,
and second the ability to
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interrupt&quot;&gt;interrupt&lt;/a&gt; the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Soft_microprocessor&quot;&gt;CPU&lt;/a&gt;
when the specified delay runs out.&lt;/p&gt;

&lt;p&gt;Therefore, let’s examine this &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/ziptimer.v&quot;&gt;timer
peripheral&lt;/a&gt;
as an exercise in learning Verilog,
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal verification&lt;/a&gt;,
and connecting a simple item to a bus using
&lt;a href=&quot;/zipcpu/2017/10/05/autofpga-intro.html&quot;&gt;AutoFPGA&lt;/a&gt;.
Along the way, I’ll do my best to avoid calling this a “counter example”.&lt;/p&gt;

&lt;h2 id=&quot;the-beginners-exercise&quot;&gt;The Beginner’s Exercise&lt;/h2&gt;

&lt;p&gt;Hopefully everyone reading this blog has at one time built a countdown timer
in Verilog.  Indeed, I use a basic countdown timer as one of the first examples
in the &lt;a href=&quot;/projects.html&quot;&gt;Formal Verification course&lt;/a&gt;
I now teach.  Below is the simple example timer that we’ll start
with today.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 2. A Countdown Timer&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/timer-oneshot.svg&quot; alt=&quot;&quot; width=&quot;248&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;initial	r_value = 0;
always @(posedge i_clk)
	if (i_start)
		r_value &amp;lt;= TIMEOUT;
	else if (r_value != 0)
		r_value &amp;lt;= r_value - 1&#39;b1;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This counter starts at zero.  Any time an &lt;code class=&quot;highlighter-rouge&quot;&gt;i_start&lt;/code&gt; signal takes place, the
counter is set to &lt;code class=&quot;highlighter-rouge&quot;&gt;TIMEOUT&lt;/code&gt; and then counts down to zero, as illustrated in
Fig 2.  Note that
setting this counter to &lt;code class=&quot;highlighter-rouge&quot;&gt;TIMEOUT&lt;/code&gt; doesn’t guarantee that it will take
&lt;code class=&quot;highlighter-rouge&quot;&gt;TIMEOUT&lt;/code&gt; clock ticks until it returns to zero–it is possible the &lt;code class=&quot;highlighter-rouge&quot;&gt;i_start&lt;/code&gt;
signal resets this counter back to &lt;code class=&quot;highlighter-rouge&quot;&gt;TIMEOUT&lt;/code&gt; before it hits zero.&lt;/p&gt;

&lt;p&gt;We’ll also create an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interrupt&quot;&gt;interrupt&lt;/a&gt;
signal that we will set anytime the counter becomes zero.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;initial	o_int &amp;lt;= 1&#39;b0;
always @(posedge i_clk)
	o_int &amp;lt;= (r_value == 1);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;That’s not all that hard, right?&lt;/p&gt;

&lt;p&gt;Did you notice the subtlety associated with checking &lt;code class=&quot;highlighter-rouge&quot;&gt;r_value==1&lt;/code&gt; here?
One of my readers pointed this out.  If &lt;code class=&quot;highlighter-rouge&quot;&gt;i_start&lt;/code&gt; happens to be true on the
same cycle that &lt;code class=&quot;highlighter-rouge&quot;&gt;r_value==1&lt;/code&gt;, then &lt;code class=&quot;highlighter-rouge&quot;&gt;o_int&lt;/code&gt; might be true on a clock cycle
when &lt;code class=&quot;highlighter-rouge&quot;&gt;r_value != 0&lt;/code&gt;.  Yes, this is a bug.  It’ll come back in the next section
as well.  However, I’m going to leave this bug in place because this was how I
originally designed the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/ziptimer.v&quot;&gt;ZipTimer&lt;/a&gt;–with
this bug within it.  (Oops!) It wasn’t until years later when I attempted to
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formally verify&lt;/a&gt; the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/ziptimer.v&quot;&gt;timer
code&lt;/a&gt;
presented below that I discovered this subtlety.&lt;/p&gt;

&lt;p&gt;For now, let’s just peel this onion back a bit further.&lt;/p&gt;

&lt;p&gt;The problem with the above implementation of a counter is that it isn’t very
reusable.  If you are going to generate a counter that will be
&lt;a href=&quot;https://en.wikipedia.org/wiki/Programmable_interval_timer&quot;&gt;programmable&lt;/a&gt;,
then you’ll want to add a
&lt;a href=&quot;/zipcpu/2017/05/29/simple-wishbone.html&quot;&gt;bus interface &lt;/a&gt;.
If we use the
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;wishbone bus&lt;/a&gt;,
then anytime &lt;code class=&quot;highlighter-rouge&quot;&gt;(i_wb_stb)&amp;amp;&amp;amp;(i_wb_we)&lt;/code&gt; is true, and the address reflects our
timer’s address, then we can reload our timer from &lt;code class=&quot;highlighter-rouge&quot;&gt;i_wb_data&lt;/code&gt;.
This would give us a more adaptable, configurable timer.  Such a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_(computing)&quot;&gt;bus&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Programmable_interval_timer&quot;&gt;controlled timer&lt;/a&gt;
could easily become a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Soft_microprocessor&quot;&gt;CPU&lt;/a&gt; peripheral.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;initial	r_value = 0;
always @(posedge i_clk)
	if ((i_wb_stb)&amp;amp;&amp;amp;(i_wb_we))
		r_value &amp;lt;= i_wb_data;
	else if (r_value != 0)
		r_value &amp;lt;= r_value - 1&#39;b1;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This works fine for
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
implementations, but what if you want this counter to run in a &lt;a href=&quot;/blog/2017/10/13/fpga-v-asic.html&quot;&gt;context
where &lt;code class=&quot;highlighter-rouge&quot;&gt;initial&lt;/code&gt; statements are
ignored&lt;/a&gt;?  In that case,
you need an &lt;code class=&quot;highlighter-rouge&quot;&gt;i_reset&lt;/code&gt; input.  On a reset, that is when &lt;code class=&quot;highlighter-rouge&quot;&gt;i_reset&lt;/code&gt; is high,
the counter should return to idle, &lt;code class=&quot;highlighter-rouge&quot;&gt;r_value == 0&lt;/code&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;initial	r_value = 0;
always @(posedge i_clk)
	if (i_reset)
		r_value &amp;lt;= 0;
	else if ((i_wb_stb)&amp;amp;&amp;amp;(i_wb_we))
		r_value &amp;lt;= i_wb_data;
	else if (r_value != 0)
		r_value &amp;lt;= r_value - 1&#39;b1;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;In a similar fashion, with only a tiny adjustment, we can use this module
to count events.  We’ll use an incoming &lt;code class=&quot;highlighter-rouge&quot;&gt;i_ce&lt;/code&gt; signal to denote when an event
has taken place.  Examples of such events include not only clock cycles
(&lt;code class=&quot;highlighter-rouge&quot;&gt;i_ce=1&lt;/code&gt;), but also incoming or outgoing samples in a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_signal_processing&quot;&gt;DSP&lt;/a&gt;
system, or lines or frames in a video system.  All of these options can
be created by appropriately setting an &lt;code class=&quot;highlighter-rouge&quot;&gt;i_ce&lt;/code&gt; input to one &lt;a href=&quot;/blog/2017/08/14/strategies-for-pipelining.html&quot;&gt;any time the
timer is to
step&lt;/a&gt;.
Put together, our original counter now becomes,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;initial	r_value = 0;
always @(posedge i_clk)
	if (i_reset)
		r_value &amp;lt;= 0;
	else if ((i_wb_stb)&amp;amp;&amp;amp;(i_wb_we))
		r_value &amp;lt;= i_wb_data;
	else if ((i_ce)&amp;amp;&amp;amp;(r_value != 0))
		r_value &amp;lt;= r_value - 1&#39;b1;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;That’s quite the configurable counter, no?&lt;/p&gt;

&lt;p&gt;Let’s now return to our
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus interface&lt;/a&gt;
and properly set the rest of the required
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;
&lt;a href=&quot;/zipcpu/2017/05/29/simple-wishbone.html&quot;&gt;control values&lt;/a&gt;.
Since we can respond on every clock cycle, there’s no reason to ever stall the
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;assign	o_wb_stall = 1&#39;b0;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;We’ll also need to create a response to the &lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;wishbone
bus&lt;/a&gt;.  Since
this operation takes only a single cycle, we’ll acknowledge the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_(computing)&quot;&gt;bus&lt;/a&gt;
any time we are selected.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;assign	o_wb_ack = (i_wb_stb);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;We can do this if the current counter state data is always valid on the
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;’s
&lt;code class=&quot;highlighter-rouge&quot;&gt;o_wb_data&lt;/code&gt; lines.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;assign	o_wb_data = r_value;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Voila!  A &lt;a href=&quot;/zipcpu/2017/05/29/simple-wishbone.html&quot;&gt;simple, wishbone bus
controlled&lt;/a&gt;
count-down timer!&lt;/p&gt;

&lt;h2 id=&quot;interval-timer&quot;&gt;Interval Timer&lt;/h2&gt;

&lt;p&gt;The former code works great for a one-shot timer.  However, if you want to
create a timer that
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interrupt&quot;&gt;interrupts&lt;/a&gt; the 
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt; every 10ms (as an example), only
to be reset by the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt; in an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interrupt_handler&quot;&gt;interrupt service routine&lt;/a&gt;,
then you will find that the interval pseudorandomly walks in phase.  The
intervals will all be longer then 10ms.  How can we fix this?&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 3. An Interval Timer&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/timer-interval.svg&quot; alt=&quot;&quot; width=&quot;248&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;One solution is to use an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Programmable_interval_timer&quot;&gt;interval timer&lt;/a&gt;.
Simply put, an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Programmable_interval_timer&quot;&gt;interval timer&lt;/a&gt;
is one that counts down to zero, and then resets itself to count down again.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;initial	r_value = 0;
always @(posedge i_clk)
	if (r_value != 0)
		r_value &amp;lt;= r_value - 1&#39;b1;
	else
		r_value &amp;lt;= interval_count;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;As before, we’ll generate an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interrupt&quot;&gt;interrupt&lt;/a&gt;
anytime this timer hits zero,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;initial	o_int &amp;lt;= 1&#39;b0;
always @(posedge i_clk)
	o_int &amp;lt;= (r_value == 1);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;But … what if we wanted to allow this reload value to be externally set?
To create this capability, we’ll attach this
&lt;a href=&quot;https://en.wikipedia.org/wiki/Programmable_interval_timer&quot;&gt;interval timer&lt;/a&gt;
to &lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;wishbone bus&lt;/a&gt;.
Perhaps we want something like,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;initial	r_value = 0;
always @(posedge i_clk)
	if ((i_wb_stb)&amp;amp;&amp;amp;(i_wb_we))
		r_interval_count &amp;lt;= i_wb_data;

always @(posedge i_clk)
	if (r_value != 0)
		r_value &amp;lt;= r_value - 1&#39;b1;
	else
		r_value &amp;lt;= r_interval_count;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This is almost identical to our original counter above, save that every time
it resets it goes back to &lt;code class=&quot;highlighter-rouge&quot;&gt;r_interval_count&lt;/code&gt; instead of the original &lt;code class=&quot;highlighter-rouge&quot;&gt;TIMEOUT&lt;/code&gt;
parameter.  Since &lt;code class=&quot;highlighter-rouge&quot;&gt;r_interval_count&lt;/code&gt; is programmable from the
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;,
we now have a &lt;a href=&quot;https://en.wikipedia.org/wiki/Programmable_interval_timer&quot;&gt;programmable interrupt
timer&lt;/a&gt;.
How hard can this be?&lt;/p&gt;

&lt;p&gt;In this case, the devil is in the details.&lt;/p&gt;

&lt;p&gt;Look closer.  Do you see any of the problems with this implementation?
For example, what happens if you want to switch from a 4-second intervals to
10ms intervals?  Just how many counts will that first 10ms interval contain?
Up to 4 seconds?&lt;/p&gt;

&lt;p&gt;If that’s not the response you want, then how should this timer respond?&lt;/p&gt;

&lt;p&gt;While we consider this, let’s also consider merging the countdown timer
together with the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Programmable_interval_timer&quot;&gt;interval timer&lt;/a&gt;
in a way that both respond to
&lt;a href=&quot;/zipcpu/2017/05/29/simple-wishbone.html&quot;&gt;bus requests&lt;/a&gt;.
Here’s the capability or requirement we’ll build to then:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;On any reset, the counter will set itself to zero and wait to be configured&lt;/p&gt;

    &lt;p&gt;This matches the count-down timer behavior we discussed above.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 4. The ZipTimer Register&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/timer-reg.png&quot; alt=&quot;&quot; width=&quot;557&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;On any write, the counter will assume the value written to it, as shown
in Fig 4 as the &lt;code class=&quot;highlighter-rouge&quot;&gt;New Counter&lt;/code&gt; bits, and will then start counting down.
If the number written was a zero, then the counter will stay at zero and stop.&lt;/p&gt;

    &lt;p&gt;Again, this matches the count-down timer behavior we originally discussed.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;If the high bit is set upon any write, shown as &lt;code class=&quot;highlighter-rouge&quot;&gt;R&lt;/code&gt; in Fig 4 above,
then the timer will enter into interval mode.  In all other cases, the timer
will be started as a one-shot countdown timer.&lt;/p&gt;

    &lt;p&gt;This is our first break from the original countdown timer’s functionality,
allowing us to run in an interval timer mode.&lt;/p&gt;

    &lt;p&gt;Further, if set to interval mode, then the value written to the timer will
become the interval definition.  Hence, when the timer finishes counting
down to zero, we’ll just automatically restart it again with the same
&lt;code class=&quot;highlighter-rouge&quot;&gt;New Counter&lt;/code&gt; value just written to it.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;On writing a zero to the counter, all ongoing counts will be ended and the
counter will return to idle.  Any interval capability will be turned off.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;We’ll also use a &lt;a href=&quot;/blog/2017/08/14/strategies-for-pipelining.html&quot;&gt;global CE
register&lt;/a&gt;,
&lt;code class=&quot;highlighter-rouge&quot;&gt;i_ce&lt;/code&gt;.  This will allow you to count down things other than clock cycles.
Perhaps you can count incoming samples on an interface.  Perhaps you
want to count video frames.  Perhaps you want to count finished instructions.
All of these can be implemented with an appropriate connection to this &lt;code class=&quot;highlighter-rouge&quot;&gt;i_ce&lt;/code&gt;
wire.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Simple enough?  Almost.&lt;/p&gt;

&lt;p&gt;If low logic is a priority, and it has always been a priority for me, then
you’ll also want to be able to configure this peripheral for just the amount
of logic necessary.  We’ll use the parameter &lt;code class=&quot;highlighter-rouge&quot;&gt;VW&lt;/code&gt; to control how many bits
are in our counter.  We’ll also use &lt;code class=&quot;highlighter-rouge&quot;&gt;BW&lt;/code&gt; to be the width of the data
bus–nominally 32 bits.  Finally we’ll use the one bit parameter,
&lt;code class=&quot;highlighter-rouge&quot;&gt;RELOADABLE&lt;/code&gt; to control whether or not this timer offers an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Programmable_interval_timer&quot;&gt;interval timer&lt;/a&gt;
mode or not.  For example, if you know you are only ever going to measure
20ms intervals from a 100MHz clock, then you won’t ever need any
more than &lt;code class=&quot;highlighter-rouge&quot;&gt;VW=21&lt;/code&gt; bits.&lt;/p&gt;

&lt;p&gt;Simple enough now?  I thought so.  Let’s dive into a walk through of the code.&lt;/p&gt;

&lt;h2 id=&quot;the-code&quot;&gt;The Code&lt;/h2&gt;

&lt;p&gt;We’ll walk through the code of the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/ziptimer.v&quot;&gt;ZipTimer&lt;/a&gt;
in two separate sections.  First, we’ll discuss the traditional Verilog code.
Then we’ll move from that to the
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal properties&lt;/a&gt;
section.  Once we’ve finished discussing the
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal properties&lt;/a&gt;
within the code, I show how to connect a peripheral like this to an
&lt;a href=&quot;/zipcpu/2017/10/05/autofpga-intro.html&quot;&gt;AutoFPGA&lt;/a&gt;
based design.&lt;/p&gt;

&lt;p&gt;Normally I skip the front matter of a Verilog file when blogging, so as to
only focus on the relevant portions.  In this case, I’ll show the three
parameters: &lt;code class=&quot;highlighter-rouge&quot;&gt;BW&lt;/code&gt;, containing the size of the bus, &lt;code class=&quot;highlighter-rouge&quot;&gt;VW&lt;/code&gt;, containing the
number of bits in our counter, and &lt;code class=&quot;highlighter-rouge&quot;&gt;RELOADABLE&lt;/code&gt;–set to one if we want
to support an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Programmable_interval_timer&quot;&gt;interval timer&lt;/a&gt;
capability in addition to the one-shot timer capability.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	parameter	BW = 32;
	parameter	VW = (BW-1);
	parameter [0:0]	RELOADABLE=1;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;I’ll also simplify the write command below to a &lt;code class=&quot;highlighter-rouge&quot;&gt;wb_write&lt;/code&gt; flag.  Since you’ll
see this often below, here’s the declaration.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	assign	wb_write = (i_wb_stb)&amp;amp;&amp;amp;(i_wb_we);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;As a result, any time you read &lt;code class=&quot;highlighter-rouge&quot;&gt;wb_write&lt;/code&gt; below you now know that it is
nothing more than a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Predicate_(mathematical_logic)&quot;&gt;predicate&lt;/a&gt;
that will be true any time the
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;
is writing to our only
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/ziptimer.v&quot;&gt;timer&lt;/a&gt;
register.&lt;/p&gt;

&lt;p&gt;We’ll also use a flag &lt;code class=&quot;highlighter-rouge&quot;&gt;r_running&lt;/code&gt; to keep track of whether or not the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/ziptimer.v&quot;&gt;timer&lt;/a&gt;
is &lt;em&gt;running&lt;/em&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	initial	r_running = 1&#39;b0;
	always @(posedge i_clk)
		if (i_reset)
			r_running &amp;lt;= 1&#39;b0;
		else if (wb_write)
			r_running &amp;lt;= (|i_wb_data[(VW-1):0]);
		else if ((r_zero)&amp;amp;&amp;amp;(!auto_reload))
			r_running &amp;lt;= 1&#39;b0;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Basically the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/ziptimer.v&quot;&gt;timer&lt;/a&gt;
is &lt;code class=&quot;highlighter-rouge&quot;&gt;r_running&lt;/code&gt; any time it is non-zero, or any time it is
zero and about to reload for the next interval.  If we wanted to, it would
&lt;a href=&quot;/blog/2018/03/14/is-formal-hard.html&quot;&gt;make sense to scribble in our
notes&lt;/a&gt;
at this point that,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(*)
if ((r_value != 0)||(auto_reload))
	assert(r_running);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The contrary case, where &lt;code class=&quot;highlighter-rouge&quot;&gt;r_running&lt;/code&gt; is not true, will be a little more
difficult to specify so we’ll save it until we have to think our way through it
in the next section.  Either way, when we get to building our
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal properties&lt;/a&gt;
section, we’ll then &lt;a href=&quot;/blog/2018/03/14/is-formal-hard.html&quot;&gt;copy our scribbled notes over
there&lt;/a&gt;
so we can place all of our
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal properties&lt;/a&gt;
in one place.&lt;/p&gt;

&lt;p&gt;Moving on, if you recall from above, we used a &lt;code class=&quot;highlighter-rouge&quot;&gt;RELOADABLE&lt;/code&gt; parameter
option to select whether or not this
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/ziptimer.v&quot;&gt;timer&lt;/a&gt;
included the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Programmable_interval_timer&quot;&gt;interval timer&lt;/a&gt;
ability, or just a one-shot capability.  Hence, if &lt;code class=&quot;highlighter-rouge&quot;&gt;RELOADABLE&lt;/code&gt; is true
then we’ll include this
&lt;a href=&quot;https://en.wikipedia.org/wiki/Programmable_interval_timer&quot;&gt;interval timer&lt;/a&gt;
capability.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	generate
	if (RELOADABLE != 0)
	begin&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The
&lt;a href=&quot;https://en.wikipedia.org/wiki/Programmable_interval_timer&quot;&gt;interval timer&lt;/a&gt;
capability itself centers around two registers.  The
first, &lt;code class=&quot;highlighter-rouge&quot;&gt;r_auto_reload&lt;/code&gt;, is a single bit flag telling us whether or not the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/ziptimer.v&quot;&gt;timer&lt;/a&gt;
needs to be restarted once it hits zero.  The second register will tell us
what our interval is should &lt;code class=&quot;highlighter-rouge&quot;&gt;r_auto_reload&lt;/code&gt; be set–but we’ll get to that
in a moment.&lt;/p&gt;

&lt;p&gt;Initially, I cleared this &lt;code class=&quot;highlighter-rouge&quot;&gt;r_auto_reload&lt;/code&gt; value upon any reset and set it
on any write where the most significant bit is set.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;		initial	r_auto_reload = 1&#39;b0;

		always @(posedge i_clk)
			if (i_reset)
				r_auto_reload &amp;lt;= 1&#39;b0;
			else if (wb_write)
				r_auto_reload &amp;lt;= (i_wb_data[(BW-1)]);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This approach failed when I tried to
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formally verify&lt;/a&gt;
the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/ziptimer.v&quot;&gt;ZipTimer&lt;/a&gt;.
When I dug a bit deeper, I realized that the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/ziptimer.v&quot;&gt;timer&lt;/a&gt;
interval could never be allowed to be zero.  Were it zero, this would
break the &lt;code class=&quot;highlighter-rouge&quot;&gt;r_running&lt;/code&gt; assertion we placed into our notes above.
Hence, I rewrote the &lt;code class=&quot;highlighter-rouge&quot;&gt;r_auto_reload&lt;/code&gt; logic above into,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;		initial	r_auto_reload = 1&#39;b0;

		always @(posedge i_clk)
			if (i_reset)
				r_auto_reload &amp;lt;= 1&#39;b0;
			else if (wb_write)
				r_auto_reload &amp;lt;= (i_wb_data[(BW-1)])
					&amp;amp;&amp;amp;(|i_wb_data[(VW-1):0]);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The big difference is that in order to create an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Programmable_interval_timer&quot;&gt;interval timer&lt;/a&gt;,
you need to not only set the high order bit but you must also provide a
non-zero interval length.&lt;/p&gt;

&lt;p&gt;The second item worth commenting on here is the assign statement.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;		assign	auto_reload = r_auto_reload;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;By assigning to a global &lt;code class=&quot;highlighter-rouge&quot;&gt;wire&lt;/code&gt; value within a &lt;code class=&quot;highlighter-rouge&quot;&gt;generate&lt;/code&gt; block, I
can then use this &lt;code class=&quot;highlighter-rouge&quot;&gt;wire&lt;/code&gt; value throughout the rest of my design without
needing to waste &lt;code class=&quot;highlighter-rouge&quot;&gt;reg&lt;/code&gt;s when &lt;code class=&quot;highlighter-rouge&quot;&gt;RELOADABLE&lt;/code&gt; is false and I don’t need them.
Optimizations within the synthesizer will then remove any extra logic dependent
upon these values.&lt;/p&gt;

&lt;p&gt;The next register associated with the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Programmable_interval_timer&quot;&gt;interval timer&lt;/a&gt;
capability is the &lt;code class=&quot;highlighter-rouge&quot;&gt;r_interval_count&lt;/code&gt; register–containing the the interval
length expressed as value to reset our register to after it reaches zero.
On any write, we’ll set this interval count to the information found on the
data &lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;
in &lt;code class=&quot;highlighter-rouge&quot;&gt;i_wb_data&lt;/code&gt;.  The &lt;code class=&quot;highlighter-rouge&quot;&gt;r_auto_reload&lt;/code&gt; we just dealt with
above will determine whether or not this &lt;code class=&quot;highlighter-rouge&quot;&gt;r_interval_count&lt;/code&gt; is relevant or not.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;		initial	r_interval_count = 0;
		always @(posedge i_clk)
			if (i_reset)
				r_interval_count &amp;lt;= 0;
			else if (wb_write)
				r_interval_count &amp;lt;= i_wb_data[(VW-1):0];
		assign	interval_count = r_interval_count;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Finally, if we are building without the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Programmable_interval_timer&quot;&gt;interval timer&lt;/a&gt;
capability, we’ll set both of these values, &lt;code class=&quot;highlighter-rouge&quot;&gt;auto_reload&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;interval_count&lt;/code&gt;,
to zero.  The synthesizer will then remove any of the relevant
&lt;a href=&quot;https://en.wikipedia.org/wiki/Programmable_interval_timer&quot;&gt;interval timer&lt;/a&gt;
logic below.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	end else begin
		assign	auto_reload = 1&#39;b0;
		assign	interval_count = 0;
	end endgenerate&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Let’s now dig into the core of this count-down timer: the counter’s value,
&lt;code class=&quot;highlighter-rouge&quot;&gt;r_value&lt;/code&gt;.  This follows primarily from the counter we started with, corrected
by our discussion above, but now with the changes necessary to handle both an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Programmable_interval_timer&quot;&gt;interval timer&lt;/a&gt;
capability as well as a &lt;a href=&quot;https://en.wikipedia.org/wiki/Programmable_interval_timer&quot;&gt;one-shot countdown
timer&lt;/a&gt;
capability.&lt;/p&gt;

&lt;p&gt;In both cases, the counter is initialized to zero, cleared on reset, and
set on any
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;
&lt;a href=&quot;/zipcpu/2017/05/29/simple-wishbone.html&quot;&gt;write&lt;/a&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	initial	r_value = 0;
	always @(posedge i_clk)
		if (i_reset)
			r_value &amp;lt;= 0;
		else if (wb_write)
			r_value &amp;lt;= i_wb_data[(VW-1):0];&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Otherwise, we’ll adjust the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/ziptimer.v&quot;&gt;timer&lt;/a&gt;
any time &lt;code class=&quot;highlighter-rouge&quot;&gt;i_ce&lt;/code&gt; is true and the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/ziptimer.v&quot;&gt;timer&lt;/a&gt;
is currently running.  As you may remember from above, the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/ziptimer.v&quot;&gt;timer&lt;/a&gt;
is &lt;code class=&quot;highlighter-rouge&quot;&gt;r_running&lt;/code&gt; any time &lt;code class=&quot;highlighter-rouge&quot;&gt;r_value&lt;/code&gt; it is nonzero, or we are in
&lt;a href=&quot;https://en.wikipedia.org/wiki/Programmable_interval_timer&quot;&gt;interval timer&lt;/a&gt;
mode (&lt;code class=&quot;highlighter-rouge&quot;&gt;r_auto_reload&lt;/code&gt; is true).&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;		else if ((i_ce)&amp;amp;&amp;amp;(r_running))
		begin&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;If the counter is not zero, we’ll count down.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;			if (!r_zero)
				r_value &amp;lt;= r_value - 1&#39;b1;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Once it reaches zero, we’ll restart it if we are in
&lt;a href=&quot;https://en.wikipedia.org/wiki/Programmable_interval_timer&quot;&gt;interval timer&lt;/a&gt;
mode.  In this mode, &lt;code class=&quot;highlighter-rouge&quot;&gt;auto_reload&lt;/code&gt; will be true.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;			else if (auto_reload)
				r_value &amp;lt;= interval_count;
		end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;If &lt;code class=&quot;highlighter-rouge&quot;&gt;auto_reload&lt;/code&gt; is not set then once the counter reaches zero, the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/ziptimer.v&quot;&gt;timer&lt;/a&gt;
will stop.&lt;/p&gt;

&lt;p&gt;The next register in our implementation is &lt;code class=&quot;highlighter-rouge&quot;&gt;r_zero&lt;/code&gt;.  &lt;code class=&quot;highlighter-rouge&quot;&gt;r_zero&lt;/code&gt; is a helper
register.  It needs to
be equivalent to &lt;code class=&quot;highlighter-rouge&quot;&gt;r_value == 0&lt;/code&gt;.  (We’ll prove that these two expressions
evaluate to the same value in a moment.)  By setting &lt;code class=&quot;highlighter-rouge&quot;&gt;r_zero&lt;/code&gt; on the clock
before &lt;code class=&quot;highlighter-rouge&quot;&gt;r_value&lt;/code&gt; reaches zero, we relieve some of the timing stress within
this module.  Hence, instead of an always block that depends upon whether
or not &lt;code class=&quot;highlighter-rouge&quot;&gt;r_value == 0&lt;/code&gt;, such as the original designs we started out with,
they can instead depend upon a single pre-calculated single-bit value &lt;code class=&quot;highlighter-rouge&quot;&gt;r_zero&lt;/code&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	reg	r_zero  = 1&#39;b1;
	always @(posedge i_clk)
		if (i_reset)
			r_zero &amp;lt;= 1&#39;b1;
		else if (wb_write)
			r_zero &amp;lt;= (i_wb_data[(VW-1):0] == 0);
		else if ((r_running)&amp;amp;&amp;amp;(i_ce))
		begin
			if (r_value == { {(VW-1){1&#39;b0}}, 1&#39;b1 })
				r_zero &amp;lt;= 1&#39;b1;
			else if ((r_zero)&amp;amp;&amp;amp;(auto_reload))
				r_zero &amp;lt;= 1&#39;b0;
		end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;a href=&quot;/blog/2018/03/14/is-formal-hard.html&quot;&gt;Were I writing this code from
scratch&lt;/a&gt;, I’d
scribble into the margin that I’ll want to come back and prove the
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal property&lt;/a&gt;
that&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(*) assert(r_zero == (r_value == 0));&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The final required piece of logic is the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interrupt&quot;&gt;interrupt&lt;/a&gt;
register, &lt;code class=&quot;highlighter-rouge&quot;&gt;o_int&lt;/code&gt;.  While we might consider setting the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interrupt&quot;&gt;interrupt&lt;/a&gt;
line to &lt;code class=&quot;highlighter-rouge&quot;&gt;r_zero&lt;/code&gt;, we’d then get lots of
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interrupt&quot;&gt;interrupt&lt;/a&gt;s
every time the counter was idle.  We’d also get lots of
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interrupt&quot;&gt;interrupt&lt;/a&gt;s
between any pair of &lt;code class=&quot;highlighter-rouge&quot;&gt;i_ce&lt;/code&gt; strobes while the counter was waiting to reload.
Hence, we’ll only set the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interrupt&quot;&gt;interrupt&lt;/a&gt;
any time &lt;code class=&quot;highlighter-rouge&quot;&gt;r_value&lt;/code&gt; transitions to zero, or more explicitly any time it is
equal to one and the &lt;code class=&quot;highlighter-rouge&quot;&gt;i_ce&lt;/code&gt; register is high.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	initial	o_int   = 1&#39;b0;
	always @(posedge i_clk)
		if ((i_reset)||(wb_write)||(!i_ce))
			o_int &amp;lt;= 1&#39;b0;
		else // if (i_ce)
			o_int &amp;lt;= (r_value == { {(VW-1){1&#39;b0}}, 1&#39;b1 });&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;As our last step, we’ll set the return data on the
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;
to be the indication of whether we are in
&lt;a href=&quot;https://en.wikipedia.org/wiki/Programmable_interval_timer&quot;&gt;interval timer&lt;/a&gt;
mode (&lt;code class=&quot;highlighter-rouge&quot;&gt;auto_reload&lt;/code&gt; is high), followed by the current
state of the counter.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	assign	o_wb_data = { auto_reload, r_value };&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Other
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;wishbone return&lt;/a&gt;
return values follow from our prior discussion:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	assign	o_wb_stall = 1&#39;b0;
	assign	o_wb_ack = (i_wb_stb);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;That’s all it takes to generate a timer peripheral for a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Soft_microprocessor&quot;&gt;CPU&lt;/a&gt;.  It’s a bit more
than the simple counter we started out with.
In the next section, we’ll discuss how we might go about &lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formally
verifying&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/ziptimer.v&quot;&gt;this timer&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;the-formal-proof&quot;&gt;The formal proof&lt;/h2&gt;

&lt;p&gt;If you are not familiar with using &lt;a href=&quot;http://www.clifford.at/yosys/&quot;&gt;yosys&lt;/a&gt;
for &lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal
verification&lt;/a&gt;,
then I’ll recommend you go back and read about my &lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;first experiences with
formal methods&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;If you just want a quick reminder, there are two basic operators we’ll be using
below.  The &lt;code class=&quot;highlighter-rouge&quot;&gt;assume()&lt;/code&gt; operator restricts the size of the possible state space
that the
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal methods&lt;/a&gt;
will examine.  The &lt;code class=&quot;highlighter-rouge&quot;&gt;assert()&lt;/code&gt; operator defines which states within
this group are illegal.  The formal engine will try all possible logic threads
to find one where the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Predicate_(mathematical_logic)&quot;&gt;predicate&lt;/a&gt;
expression inside the &lt;code class=&quot;highlighter-rouge&quot;&gt;assert()&lt;/code&gt; statement can be made to be false.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 5. The Golden Rule of Formal Verification&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/fv-master-rule.svg&quot; alt=&quot;&quot; width=&quot;360&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;To know which of &lt;code class=&quot;highlighter-rouge&quot;&gt;assume()&lt;/code&gt; or &lt;code class=&quot;highlighter-rouge&quot;&gt;assert()&lt;/code&gt; to use for any particular
property, I follow the rule shown in Fig 5.  Hence, we’ll &lt;code class=&quot;highlighter-rouge&quot;&gt;assume()&lt;/code&gt;
any properties about our inputs, and we’ll &lt;code class=&quot;highlighter-rouge&quot;&gt;assert()&lt;/code&gt; any properties
about our own internal state or any outputs we might produce.&lt;/p&gt;

&lt;p&gt;There is a third operator we’ll be using as well.  This is the &lt;code class=&quot;highlighter-rouge&quot;&gt;$past()&lt;/code&gt;
operator.  As we use it below, this operator returns the value of the
item within it one clock ago.  The problem with the &lt;code class=&quot;highlighter-rouge&quot;&gt;$past&lt;/code&gt; operator is that
it tends to misbehave prior to the beginning of time.  Hence, any time you
see me using this you’ll also see &lt;code class=&quot;highlighter-rouge&quot;&gt;f_past_valid&lt;/code&gt; in the condition list.&lt;/p&gt;

&lt;p&gt;As with most of my
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal property&lt;/a&gt;
sections, they start with the definition of the &lt;code class=&quot;highlighter-rouge&quot;&gt;f_past_valid&lt;/code&gt; variable
I just mentioned.  We discussed this above, and in more detail
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;before&lt;/a&gt;.
Basically, any assertion regarding something one clock in the &lt;code class=&quot;highlighter-rouge&quot;&gt;$past()&lt;/code&gt;,
before any &lt;code class=&quot;highlighter-rouge&quot;&gt;initial&lt;/code&gt; settings, will fail.
By checking for &lt;code class=&quot;highlighter-rouge&quot;&gt;f_past_valid&lt;/code&gt; being true as part of a formal logic
test, I can then use &lt;code class=&quot;highlighter-rouge&quot;&gt;$past()&lt;/code&gt; expressions in any &lt;code class=&quot;highlighter-rouge&quot;&gt;assert()&lt;/code&gt; statements below
without worrying about whether or not the logic being referenced occurred
before time began.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;`ifdef	FORMAL
	reg	f_past_valid;
	initial	f_past_valid = 1&#39;b0;
	always @(posedge i_clk)
		f_past_valid &amp;lt;= 1&#39;b1;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The next order of business is bounding the &lt;code class=&quot;highlighter-rouge&quot;&gt;i_reset&lt;/code&gt; signal.  This signal needs
to be true initially.  We’ll also insist that it’s true any time &lt;code class=&quot;highlighter-rouge&quot;&gt;f_past_valid&lt;/code&gt;
is false.  Aren’t these two the same condition?  Not quite. While they are
very similar, they are separate conditions.  This second
condition specifies that any time the induction engine tries to set
&lt;code class=&quot;highlighter-rouge&quot;&gt;f_past_valid&lt;/code&gt; to false, then the &lt;code class=&quot;highlighter-rouge&quot;&gt;i_reset&lt;/code&gt; line must also be true which will
then force the design into its initial state.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	initial	assume(i_reset);
	always @(*)
		if (!f_past_valid)
			assume(i_reset);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;If we do this properly, we can use &lt;code class=&quot;highlighter-rouge&quot;&gt;f_past_valid&lt;/code&gt; being false as an indication
that our design should be in its reset state.  In a similar fashion, on the
clock following any &lt;code class=&quot;highlighter-rouge&quot;&gt;i_reset&lt;/code&gt;, the design should also be in its reset state.&lt;/p&gt;

&lt;p&gt;We’ll pull any value from above that has an &lt;code class=&quot;highlighter-rouge&quot;&gt;initial&lt;/code&gt; statement or responds
to an &lt;code class=&quot;highlighter-rouge&quot;&gt;i_reset&lt;/code&gt; signal, and insist on either condition that the registers
have the same value.  We’ll also desk check our design to make certain that
registers set via an &lt;code class=&quot;highlighter-rouge&quot;&gt;initial&lt;/code&gt; statement are also responsive to an &lt;code class=&quot;highlighter-rouge&quot;&gt;i_reset&lt;/code&gt;
and vice-versa.  That is, an &lt;code class=&quot;highlighter-rouge&quot;&gt;initial&lt;/code&gt; statement should set the register
to the same value that an &lt;code class=&quot;highlighter-rouge&quot;&gt;i_reset&lt;/code&gt; would set them to.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(posedge i_clk)
	if ((!f_past_valid)||($past(i_reset)))
	begin
		assert(r_value     == 0);
		assert(r_running   == 0);
		assert(auto_reload == 0);
		assert(interval_count== 0);
		assert(r_zero      == 1&#39;b1);
	end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Let’s now move on to some internal consistency checks.  For example, we
stated above that we wanted &lt;code class=&quot;highlighter-rouge&quot;&gt;r_zero&lt;/code&gt; to be equivalent to &lt;code class=&quot;highlighter-rouge&quot;&gt;r_value==0&lt;/code&gt;.
Let’s now assert that this relationship holds.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(*)
		assert(r_zero == (r_value == 0));&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Likewise, anytime our value is non-zero the timer should be running.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(*)
		if (r_value != 0)
			assert(r_running);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;In a similar fashion, any time we are in interval mode we should be running.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(*)
		if (auto_reload)
			assert(r_running);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Perhaps you may recall these from our scribbled notes above as well?&lt;/p&gt;

&lt;p&gt;Further, if our parameter &lt;code class=&quot;highlighter-rouge&quot;&gt;RELOADABLE&lt;/code&gt; is false, then &lt;code class=&quot;highlighter-rouge&quot;&gt;auto_reload&lt;/code&gt; should
also be false.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(*)
		if (!RELOADABLE)
			assert(auto_reload == 0);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Finally, anytime &lt;code class=&quot;highlighter-rouge&quot;&gt;auto_reload&lt;/code&gt; is true, we should have a non-zero interval
time.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(*)
		if (auto_reload)
			assert(interval_count != 0);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Those are the simple properties.  The next several are more complex.&lt;/p&gt;

&lt;p&gt;Our next step will be to work through the properties associated with &lt;code class=&quot;highlighter-rouge&quot;&gt;r_value&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;For the first of these more complex properties, we’ll say that any
time &lt;code class=&quot;highlighter-rouge&quot;&gt;r_value==0&lt;/code&gt;, i.e. any time the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/ziptimer.v&quot;&gt;timer&lt;/a&gt;
has stopped counting down, then it should stay that way.  However, if you try
to express this simply,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(posedge i_clk)
	if ((f_past_valid)&amp;amp;&amp;amp;($past(r_value)==0))
		assert(r_value == 0);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;you might be surprised that your assertion doesn’t hold.  You’ll first find
that following a
&lt;a href=&quot;/zipcpu/2017/05/29/simple-wishbone.html&quot;&gt;wishbone write&lt;/a&gt;,
&lt;code class=&quot;highlighter-rouge&quot;&gt;r_value&lt;/code&gt; might be something other than zero.
You’ll then discover that, by design, following an automatic reload it won’t
be zero either.  Hence, the actual property is a touch more complex.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(posedge i_clk)
	if ((f_past_valid)&amp;amp;&amp;amp;($past(r_value)==0)
			&amp;amp;&amp;amp;(!$past(wb_write))&amp;amp;&amp;amp;(!$past(auto_reload)))
		assert(r_value == 0);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Next, let’s consider the case where &lt;code class=&quot;highlighter-rouge&quot;&gt;r_value&lt;/code&gt; was equal to zero on the last
clock, but isn’t equal to zero any more.  Specifically, we want to test
whether the interval
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/ziptimer.v&quot;&gt;timer&lt;/a&gt;
started over on a reload as desired.&lt;/p&gt;

&lt;p&gt;In this case, the simple property has several exceptions to it.  The counter
won’t move to its reload value following a reset, nor will it necessarily
move to its reload value following a
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;
&lt;a href=&quot;/zipcpu/2017/05/29/simple-wishbone.html&quot;&gt;write&lt;/a&gt;.
Finally, it should only restart if &lt;code class=&quot;highlighter-rouge&quot;&gt;i_ce&lt;/code&gt; is true, and in all other
cases remain where it was.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(posedge i_clk)
	if ((f_past_valid)&amp;amp;&amp;amp;(!$past(i_reset))&amp;amp;&amp;amp;(!$past(wb_write))
			&amp;amp;&amp;amp;($past(r_value)==0)&amp;amp;&amp;amp;($past(auto_reload)))
	begin
		if ($past(i_ce))
			assert(r_value == interval_count);
		else
			assert(r_value == $past(r_value));
	end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Now let’s consider the case where the &lt;code class=&quot;highlighter-rouge&quot;&gt;r_value&lt;/code&gt; is not equal to zero on
the last clock.  While I’d like to write the assertion that,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(posedge i_clk)
	if ((f_past_valid)&amp;amp;&amp;amp;($past(r_value)!=0))
		assert(r_value == $past(r_value)-1&#39;b1);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;the formal engine again corrects me with several traces showing why this
isn’t the case.  The first trace reminds me that, following a reset,
&lt;code class=&quot;highlighter-rouge&quot;&gt;r_value&lt;/code&gt; will be zero.  Once I fix that and try again, the second trace
reminds me that &lt;code class=&quot;highlighter-rouge&quot;&gt;r_value&lt;/code&gt; can be anything
following a
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;
&lt;a href=&quot;/zipcpu/2017/05/29/simple-wishbone.html&quot;&gt;write&lt;/a&gt;.
Rather than running the formal tools again, I go back and desk check this
time to discover that
if &lt;code class=&quot;highlighter-rouge&quot;&gt;i_ce&lt;/code&gt; isn’t true on the last clock then &lt;code class=&quot;highlighter-rouge&quot;&gt;r_value&lt;/code&gt; shouldn’t change.&lt;/p&gt;

&lt;p&gt;This brings us to the following property,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(posedge i_clk)
	if ((f_past_valid)&amp;amp;&amp;amp;(!$past(i_reset))
			&amp;amp;&amp;amp;(!$past(wb_write))&amp;amp;&amp;amp;($past(r_value)!=0))
	begin
		if ($past(i_ce))
			assert(r_value == $past(r_value)-1&#39;b1);
		else
			assert(r_value == $past(r_value));
	end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;How about a
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;
&lt;a href=&quot;/zipcpu/2017/05/29/simple-wishbone.html&quot;&gt;write&lt;/a&gt;?
Following a
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;
&lt;a href=&quot;/zipcpu/2017/05/29/simple-wishbone.html&quot;&gt;write&lt;/a&gt;,
we want our counter to have the data written to it in our value.
The exception is a reset.  If a
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;
&lt;a href=&quot;/zipcpu/2017/05/29/simple-wishbone.html&quot;&gt;write&lt;/a&gt;
and a reset occur on the same clock, we’d rather reset.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(posedge i_clk)
	if ((f_past_valid)&amp;amp;&amp;amp;(!$past(i_reset))&amp;amp;&amp;amp;($past(wb_write)))
		assert(r_value == $past(i_wb_data[(VW-1):0]));&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This also applies to the interval length.  Following a
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;
&lt;a href=&quot;/zipcpu/2017/05/29/simple-wishbone.html&quot;&gt;write&lt;/a&gt;,
if the value is non-zero, and if this module is built with the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Programmable_interval_timer&quot;&gt;interval timer&lt;/a&gt;
capability, then the high bit will determine whether or not we enter into
&lt;a href=&quot;https://en.wikipedia.org/wiki/Programmable_interval_timer&quot;&gt;interval timer&lt;/a&gt;
mode.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(posedge i_clk)
	if ((f_past_valid)&amp;amp;&amp;amp;(!$past(i_reset))&amp;amp;&amp;amp;($past(wb_write))
			&amp;amp;&amp;amp;(RELOADABLE)&amp;amp;&amp;amp;(|$past(i_wb_data[(VW-1):0])))
		assert(auto_reload == $past(i_wb_data[(BW-1)]));&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;We’re almost done.  Before leaving, we need to double check our output
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interrupt&quot;&gt;interrupt&lt;/a&gt;.
This wire, &lt;code class=&quot;highlighter-rouge&quot;&gt;o_int&lt;/code&gt;, should be set any time &lt;code class=&quot;highlighter-rouge&quot;&gt;r_value&lt;/code&gt; transitions from &lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt; to
&lt;code class=&quot;highlighter-rouge&quot;&gt;0&lt;/code&gt;.  Or, at least, that was my original thought.  Then as I worked through
this logic using &lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal
methods&lt;/a&gt;,
I realized there were some exceptions.&lt;/p&gt;

&lt;p&gt;If the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/ziptimer.v&quot;&gt;timer&lt;/a&gt;
is reset in the last cycle, then the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interrupt&quot;&gt;interrupt&lt;/a&gt;
should be inactive.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(posedge i_clk)
	if (!(f_past_valid)||($past(i_reset)))
		assert(!o_int);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Following a
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;
&lt;a href=&quot;/zipcpu/2017/05/29/simple-wishbone.html&quot;&gt;write&lt;/a&gt;, the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interrupt&quot;&gt;interrupt&lt;/a&gt;
wire should be zero as well.  This will allow us to turn the timer &lt;em&gt;off&lt;/em&gt; by
simply writing a zero to it.  Likewise, if
&lt;code class=&quot;highlighter-rouge&quot;&gt;i_ce&lt;/code&gt; wasn’t true on the last clock, then we didn’t just hit zero and the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interrupt&quot;&gt;interrupt&lt;/a&gt;
should be clear again.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	else if (($past(wb_write))||(!$past(i_ce)))
		assert(!o_int);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;So when should the output
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interrupt&quot;&gt;interrupt&lt;/a&gt;
be set?  Any time we transition to zero.
Hence, it should be set following the clock where &lt;code class=&quot;highlighter-rouge&quot;&gt;i_ce&lt;/code&gt; was high and
&lt;code class=&quot;highlighter-rouge&quot;&gt;r_value&lt;/code&gt; was a one.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	else
		assert(o_int == ((r_running)&amp;amp;&amp;amp;(r_value == 0)));&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Our last
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal properties&lt;/a&gt;
are associated with the
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;wishbone bus&lt;/a&gt;.
At first glance, these properties below may just appear like restatements
of the logic above.  In many ways they are.  However, by placing these here
I know I won’t carelessly adjust this interface logic while trying to optimize
things.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(*)
		assert(o_wb_ack == i_wb_stb);

	always @(*)
		assert(!o_wb_stall);
	always @(*)
		assert(o_wb_data[BW-1] == auto_reload);
	always @(*)
		assert(o_wb_data[VW-1:0] == r_value);
`endif
endmodule&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;That’s the last of our formal properties.  Did you notice along the way how
the formal engine helped us find the right properties for our code?  That it
found subtleties like the reset condition that needed to be checked for?
Not only that, did you notice how the formal engine helped us flesh out the
final details in our &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/ziptimer.v&quot;&gt;timer
implementation&lt;/a&gt;?&lt;/p&gt;

&lt;p&gt;These are all reasons why I have now started using
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal methods&lt;/a&gt;
before ever writing a test bench or running a simulation.  Using
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal methods&lt;/a&gt;
helps me discover details I might otherwise not think about.&lt;/p&gt;

&lt;h2 id=&quot;autofpga&quot;&gt;AutoFPGA&lt;/h2&gt;

&lt;p&gt;We have one more task before we are done: connecting &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/ziptimer.v&quot;&gt;this
timer&lt;/a&gt;
to the rest of our design.  If you are using
&lt;a href=&quot;/zipcpu/2017/10/05/autofpga-intro.html&quot;&gt;AutoFPGA&lt;/a&gt;,
that’s just as easy as adding the configuration file for this timer
to the &lt;a href=&quot;/zipcpu/2017/10/05/autofpga-intro.html&quot;&gt;AutoFPGA&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/tinyzip/blob/master/auto-data/Makefile&quot;&gt;command line&lt;/a&gt;.
Alternatively, we could &lt;a href=&quot;/blog/2017/06/22/simple-wb-interconnect.html&quot;&gt;connect this to the bus interconnect by
hand&lt;/a&gt;,
but I think you’ll find it simpler to use
&lt;a href=&quot;/zipcpu/2017/10/05/autofpga-intro.html&quot;&gt;AutoFPGA&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Normally this isn’t necessary with the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
since the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/ziptimer.v&quot;&gt;ZipTimer&lt;/a&gt;
is already connected manually within the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/zipsystem.v&quot;&gt;ZipSystem&lt;/a&gt;
module, shown above in Fig 1.
Two recent &lt;a href=&quot;/zipcpu/2017/10/05/autofpga-intro.html&quot;&gt;AutoFPGA&lt;/a&gt;
based designs, one for the
&lt;a href=&quot;https://github.com/ZipCPU/arrowzip/&quot;&gt;MAX-1000&lt;/a&gt;
and another for the
&lt;a href=&quot;https://github.com/ZipCPU/tinyzip&quot;&gt;TinyFPGA&lt;/a&gt; (neither quite complete),
however, don’t use the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/zipsystem.v&quot;&gt;ZipSystem&lt;/a&gt;
but rather the bare
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/zipbones.v&quot;&gt;ZipBones&lt;/a&gt;
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; wrapper, shown in Fig 6.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 6. The ZipBones&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/zipbones.svg&quot; alt=&quot;&quot; width=&quot;320&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;In each of these designs, you can find a
&lt;a href=&quot;/zipcpu/2017/10/05/autofpga-intro.html&quot;&gt;AutoFPGA&lt;/a&gt;
bustimer configuration within the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/zipbones.v&quot;&gt;ZipBones&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/tinyzip/blob/master/auto-data/zipbones.txt&quot;&gt;configuration&lt;/a&gt;
file, since having the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/ziptimer.v&quot;&gt;timer&lt;/a&gt;
is so useful to the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;–as
it would be to any
&lt;a href=&quot;https://en.wikipedia.org/wiki/Soft_microprocessor&quot;&gt;CPU&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;You may recall from the general format of an
&lt;a href=&quot;/zipcpu/2017/10/05/autofpga-intro.html&quot;&gt;AutoFPGA&lt;/a&gt;
configuration file that the entries consist of &lt;code class=&quot;highlighter-rouge&quot;&gt;@KEY=VALUE&lt;/code&gt; pairs.  They are
primarily used to tell
&lt;a href=&quot;/zipcpu/2017/10/05/autofpga-intro.html&quot;&gt;AutoFPGA&lt;/a&gt;
what text to copy and paste into a set of various project files.
If the &lt;code class=&quot;highlighter-rouge&quot;&gt;VALUE&lt;/code&gt; takes less than a line, the &lt;code class=&quot;highlighter-rouge&quot;&gt;@KEY=VALUE&lt;/code&gt; definition can be
placed on a single line.  Otherwise, all of the lines following &lt;code class=&quot;highlighter-rouge&quot;&gt;@KEY=&lt;/code&gt; will
consist of the &lt;code class=&quot;highlighter-rouge&quot;&gt;VALUE&lt;/code&gt; for that key.  Likewise, if the &lt;code class=&quot;highlighter-rouge&quot;&gt;VALUE&lt;/code&gt; is numeric,
you can have
&lt;a href=&quot;/zipcpu/2017/10/05/autofpga-intro.html&quot;&gt;AutoFPGA&lt;/a&gt;
calculate the value by placing a &lt;code class=&quot;highlighter-rouge&quot;&gt;$&lt;/code&gt; between the &lt;code class=&quot;highlighter-rouge&quot;&gt;@&lt;/code&gt; and the &lt;code class=&quot;highlighter-rouge&quot;&gt;KEY&lt;/code&gt; and so use
the &lt;code class=&quot;highlighter-rouge&quot;&gt;@$KEY=EXPRESSION&lt;/code&gt; form.  Finally, to reference
one value, &lt;code class=&quot;highlighter-rouge&quot;&gt;@KEYONE=VALONE&lt;/code&gt;, from within another, you would reference
it as &lt;code class=&quot;highlighter-rouge&quot;&gt;@$(KEYONE)&lt;/code&gt; within the value portion of the second
&lt;code class=&quot;highlighter-rouge&quot;&gt;@KEYTWO=VALTWO&lt;/code&gt; construct.&lt;/p&gt;

&lt;p&gt;Perhaps this would make more sense if we walked through an example.&lt;/p&gt;

&lt;p&gt;Every &lt;a href=&quot;/zipcpu/2017/10/05/autofpga-intro.html&quot;&gt;AutoFPGA&lt;/a&gt;
component description begins with a &lt;code class=&quot;highlighter-rouge&quot;&gt;@PREFIX&lt;/code&gt; tag.  This defines the beginning
of the component, as well as providing a name for the component.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;@PREFIX=bustimer&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;I chose to call this device a &lt;code class=&quot;highlighter-rouge&quot;&gt;bustimer&lt;/code&gt;.  Unlike other timers that might be
internal to other portions of the design, this one can be accessed from the
main &lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;wishbone bus&lt;/a&gt;–hence
the name.&lt;/p&gt;

&lt;p&gt;If you are following along from the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/zipbones.v&quot;&gt;ZipBones&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/tinyzip/blob/master/auto-data/zipbones.txt&quot;&gt;configuration&lt;/a&gt;
file, you can skip to the &lt;code class=&quot;highlighter-rouge&quot;&gt;@PREFIX=bustimer&lt;/code&gt; line.  The information prior
defines how to connect the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/zipbones.v&quot;&gt;ZipBones&lt;/a&gt;
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
wrapper to the bus.  A watchdog timer definition follows this one, all within
the same
&lt;a href=&quot;https://github.com/ZipCPU/tinyzip/blob/master/auto-data/zipbones.txt&quot;&gt;configuration&lt;/a&gt;
file.&lt;/p&gt;

&lt;p&gt;While &lt;a href=&quot;/zipcpu/2017/10/05/autofpga-intro.html&quot;&gt;AutoFPGA&lt;/a&gt;
doesn’t require it, I often define a &lt;code class=&quot;highlighter-rouge&quot;&gt;@DEVID&lt;/code&gt; tag.  I
primarily use this tag for contexts that don’t like lower case.
&lt;a href=&quot;/zipcpu/2017/10/05/autofpga-intro.html&quot;&gt;AutoFPGA&lt;/a&gt;
doesn’t do anything fancy with this tag, other then paste it into other
tags as I tell it to below.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;@DEVID=BUSTIMER&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The &lt;a href=&quot;https://github.com/ZipCPU/tinyzip/blob/master/rtl/main.v&quot;&gt;main.v&lt;/a&gt;
file of an
&lt;a href=&quot;/zipcpu/2017/10/05/autofpga-intro.html&quot;&gt;AutoFPGA&lt;/a&gt;
based project starts with a series of
&lt;code class=&quot;highlighter-rouge&quot;&gt;ifdef&lt;/code&gt;’s just before the &lt;code class=&quot;highlighter-rouge&quot;&gt;module&lt;/code&gt; declaration.  This allows a user to select
some items and not others, as well as capturing a set of dependencies of what
items depend upon others.  In this case, we have no dependencies, but we’ll
still create an &lt;code class=&quot;highlighter-rouge&quot;&gt;define&lt;/code&gt; line in case something else depends upon this
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_(computing)&quot;&gt;bus&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/ziptimer.v&quot;&gt;timer&lt;/a&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;@ACCESS=@$(DEVID)_ACCESS&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Now let’s connect our timer to a
&lt;a href=&quot;/zipcpu/2017/05/29/simple-wishbone.html&quot;&gt;wishbone bus&lt;/a&gt;.
Specifically, we want to connect this component to the system
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_(computing)&quot;&gt;bus&lt;/a&gt;,
by default named &lt;code class=&quot;highlighter-rouge&quot;&gt;wb&lt;/code&gt;.
We’ll also declare that this
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_(computing)&quot;&gt;bus&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/ziptimer.v&quot;&gt;timer&lt;/a&gt;
is a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_(computing)&quot;&gt;bus&lt;/a&gt;
slave whose result is always available and that never stalls,
&lt;code class=&quot;highlighter-rouge&quot;&gt;@SLAVE.TYPE=SINGLE&lt;/code&gt;, and one that has only a single address, &lt;code class=&quot;highlighter-rouge&quot;&gt;@NADDR=1&lt;/code&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;@SLAVE.BUS=wb
@SLAVE.TYPE=SINGLE
@NADDR=1&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Actually connecting this to a
&lt;a href=&quot;/zipcpu/2017/05/29/simple-wishbone.html&quot;&gt;bus&lt;/a&gt;
depends upon the code we want to place into our
&lt;a href=&quot;https://github.com/ZipCPU/tinyzip/blob/master/rtl/main.v&quot;&gt;main.v&lt;/a&gt;
file.  This is the purpose of the &lt;code class=&quot;highlighter-rouge&quot;&gt;@MAIN.INSERT&lt;/code&gt; tag.  Code within
this tag will get copied directly (after variable name substitution) into the
&lt;a href=&quot;https://github.com/ZipCPU/tinyzip/blob/master/rtl/main.v&quot;&gt;main.v&lt;/a&gt;
file.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;@MAIN.INSERT=
	ziptimer @$(PREFIX)i(i_clk, i_reset, 1&#39;b1,
			wb_cyc, (wb_stb)&amp;amp;&amp;amp;(@$(PREFIX)_sel), wb_we, wb_data,
				@$(PREFIX)_ack, @$(PREFIX)_stall,
				@$(PREFIX)_data, @$(PREFIX)_int);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;While you don’t need to reference the &lt;code class=&quot;highlighter-rouge&quot;&gt;@$(PREFIX)&lt;/code&gt; tag at all, I often use this
to help keep the names unique within any given design.  Once the pattern
matching takes place, these lines will just turn into:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;@MAIN.INSERT=
	ziptimer bustimeri(i_clk, i_reset, 1&#39;b1,
			wb_cyc, (wb_stb)&amp;amp;&amp;amp;(bustimer_sel), wb_we, wb_data,
				bustimer_ack, bustimer_stall,
				bustimer_data, bustimer_int);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;You don’t need to define the &lt;code class=&quot;highlighter-rouge&quot;&gt;bustimer_ack&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;bustimer_stall&lt;/code&gt;, or
&lt;code class=&quot;highlighter-rouge&quot;&gt;bustimer_data&lt;/code&gt; wires.&lt;br /&gt;
&lt;a href=&quot;/zipcpu/2017/10/05/autofpga-intro.html&quot;&gt;AutoFPGA&lt;/a&gt;
will define these for you once you tell it that this item is a
&lt;a href=&quot;/zipcpu/2017/05/29/simple-wishbone.html&quot;&gt;bus&lt;/a&gt; slave.
&lt;a href=&quot;/zipcpu/2017/10/05/autofpga-intro.html&quot;&gt;AutoFPGA&lt;/a&gt;
will also create a &lt;code class=&quot;highlighter-rouge&quot;&gt;bustimer_sel&lt;/code&gt; wire.  This wire will be true any time this
&lt;a href=&quot;/zipcpu/2017/05/29/simple-wishbone.html&quot;&gt;bus&lt;/a&gt;
component’s address is selected.  You do need to connect these wires to your
component, as we’ve done above.&lt;/p&gt;

&lt;p&gt;After running
&lt;a href=&quot;/zipcpu/2017/10/05/autofpga-intro.html&quot;&gt;AutoFPGA&lt;/a&gt;,
you should then be able to find this code snipped in the
&lt;a href=&quot;https://github.com/ZipCPU/tinyzip/blob/master/rtl/main.v&quot;&gt;main.v&lt;/a&gt;,
file.
&lt;a href=&quot;/zipcpu/2017/10/05/autofpga-intro.html&quot;&gt;AutoFPGA&lt;/a&gt;
will also declare the rest of the wires necessary to set this up as well.&lt;/p&gt;

&lt;p&gt;The last wire, &lt;code class=&quot;highlighter-rouge&quot;&gt;bustimer_int&lt;/code&gt;, is also defined automatically by
&lt;a href=&quot;/zipcpu/2017/10/05/autofpga-intro.html&quot;&gt;AutoFPGA&lt;/a&gt; as
part of generating and connecting up the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interrupt&quot;&gt;interrupt&lt;/a&gt;
wires.  In our case, we have a &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/icontrol.v&quot;&gt;programmable interrupt controller
(PIC)&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/tinyzip/blob/master/auto-data/pic.txt&quot;&gt;defined elsewhere in the
design&lt;/a&gt;
with the name of &lt;code class=&quot;highlighter-rouge&quot;&gt;buspic&lt;/code&gt;.  Hence, all we need to tell
&lt;a href=&quot;/zipcpu/2017/10/05/autofpga-intro.html&quot;&gt;AutoFPGA&lt;/a&gt;
is that we have an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interrupt&quot;&gt;interrupt&lt;/a&gt;
named &lt;code class=&quot;highlighter-rouge&quot;&gt;BUSTIMER&lt;/code&gt;, whose
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interrupt&quot;&gt;interrupt&lt;/a&gt;
wire is &lt;code class=&quot;highlighter-rouge&quot;&gt;bustimer_int&lt;/code&gt;, that needs to be connected to the
&lt;code class=&quot;highlighter-rouge&quot;&gt;buspic&lt;/code&gt;s inputs.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;@INT.BUSTIMER.WIRE= @$(PREFIX)_int
@INT.BUSTIMER.PIC= buspic&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This will add our &lt;code class=&quot;highlighter-rouge&quot;&gt;bustimer_int&lt;/code&gt; to the list of components within the
&lt;code class=&quot;highlighter-rouge&quot;&gt;bus_int_vector&lt;/code&gt;.  Hence, if you check the
&lt;a href=&quot;https://github.com/ZipCPU/tinyzip/blob/master/rtl/main.v&quot;&gt;main.v&lt;/a&gt;
file, you’ll see the &lt;code class=&quot;highlighter-rouge&quot;&gt;bustimer_int&lt;/code&gt; listed long with the other
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interrupt&quot;&gt;interrupt&lt;/a&gt;
lines.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;assign	bus_int_vector = {
	// ...
	bustimer_int,
	// ...
};&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Internal to the
&lt;a href=&quot;https://github.com/ZipCPU/tinyzip/blob/master/sw/zlib/board.h&quot;&gt;board.h&lt;/a&gt;
file that
&lt;a href=&quot;/zipcpu/2017/10/05/autofpga-intro.html&quot;&gt;AutoFPGA&lt;/a&gt;
creates for the internal processor that might use this design, this will
also create a line,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;cp&quot;&gt;#define	BUSPIC_BUSTIMER	BUSPIC(1)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;after assigning this peripheral to
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interrupt&quot;&gt;interrupt&lt;/a&gt;
control wire number one.&lt;/p&gt;

&lt;p&gt;The last two parts deal with non-Verilog parts of the design.  The first of
these deals with &lt;a href=&quot;/blog/2017/06/29/sw-dbg-interface.html&quot;&gt;connecting this device to the external debugging
interface&lt;/a&gt;.
Specifically, we’ll want to create a register, &lt;code class=&quot;highlighter-rouge&quot;&gt;R_BUSTIMER&lt;/code&gt;, with the human
name, &lt;code class=&quot;highlighter-rouge&quot;&gt;BUSTIMER&lt;/code&gt;.  These next three lines adjust the files
&lt;a href=&quot;https://github.com/ZipCPU/tinyzip/blob/master/sw/host/regdefs.h&quot;&gt;regdefs.h&lt;/a&gt;
and &lt;a href=&quot;https://github.com/ZipCPU/tinyzip/blob/master/sw/host/regdefs.cpp&quot;&gt;regdefs.cpp&lt;/a&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;@REGS.NOTE= // The bus timer
@REGS.N=1
@REGS.0= 0 R_@$(DEVID) @$(DEVID)&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;First, upon reading these lines,
&lt;a href=&quot;/zipcpu/2017/10/05/autofpga-intro.html&quot;&gt;AutoFPGA&lt;/a&gt;
will place a definition into the 
&lt;a href=&quot;https://github.com/ZipCPU/tinyzip/blob/master/sw/host/regdefs.h&quot;&gt;regdefs.h&lt;/a&gt;
output file, defining an
&lt;code class=&quot;highlighter-rouge&quot;&gt;R_BUSTIMER&lt;/code&gt; identifier to be equivalent to the address of this
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/ziptimer.v&quot;&gt;timer&lt;/a&gt;
register.  This will tell external host components where in the memory
space to access this register when using &lt;code class=&quot;highlighter-rouge&quot;&gt;readio()&lt;/code&gt; or &lt;code class=&quot;highlighter-rouge&quot;&gt;writeio()&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/zipcpu/2017/10/05/autofpga-intro.html&quot;&gt;AutoFPGA&lt;/a&gt;
will also place references to this register into
&lt;a href=&quot;https://github.com/ZipCPU/tinyzip/blob/master/sw/host/regdefs.cpp&quot;&gt;regdefs.cpp&lt;/a&gt;.
&lt;a href=&quot;https://github.com/ZipCPU/tinyzip/blob/master/sw/host/regdefs.cpp&quot;&gt;This file&lt;/a&gt;
contains a mapping between the computer regiser name &lt;code class=&quot;highlighter-rouge&quot;&gt;R_BUSTIMER&lt;/code&gt;
and the user name for this register, &lt;code class=&quot;highlighter-rouge&quot;&gt;BUSTIMER&lt;/code&gt;.  As a result, you can then
use the &lt;code class=&quot;highlighter-rouge&quot;&gt;wbregs&lt;/code&gt; program, a variant of the old fashioned
&lt;a href=&quot;https://en.wikipedia.org/wiki/PEEK_and_POKE&quot;&gt;peek and poke hardware interface&lt;/a&gt;,
to read from the
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/ziptimer.v&quot;&gt;timer&lt;/a&gt;
with the command &lt;code class=&quot;highlighter-rouge&quot;&gt;wbregs bustimer&lt;/code&gt;, or to write to it via
&lt;a href=&quot;/blog/2017/06/29/sw-dbg-interface.html&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;wbregs bustimer newvalue&lt;/code&gt;&lt;/a&gt;.
(I have another version of this program called &lt;code class=&quot;highlighter-rouge&quot;&gt;avregs&lt;/code&gt; for use with the
&lt;a href=&quot;https://www.altera.com/literature/manual/mnl_avalon_spec.pdf&quot;&gt;Avalon bus&lt;/a&gt;
on a
&lt;a href=&quot;/blog/2018/02/09/first-cyclonev.html&quot;&gt;Cyclone-V&lt;/a&gt;
 …)&lt;/p&gt;

&lt;p&gt;The last item places a reference to this
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/ziptimer.v&quot;&gt;timer&lt;/a&gt;
into the
&lt;a href=&quot;https://github.com/ZipCPU/tinyzip/blob/master/sw/zlib/board.h&quot;&gt;board.h&lt;/a&gt;
file.  This file would be used by the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
to know if the
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/ziptimer.v&quot;&gt;timer&lt;/a&gt;
was built into the design and, if so, what address that
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/ziptimer.v&quot;&gt;timer&lt;/a&gt;
was placed into.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;@BDEF.IONAME=_bustimer
@BDEF.IOTYPE=unsigned
@BDEF.OSDEF=_BOARD_HAS_@$(DEVID)
@BDEF.OSVAL=static volatile @$BDEF.IOTYPE *const @$(BDEF.IONAME) = ((@$BDEF.IOTYPE *)@$[0x%08x](REGBASE));&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;a href=&quot;/zipcpu/2017/10/05/autofpga-intro.html&quot;&gt;AutoFPGA&lt;/a&gt;
will use this to create a line, similar to the following one, inside the
&lt;a href=&quot;https://github.com/ZipCPU/tinyzip/blob/master/sw/zlib/board.h&quot;&gt;board.h&lt;/a&gt;
file:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;cp&quot;&gt;#ifdef	BUSTIMER_ACCESS
#define	_BOARD_HAS_BUSTIMER
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;volatile&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_bustimer&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;mh&quot;&gt;0x00100000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;cp&quot;&gt;#endif	// BUSTIMER_ACCESS&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Remember, the goal of
&lt;a href=&quot;/zipcpu/2017/10/05/autofpga-intro.html&quot;&gt;AutoFPGA&lt;/a&gt;
is to make the inclusion of
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_(computing)&quot;&gt;bus&lt;/a&gt;
components into a design easier.  Hence, by placing these few lines into an
&lt;a href=&quot;/zipcpu/2017/10/05/autofpga-intro.html&quot;&gt;AutoFPGA&lt;/a&gt;
configuration file, this
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_(computing)&quot;&gt;bus&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/ziptimer.v&quot;&gt;timer&lt;/a&gt;
will be included into the design.  Removing these lines from the
&lt;a href=&quot;/zipcpu/2017/10/05/autofpga-intro.html&quot;&gt;AutoFPGA&lt;/a&gt;
configuration will seemlessly remove this
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_(computing)&quot;&gt;bus&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/ziptimer.v&quot;&gt;timer&lt;/a&gt;
from the design.&lt;/p&gt;

&lt;h2 id=&quot;conclusions&quot;&gt;Conclusions&lt;/h2&gt;

&lt;p&gt;We’ve now gone over everything it takes to create a useful countdown timer
within an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
design–whether a “one-shot” timer, or a fully programmable
interval timer.  Once put together, the final &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/ziptimer.v&quot;&gt;Verilog
code&lt;/a&gt;
isn’t all that much more difficult than
the original counter we started out from.  What may surprise you, though,
is how much work we went through to place such a &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/ziptimer.v&quot;&gt;simple
counter&lt;/a&gt;
into a design.  Not only did we
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formally&lt;/a&gt;
verify our
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/ziptimer.v&quot;&gt;timer&lt;/a&gt;,
but then we also had to connect it to the
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;wishbone bus&lt;/a&gt;
within the design.  We also dealt with several subtle issues associated with
making a
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/ziptimer.v&quot;&gt;timer&lt;/a&gt;
useful along the way.&lt;/p&gt;

&lt;p&gt;What can you use such a
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/ziptimer.v&quot;&gt;timer&lt;/a&gt;
for?&lt;/p&gt;

&lt;p&gt;We’ve already discussed how this can be the centerpiece of the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Computer_multitasking&quot;&gt;multitasking&lt;/a&gt;
implementation within an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Operating_System&quot;&gt;Operating System&lt;/a&gt;.
Upon any
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/ziptimer.v&quot;&gt;timer&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interrupt&quot;&gt;interrupt&lt;/a&gt;, the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Operating_System&quot;&gt;Operating System&lt;/a&gt;
can then swap user tasks or processes. 
&lt;a href=&quot;https://www.blueletterbible.org/kjv/jas/4/15&quot;&gt;Should the Lord will&lt;/a&gt;, I’ll
come back and share how one
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/s6soc&quot;&gt;implementation&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/s6soc/blob/master/sw/zipos/kernel.c&quot;&gt;uses this&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interrupt&quot;&gt;interrupt&lt;/a&gt;
for exactly that purpose.&lt;/p&gt;

&lt;p&gt;There’s another valuable use of a
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/ziptimer.v&quot;&gt;timer&lt;/a&gt;
such as this–one which may not be
as obvious.  In the presentation above, we discussed wiring the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interrupt&quot;&gt;interrupt&lt;/a&gt;
wire to the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Soft_microprocessor&quot;&gt;CPU&lt;/a&gt;’s
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/icontrol.v&quot;&gt;interrupt controller&lt;/a&gt;.  If you instead connected the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interrupt&quot;&gt;interrupt&lt;/a&gt;
output to the reset wire for the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Soft_microprocessor&quot;&gt;CPU&lt;/a&gt;,
you would have created a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Watchdog_timer&quot;&gt;watchdog&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/ziptimer.v&quot;&gt;timer&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;So you see, a basic counter isn’t nearly as irrelevant as you might have
thought it would be, neither is it as simple.  It’s also provides a very
good example of the full
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
&lt;a href=&quot;/blog/2017/06/02/design-process.html&quot;&gt;design process&lt;/a&gt;.&lt;/p&gt;
&lt;hr /&gt;&lt;p&gt;&lt;em&gt;And He said unto them, It is not for you to know the times or the seasons, which the Father hath put in His own power. (Acts 1:7)&lt;/em&gt;</description>
        <pubDate>Tue, 17 Apr 2018 00:00:00 -0400</pubDate>
        <link>http://zipcpu.com/zipcpu/2018/04/17/ziptimer.html</link>
        <guid isPermaLink="true">http://zipcpu.com/zipcpu/2018/04/17/ziptimer.html</guid>
        
        
        <category>zipcpu</category>
        
      </item>
    
      <item>
        <title>Formally Verifying an Asynchronous Reset</title>
        <description>&lt;p&gt;&lt;a href=&quot;/blog/2017/10/20/cdc.html&quot;&gt;Clock Domain Crossings&lt;/a&gt;
can be difficult to get right.  This applies not only
to crossing data and logic from one clock domain to another, but also to
crossing resets from one clock domain to another.  The general rule is that all
logic &lt;a href=&quot;https://en.wikipedia.org/wiki/Flip-flop_(electronics)#Timing_considerations&quot;&gt;must have a guaranteed settling time before the next rising edge of
the next clock&lt;/a&gt;.
If this rule is violated then logic may enter a state that
is neither &lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt; nor &lt;code class=&quot;highlighter-rouge&quot;&gt;0&lt;/code&gt;, neither true nor false.&lt;/p&gt;

&lt;p&gt;This is
&lt;a href=&quot;https://en.wikipedia.org/wiki/Metastability_in_electronics&quot;&gt;metastability&lt;/a&gt;.
Avoid it at all costs.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 1. Synchronizing an Asynchronous Reset&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/areset-regions.svg&quot; width=&quot;360&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;In the case of an asynchronous reset, it usually doesn’t matter all that much
during which clock interval the design enters into the reset state.  As long
as the reset remains active long enough to fully propagate through the design,
everything will eventually enter into this state.  What matters is whether or
not the whole design leaves the reset state at the same time: on a clock edge.&lt;/p&gt;

&lt;p&gt;Fig 1. shows an example of such an asynchronous reset.  The negative logic
reset comes into the design with no guarantee of being synchronous with
the clock.
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flip-flop_(electronics)&quot;&gt;Flip-flops&lt;/a&gt;
dependent upon that reset may then enter into a metastable state, shown by
the pink background in the figure.  Logic within the design needs to
recognize this reset, and synchronize its release.  This is shown by the
green region, where the adjusted reset clears and returns to zero at
the sime time as the rising edge of the system clock.&lt;/p&gt;

&lt;p&gt;You may also notice from Fig 1 that the incoming asynchronous reset
signal is based upon negative logic.  In other words, to activate the reset
the logic needs to be pulled low.  This is a common practice in
&lt;a href=&quot;/blog/2017/10/13/fpga-v-asic.html&quot;&gt;ASIC designs&lt;/a&gt;,
since it allows a design to start entering into its reset state before
sufficient power is available to assert a positive going reset across the
entire design–although this isn’t usually required with FPGA designs.&lt;/p&gt;

&lt;p&gt;Since the logic necessary to do this is pretty simple, let’s take a look at it
in the next section.&lt;/p&gt;

&lt;h2 id=&quot;verilog&quot;&gt;Verilog&lt;/h2&gt;

&lt;p&gt;For our &lt;a href=&quot;/examples/areset.v&quot;&gt;simple Verilog example&lt;/a&gt;,
let’s create a synchronous positive logic
reset signal from a negative logic asynchronous reset.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: left&quot;&gt;&lt;caption&gt;Fig 2. Three Flip-flop Asynchronous Reset Synchronizer&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/areset-fifos.svg&quot; width=&quot;360&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;The &lt;a href=&quot;/examples/areset.v&quot;&gt;basic code&lt;/a&gt;
just sets the outgoing reset and the three
&lt;a href=&quot;/blog/2017/10/20/cdc.html&quot;&gt;flip-flop synchronizers&lt;/a&gt;
to &lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt; anytime the asynchronous reset is true, and then waits for three clock
edges to release.  You can see this basic logic pictorially in Fig 2 on the
left.&lt;/p&gt;

&lt;p&gt;Since &lt;a href=&quot;/examples/areset.v&quot;&gt;the code&lt;/a&gt;
itself is so short, I’ll spend a moment touching on some
details I usually avoid along the way.  For example, I (now) always start
any Verilog design by setting the &lt;code class=&quot;highlighter-rouge&quot;&gt;default_nettype&lt;/code&gt; to
&lt;code class=&quot;highlighter-rouge&quot;&gt;none&lt;/code&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;`default_nettype	none&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This one statement is really a blessing when it comes to finding
errors within your code.  Verilog specifies that the default synthesizer
behavior upon finding any undeclared identifier
is to assume that the identifier was supposed to reference a &lt;code class=&quot;highlighter-rouge&quot;&gt;wire&lt;/code&gt;, and so
the synthesizer will then quietly declare a &lt;code class=&quot;highlighter-rouge&quot;&gt;wire&lt;/code&gt; for you when you would have
rather had the synthesizer report an error due to your misspelling.  By
telling the synthesis tool not to do this, it becomes much easier to catch
errors you might have in your code.&lt;/p&gt;

&lt;p&gt;Our module will accept two inputs, and produce one output.  The two inputs will
be the clock, &lt;code class=&quot;highlighter-rouge&quot;&gt;i_clk&lt;/code&gt; and the negative going asynchronous reset, &lt;code class=&quot;highlighter-rouge&quot;&gt;i_areset_n&lt;/code&gt;.
The underscores here have specific meanings.  &lt;code class=&quot;highlighter-rouge&quot;&gt;i_&lt;/code&gt; references an input,
&lt;code class=&quot;highlighter-rouge&quot;&gt;o_&lt;/code&gt; in a moment will reference an output, and in the case of this reset the
&lt;code class=&quot;highlighter-rouge&quot;&gt;_n&lt;/code&gt; suffix references negative logic.  The last item in our portlist is
our synchronized output signal, &lt;code class=&quot;highlighter-rouge&quot;&gt;o_reset&lt;/code&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;module areset(i_clk, i_areset_n, o_reset);
	input	wire	i_clk, i_areset_n;
	output	reg	o_reset;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;To handle the synchronization, we’ll use a &lt;a href=&quot;/blog/2017/10/20/cdc.html&quot;&gt;three clock
synchronizer&lt;/a&gt;.  This requires
two internal state bits that we’ll call &lt;code class=&quot;highlighter-rouge&quot;&gt;sync_fifo&lt;/code&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	reg	[1:0]	sync_fifo;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;We’ll also assume the design begins in a reset state, and so initialize our
&lt;a href=&quot;/blog/2017/10/20/cdc.html&quot;&gt;synchronization FIFO&lt;/a&gt;
and our output to start in a reset condition.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	initial	sync_fifo = 2&#39;h3;
	initial	o_reset = 1&#39;b1;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Enough of the preliminaries.  What does it take to synchronize a reset?
Just the following four lines of code.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(posedge i_clk or negedge i_areset_n)
	if (!i_areset_n)
		{ o_reset, sync_fifo } &amp;lt;= 3&#39;h7;
	else
		{ o_reset, sync_fifo } &amp;lt;= { sync_fifo, 1&#39;b0 };&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;So how does this work?  As shown in Fig 1 above, anytime &lt;code class=&quot;highlighter-rouge&quot;&gt;i_areset_n&lt;/code&gt; goes low
(active), then we set the synchonizer and the output reset registers to all
ones.  Otherwise, if &lt;code class=&quot;highlighter-rouge&quot;&gt;i_areset_n&lt;/code&gt; is high (inactive), then on the positive
edge of the clock we’ll shift a zero into and through the the &lt;code class=&quot;highlighter-rouge&quot;&gt;sync_fifo&lt;/code&gt;
shift register until it clears the &lt;code class=&quot;highlighter-rouge&quot;&gt;o_reset&lt;/code&gt; output.&lt;/p&gt;

&lt;p&gt;That’s it.  There’s really not that much more to it.&lt;/p&gt;

&lt;p&gt;That is, there’s nothing more involved unless you want to
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formally verify&lt;/a&gt;
that this operation works as advertised.  Hence, let’s look at
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formally verifying&lt;/a&gt;
this reset logic in the next section.&lt;/p&gt;

&lt;h2 id=&quot;formal-properties&quot;&gt;Formal Properties&lt;/h2&gt;

&lt;p&gt;When it comes to
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal properties&lt;/a&gt;,
I’ve &lt;a href=&quot;/zipcpu/2018/03/21/dblfetch.html&quot;&gt;recently started including
“contracts”&lt;/a&gt; into the
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal properties&lt;/a&gt;
I write.  I’ve found it valuable to clearly indicate what the minimum
you want something to do is.  Let’s do that here.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;`ifdef	FORMAL
	////////////////////////////////////////////////////
	//
	// Our &quot;contract&quot;
	//
	////////////////////////////////////////////////////
	//&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;In this case, I can think of four basic properties that are relevant.&lt;/p&gt;

&lt;p&gt;The first is our one assumption that we always start in a reset state.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	initial	assume(!i_areset_n);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Our next property is that any time &lt;code class=&quot;highlighter-rouge&quot;&gt;i_areset_n&lt;/code&gt; is low (active) our outgoing
reset value &lt;code class=&quot;highlighter-rouge&quot;&gt;o_reset&lt;/code&gt; must be high (active).&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(*)
	if (!i_areset_n)
		assert(o_reset);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;At this point I can hear someone asking, doesn’t that make this an
asynchronous reset as well?&lt;/p&gt;

&lt;p&gt;Yes, technically it does.  However, &lt;code class=&quot;highlighter-rouge&quot;&gt;o_reset&lt;/code&gt; is guaranteed to also be high
for at least one clock before it is released, so we can (usually) just treat
it as a regular synchronous logic reset as well.  There is a risk
that this reset will send some
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flip-flop_(electronics)&quot;&gt;flip-flops&lt;/a&gt;
into a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Metastability_in_electronics&quot;&gt;metastable&lt;/a&gt; state
for one clock cycle.
While this is a possibility when using &lt;code class=&quot;highlighter-rouge&quot;&gt;o_reset&lt;/code&gt;, those
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flip-flop_(electronics)&quot;&gt;flip-flops&lt;/a&gt;
will be reset in the next clock interval.  If this is not acceptable
for your logic, then just treat &lt;code class=&quot;highlighter-rouge&quot;&gt;o_reset&lt;/code&gt; as an asynchronous reset.&lt;/p&gt;

&lt;p&gt;The third part of our contract is that we only ever leave the reset state
on the positive edge of any clock.  This property is a little less intuitive
to express as an &lt;code class=&quot;highlighter-rouge&quot;&gt;assert&lt;/code&gt;ion.  Specifically, we want to assert that any
time &lt;code class=&quot;highlighter-rouge&quot;&gt;o_reset&lt;/code&gt; transitions from &lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt; to &lt;code class=&quot;highlighter-rouge&quot;&gt;0&lt;/code&gt;, i.e. any time it &lt;em&gt;falls&lt;/em&gt;,
that the clock is also transitioning from &lt;code class=&quot;highlighter-rouge&quot;&gt;0&lt;/code&gt; to &lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt; (&lt;em&gt;rising&lt;/em&gt;).&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @($global_clock)
	if ($fell(o_reset))
		assert($rose(i_clk));&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;As one last part of our
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal proof&lt;/a&gt;,
let’s &lt;code class=&quot;highlighter-rouge&quot;&gt;cover()&lt;/code&gt; the release from reset to make certain this design will
release from reset like we expect it to.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(*)
		cover(!o_reset);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;At this point, if we only wanted to pass a bounded model check we’d be done.
If you instead want to &lt;em&gt;prove&lt;/em&gt; that this asynchronous reset works, then you’ll
&lt;a href=&quot;/blog/2018/03/10/induction-exercise.html&quot;&gt;need to create some more
formal properties&lt;/a&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	////////////////////////////////////////////////////
	//
	// Extras for passing induction
	//
	////////////////////////////////////////////////////&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;These extra properties are primarily used to make certain that the &lt;a href=&quot;/blog/2018/03/10/induction-exercise.html&quot;&gt;induction
engine doesn’t find the design in an unreachable
state&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;For the first of these properties, we’ll assert that any time the design
is not in a reset condition, then the &lt;code class=&quot;highlighter-rouge&quot;&gt;sync_fifo&lt;/code&gt; shift register bits should
be zero as well.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(*)
	if (!o_reset)
		assert(sync_fifo == 2&#39;b00);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;In a similar fashion, the &lt;code class=&quot;highlighter-rouge&quot;&gt;sync_fifo&lt;/code&gt; should &lt;em&gt;never&lt;/em&gt; be able to get into
a state where the bits are &lt;code class=&quot;highlighter-rouge&quot;&gt;2&#39;b01&lt;/code&gt;.  This property is necessary
to keep the &lt;a href=&quot;/blog/2018/03/10/induction-exercise.html&quot;&gt;induction stage from starting in this unreachable
state&lt;/a&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(*)
		assert(sync_fifo != 2&#39;b01);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Likewise, any time &lt;code class=&quot;highlighter-rouge&quot;&gt;sync_fifo[1]&lt;/code&gt; is &lt;em&gt;true&lt;/em&gt;, then &lt;code class=&quot;highlighter-rouge&quot;&gt;o_reset&lt;/code&gt; should be active.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(*)
	if (sync_fifo[1])
		assert(o_reset);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Finally, any time &lt;code class=&quot;highlighter-rouge&quot;&gt;i_areset_n&lt;/code&gt; is active (low), we’ll want to make certain
that &lt;code class=&quot;highlighter-rouge&quot;&gt;sync_fifo&lt;/code&gt; is in its full reset state as &lt;code class=&quot;highlighter-rouge&quot;&gt;2&#39;b11&lt;/code&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(*)
	if (!i_areset_n)
		assert(sync_fifo == 2&#39;b11);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;All four of these criteria are necessary to make certain that the design
passes induction.&lt;/p&gt;

&lt;p&gt;That also ends the
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal properties&lt;/a&gt;
of our asynchronous reset module.&lt;/p&gt;

&lt;h2 id=&quot;symbiyosys&quot;&gt;SymbiYosys&lt;/h2&gt;

&lt;p&gt;If you want to prove this design using
&lt;a href=&quot;https://symbiyosys.readthedocs.io/en/latest&quot;&gt;SymbiYosys&lt;/a&gt;,
you’ll need to put a
&lt;a href=&quot;https://symbiyosys.readthedocs.io/en/latest&quot;&gt;SymbiYosys&lt;/a&gt;
script together to do so.  Let’s take a quick moment to build this
&lt;a href=&quot;/examples/areset.sby&quot;&gt;script&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;We’ve discussed
&lt;a href=&quot;https://symbiyosys.readthedocs.io/en/latest&quot;&gt;SymbiYosys&lt;/a&gt;
scripts a little on the blog, although we haven’t discussed
&lt;a href=&quot;https://symbiyosys.readthedocs.io/en/latest&quot;&gt;SymbiYosys&lt;/a&gt;
&lt;em&gt;tasks&lt;/em&gt; much.  For this design, we’ll use a
&lt;a href=&quot;https://symbiyosys.readthedocs.io/en/latest&quot;&gt;SymbiYosys&lt;/a&gt;
task so that we can have
&lt;a href=&quot;https://symbiyosys.readthedocs.io/en/latest&quot;&gt;SymbiYosys&lt;/a&gt;
handle both &lt;em&gt;prove&lt;/em&gt;ing that our design works, as well as the &lt;em&gt;cover&lt;/em&gt; property
above.&lt;/p&gt;

&lt;p&gt;A &lt;a href=&quot;https://symbiyosys.readthedocs.io/en/latest&quot;&gt;SymbiYosys&lt;/a&gt;
&lt;a href=&quot;/examples/areset.sby&quot;&gt;script&lt;/a&gt;
with tasks in it starts with a &lt;code class=&quot;highlighter-rouge&quot;&gt;[tasks]&lt;/code&gt; section declaring the names
of the various tasks.  In our case, we’ll declare a &lt;code class=&quot;highlighter-rouge&quot;&gt;cover&lt;/code&gt; and a &lt;code class=&quot;highlighter-rouge&quot;&gt;prove&lt;/code&gt;
task.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;[tasks]
prove
cover&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The second section of the
&lt;a href=&quot;/examples/areset.sby&quot;&gt;SymbiYosys script&lt;/a&gt;
describes the options to be given to the formal solver.  The &lt;code class=&quot;highlighter-rouge&quot;&gt;mode&lt;/code&gt; option
selects what mode we wish to run the solvers in.  For the &lt;code class=&quot;highlighter-rouge&quot;&gt;prove&lt;/code&gt; task, we’ll
run in &lt;code class=&quot;highlighter-rouge&quot;&gt;prove&lt;/code&gt; mode.  This will apply both a bounded model check as well as
the &lt;em&gt;k&lt;/em&gt;-induction pass.  Passing this task will &lt;em&gt;prove&lt;/em&gt; that the safety
properties hold.  This applies to all of the &lt;code class=&quot;highlighter-rouge&quot;&gt;assume&lt;/code&gt;s and &lt;code class=&quot;highlighter-rouge&quot;&gt;assert&lt;/code&gt;s above.
The second mode, used by our
second task, is the &lt;code class=&quot;highlighter-rouge&quot;&gt;cover&lt;/code&gt; mode.  We’ll use this to make certain our
&lt;code class=&quot;highlighter-rouge&quot;&gt;cover&lt;/code&gt; statement is reached.  The final option, &lt;code class=&quot;highlighter-rouge&quot;&gt;multiclock on&lt;/code&gt;, applies
to both tasks.  This option tells
&lt;a href=&quot;https://symbiyosys.readthedocs.io/en/latest&quot;&gt;SymbiYosys&lt;/a&gt;
that we’ll be using the asynchronous or multiple clock capabilities of the
formal solvers.&lt;/p&gt;

&lt;p&gt;For those who have been following
&lt;a href=&quot;https://symbiyosys.readthedocs.io/en/latest&quot;&gt;SymbiYosys&lt;/a&gt;
development, this option replaces the &lt;code class=&quot;highlighter-rouge&quot;&gt;clk2fflogic&lt;/code&gt;
&lt;a href=&quot;http://www.clifford.at/yosys/&quot;&gt;yosys&lt;/a&gt;
option.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;[options]
prove: mode prove
cover: mode cover
multiclock on&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The third section is the &lt;code class=&quot;highlighter-rouge&quot;&gt;[engines]&lt;/code&gt; section.  This particular design doesn’t
really need any particular engine.  We’ll pick
&lt;a href=&quot;http://yices.csl.sri.com&quot;&gt;yices&lt;/a&gt;
therefore, since it is a good general purpose engine.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;[engines]
smtbmc yices&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Alternatively, we might have just stated &lt;code class=&quot;highlighter-rouge&quot;&gt;smtbmc&lt;/code&gt; without naming the
&lt;a href=&quot;http://yices.csl.sri.com&quot;&gt;yices&lt;/a&gt;
engine, since
&lt;a href=&quot;http://yices.csl.sri.com&quot;&gt;yices&lt;/a&gt; is the default engine anyway.&lt;/p&gt;

&lt;p&gt;That leaves two sections left.  The fourth section lists the commands that
&lt;a href=&quot;http://www.clifford.at/yosys/&quot;&gt;yosys&lt;/a&gt;
itself will use to prepare our design for the
&lt;a href=&quot;http://yices.csl.sri.com&quot;&gt;formal solver&lt;/a&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;[script]
read_verilog -formal areset.v
prep -top areset&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The final section lists all the files in our design–in this case, just
&lt;code class=&quot;highlighter-rouge&quot;&gt;areset.v&lt;/code&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;[files]
areset.v&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;We’re now ready to run
&lt;a href=&quot;https://symbiyosys.readthedocs.io/en/latest&quot;&gt;SymbiYosys&lt;/a&gt;!&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span class=&quot;gp&quot;&gt;&amp;gt; &lt;/span&gt;sby -f areset.sby&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;There’s really not much more to it.  That’s all that’s required to
formally verify
a simple
&lt;a href=&quot;/examples/areset.v&quot;&gt;asynchronous reset&lt;/a&gt;
design.&lt;/p&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;Proving that this &lt;a href=&quot;/examples/areset.v&quot;&gt;asynchronous reset to synchronous release
module&lt;/a&gt;
works may seem trivial, but it does demonstrate a lot of the capabilities of the
open source formal tools.  For example, did you notice that this proof applies
to &lt;em&gt;any&lt;/em&gt; clock structure?&lt;/p&gt;

&lt;p&gt;There are several other simple designs that can be proven just like this one.
Examples include a clock gate, clock switch, input or output DDR components
or even SERDES implementations.
I discuss each these projects in my Formal Verification course, before
offering them as student exercises.  &lt;a href=&quot;https://www.blueletterbible.org/kjv/jas/4/15&quot;&gt;If the Lord is
willing&lt;/a&gt;,
we’ll continue with these techniques to create and then &lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formally
verify&lt;/a&gt; an
&lt;a href=&quot;https://www.sunburst-design.com/papers/CummingsSNUG2002SJ_FIFO1.pdf&quot;&gt;asynchronous FIFO&lt;/a&gt;
as a future post.&lt;/p&gt;

&lt;hr /&gt;&lt;p&gt;&lt;em&gt;Come now, and let us reason together, saith the LORD: though your sins be as scarlet, they shall be as white as snow; though they be red like crimson, they shall be as wool.  (Is 1:18)&lt;/em&gt;</description>
        <pubDate>Thu, 12 Apr 2018 00:00:00 -0400</pubDate>
        <link>http://zipcpu.com/formal/2018/04/12/areset.html</link>
        <guid isPermaLink="true">http://zipcpu.com/formal/2018/04/12/areset.html</guid>
        
        
        <category>formal</category>
        
      </item>
    
      <item>
        <title>What would you like to see on the ZipCPU blog?</title>
        <description>&lt;p&gt;The &lt;a href=&quot;http://zipcpu.com/&quot;&gt;ZipCPU blog&lt;/a&gt; has recently picked
up a lot of readers in light of my
&lt;a href=&quot;/blog/2018/04/02/formal-cpu-bugs.html&quot;&gt;recent on-going work&lt;/a&gt;
to &lt;a href=&quot;/blog/2018/04/02/formal-cpu-bugs.html&quot;&gt;formally verify&lt;/a&gt;
the entire &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;To all of those new readers, &lt;em&gt;Welcome!&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;The &lt;a href=&quot;http://zipcpu.com/&quot;&gt;ZipCPU blog&lt;/a&gt; is dedicated to helping
FPGA designers avoid getting stuck in
&lt;a href=&quot;/blog/2017/05/19/fpga-hell.html&quot;&gt;FPGA Hell&lt;/a&gt;–a place where
&lt;a href=&quot;/blog/2017/09/14/even-i-get-stuck.html&quot;&gt;your design doesn’t work and you can’t figure out why
not&lt;/a&gt;.  To this end,
I’ve presented techniques for &lt;a href=&quot;/blog/2017/06/21/looking-at-verilator.html&quot;&gt;simulating your design using
Verilator&lt;/a&gt;,
&lt;a href=&quot;https://github.com/ZipCPU/dbgbus/blob/master/hexbus/README.md&quot;&gt;how to build a debugging
bus&lt;/a&gt; for
command, control, and internal register and state inspection, &lt;a href=&quot;/blog/2017/06/08/simple-scope.html&quot;&gt;how to build
your own internal logic
analyzer&lt;/a&gt;,
&lt;a href=&quot;/blog/2017/07/08/getting-started-with-wbscope.html&quot;&gt;how to use my own wishbone
scope&lt;/a&gt;,
&lt;a href=&quot;/blog/2017/07/31/vcd.html&quot;&gt;how the VCD file format expresses your logic
trace&lt;/a&gt;,
&lt;a href=&quot;/dsp/2017/07/24/dsp-debugging.html&quot;&gt;how to debug a DSP
algorithm&lt;/a&gt;,
&lt;a href=&quot;/blog/2017/06/17/why-network-debugging.html&quot;&gt;network debugging&lt;/a&gt;,
and more.&lt;/p&gt;

&lt;p&gt;Recently I’ve started learning about &lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal
verification&lt;/a&gt;,
and so I’ve added &lt;a href=&quot;/formal/formal.html&quot;&gt;that
topic&lt;/a&gt;
to my list as well.  As a result there have now been
&lt;a href=&quot;/formal/formal.html&quot;&gt;several articles&lt;/a&gt;
on how to &lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formally
verify&lt;/a&gt;
your logic as and after you have put it together, and &lt;a href=&quot;/blog/2018/03/14/is-formal-hard.html&quot;&gt;the value of formal
verification&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;What you as a reader need to know, however, is that these articles are
&lt;a href=&quot;https://www.patreon.com/ZipCPU&quot;&gt;sponsor supported&lt;/a&gt;.  If you find this blog
valuable, and would like to see it continue, then please consider becoming
one of my &lt;a href=&quot;https://www.patreon.com/ZipCPU&quot;&gt;Patreon Sponsors&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;One of the perks of being a
&lt;a href=&quot;https://www.patreon.com/ZipCPU&quot;&gt;sponsor&lt;/a&gt;
is that I am responsive to the topics my
&lt;a href=&quot;https://www.patreon.com/ZipCPU&quot;&gt;sponsors&lt;/a&gt;
are interested in.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.patreon.com/ZipCPU&quot;&gt;sponsors&lt;/a&gt;.
So, here’s a short list of some of the upcoming topics which I think would be
fun to post about.  If you are one of my
&lt;a href=&quot;https://www.patreon.com/ZipCPU&quot;&gt;sponsors&lt;/a&gt;,
then please consider yourself invited to contact me and let me know
which of these (or other) topics you might be interested in.  There
is also a more complete list of both past and upcoming topics in the site
&lt;a href=&quot;/topics.html&quot;&gt;topics&lt;/a&gt; list as well.&lt;/p&gt;

&lt;p&gt;So, without further delay, here are some of the topics I am considering
writing about in the near future, should &lt;a href=&quot;https://www.blueletterbible.org/kjv/jas/4/15&quot;&gt;the Lord be
willing&lt;/a&gt;:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;ZBasic ZipCPU Peripheral&lt;/strong&gt;: Some time ago, I promised I was going to
discuss how easy it was to add a peripheral to the
&lt;a href=&quot;https://github.com/ZipCPU/zbasic&quot;&gt;ZBasic&lt;/a&gt;
using &lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt;.
I am still fully intending to do this, although I am somewhat struggling to
decide what that example peripheral should be–there are just too many
&lt;a href=&quot;https://github.com/ZipCPU?tab=repositories&quot;&gt;possibilities&lt;/a&gt;.  Feel free
to make a suggestion if you would like.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Quadratic Sinewave generation&lt;/strong&gt;: &lt;a href=&quot;/dsp/2017/08/30/cordic.html&quot;&gt;CORDIC sinewave
generation&lt;/a&gt; is really cool,
but it can also be logically expensive within an FPGA.
A potentially cheaper algorithm, requiring only two multiplies, would be to
apply our &lt;a href=&quot;/dsp/2018/03/30/quadratic.html&quot;&gt;quadratic interpolation
techniques&lt;/a&gt;
to generating a cleaner sine wave.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Asynchronous FIFO&lt;/strong&gt;: I have a nice formal proof of &lt;a href=&quot;http://www.sunburst-design.com/papers/CummingsSNUG2002SJ_FIFO1.pdf&quot;&gt;Cliff Cummings’
asynchronous FIFO
design&lt;/a&gt;
that I think would be valuable to present as well.  Unlike many of &lt;a href=&quot;/formal/formal.html&quot;&gt;my other
formal articles&lt;/a&gt;, this one requires
a formal solution across more than one clock domain, and for arbitrary
clock speeds.  This will add to the interest and value of it.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Ethernet CRC&lt;/strong&gt;: When I recently built a Ethernet CRC module for the 1Gb
Ethernet port of the &lt;a href=&quot;https://store.digilentinc.com/nexys-video-artix-7-fpga-trainer-board-for-multimedia-applications&quot;&gt;Nexys Video
board&lt;/a&gt;,
I was surprised at how much formal methods could help simplify
the complicated math of a multi-stepping CRC generator.  This would
therefore be a fun topic to share, as there is a lot of practical
information within it.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Dual I/O SPI flash&lt;/strong&gt;: While I am personally quite biased towards a &lt;a href=&quot;http://opencores.org/project,qspiflash&quot;&gt;Quad
SPI flash implementation&lt;/a&gt;,
recent events have led me to need to build a
&lt;em&gt;Dual I/O SPI flash&lt;/em&gt; implementation for a couple of logic challenged
implementations.  This means that this controller should be simple enough to
both present and understand, and makes a nice blog topic&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;TinyFPGA&lt;/strong&gt;: I’m also building a &lt;a href=&quot;https://github.com/ZipCPU/tinyzip&quot;&gt;TinyFPGA BX
design&lt;/a&gt; using the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;, and would love to blog about
this design.  Yes, the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; does
fit nicely on that board with room to spare (when &lt;a href=&quot;https://github.com/ZipCPU/tinyzip/blob/master/rtl/cpu/cpudefs.v&quot;&gt;properly
trimmed&lt;/a&gt;),
however my &lt;a href=&quot;https://github.com/ZipCPU/s6soc/blob/master/rtl/qflashxpress.v&quot;&gt;minimal flash
controller&lt;/a&gt;
needed to be redesigned, and my C++ &lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/sim/verilated/qspiflashsim.cpp&quot;&gt;flash
simulator&lt;/a&gt;
needed to be adjusted to get this to work.  Once I’ve finished verifying
that I can program and run the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
on this board, then it would be fun to describe my experiences.  Because of
the dependence upon the flash controller, however, this post would follow the
discussion of the &lt;strong&gt;Dual I/O SPI flash&lt;/strong&gt; design.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Some Simple Formal Verification Proofs&lt;/strong&gt;: It might be nice to return to our
(event) &lt;a href=&quot;/blog/2017/06/02/generating-timing.html&quot;&gt;timing control solutions
post&lt;/a&gt;,
and take a new look at them in light of &lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal
verification&lt;/a&gt;.
For example, how would you verify that a timer provides you with the right
number of clock ticks, or how would you speed up an otherwise exceptionally
long proof.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Prefetch with Cache&lt;/strong&gt;: The
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; has a 1-way instruction
cache that would be fun to present, and would also conclude our discussion
of prefetch methods.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Data Movement&lt;/strong&gt;: One of the sad realities of FPGA work is that its not all
about data transformation.  There’s a lot to be done in data movement as well.&lt;/p&gt;

    &lt;p&gt;The &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZiPCPU&lt;/a&gt; contains a
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/wbdmac.v&quot;&gt;DMA controller&lt;/a&gt;
that can be set up to automatically move data from one place to another within
any &lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;wishbone based
design&lt;/a&gt;.  &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/wbdmac.v&quot;&gt;This
component&lt;/a&gt;,
and its formal properties would be useful to many of my readers.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Abstraction in Formal Verification&lt;/strong&gt;: The recent
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
&lt;a href=&quot;/blog/2018/04/02/formal-cpu-bugs.html&quot;&gt;verification work&lt;/a&gt;
depends heavily on formal verification concepts of abstraction and
invariance.  Both techniques are useful when trying to break a complicated
design, such as a full CPU, down into its subcomponents.&lt;/p&gt;

    &lt;p&gt;This article would present abstraction.  In short, abstraction is based upon
the statement that if &lt;code class=&quot;highlighter-rouge&quot;&gt;A&lt;/code&gt; implies &lt;code class=&quot;highlighter-rouge&quot;&gt;B&lt;/code&gt;, then &lt;code class=&quot;highlighter-rouge&quot;&gt;A&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;C&lt;/code&gt; must also imply
&lt;code class=&quot;highlighter-rouge&quot;&gt;B&lt;/code&gt;.  The figures and outline of this lesson would be taken from the
formal verification course I’ve put together for
&lt;a href=&quot;https://www.symbioticeda.com&quot;&gt;Symbiotic EDA&lt;/a&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Invariance in Formal Verification&lt;/strong&gt;: Invariance is a second very powerful
tool that can be used to simplify the formal prove of a component.  Put
simply, if you can prove the &lt;code class=&quot;highlighter-rouge&quot;&gt;A&lt;/code&gt; is true, you no longer need to prove &lt;code class=&quot;highlighter-rouge&quot;&gt;A&lt;/code&gt;
anymore.  The difference over what can, and cannot, be proven using this
technique can be drastic.&lt;/p&gt;

    &lt;p&gt;The figures and outline of this lesson would also be taken from the
formal verification course I’ve put together for
&lt;a href=&quot;https://www.symbioticeda.com&quot;&gt;Symbiotic EDA&lt;/a&gt;, as with the potential
abstraction course discussed above.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;More filtering&lt;/strong&gt;: We left our discussion of filtering incomplete, and
so I’d still like to come back to demonstrate both symmetric and halfband
filters.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Dhrystone&lt;/strong&gt;: Also on my list of items to discuss is Dhrystone, the
outdated-yet-still-useful CPU bench mark.  For all of you who are
interested in comparing your CPU’s performance against Dhrystone, this
article would take a quick look at how Dhrystone can be run within a
Verilator simulation, and how I’ve gone about interpreting the results.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Synchronization&lt;/strong&gt;: One common problem in &lt;a href=&quot;/dsp/dsp.html&quot;&gt;digital signal
processing&lt;/a&gt; is the
“two-clock” problem where data comes into the algorithm on one clock, and
yet needs to be output on the edges of an unrelated clock.  Now that we’ve
spent some time with
&lt;a href=&quot;/dsp/2018/03/30/quadratic.html&quot;&gt;interpolation&lt;/a&gt;, as well as
&lt;a href=&quot;/dsp/2017/12/14/logic-pll.html&quot;&gt;how to build a simple PLL
module&lt;/a&gt;, it only makes
sense that we would connect these two concepts to be able to synchronize
two data streams.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Generating an Arbitrary Clock Signal&lt;/strong&gt;: I also have a simple design
component that can be used to generate a clock signal at an arbitrary
frequency, without requiring any additional clock chips.  (The FPGA still
needs its input clock.)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Building a HyperRAM controller&lt;/strong&gt;:
&lt;a href=&quot;http://www.cypress.com/products/hyperram-memory&quot;&gt;HyperRAM&lt;/a&gt; is a powerful
RAM communication protocol.  Unlike
DDR3 SDRAM, building a controller for
&lt;a href=&quot;http://www.cypress.com/products/hyperram-memory&quot;&gt;HyperRAM&lt;/a&gt;
doesn’t require undocumented chip features.  This article would discuss
such a controller, both how to build it as well as how to formally verify
that it works.&lt;/p&gt;

    &lt;p&gt;If there’s enough demand, a separate article could discuss how to build a
simulation component for this device.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;If you’ve made it this far, let share this with you: I’m creating today
a &lt;a href=&quot;/formal/formal.html&quot;&gt;formal page&lt;/a&gt; which will capture
all of my formal verification posts.  This should make it easier for someone
who is only interested in &lt;a href=&quot;/formal/formal.html&quot;&gt;formal
verification&lt;/a&gt; to find articles that
discuss or provide examples of &lt;a href=&quot;/formal/formal.html&quot;&gt;formal
verification&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/formal/formal.html&quot;&gt;This new topical page&lt;/a&gt;
joins my prior &lt;a href=&quot;/dsp/dsp.html&quot;&gt;DSP topical page&lt;/a&gt;.  However,
&lt;em&gt;all&lt;/em&gt; articles will remain on the blog’s main page.&lt;/p&gt;

&lt;p&gt;Finally, if you are one of my 
&lt;a href=&quot;https://www.patreon.com/ZipCPU&quot;&gt;Patreon sponsors&lt;/a&gt;,
please feel free to contact me at the e-mail address below and let me know
which, if any, of these topics you might be interested in.  Even better,
these are only suggestions.  If you are interested in a topic that isn’t
listed above, please feel free to share that topic with me as well.  Just please
be aware that topics not on this list, such as creating a GCC port, might
take a bit longer to work up to.&lt;/p&gt;

&lt;p&gt;If you are not one of my 
&lt;a href=&quot;https://www.patreon.com/ZipCPU&quot;&gt;Patreon sponsors&lt;/a&gt;,
and yet you find this
&lt;a href=&quot;http://zipcpu.com/&quot;&gt;blog valuable&lt;/a&gt;, please consider joining
the team!  While I have no intention of restricting
&lt;a href=&quot;http://zipcpu.com/&quot;&gt;the blog&lt;/a&gt;’s content to subscribers only,
your support will help
&lt;a href=&quot;http://zipcpu.com/&quot;&gt;this blog&lt;/a&gt; continue into the future.&lt;/p&gt;
&lt;hr /&gt;&lt;p&gt;&lt;em&gt;The husbandman that laboureth must be first partaker of the fruits. (2Tim 2:6)&lt;/em&gt;</description>
        <pubDate>Thu, 05 Apr 2018 00:00:00 -0400</pubDate>
        <link>http://zipcpu.com/blog/2018/04/05/topatreon.html</link>
        <guid isPermaLink="true">http://zipcpu.com/blog/2018/04/05/topatreon.html</guid>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>Will formal methods ever find a bug in a working CPU?</title>
        <description>&lt;p&gt;Today, I’m starting what will likely be the slow process of
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formally verifying&lt;/a&gt;
the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;.  I’m going to use
&lt;a href=&quot;http://www.clifford.at/yosys&quot;&gt;yosys&lt;/a&gt; for this process initially, but given
&lt;a href=&quot;https://symbiyosys.readthedocs.io/en/latest&quot;&gt;SymbiYosys&lt;/a&gt;’s ability to
run multiple formal configurations as separate tasks, I will probably need to
switch after I get some distance along.&lt;/p&gt;

&lt;p&gt;At this point in the game, I’ve already &lt;a href=&quot;/blog/2018/01/22/formal-progress.html&quot;&gt;formally proven all of the
components&lt;/a&gt;
of the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;.
What remains is to prove the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU itself&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;So here’s my question: How many bugs would you expect to find in a “working”
soft-core CPU?  One?  Ten?  Twenty?  One hundred?  Shall we count?  I propose
keeping a running log of the bugs I find in the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; while using
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formally methods&lt;/a&gt;.
Perhaps this log will help to convince you the value of
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formally methods&lt;/a&gt;,
perhaps not.  Either way, I’ll keep it accurate to the information I discover.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;The memory manager refused to release the bus if the response came back
on the same cycle.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Certain errors should cause the CPU to halt–such as encountering a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_(computing)&quot;&gt;bus&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_error&quot;&gt;error&lt;/a&gt;
when reading from instruction memory.  Due to a (now locally fixed) bug
in the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;, these errors
would not cause the CPU to halt if they were one of the first couple
instructions.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; is designed so that
memory reads or writes &lt;em&gt;never&lt;/em&gt; need to be rolled back. This is to
facilitate using the memory bus for reading and
writing peripherals, such as the serial port.  Reads from such peripherals
have side effects that cannot be rolled back.  The formal methods however,
discovered an example where reading into the program counter, such as during
an indirect jump, my cause a following memory instruction to need to be
rolled back.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;’s current approach to
the compressed instruction set (CIS)
is to prevent the CPU from interrupting in the middle of a CIS instruction.
Formal methods, however, found an internal accounting bug which prevented
this logic from working properly.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Several bugs have been found in the debug infrastructure, allowing an
external debugger to change registers internal to the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;.&lt;/p&gt;

    &lt;p&gt;In one example, this was violating the rules the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; uses when issuing
pipelined memory instructions.&lt;/p&gt;

    &lt;p&gt;In another example, during a divide that was to write its results into &lt;code class=&quot;highlighter-rouge&quot;&gt;R0&lt;/code&gt;,
the external debug infrastructure was allowed to write to a register,
say &lt;code class=&quot;highlighter-rouge&quot;&gt;R1&lt;/code&gt;.  This would cause the divide to write its results into &lt;code class=&quot;highlighter-rouge&quot;&gt;R1&lt;/code&gt; upon
completion, rather than &lt;code class=&quot;highlighter-rouge&quot;&gt;R0&lt;/code&gt;.&lt;/p&gt;

    &lt;p&gt;The &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; has
therefore been adjusted so that the debug infrastructure
can only modify the value of a register if the CPU has been fully halted.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The flag indicating that the CPU is fully halted was not properly
implemented.  Specifically, the CPU might declare it was halted in the middle
of a CIS instruction when the second half of the instruction still needed
to be flushed through the pipeline.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;On a multi-cycle ALU operation (i.e. one of the multiplies), the flags
were being set before the operation was complete&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The clock-less version of the instruction decoder, used by the formal
properties alone to know what to expect from an instruction, didn’t match
the actual instruction decoder when it came to whether or not SIM
instructions should cause an illegal interrupt exception&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The divide wouldn’t wait for a multiply to complete before starting.  Such
a multiply might have provided the divide with its operand, but due to this
bug the divide input would’ve been the prior value of the register.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Under certain circumstances in the pipeline, the break instruction would
get bypassed.&lt;/p&gt;

    &lt;p&gt;I’m actually looking forward to simplifying this break logic by merging it
with the illegal instruction logic, since the two do the same thing in
different ways.  I’m holding off on this for now, however.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Writes to the user PC register, such as by the debug port or even the ALU,
   while in supervisor (not user) mode, would corrupt any logic depending
   upon the user PC register that was already in the pipeline.  Hence, the
   pipeline needs to be cleared following any such write.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;After making several fixes, the memory instruction following an illegal
instruction would be issued.  This error isn’t so much a bug in the working
CPU, but rather a bug in my pipeline logic rewrite.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Perhaps this would never happen.  However, the memory controller wouldn’t
stall when it ran out of internal memory to keep track of where the
write back results would be written to.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;On an early branch or an illegal instruction, the valid memory instruction
flag was still being set, eventually violating the contract with the memory
device.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The switch to interrupt flag wasn’t waiting for any ongoing memory
operations to complete first&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;On a divide error, the memory unit would still issue an instruction.
This creates a problem because a memory operation to a peripheral device
cannot be withdrawn, as the CPU tries to switch to its exception handling
code.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Under certain circumstances, the CPU would continue issuing instructions
following a bus error or division by zero error.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;At this point, I’m going to stop counting.  It’s not because there are so
many errors remaining, but rather because its no longer clear which of the
remaining errors were originally
in the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
and which ones were added while trying to fix the earlier bugs.&lt;/p&gt;

&lt;h2 id=&quot;bugs-in-the-formal-properties&quot;&gt;Bugs in the Formal Properties&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;The formal properties within the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;core&lt;/a&gt;,
as well as the abstracted components, are still quite immature.
Multiple bugs are still being found within them.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/ex/wbdblpriarb.v&quot;&gt;Wishbone
arbiter&lt;/a&gt;
had a careless assumption within it.  This prevented the arbiter from ever
being fully tested and verified.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
recognizes two memory regions: a local region for CPU-specific
peripherals from &lt;code class=&quot;highlighter-rouge&quot;&gt;0xff000000&lt;/code&gt; to &lt;code class=&quot;highlighter-rouge&quot;&gt;0xffffffff&lt;/code&gt; (used by the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/zipsystem.v&quot;&gt;ZipSystem&lt;/a&gt;,
and a more global memory
region (everything else).  Crossing regions within the same memory operation
is a fault that needs to be prevented in software, and the formal
properties for describing this fault were &lt;code class=&quot;highlighter-rouge&quot;&gt;assert()&lt;/code&gt; functions rather than
&lt;code class=&quot;highlighter-rouge&quot;&gt;restrict()&lt;/code&gt; functions.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;current-status&quot;&gt;Current status&lt;/h2&gt;

&lt;p&gt;I’m currently fully verifying the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;’s
capability using an &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/formal/bench/formal/abs_prefetch.v&quot;&gt;abstract
prefetch&lt;/a&gt;,
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/formal/bench/formal/abs_div.v&quot;&gt;abstract
divide&lt;/a&gt;,
and an &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/dev/bench/formal/abs_mpy.v&quot;&gt;abstract
multiply&lt;/a&gt;.
Thanks to SymbiYosys and “abc pdr”, the pipeline properties I’ve now verified
constitutes a full formal proof (BMC + induction) of the first set of
formal properties for the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;. 
A second stage of properties have since been added, dependent upon the
synthesizer define &lt;code class=&quot;highlighter-rouge&quot;&gt;PHASE_ONE&lt;/code&gt;. The proof of this second set of properties
remains ongoing.&lt;/p&gt;

&lt;p&gt;First, the formal properties:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;I’ve proven that the assumptions within all of the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;’s
sub-modules hold.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;I’ve manage to verify that the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;’s
pipeline logic won’t accidentally “delete” an instruction in the pipeline.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;I’ve also added the properties that the operands given to the
ALU, memory, or divide unit, need to be valid.&lt;/p&gt;

    &lt;p&gt;This portion of the proof is ongoing.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Following any ALU or divide instruction, only the correct register will
ever be written if at all–I haven’t dealt with predicates yet.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;BREAK&lt;/code&gt; instructions never pass the OP stage as desired.  This makes certain
these instructions will not increment the PC when encountered.  This is
very similar to an illegal operand instruction, and the logic for these
may yet be merged.  For now, the &lt;code class=&quot;highlighter-rouge&quot;&gt;BREAK&lt;/code&gt; instruction bypasses the ALU
stage of the CPU as desired.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;I haven’t gotten to the cover properties yet, those are yet to come.  As a
result, I may have carelessly assumed away a portion of the proof and can’t
tell yet.&lt;/p&gt;

&lt;p&gt;Here’s how far I’ve gotten:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Without pipelining the memory bus, the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; made it for a full 40 clocks
in a bounded model check.  This was the extent of the test.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;With the pipelined memory bus, the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; has formally passed
&lt;em&gt;all of the formal properties&lt;/em&gt; now written for it&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The updated formal code is currently in a git repository branch that hasn’t
(yet) been pushed.  Upon request I have pushed components of this
proof into the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/tree/dev&quot;&gt;dev branc&lt;/a&gt;,
although I’d still be a bit embarrassed to present the (not quite working)
CPU yet.  This includes the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/dev/bench/formal/abs_mpy.v&quot;&gt;abstract
multiply&lt;/a&gt;
mentioned above, as well as the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/dev/rtl/core/mpyop.v&quot;&gt;multiply
module&lt;/a&gt; that it
replaces.&lt;/p&gt;

    &lt;p&gt;My apologies to all that have indicated an interest in seeing this code.
Thank you for your interest.  I guess it surprised me a bit.
I’m just not quite ready yet to post the code–mostly because things aren’t
fully working.  I do anticipate fully sharing this code in due time.  If
you are really interested in seeing this before it is complete, then
please send me an e-mail and I will consider placing it on
&lt;a href=&quot;https://gitlab.com&quot;&gt;gitlab&lt;/a&gt; where
&lt;a href=&quot;https://www.patreon.com/ZipCPU&quot;&gt;sponsors&lt;/a&gt; can have access to the current
work in progress.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;You can find and further follow my work through the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/tree/formal&quot;&gt;formal branch&lt;/a&gt;
of the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;github repository&lt;/a&gt;
for the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;.  Specifically,
you can find the properties that I’m working with at the bottom of the core
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/formal/rtl/core/zipcpu.v&quot;&gt;zipcpu.v&lt;/a&gt;
Verilog file.  I’m using a &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/formal/bench/formal/Makefile&quot;&gt;“make”
file&lt;/a&gt; within
the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/tree/bench/formal&quot;&gt;bench/forma&lt;/a&gt;
directory to control the process.&lt;/p&gt;
&lt;hr /&gt;&lt;p&gt;&lt;em&gt;Again, when the wicked man turneth away from his wickedness that he hath committed, and doeth that which is lawful and right, he shall save his soul alive.  (Ezek 18:27)&lt;/em&gt;</description>
        <pubDate>Mon, 02 Apr 2018 00:00:00 -0400</pubDate>
        <link>http://zipcpu.com/blog/2018/04/02/formal-cpu-bugs.html</link>
        <guid isPermaLink="true">http://zipcpu.com/blog/2018/04/02/formal-cpu-bugs.html</guid>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>Resurrection Day!</title>
        <description>&lt;p&gt;Buddha &lt;a href=&quot;https://en.wikipedia.org/wiki/Gautama_Buddha#Relics&quot;&gt;is dead&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Mohammed &lt;a href=&quot;https://en.wikipedia.org/wiki/Muhammad#Death_and_tomb&quot;&gt;is dead&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.blueletterbible.org/kjv/deu/34/1&quot;&gt;Moses died&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.blueletterbible.org/kjv/mat/27/50&quot;&gt;Jesus died&lt;/a&gt; as well, but unlike
these others &lt;a href=&quot;https://www.blueletterbible.org/kjv/mat/28/7&quot;&gt;He is dead no more&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;This simple fact &lt;a href=&quot;https://www.blueletterbible.org/kjv/act/17/31&quot;&gt;makes Christianity
different&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Today, we celebrate this difference.&lt;/p&gt;

&lt;h2 id=&quot;what-makes-jesus-special&quot;&gt;What makes Jesus special?&lt;/h2&gt;

&lt;p&gt;Jesus knew He was going to die.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;And as Moses lifted up the serpent in the wilderness
[&lt;a href=&quot;https://www.blueletterbible.org/kjv/num/21/8&quot;&gt;Num 21:8&lt;/a&gt;],
even so must the Son of man be lifted up [i.e. crucified]: That whosoever
believeth in him should not perish, but have eternal life.
(&lt;a href=&quot;https://www.blueletterbible.org/kjv/jhn/3/14&quot;&gt;John 3:14-15&lt;/a&gt;)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;This was His purpose in coming to the earth.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Now is my soul troubled; and what shall I say?  Father, save me from this
hour: but for this cause came I unto this hour.  Father, glorify thy name.
Then came there a voice from heaven, saying, I have both glorified it, and
will glorify it again.
(&lt;a href=&quot;https://www.blueletterbible.org/kjv/jhn/12/27&quot;&gt;John 12:27-28&lt;/a&gt;)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Jesus also knew that He could raise Himself up from the grave long before
He was put to death.  This was a commandment given to Him by His Father,
the one we call God.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Therefore doth my Father love me, because I lay down my life, that I might
take it again.  No man taketh it from me, but I lay it down of myself.
I have the power to lay it down, and I have the power to take it again.
This command have I received of my Father.
(&lt;a href=&quot;https://www.blueletterbible.org/kjv/jhn/10/17&quot;&gt;John 10:17-18&lt;/a&gt;)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;The disciples were falsely accused of hiding His body.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Saying, Say ye, His disciples came by night, and stole him away while we
slept.
(&lt;a href=&quot;https://www.blueletterbible.org/kjv/mat/28/13&quot;&gt;Mat 28:13&lt;/a&gt;).&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;In spite of this lie, no one found the missing body because there was no
missing body.  Jesus is no longer dead, He is risen!&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;And as they were afraid, and bowed down their faces to the earth, they
said unto them, “Why seek ye the living among the dead?”
(&lt;a href=&quot;https://www.blueletterbible.org/kjv/luk/24/5&quot;&gt;Luke 24:5&lt;/a&gt;)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;em&gt;(By the way, I love the song by this same name which comes from the musical
&lt;a href=&quot;https://www.youtube.com/watch?v=roxCbUndmR0&quot;&gt;The Choice&lt;/a&gt; by Nate Copeland.
[&lt;a href=&quot;https://www.youtube.com/watch?v=6bM3S5fBYec&quot;&gt;1&lt;/a&gt;],
[&lt;a href=&quot;https://www.youtube.com/watch?v=wZ-qPvYQNr4&quot;&gt;2&lt;/a&gt;],
[&lt;a href=&quot;https://www.youtube.com/watch?v=c2fg_hhDN94&quot;&gt;3&lt;/a&gt;],
[&lt;a href=&quot;https://www.youtube.com/watch?v=Osbuen8WkRI&quot;&gt;4&lt;/a&gt;])&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;The resurrection, evidenced by the empty tomb, proves the validity
of the message.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Because he hath appointed a day, in the which He will judge the world in
righteousness by that Man whom he hath ordained; whereof He hath given
assurance unto all men, in that He hath raised Him from the dead.
(&lt;a href=&quot;https://www.blueletterbible.org/kjv/act/17/31&quot;&gt;Acts 17:31&lt;/a&gt;)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Without the resurrection, there is no point in Christianity.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;And if Christ be not risen, then is our preaching vain, and your faith is
vain [i.e. useless or pointless].  Yea, and we are found false witnesses of
God [i.e. liars]; because we have testified of God that He raised up Christ:
whom He raised not up, if so be that the dead rise not.&lt;/p&gt;

  &lt;p&gt;For if the dead rise not, then is Christ not raised: and if Christ be not
raised, your faith is vain; ye are yet in your sins.
Then they also which are fallen asleep in Christ are perished.&lt;/p&gt;

  &lt;p&gt;If in this life only we have hope in Christ, we are of all men most miserable.
(&lt;a href=&quot;https://www.blueletterbible.org/kjv/1co/15/14&quot;&gt;1Cor 15:14-19&lt;/a&gt;)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Indeed, were there no resurrection, then there would be no hope in living.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;If after the manner of men I have fought with beasts at Ephesus, what
advantageth it me, if the dead rise not?  Let us eat and drink; for
tomorrow we die.
(&lt;a href=&quot;https://www.blueletterbible.org/kjv/eph/15/32&quot;&gt;Eph 15:32&lt;/a&gt;)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;But there is a resurrection!  We know this from the testimony of those who
have seen him.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;This Jesus hath God raised up, whereof we all are witnesses.
(&lt;a href=&quot;https://www.blueletterbible.org/kjv/act/4/32&quot;&gt;Acts 4:32&lt;/a&gt;)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;or again,&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;For I delivered unto you first of all that which I also received, how that
Christ died for our sins according to the scriptures;
And that he was buried, and that he rose again the third day according to
the scriptures:
And that he was seen of Cephas, then of the twelve: After that, he was seen
of above five hundred brethren at once; of whom the greater part remain to
this present, but some are fallen asleep.
After that, he was seen of James; then of all the apostles.
And last of all he was seen of me also, as of one born out of due time.
(&lt;a href=&quot;https://www.blueletterbible.org/kjv/jhn/10/17&quot;&gt;1 Cor 15:3-8&lt;/a&gt;)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;We also know this by the empty tomb, proving to all that He is the Christ!&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Therefore let all the house of Israel know assuredly, that God hath made
the same Jesus, whom ye have crucified, both Lord and Christ.
(&lt;a href=&quot;https://www.blueletterbible.org/kjv/act/4/36&quot;&gt;Acts 4:36&lt;/a&gt;)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;i-serve-a-risen-savior&quot;&gt;I serve a risen Savior&lt;/h2&gt;

&lt;p&gt;Because He lives, I have been
&lt;a href=&quot;https://www.blueletterbible.org/kjv/rom/8/1&quot;&gt;freed from my own personal sins&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Because He lives, I no longer need to live a life 
&lt;a href=&quot;https://www.blueletterbible.org/kjv/jhn/8/34&quot;&gt;controlled by my own wickedness&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Because He lives, &lt;a href=&quot;https://www.blueletterbible.org/kjv/jhn/10/28&quot;&gt;I have a
future&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Because He lives, &lt;a href=&quot;https://www.blueletterbible.org/kjv/col/3/23&quot;&gt;I blog&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Because He lives, &lt;a href=&quot;https://www.blueletterbible.org/kjv/jhn/6/37&quot;&gt;you may choose to have a future
  as well&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;If you know Christ, then
please join me today in celebrating the risen Savior, which is Christ the Lord.&lt;/p&gt;

&lt;p&gt;If you &lt;a href=&quot;https://www.blueletterbible.org/kjv/mat/7/23&quot;&gt;do not know Him&lt;/a&gt;,
or perhaps if you only know of or
&lt;a href=&quot;https://www.blueletterbible.org/kjv/jas/2/19&quot;&gt;about Him&lt;/a&gt;,
then please let me invite you discover Him through the letters His disciples
wrote describing their time with him:
&lt;a href=&quot;https://www.blueletterbible.org/kjv/mat/1&quot;&gt;Matthew&lt;/a&gt;,
&lt;a href=&quot;https://www.blueletterbible.org/kjv/mar/1&quot;&gt;Mark&lt;/a&gt;,
&lt;a href=&quot;https://www.blueletterbible.org/kjv/luk/1&quot;&gt;Luke&lt;/a&gt; and
&lt;a href=&quot;https://www.blueletterbible.org/kjv/jhn/1&quot;&gt;John&lt;/a&gt;.&lt;/p&gt;

&lt;hr /&gt;&lt;p&gt;&lt;em&gt;He is not here: for He is risen, as He said.  Come, see the place where the Lord lay. (Matthew 28:6)&lt;/em&gt;</description>
        <pubDate>Sun, 01 Apr 2018 00:00:00 -0400</pubDate>
        <link>http://zipcpu.com/blog/2018/04/01/resurrection-day.html</link>
        <guid isPermaLink="true">http://zipcpu.com/blog/2018/04/01/resurrection-day.html</guid>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>Quadratic fits are entirely inappropriate for DSP</title>
        <description>&lt;p&gt;Waveforms in nature have two characteristics that are difficult to handle in
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_signal_processing&quot;&gt;signal processing&lt;/a&gt;
applications: natural waveforms are
&lt;a href=&quot;https://en.wikipedia.org/wiki/Continuous_function&quot;&gt;continuous&lt;/a&gt;
and they are tend to last for a &lt;em&gt;long time&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;This is to be contrasted to the “signals” that &lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_signal_processing&quot;&gt;Digital Signal Processing
(DSP)&lt;/a&gt;
algorithms act upon.
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_signal_processing&quot;&gt;DSP&lt;/a&gt;
algorithms are applied to &lt;em&gt;finite&lt;/em&gt; sections of
(typically) longer waveforms that have been
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;sampled&lt;/a&gt;
at evenly spaced intervals.&lt;/p&gt;

&lt;p&gt;This leads to a fundamental problem: if you want to work on a waveform
as though it were
&lt;a href=&quot;https://en.wikipedia.org/wiki/Continuous_function&quot;&gt;continuous&lt;/a&gt;
instead of
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;sampled&lt;/a&gt;,
then you need to figure out how to reconstruct what the signal
&lt;em&gt;should be&lt;/em&gt; between the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;sample&lt;/a&gt;
points.  Perhaps you need to
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sample-rate_conversion&quot;&gt;resample&lt;/a&gt;
that signal at some new rate whose ratio is far from simple when compared
to the old rate.  Perhaps you need to
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sample-rate_conversion&quot;&gt;resample&lt;/a&gt;
your signal at locations driven by a tracking loop, such as a digital receiver
would need to do.  Perhaps you just want to zoom in on a screen plot of your
signal and &lt;a href=&quot;/dsp/2017/07/29/series-linear-interpolation.html&quot;&gt;linear
interpolation&lt;/a&gt;
leaves you with a signal that looks nothing like the original reality.  Either
way, if you want to
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;recover&lt;/a&gt;
what your signal does between
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;samples&lt;/a&gt;,
you’ll want to apply some form of
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolation&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;In the past, we’ve looked at both a &lt;a href=&quot;/dsp/2017/06/06/simple-interpolator.html&quot;&gt;sample-and-hold
“interpolator”&lt;/a&gt;
and a &lt;a href=&quot;/dsp/2017/07/29/series-linear-interpolation.html&quot;&gt;linear
interpolator&lt;/a&gt;
as possible subsample
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolation&lt;/a&gt; methods.
However, if &lt;a href=&quot;/dsp/2017/07/29/series-linear-interpolation.html&quot;&gt;linear
interpolation&lt;/a&gt;
isn’t good enough for your application, then the next best approach is some
form of &lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial_interpolation&quot;&gt;quadratic
interpolation&lt;/a&gt;.
Indeed, it’s not that hard to take three points and generate a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Quadratic_function&quot;&gt;quadratic&lt;/a&gt;
that will pass through all three of them.&lt;/p&gt;

&lt;p&gt;Stop.  Now.  Don’t do that.  Really.  Don’t.&lt;/p&gt;

&lt;p&gt;In a moment I’ll show you why not.  Then I’ll show you a better approach.
Further, when &lt;a href=&quot;https://github.com/ZipCPU/interpolation/blob/master/rtl/quadratic/quadinterp.v&quot;&gt;implemented in
logic&lt;/a&gt;,
this better approach will still use only the same two hardware multiplies that
a quadratic fit would’ve used.&lt;/p&gt;

&lt;h2 id=&quot;why-interpolation&quot;&gt;Why interpolation&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;Interpolation&lt;/a&gt; is the term used
to describe an algorithm that can be used to create (or estimate) data points
between
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;samples&lt;/a&gt;.
This is often called
&lt;a href=&quot;https://en.wikipedia.org/wiki/Upsamplers&quot;&gt;upsampling&lt;/a&gt; in a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_signal_processing&quot;&gt;Signal Processing&lt;/a&gt;
context, with the difference between
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolating&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Upsamplers&quot;&gt;upsamplers&lt;/a&gt;
and those that are not
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolating&lt;/a&gt;
is that the output of an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;
is guaranteed to go through the original
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;sample&lt;/a&gt;
points, whereas this is not necessarily the case of a more generic
&lt;a href=&quot;https://en.wikipedia.org/wiki/Upsamplers&quot;&gt;upsampler&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Today, we’ll be discussing
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolators&lt;/a&gt;
that are also infinite
&lt;a href=&quot;https://en.wikipedia.org/wiki/Upsamplers&quot;&gt;upsamplers&lt;/a&gt;, such as those &lt;a href=&quot;/dsp/2018/01/16/interpolation-is-convolution.html&quot;&gt;we
discussed earlier&lt;/a&gt;
when proving that all such
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolators&lt;/a&gt;
could be modeled as
&lt;a href=&quot;https://en.wikipedia.org/wiki/Convolution&quot;&gt;convolutions&lt;/a&gt;
of discrete-time signals with a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Continuous_function&quot;&gt;continuous&lt;/a&gt;
time filter.  Such 
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolators&lt;/a&gt;
can form the basis of an &lt;em&gt;asynchronous &lt;a href=&quot;https://en.wikipedia.org/wiki/Sample-rate_conversion&quot;&gt;sample rate
converter&lt;/a&gt;&lt;/em&gt;.
For our purposes today, though, we will limit our discussion to
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolators&lt;/a&gt;
which are simply the result of a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Piecewise&quot;&gt;piecewise&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial&quot;&gt;polynomial&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Upsamplers&quot;&gt;upsamplers&lt;/a&gt;.  We’ll even limit the
discussion further to that subset of all
&lt;a href=&quot;https://en.wikipedia.org/wiki/Piecewise&quot;&gt;piecewise&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial&quot;&gt;polynomial&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Upsamplers&quot;&gt;upsamplers&lt;/a&gt;
that is formed from quadratic
&lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial&quot;&gt;polynomials&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;I first learned the idea of
&lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial&quot;&gt;polynomial&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Upsamplers&quot;&gt;upsampling&lt;/a&gt;
from &lt;a href=&quot;http://ieeexplore.ieee.org/document/679201&quot;&gt;Harris&lt;/a&gt;,
although it seems as though
&lt;a href=&quot;http://ieeexplore.ieee.org/document/15483/&quot;&gt;Farrow&lt;/a&gt;
was the actual originator of the idea.  Hence, you might recognize our
ultimate solution as a
&lt;a href=&quot;http://ieeexplore.ieee.org/document/15483/&quot;&gt;Farrow&lt;/a&gt;
filter, although it may not look like any
&lt;a href=&quot;http://ieeexplore.ieee.org/document/15483/&quot;&gt;Farrow&lt;/a&gt;
filter you’ve seen before.  Even better, it will have provably better
asymptotic out of band performance than any
&lt;a href=&quot;http://ieeexplore.ieee.org/document/15483/&quot;&gt;Farrow&lt;/a&gt;
filter or approach I’ve seen published to date.&lt;/p&gt;

&lt;h2 id=&quot;the-problem-with-quadratic-fitting&quot;&gt;The Problem with Quadratic Fitting&lt;/h2&gt;

&lt;p&gt;I started out this post by declaring that using a quadratic fit to
the nearest three points were a horrible means of
&lt;a href=&quot;https://en.wikipedia.org/wiki/Upsamplers&quot;&gt;upsampling&lt;/a&gt;.
Let’s take a moment before going
further to see why this is the case.  We’ll do this by first creating a fit
to the nearest three points of a signal, and then examining what happens when
you extend this fit beyond those three points into the points nearby.&lt;/p&gt;

&lt;p&gt;As with any
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolation&lt;/a&gt;
problem, we’ll start with a signal, &lt;code class=&quot;highlighter-rouge&quot;&gt;x[n]&lt;/code&gt;.  I’ll
use the square brackets, &lt;code class=&quot;highlighter-rouge&quot;&gt;[]&lt;/code&gt;, to emphasize that this is a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;sampled signal&lt;/a&gt;
and hence only integer indices are allowed.  From this
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;sampled signal&lt;/a&gt;,
our goal will be to create a new signal, &lt;code class=&quot;highlighter-rouge&quot;&gt;y(t)&lt;/code&gt;, with a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Continuous_function&quot;&gt;continuous&lt;/a&gt;
index, &lt;code class=&quot;highlighter-rouge&quot;&gt;t&lt;/code&gt;–herein noted by the parentheses, &lt;code class=&quot;highlighter-rouge&quot;&gt;()&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;To create a quadratic fit, well pick three points from this signal,
&lt;code class=&quot;highlighter-rouge&quot;&gt;x[n-1]&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;x[n]&lt;/code&gt;, and &lt;code class=&quot;highlighter-rouge&quot;&gt;x[n+1]&lt;/code&gt;, and then fit a quadratic function, &lt;code class=&quot;highlighter-rouge&quot;&gt;f_n(t)&lt;/code&gt;
to these three points so that:&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/quadeqn-fit-genquad.png&quot; alt=&quot;f_n(t-n) = a(t-n)^2 + b(t-n) + c&quot; width=&quot;599&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Further, if we assume that our
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;samples&lt;/a&gt;
are spaced one unit apart, then&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/quadeqn-fit-triplet.png&quot; alt=&quot;&quot; width=&quot;203&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;The constant term of this quadratic
&lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial&quot;&gt;polynomial&lt;/a&gt;
is very simple to solve.  If we examine &lt;code class=&quot;highlighter-rouge&quot;&gt;t=n&lt;/code&gt;, then,&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/quadeqn-fit-fzero.png&quot; alt=&quot;f_0(0) = a(0)+b(0)+c&quot; width=&quot;418&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;The linear term is just a bit harder, but it can be obtained by subtracting
&lt;code class=&quot;highlighter-rouge&quot;&gt;f_n(-1)&lt;/code&gt; from &lt;code class=&quot;highlighter-rouge&quot;&gt;f_n(1)&lt;/code&gt;,&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/quadeqn-fit-fsub.png&quot; alt=&quot;&quot; width=&quot;605&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;In other words,&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/quadeqn-fit-b.png&quot; alt=&quot;&quot; width=&quot;296&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Getting the last coefficient is just a little bit more work, but follows from
adding the two end point values, &lt;code class=&quot;highlighter-rouge&quot;&gt;f_n(1)&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;f_n(-1)&lt;/code&gt; together,&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/quadeqn-fit-fsum.png&quot; alt=&quot;&quot; width=&quot;531&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;This yields our quadratic coefficint,&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/quadeqn-fit-a.png&quot; alt=&quot;&quot; width=&quot;367&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Therefore, we can fit any three
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;sample&lt;/a&gt;
values to the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial&quot;&gt;polynomial&lt;/a&gt;,&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/quadeqn-fit-complete.png&quot; alt=&quot;&quot; width=&quot;632&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Fig 1 shows an example of one such fit.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 1. An example quadratic fit of three points&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/quadeqn-fit-result.png&quot; alt=&quot;&quot; width=&quot;410&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;At first glance, this looks pretty good.  We started with three data points,
and now we’ve created a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Continuous_function&quot;&gt;continuous&lt;/a&gt;
line that smoothly
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolates&lt;/a&gt;
between these three data points.  What could the problem be?&lt;/p&gt;

&lt;p&gt;The problem comes into play when you expand out from these three data points
and examine the infinite set of
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;samples&lt;/a&gt;
that are the incoming data.  In this case, the quadratic fit turns from a nice
&lt;a href=&quot;https://en.wikipedia.org/wiki/Continuous_function&quot;&gt;continuous&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;,
to discontinuous
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;,
where the discontinuity takes place halfway between any pair of
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;samples&lt;/a&gt;.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 2. Using a quadratic fit across multiple sample points create discontinuities&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/interpolation-discontinuous-quadratic.png&quot; alt=&quot;&quot; width=&quot;603&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;What happened?&lt;/p&gt;

&lt;p&gt;What happened was that we chose to only use &lt;code class=&quot;highlighter-rouge&quot;&gt;f_n&lt;/code&gt; between &lt;code class=&quot;highlighter-rouge&quot;&gt;n-1/2&lt;/code&gt; and
&lt;code class=&quot;highlighter-rouge&quot;&gt;n+1/2&lt;/code&gt;.  Once past &lt;code class=&quot;highlighter-rouge&quot;&gt;n+1/2&lt;/code&gt;, we switched to a new
&lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial&quot;&gt;polynomial&lt;/a&gt;,
&lt;code class=&quot;highlighter-rouge&quot;&gt;f_{n+1}&lt;/code&gt;.  Since we did nothing to constrain our
&lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial&quot;&gt;polynomial&lt;/a&gt;
solution so that it was
&lt;a href=&quot;https://en.wikipedia.org/wiki/Continuous_function&quot;&gt;continuous&lt;/a&gt;
between data sets, the result wasn’t
&lt;a href=&quot;https://en.wikipedia.org/wiki/Continuous_function&quot;&gt;continuous&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Before going further, let’s consider my previous statement that “&lt;a href=&quot;/dsp/2018/01/16/interpolation-is-convolution.html&quot;&gt;Interpolation
is just a special type of
convolution&lt;/a&gt;.”
Why?  Because if you can understand this quadratic
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt; as just a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Convolution&quot;&gt;convolution&lt;/a&gt;
of your data with a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Continuous_function&quot;&gt;continuous function&lt;/a&gt;,&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/interp-is-convolution.png&quot; alt=&quot;&quot; width=&quot;275&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;then we can plot the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency_response&quot;&gt;frequency response&lt;/a&gt;
of this
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;.
Knowing that
&lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency_response&quot;&gt;frequency response&lt;/a&gt;
will allow us, further on, to compare  this quadratic fit
with other alternative quadratic
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolators&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;To see how this fits into the form of a filter’s
&lt;a href=&quot;https://en.wikipedia.org/wiki/Impulse_response&quot;&gt;impulse response&lt;/a&gt;, let’s
examine what happens when this
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;
is applied to an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Kronecker_delta&quot;&gt;impulse&lt;/a&gt;.
If we allow &lt;code class=&quot;highlighter-rouge&quot;&gt;x[n]&lt;/code&gt; to be a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Kronecker_delta&quot;&gt;Kronecker delta function&lt;/a&gt;,
where &lt;code class=&quot;highlighter-rouge&quot;&gt;x[n]=0&lt;/code&gt; for all &lt;code class=&quot;highlighter-rouge&quot;&gt;n&lt;/code&gt; save for &lt;code class=&quot;highlighter-rouge&quot;&gt;x[0]=1&lt;/code&gt;, then the result of applying
this quadratic fit to this
&lt;a href=&quot;https://en.wikipedia.org/wiki/Kronecker_delta&quot;&gt;sequence&lt;/a&gt;
will be the &lt;a href=&quot;https://en.wikipedia.org/wiki/Impulse_response&quot;&gt;impulse
response&lt;/a&gt;
of this &lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;.  Let’s do
that now.&lt;/p&gt;

&lt;p&gt;First, &lt;code class=&quot;highlighter-rouge&quot;&gt;f_{-1}(t+1)&lt;/code&gt; will
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;sample&lt;/a&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;x[0]=1&lt;/code&gt; in it’s &lt;code class=&quot;highlighter-rouge&quot;&gt;n+1&lt;/code&gt; term, yielding the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial&quot;&gt;polynomial&lt;/a&gt;,&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/quadeqn-fit-impulse-neg.png&quot; alt=&quot;&quot; width=&quot;354&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Likewise, &lt;code class=&quot;highlighter-rouge&quot;&gt;f_{0}(t)&lt;/code&gt; will
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;sample&lt;/a&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;x[0]=1&lt;/code&gt; in it’s &lt;code class=&quot;highlighter-rouge&quot;&gt;n&lt;/code&gt; term, yielding,&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/quadeqn-fit-impulse-zero.png&quot; alt=&quot;&quot; width=&quot;175&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Next, the &lt;code class=&quot;highlighter-rouge&quot;&gt;f_{1}(t)&lt;/code&gt; term will
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;sample&lt;/a&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;x[0]=1&lt;/code&gt; in it’s &lt;code class=&quot;highlighter-rouge&quot;&gt;n-1&lt;/code&gt; term, giving us
our final &lt;a href=&quot;https://en.wikipedia.org/wiki/Piecewise&quot;&gt;piecewise&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial&quot;&gt;polynomial&lt;/a&gt; component,&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/quadeqn-fit-impulse-pos.png&quot; alt=&quot;&quot; width=&quot;341&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Put together, you can see this
&lt;a href=&quot;https://en.wikipedia.org/wiki/Piecewise&quot;&gt;piecewise&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial&quot;&gt;polynomial&lt;/a&gt;
plotted out in Fig 3.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 3. Impulse response of a Quadratic Fit Interpolator&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/interpolation-fig-qfit.png&quot; alt=&quot;&quot; width=&quot;325&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;See what happened?  This
&lt;a href=&quot;https://en.wikipedia.org/wiki/Impulse_response&quot;&gt;impulse response&lt;/a&gt; isn’t
&lt;a href=&quot;https://en.wikipedia.org/wiki/Continuous_function&quot;&gt;continuous&lt;/a&gt;
at all!  This is the reason why our
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolated&lt;/a&gt;
signal wasn’t &lt;a href=&quot;https://en.wikipedia.org/wiki/Continuous_function&quot;&gt;continuous&lt;/a&gt;
either.&lt;/p&gt;

&lt;p&gt;Further, it only takes some basic integral calculus to plot the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency_response&quot;&gt;frequency response&lt;/a&gt;
of this function in Fig 4.  (I’ll spare you the calculation–while basic,
it isn’t pretty.)&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 4. Fourier Transform of a Quadratic Fit&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/interpolation-fig-qfit-H.png&quot; alt=&quot;&quot; width=&quot;325&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;The gray line in Fig 4 is proportional to &lt;code class=&quot;highlighter-rouge&quot;&gt;1/f&lt;/code&gt;, showing how this
&lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency_response&quot;&gt;frequency response&lt;/a&gt;
only slowly converges towards zero as &lt;code class=&quot;highlighter-rouge&quot;&gt;f&lt;/code&gt; goes to infinity.  This is the
consequence of the discontinuities in the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Impulse_response&quot;&gt;impulse response&lt;/a&gt;
of this fit.&lt;/p&gt;

&lt;p&gt;Now that you see the problem with using a simple quadratic fit as an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;,
let’s see if we can do better.&lt;/p&gt;

&lt;h2 id=&quot;a-better-interpolator&quot;&gt;A Better Interpolator&lt;/h2&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 5. A Piecewise Polynomial&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/interpolation-piecewise-poly.png&quot; alt=&quot;&quot; width=&quot;278&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Now that we know what can go wrong with a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Piecewise&quot;&gt;piecewise&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial&quot;&gt;polynomial&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;,
it’s time to return to where we left off in our &lt;a href=&quot;/dsp/2018/01/16/interpolation-is-convolution.html&quot;&gt;prior
post&lt;/a&gt;
on this topic, and use the principles we developed there to develop
a better &lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;.
In that post, we showed that all
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolators&lt;/a&gt;
that met a minimum set of problem related assumptions have the form of a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Piecewise&quot;&gt;piecewise&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial&quot;&gt;polynomial&lt;/a&gt;,
such as is shown in Fig 5.&lt;/p&gt;

&lt;p&gt;Further, &lt;a href=&quot;/dsp/2018/01/16/interpolation-is-convolution.html&quot;&gt;we pointed
out&lt;/a&gt;
that an &lt;code class=&quot;highlighter-rouge&quot;&gt;h(t)&lt;/code&gt; function that is given by a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Piecewise&quot;&gt;piecewise&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial&quot;&gt;polynomial&lt;/a&gt;,
such as the one shown in Fig 5, can be a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Linear_system&quot;&gt;linear&lt;/a&gt;,
discrete shift invariant,
&lt;a href=&quot;https://en.wikipedia.org/wiki/Upsamplers&quot;&gt;upsampler&lt;/a&gt;.
In Fig 5, you can see separate regions of an example filter, &lt;code class=&quot;highlighter-rouge&quot;&gt;h(t)&lt;/code&gt;, shown
in separate colors.  Each colored region represents a separate quadratic
&lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial&quot;&gt;polynomial&lt;/a&gt;.  Our goal will be
to try to use some criteria to create a useful set of
&lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial&quot;&gt;polynomials&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;As a first step to building our own, let’s define our component
&lt;a href=&quot;https://en.wikipedia.org/wiki/Piecewise&quot;&gt;piecewise&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial&quot;&gt;polynomials&lt;/a&gt; as,&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/quadeqn-nfit-piecewise-eqn.png&quot; alt=&quot;&quot; width=&quot;818&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;That is to say, we’re going to look for a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Piecewise&quot;&gt;piecewise&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial&quot;&gt;polynomials&lt;/a&gt;
function, &lt;code class=&quot;highlighter-rouge&quot;&gt;h(t)&lt;/code&gt;, defined by the equations,&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/quadeqn-criteria-eqn-defns.png&quot; alt=&quot;&quot; width=&quot;666&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Why only five intervals?  This is an arbitrary choice.
There’s no hard and fast rule here.  More intervals or a higher
&lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial&quot;&gt;polynomial&lt;/a&gt;
degree might produce a better filter, but one that will cost more logic to
calculate.  Such longer filters can be the topic for another
discussion on another day.  I do know that this setup will yield a nicely
implementable solution ultimately requiring only two RTL multiplies.&lt;/p&gt;

&lt;p&gt;Two multiplies you ask?  What about all those arbitrary coefficients in &lt;code class=&quot;highlighter-rouge&quot;&gt;h(t)&lt;/code&gt;?
Hang on, we’ll get there.&lt;/p&gt;

&lt;p&gt;Why is there no &lt;code class=&quot;highlighter-rouge&quot;&gt;b&lt;/code&gt; coefficient for the middle interval?  Or, equivalently,
why are the &lt;code class=&quot;highlighter-rouge&quot;&gt;*_1&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;*_2&lt;/code&gt; coefficients repeated?  Because I have chosen a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Linear_phase&quot;&gt;symmetric&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolation&lt;/a&gt;
filter, in the hopes of achieving a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Linear_phase&quot;&gt;linear phase&lt;/a&gt;
result.  Further, I’ve started this derivation often enough without
pre-specifying these certain coefficients, and I end up specifying
them via equations anyway.  By doing it this way, it just reduces the
number of coefficients we’ll need to solve for from the beginning.&lt;/p&gt;

&lt;p&gt;To get to our result, all that remains is to determine the coefficients of the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Piecewise&quot;&gt;piecewise&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial&quot;&gt;polynomials&lt;/a&gt;
in our chosen filter.  To do this, we’ll use some (rather ad-hoc) criteria to
set up a system of linear equations to yield the as yet unknown coefficients.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;Interpolator&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Our first criteria for &lt;code class=&quot;highlighter-rouge&quot;&gt;h(t)&lt;/code&gt; is that the resulting waveform needs to
   &lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolate&lt;/a&gt;
   the incoming waveform.  In other words, whenever &lt;code class=&quot;highlighter-rouge&quot;&gt;t&lt;/code&gt; is
   an integer, the output value should equal the input.  That is, if &lt;code class=&quot;highlighter-rouge&quot;&gt;t=n&lt;/code&gt;
   then &lt;code class=&quot;highlighter-rouge&quot;&gt;y(n) = x[n]&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;If we work this from the equation standpoint,&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/interp-is-convolution.png&quot; alt=&quot;&quot; width=&quot;275&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p style=&quot;list-style-type: none;&quot;&gt;you can see that if &lt;code class=&quot;highlighter-rouge&quot;&gt;t=n&lt;/code&gt; then &lt;code class=&quot;highlighter-rouge&quot;&gt;y(n)&lt;/code&gt; is composed of a summation across
   several &lt;code class=&quot;highlighter-rouge&quot;&gt;h(t)&lt;/code&gt;
   values, each with the index &lt;code class=&quot;highlighter-rouge&quot;&gt;n-k&lt;/code&gt;.  Further, when &lt;code class=&quot;highlighter-rouge&quot;&gt;n=k&lt;/code&gt; we get the one
   component we want, and all of the other components will just pull us off in
   one direction or another.  Hence, we need to insist that,&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/quadeqn-criteria-interpolator.png&quot; alt=&quot;&quot; width=&quot;364&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 6. An interpolating filter must go through zero for all integers but zero&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/quadeqn-criteria-interpolator-dots.png&quot; alt=&quot;&quot; width=&quot;325&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;This means that every one of our
&lt;a href=&quot;https://en.wikipedia.org/wiki/Piecewise&quot;&gt;piecewise&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial&quot;&gt;polynomial&lt;/a&gt; component
functions, save the one in the center, will need to go through zero
near the integer within it, as shown in Fig 6.  The point in the center,
on the other hand, will need to pass through &lt;code class=&quot;highlighter-rouge&quot;&gt;y=1&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;It shouldn’t take too much work to see that our set of
&lt;a href=&quot;https://en.wikipedia.org/wiki/Piecewise&quot;&gt;piecewise&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial&quot;&gt;polynomial&lt;/a&gt; will
meet this criteria if we simply set &lt;code class=&quot;highlighter-rouge&quot;&gt;c_1&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;c_2&lt;/code&gt; to be zero.  Indeed,
this is the reason why it was constructed it based upon &lt;code class=&quot;highlighter-rouge&quot;&gt;t-n&lt;/code&gt; terms in the
first place.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;DSP Guru Meditation&lt;/strong&gt;: It can be shown that if &lt;code class=&quot;highlighter-rouge&quot;&gt;h(n)&lt;/code&gt; is a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Kronecker_delta&quot;&gt;Kronecker Delta function&lt;/a&gt;,
then it must also be true that,&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/quadeqn-criteria-interpolator-guru-1.png&quot; alt=&quot;&quot; width=&quot;213&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;or, equivalently,&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/quadeqn-criteria-interpolator-guru-2.png&quot; alt=&quot;&quot; width=&quot;330&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;This, plus the fact that &lt;code class=&quot;highlighter-rouge&quot;&gt;h(t)&lt;/code&gt; is real, forces the awkward reality
that &lt;code class=&quot;highlighter-rouge&quot;&gt;H(1/2)&lt;/code&gt; &lt;em&gt;must be&lt;/em&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;1/2&lt;/code&gt; as well for all practical
&lt;a href=&quot;https://en.wikipedia.org/wiki/Low-pass_filter&quot;&gt;low-pass&lt;/a&gt;
filters.  Hence, this criteria alone forces the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Passband&quot;&gt;passband&lt;/a&gt; and
&lt;a href=&quot;https://en.wikipedia.org/wiki/Stopband&quot;&gt;stopband&lt;/a&gt;
cutoff frequencies of any
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;
to be &lt;code class=&quot;highlighter-rouge&quot;&gt;f=1/2&lt;/code&gt;.  This is a somewhat unfortunate limitation on the
performance that might be achieved using this approach.&lt;/p&gt;

&lt;p&gt;This criteria is also a point of separation from
&lt;a href=&quot;http://ieeexplore.ieee.org/document/15483/&quot;&gt;Farrow&lt;/a&gt;’s work, since
&lt;a href=&quot;http://ieeexplore.ieee.org/document/15483/&quot;&gt;Farrow&lt;/a&gt; never insisted that the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sample-rate_conversion&quot;&gt;resamplers&lt;/a&gt;
he developed went through the original
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;sample&lt;/a&gt;
points.&lt;/p&gt;

&lt;ol start=&quot;2&quot;&gt;
  &lt;li&gt;&lt;strong&gt;Constant -&amp;gt; Constant&lt;/strong&gt;: &lt;code class=&quot;highlighter-rouge&quot;&gt;x[n]=c&lt;/code&gt; implies &lt;code class=&quot;highlighter-rouge&quot;&gt;y(t)=c&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;When I built my first
&lt;a href=&quot;http://ieeexplore.ieee.org/document/15483/&quot;&gt;Farrow&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolation&lt;/a&gt;
filter
from a quadratic
&lt;a href=&quot;https://en.wikipedia.org/wiki/Piecewise&quot;&gt;piecewise&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial&quot;&gt;polynomial&lt;/a&gt;,
I was surprised to discover that a constant input to my filter was producing
a non-constant output.  Instead, there was a small but repeating quadratic
component.  How could this to happen?!  How could I call this an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;, if the
resulting
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolated&lt;/a&gt; waveform
didn’t smoothly go through the given points?&lt;/p&gt;

&lt;p&gt;So I then went back to my equations for &lt;code class=&quot;highlighter-rouge&quot;&gt;h(t)&lt;/code&gt; and the coefficients of the
component &lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial&quot;&gt;polynomials&lt;/a&gt;, 
and rebuilt them to insist that if &lt;code class=&quot;highlighter-rouge&quot;&gt;x[n]&lt;/code&gt; is the constant &lt;code class=&quot;highlighter-rouge&quot;&gt;c&lt;/code&gt;, then
&lt;code class=&quot;highlighter-rouge&quot;&gt;y(t)&lt;/code&gt; should equal that same constant &lt;code class=&quot;highlighter-rouge&quot;&gt;c&lt;/code&gt; as well.&lt;/p&gt;

&lt;p&gt;Let’s do that here.  With just a little manipulation, you’ll see that,&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/quadeqn-criteria-const-deriv.png&quot; alt=&quot;&quot; width=&quot;330&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Hence, we’ll want&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/quadeqn-criteria-const.png&quot; alt=&quot;&quot; width=&quot;375&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;for all possible values of &lt;code class=&quot;highlighter-rouge&quot;&gt;t&lt;/code&gt; between &lt;code class=&quot;highlighter-rouge&quot;&gt;-1/2&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;1/2&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;We can apply this criteria to our
&lt;a href=&quot;https://en.wikipedia.org/wiki/Piecewise&quot;&gt;piecewise&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial&quot;&gt;polynomial&lt;/a&gt;
filter without too much hassle.  I’ll spare you the gory details, although
you should know that the result is a set of equations further constraining our
&lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial&quot;&gt;polynomial&lt;/a&gt; coefficients.&lt;/p&gt;

&lt;p&gt;If we continue solving for our eight coefficients,
we’ll still need some more equations.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 7. The frequency response of a linear interpolator, showing a zero response for all integer frequencies but zero&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/quadeqn-criteria-const-H.png&quot; alt=&quot;&quot; width=&quot;378&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;&lt;strong&gt;DSP Guru Meditation&lt;/strong&gt;:
If you examine this property in
&lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency_response&quot;&gt;frequency&lt;/a&gt;,
it forces a unique and very desirable property upon the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolating&lt;/a&gt;
filter’s
&lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency_response&quot;&gt;frequency response&lt;/a&gt;.
In particular, the &lt;a href=&quot;https://en.wikipedia.org/wiki/Fourier_transform&quot;&gt;Fourier
transform&lt;/a&gt; of a constant
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;sampled&lt;/a&gt;
input has a component at &lt;code class=&quot;highlighter-rouge&quot;&gt;X(e^{j0})&lt;/code&gt; only, with &lt;code class=&quot;highlighter-rouge&quot;&gt;X(e^{j2pi f})=c delta(f)&lt;/code&gt;,
where &lt;code class=&quot;highlighter-rouge&quot;&gt;delta(f)&lt;/code&gt; is the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Dirac_delta_function&quot;&gt;Dirac delta function&lt;/a&gt;.
This would normally create aliasing components at frequencies &lt;code class=&quot;highlighter-rouge&quot;&gt;X(e^{j2pi m})&lt;/code&gt;
for all integers &lt;code class=&quot;highlighter-rouge&quot;&gt;m&lt;/code&gt; as well.  However, we just insisted that for a constant
input, the &lt;a href=&quot;https://en.wikipedia.org/wiki/Fourier_transform&quot;&gt;Fourier
transform&lt;/a&gt; of the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Continuous_function&quot;&gt;continuous&lt;/a&gt;
output function was to have a component at zero only.  Hence, we know that
&lt;code class=&quot;highlighter-rouge&quot;&gt;X(e^{j2pi f})H(f)&lt;/code&gt; must be nonzero for &lt;code class=&quot;highlighter-rouge&quot;&gt;f=0&lt;/code&gt;, and so we now know that
&lt;code class=&quot;highlighter-rouge&quot;&gt;H(0)=1&lt;/code&gt;.  We also know that &lt;code class=&quot;highlighter-rouge&quot;&gt;H(m)&lt;/code&gt; must be zero for all integers &lt;code class=&quot;highlighter-rouge&quot;&gt;m!=0&lt;/code&gt;,
&lt;code class=&quot;highlighter-rouge&quot;&gt;H(m)=0&lt;/code&gt;–just like a &lt;a href=&quot;https://en.wikipedia.org/wiki/Sinc_funtion&quot;&gt;sinc
function&lt;/a&gt; although other
functions can have this property as well.&lt;/p&gt;

&lt;p&gt;You can see this property shown in Fig 7 on the right.&lt;/p&gt;

&lt;ol start=&quot;3&quot;&gt;
  &lt;li&gt;&lt;strong&gt;Linear -&amp;gt; Linear&lt;/strong&gt;: &lt;code class=&quot;highlighter-rouge&quot;&gt;x[n] = n&lt;/code&gt; implies &lt;code class=&quot;highlighter-rouge&quot;&gt;y(t)=t&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Let’s follow that last criteria a bit further.  Instead of just insisting
that every constant produce a constant signal output, we can also insist
that every linear input produce a linear output.  Hence, if &lt;code class=&quot;highlighter-rouge&quot;&gt;x[n]=n&lt;/code&gt;,
then &lt;code class=&quot;highlighter-rouge&quot;&gt;y(t)&lt;/code&gt; should equal &lt;code class=&quot;highlighter-rouge&quot;&gt;t&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;As with our last criteria, we’ll apply our input, &lt;code class=&quot;highlighter-rouge&quot;&gt;x[n]=n&lt;/code&gt;, and then
insist that the result contains no &lt;code class=&quot;highlighter-rouge&quot;&gt;t^2&lt;/code&gt; terms.  (We already know it will
contain no constant terms.)&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 8. Constraining performance under linear inputs constrains the slope of the frequency response&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/quadeqn-criteria-const-Hdot.png&quot; alt=&quot;&quot; width=&quot;386&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;This will give us another linear constraint on our coefficients.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;DSP Guru Meditation&lt;/strong&gt;:
If you examine this criteria in
&lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency_response&quot;&gt;frequency&lt;/a&gt;, it basically
forces the slope of &lt;code class=&quot;highlighter-rouge&quot;&gt;H(m)&lt;/code&gt; to be zero for integers &lt;code class=&quot;highlighter-rouge&quot;&gt;m&lt;/code&gt;.  To be effective,
this criteria is dependent upon the constant criteria described above.&lt;/p&gt;

&lt;p&gt;This constraint therefore not only increases the width of our pass band,
but it also increases the depth of the nulls.&lt;/p&gt;

&lt;ol start=&quot;4&quot;&gt;
  &lt;li&gt;&lt;strong&gt;Quadratic -&amp;gt; Quadratic&lt;/strong&gt;: &lt;code class=&quot;highlighter-rouge&quot;&gt;x[n] = n^2&lt;/code&gt; implies &lt;code class=&quot;highlighter-rouge&quot;&gt;y(t)=t^2&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;For our fourth criteria, we’ll insist that if &lt;code class=&quot;highlighter-rouge&quot;&gt;x[n]=n^2&lt;/code&gt; then &lt;code class=&quot;highlighter-rouge&quot;&gt;y(t)&lt;/code&gt; should
equal &lt;code class=&quot;highlighter-rouge&quot;&gt;t^2&lt;/code&gt;.  In many ways this is similar to the linear criteria above.
As with the linear criteria, this also provides us with another equation
to add to the system of equations we are building to solve for &lt;code class=&quot;highlighter-rouge&quot;&gt;h(t)&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;DSP Guru Meditation&lt;/strong&gt;: This criteria constrains the second derivative of
the &lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency_response&quot;&gt;frequency response&lt;/a&gt;
near both &lt;code class=&quot;highlighter-rouge&quot;&gt;f=m&lt;/code&gt; for all integer frequencies &lt;code class=&quot;highlighter-rouge&quot;&gt;m&lt;/code&gt;, thus also widening our
passband, as well as the width of the nulls in the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency_response&quot;&gt;frequency response&lt;/a&gt;.
As a result, this criteria only intensifies our last constraint.&lt;/p&gt;

&lt;ol start=&quot;5&quot;&gt;
  &lt;li&gt;&lt;strong&gt;Continuous&lt;/strong&gt;: &lt;img src=&quot;/img/quadeqn-criteria-continuous.png&quot; width=&quot;233&quot; /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;As a final set of criteria, we’ll insist that our
&lt;a href=&quot;https://en.wikipedia.org/wiki/Piecewise&quot;&gt;piecewise&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial&quot;&gt;polynomial&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Impulse_response&quot;&gt;impulse response&lt;/a&gt; be
&lt;a href=&quot;https://en.wikipedia.org/wiki/Continuous_function&quot;&gt;continuous&lt;/a&gt;.
Hence, the &lt;code class=&quot;highlighter-rouge&quot;&gt;h(t)&lt;/code&gt; function must be
&lt;a href=&quot;https://en.wikipedia.org/wiki/Continuous_function&quot;&gt;continuous&lt;/a&gt;
at its seams: &lt;code class=&quot;highlighter-rouge&quot;&gt;t=-5/2&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;t=-3/2&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;t=-1/2&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;t=1/2&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;t=3/2&lt;/code&gt;, and &lt;code class=&quot;highlighter-rouge&quot;&gt;t=5/2&lt;/code&gt;.
However, since we constrained our
&lt;a href=&quot;https://en.wikipedia.org/wiki/Piecewise&quot;&gt;piecewise&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial&quot;&gt;polynomial&lt;/a&gt; to be
&lt;a href=&quot;https://en.wikipedia.org/wiki/Linear_phase&quot;&gt;symmetric&lt;/a&gt;
in time, we really only need to deal with half of those &lt;code class=&quot;highlighter-rouge&quot;&gt;t&lt;/code&gt; values.&lt;/p&gt;

&lt;p&gt;Because any linear combination of
&lt;a href=&quot;https://en.wikipedia.org/wiki/Continuous_function&quot;&gt;continuous functions&lt;/a&gt;
is also
&lt;a href=&quot;https://en.wikipedia.org/wiki/Continuous_function&quot;&gt;continuous&lt;/a&gt;,
&lt;code class=&quot;highlighter-rouge&quot;&gt;y(t)&lt;/code&gt; will be
&lt;a href=&quot;https://en.wikipedia.org/wiki/Continuous_function&quot;&gt;continuous&lt;/a&gt;
any time &lt;code class=&quot;highlighter-rouge&quot;&gt;h(t)&lt;/code&gt; is
&lt;a href=&quot;https://en.wikipedia.org/wiki/Continuous_function&quot;&gt;continuous&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;There’s an even more important consequence of this ad-hoc criteria: any
&lt;a href=&quot;https://en.wikipedia.org/wiki/Continuous_function&quot;&gt;continuous function&lt;/a&gt;
will have a &lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency_response&quot;&gt;frequency
response&lt;/a&gt;.
with an asymptotic decay proportional to &lt;code class=&quot;highlighter-rouge&quot;&gt;1/f^2&lt;/code&gt; or better.  This function
is no different.  Hence, when you put all of our constraints together, we’ve
now constrained the zero frequency, &lt;code class=&quot;highlighter-rouge&quot;&gt;f=0&lt;/code&gt;, and the first and second
derivatives of all integer frequencies.  By now insisting on a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Continuous_function&quot;&gt;continuous&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Impulse_response&quot;&gt;impulse response&lt;/a&gt;,
we’ve also constrained the asymptotic &lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency_response&quot;&gt;frequency
response&lt;/a&gt; of this
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolating&lt;/a&gt;
filter as well.&lt;/p&gt;

&lt;p&gt;In other words, we’ve just created an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolating&lt;/a&gt;
function with a very nice
&lt;a href=&quot;https://en.wikipedia.org/wiki/Low-pass_filter&quot;&gt;low-pass&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency_response&quot;&gt;frequency response&lt;/a&gt;–it
just doesn’t have a very narrow
&lt;a href=&quot;https://en.wikipedia.org/wiki/Transition_band&quot;&gt;transition band&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;DSP Guru Meditation&lt;/strong&gt;: I will contend, based more upon frustration then
proof, that it is actually impossible to create a finite quadratic
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolating&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial&quot;&gt;polynomial&lt;/a&gt; via this method that
will be &lt;a href=&quot;https://en.wikipedia.org/wiki/Continuous_function&quot;&gt;continuous&lt;/a&gt; in
its first derivative.  Before you jump to disprove me, remember my definition
of an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolating&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial&quot;&gt;polynomial&lt;/a&gt;, which requires that it
equal zero at all integer locations but zero.  Were we able to create such a
function, it would have an out of band asymptotic decay rate of &lt;code class=&quot;highlighter-rouge&quot;&gt;1/f^3&lt;/code&gt;–but
we’ll leave the discussion of such functions for a later discussion of either
higher order &lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolators&lt;/a&gt;,
or quadratic &lt;a href=&quot;https://en.wikipedia.org/wiki/Spline_interpolation&quot;&gt;splines&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;As an aside, it is possible to formulate the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Spline_interpolation&quot;&gt;splines&lt;/a&gt; problem in &lt;a href=&quot;/dsp/2018/01/16/interpolation-is-convolution.html&quot;&gt;this
fashion&lt;/a&gt;.
Doing so produces a solution that no longer requires solving for the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Piecewise&quot;&gt;piecewise&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial&quot;&gt;polynomial&lt;/a&gt; to be
coefficients at every step, while yielding a cleaner and (slightly) wider
&lt;a href=&quot;https://en.wikipedia.org/wiki/Passband&quot;&gt;passband&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;If you put all of the resulting equations together, for the constraints outlined
above, you will get an over-determined system.  This over determined system
will include several redundant equations which can be easily removed.  Once
the redundant equations are removed, you will then get the system
of linear equations below.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/quadeqn-criteria-eqns.png&quot; alt=&quot;&quot; width=&quot;441&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;In spite of starting with an over determined system in this process, we got
lucky: the system above has a unique solution given by,&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/quadeqn-criteria-soln.png&quot; alt=&quot;&quot; width=&quot;233&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Wow, that was a lot of work to just get a bunch of numbers.  So what,
right?  What’s the use of these five values?&lt;/p&gt;

&lt;p&gt;The value of this solution is seen in the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Impulse_response&quot;&gt;impulse response&lt;/a&gt; and
&lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency_response&quot;&gt;frequency response&lt;/a&gt;
shown in Fig 9.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 9. Impulse response (left) and Frequency Response (right) of this piecewise polynomial interpolator&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/interpolation-fig-betterq.png&quot; alt=&quot;&quot; width=&quot;728&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;As we required, the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Passband&quot;&gt;passband&lt;/a&gt; and
is “flat” near &lt;code class=&quot;highlighter-rouge&quot;&gt;f=0&lt;/code&gt;, and the nulls are deep.
Unlike both the &lt;a href=&quot;/dsp/2017/06/06/simple-interpolator.html&quot;&gt;nearest neighbor
interpolator&lt;/a&gt;
and the quadratic fit we
discussed above, the asymptotic fall off of this filter is proportional to
&lt;code class=&quot;highlighter-rouge&quot;&gt;1/f^2&lt;/code&gt;.  Further, unlike the &lt;a href=&quot;/dsp/2017/07/29/series-linear-interpolation.html&quot;&gt;linear interpolator we built
earlier&lt;/a&gt;
which also has an asymptotic fall off of &lt;code class=&quot;highlighter-rouge&quot;&gt;1/f^2&lt;/code&gt;, this
asymptotic fall off has a smaller proportionality coefficient of &lt;code class=&quot;highlighter-rouge&quot;&gt;1/f^2&lt;/code&gt;.
For comparison, consider Fix 7 above showing the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency_response&quot;&gt;frequency response&lt;/a&gt;
of the &lt;a href=&quot;/dsp/2017/07/29/series-linear-interpolation.html&quot;&gt;linear
interpolator&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;In other words, this quadratic
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt; forms a &lt;em&gt;nice&lt;/em&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Piecewise&quot;&gt;piecewise&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial&quot;&gt;polynomial&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolation&lt;/a&gt;
filter.&lt;/p&gt;

&lt;p&gt;Even better, with some careful coding (below) we can implement the coefficient
multiplication with only adds and subtracts.  This will mean that we can
evaluate this &lt;a href=&quot;https://github.com/ZipCPU/interpolation/blob/master/rtl/quadratic/quadinterp.v&quot;&gt;quadratic in
Verilog&lt;/a&gt;
using only two hardware multiplies–minimizing a precious resource found within
any digital logic component.&lt;/p&gt;

&lt;p&gt;Sadly, the development above is only an ad-hoc formulation.  While it
may be possible to truly generate &lt;em&gt;optimal&lt;/em&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolators&lt;/a&gt;
via this method, I have not yet pursued such a study in depth.&lt;/p&gt;

&lt;h2 id=&quot;three-interpolators-and-only-two-multiplies&quot;&gt;Three Interpolators and only Two Multiplies&lt;/h2&gt;

&lt;p&gt;In the next section, we’ll start discussing how to build the
&lt;a href=&quot;https://github.com/ZipCPU/interpolation/blob/master/rtl/quadratic/quadinterp.v&quot;&gt;Verilog code necessary to
implement&lt;/a&gt;
this &lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;.
Indeed, well even do one better than that: we’ll show
the Verilog code necessary to implement three separate quadratic
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolators&lt;/a&gt;–all with only
&lt;em&gt;two multiplies&lt;/em&gt;.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;The first &lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;
will be the one that results from the quadratic fit approach I was so
critical of above.  We’ll use this performance for reference below.  This
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;
is given by the equations we developed above:&lt;/li&gt;
&lt;/ol&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/quadeqn-fit-coeffs.png&quot; alt=&quot;&quot; width=&quot;367&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;As we discussed above, we can expect this
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;
to produce a discontinuous output waveform.&lt;/p&gt;

&lt;ol start=&quot;2&quot;&gt;
  &lt;li&gt;The second &lt;a href=&quot;https://en.wikipedia.org/wiki/Upsamplers&quot;&gt;upsampling&lt;/a&gt;
function may have the best &lt;a href=&quot;https://en.wikipedia.org/wiki/Stopband&quot;&gt;stopband&lt;/a&gt;
performance among all quadratic
&lt;a href=&quot;https://en.wikipedia.org/wiki/Upsamplers&quot;&gt;upsamplers&lt;/a&gt;, however it’s not a true
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;
since it doesn’t necessarily go through the original signal
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;sample&lt;/a&gt;
points.  We’ll call this the
non-&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;
for lack of a better term.  This
non-&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;
is a very valuable
&lt;a href=&quot;https://en.wikipedia.org/wiki/Upsamplers&quot;&gt;upsampling&lt;/a&gt;
function for the simple reason that its
&lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency_response&quot;&gt;frequency response&lt;/a&gt;
tail falls off faster (&lt;code class=&quot;highlighter-rouge&quot;&gt;1/f^3&lt;/code&gt;) than any other quadratic.  Indeed, it is
so valuable, that we may come back and use it to beat the performance of a
&lt;a href=&quot;/dsp/2017/08/30/cordic.html&quot;&gt;CORDIC&lt;/a&gt;–but
that will have to be the topic of a future article (it will still require
two multiples, something the
&lt;a href=&quot;/dsp/2017/08/30/cordic.html&quot;&gt;CORDIC&lt;/a&gt; doesn’t need).&lt;/li&gt;
&lt;/ol&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/quadeqn-cub-coeffs.png&quot; alt=&quot;&quot; width=&quot;383&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 11.  The impulse response of a rectangle convolved with itself three times&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/interpolation-fig-rcubd-impulse.png&quot; alt=&quot;&quot; width=&quot;325&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;This non-&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;
will not suffer from the discontinuities we discussed above.  Further, if you
are up to a calculus challenge, this function can be derived by
&lt;a href=&quot;https://en.wikipedia.org/wiki/Convolution&quot;&gt;convolving&lt;/a&gt; a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Rectangular_function&quot;&gt;rectangle function&lt;/a&gt;
with itself three separate times, hence its
&lt;a href=&quot;https://en.wikipedia.org/wiki/Impulse_response&quot;&gt;impulse response&lt;/a&gt;
is shown in Fig 11.&lt;/p&gt;

&lt;p&gt;One unique feature of this
&lt;a href=&quot;https://en.wikipedia.org/wiki/Upsamplers&quot;&gt;upsampler&lt;/a&gt;
is its properties when doing peak finding.  Indeed, peaks found following
this fit tend to be more accurately located than when using the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;
that is the topic of today’s development–but this again is a topic for
another day.&lt;/p&gt;

&lt;p&gt;Since the non-&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;’s
&lt;a href=&quot;https://en.wikipedia.org/wiki/Impulse_response&quot;&gt;impulse response&lt;/a&gt;
response is created by &lt;a href=&quot;https://en.wikipedia.org/wiki/Convolution&quot;&gt;convolving&lt;/a&gt; a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Rectangular_function&quot;&gt;rectangle function&lt;/a&gt;
with itself three separate times, its
&lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency_response&quot;&gt;frequency response&lt;/a&gt;
will be given by the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency_response&quot;&gt;frequency response&lt;/a&gt; of a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Rectangular_function&quot;&gt;rectangle function&lt;/a&gt;
cubed, or in other words by a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sinc_funtion&quot;&gt;sinc function&lt;/a&gt; cubed.&lt;/p&gt;

&lt;p&gt;Further, if you compare the coefficients of this
the non-&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;’s
&lt;a href=&quot;https://en.wikipedia.org/wiki/Impulse_response&quot;&gt;impulse response&lt;/a&gt;
with those of the quadratic fit (above), you’ll see that all but the
constant coefficients, &lt;code class=&quot;highlighter-rouge&quot;&gt;c_n&lt;/code&gt;, are identical.&lt;/p&gt;

&lt;p&gt;In &lt;a href=&quot;https://github.com/ZipCPU/interpolation/blob/master/rtl/quadratic/quadinterp.v&quot;&gt;our code&lt;/a&gt;
below, the parameter &lt;code class=&quot;highlighter-rouge&quot;&gt;OPT_IMPROVED_FIT&lt;/code&gt; will control whether or not this
non-&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolating&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Upsamplers&quot;&gt;upsampler&lt;/a&gt;
is generated or not.  If set, the traditional quadratic fit will be bypassed
for this alternative implementation.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;DSP Guru Meditation&lt;/strong&gt;: My statement above that the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency_response&quot;&gt;frequency response&lt;/a&gt;
tail of this filter asymptotically decays &lt;em&gt;faster than any other quadratic&lt;/em&gt;
isn’t quite true.  Quadratics filters composed of a linear combinations of
this filter function will also fall off at the &lt;code class=&quot;highlighter-rouge&quot;&gt;1/f^3&lt;/code&gt; rate … but we’ll
leave the further discussion of this approach to a future discussion of
quadratic (and/or cubic)
&lt;a href=&quot;https://en.wikipedia.org/wiki/Spline_interpolation&quot;&gt;splines&lt;/a&gt;, since that’s
where it is most relevant.&lt;/p&gt;

&lt;ol start=&quot;3&quot;&gt;
  &lt;li&gt;The third function we’ll implement is defined by the coefficient
equations we just developed in the last section above.&lt;/li&gt;
&lt;/ol&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/quadeqn-nfit-coeffs.png&quot; alt=&quot;&quot; width=&quot;675&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;This is the one we expect to see good results from–it is
&lt;a href=&quot;https://en.wikipedia.org/wiki/Continuous_function&quot;&gt;continuous&lt;/a&gt;,
and passes constants, lines, and quadratics without distortion.  Not
only that, the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;
generated by this function is guaranteed to go through the initial
&lt;code class=&quot;highlighter-rouge&quot;&gt;x[n]&lt;/code&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;sample&lt;/a&gt;
points given to it.&lt;/p&gt;

&lt;p&gt;The parameter &lt;code class=&quot;highlighter-rouge&quot;&gt;OPT_INTERPOLATOR&lt;/code&gt; in
&lt;a href=&quot;https://github.com/ZipCPU/interpolation/blob/master/rtl/quadratic/quadinterp.v&quot;&gt;our code below&lt;/a&gt;
will control whether or not this
implementation is used.  If set, &lt;code class=&quot;highlighter-rouge&quot;&gt;OPT_INTERPOLATOR&lt;/code&gt; will override the
&lt;code class=&quot;highlighter-rouge&quot;&gt;OPT_IMPROVED_FIT&lt;/code&gt; option parameter above, yielding an implementation of
this quadratic
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;We’ll use some careful coding techniques in the next section in order to
avoid using hardware multiplication elements when multiplying the quadratic
coefficients generated by the incoming data by these factors,
28, 16, 10, 3/4, etc.  The resulting algorithm will use only shifts and adds–up
until the final quadratic evaluation.  We will need to be careful
to make certain that we track the decimal point during this process though.&lt;/p&gt;

&lt;p&gt;When it comes to evaluating the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial&quot;&gt;polynomial&lt;/a&gt;
itself, if you’ve never implemented one numerically, then you should know
that there is a right and a wrong way to apply the multiply–a “trick” if you
will.  In particular, you don’t want to calculate your result by a
straight forward evaluation,&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/quadeqn-implementation-bad.png&quot; alt=&quot;&quot; width=&quot;243&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;This straight forward approach suffers from two problems.  The first problem is
that it costs three multiplies.  (Ouch!) The second problem is that this method
is susceptible to the loss of precision as the intermediate values are
truncated prior to their final addition.&lt;/p&gt;

&lt;p&gt;Instead, we’ll calculate this
&lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial&quot;&gt;polynomial&lt;/a&gt;’s
value based upon a different formulation:&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/quadeqn-implementation.png&quot; alt=&quot;&quot; width=&quot;217&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;This will solve both of these problems, yielding a nice solution suitable for
RTL implementation.&lt;/p&gt;

&lt;h2 id=&quot;fixed-point&quot;&gt;Fixed Point&lt;/h2&gt;

&lt;p&gt;Let’s pause for one more section before diving into
&lt;a href=&quot;https://github.com/ZipCPU/interpolation/blob/master/rtl/quadratic/quadinterp.v&quot;&gt;the code&lt;/a&gt;
below, to discuss how we are going to handle the evaluation of the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Piecewise&quot;&gt;piecewise&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial&quot;&gt;polynomial&lt;/a&gt;
function coefficients.&lt;/p&gt;

&lt;p&gt;Our first step will be to replace the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial&quot;&gt;polynomial&lt;/a&gt;,
coefficients with elements of a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;sample&lt;/a&gt;
based shift register.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
if (i_ce)
	{ x[3], x[2], x[1], x[0] } &amp;lt;= { x[2], x[1], x[0], in };&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This will eliminate the dependence of the algorithm on the integer &lt;code class=&quot;highlighter-rouge&quot;&gt;n&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;We’ll use the input data as the first element in this registers,
and use &lt;code class=&quot;highlighter-rouge&quot;&gt;x[0]&lt;/code&gt; to refer to the prior input, &lt;code class=&quot;highlighter-rouge&quot;&gt;x[1]&lt;/code&gt; to refer to the value
before that, etc.  Hence, we’ll map the following values:&lt;/p&gt;

&lt;table class=&quot;bordered-table&quot;&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Old name&lt;/th&gt;
      &lt;th&gt;New Name&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;x[n+2]&lt;/td&gt;
      &lt;td&gt;in&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;x[n+1]&lt;/td&gt;
      &lt;td&gt;x[0]&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;x[n+0]&lt;/td&gt;
      &lt;td&gt;x[1]&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;x[n-1]&lt;/td&gt;
      &lt;td&gt;x[2]&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;x[n-2]&lt;/td&gt;
      &lt;td&gt;x[3]&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;This allows us to re-express the above filter coefficient equations as,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;   16 av = 4(x[1]-8x[1])+16(x[0]+x[2])-2(in+x[3])
   16 bv = 2[(x[0]-x[2])+4(x[0]-x[2])]+(in-x[3])
   cv = x[1]&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;You may also notice that all of the multiplies necessary to calculate
the coefficients, &lt;code class=&quot;highlighter-rouge&quot;&gt;a_n&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;b_n&lt;/code&gt;, and &lt;code class=&quot;highlighter-rouge&quot;&gt;c_n&lt;/code&gt;,
have now been replaced with adds and shifts.  Instead of multiplying by &lt;code class=&quot;highlighter-rouge&quot;&gt;-28&lt;/code&gt;
for example, we can subtract &lt;code class=&quot;highlighter-rouge&quot;&gt;8x[1]&lt;/code&gt; from &lt;code class=&quot;highlighter-rouge&quot;&gt;x[1]&lt;/code&gt; and then shift the result left by two bits.  In a similar fashion, we can multiply &lt;code class=&quot;highlighter-rouge&quot;&gt;x[0]-x[2]&lt;/code&gt; by five
by adding &lt;code class=&quot;highlighter-rouge&quot;&gt;x[0]-x[2]&lt;/code&gt; to &lt;code class=&quot;highlighter-rouge&quot;&gt;4(x[0]-x[2])&lt;/code&gt;.  The final multiplication by
two, or rather left shift by one, just completes the desired multiply by ten.&lt;/p&gt;

&lt;p&gt;Even this is too hard, though, since it will take us a couple of clocks to
calculate these values.  Hence we’ll go about calculating our coefficients
in three steps each in a different clock cycle.&lt;/p&gt;

&lt;p&gt;We’ll start, therefore, by splitting this process into three sets of operations.
Eventually these will take place on separate clock cycles, but for now we can
draw them out as though they all happened at once.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;   pmidv = 8x[1] - x[1]; // = 7x[1]
   psumn =  x[0] + x[2];
   difn  =  x[0] - x[2];
   //
   diffn = difn + 4difn;	// = 5 * (x[0] - x[2])
   sumw  =   in  + x[3];
   diffw =   in  - x[3];
   midvpsumn = 4(psumn) - (pmidv); // = 4(x[0]+x[2])-7x[1]
   //
   16 av = 4(midvpsumn)-2(sumw)
   16 bv = 2(diffn)+(diffw)
   cv = x[1]&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This can then be rewritten into pseudo-RTL logic over the space of three clock
cycles.  Our notation for the shift register components from before, &lt;code class=&quot;highlighter-rouge&quot;&gt;in&lt;/code&gt;
through &lt;code class=&quot;highlighter-rouge&quot;&gt;x[3]&lt;/code&gt;, will be valid on the second clock cycle.  Hence, for the
first clock we’ll be referencing &lt;code class=&quot;highlighter-rouge&quot;&gt;in&lt;/code&gt; through &lt;code class=&quot;highlighter-rouge&quot;&gt;x[2]&lt;/code&gt; instead of &lt;code class=&quot;highlighter-rouge&quot;&gt;x[0]&lt;/code&gt;
through &lt;code class=&quot;highlighter-rouge&quot;&gt;x[3]&lt;/code&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
if (i_ce)
begin
   // First clock, pre-data
   pmidv &amp;lt;= 8x[0] - x[0]; // Was 8x[1] - x[1]
   psumn &amp;lt;=   in + x[1];  // Was x[0] + x[2]
   difn  &amp;lt;=   in - x[1];  // Was x[0] - x[2]&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This takes care of some of the inner operations from our equations above.
The next step handles some more of the “multiplies”.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;   // Second clock
   diffn &amp;lt;= difn + 4difn;	// = 5 * (x[0] - x[2])
   sumw  &amp;lt;=   in  + x[3];
   diffw &amp;lt;=   in  - x[3];
   midvpsumn &amp;lt;= 4(psumn) - (pmidv); // = 4(x[0]+x[2])-7x[1]&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;In the final clock cycle we’ll calculate the actual coefficients.  Because
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
math is primarily fixed point, we’ll leave the &lt;code class=&quot;highlighter-rouge&quot;&gt;16&lt;/code&gt; on the left–indicating
that we never divided by the necessary 16.  We’ll need to drop the extra four
bits later, but for now we’ll leave them in
place as long as possible to avoid loss of precision.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;   // Third clock, data delayed by one
   av &amp;lt;= 4(midvpsumn)-2(sumw); // * 2^4
   bv &amp;lt;= 2(diffn)+(diffw); // * 2^4
   cv &amp;lt;= x[2];
end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This gives us the coefficients of our
&lt;a href=&quot;https://en.wikipedia.org/wiki/Piecewise&quot;&gt;piecewise&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial&quot;&gt;polynomial&lt;/a&gt; for a given
set of five input samples.&lt;/p&gt;

&lt;p&gt;We still need to calculate the value of &lt;code class=&quot;highlighter-rouge&quot;&gt;t&lt;/code&gt; that needs to be used when
evaluating this &lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial&quot;&gt;polynomial&lt;/a&gt;.
This logic will follow directly from the &lt;a href=&quot;/dsp/2017/07/29/series-linear-interpolation.html&quot;&gt;linear interpolator
development&lt;/a&gt;,
and is even copied from that development.&lt;/p&gt;

&lt;p&gt;The only big difference between this and the &lt;a href=&quot;/dsp/2017/07/29/series-linear-interpolation.html&quot;&gt;linear
interpolator&lt;/a&gt;
development is that, unlike the
&lt;a href=&quot;/dsp/2017/07/29/series-linear-interpolation.html&quot;&gt;linear interpolator&lt;/a&gt;,
this &lt;a href=&quot;https://en.wikipedia.org/wiki/Piecewise&quot;&gt;piecewise&lt;/a&gt; quadratic
&lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial&quot;&gt;polynomial&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolates&lt;/a&gt;
from &lt;em&gt;around&lt;/em&gt; the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;sample&lt;/a&gt; points
(&lt;code class=&quot;highlighter-rouge&quot;&gt;|t|&amp;lt;1/2&lt;/code&gt;), rather than &lt;em&gt;between&lt;/em&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;sample&lt;/a&gt; points,
(&lt;code class=&quot;highlighter-rouge&quot;&gt;0&amp;lt;t&amp;lt;1&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;Perhaps this would make more sense with a figure.  Fig 12 therefore shows in
color how the quadratic
&lt;a href=&quot;https://en.wikipedia.org/wiki/Upsamplers&quot;&gt;upsampler&lt;/a&gt;
will interpolate from &lt;em&gt;around&lt;/em&gt; the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;sample&lt;/a&gt;
points on the left, rather than &lt;em&gt;between&lt;/em&gt; the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;sample&lt;/a&gt;
points as shown on the right.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 12. Piecewise quadratics interpolate around sample points (left), rather than between sample points (right)&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/quadeqn-intervals-compared.png&quot; alt=&quot;&quot; width=&quot;728&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;I’m not really sure why this is so, I just know that I haven’t managed to
build a symmetric quadratic
&lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial&quot;&gt;polynomial&lt;/a&gt;
&lt;em&gt;between&lt;/em&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;sample&lt;/a&gt; points
(right side of Fig. 12 above) that ended up being very useful.  To handle this
difference, we’ll keep track of the last coefficients.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
if (i_ce)
begin
	avold &amp;lt;= av;
	bvold &amp;lt;= bv;
	cvold &amp;lt;= cv;
end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Then, if our local &lt;code class=&quot;highlighter-rouge&quot;&gt;t&lt;/code&gt; value is less then zero (&lt;code class=&quot;highlighter-rouge&quot;&gt;MSB&lt;/code&gt; is set), we’ll
use the newer coefficients, &lt;code class=&quot;highlighter-rouge&quot;&gt;av&lt;/code&gt;-&lt;code class=&quot;highlighter-rouge&quot;&gt;cv&lt;/code&gt;, otherwise we’ll use the
older, delayed by one &lt;code class=&quot;highlighter-rouge&quot;&gt;avold&lt;/code&gt;-&lt;code class=&quot;highlighter-rouge&quot;&gt;cvold&lt;/code&gt; coefficients.&lt;/p&gt;

&lt;p&gt;We’d also like to add a half to &lt;code class=&quot;highlighter-rouge&quot;&gt;t&lt;/code&gt; at this point, so that it ranges between
&lt;code class=&quot;highlighter-rouge&quot;&gt;0&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt; instead of from &lt;code class=&quot;highlighter-rouge&quot;&gt;-0.5&lt;/code&gt; to &lt;code class=&quot;highlighter-rouge&quot;&gt;0.5&lt;/code&gt;.  It turns out that’s not needed.
&lt;code class=&quot;highlighter-rouge&quot;&gt;t&lt;/code&gt; naturally fits into place without change–all that’s required is to
re-interpret the signed &lt;code class=&quot;highlighter-rouge&quot;&gt;t&lt;/code&gt; value as an unsigned value and the conversion
is done.&lt;/p&gt;

&lt;p&gt;That gives us our three coefficients, &lt;code class=&quot;highlighter-rouge&quot;&gt;r_av&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;r_bv&lt;/code&gt;, and &lt;code class=&quot;highlighter-rouge&quot;&gt;r_cv&lt;/code&gt;,
together with our time offset, &lt;code class=&quot;highlighter-rouge&quot;&gt;r_offset&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Finally, as we go through the rest of the algorithm, we’ll use the prefixes
&lt;code class=&quot;highlighter-rouge&quot;&gt;r_&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;qp_&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;ls_&lt;/code&gt;, and &lt;code class=&quot;highlighter-rouge&quot;&gt;lp_&lt;/code&gt; to indicate which stage of the quadratic
algorithm we are in.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;The &lt;code class=&quot;highlighter-rouge&quot;&gt;r_&lt;/code&gt; prefix will hold the first copies of our variables in the “new”
sample rate domain.  This will include not only the quadratic coefficients,
&lt;code class=&quot;highlighter-rouge&quot;&gt;r_av&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;r_bv&lt;/code&gt;, and &lt;code class=&quot;highlighter-rouge&quot;&gt;r_cv&lt;/code&gt;, but also the value of &lt;code class=&quot;highlighter-rouge&quot;&gt;t&lt;/code&gt; associated with
these coefficients, held in &lt;code class=&quot;highlighter-rouge&quot;&gt;r_offset&lt;/code&gt;.  Finally, &lt;code class=&quot;highlighter-rouge&quot;&gt;r_ce&lt;/code&gt; will be true on
any clock where these values are valid.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The &lt;code class=&quot;highlighter-rouge&quot;&gt;qp_&lt;/code&gt; prefix will hold our variables immediately after taking
the &lt;em&gt;quadratic product&lt;/em&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;a*t&lt;/code&gt; or in terms of our registers,
&lt;code class=&quot;highlighter-rouge&quot;&gt;r_av * r_offset&lt;/code&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The &lt;code class=&quot;highlighter-rouge&quot;&gt;ls_&lt;/code&gt; prefix will refer to the variables associated with the
&lt;em&gt;linear sum&lt;/em&gt;, the result of adding &lt;code class=&quot;highlighter-rouge&quot;&gt;a*t+b&lt;/code&gt; or equivalently the output
of the quadratic product plus &lt;code class=&quot;highlighter-rouge&quot;&gt;r_bv&lt;/code&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The &lt;code class=&quot;highlighter-rouge&quot;&gt;lp_&lt;/code&gt; prefix will denote values associated with multiplying this
&lt;em&gt;last product&lt;/em&gt; and linear sum by our &lt;code class=&quot;highlighter-rouge&quot;&gt;t&lt;/code&gt; value one more time to get
&lt;code class=&quot;highlighter-rouge&quot;&gt;(at+b)*t&lt;/code&gt;.  As a result, when we add the constant to the result
of this last multiply, we’ll have our final value which we shall
call &lt;code class=&quot;highlighter-rouge&quot;&gt;r_done&lt;/code&gt;.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The algorithm below doesn’t do any rounding until the final step.  Instead,
it accumulates a lot of extra bits along the way, so that there’s not that
much precision lost along the way.&lt;/p&gt;

&lt;h2 id=&quot;the-code&quot;&gt;The Code&lt;/h2&gt;

&lt;p&gt;We’ve now made it far enough in our description that we can now walk through
the algorithm.  Feel free to skip this section if you would like and go
directly to the performance section below, and then return to this once you’ve
become convinced that you really are interested in the algorithmic details.
You can also just examine (or implement)
&lt;a href=&quot;https://github.com/ZipCPU/interpolation/blob/master/rtl/quadratic/quadinterp.v&quot;&gt;the code&lt;/a&gt;,
yourself to see what your thoughts are of it.&lt;/p&gt;

&lt;p&gt;The algorithm starts by defining some interface parameters.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	parameter	INW   = 25,	// Input width
			OWID  = INW,	// Output width
			MP    = 25,	// Multiply precision
			CTRBITS = 32;	// Bits in our counter&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;These are the input width, the output width, and the number of bits of our
time counter to use in the multiply.  The fourth value, &lt;code class=&quot;highlighter-rouge&quot;&gt;CTRBITS&lt;/code&gt;, controls
the total number of bits in the time counter.  In other words, how accurate
the fractional
&lt;a href=&quot;https://en.wikipedia.org/wiki/Upsamplers&quot;&gt;upsampling&lt;/a&gt;
ratio should be.  As with the &lt;a href=&quot;/dsp/2017/07/29/series-linear-interpolation.html&quot;&gt;linear
interpolator&lt;/a&gt;
development, this counter will step, on each input
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;sample&lt;/a&gt;,
by a step size given by the input &lt;code class=&quot;highlighter-rouge&quot;&gt;i_step&lt;/code&gt;,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;i_step = 2^(CTRBITS) (int)(old_sample_rate / new_sample_rate);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The number of bits in &lt;code class=&quot;highlighter-rouge&quot;&gt;CTRBITS&lt;/code&gt; will just control the accuracy and precision
of the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sample-rate_conversion&quot;&gt;resampling&lt;/a&gt;
function.&lt;/p&gt;

&lt;p&gt;The next two parameters, &lt;code class=&quot;highlighter-rouge&quot;&gt;OPT_INTERPOLATOR&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;OPT_IMPROVE_FIT&lt;/code&gt;, we
discussed earlier.  These control which quadratic
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sample-rate_conversion&quot;&gt;resampler&lt;/a&gt;
to implement among three defined in the code.  &lt;code class=&quot;highlighter-rouge&quot;&gt;OPT_INTERPOLATOR=1&lt;/code&gt; will
cause us to use the new
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;.
On the other hand, if &lt;code class=&quot;highlighter-rouge&quot;&gt;OPT_INTERPOLATOR=0&lt;/code&gt; but
&lt;code class=&quot;highlighter-rouge&quot;&gt;OPT_IMPROVED_FIT=1&lt;/code&gt;, then we’ll use the
non-&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;
output.  Finally, if both are zero the algorithm will calculate the
quadratic fit I’ve been so critical of.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	parameter  [0:0]	OPT_IMPROVED_FIT = 1&#39;b1;
	parameter  [0:0]	OPT_INTERPOLATOR = 1&#39;b1;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The last parameter, &lt;code class=&quot;highlighter-rouge&quot;&gt;GAIN_OFFSET&lt;/code&gt;, controls how far we shift the final result
to the right.  Ideally, this would be 4 if &lt;code class=&quot;highlighter-rouge&quot;&gt;OPT_INTERPOLATOR&lt;/code&gt; would be set in
order to divide by the factor of sixteen shown above.  Sadly, we can’t do that.
In particular, a set of constant maximum negative values surrounding a maximum
positive value, or vice versa, will yield filter results outside of that
incoming range.  Hence, to avoid overflow, we’ll only shift by three bits
(divide by eight), or two for the quadratic fit approaches.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	parameter		GAIN_OFFSET = (OPT_INTERPOLATOR)? 3:2;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The next step is to calculate the bit widths of various portions of this
algorithm.  These are held in local parameters, since they are calculated
from the main parameters above.  The first are the bit widths of the
coefficients,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;			// Bit-Width&#39;s of the quadratic, linear, and constant
			// coefficients
	localparam	AW = (OPT_INTERPOLATOR)?INW+6:INW+2,
			BW = (OPT_INTERPOLATOR)?INW+6:INW+1,
			CW = (OPT_INTERPOLATOR)?INW  :((OPT_IMPROVED_FIT)?(INW+3):INW),&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;followed by the number of bits we’ll have after the decimal place following each
computation,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;			ADEC=(OPT_INTERPOLATOR)? 4:1,
			BDEC=(OPT_INTERPOLATOR)? 4:1,
			CDEC=(OPT_INTERPOLATOR)? 0:((OPT_IMPROVED_FIT)? 3:0);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Remember, any time you want to multiply integers and fractions such as &lt;code class=&quot;highlighter-rouge&quot;&gt;A.B&lt;/code&gt;
times &lt;code class=&quot;highlighter-rouge&quot;&gt;X.Y&lt;/code&gt; (not the decimal place), you’ll need to first move the decimal
place to the far right so as to get &lt;code class=&quot;highlighter-rouge&quot;&gt;2^N(AB.)&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;2^M(XY.)&lt;/code&gt;.  Then, when
you multiply these numbers, you can shift them back to get the result you
were looking for back to where it belongs:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;A.B * X.Y = (AB. * XY.)*2^(-N-M)&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Of course, in practice this just means that we’ll track this resulting
decimal point, as you’ll see through &lt;a href=&quot;https://github.com/ZipCPU/interpolation/blob/master/rtl/quadratic/quadinterp.v&quot;&gt;the
code&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The final local parameter is the width of the internal calculations.
This is the number of bits that we will keep following each multiply.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	localparam	BMW = ((AW-ADEC&amp;gt;BW-BDEC) ? (AW-ADEC+BDEC) : BW);
	localparam	CMW = ((BMW+1-BDEC&amp;gt;CW-CDEC) ? (BMW+1-BDEC+CDEC) : CW);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;With these preliminaries aside, we can finally dig in to the
&lt;a href=&quot;https://github.com/ZipCPU/interpolation/blob/master/rtl/quadratic/quadinterp.v&quot;&gt;implementation&lt;/a&gt;
of our quadratic
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;,
beginning with how we generate the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial&quot;&gt;polynomial&lt;/a&gt;
coefficients themselves.  Since this will change depending upon our
choice of quadratic, we’ll use a generate block to select from among
several logic sets.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	generate if (OPT_INTERPOLATOR)
	begin&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;As our first step, we’ll calculate the shift register of data inputs
and a short history that we discussed above in the last section.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;		always @(posedge i_clk)
		if (i_ce)
			{ mem[3], mem[2], mem[1], mem[0] }
				&amp;lt;= { mem[2], mem[1], mem[0], i_data };&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Let’s take a moment here to discuss &lt;code class=&quot;highlighter-rouge&quot;&gt;i_ce&lt;/code&gt;.  This is the “global CE” signal
from our &lt;a href=&quot;/blog/2017/08/14/strategies-for-pipelining.html&quot;&gt;previous discussion on pipeline
strategies&lt;/a&gt;.
As you may recall from &lt;a href=&quot;/blog/2017/08/14/strategies-for-pipelining.html&quot;&gt;that
discussion&lt;/a&gt;,
the “global CE strategy” is very appropriate for
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_signal_processing&quot;&gt;signal processing&lt;/a&gt;
applications.  Further, you’ll want to remember the rules associated with the
“global CE” signal: &lt;em&gt;Nothing&lt;/em&gt; changes except on the clock that &lt;code class=&quot;highlighter-rouge&quot;&gt;i_ce&lt;/code&gt; is true.
Since this is a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sample-rate_conversion&quot;&gt;resampling&lt;/a&gt;
module, though, we’ll have to extend this rule.  Nothing on the incoming
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;sample&lt;/a&gt;,
rate side changes unless &lt;code class=&quot;highlighter-rouge&quot;&gt;i_ce&lt;/code&gt; is true.
We’ll use another CE signal, &lt;code class=&quot;highlighter-rouge&quot;&gt;r_ce&lt;/code&gt; for the output
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;sample&lt;/a&gt;
side in a moment.&lt;/p&gt;

&lt;p&gt;The next several calculations also follow directly from the last section
as well.  The only difference here is that this time we are applying the
necessary shifts to accomplish the needed “multiplies” from before.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;		always @(posedge i_clk)
		if (i_ce)
		begin
			pmidv &amp;lt;= { mem[0], 3&#39;b000 }
					- { {(3){mem[0][INW-1]}},mem[0]};// x7
			psumn &amp;lt;= { i_data[(INW-1)], i_data }
					+ { mem[1][(INW-1)], mem[1] };
			pdifn &amp;lt;= { i_data[(INW-1)], i_data }
					- { mem[1][(INW-1)], mem[1] };
			//
			sumw &amp;lt;= { mem[3][(INW-1)], mem[3] }
					+ { i_data[(INW-1)], i_data };
			// sumn &amp;lt;= psumn;
			diffn&amp;lt;= { pdifn[INW], pdifn, 2&#39;b00 }
					+ ,pdifn };// x5
			diffw&amp;lt;= { i_data[(INW-1)], i_data }
					- { mem[3][(INW-1)], mem[3] };
			// midv &amp;lt;= pmidv;
			midvpsumn &amp;lt;= -{ pmidv[(INW+2)],pmidv }
					+ { psumn[INW], psumn, 2&#39;h0 };//x7 + x4
		end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;That’s the first two clocks.  Then, on the third clock, we use these
intermediate expressions to generate the actual quadratic coefficients.
Remember, though, the &lt;code class=&quot;highlighter-rouge&quot;&gt;mem[x]&lt;/code&gt; values by this clock have shifted forward by
one extra
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;sample&lt;/a&gt;.
As a result, &lt;code class=&quot;highlighter-rouge&quot;&gt;cv&lt;/code&gt; is set to &lt;code class=&quot;highlighter-rouge&quot;&gt;mem[2]&lt;/code&gt; instead of &lt;code class=&quot;highlighter-rouge&quot;&gt;mem[1]&lt;/code&gt;.
Likewise, the &lt;code class=&quot;highlighter-rouge&quot;&gt;av&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;bv&lt;/code&gt; values here have been multiplied by sixteen
compared to the coefficients we want.  This factor of sixteen will ultimately,
and only partially, be corrected with the &lt;code class=&quot;highlighter-rouge&quot;&gt;GAIN_OFFSET&lt;/code&gt; when we are done.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;		initial	av = 0;
		initial	bv = 0;
		always @(posedge i_clk)
		if (i_ce)
		begin
			// av = x28 + x16 + x2
			// av = - { midv, 2&#39;b00 } + { sumn, 4&#39;h0 } - { sumw, 1&#39;b0 };
			av &amp;lt;= { midvpsumn, 2&#39;b00 }
					- { {(4){sumw[INW]}}, sumw, 1&#39;b0 };
			bv &amp;lt;= { diffn[INW+3],diffn, 1&#39;b0 }
				- { {(5){diffw[INW]}}, diffw };
			cv &amp;lt;= mem[2];
		end

	end else begin&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The next two sections in &lt;a href=&quot;https://github.com/ZipCPU/interpolation/blob/master/rtl/quadratic/quadinterp.v&quot;&gt;the
code&lt;/a&gt;
calculate the coefficients of the quadratic fit and
our non-&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolating&lt;/a&gt;
quadratic.  We’ll skip these here for simplicity, so that we can focus on
today’s quadratic &lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;,
however we’ll show the results of these
&lt;a href=&quot;https://en.wikipedia.org/wiki/Upsamplers&quot;&gt;upsampling&lt;/a&gt;
filters further down.&lt;/p&gt;

&lt;p&gt;At this point, then, we have our three quadratic coefficients, &lt;code class=&quot;highlighter-rouge&quot;&gt;av&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;bv&lt;/code&gt;,
and &lt;code class=&quot;highlighter-rouge&quot;&gt;cv&lt;/code&gt;–regardless of which algorithm generated them.&lt;/p&gt;

&lt;p&gt;We discussed in the last section the need for keeping the coefficients from
the last interval around, so we’ll copy them here.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(posedge i_clk)
	if (i_ce)
	begin
		avold &amp;lt;= av;
		bvold &amp;lt;= bv;
		cvold &amp;lt;= cv;
	end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;We’ll
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sample-rate_conversion&quot;&gt;resample&lt;/a&gt;
our data two clocks following any new incoming data, so let’s
capture that new value here.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(posedge i_clk)
		pre_ce &amp;lt;= i_ce;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;That brings us to calculating when to take our next
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;sample&lt;/a&gt;.
This code should be familiar, as it was lifted from our discussion on
&lt;a href=&quot;/dsp/2017/07/29/series-linear-interpolation.html&quot;&gt;linear interpolators&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;First, we calculate the when of the next
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;sample&lt;/a&gt;
point.  Our &lt;code class=&quot;highlighter-rouge&quot;&gt;t&lt;/code&gt; value is given by this counter.  When the counter overflows,
the next outgoing
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;sample&lt;/a&gt;
will require a new incoming
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;sample&lt;/a&gt;
so we’ll then stop moving forward and wait for that next
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;sample&lt;/a&gt;&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	// ...
	initial	r_ovfl  = 1&#39;b1;
	always @(posedge i_clk)
		if (i_ce)
			{ r_ovfl, r_counter } &amp;lt;= r_counter + i_step;
		else if (!r_ovfl)
			{ r_ovfl, r_counter } &amp;lt;= r_counter + i_step;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;In the end, the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;sample&lt;/a&gt;
indicator is a combination of either following a new
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;sample&lt;/a&gt;
value, or any other
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;sample&lt;/a&gt;
up until the counter overflows.  In this fashion, we’ll
&lt;a href=&quot;https://en.wikipedia.org/wiki/Upsamplers&quot;&gt;upsample&lt;/a&gt;
the incoming data.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	// ...
	initial	r_ce = 1&#39;b0;
	always @(posedge i_clk)
		r_ce &amp;lt;= ((pre_ce)||(!r_ovfl));&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Please feel free to refer back to the &lt;a href=&quot;/dsp/2017/07/29/series-linear-interpolation.html&quot;&gt;linear
interpolator&lt;/a&gt;
series if you find this logic difficult to understand.&lt;/p&gt;

&lt;p&gt;Two steps are left before evaluating the quadratic
&lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial&quot;&gt;polynomial&lt;/a&gt;: calculating &lt;code class=&quot;highlighter-rouge&quot;&gt;t&lt;/code&gt;,
and switching our coefficients so that the quadratic function we create
&lt;em&gt;surrounds&lt;/em&gt; our incoming data point. This accomplishes the transformation
illustrated in Fig 12 above.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(posedge i_clk)
	if (r_ce)
		pre_offset &amp;lt;= r_counter[(CTRBITS-1):(CTRBITS-MP)];

	// ...
	always @(posedge i_clk)
		if (r_ce)
		begin
			r_offset &amp;lt;= { pre_offset[MP-1], pre_offset[(MP-2):0] };
			if (pre_offset[(MP-1)])
			begin
				r_av &amp;lt;= av;
				r_bv &amp;lt;= bv;
				r_cv &amp;lt;= cv;
			end else begin
				r_av &amp;lt;= avold;
				r_bv &amp;lt;= bvold;
				r_cv &amp;lt;= cvold;
			end
		end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;At this point we now have our quadratic coefficients, &lt;code class=&quot;highlighter-rouge&quot;&gt;r_av&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;r_bv&lt;/code&gt;, and
&lt;code class=&quot;highlighter-rouge&quot;&gt;r_cv&lt;/code&gt;, together with our time offset, &lt;code class=&quot;highlighter-rouge&quot;&gt;r_offset&lt;/code&gt;.  These are the coefficients
of the quadratic we wish to evaluate.  Indeed, at this point all of the
difficult stuff is done.  All that remains is to handle the quadratic
evaluation itself.&lt;/p&gt;

&lt;p&gt;The first step is to multiply &lt;code class=&quot;highlighter-rouge&quot;&gt;a&lt;/code&gt; by &lt;code class=&quot;highlighter-rouge&quot;&gt;t&lt;/code&gt;.  To keep everything else aligned,
we’ll forward all of our other coefficients to the next clock.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(posedge i_clk)
	if (r_ce)
	begin
		qp_quad  &amp;lt;= r_av * r_offset;	// * 2^(-MP-ADEC)
		qp_bv    &amp;lt;= r_bv;		// * 2^(-BDEC)
		qp_cv    &amp;lt;= r_cv;		// * 2^(-CDEC)
		qp_offset&amp;lt;= r_offset;		// * 2^(-MP)
	end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Many FPGA’s have dedicated multiply accumulate capability in their
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_signal_processing&quot;&gt;DSP&lt;/a&gt;
hardware.  Such a capability would allow
us to calculate &lt;code class=&quot;highlighter-rouge&quot;&gt;r_av * r_offset + r_bv&lt;/code&gt;–with an appropriate bit select
along the way.  For right or wrong, this has never been my coding practice.
Perhaps I just want more control of the operation.  Either way, I will often
split these two calculations into two separate clocks.  That’s why we aren’t
adding the &lt;code class=&quot;highlighter-rouge&quot;&gt;bv&lt;/code&gt; coefficient to this multiplication result in this clock.&lt;/p&gt;

&lt;p&gt;Before the next step, let’s consider what we have.  We have three numbers,
with decimal points in varying locations.  &lt;code class=&quot;highlighter-rouge&quot;&gt;r_av&lt;/code&gt; for example has &lt;code class=&quot;highlighter-rouge&quot;&gt;ADEC&lt;/code&gt;
bits following the decimal point, and we just multiplied it by a value, &lt;code class=&quot;highlighter-rouge&quot;&gt;t&lt;/code&gt;,
all of whose bits were to the right of the decimal point.  Hence, we now
have &lt;code class=&quot;highlighter-rouge&quot;&gt;(MP+ADEC)&lt;/code&gt; bits following our decimal point in a number that is
&lt;code class=&quot;highlighter-rouge&quot;&gt;AW&lt;/code&gt; bits wide.  Let’s keep track of this decimal point as well as the
decimal point for &lt;code class=&quot;highlighter-rouge&quot;&gt;qb_bv&lt;/code&gt; in our notes.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	// qp_quad (AW-ADEC).(MP+ADEC)
	// qb_bv   (BW-BDEC).(BDEC)&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;We are now going to want to add the results of this multiply to our &lt;code class=&quot;highlighter-rouge&quot;&gt;b&lt;/code&gt;
coefficient in our next step.  To do this though, we’re going to first
need to normalize
both values so that they have the same number of decimal points.
In spite of the ugly looking code below, we’re just dropping the extra
bits off the bottom.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	// lw_quad (BW-BDEC).(BDEC)
	assign	lw_quad = { {(BMW-(AW+MP-(MP+ADEC-BDEC))){qp_quad[(AW+MP-1)]}},
				qp_quad[(AW+MP-1):(MP+ADEC-BDEC)] };&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Hence, we just shifted &lt;code class=&quot;highlighter-rouge&quot;&gt;qp_quad&lt;/code&gt; down by &lt;code class=&quot;highlighter-rouge&quot;&gt;(MP+ADEC-BDEC)&lt;/code&gt; binary decimal points,
so that it now has &lt;code class=&quot;highlighter-rouge&quot;&gt;BDEC&lt;/code&gt; bits following the decimal instead of &lt;code class=&quot;highlighter-rouge&quot;&gt;MP+ADEC&lt;/code&gt;.
The result, &lt;code class=&quot;highlighter-rouge&quot;&gt;lw_quad&lt;/code&gt;, now has the same number of decimal places as
&lt;code class=&quot;highlighter-rouge&quot;&gt;qp_bv&lt;/code&gt;, so we can now add these two numbers together.  As before, we’ll
forward the constants we haven’t yet used to the next clock cycle.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(posedge i_clk)
	if (r_ce)
	begin
		// ...
		ls_bv    &amp;lt;= { { (BMW+1-BW){qp_bv[BW-1] } }, qp_bv }
				+ { lw_quad[BMW-1], lw_quad };
		ls_cv    &amp;lt;= qp_cv;
		ls_offset&amp;lt;= qp_offset;
	end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;As a next step, we’ll calculate &lt;code class=&quot;highlighter-rouge&quot;&gt;(a*t+b)*t&lt;/code&gt; and place the result into &lt;code class=&quot;highlighter-rouge&quot;&gt;lp_bv&lt;/code&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(posedge i_clk)
	if (r_ce)
	begin
		lp_bv    &amp;lt;= ls_bv * ls_offset;	// * 2^(-MP-BDEC)
		lp_cv    &amp;lt;= ls_cv;		// * 2^(-   CDEC)
	end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;As before, we keep track of our decimal points at this step.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	// lp_bv (BMW+1-BDEC).(BDEC+MP)
	// lp_cv    (CW-CDEC).(CDEC)&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This helps us to know how much to shift &lt;code class=&quot;highlighter-rouge&quot;&gt;lp_bv&lt;/code&gt; by in order to align it with
&lt;code class=&quot;highlighter-rouge&quot;&gt;lp_cv&lt;/code&gt; so that the two can be added in the next step.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	wire	signed	[(CMW-1):0]	wp_bv;
	assign	wp_bv = { lp_bv[(BMW+MP):(MP+BDEC-CDEC)] };&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This brings us to the last part of calculating the quadratic, adding the
constant to the final result.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(posedge i_clk)
	if (r_ce)
		r_done &amp;lt;= { wp_bv[CMW-1], wp_bv }
				 + , lp_cv};&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;And we’re done!&lt;/p&gt;

&lt;p&gt;Okay, not quite.  We still need to drop a bunch of bits.
As &lt;a href=&quot;/dsp/2017/07/22/rounding.html&quot;&gt;we discussed earlier&lt;/a&gt;,
there’s a right and a wrong way to do drop bits in a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_signal_processing&quot;&gt;DSP&lt;/a&gt;
algorithm.  Hence, we’ll round towards the nearest even integer here
and then throw the rest of the bits away.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	generate if (CMW+1-GAIN_OFFSET &amp;gt; OWID)
	begin

		reg	[CMW-GAIN_OFFSET:0]	rounded;

		initial rounded = 0;
		always @(posedge i_clk)
		if (r_ce)
			rounded &amp;lt;= r_done[(CMW-GAIN_OFFSET):0]
				+ { {(OWID){1&#39;b0}},
					r_done[CMW-GAIN_OFFSET-OWID],
				{(CMW-OWID-GAIN_OFFSET-1)
					{!r_done[CMW-GAIN_OFFSET-OWID]}} };

		assign	o_data = rounded[(CMW-GAIN_OFFSET)
					:(CMW+1-GAIN_OFFSET-OWID)];&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The &lt;a href=&quot;https://github.com/ZipCPU/interpolation/blob/master/rtl/quadratic/quadinterp.v&quot;&gt;code&lt;/a&gt;
contains two other non-rounding choices, which we shall skip here
in our discussion.&lt;/p&gt;

&lt;p&gt;The final step is to note when this output is valid.  This involves
forwarding our new &lt;a href=&quot;/blog/2017/08/14/strategies-for-pipelining.html&quot;&gt;global CE pipeline control
signal&lt;/a&gt;
to the output.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	// ...
	end endgenerate

	assign	o_ce = r_ce;

	// ...
endmodule&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;At this, we are now done and our
&lt;a href=&quot;https://github.com/ZipCPU/interpolation/blob/master/rtl/quadratic/quadinterp.v&quot;&gt;code&lt;/a&gt;
is complete.  But does it work?  Let’s see in the next section.&lt;/p&gt;

&lt;h2 id=&quot;the-proof&quot;&gt;The Proof&lt;/h2&gt;

&lt;p&gt;I’ve always counseled individuals not to use a tool they aren’t familiar with.
Every tool in the shed has its purpose, its capabilities, and its limitations.
This &lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;
is no different from any other tool in that sense.  To see how well, or
poorly, this quadratic
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;
works, let’s test it.  In particular, we can sweep a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sine_wave&quot;&gt;sine wave&lt;/a&gt;
through the input and see what happens.  Further, let’s compare this 
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;
with four different
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolation&lt;/a&gt;
methods:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Our first method will be the simple &lt;a href=&quot;/dsp/2017/06/06/simple-interpolator.html&quot;&gt;sample and hold
circuit&lt;/a&gt; we
presented earlier.  Since the code within this module doesn’t really handle
&lt;a href=&quot;https://en.wikipedia.org/wiki/Upsamplers&quot;&gt;upsampling&lt;/a&gt;, we’ll use the &lt;a href=&quot;/blog/2017/08/14/strategies-for-pipelining.html&quot;&gt;global
CE&lt;/a&gt;
from the other
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolators&lt;/a&gt;
to know when to capture this output.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The second method will be a straight-forward
&lt;a href=&quot;/dsp/2017/07/29/series-linear-interpolation.html&quot;&gt;linear interpolator&lt;/a&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Our third choice will be the quadratic fit we developed above, allowing
you to see just how good, or poor, this
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt; is in practice.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;We’ll then use the nice quadratic
&lt;a href=&quot;https://en.wikipedia.org/wiki/Upsamplers&quot;&gt;upsampler&lt;/a&gt; from above,
the one that we chose to call the
non-&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The final test algorithm is today’s quadratic
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt; algorithm.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;While I won’t walk you through the test code (today), I will post it with the
rest of the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;’s
&lt;a href=&quot;https://github.com/ZipCPU/interpolation/blob/master/rtl/quadratic/quadinterp.v&quot;&gt;code&lt;/a&gt;
in my &lt;a href=&quot;https://github.com/ZipCPU/interpolation&quot;&gt;interpolation repository&lt;/a&gt;.
If you are interested in this test code, check out the
&lt;a href=&quot;https://github.com/ZipCPU/interpolation/tree/master/bench&quot;&gt;bench&lt;/a&gt;
subdirectories.  There you will find a &lt;a href=&quot;https://github.com/ZipCPU/interpolation/blob/master/bench/rtl/icomparison.v&quot;&gt;master Verilog
module&lt;/a&gt;
that instantiates examples of all of the filters below, as well as a &lt;a href=&quot;https://github.com/ZipCPU/interpolation/blob/master/bench/cpp/icompare.cpp&quot;&gt;Verilator
based C++&lt;/a&gt;
program that will exercise these filters and write the outputs to a data file.
Finally, there’s a &lt;a href=&quot;https://github.com/ZipCPU/interpolation/blob/master/bench/cpp/plotem.m&quot;&gt;Octave
script&lt;/a&gt;
that can be used to plot these results.&lt;/p&gt;

&lt;p&gt;Sadly, the resulting data is too voluminous to plot in its entirety here,
so I’ll just pick some useful and revealing sections of this data for
discussion.&lt;/p&gt;

&lt;p&gt;For four first example, let’s compare how these
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolation&lt;/a&gt;
functions perform for a low frequency
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sine_wave&quot;&gt;sine wave&lt;/a&gt;.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 13. Low frequency interpolation&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/quadeqn-result-lo.png&quot; alt=&quot;&quot; width=&quot;581&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;By visual inspection alone, most of the quadratic
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolators&lt;/a&gt;
did pretty well.  Even the linear
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;
seems to be tracking the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sine_wave&quot;&gt;sine wave&lt;/a&gt;.
quite nicely.&lt;/p&gt;

&lt;p&gt;If you look even closer, though, you may notice some minor discontinuities
in the quadratic fit, or locations where the quadratic
non-&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;
doesn’t go through the given
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;sample&lt;/a&gt;
points.  These effects are minimal at this low frequency, but they are present.&lt;/p&gt;

&lt;p&gt;So, let’s increase the frequency.&lt;/p&gt;

&lt;p&gt;Fig 14 below shows the same
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sine_wave&quot;&gt;sine wave&lt;/a&gt;,
but this time with a frequency between &lt;code class=&quot;highlighter-rouge&quot;&gt;0.25&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;0.3&lt;/code&gt; cycles per sample.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 14. Higher frequency interpolation&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/quadeqn-result-hi.png&quot; alt=&quot;&quot; width=&quot;582&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Here the differences become very stark.  The quadratic fit’s discontinuities
are much larger, and the
non-&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;
is clearly missing the input
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;sample&lt;/a&gt;
points.&lt;/p&gt;

&lt;p&gt;If you look closer, you may even see some kinks in the quadratic
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt; we just built.
These are a result of the fact that, although this
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt; is
&lt;a href=&quot;https://en.wikipedia.org/wiki/Continuous_function&quot;&gt;continuous&lt;/a&gt;,
it is not 
&lt;a href=&quot;https://en.wikipedia.org/wiki/Continuous_function&quot;&gt;continuous&lt;/a&gt;
in its first derivative.  Achieving that result will take more work–something
we’ll leave for another day.  Even still, though, this is probably good enough
for most purposes at this frequency.&lt;/p&gt;

&lt;p&gt;What about a higher frequency?  Why not push both of these
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolators&lt;/a&gt;
until they completely break down near the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Nyquist_frequency&quot;&gt;Nyquist frequency&lt;/a&gt;?&lt;/p&gt;

&lt;p&gt;That’s the purpose of the next figure, Fig 15.  In this figure, the incoming
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sine_wave&quot;&gt;sine wave&lt;/a&gt; is
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;sampled&lt;/a&gt;
right near the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Nyquist_frequency&quot;&gt;Nyquist cutoff frequency&lt;/a&gt;
of two samples per cycle.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 15. Interpolation near Nyquist&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/quadeqn-result-aliased.png&quot; alt=&quot;&quot; width=&quot;584&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Judging from the images above, it looks like the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolators&lt;/a&gt;
are tracking the outline of a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sine_wave&quot;&gt;sine wave&lt;/a&gt;
multiplied by some kind of envelope.  The
incoming signal, however, had no envelope function constraining it.  Indeed,
the incoming signal was nothing but a straight
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sine_wave&quot;&gt;sine wave&lt;/a&gt;.  Instead, this
apparent “envelope” is the result of undersampling a high frequency
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sine_wave&quot;&gt;sine wave&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Which &lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;
is better in this environment?  I might argue that none of them work well
this close to the &lt;a href=&quot;https://en.wikipedia.org/wiki/Nyquist_frequency&quot;&gt;Nyquist
frequency&lt;/a&gt;,
and that instead this final example frequency is really beyond their
capability.  This isn’t to say that better
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolators&lt;/a&gt;
do not exist, or that they cannot be developed.  Rather, it is simply a
statement of the reality that any
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;
will break down as it approaches the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Nyquist_frequency&quot;&gt;Nyquist frequency&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;For just the cost of a couple multiplies, several additions and bit selects,
and quite a few flip-flops, we’ve managed to implement a better
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;.
This &lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;
is better than a &lt;a href=&quot;/dsp/2017/06/06/simple-interpolator.html&quot;&gt;sample and
hold&lt;/a&gt;,
better than a
&lt;a href=&quot;/dsp/2017/07/29/series-linear-interpolation.html&quot;&gt;linear interpolator&lt;/a&gt;,
and even better than the straight forward quadratic fit we started with.
Further, unlike the more traditional
&lt;a href=&quot;http://ieeexplore.ieee.org/document/15483/&quot;&gt;Farrow&lt;/a&gt;
filter development, the output of the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sample-rate_conversion&quot;&gt;resampler&lt;/a&gt;
created by &lt;a href=&quot;https://github.com/ZipCPU/interpolation/blob/master/rtl/quadratic/quadinterp.v&quot;&gt;this interpolator&lt;/a&gt;
is actually constrained to go through the input samples.&lt;/p&gt;

&lt;p&gt;Does this mean that this is the best approach to
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolation&lt;/a&gt;?
By no means.  While &lt;a href=&quot;https://github.com/ZipCPU/interpolation/blob/master/rtl/quadratic/quadinterp.v&quot;&gt;this
solution&lt;/a&gt;
has some nice properties associated with it, it has no optimality properties.
In that sense, it’s just another ad-hoc development in a similar vein to
&lt;a href=&quot;http://ieeexplore.ieee.org/document/15483/&quot;&gt;Farrow&lt;/a&gt;’s.&lt;/p&gt;

&lt;p&gt;As with everything, though, you get want you pay for.  Better 
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolators&lt;/a&gt; of this
variety exist, but they do cost more.  For example, there’s another filter like
this one documented in my &lt;a href=&quot;https://github.com/ZipCPU/interpolation/raw/master/tutorial.pdf&quot;&gt;interpolation
tutorial&lt;/a&gt;,
although the coefficient multiplies are too difficult to do with just adds
and subtracts.  Indeed, they require a divide by 80!  Another approach is to use
&lt;a href=&quot;https://en.wikipedia.org/wiki/Spline_interpolation&quot;&gt;spline&lt;/a&gt; interpolation.
You may remember my earlier suggestion that
&lt;a href=&quot;https://en.wikipedia.org/wiki/Spline_interpolation&quot;&gt;spline&lt;/a&gt; interpolation could
be done without calculating a new matrix solution for every data point.&lt;/p&gt;

&lt;!-- Mention: Asynchronous Sample Rate Conversion? --&gt;

&lt;p&gt;This, though, will need to be a discussion for another day.&lt;/p&gt;
&lt;hr /&gt;&lt;p&gt;&lt;em&gt;And he spake also a parable unto them; No man putteth a piece of a new garment upon an old; if otherwise, then both the new maketh a rent, and the piece that was taken out of the new agreeth not with the old. (Luke 5:36)&lt;/em&gt;</description>
        <pubDate>Fri, 30 Mar 2018 00:00:00 -0400</pubDate>
        <link>http://zipcpu.com/dsp/2018/03/30/quadratic.html</link>
        <guid isPermaLink="true">http://zipcpu.com/dsp/2018/03/30/quadratic.html</guid>
        
        
        <category>dsp</category>
        
      </item>
    
      <item>
        <title>Pipelining a Prefetch</title>
        <description>&lt;p&gt;If you are familiar with the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;,
you’ll know that it was built in order to be a fully capable
&lt;a href=&quot;https://en.wikipedia.org/wiki/Soft_microprocessor&quot;&gt;CPU&lt;/a&gt;
while only using a
&lt;a href=&quot;/blog/2017/06/12/minimizing-luts.html&quot;&gt;minimal amount&lt;/a&gt; of
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt; logic.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 1. The ZipCPU&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/zipcpu.png&quot; alt=&quot;&quot; width=&quot;320&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;There’s a problem, though, with the phrase, “minimal amount of logic.”
Specifically, how much is minimal?  This is a difficult question,
since the answer changes from
&lt;a href=&quot;https://github.com/ZipCPU/s6soc&quot;&gt;one design&lt;/a&gt;
to the
&lt;a href=&quot;https://github.com/ZipCPU/openarty&quot;&gt;next&lt;/a&gt;.  When it comes to a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Soft_microprocessor&quot;&gt;soft-core CPU&lt;/a&gt;,
logic and performance start to trade off against each other as well.  What
I mean by that is that you can often spend logic within an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt; in order
to purchase better performance.  Hence, if you want to build a fast
&lt;a href=&quot;https://en.wikipedia.org/wiki/Soft_microprocessor&quot;&gt;CPU&lt;/a&gt;,
you’ll want to use as much logic as you can to purchase that high speed.  On
the other hand, if you want to &lt;a href=&quot;/blog/2017/06/12/minimizing-luts.html&quot;&gt;fit within a very small
space&lt;/a&gt;,
you might find that speed is not nearly as important.&lt;/p&gt;

&lt;p&gt;As an example, this was the trade-off within the
&lt;a href=&quot;https://github.com/ZipCPU/s6soc/&quot;&gt;S6SoC&lt;/a&gt;. The
&lt;a href=&quot;https://github.com/ZipCPU/s6soc/&quot;&gt;S6SoC&lt;/a&gt; as you
&lt;a href=&quot;/blog/2017/06/12/minimizing-luts.html&quot;&gt;may recall&lt;/a&gt;
is a demonstration
of the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; that runs within a
&lt;a href=&quot;https://www.xilinx.com/support/documentation/data_sheets/ds160.pdf&quot;&gt;Spartan 6 LX4&lt;/a&gt;–the
smallest &lt;a href=&quot;https://www.xilinx.com/support/documentation/data_sheets/ds160.pdf&quot;&gt;Spartan 6
(S6)&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
you could ever buy from
&lt;a href=&quot;https://www.xilinx.com&quot;&gt;Xilinx&lt;/a&gt;.  Getting a multi-tasking
&lt;a href=&quot;https://en.wikipedia.org/wiki/Soft_microprocessor&quot;&gt;CPU&lt;/a&gt; to fit within these
constraints was a challenge.  Getting that same
&lt;a href=&quot;https://en.wikipedia.org/wiki/Soft_microprocessor&quot;&gt;CPU&lt;/a&gt;
to have decent performance at the same time is even harder.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: left&quot;&gt;&lt;caption&gt;Fig 2. Digilent&#39;s CMod S6&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/cmods6.png&quot; alt=&quot;&quot; width=&quot;250&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Getting the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; to fit within the
&lt;a href=&quot;https://github.com/ZipCPU/s6soc&quot;&gt;S6SoC&lt;/a&gt; took a bit of trimming.  I got rid
of the
&lt;a href=&quot;/zipcpu/2017/08/23/cpu-pipeline.html&quot;&gt;pipelining&lt;/a&gt;,
switched to the lowest logic
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/memops.v&quot;&gt;memory controller&lt;/a&gt;
I knew how to
build and the lowest logic
&lt;a href=&quot;/zipcpu/2017/11/18/wb-prefetch.html&quot;&gt;prefetch&lt;/a&gt;.  I
removed the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/div.v&quot;&gt;divide unit&lt;/a&gt;
and removed
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/cpudefs.v&quot;&gt;early branching&lt;/a&gt;.
(All of these modifications can be made from within the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/cpudefs.v&quot;&gt;cpudefs.v&lt;/a&gt; file.)
I got rid of the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/zipcounter.v&quot;&gt;performance
counters&lt;/a&gt;,
the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/wbdmac.v&quot;&gt;DMA
engine&lt;/a&gt;,
and the various
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/ziptimer.v&quot;&gt;timers&lt;/a&gt;
that service the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt;.
I even had to remove the &lt;a href=&quot;/blog/2017/06/28/dbgbus-goal.html&quot;&gt;debugging
bus&lt;/a&gt;–there just wasn’t
room on the
&lt;a href=&quot;https://www.xilinx.com/support/documentation/data_sheets/ds160.pdf&quot;&gt;LX4&lt;/a&gt;.
With a bit of work, I managed to get this
&lt;a href=&quot;https://github.com/ZipCPU/s6soc/tree/master/rtl/cpu&quot;&gt;trimmed-down&lt;/a&gt;
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt; to fit within the
&lt;a href=&quot;https://www.xilinx.com/support/documentation/data_sheets/ds160.pdf&quot;&gt;S6&lt;/a&gt;
on board
&lt;a href=&quot;https://store.digilentinc.com&quot;&gt;Digilent&lt;/a&gt;’s &lt;a href=&quot;https://store.digilentinc.com/cmod-s6-breadboardable-spartan-6-fpga-module&quot;&gt;CMod
S6&lt;/a&gt;
board.&lt;/p&gt;

&lt;p&gt;Then I tried to apply this
&lt;a href=&quot;https://github.com/ZipCPU/s6soc/tree/master/rtl/cpu&quot;&gt;trimmed-down&lt;/a&gt;
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt; to an
audio application.  Oh, it was a simple
demonstration: when the button is pressed, play a doorbell sound from a
recorded &lt;code class=&quot;highlighter-rouge&quot;&gt;8 kHz&lt;/code&gt; audio sample array.&lt;/p&gt;

&lt;p&gt;The &lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt; wasn’t fast enough.&lt;/p&gt;

&lt;p&gt;All the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt; had to do was to
read the audio samples from
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt;
memory, service interrupts, and particularly service the audio interrupt to
write one sample at a time to the
&lt;a href=&quot;/blog/2017/09/04/pwm-reinvention.html&quot;&gt;audio controller&lt;/a&gt;.
(Remember, I had no room for the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/wbdmac.v&quot;&gt;DMA
engine&lt;/a&gt;
to do this automatically.)&lt;/p&gt;

&lt;p&gt;The &lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt; just wasn’t fast enough as
built for even that.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Speeding&lt;/em&gt; up a &lt;a href=&quot;https://en.wikipedia.org/wiki/Soft_microprocessor&quot;&gt;CPU&lt;/a&gt; in an
environment where
&lt;a href=&quot;/blog/2017/06/12/minimizing-luts.html&quot;&gt;every LUT matters&lt;/a&gt;
can be a challenge.&lt;/p&gt;

&lt;p&gt;The first thing I did was to move some of the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt;’s instructions from
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt;
to &lt;a href=&quot;https://en.wikipedia.org/wiki/Random-access_memory&quot;&gt;block RAM&lt;/a&gt;.
Since I didn’t have enough block
&lt;a href=&quot;https://en.wikipedia.org/wiki/Random-access_memory&quot;&gt;RAM&lt;/a&gt;
to do this for the whole multitasking
“O/S”, I only put the critical components into the limited
&lt;a href=&quot;https://en.wikipedia.org/wiki/Random-access_memory&quot;&gt;RAM&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;That still wasn’t fast enough.&lt;/p&gt;

&lt;p&gt;Then, in my last round with the &lt;a href=&quot;https://github.com/ZipCPU/s6soc&quot;&gt;S6SoC&lt;/a&gt;, I
created a better prefetch unit I called
&lt;a href=&quot;https://github.com/ZipCPU/s6soc/blob/master/rtl/cpu/dblfetch.v&quot;&gt;dblfetch&lt;/a&gt;.
&lt;a href=&quot;https://github.com/ZipCPU/s6soc/blob/master/rtl/cpu/dblfetch.v&quot;&gt;This prefetch&lt;/a&gt;
was low logic enough to fit within the space
I had, but also faster than the
&lt;a href=&quot;/zipcpu/2017/11/18/wb-prefetch.html&quot;&gt;simpler prefetch&lt;/a&gt;
I had started with.
&lt;a href=&quot;https://github.com/ZipCPU/s6soc/blob/master/rtl/cpu/dblfetch.v&quot;&gt;This prefetch&lt;/a&gt;
unit, or rather a slightly modified one, is also the subject of this article.&lt;/p&gt;

&lt;h2 id=&quot;measuring-memory-performance&quot;&gt;Measuring Memory Performance&lt;/h2&gt;

&lt;p&gt;Let’s start, though, by looking at how to measure memory performance.  In
a synchronous design, where everything takes place on a clock tick, then
memory performance can be quantified by how many clocks it takes per
transaction.&lt;/p&gt;

&lt;p&gt;When using the &lt;a href=&quot;http://opencores.org/cdn/downloads/wbspec_b3.pdf&quot;&gt;B3 version&lt;/a&gt;
of the
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;wishbone bus&lt;/a&gt;, there’s
a fixed number of clocks for every transaction–we’ll call this the
transaction’s latency, &lt;code class=&quot;highlighter-rouge&quot;&gt;L&lt;/code&gt;.  Hence, if you want to access &lt;code class=&quot;highlighter-rouge&quot;&gt;N&lt;/code&gt; memory locations,
this will cost you &lt;code class=&quot;highlighter-rouge&quot;&gt;LN&lt;/code&gt; clocks.&lt;/p&gt;

&lt;table style=&quot;float: left&quot;&gt;&lt;caption&gt;Fig 3: A pair of Wishbone bus requests&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/dblfetch-ram.svg&quot; alt=&quot;The trace for a pair of Wishbone bus requests, as drawn from the ZipCPU prefetch named dblfetch&quot; width=&quot;420&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;On the other hand, if you use the
&lt;a href=&quot;/blog/2017/08/14/strategies-for-pipelining.html&quot;&gt;pipelined&lt;/a&gt;
mode of the
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;wishbone bus&lt;/a&gt;
as illustrated in Fig 3 on the left
(&lt;a href=&quot;/doc/wbspec_b4.pdf&quot;&gt;version B4&lt;/a&gt; only), you can then have
multiple transactions in flight at the same
time.  In this case, the time it takes to accomplish a transaction becomes
&lt;code class=&quot;highlighter-rouge&quot;&gt;(N-1)S+L&lt;/code&gt;.  In other words, there’s an initial latency &lt;code class=&quot;highlighter-rouge&quot;&gt;L&lt;/code&gt;, followed by a
number of clocks &lt;code class=&quot;highlighter-rouge&quot;&gt;S&lt;/code&gt; for each additional transaction within the burst.&lt;/p&gt;

&lt;p&gt;If you look at this from a purely peripheral perspective, you can see six
separate peripheral implementations  (approximately) outlined in the table
below.&lt;/p&gt;

&lt;table class=&quot;bordered-table&quot;&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Peripheral&lt;/th&gt;
      &lt;th&gt;Clocks to access&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;a href=&quot;https://opencores.org/project,qspiflash&quot;&gt;Initial QSPI Flash&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;16N + 16&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;a href=&quot;https://github.com/ZipCPU/xulalx25soc/blob/master/rtl/wbspiflash.v&quot;&gt;Flash&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;32N + 40&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Dual SPI Flash, XIP&lt;/td&gt;
      &lt;td&gt;16N + 16&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;QSPI Flash, XIP&lt;/td&gt;
      &lt;td&gt;8N +  8&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;a href=&quot;https://github.com/ZipCPU/s6soc/blob/master/rtl/memdev.v&quot;&gt;Block RAM&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;N +  1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;a href=&quot;https://github.com/ZipCPU/xulalx25soc/blob/master/rtl/wbsdram.v&quot;&gt;SDRAM&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;2N +  6&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;DDR3 SDRAM&lt;/td&gt;
      &lt;td&gt;N + 22&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;My &lt;a href=&quot;https://github.com/ZipCPU/s6soc/blob/master/rtl/wbqspiflash.v&quot;&gt;initial controller for the QSPI
flash&lt;/a&gt;
on the &lt;a href=&quot;https://github.com/ZipCPU/s6soc&quot;&gt;S6SoC&lt;/a&gt; required 43-clocks
for a single transaction.  There was a delay or two within the logic of the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt; and the &lt;a href=&quot;https://github.com/ZipCPU/s6soc/blob/master/rtl/busmaster.v&quot;&gt;bus
structure&lt;/a&gt;–we’ll
say it was a two clock delay, with one clock on either side of the actual
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt;
access (shown in blue below).  Further, the
non-&lt;a href=&quot;/zipcpu/2017/08/23/cpu-pipeline.html&quot;&gt;pipelined&lt;/a&gt;
version of the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt; at the time
required 4 more clocks per instruction.  The result was that it cost the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt; 49 clocks per instruction (CPI).
With a 12ns clock, this meant that the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
could at best run 1.6 Million Instructions per Second (MIPS).&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 4. Unoptimized Prefetch from Flash and CPU Performance&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/pfpipe-slow-flash.svg&quot; alt=&quot;&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;At a rate of 1.6 MIPS I had 200 instructions to deal with each audio sample.
These 200 instructions had handle everything else as well: interrupts, button
presses, the software based real-time clock, etc.  No wonder it couldn’t keep
up with the 8kHz audio stream!&lt;/p&gt;

&lt;p&gt;Of course, the real answer to making a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Soft_microprocessor&quot;&gt;CPU&lt;/a&gt; faster would be to
&lt;a href=&quot;/zipcpu/2017/08/23/cpu-pipeline.html&quot;&gt;pipeline the CPU&lt;/a&gt;
and run with a &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/pfcache.v&quot;&gt;proper prefetch and instruction
cache&lt;/a&gt;–even
better, to run the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt; from an
on-board block
&lt;a href=&quot;https://en.wikipedia.org/wiki/Random-access_memory&quot;&gt;RAM&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/s6soc/blob/master/rtl/memdev.v&quot;&gt;device&lt;/a&gt;.
This approach would have the performance shown in Fig 5.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 5. Prefetch with Instruction Cache&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/pfpipe-wcache.svg&quot; alt=&quot;&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;If I only had the logic to do that, the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; would’ve ran close to one clock
per instruction, once the cache was loaded, and would then achieve nearly
82 MIPS (minus cache stalls) on the
&lt;a href=&quot;https://www.xilinx.com/support/documentation/data_sheets/ds160.pdf&quot;&gt;Spartan 6&lt;/a&gt;.
There just wasn’t enough logic in the
&lt;a href=&quot;https://www.xilinx.com/support/documentation/data_sheets/ds160.pdf&quot;&gt;LX4&lt;/a&gt;
to do this.&lt;/p&gt;

&lt;p&gt;What else could be done?&lt;/p&gt;

&lt;p&gt;If I placed the most common instructions into block
&lt;a href=&quot;https://en.wikipedia.org/wiki/Random-access_memory&quot;&gt;RAM&lt;/a&gt;,
as I discussed above, then the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt; could run at about
12 MIPS.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 6. Fetching instructions from Block RAM&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/pfpipe-bkram.svg&quot; alt=&quot;&quot; width=&quot;315&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Thanks to the author of the
&lt;a href=&quot;https://github.com/hgeisse/eco32&quot;&gt;ECO32 CPU&lt;/a&gt;
I was rather surprised to learn at the time that
&lt;a href=&quot;https://www.gnu.org/software/binutils&quot;&gt;binutils&lt;/a&gt; 
supported this sort of dual addressing–with some addresses in
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt;,
and other addresses in a section of
&lt;a href=&quot;https://en.wikipedia.org/wiki/Random-access_memory&quot;&gt;RAM&lt;/a&gt;
that had been copied/loaded from the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt;–all controlled from a
&lt;a href=&quot;https://github.com/ZipCPU/s6soc/blob/master/sw/dev/cmod.ld&quot;&gt;linker script&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;This would’ve been perfect except the
&lt;a href=&quot;https://www.xilinx.com/support/documentation/data_sheets/ds160.pdf&quot;&gt;S6 LX4&lt;/a&gt;
just doesn’t have that much block
&lt;a href=&quot;https://en.wikipedia.org/wiki/Random-access_memory&quot;&gt;RAM&lt;/a&gt;.
I &lt;em&gt;needed&lt;/em&gt; to run instructions from the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;In my case, there was more that could be done by trimming the &lt;a href=&quot;https://github.com/ZipCPU/s6soc/blob/master/rtl/wbqspiflash.v&quot;&gt;flash
controller&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;To understand the options and possibilities, let’s back up for a moment and
discuss what the
&lt;a href=&quot;https://www.cypress.com/file/177966/download&quot;&gt;QSPI flash protocol&lt;/a&gt;
requires.
After you give the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt;
a “Fast Read Quad Output” command (0xEBh), the
&lt;a href=&quot;https://www.cypress.com/file/177966/download&quot;&gt;QSPI flash&lt;/a&gt;
I was working with would enter into an eXecute In Place (XIP) mode.
From this XIP mode,
any new instruction requires lowering the &lt;code class=&quot;highlighter-rouge&quot;&gt;CS_n&lt;/code&gt; line, issuing an address,
then another byte indicating whether or not you wish to remain in XIP mode,
and then several dummy clocks.  Only after all this setup could you then read
one 32-bit value from the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt;
every eight clocks.&lt;/p&gt;

&lt;p&gt;Fig 7. below shows the clocks required in the setup.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 7. QSPI Flash Quad Read Protocol in XIP Mode&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/qspi-xip.png&quot; alt=&quot;&quot; width=&quot;600&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;This is the fastest way to read from the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt;,
although it requires an
SCK or two for setup and tear-down.
Using this mode, it will take 80 QSPI bits, or equivalently
20 QSPI SCK’s, to read any arbitrary 32-bits of data from the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;One problem with my
&lt;a href=&quot;https://opencores.org/project,qspiflash&quot;&gt;flash design&lt;/a&gt; at the time was
that it was creating a SPI
clock from logic.  On one clock cycle the SPI clock output would be a one,
then a zero, etc.  As a result, the fastest SPI clock, &lt;code class=&quot;highlighter-rouge&quot;&gt;SCK&lt;/code&gt;, I could create
was at half my system clock rate, or 41MHz.&lt;/p&gt;

&lt;p&gt;If I instead switched from a &lt;em&gt;logic generated&lt;/em&gt; clock to a clock generated by a
&lt;a href=&quot;https://www.xilinx.com&quot;&gt;Xilinx&lt;/a&gt;
&lt;a href=&quot;https://www.xilinx.com/support/documentation/sw_manuals/xilinx14_7/7series_hdl.pdf&quot;&gt;ODDR&lt;/a&gt;
primitive,
then the SPI clock &lt;code class=&quot;highlighter-rouge&quot;&gt;SCK&lt;/code&gt; would transition on each clock edge and run at the
same speed as the design’s system clock speed (82 MHz).
By doubling the speed of the SPI SCK, I could then also double the speed of the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt;
to roughly 22-clocks per fetch, or 28 clocks per instruction.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 8. Doubling the SCK speed via an ODDR&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/pfpipe-fast-flash.svg&quot; alt=&quot;&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;While a 2.9 MHz instruction rate is better than a 1.6 MHz rate, it’s still
quite dismal.&lt;/p&gt;

&lt;p&gt;If I cleaned up the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt; so that 2 of
the five stages were
&lt;a href=&quot;/zipcpu/2017/08/23/cpu-pipeline.html&quot;&gt;pipelined&lt;/a&gt;–the two
stages that didn’t suffer from
&lt;a href=&quot;/zipcpu/2017/08/23/cpu-pipeline.html&quot;&gt;pipeline&lt;/a&gt;
conflicts (prefetch and instruction decode), then I could get up to
3.0 MHz.  This would be a slight improvement.&lt;/p&gt;

&lt;p&gt;On the other hand, if I could fetch two instructions at a time, the second
instruction would benefit from the fact that the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt;
chip is already set
up to get a provide the next instruction word.  In this case, I could fetch
2 instructions in 36 clocks vice one instruction in 28 clocks.  When the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt; performance
was factored in, the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt; would now
(nominally) take 36 clocks per two instructions, or 18 clocks total (with
exceptions) per instruction.  This would mean that the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt;
could then speed up to a whopping
4.6 MIPS, based upon an (82 MHz/18 CPI).&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 9. Fetching two instructions from flash at a time&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/pfpipe-dblflash.svg&quot; alt=&quot;&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;This *was *going to be the topic of this article–how to read two instructions
at a time.  It was how I managed to speed up the
&lt;a href=&quot;https://github.com/ZipCPU/s6soc&quot;&gt;S6SoC&lt;/a&gt; at the time.  In a
moment, though, I’ll share a better, faster, and &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/dblfetch.v&quot;&gt;cheaper prefetch
module&lt;/a&gt; just
for this blog article.&lt;/p&gt;

&lt;p&gt;Before going there, though, I should finish the story of the
&lt;a href=&quot;https://github.com/ZipCPU/s6soc&quot;&gt;S6SoC&lt;/a&gt; since I made another
improvement as well: I compressed instructions.&lt;/p&gt;

&lt;p&gt;Using the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; compressed
instruction set, two 16-bit instructions can be
stored into a single 32-bit instruction word.  The performance isn’t
necessarily all that wonderful, but roughly two in ten instructions can
be packed together into a single word.
(A recent bug-fix suggests the true value might be four in ten instructions,
but I haven’t been able to measure this improvement properly yet–so we’ll
just use the two in ten number.)
I could probably do a bit better if
I taught the compiler or the assembler how to re-order instructions to maximize
this feature’s usage, but I’ll still take the 10% improvement.  Hence, the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; speed ultimately
became somewhere near (82/18/0.8) or 5.7 MHz.&lt;/p&gt;

&lt;p&gt;A funny thing happened, though, on the way to putting
&lt;a href=&quot;http://zipcpu.com/&quot;&gt;this blog&lt;/a&gt;
post together.  When I started using
&lt;a href=&quot;http://www.clifford.at/yosys&quot;&gt;yosys&lt;/a&gt;
to measure the logic usage of
&lt;a href=&quot;https://github.com/ZipCPU/s6soc/blob/master/rtl/cpu/dblfetch.v&quot;&gt;this prefetch&lt;/a&gt;,
I realized two things.  First, I was using more logic than I needed to, and
second I could adjust the algorithm so that the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt;
could run concurrently with this second fetch.  In this manner, the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/dblfetch.v&quot;&gt;prefetch&lt;/a&gt;
can run continuously.  As a result, the (new/modified) performance of this
algorithm is now shown below.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 10. Two-Instruction Prefetch&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/pfpipe-new-dblfetch.svg&quot; alt=&quot;&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;At (roughly) 8 clocks per instruction (between
&lt;a href=&quot;https://en.wikipedia.org/wiki/Branch_(computer_science)&quot;&gt;branches&lt;/a&gt;),
this new version should run at roughly
10 MIPS—a big improvement over the 2MIPS we started with.  When you
factor in the compressed instruction set, this yields an even better
12.8 MIPS when running from &lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt;
and an 82MHz clock.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 11. Two instructions sharing the same instruction word&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/pfpipe-cis.svg&quot; alt=&quot;&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Consider the difference this makes when trying to process an 8k audio stream.
Instead of struggling along at 200 &lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt;
instructions per audio sample, I now have closer to 1,600
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt; instructions per audio sample
(neglecting
&lt;a href=&quot;https://en.wikipedia.org/wiki/Branch_(computer_science)&quot;&gt;branches&lt;/a&gt;).
For just a little adjustment in logic, then, the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt; now runs &lt;em&gt;MUCH&lt;/em&gt; faster.&lt;/p&gt;

&lt;p&gt;Before leaving this topic, I would be remiss if I didn’t point out that the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; &lt;em&gt;can&lt;/em&gt; run a lot faster–it just
takes more logic to implement
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/pfcache.v&quot;&gt;the cache&lt;/a&gt;
necessary to do so.  Indeed, we may even be able to come back and discuss how
the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/pfcache.v&quot;&gt;prefetch plus instruction
cache&lt;/a&gt;
approach is put together in a later article–although we’ll have to see
if the &lt;a href=&quot;https://www.blueletterbible.org/kjv/jas/4/15&quot;&gt;Lord is willing&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;how-dblfetch-works&quot;&gt;How dblfetch Works&lt;/h2&gt;

&lt;p&gt;While I could spend some time discussing how to strip the performance of a QSPI
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt;
controller to its
&lt;a href=&quot;https://github.com/ZipCPU/s6soc/blob/master/rtl/qflashxpress.v&quot;&gt;bare minimums&lt;/a&gt;,
today’s topic is going to be how to keep an instruction fetch operation going
so as to achieve the performance shown in Fig 11 above.&lt;/p&gt;

&lt;table style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 12: The two interfaces to a prefetch&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/prefetch-interface.svg&quot; alt=&quot;A prefetch must support both an interface to a CPU and an interface to memory&quot; width=&quot;380&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;As you may recall from our earlier discussion of the
&lt;a href=&quot;/zipcpu/2017/11/18/wb-prefetch.html&quot;&gt;simpler prefetch&lt;/a&gt;,
the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; prefetch interacts with the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt;
using only a small handful of signals:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;The clock, &lt;code class=&quot;highlighter-rouge&quot;&gt;i_clk&lt;/code&gt;, and reset, &lt;code class=&quot;highlighter-rouge&quot;&gt;i_reset&lt;/code&gt;, wires should need no more
description.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;On any
&lt;a href=&quot;https://en.wikipedia.org/wiki/Branch_(computer_science)&quot;&gt;branch&lt;/a&gt;,
whether early (unconditional), or late (conditional or indirect), the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt; will raise an
&lt;code class=&quot;highlighter-rouge&quot;&gt;i_new_pc&lt;/code&gt; flag and set the new
&lt;a href=&quot;https://en.wikipedia.org/wiki/Program_counter&quot;&gt;program counter&lt;/a&gt; in &lt;code class=&quot;highlighter-rouge&quot;&gt;i_pc&lt;/code&gt;.
From then until the next
&lt;a href=&quot;https://en.wikipedia.org/wiki/Branch_(computer_science)&quot;&gt;branch&lt;/a&gt;, the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Program_counter&quot;&gt;program counter&lt;/a&gt;
will increment from one instruction to the next.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;There’s also an &lt;code class=&quot;highlighter-rouge&quot;&gt;i_clear_cache&lt;/code&gt; line, which is used to force the
prefetch
to mark any cached information as invalid.  This allows the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt;
to load instructions into a memory area, and then make sure the instructions
freshly loaded into memory are the ones the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt;
executes later.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;These are just the signaling wires coming from the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt;.  Most of the work within the
&lt;a href=&quot;/zipcpu/2017/11/18/wb-prefetch.html&quot;&gt;prefetch&lt;/a&gt;,
h, however, is done with the &lt;code class=&quot;highlighter-rouge&quot;&gt;o_valid&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;o_insn&lt;/code&gt; wires returned to the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt;.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;o_valid&lt;/code&gt; indicates that the instruction presented to the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
is a valid instruction, and by implication that the instruction fetch
has completed.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;o_insn&lt;/code&gt; is the instruction being presented to the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;.
It has meaning only if &lt;code class=&quot;highlighter-rouge&quot;&gt;o_valid&lt;/code&gt; is also true.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Basically, any time &lt;code class=&quot;highlighter-rouge&quot;&gt;o_valid&lt;/code&gt; is true, &lt;code class=&quot;highlighter-rouge&quot;&gt;o_insn&lt;/code&gt; must contain a valid
instruction.  Once set, these values must hold until the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
accepts them by raising the &lt;code class=&quot;highlighter-rouge&quot;&gt;i_stall_n&lt;/code&gt; line.  (Why this is a negative logic
signal, vs just a &lt;code class=&quot;highlighter-rouge&quot;&gt;*_ready&lt;/code&gt; line is a long story …)&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;i_stall_n&lt;/code&gt; is an active low line indicating that the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
is stalled when active (low).  For those familiar with the AXI ready
signals, this signal is basically a ready signal from the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;.
When this line is high, and &lt;code class=&quot;highlighter-rouge&quot;&gt;o_valid&lt;/code&gt; is high on the same clock, then the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
has just accepted an instruction from the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/dblfetch.v&quot;&gt;prefetch&lt;/a&gt;.
and it is time to move on to the next instruction.&lt;/p&gt;

    &lt;p&gt;This detail is key, so remember this: when &lt;code class=&quot;highlighter-rouge&quot;&gt;(o_valid)&amp;amp;&amp;amp;(i_stall_n)&lt;/code&gt;, the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
has just accepted an instruction and we can move forward.&lt;/p&gt;

    &lt;p&gt;Hence, any time &lt;code class=&quot;highlighter-rouge&quot;&gt;(o_valid)&amp;amp;&amp;amp;(!i_stall_n)&lt;/code&gt;, we’ll need to hold the
instruction valid and wait for the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
to read it.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;If this signaling system is new or confusing to you, then I’m going to
recommend that you go back and review the &lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;formal properties of the
wishbone bus&lt;/a&gt;,
and likewise the &lt;a href=&quot;/zipcpu/2017/11/18/wb-prefetch.html&quot;&gt;formal properties and initial
discussion&lt;/a&gt;
from when we examined the &lt;a href=&quot;/zipcpu/2017/11/18/wb-prefetch.html&quot;&gt;single instruction
prefetch&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;In this case, we’ll be building essentially the same &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/prefetch.v&quot;&gt;basic
prefetch&lt;/a&gt;
as &lt;a href=&quot;/zipcpu/2017/11/18/wb-prefetch.html&quot;&gt;before&lt;/a&gt;
save for a small number of changes.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;The first change is that we’ll allow up to two requests to be in flight
at a time.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The second change is that we’ll need to keep track of both responses, and
feed them to the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
one at a time.&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;The first response from the
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;
will go into the &lt;code class=&quot;highlighter-rouge&quot;&gt;o_insn&lt;/code&gt; register, and will set &lt;code class=&quot;highlighter-rouge&quot;&gt;o_valid&lt;/code&gt;.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;Subsequent responses will also go into the &lt;code class=&quot;highlighter-rouge&quot;&gt;o_insn&lt;/code&gt; register, if ever
&lt;code class=&quot;highlighter-rouge&quot;&gt;o_valid&lt;/code&gt; is false&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;If &lt;code class=&quot;highlighter-rouge&quot;&gt;o_valid&lt;/code&gt; is true, but &lt;code class=&quot;highlighter-rouge&quot;&gt;i_stall_n&lt;/code&gt; is low, indicating that the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
is stalled, we won’t be able to place the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_(computing)&quot;&gt;bus&lt;/a&gt;
return into the &lt;code class=&quot;highlighter-rouge&quot;&gt;o_insn&lt;/code&gt; wires to the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;.
Instead, we’ll create a one-instruction cache to place it into.&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;table align=&quot;center&quot; style=&quot;float: left&quot;&gt;&lt;caption&gt;Fig 13. Two bus requests issued&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/pfpipe-request.svg&quot; alt=&quot;The prefetch issues two requests to the bus&quot; width=&quot;400&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Let’s see if we can draw this out.  The process starts with a state machine
that will issue two requests.  Further requests will be issued if any
requests are outstanding when the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
accepts an instruction from the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/dblfetch.v&quot;&gt;prefetch&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The rule here, though, is that no request may be made of the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_(computing)&quot;&gt;bus&lt;/a&gt;
unless there’s a place to put the result.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 14. Responses go into an Instruction Queue&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/pfpipe-response.svg&quot; alt=&quot;The responses from these requests go into a two-instruction queue&quot; width=&quot;400&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;On the return end from the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_(computing)&quot;&gt;bus&lt;/a&gt;,
responses will go either into our &lt;code class=&quot;highlighter-rouge&quot;&gt;o_insn&lt;/code&gt;
register to be sent immediately to the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
or into the &lt;code class=&quot;highlighter-rouge&quot;&gt;cache_word&lt;/code&gt; if &lt;code class=&quot;highlighter-rouge&quot;&gt;o_insn&lt;/code&gt; already has a valid value within it.
Which location the return goes into
will be governed both by the &lt;code class=&quot;highlighter-rouge&quot;&gt;o_valid&lt;/code&gt; flag, indicating that &lt;code class=&quot;highlighter-rouge&quot;&gt;o_insn&lt;/code&gt;
has a valid instruction within it, by &lt;code class=&quot;highlighter-rouge&quot;&gt;cache_valid&lt;/code&gt;, indicating that
the &lt;code class=&quot;highlighter-rouge&quot;&gt;cache_word&lt;/code&gt; has a valid instruction within it, and &lt;code class=&quot;highlighter-rouge&quot;&gt;i_stall_n&lt;/code&gt;
indicating that everything is moving forward.&lt;/p&gt;

&lt;h2 id=&quot;the-cpus-contract-with-the-prefetch&quot;&gt;The CPU’s Contract with the Prefetch&lt;/h2&gt;

&lt;p&gt;Since I &lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;started working with formal
methods&lt;/a&gt;, I’ve
started thinking of modules
within a design as having a &lt;em&gt;contract&lt;/em&gt; with the rest of the design.  For
example, a memory module has a &lt;em&gt;contract&lt;/em&gt; to return the values found within
the memory at the requested address, and to allow you to change those
values and retrieve the changed values later.  In the case of a
&lt;a href=&quot;/zipcpu/2017/11/18/wb-prefetch.html&quot;&gt;prefetch&lt;/a&gt;,
the contract is fairly simple: the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/dblfetch.v&quot;&gt;prefetch
module&lt;/a&gt;
needs to return to the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
the memory it read from the address the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
requested.  It’s that simple.&lt;/p&gt;

&lt;p&gt;To make matters even easier,
&lt;a href=&quot;http://www.clifford.at/yosys&quot;&gt;yosys&lt;/a&gt;
offers two expressions that can help:
&lt;code class=&quot;highlighter-rouge&quot;&gt;$anyseq&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;$anyconst&lt;/code&gt;.  These describe “free variables.”  They are so
valuable, that I’d like to take a moment longer to discuss these terms.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;$anyseq&lt;/code&gt; defines an arbitrary value that can change on every clock cycle.
You might find it within a section of Verilog code that looks something like:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;wire	[N-1:0]	some_value;
assign	some_value = $anyseq;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;It’s equivalent to having an unconstrained input (i.e. a “free variable”) to
your module, but doesn’t require you to actually create such an input.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;$anyconst&lt;/code&gt; is similar, only the value of &lt;code class=&quot;highlighter-rouge&quot;&gt;$anyconst&lt;/code&gt; will never change within
a run.  Indeed, not only is it similar, but you’d write it out in the exact
same way.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;wire	[N-1:0]	some_constant;
assign	some_constant = $anyconst;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;With a just one simple assumption, &lt;code class=&quot;highlighter-rouge&quot;&gt;$anyseq&lt;/code&gt; can be turned into an &lt;code class=&quot;highlighter-rouge&quot;&gt;$anyconst&lt;/code&gt;,
as in:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;wire	[N-1:0]	some_constant;
assign	some_constant = $anyseq;
always @($global_clock)
	assume(some_valid == $past(some_value));&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;However, this is only for illustration purposes.  &lt;code class=&quot;highlighter-rouge&quot;&gt;$anyconst&lt;/code&gt; will work
for us today rather than &lt;code class=&quot;highlighter-rouge&quot;&gt;$anyseq&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Specifically, we can use &lt;code class=&quot;highlighter-rouge&quot;&gt;$anyconst&lt;/code&gt; to describe the formal contract between the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt; and
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/dblfetch.v&quot;&gt;this prefetch&lt;/a&gt;
module.  Using &lt;code class=&quot;highlighter-rouge&quot;&gt;$anyconst&lt;/code&gt;, we can describe both an arbitrary address in memory,
as well as an arbitrary value (the instruction) that will be at this address.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;wire	[AW-1:0]	f_const_addr;
wire	[DW-1:0]	f_const_insn;

assign	f_const_addr = $anyconst;
assign	f_const_insn = $anyconst;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Then the basic contract is that any time the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/dblfetch.v&quot;&gt;prefetch&lt;/a&gt;
tells the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
that it has a valid instruction, i.e. &lt;code class=&quot;highlighter-rouge&quot;&gt;o_valid&lt;/code&gt; is true, &lt;em&gt;and&lt;/em&gt; that this
instruction comes from the address listed above, &lt;code class=&quot;highlighter-rouge&quot;&gt;f_const_addr&lt;/code&gt;, &lt;em&gt;then&lt;/em&gt; the
instruction must also match the value listed above as well, &lt;code class=&quot;highlighter-rouge&quot;&gt;f_const_insn&lt;/code&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(*)
if ((o_valid)&amp;amp;&amp;amp;(o_pc == f_const_addr))
	assert(o_insn == f_const_insn);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Well, this is close but it isn’t quite right yet.  This doesn’t handle the
case where an attempt to read from this instruction address results in a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_(computing)&quot;&gt;bus&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_error&quot;&gt;error&lt;/a&gt;.
To handle that case, we’ll need an additional flag to determine
if our arbitrary example address references a legal location on the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_(computing)&quot;&gt;bus&lt;/a&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;wire	f_const_illegal;

assign	f_const_illegal = $anyconst;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Using this new flag, the contract then becomes,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(*)
if ((o_valid)&amp;amp;&amp;amp;(o_pc == f_const_addr))
begin
	assert(o_illegal == f_const_illegal);
	if (!o_illegal)
		assert(o_insn == f_const_insn);
end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Well, even that’s not quite right.  I like using the &lt;code class=&quot;highlighter-rouge&quot;&gt;o_illegal&lt;/code&gt; bit as a
sticky bit.  Once it becomes true, it should stay true until the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt; and
issues an &lt;code class=&quot;highlighter-rouge&quot;&gt;i_new_pc&lt;/code&gt; flag and new &lt;code class=&quot;highlighter-rouge&quot;&gt;i_pc&lt;/code&gt;.  Alternatively, we can clear it on the
rarer &lt;code class=&quot;highlighter-rouge&quot;&gt;i_reset&lt;/code&gt; or &lt;code class=&quot;highlighter-rouge&quot;&gt;i_clear_cache&lt;/code&gt; flags.  This means that our contract is
instead going to be,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(*)
if ((o_valid)&amp;amp;&amp;amp;(o_pc == f_const_addr))
begin
	if (f_const_illegal)
		assert(o_illegal)
	if (!o_illegal)
		assert(o_insn == f_const_insn);
end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;We’ll also have to add some assumptions to our algorithm in order to meet
this contract.  Specifically, we’ll need to assume that any time we read
from the &lt;code class=&quot;highlighter-rouge&quot;&gt;f_const_addr&lt;/code&gt; address
that the result returned will be an acknowledgment (not an error) carrying
&lt;code class=&quot;highlighter-rouge&quot;&gt;f_const_insn&lt;/code&gt; in &lt;code class=&quot;highlighter-rouge&quot;&gt;i_wb_data&lt;/code&gt; if &lt;code class=&quot;highlighter-rouge&quot;&gt;f_const_illegal&lt;/code&gt; is false, or a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_(computing)&quot;&gt;bus&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_error&quot;&gt;error&lt;/a&gt;
if &lt;code class=&quot;highlighter-rouge&quot;&gt;f_const_illegal&lt;/code&gt; is true, but that part will be prefetch specific
so we’ll hold off on that until we get to our actual properties.&lt;/p&gt;

&lt;h2 id=&quot;working-through-the-algorithm&quot;&gt;Working through the Algorithm&lt;/h2&gt;

&lt;p&gt;I normally work through an algorithm via pseudocode before presenting it
here.  Today, we’ll just walk through this by steps–since I’m not sure I
have a simple pseudocode to describe it.&lt;/p&gt;

&lt;p&gt;So, here’s how this algorithm will function:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;On any reset or request to clear the cache, wait for a new PC to be given&lt;/li&gt;
&lt;/ul&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 13. On Reset&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/dblfetch-reset.svg&quot; alt=&quot;&quot; width=&quot;320&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;We’ll assume &lt;code class=&quot;highlighter-rouge&quot;&gt;i_new_pc&lt;/code&gt; takes place on the clock after &lt;code class=&quot;highlighter-rouge&quot;&gt;i_reset&lt;/code&gt;.  That means
that on the clock following &lt;code class=&quot;highlighter-rouge&quot;&gt;i_new_pc&lt;/code&gt;, we want to initiate a bus request
with the address of the program counter just given within &lt;code class=&quot;highlighter-rouge&quot;&gt;i_pc&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;This logic is shown in Fig 13. on the right.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Likewise, on a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_(computing)&quot;&gt;bus&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_error&quot;&gt;error&lt;/a&gt;,
set the error flag and wait for a new
&lt;a href=&quot;https://en.wikipedia.org/wiki/Program_counter&quot;&gt;PC&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;You can see this in Fig 14. on the right.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 14. On a Bus Error&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/dblfetch-buserr.svg&quot; alt=&quot;&quot; width=&quot;280&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;In that figure, you can see that following a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_(computing)&quot;&gt;bus&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_error&quot;&gt;error&lt;/a&gt;:
the bus cycle ends and so &lt;code class=&quot;highlighter-rouge&quot;&gt;o_wb_cyc&lt;/code&gt; drops.  &lt;code class=&quot;highlighter-rouge&quot;&gt;o_valid&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;o_illegal&lt;/code&gt; are
then both set together.  &lt;code class=&quot;highlighter-rouge&quot;&gt;o_valid&lt;/code&gt; indicates that the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_(computing)&quot;&gt;bus&lt;/a&gt;
transaction is complete, &lt;code class=&quot;highlighter-rouge&quot;&gt;o_illegal&lt;/code&gt; that it ended with an invalid instruction.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;On any &lt;code class=&quot;highlighter-rouge&quot;&gt;i_new_pc&lt;/code&gt; request, start a new
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_(computing)&quot;&gt;bus&lt;/a&gt;
transaction.&lt;/li&gt;
&lt;/ul&gt;

&lt;table align=&quot;right&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 15. On a New PC mid-cycle&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/dblfetch-midcycle.svg&quot; alt=&quot;&quot; width=&quot;400&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;As shown in Fig 15 above, if a
  &lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_(computing)&quot;&gt;bus&lt;/a&gt;
  transaction is currently underway when the
  &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
  signals an &lt;code class=&quot;highlighter-rouge&quot;&gt;i_new_pc&lt;/code&gt;, then the
  &lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_(computing)&quot;&gt;bus&lt;/a&gt;
  request is aborted (&lt;code class=&quot;highlighter-rouge&quot;&gt;o_wb_cyc&lt;/code&gt; is dropped) and a new one is started on the
  clock following.  We’ll use the internal register
  &lt;code class=&quot;highlighter-rouge&quot;&gt;invalid_bus_cycle&lt;/code&gt;, as shown in Fig 15, to mark that a 
  &lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_(computing)&quot;&gt;bus&lt;/a&gt; transaction was aborted,
  and that a new
  &lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_(computing)&quot;&gt;bus&lt;/a&gt; transaction
  needs to be initiated on the next clock.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;When any
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_(computing)&quot;&gt;bus&lt;/a&gt;
transaction begins, immediately issue two requests.&lt;/p&gt;

    &lt;p&gt;This was what we showed above in Fig 3 when we started.  Everything starts
with two requests.  Then, if a response comes back before the second request
is issued an additional value will be requested from the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_(computing)&quot;&gt;bus&lt;/a&gt;.&lt;/p&gt;

    &lt;p&gt;Remember the rule: no request may be issued unless there is a place to put
the result–lest the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_(computing)&quot;&gt;bus&lt;/a&gt;
respond faster then we are expecting.  Hence, the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_(computing)&quot;&gt;bus&lt;/a&gt;
transaction starts out with our two instruction “cache” entries empty so we
can issue two requests.  If one value comes back and leaves our “cache” for
the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;,
then we can immediately issue a third request.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The initial address requested will be given by the value in &lt;code class=&quot;highlighter-rouge&quot;&gt;i_pc&lt;/code&gt;
whenever &lt;code class=&quot;highlighter-rouge&quot;&gt;i_new_pc&lt;/code&gt; is true.
Ever after, the request address should increment by one on each clock.&lt;/p&gt;

    &lt;p&gt;This goes for the output
&lt;a href=&quot;https://en.wikipedia.org/wiki/Program_counter&quot;&gt;PC&lt;/a&gt;
value, &lt;code class=&quot;highlighter-rouge&quot;&gt;o_pc&lt;/code&gt; as well.  It will also be set to &lt;code class=&quot;highlighter-rouge&quot;&gt;i_pc&lt;/code&gt;
any time &lt;code class=&quot;highlighter-rouge&quot;&gt;i_new_pc&lt;/code&gt; is true.  However, unlike the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_(computing)&quot;&gt;bus&lt;/a&gt;
addresses which increments on every new
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_(computing)&quot;&gt;bus&lt;/a&gt;
request that is made, this value will instead increment any time the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
accepts an instruction.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Responses to the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_(computing)&quot;&gt;bus&lt;/a&gt;
will be placed into the &lt;code class=&quot;highlighter-rouge&quot;&gt;o_insn&lt;/code&gt; register any time &lt;code class=&quot;highlighter-rouge&quot;&gt;o_valid&lt;/code&gt; is
false, or any time there’s nothing in the cache and &lt;code class=&quot;highlighter-rouge&quot;&gt;i_stall_n&lt;/code&gt; is true.&lt;/p&gt;

    &lt;p&gt;We’ll get deeper into these details in the next section.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;If an instruction is being held in &lt;code class=&quot;highlighter-rouge&quot;&gt;o_valid&lt;/code&gt;, the second return will be
placed into a &lt;code class=&quot;highlighter-rouge&quot;&gt;cache_word&lt;/code&gt;, and then
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_(computing)&quot;&gt;bus&lt;/a&gt;
transaction will stop and the
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;wishbone&lt;/a&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;CYC&lt;/code&gt; line will be lowered.&lt;/p&gt;

    &lt;p&gt;We’ve gone for too long without an image.  Here’s what I’m talking about
in Fig 16.&lt;/p&gt;

    &lt;p&gt;It is important that the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_(computing)&quot;&gt;bus&lt;/a&gt;
request end if the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
is stalled for too long (&lt;code class=&quot;highlighter-rouge&quot;&gt;i_stall_n&lt;/code&gt; is low), as the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
might be stalled at the internal &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/ex/wbdblpriarb.v&quot;&gt;memory vs prefetch
arbiter&lt;/a&gt;
while trying to access the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_(computing)&quot;&gt;bus&lt;/a&gt;.
By making sure that we never receive more than two instructions, and then
let the &lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_(computing)&quot;&gt;bus&lt;/a&gt;
return to idle, we keep the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
from entering into a deadlock state.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;All of this needs to be subject to the rule that the two element return
&lt;a href=&quot;https://en.wikipedia.org/wiki/FIFO_(computing_and_electronics)&quot;&gt;FIFO&lt;/a&gt;
cannot be allowed to ever overflow it’s two instruction depth.  We’ll use
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal properties&lt;/a&gt;
below to convince ourselves that such will never happen.&lt;/p&gt;

&lt;h2 id=&quot;the-code&quot;&gt;The Code&lt;/h2&gt;

&lt;p&gt;Now that you know the basic idea behind
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/dblfetch.v&quot;&gt;the code&lt;/a&gt;,
it’s time to examine it in detail.  Once we finish, we’ll get into the
formal properties necessary to verify that this works in the next section.&lt;/p&gt;

&lt;p&gt;We’ll start from the beginning: when shall a bus transaction begin and
end?  As you may recall from the &lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal
properties&lt;/a&gt; of the
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;wishbone bus&lt;/a&gt;,
&lt;code class=&quot;highlighter-rouge&quot;&gt;o_wb_cyc&lt;/code&gt; will capture anytime we in the middle of one (or more) transactions,
and &lt;code class=&quot;highlighter-rouge&quot;&gt;o_wb_stb&lt;/code&gt; will be true anytime we are making a request of the
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;.
You may also remember that &lt;code class=&quot;highlighter-rouge&quot;&gt;o_wb_stb&lt;/code&gt; can only ever be true during a
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;
cycle.  Hence, &lt;code class=&quot;highlighter-rouge&quot;&gt;o_wb_stb&lt;/code&gt; must imply that &lt;code class=&quot;highlighter-rouge&quot;&gt;o_wb_cyc&lt;/code&gt; is also true.&lt;/p&gt;

&lt;p&gt;The &lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;
initially starts out idle.  We’ll also return to an idle on any reset
or &lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_(computing)&quot;&gt;bus&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_error&quot;&gt;error&lt;/a&gt;.
This logic is similar to any &lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;Wishbone
bus&lt;/a&gt;
master.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	initial	o_wb_cyc = 1&#39;b0;
	initial	o_wb_stb = 1&#39;b0;
	always @(posedge i_clk)
		if ((i_reset)||((o_wb_cyc)&amp;amp;&amp;amp;(i_wb_err)))
		begin
			o_wb_cyc &amp;lt;= 1&#39;b0;
			o_wb_stb &amp;lt;= 1&#39;b0;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Next, during any
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;
transaction, we’ll keep issuing transactions
until a &lt;code class=&quot;highlighter-rouge&quot;&gt;last_stb&lt;/code&gt; flag becomes true.  We’re going to use this &lt;code class=&quot;highlighter-rouge&quot;&gt;last_stb&lt;/code&gt;
idea to keep this set of
&lt;a href=&quot;/blog/2017/06/12/minimizing-luts.html&quot;&gt;logic simpler&lt;/a&gt;,
since &lt;code class=&quot;highlighter-rouge&quot;&gt;last_stb&lt;/code&gt; can be calculated on the prior clock.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;		end else if (o_wb_cyc)
		begin
			if ((!o_wb_stb)||(!i_wb_stall))
				o_wb_stb &amp;lt;= (!last_stb);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Releasing the
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;
is a little more complicated.&lt;/p&gt;

&lt;p&gt;The first step is to count the number of items in flight at any given time.
We’ll place this count into &lt;code class=&quot;highlighter-rouge&quot;&gt;inflight&lt;/code&gt; and come back to the logic to do
this later.&lt;/p&gt;

&lt;p&gt;We’ll end the transaction on any last acknowledgment.
We’re also going to release the
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;
anytime we’ve made our last request,
and nothing is in flight.  Finally, anytime a new
&lt;a href=&quot;https://en.wikipedia.org/wiki/Program_counter&quot;&gt;program counter&lt;/a&gt;
is given to us, or any time we are asked to clear our cache, we’ll
also end this
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;
transaction.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;			if (((i_wb_ack)&amp;amp;&amp;amp;(!o_wb_stb)&amp;amp;&amp;amp;(inflight&amp;lt;=1))
				||((!o_wb_stb)&amp;amp;&amp;amp;(inflight == 0))
				// Or any new transaction request
				||((i_new_pc)||(i_clear_cache)))
			begin
				o_wb_cyc &amp;lt;= 1&#39;b0;
				o_wb_stb &amp;lt;= 1&#39;b0;
			end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;That’s how we’ll end a transaction, but when will one start?&lt;/p&gt;

&lt;p&gt;We’re going to need to start a transaction on a couple conditions.
First, if we are idle and the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
asks for a new
&lt;a href=&quot;https://en.wikipedia.org/wiki/Program_counter&quot;&gt;PC&lt;/a&gt;,
we’ll need to start
a transaction.  Likewise, if the last transaction was aborted because the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
requested a new
&lt;a href=&quot;https://en.wikipedia.org/wiki/Program_counter&quot;&gt;PC&lt;/a&gt;,
then &lt;code class=&quot;highlighter-rouge&quot;&gt;invalid_bus_cycle&lt;/code&gt; will be true and we need to start again.  Finally,
any time we’ve run our two instruction cache/FIFO
dry, then we’ll start a new
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;
cycle as well.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;		end else if ((i_new_pc)||(invalid_bus_cycle)
			||((o_valid)&amp;amp;&amp;amp;(i_stall_n)&amp;amp;&amp;amp;(!o_illegal)))
		begin
			// ...
			o_wb_cyc &amp;lt;= 1&#39;b1;
			o_wb_stb &amp;lt;= 1&#39;b1;
		end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Normally, when I build a multi-transaction
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;
master, I know ahead of time how many transaction requests to issue.  Examples
would be the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/pfcache.v&quot;&gt;prefetch plus
cache&lt;/a&gt;
bus master, which always fetches a complete cache line, and the &lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/rtl/wbuexec.v&quot;&gt;full-featured
debugging bus
master&lt;/a&gt;
I like to use.  In the case of the &lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/rtl/wbuexec.v&quot;&gt;debugging
bus&lt;/a&gt;,
the read
&lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/rtl/wbuexec.v&quot;&gt;bus&lt;/a&gt;,
request tells it how many transactions to request, although the write
&lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/rtl/wbuexec.v&quot;&gt;bus&lt;/a&gt;,
request just requests an additional transaction.&lt;/p&gt;

&lt;p&gt;This &lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;
master is different.&lt;/p&gt;

&lt;p&gt;In this case, we want to issue two requests, and then possibly more depending
on whether or not we have enough available spaces.  Doing this requires
counting the number of transactions in flight.  We’ll do this with the
register, &lt;code class=&quot;highlighter-rouge&quot;&gt;inflight&lt;/code&gt;.  Upon any successful
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;
request, we’ll increment this value and on
any acknowledgment we’ll decrement it to keep a count of what’s
in flight.  (We don’t need to adjust our count on
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_error&quot;&gt;error&lt;/a&gt;,
since the
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;
transaction will always be aborted on any
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_error&quot;&gt;error&lt;/a&gt;
anyway.)&lt;/p&gt;

&lt;p&gt;There are some key features of this logic.  Because an acknowledgment can come
back when the &lt;code class=&quot;highlighter-rouge&quot;&gt;o_wb_cyc&lt;/code&gt; line is low, such as immediately following an
aborted transaction, we’ll just set everything to zero if &lt;code class=&quot;highlighter-rouge&quot;&gt;o_wb_cyc&lt;/code&gt; is low.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	initial	inflight = 2&#39;b00;
	always @(posedge i_clk)
	if (!o_wb_cyc)
		inflight &amp;lt;= 2&#39;b00;
	else begin&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;After that, we increase the number of items in flight on any accepted
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;
request, and decrease the number on any acknowledgment.  If neither are true,
or if both are true, the count won’t change.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;		case({ ((o_wb_stb)&amp;amp;&amp;amp;(!i_wb_stall)), i_wb_ack })
		2&#39;b01:	inflight &amp;lt;= inflight - 1&#39;b1;
		2&#39;b10:	inflight &amp;lt;= inflight + 1&#39;b1;
		// If neither ack nor request, then no change.  Likewise
		// if we have both an ack and a request, there&#39;s no change
		// in the number of requests in flight.
		default: begin end
		endcase
	end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Just as an example of how
&lt;a href=&quot;/blog/2018/03/14/is-formal-hard.html&quot;&gt;easy formal can be&lt;/a&gt;,
I knew when I wrote these lines that &lt;code class=&quot;highlighter-rouge&quot;&gt;inflight&lt;/code&gt; could never be greater than
two.  Hence, I originally placed an assert statement here to that effect.
It has since been moved to our formal section and so we’ll discuss it
below when we get to it.  I only bring it up here to discuss an example
situation where it is useful to immediately write a formal property.&lt;/p&gt;

&lt;p&gt;Let’s move on to the &lt;code class=&quot;highlighter-rouge&quot;&gt;last_stb&lt;/code&gt; piece of logic.  You may recall from above
that we used a piece of logic to determine when the current request was the last
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;
request that needed to be issued.  Normally when I build a
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;
master, this is a registered value–set on the clock before the last strobe.
A good example of this would be the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/wbdmac.v&quot;&gt;DMA controller&lt;/a&gt; for the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;,
which separates the difficult logic of when to end a
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;
cycle from the already
&lt;a href=&quot;/blog/2017/06/12/minimizing-luts.html&quot;&gt;difficult logic&lt;/a&gt;,
describing the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/wbdmac.v&quot;&gt;DMA&lt;/a&gt;
state machine.&lt;/p&gt;

&lt;p&gt;This isn’t that either.&lt;/p&gt;

&lt;p&gt;This &lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;
master is different because I want to keep issuing requests anytime the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
accepts an instruction.  In this case, the second strobe will be the
last strobe–i.e. if the number in flight is more than one.  Likewise if
there’s a valid instruction waiting for the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
then this also needs to be the last
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;
request.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(*)
		last_stb = (inflight != 2&#39;b00)||((o_valid)&amp;amp;&amp;amp;(!i_stall_n));&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The next register, &lt;code class=&quot;highlighter-rouge&quot;&gt;invalid_bus_cycle&lt;/code&gt;, is one I’ve tried to get rid of many
times.  In many ways it feels redundant.  Timing, however, requires it.
Specifically, my problem is this: if &lt;code class=&quot;highlighter-rouge&quot;&gt;i_new_pc&lt;/code&gt; comes during the middle of a
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;
cycle, &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/dblfetch.v&quot;&gt;the
prefetch&lt;/a&gt;
immediately aborts that
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;
cycle.  The
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;
cycle needs to then be re-initiated on the next clock cycle, as shown in Fig 15
above.  That’s the purpose of &lt;code class=&quot;highlighter-rouge&quot;&gt;invalid_bus_cycle&lt;/code&gt;: to tell the design to start
up a new
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;
cycle after the last one was artificially ended by an &lt;code class=&quot;highlighter-rouge&quot;&gt;i_new_pc&lt;/code&gt; request.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	initial	invalid_bus_cycle = 1&#39;b0;
	always @(posedge i_clk)
		if (i_reset)
			invalid_bus_cycle &amp;lt;= 1&#39;b0;
		else if ((o_wb_cyc)&amp;amp;&amp;amp;(i_new_pc))
			invalid_bus_cycle &amp;lt;= 1&#39;b1;
		else if (!o_wb_cyc)
			invalid_bus_cycle &amp;lt;= 1&#39;b0;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;We discussed above how the
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;
request address, &lt;code class=&quot;highlighter-rouge&quot;&gt;o_wb_addr&lt;/code&gt;, will be set by
the address given on any &lt;code class=&quot;highlighter-rouge&quot;&gt;i_new_pc&lt;/code&gt; request.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	initial	o_wb_addr = {(AW){1&#39;b1}};
	always @(posedge i_clk)
		if (i_new_pc)
			o_wb_addr &amp;lt;= i_pc[AW+1:2];&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Other than on any &lt;code class=&quot;highlighter-rouge&quot;&gt;i_new_pc&lt;/code&gt; request, we’ll increment the
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;
address on every successful transaction request but leave it alone otherwise.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;		else if ((o_wb_stb)&amp;amp;&amp;amp;(!i_wb_stall))
			o_wb_addr &amp;lt;= o_wb_addr + 1&#39;b1;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;We can now look at the &lt;code class=&quot;highlighter-rouge&quot;&gt;o_valid&lt;/code&gt; signal.  As you may recall, this signal
needs to be true any time a valid instruction is being presented to the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;We’ll start on reset.  On any reset, any &lt;code class=&quot;highlighter-rouge&quot;&gt;i_new_pc&lt;/code&gt; request, or any request
to &lt;code class=&quot;highlighter-rouge&quot;&gt;i_clear_cache&lt;/code&gt;, we’ll clear this valid signal.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	initial	o_valid = 1&#39;b0;
	always @(posedge i_clk)
		if ((i_reset)||(i_new_pc)||(i_clear_cache))
			o_valid &amp;lt;= 1&#39;b0;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Further, on any valid return from the
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;,
whether an acknowledgment or an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_error&quot;&gt;error&lt;/a&gt;,
we’ll set the valid signal to true.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;		else if ((o_wb_cyc)&amp;amp;&amp;amp;((i_wb_ack)||(i_wb_err)))
			o_valid &amp;lt;= 1&#39;b1;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The final piece of logic references what to do if the
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;
isn’t providing an instruction, but the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
has just accepted the one we’ve presented to it within &lt;code class=&quot;highlighter-rouge&quot;&gt;o_insn&lt;/code&gt;.  In this case,
whether or not we are valid will be determined by whether or not the
second word in our FIFO or cache, &lt;code class=&quot;highlighter-rouge&quot;&gt;cache_word&lt;/code&gt;, has a valid value within it.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;		else if (i_stall_n)
			o_valid &amp;lt;= cache_valid;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;o_valid&lt;/code&gt; tells the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
when the instruction from the
&lt;a href=&quot;/zipcpu/2017/11/18/wb-prefetch.html&quot;&gt;prefetch&lt;/a&gt;
is a valid instruction.  The instruction itself is kept in the &lt;code class=&quot;highlighter-rouge&quot;&gt;o_insn&lt;/code&gt;
register, our next item to discuss.&lt;/p&gt;

&lt;p&gt;As you’ll recall from above, there are a couple cases to consider with &lt;code class=&quot;highlighter-rouge&quot;&gt;o_insn&lt;/code&gt;.
If &lt;code class=&quot;highlighter-rouge&quot;&gt;o_valid&lt;/code&gt; isn’t true, then &lt;code class=&quot;highlighter-rouge&quot;&gt;o_insn&lt;/code&gt; is a don’t care.  If &lt;code class=&quot;highlighter-rouge&quot;&gt;o_valid&lt;/code&gt;
is true, but &lt;code class=&quot;highlighter-rouge&quot;&gt;i_stall_n&lt;/code&gt; is false, then the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
is busy (stalled), and the
instruction must stay ready and unchanged until the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
is ready to accept it.&lt;/p&gt;

&lt;p&gt;Hence, any time &lt;code class=&quot;highlighter-rouge&quot;&gt;o_valid&lt;/code&gt; is false, or any time the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
is ready to accept an instruction, then we can update the instruction.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	initial	o_insn = {(32){1&#39;b1}};
	always @(posedge i_clk)
	if ((!o_valid)||(i_stall_n))
	begin&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;If the cache word is valid, then we want to present the cache word as the
next instruction word.  Otherwise, the next instruction word can only come from
the &lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;.
While it may not be on the
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;
on this cycle, it will eventually be on the
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;,
i.e. in &lt;code class=&quot;highlighter-rouge&quot;&gt;i_wb_data&lt;/code&gt;, and then &lt;code class=&quot;highlighter-rouge&quot;&gt;o_valid&lt;/code&gt; will be set on the
next clock–keeping us from changing again until the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
accepts the instruction.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;		if (cache_valid)
			o_insn &amp;lt;= cache_word;
		else
			o_insn &amp;lt;= i_wb_data;
	end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;As a side note, you may notice that the logic for this 32-bit word has
been kept very simple.  &lt;a href=&quot;/blog/2017/06/12/minimizing-luts.html&quot;&gt;This is
important&lt;/a&gt;.
Complex logic on a wide bus can suddenly and greatly &lt;a href=&quot;/blog/2017/06/12/minimizing-luts.html&quot;&gt;increase your logic
usage&lt;/a&gt;.
Instead, we are reserving the complex logic for the one or two wire
registers, such as &lt;code class=&quot;highlighter-rouge&quot;&gt;o_wb_cyc&lt;/code&gt; or &lt;code class=&quot;highlighter-rouge&quot;&gt;o_wb_stb&lt;/code&gt; above, while keeping the logic
for the larger registers, like &lt;code class=&quot;highlighter-rouge&quot;&gt;o_insn&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;o_wb_addr&lt;/code&gt;, or even &lt;code class=&quot;highlighter-rouge&quot;&gt;o_pc&lt;/code&gt; simple.&lt;/p&gt;

&lt;p&gt;Speaking of &lt;code class=&quot;highlighter-rouge&quot;&gt;o_pc&lt;/code&gt;, that’s our next register to examine.  The
&lt;code class=&quot;highlighter-rouge&quot;&gt;o_pc&lt;/code&gt; register is very similar to the &lt;code class=&quot;highlighter-rouge&quot;&gt;o_wb_addr&lt;/code&gt; register that we dealt with
above.  It needs to be set on any &lt;code class=&quot;highlighter-rouge&quot;&gt;i_new_pc&lt;/code&gt; event, and otherwise incremented
any time the output instruction is valid, &lt;code class=&quot;highlighter-rouge&quot;&gt;o_valid&lt;/code&gt;, and the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
accepts that instruction, &lt;code class=&quot;highlighter-rouge&quot;&gt;i_stall_n&lt;/code&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	initial	o_pc = 0;
	always @(posedge i_clk)
		if (i_new_pc)
			o_pc &amp;lt;= i_pc;
		else if ((o_valid)&amp;amp;&amp;amp;(i_stall_n))
			o_pc[AW+1:2] &amp;lt;= o_pc[AW+1:2] + 1&#39;b1;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;You’ll notice that we kept this logic
&lt;a href=&quot;/blog/2017/06/12/minimizing-luts.html&quot;&gt;simple&lt;/a&gt; as well,
since the number of LUTs required by
this logic will be required &lt;em&gt;for every bit&lt;/em&gt; of &lt;code class=&quot;highlighter-rouge&quot;&gt;o_pc&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Just to illustrate this point, the &lt;code class=&quot;highlighter-rouge&quot;&gt;o_pc&lt;/code&gt; logic alone uses 61 4-LUTs of the
total 246 LUTs used by the design as a whole on an iCE40.  That’s a whole 24%
of the total logic for this design–and it’s a very minimal piece of logic at
that.&lt;/p&gt;

&lt;p&gt;The final word used to interface with the rest of the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
is the &lt;code class=&quot;highlighter-rouge&quot;&gt;o_illegal&lt;/code&gt; register.  This is the flag used to tell the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
that the attempt to read from this address resulted in a
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_error&quot;&gt;error&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;We’ll clear this flag on any reset, or &lt;code class=&quot;highlighter-rouge&quot;&gt;i_new_pc&lt;/code&gt; request.  Likewise, we’ll
clear it on any request to clear the cache, &lt;code class=&quot;highlighter-rouge&quot;&gt;i_clear_cache&lt;/code&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	initial	o_illegal = 1&#39;b0;
	always @(posedge i_clk)
		if ((i_reset)||(i_new_pc)||(i_clear_cache))
			o_illegal &amp;lt;= 1&#39;b0;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;As with &lt;code class=&quot;highlighter-rouge&quot;&gt;o_insn&lt;/code&gt;, nothing is allowed to change if we have a valid
instruction that the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
hasn’t yet accepted the last instruction, or equivalently if
&lt;code class=&quot;highlighter-rouge&quot;&gt;(o_valid)&amp;amp;&amp;amp;(!i_stall_n)&lt;/code&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;		else if ((!o_valid)||(i_stall_n))
		begin&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;That brings us to how &lt;code class=&quot;highlighter-rouge&quot;&gt;o_illegal&lt;/code&gt; needs to be set.  If the &lt;code class=&quot;highlighter-rouge&quot;&gt;cache_word&lt;/code&gt; is
valid, then it moves into the &lt;code class=&quot;highlighter-rouge&quot;&gt;o_insn&lt;/code&gt; position.  At that same time,
if the &lt;code class=&quot;highlighter-rouge&quot;&gt;cache_illegal&lt;/code&gt; flag associated with that &lt;code class=&quot;highlighter-rouge&quot;&gt;cache_word&lt;/code&gt; is true,
that will indicate that a
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_error&quot;&gt;error&lt;/a&gt;
was returned while attempting to request the second word.  This illegal
flag will then also need to move into the &lt;code class=&quot;highlighter-rouge&quot;&gt;o_insn&lt;/code&gt; position and we’ll set
&lt;code class=&quot;highlighter-rouge&quot;&gt;o_illegal&lt;/code&gt; in that case.&lt;/p&gt;

&lt;p&gt;Otherwise, if the cached value isn’t valid, then there’s nothing in our
cache and we’ll need to set the &lt;code class=&quot;highlighter-rouge&quot;&gt;o_illegal&lt;/code&gt; flag immediately on a
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_error&quot;&gt;error&lt;/a&gt;,
since that’s the value directly going into the first output position,
&lt;code class=&quot;highlighter-rouge&quot;&gt;o_insn&lt;/code&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;			if (cache_valid)
				o_illegal &amp;lt;= (o_illegal)||(cache_illegal);
			else if ((o_wb_cyc)&amp;amp;&amp;amp;(i_wb_err))
				o_illegal &amp;lt;= 1&#39;b1;
		end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Ok, so we’ve now dealt with the output values to the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;:
&lt;code class=&quot;highlighter-rouge&quot;&gt;o_valid&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;o_insn&lt;/code&gt;, and &lt;code class=&quot;highlighter-rouge&quot;&gt;o_illegal&lt;/code&gt;.  These are the values associated
with the current item being sent to the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
from our two instruction FIFO.&lt;/p&gt;

&lt;p&gt;Let’s now turn our attention to that second response from the bus, the &lt;em&gt;other&lt;/em&gt;
element in our two instruction FIFO.  We’ll store this value in the word
&lt;code class=&quot;highlighter-rouge&quot;&gt;cache_word&lt;/code&gt;, and mark it as valid using &lt;code class=&quot;highlighter-rouge&quot;&gt;cache_valid&lt;/code&gt;.
Should this word be the result of a
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_error&quot;&gt;error&lt;/a&gt;,
we’ll then set the value &lt;code class=&quot;highlighter-rouge&quot;&gt;cache_illegal&lt;/code&gt; to reflect this.&lt;/p&gt;

&lt;p&gt;We’ll start here, though, with &lt;code class=&quot;highlighter-rouge&quot;&gt;cache_valid&lt;/code&gt;.  On any reset, any new
&lt;a href=&quot;https://en.wikipedia.org/wiki/Program_counter&quot;&gt;PC&lt;/a&gt;,
or any time we clear the cache, &lt;code class=&quot;highlighter-rouge&quot;&gt;cache_valid&lt;/code&gt; needs to be cleared.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	initial	cache_valid = 1&#39;b0;
	always @(posedge i_clk)
		if ((i_reset)||(i_new_pc)||(i_clear_cache))
			cache_valid &amp;lt;= 1&#39;b0;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Otherwise, we need to set it any time &lt;code class=&quot;highlighter-rouge&quot;&gt;o_valid&lt;/code&gt; is true, the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt; is
stalled &lt;code class=&quot;highlighter-rouge&quot;&gt;(!i_stall_n)&lt;/code&gt;, and a return comes in from the
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;.
In a similar fashion, we’ll need to clear this flag anytime the &lt;code class=&quot;highlighter-rouge&quot;&gt;cache_word&lt;/code&gt;
gets moved into the &lt;code class=&quot;highlighter-rouge&quot;&gt;o_insn&lt;/code&gt; position and presented to the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;.
 This will be when &lt;code class=&quot;highlighter-rouge&quot;&gt;i_stall_n&lt;/code&gt; is true, but not response is coming from the
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The only catch is when/if &lt;code class=&quot;highlighter-rouge&quot;&gt;cache_valid&lt;/code&gt; is already true and a new response
comes back from the
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;. (This should never
happen.) In this case, &lt;code class=&quot;highlighter-rouge&quot;&gt;cache_valid&lt;/code&gt; needs to be set as well.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;		else begin
			if ((o_valid)&amp;amp;&amp;amp;(o_wb_cyc)&amp;amp;&amp;amp;((i_wb_ack)||(i_wb_err)))
				cache_valid &amp;lt;= (!i_stall_n)||(cache_valid);
			else if (i_stall_n)
				cache_valid &amp;lt;= 1&#39;b0;
		end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This brings us to the cache word.  As you’ll recall from above, the
&lt;code class=&quot;highlighter-rouge&quot;&gt;cache_word&lt;/code&gt; register is the second word in the output FIFO after &lt;code class=&quot;highlighter-rouge&quot;&gt;o_insn&lt;/code&gt;.
This value is completely irrelevant, though, unless &lt;code class=&quot;highlighter-rouge&quot;&gt;cache_valid&lt;/code&gt; (above)
is also true.  Hence, we can set it to whatever returns from the
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt; in
&lt;code class=&quot;highlighter-rouge&quot;&gt;i_wb_data&lt;/code&gt; whenever it returns.  We’ll use other logic, above in &lt;code class=&quot;highlighter-rouge&quot;&gt;cache_valid&lt;/code&gt;,
to determine whether or not this value is relevant to us.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(posedge i_clk)
		if ((o_wb_cyc)&amp;amp;&amp;amp;(i_wb_ack))
			cache_word &amp;lt;= i_wb_data;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Obviously this will fail if an acknowledgment is returned while &lt;code class=&quot;highlighter-rouge&quot;&gt;cache_valid&lt;/code&gt;
is true.  We’ll need to make certain this never happens, and we’ll use the
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal methods&lt;/a&gt;
below to convince ourselves that this will never happen.&lt;/p&gt;

&lt;p&gt;The last value is the &lt;code class=&quot;highlighter-rouge&quot;&gt;cache_illegal&lt;/code&gt; value.  This flag is used to
indicate that the second response from the
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt; was a
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_error&quot;&gt;error&lt;/a&gt;,
&lt;code class=&quot;highlighter-rouge&quot;&gt;i_wb_err&lt;/code&gt;.  As before, this value is cleared on any &lt;code class=&quot;highlighter-rouge&quot;&gt;i_reset&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;i_new_pc&lt;/code&gt;,
or &lt;code class=&quot;highlighter-rouge&quot;&gt;i_clear_cache&lt;/code&gt;.  After that, it’s set on any &lt;code class=&quot;highlighter-rouge&quot;&gt;i_wb_err&lt;/code&gt; return where
the first
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;
return position in the FIFO is stuck waiting on the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;,
&lt;code class=&quot;highlighter-rouge&quot;&gt;(o_valid)&amp;amp;&amp;amp;(!i_stall_n)&lt;/code&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	initial	cache_illegal = 1&#39;b0;
	always @(posedge i_clk)
	if ((i_reset)||(i_clear_cache)||(i_new_pc))
		cache_illegal &amp;lt;= 1&#39;b0;
	else if ((o_wb_cyc)&amp;amp;&amp;amp;(i_wb_err)&amp;amp;&amp;amp;(o_valid)&amp;amp;&amp;amp;(!i_stall_n))
		cache_illegal &amp;lt;= 1&#39;b1;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Remember that the &lt;code class=&quot;highlighter-rouge&quot;&gt;i_wb_err&lt;/code&gt; flag needs to be cross-checked with the
&lt;code class=&quot;highlighter-rouge&quot;&gt;o_wb_cyc&lt;/code&gt; flag, since suddenly dropping &lt;code class=&quot;highlighter-rouge&quot;&gt;o_wb_cyc&lt;/code&gt; might still allow
&lt;code class=&quot;highlighter-rouge&quot;&gt;i_wb_err&lt;/code&gt; to return on the next cycle when &lt;code class=&quot;highlighter-rouge&quot;&gt;o_wb_cyc&lt;/code&gt; is low.&lt;/p&gt;

&lt;p&gt;That’s it!  At this point, we have a completed
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/dblfetch.v&quot;&gt;prefetch module&lt;/a&gt;
that will continue fetching instructions from memory until it’s two
instruction word FIFO is full and the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
remains stalled.&lt;/p&gt;

&lt;p&gt;But … does it work?  That’s the point of the
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal properties&lt;/a&gt;
presented in the next section.&lt;/p&gt;

&lt;h2 id=&quot;the-formal-properties&quot;&gt;The Formal Properties&lt;/h2&gt;

&lt;p&gt;A &lt;a href=&quot;/zipcpu/2017/11/18/wb-prefetch.html&quot;&gt;prefetch&lt;/a&gt;
has two basic interfaces it needs to maintain, as shown
above in Fig 12.  The first is formally characterized by the set of &lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;wishbone
properties&lt;/a&gt;.
The second interface is to the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;.
Therefore, we’ll spend some time putting together the assumptions and assertions
necessary for interacting with the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;.
Finally, we’ll present the logic necessary to formally verify that &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/dblfetch.v&quot;&gt;this
prefetch&lt;/a&gt;
formally maintains its &lt;em&gt;contract&lt;/em&gt; with the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt; as
we discussed above.&lt;/p&gt;

&lt;p&gt;We’ll start with the
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal properties&lt;/a&gt;
necessary for interacting with the
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;wishbone bus&lt;/a&gt;.
Aside from assuming that &lt;code class=&quot;highlighter-rouge&quot;&gt;i_reset&lt;/code&gt; is true on startup,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	initial	`ASSUME(i_reset);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;most of this is already done for us by the &lt;code class=&quot;highlighter-rouge&quot;&gt;fwb_master&lt;/code&gt; module.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	localparam	F_LGDEPTH=2;
	wire	[(F_LGDEPTH-1):0]	f_nreqs, f_nacks, f_outstanding;

	//
	// Add a bunch of wishbone-based asserts
	fwb_master #(.AW(AW), .DW(DW), .F_LGDEPTH(F_LGDEPTH),
				.F_MAX_STALL(2),
				.F_MAX_REQUESTS(0), .F_OPT_SOURCE(1),
				.F_OPT_CLK2FFLOGIC(F_OPT_CLK2FFLOGIC),
				.F_OPT_RMW_BUS_OPTION(1),
				.F_OPT_DISCONTINUOUS(0))
		f_wbm(i_clk, i_reset,
			o_wb_cyc, o_wb_stb, o_wb_we, o_wb_addr, o_wb_data, 4&#39;h0,
			i_wb_ack, i_wb_stall, i_wb_data, i_wb_err,
			f_nreqs, f_nacks, f_outstanding);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;You may remember how we built that
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;property list together&lt;/a&gt;
earlier, right?&lt;/p&gt;

&lt;p&gt;In this case, the important parts of this are the parameters being used
to set this up.  First, we’re only expecting a two items to ever be in
flight at a time, so we can set &lt;code class=&quot;highlighter-rouge&quot;&gt;F_LGDEPTH&lt;/code&gt; to two.  Second, just to keep
things moving, we’ll assume that the
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;
will never stall more than 2
clocks at a time, &lt;code class=&quot;highlighter-rouge&quot;&gt;F_MAX_STALL(2)&lt;/code&gt;.  We won’t set a maximum number of
requests, since our particular goal is to allow us to continually make
requests until our result buffer is full.  &lt;code class=&quot;highlighter-rouge&quot;&gt;F_OPT_SOURCE&lt;/code&gt; is set to
true, just to check that &lt;code class=&quot;highlighter-rouge&quot;&gt;o_wb_stb&lt;/code&gt; gets set to true any time
&lt;code class=&quot;highlighter-rouge&quot;&gt;o_wb_cyc&lt;/code&gt; rises.&lt;/p&gt;

&lt;p&gt;It’s really just about that simple, but there is one exception: we’ll
&lt;a href=&quot;/blog/2018/03/14/is-formal-hard.html&quot;&gt;need to tie our logic&lt;/a&gt;
to the &lt;code class=&quot;highlighter-rouge&quot;&gt;f_nreqs&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;f_nacks&lt;/code&gt;, and &lt;code class=&quot;highlighter-rouge&quot;&gt;f_outstanding&lt;/code&gt; signals, or we won’t pass the
&lt;a href=&quot;/blog/2018/03/10/induction-exercise.html&quot;&gt;formal induction&lt;/a&gt;
step.&lt;/p&gt;

&lt;p&gt;That logic is coming up in a bit.&lt;/p&gt;

&lt;p&gt;The next section discusses the assumptions associated with interacting with
the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;.
To make sure these statements hold properly, we’ll use a variety
of &lt;code class=&quot;highlighter-rouge&quot;&gt;f_past_*&lt;/code&gt; variables.  We’ll use these in place of the &lt;code class=&quot;highlighter-rouge&quot;&gt;$past()&lt;/code&gt; operator,
since
&lt;a href=&quot;/blog/2017/06/21/looking-at-verilator.html&quot;&gt;Verilator&lt;/a&gt;
doesn’t support it (yet).  This includes &lt;code class=&quot;highlighter-rouge&quot;&gt;f_past_reset&lt;/code&gt;,
&lt;code class=&quot;highlighter-rouge&quot;&gt;f_past_clear_cache&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;f_past_o_valid&lt;/code&gt;, and &lt;code class=&quot;highlighter-rouge&quot;&gt;f_past_stall_n&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The first assumption is that following any reset, the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
will provide a new
&lt;a href=&quot;https://en.wikipedia.org/wiki/Program_counter&quot;&gt;instruction address&lt;/a&gt;
on the next clock cycle.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(posedge i_clk)
		if ((f_past_valid)&amp;amp;&amp;amp;(f_past_reset))
			assume(i_new_pc);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;We’ll assume the same of an &lt;code class=&quot;highlighter-rouge&quot;&gt;i_clear_cache&lt;/code&gt; request, that the next clock
cycle will provide us with an new
&lt;a href=&quot;https://en.wikipedia.org/wiki/Program_counter&quot;&gt;PC&lt;/a&gt;
value.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(posedge i_clk)
		if ((f_past_valid)&amp;amp;&amp;amp;(f_past_clear_cache))
			assume(i_new_pc);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Further, we know from the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;’s code
that the &lt;code class=&quot;highlighter-rouge&quot;&gt;i_clear_cache&lt;/code&gt; request will never be held high for two clocks
in a row.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(posedge i_clk)
	if (f_past_clear_cache)
		assume(!i_clear_cache);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This brings us to a rather unusual assertion.&lt;/p&gt;

&lt;p&gt;Some time ago, I got frustrated trying to translate between word addresses
on the
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;
and the byte addresses the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
uses.  In a fit of frustration, I converted all of the versions of the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Program_counter&quot;&gt;program counter&lt;/a&gt;
maintained within the
design to byte addressing.  That means that the bottom two bits of 
&lt;code class=&quot;highlighter-rouge&quot;&gt;i_pc&lt;/code&gt; need to be zero.  It also means the bottom two bits of &lt;code class=&quot;highlighter-rouge&quot;&gt;o_pc&lt;/code&gt; will
need to be zero, but we’ll get to that one later.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(*)
		assume(i_pc[1:0] == 2&#39;b00);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The result of using byte addressing is that I can now correlate these
&lt;a href=&quot;https://en.wikipedia.org/wiki/Program_counter&quot;&gt;program counter&lt;/a&gt; values
with the byte addresses in a dump of any
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
executable.&lt;/p&gt;

&lt;p&gt;Now let’s talk about the &lt;code class=&quot;highlighter-rouge&quot;&gt;i_stall_n&lt;/code&gt; line.  Following any reset, the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
will be reset and there will be no reason to stall.  Hence, following any
reset &lt;code class=&quot;highlighter-rouge&quot;&gt;i_stall_n&lt;/code&gt; will be true indicating that the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
is &lt;em&gt;ready&lt;/em&gt; to accept an instruction.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	initial	assume(i_stall_n);
	always @(posedge i_clk)
		if ((f_past_valid)&amp;amp;&amp;amp;(f_past_reset))
			assume(i_stall_n);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;In a similar manner, the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
will never become busy and stall unless it has already accepted an instruction.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(posedge i_clk)
		if ((f_past_valid)&amp;amp;&amp;amp;(!f_past_o_valid)&amp;amp;&amp;amp;(f_past_stall_n))
			assume(i_stall_n);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Our last criteria regarding our interaction with the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
is the assumption that the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
will always accept an instruction within four clocks.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	localparam	F_CPU_DELAY = 4;
	reg	[4:0]	f_cpu_delay;

	// Now, let&#39;s look at the delay the CPU takes to accept an instruction.
	always @(posedge i_clk)
		// If no instruction is ready, then keep our counter at zero
		if ((!o_valid)||(i_stall_n))
			f_cpu_delay &amp;lt;= 0;
		else
			// Otherwise, count the clocks the CPU takes to respond
			f_cpu_delay &amp;lt;= f_cpu_delay + 1&#39;b1;

	always @(posedge i_clk)
		assume(f_cpu_delay &amp;lt; F_CPU_DELAY);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This isn’t necessarily true.  A divide instruction might cause the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
to stall for 30+ clocks.  However, it’s good enough to speed our way through
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal verification&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;We can now turn to some assertions about our outputs to the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;.
This isn’t (yet) the contract we discussed above, but we’ll get to that
in the next section.&lt;/p&gt;

&lt;p&gt;We’ll start with the assertion about the output
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;wishbone bus&lt;/a&gt;
address.
Anytime a new request is accepted by the
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;,
the &lt;code class=&quot;highlighter-rouge&quot;&gt;o_wb_pc&lt;/code&gt; should increment.  The only exception is following an
&lt;code class=&quot;highlighter-rouge&quot;&gt;i_new_pc&lt;/code&gt; signal–when it should be set by the new &lt;code class=&quot;highlighter-rouge&quot;&gt;i_pc&lt;/code&gt; value.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(posedge i_clk)
	if ((f_past_valid)&amp;amp;&amp;amp;($past(o_wb_stb))&amp;amp;&amp;amp;(!$past(i_wb_stall))
			&amp;amp;&amp;amp;(!$past(i_new_pc)))
		assert(o_wb_addr &amp;lt;= $past(o_wb_addr)+1&#39;b1);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;When it comes to the output values, the rule is that anytime the output
is valid and the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
is stalled, i.e. any time &lt;code class=&quot;highlighter-rouge&quot;&gt;(o_valid)&amp;amp;&amp;amp;(!i_stall_n)&lt;/code&gt;,
then the output values need to stay constant.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(posedge i_clk)
	if ((f_past_valid)&amp;amp;&amp;amp;(!$past(i_reset))
			&amp;amp;&amp;amp;(!$past(i_new_pc))&amp;amp;&amp;amp;(!$past(i_clear_cache))
			&amp;amp;&amp;amp;($past(o_valid))&amp;amp;&amp;amp;(!$past(i_stall_n)))
	begin
		assert($stable(o_pc));
		assert($stable(o_insn));
		assert($stable(o_valid));
		assert($stable(o_illegal));
	end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The same is true for that second cached word as well.  If that cache position
is valid, yet the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
is stalled, then it should never change.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(posedge i_clk)
	if ((f_past_valid)&amp;amp;&amp;amp;(!$past(i_reset))
			&amp;amp;&amp;amp;(!$past(i_new_pc))&amp;amp;&amp;amp;(!$past(i_clear_cache))
			&amp;amp;&amp;amp;($past(o_valid))&amp;amp;&amp;amp;(!$past(i_stall_n))
			&amp;amp;&amp;amp;($past(cache_valid)))
	begin
		assert($stable(cache_valid));
		assert($stable(cache_word));
		assert($stable(cache_illegal));
	end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;In a fashion similar to &lt;code class=&quot;highlighter-rouge&quot;&gt;o_wb_addr&lt;/code&gt; above, &lt;code class=&quot;highlighter-rouge&quot;&gt;o_pc&lt;/code&gt; should only ever increment,
and it should only do that if an instruction has been accepted–with the
exception of any time &lt;code class=&quot;highlighter-rouge&quot;&gt;i_new_pc&lt;/code&gt; is asserted.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(posedge i_clk)
	if ((f_past_valid)&amp;amp;&amp;amp;(!$past(i_new_pc))
			&amp;amp;&amp;amp;($past(o_valid))&amp;amp;&amp;amp;($past(i_stall_n)))
		assert(o_pc[AW+1:2] == $past(o_pc[AW+1:2])+1&#39;b1);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;As with &lt;code class=&quot;highlighter-rouge&quot;&gt;i_pc[1:0]&lt;/code&gt; and the frustration I described above, the bottom two
bits of the &lt;code class=&quot;highlighter-rouge&quot;&gt;o_pc&lt;/code&gt; address are unused.  Let’s assert here that they remain zero.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(*)
		assert(o_pc[1:0] == 2&#39;b00);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Upon any
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_error&quot;&gt;error&lt;/a&gt;
return, one of either &lt;code class=&quot;highlighter-rouge&quot;&gt;o_illegal&lt;/code&gt; or &lt;code class=&quot;highlighter-rouge&quot;&gt;cache_illegal&lt;/code&gt; should be
set.  Further, if &lt;code class=&quot;highlighter-rouge&quot;&gt;o_illegal&lt;/code&gt; is set, so too should be &lt;code class=&quot;highlighter-rouge&quot;&gt;o_valid&lt;/code&gt; to indicate
this is a valid return, and the same for &lt;code class=&quot;highlighter-rouge&quot;&gt;cache_valid&lt;/code&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(posedge i_clk)
	if ((f_past_valid)&amp;amp;&amp;amp;(!$past(i_reset))
			&amp;amp;&amp;amp;(!$past(i_new_pc))
			&amp;amp;&amp;amp;(!$past(i_clear_cache))
			&amp;amp;&amp;amp;($past(o_wb_cyc))&amp;amp;&amp;amp;($past(i_wb_err)))
		assert( ((o_valid)&amp;amp;&amp;amp;(o_illegal))
			||((cache_valid)&amp;amp;&amp;amp;(cache_illegal)) );&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Any time &lt;code class=&quot;highlighter-rouge&quot;&gt;o_illegal&lt;/code&gt; gets set, &lt;code class=&quot;highlighter-rouge&quot;&gt;o_valid&lt;/code&gt; should also be set at the same time.
&lt;code class=&quot;highlighter-rouge&quot;&gt;o_illegal&lt;/code&gt; will then stay true until cleared by a &lt;code class=&quot;highlighter-rouge&quot;&gt;i_reset&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;i_new_pc&lt;/code&gt;, etc,
so this is the most important part of the check.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(posedge i_clk)
	if ((f_past_valid)&amp;amp;&amp;amp;(!$past(o_illegal))&amp;amp;&amp;amp;(o_illegal))
		assert(o_valid);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;We’ll need to check for the same thing in the cache as well.  Hence, any
time the cached value was not illegal before, and the cache remains invalid
now, then the cache cannot have become illegal during this clock as well.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(posedge i_clk)
	if ((f_past_valid)&amp;amp;&amp;amp;(!$past(cache_illegal))&amp;amp;&amp;amp;(!cache_valid))
		assert(!cache_illegal);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Following any &lt;code class=&quot;highlighter-rouge&quot;&gt;i_new_pc&lt;/code&gt; request, &lt;code class=&quot;highlighter-rouge&quot;&gt;o_valid&lt;/code&gt; &lt;em&gt;must&lt;/em&gt; be low.  This assertion
comes from searching for a bug in the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/idecode.v&quot;&gt;instruction
decoder&lt;/a&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(posedge i_clk)
	if ((f_past_valid)&amp;amp;&amp;amp;($past(i_new_pc)))
		assert(!o_valid);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Finally, any time we transition from &lt;code class=&quot;highlighter-rouge&quot;&gt;o_valid&lt;/code&gt; to &lt;code class=&quot;highlighter-rouge&quot;&gt;!o_valid&lt;/code&gt;, we should also
be starting a
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;
cycle–lest we somehow get stuck.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(posedge i_clk)
	if ((f_past_valid)&amp;amp;&amp;amp;(!$past(i_reset))&amp;amp;&amp;amp;(!$past(i_clear_cache))
			&amp;amp;&amp;amp;($past(o_valid))&amp;amp;&amp;amp;(!o_valid)&amp;amp;&amp;amp;(!o_illegal))
		assert((o_wb_cyc)||(invalid_bus_cycle));&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Okay, that was a lot of properties!  Are you still with me?&lt;/p&gt;

&lt;p&gt;At this point, we are finally ready for the contract with the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;!
Remember how we discussed this above?  Let’s now take a look at how it’s done.&lt;/p&gt;

&lt;p&gt;We’ll start with three arbitrary values, an address, &lt;code class=&quot;highlighter-rouge&quot;&gt;f_const_addr&lt;/code&gt;, an
instruction, &lt;code class=&quot;highlighter-rouge&quot;&gt;f_const_insn&lt;/code&gt;, and whether or not that address will return a
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_error&quot;&gt;error&lt;/a&gt;,
&lt;code class=&quot;highlighter-rouge&quot;&gt;f_const_illegal&lt;/code&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	wire	[AW-1:0]	f_const_addr;
	wire	[DW-1:0]	f_const_insn;
	wire			f_const_illegal;

	// ...
	assign	f_const_addr    = $anyconst;
	assign	f_const_insn    = $anyconst;
	assign	f_const_illegal = $anyconst;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The next section is a bit verbose.  It probably doesn’t need to be.
But, just to tell the story …&lt;/p&gt;

&lt;p&gt;Over the course of time, while working with these values, I got somewhat
frustrated with the waveform viewing tool I was using.  One frustration was
my formal properties often contained something like &lt;code class=&quot;highlighter-rouge&quot;&gt;if ((A)&amp;amp;&amp;amp;(B)&amp;amp;&amp;amp;...)&lt;/code&gt; and
I could never tell when
something failed which of &lt;code class=&quot;highlighter-rouge&quot;&gt;A&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;B&lt;/code&gt;, or (other) wasn’t true.  To keep this
from happening, I assigned wires (below) to the various comparisons checks
I needed to do.  This way, I can examine these wires on any trace
failure and see why things failed.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	wire	f_this_addr, f_this_pc, f_this_req, f_this_data,
		f_this_insn;

	assign	f_this_addr = (o_wb_addr ==   f_const_addr);
	assign	f_this_pc   = (o_pc      == { f_const_addr, 2&#39;b00 });
	assign	f_this_req  = (i_pc      == { f_const_addr, 2&#39;b00 });
	assign	f_this_data = (i_wb_data ==   f_const_insn);
	assign	f_this_insn = (o_insn    ==   f_const_insn);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;That said, I’m undecided as to whether or not this frustration should lead me
to split out wires like this in the future.&lt;/p&gt;

&lt;p&gt;Ok, that’s the setup, here’s the contract: on any clock where the result
is valid, and where it’s our &lt;code class=&quot;highlighter-rouge&quot;&gt;f_const_addr&lt;/code&gt; address being returned, then
we need to be returning either this instruction, &lt;code class=&quot;highlighter-rouge&quot;&gt;f_const_insn&lt;/code&gt;, or
&lt;code class=&quot;highlighter-rouge&quot;&gt;o_illegal&lt;/code&gt; if this instruction returned a
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_error&quot;&gt;error&lt;/a&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(*)
	if ((o_valid)&amp;amp;&amp;amp;(f_this_pc))
	begin
		if (f_const_illegal)
			assert(o_illegal);
		if (!o_illegal)
			assert(f_this_insn);
	end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Of course, this will only work if the
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;
itself returns either this instruction or an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_error&quot;&gt;error&lt;/a&gt;
upon request.  Since this is an input of the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/dblfetch.v&quot;&gt;prefetch&lt;/a&gt;,
it needs to be assumed.&lt;/p&gt;

&lt;p&gt;The trick in making this assumption is that we need to know which return
of the many
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;
requests that we’ve made is the return value for this contract instruction.
Given that we increment &lt;code class=&quot;highlighter-rouge&quot;&gt;o_wb_addr&lt;/code&gt; any time we send a
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;
request in flight, and given that
&lt;code class=&quot;highlighter-rouge&quot;&gt;f_outstanding&lt;/code&gt; counts the number of items in flight, we can then know if this
return is our address by subtracting from &lt;code class=&quot;highlighter-rouge&quot;&gt;o_wb_addr&lt;/code&gt; the number of items
in flight.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	assign	f_this_return = (o_wb_addr - f_outstanding == f_const_addr);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Using this predicate, we can now say that if the next
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;
return will be for this request (i.e. &lt;code class=&quot;highlighter-rouge&quot;&gt;f_this_return&lt;/code&gt; is set), then if
we receive an acknowledgment from the
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;
the data should be &lt;code class=&quot;highlighter-rouge&quot;&gt;f_const_insn&lt;/code&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(*)
	if ((o_wb_cyc)&amp;amp;&amp;amp;(f_this_return))
	begin
		if (i_wb_ack)
			assume(i_wb_data == f_const_insn);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;To handle whether we get a
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_error&quot;&gt;error&lt;/a&gt;
or an acknowledgment, we’ll do it this way:  If &lt;code class=&quot;highlighter-rouge&quot;&gt;f_const_illegal&lt;/code&gt; is true, we
should &lt;em&gt;only&lt;/em&gt; get an &lt;code class=&quot;highlighter-rouge&quot;&gt;i_wb_err&lt;/code&gt; from the
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;
and never any valid acknowledgment.  Likewise the reverse: if &lt;code class=&quot;highlighter-rouge&quot;&gt;f_const_illegal&lt;/code&gt;
is false, we should &lt;em&gt;only&lt;/em&gt; ever get an acknowledgment from the
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;.
This particular way of describing this behavior allows the
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;.
to still take its own sweet time to return any values, but
yet still forces the
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_error&quot;&gt;error&lt;/a&gt;
when appropriate–i.e., when &lt;code class=&quot;highlighter-rouge&quot;&gt;f_const_illegal&lt;/code&gt; is set.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;		if (f_const_illegal)
			assume(!i_wb_ack);
		else
			assume(!i_wb_err);
	end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;There’s a corollary to our contract above.  This corollary has to do
with the cached value that hasn’t yet been given to the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;.
In this case, we still need to assert that this cached value holds to our
contract.  While this wouldn’t be necessary for a simple Bounded Model Check
(BMC), it is a &lt;a href=&quot;/blog/2018/03/10/induction-exercise.html&quot;&gt;necessary
requirement&lt;/a&gt;
in order to pass the formal
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Mathematical_induction&quot;&gt;induction step&lt;/a&gt;.
Hence, if the address within the cache, the next &lt;code class=&quot;highlighter-rouge&quot;&gt;o_pc&lt;/code&gt; address, &lt;code class=&quot;highlighter-rouge&quot;&gt;o_pc+4&lt;/code&gt;,
matches our arbitrary address, &lt;code class=&quot;highlighter-rouge&quot;&gt;f_const_addr&lt;/code&gt;, and if the cache has a valid
value within it, then these conditions apply: unless the cache value is
illegal, it should contain our arbitrary instruction word.  Likewise,
if the cache value is supposed to be illegal, then &lt;code class=&quot;highlighter-rouge&quot;&gt;cache_illegal&lt;/code&gt;
should be true as well.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(*)
	if ((o_pc[AW+1:2] + 1&#39;b1 == f_const_addr)&amp;amp;&amp;amp;(cache_valid))
	begin
		if (!cache_illegal)
			assert(cache_word == f_const_insn);

		if (f_const_illegal)
			assert(cache_illegal);
	end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;That’s our contract.  If we meet that contract, then we’ll know this
design works.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(posedge i_clk)
	if ((f_past_valid)&amp;amp;&amp;amp;(!$past(cache_illegal))&amp;amp;&amp;amp;(!cache_valid))
		assert(!cache_illegal);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;We’re not done yet, however.&lt;/p&gt;

&lt;p&gt;First, we want to make certain that our two instruction FIFO will never
overflow.  As we’ve written our design above, any overflow would be
catastrophic.  Hence, any time we request a new value, we must have a place
to put it.  In other words, either the cache value must be empty, or the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
must have just accepted a value.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(*)
	if (o_wb_stb)
		assert((!cache_valid)||(i_stall_n));&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;In a similar vein, any time both the output and the cache value are both
valid, then we need to guarantee that we aren’t requesting any more values,
and that nothing is in flight.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(*)
	if ((o_valid)&amp;amp;&amp;amp;(cache_valid))
		assert((f_outstanding == 0)&amp;amp;&amp;amp;(!o_wb_stb));&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;These should be sufficient to keep us from overflowing this two instruction
FIFO.&lt;/p&gt;

&lt;p&gt;However, the
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal properties&lt;/a&gt;
we’ve listed so far &lt;a href=&quot;/blog/2018/03/10/induction-exercise.html&quot;&gt;aren’t sufficient to
guarantee&lt;/a&gt;
that the design will pass the &lt;a href=&quot;https://en.wikipedia.org/wiki/Mathematical_induction&quot;&gt;induction
step&lt;/a&gt;.  In order to pass
&lt;a href=&quot;https://en.wikipedia.org/wiki/Mathematical_induction&quot;&gt;induction&lt;/a&gt;,
we need to restrict the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Mathematical_induction&quot;&gt;induction&lt;/a&gt;
engine so that it only considers reachable states.&lt;/p&gt;

&lt;p&gt;To make certain we don’t over-restrict our design, we’ll limit ourselves here
to only using assert statements.  As a result, the BMC and
&lt;a href=&quot;https://en.wikipedia.org/wiki/Mathematical_induction&quot;&gt;induction&lt;/a&gt;
stages will be able to catch anything that is over constrained–as long as the
number of stages examined in BMC is more than the stages examined during
&lt;a href=&quot;https://en.wikipedia.org/wiki/Mathematical_induction&quot;&gt;induction&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The first assertion is that any time we have at least one item in our FIFO,
that is any time &lt;code class=&quot;highlighter-rouge&quot;&gt;o_valid&lt;/code&gt; is true, and any time that item isn’t moving forward,
then there can only be one or zero
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;
requests outstanding.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(*)
	if ((o_valid)&amp;amp;&amp;amp;(!i_stall_n))
		assert(f_outstanding &amp;lt; 2);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The next assertion follows, but in this case any time the FIFO is completely
empty we allow ourselves to have up to two requests in flight.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(*)
	if ((!o_valid)||(i_stall_n))
		assert(f_outstanding &amp;lt;= 2);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Further, any time we are within a
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;
cycle, i.e. &lt;code class=&quot;highlighter-rouge&quot;&gt;o_wb_cyc&lt;/code&gt; is high, but yet we’ve stopped making
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;
requests, i.e. &lt;code class=&quot;highlighter-rouge&quot;&gt;o_wb_stb&lt;/code&gt; is low, then there should
be some number of requests in flight.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(posedge i_clk)
	if ((f_past_valid)&amp;amp;&amp;amp;($past(o_wb_cyc))&amp;amp;&amp;amp;(!$past(o_wb_stb))
			&amp;amp;&amp;amp;(o_wb_cyc))
		assert(inflight != 0);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Just to make sure we captured everything, let’s state this again: on any
return from the
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;,
there must be a place to put that return.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(*)
	if ((o_wb_cyc)&amp;amp;&amp;amp;(i_wb_ack))
		assert(!cache_valid);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Further, our design has two separate counters of how many items are within
flight.  One is from the &lt;code class=&quot;highlighter-rouge&quot;&gt;f_outstanding&lt;/code&gt; counter created within the
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;formal WB properties&lt;/a&gt;,
module, and the other our &lt;code class=&quot;highlighter-rouge&quot;&gt;inflight&lt;/code&gt; counter.&lt;/p&gt;

&lt;p&gt;These two counters need to be identical any time the
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;,
is in use.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(posedge i_clk)
	if (o_wb_cyc)
		assert(inflight == f_outstanding);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Now let’s look at the address of the request being made, vs the address
being given to the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;First, upon any return from the
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;,
that goes into &lt;code class=&quot;highlighter-rouge&quot;&gt;o_valid&lt;/code&gt;, the address
of the value returned needs to be equal to the value given to the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	assign	this_return_address = o_wb_addr - f_outstanding;
	assign	next_pc_address = o_pc[AW+1:2] + 1&#39;b1;

	always @(posedge i_clk)
	if ((f_past_valid)&amp;amp;&amp;amp;($past(o_wb_cyc))
			&amp;amp;&amp;amp;(!$past(i_reset))
			&amp;amp;&amp;amp;(!$past(i_new_pc))
			&amp;amp;&amp;amp;(!$past(i_clear_cache))
			&amp;amp;&amp;amp;(!$past(invalid_bus_cycle))
			&amp;amp;&amp;amp;(($past(i_wb_ack))||($past(i_wb_err)))
			&amp;amp;&amp;amp;((!$past(o_valid))||($past(i_stall_n)))
			&amp;amp;&amp;amp;(!$past(cache_valid)))
		assert(o_pc[AW+1:2] == $past(this_return_address));&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This isn’t enough, though, to constrain the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Mathematical_induction&quot;&gt;induction&lt;/a&gt;
engine.  I know, I tried.&lt;/p&gt;

&lt;p&gt;Getting
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/dblfetch.v&quot;&gt;this design&lt;/a&gt;
to pass the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Mathematical_induction&quot;&gt;induction&lt;/a&gt; step
required running the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Mathematical_induction&quot;&gt;induction&lt;/a&gt;
engine many times, then looking at the failures and trying to find out
which wires or values didn’t make sense.  When you find them, you look
at them and wonder, how on earth did that happen?  That doesn’t follow
my design principles!  Yes, but you
&lt;a href=&quot;/blog/2018/03/10/induction-exercise.html&quot;&gt;need to tell&lt;/a&gt;
the &lt;a href=&quot;https://en.wikipedia.org/wiki/Mathematical_induction&quot;&gt;induction&lt;/a&gt; step
engine that.&lt;/p&gt;

&lt;p&gt;So, let’s look at the case where &lt;code class=&quot;highlighter-rouge&quot;&gt;o_valid&lt;/code&gt; isn’t true, but yet we are within a
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;
cycle.  In this case, &lt;code class=&quot;highlighter-rouge&quot;&gt;o_pc&lt;/code&gt; must be the address of the next request
that will be returned from the
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(posedge i_clk)
	if ((f_past_valid)&amp;amp;&amp;amp;($past(o_wb_cyc))&amp;amp;&amp;amp;(!o_valid)&amp;amp;&amp;amp;(!$past(i_new_pc))
			&amp;amp;&amp;amp;(o_wb_cyc))
		assert(o_pc[AW+1:2] == this_return_address);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;We need to check the same thing with the cache word.  Any time the cache
becomes valid, the address coming back needs to be one past the &lt;code class=&quot;highlighter-rouge&quot;&gt;o_pc&lt;/code&gt;
address being presented to the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(posedge i_clk)
	if ((f_past_valid)&amp;amp;&amp;amp;($past(o_wb_cyc))
			&amp;amp;&amp;amp;(!$past(cache_valid))&amp;amp;&amp;amp;(cache_valid))
		assert(next_pc_address == $past(this_return_address));&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The final step looks at these relationships a bit more thoroughly.  We’ll
examine only those times, though, when the bus is active.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(posedge i_clk)
	if ((f_past_valid)&amp;amp;&amp;amp;($past(o_wb_cyc))&amp;amp;&amp;amp;(o_wb_cyc))
	begin&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;If there’s one active value in our FIFO, then anything returned from the
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;
should have an address given by our next
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;
address.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;		if ((o_valid)&amp;amp;&amp;amp;(!cache_valid))
			assert(this_return_address == next_pc_address);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Likewise anytime we have no valid instructions, the next value to be returned
by the
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;
must match the next
&lt;a href=&quot;https://en.wikipedia.org/wiki/Program_counter&quot;&gt;PC&lt;/a&gt;
value, &lt;code class=&quot;highlighter-rouge&quot;&gt;o_pc&lt;/code&gt;, to be sent to the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;		else if (!o_valid)
			assert(this_return_address == o_pc[AW+1:2]);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Finally, any time the
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;
is idle, and there’s only one word in our cache and it’s not illegal,
then the address remaining on the
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;
needs to be the next address to be requested.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	end else if ((f_past_valid)&amp;amp;&amp;amp;(!invalid_bus_cycle)
			&amp;amp;&amp;amp;(!o_wb_cyc)&amp;amp;&amp;amp;(o_valid)&amp;amp;&amp;amp;(!o_illegal)
			&amp;amp;&amp;amp;(!cache_valid))
		assert(o_wb_addr == next_pc_address);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This leaves us with only two more assertions.  These are sort of dogs and
cats assertions that don’t fit under any other category above.&lt;/p&gt;

&lt;p&gt;First, the &lt;code class=&quot;highlighter-rouge&quot;&gt;invalid_bus_cycle&lt;/code&gt; should only ever be true if we aren’t in a
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;
cycle.  This assertion was added to make certain I could simplify
some of the assertions above.  Since I know it is true, I could make the
other assertions simpler.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(*)
	if (invalid_bus_cycle)
		assert(!o_wb_cyc);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Finally, the &lt;code class=&quot;highlighter-rouge&quot;&gt;cache_valid&lt;/code&gt; signal should never be true unless &lt;code class=&quot;highlighter-rouge&quot;&gt;o_valid&lt;/code&gt; is
also true.  This lines up with the idea that &lt;code class=&quot;highlighter-rouge&quot;&gt;cache_valid&lt;/code&gt; is our signal that
the second item within our two-element FIFO is valid, so therefore the first
item in the FIFO must also be valid in these cases as well.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(*)
	if (cache_valid)
		assert(o_valid);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Wow!  That was a lot of work on those properties!  The cool thing about these,
though, is that now that I have these properties, I can then test simple logic
changes to my design, such as &lt;a href=&quot;/blog/2017/06/12/minimizing-luts.html&quot;&gt;trying to remove LUTs to make the design
simpler&lt;/a&gt;,
and see if those changes affect the functionality of this design.&lt;/p&gt;

&lt;h2 id=&quot;cover-properties&quot;&gt;Cover Properties&lt;/h2&gt;

&lt;p&gt;I haven’t presented &lt;code class=&quot;highlighter-rouge&quot;&gt;cover&lt;/code&gt; properties before, although they are a valuable
part of
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal methods&lt;/a&gt;.
The &lt;code class=&quot;highlighter-rouge&quot;&gt;cover&lt;/code&gt; property is very different from the &lt;code class=&quot;highlighter-rouge&quot;&gt;assume&lt;/code&gt; an &lt;code class=&quot;highlighter-rouge&quot;&gt;assert&lt;/code&gt; properties
above.  Indeed, &lt;code class=&quot;highlighter-rouge&quot;&gt;cover&lt;/code&gt; is called a “liveness” property, unlike
&lt;code class=&quot;highlighter-rouge&quot;&gt;assume&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;assert&lt;/code&gt; which are called “safety” properties.  The difference is
that &lt;code class=&quot;highlighter-rouge&quot;&gt;assume&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;assert&lt;/code&gt; properties must apply to all traces, whereas a
&lt;code class=&quot;highlighter-rouge&quot;&gt;cover&lt;/code&gt; property only needs to apply to a single trace to be true.&lt;/p&gt;

&lt;p&gt;A quick Google search suggests that there’s a bit of a disagreement as to
whether “liveness” properties are even needed, or whether “safety” properties
are sufficient.&lt;/p&gt;

&lt;p&gt;While I’m not going to enter into that debate today, I will note that
&lt;code class=&quot;highlighter-rouge&quot;&gt;cover&lt;/code&gt; statements can be used while you are building your design to
see if it is working.&lt;/p&gt;

&lt;p&gt;As an example, before I listed out all of the properties in the last
section, I wanted to know if this routine might ever get a third
acknowledgment from the same
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;
cycle.  If you’ll remember from Fig 11 above, this was part of the purpose
of
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/dblfetch.v&quot;&gt;this design&lt;/a&gt;
in the first place–to be able to continue the
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus&lt;/a&gt;
cycle as long as possible.  Therefore, I put the following &lt;code class=&quot;highlighter-rouge&quot;&gt;cover&lt;/code&gt;
statement into my design.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(posedge i_clk)
	cover((f_past_valid)&amp;amp;&amp;amp;($past(f_nacks)==3)
		&amp;amp;&amp;amp;($past(i_wb_ack))&amp;amp;&amp;amp;($past(o_wb_cyc)));&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;When this &lt;code class=&quot;highlighter-rouge&quot;&gt;cover&lt;/code&gt; statement failed at first, I knew I didn’t have my design
right yet.  Further, when I dug into the problem, I discovered that this
&lt;code class=&quot;highlighter-rouge&quot;&gt;cover&lt;/code&gt; statement was failing not due to my logic, but rather due to some
erroneous assumptions I had made.&lt;/p&gt;

&lt;p&gt;Erroneous assumptions can be particularly problematic in
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal methods&lt;/a&gt;,
especially if you are only using the “safety” properties, &lt;code class=&quot;highlighter-rouge&quot;&gt;assume&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;assert&lt;/code&gt;,
since an erroneous assumption will artificially limit your proof.  Worse yet,
you might not notice that your assumptions are creating this artificial
limit.  Such an assumption might then give you a false assurance that your
design works–even though it does not. (Yes, I’ve &lt;a href=&quot;/blog/2018/02/09/first-cyclonev.html&quot;&gt;been burned by
this&lt;/a&gt;
more than once.)&lt;/p&gt;

&lt;h2 id=&quot;logic-usage&quot;&gt;Logic Usage&lt;/h2&gt;

&lt;p&gt;If you’ll remember from when we started, the purpose of this particular
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/dblfetch.v&quot;&gt;prefetch
module&lt;/a&gt;
was to be a compromise–it was to have better performance than our &lt;a href=&quot;/zipcpu/2017/11/18/wb-prefetch.html&quot;&gt;one
instruction prefetch&lt;/a&gt;,
but not nearly as much as we might have with a proper &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/pfcache.v&quot;&gt;instruction
cache&lt;/a&gt;.
It’s also supposed to be a (fairly) low logic design.&lt;/p&gt;

&lt;p&gt;So, for a small design, how did we do?&lt;/p&gt;

&lt;p&gt;In particular, I’d like to place
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/dblfetch.v&quot;&gt;this prefetch&lt;/a&gt;
into both a
&lt;a href=&quot;https://tinyfpga.com&quot;&gt;TinyFPGA&lt;/a&gt;
and the &lt;a href=&quot;/blog/2017/12/16/max1k.html&quot;&gt;MAX1000 from Arrow&lt;/a&gt;.
Will it fit?&lt;/p&gt;

&lt;p&gt;The iCE40 &lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
within the &lt;a href=&quot;https://tinyfpga.com&quot;&gt;TinyFPGA&lt;/a&gt; board is perhaps the most
constrained of these two.  This
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
has just less than 8k 4-LUTs available to it.  With just a simple
&lt;a href=&quot;https://www.clifford.at/yosys&quot;&gt;yosys&lt;/a&gt;
script,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;read_verilog dblfetch.v
synth_ice40&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;we can easily measure this components usage on an iCE40–in only
a half-second no less (try doing that with a vendor tool!).  You can
see the LUT4 usage of these various components in the table below.&lt;/p&gt;

&lt;table class=&quot;bordered-table&quot;&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Prefetch&lt;/th&gt;
      &lt;th&gt;LUT4s&lt;/th&gt;
      &lt;th&gt;iCE40 Device usage&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;Single&lt;/td&gt;
      &lt;td&gt;74&lt;/td&gt;
      &lt;td&gt;1.0%&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Double&lt;/td&gt;
      &lt;td&gt;247&lt;/td&gt;
      &lt;td&gt;3.2%&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;(Before)&lt;/td&gt;
      &lt;td&gt;277&lt;/td&gt;
      &lt;td&gt;3.6%&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;w/ 4k Cache&lt;/td&gt;
      &lt;td&gt;621&lt;/td&gt;
      &lt;td&gt;8.0%&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;As you can see from the table, this module offers an area compromise between
the &lt;a href=&quot;/zipcpu/2017/11/18/wb-prefetch.html&quot;&gt;slowest prefetch
module&lt;/a&gt;
and the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/pfcache.v&quot;&gt;full prefetch and cache
module&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;running-the-zipcpu-with-this-prefetch&quot;&gt;Running the ZipCPU with this prefetch&lt;/h2&gt;

&lt;p&gt;If you want to try running the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
or even
&lt;a href=&quot;/zipcpu/2018/02/12/zbasic-intro.html&quot;&gt;ZBasic&lt;/a&gt; with this
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/dblfetch.v&quot;&gt;this prefetch&lt;/a&gt;
installed, all you need to do is to adjust the flags in
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/cpudefs.v&quot;&gt;cpudefs.v&lt;/a&gt;.
Specifically, you’ll want to make certain the &lt;code class=&quot;highlighter-rouge&quot;&gt;OPT_SINGLE_FETCH&lt;/code&gt; define is
commented,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;// `define	OPT_SINGLE_FETCH&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;and the &lt;code class=&quot;highlighter-rouge&quot;&gt;OPT_DOUBLE_FETCH&lt;/code&gt; line is not,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;`ifndef	OPT_SINGLE_FETCH
`define	OPT_DOUBLE_FETCH
`endif&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;You may recall discussing &lt;a href=&quot;/zipcpu/2018/01/31/cpu-build.html&quot;&gt;this comparison in a previous
article&lt;/a&gt;,
only now this &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/dblfetch.v&quot;&gt;compromise prefetch
module&lt;/a&gt;
has been updated for better performance and lower logic.  Hence, if you’ve
downloaded the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; before, you’ll
want to do a &lt;code class=&quot;highlighter-rouge&quot;&gt;git pull&lt;/code&gt; to get the latest version of
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/dblfetch.v&quot;&gt;this module&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;While it’s generally true that nothing comes for free, today’s post presents
a bit of an exception.  By redesigning &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/dblfetch.v&quot;&gt;my original dblfetch
module&lt;/a&gt;,
used by the &lt;a href=&quot;https://github.com/ZipCPU/s6soc&quot;&gt;S6SoC&lt;/a&gt;
and some other &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; low logic
implementations, we were able to get both better performance and
&lt;a href=&quot;/blog/2017/06/12/minimizing-luts.html&quot;&gt;fewer LUTs&lt;/a&gt;.
Hence, there are two conclusions we might draw:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;In general, the more LUTs you apply to a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Soft_microprocessor&quot;&gt;soft-core CPU&lt;/a&gt;,
the faster the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Soft_microprocessor&quot;&gt;CPU&lt;/a&gt; will be.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;There exist times when a better design can achieve more or better
performance.  Today’s post represents one of those times.  Such
performance increases, though, do tend to be asymptotic over time.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;What made the difference?  This new/updated
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/dblfetch.v&quot;&gt;prefetch&lt;/a&gt;
doesn’t use a two element memory array, nor the associated pair of valid
signals, to capture the two elements returned by the bus.&lt;/p&gt;

&lt;p&gt;How about the
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal methods&lt;/a&gt; we
used?  Did they help?  To this I’ll answer both yes and no.  The first time
I used this logic in a
&lt;a href=&quot;/blog/2017/06/21/looking-at-verilator.html&quot;&gt;simulated&lt;/a&gt;
&lt;a href=&quot;/blog/2017/12/16/max1k.html&quot;&gt;board&lt;/a&gt;, the
&lt;a href=&quot;/zipcpu/2018/02/12/zbasic-intro.html&quot;&gt;CPU test&lt;/a&gt;
failed.  That’s the “No” part of the answer.  However, the logic failed
within the early branch logic in the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/idecode.v&quot;&gt;instruction
decoder&lt;/a&gt;, not the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/dblfetch.v&quot;&gt;prefetch&lt;/a&gt;.
Indeed, this updated
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/dblfetch.v&quot;&gt;prefetch&lt;/a&gt;
has yet to have any failures since passing
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal verification&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Sadly, this wonderful anecdote of the performance of
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal methods&lt;/a&gt;
isn’t nearly as clear as I might like it to be.  The logic that failed within
the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/idecode.v&quot;&gt;instruction
decoder&lt;/a&gt;
had already been &lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formally
verified&lt;/a&gt;.
Apparently, that proof just wasn’t sufficient and I must still be only learning
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal methods&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The one question we haven’t answered is just how much faster is this
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/dblfetch.v&quot;&gt;prefetch&lt;/a&gt;?
That is, how does it’s &lt;em&gt;performance&lt;/em&gt; quantitatively compare to the other
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
&lt;a href=&quot;/zipcpu/2017/11/18/wb-prefetch.html&quot;&gt;prefetch&lt;/a&gt; modules?
I’m going to hold those questions off, though, for a future article on how
to measure your &lt;a href=&quot;https://en.wikipedia.org/wiki/Soft_microprocessor&quot;&gt;CPU&lt;/a&gt;’s
performance via a benchmark test–such as the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Dhrystone&quot;&gt;Dhrystone benchmark&lt;/a&gt;.  Such a
benchmark test will also bring us face to face with the fact that our
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;
speed measurements above weren’t accurate at all since they ignored the
(very significant) cost of
&lt;a href=&quot;https://en.wikipedia.org/wiki/Branch_(computer_science)&quot;&gt;branching&lt;/a&gt;.&lt;/p&gt;
&lt;hr /&gt;&lt;p&gt;&lt;em&gt;Many will say to me in that day, Lord, Lord, have we not prophesied in thy name? and in thy name have cast out devils? and in thy name done many wonderful works?  And then will I profess unto them, I never knew you: depart from me, ye that work iniquity.  (Matt 7:22-23)&lt;/em&gt;</description>
        <pubDate>Wed, 21 Mar 2018 00:00:00 -0400</pubDate>
        <link>http://zipcpu.com/zipcpu/2018/03/21/dblfetch.html</link>
        <guid isPermaLink="true">http://zipcpu.com/zipcpu/2018/03/21/dblfetch.html</guid>
        
        
        <category>zipcpu</category>
        
      </item>
    
      <item>
        <title>Is formal really all that hard?</title>
        <description>&lt;p&gt;I spent the first week of March, 2018, at
&lt;a href=&quot;https://dvcon.org&quot;&gt;DVCon&lt;/a&gt;
in San Francisco, talking to vendors and asking questions regarding
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;Formal Verification&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Many vendors offered Verification IP (VIP) modules that you could use in
&lt;a href=&quot;/blog/2017/06/21/looking-at-verilator.html&quot;&gt;simulation&lt;/a&gt;
to know that your interface matched the specification.  These models would
attach to your design, allowing you to then run tests on your design.  When/if
your design didn’t match what the protocol required, these commercial
VIP modules would issue an error.&lt;/p&gt;

&lt;p&gt;Indeed, it seems like the primary method of &lt;em&gt;proving&lt;/em&gt; that an
&lt;a href=&quot;/blog/2017/10/13/fpga-v-asic.html&quot;&gt;ASIC design&lt;/a&gt;
would work prior to tape out is to feed the simulated design with random data
and requests, over and over again, in order to get the design to fail.  Several
presentations discussed how to do this.  Hardware was advertised that could
help to make this happen.  While I’ll admit that the level of effort discussed
and presented goes well beyond my simple &lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;scripted test bench
failures&lt;/a&gt;,
it still only provides a small stochastic confidence that the design would work.&lt;/p&gt;

&lt;p&gt;What a difference from
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal&lt;/a&gt;!&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/v-method.svg&quot; alt=&quot;&quot; width=&quot;600&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;When using
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal methods&lt;/a&gt;,
&lt;em&gt;every&lt;/em&gt; path through the your logic is tested to determine if the design
works.  &lt;em&gt;Every path&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;This led me to wandering through the exhibit hall, asking vendor after vendor
if they had any &lt;em&gt;formal&lt;/em&gt; VIP.  Perhaps 5-10% of the VIP available was available
for proving something
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formally&lt;/a&gt;.
While the reasons were mixed, the general consensus was that
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal&lt;/a&gt;
was more difficult to use, and so there wasn’t the same market for it.  One
vendor even declared that his tools were faster, better, and cheaper than
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal&lt;/a&gt;,
although less than
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal&lt;/a&gt;
in capability.&lt;/p&gt;

&lt;p&gt;What??  Really?  Is
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal&lt;/a&gt;
really all that difficult to use?&lt;/p&gt;

&lt;p&gt;Let’s look at a simple example or two.  Then, we can discuss how I go about
getting started with
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal&lt;/a&gt; on any new
design, and what designs I apply
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal methods&lt;/a&gt; to.
Finally, we’ll attempt to address the question of whether
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal methods&lt;/a&gt;
really are all that hard.&lt;/p&gt;

&lt;h2 id=&quot;cover&quot;&gt;Cover&lt;/h2&gt;

&lt;p&gt;Just one simple &lt;code class=&quot;highlighter-rouge&quot;&gt;cover&lt;/code&gt; statement can have an amazing impact on a new design.
As an example, in a &lt;a href=&quot;https://github.com/ZipCPU/tinyzip&quot;&gt;recent design&lt;/a&gt;
I was working on for the
&lt;a href=&quot;https://tinyfpga.com&quot;&gt;TinyFPGA&lt;/a&gt;, a project I am calling
&lt;a href=&quot;https://github.com/ZipCPU/tinyzip&quot;&gt;TinyZip&lt;/a&gt;, I simply inserted&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	cover(o_wb_ack);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;into the &lt;a href=&quot;https://github.com/ZipCPU/tinyzip/blob/master/rtl/dualflexpress.v&quot;&gt;new/updated dual
I/O&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt;
controller.
(I was starting with
&lt;a href=&quot;https://github.com/ZipCPU/s6soc/blob/master/rtl/qflashxpress.v&quot;&gt;this QSPI&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt; controller.)
If you aren’t familiar with a &lt;code class=&quot;highlighter-rouge&quot;&gt;cover&lt;/code&gt; statement, you can consider
it a challenge to the
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal&lt;/a&gt;
&lt;a href=&quot;http://www.clifford.at/yosys&quot;&gt;tools&lt;/a&gt; to find some way to make the predicate
inside of the &lt;code class=&quot;highlighter-rouge&quot;&gt;cover&lt;/code&gt; statement–in this case &lt;code class=&quot;highlighter-rouge&quot;&gt;o_wb_ack&lt;/code&gt;–true.  To do this,
the &lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal&lt;/a&gt;
&lt;a href=&quot;http://www.clifford.at/yosys&quot;&gt;tools&lt;/a&gt; needed to trace &lt;a href=&quot;https://github.com/ZipCPU/tinyzip/blob/master/rtl/dualflexpress.v&quot;&gt;my
design&lt;/a&gt;
through the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt;
bring-up, the
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus request&lt;/a&gt;, the address
passing to the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt;,
and the return value.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;No extra logic was required!&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;I didn’t need to &lt;a href=&quot;/blog/2017/06/21/looking-at-verilator.html&quot;&gt;build a
simulation&lt;/a&gt;,
to tell the simulator to tick the clock,
tell it how many clocks to tick, feed it with just the right input along
the way–none of that.  With one line I had an example
trace through the important parts of my code.&lt;/p&gt;

&lt;p&gt;Was that all that hard?&lt;/p&gt;

&lt;p&gt;Ok, so it wasn’t perfect: the bus wires were being driven incoherently.
However, with some additional assumptions, such as those &lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;we discussed for the
Wishbone Bus&lt;/a&gt;, the traces
greatly improved.  (No, the
&lt;a href=&quot;https://github.com/ZipCPU/tinyzip/blob/master/rtl/dualflexpress.v&quot;&gt;controller&lt;/a&gt;
isn’t finished yet …)  Later, I added another cover statement to make
certain I could keep &lt;a href=&quot;https://github.com/ZipCPU/tinyzip/blob/master/rtl/dualflexpress.v&quot;&gt;the
design&lt;/a&gt;
loaded with one request after another.&lt;/p&gt;

&lt;h2 id=&quot;state-machines&quot;&gt;State Machines&lt;/h2&gt;

&lt;p&gt;Many of my designs use state machines that don’t completely cover
all of the states bits available.  For example, the “lite” versions of
&lt;a href=&quot;https://github.com/ZipCPU/wbuart32&quot;&gt;my serial port modules&lt;/a&gt;
only use states 0-8 and 15.  What if the design entered into any other
state?  Would such be possible?  With just a simple assertion,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	assert((state &amp;lt;= 8)||(state == 15));&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;I can then use
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal methods&lt;/a&gt;
to tell me if my state machine will ever get out of bounds.  Indeed, this
concept is so useful, it’s worth discussing further in the next section.&lt;/p&gt;

&lt;h2 id=&quot;dependent-logic&quot;&gt;Dependent logic&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;Formal methods&lt;/a&gt; are
also &lt;em&gt;very&lt;/em&gt; useful for making sure that dependencies between logic elements
are captured.  Hence, if you have two variables, &lt;code class=&quot;highlighter-rouge&quot;&gt;A&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;B&lt;/code&gt; that &lt;em&gt;must&lt;/em&gt;
have a dependent relationship,
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal methods&lt;/a&gt; are
very useful for making sure that dependent relationship is maintained.&lt;/p&gt;

&lt;p&gt;For example, many designs depend upon a state machine that transitions at a
speed much slower than the system clock.  My own &lt;a href=&quot;https://github.com/ZipCPU/wbuart32&quot;&gt;UART
implementation&lt;/a&gt; makes a great example
of this.  In this design, as with many similar ones, there is often a counter
used to determine &lt;em&gt;when&lt;/em&gt; the next state change will be.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
if (counter != 0)
	counter &amp;lt;= counter - 1&#39;b1;
else if (state_change) // &amp;amp;&amp;amp; counter == 0
	counter &amp;lt;= NEW_VALUE-1&#39;b1;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The problem with this approach is that within the state machine logic, I would
need to place tests for whether or not &lt;code class=&quot;highlighter-rouge&quot;&gt;counter == 0&lt;/code&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
if (i_reset)
	state  == reset_state;
else if (counter == 0)
begin
	case(state)
	STATE_ONE:
		// ...
	end case
end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This test for zero can make the &lt;a href=&quot;/blog/2017/06/12/minimizing-luts.html&quot;&gt;state transition logic unnecessarily
complex&lt;/a&gt;,
so I’ll often calculate it the clock prior with something like:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	zclk &amp;lt;= (counter == 1)||((counter == 0)&amp;amp;&amp;amp;(!state_change));&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;To determine if I got the logic right, I only need to
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formally verify&lt;/a&gt; that:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	assert(zclk == (counter == 0));&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;When the
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal&lt;/a&gt;
proof passes, I’ll know that these two dependent registers, &lt;code class=&quot;highlighter-rouge&quot;&gt;zclk&lt;/code&gt; and
&lt;code class=&quot;highlighter-rouge&quot;&gt;counter&lt;/code&gt;, are guaranteed to maintain their dependent relationship.
Hence, I can rely upon this dependency always being true within my
code–as I intended.&lt;/p&gt;

&lt;p&gt;Certainly other internal code dependencies can exist as well–often more
complex than this one.  For example, a packet index or address might need
to be zero any time the network is idle.  As I recognize that I have such
a dependency when writing my own code, I’ll often quickly write an
assertion to capture it.  Indeed, I do this so often that I’ll discuss
how to go about this in the next section.&lt;/p&gt;

&lt;h2 id=&quot;while-writing-code&quot;&gt;While writing code&lt;/h2&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/files-formal.svg&quot; alt=&quot;&quot; width=&quot;180&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Often, when I write RTL, I’ll come across a situation where I recognize some
dependency within my code that must be hold true.  Rather than write a fully
defensive piece of code that handles any potential internal failure, it
is often effective (and easier) to write a quick assertion to remind myself
to come back later and place this into the list of &lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal
properties&lt;/a&gt;
at the end of the module.&lt;/p&gt;

&lt;p&gt;Making sure I remember all of these dependencies later can be a hassle.&lt;/p&gt;

&lt;p&gt;Here’s a method I’ve found useful for that purpose.&lt;/p&gt;

&lt;p&gt;As I’m working on creating a module,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;//
// All files start with a (legalese) comment block
//
module name(/* portlist */);
	//
	// Module code is indented by one tab
	//&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;I’ll add any
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal properties&lt;/a&gt;
in line as I’m writing–but with the caveat that these ad-hoc properties
are not indented like the rest of the code.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;// Properties that need to be moved around later are not indented
// This helps me remember, when I see something that doesn&#39;t line
// up, that this property needs to be moved to another location.
always @(posedge i_clk)
	assume(!i_reset);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;My development will then continue, returning to my original indentation
scheme.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	//
	// Further module code (now indented again) may follow
	//&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Then, some time later, I’ll collect these ad-hoc &lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;assumtions and
assertions&lt;/a&gt;
into a section at the end of the module together with the rest of its
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal properties&lt;/a&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;`ifdef	FORMAL
	// Here&#39;s where the formal properties will eventually be placed:
	// between `ifdef FORMAL and it&#39;s associated `endif.
`endif&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;For example, a
&lt;a href=&quot;https://github.com/ZipCPU/wbuart32&quot;&gt;UART&lt;/a&gt; baud counter should never count
higher than one baud interval.  Hence, as I’m putting my
&lt;a href=&quot;https://github.com/ZipCPU/wbuart32&quot;&gt;UART&lt;/a&gt;
component design together, I’ll place an assertion to this effect into my code.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	assert(baud_counter &amp;lt; ONE_BAUD);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Some of my code, such as the &lt;a href=&quot;https://github.com/ZipCPU/tinyzip/blob/master/rtl/dualflexpress.v&quot;&gt;dual I/O flash
controller&lt;/a&gt;
I mentioned above, depends upon the ability to peek at a
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus request&lt;/a&gt;
at certain times before accepting it.  This requirement is easily captured by
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal properties&lt;/a&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
if ((f_past_valid)&amp;amp;&amp;amp;($past(request))&amp;amp;&amp;amp;(!$past(accepted)))
	assert(request_details == $past(request_details));&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Once I realize this, usually while building the code, I’ll just write it in
as I discussed above.  &lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;Asserts and
assumptions&lt;/a&gt;
like this alone have helped me flush out many
&lt;a href=&quot;/blog/2017/08/14/strategies-for-pipelining.html&quot;&gt;pipeline&lt;/a&gt;
bugs!&lt;/p&gt;

&lt;p&gt;Knowing that I intend to use
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal methods&lt;/a&gt;
to verify a design helps to encourage me to write properties within my
code as I write my code–even though I’ll place those at the end of the
file later.&lt;/p&gt;

&lt;h2 id=&quot;some-modules-are-just-too-critical-not-to-use-formal&quot;&gt;Some modules are just too critical not to use formal&lt;/h2&gt;

&lt;p&gt;Some interfaces I deal with are just &lt;em&gt;too critical&lt;/em&gt; not to use
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal methods&lt;/a&gt;
to prove a design component before introducing it to hardware.
For example, just one misbehaving &lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;bus
component&lt;/a&gt;
and the whole design will come crashing down.&lt;/p&gt;

&lt;p&gt;Remember how this happened to me in my first &lt;a href=&quot;/blog/2018/02/09/first-cyclonev.html&quot;&gt;Cyclone-V
project&lt;/a&gt;?  Before I
got the &lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal&lt;/a&gt;
properties of the &lt;a href=&quot;https://www.altera.com/literature/manual/mnl_avalon_spec.pdf&quot;&gt;Avalon
bus&lt;/a&gt;
just right, I had to deal with several cases of hardware lockup.
It would seem as though a
&lt;a href=&quot;/blog/2018/02/09/first-cyclonev.html&quot;&gt;Cyclone-V&lt;/a&gt;
can’t recover if my own logic fails to lower the wait request line, or
equivalently if it returns random bus responses that don’t follow requests).
In my case, only cycling power ever rescued my design, leaving me wondering
what had happened.&lt;/p&gt;

&lt;p&gt;If you’ve been reading this blog for a while, you may now recognize this
purpose in the &lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;formal WB properties
post&lt;/a&gt;.
Bus control logic is just &lt;em&gt;too sensitive&lt;/em&gt; to mess up.  All it takes
is one master missing a response to a request and your design may be locked
up until a hard reset.&lt;/p&gt;

&lt;p&gt;Cache controllers are another example, as they can be a &lt;em&gt;real pain&lt;/em&gt; to get
right.  Worse, all it takes is one &lt;a href=&quot;/zipcpu/2017/12/28/ugliest-bug.html&quot;&gt;ugly caching
error&lt;/a&gt; and you may be
&lt;a href=&quot;/blog/2017/05/19/fpga-hell.html&quot;&gt;spending days (or weeks)&lt;/a&gt;
looking in the wrong place to find the bug.&lt;/p&gt;

&lt;p&gt;My recommendation, therefore, would be that you consider this principle for
any portion of your design that, if it fails, will cause the whole design to
fail while leaving you in &lt;a href=&quot;/blog/2017/05/19/fpga-hell.html&quot;&gt;FPGA
Hell&lt;/a&gt;.
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;Formally verify&lt;/a&gt;
those components early in your design cycle, before ever placing them onto
real hardware.  Then verify them again any time you change them.&lt;/p&gt;

&lt;h2 id=&quot;some-simple-contracts&quot;&gt;Some simple contracts&lt;/h2&gt;

&lt;p&gt;I’ve recently started looking at the designs I’m building as providing a
service, and so when I start building the design I’ll often create a &lt;em&gt;contract&lt;/em&gt;
to describe the service that must be provided.  These &lt;em&gt;contracts&lt;/em&gt; are usually
just a couple of lines of &lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal
properties&lt;/a&gt;
that describe outputs in relationship to the designs inputs.
Such design contracts are often so fundamental that if the contract holds,
the design will be 80% verified (or better).&lt;/p&gt;

&lt;p&gt;Consider, for a moment, some simple peripherals from the standpoint of a
“contract”.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;Bus requests should always be followed by a bus
response&lt;/a&gt;.  There should be
no more responses than there are requests.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;A &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/dev/rtl/core/pfcache.v&quot;&gt;cache&lt;/a&gt;
should always return the value that would be found in memory at the
given address, whether it needs to read from memory to get it or instead if
it is already in the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/dev/rtl/core/pfcache.v&quot;&gt;cache&lt;/a&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Reads from a memory controller
(&lt;a href=&quot;https://github.com/ZipCPU/xulalx25soc/blob/master/rtl/wbsdram.v&quot;&gt;SDRAM&lt;/a&gt;,
&lt;a href=&quot;https://github.com/ZipCPU/tinyzip/blob/master/rtl/dualflexpress.v&quot;&gt;flash&lt;/a&gt;,
etc.) should always return the value that exists in the memory at that
location, and writes should change the memory.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;An &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/zipmmu.v&quot;&gt;MMU&lt;/a&gt;
should act as a bus bridge, between one set of addresses (the virtual ones)
and another (the physical ones), while creating page misses for anything
that doesn’t match.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The neat thing about these contracts is that they can help me prove that an
item works–to include passing the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Mathematical_induction&quot;&gt;induction&lt;/a&gt;
&lt;a href=&quot;/blog/2018/03/10/induction-exercise.html&quot;&gt;step&lt;/a&gt;.
Specifically, until the contract can be proven, the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Mathematical_induction&quot;&gt;induction&lt;/a&gt;
solver will keep presenting me with traces I need to examine.  This helps me
know how many properties I need to write.&lt;/p&gt;

&lt;p&gt;If the Lord wills, I’m hoping to blog about this concept soon with respect to a
second &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
&lt;a href=&quot;/zipcpu/2017/11/18/wb-prefetch.html&quot;&gt;prefetch module&lt;/a&gt;,
showing how a contract can be written using a couple free variables.&lt;/p&gt;

&lt;h2 id=&quot;why-do-people-think-formal-is-hard&quot;&gt;Why do people think formal is hard?&lt;/h2&gt;

&lt;p&gt;After hearing that 
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal&lt;/a&gt;
was too hard, I tried to gather all of the excuses I heard
to see if there might be some merit to any of them.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Mathematical_induction&quot;&gt;Induction&lt;/a&gt;
is harder than Bounded Model Checking (BMC)&lt;/p&gt;

    &lt;p&gt;Many of the simple examples I gave above would be perfect for bounded
proofs.  These proofs are only applicable for the first N steps (i.e
the bound) following a reset.  Bounded proofs are much easier than the
full proofs, simply because in the case of a full proof you need to
find &lt;em&gt;ALL&lt;/em&gt; the &lt;a href=&quot;/blog/2018/03/10/induction-exercise.html&quot;&gt;internal
dependencies&lt;/a&gt;.
within your design and make them known to the
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal&lt;/a&gt;
engine via additional properties–whether they be assumptions or assertions.
This can be a pain, and so I can understand that you might not wish to use
&lt;a href=&quot;https://en.wikipedia.org/wiki/Mathematical_induction&quot;&gt;induction&lt;/a&gt;
at first.  Even in this case, though, the bounded model check is still
valuable–just not nearly as valuable as the full proof with
&lt;a href=&quot;https://en.wikipedia.org/wiki/Mathematical_induction&quot;&gt;induction&lt;/a&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Some modules are just too complex to prove using
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal methods&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;This isn’t an excuse, nor should it be.  It is just a reality.&lt;/p&gt;

    &lt;p&gt;While I’ve been able to &lt;a href=&quot;/zipcpu/2018/01/22/formal-progress.html&quot;&gt;prove all of the leaf
modules&lt;/a&gt; of the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;,
the complexity of the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt; as a whole
has caused me to pause before diving into it.  While I think I &lt;em&gt;can&lt;/em&gt;
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formally prove&lt;/a&gt;
that it works, the sheer complexity has caused me to pause.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The full System Verilog Assertions syntax can be confusing&lt;/p&gt;

    &lt;p&gt;If you’ve looked at the articles I’ve written so far regarding
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal methods&lt;/a&gt;,
you may notice that I haven’t used the full System Verilog Assertion (SVA)
syntax.  This is for two reasons.&lt;/p&gt;

    &lt;p&gt;First, the open source
&lt;a href=&quot;http://www.clifford.at/yosys&quot;&gt;yosys&lt;/a&gt;
synthesis tool that I’m using to get access to
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal methods&lt;/a&gt;
without re-mortgaging my home doesn’t understand this syntax (yet).
Indeed, I’ve managed to &lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formally
verify&lt;/a&gt;
many designs with only the subset that
&lt;a href=&quot;http://www.clifford.at/yosys&quot;&gt;yosys&lt;/a&gt;
supports.  Since
&lt;a href=&quot;http://www.clifford.at/yosys&quot;&gt;yosys&lt;/a&gt;
is the tool I can afford, it’s the tool I’ve been using.&lt;/p&gt;

    &lt;p&gt;Second, I’m in the process of building a class in
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal methods&lt;/a&gt;.
This class includes a section on how to use the full SVA syntax: properties,
sequences, clocking blocks, bind statements, and more.  Since I’ve now
been introduced to the full SVA syntax, my initial impressions are that
it is very expressive, terse and compact, and as a result it is confusing
to those who are not familiar with them.  On the other hand, the
&lt;code class=&quot;highlighter-rouge&quot;&gt;assert&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;assume&lt;/code&gt; statements I’ve used within always or initial blocks
have been expressive enough for me, and simpler to understand.&lt;/p&gt;

    &lt;p&gt;It just happens that this simpler subset is also the set that
&lt;a href=&quot;http://www.clifford.at/yosys&quot;&gt;yosys&lt;/a&gt;
currently supports.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;It can be really difficult to sell
&lt;em&gt;&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal&lt;/a&gt;&lt;/em&gt;
Verification IP, simply because
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal&lt;/a&gt;
verification is a form of
&lt;a href=&quot;https://en.wikipedia.org/wiki/White_box_testing&quot;&gt;&lt;em&gt;white&lt;/em&gt; box testing&lt;/a&gt;&lt;/p&gt;

    &lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 3. Just attaching VIP to a formal design doesn&#39;t usually work&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/files-vip-unlinked.svg&quot; alt=&quot;&quot; width=&quot;360&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p style=&quot;list-style-type: none;&quot;&gt;What I mean by this is that attaching any vendor
   supplied Verification IP module to your design isn’t as simple as just
   instantiating the two components within the same design.  The
   &lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal methods&lt;/a&gt;,
   and &lt;a href=&quot;https://en.wikipedia.org/wiki/Mathematical_induction&quot;&gt;induction&lt;/a&gt;
   in particular, won’t work if you just plug and play related design pieces
   together such as Fig 3. attempts to show.  This makes it more difficult
   to sell, purchase, or use vendor provided Verification IP with
   &lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;In order to connect an external set of
   &lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal&lt;/a&gt; properties,
   such as those from a piece of vendor supplied Verification IP, to the
   &lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal&lt;/a&gt; properties
   within your own design–relevant portions of the design need to be
   constrained to be properly dependent with the VIP.
   Success in this fashion is far more intrusive, and not nearly as simple
   as just purchasing someone else’s IP.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 4. Passing Induction requires component state to interact&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/files-vip-linked.svg&quot; alt=&quot;&quot; width=&quot;360&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Perhaps a good example of this is my
   &lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;Wishbone&lt;/a&gt; &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/ex/wbpriarbiter.v&quot;&gt;bus
   arbiter&lt;/a&gt;.
   Internal to the &lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;Wishbone formal
   property&lt;/a&gt;
   &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/tree/master/rtl/ex&quot;&gt;IP modules&lt;/a&gt;
   are the counters necessary to insure that slaves will only respond
   to outstanding requests.  This
   requires counting the number of requests, the number of acknowledgments,
   and then making certain that there are never more acknowledgments than
   requests.  When I then try to use these properties within the bus
   &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/ex/wbpriarbiter.v&quot;&gt;arbiter&lt;/a&gt;
   to pass
   &lt;a href=&quot;https://en.wikipedia.org/wiki/Mathematical_induction&quot;&gt;induction&lt;/a&gt;,
   the
   &lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal&lt;/a&gt; engine
   may set these counters to &lt;a href=&quot;/blog/2018/03/10/induction-exercise.html&quot;&gt;any initial value it
   wants&lt;/a&gt;.  However,
   the arbiter
   is designed so that only one master can ever have access to the bus at a
   time.  This means that the counters for the two slave inputs and the master
   output must be kept in sync.  Doing this requires knowledge of the counters
   within the
   &lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;Wishbone&lt;/a&gt; propert
   &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/tree/master/rtl/ex&quot;&gt;module&lt;/a&gt;,
   enough so that I can assert that when one bus source has access to the bus,
   the other sources number of outstanding requests must remain at zero.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
if (r_a_owner)
begin
	// If A owns the bus

	// B must have no outstanding requests, nor may it
	// have received any acknowledgements
	assert(f_b_nreqs == 0);
	assert(f_b_nacks == 0);

	// The total number of outstanding requests must equal
	// the number of outstanding requests A is expecting
	assert(f_a_outsanding == f_outstanding);
end else begin
	// Else B must own the bus
	// Same properties as before, just reversed
	assert(f_a_nreqs == 0);
	assert(f_a_nacks == 0);
	assert(f_b_outsanding == f_outstanding);
end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig. Here&#39;s how I ended up attaching WB properties to a simple design&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/files-wb-properties.svg&quot; alt=&quot;&quot; width=&quot;480&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;If you fail to do this, your design &lt;a href=&quot;/blog/2018/03/10/induction-exercise.html&quot;&gt;won’t be able
   to pass&lt;/a&gt;
   &lt;a href=&quot;https://en.wikipedia.org/wiki/Mathematical_induction&quot;&gt;induction&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Even if your design doesn’t pass
   &lt;a href=&quot;https://en.wikipedia.org/wiki/Mathematical_induction&quot;&gt;induction&lt;/a&gt;,
   (most big chip maker designs don’t) your &lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal
   properties&lt;/a&gt;
   may still be good enough to accomplish some purposes, since you can still
   find lots of bugs via a simple Bounded Model Check.  You just can’t &lt;em&gt;prove&lt;/em&gt;
   that your design will maintain those properties for all time.&lt;/p&gt;

&lt;p&gt;Does it take a genius?  Not really.  Indeed, from my own experience,
it just takes someone smart enough to write Verilog RTL in the first place.&lt;/p&gt;

&lt;h2 id=&quot;formal-isnt-perfect&quot;&gt;Formal isn’t perfect&lt;/h2&gt;

&lt;p&gt;My thesis today is just that
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal&lt;/a&gt;
isn’t really any more difficult than normal RTL coding.  Not only that, it fits
nicely into the RTL coding process and even adds to it.  Now that I’ve used it
for a while, and now that I’ve found as many errors as I have using
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal&lt;/a&gt;,
I’m convinced from my own experience that it’s not really that hard.  Indeed,
if I had the choice today, I would find it difficult to start a project
&lt;em&gt;without&lt;/em&gt; the help
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal methods&lt;/a&gt;
provide.&lt;/p&gt;

&lt;p&gt;While I was at the
&lt;a href=&quot;https://dvcon.org&quot;&gt;DVCon&lt;/a&gt; conference, I heard two fascinating comments
regarding how valuable &lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal
methods&lt;/a&gt; are,
and many fascinating anecdotes.  The first comment I scribbled down was
that, “Without &lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal&lt;/a&gt;,
70% of the bugs in a design are found after the module is turned in.  With
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal&lt;/a&gt;,
80% of the bugs in a design are found before the module is turned in.”
No, I’m not sure any more where these numbers came from, so if I can find the
study I’d love to share it with you.  The
second comment was from one of the panelists who noted that a rough 80% of a
verification engineer’s time is spent fixing the &lt;em&gt;silly&lt;/em&gt; bugs.  The
implication in this statement was that, had only
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal methods&lt;/a&gt;
been used, the verification engineer wouldn’t need to be spending his time
fixing the stupid mistakes.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;Formal methods&lt;/a&gt;
aren’t perfect.  By that I mean that, in my own experience, I’ve still had
to chase down bugs that “passed” a formal proof.
These include problems with not constraining my design enough, with adding
careless assumptions, and even misunderstood requirements.&lt;/p&gt;

&lt;p&gt;However, I find 
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal methods&lt;/a&gt;
easier to use than the alternative, and I also feel like I am finding more
bugs by using them as part of my design process.  As a result, I now use
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal methods&lt;/a&gt;
first, and then continue with simulation when I’m done.&lt;/p&gt;

&lt;p&gt;So why do people think
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal&lt;/a&gt; is all that
difficult?  My best guess is that
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal methods&lt;/a&gt;
appear difficult to those who have not tried them, and additionally to those
selling Verification IP.&lt;/p&gt;
&lt;hr /&gt;&lt;p&gt;&lt;em&gt;Behold, I am the LORD, the God of all flesh: is there any thing too hard for me?  (Jeremiah 32:27)&lt;/em&gt;</description>
        <pubDate>Wed, 14 Mar 2018 00:00:00 -0400</pubDate>
        <link>http://zipcpu.com/blog/2018/03/14/is-formal-hard.html</link>
        <guid isPermaLink="true">http://zipcpu.com/blog/2018/03/14/is-formal-hard.html</guid>
        
        
        <category>blog</category>
        
      </item>
    
  </channel>
</rss>
