<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>The ZipCPU by Gisselquist Technology</title>
    <description>The ZipCPU blog, featuring how to discussions of FPGA and CPU design. This site will be focused on Verilog solutions, using exclusively OpenSource IP products for FPGA design.
</description>
    <link>http://zipcpu.com/</link>
    <atom:link href="http://zipcpu.com/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Mon, 29 May 2017 07:54:48 -0400</pubDate>
    <lastBuildDate>Mon, 29 May 2017 07:54:48 -0400</lastBuildDate>
    <generator>Jekyll v3.0.1</generator>
    
      <item>
        <title>Building a simple wishbone slave</title>
        <description>&lt;p&gt;If you’ve never written bus logic before, the
&lt;a href=&quot;http://opencores.org/opencores,wishbone&quot;&gt;wishbone bus&lt;/a&gt; is a good place to
start.  Although other busses have more features to them, 
the &lt;a href=&quot;http://opencores.org/opencores,wishbone&quot;&gt;wishbone bus&lt;/a&gt; can be simplified
into an extremely easy bus to work with.&lt;/p&gt;

&lt;p&gt;For our purpose, we’ll be using the
&lt;a href=&quot;http://opencores.org/cdn/downloads/wbspec_b4.pdf&quot;&gt;B4 version of the specification&lt;/a&gt;,
and specifically the pipelined mode within it.&lt;/p&gt;

&lt;h2 id=&quot;wishbone-bus-components&quot;&gt;Wishbone bus components&lt;/h2&gt;

&lt;p&gt;The first step, though, is to simplify the wishbone bus for our discussion.
As with the other logic I have presented, I prefix ports with &lt;strong&gt;i_&lt;/strong&gt; if they
are inputs, and &lt;strong&gt;o_&lt;/strong&gt; if they are outputs.  Further, because these inputs
and outputs to our bus slave are wishbone connected, I’ll adjust their
prefixes to read &lt;strong&gt;i_wb_&lt;/strong&gt; for inputs and &lt;strong&gt;o_wb_&lt;/strong&gt; for outputs.&lt;/p&gt;

&lt;p&gt;Using this notation, the
&lt;a href=&quot;http://opencores.org/cdn/downloads/wbspec_b4.pdf&quot;&gt;wishbone specification&lt;/a&gt;
defines the following wires from the perspective of a slave:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;i_wb_cyc&lt;/strong&gt; is true any time a wishbone transaction is taking place.  It
 needs to become true on (or before) the first &lt;strong&gt;i_wb_stb&lt;/strong&gt; clock,
 and generally stays true until the last &lt;strong&gt;o_wb_ack&lt;/strong&gt;.&lt;/p&gt;

    &lt;p&gt;We’re going to assume that the &lt;strong&gt;i_wb_cyc&lt;/strong&gt; line is high during our
 transaction, and that the logic necessary to insure this has already been
 taken care of within the bus master.  Therefore, we’ll ignore this wire.&lt;/p&gt;

    &lt;p&gt;Incidentally, the &lt;a href=&quot;http://opencores.org/cdn/downloads/wbspec_b4.pdf&quot;&gt;specification&lt;/a&gt;
 isn’t clear regarding whether or not this signal can be ignored by the slave.
 (It cannot be ignored by the interconnect …)  If you
 are dealing with a master you aren’t certain of, you can &lt;em&gt;and&lt;/em&gt; your
 &lt;strong&gt;i_wb_stb&lt;/strong&gt; line with your &lt;strong&gt;i_wb_cyc&lt;/strong&gt; signal and do just as well.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;i_wb_stb&lt;/strong&gt; is true for any bus transaction request.  While &lt;strong&gt;i_wb_stb&lt;/strong&gt;
 is true, the other wishbone slave inputs (&lt;strong&gt;i_wb_we&lt;/strong&gt;, &lt;strong&gt;i_wb_addr&lt;/strong&gt;,
 &lt;strong&gt;i_wb_data&lt;/strong&gt;, and &lt;strong&gt;i_wb_sel&lt;/strong&gt;) are valid and reference the same
 transaction.  The transaction is accepted by the slave any time
 &lt;strong&gt;i_wb_stb&lt;/strong&gt; is true at the same time as &lt;strong&gt;o_wb_stall&lt;/strong&gt; is false.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;i_wb_we&lt;/strong&gt; is true for any write requests&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;i_wb_addr&lt;/strong&gt; contains the address of the request&lt;/p&gt;

    &lt;p&gt;From the perspective of
 the wishbone slave that we are working with, this address contains only the
 address lines of relevance to the slave.  Hence, while the bus may have 32
 address lines, the slave might only be interested in might have anywhere
 between no address lines and all 32 address lines.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;i_wb_data&lt;/strong&gt; contains the data we wish to write.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;o_wb_ack&lt;/strong&gt; is a response from the slave, indicating that the request has
 been completed.  For every request given to the slave, there must be one
 and only one clock cycle with &lt;strong&gt;o_wb_ack&lt;/strong&gt; high&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;o_wb_stall&lt;/strong&gt; is used to control the flow of data into the slave.  It will
 be true on any cycle when the master &lt;em&gt;cannot&lt;/em&gt; accept data from the slave,
 and false any time data can be accepted.  This allows the slave to control
 the flow of requests being given to it.&lt;/p&gt;

    &lt;p&gt;For our simple example, we’ll just set this line to zero.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;o_wb_data&lt;/strong&gt; is the data returned by the slave to the bus master as a 
 result of any read request.  It is valid whenever &lt;strong&gt;o_wb_ack&lt;/strong&gt; is true,
 and it’s value may be ignored any time &lt;strong&gt;o_wb_ack&lt;/strong&gt; is false.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;While &lt;a href=&quot;http://opencores.org/cdn/downloads/wbspec_b4.pdf&quot;&gt;the spec&lt;/a&gt;,
defines other wires that may be a part of this interface, we’ll ignore these
and instead focus on the minimum required logic
necessary to get a simplified demonstration up and running.&lt;/p&gt;

&lt;h2 id=&quot;writes-to-the-slave&quot;&gt;Writes to the slave&lt;/h2&gt;

&lt;p&gt;You may remember from our discussion on how to write to a 
&lt;a href=&quot;/zipcpu/2017/05/23/simplebus.html&quot;&gt;very simple bus&lt;/a&gt; that we based all of
our logic off of an &lt;strong&gt;i_wr&lt;/strong&gt; line.  Whenever this line was true, we would
read from the bus.  As a review,
the &lt;a href=&quot;/zipcpu/2017/05/23/simplebus.html&quot;&gt;simple bus&lt;/a&gt; write logic was written as,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	if (i_wr)
		memory[i_addr] &amp;lt;= i_data;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Moving from this simple example to the wishbone is quite easy.  In particular,
&lt;em&gt;all&lt;/em&gt; we need to do is to adjust the &lt;strong&gt;i_wr&lt;/strong&gt; logic for the wishbone bus.
Once done, the interaction should look identical:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	if ((i_wb_stb)&amp;amp;&amp;amp;(i_wb_we)&amp;amp;&amp;amp;(!o_wb_stall))
	begin
		// Your write logic here, such as
		// memory[i_addr] &amp;lt;= i_data;
	end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Simple, huh?&lt;/p&gt;

&lt;h2 id=&quot;reads-from-the-slave&quot;&gt;Reads from the slave&lt;/h2&gt;

&lt;p&gt;Reading from the port is fairly easy as well.  The first step is to create a
response for every address given to us, as we did before.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	//
	// Basically o_wb_data &amp;lt;= memory[i_wb_addr];
	//
	// If you aren&#39;t implementing a memory, your
	// result will instead look like ...
	case(i_wb_addr)
	4&#39;h0: o_wb_data &amp;lt;= some_register;
	// ...
	default: o_wb_data &amp;lt;= some_default response;
	end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;One more step is required for both reading and writing: we need to return an
acknowledgement back to the bus that this transaction has been completed, and
that the data on the bus is now valid.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	o_wb_ack &amp;lt;= ((i_wb_stb)&amp;amp;&amp;amp;(!o_wb_stall));&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;For some peripherals, the answer is known before you request it.  In that
case, you might just &lt;em&gt;assign&lt;/em&gt; the &lt;strong&gt;o_wb_ack&lt;/strong&gt; signal instead of waiting for
the positive edge of the clock.&lt;/p&gt;

&lt;p&gt;Other peripherals may need to delay the acknowledgement by another clock.  Two examples of this would be the &lt;a href=&quot;https://github.com/ZipCPU/wbscope&quot;&gt;wishbone scope&lt;/a&gt; and the &lt;a href=&quot;https://github.com/ZipCPU/wbuart/blob/master/wbuart.v&quot;&gt;wbuart serial port&lt;/a&gt; controller.  Both of these examples require one clock to calculate an output,
and then another clock to select between possible outputs.&lt;/p&gt;

&lt;p&gt;The other key piece to any wishbone interaction is the stall line.  For our
simple interaction, we’ll just hold this line zero.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;assign	o_wb_stall = 1&#39;b0;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;What that means is that we are able to accept a wishbone request on every
clock cycle, and that our transaction rate will be as fast as the clock rate.
This works well for many peripherals, although some peripherals such as
&lt;a href=&quot;http://opencores.org/project,qspiflash&quot;&gt;flash&lt;/a&gt;
or &lt;a href=&quot;http://github.com/ZipCPU/xulalx25/blob/master/rtl/wbsdram.v&quot;&gt;SDRAM&lt;/a&gt; may
need to adjust this line if they cannot accept a new request every
clock cycle.&lt;/p&gt;

&lt;h2 id=&quot;what-if-you-can-only-accept-requests--sometimes&quot;&gt;What if you can only accept requests … sometimes?&lt;/h2&gt;

&lt;p&gt;So … what if your peripheral cannot accept requests on every clock cycle?&lt;/p&gt;

&lt;p&gt;Here’s an example set of logic where the peripheral starts a state machine
upon any request, and only returns a result once the state machine becomes
idle.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;reg	busy;

always @(posedge i_clk)
	if ((i_wb_stb)&amp;amp;&amp;amp;(!o_wb_stall))
	begin
		state &amp;lt;= SOME_NEW_STATE;
		local_data &amp;lt;= i_wb_data;
		busy &amp;lt;= 1&#39;b1;
	end else case(state)
	SOME_NEW_STATE: begin
		// Your logic here ...
		if (some_condition)
			state &amp;lt;= SOME_NEXT_STATE;
		end
	...
	SOME_FINAL_STATE: begin
		state &amp;lt;= IDLE_STATE;
		busy &amp;lt;= 1&#39;b0;
		ack  &amp;lt;= 1&#39;b1;
		o_data &amp;lt;= any_read_data_response;
	enddcase

assign	o_wb_stall &amp;lt;= busy;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Examples of this in practice include the
&lt;a href=&quot;https://github.com/ZipCPU/wbicapetwo&quot;&gt;wishbone ICAPE2 controller&lt;/a&gt;,
and a &lt;a href=&quot;http://opencores.org/project,qspiflash&quot;&gt;QSPI flash controller&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;what-can-you-use-this-interface-for&quot;&gt;What can you use this interface for?&lt;/h2&gt;

&lt;p&gt;What can you use this for?  Anything!  Feel free to look over our
&lt;a href=&quot;/projects.html&quot;&gt;projects page&lt;/a&gt; for some example peripheral components that
use this simple interaction.&lt;/p&gt;

&lt;p&gt;In particular, I intend to follow up this article with the idea of using a
wishbone interface to create an interface whereby
&lt;a href=&quot;https://github.com/ZipCPU/wbscope&quot;&gt;a scope&lt;/a&gt; may be read for improved
debugging purposes.&lt;/p&gt;
</description>
        <pubDate>Mon, 29 May 2017 00:00:00 -0400</pubDate>
        <link>http://zipcpu.com/zipcpu/2017/05/29/simple-wishbone.html</link>
        <guid isPermaLink="true">http://zipcpu.com/zipcpu/2017/05/29/simple-wishbone.html</guid>
        
        
        <category>zipcpu</category>
        
      </item>
    
      <item>
        <title>Debugging an FPGA through the serial port--first steps</title>
        <description>&lt;p&gt;Now that you have a working &lt;a href=&quot;https://github.com/ZipCPU/wbuart32&quot;&gt;serial port&lt;/a&gt;
which you can use to interact with your CPU, and now again that you know how to
&lt;a href=&quot;/zipcpu/2017/05/23/simplebus.html&quot;&gt;respond to simple bus requests&lt;/a&gt;,
let’s examine whether these two be put together to create a simple means of
debugging your FPGA.&lt;/p&gt;

&lt;p&gt;In this post, we’ll build a generic means for both reading registers
internal to an FPGA using a serial port, and then using that approach to
debug your design.&lt;/p&gt;

&lt;h2 id=&quot;an-generic-serial-port-communication-interface&quot;&gt;An generic serial port communication interface&lt;/h2&gt;

&lt;p&gt;For the purpose of this discussion, let’s assume your serial port receiver
produces two outputs:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;rx_stb&lt;/strong&gt; – a logic value that is true any time a value has been received
across the receive port.  It is to be true for one clock cycle, and one clock
cycle only, any time something is received.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;rx_data&lt;/strong&gt; – Eight bits of logic representing the most recently received
data value from the received serial port.  This value has meaning anytime
&lt;strong&gt;rx_data&lt;/strong&gt; is true, and ignored at all other times.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Likewise, we’ll assume that your serial port transmitter has two inputs,
&lt;strong&gt;tx_stb&lt;/strong&gt; and &lt;strong&gt;tx_data&lt;/strong&gt;.  Their meaning will be analogous to that of the
receivers ports.&lt;/p&gt;

&lt;p&gt;The advanced student may notice this interface protocol isn’t complete.
In particular, the transmitter may be busy some time &lt;strong&gt;tx_stb&lt;/strong&gt; is true, and
nothing above allows us to capture that reality.  To be complete, then, you
will need a third wire, this one coming from your transmit interface:
&lt;strong&gt;tx_busy&lt;/strong&gt;.  This wire is true any time the transmitter is busy.  When put
together with the rest of the interface, a character will be accepted into
the transmit interface any time &lt;strong&gt;tx_stb&lt;/strong&gt; is true &lt;em&gt;and&lt;/em&gt; &lt;strong&gt;tx_busy&lt;/strong&gt; is
false.  We’ll ignore this wire for now.  As long as you don’t press this
interface too hard, the approach below will work.&lt;/p&gt;

&lt;p&gt;With that out of the way, we can move on to building our basic debug protocol,
based upon this interface to a serial port.&lt;/p&gt;

&lt;h2 id=&quot;using-a-clock-enable-as-part-of-a-debug-process&quot;&gt;Using a Clock Enable as part of a debug process&lt;/h2&gt;

&lt;p&gt;The first step is a clock enable line.  I’ll call this &lt;strong&gt;logic_ce&lt;/strong&gt; for now,
but you may see me call it &lt;strong&gt;i_ce&lt;/strong&gt; later.
We’ll use this clock enable line to gate all of your logic, such as:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	if (logic_ce)
	begin
		//
		// Your debuggable FPGA logic goes here.
		//

		// You could even stuff a full blown CPU in here, if you
		// wanted to debug it this way.

		// Anything that doesn&#39;t fit in this always block, will
		// still need to have it&#39;s logic gated by the ce line above.
	end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The goal here is to keep &lt;em&gt;any&lt;/em&gt; logic from changing unless the &lt;strong&gt;logic_ce&lt;/strong&gt;
line is true.&lt;/p&gt;

&lt;p&gt;Why are we doing this?  We’re doing this to slow down your logic to the point
where it can be inspected.&lt;/p&gt;

&lt;p&gt;What … how shall this ce line be controlled?&lt;br /&gt;
You can use the serial port to control this clock enable.   For this
example, we’ll set the serial port up so that any time you send an
8’h00 across the serial port channel, you also step all the logic by one clock.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	logic_ce &amp;lt;= (rx_stb)&amp;amp;&amp;amp;(rx_data == 8&#39;h00);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Sure, this will &lt;em&gt;really&lt;/em&gt; slow down your logic, but … you’ll still be running
&lt;em&gt;your&lt;/em&gt; logic on the FPGA.  Where this gets useful is in the next step, reading
data back ouf of the FPGA.&lt;/p&gt;

&lt;h2 id=&quot;reading-data-back-from-within-your-fpga&quot;&gt;Reading data back from within your FPGA&lt;/h2&gt;

&lt;p&gt;What really makes this idea flow work, is that now, because of the &lt;em&gt;ce&lt;/em&gt; line
above, we can step any logic within the FPGA.  We can then read values back
out of the FPGA while everything is stopped.  Using that UART to control your
bus, you can read out any of your data points with code something like this:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	if (rx_stb)
	begin
		tx_stb &amp;lt;= 1&#39;b1;
		case(rx_data)
		8&#39;h00: tx_data &amp;lt;= 8&#39;h00;
		8&#39;h01: tx_data &amp;lt;= one_of_my_registers;
		8&#39;h02: tx_data &amp;lt;= another_of_my_registers;
		8&#39;h03: tx_data &amp;lt;= a_third_set_of_internal_variables;
		...
		8&#39;hff: tx_data &amp;lt;= the_last_result_i_might_return;
		default: tx_data &amp;lt;= 8&#39;h00;
		endcase
	end else
		tx_stb &amp;lt;= 1&#39;b0;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Using this simple approach, you can now read the results of any logic within
your design.  You could also do something similar in the other direction
to set any values within your design if you so wished, but I’ll leave that last
change up to you.&lt;/p&gt;

&lt;h2 id=&quot;this-really-needs-a-software-controller&quot;&gt;This really needs a software controller&lt;/h2&gt;

&lt;p&gt;While reading from addresses ‘0’-‘9’ (i.e. 8’d48 to 8’d57) may be pretty
simple, and may be done within a
simple terminal program, chances are that if you wish to make this work you’ll
want to connect a computer program to that terminal program.   That computer
program will need to send the full set of characters from 8’d0 to 8’d255.&lt;/p&gt;

&lt;p&gt;You can see how I drive my serial port in the
&lt;a href=&quot;https://github.com/ZipCPU/openarty/blob/master/sw/host/netuart.cpp&quot;&gt;netuart&lt;/a&gt;
program I use to
bounce the serial port to a TCP/IP port, but there’s no reason why you couldn’t
use this as an example of how to interact with a serial port.  The commands
would be similar, only the network stuff would need to come out.&lt;/p&gt;

&lt;h2 id=&quot;multi-stepping&quot;&gt;Multi-Stepping&lt;/h2&gt;

&lt;p&gt;There’s no reason why you cannot step several steps at a time using this
approach.  You could also set-up multi-cycle instructions that will start
whenever you write a NULL to the port, and whose data may be read after a
programmable number of clocks.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;reg	counter;
always @(posedge i_clk)
	if ((rx_stb)&amp;amp;&amp;amp;(rx_data == 8&#39;h00))
		counter &amp;lt;= 0;
		logic_ce &amp;lt;= 1&#39;b1;
	else if (counter &amp;lt; NCLOCKS-1)
		counter &amp;lt;= counter + 1&#39;b1;
	else
		logic_ce &amp;lt;= 1&#39;b0;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Indeed, the possibilities of using this approach for debugging are nearly
endless.&lt;/p&gt;

&lt;h2 id=&quot;output-formats&quot;&gt;Output Formats&lt;/h2&gt;

&lt;p&gt;If you’d like, you can take the outputs you get from this debugging interface
and build a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Value_change_dump&quot;&gt;VCD&lt;/a&gt; file for viewing in
&lt;a href=&quot;gtkwave.sourceforge.net&quot;&gt;GTKwave&lt;/a&gt;.  If your not sure how to build a 
&lt;a href=&quot;https://en.wikipedia.org/wiki/Value_change_dump&quot;&gt;VCD&lt;/a&gt; file, then just dump
the results into a pseudo-human readable text file and you can then wait
for a later discussion on how to create
&lt;a href=&quot;https://en.wikipedia.org/wiki/Value_change_dump&quot;&gt;VCD&lt;/a&gt; files.&lt;/p&gt;

&lt;p&gt;Me?  Back when I last used this approach (yes, it was some time ago), I just
created a file that I could view using &lt;a href=&quot;https://www.gnu.org/software/octave&quot;&gt;octave&lt;/a&gt;.  &lt;a href=&quot;https://www.gnu.org/software/octave&quot;&gt;Octave&lt;/a&gt; allowed me to not only read in a set of binary data, but it aso allowed me to create
&lt;a href=&quot;gtkwave.sourceforge.net&quot;&gt;GTKwave&lt;/a&gt; types of graphs of the signals within my
design.  Then again, that was a personal choice and you might wish to view
the results in another fashion..&lt;/p&gt;

&lt;p&gt;Am I still using this approach?  Not really.  I’ve built something better
since.  Stick around, and you’ll hear about it.  For now, …&lt;/p&gt;

&lt;p&gt;Go ahead, take this opportunity to surprise me with your ingenuity.&lt;/p&gt;

</description>
        <pubDate>Fri, 26 May 2017 00:00:00 -0400</pubDate>
        <link>http://zipcpu.com/blog/2017/05/26/simpledbg.html</link>
        <guid isPermaLink="true">http://zipcpu.com/blog/2017/05/26/simpledbg.html</guid>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>That first serial port: Debugging when you are blind</title>
        <description>&lt;p&gt;Getting your first communications port up and running on an FPGA can be a &lt;em&gt;real&lt;/em&gt;
challenge.  After you get your serial port up and running, you can then use it
to get the next item up and running–since a serial port can provide a lot of 
feedback.  But until you can read that feedback, how can you avoid
&lt;a href=&quot;/blog/2017/05/19/fpga-hell.html&quot;&gt;FPGA hell&lt;/a&gt; long enough to
get that first port up and running?&lt;/p&gt;

&lt;h2 id=&quot;the-easy-way&quot;&gt;The easy way&lt;/h2&gt;

&lt;p&gt;If you want to do things the easy way, then just connect your serial port logic
to a known working
&lt;a href=&quot;https://en.wikipedia.org/wiki/Universal_asynchronous_receiver/transmitter&quot;&gt;UART&lt;/a&gt;
simulator, such as &lt;a href=&quot;https://github.com/ZipCPU/wbuart32/blob/master/bench/cpp/uartsim.cpp&quot;&gt;this
one&lt;/a&gt;,
and examine the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Value_change_dump&quot;&gt;VCD&lt;/a&gt;
output until you get the right answers from the serial
port.  As an example, consider the
&lt;a href=&quot;https://github.com/ZipCPU/wbuart/blob/master/bench/verilog/helloworld.v&quot;&gt;helloworld.v&lt;/a&gt;
module, together with the
&lt;a href=&quot;https://github.com/ZipCPU/wbuart/blob/master/bench/cpp/helloworld.cpp&quot;&gt;helloworld.cpp&lt;/a&gt;
&lt;a href=&quot;https://www.veripool.org/wiki/verilator&quot;&gt;Verilator&lt;/a&gt; driver,
for inspiration on how you might do this.&lt;/p&gt;

&lt;p&gt;Once your hello world design runs in the simulator, and once you get “Hello
World” on the screen, you are reading for real hardware.&lt;/p&gt;

&lt;p&gt;That’s the easy way.&lt;/p&gt;

&lt;h2 id=&quot;building-your-own-simulator&quot;&gt;Building your own simulator&lt;/h2&gt;

&lt;p&gt;But … what happens if you wish to communicate with your FPGA over something
other than a serial port, and you have no serial port to bootstrap your
efforts?&lt;/p&gt;

&lt;p&gt;In that case, you’ll want to build your own simulator.&lt;/p&gt;

&lt;p&gt;Since I’ve done this so often, I maintain a &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/sim/verilator/testb.h&quot;&gt;test bench C++
class&lt;/a&gt;
which I often use for wrapping the
&lt;a href=&quot;https://www.veripool.org/wiki/verilator&quot;&gt;Verilator&lt;/a&gt;
commands within a simulator. 
While it doesn’t handle all of the
&lt;a href=&quot;https://www.veripool.org/wiki/verilator&quot;&gt;Verilator&lt;/a&gt;
code, it does handle most of it.  Still, there’s often quite a bit of work
to be done.  You can see examples of simulators I’ve built for
&lt;a href=&quot;https://github.com/ZipCPU/wbi2c/blob/master/bench/cpp&quot;&gt;I2C controller&lt;/a&gt;,
a &lt;a href=&quot;https://github.com/ZipCPU/wbpmic/blob/master/bench/cpp&quot;&gt;PMod MIC controller&lt;/a&gt;,
a &lt;a href=&quot;https://github.com/ZipCPU/sdspi/blob/master/bench/cpp&quot;&gt;SPI based SD-card controller&lt;/a&gt;,
or even the &lt;a href=&quot;https://github.com/ZipCPU/wbscope/blob/master/bench/cpp&quot;&gt;wishbone scope&lt;/a&gt;, which I hope to work our way up to in this blog.&lt;/p&gt;

&lt;p&gt;I would also recommend making heavy use of the
&lt;a href=&quot;http://www.cplusplus.com/refernce/cassert/assert/&quot;&gt;C assert&lt;/a&gt;
statement any time your code &lt;em&gt;must&lt;/em&gt; do something.  For example, if you must
wait at least 20 clocks from any request to the next, then count clocks within
your simulator and
&lt;a href=&quot;http://www.cplusplus.com/refernce/cassert/assert/&quot;&gt;assert&lt;/a&gt;
that the time between accesses is less than 20.  Just be careful to make
certain you flush any
&lt;a href=&quot;https://en.wikipedia.org/wiki/Value_change_dump&quot;&gt;VCD&lt;/a&gt;
file you are creating before calling
&lt;a href=&quot;http://www.cplusplus.com/refernce/cassert/assert/&quot;&gt;assert&lt;/a&gt;, lest
you don’t get the data leading up to it.
(The &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/sim/verilator/testb.h&quot;&gt;test bench
class&lt;/a&gt;
was recently updated to handle this by default)&lt;/p&gt;

&lt;p&gt;Once your code works in your simulated environment, the next step is to try
it on the hardware.&lt;/p&gt;

&lt;h2 id=&quot;the-easy-move-to-hardware&quot;&gt;The Easy Move to Hardware&lt;/h2&gt;

&lt;p&gt;The easy way of getting this next step going is to use an oscilloscope.  You’ll
want to build a development board with particular “test-points” where you can
hook up the probe for the scope, and see what’s going on.  Barring test points
on the actual wires, sometimes you can use a general purpose I/O pin to become
a test point.&lt;/p&gt;

&lt;p&gt;This is also the expensive way.&lt;/p&gt;

&lt;p&gt;I don’t own a scope, neither do I have the cash to design my own boards, so …
enjoy this approach if you can do it.&lt;/p&gt;

&lt;h2 id=&quot;the-harder-way-to-get-hardware-working&quot;&gt;The Harder way to get Hardware Working&lt;/h2&gt;

&lt;p&gt;The difficult part of this first task on your hardware is, how do you know
what’s going on at high speed?  If you don’t have an Oscilloscope to measure
that high speed interaction, if all you have are your LED’s and your clock,
how shall you get to the next step?&lt;/p&gt;

&lt;p&gt;The answer is to use your LED(s), just like we discussed when &lt;a href=&quot;/blog/2017/05/19/blinky.html&quot;&gt;building
blinky&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Let’s take a look a some particular tests you can try.&lt;/p&gt;

&lt;h2 id=&quot;look-for-whether-or-not-the-serial-port-is-getting-set&quot;&gt;Look for whether or not the serial port is getting set&lt;/h2&gt;

&lt;p&gt;Your first question is going to be, am I even toggling the right wire, or
vice versa, am I listening to the right wire?&lt;/p&gt;

&lt;p&gt;In the case of a serial port, the line should idle high (at one) when nothing
is being sent.  So anytime the line isn’t one is an event you are interested in,
right?&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	if (!ck_uart)
		counter &amp;lt;= 0;
	else if (!counter[24])
		counter &amp;lt;= counter + 1&#39;b1;
assign	o_led = counter[24];&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;You did remember to use two flip flops to synchronize an asynchronous input,
right?&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	r_uart &amp;lt;= i_uart;
always @(posedge i_clk)
	ck_uart &amp;lt;= r_uart;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Put together, this will turn your LED off if the UART line is ever active. 
Once the character has been sent, the LED should idle high.  (This way you
know the LED works …)  If the LED isn’t
idling high, or if the line never goes low, then you know that you may be
listening to the wrong wire.  If the LED never turns off, you might not
have the right serial port coming out of your computer.&lt;/p&gt;

&lt;p&gt;Incidentally, this test usually finds most of the UART problems that take
place using code that passes the simulation test.&lt;/p&gt;

&lt;h2 id=&quot;check-to-see-if-your-baud-rate-is-set-right&quot;&gt;Check to see if your baud rate is set right&lt;/h2&gt;

&lt;p&gt;Since the start bit in any &lt;a href=&quot;https://en.wikipedia.org/wiki/Universal_asynchronous_receiver/transmitter&quot;&gt;serial port transaction is always
zero&lt;/a&gt;, we should be able
to check for whether or not that first clock stays low for a full baud duration
as follows:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	if ((counter[24])&amp;amp;&amp;amp;(!ck_uart))
	begin
		// If we are idle and something comes across the wire,
		// start counting.
		counter &amp;lt;= 0;
		transitioned &amp;lt;= 1&#39;b0;
	end else if (!counter[24])
	begin
		// While we are not yet idle, count up on the counter
		// to something near a second ...
		counter &amp;lt;= counter + 1&#39;b1;

		// Set the bit_interval counter on *every* clock,
		// up until the UART line goes high again
		if (!transitioned)
			bit_interval &amp;lt;= counter;

		// When that first transition from zero happens, grab
		// how long things had been low.
		if ((ck_uart)&amp;amp;&amp;amp;(!transitioned))
			transitioned &amp;lt;= 1&#39;b1;
	end

// Now that we have a bit_interval estimate, test it and set our LED
always @(posedge i_clk)
	o_led &amp;lt;= ((transitioned)&amp;amp;&amp;amp;&amp;amp;(bit_interval &amp;lt; ONE_AND_A_TENTH_BAUD)
			&amp;amp;&amp;amp;(bit_interval &amp;gt; NINE_TENTHS_OF_A_BAUD));&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This should help you discover what speed your port is transmitting at.  Just
to check, send an “A” to the port.  Since “A” is represented by 8’d65, which
is an odd number, and since serial ports transmit the
&lt;a href=&quot;https://upload.wikipedia.org/wikipedia/commons/thumb/2/24/UART_timing_diagram.svg/800px&quot;&gt;LSB first&lt;/a&gt;, this should
allow you to determine if you are within the baud rate you are expecting.
If “A” doesn’t pass, but “B” does, then you’re baud rate is too slow.&lt;/p&gt;

&lt;p&gt;This simple test &lt;em&gt;should&lt;/em&gt; find most of the rest of your problems.&lt;/p&gt;

&lt;h2 id=&quot;check-to-see-if-you-are-discovering-any-characters-at-all&quot;&gt;Check to see if you are discovering any characters at all&lt;/h2&gt;

&lt;p&gt;At this point, we turn from common and known problems to answering whether
we can debug something … not so well known.  This example tests whether
or not the serial port ever declares that a value has been read (i.e.,
sets rx_stb high for one cycle).&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	if ((counter[24])&amp;amp;&amp;amp;(!ck_uart))
	begin
		counter &amp;lt;= 0;
		found &amp;lt;= 1&#39;b0;
	end else if (!counter[24])
	begin
		if (rx_stb)
			found &amp;lt;= 1&#39;b1;
		counter &amp;lt;= counter + 1&#39;b1;
	end else
		counter[23:0] &amp;lt;= counter[23:0] + 1&#39;b1;

assign	o_led = (found)&amp;amp;&amp;amp;(counter[23]);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Usually, though, if you’ve passed the simulation test, you’ll never have this
problem.  Still, it can be useful to determine what’s going on.&lt;/p&gt;

&lt;p&gt;Did you notice that we kept the bottom 24 bits of this counter counting,
even after the 25th bit went high?  Or the fact that the LED was the AND
of the found light and the 24th counter bit?  In other words, if anything
was found, the light will blink.  If the UART line ever goes active, but
rx_stb never goes high during this time frame, then the LED will stay off.&lt;/p&gt;

&lt;h2 id=&quot;check-to-see-what-character-you-are-reading&quot;&gt;Check to see what character you are reading&lt;/h2&gt;

&lt;p&gt;If you know you are receiving a character, but don’t know what it is, then …
use the LED to find out!&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	if ((counter[24])&amp;amp;&amp;amp;(!ck_uart))
	begin
		counter &amp;lt;= 0;
	end else if (!counter[24])
	begin
		if (rx_stb)
			read_data &amp;lt;= rx_data;
		counter &amp;lt;= counter + 1&#39;b1;
	end else
		counter[23:0] &amp;lt;= counter[23:0] + 1&#39;b1;

// If you don&#39;t have 8 LED&#39;s, there&#39;s no reason why you can&#39;t do this one
// LED at a time ... it&#39;ll just take longer to do.
assign	o_led[7:0] = read_data;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Of course, this solution depends upon your being able to display eight data bits
on your LEDs at the same time.&lt;/p&gt;

&lt;h2 id=&quot;what-about-the-transmitter&quot;&gt;What about the transmitter?&lt;/h2&gt;

&lt;p&gt;While the examples shown above apply to the UART receiver, there’s no reason
why they cannot be turned around and made to work for the transmitter as well.
You’ll probably want to check the transmitter output in the reverse order,
though: first that it is getting something to send, then whether or not the
baud rate is set right, etc.&lt;/p&gt;

&lt;h2 id=&quot;possibilities-are-endless&quot;&gt;Possibilities are endless&lt;/h2&gt;

&lt;p&gt;The number of ways you can set an LED as you work through a problem like
this is endless.  There are just so many tests you can do.&lt;/p&gt;

&lt;p&gt;Even still, … this approach has two problems:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;An LED can only give you one bit of information over the course of a 
  quarter second or so … at best!  If you need more complete information
  about what is going on within your design, getting it out via this means
  will take a long time and may well turn into an exercise in frustration.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;LED’s can’t tell you what’s happening on a clock by clock basis.  While you
  might be able to build a serial port without knowing this information, on
  anything more complex this approach will become a challenge.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;So, stick around–how to use an FPGA to debug itself is the subject of this
blog.&lt;/p&gt;
</description>
        <pubDate>Wed, 24 May 2017 00:00:00 -0400</pubDate>
        <link>http://zipcpu.com/blog/2017/05/24/serial-port.html</link>
        <guid isPermaLink="true">http://zipcpu.com/blog/2017/05/24/serial-port.html</guid>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>Building a simple bus</title>
        <description>&lt;p&gt;Busses consist of both bus masters, and bus slaves.  Masters command which
addresses need to be read from or written to, while slaves respond to the
requests of the bus master(s).  For this article, we’ll discuss the logic
necessary to implement a very simple bus slave.  Why?  Because at the core of
every memory mapped peripheral is just a touch of simple bus logic.&lt;/p&gt;

&lt;p&gt;To understand this concept, let’s consider a very simple bus.  Three things
can only ever happen on this bus on any given clock cycle.  1) The vast majority
of the time, the bus will be idle.  2) You might write to the bus.  Or 3),
you might read from the bus.  On a simple bus, this type of interaction can
easily be understood with just a few simple wires:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;i_wr&lt;/strong&gt;: True any time a write is requested.  If true for two clocks in a row, then two writes should take place in a row.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;i_rd&lt;/strong&gt;: True any time a read is requested&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;i_addr&lt;/strong&gt;: The address of the value to read/write&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;i_data&lt;/strong&gt;: The data to be written on any write access&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;o_data&lt;/strong&gt;: The data to be returned on any read access&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;a-simple-write-cycle&quot;&gt;A Simple Write Cycle&lt;/h1&gt;

&lt;p&gt;Using these values, writing to a memory might be as simple as:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	if (i_wr)
		memory[i_addr] &amp;lt;= i_data;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Writing to an arbitrary peripheral has much the same logic, but what it does
is a little bit different:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	if (i_wr) case(i_addr)
	4&#39;h0: config &amp;lt;= i_data;
	4&#39;h1: begin end // A read only address
	4&#39;h2: begin end // A read only address
	4&#39;h3: begin
		transmitter_data &amp;lt;= i_data;
		transmitter_stb  &amp;lt;= 1&#39;b1;
	default: begin end
	endcase else
		transmitter_stb &amp;lt;= 1&#39;b0;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Specifically, writes to a peripheral specify some logic to be done for each
possible address you might write to.&lt;/p&gt;

&lt;p&gt;In this example, writing to address zero simply sets a configuration register.
Writes to
addresses one and two are ignored: these addresses reference read only
registers.  Finally, address three sets a strobe value indicating that
some action is to take place, together with the data necessary for that
action.&lt;/p&gt;

&lt;p&gt;Indeed, from this perspective, the write cycle is pretty simple.&lt;/p&gt;

&lt;h1 id=&quot;a-simple-read-cycle&quot;&gt;A Simple Read Cycle&lt;/h1&gt;

&lt;p&gt;The read cycle isn’t really that much more complicated either.  For a simple
memory, it would look like:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	o_data &amp;lt;= memory[i_addr];&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Within a more generic peripheral, where reads might have side-effects, the
read logic might look instead like:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	case(i_addr)
	4&#39;h0: o_data &amp;lt;= config;
	4&#39;h1: begin o_data &amp;lt;= w_internal_values; advance_data_stb &amp;lt;= i_rd; end
	4&#39;h2: o_data &amp;lt;= w_other_internal_values;
	// 4&#39;h3: // A write only address
	defautl: o_data &amp;lt;= 0;
	endcase else
		advance_data_stb &amp;lt;= 1&#39;b0;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;You may notice that o_data gets set any time the address changes.
What if nothing is being read?  In this case, it’s not a problem.  The right
answer is being placed on the bus either way.  However, if you have an input
queue, such as in a read FIFO, you might wish to advance that queue on reads
only.  This is the idea behind the advance_data_stb logic above.&lt;/p&gt;

&lt;h2 id=&quot;shared-data-lines&quot;&gt;Shared data lines&lt;/h2&gt;

&lt;p&gt;Having separate input data lines, i_data, and output data lines, o_data,
makes a lot of sense within an FPGA.&lt;/p&gt;

&lt;p&gt;However, between components on a circuit board, cost may be measured in both
area and the number of wires routed from one place to another.&lt;/p&gt;

&lt;p&gt;For this reason, when communicating over an external bus, the simple bus we
have been describing has one more step:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;assign io_data (i_rd) ? 32&#39;bzzzz_..._zzzz : o_data;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This last step determines which of multiple digital pieces of logic drives
the bus.&lt;/p&gt;

&lt;h2 id=&quot;thats-it&quot;&gt;That’s it!&lt;/h2&gt;

&lt;p&gt;That’s all there is to working with a bus.  You need to read the address,
check if you are being read or written to, and return a value and act
appropriately.  At some level, every bus acts in this fashion.  Hence,
if you can understand how to interact with a bus like this, you’ve gone
through the first step of ever interacting with any bus.&lt;/p&gt;
</description>
        <pubDate>Tue, 23 May 2017 00:00:00 -0400</pubDate>
        <link>http://zipcpu.com/zipcpu/2017/05/23/simplebus.html</link>
        <guid isPermaLink="true">http://zipcpu.com/zipcpu/2017/05/23/simplebus.html</guid>
        
        
        <category>zipcpu</category>
        
      </item>
    
      <item>
        <title>Moving to memory</title>
        <description>&lt;p&gt;There seems to be a difficult transition between the beginning FPGA
designer, and the more experienced designer.  From the posts I’ve watched
and replied to, this transition appears to be centered around accessing
memory.&lt;/p&gt;

&lt;h2 id=&quot;before-memory&quot;&gt;Before Memory&lt;/h2&gt;

&lt;p&gt;Usually, a beginner’s FPGA work consists of very simple tasks: building a serial
port, controlling LED’s, &lt;a href=&quot;/blog/2017/05/19/blinky.html&quot;&gt;making things blink&lt;/a&gt;,
and so on.  These tasks can seem fairly simple, and they can usually be solved
with only some simple Verilog.&lt;/p&gt;

&lt;p&gt;Once the beginner has successfully completed these tasks, they then try to 
move on to something real.  For example, maybe they want to record some video,
capture images from a camera, or even to transmit a song over a
&lt;a href=&quot;https://github.com/ZipCPU/wbfmtx&quot;&gt;FM radio peripheral&lt;/a&gt;.
Every one of these tasks, though, requires memory.  These beginners quickly
discover that … there’s just not that much block RAM within an FPGA.&lt;/p&gt;

&lt;p&gt;What these beginners want is to continue their learning process just like
they’ve done it up to that time.&lt;/p&gt;

&lt;p&gt;This is where they get stuck.&lt;/p&gt;

&lt;h2 id=&quot;why-is-memory-different&quot;&gt;Why is memory different&lt;/h2&gt;

&lt;p&gt;Up until this point, when building for an FPGA, they can access as many memories
as they want within their FPGA.  When they need a memory, the just connect it
to their circuit.&lt;/p&gt;

&lt;p&gt;Now, when they need a big memory from an external circuit, … there’s only
one memory pipe.  Anything that needs to access that memory, needs access to
the one and only memory pipe’s controls.   The controls look much like any
bus:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Given an address and a read strobe, return the value at that address.&lt;/li&gt;
  &lt;li&gt;Given an address, a data value, and a write strobe, replace the contents at
that address with the new data value.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;For this, you need a bus.&lt;/p&gt;

&lt;p&gt;Many different bus standards exist.  There’s the
&lt;a href=&quot;http://opencores.org/opencores,wishbone&quot;&gt;Wishbone&lt;/a&gt;, the
&lt;a href=&quot;http://opencores.org/cdn/downloads/wbspec_b4.pdf&quot;&gt;B4 version of the Wishbone&lt;/a&gt;
that I like and use, there’s the
&lt;a href=&quot;http://opencores.org/cdn/downloads/wbspec_b3.pdf&quot;&gt;B3 version&lt;/a&gt;
used by the &lt;a href=&quot;https://openrisc.io&quot;&gt;OpenRISC&lt;/a&gt; team,
there’s the &lt;a href=&quot;http://www.gstitt.ece.ufl.edu/courses/fall15/eel4720_5721/labs/refs/AXI4_specification.pdf&quot;&gt;AXI bus&lt;/a&gt;
used by &lt;a href=&quot;https://www.xilinx.com&quot;&gt;Xilinx&lt;/a&gt; and ARM, etc.&lt;/p&gt;

&lt;p&gt;By itself, using the &lt;a href=&quot;http://opencores.org/opencores,wishbone&quot;&gt;wishbone bus&lt;/a&gt;
is pretty easy.
&lt;a href=&quot;http://www.gstitt.ece.ufl.edu/courses/fall15/eel4720_5721/labs/refs/AXI4_specification.pdf&quot;&gt;AXI&lt;/a&gt;
is harder, but once you understand how a bus works its not that much harder.
We’ll come back to that later with some easy examples of how to use one.&lt;/p&gt;

&lt;h2 id=&quot;beginners-should-get-used-to-busses&quot;&gt;Beginners should get used to busses&lt;/h2&gt;

&lt;p&gt;Before trying to read from memory or building a memory controller, a beginner
should learn how to read and write from a bus.  Lots of simple things with
busses are really appropriate beginner tasks.&lt;/p&gt;

&lt;p&gt;For example, a very simple piece of bus logic is a bus arbiter. 
Since only
one piece of logic can access the memory at any given time, if you want
two pieces of logic to be able to access memory, you need a bus arbiter.
(See &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/aux/wbarbiter.v&quot;&gt;here&lt;/a&gt;
for a wishbone example.)&lt;/p&gt;

&lt;p&gt;A classic example of this would be a project that reads from a camera port and
writes the result to memory.  If you ever want to get that image out of memory,
you will need an arbiter controlling which logic has access to the bus.&lt;/p&gt;

&lt;p&gt;As another example, if you are going to build a bus, why not put some &lt;a href=&quot;https://github.com/ZipCPU/wbscope&quot;&gt;
debug logic&lt;/a&gt; on that bus?  It’ll make
getting your memory interface up and running later a whole lot easier.&lt;/p&gt;

&lt;p&gt;The simplest bus to get used to is one where every item on the bus has exactly
the same timing.  A simple debug port might be like this.&lt;/p&gt;

&lt;p&gt;A harder bus is one where requests must be held on the bus until the respective
peripheral is ready to read them.
(&lt;a href=&quot;http://opencores.org/cdn/downloads/wbspec_b3.pdf&quot;&gt;WB B3/Classic&lt;/a&gt;)&lt;/p&gt;

&lt;p&gt;Harder still, one where many requests may be made before the first result comes
back, some variable number of clocks later.
(&lt;a href=&quot;http://opencores.org/cdn/downloads/wbspec_b4.pdf&quot;&gt;WB B4/Pipeline&lt;/a&gt;)&lt;/p&gt;

&lt;p&gt;The &lt;a href=&quot;http://www.gstitt.ece.ufl.edu/courses/fall15/eel4720_5721/labs/refs/AXI4_specification.pdf&quot;&gt;AXI&lt;/a&gt;
bus, though, usually takes the cake for complexity.  This bus has separate
channels for read requests, write requests, write data, read data, and the write
request acknowledgement.  Each of these channels has bi-directional flow control
so that requests may have to wait for the peripheral to be ready.  Worse,
this bus may respond out of order to various requests.  Ouch!&lt;/p&gt;

&lt;h2 id=&quot;actual-memory-controllers-are-complicated&quot;&gt;Actual memory controllers are complicated&lt;/h2&gt;

&lt;p&gt;Finally, once you are comfortable using a bus, only then is it time to connect
it to a memory controller.&lt;/p&gt;

&lt;p&gt;This is also where the beginner punts and looks for a prewritten memory
controller—usually because he has never learned how to deal with a bus,
or he’s read the memory controller spec sheet and … decided it wasn’t worth
his while.&lt;/p&gt;

&lt;p&gt;These beginners will also tend to switch to the
&lt;a href=&quot;http://www.gstitt.ece.ufl.edu/courses/fall15/eel4720_5721/labs/refs/AXI4_specification.pdf&quot;&gt;AXI&lt;/a&gt;
bus, not because they know
how to use it, neither because it’s the best bus out there, but because
&lt;a href=&quot;https://www.xilinx.com&quot;&gt;Xilinx&lt;/a&gt; has provided them with a memory controller
for their memory chip that uses the
&lt;a href=&quot;http://www.gstitt.ece.ufl.edu/courses/fall15/eel4720_5721/labs/refs/AXI4_specification.pdf&quot;&gt;AXI&lt;/a&gt;
bus.&lt;/p&gt;

&lt;p&gt;This is usually also the time in their development where they abandon the
Verilog or VHDL code they’ve been working with in favor of one of the visual
and graphical tool flows.&lt;/p&gt;

&lt;p&gt;This leads to a bigger problem down the road: they’re stuck using the Xilinx
IP because 1) building
&lt;a href=&quot;https://github.com/ZipCPU/wbscope/blob/master/rtl/axi4lscope.v&quot;&gt;something&lt;/a&gt; that
interacts on an
&lt;a href=&quot;http://www.gstitt.ece.ufl.edu/courses/fall15/eel4720_5721/labs/refs/AXI4_specification.pdf&quot;&gt;AXI&lt;/a&gt;
bus isn’t simple, and
2) because it’s difficult to integrate their special sauce into the official
IP integrator.  Indeed, the problem is so complicated that 
&lt;a href=&quot;http://www.gstitt.ece.ufl.edu/courses/fall15/eel4720_5721/labs/refs/AXI4_specification.pdf&quot;&gt;AXI&lt;/a&gt;
has to offer a special subset of the AXI bus specification, AXI-lite, just to
try to make this easier.&lt;/p&gt;

&lt;h2 id=&quot;stick-around-and-ill-show-another-way&quot;&gt;Stick around, and I’ll show another way&lt;/h2&gt;

&lt;p&gt;Having now written several memory controllers, I understand they can be
difficult.  They are also, however, quite possible to build.  The beginner
who abandons their learning process for a set of ready-set of tools, however,
will quickly loose the fortitude they need to get there.&lt;/p&gt;

&lt;p&gt;If you stick around on this blog, I intend to show you another way.&lt;/p&gt;
</description>
        <pubDate>Mon, 22 May 2017 00:00:00 -0400</pubDate>
        <link>http://zipcpu.com/digilent/2017/05/22/moving-to-memory.html</link>
        <guid isPermaLink="true">http://zipcpu.com/digilent/2017/05/22/moving-to-memory.html</guid>
        
        
        <category>digilent</category>
        
      </item>
    
      <item>
        <title>A Vision for Controlling FPGA Logic</title>
        <description>&lt;p&gt;I’d like to spend some time on this forum discussing how to debug an FPGA.
Indeed, I might wish to spend a lot of time discussing how to debug an FPGA.
I’ve done it several ways, but for this post I’d like to discuss a vision
for how I like to debug FPGA’s.&lt;/p&gt;

&lt;h3 id=&quot;memory-mapped-io&quot;&gt;Memory Mapped I/O&lt;/h3&gt;

&lt;p&gt;We’ll start with the concept of
&lt;a href=&quot;https://en.wikipedia.org/wiki/Memory-mapped_I/O&quot;&gt;Memory Mapped I/O&lt;/a&gt;.
The idea is simply this: peripherals can be connected to a bus, together with
whatever memory is on that bus, so that they can be accessed like memory.
Like memory, the peripheral will have an address.  Like memory, the bus
controller, whether it be a CPU or &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/wbdmac.v&quot;&gt;DMA
peripheral&lt;/a&gt;,
can write to the peripheral
and read from it.  Unlike memory, however, reading or writing to a peripheral
can have side effects.&lt;/p&gt;

&lt;p&gt;We’ll use the term “register” to describe a single address within a peripheral.&lt;/p&gt;

&lt;p&gt;Register’s can be read only, write only, or read/write.  Further, peripherals
may have many addresses.  Finally, peripherals may take different amounts of
time to access.  For example, a
&lt;a href=&quot;https://github.com/ZipCPU/xulalx25soc/blob/master/rtl/memdev.v&quot;&gt;block RAM&lt;/a&gt;
peripheral can typically be accessed in a single cycle, whereas an
&lt;a href=&quot;https://github.com/ZipCPU/xulalx25soc/blob/master/rtl/wbsdram.v&quot;&gt;SDRAM&lt;/a&gt;
peripheral may take longer, and a
&lt;a href=&quot;https://github.com/ZipCPU/xulalx25soc/blob/master/rtl/wbspiflash.v&quot;&gt;flash&lt;/a&gt;
peripheral may take much longer.&lt;/p&gt;

&lt;p&gt;Perhaps a perfect example of this concept is that of a serial port, such as
the &lt;a href=&quot;https://github.com/ZipCPU/wbuart32&quot;&gt;wbuart32&lt;/a&gt; serial port the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt; uses.  Reading from the receiver
address of this serial port returns the next character from the receiver
queue, advancing the queue to the next character.  Writing to the transmit
register queue’s a character for sending over the port.  A third register
controls the speed and configuration of the port, whereas a fourth register
is used when the serial port has a queue to indicate how much of the queue
is used.&lt;/p&gt;

&lt;p&gt;But how does this apply to controlling an FPGA?  Simple!  We’ll implement
our logic as peripherals on an FPGA bus, and then control those peripherals
by simply reading from or writing to that bus.  By having a common standard
for accessing peripherals, we only have to build our peripherals to meet that
standard once.&lt;/p&gt;

&lt;h3 id=&quot;pcie-card&quot;&gt;PCIe card&lt;/h3&gt;

&lt;p&gt;Perhaps the vision I’m about to share will make more sense if I explain that
I first came up with it while trying to figure out how to control an
FPGA on a
&lt;a href=&quot;https://en.wikipedia.org/wiki/PCI_Express&quot;&gt;PCIe&lt;/a&gt;
card.  Indeed, I was trying to figure out how I would control
a &lt;a href=&quot;https://www.xilinx.com/products/boards-and-kits/ek-v7-vc707-g.html&quot;&gt;VC707&lt;/a&gt;
card made by &lt;a href=&quot;https://www.xilinx.com/&quot;&gt;Xilinx&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The &lt;a href=&quot;https://en.wikipedia.org/wiki/PCI_Express&quot;&gt;PCIe&lt;/a&gt;
bus allows for several different areas or sections of address space
which get assigned to each card.  These can include both memory address space,
and peripheral address space, but every thing is still accessed on a bus.
You can read from any given addresses on that bus, or write to a given
addresses, as with any other bus.&lt;/p&gt;

&lt;p&gt;Since I wanted to build an FPGA capability that could eventually be used on
an FPGA over a &lt;a href=&quot;https://en.wikipedia.org/wiki/PCI_Express&quot;&gt;PCIe&lt;/a&gt;
interface, I wanted to create something that would work on a
&lt;a href=&quot;https://en.wikipedia.org/wiki/PCI_Express&quot;&gt;PCIe&lt;/a&gt;
bus eventually, but that could be used over some other transport
prior to that point.  Further, when plugging the FPGA into the
&lt;a href=&quot;https://en.wikipedia.org/wiki/PCI_Express&quot;&gt;PCIe&lt;/a&gt; bus, I already knew that
I would need to use some sort of alternative transport in order to debug
whatever was going on.&lt;/p&gt;

&lt;p&gt;So, here was my vision: I would use the serial port on the
&lt;a href=&quot;https://www.xilinx.com/products/boards-and-kits/ek-v7-vc707-g.html&quot;&gt;VC707&lt;/a&gt;
to command the
&lt;a href=&quot;https://www.xilinx.com/products/boards-and-kits/ek-v7-vc707-g.html&quot;&gt;VC707&lt;/a&gt;
as though it were connected via
&lt;a href=&quot;https://en.wikipedia.org/wiki/PCI_Express&quot;&gt;PCIe&lt;/a&gt;.  Then, over this same
serial port, I could get the debugging information I needed to know if the
&lt;a href=&quot;https://en.wikipedia.org/wiki/PCI_Express&quot;&gt;PCIe&lt;/a&gt; bus were working, or
if not … why not?&lt;/p&gt;

&lt;h3 id=&quot;required-interactions&quot;&gt;Required Interactions&lt;/h3&gt;

&lt;p&gt;If you are going to create a memory mapped bus, that you are then going to
work with, you need to know what operations you want to do on this bus.
I captured the interface for, what I called a device bus, in a C++ header file,
&lt;a href=&quot;https://github.com/ZipCPU/openarty/blob/master/sw/host/devbus.cpp&quot;&gt;devbus.h&lt;/a&gt;.
Operations on this interface include:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;readio()&lt;/strong&gt;:  Reads a 32-bit value from any individual register&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;readz()&lt;/strong&gt;: Reading multiple 32-bit values from the same register.  While
most memories have one address per memory location, peripherals aren’t
necessarily like that.  This mode captures some of that difference.  Some
examples where this would be useful include reading from a FIFO, such as the
serial port input FIFO, and reading from my debugging scope, where
multiple reads from the data register read subsequent values from the scope’s
memory.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;readi()&lt;/strong&gt;: Reading a series of 32-bit values from consecutive registers.
This is akin to a memcpy command, where one end is coming from the device.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The same operations are then mirrored for writing to registers.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;This &lt;a href=&quot;https://github.com/ZipCPU/openarty/blob/master/sw/host/devbus.cpp&quot;&gt;bus interface&lt;/a&gt;
also allows for some minimal interrupt capability.  For example, you
can &lt;strong&gt;wait()&lt;/strong&gt; for an interrupt to be created within the device, or &lt;strong&gt;poll()&lt;/strong&gt;
to see if an interrupt has taken place.  How these interactions take place is
… up to whatever transport implements the interface.&lt;/p&gt;

&lt;p&gt;Back when I started working on computers decades ago, you could
&lt;a href=&quot;https://en.wikipedia.org/wiki/PEEK_and_POKE&quot;&gt;Peek or Poke&lt;/a&gt; an addresses within
your &lt;a href=&quot;https://en.wikipedia.org/wiki/Apple_IIe&quot;&gt;Apple IIe&lt;/a&gt; computer, and so
control the hardware.  While I thought of repeating this approach with FPGA’s,
I also like the thought of being able to name the peripheral register, rather
than trying to remembering &lt;a href=&quot;http://apple2.org.za/gswv/USA2WUG/FOUNDING.MEMBERS/HOME.PAGES/EDHEL/texts/pokes.html&quot;&gt;all the register numbers&lt;/a&gt; (OUCH!).
This would allow an FPGA to be reconfigured so the addresses might be moved
around, and yet you could still read and write the same peripherals via the
same names.  I like this idea so much,
that all of my projects have a
&lt;a href=&quot;https://github.com/ZipCPU/openarty/blob/master/sw/host/wbregs.cpp&quot;&gt;wbregs&lt;/a&gt;
program within them to control peripherals over some command line.&lt;/p&gt;

&lt;h3 id=&quot;tcpip-bridge&quot;&gt;TCP/IP bridge&lt;/h3&gt;

&lt;p&gt;Rather than getting into details regarding how such an interface might be built
(yet),
I’d like to add one more component to the vision: I want to be able to control
my FPGA devices from anywhere on my local network.  If I’m working on my
laptop, I’d like to be able to control them from my laptop.  If I’m working on
my desktop, I’d like to be able to control them from my desktop.  If I have the
device located next to an antenna in the attic, I still want to be able to
control it.&lt;/p&gt;

&lt;p&gt;For this purpose, I like to forward all of my transport connections over a
TCP/IP link.  While this would probably never be appropriate for an FPGA
with a PCIe connection, it has worked for all of my FPGA’s with slower
transport connections.&lt;/p&gt;

&lt;p&gt;Lest you be confused, this is different from having an FPGA with an Ethernet
port that can be accessed from your network.  We want to use our network
interface to command, control, and debug our FPGA before the network controller
connected to the FPGA works.&lt;/p&gt;

&lt;h3 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h3&gt;

&lt;p&gt;This vision for FPGA control leads nicely into a vision for building and
debugging an FPGA.  We’ll get more into that idea as this blog progresses,
but for now … we’ll just use this idea to keep things simple.&lt;/p&gt;
</description>
        <pubDate>Mon, 22 May 2017 00:00:00 -0400</pubDate>
        <link>http://zipcpu.com/blog/2017/05/22/a-vision-for-controlling-fpgas.html</link>
        <guid isPermaLink="true">http://zipcpu.com/blog/2017/05/22/a-vision-for-controlling-fpgas.html</guid>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>Which comes first: the CPU or the peripherals?</title>
        <description>&lt;p&gt;When working on the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;, the peripherals
came first.  &lt;em&gt;Only&lt;/em&gt; when the peripherals were known to work did I transition to
building the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Does the order matter?  I think it does.  Someone else tried to build a CPU
first before building all of his peripherals–in this case, the memory
peripheral was the problem.
The result
&lt;a href=&quot;https://forum.digilentinc.com/topic/3298-psram-chip-baked-or-am-i-just-high/&quot;&gt;wasn’t pretty&lt;/a&gt;.
While it hasn’t quite killed his project, he did run out of his startup dollars and had to put the project on the backburner.&lt;/p&gt;

&lt;p&gt;If you want to build a CPU, I recommend building in this order:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Build the debugging scaffolding.  The first thing you will need is an
interface to your FPGA that you can rely upon, one that will also allow you
to test the peripheral components found within your FPGA.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Using your scaffolding, build some peripherals.  Test them.  Get to know
them.  Get familiar with them.  Understand how many clocks they will take to
respond to a request.  Understand how to aggregate those peripherals
together so you can debug them all.&lt;/p&gt;

    &lt;p&gt;I personally hang all of my peripherals off of a
&lt;a href=&quot;http://opencores.org/opencores,wishbone&quot;&gt;Wishbone&lt;/a&gt;
&lt;a href=&quot;https://opencores.org/cdn/downloads/wbspec_b4.pdf&quot;&gt;B4 bus&lt;/a&gt;,
although other busses exist which can be used for this purpose.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Only once you know that your scaffolding and peripherals work, should you
then start on trying to place your CPU within your FPGA.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Of course, this is all my own personal and humble opinions.  On the other hand,
the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt; already runs on several platforms.&lt;/p&gt;
</description>
        <pubDate>Sat, 20 May 2017 00:00:00 -0400</pubDate>
        <link>http://zipcpu.com/zipcpu/2017/05/20/which-came-first.html</link>
        <guid isPermaLink="true">http://zipcpu.com/zipcpu/2017/05/20/which-came-first.html</guid>
        
        
        <category>zipcpu</category>
        
      </item>
    
      <item>
        <title>Knight Rider</title>
        <description>&lt;p&gt;When I was a kid, I loved watching Knight Rider.  Once I picked up FPGA design,
I wanted to know how to make LED’s move and dim … just like 
&lt;a href=&quot;https://www.youtube.com/watch?v=WxE2xWZNfOc&quot;&gt;KITT’s lights&lt;/a&gt; did.&lt;/p&gt;

&lt;p&gt;If you are a beginner FPGA designer, this makes the perfect beginners project.&lt;/p&gt;

&lt;h2 id=&quot;walking-through-the-leds&quot;&gt;Walking through the LEDs&lt;/h2&gt;

&lt;p&gt;The first step requires simply walking through the LEDs.  This is a very
important step, as it demonstrates that all of your LEDs are properly set
up, properly connected, and that they will turn on when requested.&lt;/p&gt;

&lt;p&gt;In our case, we’ll do this two different ways.  First, we’ll step the LED’s
once each second.  This way, there can be no question that the LED comes on
at the proper time.  Once that works, we can speed the process up, and make
a cool LED demo.&lt;/p&gt;

&lt;p&gt;To step through the LED’s one at a time, you can use the following code:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;`default_nettype none
`define	FASTWALKER
//
module	ledwalker(i_clk, o_led);
	input	wire		i_clk;
	output	reg	[7:0]	o_led;

	// Remember the clock testing code?  This is very similar, only it
	// creates a PPS signal once per second--every time the counter rolls
	// over.  You could create this signal ever half second, or every
	// quarter second, by just dropping the number of bits in the counter.
	reg	pps;
	reg	[31:0]	time_counter;
	always @(posedge i_clk)
		{ pps, time_counter } &amp;lt;= time_counter + 32&#39;d43;

	//
	// We then want to keep track of our state: which LED will be on
	//
	reg	[2:0]	led_posn;
	always @(posedge i_clk)
		if (pps)
			led_posn &amp;lt;= led_posn + 1&#39;b1;

	//
	// Now, we turn on the one LED on corresponding to the state we have
	// chosen.
	//
	always @(posedge i_clk)
	begin
		o_led[0] &amp;lt;= (led_posn == 3&#39;h0);
		o_led[1] &amp;lt;= (led_posn == 3&#39;h1);
		o_led[2] &amp;lt;= (led_posn == 3&#39;h2);
		o_led[3] &amp;lt;= (led_posn == 3&#39;h3);
		o_led[4] &amp;lt;= (led_posn == 3&#39;h4);
		o_led[5] &amp;lt;= (led_posn == 3&#39;h5);
		o_led[6] &amp;lt;= (led_posn == 3&#39;h6);
		o_led[7] &amp;lt;= (led_posn == 3&#39;h7);
	end

endmodule&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;If you don’t want to type this in, you can find my version of this example
&lt;a href=&quot;https://github.com/ZipCPU/icozip/blob/master/rtl/pmodleds/ledwalker.v&quot;&gt;here&lt;/a&gt;.
You’ll need an &lt;a href=&quot;http://icoboard.org&quot;&gt;ICO board&lt;/a&gt; and a &lt;a href=&quot;https://store.digilentinc.com/pmod-8ld-eight-high-brightness-leds/&quot;&gt;PMod
LED8&lt;/a&gt;
from &lt;a href=&quot;http://store.digilentinc.com&quot;&gt;Digilent&lt;/a&gt; to
run it, although it’s almost generic enough to run on any FPGA board.  If you
don’t have that many LED’s?  Either don’t turn them all on, or adjust led_posn
to only cycle through the LED’s that you do have.&lt;/p&gt;

&lt;p&gt;With a little work, I’m sure you could modify this example, so that the LED
that was ON walked from left to right, and then back from right to left.&lt;/p&gt;

&lt;h2 id=&quot;dimming-the-led&quot;&gt;Dimming the LED&lt;/h2&gt;

&lt;p&gt;The next thing you need to know, once you can turn each LED on individually,
is that you can “dim” an LED by turning it on
and off faster than an eye can see.  As you transition the LED from being more
often on to more often off, the LED will appear to dim.  As an example, try the
following:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;//
`default_nettype none
//
module dimmer(i_clk, o_led);
  input  wire i_clk;
  output wire o_led;

reg [26:0] counter;
always @(posedge i_clk)
  counter &amp;lt;= counter + 1&#39;b1;

always @(posedge i_clk)
  o_led &amp;lt;= (counter[3:0] &amp;lt; counter[26:23]);

endmodule&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;If you don’t want to type this in, you can find my version of this
&lt;a href=&quot;https://github.com/ZipCPU/icozip/blob/master/rtl/basic/dimmer.v&quot;&gt;here&lt;/a&gt;,
written for the ICO Board.&lt;/p&gt;

&lt;h2 id=&quot;the-final-design&quot;&gt;The final design&lt;/h2&gt;

&lt;p&gt;You really don’t want me to give you the answer, now, do you?  Without giving
you a chance to do it yourself?  Try doing it yourself first.  Then, if you get
stuck or once you’ve achieved your goal, feel free to look at my solution
&lt;a href=&quot;https://github.com/ZipCPU/icozip/blob/master/rtl/pmodleds/ledbouncer.v&quot;&gt;here&lt;/a&gt;.
It’s a little more advanced than the ones above, in that it uses generic’s and
for loops within Verilog, but the concept remains the same.&lt;/p&gt;

&lt;p&gt;One problem I had using the “High-brightness” LED’s on the 
&lt;a href=&quot;https://store.digilentinc.com/pmod-8ld-eight-high-brightness-leds/&quot;&gt;PMod LED8&lt;/a&gt;,
was that it’s hard to see them actually “dim”.  As a result, the Knight
Rider effect is more substantial
on another board, such as the &lt;a href=&quot;https://store.digilentinc.com/nexys-video-artix-7-fpga-trainer-board-for-multimedia-applications&quot;&gt;Nexys Video&lt;/a&gt; or the &lt;a href=&quot;https://store.digilentinc.com/basys-3-artix-7-fpga-trainer-board-recommended-for-introductory-users/&quot;&gt;Basys-3&lt;/a&gt; from &lt;a href=&quot;https://store.digilentinc.com&quot;&gt;Digilent&lt;/a&gt;,
since these use red LED’s that aren’t nearly as bright.&lt;/p&gt;

</description>
        <pubDate>Sat, 20 May 2017 00:00:00 -0400</pubDate>
        <link>http://zipcpu.com/blog/2017/05/20/knight-rider.html</link>
        <guid isPermaLink="true">http://zipcpu.com/blog/2017/05/20/knight-rider.html</guid>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>FPGA Hell</title>
        <description>&lt;p&gt;The worst place to be in digital design is where you load the design onto your
device, it doesn’t work, and you don’t know why.&lt;/p&gt;

&lt;p&gt;I call this: &lt;em&gt;FPGA Hell&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;If you find yourself deskcheck your code and not knowing what to look for, you
may be in FPGA Hell.  Weeks and months can spent in there, and you will make no
progress towards your goal while you are there.&lt;/p&gt;

&lt;p&gt;Time is money.  FPGA Hell will cost you dearly.  Avoid FPGA Hell at &lt;em&gt;all&lt;/em&gt; cost.&lt;/p&gt;

&lt;h2 id=&quot;the-solution&quot;&gt;The solution&lt;/h2&gt;

&lt;p&gt;The solution to FPGA Hell is twofold.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;First, simulate everything.  If you don’t have a simulation to describe
the hardware you are working with, make one.&lt;/p&gt;

    &lt;p&gt;As an example, &lt;a href=&quot;https://github.com/ZipCPU/wbuart32/blob/master/bench/cpp/uartsim.cpp&quot;&gt;here is&lt;/a&gt; a simulation of a UART port.  It turns a UART port into either your
standard input and output FILE streams, or into a TCP/IP port that you can
stream your data in and out of.  I built the simulation from an &lt;a href=&quot;https://en.wikipedia.org/wiki/Universal_asynchronous_receiver/transmitter&quot;&gt;online
description&lt;/a&gt; of how a UART works.  I then use the simulation to debug any Verilog
code someone posts to &lt;a href=&quot;http://forum.digilentinc.com&quot;&gt;Digilent’s forums&lt;/a&gt;, but
now that you know my secrets, you can do it too.&lt;/p&gt;

    &lt;p&gt;The problem with this first step is: what happens if your understanding of
the device you just built a simulator doesn’t match reality?  For that, you
need a scope.  Specifically, you need to measure reality and learn what’s
actually happening, and then you need to adjust your simulation to match
reality.  This leads us to the second part of the solution: using a scope.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Use a scope.  Measure what’s really going on.  Watch your code interact with
the real hardware, and use what you learn to find where reality and your
simulation disconnect.&lt;/p&gt;

    &lt;p&gt;A good example of this is my first attempt to build an &lt;a href=&quot;https://github.com/ZipCPU/wbi2c&quot;&gt;I2C
controller&lt;/a&gt;.  For that project, I built
two controllers, &lt;a href=&quot;https://github.com/ZipCPU/wbi2c/blob/master/rtl/wbi2cslave.v&quot;&gt;one a
slave&lt;/a&gt; and &lt;a href=&quot;https://github.com/ZipCPU/wbi2c/blob/master/rtl/wbi2cmaster.v&quot;&gt;the
other a
master&lt;/a&gt;.
I then built simulations for both &lt;a href=&quot;https://github.com/ZipCPU/wbi2c/blob/master/bench/cpp/wbi2cs_tb.cpp&quot;&gt;the
slave&lt;/a&gt;
and &lt;a href=&quot;https://github.com/ZipCPU/wbi2c/blob/master/bench/cpp/wbi2cm_tb.cpp&quot;&gt;the
master&lt;/a&gt;,
and then worked with the simulations until my code worked.  Once my code
worked, I placed it onto the device and … my code didn’t work.&lt;/p&gt;

    &lt;p&gt;To get past the problem, I placed a
&lt;a href=&quot;https://github.com/ZipCPU/wbscope/blob/master/rtl/wbscopc.v&quot;&gt;scope&lt;/a&gt; into my
design, allowing me to “see” what was going on.  What I learned was that the
hardware I was talking to (my monitor) wasn’t doing what I thought it should.
I then had to find &lt;a href=&quot;https://www.i2c-bus.org/specification&quot;&gt;a better
description&lt;/a&gt; of how an I2C port
works, rebuild my simulation, get the simulation working again, and then
test on the hardware.&lt;/p&gt;

    &lt;p&gt;You can find a discussion of the result, together with pictures of what I was
looking at,
&lt;a href=&quot;https://github.com/ZipCPU/wbscope/tree/master/doc/examples/hdmi-eddc&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;If you cannot use a scope, modify &lt;a href=&quot;/blog/2017/05/19/blinky.html&quot;&gt;blinky&lt;/a&gt; to get the
information you need.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Hopefully this helps you avoid FPGA Hell.  If not, watch this space.  I intend
to write more articles here about how to debug an FPGA design.&lt;/p&gt;
</description>
        <pubDate>Fri, 19 May 2017 00:00:00 -0400</pubDate>
        <link>http://zipcpu.com/blog/2017/05/19/fpga-hell.html</link>
        <guid isPermaLink="true">http://zipcpu.com/blog/2017/05/19/fpga-hell.html</guid>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>Blinky</title>
        <description>&lt;p&gt;In C, the first program a person writes is often known  as a
&lt;a href=&quot;https://en.wikipedia.org/wiki/&amp;quot;Hello,_World!&amp;quot;_program&quot;&gt;“Hello, World!”&lt;/a&gt;
program.  It does nothing but print “Hello, World!” to the screen and exit.
While this is a wonderful first program for the C programmer, it is wholly
inappropriate for either the FPGA programmer or the embedded programmer.&lt;/p&gt;

&lt;p&gt;The FPGA or embedded programmer must work to get the serial port or the
C-library working, if he has either.  Instead, he has a simple LED to work with.
Hence the first program, &lt;a href=&quot;https://hackaday.io/project/7982-cat-board/log/37305-getting-to-blinky-cat-board-style&quot;&gt;blinky&lt;/a&gt;, simply blinks that LED.&lt;/p&gt;

&lt;h2 id=&quot;why-blinky&quot;&gt;Why blinky?&lt;/h2&gt;

&lt;p&gt;Blinky is a very important program: it proves that you can 1) program the
FPGA, that you 2) have a working clock, and that 3) you have a working LED.
These are very important steps in programming a new board.  Indeed, they are
so profound, I still run blinky as my first program on any FPGA board today.
Even after your first configuration, blinky is still important, because it can
tell you if the problem is your design versus the ability to load the board.&lt;/p&gt;

&lt;h2 id=&quot;what-is-blinky&quot;&gt;What is blinky?&lt;/h2&gt;

&lt;p&gt;Below is a very simple version of the blinky program, written in Verilog.
Remember, simple is better at this point.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;//
`default_nettype none
//
module blinky(i_clk, o_led);
  input wire i_clk;
  output wire o_led;

reg	[25:0]	counter;
always @(posedge i_clk)
  counter &amp;lt;= counter + 1&#39;b1;
assign o_led = counter[25];

endmodule&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;While there’s not much to the design, the “not much” that is there is important.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Notice that I mark my inputs with the prefix i_, and my outputs with the prefix o_.  You’ll find this consistent notation through all of my work.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Notice the default_nettype directive.  We’ll come back to it later.  For now, I highly recommend every Verilog design you build start with it.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Notice the counter.  Many beginners place an LED in their design without the counter, and then wonder why things don’t work.  An FPGA runs faster than your eye can see.  Without the counter, you wouldn’t be able to see this LED blink.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;I have 26 bits in my counter (25+1).  This is just about right for most of the projects I’ve worked on.  It divides the clock by 2^26, creating a clock rate at around one Hertz.  If you pick a number too low, you won’t see the LED blink.  If you pick a number too high, you’ll get bored waiting for the LED to blink while wondering if your FPGA works.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;a-better-blinky&quot;&gt;A better blinky&lt;/h2&gt;

&lt;p&gt;With no more than just a clock and an LED, can you figure out how fast your
clock is running?&lt;/p&gt;

&lt;p&gt;This was a challenge of mine when first firing up my
&lt;a href=&quot;http://icoboard.org&quot;&gt;icoboard&lt;/a&gt;.  The
&lt;a href=&quot;https://drive.google.com/file/d/0By-zY9AlHqXIcXZ6ZWdBR2dPXzg/view&quot;&gt;schematic&lt;/a&gt;
for that board initially identified the
clock as being at 25MHz, the examples identified it as being at 100MHz.  (The
team has since fixed the schematic, to properly reflect the 100MHz clock.)  How
should I tell which of the two was the right answer?&lt;/p&gt;

&lt;p&gt;Here was my solution:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;//
`default_nettype none
//
module clktest(i_clk, o_led);
  input wire i_clk;
  output wire o_led;

// We use a larger, 32-bit, counter here so as to get some better time
// precision.
reg	[31:0]	counter;
always @(posedge i_clk)
  counter &amp;lt;= counter + 32&#39;d43; // Valid if clk rate = 100MHz

// Blink the LED sharply at the top of each second, so that
// it remains on for a quarter of a second only before turning
// off
assign o_led = (counter[31:30] == 2&#39;b00);

endmodule&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Did you notice the 32’d43 value?  This value is set to 2^32 divided by the
clock rate.  Since the clock rate on this board is 100 MHz, 2^32 divided by
100 MHz is about 43.  Hence, if the counter starts at zero, then after
100 million clock ticks, the counter should equal 2^32 and roll over to zero
again.  In this case, though, since 2^32/100M isn’t exactly 43, our clock will
run about 5% too fast.  Still … it should be close enough that we can use a
stop watch to verify that we are in about the right clock range.&lt;/p&gt;

&lt;p&gt;If you are interested, this method of clock division is also used within the
&lt;a href=&quot;https://github.com/ZipCPU/rtcclock&quot;&gt;Real-Time Clock&lt;/a&gt; project used by the
ZipCPU.  The project, though, uses a 48-bit counter to get much better 
time accuracy–assuming that the oscillator is that good.&lt;/p&gt;

&lt;h2 id=&quot;using-blinky-for-debugging&quot;&gt;Using blinky for debugging&lt;/h2&gt;

&lt;p&gt;If you ever find yourself debugging with nothing but an LED, you can use the
LED for your debugging.  It’s not the best means of debugging: it can only
return one bit of information, and sometimes not even that, but it may be
the only means you have.&lt;/p&gt;

&lt;p&gt;The basic idea is to set the LED to on any time some condition takes place.
The trick is … you need to reset the LED so that you can see if that
condition takes place again later, and you need to make certain that the
condition (whatever it is) takes place so rarely that you can understand
what’s going on.&lt;/p&gt;

&lt;p&gt;Here’s an updated blinky, therefore, that can be used within a design to help
debug it:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;reg	[24:0]	counter;
always @(posedge i_clk)
  if (debug_event)
    // Reset the counter if our event ever takes place
    counter &amp;lt;= 0;
  else if (!counter[24])
    // Increment the counter, to hold the LED for a period of time
    // long enough for us to observe it ... before turning the LED
    // back off again
    counter &amp;lt;= counter + 1&#39;b1;

// Since the reset condition sets this high order bit low and holds
// it low for a period of time, and since the light &quot;on&quot; usually
// indicates the condition has taken place, negate the top bit of
// the counter so that the LED will turn _on_ any time your event
// takes place.
assign o_led = !counter[24];&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;As before, the choice of the length of the counter is important.&lt;/p&gt;

&lt;p&gt;This time, though, we’ve used “debug_event”, a variable coming from elsewhere
in the design, to check to see if something ever happens.  If this event ever
happens, the counter is set to zero, and the LED is turned on.  The counter
then holds the LED on for 2^24 clocks, before stopping and waiting for a new
event.&lt;/p&gt;

&lt;p&gt;While better approaches exist, most of those require more logic that needs to
be debugged first.  As a result, I’ve used this approach to debug my 
&lt;a href=&quot;https://github.com/ZipCPU/wbuart32/&quot;&gt;serial port controller&lt;/a&gt;, since most of my
debugging logic depends upon a working serial port.  I’ve also used this
approach to track how much time the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;
is spending in &lt;a href=&quot;https://github.com/ZipCPU/s6soc/blob/master/sw/zipos/kernel.c#L118&quot;&gt;interrupts&lt;/a&gt;, and if
and when the ZipCPU &lt;a href=&quot;https://github.com/ZipCPU/s6soc/blob/master/rtl/busmaster.v#L448&quot;&gt;has frozen&lt;/a&gt; in &lt;a href=&quot;https://github.com/ZipCPU/s6soc&quot;&gt;designs&lt;/a&gt; that are too tight
to fit a &lt;a href=&quot;https://github.com/ZipCPU/wbscope&quot;&gt;better debugging infrastructure&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;what-next&quot;&gt;What next?&lt;/h2&gt;

&lt;p&gt;Once you have blinky running, it’s time to move on to other tasks.  These tasks, though, will be easier because you have a clock and an LED that works.  Indeed, you can use blinky to your advantage as you struggle to get those newer tasks running.&lt;/p&gt;

</description>
        <pubDate>Fri, 19 May 2017 00:00:00 -0400</pubDate>
        <link>http://zipcpu.com/blog/2017/05/19/blinky.html</link>
        <guid isPermaLink="true">http://zipcpu.com/blog/2017/05/19/blinky.html</guid>
        
        
        <category>blog</category>
        
      </item>
    
  </channel>
</rss>
