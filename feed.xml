<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>The ZipCPU by Gisselquist Technology</title>
    <description>The ZipCPU blog, featuring how to discussions of FPGA and CPU design. This site will be focused on Verilog solutions, using exclusively OpenSource IP products for FPGA design.
</description>
    <link>http://zipcpu.com/</link>
    <atom:link href="http://zipcpu.com/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Fri, 04 Aug 2017 06:31:40 -0400</pubDate>
    <lastBuildDate>Fri, 04 Aug 2017 06:31:40 -0400</lastBuildDate>
    <generator>Jekyll v3.0.1</generator>
    
      <item>
        <title>How to eliminate button bounces with digital logic</title>
        <description>&lt;p&gt;The fundamental way to avoid &lt;a href=&quot;/fpga-hell.md&quot;&gt;FPGA Hell&lt;/a&gt; is
to start from a small design and to build to a more complex design one small
piece at a time.  You might even call this &lt;em&gt;good engineering process.&lt;/em&gt;  Along
the way, you’ll want to avoid changing too many things at once.  Lest, if you
introduce too many changes at the same time, you’ll never know which change
is keeping your design from working.  Hence, your goal should be to build
your complex designs from an initial simple design, modified by only simple
changes.&lt;/p&gt;

&lt;p&gt;The corollary to this rule is to make certain that your test and debug
infrastructure, I like to call this your &lt;em&gt;scaffolding&lt;/em&gt;, is never one of
multiple unknowns within your design.  There is a time for testing the
scaffolding of your design: &lt;em&gt;before you need it&lt;/em&gt;.  You want to be convinced
in the reliability of your scaffolding before you ever commit your time
and design to its strength.&lt;/p&gt;

&lt;p&gt;This has a particular application when you wish to use the buttons, switches,
or keypad entry mechanisms to your design.  My advice?  Don’t use them as part
of your debug infrastructure until you have &lt;em&gt;proven&lt;/em&gt; that they work the way
you want them to work first.  The reason is that buttons bounce, and
creating a signal that doesn’t bounce requires digital logic.&lt;/p&gt;

&lt;p&gt;What makes a button debouncing circuit particularly unique when it comes to
debugging, is that it is
difficult to test apart from using a real button.  You just can’t simulate
an unknown piece of hardware’s response very well.  This is what makes the
coupling of the &lt;a href=&quot;https://github.com/ZipCPU/dbgbus&quot;&gt;debugging bus&lt;/a&gt; and
&lt;a href=&quot;https://github.com/ZipCPU/wbscope&quot;&gt;wishbone scope&lt;/a&gt; so powerful: using them,
you can not only measure what’s going on any time a button gets pressed, but
you can also measure whether or not your debouncing logic works within that
context.&lt;/p&gt;

&lt;p&gt;In this article, we will examine how to debounce a set of button inputs,
so that they can then be used as part of your test infrastructure.&lt;/p&gt;

&lt;h2 id=&quot;generating-events&quot;&gt;Generating Events&lt;/h2&gt;

&lt;p&gt;User inputs, whether they be button presses, switches, or other, can be a very
valuable part of your design.  They can be used
to reset your board, to start a test, or even to enter data into your design.
Indeed, once you cut the umbilical (&lt;a href=&quot;https://en.wikipedia.org/wiki/JTAG&quot;&gt;JTAG&lt;/a&gt;,
&lt;a href=&quot;https://en.wikipedia.org/wiki/Universal_asynchronous_receiver/transmitter&quot;&gt;UART&lt;/a&gt;, or
&lt;a href=&quot;https://github.com/ZipCPU/dbgbus/&quot;&gt;debugging bus&lt;/a&gt;) to your
board, such inputs may be the only means you have remaining of controlling
your board.&lt;/p&gt;

&lt;p&gt;To understand how valuable these inputs can be, consider the following
scenarios where student’s have tried to use a button:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;One student thought it would be nice to create a design that prints &lt;a href=&quot;https://en.wikipedia.org/wiki/&amp;quot;Hello,_World!&amp;quot;_program&quot;&gt;Hello
World&lt;/a&gt;
anytime a button is pressed.&lt;/p&gt;

    &lt;p&gt;This student hadn’t yet gotten his first serial port to work.  By adding
the button processing to his design, he added an additional unknown to the
design and was thus unable to discern which piece of logic was failing
when the whole didn’t work.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Another student’s challenge was to increment a counter every time a key was
pressed.
&lt;a href=&quot;https://forum.digilentinc.com/topic/3992-something-simple-is-apparently-impossible-incrdec-number/&quot;&gt;[1]&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;This sounds easy, right?&lt;/p&gt;

    &lt;p&gt;This student was surprised to discover that every time he pressed a button,
his counter jumped by more than a single count.  He was expecting a single
state change only.  Indeed, his design depended upon being able to detect
singular button press events.  The multiple detected events “broke” the
design he was building.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;While both of these applications are valid applications of a button, both
students ended up stuck with an FPGA design that didn’t work because they
weren’t aware of the difficulty associated with buttons: they bounce.&lt;/p&gt;

&lt;p&gt;Turning a button from a bouncing electrical signal into a useful entry method
requires some &lt;em&gt;debouncing logic&lt;/em&gt;.&lt;/p&gt;

&lt;h2 id=&quot;metastability-and-avoiding-the-beginners-mistakes&quot;&gt;Metastability, and avoiding the beginner’s mistakes&lt;/h2&gt;

&lt;p&gt;Before we dig deeply into how to &lt;em&gt;debounce&lt;/em&gt; a button, let’s take a quick
moment to mention how &lt;em&gt;not&lt;/em&gt; to work with a button.&lt;/p&gt;

&lt;p&gt;The beginner is often enticed by the capabilities of a chip to transition on 
a positive edge.  Hence, I’ve seen many beginners start their approach with&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;initial	event = 1&#39;b0;
always @(posedge i_button, posedge i_reset)
	if (i_reset)
		// Reset our system whenever i_reset is true
		event &amp;lt;= 1&#39;b0
	else
		event &amp;lt;= 1&#39;b1;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The same mistake can be manifest in an attempt to count events, as in:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;initial	event = 1&#39;b0;
always @(posedge i_button, posedge i_reset)
	if (i_reset)
		counter &amp;lt;= 0;
	else
		counter &amp;lt;= counter + 1&#39;b1;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Both of these approaches to measuring buttons are problematic.&lt;/p&gt;

&lt;p&gt;Here’s why:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Timing&lt;/strong&gt;: &lt;code class=&quot;highlighter-rouge&quot;&gt;i_button&lt;/code&gt; is not a clock.  Your tool-suite will struggle to
analyze the timing between when a button press event takes place and
the rest of the logic within your design.  It’s going to try to optimize
the distance (in time and space) between the button press logic taking
place and the logic that depends upon it, and since the button press wasn’t
a clock the result will be difficult to analyze.  The result will be
unreliable logic in the rest of your circuit.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Asynchronous reset&lt;/strong&gt;’s tend to have a propagation delay when they work
their way through your circuitry.  Therefore, they may reset one portion
of your circuitry before another.  While this might not be such a problem
if every part of the circuit gets reset eventually, this doesn’t mitigate
the exit from the asynchronous reset .  Hence, when using an asynchronous
reset, you may find some pieces of logic are released from reset before
other pieces of logic. (This is &lt;em&gt;bad&lt;/em&gt;)&lt;/p&gt;

    &lt;p&gt;Particularly problematic are spurious reset signals that last for less than
a clock interval, perhaps created by some radio frequency interference
within the FPGA board’s environment.  These signals may partially but not
completely reset an FPGA’s logic.&lt;/p&gt;

    &lt;p&gt;&lt;strong&gt;The beginner’s reset rule:&lt;/strong&gt; Just avoid the asynchronous reset.  This
is easily done by removing &lt;code class=&quot;highlighter-rouge&quot;&gt;posedge i_reset&lt;/code&gt; from the dependency line in
the always block.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Given this information, let’s try to build our logic again:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;initial	down  = 1&#39;b0;
initial	event = 1&#39;b0;
always @(posedge i_clk)
	if (i_reset)
	begin
		down  &amp;lt;= 0;
		event &amp;lt;= 0;
	end else begin
		down &amp;lt;= i_button;
		event &amp;lt;= (i_button)&amp;amp;&amp;amp;(!down);
	end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This approach, while better than the first one, is still problematic.&lt;/p&gt;

&lt;p&gt;While this avoids the asynchronous reset, it now has a problem with
&lt;a href=&quot;https://en.wikipedia.org/wiki/Metastability_in_electronics&quot;&gt;metastability&lt;/a&gt;. 
Specifically, &lt;code class=&quot;highlighter-rouge&quot;&gt;i_button&lt;/code&gt; may not have settled for enough time prior to the
clock to create a stable logic signal.  As a result, the &lt;code class=&quot;highlighter-rouge&quot;&gt;down&lt;/code&gt; register may
be indeterminate. Some parts of your circuitry may decide &lt;code class=&quot;highlighter-rouge&quot;&gt;down&lt;/code&gt; is true,
while other parts deciding &lt;code class=&quot;highlighter-rouge&quot;&gt;down&lt;/code&gt; is false.  You may get two events in a
row, or no events at all.&lt;/p&gt;

&lt;p&gt;To avoid these problems, stick to these rules:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Use the positive edge of a single clock for &lt;em&gt;all&lt;/em&gt; of your logic.
I like to use the same basic clock wire, &lt;code class=&quot;highlighter-rouge&quot;&gt;i_clk&lt;/code&gt;, within all my modules
for this purpose.  The &lt;code class=&quot;highlighter-rouge&quot;&gt;i_clk&lt;/code&gt; signal itself is either externally generated,
or the result of a PLL applied to an external clock signal.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;For any logic inputs that are not created synchronously to your clock,
such as your button inputs, clock them through a pair of flip flops
(example below).  This applies to all external user input devices, such
as buttons, switches, and keypad entry.  This rule also applies to all
of your external asynchronous inputs as well: PS/2 devices, UARTs, or
indeed any wires coming from external circuits that do not share your clock.&lt;/p&gt;

    &lt;p&gt;While this alone doesn’t solve the problem of bouncing, it will make
actually dealing with it a lot easier.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Using these rules, we can create a clock synchronous button input.  The first
step is to run the button input through two flip-flops to avoid any
&lt;a href=&quot;https://en.wikipedia.org/wiki/Metastability_in_electronics&quot;&gt;metastability&lt;/a&gt;
issues.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;initial	sync_pipe      = 1&#39;b0;
initial	r_button_state = 1&#39;b0;
always @(posedge i_clk)
	{ r_button_state, sync_pipe }
		&amp;lt;= { sync_pipe, i_button };&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;r_button_state&lt;/code&gt; has now gone through two flip flops from &lt;code class=&quot;highlighter-rouge&quot;&gt;i_button&lt;/code&gt;, and so
it will be a one or a zero to all logic within your FPGA.  Now that the
button input has been synchronized to our clock, we can detect when the
button input changes with such simple code as:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;initial	r_last         = 1&#39;b0;
initial	r_button_event = 1&#39;b0;
always @(posedge i_clk)
begin
	r_last &amp;lt;= r_button_state;
	r_button_event &amp;lt;= (r_button_state)&amp;amp;&amp;amp;(!r_last);
end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The nice part of this technique for generating &lt;code class=&quot;highlighter-rouge&quot;&gt;r_button_event&lt;/code&gt;, is that it
will only ever be true &lt;em&gt;once&lt;/em&gt; for every time the &lt;code class=&quot;highlighter-rouge&quot;&gt;i_button&lt;/code&gt; goes from off to
on.&lt;/p&gt;

&lt;p&gt;The other common piece of logic drawn from an external button input is a
counter.  Let’s assume that our reset input, &lt;code class=&quot;highlighter-rouge&quot;&gt;i_reset&lt;/code&gt; is synchronous–perhaps
you created it via the &lt;a href=&quot;https://github.com/ZipCPU/dbgbus&quot;&gt;dbgbus&lt;/a&gt;
infrastructure &lt;a href=&quot;/blog/2017/06/28/dbgbus-goal.html&quot;&gt;we’ve already
built&lt;/a&gt;.  We can
use that input to increment our counter, and then we can use the button event
we just created to increment a counter:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	if (i_reset)
		counter &amp;lt;= 0;
	else if (r_button_event)
		counter &amp;lt;= counter + 1&#39;b1;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;At this point we’ve only solved the problems with metastability, the
asynchronous clock, and synchronizing the button input to our clock.
Now that we know how to avoid these mistakes, let’s &lt;em&gt;debounce&lt;/em&gt; this button.&lt;/p&gt;

&lt;h2 id=&quot;a-very-simple-debouncer&quot;&gt;A Very Simple Debouncer&lt;/h2&gt;

&lt;p&gt;The basic approach to debouncing a button is to prevent the button’s output
from changing more than once every &lt;code class=&quot;highlighter-rouge&quot;&gt;N&lt;/code&gt; clocks.  Hence, we’ll build our
approach to debouncing around a timer, &lt;code class=&quot;highlighter-rouge&quot;&gt;timer&lt;/code&gt;, that simply counts down to
zero.  Any time this &lt;code class=&quot;highlighter-rouge&quot;&gt;timer&lt;/code&gt; reaches zero, the current value will be forwarded
to the output.  Further, we can control the time interval by just adjusting
the number of bits in the timer.  We’ll call this number of bits &lt;code class=&quot;highlighter-rouge&quot;&gt;LGWAIT&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Given those goals, here’s the code for a very simple digital logic debouncer:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;initial timer = {(LGWAIT){1&#39;b1}};
always @(posedge i_clk)
	timer &amp;lt;= timer - 1&#39;b1;
always @(posedge i_clk)
	if (timer == 0)
		o_debounced &amp;lt;= r_button_state;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This approach should be good enough for most uses, so if you just want a very
simple debouncing circuit this one will work.&lt;/p&gt;

&lt;p&gt;However, if the latency in reporting the button press is important to you,
this piece of logic may cause the button press indication to wait for up to
&lt;code class=&quot;highlighter-rouge&quot;&gt;2^(LGWAIT)&lt;/code&gt; samples before being reported.&lt;/p&gt;

&lt;p&gt;So, let’s return to this concept and see if we can’t do any better.&lt;/p&gt;

&lt;h2 id=&quot;a-debouncer-with-more-immediate-results&quot;&gt;A Debouncer with more Immediate Results&lt;/h2&gt;

&lt;p&gt;This time, let’s rebuild this debouncing circuit around the idea that a
pressed button should be reported immediately, but that following changes
should be held off at least &lt;code class=&quot;highlighter-rouge&quot;&gt;N=2^(LGWAIT)&lt;/code&gt; clocks after that.&lt;/p&gt;

&lt;p&gt;Further, we’ll follow some of the lessons from our post on how to &lt;a href=&quot;/blog/2017/06/12/minimizing-luts.html&quot;&gt;minimize
logic resources&lt;/a&gt;.
In particular, we’ll use a second register, &lt;code class=&quot;highlighter-rouge&quot;&gt;ztimer&lt;/code&gt;, together with our timer.
This register will be a single wire only, and we’ll set it to true any time
&lt;code class=&quot;highlighter-rouge&quot;&gt;timer&lt;/code&gt; is zero.  Finally, as we are going to set this up, any time &lt;code class=&quot;highlighter-rouge&quot;&gt;ztimer&lt;/code&gt;
is true the circuit will be responsive to a changing signal.&lt;/p&gt;

&lt;p&gt;So here’s the code for the &lt;code class=&quot;highlighter-rouge&quot;&gt;timer&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;ztimer&lt;/code&gt;:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;initial	ztimer = 1&#39;b1;
initial	timer  = 0;
always @(posedge i_clk)
	if ((ztimer)&amp;amp;&amp;amp;(different))
	begin
		timer  &amp;lt;= {(LGWAIT) {1&#39;b1} };
		ztimer &amp;lt;= 1&#39;b0;
	end else if (!ztimer)
	begin
		timer  &amp;lt;= timer - 1&#39;b1;
		ztimer &amp;lt;= (timer[(LGWAIT-1):1] == 0);
	end else begin
		ztimer &amp;lt;= 1&#39;b1;
		timer  &amp;lt;= 0;
	end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The count-down will begin any time the &lt;code class=&quot;highlighter-rouge&quot;&gt;timer&lt;/code&gt; is at zero (&lt;code class=&quot;highlighter-rouge&quot;&gt;ztimer&lt;/code&gt; is high),
and the inputs are &lt;code class=&quot;highlighter-rouge&quot;&gt;different&lt;/code&gt; from what they were.  (We’ll come back to this
in a moment.)    Once the timer is running, it will count down to zero.
When it hits zero, it will hold there until another change has been detected.&lt;/p&gt;

&lt;p&gt;As mentioned above, we’ll use the register &lt;code class=&quot;highlighter-rouge&quot;&gt;different&lt;/code&gt; to signal any time the
input is different from the output of our debouncing circuit.  &lt;code class=&quot;highlighter-rouge&quot;&gt;different&lt;/code&gt;,
though, will then need to remain true until any ongoing countdown completes.
Hence, as long as &lt;code class=&quot;highlighter-rouge&quot;&gt;different&lt;/code&gt; gets set, either when the timer isn’t counting
or between count-downs, &lt;code class=&quot;highlighter-rouge&quot;&gt;different&lt;/code&gt; will make sure that the timer restarts
again.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	different &amp;lt;= ((different)&amp;amp;&amp;amp;(!ztimer))||(r_in != o_debounced);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;We now finally have all the pieces necessary to create our low-latency
debounced output.  This output will be set to whatever we just finished
reading, but only ever anytime &lt;code class=&quot;highlighter-rouge&quot;&gt;ztimer&lt;/code&gt; is set.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;initial	o_debounced = { (NIN) {1&#39;b0} };
always @(posedge i_clk)
	if (ztimer)
		o_debounced &amp;lt;= r_last;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Notice the choice to set &lt;code class=&quot;highlighter-rouge&quot;&gt;o_debounced&lt;/code&gt; any time &lt;code class=&quot;highlighter-rouge&quot;&gt;ztimer&lt;/code&gt; is true, coupled with
the fact that &lt;code class=&quot;highlighter-rouge&quot;&gt;ztimer&lt;/code&gt; idles at zero.  Because of this, any time a button is
pressed (or released), while the circuit is idle (&lt;code class=&quot;highlighter-rouge&quot;&gt;ztimer&lt;/code&gt; is true), will
immediately adjust &lt;code class=&quot;highlighter-rouge&quot;&gt;o_debounced&lt;/code&gt; with the new value.  Subsequent bounces,
until the signal becomes stable again, will be limited to only change every
&lt;code class=&quot;highlighter-rouge&quot;&gt;2^LGWAIT&lt;/code&gt; clocks.&lt;/p&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;While this post presents &lt;a href=&quot;https://github.com/ZipCPU/debouncer/blob/master/rtl/debouncer.v&quot;&gt;working debouncing
logic&lt;/a&gt;, the
task remains far from complete.  For example, how many bits (&lt;code class=&quot;highlighter-rouge&quot;&gt;LGWAIT&lt;/code&gt;) need
to be allocated to the counter?  Not quite so subtle is the question of how
shall this capability be proven?  In particular, this logic requires
an external button input bounce in order to properly verify its functionality.&lt;/p&gt;

&lt;p&gt;Our next post, therefore, will focus on how to measure bounces so we can
tell if a bounce has taken place.  After that, we’ll discuss how to modify
the debugging bus for this purpose, and to get a trace from within the
design so we can see what’s going on.  Then we’ll go and move on to the next
topic.&lt;/p&gt;

</description>
        <pubDate>Fri, 04 Aug 2017 00:00:00 -0400</pubDate>
        <link>http://zipcpu.com/blog/2017/08/04/debouncing.html</link>
        <guid isPermaLink="true">http://zipcpu.com/blog/2017/08/04/debouncing.html</guid>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>Visualizing Contact Bounce</title>
        <description>&lt;p&gt;If you’ve ever tried to press a button on an FPGA board, you might expect a response similar to Fig 1 below:&lt;/p&gt;

&lt;table style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 1: A Simple button press&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/arty-simple-press.png&quot; alt=&quot;A Simple Button Press on the Arty&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;You want the button to transition from low (idle) to high (pressed) once for
every time your finger pushes the button.  You also want the button to return
to zero in a similarly simple fashion.  In Fig 1 above, &lt;code class=&quot;highlighter-rouge&quot;&gt;i_btn&lt;/code&gt; does just
that, although only the button press (&lt;code class=&quot;highlighter-rouge&quot;&gt;i_btn&lt;/code&gt; rises) is shown and not the
button release.&lt;/p&gt;

&lt;p&gt;In reality, electrical contacts don’t work that way.&lt;/p&gt;

&lt;p&gt;The following several images show examples of what happens when a button is
either pressed or released.  In each of them, &lt;code class=&quot;highlighter-rouge&quot;&gt;i_btn&lt;/code&gt; is the raw input from
the external port, whereas &lt;code class=&quot;highlighter-rouge&quot;&gt;debounced&lt;/code&gt; is the result of a debouncing circuit
that we’ll discuss over the next couple of posts.  Further, you may notice
that the number of wires in &lt;code class=&quot;highlighter-rouge&quot;&gt;i_btn&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;debounced&lt;/code&gt; changes from board to
board–this is just a reality of different boards having different numbers
of buttons.&lt;/p&gt;

&lt;p&gt;For example, Fig 2 shows the logic read when a button was released on
&lt;a href=&quot;https://store.digilentinc.com/arty-artix-7-fpga-development-board-for-makers-and-hobbyists/&quot;&gt;Digilent’s Arty development board&lt;/a&gt;.&lt;/p&gt;

&lt;table style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 2: A not so simple release&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/arty-release.png&quot; alt=&quot;A trace of a button release from the Arty&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Notice how &lt;code class=&quot;highlighter-rouge&quot;&gt;i_btn&lt;/code&gt; doesn’t simply transition back to zero (off) when the button
is released, but rather bounces on its way down.
It’s not that the board is broken, its not.  The board actually works quite
well.  Rather, the signal from a changing button doesn’t always simply change.
It tends to bounce as well.&lt;/p&gt;

&lt;p&gt;Figs 3 and 4 show bouncing as measured on the &lt;a href=&quot;http://www.icoboard.org&quot;&gt;ICO
board&lt;/a&gt;.&lt;/p&gt;

&lt;table style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 3: ICO Board Button Press with Bounce&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/ico-entry-bounce.png&quot; alt=&quot;Example FIFO read/write pointers&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;table style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 4: ICO Board Button Release with Multiple Bounces&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/ico-tripl-bounce.png&quot; alt=&quot;Example FIFO read/write pointers&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Notice that, though we’ve switched boards, the button on this other board
still bounces.&lt;/p&gt;

&lt;p&gt;In case you think the reason for the bounce might be because both the
&lt;a href=&quot;https://store.digilentinc.com/arty-artix-7-fpga-development-board-for-makers-and-hobbyists/&quot;&gt;Arty&lt;/a&gt;.
and the &lt;a href=&quot;https://www.icoboard.org&quot;&gt;ICO Board&lt;/a&gt; use similar buttons, Figs 5-8
show example button bounces from the &lt;a href=&quot;https://store.digilentinc.com/pmod-kypd-16-button-keypad/&quot;&gt;PMod
Keypad&lt;/a&gt; as measured
by a &lt;a href=&quot;http://store.digilentinc.com/cmod-s6-breadboardable-spartan-6-fpga-module&quot;&gt;CMod S6 board&lt;/a&gt;.  Since the keypads logic is inverted from that of the
buttons above, the events presented are actually keypad releases, and not
keypad presses.&lt;/p&gt;

&lt;p&gt;Of these, Fig 5 (below) may show the most severe bounce from the keypad.&lt;/p&gt;

&lt;table style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 5: PMod Keypad Severe Bounce on Release&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/kypad.png&quot; alt=&quot;A trace of a severe bounce when a keypad button is released&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;

&lt;p&gt;Fig 6 appears to be fairly benign, but the key still bounces.&lt;/p&gt;

&lt;table style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 6: PMod Keypad Bounce on Release&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/kypad2.png&quot; alt=&quot;Tracing a button release from a 16-character numeric keypad&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;

&lt;p&gt;Fig 7 shows another two bounces.&lt;/p&gt;

&lt;table style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 7: PMod Keypad Bounce on Release&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/kypad3.png&quot; alt=&quot;Another example trace of a button release from a numeric keypad&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;

&lt;p&gt;Fig 8 shows that the locations appear fairly random–even though it represents
the same number of bounces Fig 7 had.&lt;/p&gt;

&lt;table style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 8: Another PMod Keypad Severe Bounce on Release&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/kypad4.png&quot; alt=&quot;Last example trace from a keypad button release&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;

&lt;p&gt;Measuring this sort of contact bounce isn’t really that hard at
all—especially once you have access to a &lt;a href=&quot;https://github.com/ZipCPU/dbgbus&quot;&gt;debugging bus&lt;/a&gt;
such as the one &lt;a href=&quot;/blog/2017/06/20/dbg-put-together.html&quot;&gt;we built together&lt;/a&gt; on this blog.&lt;/p&gt;

&lt;p&gt;Stick around, and we’ll discuss not only how to debounce a set of buttons,
but also how to measure the effects of button bounce, and how to modify the
&lt;a href=&quot;https://github.com/ZipCPU/dbgbus&quot;&gt;debugging bus&lt;/a&gt; project to handle a task such as this one.&lt;/p&gt;

</description>
        <pubDate>Wed, 02 Aug 2017 00:00:00 -0400</pubDate>
        <link>http://zipcpu.com/blog/2017/08/02/debounce-teaser.html</link>
        <guid isPermaLink="true">http://zipcpu.com/blog/2017/08/02/debounce-teaser.html</guid>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>ZipCPU Advertising</title>
        <description>&lt;p&gt;The ZipCPU blog is supported today by a small number of
&lt;a href=&quot;https://www.patreon.com/ZipCPU&quot;&gt;Patreon&lt;/a&gt; donations.
I do not get any advertising or other revenues for this work.&lt;/p&gt;

&lt;p&gt;Last night, I removed Disqus support from the ZipCPU blog. 
Disqus had offered a free discussion capability at the bottoms of the
various posts, for only “minimal” “unobtrusive” advertising.
I had no problems with this contract, especially since I never saw any of
these advertisements.  (I use a strong Ad-blocker on Firefox, and constantly
tune it personally myself.)&lt;/p&gt;

&lt;p&gt;Monday night, though, I finally saw the first of these “unobtrusive”
advertisements.  I will not repeat what I saw here.  I will summarize my
impression by saying that the advertising I saw on my own blog
page was not consistent with my strong Christian values.&lt;/p&gt;

&lt;p&gt;These values are captured within the Bible, from Genesis to Revelation, and
they are reflected in the verses posted at the bottom of every page.&lt;/p&gt;

&lt;p&gt;I do, however, continue to use Google-Analytics support.  From
Google-Analytics, I can tell
how often web pages on this site get read, which pages are read the most,
and how folks move around the site.  However, if Google-Analytics becomes
a problem, I will remove that capability as well.&lt;/p&gt;

&lt;p&gt;The blog articles posted here take a lot of work to put together.  While I
have nothing in principle against getting some advertising revenue in
addition to &lt;a href=&quot;https://www.patreon.com/ZipCPU&quot;&gt;Patreon&lt;/a&gt; support, I refuse
to sacrifice my morals to get this revenue.&lt;/p&gt;

&lt;p&gt;Please contact me, therefore, if you ever see any advertisements on this
site that would be inconsistent with strong Christian (i.e. Biblical)
moral values.  This includes if you see advertisements showing “skin”,
or otherwise making a profit from another man’s sin and suffering.&lt;/p&gt;
</description>
        <pubDate>Tue, 01 Aug 2017 00:00:00 -0400</pubDate>
        <link>http://zipcpu.com/blog/2017/08/01/advertising.html</link>
        <guid isPermaLink="true">http://zipcpu.com/blog/2017/08/01/advertising.html</guid>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>Writing your own VCD File</title>
        <description>&lt;p&gt;Some time ago, we discussed how you can &lt;a href=&quot;/blog/2017/06/08/simple-scope.html&quot;&gt;build a scope within your own
logic&lt;/a&gt;, and even &lt;a href=&quot;/blog/2017/06/29/sw-dbg-interface.html&quot;&gt;how to
get the contents of that scope back out of your
FPGA&lt;/a&gt;.  Today, we’ll
finish the discussion by describing what it takes to turn that data into a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Value_change_dump&quot;&gt;Value-Change Dump (VCD)&lt;/a&gt;
file.&lt;/p&gt;

&lt;p&gt;The &lt;a href=&quot;https://en.wikipedia.org/wiki/Value_change_dump&quot;&gt;VCD&lt;/a&gt;
file format structure is a common data format that can be used to store
digital logic traces, so
that you can then later view it with a waveform viewing
tool.  &lt;a href=&quot;https://gtkwave.sourceforge.net&quot;&gt;GTKWave&lt;/a&gt; ingests
&lt;a href=&quot;https://en.wikipedia.org/wiki/Value_change_dump&quot;&gt;VCD&lt;/a&gt;
files easily.
Indeed, two of my favorite tools,
&lt;a href=&quot;https://www.veripool.org/wiki/verilator&quot;&gt;Verilator&lt;/a&gt;
and the &lt;a href=&quot;https://github.com/ZipCPU/wbscope&quot;&gt;wishbone scope&lt;/a&gt;,
will both output
&lt;a href=&quot;https://en.wikipedia.org/wiki/Value_change_dump&quot;&gt;VCD&lt;/a&gt; traces for this purpose.&lt;/p&gt;

&lt;p&gt;One of the really nice parts of this standard is that it is a text-based
standard.  This means you can view, review, and even edit a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Value_change_dump&quot;&gt;VCD&lt;/a&gt; file if you
really need to with your favorite text editor.  While I don’t recommend
it, I have needed to load
&lt;a href=&quot;https://en.wikipedia.org/wiki/Value_change_dump&quot;&gt;VCD&lt;/a&gt; 
files into &lt;a href=&quot;http://www.vim.org&quot;&gt;gvim&lt;/a&gt; from time to time to figure out what’s
wrong (or right) with the file.&lt;/p&gt;

&lt;h2 id=&quot;the-standard&quot;&gt;The standard&lt;/h2&gt;

&lt;p&gt;The actual standard for the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Value_change_dump&quot;&gt;VCD&lt;/a&gt; 
format is part of
&lt;em&gt;&lt;a href=&quot;https://staff.ustc.edu.cn/~songch/download/IEEE.1364-2005.pdf&quot;&gt;The IEEE Standard for (the) Verilog Hardware Description Language&lt;/a&gt;&lt;/em&gt;.
My copy is IEEE Std 1364-2005, where the &lt;a href=&quot;https://en.wikipedia.org/wiki/Value_change_dump&quot;&gt;Value Change Dump
(VCD)&lt;/a&gt;
file format is discussed starting on page 325.&lt;/p&gt;

&lt;p&gt;While this article will discuss some basic components of the standard,
it will by no means by exhaustive.  For further information, you’ll want to
look up the standard itself.&lt;/p&gt;

&lt;h2 id=&quot;the-vcd-header&quot;&gt;The VCD Header&lt;/h2&gt;

&lt;p&gt;The first part of any
&lt;a href=&quot;https://en.wikipedia.org/wiki/Value_change_dump&quot;&gt;VCD&lt;/a&gt; 
file is a header.  There are two primary components to the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Value_change_dump&quot;&gt;VCD&lt;/a&gt; 
file header: basic file meta-data, and variable declarations.
White space is used to separate commands, and to make the file more human
legible.&lt;/p&gt;

&lt;p&gt;The basic file meta-data identifies the program, or program version, that
created the &lt;a href=&quot;https://en.wikipedia.org/wiki/Value_change_dump&quot;&gt;VCD&lt;/a&gt; 
file, as well as the date the trace was created on and the timescale it uses.
As an example, a recent
&lt;a href=&quot;https://www.veripool.org/wiki/verilator&quot;&gt;Verilator&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Value_change_dump&quot;&gt;VCD&lt;/a&gt; 
output file from the
&lt;a href=&quot;https://github.com/ZipCPU/wbuart32/&quot;&gt;wbuart32&lt;/a&gt;
distribution started with the following text:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;$version Generated by VerilatedVcd $end
$date Wed Jun  7 11:35:32 2017
 $end
$timescale 1ns $end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The first line identifies the tool that created the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Value_change_dump&quot;&gt;VCD&lt;/a&gt; 
file and what it’s version is.  This line begins with &lt;code class=&quot;highlighter-rouge&quot;&gt;$version&lt;/code&gt;, and ends
with &lt;code class=&quot;highlighter-rouge&quot;&gt;$end&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The second line identifies when this file was created.  This field begins
with &lt;code class=&quot;highlighter-rouge&quot;&gt;$date&lt;/code&gt; and ends with &lt;code class=&quot;highlighter-rouge&quot;&gt;$end&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The third line identifies the timescale.  The timescale includes a time
number (1, 10, or 100) followed by a unit (s, ms, us, ns, ps, or fs).
Time integers within the file may then be multiplied by this unit to turn them
into engineering units in a display.
I have typically used a time scale of &lt;code class=&quot;highlighter-rouge&quot;&gt;1ns&lt;/code&gt;, although I suspect
&lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;autofpga&lt;/a&gt; files will use more precise
time scales so as to be able to handle multiple dissimilar clocks.&lt;/p&gt;

&lt;p&gt;This ends the necessary file meta-data, but not the end of the header yet.&lt;/p&gt;

&lt;p&gt;The next section of the header declares your variables.  Variables are
defined within a hierarchical scope.  Hence, you’ll seen sections of variables
defined by a &lt;code class=&quot;highlighter-rouge&quot;&gt;$scope&lt;/code&gt; line and ending with an &lt;code class=&quot;highlighter-rouge&quot;&gt;$upscope&lt;/code&gt; line.  The first
line (&lt;code class=&quot;highlighter-rouge&quot;&gt;$scope&lt;/code&gt;) defines the name of the scope the variables are found within. 
For example, variables at the top level of a
&lt;a href=&quot;https://www.veripool.org/wiki/verilator&quot;&gt;Verilator&lt;/a&gt;
produced
&lt;a href=&quot;https://en.wikipedia.org/wiki/Value_change_dump&quot;&gt;VCD&lt;/a&gt; 
file will have a top-level scope of TOP.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt; $scope module TOP $end

 .... (variables defined here)

 $upscope $end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The &lt;code class=&quot;highlighter-rouge&quot;&gt;$scope&lt;/code&gt; line has two words within it.  The first is the type of scope
being referenced.  In this case, it references a &lt;code class=&quot;highlighter-rouge&quot;&gt;module&lt;/code&gt;.  The second
is the name of the scope, &lt;code class=&quot;highlighter-rouge&quot;&gt;TOP&lt;/code&gt;, being
&lt;a href=&quot;https://www.veripool.org/wiki/verilator&quot;&gt;Verilator&lt;/a&gt;’s
term for the top level of a design.&lt;/p&gt;

&lt;p&gt;Variables found within a module &lt;code class=&quot;highlighter-rouge&quot;&gt;foo&lt;/code&gt; within TOP would be defined with
a similar module section, only that this section would be found within the
TOP section.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt; $scope module TOP $end
   ...
   $scope module foo $end
   ... (variables of the foo module within TOP would be defined here)
   $upscope $end
 $upscope $end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Variables themselves are declared on lines between &lt;code class=&quot;highlighter-rouge&quot;&gt;$var&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;$end&lt;/code&gt; tags.
Four tokens are used, between these two flags, to define any variable,
as shown below:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;$var vary_type size identifier_code reference $end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The first token, &lt;strong&gt;var_type&lt;/strong&gt; specifies the type of variable.  The standard
allows many different variable types, although I’ve only ever used &lt;code class=&quot;highlighter-rouge&quot;&gt;wire&lt;/code&gt;.
Other types that might be useful include &lt;code class=&quot;highlighter-rouge&quot;&gt;parameter&lt;/code&gt;, and &lt;code class=&quot;highlighter-rouge&quot;&gt;reg&lt;/code&gt;, although the
standard identifies many more types.&lt;/p&gt;

&lt;p&gt;The second token, &lt;strong&gt;size&lt;/strong&gt; specifies the number of bits this value will
contain.&lt;/p&gt;

&lt;p&gt;The third token is perhaps the most cryptic,
although it need not be.  This is the &lt;strong&gt;identifer_code&lt;/strong&gt; assigned to this
particular variable.  This is a printable character, or string of printable
characters, used to identify the variable during the data section of the file.
We’ll come back to this in a moment.&lt;/p&gt;

&lt;p&gt;The last part of the &lt;code class=&quot;highlighter-rouge&quot;&gt;$var&lt;/code&gt; line is the &lt;strong&gt;reference&lt;/strong&gt;.  This is the variable
name the user has given to the trace.  If the variable had a width, it would
then be followed by something like &lt;code class=&quot;highlighter-rouge&quot;&gt;[MSB:LSB]&lt;/code&gt;.  For example, a four bit
trace &lt;code class=&quot;highlighter-rouge&quot;&gt;i_button&lt;/code&gt; could have the &lt;strong&gt;reference&lt;/strong&gt; of &lt;code class=&quot;highlighter-rouge&quot;&gt;i_button[3:0]&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;One line that
&lt;a href=&quot;https://gtkwave.sourceforge.net&quot;&gt;GTKWave&lt;/a&gt;
understand’s that I haven’t found in the specification is a &lt;code class=&quot;highlighter-rouge&quot;&gt;$timezero&lt;/code&gt;
line.  This line has three items in it, &lt;code class=&quot;highlighter-rouge&quot;&gt;$timezero&lt;/code&gt;, the internal time
where the zero occurs, and the &lt;code class=&quot;highlighter-rouge&quot;&gt;$end&lt;/code&gt; tag. 
&lt;a href=&quot;https://github.com/ZipCPU/wbscope&quot;&gt;wbscope&lt;/a&gt; uses this tag to place the
trigger at time zero.&lt;/p&gt;

&lt;p&gt;Finally, the header section is ended by an &lt;code class=&quot;highlighter-rouge&quot;&gt;$enddefinitions&lt;/code&gt; line:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;$var vary_type size identifier_code reference $end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;If you are confused about these values and terms, consider looking through a 
&lt;a href=&quot;https://en.wikipedia.org/wiki/Value_change_dump&quot;&gt;VCD&lt;/a&gt; 
file from a reader that works.  The files just aren’t that hard to understand.&lt;/p&gt;

&lt;h2 id=&quot;data-section&quot;&gt;Data Section&lt;/h2&gt;

&lt;p&gt;From the end of the header to the end of the file is the data section.
This section contains two types of lines: simulation time lines and value
change lines.&lt;/p&gt;

&lt;p&gt;Simulation time lines start with a &lt;code class=&quot;highlighter-rouge&quot;&gt;#&lt;/code&gt; and a time value.  That’s it.
For example,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;#295&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;specifies that the following changes happen at &lt;code class=&quot;highlighter-rouge&quot;&gt;295&lt;/code&gt; time units.  Exactly
how much time this references depends upon the &lt;code class=&quot;highlighter-rouge&quot;&gt;$timescale&lt;/code&gt; command in the
header.  Further, the simulation time is an &lt;em&gt;unsigned number&lt;/em&gt;.  Negative
negative numbers are not allowed, and will really mess up your
&lt;a href=&quot;https://en.wikipedia.org/wiki/Value_change_dump&quot;&gt;VCD&lt;/a&gt; 
file.  (I know … I’ve tried.)&lt;/p&gt;

&lt;p&gt;Value change lines contain the value the variable is taking on, followed by the
identifier code for the variable that was assigned in the header.  These lines
are only necessary any time the value in question changes.&lt;/p&gt;

&lt;p&gt;For single bit values, the value in a value change line consists of a
&lt;code class=&quot;highlighter-rouge&quot;&gt;0&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;x&lt;/code&gt;, or &lt;code class=&quot;highlighter-rouge&quot;&gt;z&lt;/code&gt; followed by
the identifier code that was assigned to this value in the header.  For
multibit values, a &lt;code class=&quot;highlighter-rouge&quot;&gt;b&lt;/code&gt; precedes all of the bits.
If not all of the bits are given, then the value is left-extended in an
unsigned fashion.&lt;/p&gt;

&lt;p&gt;As an example, if &lt;code class=&quot;highlighter-rouge&quot;&gt;J&lt;/code&gt; is defined in the header to reference &lt;code class=&quot;highlighter-rouge&quot;&gt;i_clk&lt;/code&gt;, then&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;0J&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;specifies that the clock is now set to zero.  Likewise if &lt;code class=&quot;highlighter-rouge&quot;&gt;#&lt;/code&gt; is assigned
to the 8-bit data value &lt;code class=&quot;highlighter-rouge&quot;&gt;i_data[7:0]&lt;/code&gt;, then this value can be set with&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;b01000101#&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;While most FPGA programmers will not need to read or write
&lt;a href=&quot;https://en.wikipedia.org/wiki/Value_change_dump&quot;&gt;VCD&lt;/a&gt; 
files, anyone wanting to build &lt;a href=&quot;/blog/2017/06/08/simple-scope.html&quot;&gt;their own digital logic
scope&lt;/a&gt; will find
it valuable to know how to create
&lt;a href=&quot;https://en.wikipedia.org/wiki/Value_change_dump&quot;&gt;VCD&lt;/a&gt; 
files.&lt;/p&gt;

</description>
        <pubDate>Mon, 31 Jul 2017 00:00:00 -0400</pubDate>
        <link>http://zipcpu.com/blog/2017/07/31/vcd.html</link>
        <guid isPermaLink="true">http://zipcpu.com/blog/2017/07/31/vcd.html</guid>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>Linear Interpolation</title>
        <description>&lt;p&gt;Now that we’ve finished our series on how to build an upsampling linear
interpolator, let’s take a moment to collect the various posts in the 
series together.&lt;/p&gt;

&lt;p&gt;First, we had a pre-series post, discussing &lt;a href=&quot;/dsp/2017/06/06/simple-interpolator.html&quot;&gt;how to resample using a sample
and hold interperolator&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Given that context, our discussion of how to build a linear interpolator
included posts on:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;How an &lt;a href=&quot;/dsp/2017/07/19/linear-upsampling.html&quot;&gt;upsampling linear interpolator&lt;/a&gt; works&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;/dsp/2017/07/21/bit-growth.html&quot;&gt;Bit-width allocation within an FPGA&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;How to &lt;a href=&quot;/dsp/2017/07/22/rounding.html&quot;&gt;drop bits (i.e. round)&lt;/a&gt;, to keep bit growth from getting out of hand&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;How to &lt;a href=&quot;/dsp/2017/07/24/dsp-debugging.html&quot;&gt;debug DSP logic&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The one topic in linear interpolation that wasn’t covered was how to build
a downsampling linear interpolator.  This hardly needs a discussion of its
own, however, since a downsampler that downsamples by an integer amount can
easily just select points at the output of the linear upsampler.&lt;/p&gt;

&lt;p&gt;Hence, the posts above really cover the issue.&lt;/p&gt;

</description>
        <pubDate>Sat, 29 Jul 2017 00:00:00 -0400</pubDate>
        <link>http://zipcpu.com/dsp/2017/07/29/series-linear-interpolation.html</link>
        <guid isPermaLink="true">http://zipcpu.com/dsp/2017/07/29/series-linear-interpolation.html</guid>
        
        
        <category>dsp</category>
        
      </item>
    
      <item>
        <title>Getting the basic FIFO right</title>
        <description>&lt;p&gt;If you’ve ever waited in a line, then you understand what a
&lt;a href=&quot;https://en.wikipedia.org/wiki/FIFO&quot;&gt;FIFO&lt;/a&gt; is about.
A &lt;a href=&quot;https://en.wikipedia.org/wiki/FIFO&quot;&gt;FIFO&lt;/a&gt;
refers to a &lt;em&gt;First in, First out&lt;/em&gt; (i.e.
&lt;a href=&quot;https://en.wikipedia.org/wiki/FIFO&quot;&gt;FIFO&lt;/a&gt;) data structure that has
many applications in both computers and electronics.  The data structure
is designed to support the digital equivalent of waiting in line.&lt;/p&gt;

&lt;p&gt;Perhaps I need to underline that.
&lt;a href=&quot;https://en.wikipedia.org/wiki/FIFO&quot;&gt;FIFO&lt;/a&gt;’s don’t have one application, they
have &lt;em&gt;many&lt;/em&gt; applications in both software and electronic digital design.&lt;/p&gt;

&lt;p&gt;Let’s see if we can find some examples, shall we?&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;A &lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;, such as the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;Interrupting a CPU costs time and performance.  It’s not a simple thing to
do, in spite of the hard work of many men to make interrupts fast and
efficient.   Hence, at some data rates, handling requests one at a time can
just cripple a CPU–it’s just spending too much time handling the interrupt.&lt;/p&gt;

    &lt;p&gt;To deal with this, peripheral hardware is often created so that the CPU
can mange many items at the same time–spreading the cost of the interrupt
across many accesses.&lt;/p&gt;

    &lt;p&gt;Perhaps a good analogy here might be an airport taxi line.  Only one person
(family) can get into any taxi at a time, and then all the taxi’s move
forward so the next person can get into the next taxi.  In this case, when
an airplane arrives (the CPU gets busy), the line suddenly swells as many
people get off and start waiting in line for a taxi.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Synchronous_dynamic_random-access_memory&quot;&gt;SDRAM Memory&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;Memory is also another candidate for a FIFO.   Unlike the airport taxi line,
Memory acts more
like a school cafeteria buffet line.  Only one class is allowed to use
the line at a time, yet there are several stations that each student needs
to visit to get his lunch.  Hence, in the case of memory, you want to make
many transactions at once, fill the pipeline, and then get the whole data
through the line as soon as possible so the next class can come through.&lt;/p&gt;

    &lt;p&gt;In this case, you want a FIFO that can be filled, or nearly filled, and
then make all its transactions at once and release the memory so that
something else can use it.&lt;/p&gt;

    &lt;p&gt;(Example: &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/wbdmac.v&quot;&gt;DMA
Controller&lt;/a&gt;,
and a &lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/rtl/wbufifo.v&quot;&gt;Wishbone-UART debugging bus
FIFO&lt;/a&gt;)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;A &lt;a href=&quot;https://en.wikipedia.org/wiki/Universal_asynchronous_receiver/transmitter&quot;&gt;Universal Asynchronous Receiver Transmitter
(UART)&lt;/a&gt;,
sometimes known as a &lt;a href=&quot;https://en.wikipedia.org/wiki/Serial_port&quot;&gt;serial port&lt;/a&gt;.&lt;/p&gt;

    &lt;p&gt;Computers like to load a serial port with data.  However, the serial port
can typically only handle one item every so many clocks.  Often, the serial
port can operate much faster than the computer can interrupt, but slower
than the computer can issue characters to the port.&lt;/p&gt;

    &lt;p&gt;In this case, a FIFO can be used to allow the computer to write many
characters to the port.  These characters will then “wait in line” to be
transmitted, and when the line is (nearly) empty, the computer can then
send a whole bunch more characters to the port–keeping the port busy at all
times.&lt;/p&gt;

    &lt;p&gt;A similar case for a FIFO can be made on receive as well.  The computer
just waits for the line to fill up, before it processes all of the elements
in the line quickly.&lt;/p&gt;

    &lt;p&gt;&lt;a href=&quot;https://github.com/ZipCPU/wbuart32/blob/master/rtl/ufifo.v&quot;&gt;(Verilog example code)&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Audio&lt;/p&gt;

    &lt;p&gt;Audio is very much like the UART above.  The CPU can write at one speed,
but the audio may only be able to read at another.  A FIFO can allow a
CPU the ability to write a &lt;em&gt;lot&lt;/em&gt; of things to the audio port at once, after
which the audio hardware reads the samples out one by one.&lt;/p&gt;

    &lt;p&gt;Audio receiving is in many ways like some buses I’ve traveled on.  The line
for the bus grows and grows.  Once it reaches a certain length (in the case
of the FIFO), the “bus” comes along and clears the line.&lt;/p&gt;

    &lt;p&gt;&lt;a href=&quot;https://github.com/ZipCPU/wbpmic/blob/master/rtl/smplfifo.v&quot;&gt;(Verilog example code)&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Video&lt;/p&gt;

    &lt;p&gt;Unlike UARTs and Audio, the video FIFOs I’ve worked with have rarely (if ever)
required the CPU’s attention.  They usually work in the background.  When
receiving video data, once a FIFO buffer fills, the buffer is then dumped
into memory.  Likewise on the transmit: the video controller reads from
memory, fills its buffer, and then slowly sends it to the display one pixel
at a time.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;These are all examples of a FIFO.&lt;/p&gt;

&lt;p&gt;Basically, you need a FIFO anytime something is going to be produced (written)
at one rate, and consumed (read) at another.  The buffer in the FIFO, then,
adjusts like any line as items are added, or removed, from it.&lt;/p&gt;

&lt;p&gt;It’s really a fundamental digital design component.&lt;/p&gt;

&lt;p&gt;Let’s see what we need to do to build one.&lt;/p&gt;

&lt;h1 id=&quot;the-goal&quot;&gt;The Goal&lt;/h1&gt;

&lt;p&gt;For our simple example here, we’ll assume there are three operations that
can be done on a FIFO, and some parts and pieces of FIFO status that we may
wish to know.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;The FIFO may need to be reset.  This clears any items from the line,
and empties the buffer regardless of how many items were in line or how
full the buffer ever was.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;You can add someone to the end of the line.  This is what happens when data
is &lt;em&gt;written&lt;/em&gt; to the FIFO.&lt;/p&gt;

    &lt;p&gt;In digital electronics, though, there is a maximum length to any line.
Hence, if the line is too long, attempts to add one more item to the line
will fail.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;You can process the first item in the line.  This is what happens when data
is &lt;em&gt;read&lt;/em&gt; from the FIFO.&lt;/p&gt;

    &lt;p&gt;Any attempt to read from an empty FIFO must of necessity fail.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Those are the operations that can take place on a FIFO.&lt;/p&gt;

&lt;p&gt;For our discussion below, we’ll support three pieces of status:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;We’ll want to know how many items are in the line.
That way we can announce that the line is empty, full, half-full or …
whatever condition is necessary to move forward.&lt;/p&gt;

    &lt;p&gt;Eventually, we’ll want to know if the line is full or empty, but we’ll just
start with trying to know how many items are within it.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;We’ll want to know if we ever spilled an item by adding too many items to
the line (overflow), or if&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;We ever tried to read from the FIFO when it was empty (underflow).&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Further, to outline the necessary logic, we’ll start with a software example
of this FIFO, and then convert it to digital logic (i.e. Verilog).&lt;/p&gt;

&lt;h1 id=&quot;circular-buffer&quot;&gt;Circular Buffer&lt;/h1&gt;

&lt;p&gt;Wikipedia’s &lt;a href=&quot;https://en.wikipedia.org/wiki/FIFO&quot;&gt;FIFO&lt;/a&gt; article discusses
creating a
&lt;a href=&quot;https://en.wikipedia.org/wiki/FIFO&quot;&gt;FIFO&lt;/a&gt;
using dynamically allocated objects and pointers.&lt;/p&gt;

&lt;p&gt;Where this fails is in digital logic, because physical logic resources are
limited–dynamically allocated memory is unavailable.&lt;/p&gt;

&lt;p&gt;Hence, we’re going to use a different form of algorithm here.  We’ll use instead
a circular buffer with a fixed size.&lt;/p&gt;

&lt;p&gt;In this buffer, there are two pointers: the write pointer and the read pointer.&lt;/p&gt;

&lt;p&gt;Whenever the read and write pointers are identical, as in Fig 1 below,
we’ll use that as the indication that the buffer is empty.
Initially, both pointers will point to the same address in the buffer (zero).
Further, we’ll return both pointers to zero any time the user requests that the
buffer be reset.&lt;/p&gt;

&lt;table style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 1: Empty FIFO&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/fifo-empty.svg&quot; alt=&quot;Example image of an empty FIFO&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;When an item is written to the buffer, the write pointer is incremented.
This pointer then always points to the item not yet written to.&lt;/p&gt;

&lt;p&gt;When an item is read from the buffer, the read pointer is incremented.  This
pointer always references the next item to be read.&lt;/p&gt;

&lt;p&gt;If you look at a diagram of this, such as Fig 2, it looks like the
read pointer is &lt;em&gt;chasing&lt;/em&gt; the write pointer.&lt;/p&gt;

&lt;table style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 2: FIFO with data&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/fifo-rdwr.svg&quot; alt=&quot;Example FIFO read/write pointers&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;What happens when the write or read pointer gets to the end
of the buffer?  The pointer in question simply wraps around to the
beginning of the buffer.  Because the buffer pointers just wrap around,
this type of buffer is called a &lt;em&gt;circular buffer&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;You can tell when this type of FIFO is full, because write pointer one plus
will equal the read pointer, as in Fig 3 below.&lt;/p&gt;

&lt;table style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 3: A full FIFO&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/fifo-full.svg&quot; alt=&quot;Example image of a full FIFO&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Further, we’re going to use a special property of FIFO’s that are &lt;code class=&quot;highlighter-rouge&quot;&gt;2^N&lt;/code&gt;
in length.  That is, the read and write pointers will always fit into
&lt;code class=&quot;highlighter-rouge&quot;&gt;N&lt;/code&gt; bits, so no boundary checking is required.  Likewise, the number of elements
within the FIFO is given by the bottom &lt;code class=&quot;highlighter-rouge&quot;&gt;N&lt;/code&gt; bits of the difference between the
write and read pointers.&lt;/p&gt;

&lt;h1 id=&quot;a-simple-software-fifo&quot;&gt;A Simple Software FIFO&lt;/h1&gt;

&lt;p&gt;Our focus today is going to be on implementing this operation in Verilog.
Sometimes, though, it helps for formalism of expression to first implement
something like this in C++.  Hence, we’ll use the following C++ code to
illustrate how a FIFO works.&lt;/p&gt;

&lt;p&gt;First, we’ll declare what we stated above: our FIFO will have three operations.
These are reset, write, and read.  We’ll also want to be able to query how
many items are in the FIFO.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;FIFO&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;bool&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;m_overflow&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m_underflow&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;	&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_mem&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m_len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m_rdaddr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m_wraddr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;FIFO&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lglength&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;c1&quot;&gt;// On any allocation of a new FIFO,
&lt;/span&gt;		&lt;span class=&quot;c1&quot;&gt;// allocate memory to hold our buffer,
&lt;/span&gt;		&lt;span class=&quot;c1&quot;&gt;// and record how big the buffer is.
&lt;/span&gt;		&lt;span class=&quot;n&quot;&gt;m_len&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lglength&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;m_mem&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;reset&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

	&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;reset&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;write&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;item&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;read&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;fill&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Resetting the FIFO will simply set both read and write pointers back to zero.
It will also clear any error flags.  Note that we aren’t going to &lt;em&gt;clear&lt;/em&gt;
the memory here–mostly because we won’t be able to do that in Verilog very
easily later.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;FIFO&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;reset&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;// Reset our pointers to the beginning of the memory
&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;m_wraddr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m_rdaddr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;

	&lt;span class=&quot;c1&quot;&gt;// Reset the error flags to false
&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;m_overflow&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m_underflow&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;em&gt;Writing&lt;/em&gt; an item is almost as simple as setting the memory and incrementing
the pointer.  We’re going to add two more pieces to this logic, though.  The
first is required: the address of the next write pointer, &lt;code class=&quot;highlighter-rouge&quot;&gt;nxtaddr&lt;/code&gt; may need
to wrap around the buffer to be valid.  So, we’ll check that first.  Second,
if the newly calculated next write pointer, &lt;code class=&quot;highlighter-rouge&quot;&gt;nxtaddr&lt;/code&gt;, is equal to our read
address, that’s an indication that the buffer is full.  Here, we’ll cowardly
refuse to write to a full FIFO.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;c1&quot;&gt;// Produce an item / Write one item to the FIFO
&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;FIFO&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;write&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;item&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;// First, calculate the address of the next
&lt;/span&gt;	&lt;span class=&quot;c1&quot;&gt;// write pointer.
&lt;/span&gt;	&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nxtaddr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m_wraddr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

	&lt;span class=&quot;c1&quot;&gt;// Adjust for any wrapping around the ends of the buffer
&lt;/span&gt;	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nxtaddr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m_len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;nxtaddr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

	&lt;span class=&quot;c1&quot;&gt;// If this next pointer is the same as the read pointer,
&lt;/span&gt;	&lt;span class=&quot;c1&quot;&gt;// the FIFO is full: cowardly refuse to write to the FIFO
&lt;/span&gt;	&lt;span class=&quot;c1&quot;&gt;// in that casej
&lt;/span&gt;	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nxtaddr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m_rdaddr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;

		&lt;span class=&quot;c1&quot;&gt;// Actually write an item to the FIFO
&lt;/span&gt;		&lt;span class=&quot;n&quot;&gt;m_mem&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_wraddr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;item&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;m_wraddr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nxtaddr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;
		&lt;span class=&quot;c1&quot;&gt;// Set an error flag on any attempt to write to a full FIFO
&lt;/span&gt;		&lt;span class=&quot;n&quot;&gt;m_overflow&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;em&gt;Reading&lt;/em&gt; from the FIFO is just about as simple: we want to return the next
item in our buffer and increment the read pointer, wrapping if necessary.  As
before, though, there’s a twist: we only want to
increase our buffer pointer if the FIFO wasn’t empty.  Attempts to read from
an empty buffer should create an underflow (error) condition, while leaving
the FIFO empty.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;c1&quot;&gt;// Read/consume one item from the FIFO
&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;FIFO&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;read&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;item&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

	&lt;span class=&quot;c1&quot;&gt;// We&#39;ll return the next item to be read
&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;item&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m_mem&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_rdaddr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;

	&lt;span class=&quot;c1&quot;&gt;// Only consume if the FIFO is not empty
&lt;/span&gt;	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_rdaddr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m_wraddr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;

		&lt;span class=&quot;c1&quot;&gt;// Increment the read pointer
&lt;/span&gt;		&lt;span class=&quot;n&quot;&gt;m_rdaddr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

		&lt;span class=&quot;c1&quot;&gt;// Check to see if it wraps ppast the end of the buffer
&lt;/span&gt;		&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_rdaddr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m_len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;m_rdaddr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;m_underflow&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

	&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;item&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Finally, our last operation is to return the number of items found within this
FIFO.  This is given by the write pointer minus the read pointer, but done in
such a way as to never return anything less than zero or greater than the
size of our buffer.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;FIFO&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fill&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

	&lt;span class=&quot;n&quot;&gt;count&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m_wraddr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m_rdaddr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;count&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;count&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m_len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;In many ways, this set of operations isn’t really complete.  We haven’t returned
the number of empty (unused) values in the buffer, we haven’t created any
boolean values to return whether or not the buffer is non-empty, half-empty, or
half full, neither have we made any methods to read whether or not an error
condition has occurred.  We’ll leave these exercises to the student.&lt;/p&gt;

&lt;h1 id=&quot;first-verilog-cut&quot;&gt;First Verilog Cut&lt;/h1&gt;

&lt;p&gt;If we just tried to translate this C++ code to Verilog, we might end up with
the always block shown below:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;parameter	LGLEN = 8;
reg	[(LGLEN-1):0]	rdaddr, wraddr;
reg	[(INPUTWIDTH-1):0]	mem	[0:((1&amp;lt;&amp;lt;LGLEN)-1)];

always @(posedge i_clk)
	if (i_reset)
	begin
		rdaddr &amp;lt;= 0;
		wraddr &amp;lt;= 0;
		overrun  &amp;lt;= 0;
		underrun &amp;lt;= 0;
		o_fill   &amp;lt;= 0;
	end else if (i_write)
	begin
		if (wraddr + 1&#39;b1 != rdaddr)
		begin
			mem[wraddr] &amp;lt;= i_item;
			wraddr &amp;lt;= (wraddr + 1&#39;b1);
			o_fill   &amp;lt;= o_fill + 1&#39;b1;;
		end else
			overrun &amp;lt;= 1&#39;b1;
	end else if (i_read)
	begin
		if (wraddr != rdaddr) // If not empty
		begin
			o_item &amp;lt;= mem[wraddr]
			wraddr &amp;lt;= wraddr + 1&#39;b1;
			o_fill   &amp;lt;= o_fill - 1&#39;b1;;
		end else
			underrun &amp;lt;= 1&#39;b1;
	end /// Ooops!  What about ((i_write)&amp;amp;&amp;amp;(i_read))&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;With a little thought, it’s not too hard to see that this initial approach
is going to have some problems.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;What happens when a read and write request come in together?&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;wraddr + 1&#39;b1&lt;/code&gt; needs to be limited to &lt;code class=&quot;highlighter-rouge&quot;&gt;N&lt;/code&gt; bits, otherwise we don’t get the
proper wrap around the end of the buffer effect.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;We’ll need to make some changes therefore.&lt;/p&gt;

&lt;h1 id=&quot;next-verilog-cut&quot;&gt;Next Verilog Cut&lt;/h1&gt;

&lt;p&gt;Let’s see if we can’t improve on our first attempt to write the Verilog
code for a FIFO with four basic changes.&lt;/p&gt;

&lt;p&gt;The first change we’ll make is to separate the read and write tasks, and
likewise the various variables, into separate always blocks.  This will
make it easier to handle concurrent reads and writes.&lt;/p&gt;

&lt;p&gt;Our second change will be to capture the logic associated with testing whether
or not the FIFO is full or empty into two flags: &lt;code class=&quot;highlighter-rouge&quot;&gt;full&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;empty&lt;/code&gt;.  This
will help us figure out how to optimize things later.&lt;/p&gt;

&lt;p&gt;Third, to deal with concurrent reading and writing, we’ll allow the following:
Concurrent reads and writes are allowed, as long as the FIFO isn’t empty.
This is to allow the memory a full clock to handle the write before the memory
is available to be read.&lt;/p&gt;

&lt;p&gt;Finally, we’ll separate the calculation of the number of items in the buffer
into its own logic section.&lt;/p&gt;

&lt;p&gt;So, to walk through the code, on every clock we will write to memory.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	mem[wraddr] &amp;lt;= i_item;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;If there’s no write taking place on this clock, the memory write will just
change the contents of an unused data item.&lt;/p&gt;

&lt;p&gt;Likewise on every clock we will read from memory and create one of our outputs.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	o_item &amp;lt;= mem[wraddr];&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;As with the memory write, if the FIFO isn’t being read on this clock then it
won’t hurt us to set the output anyway.&lt;/p&gt;

&lt;p&gt;Many FPGA’s will also allow you to gate
these memory operation for no additional logic cost, as in:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	if (i_write)
		mem[wraddr] &amp;lt;= i_item;
always @(posedge i_clk)
	if (i_read)
		o_item &amp;lt;= mem[wraddr];&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;While such gating may be useful, it’s not required in this example.&lt;/p&gt;

&lt;p&gt;The next step in writing to the FIFO is handling the FIFO write pointer,
&lt;code class=&quot;highlighter-rouge&quot;&gt;wraddr&lt;/code&gt;.
Since the logic used to adjust the FIFO write pointer is almost identical to the
logic to adjust the overrun flag, we’ll place the two into the same always
block.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	if (i_reset)
	begin
		wraddr &amp;lt;= 0;
		overrun  &amp;lt;= 0;
	end else if (i_write)
	begin
		// Update the FIFO write address any time a write is made to
		// the FIFO and it&#39;s not FULL.
		//
		// OR any time a write is made to the FIFO at the same time a
		// read is made from the FIFO.
		if ((!full)||(i_read))
			wraddr &amp;lt;= (wraddr + 1&#39;b1);
		else
			overrun &amp;lt;= 1&#39;b1;
	end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Other than separating this into its own always blog, the biggest change between
this version and our prior one is the introduction of the &lt;code class=&quot;highlighter-rouge&quot;&gt;!full&lt;/code&gt; flag.  This
flag replaces the &lt;code class=&quot;highlighter-rouge&quot;&gt;(wraddr+1&#39;b1)!=rdaddr&lt;/code&gt; calculation from before.&lt;/p&gt;

&lt;p&gt;The other more subtle change is that we will now write to the FIFO any
time the FIFO is not full, &lt;em&gt;or&lt;/em&gt; any time the FIFO is full &lt;em&gt;and&lt;/em&gt; a read is
taking place on the same clock.&lt;/p&gt;

&lt;p&gt;The read address, &lt;code class=&quot;highlighter-rouge&quot;&gt;rdaddr&lt;/code&gt;, and &lt;code class=&quot;highlighter-rouge&quot;&gt;underrun&lt;/code&gt; error flag calculation below
follow a very similar form to that of the write address and overflow
calculation above.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;// Set wraddr and underrun
always @(posedge i_clk)
	if (i_reset)
	begin
		rdaddr &amp;lt;= 0;
		underrun &amp;lt;= 0;
	end else if (i_read)
	begin
		// On any read request, increment the pointer if the FIFO isn&#39;t
		// empty--independent of whether a write operation is taking
		// place at the same time.
		if (!empty)
			rdaddr &amp;lt;= rdaddr + 1&#39;b1;
		else
			// If a read is requested, but the FIFO was full, set
			// an underrun error flag.
			underrun &amp;lt;= 1&#39;b1;
	end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The big difference is that the FIFO must be non-empty to read, &lt;em&gt;even if&lt;/em&gt; a
write is taking place on the same clock.  This gives the memory a clock
to store the value, before trying to read it.&lt;/p&gt;

&lt;p&gt;The next and final trick is determining how full the FIFO is.&lt;/p&gt;

&lt;p&gt;You might be tempted to set &lt;code class=&quot;highlighter-rouge&quot;&gt;o_fill &amp;lt;= wraddr-rdaddr&lt;/code&gt; just like we did in our
C++ implementation.  This, however, doesn’t work.  Such a fill measure will
always be one clock out of date.&lt;/p&gt;

&lt;p&gt;Instead, we’ll count how many items are in our buffer as those items are
added or removed from the buffer.  That means, though, that we’ll need to pay
attention to not only the read and write request lines, but also whether or
not the FIFO is full or empty when the request is made.  This simple logic
fits nicely into a case statement.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;// Calculate the fill
always @(posedge i_clk)
	if (i_reset)
	begin
		o_fill &amp;lt;= 0;
	end else casez({ i_write, i_read, !full, !empty })
	4&#39;b01?1: o_fill &amp;lt;= o_fill - 1&#39;b1;	// A successful read
	4&#39;b101?: o_fill &amp;lt;= o_fill + 1&#39;b1;	// A successful write
	4&#39;b1100: o_fill &amp;lt;= o_fill + 1&#39;b1;	// Successful write, failed read
	// 4&#39;b11?1: Successful read *and* write -- no change
	default: o_fill &amp;lt;= o_fill;	// Default, no change
	endcase&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;That leaves as our final task determining whether or not the FIFO is full,
as well as what the next write address would be, were we to write to our FIFO
on this clock.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;assign	nxtaddr = wraddr + 1&#39;b1;
assign	full  = (nxtaddr == rdaddr);
assign	empty = (wraddr  == rdaddr);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The above approach should yield a working FIFO.&lt;/p&gt;

&lt;p&gt;It just won’t be a high speed FIFO, or a low logic FIFO implementation.&lt;/p&gt;

&lt;p&gt;The problem is specifically the cost of calculating &lt;code class=&quot;highlighter-rouge&quot;&gt;full&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;empty&lt;/code&gt;.
Remember when I discussed &lt;a href=&quot;/blog/2017-06-12-minimizing-luts.html&quot;&gt;keeping the conditions on an &lt;code class=&quot;highlighter-rouge&quot;&gt;if-then-else&lt;/code&gt; branch
simple&lt;/a&gt;?  We just
violated that rule.&lt;/p&gt;

&lt;p&gt;We’ll have to try again, therefore.&lt;/p&gt;

&lt;h1 id=&quot;high-speed-verilog-cut&quot;&gt;High Speed Verilog Cut&lt;/h1&gt;

&lt;p&gt;This time, let’s keep everything the same as before, with the exception of the
&lt;code class=&quot;highlighter-rouge&quot;&gt;full&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;empty&lt;/code&gt; flags.  Let’s spend some time focusing on those.&lt;/p&gt;

&lt;p&gt;The problem with these two flags is that they are calculated within the
nested if’s above.  Further, they are calculated within the nested if of a
large amount of logic, since each of the address lines sets &lt;code class=&quot;highlighter-rouge&quot;&gt;N&lt;/code&gt; bits.
What this means is that once the logic has been calculated, it then needs
to be distributed among many elements–an additional timing cost.&lt;/p&gt;

&lt;p&gt;We’ll solve this problem by pushing back the &lt;code class=&quot;highlighter-rouge&quot;&gt;full&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;empty&lt;/code&gt; logic one
clock earlier.  This will keep the &lt;code class=&quot;highlighter-rouge&quot;&gt;full&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;empty&lt;/code&gt; designations
synchronous to the actual state of the FIFO on any given clock.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;wire	[(N-1):0]	dblnext, nxtread;
assign	dblnext = wraddr + 2;
assign	nxtread = rdaddr + 1&#39;b1;

always @(posedge i_clk)
	if (reset)
	begin
		full &amp;lt;= 1&#39;b0;
		empty &amp;lt;= 1&#39;b1;
	end else casez({ i_write, i_read, !full, !empty })
	4&#39;b01?1: begin	// A successful read
		full  &amp;lt;= 1&#39;b0;
		empty &amp;lt;= (nxtread == wraddr);
		end
	4&#39;b101?: begin	// A successful write
		full &amp;lt;= (dblnext == rdaddr);
		empty &amp;lt;= 1&#39;b0;
	4&#39;b1100: begin	// Successful write, failed read
		full  &amp;lt;= 1&#39;b0;
		empty &amp;lt;= 1&#39;b0;
	default: begin end
	endcase&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;We’ll get a warning for adding a 32-bit number to an &lt;code class=&quot;highlighter-rouge&quot;&gt;N&lt;/code&gt; bit number when
calculating dblnext, but rather than complicating the logic to get rid of
the warning, we’ll leave it as is so you can see and understand what’s going
on.&lt;/p&gt;

&lt;p&gt;That’s it, though.  Now you know how to build a simple (application independent)
FIFO in Verilog.&lt;/p&gt;

&lt;h1 id=&quot;next-steps&quot;&gt;Next Steps&lt;/h1&gt;

&lt;p&gt;Knowing how to build a FIFO is really the first step in many steps.  It’s a
required part of many component designs, and so being able to build one
is a good skill to have.&lt;/p&gt;

&lt;p&gt;Indeed, now that we’ve discussed how to build a FIFO, we can return to our
&lt;a href=&quot;https://github.com/ZipCPU/dbgbus&quot;&gt;debugging bus&lt;/a&gt; and create an asynchronous
capabilities.  Such a capability will be required to demonstrate the pipeline
modes of the wishbone bus.&lt;/p&gt;

&lt;p&gt;If you ever want to reference other examples, you’ll find many FIFO
implementations posted on &lt;a href=&quot;https://opencores.org/projects&quot;&gt;OpenCores&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Strangely, from my own experience, I tend not to reuse the FIFO’s I’ve built
from one design need to the next.  Sure, the &lt;a href=&quot;https://github.com/ZipCPU/wbuart32/blob/master/rtl/ufifo.v&quot;&gt;FIFO I
built&lt;/a&gt; for a
&lt;a href=&quot;https://github.com/ZipCPU/wbuart32&quot;&gt;UART&lt;/a&gt; tends
to stay with that &lt;a href=&quot;https://github.com/ZipCPU/wbuart32&quot;&gt;UART&lt;/a&gt;, but the FIFO’s
I build for &lt;a href=&quot;https://github.com/ZipCPU/wbpmic&quot;&gt;audio&lt;/a&gt; or video tend to be
different from the &lt;a href=&quot;https://github.com/ZipCPU/wbuart32/blob/master/rtl/ufifo.v&quot;&gt;one for the
UART&lt;/a&gt;–even though
the design outline above is roughly the same.&lt;/p&gt;

&lt;p&gt;Instead, whenever I need a FIFO, I tend to copy from a working FIFO
and then adjust the code to fit my new needs.  The reason is simple: it seems
that every application requires a different interface to the FIFO.&lt;/p&gt;

&lt;p&gt;For example, a CPU will want to know from a
&lt;a href=&quot;https://github.com/ZipCPU/wbuart32/blob/master/rtl/wbuart.v&quot;&gt;UART receiver&lt;/a&gt;
how many items can be read (i.e. &lt;code class=&quot;highlighter-rouge&quot;&gt;o_fill&lt;/code&gt;), but from the transmitter it wants
to know how many items can be written to it (&lt;code class=&quot;highlighter-rouge&quot;&gt;N-1-ofill&lt;/code&gt;).  Likewise, the CPU
might wish to want until the receive queue is halfway full (&lt;code class=&quot;highlighter-rouge&quot;&gt;o_fill &amp;gt; N/2&lt;/code&gt;),
whereas the transmit FIFO would want to wait until the transmit queue is half
empty (&lt;code class=&quot;highlighter-rouge&quot;&gt;ofill &amp;lt; N/2-1&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;I guess this means that FIFO’s are one of the few places where the question
of whether the glass is half full or half empty becomes important.&lt;/p&gt;

&lt;p&gt;Another strange FIFO I’ve needed is the one to handle &lt;a href=&quot;https://github.com/ZipCPU/wb2axip&quot;&gt;AXI bus
requests&lt;/a&gt;.  In this case, instead of a
single set of read and write pointers, I’ve needed to use
multiple pointers so as to properly know where a transaction request is in
the process, and whether or not the AXI ready signals need to be dropped.&lt;/p&gt;

&lt;p&gt;The point is just that, in spite of the basics, FIFO’s tend to differ from
one context to another.&lt;/p&gt;

&lt;p&gt;Let me know your thoughts and experiences below!&lt;/p&gt;

</description>
        <pubDate>Sat, 29 Jul 2017 00:00:00 -0400</pubDate>
        <link>http://zipcpu.com/blog/2017/07/29/fifo.html</link>
        <guid isPermaLink="true">http://zipcpu.com/blog/2017/07/29/fifo.html</guid>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>Windows FPGA designers may not need a Linux machine ... yet</title>
        <description>&lt;p&gt;While I do all my work on a Linux platform, all of the OpenSource tools that I
use can be built and used under Windows just as well as under Linux.&lt;/p&gt;

&lt;p&gt;Here’s a set of FPGA tools that can also be used under Windows:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://veripool.org/wiki/verilator&quot;&gt;Verilator&lt;/a&gt; provides an integrated
simulation capability&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://gtkwave.sourceforge.net&quot;&gt;GTKWave&lt;/a&gt; provides a very useful trace
viewing capability.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The &lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt; toolchain also uses:
&lt;a href=&quot;https://www.gnu.org/binutils&quot;&gt;binutils&lt;/a&gt;,
&lt;a href=&quot;https://gcc.gnu.org&quot;&gt;GCC&lt;/a&gt;,
&lt;a href=&quot;https://sourceware.org/newlib&quot;&gt;newlib&lt;/a&gt;, and
&lt;a href=&quot;http://www.mr511.de/software&quot;&gt;libelf&lt;/a&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;I also use &lt;a href=&quot;https://www.gnu.org/software/ncurses&quot;&gt;ncurses&lt;/a&gt; for creating
textual displays, such as any of the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt; debuggers.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;When I need a home-made graphical capability, such as an OLED, VGA, or HDMI
simulator, &lt;a href=&quot;https://www.gtkmm.org&quot;&gt;GTKmm&lt;/a&gt; provides me with a nice platform
independent windowing library&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;At first glance, these might appear to be Linux-only applications.&lt;/p&gt;

&lt;p&gt;They aren’t.&lt;/p&gt;

&lt;p&gt;They can also run under Windows.&lt;/p&gt;

&lt;p&gt;Today, we’ll discuss how to get this toolchain working under Windows.&lt;/p&gt;

&lt;h2 id=&quot;cygwin-and-how-to-intall-it&quot;&gt;CygWin, and how to intall it&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://cygwin.com&quot;&gt;Cygwin&lt;/a&gt; is a program and set of libraries that can be
used on a Microsoft Windows machine to make it look, act, and feel like a
Linux system.&lt;/p&gt;

&lt;p&gt;We’ll use &lt;a href=&quot;https://cygwin.com&quot;&gt;Cygwin&lt;/a&gt; today to give us access to enough of a
Linux environment, so that we can then run
&lt;a href=&quot;https://veripool.org/wiki/verilator&quot;&gt;Verilator&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;You can find the &lt;a href=&quot;https://cygwin.com&quot;&gt;Cygwin&lt;/a&gt; install page
&lt;a href=&quot;https://cygwin.com/install.html&quot;&gt;here&lt;/a&gt;.  Go ahead and download the
software appropriate for your computer, whether 32 or 64-bit (if you don’t
know, download the 64-bit version).  Start the installer, and accept the
default configuration options until you get to the package page.&lt;/p&gt;

&lt;p&gt;The package page lists all of the programs that can be installed under
&lt;a href=&quot;https://cygwin.com&quot;&gt;Cygwin&lt;/a&gt;, and it lists them by category.  You might find
it daunting at first—there are a lot of packages to chose from. 
We’ll select the packages here that are necessary
to run &lt;a href=&quot;https://veripool.org/wiki/verilator&quot;&gt;Verilator&lt;/a&gt;,
&lt;a href=&quot;https://gtkwave.sourceforge.net&quot;&gt;GTKWave&lt;/a&gt;, and even the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt; compiler/toolchain.  We’ll also
grab some of the packages we may wish to have later in order to install either
&lt;a href=&quot;https://store.digilentinc.com/pmod-oledrgb-96-x-64-rgb-led-display-with-16-bit-color-resolution&quot;&gt;OLED&lt;/a&gt;
or VGA simulations.  You may need to use the search facility at the top of
the page to find the following packages–just don’t hit the return key until
you are done.&lt;/p&gt;

&lt;p&gt;Here’s our list of packages to enable:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;flex bison libtool make gcc-core gdb ddd ctags colorgcc gperf
libisl-devel libisl-doc libmpfr-devel libmpc-devel libmpc-doc
libgmp-devel libgmp-doc binutils automake autoconf autoconf2.5 automake1.15
libcairomm1.0_1-devel libcairomm1.0_1-doc libcairomm1.0_1-base
libelf-devel libncurses-devel
aspell-en enscript less source-highlight ghostscript gv
git git-gui svn patch dos2unix
tcl-devel tcl-tk tcl-tk-devel tcl-tck-iwidgets
gtk-doc libgtk2.0-devel libgtk2.0-doc libgtkmm2.4-doc libgtkmm2.4-devel
libgtk3-doc libgtkmm3.0-doc
xorg-server xorg-server-devel WindowMaker xterm
perl-doc&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;A lot of these packages have LaTeX based documentation.  If you want to be able
to rebuild that documentation, you may need to download LaTeX as well.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;texinfo texinfo-tex texlive texlive-collection-basic-doc
texlive-collection-latex texlive-collection-latex-doc
texlive-collection-latexextra  texlive-collection-latexextra-doc
texlive-collection-langenglish texlive-collection-pstricks
texlive-collection-pstricks-doc&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;If you find out later that you missed any packages, just restart the same
&lt;a href=&quot;https://cygwin.com&quot;&gt;Cygwin&lt;/a&gt; setup program that you just ran, but at that
later time when you know you need more packages.  You can then
repeat the configuration, but when you get to the package screen you can
add any packages you missed as though you were installing them initially.
&lt;a href=&quot;https://cygwin.com&quot;&gt;Cygwin&lt;/a&gt; will install only the changes, as you would like
it to.  Just … don’t forget where you put the
&lt;a href=&quot;https://cygwin.com&quot;&gt;Cygwin&lt;/a&gt; installer!&lt;/p&gt;

&lt;p&gt;Because we’re going to spend some time working on this machine as well, and
perhaps even need to do some real work, let’s add in some of my favorite
Linux packages to work with:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;hexchat putty gnome-terminal screen gvim meld
octave octave-devel octave-doc gnuplot
dia dia-shapes inkscape&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;These are my favorite editor, &lt;em&gt;gvim&lt;/em&gt;,
my favorite code-comparison tool, &lt;em&gt;meld&lt;/em&gt;,
my favorite IRC client, &lt;em&gt;hexchat&lt;/em&gt;,
and my favorite screen multiplexer, &lt;em&gt;screen&lt;/em&gt;.
Also included in this list is &lt;em&gt;octave&lt;/em&gt;, a free and open source package
offering a Matlab-like capability,
and &lt;em&gt;dia&lt;/em&gt;, a program for making quick vector graphics diagrams. 
I personally like &lt;em&gt;dia&lt;/em&gt;.  However you may find that you not only like
&lt;em&gt;inkspace&lt;/em&gt; better, but also that it is better maintained.&lt;/p&gt;

&lt;p&gt;While all of these may not be needed, this was the set I used to prove the
toolsuite I use.&lt;/p&gt;

&lt;p&gt;Once &lt;a href=&quot;https://cygwin.com&quot;&gt;Cygwin&lt;/a&gt; finishes installing, it’ll ask you if you
wish to place a cygwin icon on the desktop and in your start menu.  I
chose to accept the default, which was to say “yes” to both.  Then, to start
up the &lt;a href=&quot;https://cygwin.com&quot;&gt;Cygwin&lt;/a&gt; environment, you can just double click
on the &lt;a href=&quot;https://cygwin.com&quot;&gt;Cygwin&lt;/a&gt; icon that should now be on your desktop.
That will bring up a terminal window that we can then use for our next steps.&lt;/p&gt;

&lt;p&gt;Indeed, we are not done yet.  Though we have &lt;a href=&quot;https://cygwin.com&quot;&gt;Cygwin&lt;/a&gt;
installed, &lt;a href=&quot;https://cygwin.com&quot;&gt;Cygwin&lt;/a&gt; didn’t come with all of our favorite
packages, or the packages we need.  Specifically, neither
&lt;a href=&quot;https://www.veripool.org/wiki/verilator&quot;&gt;Verilator&lt;/a&gt; nor
&lt;a href=&quot;http://gtkwave.sourceforge.net&quot;&gt;GTKWave&lt;/a&gt; were on
&lt;a href=&quot;https://cygwin.com&quot;&gt;Cygwin&lt;/a&gt;’s list.  So, we’ll have to go back and get them
separately.&lt;/p&gt;

&lt;h2 id=&quot;installing-verilator&quot;&gt;Installing Verilator&lt;/h2&gt;

&lt;p&gt;The first FPGA support package to get is
&lt;a href=&quot;https://www.veripool.org/wiki/verilator&quot;&gt;Verilator&lt;/a&gt;.  We’ll start by grabbing
the sources for &lt;a href=&quot;https://www.veripool.org/wiki/verilator&quot;&gt;Verilator&lt;/a&gt;
from a tarball found on &lt;a href=&quot;https://www.veripool.org/projects/verilator/wiki/installing&quot;&gt;this
page&lt;/a&gt;.  In my
case, that tarball was named &lt;em&gt;verilator-3.904.tgz&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;The instructions for installing
&lt;a href=&quot;https://www.veripool.org/wiki/verilator&quot;&gt;Verilator&lt;/a&gt;, also found on that
&lt;a href=&quot;https://www.veripool.org/projects/verilator/wiki/installing&quot;&gt;same page&lt;/a&gt;,
are fairly simple.  At your command line, type:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;unset VERILATOR_ROOT
tar xvzf verilator*.t*gz
cd verilator\*
./configure
make
sudo make install&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Much to my surprise, this worked without any hassles.  (I was expecting things
to be harder.)&lt;/p&gt;

&lt;h2 id=&quot;installing-gtkwave&quot;&gt;Installing GTKWave&lt;/h2&gt;

&lt;p&gt;The next program we’ll install is &lt;a href=&quot;http://gtkwave.sourceforge.net&quot;&gt;GTKWave&lt;/a&gt;.
We’ll use this program later to view any traces &lt;a href=&quot;/blog/2017/06/21/looking-at-verilator.html&quot;&gt;created by
simulations&lt;/a&gt;
we might run and try.&lt;/p&gt;

&lt;p&gt;You can find &lt;a href=&quot;http://gtkwave.sourceforge.net&quot;&gt;GTKWave&lt;/a&gt; on it’s
&lt;a href=&quot;http://gtkwave.sourceforge.net&quot;&gt;sourceforge website&lt;/a&gt;.  On their front page,
they have a link to a source tarball.  In my case, that tarball was named
&lt;a href=&quot;http://gtkwave.sourceforge.net/gtkwave-3.3.81.tar.gz&quot;&gt;gtkwave-3.3.81.tar.gz&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;We’ll download this tarball and place it into our
&lt;a href=&quot;https://cygwin.com&quot;&gt;Cygwin&lt;/a&gt; home directory.  Once done, we can build
&lt;a href=&quot;http://gtkwave.sourceforge.net&quot;&gt;GTKWave&lt;/a&gt; simply with:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;tar -xvzf gtkwave-3.3.81.tar.gz
cd gtkwave-3.3.81/
./configure --disable-xz
make install&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;At this point, we’re &lt;em&gt;almost&lt;/em&gt; ready to try it.  One step remains.  We need to
start up the X-server.  We’ll start the server, and then start a window manager
(wmaker) and an xterm.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;X &amp;amp;
wmaker -display :0 &amp;amp;
xterm -display :0 &amp;amp;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This will create a large window on the display, and place a terminal within
it.  We can now simulate something with
&lt;a href=&quot;https://www.veripool.org/wiki/verilator&quot;&gt;Verilator&lt;/a&gt;,
and then display it from this window using
&lt;a href=&quot;http://gtkwave.sourceforge.net&quot;&gt;GTKWave&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;running-a-serial-port-test&quot;&gt;Running a Serial Port Test&lt;/h2&gt;

&lt;p&gt;Now that we have everything installed, we need something to test to prove that
this install works.&lt;/p&gt;

&lt;p&gt;Perhaps the easiest package to test, and the package that offers a complete
end-to-end test case without requiring anything else,
is the &lt;a href=&quot;https://github.com/ZipCPU/wbuart32&quot;&gt;wbuart32&lt;/a&gt; serial
port package.  This package contains a complete &lt;a href=&quot;https://github.com/ZipCPU/wbuart32/blob/master/rtl/wbuart.v&quot;&gt;wishbone controlled UART
peripheral&lt;/a&gt;,
together with some &lt;a href=&quot;https://github.com/ZipCPU/wbuart32/tree/master/bench/verilog&quot;&gt;self-contained testing
programs&lt;/a&gt;–such
as &lt;a href=&quot;https://github.com/ZipCPU/wbuart32/blob/master/bench/verilog/helloworld.v&quot;&gt;Hello World&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;To run this test, we’ll first clone the git repository,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;git clone https://github.com/ZipCPU/wbuart32&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;and then we’ll change into the new directory we’ve just created.  From here,
we can build the distro.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;cd wbuart32 ; make&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This will also run a UART simulation test, just to prove that the package
works.&lt;/p&gt;

&lt;p&gt;Once the build and test bench have completed, we’ll move into the C++ test
directory and run the &lt;a href=&quot;https://github.com/ZipCPU/wbuart32/blob/master/bench/cpp/helloworld.cpp&quot;&gt;Hello
World&lt;/a&gt;
program on its own.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;cd bench/cpp
./helloworld&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;If all works well, you should see the “Hello, World!” characters printed
across your screen, and then the program should exit.&lt;/p&gt;

&lt;p&gt;Now if you look in your directory (type ‘ls’), you should be able to find a
“helloworld.vcd” file.  This is a 
&lt;a href=&quot;https://en.wikipedia.org/wiki/Value_change_dump&quot;&gt;value-change-dump&lt;/a&gt; type of
file, that contains
the value of every variable as it existed on every clock cycle within the
simulation we just ran.  Not bad, huh?&lt;/p&gt;

&lt;p&gt;Let’s start up &lt;a href=&quot;http://gtkwave.sourceforge.net&quot;&gt;GTKWave&lt;/a&gt;,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;gtkwave helloworld.vcd&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;and take a look at what we can find.&lt;/p&gt;

&lt;p&gt;If you’ve never used
&lt;a href=&quot;http://gtkwave.sourceforge.net&quot;&gt;GTKWave&lt;/a&gt; before, stay with me.
When I first started using &lt;a href=&quot;http://gtkwave.sourceforge.net&quot;&gt;GTKWave&lt;/a&gt;,
the opening screen left me confused.  It
was big and black with green lines and … didn’t do anything.&lt;/p&gt;

&lt;table style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 1: GTKWave, your first click&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/gtkwave-firstclick.png&quot; alt=&quot;Step one with gtkwave&quot; width=&quot;240&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Now that I’ve used it for some time, I no longer find it so confusing.  Just
go over to the left side of the screen.  There, in the top of two white panel’s,
will be the name of our top level module, TOP, with a plus beside it.  Go ahead
and click on it (the word TOP, not the plus yet).&lt;/p&gt;
&lt;table style=&quot;float: left; padding: 15px&quot;&gt;&lt;caption&gt;Fig 2: GTKWave, drag items to view&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/gtkwave-firstdrag.png&quot; alt=&quot;Dragging waveforms to view in GTKWave&quot; width=&quot;240&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;You’ll then see, listed in
the small panel below, all of the external I/O ports associated with our
design.  Let’s use the mouse to grab the clock register, &lt;code class=&quot;highlighter-rouge&quot;&gt;i_clk&lt;/code&gt;
and drag it to the display area.  Next, let’s grab the output serial port
register, &lt;code class=&quot;highlighter-rouge&quot;&gt;o_uart&lt;/code&gt;, and drag that to the display as well.&lt;/p&gt;

&lt;p&gt;Ok, so now you’ve got two green lines in the display.  We can do one better.&lt;/p&gt;

&lt;p&gt;While holding the control key down, scroll with the mouse wheel.  Go ahead
and scroll out until you see the &lt;code class=&quot;highlighter-rouge&quot;&gt;o_uart&lt;/code&gt; field changing.  You can then
move over to it and control scroll zoom-in and see what we just did, or simply
use the scroll button to move left or right in time.  Doing this, you should
be able to see the waveform shown in Fig. 3 below.&lt;/p&gt;

&lt;table style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 3: GTKWave: Hello World&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/gtkwave-hello.png&quot; alt=&quot;Hello World UART output in GTKWave&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;You can view other variables as well.  Just go back to that “TOP” value in
the upper left pane and click on the plus.  This will bring up the next
level down in your design.  You can then drag any the variables you are
interested in into the main green window and see how they line up with
the serial port and clock wires that we already added in.&lt;/p&gt;

&lt;p&gt;We’ll have to leave for another time, though, the further details of what’s
going on.  This is enough for the day as it is.&lt;/p&gt;

&lt;h2 id=&quot;the-power-of-the-simulator&quot;&gt;The power of the simulator&lt;/h2&gt;

&lt;p&gt;Before closing, let me just ask: do you realize the significance of what we’ve
just done?  We’ve just
ran a simulator as though it were a real FPGA.  The simulator talked to a
console port, just like any real serial port connected to an FPGA might have
done.  The great point here is that you can learn a lot about what it takes
to build and run logic using this simulator!&lt;/p&gt;

&lt;p&gt;Sure, it’s not quite the same thing as the real thing.  A real FPGA has
limits on the amount of logic that can take place between two clock pulses.
A real FPGA has a finite number of resources that can be assigned to your
logic.  A real FPGA would also need to match the baud rate on your terminal
program.  Still, simulation is one of the big things that will keep you from
&lt;a href=&quot;/fpga-hell.html&quot;&gt;FPGA Hell&lt;/a&gt;, and we’ve just shown you how you can simulate a
serial port.&lt;/p&gt;

&lt;p&gt;Feel free to write me if you have any struggles, or &lt;a href=&quot;https://www.patreon.com/ZipCPU&quot;&gt;support this blog on
Patreon&lt;/a&gt;, and get a vote into what I
write about next!&lt;/p&gt;
</description>
        <pubDate>Fri, 28 Jul 2017 00:00:00 -0400</pubDate>
        <link>http://zipcpu.com/blog/2017/07/28/cygwin-fpga.html</link>
        <guid isPermaLink="true">http://zipcpu.com/blog/2017/07/28/cygwin-fpga.html</guid>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>How to build a simulation based debugger for your own soft-core CPU</title>
        <description>&lt;p&gt;So you want to build a soft-core CPU?&lt;/p&gt;

&lt;p&gt;Have you given any thought to how you will test that CPU, or &lt;a href=&quot;/zipcpu/2017/07/14/cpu-debugging-needs.html&quot;&gt;how you will
debug the
programs&lt;/a&gt;
you are running within it?&lt;/p&gt;

&lt;p&gt;If you know &lt;a href=&quot;/blog/2017/06/23/my-dbg-philosophy.html&quot;&gt;my debugging
philosophy&lt;/a&gt;, you’ll
also know that I am a firm believer in simulation.  I like to use not only
&lt;a href=&quot;https://www.veripool.org/wiki/verilator&quot;&gt;Verilator&lt;/a&gt;
for simulating my cores, but also printf() and
&lt;a href=&quot;http://gtkwave.sourceforge.net&quot;&gt;GTKWave&lt;/a&gt;
for examining the results as I’ve discussed
&lt;a href=&quot;/blog/2017/06/21/looking-at-verilator.html&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Somehow, as with &lt;a href=&quot;/dsp/2017/07/22/dsp-debugging.html&quot;&gt;DSP
debugging&lt;/a&gt;,
these two approaches are insufficient when it comes to debugging a sort-core
CPU.  Another approach is needed.&lt;/p&gt;

&lt;p&gt;Therefore, this article will present a simpler approach to debugging a CPU
when using 
&lt;a href=&quot;https://www.veripool.org/wiki/verilator&quot;&gt;Verilator&lt;/a&gt;.
Sure, it will take a bit more work to set up, but I think you’ll find the result
well worth the effort when it comes time to debug your own CPU.&lt;/p&gt;

&lt;h2 id=&quot;debugger-overview&quot;&gt;Debugger Overview&lt;/h2&gt;

&lt;p&gt;You may remember from our discussion of CPU debuggers what the requirements
of a debugger in simulation are, shown in Fig 1.&lt;/p&gt;

&lt;table style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 1: Debugging a CPU in simulation&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/cpu-dbg-simulation.svg&quot; alt=&quot;CPU Debugging needs ... in simulation&quot; width=&quot;350&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Today, we’ll be focusing our efforts on building the interaction in the
&lt;em&gt;simulation&lt;/em&gt; column.&lt;/p&gt;

&lt;p&gt;What makes building a CPU debugger different from any other
&lt;a href=&quot;https://www.veripool.org/wiki/verilator&quot;&gt;Verilator&lt;/a&gt; based
simulation test harness, is the requirement that you may wish to examine the
CPU state after every clock tick.  It is this examination
that will be the primary focus of the discussion today.  Along the way,
we’ll show how to step the CPU by a single clock tick, as well as how to
generate trace information.  Stopping on a break point, though,
will require a handshake between your simulation and your CPU.&lt;/p&gt;

&lt;table style=&quot;float: left; padding: 15px&quot;&gt;&lt;caption&gt;Fig 2: Integrated Debugging&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/dbg-by-integrated-sim.svg&quot; alt=&quot;Integrated Debugging&quot; width=&quot;300&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;We’ll start with the code that we’ve written and 
&lt;a href=&quot;/blog/2017/06/21/looking-at-verilator.html&quot;&gt;discussed&lt;/a&gt;
for simulating an FPGA design while also simulating multiple peripherals.
We &lt;a href=&quot;/blog/2017/06/23/my-dbg-philosophy.html&quot;&gt;illustrated this concept&lt;/a&gt; before using Fig 2.
If you haven’t already built a simple
&lt;a href=&quot;/blog/2017/06/21/looking-at-verilator.html&quot;&gt;test harness&lt;/a&gt;
for your FPGA design,
you’ll want to put that functionality together before we start.  You don’t
have to make it work yet.  Building a Verilator based CPU debugger will
require some other modifications before getting there.&lt;/p&gt;

&lt;p&gt;Then, to that basic test harness, we’ll add an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Ncurses&quot;&gt;ncurses&lt;/a&gt;
display functionality, as outlined in Fig 3. below.  In this case, we’ll break
up the
Verilator
test harness
while loop, and add an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Ncurses&quot;&gt;ncurses&lt;/a&gt;
interface to it in order to achieve a debugging capability.&lt;/p&gt;

&lt;table style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 3: Structure of a Verilator CPU Debugger&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/vlator-debugger.svg&quot; alt=&quot;Pictorial image of a Verilaor Debugger&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;If you’ve never used the &lt;a href=&quot;https://www.gnu.org/software/ncurses&quot;&gt;ncurses library&lt;/a&gt;
before, it’s &lt;a href=&quot;http://invisible-island.net/ncurses/NCURSES-Programming-HOWTO.html#WHATIS&quot;&gt;really not all that
hard&lt;/a&gt;,
and it really simplifies building a textual debugger.&lt;/p&gt;

&lt;h2 id=&quot;loading-your-program&quot;&gt;Loading your program&lt;/h2&gt;

&lt;p&gt;The &lt;a href=&quot;https://www.gnu.org/software/ncurses&quot;&gt;ncurses library&lt;/a&gt; library is very
much about textual screen manipulation.  We’ll use that to place register
values on the screen, and to accept user input to control the simulation.&lt;/p&gt;

&lt;p&gt;However, before any screen manipulation, you’ll want to process any command
line arguments to your test harness program.  This includes finding and loading
any initial memory, whether into your
&lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/sim/verilated/qspiflashsim.cpp&quot;&gt;flash&lt;/a&gt; or
SDRAM simulator or other.&lt;/p&gt;

&lt;p&gt;In particular, if there’s any reason why your test program would need to end
on an error, it helps to find and handle those errors before starting the
&lt;a href=&quot;http://invisible-island.net/ncurses/NCURSES-Programming-HOWTO.html#INIT&quot;&gt;ncurses&lt;/a&gt;,
environment.  Once
&lt;a href=&quot;http://invisible-island.net/ncurses/NCURSES-Programming-HOWTO.html&quot;&gt;ncurses&lt;/a&gt;,
starts, we’ll need to be careful to make sure that your program &lt;em&gt;only&lt;/em&gt;
exits by way of the &lt;a href=&quot;http://invisible-island.net/ncurses/NCURSES-Programming-HOWTO.html#ABOUT-ENDWIN&quot;&gt;ncurses
endwin&lt;/a&gt;,
function before calling exit.&lt;/p&gt;

&lt;h2 id=&quot;starting-and-stopping-ncurses&quot;&gt;Starting and stopping ncurses&lt;/h2&gt;

&lt;p&gt;Once you are sure your test harness is ready to fire up your design,
then it’s time to start the
&lt;a href=&quot;http://invisible-island.net/ncurses/NCURSES-Programming-HOWTO.html#ABOUTINIT&quot;&gt;ncurses&lt;/a&gt;
screen environment.  &lt;a href=&quot;http://invisible-island.net/ncurses/NCURSES-Programming-HOWTO.html#ABOUTINIT&quot;&gt;Starting up 
ncurses&lt;/a&gt;
involves calling four basic functions:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;cp&quot;&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;ncurses.h&amp;gt;
&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(...)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;// Process arguments
&lt;/span&gt;	&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;// Initialize ncurses
&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;initscr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;raw&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;noecho&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;keypad&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;stdscr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;//
&lt;/span&gt;	&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The first of these functions,
&lt;a href=&quot;http://invisible-island.net/ncurses/NCURSES-Programming-HOWTO.html#ABOUT-INITSCR&quot;&gt;initscr()&lt;/a&gt;,
just initializes &lt;a href=&quot;https://en.wikipedia.org/wiki/Ncurses&quot;&gt;ncurses&lt;/a&gt;
and starts up the display.&lt;/p&gt;

&lt;p&gt;The 
&lt;a href=&quot;http://invisible-island.net/ncurses/NCURSES-Programming-HOWTO.html#RAWCBREAK&quot;&gt;raw()&lt;/a&gt;
function tells &lt;a href=&quot;https://en.wikipedia.org/wiki/Ncurses&quot;&gt;ncurses&lt;/a&gt;
that we don’t want any input buffering.  This will become
important later, as we’d like to be able to step the CPU one clock at a time
on a keypress, and we don’t want to have to wait for a return key along the way.&lt;/p&gt;

&lt;p&gt;If you want to be able to just hit a key and step the CPU, then you aren’t
really going to want that key displayed to the screen.  That’s the purpose
of the 
&lt;a href=&quot;http://invisible-island.net/ncurses/NCURSES-Programming-HOWTO.html#ECHONOECHO&quot;&gt;noecho()&lt;/a&gt; function call.&lt;/p&gt;

&lt;p&gt;Finally, the
&lt;a href=&quot;http://invisible-island.net/ncurses/NCURSES-Programming-HOWTO.html#KEYPAD&quot;&gt;keypad(stdscr, true)&lt;/a&gt;
command requests that all special characters (function keys, arrows, etc), be
sent to our processing loop just like everything else.&lt;/p&gt;

&lt;p&gt;The other part of the basic
&lt;a href=&quot;https://en.wikipedia.org/wiki/Ncurses&quot;&gt;ncurses&lt;/a&gt;
setup is stopping your simulation.  Once you finally get
to the end of your debugging and simulation session, then you are going to want
to call
&lt;a href=&quot;http://invisible-island.net/ncurses/NCURSES-Programming-HOWTO.html#ABOUT-ENDWIN&quot;&gt;endwin&lt;/a&gt;
to return your screen to normal, like it was before you started your simulator.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;n&quot;&gt;endwin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;If you get in trouble, you may find that typing&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;n&quot;&gt;stty&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sane&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;helps.  Modern terminals often have a reset terminal button that cna help as
well.&lt;/p&gt;

&lt;p&gt;That’s the basics of getting
&lt;a href=&quot;https://en.wikipedia.org/wiki/Ncurses&quot;&gt;ncurses&lt;/a&gt;
started, now let’s see if we can’t turn around and use it to help us
simulate this design.&lt;/p&gt;

&lt;h2 id=&quot;the-verilator-loop&quot;&gt;The Verilator Loop&lt;/h2&gt;

&lt;p&gt;Remember the &lt;a href=&quot;/blog/2017/06/21/looking-at-verilator.html&quot;&gt;previous Verilator test harness loop
function&lt;/a&gt;,
we built?  It looked something like:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(...)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;// ...
&lt;/span&gt;	&lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;done&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;tb&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tick&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;// ...
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;As you &lt;a href=&quot;/blog/2017/06/21/looking-at-verilator.html&quot;&gt;may recall from the Verilator
article&lt;/a&gt;,
this function then called a testbench method
which toggled our clock and provided any peripheral inputs:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;CPU&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_TB&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;// ...
&lt;/span&gt;	&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tick&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;m_tickcount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

		&lt;span class=&quot;c1&quot;&gt;// ... Handle peripheral inputs
&lt;/span&gt;
		&lt;span class=&quot;c1&quot;&gt;// Allow combinatorial logic to settle before toggling the
&lt;/span&gt;		&lt;span class=&quot;c1&quot;&gt;// clock
&lt;/span&gt;		&lt;span class=&quot;n&quot;&gt;m_core&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i_clk&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;m_core&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;eval&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_trace&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m_trace&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dump&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_tickcount&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

		&lt;span class=&quot;c1&quot;&gt;// Simulate the positive edge of the clock
&lt;/span&gt;		&lt;span class=&quot;n&quot;&gt;m_core&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i_clk&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;m_core&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;eval&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_trace&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m_trace&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dump&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_tickcount&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

		&lt;span class=&quot;c1&quot;&gt;// Simulate the negative edge of the clock
&lt;/span&gt;		&lt;span class=&quot;n&quot;&gt;m_core&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i_clk&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;m_core&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;eval&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_trace&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;m_trace&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dump&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_tickcount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;m_trace&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;flush&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
		&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
		&lt;span class=&quot;c1&quot;&gt;// ... Handle any debugging output requirements
&lt;/span&gt;	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;// ...
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This is going to be the first thing we’ll need to change.&lt;/p&gt;

&lt;p&gt;Specifically, we’re going to rebuild the inner loop portion of &lt;code class=&quot;highlighter-rouge&quot;&gt;main&lt;/code&gt; function.
The new inner loop is going to read a user keypress, and then its going to
process that keypress as you would like.  For demonstration purposes, we’ll
set this up so that:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;If the user types a control-L, the screen will redraw itself&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;If the user types an ‘r’, the CPU will restart&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;If he types a ‘q’, we’ll quit.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Finally, if the user types a &lt;code class=&quot;highlighter-rouge&quot;&gt;t&lt;/code&gt;, and only then, will we actually step the
CPU &lt;em&gt;by one clock only&lt;/em&gt;.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;cp&quot;&gt;#define	CTRL(X)	((X)&amp;amp;0x01f)
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;done&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;// Get a user command
&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;chv&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;getch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;

	&lt;span class=&quot;c1&quot;&gt;// Process the user&#39;s command
&lt;/span&gt;	&lt;span class=&quot;k&quot;&gt;switch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tolower&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;chv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;// Place any user keyboard commands you&#39;d like here.
&lt;/span&gt;	&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;// Some I use include:
&lt;/span&gt;	&lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CTRL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;&#39;L&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Redraw the screen on control-L
&lt;/span&gt;		&lt;span class=&quot;n&quot;&gt;redrawwin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;stdscr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;sc&quot;&gt;&#39;q&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Reset the CPU
&lt;/span&gt;		&lt;span class=&quot;n&quot;&gt;done&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;sc&quot;&gt;&#39;r&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Reset the CPU
&lt;/span&gt;		&lt;span class=&quot;n&quot;&gt;tb&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;reset&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;sc&quot;&gt;&#39;t&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Tick the CPU by one clock tick
&lt;/span&gt;		&lt;span class=&quot;c1&quot;&gt;// tb-&amp;gt;tick() toggles our clock,
&lt;/span&gt;		&lt;span class=&quot;c1&quot;&gt;// and sends CPU values to a trace file
&lt;/span&gt;		&lt;span class=&quot;n&quot;&gt;tb&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tick&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;default&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
		&lt;span class=&quot;c1&quot;&gt;// Either no keypress was available, or the
&lt;/span&gt;		&lt;span class=&quot;c1&quot;&gt;// user hit an accidental keypress.
&lt;/span&gt;		&lt;span class=&quot;c1&quot;&gt;//
&lt;/span&gt;		&lt;span class=&quot;c1&quot;&gt;// In either case: do nothing
&lt;/span&gt;	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

	&lt;span class=&quot;n&quot;&gt;tb&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;show_cpu_state&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The code above presents a couple of new functions.  These include
two new ncurses commands,
&lt;a href=&quot;http://invisible-island.net/ncurses/NCURSES-Programming-HOWTO.html#GETCHCLASS&quot;&gt;getch()&lt;/a&gt;
and redrawwin(stdscr).  They also include
some methods to add to our testbench.&lt;/p&gt;

&lt;p&gt;The first of these, &lt;a href=&quot;http://invisible-island.net/ncurses/NCURSES-Programming-HOWTO.html#GETCHCLASS&quot;&gt;getch()&lt;/a&gt;, simply returns a character from the terminal.
This function also hides a beginner bug.  Normally, after any change to the
screen, ncurses will require you to call
&lt;a href=&quot;http://invisible-island.net/ncurses/NCURSES-Programming-HOWTO.html#MYST-REFRESH&quot;&gt;refresh()&lt;/a&gt;
to update the screen.
The reality of ncurses is that none of the functions that write to the screen
actually send any output to the screen until
&lt;a href=&quot;http://invisible-island.net/ncurses/NCURSES-Programming-HOWTO.html#MYST-REFRESH&quot;&gt;refresh()&lt;/a&gt;
is called.  Hence, if you aren’t familiar with ncurses, you might get frustrated
when nothing gets written to your screen.
&lt;a href=&quot;http://invisible-island.net/ncurses/NCURSES-Programming-HOWTO.html#GETCHCLASS&quot;&gt;getch()&lt;/a&gt;
helps us avoid this error, by quietly calling
&lt;a href=&quot;http://invisible-island.net/ncurses/NCURSES-Programming-HOWTO.html#MYST-REFRESH&quot;&gt;refresh()&lt;/a&gt;
for us anytime we call
&lt;a href=&quot;http://invisible-island.net/ncurses/NCURSES-Programming-HOWTO.html#GETCHCLASS&quot;&gt;getch()&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The other command, redrawwin(stdscr), repaints the screen from scratch.  It’s
not normally necessary, but if some other program has written to your screen
you will enjoy the ability to refresh what’s on it.  Ctrl-L seems to be a
common key among other programs for this purpose, 
so we continue that capability here.&lt;/p&gt;

&lt;p&gt;You can also get creative in this main loop.  For example, if you know that
your CPU will have a problem &lt;code class=&quot;highlighter-rouge&quot;&gt;N&lt;/code&gt; clocks after reboot, you can run a simple
&lt;em&gt;for loop&lt;/em&gt; before entering this main while loop in order to skip those
&lt;code class=&quot;highlighter-rouge&quot;&gt;N&lt;/code&gt; clocks before starting your debugging session.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;c1&quot;&gt;//...
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;STARTUP_TICKS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;tb&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tick&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;done&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;// ...
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;For example, you might wish to skip the bootloader that copies data from
flash to memory, so you can debug your actual program.&lt;/p&gt;

&lt;p&gt;All in all, though, this while loop handles the logic necessary to step and
reset the CPU, as well as the
logic necessary to quit the simulation from the standpoint of the main loop. 
The big capability we are missing at this point is how to implement these
new testbench methods.&lt;/p&gt;

&lt;h2 id=&quot;the-testbench-class&quot;&gt;The Testbench Class&lt;/h2&gt;

&lt;p&gt;So let’s look at the test bench methods that will need to change.  From the
source above, we needed three functions: &lt;code class=&quot;highlighter-rouge&quot;&gt;reset()&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;show_cpu_state()&lt;/code&gt;, as
well as the &lt;code class=&quot;highlighter-rouge&quot;&gt;tick()&lt;/code&gt; function that we’ve already discussed.&lt;/p&gt;

&lt;p&gt;Of these three functions, &lt;code class=&quot;highlighter-rouge&quot;&gt;reset()&lt;/code&gt;, is the simplest to implement–assuming
your CPU has an input for a synchronous reset:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CPU_TB&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;reset&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;m_core&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i_reset&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;tick&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;m_core&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i_reset&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Showing the CPU’s state will take a bit more work.  The first step is to
find the variables and registers within
&lt;a href=&quot;https://www.veripool.org/wiki/verilator&quot;&gt;Verilator&lt;/a&gt;’s
variable set.  To do this, I usually browse the &lt;code class=&quot;highlighter-rouge&quot;&gt;*.h&lt;/code&gt; file found within the
&lt;a href=&quot;https://www.veripool.org/wiki/verilator&quot;&gt;Verilator&lt;/a&gt;
output directory.  (This defaults to &lt;code class=&quot;highlighter-rouge&quot;&gt;obj_dir/&lt;/code&gt;).  In the case of the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;, the register set
can be found in
&lt;a href=&quot;https://www.veripool.org/wiki/verilator&quot;&gt;Verilator&lt;/a&gt;’s
&lt;code class=&quot;highlighter-rouge&quot;&gt;v__DOT__thecpu__DOT__regset&lt;/code&gt; variable.  If you aren’t familiar with
&lt;a href=&quot;https://www.veripool.org/wiki/verilator&quot;&gt;Verilator&lt;/a&gt;’s
naming scheme, this is the name
&lt;a href=&quot;https://www.veripool.org/wiki/verilator&quot;&gt;Verilator&lt;/a&gt;
gives to the &lt;code class=&quot;highlighter-rouge&quot;&gt;regset&lt;/code&gt; array found
within the &lt;code class=&quot;highlighter-rouge&quot;&gt;thecpu&lt;/code&gt; module found at the top level.  Be aware that
&lt;a href=&quot;https://www.veripool.org/wiki/verilator&quot;&gt;Verilator&lt;/a&gt;
has recently changed its naming schemes, so you may have to look a bit.&lt;/p&gt;

&lt;p&gt;Now that I know where to find my register array, I can copy it to a local
variable where I can then use it:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;n&quot;&gt;CPU_TB&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;read_state_from_cpu&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;memcpy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_state&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m_core&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v__DOT__thecpu__DOT__regset&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;NREGS&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v__DOT__thecpu__DOT__regset&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]));&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Now that we know what our register values are, it’s time to place them onto
the screen.  The easiest way to do this is with the
&lt;a href=&quot;http://invisible-island.net/ncurses/NCURSES-Programming-HOWTO.html#GETCHCLASS&quot;&gt;mvprintw()&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Ncurses&quot;&gt;ncurses&lt;/a&gt;
command.  This command combines screen movement with a printf-like
interface.  Hence, we can write the values of all our registers to the
screen, as in:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;n&quot;&gt;CPU_TB&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;show_cpu_state&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;read_state_from_cpu&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;

	&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;16&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;mvprintw&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;20&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;R%2d: 0x%08x&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m_state&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Don’t get surprised: the coordinates are not in &lt;code class=&quot;highlighter-rouge&quot;&gt;x, y&lt;/code&gt; order, but rather
&lt;code class=&quot;highlighter-rouge&quot;&gt;y, x&lt;/code&gt; order.&lt;/p&gt;

&lt;p&gt;You can also get as fancy as you want in this step.  For example, I like to
look up the instruction memory at the program counter, and disassemble
the instructions in the CPU pipeline.&lt;/p&gt;

&lt;p&gt;In my case, it has gotten so that every time I need to debug a register
within the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;, I tend to just add another
&lt;a href=&quot;http://invisible-island.net/ncurses/NCURSES-Programming-HOWTO.html#GETCHCLASS&quot;&gt;mvprintw()&lt;/a&gt;
function call to my CPU-state display, so I can see how that new line
is being adjusted as the CPU runs.  The result looks something like Fig
4 below.&lt;/p&gt;

&lt;table style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 4: Debugging the ZipCPU in simulation&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/zipdbg-simtest.png&quot; alt=&quot;Snapshot of the ZipCPU simulation debugger&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Indeed, I have not only register sets and disassembled instruction words,
but also bus debugging information (&lt;code class=&quot;highlighter-rouge&quot;&gt;PFCACH&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;PF BUS&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;MEMBUS&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;SYSBSM&lt;/code&gt;,
etc), and pipeline stall information (see the &lt;code class=&quot;highlighter-rouge&quot;&gt;Ck&lt;/code&gt; at the far left).&lt;/p&gt;

&lt;p&gt;That’s just about it: you’ve now made all of the modifications you need to make
to turn your
&lt;a href=&quot;https://www.veripool.org/wiki/verilator&quot;&gt;Verilator&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/sim/verilator/testb.h&quot;&gt;test harness&lt;/a&gt; into a &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/sim/verilator/zippy_tb.cpp&quot;&gt;usable CPU debugger&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;compiling-with-ncurses&quot;&gt;Compiling with ncurses&lt;/h2&gt;

&lt;p&gt;Getting this test bench to compile shouldn’t be any more difficult than
getting any
&lt;a href=&quot;https://www.veripool.org/wiki/verilator&quot;&gt;Verilator&lt;/a&gt;
based test bench to compile, but with one significant
difference: You’ll need to add &lt;code class=&quot;highlighter-rouge&quot;&gt;-lncurses&lt;/code&gt; to your final compile to make
sure that the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Ncurses&quot;&gt;ncurses&lt;/a&gt;
library gets included.&lt;/p&gt;

&lt;h2 id=&quot;the-big-drawback-to-an-ncurses-based-display&quot;&gt;The big drawback to an ncurses based display&lt;/h2&gt;

&lt;p&gt;Having used a debugger of this form for a couple of years now, I find there
is one significant drawback to it: once you type ‘t’ and cause the simulator
to ‘tick’ the clock and step the processor forward by a single clock tick,
there’s no going back to look at the previous state.&lt;/p&gt;

&lt;p&gt;While I’ve dreamed of implementing a ‘back’ key, my
current approach is to do any further debugging with printf() and
&lt;a href=&quot;http://gtkwave.sourceforge.net&quot;&gt;GTKWave&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The problem with printf() based debugging at this point, though, is that
the screen is already being used.  While I suppose you could pipe the output
of an &lt;a href=&quot;https://en.wikipedia.org/wiki/Ncurses&quot;&gt;ncurses&lt;/a&gt;
based program into a file, the screen control keys that
&lt;a href=&quot;https://en.wikipedia.org/wiki/Ncurses&quot;&gt;ncurses&lt;/a&gt; uses
are likely going to keep it from being very legible.&lt;/p&gt;

&lt;p&gt;I get around this problem by adding some debugging functions to the &lt;code class=&quot;highlighter-rouge&quot;&gt;tick()&lt;/code&gt;
method.  Specifically, between every positive clock edge and the next,
I will dump any debugging information such as the program counter or register
set, to a debugging file so that I can look back later and understand
what just took place.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;n&quot;&gt;CPU_TB&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tick&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;// ...
&lt;/span&gt;	&lt;span class=&quot;c1&quot;&gt;// Provide any simulated inputs to your core here.
&lt;/span&gt;	&lt;span class=&quot;c1&quot;&gt;// ...
&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;// Tick the clock
&lt;/span&gt;	&lt;span class=&quot;c1&quot;&gt;// ...
&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;// Take a moment to write things to a debugging file, for after
&lt;/span&gt;	&lt;span class=&quot;c1&quot;&gt;// action tracing.  I just use fprintf&#39;s here.
&lt;/span&gt;	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_dbgfp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;fprintf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_dbgfp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Some useful information&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h2 id=&quot;other-things-you-can-do&quot;&gt;Other things you can do&lt;/h2&gt;

&lt;p&gt;If you haven’t figured it out yet, the moral of all of this story is that
&lt;a href=&quot;https://www.veripool.org/wiki/verilator&quot;&gt;Verilator&lt;/a&gt;
turns an FPGA debugging and development session into any other C++ program.
You can add functionality to this program just like you would any other.&lt;/p&gt;

&lt;p&gt;For example, here are some additional functions that you may find very useful:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Creating commands to simulate debugging the CPU via your chosen hardware
debugging interface.&lt;/p&gt;

    &lt;p&gt;On the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;, the step command is
implemented this way.  Typing an ‘s’ will
“step” the CPU by one instruction, using the same interface that will be
needed to control the CPU for debugging later.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;A “Go” until breakpoint command&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Perhaps I should describe how to use the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt; debugging simulator as an example
of this lesson?
It’s actually really fun to watch, since you can see what happens on each
pipeline step, when instructions need to stall, or even how the pipeline
fills behind a stalled instruction.&lt;/p&gt;

&lt;p&gt;Let me know what you think!&lt;/p&gt;
</description>
        <pubDate>Wed, 26 Jul 2017 00:00:00 -0400</pubDate>
        <link>http://zipcpu.com/zipcpu/2017/07/26/cpu-sim-debugger.html</link>
        <guid isPermaLink="true">http://zipcpu.com/zipcpu/2017/07/26/cpu-sim-debugger.html</guid>
        
        
        <category>zipcpu</category>
        
      </item>
    
      <item>
        <title>How to Debug a DSP algorithm</title>
        <description>&lt;p&gt;We’ve now written a &lt;a href=&quot;/dsp/2017/07/19/linear-upsampling.html&quot;&gt;linear upsampling
algorithm&lt;/a&gt;, and
discussed how to handle both &lt;a href=&quot;/dsp/2017/07/21/bit-growth.html&quot;&gt;bit
growth&lt;/a&gt; and
&lt;a href=&quot;/dsp/2017/07/22/rounding.html&quot;&gt;rounding&lt;/a&gt; within it.  It’s
now time to debug it, and prove that it does (or doesn’t) work.&lt;/p&gt;

&lt;p&gt;The problem I’ve always had at this point is that my favorite tools don’t
work very well for this task.&lt;/p&gt;

&lt;p&gt;My favorite tool for debugging my own programs has always been (f)printf().
Sure, I’ve used &lt;a href=&quot;https://www.gnu.org/software/gdb&quot;&gt;gdb&lt;/a&gt;, and even its
friendlier cousin &lt;a href=&quot;https://www.gnu.org/software/ddd&quot;&gt;ddd&lt;/a&gt;.  It’s just that
these two debuggers have not been my favorite tool.  (f)printf() is still my
favorite tool when it comes to debugging logic with
&lt;a href=&quot;https://www.veripool.org/wiki/verilator&quot;&gt;Verilator&lt;/a&gt;.
In the case of HDL, &lt;a href=&quot;http://gtkwave.sourceforge.net&quot;&gt;GTKWave&lt;/a&gt; comes in as a
close second.&lt;/p&gt;

&lt;p&gt;None of these approaches has ever worked well for me when debugging &lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_signal_processing&quot;&gt;Digital
Signal Processing (DSP)&lt;/a&gt;
algorithms like this &lt;a href=&quot;https://github.com/ZipCPU/interpolation/blob/master/rtl/lininterp/lininterp.v&quot;&gt;linear
interpolator&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;There’s just no substitute for the ability to plot waveforms, raw, processed,
and even partially processed, on an ad-hoc basis.  This ad-hoc capability
is available through &lt;a href=&quot;https://www.gnu.org&quot;&gt;GNU&lt;/a&gt;’s
&lt;a href=&quot;https://www.gnu.org/software/octave&quot;&gt;Octave&lt;/a&gt;,
&lt;a href=&quot;https://www.mathworks.com&quot;&gt;Matlab&lt;/a&gt;, and to some extent with 
&lt;a href=&quot;http://www.gnuplot.info&quot;&gt;gnuplot&lt;/a&gt;.  Of these three, my favorite has been
&lt;a href=&quot;https://www.gnu.org/software/octave&quot;&gt;Octave&lt;/a&gt;–mostly because I cannot
afford &lt;a href=&quot;https://www.mathworks.com&quot;&gt;Matlab&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;In this post, we’ll return to examining our
&lt;a href=&quot;https://github.com/ZipCPU/interpolation/blob/master/rtl/lininterp/lininterp.v&quot;&gt;linear interpolator&lt;/a&gt;, 
but this time we’ll place it within a &lt;a href=&quot;https://github.com/ZipCPU/interpolation/blob/master/rtl/lininterp/lininterp.cpp&quot;&gt;test
harness&lt;/a&gt;
to find out whether or not it works, and to see why or why not.&lt;/p&gt;

&lt;p&gt;This &lt;a href=&quot;https://github.com/ZipCPU/interpolation/blob/master/rtl/lininterp/lininterp.cpp&quot;&gt;test harness&lt;/a&gt;
is the topic of this post.&lt;/p&gt;

&lt;h2 id=&quot;test-points&quot;&gt;Test Points&lt;/h2&gt;

&lt;p&gt;We know what we want our &lt;a href=&quot;https://github.com/ZipCPU/interpolation/blob/master/rtl/lininterp/lininterp.v&quot;&gt;linear
interpolator&lt;/a&gt;
to do.  &lt;a href=&quot;https://en.wikipedia.org/wiki/Linear_interpolation&quot;&gt;That theory&lt;/a&gt; was
well developed before we started.  Hence, no &lt;em&gt;validation&lt;/em&gt; is required.  What we
want to know instead is whether or not our &lt;a href=&quot;https://github.com/ZipCPU/interpolation/blob/master/rtl/lininterp/lininterp.v&quot;&gt;linear
interpolator&lt;/a&gt;
is coming up with the right answers.  That is, we want to &lt;em&gt;verify&lt;/em&gt; that our
Verilog logic works.&lt;/p&gt;

&lt;p&gt;The easiest way to find any errors within our logic is going to be to build a
&lt;a href=&quot;https://github.com/ZipCPU/interpolation/blob/master/rtl/lininterp/lintest.m&quot;&gt;duplicate set of logic&lt;/a&gt;
to do the &lt;em&gt;exact&lt;/em&gt; same thing, and then to compare the results to see if they
match.  While the approach isn’t perfect, the likelihood that both test
fixture &lt;em&gt;and&lt;/em&gt; system under test will be in error is much smaller than just
the one being in error.&lt;/p&gt;

&lt;p&gt;That means we are going to need to know:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;The input(s) to our routine&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Any intermediate results calculated by the routine, such as the slope the
routine generated, and&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The output of the routine.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The trick is that all of these values need to be lined up together in order
for &lt;a href=&quot;https://www.gnu.org/software/octave&quot;&gt;Octave&lt;/a&gt;
to repeat the calculation and compare the result.&lt;/p&gt;

&lt;p&gt;This isn’t quite as simple as it sounds, particularly because the outputs of
the &lt;a href=&quot;https://github.com/ZipCPU/interpolation/blob/master/rtl/lininterp/lininterp.v&quot;&gt;linear
interpolator&lt;/a&gt;,
as we built it, aren’t evenly spaced every &lt;code class=&quot;highlighter-rouge&quot;&gt;N&lt;/code&gt; ticks apart, but rather they get
produced in groups or bunches.  Hence, when you look at them in 
&lt;a href=&quot;http://gtkwave.sourceforge.net&quot;&gt;GTKWave&lt;/a&gt;, you may easily struggle to “see”
the waveform is that the interpolator is actually producing, as seen in Fig 1
below.&lt;/p&gt;

&lt;table style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 1: GTKWave view of the interpolated signal&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/lininterp-gtkwave.png&quot; alt=&quot;Example GTKWave window showing the output of a linear interpolator&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;So, we’re going to add to our &lt;a href=&quot;https://github.com/ZipCPU/interpolation/blob/master/rtl/lininterp/lininterp.cpp&quot;&gt;test
harness&lt;/a&gt;
a quick capability to write a debugging file out.  We’ll write this file
as a series of 32-bit integer binary values–something
&lt;a href=&quot;https://www.gnu.org/software/octave&quot;&gt;Octave&lt;/a&gt; will have no problems ingesting.
For test purposes, we’ll also use some logic within the
&lt;a href=&quot;https://github.com/ZipCPU/interpolation/blob/master/rtl/lininterp/lininterp.v&quot;&gt;core&lt;/a&gt; 
to keep the &lt;a href=&quot;https://github.com/ZipCPU/interpolation/blob/master/rtl/lininterp/lininterp.cpp&quot;&gt;test
harness&lt;/a&gt;
test points aligned.&lt;/p&gt;

&lt;p&gt;Our goal will be to produce two data sets, using
&lt;a href=&quot;https://www.gnu.org/software/octave&quot;&gt;Octave&lt;/a&gt;,
and to plot them one on top of the other.  The first line on the graph will
be our alternate calculation, done within
&lt;a href=&quot;https://www.gnu.org/software/octave&quot;&gt;Octave&lt;/a&gt;,
showing what the linear interpolators result &lt;em&gt;should&lt;/em&gt; be.  The second line
will plot what the result &lt;em&gt;actually is&lt;/em&gt;.  If the two functions
lie on top of each other, then we’ll know our algorithm works.&lt;/p&gt;

&lt;h2 id=&quot;the-test-harness&quot;&gt;The Test Harness&lt;/h2&gt;

&lt;p&gt;Let’s look through how the &lt;a href=&quot;https://github.com/ZipCPU/interpolation/blob/master/rtl/lininterp/lininterp.cpp&quot;&gt;test
harness&lt;/a&gt;
for this &lt;a href=&quot;https://github.com/ZipCPU/interpolation/blob/master/rtl/lininterp/lininterp.v&quot;&gt;linear
interpolator&lt;/a&gt;
is put together.  While in many ways it’s just like any other
&lt;a href=&quot;https://www.veripool.org/wiki/verilator&quot;&gt;Verilator&lt;/a&gt;
based test harness, one thing that makes it very unique is what happens
&lt;em&gt;after&lt;/em&gt; the clock tick.  To keep this simple, we’ll work in broad brush
strokes to explain how this works, skipping large portions of it.  If this
gets confusing, please look back at our &lt;a href=&quot;/blog/2017/06/21/looking-at-verilator.html&quot;&gt;first Verilator
tutorial&lt;/a&gt;, or
even the &lt;a href=&quot;https://github.com/ZipCPU/interpolation/blob/master/rtl/lininterp/lininterp.cpp&quot;&gt;test
harness&lt;/a&gt;
itself to see what’s going on.&lt;/p&gt;

&lt;p&gt;To set this up, at the beginning of &lt;a href=&quot;https://github.com/ZipCPU/interpolation/blob/master/rtl/lininterp/lininterp.cpp&quot;&gt;the test
harness&lt;/a&gt;’s
main routine, I created a debugging output file and pointer:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt;   &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;    &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;DBGFNAME&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;dbgfp.32t&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;FILE&lt;/span&gt;    &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dbg_fp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;dbg_fp&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fopen&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;DBGFNAME&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;w&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This file will also need to get closed when we’re all done.&lt;/p&gt;

&lt;p&gt;Second, it turns out that picking the right interpolation frequency is
rather important.  You want your input clock to be fairly low, and your
output clock fairly high if you want to make the pretty looking pictures below.
Testing with an output clock rate very near the input clock rate can also be
very useful and instructive as well, it just tends to be harder to understand
the results.&lt;/p&gt;

&lt;p&gt;For this &lt;a href=&quot;https://github.com/ZipCPU/interpolation/blob/master/rtl/lininterp/lininterp.cpp&quot;&gt;test
harness&lt;/a&gt;,
I set the input sample rate to be one input sample for every forty clock ticks.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;iclocks&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;40&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Third, we need to pick a signal to evaluate.  I chose a sine wave.  I set this
to be at a fairly low frequency, 24 input samples per wavelength, because it
will help to reveal any problems with our interpolator.  Higher frequencies
may also help, but they’ll test and reveal a different set of errors.&lt;/p&gt;

&lt;p&gt;The sine wave function call takes place between one input sample and the next.
To create the desired frequency, we’ll step the phase forward by some angle
on every input sample.  In the &lt;a href=&quot;https://github.com/ZipCPU/interpolation/blob/master/rtl/lininterp/lininterp.cpp&quot;&gt;test
harness&lt;/a&gt;
code snippet below, I have called this step &lt;code class=&quot;highlighter-rouge&quot;&gt;dphase&lt;/code&gt;, for a &lt;em&gt;phase difference&lt;/em&gt;
or phase step.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;c1&quot;&gt;// dphase is the phase increment of our test sinewave.  It&#39;s really
// represented by a phase step, rater than a frequency.  The phase
// step is how many radians to advance on each SYSTEM clock pulse
// (not input sample pulse).  This difference just makes things
// easier to track later.
&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// double	dphase = 1 / (double)iclocks / 260.0, dtheta = 0.0;
&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;dphase&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;iclocks&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;24.0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dtheta&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;DPHASE = %f&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dphase&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(...)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;

	&lt;span class=&quot;c1&quot;&gt;// As well as the phase of the simulated input sinewave
&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;dtheta&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dtheta&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dphase&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dtheta&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;1.0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;dtheta&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-=&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;1.0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

	&lt;span class=&quot;c1&quot;&gt;// Do I need to produce a new input sample to be interpolated?
&lt;/span&gt;	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;inow&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;iclocks&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;
		&lt;span class=&quot;c1&quot;&gt;// Calculate a new test sample via a sine wave
&lt;/span&gt;		&lt;span class=&quot;n&quot;&gt;rv&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cos&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;2.0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;M_PI&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dtheta&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
		&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Notice how &lt;code class=&quot;highlighter-rouge&quot;&gt;dphase&lt;/code&gt; increments the actual phase, &lt;code class=&quot;highlighter-rouge&quot;&gt;dtheta&lt;/code&gt; (double valued
theta).  Further, any time &lt;code class=&quot;highlighter-rouge&quot;&gt;dtheta&lt;/code&gt; wraps, we just subtract one to keep it
between zero and one.  Then, when an input sample is required, we use this
phase as an input to the cosine function.&lt;/p&gt;

&lt;p&gt;Fourth, there’s no reason to run this simulation until your PC needs to be
rebooted.  Hence, we’ll only look at a finite number of clock ticks before
halting our simulation:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;clocks&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MAXTICKS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;clocks&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Finally, the real important part of any &lt;a href=&quot;https://github.com/ZipCPU/interpolation/blob/master/rtl/lininterp/lininterp.cpp&quot;&gt;DSP
debugger&lt;/a&gt;,
in &lt;a href=&quot;https://www.veripool.org/wiki/verilator&quot;&gt;Verilator&lt;/a&gt;
(or any C++ algorithm for that matter), is to output values that
you can then ingest into &lt;a href=&quot;https://www.gnu.org/software/octave&quot;&gt;Octave&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;For our example, we’ll pick the inputs and outputs of the &lt;a href=&quot;https://github.com/ZipCPU/interpolation/blob/master/rtl/lininterp/lininterp.v&quot;&gt;linear
interpolator&lt;/a&gt;,
together with four internal values.  These will all be converted to signed
32-bit integers, and dumped to a file: six outputs at a time.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;c1&quot;&gt;// If the core is producing an output, then let&#39;s examine
// what went into it, and what it&#39;s calculations were.
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tb&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;o_ce&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;// We&#39;ll record six values
&lt;/span&gt;	&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;vals&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;6&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;

	&lt;span class=&quot;c1&quot;&gt;// Capture, from the core, the values to send to
&lt;/span&gt;	&lt;span class=&quot;c1&quot;&gt;// our binary debugging file
&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;vals&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tb&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i_data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;vals&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tb&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;o_data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;vals&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tb&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;o_last&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;vals&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tb&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;o_next&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;vals&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tb&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;o_slope&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;vals&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tb&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;o_offset&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

	&lt;span class=&quot;c1&quot;&gt;// Sign extend these values first
&lt;/span&gt;	&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;

	&lt;span class=&quot;c1&quot;&gt;// Write these to the debugging file
&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;fwrite&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vals&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;6&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dbg_fp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

	&lt;span class=&quot;c1&quot;&gt;// Just to prove we are doing something useful, print
&lt;/span&gt;	&lt;span class=&quot;c1&quot;&gt;// results out.  These tend to be incomprehensible to
&lt;/span&gt;	&lt;span class=&quot;c1&quot;&gt;// me in general, but I like seeing them because they
&lt;/span&gt;	&lt;span class=&quot;c1&quot;&gt;// convince me that something&#39;s going on.
&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;%8.2f: %08x, %08x, (%08x, %08x)&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;rv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tb&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i_data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tb&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;o_data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;vals&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;vals&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;You’ll see in the next section, when we discuss the
&lt;a href=&quot;https://www.gnu.org/software/octave&quot;&gt;Octave&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/interpolation/blob/master/rtl/lininterp/lintest.m&quot;&gt;test script&lt;/a&gt;,
why we chose a constant number of values, and a common type for all of these
same values.&lt;/p&gt;

&lt;h2 id=&quot;the-octave-script&quot;&gt;The Octave Script&lt;/h2&gt;

&lt;p&gt;The first step to processing this data within 
&lt;a href=&quot;https://www.gnu.org/software/octave&quot;&gt;Octave&lt;/a&gt;
is to load the information into
&lt;a href=&quot;https://www.gnu.org/software/octave&quot;&gt;Octave&lt;/a&gt;.
You’ll notice that all of the data we produced was uniform in
type, and all of the records had the same number of samples, six.  This
makes loading the file into octave very easy.  Indeed, it’s so easy that
I usually do it by hand for the first several rounds of debugging, before
I turn it into &lt;a href=&quot;https://github.com/ZipCPU/interpolation/blob/master/rtl/lininterp/lintest.m&quot;&gt;a script&lt;/a&gt;:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-matlab&quot; data-lang=&quot;matlab&quot;&gt;&lt;span class=&quot;n&quot;&gt;fid&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;fopen&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&#39;dbgfp.32t&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&#39;r&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;dat&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;fread&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,[&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;6&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;inf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&#39;int32&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;fclose&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;% Assign names to these values&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;i_data&lt;/span&gt;  &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dat&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,:);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;o_data&lt;/span&gt;  &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dat&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,:);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;o_last&lt;/span&gt;  &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dat&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,:);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;o_next&lt;/span&gt;  &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dat&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,:);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;o_slope&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dat&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,:);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;o_offset&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dat&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;6&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,:);&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;% We used 28 bits for our values internal to our simulation.  We&#39;d like to&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;% plot our sine wave here between +1 and -2.  Hence, we&#39;ll need to scale&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;% them by 1/2^27.&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;nbits&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;28&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;mxv&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;^&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nbits&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;I think if I needed multiple data types, I’d probably first promote values to
the largest type, and if that didn’t work I’d create multiple data files.&lt;/p&gt;

&lt;p&gt;Now that our data has been ingested into
&lt;a href=&quot;https://www.gnu.org/software/octave&quot;&gt;Octave&lt;/a&gt;,
let’s see if we can
&lt;a href=&quot;https://github.com/ZipCPU/interpolation/blob/master/rtl/lininterp/lintest.m&quot;&gt;redo the arithmetic&lt;/a&gt;
the FPGA is supposed to do, only this time in double precision math.&lt;/p&gt;

&lt;p&gt;In this case, all the required math was discussed in our
&lt;a href=&quot;/2017/07/19/linear-upsampling.html&quot;&gt;first post&lt;/a&gt;, so
here we just repeat it.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-matlab&quot; data-lang=&quot;matlab&quot;&gt;&lt;span class=&quot;n&quot;&gt;redo&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;o_last&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;o_next&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;o_last&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;o_offset&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mxv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;redo&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;redo&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mxv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;One key difference in this version, from the discussion of how to do this
within the FPGA, is the divide by &lt;code class=&quot;highlighter-rouge&quot;&gt;mxv*2&lt;/code&gt;.  This comes back to a bit growth
issue, but a fixed vs floating point version of it.  &lt;code class=&quot;highlighter-rouge&quot;&gt;o_offset&lt;/code&gt;, as &lt;a href=&quot;/2017/07/19/linear-upsampling.html&quot;&gt;you may
recall&lt;/a&gt;,
is an integer being used to represent a value between zero and one.
Hence, we need to divide it by its scale factor to turn it back into a floating
point value between zero and one.&lt;/p&gt;

&lt;p&gt;We’re also dividing our result, and indeed our input values as well, by &lt;code class=&quot;highlighter-rouge&quot;&gt;mxv&lt;/code&gt;
so that we can plot the result between more reasonable bounds.&lt;/p&gt;

&lt;p&gt;All that remains is to plot the results and see how well (or poorly) we did.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-matlab&quot; data-lang=&quot;matlab&quot;&gt;&lt;span class=&quot;nb&quot;&gt;plot&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i_data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mxv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&#39;b;Input Signal;&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;redo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&#39;r;Octave results;&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;o_data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mxv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&#39;g;Interpolated/Output Signal;&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;axis&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;([&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2501&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]);&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;grid&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;on&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;title&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&#39;Comparing output results to Octave calculated results&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;xlabel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&#39;Output Samples&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;ylabel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&#39;Units&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Plotting data like this will &lt;em&gt;really&lt;/em&gt; help you &lt;em&gt;see&lt;/em&gt; problems in your code,
and by seeing them, recognizing them will become easier to do.&lt;/p&gt;

&lt;h2 id=&quot;bugs-i-found&quot;&gt;Bugs I found&lt;/h2&gt;

&lt;p&gt;I really dislike sharing buggy code on this Blog.  Sorry.  As a result, I’m
not going to show how how I messed this up along the way. 
(My code always works the first time, right?)  Therefore, if you examine the
&lt;a href=&quot;https://github.com/ZipCPU/interpolation/blob/master/rtl/lininterp/lininterp.v&quot;&gt;linear interpolation example Verilog
code&lt;/a&gt;,
you’re not likely to find any bugs within it.  (I won’t put it past you,
though–as of today, I’ve only bench tested this component.)&lt;/p&gt;

&lt;p&gt;In reality, there were bugs within it when I first simulated it.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;The first bug I struggled with was a bit-width bug.&lt;/p&gt;

    &lt;p&gt;At several points during the linear interpolation algorithm, bits need to
be selected and &lt;a href=&quot;/dsp/2017/07/22/rounding.html&quot;&gt;even dropped&lt;/a&gt;.&lt;/p&gt;

    &lt;p&gt;When I first ran this test, I dropped some of the more significant bits
along the way.  The result looked &lt;em&gt;very&lt;/em&gt; &lt;em&gt;jumbled&lt;/em&gt;.   Further, since I was
trying to view a sinewave in
&lt;a href=&quot;http://gtkwave.sourceforge.net&quot;&gt;GTKWave&lt;/a&gt;,
they looked even more jumbled.  If you think you are
struggling with this problem at all, try increasing the bit width (there’s
a reason it’s set to 28 for this test), and backing away from full range to
see if it helps.&lt;/p&gt;

    &lt;p&gt;Because the number of input bits in our test is so large, this problem
can be see to have a clear signature (now) in Fig 2.&lt;/p&gt;

    &lt;table style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 2: Internal bit selects in error&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/lininterp-badbits.png&quot; alt=&quot;Linear interpolator bugs: errant bit selects&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

    &lt;p&gt;Once the algorithm works, you can remove any extra bits that were needed to
test and prove it.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Signed multiplies are different from unsigned multiplies&lt;/p&gt;

    &lt;p&gt;This was another of my problems.&lt;/p&gt;

    &lt;p&gt;If you aren’t familiar with this problem, the consider multiplying some
&lt;a href=&quot;https://en.wikipedia.org/wiki/Two&#39;s_complement&quot;&gt;two’s complement&lt;/a&gt; 3’bit
numbers together.  A &lt;code class=&quot;highlighter-rouge&quot;&gt;-2&lt;/code&gt; would be represented as &lt;code class=&quot;highlighter-rouge&quot;&gt;3&#39;b110&lt;/code&gt;.  Multiplying &lt;code class=&quot;highlighter-rouge&quot;&gt;-2&lt;/code&gt;
times &lt;code class=&quot;highlighter-rouge&quot;&gt;-2&lt;/code&gt; should be a six bit &lt;code class=&quot;highlighter-rouge&quot;&gt;-4&lt;/code&gt;, or &lt;code class=&quot;highlighter-rouge&quot;&gt;6&#39;b111100&lt;/code&gt; (Remember to
&lt;a href=&quot;/dsp/2017/07/21/bit-growth.html&quot;&gt;add the bit widths&lt;/a&gt;
of the inputs together to get the final bitwidth.)
However, if you use unsigned multiplication then &lt;code class=&quot;highlighter-rouge&quot;&gt;3&#39;b110&lt;/code&gt; (6) times
&lt;code class=&quot;highlighter-rouge&quot;&gt;3&#39;b110&lt;/code&gt; (6) is 6’b100100 (36) not 6’b111100.  See the difference?&lt;/p&gt;

    &lt;p&gt;You’ll notice this problem when everything works properly for positive
numbers, and then fails for negative numbers.  Indeed, if you ever see
a result where things work in sections but not entirely,
then you might want to check for this bug.&lt;/p&gt;

    &lt;table style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 3: Unsigned vs Signed Multiplication Error&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/lininterp-badsign.png&quot; alt=&quot;Unsigned vs Signed Multiplication Error&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

    &lt;p&gt;To fix this, I needed to declare the inputs to the multiply to be &lt;code class=&quot;highlighter-rouge&quot;&gt;signed&lt;/code&gt;
wire’s or registers.
I also needed to extend the unsigned time offset by a zero bit, to make
sure it had the right sign.  Once done, this bug cleared up as well.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;You can find the final working &lt;a href=&quot;https://github.com/ZipCPU/interpolation/blob/master/rtl/lininterp/lininterp.v&quot;&gt;linear interpolator
here&lt;/a&gt;. 
The two bugs listed above have been fixed.  As a result, the interpolator’s
test bench output now looks like Fig 4 below.&lt;/p&gt;

&lt;table style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 4: A Working Interpolator&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/lininterp-working.png&quot; alt=&quot;Working Linear Interpolator Output&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Not bad, huh?  In fact, it’s just the result we wanted.&lt;/p&gt;

&lt;h2 id=&quot;when-simulation-doesnt-match-realtiy&quot;&gt;When Simulation doesn’t Match Realtiy&lt;/h2&gt;

&lt;p&gt;Since I’ve only tested this linear interpolation core under simulation, there
may well be some residual problems if/when I try it on some actual hardware. 
It’s just a fact of life.&lt;/p&gt;

&lt;p&gt;If you ever find yourself in that situation, then just repeat the same test,
or one similar, but this time do it within the hardware itself.  Remember,
that was what your &lt;a href=&quot;/blog/2017/06/08/simple-scope.html&quot;&gt;internal
scope&lt;/a&gt; was for, right?&lt;/p&gt;

&lt;p&gt;You can also use the debugging method &lt;a href=&quot;/digilent/2017/05/29/fft-debugging.html&quot;&gt;discussed
here&lt;/a&gt;, should you
have problems where this works in simulation but not in hardware.  Further,
feel free to post any bugs below, or on the &lt;a href=&quot;https://github.com/ZipCPU/interpolation/issues&quot;&gt;issues
page&lt;/a&gt; for the
&lt;a href=&quot;https://github.com/ZipCPU/interpolation&quot;&gt;GitHub repo&lt;/a&gt;, and I’ll
fix anything you point out.&lt;/p&gt;

&lt;h2 id=&quot;lessons-learned&quot;&gt;Lessons Learned&lt;/h2&gt;

&lt;p&gt;This example should illustrate for you two important lessons:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;To determine if an FPGA algorithm is working, create another (similar)
non-FPGA algorithm and test the two against each other.&lt;/p&gt;

    &lt;p&gt;In this example, we compared an
&lt;a href=&quot;https://www.gnu.org/software/octave&quot;&gt;Octave&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/interpolation/blob/master/rtl/lininterp/lintest.m&quot;&gt;script&lt;/a&gt;’s
version of our interpolator (we called this &lt;code class=&quot;highlighter-rouge&quot;&gt;redo&lt;/code&gt;) with the outputs of our
&lt;a href=&quot;https://github.com/ZipCPU/interpolation/blob/master/rtl/lininterp/lininterp.v&quot;&gt;Verilog
interpolator&lt;/a&gt;.
When they matched, as in Fig 4 above, we knew the algorithm worked.&lt;/p&gt;

    &lt;p&gt;While this example accomplishes our needs for debugging a DSP algorithm,
the same approach can (in general) be applied to &lt;em&gt;many&lt;/em&gt; other FPGA
algorithms.
For example, you can find my &lt;a href=&quot;https://github.com/ZipCPU/wbuart32/tree/master/bench/cpp&quot;&gt;UART protocol validator here&lt;/a&gt;, my QSPI flash
&lt;a href=&quot;http://opencores.org/project,qspiflash&quot;&gt;validator here&lt;/a&gt;, and an
&lt;a href=&quot;https://github.com/ZipCPU/sdspi/tree/master/bench/cpp&quot;&gt;SD-Card SPI-based protocol validator here&lt;/a&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The easiest way of writing the logic twice with a DSP algorithm is to do
(and plot) the work within &lt;a href=&quot;https://www.gnu.org/software/octave&quot;&gt;Octave&lt;/a&gt;.&lt;/p&gt;

    &lt;p&gt;The neat thing about &lt;a href=&quot;https://www.gnu.org/software/octave&quot;&gt;Octave&lt;/a&gt;
is that you can plot various things in an ad-hoc manner.  Data can be
scaled, reshaped and resampled, Fourier transforms may be applied, axes
can be changed, labels adjusted, screen sizes changed, bit widths adjusted,
etc., all very quickly and easily.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;As an interesting side note, I once debugged the signal processing internal to
a two-way radio communications channel in a similar fashion to this.  This
approach really works very well.&lt;/p&gt;

&lt;p&gt;Feel free to share your own experiences below!&lt;/p&gt;

</description>
        <pubDate>Mon, 24 Jul 2017 00:00:00 -0400</pubDate>
        <link>http://zipcpu.com/dsp/2017/07/24/dsp-debugging.html</link>
        <guid isPermaLink="true">http://zipcpu.com/dsp/2017/07/24/dsp-debugging.html</guid>
        
        
        <category>dsp</category>
        
      </item>
    
      <item>
        <title>Rounding Numbers without Adding a Bias</title>
        <description>&lt;p&gt;Every time I’ve built a signal processing system, I’ve struggled with bit-width.
&lt;a href=&quot;/dsp/2017/07/21/bit-growth.html&quot;&gt;Bit width grows&lt;/a&gt; when you
apply a filter.  It grows when you add two streams together.  It grows when
you multiply your signal by an sine wave or a complex exponential.  Indeed,
&lt;a href=&quot;/dsp/2017/07/21/bit-growth.html&quot;&gt;bit growth&lt;/a&gt; alone can be
a challenge to keep track of.&lt;/p&gt;

&lt;p&gt;If you are not careful, you will make the problem worse like I first did when
you try to deal with it.&lt;/p&gt;

&lt;p&gt;You see, on my first
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt; &lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_signal_processing&quot;&gt;Digital
Signal Processing (DSP)&lt;/a&gt;
project, I just got rid of the bits I didn’t need by simply dropping them.  I’d
take the result of whatever arithmetic I had accomplished, and I’d only keep
the top &lt;code class=&quot;highlighter-rouge&quot;&gt;N&lt;/code&gt; bits.  Problem solved, right?&lt;/p&gt;

&lt;p&gt;Not quite.  While that approach kept the number of bits I was using in
bounds, it also created artifacts at DC that confused both myself and the
team of individuals I was working with.  Did the system really have an
uncontrolled DC bias?  Where did this bias come from?  Did we need better
analog filtering?  Better bias control up front?&lt;/p&gt;

&lt;p&gt;The answer was none of the above.  The problem was that I had not properly
handled dropping bits, although it took building
&lt;a href=&quot;https://github.com/ZipCPU/dblclockfft&quot;&gt;my own&lt;/a&gt; &lt;a href=&quot;https://en.wikipedia.org/wiki/Fast_Fourier_transform&quot;&gt;Fast Fourier Transform
(FFT)&lt;/a&gt; to realize I
had a problem.&lt;/p&gt;

&lt;p&gt;So let’s examine how to round numbers within an FPGA.
We’ll examine several forms of rounding, and look at how each of these
forms biases the result one way or another from true. Along the way, we’ll
use consider diagrams, similar Fig 1 below, to explain what’s happening.&lt;/p&gt;

&lt;table style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 1: The need for Rounding&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/rounding-tbd.svg&quot; alt=&quot;Outlining the rounding discussion&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;This figure shows a series of numbers, and a series of boxes.  The boxes
represent the incoming values, and the numbers above represent the possible
output values.  They are placed above the box where the operation would be
exact.&lt;/p&gt;

&lt;p&gt;If you look closer, you’ll notice that there are eight boxes per output
integer.  The boxes that line up exactly are under the arrows, and they are
also shown in color, to representing the integer they are assigned to. 
This leaves seven boxes between exact results that need to be determined.&lt;/p&gt;

&lt;p&gt;This is the issue of rounding.  When given a value (represented by one of
these boxes) between two integers, how shall it be mapped to one of the
integers above?  We’ll represent individual chosen mappings via color below,
so you can see and get a feel the concept.&lt;/p&gt;

&lt;p&gt;With this background, we can return to our question: how to go from
too many bits, to just the right number?&lt;/p&gt;

&lt;h1 id=&quot;go-for-easy-truncation&quot;&gt;Go for easy: truncation&lt;/h1&gt;

&lt;p&gt;The first way of dropping bits may be the easiest … just get rid of any
excess bits.  This was what I had done originally.  Consider, if you have
a data values &lt;code class=&quot;highlighter-rouge&quot;&gt;i_data&lt;/code&gt; coming in with &lt;code class=&quot;highlighter-rouge&quot;&gt;IWID&lt;/code&gt; (input width) bits, and you want
to create a data value with &lt;code class=&quot;highlighter-rouge&quot;&gt;OWID&lt;/code&gt; bits, why not just grab the top &lt;code class=&quot;highlighter-rouge&quot;&gt;OWID&lt;/code&gt; bits?&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;assign o_truncate = i_data[(IWID-1):(IWID-OWID)];&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;If you just want something quick and simple, this approach works.&lt;/p&gt;

&lt;p&gt;Well, sort of.&lt;/p&gt;

&lt;p&gt;Maybe not really.&lt;/p&gt;

&lt;p&gt;It’s what I used before I started working on an &lt;a href=&quot;https://github.com/ZipCPU/dblclockfft&quot;&gt;FFT
algorithm&lt;/a&gt;.  When I built my testbench
for the &lt;a href=&quot;https://github.com/ZipCPU/dblclockfft&quot;&gt;FFT&lt;/a&gt;, one of my inputs would
be a sine wave.  I expected as an output a single non-zero value at or near the
frequency of the sine wave.  While I got the value I was looking for at the
frequency of the sine wave, I also kept getting values at DC that didn’t make
sense to me.&lt;/p&gt;

&lt;p&gt;When I dug into this, I discovered that dropping bits in this fashion biases
the result by about a half of a bit in the negative direction.  If you consider
Fig 1 below, you can see this effect since it shows how the area covered by
each number is biased to the right of the number.&lt;/p&gt;

&lt;table style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 2: Truncation effects&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/rounding-bytruncation.svg&quot; alt=&quot;Effect of dropping bits by truncation&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;So it was working on this &lt;a href=&quot;https://github.com/ZipCPU/dblclockfft&quot;&gt;FFT algorithm&lt;/a&gt;
that sent me looking for alternatives.  The best explanation I found of the
various alternatives was on &lt;a href=&quot;https://en.wikipedia.org/wiki/Rounding&quot;&gt;wikipedia’s rounding
page&lt;/a&gt;.  Here, we’ll just explain
the types of rounding discussed &lt;a href=&quot;https://en.wikipedia.org/wiki/Rounding&quot;&gt;there&lt;/a&gt;,
and show some Verilog examples of how to do each.&lt;/p&gt;

&lt;h1 id=&quot;basic-rounding-round-half-up&quot;&gt;Basic rounding: Round half up&lt;/h1&gt;

&lt;p&gt;My next approach to dropping bits was to add a half.  This was the type of
rounding I learned to do as a child in grade school. 
&lt;a href=&quot;https://en.wikipedia.org/wiki/Rounding&quot;&gt;Wikipedia calls this&lt;/a&gt;
“round half up”.&lt;/p&gt;

&lt;p&gt;The Verilog code for doing this is nice, in that it only needs &lt;code class=&quot;highlighter-rouge&quot;&gt;OWID+1&lt;/code&gt; bits
to work on.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;assign	w_halfup = i_data[(IWID-1):0]
		+ { {(OWID){1&#39;b0}}, 1&#39;b1, {(IWID-OWID-1){1&#39;b0}} };
always @(posedge i_clk)
	o_halfup &amp;lt;= w_halfup[(IWID-1):(IWID-OWID)];&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Many of the other approaches we’ll discuss will require adding numbers to all
&lt;code class=&quot;highlighter-rouge&quot;&gt;IWID&lt;/code&gt; bits, so this approach turns out to be simpler than the other
rounding approaches below.&lt;/p&gt;

&lt;p&gt;While this approach worked a lot better, it still leaves a bias within the data
values.&lt;/p&gt;

&lt;table style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 3: Round Half-Up&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/rounding-halfup.svg&quot; alt=&quot;Round Half-Up&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;To understand what the problem is, consider the bins around our output numbers,
as shown in Fig 4 below:&lt;/p&gt;

&lt;table style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 4: Illustrating the problem with rounding&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/rounding-problem.svg&quot; alt=&quot;Illustrating the problem(s) with rounding&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;We might argue that every bin should be attached to the output value “nearest”
to it.&lt;/p&gt;

&lt;p&gt;That leaves the bins or boxes in the exact center, exactly located between
any two integer values.&lt;/p&gt;

&lt;p&gt;If you connect all those between bins to the integers
on the right, you’ll create the bias we saw in Fig 3.  Sure, it’s less than
the bias in Fig 2, bit its still a bias.&lt;/p&gt;

&lt;p&gt;On the other hand, if you connect all these in-between bins to the integer
values on the left (round half down), you’ll create a similar bias–only
in the other direction.&lt;/p&gt;

&lt;p&gt;Several types of rounding will fix this.&lt;/p&gt;

&lt;h1 id=&quot;round-towards-zero&quot;&gt;Round towards zero&lt;/h1&gt;

&lt;p&gt;One unbiased method of rounding is to round towards zero, shown in Fig 5 below.&lt;/p&gt;

&lt;table style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 5: Rounding towards zero&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/rounding-tozero.svg&quot; alt=&quot;Rounding towards zero&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;In this case, we select the integer nearest zero for our midpoint.&lt;/p&gt;

&lt;p&gt;Doing this in Verilog is simple, too:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;assign	w_tozero = i_data[(IWID-1):0] + , i_data[(IWID-1)],
			{(IWID-OWID-1){!i_data[(IWID-1)]}}};
always @(posedge i_clk)
	o_tozero &amp;lt;= w_tozero[(IWID-1):(IWID-OWID)];&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;An almost identical method is to round away from zero.  In this case, the
mid point values are assigned to the integer nearest them that is farthest
from zero.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;assign	w_fromzero = i_data[(IWID-1):0] + , !i_data[(IWID-1)],
			{(IWID-OWID-1){i_data[(IWID-1)]}}};
always @(posedge i_clk)
	o_fromzero &amp;lt;= w_fromzero[(IWID-1):(IWID-OWID)];&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The problem with these two approaches is that they will subtly change
the amplitude of your signal.&lt;/p&gt;

&lt;p&gt;Is there a better approach?&lt;/p&gt;

&lt;h1 id=&quot;convergent-rounding-round-half-to-even&quot;&gt;Convergent rounding: Round half to even&lt;/h1&gt;

&lt;p&gt;Thankfully, I didn’t need to invent a better approach.  Several solutions to the
rounding problem were already listed for me in a 
&lt;a href=&quot;https://en.wikipedia.org/wiki/Rounding&quot;&gt;Wikipedia&lt;/a&gt; article.&lt;/p&gt;

&lt;p&gt;The better approach that I have found is called convergent rounding, although
&lt;a href=&quot;https://en.wikipedia.org/wiki/Rounding#Round_half_to_even&quot;&gt;Wikipedia&lt;/a&gt; gives it many other names.
Perhaps “Round half to even” is the most
descriptive.  Convergent rounding starts out in an identical fashion to the
more traditional rounding (round half up), with the exception of when you are
at the exact half way point.  In that case, convergent rounding rounds towards
the nearest &lt;em&gt;even&lt;/em&gt; integer, as shown in Fig 6 below.&lt;/p&gt;

&lt;table style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 6: Convergent Rounding&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/rounding-toeven.svg&quot; alt=&quot;Illustrating convergent rouding&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;If you count the number of input bins assigned to each output integer, you’ll
notice that 0 gets 9 bins, 1 gets 7, 2 gets 9, etc.&lt;/p&gt;

&lt;p&gt;Likewise, the Verilog code to perform this operation is no more difficult
than rounding towards (or away from) zero.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;assign	w_convergent = i_data[(IWID-1):0]
			+ { {(OWID){1&#39;b0}},
				i_data[(IWID-OWID)],
				{(IWID-OWID-1){!i_data[(IWID-OWID)]}}};
always @(posedge i_clk)
	o_convergent &amp;lt;= w_convergent[(IWID-1):(IWID-OWID)];&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;You may notice that these last several forms of rounding required a single clock
delay to calculate the answer.  That extra clock is required to perform a
full word’s worth of addition.  This is the addition required to get the carry
to propagate through the entire input number.&lt;/p&gt;

&lt;p&gt;If you can’t afford the extra clock, consider just dropping the extra bit, as
in our first example.&lt;/p&gt;

&lt;p&gt;By the way, I’m not the only one who likes this approach.  According to the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Rounding#Round_half_to_even&quot;&gt;Wikipedia&lt;/a&gt;
article, it is the “default rounding mode used in &lt;a href=&quot;https://en.wikipedia.org/wiki/IEEE_754&quot;&gt;IEEE
754&lt;/a&gt; computing functions”.  Recognize
that standard?  &lt;a href=&quot;https://en.wikipedia.org/wiki/IEEE_754&quot;&gt;IEEE 754&lt;/a&gt; is the
standard that defines how floating point is done within your computer.&lt;/p&gt;

&lt;h1 id=&quot;the-dblclock-fft&quot;&gt;The DblClock FFT&lt;/h1&gt;

&lt;p&gt;In my motivation above, I mentiond the
&lt;a href=&quot;https://github.com/ZipCPU/dblclockfft&quot;&gt;FFT&lt;/a&gt; I had built earlier.  This
&lt;a href=&quot;https://github.com/ZipCPU/dblclockfft&quot;&gt;FFT&lt;/a&gt; is built a bit differently from a
lot of the other Verilog cores I’ve worked with and those I’ve come across. 
In particularly, the &lt;a href=&quot;https://github.com/ZipCPU/dblclockfft&quot;&gt;dblclockfft&lt;/a&gt;
project consists not in a Verilog core, but rather the
&lt;a href=&quot;https://github.com/ZipCPU/dblclockfft/blob/master/sw/fftgen.cpp&quot;&gt;C++ code&lt;/a&gt;
necessary to build a Verilog core.  This gives it the flexibility to build
any &lt;a href=&quot;https://github.com/ZipCPU/dblclockfft&quot;&gt;FFT&lt;/a&gt; size or bit-width you want.&lt;/p&gt;

&lt;p&gt;It’s also a bit of a niche product, since it takes two input samples per clock.&lt;/p&gt;

&lt;p&gt;In other words, &lt;a href=&quot;https://github.com/ZipCPU/dblclockfft&quot;&gt;dblclockfft&lt;/a&gt; can be
configured for arbitrary FFT sizes (subject to the amount of logic on your
device), incoming and outgoing bit widths, as well as the number of hardware
multiplies used internally.  It also allows you (internally) to configure
the type of rounding that will be used within the resulting algorithm.&lt;/p&gt;

&lt;p&gt;It was while testing &lt;a href=&quot;https://github.com/ZipCPU/dblclockfft&quot;&gt;this FFT core&lt;/a&gt;
that I noticed sinewaves going into the core were producing results on the
DC bin coming out.  The problem, when fully traced out, came down to rounding.
Using the &lt;a href=&quot;https://github.com/ZipCPU/dblclockfft/blob/master/sw/fftgen.cpp&quot;&gt;C++ core generator
program&lt;/a&gt;,
I then tested and compared multiple rounding
approaches against each other, and decided upon the convergent rounding
approach discussed above.  (That’s why the type of rounding can be configured
internally.)&lt;/p&gt;

&lt;p&gt;As a side note, with just a touch of care and feeding the
&lt;a href=&quot;https://github.com/ZipCPU/dblclockfft&quot;&gt;dblclockfft&lt;/a&gt; could be adjusted to
meet anyone’s
&lt;a href=&quot;https://en.wikipedia.org/wiki/Fast_Fourier_transform&quot;&gt;FFT&lt;/a&gt;
needs.  Want a single sample in per clock?  It’s &lt;em&gt;almost&lt;/em&gt;
there.  Want a real (vice complex)
&lt;a href=&quot;https://en.wikipedia.org/wiki/Fast_Fourier_transform&quot;&gt;FFT&lt;/a&gt;?
It only needs one additional module.
How about running an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Fast_Fourier_transform&quot;&gt;FFT&lt;/a&gt;?
in a non-pipelined mode, with only two hardware
multiplies required &lt;em&gt;in total&lt;/em&gt;, and the size cost turned into a block RAM cost? 
Most of the pieces are there for that as well.  In other words, with a &lt;a href=&quot;https://www.patreon.com/ZipCPU&quot;&gt;touch
of support&lt;/a&gt;, that &lt;a href=&quot;https://github.com/ZipCPU/dblclockfft&quot;&gt;FFT
project&lt;/a&gt; could be made &lt;em&gt;very&lt;/em&gt; generic.&lt;/p&gt;

&lt;h1 id=&quot;next-steps&quot;&gt;Next steps&lt;/h1&gt;

&lt;p&gt;This particular post is actually only one in a series of posts building up to a
working linear upsampling interpolator.  We’ve already discussed the basic
&lt;a href=&quot;/dsp/2017/07/19/linear-upsampling.html&quot;&gt;upsampling linear
interpolator&lt;/a&gt;, and
&lt;a href=&quot;/dsp/2017/07/21/bit-growth.html&quot;&gt;bit growth&lt;/a&gt; within it. 
Now that we understand rounding, our next step in building this
&lt;a href=&quot;https://github.com/ZipCPU/rtl/lininterp/lininterp.v&quot;&gt;interpolator&lt;/a&gt;
will be to discuss how to debug a DSP algorithm.&lt;/p&gt;

&lt;p&gt;Stick around, debugging the linear upsampler makes a great example of how to
&lt;a href=&quot;/dsp/2017/07/24/dsp-debugging.html&quot;&gt;debug a DSP algorithm&lt;/a&gt;.&lt;/p&gt;

</description>
        <pubDate>Sat, 22 Jul 2017 00:00:00 -0400</pubDate>
        <link>http://zipcpu.com/dsp/2017/07/22/rounding.html</link>
        <guid isPermaLink="true">http://zipcpu.com/dsp/2017/07/22/rounding.html</guid>
        
        
        <category>dsp</category>
        
      </item>
    
  </channel>
</rss>
