<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>The ZipCPU by Gisselquist Technology</title>
    <description>The ZipCPU blog, featuring how to discussions of FPGA and soft-core CPU design.  This site will be focused on Verilog solutions, using exclusively OpenSource IP products for FPGA design.  Particular focus areas include topics often left out of more mainstreeam FPGA design courses such as how to debug an FPGA design.
</description>
    <link>http://zipcpu.com/</link>
    <atom:link href="http://zipcpu.com/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Fri, 11 Aug 2017 08:43:12 -0400</pubDate>
    <lastBuildDate>Fri, 11 Aug 2017 08:43:12 -0400</lastBuildDate>
    <generator>Jekyll v3.0.1</generator>
    <image>
      <url>http://zipcpu.com/img/gt-rss.png</url>
      <title></title>
      <link></link>
    </image>
    
      <item>
        <title>A Simple ALU, drawn from the ZipCPU</title>
        <description>&lt;p&gt;Many digital logic design courses end with a discussion of how to build a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;.
The common lesson tends to focus on the &lt;a href=&quot;https://en.wikipedia.org/wiki/Arithmetic_logic_unit&quot;&gt;arithmetic logic unit
(ALU)&lt;/a&gt; as the work horse
within the center of the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Since &lt;a href=&quot;https://en.wikipedia.org/wiki/Arithmetic_logic_unit&quot;&gt;ALU&lt;/a&gt;’s
tend to be very simple, they are easy to look at and examine.&lt;/p&gt;

&lt;p&gt;For this post, we’ll look at the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/cpuops.v&quot;&gt;ALU&lt;/a&gt;
found within the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;.
Unlike many of the “classroom”
&lt;a href=&quot;https://en.wikipedia.org/wiki/Arithmetic_logic_unit&quot;&gt;ALU&lt;/a&gt;’s
you may have come across, this simple
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/cpuops.v&quot;&gt;ALU&lt;/a&gt;
is also complete enough to support the
&lt;a href=&quot;https://sourceware.org/newlib&quot;&gt;newlib C library&lt;/a&gt;.
As a result, you might find a couple of features within this
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/cpuops.v&quot;&gt;ALU&lt;/a&gt;
that you are not expecting.&lt;/p&gt;

&lt;h2 id=&quot;a-basic-alu&quot;&gt;A Basic ALU&lt;/h2&gt;

&lt;p&gt;If you’ve never seen how to build an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Arithmetic_logic_unit&quot;&gt;ALU&lt;/a&gt;
before, the logic to build one is actually very simple.  It’s basically
a big huge case statement that selects from among several possible outputs.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;case(i_op[3:0])
	4&#39;b0000:{c,o_c } &amp;lt;= {1&#39;b0,i_a}-{1&#39;b0,i_b};// SUB
	4&#39;b0001:   o_c   &amp;lt;= i_a &amp;amp; i_b;		// And
	4&#39;b0010:{c,o_c } &amp;lt;= i_a + i_b;		// Add
	4&#39;b0011:   o_c   &amp;lt;= i_a | i_b;		// Or
	4&#39;b0100:   o_c   &amp;lt;= i_a ^ i_b;		// Xor
	// ....
	default:   o_c   &amp;lt;= i_b;		// MOV, LDI&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;In this example, taken from the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;’s
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/cpuops.v&quot;&gt;ALU&lt;/a&gt;, the
two inputs, &lt;code class=&quot;highlighter-rouge&quot;&gt;i_a&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;i_b&lt;/code&gt;, are both 32-bit values.  The input to the
routine also includes a number, &lt;code class=&quot;highlighter-rouge&quot;&gt;i_op&lt;/code&gt;, identifying the operation that
needs to be calculated.  The result is placed into an output register, &lt;code class=&quot;highlighter-rouge&quot;&gt;o_c&lt;/code&gt;.
The &lt;code class=&quot;highlighter-rouge&quot;&gt;c&lt;/code&gt; bit you see above is associated with the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;’s carry logic–something we’ll
come back to later in this post.&lt;/p&gt;

&lt;p&gt;Structurally, within an FPGA, the logic looks like Fig 1 below.&lt;/p&gt;

&lt;table style=&quot;float: left&quot;&gt;&lt;caption&gt;Fig 1: ALU Hardware Structure&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/alu-simple.svg&quot; alt=&quot;ALU Structure&quot; width=&quot;400&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Each of the blocks in this figure takes up logic when implemented within
hardware.  As a result, even if &lt;code class=&quot;highlighter-rouge&quot;&gt;i_op&lt;/code&gt; requests that the two values be
subtracted, all of the other operations (addition, and, or, xor, etc.) will
still be calculated.  These other results, though, are just ignored.  Thus,
on the final clock of the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/cpuops.v&quot;&gt;ALU&lt;/a&gt;,
&lt;em&gt;all&lt;/em&gt; of the operations have been calculated, but &lt;em&gt;only&lt;/em&gt; the result of
the selected operation is stored into the output register.&lt;/p&gt;

&lt;p&gt;So that’s what an &lt;a href=&quot;https://en.wikipedia.org/wiki/Arithmetic_logic_unit&quot;&gt;ALU&lt;/a&gt;
looks liike in general.  Let’s now turn our attention to the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;’s
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/cpuops.v&quot;&gt;ALU&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;the-zipcpu-alu&quot;&gt;The ZipCPU ALU&lt;/h2&gt;

&lt;p&gt;The actual case statement within the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;’s
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/cpuops.v&quot;&gt;ALU&lt;/a&gt;
has sixteen operations that the instruction selects from among, not just the
six shown above.  In this section,
we’ll look at all of that logic save the multiply.  (Although the multiply
takes up most of the code space within the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/cpuops.v&quot;&gt;cpuops.v&lt;/a&gt;
file, it doesn’t fit into this lesson very well.)  Put together, the full
case statement for the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;’s
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/cpuops.v&quot;&gt;ALU&lt;/a&gt;
looks like:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
if (i_ce)
begin
	c &amp;lt;= 1&#39;b0;
	casez(i_op)
	4&#39;b0000:{c,o_c } &amp;lt;= {1&#39;b0,i_a}-{1&#39;b0,i_b};// CMP/SUB
	4&#39;b0001:   o_c   &amp;lt;= i_a &amp;amp; i_b;		// BTST/And
	4&#39;b0010:{c,o_c } &amp;lt;= i_a + i_b;		// Add
	4&#39;b0011:   o_c   &amp;lt;= i_a | i_b;		// Or
	4&#39;b0100:   o_c   &amp;lt;= i_a ^ i_b;		// Xor
	4&#39;b0101:{o_c,c } &amp;lt;= w_lsr_result[32:0];	// LSR
	4&#39;b0110:{c,o_c } &amp;lt;= w_lsl_result[32:0]; // LSL
	4&#39;b0111:{o_c,c } &amp;lt;= w_asr_result[32:0];	// ASR
	4&#39;b1000:   o_c   &amp;lt;= w_brev_result;	// BREV
	4&#39;b1001:   o_c   &amp;lt;= { i_a[31:16], i_b[15:0] }; // LODILO
	4&#39;b1010:   o_c   &amp;lt;= mpy_result[63:32];	// MPYHU
	4&#39;b1011:   o_c   &amp;lt;= mpy_result[63:32];	// MPYHS
	4&#39;b1100:   o_c   &amp;lt;= mpy_result[31:0];	// MPY
	default:   o_c   &amp;lt;= i_b;		// MOV, LDI
	endcase
end else // if (mpydone)
	// set the carry based upon a multiply result
	o_c &amp;lt;= (mpyhi)?mpy_result[63:32]:mpy_result[31:0];&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Let’s walk through each of these operations.&lt;/p&gt;

&lt;p&gt;The first operation, &lt;code class=&quot;highlighter-rouge&quot;&gt;4&#39;h0&lt;/code&gt; supports either a compare or a subtract
instruction.  This instruction subtracts two numbers in order to produce its
result.  The difference between the &lt;code class=&quot;highlighter-rouge&quot;&gt;CMP&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;SUB&lt;/code&gt; instructions is that the
compare doesn’t write the results back to any registers in the end while the
subtract does–but since that’s external to the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/cpuops.v&quot;&gt;ALU&lt;/a&gt;
implementation, you won’t see that difference here.&lt;/p&gt;

&lt;p&gt;You may notice that the subtract that is taking place is a 33-bit subtract
rather than a 32-bit subtract.  The reason for this is the carry, &lt;code class=&quot;highlighter-rouge&quot;&gt;c&lt;/code&gt;, bit.
In the case of a subtract, this bit will be true if &lt;code class=&quot;highlighter-rouge&quot;&gt;i_b&lt;/code&gt; had to &lt;em&gt;borrow&lt;/em&gt;
from the (unspecified) high order bit in order to complete.  We’ll discuss
this flag in more detail further down.&lt;/p&gt;

&lt;p&gt;The &lt;code class=&quot;highlighter-rouge&quot;&gt;TST&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;AND&lt;/code&gt; instructions are similar to the &lt;code class=&quot;highlighter-rouge&quot;&gt;CMP&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;SUB&lt;/code&gt;
instructions.  If the operation is an &lt;code class=&quot;highlighter-rouge&quot;&gt;AND&lt;/code&gt;, then both the result
and the flags will be set during writeback, whereas only the flags are set in
the case of the &lt;code class=&quot;highlighter-rouge&quot;&gt;TST&lt;/code&gt; operation.  Again, this difference is external to the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/cpuops.v&quot;&gt;ALU&lt;/a&gt;
implementation itself.&lt;/p&gt;

&lt;p&gt;The &lt;code class=&quot;highlighter-rouge&quot;&gt;ADD&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;OR&lt;/code&gt;, and &lt;code class=&quot;highlighter-rouge&quot;&gt;XOR&lt;/code&gt; instructions should need no further explanation.
(&lt;a href=&quot;https://en.wikipedia.org/wiki/Exclusive_or#Bitwise_operation&quot;&gt;XOR Ref&lt;/a&gt;)
The &lt;code class=&quot;highlighter-rouge&quot;&gt;c&lt;/code&gt; bit is set on the &lt;code class=&quot;highlighter-rouge&quot;&gt;ADD&lt;/code&gt;, though, if the result of adding unsigned
&lt;code class=&quot;highlighter-rouge&quot;&gt;i_a&lt;/code&gt; to &lt;code class=&quot;highlighter-rouge&quot;&gt;i_b&lt;/code&gt; overflows 32-bits.  This bit then makes it possible to string
32-bit additions together to create a 64-bit or larger operation.&lt;/p&gt;

&lt;p&gt;The shift instruction(s) needs some additional discussion.  The &lt;a href=&quot;https://en.wikipedia.org/wiki/Logical_shift&quot;&gt;logical
shift&lt;/a&gt; left, or &lt;code class=&quot;highlighter-rouge&quot;&gt;LSL&lt;/code&gt;, is
what the compiler creates from an &lt;code class=&quot;highlighter-rouge&quot;&gt;A = B &amp;lt;&amp;lt; C&lt;/code&gt; instruction.  The result is
created by shifting all of the bits in &lt;code class=&quot;highlighter-rouge&quot;&gt;B&lt;/code&gt; to the left by one and filling
the results in with zeros.
The &lt;a href=&quot;https://en.wikipedia.org/wiki/Logical_shift&quot;&gt;logical shift&lt;/a&gt;
right, or &lt;code class=&quot;highlighter-rouge&quot;&gt;LSR&lt;/code&gt;, comes from an &lt;code class=&quot;highlighter-rouge&quot;&gt;A = B &amp;gt;&amp;gt; C&lt;/code&gt; instruction in C, but only when
&lt;code class=&quot;highlighter-rouge&quot;&gt;B&lt;/code&gt; is unsigned.  In this case, all the bits shift to the right and the
upper bits are filled in with zeros.&lt;/p&gt;

&lt;p&gt;If &lt;code class=&quot;highlighter-rouge&quot;&gt;B&lt;/code&gt; is signed, however, the compiler will create an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Arithmetic_shift&quot;&gt;arithmetic shift&lt;/a&gt;
right, &lt;code class=&quot;highlighter-rouge&quot;&gt;ASR&lt;/code&gt;, instruction instead.  The &lt;code class=&quot;highlighter-rouge&quot;&gt;ASR&lt;/code&gt; is similar to the &lt;code class=&quot;highlighter-rouge&quot;&gt;LSR&lt;/code&gt;
instruction with one exception: the &lt;code class=&quot;highlighter-rouge&quot;&gt;ASR&lt;/code&gt; instruction propagates the high order
bit during the shift.  Hence the incoming &lt;code class=&quot;highlighter-rouge&quot;&gt;i_a[31]&lt;/code&gt; will always set the
outgoing &lt;code class=&quot;highlighter-rouge&quot;&gt;o_c[31]&lt;/code&gt; bit.  So while
&lt;a href=&quot;https://en.wikipedia.org/wiki/Logical_shift&quot;&gt;logically shifting&lt;/a&gt; a
&lt;code class=&quot;highlighter-rouge&quot;&gt;32&#39;hffff_fffe&lt;/code&gt; to the right by one bit will create a &lt;code class=&quot;highlighter-rouge&quot;&gt;32&#39;7fff_ffff&lt;/code&gt;,
&lt;a href=&quot;https://en.wikipedia.org/wiki/Arithmetic_shift&quot;&gt;arithmetically shifting&lt;/a&gt; a
&lt;code class=&quot;highlighter-rouge&quot;&gt;32&#39;hffff_fffe&lt;/code&gt; to the right by one bit will create a &lt;code class=&quot;highlighter-rouge&quot;&gt;32&#39;hffff_ffff&lt;/code&gt;.
The sign bit, &lt;code class=&quot;highlighter-rouge&quot;&gt;i_a[31]&lt;/code&gt; propagates on an &lt;code class=&quot;highlighter-rouge&quot;&gt;ASR&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Where things get interesting is what happens when you shift farther than
the number of bits in a register.  For example, what should be the result of
&lt;code class=&quot;highlighter-rouge&quot;&gt;32&#39;h0000_ffff&lt;/code&gt; when shifted left by 32?  &lt;code class=&quot;highlighter-rouge&quot;&gt;32&#39;h0000_0000&lt;/code&gt;, right?  Sure.  Now
what happens when you shift left by 34 bits?  Some
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;’s
examine only the lower 5 bits of the shift amount, and require the compiler
to make certain the shift is within bounds.  The
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;,
however, examines all 32-bits of the shift request contained in &lt;code class=&quot;highlighter-rouge&quot;&gt;i_b&lt;/code&gt;.
Hence, any attempt to logically shift more than 32-bits on the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt; results in a zero.&lt;/p&gt;

&lt;p&gt;The &lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;
handles shifts with one further difference that isn’t necessarily
used by the compiler: the carry bit is set to the last bit shifted off the
register.&lt;/p&gt;

&lt;p&gt;Now that all that is said, the &lt;code class=&quot;highlighter-rouge&quot;&gt;LSR&lt;/code&gt; logic is given by:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;assign  w_lsr_result =
	// Check if the shift amount will overflow, return 33&#39;h00 if it does
	((|i_b[31:6])||(i_b[5]&amp;amp;&amp;amp;(i_b[4:0]!=0)))? 33&#39;h00
	// On a shift of 32 exactly, keep i_a[31] in the carry
				:((i_b[5])?{32&#39;h0,i_a[31]}
	// Otherwise just shift the results by i_b
				: ( { i_a, 1&#39;b0 } &amp;gt;&amp;gt; (i_b[4:0]) ));// LSR&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The logic for the &lt;code class=&quot;highlighter-rouge&quot;&gt;LSL&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;ASR&lt;/code&gt; instructions is quite similar.&lt;/p&gt;

&lt;p&gt;A second unique
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;
instruction is the &lt;a href=&quot;https://en.wikipedia.org/wiki/Bit-reversal_permutation&quot;&gt;bit
reverse&lt;/a&gt; instruction,
&lt;code class=&quot;highlighter-rouge&quot;&gt;BREV&lt;/code&gt;.  This is a zero cost instruction that does nothing but re-order the
wires from the &lt;code class=&quot;highlighter-rouge&quot;&gt;i_b&lt;/code&gt; input:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;genvar	k; generate
for(k=0; k&amp;lt;32; k=k+1)
begin : bit_reversal_cpuop
	assign w_brev_result[k] = i_b[31-k];
end endgenerate&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This particular instruction is not found in other
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;’s.
It was placed into the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt; in order to support the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bit-reversal_permutation&quot;&gt;bit reversed&lt;/a&gt;
addressing required by a &lt;a href=&quot;https://en.wikipedia.org/Cooley-Tukey_FFT_algorithm&quot;&gt;Fast Fourier
transform&lt;/a&gt;.  It has since
become integral to the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;’s instruction set.  Here’s why:&lt;/p&gt;

&lt;p&gt;Every &lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;
needs an ability to load a value with as many bits as a register into
a register.  That is to say, a 32-bit
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;
needs the ability to load a 32-bit immediate value into a 32-bit
register–&lt;a href=&quot;https://www.gnu.org/software/binutils&quot;&gt;binutils&lt;/a&gt;, and particularly
the linker within
it, requires this capability.  Since instructions are 32-bits wide, you can’t
fit both an instruction and a 32’bit value into the same instruction.  While
the &lt;a href=&quot;https://en.wikipedia.org/wiki/X86&quot;&gt;x86&lt;/a&gt; solved this problem by storing
the 32’bit value directly in the instruction stream following this instruction,
this risks mis-aligning the instruction stream and therefore adding
complication to the instruction decoder.  To avoid this extra complication,
&lt;a href=&quot;https://en.wikipedia.org/wiki/Reduced_instruction_set_computer&quot;&gt;RISC&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;s
tend to handle this problem with a two instruction load: the first instruction
loads the upper half of the register, while the second instruction loads
the lower half of the register.&lt;/p&gt;

&lt;p&gt;In the case of the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;,
the &lt;code class=&quot;highlighter-rouge&quot;&gt;BREV&lt;/code&gt; instruction is the first instruction in this pair–it can be used to
load the upper 18-bits of a register.  The other instruction, shown in the
code above as &lt;code class=&quot;highlighter-rouge&quot;&gt;LDILO&lt;/code&gt; (load immediate into lower 16-bits), loads the lower
16-bits of any 32-bit value.  &lt;a href=&quot;https://gcc.gnu.org&quot;&gt;GCC&lt;/a&gt; requires that neither
of these operations affect the flags, something we can come back and discuss
another time.  Together, these two instructions allow the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;
to load &lt;em&gt;any&lt;/em&gt; 32-bit immediate value into a register.  Since the extra cost
of &lt;a href=&quot;https://en.wikipedia.org/wiki/Bit-reversal_permutation&quot;&gt;bit reversing&lt;/a&gt;
a 32-bit value is handled by the
&lt;a href=&quot;https://www.gnu.org/software/binutils&quot;&gt;assembler and linker&lt;/a&gt; (there’s no
hardware cost for doing this), there’s no performance penalty to the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt; for having this instruction.&lt;/p&gt;

&lt;p&gt;That leaves two pieces of logic we haven’t discussed within the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/cpuops.v&quot;&gt;ALU&lt;/a&gt;.
The first is the flag generation logic which we will come to next.  The
other piece of logic within the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/cpuops.v&quot;&gt;ALU&lt;/a&gt;
that we haven’t discussed is the multiply.  The multiply logic in the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;’s
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/cpuops.v&quot;&gt;cpuops.v&lt;/a&gt;
file is particularly complicated for the sole reason that the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;
can support a 32x32-bit multiply across a wide variety of hardware
architectures.  Some of these architectures can do a multiply in a single
clock, while other FPGA’s require two, three, or even four clocks to execute a
multiply.&lt;/p&gt;

&lt;p&gt;Let’s look at calculating the flags next.&lt;/p&gt;

&lt;h2 id=&quot;the-flags-results&quot;&gt;The Flags Results&lt;/h2&gt;

&lt;p&gt;The &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/cpuops.v&quot;&gt;ALU&lt;/a&gt;
creates and outputs a set of flags from the operation.  Many instructions will
cause these to be placed into the &lt;a href=&quot;https://en.wikipedia.org/wiki/Status_register&quot;&gt;condition codes
register&lt;/a&gt;.
The &lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;
supports all four of the common condition codes, or flags as we’ll call them
here: &lt;code class=&quot;highlighter-rouge&quot;&gt;Z&lt;/code&gt; (zero), &lt;code class=&quot;highlighter-rouge&quot;&gt;C&lt;/code&gt; (carry), &lt;code class=&quot;highlighter-rouge&quot;&gt;N&lt;/code&gt; (negative) and &lt;code class=&quot;highlighter-rouge&quot;&gt;V&lt;/code&gt; (overflow).&lt;/p&gt;

&lt;p&gt;The &lt;code class=&quot;highlighter-rouge&quot;&gt;Z&lt;/code&gt; flag is set whenever the result is zero:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;assign	z = (o_c == 32&#39;h0000);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The compiler uses this flag whenever two numbers need to be tested and compared
for equality.&lt;/p&gt;

&lt;p&gt;The &lt;code class=&quot;highlighter-rouge&quot;&gt;C&lt;/code&gt; or “carry” flag was set above whenever an addition or subtraction
required a carry.  I also mentioned above how the carry flag on the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;
is also set for shift operations.  All other operations clear the carry flag.&lt;/p&gt;

&lt;p&gt;The compiler uses this flag whenever two numbers need to be tested and compared
for an unsigned &lt;em&gt;less than&lt;/em&gt;, or whenever an extended 64-bit addition (or
subtraction) needs to be carried out.  (Unlike many other CPU’s, the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;
doesn’t have either “add with carry” or “subtract with carry” instructions.)&lt;/p&gt;

&lt;p&gt;The &lt;code class=&quot;highlighter-rouge&quot;&gt;N&lt;/code&gt; flag is perhaps the simplest to discuss.  This is set whenever the
sign bit is set on the output:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;assign	n = (o_c[31]);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Well, not quite.&lt;/p&gt;

&lt;p&gt;It turns out that there’s an ugly problem associated with setting the &lt;code class=&quot;highlighter-rouge&quot;&gt;N&lt;/code&gt;
flag to the outgoing sign bit.  Specifically,
if you wish to compare whether or not &lt;code class=&quot;highlighter-rouge&quot;&gt;A&amp;lt;B&lt;/code&gt; when &lt;code class=&quot;highlighter-rouge&quot;&gt;A&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;B&lt;/code&gt; are large and
signed then &lt;code class=&quot;highlighter-rouge&quot;&gt;o_c[31]&lt;/code&gt; isn’t sufficient.  To do this comparison, the &lt;code class=&quot;highlighter-rouge&quot;&gt;CMP&lt;/code&gt;
instruction will enter the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/cpuops.v&quot;&gt;ALU&lt;/a&gt;
via a subtract, &lt;code class=&quot;highlighter-rouge&quot;&gt;A-B&lt;/code&gt;.  The result of this subtraction will then be checked
to determine whether or not the result is less than zero.  However, if the
result overflows the sign bit, then you still want to continue to set the
&lt;code class=&quot;highlighter-rouge&quot;&gt;N&lt;/code&gt; flag appropriately.  If you don’t, then &lt;code class=&quot;highlighter-rouge&quot;&gt;32&#39;h8000_0000&lt;/code&gt; won’t be less
than &lt;code class=&quot;highlighter-rouge&quot;&gt;32&#39;h7fff_ffff&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;As proof, consider what happens on a subtraction overflow:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;  32&#39;h7fff_ffff ( 2^(31)-1)
- 32&#39;h8000_0000 (-2^(31)  )
---------------
= 32`hffff_ffff&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The result of this subtraction &lt;em&gt;should&lt;/em&gt; be a positive &lt;code class=&quot;highlighter-rouge&quot;&gt;2^(32)-1&lt;/code&gt;.  However,
since an overflow took place, the MSB no longer reflects the correct sign.
We’re going to need to adjust &lt;code class=&quot;highlighter-rouge&quot;&gt;N&lt;/code&gt; therefore to reflect that this result is
positive and not negative.&lt;/p&gt;

&lt;p&gt;While there may be a simpler way, the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/cpuops.v&quot;&gt;ALU&lt;/a&gt;
solves this problem in three steps.  The first is to keep track of
the original sign of &lt;code class=&quot;highlighter-rouge&quot;&gt;i_a&lt;/code&gt; in a register called &lt;code class=&quot;highlighter-rouge&quot;&gt;pre_sign&lt;/code&gt;.  The second part
is to determine if that sign needs to be kept on an overflow.
Then, on any overflow, the sign is flipped when determining &lt;code class=&quot;highlighter-rouge&quot;&gt;N&lt;/code&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	if (i_ce) // 1 LUT
	begin
		pre_sign &amp;lt;= (i_a[31]);
		keep_sgn_on_ovfl&amp;lt;=
			(((i_op==4&#39;h0)&amp;amp;&amp;amp;(i_a[31] != i_b[31]))//SUB&amp;amp;CMP
			||((i_op==4&#39;h2)&amp;amp;&amp;amp;(i_a[31] == i_b[31]))); // ADD
	end

assign n = (o_c[31])
	^ ((keep_sgn_on_ovfl)&amp;amp;&amp;amp;(pre_sign != o_c[31]));&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;When to keep a sign on overflow needs a touch more explanation:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;If you add two values with the same sign, then the result should also
have the same sign regardless of any overflow.  Hence, two positive numbers
should yield a positive result in spite of any overflow.  In this case,
the sign should be given by &lt;code class=&quot;highlighter-rouge&quot;&gt;i_a&lt;/code&gt;’s sign, captured here in &lt;code class=&quot;highlighter-rouge&quot;&gt;pre_sign&lt;/code&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The same is true of subtract, save only that the sign needs to be
preserved any time the initial values have opposite signs.  In particular,
if you negate the second value, a subtract becomes the same as an addition,
and then the addition rule above applies again.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Now, if the sign changes but yet was supposed to be kept, then the resulting
&lt;code class=&quot;highlighter-rouge&quot;&gt;N&lt;/code&gt; flag needs to be swapped–hence the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Exclusive_or&quot;&gt;exclusive OR&lt;/a&gt;
in the code above.&lt;/p&gt;

&lt;p&gt;The &lt;code class=&quot;highlighter-rouge&quot;&gt;N&lt;/code&gt; bit is used by the compiler to test whether or not &lt;code class=&quot;highlighter-rouge&quot;&gt;i_a &amp;lt; i_b&lt;/code&gt; when
both numbers are signed.  By preserving the meaning of this bit in spite
of overflow, the compiler does what you would expect it to do–even when
comparing large numbers.&lt;/p&gt;

&lt;p&gt;The final flag bit, the overflow or &lt;code class=&quot;highlighter-rouge&quot;&gt;V&lt;/code&gt; bit, requires a touch more logic
as well.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	if (i_ce) // 1 LUT
		set_ovfl&amp;lt;=(((i_op==4&#39;h0)&amp;amp;&amp;amp;(i_a[31] != i_b[31]))//SUB&amp;amp;CMP
			||((i_op==4&#39;h2)&amp;amp;&amp;amp;(i_a[31] == i_b[31])) // ADD
			||(i_op == 4&#39;h6) // LSL
			||(i_op == 4&#39;h5)); // LSR&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The &lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;
sets the overflow flag on one of four conditions:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;If this is an addition, and the signs of both operands are the same, then
the result should be positive and the overflow bit will be set if the
signs don’t match.&lt;/p&gt;

    &lt;p&gt;This alone is almost identical to the &lt;code class=&quot;highlighter-rouge&quot;&gt;N&lt;/code&gt; logic above.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The second case is the case for the subtract.  If the incoming signs are
identical, and the outgoing sign is different, then the overflow bit
needs to be set.  This is also very similar to the &lt;code class=&quot;highlighter-rouge&quot;&gt;N&lt;/code&gt; logic above.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The last two cases regard shifts.  In particular, the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;
sets the overflow if either of the &lt;a href=&quot;https://en.wikipedia.org/wiki/Logical_shift&quot;&gt;logical
shift&lt;/a&gt;
instructions changes the sign of the output.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Put together, this yields the following logic for the &lt;code class=&quot;highlighter-rouge&quot;&gt;V&lt;/code&gt; bit:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;assign	v = (set_ovfl)&amp;amp;&amp;amp;(pre_sign != o_c[31]);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Since the C language doesn’t have a way to test for overflow within the
language, this flag has gone largely unused.  Further, the compiler support
for overflow checking for those other languages that do use it hasn’t
been implemented yet.&lt;/p&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;That’s basically how an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Arithmetic_logic_unit&quot;&gt;ALU&lt;/a&gt;
works: it’s a series of operations whose output is selected via a case
statement.  While every
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;
will support different instructions, at some level all
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;’s
will have a case statement selecting between various operations within them.&lt;/p&gt;

&lt;p&gt;In the case of a &lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;
with a &lt;a href=&quot;https://en.wikipedia.org/wiki/Status_register&quot;&gt;condition codes
register&lt;/a&gt;.
such as the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;, these codes are also
easily calculated within the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/cpuops.v&quot;&gt;ALU&lt;/a&gt; as well.&lt;/p&gt;

&lt;p&gt;Turning a simple &lt;a href=&quot;https://en.wikipedia.org/wiki/Arithmetic_logic_unit&quot;&gt;ALU&lt;/a&gt;
into a full blown &lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;,
such as the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;,
takes a bit more work than we presented above.  In fact, it takes a &lt;em&gt;lot&lt;/em&gt;
more work.  Let’s consider that a good thing, though, because it will give
us something to learn on another day.&lt;/p&gt;

&lt;hr /&gt;&lt;p&gt;&lt;em&gt;In all thy ways acknowledge him, and he shall direct thy paths. (Prov 3:6)&lt;/em&gt;</description>
        <pubDate>Fri, 11 Aug 2017 00:00:00 -0400</pubDate>
        <link>http://zipcpu.com/zipcpu/2017/08/11/simple-alu.html</link>
        <guid isPermaLink="true">http://zipcpu.com/zipcpu/2017/08/11/simple-alu.html</guid>
        
        
        <category>zipcpu</category>
        
      </item>
    
      <item>
        <title>Series: Debouncing in Digital Logic</title>
        <description>&lt;p&gt;This ends our series on contact bounce.  We started out by demonstrating that
&lt;a href=&quot;/blog/2017/08/02/debounce-teaser.html&quot;&gt;button’s do indeed bounce&lt;/a&gt;.
This initial post presented a series of images, collected from tests that
measured button bouncing across multiple devices.&lt;/p&gt;

&lt;p&gt;We then demonstrated how, using digital logic, &lt;a href=&quot;/blog/2017/08/04/debouncing.html&quot;&gt;extraneous bounces could be
removed&lt;/a&gt; from a button’s
signal.&lt;/p&gt;

&lt;p&gt;We also showed &lt;a href=&quot;/blog/2017/08/05/bounce-metric.html&quot;&gt;how to measure how much and how often a button
bounces&lt;/a&gt;.  This will
be useful to us later should we ever wish to tune the timer within our
debouncer.&lt;/p&gt;

&lt;p&gt;The final article discussed &lt;a href=&quot;/blog/2017/08/07/bounce-dbgbus.html&quot;&gt;how to modify our debugging bus to get a button
bouncing trace&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Unlike other debouncing developments, we’ve also discussed how to
synchronize the button inputs along the way,
and the consequences of metastability should the inputs not be synchronized.
We’ve also presented a debouncer that will return the debounced data
with minimal latency, vice the uncontrolled latency many other approaches
share.&lt;/p&gt;

&lt;p&gt;Further, unlike any other debouncing development I’ve seen, using the
&lt;a href=&quot;https://github.com/ZipCPU/debouncer&quot;&gt;sample code&lt;/a&gt; provided you can see
bouncing for yourself, or even test your own debouncing code.&lt;/p&gt;
&lt;hr /&gt;&lt;p&gt;&lt;em&gt;While the earth remaineth, seedtime and harvest, and cold and heat, and summer and winter, and day and night shall not cease. (Gen 8:22)&lt;/em&gt;</description>
        <pubDate>Wed, 09 Aug 2017 00:00:00 -0400</pubDate>
        <link>http://zipcpu.com/blog/2017/08/09/series-debouncing.html</link>
        <guid isPermaLink="true">http://zipcpu.com/blog/2017/08/09/series-debouncing.html</guid>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>Using a debug-bus to Measure Bouncing</title>
        <description>&lt;p&gt;As we’ve discussed in our two previous posts,
buttons and switches on
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;’s
can be very useful to work with.  They can be
very useful tools when debugging as well.  The problem is that these forms of
inputs often “&lt;a href=&quot;https://en.wikipedia.org/wiki/Switch#Contact_bounce&quot;&gt;bounce&lt;/a&gt;”,
and produce multiple edges when only one is desired.  This can be a problem
when you wish to depend or rely upon these inputs as being a dependable
part of a debugging solution–before you’ve managed to ensure their
dependability.&lt;/p&gt;

&lt;p&gt;Making &lt;a href=&quot;https://en.wikipedia.org/wiki/Switch#Contact_bounce&quot;&gt;contact bounce&lt;/a&gt;
particularly problematic is the fact that it is difficult to simulate, since
the bounces tend to appear quite random.&lt;/p&gt;

&lt;p&gt;Our &lt;a href=&quot;/blog/2017/08/02/debounce-teaser.html&quot;&gt;first post&lt;/a&gt;
on this topic looked into how this sort of bouncing manifested, showing
several examples and traces of contact bounces.  The pictures weren’t very
pretty, as many buttons from several different boards and even a keypad all
manifested this problem.&lt;/p&gt;

&lt;p&gt;Our &lt;a href=&quot;/blog/2017/08/04/debouncing.html&quot;&gt;second post&lt;/a&gt;
discussed how to create the digital logic necessary to debounce a user
input.&lt;/p&gt;

&lt;p&gt;We then &lt;a href=&quot;/blog/2017/08/05/bounce-metric.html&quot;&gt;created some simple test
points&lt;/a&gt; that could
be used to measure button press duration and the number of times a particular
button press bounced.&lt;/p&gt;

&lt;p&gt;Today, our discussion is going to focus on how to connect these two
components to the &lt;a href=&quot;https://opencores.org/cdn/downloads/wbspec_b4.pdf&quot;&gt;wishbone
bus&lt;/a&gt; present within our
&lt;a href=&quot;https://github.com/ZipCPU/dbgbus/blob/master/rtl/testbus.v&quot;&gt;debugging-bus testing
logic&lt;/a&gt;.
We’re also going to add a
&lt;a href=&quot;https://github.com/ZipCPU/wbscope&quot;&gt;compressed wishbone scope&lt;/a&gt;
to the design in order to get the traces out of our design such as were
presented in the &lt;a href=&quot;/blog/2017/08/02/debounce-teaser.html&quot;&gt;initial
post&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;instantiating-the-two-components&quot;&gt;Instantiating the two components&lt;/h2&gt;

&lt;p&gt;Over the course of the last two posts, we’ve created two components that
we would now like to test: 
a &lt;a href=&quot;https://github.com/ZipCPU/debouncer/blob/master/rtl/debouncer.v&quot;&gt;debouncer&lt;/a&gt;,
and an
&lt;a href=&quot;https://github.com/ZipCPU/debouncer/blob/master/rtl/unbounced.v&quot;&gt;unbounced&lt;/a&gt;
module.  We are going to test these two components by pressing a button, and
then reading the results produced by these two components as registers on a
bus.  Once read, we’ll use the bus to reset these components.&lt;/p&gt;

&lt;p&gt;We’ll start by assuming we have &lt;code class=&quot;highlighter-rouge&quot;&gt;NBTNS&lt;/code&gt; buttons, in a vector named &lt;code class=&quot;highlighter-rouge&quot;&gt;i_button&lt;/code&gt;
coming into our top level design.  This vector, together with our system
clock, can then be used as inputs to these two modules, as in:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;debouncer	#(NBTNS) thedebouncer(i_clk, i_button,
				debounced, debounce_dbg);
unbounced	#(NBTNS) theunbouncer(i_clk, unbounce_reset,
				i_button, transitions, max_clock);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The result of the
&lt;a href=&quot;https://github.com/ZipCPU/debouncer/blob/master/rtl/debouncer.v&quot;&gt;debouncer&lt;/a&gt;
is a &lt;code class=&quot;highlighter-rouge&quot;&gt;NBTNS&lt;/code&gt;-bit vector &lt;code class=&quot;highlighter-rouge&quot;&gt;debounced&lt;/code&gt;.  This vector is a copy of &lt;code class=&quot;highlighter-rouge&quot;&gt;i_button&lt;/code&gt;,
save only that it has been both synchronized to the clock and any bounces
have been removed.&lt;/p&gt;

&lt;p&gt;The two results of the
&lt;a href=&quot;https://github.com/ZipCPU/debouncer/blob/master/rtl/unbounced.v&quot;&gt;unbounced&lt;/a&gt;
vector are two 31-bit vectors: &lt;code class=&quot;highlighter-rouge&quot;&gt;transitions&lt;/code&gt; which holds the number of
transitions, and &lt;code class=&quot;highlighter-rouge&quot;&gt;max_clock&lt;/code&gt; which holds the number of clock ticks from the
first transition to the last.&lt;/p&gt;

&lt;p&gt;The other two items are the &lt;code class=&quot;highlighter-rouge&quot;&gt;unbounce_reset&lt;/code&gt; and the &lt;code class=&quot;highlighter-rouge&quot;&gt;debounce_dbg&lt;/code&gt;.
The &lt;code class=&quot;highlighter-rouge&quot;&gt;unbounce_reset&lt;/code&gt; line clears the counters.  We’ll hook that up in the
next section.  The &lt;code class=&quot;highlighter-rouge&quot;&gt;debounce_dbg&lt;/code&gt; lines, however, we’ll come back to when
we discuss hooking the debouncer up to the &lt;a href=&quot;https://github.com/ZipCPU/wbscope&quot;&gt;wishbone
scope&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;connecting-the-components-to-the-debugging-bus&quot;&gt;Connecting the components to the debugging bus&lt;/h2&gt;

&lt;p&gt;We’d like to hook these two peripherals to our wishbone debugging bus,
&lt;a href=&quot;https://github.com/ZipCPU/dbgbus/blob/master/bench/rtl/testbus.v&quot;&gt;testbus.v&lt;/a&gt;.
In particular, we’d like to be able to read these three values from an
external UART.  Since reading the values requires no logic handshake with
the modules, they can be hooked up just as simply as any of the other
simple registers within the
&lt;a href=&quot;https://github.com/ZipCPU/dbgbus/blob/master/bench/rtl/testbus.v&quot;&gt;testbus.v&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;To hook this new peripheral up, just assign it an address among our
simple data peripheral’s address map:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	case(wb_addr[3:0])
	...
	4&#39;h6:    smpl_data &amp;lt;= transitions;
	4&#39;h7:    smpl_data &amp;lt;= max_clock;
	4&#39;h8:    smpl_data &amp;lt;= { {(32-NBTNS){1&#39;b0}}, debounced };
	...
	defult: smpl_data &amp;lt;= 32&#39;h0;
	endcase&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Don’t forget when using these addresses, that each address references a
32-bit quantity, and hence they need to be multiplied by four to get the
offset into the address map.
Hence, address offsets of 24, 28, and 32 from the simple data peripheral
now contain our new values.  Given that we placed our simple data peripheral
at an address offset of &lt;code class=&quot;highlighter-rouge&quot;&gt;0x2040&lt;/code&gt;, that means these new registers will have
final addresses &lt;code class=&quot;highlighter-rouge&quot;&gt;0x2058&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;0x205c&lt;/code&gt;, and &lt;code class=&quot;highlighter-rouge&quot;&gt;0x2060&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;One other change is required to the bus, we need to create our reset signal,
&lt;code class=&quot;highlighter-rouge&quot;&gt;unbounce_reset&lt;/code&gt;.  We’re going to set this reset signal up so that any time
we write to either of these registers, either the &lt;code class=&quot;highlighter-rouge&quot;&gt;transitions&lt;/code&gt; or the
&lt;code class=&quot;highlighter-rouge&quot;&gt;max_clock&lt;/code&gt; register, we reset our counters:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;assign	unbounce_reset = (wb_stb)&amp;amp;&amp;amp;(wb_we)&amp;amp;&amp;amp;(smpl_sel)
				&amp;amp;&amp;amp;(wb_addr[3:1]==3&#39;b011);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;That’s it!  That’s all the changes that are necessary in order to connect
these two new peripherals to our bus.  Gosh, if it’s that easy, why not
try your own peripherals?&lt;/p&gt;

&lt;p&gt;Before moving to the next section, there’s one other difference.  If you
compare this &lt;a href=&quot;https://github.com/ZipCPU/debouncer/blob/master/bench/rtl/testbus.v&quot;&gt;new top level
design&lt;/a&gt;
with the &lt;a href=&quot;https://github.com/ZipCPU/dbgbus/blob/master/bench/rtl/testbus.v&quot;&gt;initial top level
design&lt;/a&gt;,
you’ll notice that the block RAM has been removed.  This was to provide
extra block RAM space for the wishbone scope—space that was never
really needed in the end.&lt;/p&gt;

&lt;h2 id=&quot;switching-to-a-compressed-wishbone-scope&quot;&gt;Switching to a compressed wishbone scope&lt;/h2&gt;

&lt;p&gt;There are three RTL steps to setting up a wishbone scope within your design.&lt;/p&gt;

&lt;p&gt;The first step is to create a trigger.  You can find the trigger I
created in the
&lt;a href=&quot;https://github.com/ZipCPU/dbgbus/blob/master/rtl/debouncer.v&quot;&gt;debouncer&lt;/a&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	trigger &amp;lt;= (!ztimer)&amp;amp;&amp;amp;(!different)&amp;amp;&amp;amp;(!(|i_in))
			&amp;amp;&amp;amp;(timer[(LGWAIT-1):2]==0)&amp;amp;&amp;amp;(timer[1]);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This trigger is designed to stop the scope any time the debouncing logic
is complete, &lt;em&gt;and&lt;/em&gt; the button’s logic value(s) has returned to zero.  In
practice, it didn’t work very well for testing the keypad, since the keypad
uses negative logic (a button release sends the signal high, not low).
The end result was that I often needed to trigger the scope manually from the
debugging bus, but we’ll come back to this in a moment.&lt;/p&gt;

&lt;p&gt;The next step in connecting the scope is to select the data lines you wish
to record.  Here, let’s connect to our synchronized inputs, the debounced
result, as well as the &lt;code class=&quot;highlighter-rouge&quot;&gt;ztimer&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;trigger&lt;/code&gt; logic from within the design.
Because buttons take place over a very long period of time, we’ll need
to use the compressed wishbone scope.  That’s going to limit our debugging
width to 31-bits instead of 32.  (The last bit is used for run length
encoding.)&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;//	debug[31] is used for RLE encoding, and thus not available to us here
assign	debug[30] = ztimer;
assign	debug[29] = trigger;
assign	debug[28] = 1&#39;b0;
// Bits 27:14 are assigned to the output of the debouncer
assign	debug[27 :(14+NIN)] = 0;
assign	debug[(14+NIN-1):14] = o_debounced;
// Bottom 14 bits are assigned to our synchronized input(s)
assign	debug[13 :NIN] = 0;
assign	debug[(NIN-1):0] = r_in;

assign	o_debug = debug;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;While this approach limits the number of inputs to 13-bits in a 14-bit
field, the logic within the actual &lt;a href=&quot;https://github.com/ZipCPU/debouncer/blob/master/rtl/debouncer.v&quot;&gt;debouncer
code&lt;/a&gt;
makes it possible to record up to 14-bits, and to process any number of
buttons up to an arbitrary width.&lt;/p&gt;

&lt;p&gt;The final change is to adjust the scope itself.  Switching from an
&lt;a href=&quot;https://github.com/ZipCPU/wbscope/blob/master/rtl/wbscope.v&quot;&gt;uncompressed wishbone scope&lt;/a&gt; to a
&lt;a href=&quot;https://github.com/ZipCPU/wbscope/blob/master/rtl/wbscope.v&quot;&gt;compressed wishbone scope&lt;/a&gt;
is almost as easy as changing &lt;code class=&quot;highlighter-rouge&quot;&gt;wbscope&lt;/code&gt; to &lt;code class=&quot;highlighter-rouge&quot;&gt;wbscopc&lt;/code&gt;.  Indeed, the two share
an almost identical interface standard.  The only more substantial change
beyond changing the name is adjusting the input data width from 32-bits down
to the 31-bits of the compressed scope.  We’ll also pull the &lt;code class=&quot;highlighter-rouge&quot;&gt;scope_trigger&lt;/code&gt;
from its bit position within the &lt;code class=&quot;highlighter-rouge&quot;&gt;debug&lt;/code&gt; vector coming from the &lt;a href=&quot;https://github.com/ZipCPU/debouncer/blob/master/rtl/debouncer.v&quot;&gt;debouncer
code&lt;/a&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	assign	scope_trigger = debounce_dbg[29];
	wire	[30:0]	debug_data;
	assign	debug_data    = debounce_dbg;
	wbscopc	#(5&#39;d9) thescope(i_clk, 1&#39;b1, scope_trigger, debug_data,&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Setting up the design for this purpose is really just that easy.&lt;/p&gt;

&lt;h2 id=&quot;adjusting-the-register-definition-files&quot;&gt;Adjusting the register definition files&lt;/h2&gt;

&lt;p&gt;Finally, I adjusted the
&lt;a href=&quot;https://github.com/ZipCPU/debouncer/blob/master/sw/regdefs.h&quot;&gt;regdefs.h&lt;/a&gt; and
&lt;a href=&quot;https://github.com/ZipCPU/debouncer/blob/master/sw/regdefs.cpp&quot;&gt;regdefs.cpp&lt;/a&gt;
files to reflect that there are two new registers
in our design, giving them names that I can use to access them both from
my own C code
(&lt;a href=&quot;https://github.com/ZipCPU/debouncer/blob/master/sw/regdefs.h&quot;&gt;regdefs.h&lt;/a&gt;),
as well as from the &lt;code class=&quot;highlighter-rouge&quot;&gt;wbregs&lt;/code&gt; command line
(&lt;a href=&quot;https://github.com/ZipCPU/debouncer/blob/master/sw/regdefs.cpp&quot;&gt;regdefs.cpp&lt;/a&gt;).&lt;/p&gt;

&lt;p&gt;The first change was to
&lt;a href=&quot;https://github.com/ZipCPU/debouncer/blob/master/sw/regdefs.h&quot;&gt;regdefs.h&lt;/a&gt;,
where we needed to define our three new registers:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;cp&quot;&gt;#define	R_TRANSITIONS	0x00002058
#define	R_MAXCLOCKS	0x0000205c
#define	R_DEBOUNCED	0x00002060&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;You may remember from our discussion above that these are the addresses
of these three new registers within our simple data peripheral’s address space.&lt;/p&gt;

&lt;p&gt;I then gave these registers user-friendly names by modifying
&lt;a href=&quot;https://github.com/ZipCPU/debouncer/blob/master/sw/regdefs.cpp&quot;&gt;regdefs.cpp&lt;/a&gt;:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;R_DEBOUNCED&lt;/span&gt;	  &lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;	&lt;span class=&quot;s&quot;&gt;&quot;DEBOUNCED&quot;&lt;/span&gt;	&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;R_TRANSITIONS&lt;/span&gt;	  &lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;	&lt;span class=&quot;s&quot;&gt;&quot;BOUNCES&quot;&lt;/span&gt;	&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;R_TRANSITIONS&lt;/span&gt;	  &lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;	&lt;span class=&quot;s&quot;&gt;&quot;TRANSITIONS&quot;&lt;/span&gt;	&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;R_MAXCLOCKS&lt;/span&gt;	  &lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;	&lt;span class=&quot;s&quot;&gt;&quot;DURATION&quot;&lt;/span&gt;	&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;R_MAXCLOCKS&lt;/span&gt;	  &lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;	&lt;span class=&quot;s&quot;&gt;&quot;MAXCLOCKS&quot;&lt;/span&gt;	&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This only modifies a structure providing a mapping from register values
to user register names.&lt;/p&gt;

&lt;p&gt;The final change was to create a piece of C++ code to read from the
wishbone scope.  You can see what this new scope code looks like
&lt;a href=&quot;https://github.com/ZipCPU/debouncer/blob/master/sw/btnscope.cpp&quot;&gt;here&lt;/a&gt;,
although how to develop this code is discussed in general
&lt;a href=&quot;/blog/2017/07/08/getting-started-with-wbscope.html&quot;&gt;here&lt;/a&gt;.
Build and run this new
&lt;a href=&quot;https://github.com/ZipCPU/debouncer/blob/master/sw/btnscope.cpp&quot;&gt;btnscope&lt;/a&gt;
program, and you’ll have a &lt;a href=&quot;/blog/2017/07/31/vcd.html&quot;&gt;VCD
file&lt;/a&gt; that you can then use with
&lt;a href=&quot;http://gtkwave.sourceforge.net&quot;&gt;GTKWave&lt;/a&gt; to view traces showing how your own
buttons bounce–just like the &lt;a href=&quot;/blog/2017/08/02/debounce-teaser.html&quot;&gt;traces I presented when we first
started&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;That’s it!  We can now grab two registers from our button press, and read
their results via &lt;code class=&quot;highlighter-rouge&quot;&gt;wbregs duration&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;wbregs bounces&lt;/code&gt;.  We can also reset
our count by writing to either of these registers via something like
&lt;code class=&quot;highlighter-rouge&quot;&gt;wbregs duration 0&lt;/code&gt;.  Using
&lt;a href=&quot;https://github.com/ZipCPU/debouncer/blob/master/sw/btnscope.cpp&quot;&gt;btnscope&lt;/a&gt;,
we can also read and create &lt;a href=&quot;/blog/2017/07/31/vcd.html&quot;&gt;VCD
files&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;scripts-to-access-the-design&quot;&gt;Scripts to access the design&lt;/h2&gt;

&lt;p&gt;After using this design over and over several times, I got tired of typing
the same commands over and over.  As a result, I wrote two scripts to
make things easier.&lt;/p&gt;

&lt;p&gt;The first script,
&lt;a href=&quot;https://github.com/ZipCPU/debouncer/blob/master/sw/getinfo.sh&quot;&gt;getinfo.sh&lt;/a&gt;,
simple reads the two registers and dumps them into a file record for later
analysis.  It also manually triggers the
&lt;a href=&quot;https://github.com/ZipCPU/wbscope&quot;&gt;wishbone scope&lt;/a&gt; in case it hadn’t
triggered yet.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span class=&quot;c&quot;&gt;#!/bin/bash&lt;/span&gt;

wbregs bounces  | tee -a btndata.txt
wbregs duration | tee -a btndata.txt
wbregs scope 0x88000020&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The second script,
&lt;a href=&quot;https://github.com/ZipCPU/debouncer/blob/master/sw/reset.sh&quot;&gt;reset.sh&lt;/a&gt;,
resets the logic for another button press.  Specifically, it resets the
scope (i.e. writes to it with the high data clear), and then attempts to
write to the bounce count.  As with any write to either of the
&lt;a href=&quot;https://github.com/ZipCPU/debouncer/blob/master/rtl/unbounced.v&quot;&gt;unbounced&lt;/a&gt;
registers, this will set the reset line to the
&lt;a href=&quot;https://github.com/ZipCPU/debouncer/blob/master/rtl/unbounced.v&quot;&gt;unbounced&lt;/a&gt;
module for one clock, and thus reset the counters.  Finally, just to be
certain that the two registers actually cleared as desired, they are read
after reset.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span class=&quot;c&quot;&gt;#!/bin/bash&lt;/span&gt;

wbregs scope 0x020 &lt;span class=&quot;c&quot;&gt;# Reset the scope&lt;/span&gt;
wbregs bounces 0   &lt;span class=&quot;c&quot;&gt;# Reset the unbounced code&lt;/span&gt;
wbregs bounces     &lt;span class=&quot;c&quot;&gt;# Verify that the two counts have returned to zero&lt;/span&gt;
wbregs duration&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;That’s it!  You now have all the information you need to either build and
measure your own debouncer, or to just measure the bounces on your own
device.  Further, all of the debouncing logic, design, and software files
have been placed into their own
&lt;a href=&quot;https://github.com/ZipCPU/debouncer&quot;&gt;GitHub repo&lt;/a&gt; for your own reference.&lt;/p&gt;

&lt;hr /&gt;&lt;p&gt;&lt;em&gt;As cold waters to a thirsty soul, so is good news from a far country.  (Prov 25:25)&lt;/em&gt;</description>
        <pubDate>Mon, 07 Aug 2017 00:00:00 -0400</pubDate>
        <link>http://zipcpu.com/blog/2017/08/07/bounce-dbgbus.html</link>
        <guid isPermaLink="true">http://zipcpu.com/blog/2017/08/07/bounce-dbgbus.html</guid>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>Measuring Contact Bounce</title>
        <description>&lt;p&gt;Buttons and switches on
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;’s
can be very useful to work with.  This extra
user I/O on a development board can make life easier when trying to direct
what is going on within it, or when trying to debug logic within the board.
The problem is that these forms of inputs often
“&lt;a href=&quot;https://en.wikipedia.org/wiki/Switch#Contact_bounce&quot;&gt;bounce&lt;/a&gt;”,
and produce multiple transitions when only one was directed.&lt;/p&gt;

&lt;p&gt;This problem is particularly problematic in the fact that it is difficult
to simulate hardware
&lt;a href=&quot;https://en.wikipedia.org/wiki/Switch#Contact_bounce&quot;&gt;bounces&lt;/a&gt;,
since they tend to be quite random.&lt;/p&gt;

&lt;p&gt;Our &lt;a href=&quot;/blog/2017/08/02/debounce-teaser.html&quot;&gt;first post&lt;/a&gt;
on this topic looked into how this sort of
&lt;a href=&quot;https://en.wikipedia.org/wiki/Switch#Contact_bounce&quot;&gt;bouncing&lt;/a&gt;
manifested.  It wasn’t pretty, as many buttons from several different
boards and even a keypad all demonstrated this problem.&lt;/p&gt;

&lt;p&gt;Our &lt;a href=&quot;/blog/2017/08/04/debouncing.html&quot;&gt;second post&lt;/a&gt;
discussed how to create the &lt;a href=&quot;https://github.com/ZipCPU/debouce/trunk/blob/master/rtl/debounce.html&quot;&gt;digital logic necessary to
debounce&lt;/a&gt;
a user input.&lt;/p&gt;

&lt;p&gt;Today, we’ll discuss how to measure the effect
&lt;a href=&quot;https://en.wikipedia.org/wiki/Switch#Contact_bounce&quot;&gt;bouncing&lt;/a&gt;
has on your input logic.&lt;/p&gt;

&lt;h1 id=&quot;measuring-the-reality-of-buttons-bouncing&quot;&gt;Measuring the Reality of Buttons: Bouncing&lt;/h1&gt;

&lt;p&gt;To try to capture this phenomena, let’s look at two things in particular.&lt;/p&gt;

&lt;p&gt;First, we’ll count the number of state transitions as in Fig 1 below.  In
the case of a button,
the first transition should be when the button is pressed, and the second
transition when the button is released.  In the case of a switch, only
one transition should ever take place.  It either of the two
&lt;a href=&quot;https://en.wikipedia.org/wiki/Switch#Contact_bounce&quot;&gt;bounces&lt;/a&gt;, we should be
able to tell.  In particular, the number of transitions would be
something other than two for a button or one for a switch.&lt;/p&gt;

&lt;table style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 1: Measuring Transitions&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/button-transitions.svg&quot; alt=&quot;Counting how many transitions a button creates&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;The second thing we we might wish to measure is how many clocks it takes
for the transitions to take place.  For example, with a button, this will
be the number of clocks from the first press to the last bounce on release,
as shown in Fig 2 below.  It won’t tell us as much about
&lt;a href=&quot;https://en.wikipedia.org/wiki/Switch#Contact_bounce&quot;&gt;bouncing&lt;/a&gt;, though, since
the bounces will have settled long before this measurement is concluded.
It might still tell us something about the nature and character of a button
press in general.  We can then use this information to understand how to
tune our &lt;a href=&quot;/blog/2017/08/04/debouncing.html&quot;&gt;debouncing
logic&lt;/a&gt;.&lt;/p&gt;

&lt;table style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 2: Measuring Button Press Duration&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/button-duration.svg&quot; alt=&quot;Counting a button press duration&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;h1 id=&quot;building-the-code-the-unbouncer&quot;&gt;Building the code: The Unbouncer&lt;/h1&gt;

&lt;p&gt;We’ll handle the first two measurements in a routine I’m going to call
&lt;a href=&quot;https://github.com/ZipCPU/debouncer/blog/master/rtl/unbounced.v&quot;&gt;unbounced&lt;/a&gt;.
This &lt;em&gt;unbouncer&lt;/em&gt; will help to tell us what has been going on within our
design.&lt;/p&gt;

&lt;p&gt;As we discussed during our discussion on
&lt;a href=&quot;/blog/2017/08/04/debouncing.html&quot;&gt;debouncing logic&lt;/a&gt;,
the first step of necessity is going to be to synchronize our inputs.
This synchronization is our approach to take the incoming button logic
signal, and make sure that any logic depending upon this information has
its &lt;a href=&quot;https://en.wikipedia.org/wiki/Flip-flop_(electronics)#Timing_considerations&quot;&gt;setup and
hold&lt;/a&gt;
requirements met.  It also helps us avoid any issues with
&lt;a href=&quot;https://en.wikipedia.org/wiki/Metastability_in_electronics&quot;&gt;metastability&lt;/a&gt;,
lest our logic act in an unpredictable (and incomprehensible) manner later.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
begin
	// Two clocks to synchronize asynchronous data
	q_in   &amp;lt;= i_in;
	r_in   &amp;lt;= q_in; // SYNCHRONIZED!
	// Keep track of last value, so we can find changes
	r_last &amp;lt;= r_in;
end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Once the inputs have been synchronized, we can then count the number of
times they change.  We’ll reset our count upon any reset request, but ever
afterwards we can just increment our counter on any changes:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	if (i_reset)
		o_transitions &amp;lt;= 0;
	else if (r_last != r_in)
		o_transitions &amp;lt;= o_transitions + 1&#39;b1;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;As we mentioned above, a button press should produce two transitions: one
when the button is pressed, and one when it is released.  Anything else is
an indication of
&lt;a href=&quot;https://en.wikipedia.org/wiki/Switch#Contact_bounce&quot;&gt;bouncing&lt;/a&gt;.
This simple counter can be used to test whether there was a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Switch#Contact_bounce&quot;&gt;bounce&lt;/a&gt; or not.&lt;/p&gt;

&lt;p&gt;The other thing we’re going to want to do is count how much time it takes
from the initial change (button press) until the final change (button release).
We’ll use the &lt;code class=&quot;highlighter-rouge&quot;&gt;triggered&lt;/code&gt; signal to determine when to run our counter, and
so run the counter any time after the button was &lt;code class=&quot;highlighter-rouge&quot;&gt;triggered&lt;/code&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	if (i_reset)
		triggered &amp;lt;= 1&#39;b0;
	else if (r_last != r_in)
		triggered &amp;lt;= 1&#39;b1;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Let’s just remember that we’re going to need to reset our logic
between events, so we can re-trigger on the next event.&lt;/p&gt;

&lt;p&gt;Next, we’ll keep track of the time since the last trigger:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	if (i_reset)
		counter &amp;lt;= 0;
	else if ((triggered)&amp;amp;&amp;amp;(!clock[31]))
		counter &amp;lt;= counter + 1&#39;b1;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Note that this “counter” measure will saturate once the top bit sets.  This
will give us about 21~seconds of measurement before losing track of what’s
going on (assuming a 100MHz clock).  That should be plenty for our purposes.&lt;/p&gt;

&lt;p&gt;Once we have this “time-since-event” above, we can then measure the maximum
amount of time that takes place between the initial button press and the
last change.  We’ll set this to zero upon an external reset, and ever
afterwards if our button input &lt;code class=&quot;highlighter-rouge&quot;&gt;r_in&lt;/code&gt; doesn’t match what it was once clock
ago, we’ll update our maximum clock duration value.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	if (i_reset)
		o_max_clock &amp;lt;= 0;
	else if (r_last != r_in)
		o_max_clock &amp;lt;= counter;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This &lt;code class=&quot;highlighter-rouge&quot;&gt;o_max_clock&lt;/code&gt; value will therefore capture the number of clocks between
a trigger and the last transition.&lt;/p&gt;

&lt;h2 id=&quot;coming-back-to-the-debug-bus&quot;&gt;Coming back to the Debug Bus&lt;/h2&gt;

&lt;p&gt;At this point, many students would turn to a
&lt;a href=&quot;https://store.digilentinc.com/pmod-ssd-seven-segment-display/&quot;&gt;7-segment display&lt;/a&gt;,
&lt;a href=&quot;https://store.digilentinc.com/pmod-8ld-eight-high-brightness-leds&quot;&gt;LED’s&lt;/a&gt;,
an &lt;a href=&quot;https://store.digilentinc.com/pmodclp-character-lcd-with-parallel-interface&quot;&gt;LCD&lt;/a&gt;,
or another &lt;a href=&quot;https://store.digilentinc.com/pmod-oledrgb-96-x-64-rgb-oled-display-with-16-bit-color-resolution/&quot;&gt;display output&lt;/a&gt;
to return these numbers.  This becomes a trap for
the student, though, because the problems associated with displaying these
values (particularly the &lt;a href=&quot;https://store.digilentinc.com/pmod-ssd-seven-segment-display/&quot;&gt;7-segment
display&lt;/a&gt;
or &lt;a href=&quot;https://store.digilentinc.com/pmodclp-character-lcd-with-parallel-interface&quot;&gt;LCD&lt;/a&gt;) can be just as complicated,
if not more so, than the simple button pressing logic we’ve presented above.
When this student then wants to isolate the bug he is getting to be either
the debouncing module or the display module, he can’t tell which is causing
the problem.&lt;/p&gt;

&lt;p&gt;Let’s avoid this mistake by integrating our
&lt;a href=&quot;https://github.com/ZipCPU/debouncer/trunk/rtl/deboucer.v&quot;&gt;debouncing&lt;/a&gt;
and &lt;a href=&quot;https://github.com/ZipCPU/debouncer/trunk/rtl/unbounced.v&quot;&gt;unbouncing&lt;/a&gt;
logic into a &lt;a href=&quot;https://github.com/ZipCPU/dbgbus&quot;&gt;debugging bus&lt;/a&gt;, such as
the &lt;a href=&quot;https://github.com/ZipCPU/dbgbus/tree/master/hexbus&quot;&gt;one we built together
earlier&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;This will be our next step: How to integrate our
&lt;a href=&quot;https://github.com/ZipCPU/debouncer/blob/master/rtl/debouncer.v&quot;&gt;debouncer&lt;/a&gt;
together with
&lt;a href=&quot;https://github.com/ZipCPU/debouncer/blob/master/rtl/unbounced.v&quot;&gt;today’s unbounced logic&lt;/a&gt;
and the &lt;a href=&quot;https://github.com/ZipCPU/dbgbus&quot;&gt;debugging bus&lt;/a&gt;, so that we can get
bounce information from within an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;.
Even better, if we include a
&lt;a href=&quot;http://github.com/ZipCPU/wbscope/blob/master/rtl/wbscopc.v&quot;&gt;compressed&lt;/a&gt;
&lt;a href=&quot;http://github.com/ZipCPU/wbscope&quot;&gt;wishbone scope&lt;/a&gt; into that project, you’ll
be able to generate your own button bouncing traces.&lt;/p&gt;

&lt;hr /&gt;&lt;p&gt;&lt;em&gt;And this is the fashion which thou shalt make it of: The length of the ark shall be three hundred cubits, the breadth of it fifty cubits, and the height of it thirty cubits. (Genesis 6:15)&lt;/em&gt;</description>
        <pubDate>Sat, 05 Aug 2017 00:00:00 -0400</pubDate>
        <link>http://zipcpu.com/blog/2017/08/05/bounce-metric.html</link>
        <guid isPermaLink="true">http://zipcpu.com/blog/2017/08/05/bounce-metric.html</guid>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>How to eliminate button bounces with digital logic</title>
        <description>&lt;p&gt;The fundamental way to avoid &lt;a href=&quot;/fpga-hell.md&quot;&gt;FPGA Hell&lt;/a&gt; is
to start from a small design and to build to a more complex design one small
piece at a time.  You might even call this &lt;em&gt;good engineering process.&lt;/em&gt;  Along
the way, you’ll want to avoid changing too many things at once.  Lest, if you
introduce too many changes at the same time, you’ll never know which change
is keeping your design from working.  Hence, your goal should be to build
your complex designs from an initial simple design, modified by only simple
changes.&lt;/p&gt;

&lt;p&gt;The corollary to this rule is to make certain that your test and debug
infrastructure, I like to call this your &lt;em&gt;scaffolding&lt;/em&gt;, is never one of
multiple unknowns within your design.  There is a time for testing the
scaffolding of your design: &lt;em&gt;before you need it&lt;/em&gt;.  You want to be convinced
in the reliability of your scaffolding before you ever commit your time
and design to its strength.&lt;/p&gt;

&lt;p&gt;This has a particular application when you wish to use the buttons, switches,
or keypad entry mechanisms to your design.  My advice?  Don’t use them as part
of your debug infrastructure until you have &lt;em&gt;proven&lt;/em&gt; that they work the way
you want them to work first.  The reason is that buttons bounce, and
creating a signal that doesn’t bounce requires digital logic.&lt;/p&gt;

&lt;p&gt;What makes a button debouncing circuit particularly unique when it comes to
debugging, is that it is
difficult to test apart from using a real button.  You just can’t simulate
an unknown piece of hardware’s response very well.  This is what makes the
coupling of the &lt;a href=&quot;https://github.com/ZipCPU/dbgbus&quot;&gt;debugging bus&lt;/a&gt; and
&lt;a href=&quot;https://github.com/ZipCPU/wbscope&quot;&gt;wishbone scope&lt;/a&gt; so powerful: using them,
you can not only measure what’s going on any time a button gets pressed, but
you can also measure whether or not your debouncing logic works within that
context.&lt;/p&gt;

&lt;p&gt;In this article, we will examine how to debounce a set of button inputs,
so that they can then be used as part of your test infrastructure.&lt;/p&gt;

&lt;h2 id=&quot;generating-events&quot;&gt;Generating Events&lt;/h2&gt;

&lt;p&gt;User inputs, whether they be button presses, switches, or other, can be a very
valuable part of your design.  They can be used
to reset your board, to start a test, or even to enter data into your design.
Indeed, once you cut the umbilical (&lt;a href=&quot;https://en.wikipedia.org/wiki/JTAG&quot;&gt;JTAG&lt;/a&gt;,
&lt;a href=&quot;https://en.wikipedia.org/wiki/Universal_asynchronous_receiver/transmitter&quot;&gt;UART&lt;/a&gt;, or
&lt;a href=&quot;https://github.com/ZipCPU/dbgbus/&quot;&gt;debugging bus&lt;/a&gt;) to your
board, such inputs may be the only means you have remaining of controlling
your board.&lt;/p&gt;

&lt;p&gt;To understand how valuable these inputs can be, consider the following
scenarios where student’s have tried to use a button:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;One student thought it would be nice to create a design that prints &lt;a href=&quot;https://en.wikipedia.org/wiki/&amp;quot;Hello,_World!&amp;quot;_program&quot;&gt;Hello
World&lt;/a&gt;
anytime a button is pressed.&lt;/p&gt;

    &lt;p&gt;This student hadn’t yet gotten his first serial port to work.  By adding
the button processing to his design, he added an additional unknown to the
design and was thus unable to discern which piece of logic was failing
when the whole didn’t work.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Another student’s challenge was to increment a counter every time a key was
pressed.
&lt;a href=&quot;https://forum.digilentinc.com/topic/3992-something-simple-is-apparently-impossible-incrdec-number/&quot;&gt;[1]&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;This sounds easy, right?&lt;/p&gt;

    &lt;p&gt;This student was surprised to discover that every time he pressed a button,
his counter jumped by more than a single count.  He was expecting a single
state change only.  Indeed, his design depended upon being able to detect
singular button press events.  The multiple detected events “broke” the
design he was building.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;While both of these applications are valid applications of a button, both
students ended up stuck with an FPGA design that didn’t work because they
weren’t aware of the difficulty associated with buttons: they bounce.&lt;/p&gt;

&lt;p&gt;Turning a button from a bouncing electrical signal into a useful entry method
requires some &lt;em&gt;debouncing logic&lt;/em&gt;.&lt;/p&gt;

&lt;h2 id=&quot;metastability-and-avoiding-the-beginners-mistakes&quot;&gt;Metastability, and avoiding the beginner’s mistakes&lt;/h2&gt;

&lt;p&gt;Before we dig deeply into how to &lt;em&gt;debounce&lt;/em&gt; a button, let’s take a quick
moment to mention how &lt;em&gt;not&lt;/em&gt; to work with a button.&lt;/p&gt;

&lt;p&gt;The beginner is often enticed by the capabilities of a chip to transition on 
a positive edge.  Hence, I’ve seen many beginners start their approach with&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;initial	event = 1&#39;b0;
always @(posedge i_button, posedge i_reset)
	if (i_reset)
		// Reset our system whenever i_reset is true
		event &amp;lt;= 1&#39;b0
	else
		event &amp;lt;= 1&#39;b1;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The same mistake can be manifest in an attempt to count events, as in:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;initial	event = 1&#39;b0;
always @(posedge i_button, posedge i_reset)
	if (i_reset)
		counter &amp;lt;= 0;
	else
		counter &amp;lt;= counter + 1&#39;b1;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Both of these approaches to measuring buttons are problematic.&lt;/p&gt;

&lt;p&gt;Here’s why:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Timing&lt;/strong&gt;: &lt;code class=&quot;highlighter-rouge&quot;&gt;i_button&lt;/code&gt; is not a clock.  Your tool-suite will struggle to
analyze the timing between when a button press event takes place and
the rest of the logic within your design.  It’s going to try to optimize
the distance (in time and space) between the button press logic taking
place and the logic that depends upon it, and since the button press wasn’t
a clock the result will be difficult to analyze.  The result will be
unreliable logic in the rest of your circuit.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Asynchronous reset&lt;/strong&gt;’s tend to have a propagation delay when they work
their way through your circuitry.  Therefore, they may reset one portion
of your circuitry before another.  While this might not be such a problem
if every part of the circuit gets reset eventually, this doesn’t mitigate
the exit from the asynchronous reset .  Hence, when using an asynchronous
reset, you may find some pieces of logic are released from reset before
other pieces of logic. (This is &lt;em&gt;bad&lt;/em&gt;)&lt;/p&gt;

    &lt;p&gt;Particularly problematic are spurious reset signals that last for less than
a clock interval, perhaps created by some radio frequency interference
within the FPGA board’s environment.  These signals may partially but not
completely reset an FPGA’s logic.&lt;/p&gt;

    &lt;p&gt;&lt;strong&gt;The beginner’s reset rule:&lt;/strong&gt; Just avoid the asynchronous reset.  This
is easily done by removing &lt;code class=&quot;highlighter-rouge&quot;&gt;posedge i_reset&lt;/code&gt; from the dependency line in
the always block.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Given this information, let’s try to build our logic again:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;initial	down  = 1&#39;b0;
initial	event = 1&#39;b0;
always @(posedge i_clk)
	if (i_reset)
	begin
		down  &amp;lt;= 0;
		event &amp;lt;= 0;
	end else begin
		down &amp;lt;= i_button;
		event &amp;lt;= (i_button)&amp;amp;&amp;amp;(!down);
	end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This approach, while better than the first one, is still problematic.&lt;/p&gt;

&lt;p&gt;While this avoids the asynchronous reset, it now has a problem with
&lt;a href=&quot;https://en.wikipedia.org/wiki/Metastability_in_electronics&quot;&gt;metastability&lt;/a&gt;. 
Specifically, &lt;code class=&quot;highlighter-rouge&quot;&gt;i_button&lt;/code&gt; may not have settled for enough time prior to the
clock to create a stable logic signal.  As a result, the &lt;code class=&quot;highlighter-rouge&quot;&gt;down&lt;/code&gt; register may
be indeterminate. Some parts of your circuitry may decide &lt;code class=&quot;highlighter-rouge&quot;&gt;down&lt;/code&gt; is true,
while other parts deciding &lt;code class=&quot;highlighter-rouge&quot;&gt;down&lt;/code&gt; is false.  You may get two events in a
row, or no events at all.&lt;/p&gt;

&lt;p&gt;To avoid these problems, stick to these rules:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Use the positive edge of a single clock for &lt;em&gt;all&lt;/em&gt; of your logic.
I like to use the same basic clock wire, &lt;code class=&quot;highlighter-rouge&quot;&gt;i_clk&lt;/code&gt;, within all my modules
for this purpose.  The &lt;code class=&quot;highlighter-rouge&quot;&gt;i_clk&lt;/code&gt; signal itself is either externally generated,
or the result of a PLL applied to an external clock signal.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;For any logic inputs that are not created synchronously to your clock,
such as your button inputs, clock them through a pair of flip flops
(example below).  This applies to all external user input devices, such
as buttons, switches, and keypad entry.  This rule also applies to all
of your external asynchronous inputs as well: PS/2 devices, UARTs, or
indeed any wires coming from external circuits that do not share your clock.&lt;/p&gt;

    &lt;p&gt;While this alone doesn’t solve the problem of bouncing, it will make
actually dealing with it a lot easier.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Using these rules, we can create a clock synchronous button input.  The first
step is to run the button input through two flip-flops to avoid any
&lt;a href=&quot;https://en.wikipedia.org/wiki/Metastability_in_electronics&quot;&gt;metastability&lt;/a&gt;
issues.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;initial	sync_pipe      = 1&#39;b0;
initial	r_button_state = 1&#39;b0;
always @(posedge i_clk)
	{ r_button_state, sync_pipe }
		&amp;lt;= { sync_pipe, i_button };&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;r_button_state&lt;/code&gt; has now gone through two flip flops from &lt;code class=&quot;highlighter-rouge&quot;&gt;i_button&lt;/code&gt;, and so
it will be a one or a zero to all logic within your FPGA.  Now that the
button input has been synchronized to our clock, we can detect when the
button input changes with such simple code as:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;initial	r_last         = 1&#39;b0;
initial	r_button_event = 1&#39;b0;
always @(posedge i_clk)
begin
	r_last &amp;lt;= r_button_state;
	r_button_event &amp;lt;= (r_button_state)&amp;amp;&amp;amp;(!r_last);
end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The nice part of this technique for generating &lt;code class=&quot;highlighter-rouge&quot;&gt;r_button_event&lt;/code&gt;, is that it
will only ever be true &lt;em&gt;once&lt;/em&gt; for every time the &lt;code class=&quot;highlighter-rouge&quot;&gt;i_button&lt;/code&gt; goes from off to
on.&lt;/p&gt;

&lt;p&gt;The other common piece of logic drawn from an external button input is a
counter.  Let’s assume that our reset input, &lt;code class=&quot;highlighter-rouge&quot;&gt;i_reset&lt;/code&gt; is synchronous–perhaps
you created it via the &lt;a href=&quot;https://github.com/ZipCPU/dbgbus&quot;&gt;dbgbus&lt;/a&gt;
infrastructure &lt;a href=&quot;/blog/2017/06/28/dbgbus-goal.html&quot;&gt;we’ve already
built&lt;/a&gt;.  We can
use that input to increment our counter, and then we can use the button event
we just created to increment a counter:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	if (i_reset)
		counter &amp;lt;= 0;
	else if (r_button_event)
		counter &amp;lt;= counter + 1&#39;b1;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;At this point we’ve only solved the problems with metastability, the
asynchronous clock, and synchronizing the button input to our clock.
Now that we know how to avoid these mistakes, let’s &lt;em&gt;debounce&lt;/em&gt; this button.&lt;/p&gt;

&lt;h2 id=&quot;a-very-simple-debouncer&quot;&gt;A Very Simple Debouncer&lt;/h2&gt;

&lt;p&gt;The basic approach to debouncing a button is to prevent the button’s output
from changing more than once every &lt;code class=&quot;highlighter-rouge&quot;&gt;N&lt;/code&gt; clocks.  Hence, we’ll build our
approach to debouncing around a timer, &lt;code class=&quot;highlighter-rouge&quot;&gt;timer&lt;/code&gt;, that simply counts down to
zero.  Any time this &lt;code class=&quot;highlighter-rouge&quot;&gt;timer&lt;/code&gt; reaches zero, the current value will be forwarded
to the output.  Further, we can control the time interval by just adjusting
the number of bits in the timer.  We’ll call this number of bits &lt;code class=&quot;highlighter-rouge&quot;&gt;LGWAIT&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Given those goals, here’s the code for a very simple digital logic debouncer:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;initial timer = {(LGWAIT){1&#39;b1}};
always @(posedge i_clk)
	timer &amp;lt;= timer - 1&#39;b1;
always @(posedge i_clk)
	if (timer == 0)
		o_debounced &amp;lt;= r_button_state;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This approach should be good enough for most uses, so if you just want a very
simple debouncing circuit this one will work.&lt;/p&gt;

&lt;p&gt;However, if the latency in reporting the button press is important to you,
this piece of logic may cause the button press indication to wait for up to
&lt;code class=&quot;highlighter-rouge&quot;&gt;2^(LGWAIT)&lt;/code&gt; samples before being reported.  This problem is shown in Fig
1 below.&lt;/p&gt;

&lt;table style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 1: Traditional Debouncer&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/debounce-traditional.svg&quot; alt=&quot;Traditional debouncing logic&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;This figure hows a “slow timer” in its top line.  Any time the &lt;code class=&quot;highlighter-rouge&quot;&gt;timer&lt;/code&gt;
finishes counting down, the slow timer line changes as a visual reference.
Notice then how the button press needs to wait on a transition in 
slow timer (&lt;code class=&quot;highlighter-rouge&quot;&gt;timer == 0&lt;/code&gt;) before it reports a button press?
That latency is what I’m talking about.&lt;/p&gt;

&lt;p&gt;So, let’s return to this concept and see if we can’t do any better.&lt;/p&gt;

&lt;h2 id=&quot;a-debouncer-with-more-immediate-results&quot;&gt;A Debouncer with more Immediate Results&lt;/h2&gt;

&lt;p&gt;This time, let’s rebuild this debouncing circuit around the idea that a
pressed button should be reported immediately, but that following changes
should be held off at least &lt;code class=&quot;highlighter-rouge&quot;&gt;N=2^(LGWAIT)&lt;/code&gt; clocks after that.  Fig 2 captures
this concept.&lt;/p&gt;

&lt;table style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 2: Low-latency debouncer&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/debounce-immediate.svg&quot; alt=&quot;An immediate response debouncer&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;In this approach, the timer starts when the first change is detected.
While the timer is counting, changes are not permitted.  As a result, the
latency should be much lower than before.&lt;/p&gt;

&lt;p&gt;We’ll follow some of the lessons from our post on how to &lt;a href=&quot;/blog/2017/06/12/minimizing-luts.html&quot;&gt;minimize
logic resources&lt;/a&gt;.
In particular, we’ll use a second register, &lt;code class=&quot;highlighter-rouge&quot;&gt;ztimer&lt;/code&gt;, together with our timer.
This register will be a single wire only, and we’ll set it to true any time
&lt;code class=&quot;highlighter-rouge&quot;&gt;timer&lt;/code&gt; is zero.  Finally, as we are going to set this up, any time &lt;code class=&quot;highlighter-rouge&quot;&gt;ztimer&lt;/code&gt;
is true the circuit will be responsive to a changing signal.&lt;/p&gt;

&lt;p&gt;So here’s the code for the &lt;code class=&quot;highlighter-rouge&quot;&gt;timer&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;ztimer&lt;/code&gt;:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;initial	ztimer = 1&#39;b1;
initial	timer  = 0;
always @(posedge i_clk)
	if ((ztimer)&amp;amp;&amp;amp;(different))
	begin
		timer  &amp;lt;= {(LGWAIT) {1&#39;b1} };
		ztimer &amp;lt;= 1&#39;b0;
	end else if (!ztimer)
	begin
		timer  &amp;lt;= timer - 1&#39;b1;
		ztimer &amp;lt;= (timer[(LGWAIT-1):1] == 0);
	end else begin
		ztimer &amp;lt;= 1&#39;b1;
		timer  &amp;lt;= 0;
	end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The count-down will begin any time the &lt;code class=&quot;highlighter-rouge&quot;&gt;timer&lt;/code&gt; is at zero (&lt;code class=&quot;highlighter-rouge&quot;&gt;ztimer&lt;/code&gt; is high),
and the inputs are &lt;code class=&quot;highlighter-rouge&quot;&gt;different&lt;/code&gt; from what they were.  (We’ll come back to this
in a moment.)    Once the timer is running, it will count down to zero.
When it hits zero, it will hold there until another change has been detected.&lt;/p&gt;

&lt;p&gt;As mentioned above, we’ll use the register &lt;code class=&quot;highlighter-rouge&quot;&gt;different&lt;/code&gt; to signal any time the
input is different from the output of our debouncing circuit.  &lt;code class=&quot;highlighter-rouge&quot;&gt;different&lt;/code&gt;,
though, will then need to remain true until any ongoing countdown completes.
Hence, as long as &lt;code class=&quot;highlighter-rouge&quot;&gt;different&lt;/code&gt; gets set, either when the timer isn’t counting
or between count-downs, &lt;code class=&quot;highlighter-rouge&quot;&gt;different&lt;/code&gt; will make sure that the timer restarts
again.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	different &amp;lt;= ((different)&amp;amp;&amp;amp;(!ztimer))||(r_in != o_debounced);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;We now finally have all the pieces necessary to create our low-latency
debounced output.  This output will be set to whatever we just finished
reading, but only ever anytime &lt;code class=&quot;highlighter-rouge&quot;&gt;ztimer&lt;/code&gt; is set.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;initial	o_debounced = { (NIN) {1&#39;b0} };
always @(posedge i_clk)
	if (ztimer)
		o_debounced &amp;lt;= r_last;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Notice the choice to set &lt;code class=&quot;highlighter-rouge&quot;&gt;o_debounced&lt;/code&gt; any time &lt;code class=&quot;highlighter-rouge&quot;&gt;ztimer&lt;/code&gt; is true, coupled with
the fact that &lt;code class=&quot;highlighter-rouge&quot;&gt;ztimer&lt;/code&gt; idles at zero.  Because of this, any time a button is
pressed (or released), while the circuit is idle (&lt;code class=&quot;highlighter-rouge&quot;&gt;ztimer&lt;/code&gt; is true), will
immediately adjust &lt;code class=&quot;highlighter-rouge&quot;&gt;o_debounced&lt;/code&gt; with the new value.  Subsequent bounces,
until the signal becomes stable again, will be limited to only change every
&lt;code class=&quot;highlighter-rouge&quot;&gt;2^LGWAIT&lt;/code&gt; clocks.&lt;/p&gt;

&lt;p&gt;Now, if we go back and review some of the button presses from the &lt;a href=&quot;/blog/2017/08/02/debounce-teaser.html&quot;&gt;opening
post on debouncing&lt;/a&gt;,
you’ll be able to understand the debounced trace in Fig 3. below.&lt;/p&gt;

&lt;table style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 3: Debouncing Result&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/kypad.png&quot; alt=&quot;Example debouncing trace&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;In particular, notice how the &lt;code class=&quot;highlighter-rouge&quot;&gt;debounced&lt;/code&gt; trace changes immediately as soon
as the button is pressed, and before it is done bouncing.  It doesn’t change
again until all the bouncing is over, and the user releases the button.&lt;/p&gt;

&lt;p&gt;This demonstrates that our logic actually worked.&lt;/p&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;While this post presents &lt;a href=&quot;https://github.com/ZipCPU/debouncer/blob/master/rtl/debouncer.v&quot;&gt;working debouncing
logic&lt;/a&gt;, the
task remains far from complete.  For example, how many bits (&lt;code class=&quot;highlighter-rouge&quot;&gt;LGWAIT&lt;/code&gt;) need
to be allocated to the counter?  Not quite so subtle is the question of how
shall this capability be proven?  In particular, this logic requires
an external button input bounce in order to properly verify its functionality.&lt;/p&gt;

&lt;p&gt;Our &lt;a href=&quot;/blog/2017/08/05/bounce-metric.html&quot;&gt;next post&lt;/a&gt;,
therefore, will focus on
&lt;a href=&quot;/blog/2017/08/05/bounce-metric.html&quot;&gt;how to measure bounces&lt;/a&gt;
so we can
tell if a bounce has taken place.  After that, we’ll discuss
&lt;a href=&quot;/blog/2017/08/07/bounce-dbgbus.html&quot;&gt;how to modify the&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/dbgbus&quot;&gt;debugging bus&lt;/a&gt; for this purpose, and to get
a trace from within the design so we can see what’s going on.  Then we’ll go
and move on to the next topic.&lt;/p&gt;

&lt;hr /&gt;&lt;p&gt;&lt;em&gt;Can the Ethiopian change his skin, or the leopard his spots? then may ye also do good, that are accustomed to do evil. (Jer 13:23)&lt;/em&gt;</description>
        <pubDate>Fri, 04 Aug 2017 00:00:00 -0400</pubDate>
        <link>http://zipcpu.com/blog/2017/08/04/debouncing.html</link>
        <guid isPermaLink="true">http://zipcpu.com/blog/2017/08/04/debouncing.html</guid>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>Visualizing Contact Bounce</title>
        <description>&lt;p&gt;If you’ve ever tried to press a button on an FPGA board, you might expect a response similar to Fig 1 below:&lt;/p&gt;

&lt;table style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 1: A Simple button press&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/arty-simple-press.png&quot; alt=&quot;A Simple Button Press on the Arty&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;You want the button to transition from low (idle) to high (pressed) once for
every time your finger pushes the button.  You also want the button to return
to zero in a similarly simple fashion.  In Fig 1 above, &lt;code class=&quot;highlighter-rouge&quot;&gt;i_btn&lt;/code&gt; does just
that, although only the button press (&lt;code class=&quot;highlighter-rouge&quot;&gt;i_btn&lt;/code&gt; rises) is shown and not the
button release.&lt;/p&gt;

&lt;p&gt;In reality, electrical contacts don’t work that way.&lt;/p&gt;

&lt;p&gt;The following several images show examples of what happens when a button is
either pressed or released.  In each of them, &lt;code class=&quot;highlighter-rouge&quot;&gt;i_btn&lt;/code&gt; is the raw input from
the external port, whereas &lt;code class=&quot;highlighter-rouge&quot;&gt;debounced&lt;/code&gt; is the result of a debouncing circuit
that we’ll discuss over the next couple of posts.  Further, you may notice
that the number of wires in &lt;code class=&quot;highlighter-rouge&quot;&gt;i_btn&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;debounced&lt;/code&gt; changes from board to
board–this is just a reality of different boards having different numbers
of buttons.&lt;/p&gt;

&lt;p&gt;For example, Fig 2 shows the logic read when a button was released on
&lt;a href=&quot;https://store.digilentinc.com/arty-artix-7-fpga-development-board-for-makers-and-hobbyists/&quot;&gt;Digilent’s Arty development board&lt;/a&gt;.&lt;/p&gt;

&lt;table style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 2: A not so simple release&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/arty-release.png&quot; alt=&quot;A trace of a button release from the Arty&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Notice how &lt;code class=&quot;highlighter-rouge&quot;&gt;i_btn&lt;/code&gt; doesn’t simply transition back to zero (off) when the button
is released, but rather bounces on its way down.
It’s not that the board is broken, its not.  The board actually works quite
well.  Rather, the signal from a changing button doesn’t always simply change.
It tends to bounce as well.&lt;/p&gt;

&lt;p&gt;Figs 3 and 4 show bouncing as measured on the &lt;a href=&quot;http://www.icoboard.org&quot;&gt;ICO
board&lt;/a&gt;.&lt;/p&gt;

&lt;table style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 3: ICO Board Button Press with Bounce&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/ico-entry-bounce.png&quot; alt=&quot;Example FIFO read/write pointers&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;table style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 4: ICO Board Button Release with Multiple Bounces&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/ico-tripl-bounce.png&quot; alt=&quot;Example FIFO read/write pointers&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Notice that, though we’ve switched boards, the button on this other board
still bounces.&lt;/p&gt;

&lt;p&gt;In case you think the reason for the bounce might be because both the
&lt;a href=&quot;https://store.digilentinc.com/arty-artix-7-fpga-development-board-for-makers-and-hobbyists/&quot;&gt;Arty&lt;/a&gt;.
and the &lt;a href=&quot;https://www.icoboard.org&quot;&gt;ICO Board&lt;/a&gt; use similar buttons, Figs 5-8
show example button bounces from the &lt;a href=&quot;https://store.digilentinc.com/pmod-kypd-16-button-keypad/&quot;&gt;PMod
Keypad&lt;/a&gt; as measured
by a &lt;a href=&quot;http://store.digilentinc.com/cmod-s6-breadboardable-spartan-6-fpga-module&quot;&gt;CMod S6 board&lt;/a&gt;.  Since the keypads logic is inverted from that of the
buttons above, the events presented are actually keypad releases, and not
keypad presses.&lt;/p&gt;

&lt;p&gt;Of these, Fig 5 (below) may show the most severe bounce from the keypad.&lt;/p&gt;

&lt;table style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 5: PMod Keypad Severe Bounce on Release&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/kypad.png&quot; alt=&quot;A trace of a severe bounce when a keypad button is released&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;

&lt;p&gt;Fig 6 appears to be fairly benign, but the key still bounces.&lt;/p&gt;

&lt;table style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 6: PMod Keypad Bounce on Release&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/kypad2.png&quot; alt=&quot;Tracing a button release from a 16-character numeric keypad&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;

&lt;p&gt;Fig 7 shows another two bounces.&lt;/p&gt;

&lt;table style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 7: PMod Keypad Bounce on Release&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/kypad3.png&quot; alt=&quot;Another example trace of a button release from a numeric keypad&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;

&lt;p&gt;Fig 8 shows that the locations appear fairly random–even though it represents
the same number of bounces Fig 7 had.&lt;/p&gt;

&lt;table style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 8: Another PMod Keypad Severe Bounce on Release&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/kypad4.png&quot; alt=&quot;Last example trace from a keypad button release&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;

&lt;p&gt;Measuring this sort of contact bounce isn’t really that hard at
all—especially once you have access to a &lt;a href=&quot;https://github.com/ZipCPU/dbgbus&quot;&gt;debugging bus&lt;/a&gt;
such as the one &lt;a href=&quot;/blog/2017/06/20/dbg-put-together.html&quot;&gt;we built together&lt;/a&gt; on this blog.&lt;/p&gt;

&lt;p&gt;Stick around, and we’ll discuss not only &lt;a href=&quot;/blog/2017/08/04/debouncing.html&quot;&gt;how to debounce a set of
buttons&lt;/a&gt;,
but also how to &lt;a href=&quot;/blog/2017/08/05/bounce-metric.html&quot;&gt;measure the effects of button
bounce&lt;/a&gt;, and
&lt;a href=&quot;/blog/2017/08/07/bounce-dbgbus.html&quot;&gt;how to modify the&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/dbgbus&quot;&gt;debugging bus&lt;/a&gt; project to handle a task
such as this one.&lt;/p&gt;

&lt;hr /&gt;&lt;p&gt;&lt;em&gt;Through thee will we push down our enemies: through thy name will we tread them under that rise up against us. (Ps 44:5)&lt;/em&gt;</description>
        <pubDate>Wed, 02 Aug 2017 00:00:00 -0400</pubDate>
        <link>http://zipcpu.com/blog/2017/08/02/debounce-teaser.html</link>
        <guid isPermaLink="true">http://zipcpu.com/blog/2017/08/02/debounce-teaser.html</guid>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>ZipCPU Advertising</title>
        <description>&lt;p&gt;The ZipCPU blog is supported today by a small number of
&lt;a href=&quot;https://www.patreon.com/ZipCPU&quot;&gt;Patreon&lt;/a&gt; donations.
I do not get any advertising or other revenues for this work.&lt;/p&gt;

&lt;p&gt;Last night, I removed Disqus support from the ZipCPU blog. 
Disqus had offered a free discussion capability at the bottoms of the
various posts, for only “minimal” “unobtrusive” advertising.
I had no problems with this contract, especially since I never saw any of
these advertisements.  (I use a strong Ad-blocker on Firefox, and constantly
tune it personally myself.)&lt;/p&gt;

&lt;p&gt;Monday night, though, I finally saw the first of these “unobtrusive”
advertisements.  I will not repeat what I saw here.  I will summarize my
impression by saying that the advertising I saw on my own blog
page was not consistent with my strong Christian values.&lt;/p&gt;

&lt;p&gt;These values are captured within the Bible, from Genesis to Revelation, and
they are reflected in the verses posted at the bottom of every page.&lt;/p&gt;

&lt;p&gt;I do, however, continue to use Google-Analytics support.  From
Google-Analytics, I can tell
how often web pages on this site get read, which pages are read the most,
and how folks move around the site.  However, if Google-Analytics becomes
a problem, I will remove that capability as well.&lt;/p&gt;

&lt;p&gt;The blog articles posted here take a lot of work to put together.  While I
have nothing in principle against getting some advertising revenue in
addition to &lt;a href=&quot;https://www.patreon.com/ZipCPU&quot;&gt;Patreon&lt;/a&gt; support, I refuse
to sacrifice my morals to get this revenue.&lt;/p&gt;

&lt;p&gt;Please contact me, therefore, if you ever see any advertisements on this
site that would be inconsistent with strong Christian (i.e. Biblical)
moral values.  This includes if you see advertisements showing “skin”,
or otherwise making a profit from another man’s sin and suffering.&lt;/p&gt;
&lt;hr /&gt;&lt;p&gt;&lt;em&gt;Dead flies cause the ointment of the apothecary to send forth a stinking savour: so doth a little folly him that is in reputation for wisdom and honour. (Eccl 10:1)&lt;/em&gt;</description>
        <pubDate>Tue, 01 Aug 2017 00:00:00 -0400</pubDate>
        <link>http://zipcpu.com/blog/2017/08/01/advertising.html</link>
        <guid isPermaLink="true">http://zipcpu.com/blog/2017/08/01/advertising.html</guid>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>Writing your own VCD File</title>
        <description>&lt;p&gt;Some time ago, we discussed how you can &lt;a href=&quot;/blog/2017/06/08/simple-scope.html&quot;&gt;build a scope within your own
logic&lt;/a&gt;, and even &lt;a href=&quot;/blog/2017/06/29/sw-dbg-interface.html&quot;&gt;how to
get the contents of that scope back out of your
FPGA&lt;/a&gt;.  Today, we’ll
finish the discussion by describing what it takes to turn that data into a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Value_change_dump&quot;&gt;Value-Change Dump (VCD)&lt;/a&gt;
file.&lt;/p&gt;

&lt;p&gt;The &lt;a href=&quot;https://en.wikipedia.org/wiki/Value_change_dump&quot;&gt;VCD&lt;/a&gt;
file format structure is a common data format that can be used to store
digital logic traces, so
that you can then later view it with a waveform viewing
tool.  &lt;a href=&quot;https://gtkwave.sourceforge.net&quot;&gt;GTKWave&lt;/a&gt; ingests
&lt;a href=&quot;https://en.wikipedia.org/wiki/Value_change_dump&quot;&gt;VCD&lt;/a&gt;
files easily.
Indeed, two of my favorite tools,
&lt;a href=&quot;https://www.veripool.org/wiki/verilator&quot;&gt;Verilator&lt;/a&gt;
and the &lt;a href=&quot;https://github.com/ZipCPU/wbscope&quot;&gt;wishbone scope&lt;/a&gt;,
will both output
&lt;a href=&quot;https://en.wikipedia.org/wiki/Value_change_dump&quot;&gt;VCD&lt;/a&gt; traces for this purpose.&lt;/p&gt;

&lt;p&gt;One of the really nice parts of this standard is that it is a text-based
standard.  This means you can view, review, and even edit a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Value_change_dump&quot;&gt;VCD&lt;/a&gt; file if you
really need to with your favorite text editor.  While I don’t recommend
it, I have needed to load
&lt;a href=&quot;https://en.wikipedia.org/wiki/Value_change_dump&quot;&gt;VCD&lt;/a&gt; 
files into &lt;a href=&quot;http://www.vim.org&quot;&gt;gvim&lt;/a&gt; from time to time to figure out what’s
wrong (or right) with the file.&lt;/p&gt;

&lt;h2 id=&quot;the-standard&quot;&gt;The standard&lt;/h2&gt;

&lt;p&gt;The actual standard for the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Value_change_dump&quot;&gt;VCD&lt;/a&gt; 
format is part of
&lt;em&gt;&lt;a href=&quot;https://staff.ustc.edu.cn/~songch/download/IEEE.1364-2005.pdf&quot;&gt;The IEEE Standard for (the) Verilog Hardware Description Language&lt;/a&gt;&lt;/em&gt;.
My copy is IEEE Std 1364-2005, where the &lt;a href=&quot;https://en.wikipedia.org/wiki/Value_change_dump&quot;&gt;Value Change Dump
(VCD)&lt;/a&gt;
file format is discussed starting on page 325.&lt;/p&gt;

&lt;p&gt;While this article will discuss some basic components of the standard,
it will by no means by exhaustive.  For further information, you’ll want to
look up the standard itself.&lt;/p&gt;

&lt;h2 id=&quot;the-vcd-header&quot;&gt;The VCD Header&lt;/h2&gt;

&lt;p&gt;The first part of any
&lt;a href=&quot;https://en.wikipedia.org/wiki/Value_change_dump&quot;&gt;VCD&lt;/a&gt; 
file is a header.  There are two primary components to the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Value_change_dump&quot;&gt;VCD&lt;/a&gt; 
file header: basic file meta-data, and variable declarations.
White space is used to separate commands, and to make the file more human
legible.&lt;/p&gt;

&lt;p&gt;The basic file meta-data identifies the program, or program version, that
created the &lt;a href=&quot;https://en.wikipedia.org/wiki/Value_change_dump&quot;&gt;VCD&lt;/a&gt; 
file, as well as the date the trace was created on and the timescale it uses.
As an example, a recent
&lt;a href=&quot;https://www.veripool.org/wiki/verilator&quot;&gt;Verilator&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Value_change_dump&quot;&gt;VCD&lt;/a&gt; 
output file from the
&lt;a href=&quot;https://github.com/ZipCPU/wbuart32/&quot;&gt;wbuart32&lt;/a&gt;
distribution started with the following text:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;$version Generated by VerilatedVcd $end
$date Wed Jun  7 11:35:32 2017
 $end
$timescale 1ns $end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The first line identifies the tool that created the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Value_change_dump&quot;&gt;VCD&lt;/a&gt; 
file and what it’s version is.  This line begins with &lt;code class=&quot;highlighter-rouge&quot;&gt;$version&lt;/code&gt;, and ends
with &lt;code class=&quot;highlighter-rouge&quot;&gt;$end&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The second line identifies when this file was created.  This field begins
with &lt;code class=&quot;highlighter-rouge&quot;&gt;$date&lt;/code&gt; and ends with &lt;code class=&quot;highlighter-rouge&quot;&gt;$end&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The third line identifies the timescale.  The timescale includes a time
number (1, 10, or 100) followed by a unit (s, ms, us, ns, ps, or fs).
Time integers within the file may then be multiplied by this unit to turn them
into engineering units in a display.
I have typically used a time scale of &lt;code class=&quot;highlighter-rouge&quot;&gt;1ns&lt;/code&gt;, although I suspect
&lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;autofpga&lt;/a&gt; files will use more precise
time scales so as to be able to handle multiple dissimilar clocks.&lt;/p&gt;

&lt;p&gt;This ends the necessary file meta-data, but not the end of the header yet.&lt;/p&gt;

&lt;p&gt;The next section of the header declares your variables.  Variables are
defined within a hierarchical scope.  Hence, you’ll seen sections of variables
defined by a &lt;code class=&quot;highlighter-rouge&quot;&gt;$scope&lt;/code&gt; line and ending with an &lt;code class=&quot;highlighter-rouge&quot;&gt;$upscope&lt;/code&gt; line.  The first
line (&lt;code class=&quot;highlighter-rouge&quot;&gt;$scope&lt;/code&gt;) defines the name of the scope the variables are found within. 
For example, variables at the top level of a
&lt;a href=&quot;https://www.veripool.org/wiki/verilator&quot;&gt;Verilator&lt;/a&gt;
produced
&lt;a href=&quot;https://en.wikipedia.org/wiki/Value_change_dump&quot;&gt;VCD&lt;/a&gt; 
file will have a top-level scope of TOP.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt; $scope module TOP $end

 .... (variables defined here)

 $upscope $end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The &lt;code class=&quot;highlighter-rouge&quot;&gt;$scope&lt;/code&gt; line has two words within it.  The first is the type of scope
being referenced.  In this case, it references a &lt;code class=&quot;highlighter-rouge&quot;&gt;module&lt;/code&gt;.  The second
is the name of the scope, &lt;code class=&quot;highlighter-rouge&quot;&gt;TOP&lt;/code&gt;, being
&lt;a href=&quot;https://www.veripool.org/wiki/verilator&quot;&gt;Verilator&lt;/a&gt;’s
term for the top level of a design.&lt;/p&gt;

&lt;p&gt;Variables found within a module &lt;code class=&quot;highlighter-rouge&quot;&gt;foo&lt;/code&gt; within TOP would be defined with
a similar module section, only that this section would be found within the
TOP section.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt; $scope module TOP $end
   ...
   $scope module foo $end
   ... (variables of the foo module within TOP would be defined here)
   $upscope $end
 $upscope $end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Variables themselves are declared on lines between &lt;code class=&quot;highlighter-rouge&quot;&gt;$var&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;$end&lt;/code&gt; tags.
Four tokens are used, between these two flags, to define any variable,
as shown below:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;$var vary_type size identifier_code reference $end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The first token, &lt;strong&gt;var_type&lt;/strong&gt; specifies the type of variable.  The standard
allows many different variable types, although I’ve only ever used &lt;code class=&quot;highlighter-rouge&quot;&gt;wire&lt;/code&gt;.
Other types that might be useful include &lt;code class=&quot;highlighter-rouge&quot;&gt;parameter&lt;/code&gt;, and &lt;code class=&quot;highlighter-rouge&quot;&gt;reg&lt;/code&gt;, although the
standard identifies many more types.&lt;/p&gt;

&lt;p&gt;The second token, &lt;strong&gt;size&lt;/strong&gt; specifies the number of bits this value will
contain.&lt;/p&gt;

&lt;p&gt;The third token is perhaps the most cryptic,
although it need not be.  This is the &lt;strong&gt;identifer_code&lt;/strong&gt; assigned to this
particular variable.  This is a printable character, or string of printable
characters, used to identify the variable during the data section of the file.
We’ll come back to this in a moment.&lt;/p&gt;

&lt;p&gt;The last part of the &lt;code class=&quot;highlighter-rouge&quot;&gt;$var&lt;/code&gt; line is the &lt;strong&gt;reference&lt;/strong&gt;.  This is the variable
name the user has given to the trace.  If the variable had a width, it would
then be followed by something like &lt;code class=&quot;highlighter-rouge&quot;&gt;[MSB:LSB]&lt;/code&gt;.  For example, a four bit
trace &lt;code class=&quot;highlighter-rouge&quot;&gt;i_button&lt;/code&gt; could have the &lt;strong&gt;reference&lt;/strong&gt; of &lt;code class=&quot;highlighter-rouge&quot;&gt;i_button[3:0]&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;One line that
&lt;a href=&quot;https://gtkwave.sourceforge.net&quot;&gt;GTKWave&lt;/a&gt;
understand’s that I haven’t found in the specification is a &lt;code class=&quot;highlighter-rouge&quot;&gt;$timezero&lt;/code&gt;
line.  This line has three items in it, &lt;code class=&quot;highlighter-rouge&quot;&gt;$timezero&lt;/code&gt;, the internal time
where the zero occurs, and the &lt;code class=&quot;highlighter-rouge&quot;&gt;$end&lt;/code&gt; tag. 
&lt;a href=&quot;https://github.com/ZipCPU/wbscope&quot;&gt;wbscope&lt;/a&gt; uses this tag to place the
trigger at time zero.&lt;/p&gt;

&lt;p&gt;Finally, the header section is ended by an &lt;code class=&quot;highlighter-rouge&quot;&gt;$enddefinitions&lt;/code&gt; line:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;$var vary_type size identifier_code reference $end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;If you are confused about these values and terms, consider looking through a 
&lt;a href=&quot;https://en.wikipedia.org/wiki/Value_change_dump&quot;&gt;VCD&lt;/a&gt; 
file from a reader that works.  The files just aren’t that hard to understand.&lt;/p&gt;

&lt;h2 id=&quot;data-section&quot;&gt;Data Section&lt;/h2&gt;

&lt;p&gt;From the end of the header to the end of the file is the data section.
This section contains two types of lines: simulation time lines and value
change lines.&lt;/p&gt;

&lt;p&gt;Simulation time lines start with a &lt;code class=&quot;highlighter-rouge&quot;&gt;#&lt;/code&gt; and a time value.  That’s it.
For example,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;#295&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;specifies that the following changes happen at &lt;code class=&quot;highlighter-rouge&quot;&gt;295&lt;/code&gt; time units.  Exactly
how much time this references depends upon the &lt;code class=&quot;highlighter-rouge&quot;&gt;$timescale&lt;/code&gt; command in the
header.  Further, the simulation time is an &lt;em&gt;unsigned number&lt;/em&gt;.  Negative
negative numbers are not allowed, and will really mess up your
&lt;a href=&quot;https://en.wikipedia.org/wiki/Value_change_dump&quot;&gt;VCD&lt;/a&gt; 
file.  (I know … I’ve tried.)&lt;/p&gt;

&lt;p&gt;Value change lines contain the value the variable is taking on, followed by the
identifier code for the variable that was assigned in the header.  These lines
are only necessary any time the value in question changes.&lt;/p&gt;

&lt;p&gt;For single bit values, the value in a value change line consists of a
&lt;code class=&quot;highlighter-rouge&quot;&gt;0&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;x&lt;/code&gt;, or &lt;code class=&quot;highlighter-rouge&quot;&gt;z&lt;/code&gt; followed by
the identifier code that was assigned to this value in the header.  For
multibit values, a &lt;code class=&quot;highlighter-rouge&quot;&gt;b&lt;/code&gt; precedes all of the bits.
If not all of the bits are given, then the value is left-extended in an
unsigned fashion.&lt;/p&gt;

&lt;p&gt;As an example, if &lt;code class=&quot;highlighter-rouge&quot;&gt;J&lt;/code&gt; is defined in the header to reference &lt;code class=&quot;highlighter-rouge&quot;&gt;i_clk&lt;/code&gt;, then&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;0J&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;specifies that the clock is now set to zero.  Likewise if &lt;code class=&quot;highlighter-rouge&quot;&gt;#&lt;/code&gt; is assigned
to the 8-bit data value &lt;code class=&quot;highlighter-rouge&quot;&gt;i_data[7:0]&lt;/code&gt;, then this value can be set with&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;b01000101#&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;While most FPGA programmers will not need to read or write
&lt;a href=&quot;https://en.wikipedia.org/wiki/Value_change_dump&quot;&gt;VCD&lt;/a&gt; 
files, anyone wanting to build &lt;a href=&quot;/blog/2017/06/08/simple-scope.html&quot;&gt;their own digital logic
scope&lt;/a&gt; will find
it valuable to know how to create
&lt;a href=&quot;https://en.wikipedia.org/wiki/Value_change_dump&quot;&gt;VCD&lt;/a&gt; 
files.&lt;/p&gt;

&lt;hr /&gt;&lt;p&gt;&lt;em&gt;And the vision of all is become unto you as the words of a book that is sealed, which men deliver to one that is learned, saying, Read this, I pray thee: and he saith, I cannot; for it is sealed (Is 29:11)&lt;/em&gt;</description>
        <pubDate>Mon, 31 Jul 2017 00:00:00 -0400</pubDate>
        <link>http://zipcpu.com/blog/2017/07/31/vcd.html</link>
        <guid isPermaLink="true">http://zipcpu.com/blog/2017/07/31/vcd.html</guid>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>Linear Interpolation</title>
        <description>&lt;p&gt;Now that we’ve finished our series on how to build an upsampling linear
interpolator, let’s take a moment to collect the various posts in the 
series together.&lt;/p&gt;

&lt;p&gt;First, we had a pre-series post, discussing &lt;a href=&quot;/dsp/2017/06/06/simple-interpolator.html&quot;&gt;how to resample using a sample
and hold interperolator&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Given that context, our discussion of how to build a linear interpolator
included posts on:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;How an &lt;a href=&quot;/dsp/2017/07/19/linear-upsampling.html&quot;&gt;upsampling linear interpolator&lt;/a&gt; works&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;/dsp/2017/07/21/bit-growth.html&quot;&gt;Bit-width allocation within an FPGA&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;How to &lt;a href=&quot;/dsp/2017/07/22/rounding.html&quot;&gt;drop bits (i.e. round)&lt;/a&gt;, to keep bit growth from getting out of hand&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;How to &lt;a href=&quot;/dsp/2017/07/24/dsp-debugging.html&quot;&gt;debug DSP logic&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The one topic in linear interpolation that wasn’t covered was how to build
a downsampling linear interpolator.  This hardly needs a discussion of its
own, however, since a downsampler that downsamples by an integer amount can
easily just select points at the output of the linear upsampler.&lt;/p&gt;

&lt;p&gt;Hence, the posts above really cover the issue.&lt;/p&gt;

&lt;hr /&gt;&lt;p&gt;&lt;em&gt;Better is the end of a thing than the beginning thereof: and the patient in spirit is better than the proud in spirit. (Eccl 7:8)&lt;/em&gt;</description>
        <pubDate>Sat, 29 Jul 2017 00:00:00 -0400</pubDate>
        <link>http://zipcpu.com/dsp/2017/07/29/series-linear-interpolation.html</link>
        <guid isPermaLink="true">http://zipcpu.com/dsp/2017/07/29/series-linear-interpolation.html</guid>
        
        
        <category>dsp</category>
        
      </item>
    
      <item>
        <title>Getting the basic FIFO right</title>
        <description>&lt;p&gt;If you’ve ever waited in a line, then you understand what a
&lt;a href=&quot;https://en.wikipedia.org/wiki/FIFO&quot;&gt;FIFO&lt;/a&gt; is about.
A &lt;a href=&quot;https://en.wikipedia.org/wiki/FIFO&quot;&gt;FIFO&lt;/a&gt;
refers to a &lt;em&gt;First in, First out&lt;/em&gt; (i.e.
&lt;a href=&quot;https://en.wikipedia.org/wiki/FIFO&quot;&gt;FIFO&lt;/a&gt;) data structure that has
many applications in both computers and electronics.  The data structure
is designed to support the digital equivalent of waiting in line.&lt;/p&gt;

&lt;p&gt;Perhaps I need to underline that.
&lt;a href=&quot;https://en.wikipedia.org/wiki/FIFO&quot;&gt;FIFO&lt;/a&gt;’s don’t have one application, they
have &lt;em&gt;many&lt;/em&gt; applications in both software and electronic digital design.&lt;/p&gt;

&lt;p&gt;Let’s see if we can find some examples, shall we?&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;A &lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;, such as the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;Interrupting a CPU costs time and performance.  It’s not a simple thing to
do, in spite of the hard work of many men to make interrupts fast and
efficient.   Hence, at some data rates, handling requests one at a time can
just cripple a CPU–it’s just spending too much time handling the interrupt.&lt;/p&gt;

    &lt;p&gt;To deal with this, peripheral hardware is often created so that the CPU
can mange many items at the same time–spreading the cost of the interrupt
across many accesses.&lt;/p&gt;

    &lt;p&gt;Perhaps a good analogy here might be an airport taxi line.  Only one person
(family) can get into any taxi at a time, and then all the taxi’s move
forward so the next person can get into the next taxi.  In this case, when
an airplane arrives (the CPU gets busy), the line suddenly swells as many
people get off and start waiting in line for a taxi.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Synchronous_dynamic_random-access_memory&quot;&gt;SDRAM Memory&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;Memory is also another candidate for a FIFO.   Unlike the airport taxi line,
Memory acts more
like a school cafeteria buffet line.  Only one class is allowed to use
the line at a time, yet there are several stations that each student needs
to visit to get his lunch.  Hence, in the case of memory, you want to make
many transactions at once, fill the pipeline, and then get the whole data
through the line as soon as possible so the next class can come through.&lt;/p&gt;

    &lt;p&gt;In this case, you want a FIFO that can be filled, or nearly filled, and
then make all its transactions at once and release the memory so that
something else can use it.&lt;/p&gt;

    &lt;p&gt;(Example: &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/wbdmac.v&quot;&gt;DMA
Controller&lt;/a&gt;,
and a &lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/rtl/wbufifo.v&quot;&gt;Wishbone-UART debugging bus
FIFO&lt;/a&gt;)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;A &lt;a href=&quot;https://en.wikipedia.org/wiki/Universal_asynchronous_receiver/transmitter&quot;&gt;Universal Asynchronous Receiver Transmitter
(UART)&lt;/a&gt;,
sometimes known as a &lt;a href=&quot;https://en.wikipedia.org/wiki/Serial_port&quot;&gt;serial port&lt;/a&gt;.&lt;/p&gt;

    &lt;p&gt;Computers like to load a serial port with data.  However, the serial port
can typically only handle one item every so many clocks.  Often, the serial
port can operate much faster than the computer can interrupt, but slower
than the computer can issue characters to the port.&lt;/p&gt;

    &lt;p&gt;In this case, a FIFO can be used to allow the computer to write many
characters to the port.  These characters will then “wait in line” to be
transmitted, and when the line is (nearly) empty, the computer can then
send a whole bunch more characters to the port–keeping the port busy at all
times.&lt;/p&gt;

    &lt;p&gt;A similar case for a FIFO can be made on receive as well.  The computer
just waits for the line to fill up, before it processes all of the elements
in the line quickly.&lt;/p&gt;

    &lt;p&gt;&lt;a href=&quot;https://github.com/ZipCPU/wbuart32/blob/master/rtl/ufifo.v&quot;&gt;(Verilog example code)&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Audio&lt;/p&gt;

    &lt;p&gt;Audio is very much like the UART above.  The CPU can write at one speed,
but the audio may only be able to read at another.  A FIFO can allow a
CPU the ability to write a &lt;em&gt;lot&lt;/em&gt; of things to the audio port at once, after
which the audio hardware reads the samples out one by one.&lt;/p&gt;

    &lt;p&gt;Audio receiving is in many ways like some buses I’ve traveled on.  The line
for the bus grows and grows.  Once it reaches a certain length (in the case
of the FIFO), the “bus” comes along and clears the line.&lt;/p&gt;

    &lt;p&gt;&lt;a href=&quot;https://github.com/ZipCPU/wbpmic/blob/master/rtl/smplfifo.v&quot;&gt;(Verilog example code)&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Video&lt;/p&gt;

    &lt;p&gt;Unlike UARTs and Audio, the video FIFOs I’ve worked with have rarely (if ever)
required the CPU’s attention.  They usually work in the background.  When
receiving video data, once a FIFO buffer fills, the buffer is then dumped
into memory.  Likewise on the transmit: the video controller reads from
memory, fills its buffer, and then slowly sends it to the display one pixel
at a time.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;These are all examples of a FIFO.&lt;/p&gt;

&lt;p&gt;Basically, you need a FIFO anytime something is going to be produced (written)
at one rate, and consumed (read) at another.  The buffer in the FIFO, then,
adjusts like any line as items are added, or removed, from it.&lt;/p&gt;

&lt;p&gt;It’s really a fundamental digital design component.&lt;/p&gt;

&lt;p&gt;Let’s see what we need to do to build one.&lt;/p&gt;

&lt;h1 id=&quot;the-goal&quot;&gt;The Goal&lt;/h1&gt;

&lt;p&gt;For our simple example here, we’ll assume there are three operations that
can be done on a FIFO, and some parts and pieces of FIFO status that we may
wish to know.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;The FIFO may need to be reset.  This clears any items from the line,
and empties the buffer regardless of how many items were in line or how
full the buffer ever was.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;You can add someone to the end of the line.  This is what happens when data
is &lt;em&gt;written&lt;/em&gt; to the FIFO.&lt;/p&gt;

    &lt;p&gt;In digital electronics, though, there is a maximum length to any line.
Hence, if the line is too long, attempts to add one more item to the line
will fail.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;You can process the first item in the line.  This is what happens when data
is &lt;em&gt;read&lt;/em&gt; from the FIFO.&lt;/p&gt;

    &lt;p&gt;Any attempt to read from an empty FIFO must of necessity fail.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Those are the operations that can take place on a FIFO.&lt;/p&gt;

&lt;p&gt;For our discussion below, we’ll support three pieces of status:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;We’ll want to know how many items are in the line.
That way we can announce that the line is empty, full, half-full or …
whatever condition is necessary to move forward.&lt;/p&gt;

    &lt;p&gt;Eventually, we’ll want to know if the line is full or empty, but we’ll just
start with trying to know how many items are within it.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;We’ll want to know if we ever spilled an item by adding too many items to
the line (overflow), or if&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;We ever tried to read from the FIFO when it was empty (underflow).&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Further, to outline the necessary logic, we’ll start with a software example
of this FIFO, and then convert it to digital logic (i.e. Verilog).&lt;/p&gt;

&lt;h1 id=&quot;circular-buffer&quot;&gt;Circular Buffer&lt;/h1&gt;

&lt;p&gt;Wikipedia’s &lt;a href=&quot;https://en.wikipedia.org/wiki/FIFO&quot;&gt;FIFO&lt;/a&gt; article discusses
creating a
&lt;a href=&quot;https://en.wikipedia.org/wiki/FIFO&quot;&gt;FIFO&lt;/a&gt;
using dynamically allocated objects and pointers.&lt;/p&gt;

&lt;p&gt;Where this fails is in digital logic, because physical logic resources are
limited–dynamically allocated memory is unavailable.&lt;/p&gt;

&lt;p&gt;Hence, we’re going to use a different form of algorithm here.  We’ll use instead
a circular buffer with a fixed size.&lt;/p&gt;

&lt;p&gt;In this buffer, there are two pointers: the write pointer and the read pointer.&lt;/p&gt;

&lt;p&gt;Whenever the read and write pointers are identical, as in Fig 1 below,
we’ll use that as the indication that the buffer is empty.
Initially, both pointers will point to the same address in the buffer (zero).
Further, we’ll return both pointers to zero any time the user requests that the
buffer be reset.&lt;/p&gt;

&lt;table style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 1: Empty FIFO&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/fifo-empty.svg&quot; alt=&quot;Example image of an empty FIFO&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;When an item is written to the buffer, the write pointer is incremented.
This pointer then always points to the item not yet written to.&lt;/p&gt;

&lt;p&gt;When an item is read from the buffer, the read pointer is incremented.  This
pointer always references the next item to be read.&lt;/p&gt;

&lt;p&gt;If you look at a diagram of this, such as Fig 2, it looks like the
read pointer is &lt;em&gt;chasing&lt;/em&gt; the write pointer.&lt;/p&gt;

&lt;table style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 2: FIFO with data&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/fifo-rdwr.svg&quot; alt=&quot;Example FIFO read/write pointers&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;What happens when the write or read pointer gets to the end
of the buffer?  The pointer in question simply wraps around to the
beginning of the buffer.  Because the buffer pointers just wrap around,
this type of buffer is called a &lt;em&gt;circular buffer&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;You can tell when this type of FIFO is full, because write pointer one plus
will equal the read pointer, as in Fig 3 below.&lt;/p&gt;

&lt;table style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 3: A full FIFO&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/fifo-full.svg&quot; alt=&quot;Example image of a full FIFO&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Further, we’re going to use a special property of FIFO’s that are &lt;code class=&quot;highlighter-rouge&quot;&gt;2^N&lt;/code&gt;
in length.  That is, the read and write pointers will always fit into
&lt;code class=&quot;highlighter-rouge&quot;&gt;N&lt;/code&gt; bits, so no boundary checking is required.  Likewise, the number of elements
within the FIFO is given by the bottom &lt;code class=&quot;highlighter-rouge&quot;&gt;N&lt;/code&gt; bits of the difference between the
write and read pointers.&lt;/p&gt;

&lt;h1 id=&quot;a-simple-software-fifo&quot;&gt;A Simple Software FIFO&lt;/h1&gt;

&lt;p&gt;Our focus today is going to be on implementing this operation in Verilog.
Sometimes, though, it helps for formalism of expression to first implement
something like this in C++.  Hence, we’ll use the following C++ code to
illustrate how a FIFO works.&lt;/p&gt;

&lt;p&gt;First, we’ll declare what we stated above: our FIFO will have three operations.
These are reset, write, and read.  We’ll also want to be able to query how
many items are in the FIFO.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;FIFO&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;bool&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;m_overflow&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m_underflow&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;	&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_mem&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m_len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m_rdaddr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m_wraddr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;FIFO&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lglength&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;c1&quot;&gt;// On any allocation of a new FIFO,
&lt;/span&gt;		&lt;span class=&quot;c1&quot;&gt;// allocate memory to hold our buffer,
&lt;/span&gt;		&lt;span class=&quot;c1&quot;&gt;// and record how big the buffer is.
&lt;/span&gt;		&lt;span class=&quot;n&quot;&gt;m_len&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lglength&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;m_mem&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;reset&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

	&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;reset&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;write&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;item&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;read&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;fill&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Resetting the FIFO will simply set both read and write pointers back to zero.
It will also clear any error flags.  Note that we aren’t going to &lt;em&gt;clear&lt;/em&gt;
the memory here–mostly because we won’t be able to do that in Verilog very
easily later.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;FIFO&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;reset&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;// Reset our pointers to the beginning of the memory
&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;m_wraddr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m_rdaddr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;

	&lt;span class=&quot;c1&quot;&gt;// Reset the error flags to false
&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;m_overflow&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m_underflow&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;em&gt;Writing&lt;/em&gt; an item is almost as simple as setting the memory and incrementing
the pointer.  We’re going to add two more pieces to this logic, though.  The
first is required: the address of the next write pointer, &lt;code class=&quot;highlighter-rouge&quot;&gt;nxtaddr&lt;/code&gt; may need
to wrap around the buffer to be valid.  So, we’ll check that first.  Second,
if the newly calculated next write pointer, &lt;code class=&quot;highlighter-rouge&quot;&gt;nxtaddr&lt;/code&gt;, is equal to our read
address, that’s an indication that the buffer is full.  Here, we’ll cowardly
refuse to write to a full FIFO.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;c1&quot;&gt;// Produce an item / Write one item to the FIFO
&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;FIFO&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;write&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;item&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;// First, calculate the address of the next
&lt;/span&gt;	&lt;span class=&quot;c1&quot;&gt;// write pointer.
&lt;/span&gt;	&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nxtaddr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m_wraddr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

	&lt;span class=&quot;c1&quot;&gt;// Adjust for any wrapping around the ends of the buffer
&lt;/span&gt;	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nxtaddr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m_len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;nxtaddr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

	&lt;span class=&quot;c1&quot;&gt;// If this next pointer is the same as the read pointer,
&lt;/span&gt;	&lt;span class=&quot;c1&quot;&gt;// the FIFO is full: cowardly refuse to write to the FIFO
&lt;/span&gt;	&lt;span class=&quot;c1&quot;&gt;// in that casej
&lt;/span&gt;	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nxtaddr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m_rdaddr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;

		&lt;span class=&quot;c1&quot;&gt;// Actually write an item to the FIFO
&lt;/span&gt;		&lt;span class=&quot;n&quot;&gt;m_mem&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_wraddr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;item&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;m_wraddr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nxtaddr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;
		&lt;span class=&quot;c1&quot;&gt;// Set an error flag on any attempt to write to a full FIFO
&lt;/span&gt;		&lt;span class=&quot;n&quot;&gt;m_overflow&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;em&gt;Reading&lt;/em&gt; from the FIFO is just about as simple: we want to return the next
item in our buffer and increment the read pointer, wrapping if necessary.  As
before, though, there’s a twist: we only want to
increase our buffer pointer if the FIFO wasn’t empty.  Attempts to read from
an empty buffer should create an underflow (error) condition, while leaving
the FIFO empty.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;c1&quot;&gt;// Read/consume one item from the FIFO
&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;FIFO&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;read&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;item&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

	&lt;span class=&quot;c1&quot;&gt;// We&#39;ll return the next item to be read
&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;item&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m_mem&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_rdaddr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;

	&lt;span class=&quot;c1&quot;&gt;// Only consume if the FIFO is not empty
&lt;/span&gt;	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_rdaddr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m_wraddr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;

		&lt;span class=&quot;c1&quot;&gt;// Increment the read pointer
&lt;/span&gt;		&lt;span class=&quot;n&quot;&gt;m_rdaddr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

		&lt;span class=&quot;c1&quot;&gt;// Check to see if it wraps ppast the end of the buffer
&lt;/span&gt;		&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_rdaddr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m_len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;m_rdaddr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;m_underflow&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

	&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;item&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Finally, our last operation is to return the number of items found within this
FIFO.  This is given by the write pointer minus the read pointer, but done in
such a way as to never return anything less than zero or greater than the
size of our buffer.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;FIFO&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fill&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

	&lt;span class=&quot;n&quot;&gt;count&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m_wraddr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m_rdaddr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;count&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;count&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m_len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;In many ways, this set of operations isn’t really complete.  We haven’t returned
the number of empty (unused) values in the buffer, we haven’t created any
boolean values to return whether or not the buffer is non-empty, half-empty, or
half full, neither have we made any methods to read whether or not an error
condition has occurred.  We’ll leave these exercises to the student.&lt;/p&gt;

&lt;h1 id=&quot;first-verilog-cut&quot;&gt;First Verilog Cut&lt;/h1&gt;

&lt;p&gt;If we just tried to translate this C++ code to Verilog, we might end up with
the always block shown below:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;parameter	LGLEN = 8;
reg	[(LGLEN-1):0]	rdaddr, wraddr;
reg	[(INPUTWIDTH-1):0]	mem	[0:((1&amp;lt;&amp;lt;LGLEN)-1)];

always @(posedge i_clk)
	if (i_reset)
	begin
		rdaddr &amp;lt;= 0;
		wraddr &amp;lt;= 0;
		overrun  &amp;lt;= 0;
		underrun &amp;lt;= 0;
		o_fill   &amp;lt;= 0;
	end else if (i_write)
	begin
		if (wraddr + 1&#39;b1 != rdaddr)
		begin
			mem[wraddr] &amp;lt;= i_item;
			wraddr &amp;lt;= (wraddr + 1&#39;b1);
			o_fill   &amp;lt;= o_fill + 1&#39;b1;;
		end else
			overrun &amp;lt;= 1&#39;b1;
	end else if (i_read)
	begin
		if (wraddr != rdaddr) // If not empty
		begin
			o_item &amp;lt;= mem[wraddr]
			wraddr &amp;lt;= wraddr + 1&#39;b1;
			o_fill   &amp;lt;= o_fill - 1&#39;b1;;
		end else
			underrun &amp;lt;= 1&#39;b1;
	end /// Ooops!  What about ((i_write)&amp;amp;&amp;amp;(i_read))&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;With a little thought, it’s not too hard to see that this initial approach
is going to have some problems.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;What happens when a read and write request come in together?&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;wraddr + 1&#39;b1&lt;/code&gt; needs to be limited to &lt;code class=&quot;highlighter-rouge&quot;&gt;N&lt;/code&gt; bits, otherwise we don’t get the
proper wrap around the end of the buffer effect.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;We’ll need to make some changes therefore.&lt;/p&gt;

&lt;h1 id=&quot;next-verilog-cut&quot;&gt;Next Verilog Cut&lt;/h1&gt;

&lt;p&gt;Let’s see if we can’t improve on our first attempt to write the Verilog
code for a FIFO with four basic changes.&lt;/p&gt;

&lt;p&gt;The first change we’ll make is to separate the read and write tasks, and
likewise the various variables, into separate always blocks.  This will
make it easier to handle concurrent reads and writes.&lt;/p&gt;

&lt;p&gt;Our second change will be to capture the logic associated with testing whether
or not the FIFO is full or empty into two flags: &lt;code class=&quot;highlighter-rouge&quot;&gt;full&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;empty&lt;/code&gt;.  This
will help us figure out how to optimize things later.&lt;/p&gt;

&lt;p&gt;Third, to deal with concurrent reading and writing, we’ll allow the following:
Concurrent reads and writes are allowed, as long as the FIFO isn’t empty.
This is to allow the memory a full clock to handle the write before the memory
is available to be read.&lt;/p&gt;

&lt;p&gt;Finally, we’ll separate the calculation of the number of items in the buffer
into its own logic section.&lt;/p&gt;

&lt;p&gt;So, to walk through the code, on every clock we will write to memory.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	mem[wraddr] &amp;lt;= i_item;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;If there’s no write taking place on this clock, the memory write will just
change the contents of an unused data item.&lt;/p&gt;

&lt;p&gt;Likewise on every clock we will read from memory and create one of our outputs.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	o_item &amp;lt;= mem[wraddr];&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;As with the memory write, if the FIFO isn’t being read on this clock then it
won’t hurt us to set the output anyway.&lt;/p&gt;

&lt;p&gt;Many FPGA’s will also allow you to gate
these memory operation for no additional logic cost, as in:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	if (i_write)
		mem[wraddr] &amp;lt;= i_item;
always @(posedge i_clk)
	if (i_read)
		o_item &amp;lt;= mem[wraddr];&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;While such gating may be useful, it’s not required in this example.&lt;/p&gt;

&lt;p&gt;The next step in writing to the FIFO is handling the FIFO write pointer,
&lt;code class=&quot;highlighter-rouge&quot;&gt;wraddr&lt;/code&gt;.
Since the logic used to adjust the FIFO write pointer is almost identical to the
logic to adjust the overrun flag, we’ll place the two into the same always
block.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	if (i_reset)
	begin
		wraddr &amp;lt;= 0;
		overrun  &amp;lt;= 0;
	end else if (i_write)
	begin
		// Update the FIFO write address any time a write is made to
		// the FIFO and it&#39;s not FULL.
		//
		// OR any time a write is made to the FIFO at the same time a
		// read is made from the FIFO.
		if ((!full)||(i_read))
			wraddr &amp;lt;= (wraddr + 1&#39;b1);
		else
			overrun &amp;lt;= 1&#39;b1;
	end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Other than separating this into its own always blog, the biggest change between
this version and our prior one is the introduction of the &lt;code class=&quot;highlighter-rouge&quot;&gt;!full&lt;/code&gt; flag.  This
flag replaces the &lt;code class=&quot;highlighter-rouge&quot;&gt;(wraddr+1&#39;b1)!=rdaddr&lt;/code&gt; calculation from before.&lt;/p&gt;

&lt;p&gt;The other more subtle change is that we will now write to the FIFO any
time the FIFO is not full, &lt;em&gt;or&lt;/em&gt; any time the FIFO is full &lt;em&gt;and&lt;/em&gt; a read is
taking place on the same clock.&lt;/p&gt;

&lt;p&gt;The read address, &lt;code class=&quot;highlighter-rouge&quot;&gt;rdaddr&lt;/code&gt;, and &lt;code class=&quot;highlighter-rouge&quot;&gt;underrun&lt;/code&gt; error flag calculation below
follow a very similar form to that of the write address and overflow
calculation above.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;// Set wraddr and underrun
always @(posedge i_clk)
	if (i_reset)
	begin
		rdaddr &amp;lt;= 0;
		underrun &amp;lt;= 0;
	end else if (i_read)
	begin
		// On any read request, increment the pointer if the FIFO isn&#39;t
		// empty--independent of whether a write operation is taking
		// place at the same time.
		if (!empty)
			rdaddr &amp;lt;= rdaddr + 1&#39;b1;
		else
			// If a read is requested, but the FIFO was full, set
			// an underrun error flag.
			underrun &amp;lt;= 1&#39;b1;
	end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The big difference is that the FIFO must be non-empty to read, &lt;em&gt;even if&lt;/em&gt; a
write is taking place on the same clock.  This gives the memory a clock
to store the value, before trying to read it.&lt;/p&gt;

&lt;p&gt;The next and final trick is determining how full the FIFO is.&lt;/p&gt;

&lt;p&gt;You might be tempted to set &lt;code class=&quot;highlighter-rouge&quot;&gt;o_fill &amp;lt;= wraddr-rdaddr&lt;/code&gt; just like we did in our
C++ implementation.  This, however, doesn’t work.  Such a fill measure will
always be one clock out of date.&lt;/p&gt;

&lt;p&gt;Instead, we’ll count how many items are in our buffer as those items are
added or removed from the buffer.  That means, though, that we’ll need to pay
attention to not only the read and write request lines, but also whether or
not the FIFO is full or empty when the request is made.  This simple logic
fits nicely into a case statement.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;// Calculate the fill
always @(posedge i_clk)
	if (i_reset)
	begin
		o_fill &amp;lt;= 0;
	end else casez({ i_write, i_read, !full, !empty })
	4&#39;b01?1: o_fill &amp;lt;= o_fill - 1&#39;b1;	// A successful read
	4&#39;b101?: o_fill &amp;lt;= o_fill + 1&#39;b1;	// A successful write
	4&#39;b1100: o_fill &amp;lt;= o_fill + 1&#39;b1;	// Successful write, failed read
	// 4&#39;b11?1: Successful read *and* write -- no change
	default: o_fill &amp;lt;= o_fill;	// Default, no change
	endcase&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;That leaves as our final task determining whether or not the FIFO is full,
as well as what the next write address would be, were we to write to our FIFO
on this clock.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;assign	nxtaddr = wraddr + 1&#39;b1;
assign	full  = (nxtaddr == rdaddr);
assign	empty = (wraddr  == rdaddr);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The above approach should yield a working FIFO.&lt;/p&gt;

&lt;p&gt;It just won’t be a high speed FIFO, or a low logic FIFO implementation.&lt;/p&gt;

&lt;p&gt;The problem is specifically the cost of calculating &lt;code class=&quot;highlighter-rouge&quot;&gt;full&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;empty&lt;/code&gt;.
Remember when I discussed &lt;a href=&quot;/blog/2017-06-12-minimizing-luts.html&quot;&gt;keeping the conditions on an &lt;code class=&quot;highlighter-rouge&quot;&gt;if-then-else&lt;/code&gt; branch
simple&lt;/a&gt;?  We just
violated that rule.&lt;/p&gt;

&lt;p&gt;We’ll have to try again, therefore.&lt;/p&gt;

&lt;h1 id=&quot;high-speed-verilog-cut&quot;&gt;High Speed Verilog Cut&lt;/h1&gt;

&lt;p&gt;This time, let’s keep everything the same as before, with the exception of the
&lt;code class=&quot;highlighter-rouge&quot;&gt;full&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;empty&lt;/code&gt; flags.  Let’s spend some time focusing on those.&lt;/p&gt;

&lt;p&gt;The problem with these two flags is that they are calculated within the
nested if’s above.  Further, they are calculated within the nested if of a
large amount of logic, since each of the address lines sets &lt;code class=&quot;highlighter-rouge&quot;&gt;N&lt;/code&gt; bits.
What this means is that once the logic has been calculated, it then needs
to be distributed among many elements–an additional timing cost.&lt;/p&gt;

&lt;p&gt;We’ll solve this problem by pushing back the &lt;code class=&quot;highlighter-rouge&quot;&gt;full&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;empty&lt;/code&gt; logic one
clock earlier.  This will keep the &lt;code class=&quot;highlighter-rouge&quot;&gt;full&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;empty&lt;/code&gt; designations
synchronous to the actual state of the FIFO on any given clock.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;wire	[(N-1):0]	dblnext, nxtread;
assign	dblnext = wraddr + 2;
assign	nxtread = rdaddr + 1&#39;b1;

always @(posedge i_clk)
	if (reset)
	begin
		full &amp;lt;= 1&#39;b0;
		empty &amp;lt;= 1&#39;b1;
	end else casez({ i_write, i_read, !full, !empty })
	4&#39;b01?1: begin	// A successful read
		full  &amp;lt;= 1&#39;b0;
		empty &amp;lt;= (nxtread == wraddr);
		end
	4&#39;b101?: begin	// A successful write
		full &amp;lt;= (dblnext == rdaddr);
		empty &amp;lt;= 1&#39;b0;
	4&#39;b1100: begin	// Successful write, failed read
		full  &amp;lt;= 1&#39;b0;
		empty &amp;lt;= 1&#39;b0;
	default: begin end
	endcase&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;We’ll get a warning for adding a 32-bit number to an &lt;code class=&quot;highlighter-rouge&quot;&gt;N&lt;/code&gt; bit number when
calculating dblnext, but rather than complicating the logic to get rid of
the warning, we’ll leave it as is so you can see and understand what’s going
on.&lt;/p&gt;

&lt;p&gt;That’s it, though.  Now you know how to build a simple (application independent)
FIFO in Verilog.&lt;/p&gt;

&lt;h1 id=&quot;next-steps&quot;&gt;Next Steps&lt;/h1&gt;

&lt;p&gt;Knowing how to build a FIFO is really the first step in many steps.  It’s a
required part of many component designs, and so being able to build one
is a good skill to have.&lt;/p&gt;

&lt;p&gt;Indeed, now that we’ve discussed how to build a FIFO, we can return to our
&lt;a href=&quot;https://github.com/ZipCPU/dbgbus&quot;&gt;debugging bus&lt;/a&gt; and create an asynchronous
capabilities.  Such a capability will be required to demonstrate the pipeline
modes of the wishbone bus.&lt;/p&gt;

&lt;p&gt;If you ever want to reference other examples, you’ll find many FIFO
implementations posted on &lt;a href=&quot;https://opencores.org/projects&quot;&gt;OpenCores&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Strangely, from my own experience, I tend not to reuse the FIFO’s I’ve built
from one design need to the next.  Sure, the &lt;a href=&quot;https://github.com/ZipCPU/wbuart32/blob/master/rtl/ufifo.v&quot;&gt;FIFO I
built&lt;/a&gt; for a
&lt;a href=&quot;https://github.com/ZipCPU/wbuart32&quot;&gt;UART&lt;/a&gt; tends
to stay with that &lt;a href=&quot;https://github.com/ZipCPU/wbuart32&quot;&gt;UART&lt;/a&gt;, but the FIFO’s
I build for &lt;a href=&quot;https://github.com/ZipCPU/wbpmic&quot;&gt;audio&lt;/a&gt; or video tend to be
different from the &lt;a href=&quot;https://github.com/ZipCPU/wbuart32/blob/master/rtl/ufifo.v&quot;&gt;one for the
UART&lt;/a&gt;–even though
the design outline above is roughly the same.&lt;/p&gt;

&lt;p&gt;Instead, whenever I need a FIFO, I tend to copy from a working FIFO
and then adjust the code to fit my new needs.  The reason is simple: it seems
that every application requires a different interface to the FIFO.&lt;/p&gt;

&lt;p&gt;For example, a CPU will want to know from a
&lt;a href=&quot;https://github.com/ZipCPU/wbuart32/blob/master/rtl/wbuart.v&quot;&gt;UART receiver&lt;/a&gt;
how many items can be read (i.e. &lt;code class=&quot;highlighter-rouge&quot;&gt;o_fill&lt;/code&gt;), but from the transmitter it wants
to know how many items can be written to it (&lt;code class=&quot;highlighter-rouge&quot;&gt;N-1-ofill&lt;/code&gt;).  Likewise, the CPU
might wish to want until the receive queue is halfway full (&lt;code class=&quot;highlighter-rouge&quot;&gt;o_fill &amp;gt; N/2&lt;/code&gt;),
whereas the transmit FIFO would want to wait until the transmit queue is half
empty (&lt;code class=&quot;highlighter-rouge&quot;&gt;ofill &amp;lt; N/2-1&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;I guess this means that FIFO’s are one of the few places where the question
of whether the glass is half full or half empty becomes important.&lt;/p&gt;

&lt;p&gt;Another strange FIFO I’ve needed is the one to handle &lt;a href=&quot;https://github.com/ZipCPU/wb2axip&quot;&gt;AXI bus
requests&lt;/a&gt;.  In this case, instead of a
single set of read and write pointers, I’ve needed to use
multiple pointers so as to properly know where a transaction request is in
the process, and whether or not the AXI ready signals need to be dropped.&lt;/p&gt;

&lt;p&gt;The point is just that, in spite of the basics, FIFO’s tend to differ from
one context to another.&lt;/p&gt;

&lt;p&gt;Let me know your thoughts and experiences below!&lt;/p&gt;

&lt;hr /&gt;&lt;p&gt;&lt;em&gt;He hath made everything beautiful in his time: also he hath set the world in their heart, so that no man can find out the work that God maketh from the beginning to the end.&lt;/em&gt;</description>
        <pubDate>Sat, 29 Jul 2017 00:00:00 -0400</pubDate>
        <link>http://zipcpu.com/blog/2017/07/29/fifo.html</link>
        <guid isPermaLink="true">http://zipcpu.com/blog/2017/07/29/fifo.html</guid>
        
        
        <category>blog</category>
        
      </item>
    
  </channel>
</rss>
