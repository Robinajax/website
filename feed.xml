<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>The ZipCPU by Gisselquist Technology</title>
    <description>The ZipCPU blog, featuring how to discussions of FPGA and CPU design. This site will be focused on Verilog solutions, using exclusively OpenSource IP products for FPGA design.
</description>
    <link>http://zipcpu.com/</link>
    <atom:link href="http://zipcpu.com/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Sat, 10 Jun 2017 13:00:14 -0400</pubDate>
    <lastBuildDate>Sat, 10 Jun 2017 13:00:14 -0400</lastBuildDate>
    <generator>Jekyll v3.0.1</generator>
    
      <item>
        <title>A College Student&#39;s Response to the FPGA Design Process</title>
        <description>&lt;p&gt;I recently had the opportunity to help a college student on his end of term
project.  The student’s project sounded like a lot of fun to me, but in the
typical end of term, typical college fashion, I’m not sure it was nearly as
much fun for him or his teammate.&lt;/p&gt;

&lt;p&gt;When the term was over, I shared with him my &lt;a href=&quot;/blog/2017/06/02/design-process.html&quot;&gt;blog
post&lt;/a&gt;,
describing the difference
between the student’s design process, the expert’s design process, and the
actual expert’s design process, and then offered him a chance to respond now
that his term is over.&lt;/p&gt;

&lt;p&gt;What follows is that he had to say, and then my own thoughts on his
comments.&lt;/p&gt;

&lt;h2 id=&quot;a-college-students-perspective&quot;&gt;A College Student’s Perspective&lt;/h2&gt;

&lt;p&gt;I really liked &lt;a href=&quot;/blog/2017/06/02/design-process.html&quot;&gt;your blog
post&lt;/a&gt;, and I’d like to
respond to it with my own experience.&lt;/p&gt;

&lt;p&gt;I’ve now finally finished the project, and handed in my final report.&lt;/p&gt;

&lt;p&gt;It is not
as professionally done as I might like, and it is likely that it may be
missing some desired info.  However, the main key point I want to bring out
is that &lt;em&gt;we should have spent more time
testbenching via simulation on Vivado and creating accurate testbenches, with
wait times and hold times similar to realistic button presses as well as
accounting for delay times between components in the FPGA, the
&lt;a href=&quot;http://store.digilentinc.com/pmod-kypd-16-button-keypad/&quot;&gt;keypad&lt;/a&gt;,
and the
&lt;a href=&quot;http://store.digilentinc.com/pmodclp-character-lcd-with-parallel-interface/&quot;&gt;LCD&lt;/a&gt;&lt;/em&gt;.
All of our testbenches were made very simply with a few hundred
nanosecond wait times at most and hold times of 25-50 ns. This is obviously
not very realistic in terms of how long a button stays pressed or how long
it might take for our &lt;a href=&quot;https://en.wikipedia.org/wiki/Double_dabble&quot;&gt;double dabble
algorithm&lt;/a&gt; to work. In simulation,
a &lt;a href=&quot;https://en.wikipedia.org/wiki/Double_dabble&quot;&gt;double dabble&lt;/a&gt;
will occur virtually instantly, but realistically has a much higher latency
when implemented into the board.&lt;/p&gt;

&lt;p&gt;This was not accounted for in our testbenching nor during the design process,
which is something that I feel wasn’t pushed hard enough by the curriculum,
but also might have just been common sense and didn’t hit me until now. However,
judging by what you wrote in &lt;a href=&quot;/blog/2017/06/02/design-process.html&quot;&gt;your blog
post&lt;/a&gt;, it seems
that creating proper
testbenches for each and every module doesn’t happen often amongst students,
and I feel that &lt;em&gt;we are a good example of that, unfortunately&lt;/em&gt;. This just goes
to show that if I had spent more time creating testbenches for the interfaces
and tried to figure out ways for the FPGA to tell me what’s going on in all
that hardware, we might have had more success by the end of the project period.&lt;/p&gt;

&lt;p&gt;It is interesting how you mention getting diagnostics from the FPGA because
no one ever provided details or instructions on how we should do so or what
are good methods on communicating with the FPGA and how to know what parts of
the FPGA we could use to figure out if intermediate steps are working as we
want.&lt;/p&gt;

&lt;p&gt;I do feel a little scammed knowing that there were techniques out there that,
with just a couple minutes of explanation, might have saved me hours of
debugging. 
This makes me somewhat sad because I feel like I didn’t get
the experience and fulfillment from the class that I wanted/needed just
because someone was too tired or didn’t care to explain something to me.
This is what made me relate to &lt;a href=&quot;/blog/2017/06/02/design-process.html&quot;&gt;your blog post
post&lt;/a&gt;
where you mention in the beginning that the design
process for a student and a professional are almost two different worlds.&lt;/p&gt;

&lt;p&gt;Of course, my instructor would emphasize making a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Block_diagram&quot;&gt;block diagram&lt;/a&gt;, then going
into a &lt;a href=&quot;httpw://en.wikipedia.org/wiki/Finite-state_machine&quot;&gt;state machine&lt;/a&gt; and
&lt;a href=&quot;https://en.wikipedia.org/wiki/Datapath&quot;&gt;datapath&lt;/a&gt; drawing,
then designing the VHDL code,
&lt;a href=&quot;https://en.wikipedia.org/Test_bench&quot;&gt;testbenching&lt;/a&gt;, etc.
However, I feel like during homeworks, lectures, labs, and
the project period, the aid was almost a bit too lax and every time
I asked for help on why this warning is popping up or why the output
wouldn’t be showing on the
&lt;a href=&quot;http://store.digilentinc.com/pmodclp-character-lcd-with-parallel-interface/&quot;&gt;LCD&lt;/a&gt;,
I would get: “hmmm … I’m not too sure.  I haven’t really dived
into how the
&lt;a href=&quot;http://store.digilentinc.com/pmodclp-character-lcd-with-parallel-interface/&quot;&gt;LCD&lt;/a&gt;
works” or “have you tried testbenching it” or “try telling the
FPGA to give you some info back so you know what’s happening inside.”
There was never any in-depth discussion or a 
fulfilling moment where I felt “wow!  Now, I know how to prevent/fix this
warning or error” or perhaps “Okay, I understand that I may have to adjust my
design in this way and keep this in mind for the future”. Honestly, I felt
that I was winging it
the whole time.  It was frustrating.  Still, for some reason, I feel
like I still had fun with it. I had fun because it was challenging, it was not
easy, and every time I made a little bit of noticeable progress I felt like I
conquered the world. I just wish I didn’t have to conquer the world by myself.&lt;/p&gt;

&lt;p&gt;Enough of the slightly depressing monologue, the key lessons I learned were
these:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Make accurate testbenches for &lt;em&gt;everything&lt;/em&gt; even the really simple and
intuitive modules like
&lt;a href=&quot;https://en.wikipedia.org/wiki/Binary-coded_decimal&quot;&gt;BCD&lt;/a&gt;
to binary &lt;a href=&quot;https://en.wikipedia.org/wiki/Double_dabble&quot;&gt;converters&lt;/a&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Account for timing delays in the board that pretty much never happen
in the simulation&lt;/p&gt;

    &lt;p&gt;[Editor’s note: &lt;em&gt;You should test bench your entire design as well, not just
the components.  This also would’ve helped find out what was going as
the various components within the design interacted with each other.&lt;/em&gt;]&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The main issue I think we had was that we were sending the outputs from the
&lt;a href=&quot;http://store.digilentinc.com/pmod-kypd-16-button-keypad/&quot;&gt;keypad&lt;/a&gt;
to each module simultaneously, and it is likely that the later modules
were trying to perform calculations or send outputs to the
&lt;a href=&quot;http://store.digilentinc.com/pmodclp-character-lcd-with-parallel-interface/&quot;&gt;LCD&lt;/a&gt;
before data values were even finished
&lt;a href=&quot;https://en.wikipedia.org/wiki/Double_dabble&quot;&gt;converting&lt;/a&gt;
from
&lt;a href=&quot;https://en.wikipedia.org/wiki/Binary-coded_decimal&quot;&gt;BCD&lt;/a&gt;
to binary in the very first
module. Of course, it seems like this problem would fix itself after a few
cycles, but it was probably not smart to literally not account for timing in
the physical board.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Always ask for help from a close professional, professor, instructor, or
even the &lt;a href=&quot;https://forum.digilentinc.com&quot;&gt;friendly Digilent community&lt;/a&gt;. It is
so hard to do complex projects on
your own, especially when you have no or extremely minimal programming/coding
experience (that’s me).
Even if the instructor didn’t seem interested, I feel
like I should’ve sucked it up and just asked for help more often.
My instructor was smart as hell and I still had
tons of things I definitely did not know how to do without some help.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;A big thing in the &lt;a href=&quot;/blog/2017/06/02/design-process.html&quot;&gt;blog
post&lt;/a&gt;
is getting diagnostics and always retracing
steps. Sometimes the testbench isn’t the problem, it’s the design. For example,
&lt;a href=&quot;https://forums.xilinx.com/t5/Implementation/why-latches-are-considered-bad/td-p/200291&quot;&gt;latches&lt;/a&gt;,
time loops, etc. can all be affected my design in ways that I don’t
understand but are still making it not work the way I want. Pay attention to
warnings and don’t dismiss anything until you get confirmation or find online
that the warning doesn’t mean much.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;my-own-thoughts&quot;&gt;My Own Thoughts&lt;/h2&gt;

&lt;p&gt;Perhaps I might pull out of his response some key points worth taking away
from it.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;… it also might’ve been just common sense and didn’t hit me until now.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;This is half of the point of any education: to get the student to learn how
to think about a task in such a way as to make the task simple.
I’m not talking about the mechanics of the task necessarily, but rather
how to wrap your mind around the task, so that your mind thinks in the
language of the task.  The means of achieving this enlightenment is usually
 to give the student one task after another until the student finally learn’s
how to school his own mind.&lt;/p&gt;

&lt;p&gt;This is also why an employer would be excited to see a large portfolio of
complex projects you have designed.  It means you understand how to &lt;em&gt;think&lt;/em&gt;
like a digital designer.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;This makes me somewhat sad because I feel like I didn’t get
the experience and fulfillment from the class that I wanted/needed just
because …&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;I think you’ve now learned the lesson the class was trying to teach.  Next
time, let’s see if we can’t get that lesson across with a little less pain,
and a better grade.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Every time I asked for help on why this warning is popping up or why the
output wouldn’t be showing on the
&lt;a href=&quot;http://store.digilentinc.com/pmodclp-character-lcd-with-parallel-interface/&quot;&gt;LCD&lt;/a&gt;,
I would get:
&lt;em&gt;“hmmm … I’m not too sure. I haven’t really dived into how the
&lt;a href=&quot;http://store.digilentinc.com/pmodclp-character-lcd-with-parallel-interface/&quot;&gt;LCD&lt;/a&gt;
works”&lt;/em&gt;
or
&lt;em&gt;“have you tried testbenching it”&lt;/em&gt;
or
&lt;em&gt;“try telling the FPGA to give you some info back so you know what’s
happening inside.”&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;If I were your instructor, these might be my responses as well.  If you write
into the &lt;a href=&quot;https://forums.xilinx.com&quot;&gt;Xilinx forums&lt;/a&gt;, you are also likely to
get similar responses.&lt;/p&gt;

&lt;p&gt;To understand why, think about it from the other side: I’ve now been a mentor
for many students.  I’ve looked over many pieces of code trying to find their
bugs.  While I find it a fun challenge, it’s not easy.&lt;/p&gt;

&lt;p&gt;Indeed, finding bugs in my own code is hard enough, finding bugs in someone
else’s code is a lot harder.
It can take me between minutes and hours to find the mistake in someone else’s
code, depending upon the complexity of the code.  (Debouncing
&lt;a href=&quot;http://store.digilentinc.com/pmod-kypd-16-button-keypad/&quot;&gt;keypad&lt;/a&gt;’s is
usually quick, debugging &lt;a href=&quot;https://github.com/ZipCPU/dblclockfft&quot;&gt;FFT&lt;/a&gt;’s is
hard.)&lt;/p&gt;

&lt;p&gt;To make getting help easier, you must first find out what the issue is.
The instructor is right in this case, you need to tell “the FPGA to give you
some info back so you know what’s happening inside.”&lt;/p&gt;

&lt;p&gt;That in itself is one of the ongoing topics of this blog.&lt;/p&gt;

&lt;p&gt;Although it’s a touch off topic: when I studied for my Ph.D., my advisor had
no background in my field (Digital signal processing as applied to digital
communications).  He couldn’t help me with any of the details of how to do the
mechanics of my problem.  Originally, I would’ve thought that this would’ve
disqualified him from advising me.  In hindsight, I think it worked out to
everyone’s advantage–because it forced me to finally learn how to
learn a topic for myself.  At some point, there’s only so much an instructor
can do.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;There was never any in-depth discussion or a fulfilling moment where I felt
“wow!  Now, I know how to prevent/fix this warning or error”
or perhaps
“Okay, I understand that I may have to adjust my design in this way
and keep this in mind for the future”.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;I think our student has now just had his aha moment–only he may not realize
it yet.&lt;/p&gt;

&lt;p&gt;Stick around.  This is what we are going to try to do here on this blog:
explain what it takes to keep you from getting stuck in the future!&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;It was frustrating.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;a href=&quot;/fpga-hell.html&quot;&gt;FPGA Hell&lt;/a&gt; is &lt;em&gt;always&lt;/em&gt; frustrating.  Let’s
get you out of &lt;a href=&quot;/fpga-hell.html&quot;&gt;FPGA Hell&lt;/a&gt;, so that you can
enjoy winging it like the rest of us.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;I had fun because it was challenging, it was not easy, and every time
I made a little bit of noticeable progress I felt like I conquered the world.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;This is one of my own personal reasons for doing digital design.&lt;/p&gt;

&lt;p&gt;Can I share a secret with you all?  I keep a copy of the
&lt;a href=&quot;https://www.youtube.com/watch?v=78N2SP6JFaI&quot;&gt;theme from Superman&lt;/a&gt; lying around,
just to be able to share the excitement of success with the others in the
office.  I’ve even bought copies of the theme from &lt;a href=&quot;https://www.youtube.com/watch?v=IgncJgSbbck&quot;&gt;Indiana
Jones&lt;/a&gt;, from &lt;a href=&quot;https://www.youtube.com/watch?v=4rQSJDLM8ZE&quot;&gt;Star
Wars&lt;/a&gt;, and … I’d better
just stop there.&lt;/p&gt;

</description>
        <pubDate>Sat, 10 Jun 2017 00:00:00 -0400</pubDate>
        <link>http://zipcpu.com/blog/2017/06/10/lost-college-student.html</link>
        <guid isPermaLink="true">http://zipcpu.com/blog/2017/06/10/lost-college-student.html</guid>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>Building a Simple Wishbone Master</title>
        <description>&lt;p&gt;Explaining how to build a good &lt;a href=&quot;/blog/2017/06/05/wb-bridge-overview.html&quot;&gt;wishbone controlled debug
port&lt;/a&gt;
may take a couple of posts to do right.  Worse, it may take us a couple of
rounds just to get the logic right, but let’s try anyway.&lt;/p&gt;

&lt;table style=&quot;float: left&quot;&gt;&lt;caption&gt;Fig 1: WB-UART Overview&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/wb-uart-smpl.svg&quot; alt=&quot;Block Diagram of a Simpler Wishbone to UART converter&quot; width=&quot;360&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;For this post, we’re going to concentrate on the wishbone bus master found
at the bottom of the simplified UART to wishbone converter, as outlind in
Fig 1.&lt;/p&gt;

&lt;p&gt;Hence, if the whole capability will eventually look like Fig 1, we’re only
looking at the component at the very bottom within this post, and even then
we’re only going to examine a simplified version of it.  We’ll leave the
implementation of multiple transactions at once for a later date.&lt;/p&gt;

&lt;p&gt;My strategy for this blog post will be to come back and update it later
with any updates or fixes, so (hopefully) any mistakes will get fixed over
time.&lt;/p&gt;

&lt;p&gt;We are going to try to take this opportunity to build a simple wishbone bus
master.  Before starting, you may wish to grab a copy of the
&lt;a href=&quot;http://opencores.org/opencores,wishbone&quot;&gt;wishbone bus specification&lt;/a&gt; and
follow along in the
&lt;a href=&quot;http://opencores.org/cdn/downloads/wbspec_b4.pdf&quot;&gt;B4 version&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;You can find definitions for the various wishbone interface
wires in chapter two.  We’re going to continue following our practice of
prepending input wires with &lt;strong&gt;i_…&lt;/strong&gt; and output wires with &lt;strong&gt;o_..&lt;/strong&gt;, even
though the specification appends similar notes.  We’re also going to add
the &lt;strong&gt;_wb_&lt;/strong&gt; designator to all of the inputs associated with the wishbone
bus.  Hence, &lt;strong&gt;i_wb_ack&lt;/strong&gt; will reference the return acknowledgement from
the slave.&lt;/p&gt;

&lt;p&gt;Chapter three of the 
&lt;a href=&quot;http://opencores.org/cdn/downloads/wbspec_b4.pdf&quot;&gt;spec&lt;/a&gt; describes how the
various wishbone wires compose a bus cycle.
We’ll specifically be implementing the &lt;em&gt;pipelined bus cycle&lt;/em&gt; (not the classic
bus cycle), and we’re eventually going to build our implementation so that
it can issue requests across the bus in a pipelined fashion as fast as the
slave will allow it.&lt;/p&gt;

&lt;p&gt;If you are a visual learner, check out figures 3-6, and 3-8 from
&lt;a href=&quot;http://opencores.org/cdn/downloads/wbspec_b4.pdf&quot;&gt;the specification&lt;/a&gt;.
I find these to be the most useful, as I’m explaining how the bus works.
We’ll reserve the capability shown in Figures 3-11 and 3-13 for a later post.&lt;/p&gt;

&lt;p&gt;For today’s post, we’ll handle a single bus interaction per bus cycle, so
the CYC line will be lowered between requests.  We’ll revisit this decision
in a later post so that we can issue multiple requests of the bus at
one request per clock, but that will be a later discussion.&lt;/p&gt;

&lt;p&gt;Further, you can see the code as we’re building it in the &lt;a href=&quot;https://github.com/ZipCPU/icozip&quot;&gt;ICO Zip
repository&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/icozip/blob/master/rtl/exbus/exsimple.v&quot;&gt;here&lt;/a&gt;.
Since the &lt;a href=&quot;https://github.com/ZipCPU/icozip&quot;&gt;ICO Zip project&lt;/a&gt; isn’t fully
functional (yet), we’ll be building on the master branch.  That will also help
to make sure our link references stay valid over time–even if we need to
modify our files later.&lt;/p&gt;

&lt;h2 id=&quot;the-control-interface&quot;&gt;The Control Interface&lt;/h2&gt;

&lt;p&gt;The bus master interface we are building will ultimately be commanded from an
external interface.  We’ve
&lt;a href=&quot;/blog/2017/06/05/wb-bridge-overview.html&quot;&gt;already discussed&lt;/a&gt;
how that one might wish to do this over &lt;a href=&quot;http://icoboard.org&quot;&gt;ICO board&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/icozip/blob/master/rtl/pptest&quot;&gt;parallel port&lt;/a&gt;,
&lt;a href=&quot;https://github.com/ZipCPU/wbuart32&quot;&gt;UART&lt;/a&gt;, SPI, or
&lt;a href=&quot;https://github.com/ZipCPU/xulalx25soc/blob/master/rtl/jtagser.v&quot;&gt;JTAG&lt;/a&gt;. 
Exactly which is used will be external to our bus master implementation.&lt;/p&gt;

&lt;p&gt;We’ll have to build up the functionality in our control interface 
as we build up the whole interface.  The two sort of go together.&lt;/p&gt;

&lt;p&gt;For now, let’s handle all of our communication using 34-bit words.  We’ll use
the top 2-bits of these 34-bit words for signaling, and then the bottom 32 for
any values we wish to pass.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;input		i_reset;
input		i_cmd_stb;
input	[33:0]	i_cmd_word;
output	reg	o_cmd_busy;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Our input data word will be valid any time &lt;strong&gt;i_cmd_stb&lt;/strong&gt; is valid, but it will only
be accepted whenever &lt;strong&gt;o_cmd_busy&lt;/strong&gt; is false.  Hence, when you read the code, you
may find (&lt;strong&gt;i_stb&lt;/strong&gt;)&amp;amp;&amp;amp;(!&lt;strong&gt;o_cmd_busy&lt;/strong&gt;).  This will be the indication a
request has been accepted.&lt;/p&gt;

&lt;p&gt;For now, we’ll just set &lt;strong&gt;o_cmd_busy&lt;/strong&gt; to be true any time the bus is active.
Eventually, we’ll want to take a peek at the next bus request, and drop 
&lt;strong&gt;o_cmd_busy&lt;/strong&gt; if the next request is one we are interested in.  For example,
if we are busy doing something and the user requests a bus reset, we’ll
need to drop the busy line and accept that request.&lt;/p&gt;

&lt;p&gt;For our command words, we’ll use the following definition to define how the
34-bit control words will be interpreted:&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;33&lt;/th&gt;
      &lt;th&gt;32&lt;/th&gt;
      &lt;th&gt;31 - 0&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;Read request, ignore the rest of the 32-bits, ACK on output&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;Write request, the 32-bit data contains the word to be written&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;Set an address.  If bit 31 is set, we’ll add this value to the current bus address.  If bit 30 is set, the address will be incremented upon each bus access&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;4’h0, 28’hxx, Bus Reset&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;Our signaling scheme will allow us to issue a bus reset command, which will
abruptly cause us to abandon any bus cycle we may be in the middle of.  To
make this work, the bus reset request will need to override the busy flag.&lt;/p&gt;

&lt;p&gt;This is not the most efficient scheme.  For example, why send 34-bits when
you are only going to pay attention to two of them (i.e. the read)?  Wouldn’t
it make more sense to send a smaller number of bits for the read, together with
the number of items you intend to read?  Yes, it would.  Optimizing this command
word will be the subject of another post.&lt;/p&gt;

&lt;p&gt;The output of our bus will use (almost) the exact same approach.  We’ll create
a &lt;strong&gt;o_cmd_stb&lt;/strong&gt; signal that will be true any time the output references a
valid codeword.  Unlike the input, though, we’ll ignore any flow control on the 
output.  We can add some amount of flow control back in later with
&lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/rtl/wbufifo.v&quot;&gt;a FIFO&lt;/a&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;input		o_cmd_stb;
input		o_cmd_word;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;We’ll also borrow from the input codeword encoding for the return trip encoding,
as shown below:&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;33&lt;/th&gt;
      &lt;th&gt;32&lt;/th&gt;
      &lt;th&gt;31 - 0&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;Acknowledge a write.  The 32-bit value contains number of writes to acknowledge&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;Read response, the 32 data bits are the word that was read&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;Acknowledge an address that has been set, with two zero bits and 30 address bits&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;4’h0, 28’hxx, Bus Reset acknowledgement&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;4’h1, 28’hxx, Bus Error&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;decoding-the-control-interface&quot;&gt;Decoding the Control Interface&lt;/h2&gt;

&lt;p&gt;We have only four different types of command words in our code book.
In the first section of our simple bus master, we’ll create
flags to indicate which request is currently being made.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;assign	i_cmd_addr = (i_cmd_stb)&amp;amp;&amp;amp;(i_cmd_word[33:32] == 2&#39;b00);
assign	i_cmd_rd   = (i_cmd_stb)&amp;amp;&amp;amp;(i_cmd_word[33:32] == 2&#39;b10);
assign	i_cmd_wr   = (i_cmd_stb)&amp;amp;&amp;amp;(i_cmd_word[33:32] == 2&#39;b11);
assign	i_reset    = (i_cmd_stb)&amp;amp;&amp;amp;(i_cmd_word[33:28] == 6&#39;b110000);
// We&#39;ll use i_cmd_bus to capture whether we have a read or write request
assign	i_cmd_bus  = (i_cmd_stb)&amp;amp;&amp;amp;(i_cmd_word[33]    == 1&#39;b1);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;You may notice that I have violated my naming convention with these wires:
I have named locally generated wires with an &lt;strong&gt;i_…&lt;/strong&gt; prefix when they are
not actual inputs to our bus master module, but rather the results of
combinatorial logic applied to inputs.  In this case, it tends to work
out, but it’s not something I’m regularly going to do.&lt;/p&gt;

&lt;h2 id=&quot;the-wishbone-master-interface&quot;&gt;The Wishbone Master Interface&lt;/h2&gt;

&lt;p&gt;This bus controller will have three basic states, as shown in Fig 2.&lt;/p&gt;

&lt;table syle=&quot;float: none; align: center&quot;&gt;&lt;caption&gt;Wishbone Master State Transition Diagram&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/wb-simple-master.svg&quot; alt=&quot;Simple Bus Master state transition diagram&quot; width=&quot;700&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Here’s a quick description of each of those states:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;em&gt;IDLE&lt;/em&gt;: When we are doing nothing, both CYC and STB must be low.  In this
state, we’ll need to be responsive to incoming requests from the bus.
Upon a request, we’ll need to set the request direction (&lt;strong&gt;o_wb_we&lt;/strong&gt;),
the data lines (&lt;strong&gt;o_wb_data&lt;/strong&gt;) and then CYC and STB.&lt;/p&gt;

    &lt;p&gt;We’ll also set our address lines in this state, but without adjusting
CYC or STB.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;em&gt;BUS REQUEST&lt;/em&gt;: When CYC and STB are both high, a bus request is taking
place.  This request phase lasts until &lt;strong&gt;i_wb_stall&lt;/strong&gt; goes low, at
which point our request has been accepted.&lt;/p&gt;

    &lt;p&gt;When we come back to this code later and transition it to handling multiple
requests, we will transition from one request
to the next any time &lt;strong&gt;o_wb_stb&lt;/strong&gt; is true and &lt;strong&gt;i_wb_stall&lt;/strong&gt; is false.&lt;/p&gt;

    &lt;p&gt;It is also possible that the acknowledgement might be received on the same
clock the transaction was requested.  We’ll need to make certain we deal
with this case.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;em&gt;BUS RESPONSE&lt;/em&gt;: After making a request of the bus, we need to wait until
the slave acknowledges it.  Every acknowledgement will lead us to sending
another response across our command interface back up our command stream.
More importantly, every read response will also need to carry the value
read from the &lt;strong&gt;i_wb_data&lt;/strong&gt; data lines in its payload.  We’ll need to
make certain we return those back to the user.&lt;/p&gt;

    &lt;p&gt;Once the last acknowledgement is received, we can transition back to the
idle state.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;There are a couple of exceptions to this model: if a bus error occurs, we’ll
simply abandon the current transaction.  This approach has the inherent
problem in it that acknowledgements may come back later and get mixed with
another bus request.  For now, we’ll accept that risk and do it anyway,
since it may be the only way to recover the bus if a peripheral is
non-responsive.&lt;/p&gt;

&lt;h3 id=&quot;simplified-overview&quot;&gt;Simplified Overview&lt;/h3&gt;

&lt;p&gt;If you’re still somewhat new to digital design and coming from the
software world, your first approach to building a Wishbone Bus Master might
look something like the following:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;initial	o_wb_cyc = 1&#39;b0;
initial	o_wb_stb = 1&#39;b0;
initial	newaddr  = 1&#39;b0;
initial	o_cmd_stb= 1&#39;b0;
always @(posedge i_clk)
if ((i_reset)||(i_wb_err))
begin
	o_wb_cyc &amp;lt;= 1&#39;b0;
	o_wb_stb &amp;lt;= 1&#39;b0;
	o_cmd_busy   &amp;lt;= 1&#39;b0;
	o_cmd_stb    &amp;lt;= 1&#39;b1;
	newaddr &amp;lt;= 0;

	// Return over the command interface that we just had an error,
	// or a bus reset
	if (i_wb_reset)
		o_cmd_word &amp;lt;= `RSP_RESET;
	else
		o_cmd_word &amp;lt;= `RSP_BUS_ERROR;
end else if ((i_cmd_stb)&amp;amp;&amp;amp;(!o_cmd_busy))
begin
	//
	// In the idle state
	//
	newaddr &amp;lt;= 0;
	if (i_cmd_addr)
	begin
		if (!i_cmd_word[31])
			o_wb_addr &amp;lt;= i_cmd_word[29:0];
		else
			o_wb_addr &amp;lt;= i_cmd_word[29:0] + o_wb_addr;

		inc &amp;lt;= i_cmd_word[32];

		// Acknowledge the new address -- on the next clock
		// (after the add has completed)
		newaddr &amp;lt;= 1&#39;b1;
	end

	if (newaddr)
	begin
		o_cmd_stb &amp;lt;= 1&#39;b1;
		o_cmd_word &amp;lt;= { `RSP_SUB_ADDR, 2&#39;b00, o_wb_addr };
	end

	o_we &amp;lt;= (i_cmd_wr);

	// On a read or write request, activate the bus and go to the bus
	// request state
	if (i_cmd_bus)
	begin
		o_wb_cyc &amp;lt;= 1&#39;b1;
		o_wb_stb &amp;lt;= 1&#39;b1;
		o_cmd_busy   &amp;lt;= 1&#39;b1;
	end

	if (i_cmd_wr)
		o_wb_data &amp;lt;= i_cmd_word[31:0];
end else if (o_wb_stb)
begin
	newaddr &amp;lt;= 1&#39;b0;
	//
	// BUS REQUEST state
	//
	// In the state where we are commanding the bus, and waiting for
	// the bus request to be accepted
	//
	// o_wb_cyc will also be true here, since we cannot allow
	// o_wb_stb to be true if o_wb_cyc is not true.  (Too many
	// peripherals depend upon this bus simplification ...)
	//
	if (!i_wb_stall)
	begin
		// The request has been accepted, don&#39;t request again.
		o_wb_stb  &amp;lt;= 1&#39;b0;
		o_wb_addr &amp;lt;= o_wb_addr + inc;

		// If we get an ack on the same cycle as the request,
		// quietly transition back to idle.
		if (i_wb_ack)
		begin
			o_wb_cyc &amp;lt;= 1&#39;b0;
			o_cmd_stb &amp;lt;= 1&#39;b1;
			if (o_wb_we)
				o_cmd_word &amp;lt;= `RSP_WRITE_ACKNOWLEDGEMENT;
			else
				o_cmd_word &amp;lt;= { `RSP_SUB_DATA, i_wb_data };
		end
	end
end else if (o_wb_cyc)
begin
	newaddr &amp;lt;= 1&#39;b0;
	if (i_wb_ack)
	begin
		o_wb_cyc &amp;lt;= 1&#39;b0;
		o_cmd_busy &amp;lt;= 1&#39;b0;
		o_cmd_stb &amp;lt;= 1&#39;b1;
		if (o_wb_we)
			o_cmd_word &amp;lt;= `RSP_WRITE_ACKNOWLEDGEMENT;
		else
			o_cmd_word &amp;lt;= { `RSP_SUB_DATA, i_wb_data };
	end
end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;From this view, the three states of the controller should be readily
apparent.  The controller starts out idle, CYC=STB=0. 
Once the controller receives a command, it
moves to a bus request state to issue the command, CYC=STB=1.  Once the
command has been issued, but before any response, it is in a bus wait state
with CYC=1, STB=0.  When the final ACK comes back, we’ll go back to idle,
CYC=STB=0.&lt;/p&gt;

&lt;p&gt;That’s how a wishbone master works.&lt;/p&gt;

&lt;p&gt;When I first sketch out a design, it often looks very similar to this giant
always block above.  Perhaps it’s my software background.  I like to build
one big always block with all the parts and pieces within it.  Indeed, my
&lt;a href=&quot;http://opencores.org/project,qspiflash&quot;&gt;flash controller&lt;/a&gt; is still built in
this fashion, with one giant always block.&lt;/p&gt;

&lt;p&gt;Now that I’ve been doing this for a while, I’ve learned that breaking the
big always block up into little blocks is easier on the FPGA.  For example,
in this case, why should the address lines only get set when the new address
command shows up &lt;em&gt;and&lt;/em&gt; the reset is clear?&lt;/p&gt;

&lt;p&gt;For this reason, we’ll split up the always block into parts and pieces.&lt;/p&gt;

&lt;h3 id=&quot;the-cyc-and-stb-lines&quot;&gt;The CYC and STB Lines&lt;/h3&gt;

&lt;p&gt;The wishbone CYC and STB lines are so integrally connected, they
tend to remain together no matter how the interface gets broken up.  Indeed,
these two wires alone define which state we are in within our state space.
Further, in the big always block above, few lines actually depend upon
the reset line.  Hence, we’ll build their state diagram like this:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;initial	o_wb_cyc = 1&#39;b0;
initial	o_wb_stb = 1&#39;b0;
always @(posedge i_clk)
	if ((i_reset)||((i_wb_err)&amp;amp;&amp;amp;(o_wb_cyc)))
	begin
		// On any error or reset, then clear the bus.
		o_wb_cyc &amp;lt;= 1&#39;b0;
		o_wb_stb &amp;lt;= 1&#39;b0;
	end else if (o_wb_stb)
	begin
		//
		// BUS REQUEST state
		//
		if (!i_wb_stall)
			// If we are only going to do one transaction,
			// then as soon as the stall line is lowered, we are
			// done.
			o_wb_stb &amp;lt;= 1&#39;b0;

		// While not likely, it is possible that a slave might ACK
		// our request on the same clock it is received.  In that
		// case, drop the CYC line.
		//
		// We gate this with the stall line in case we receive an
		// ACK while our request has yet to go out.  This may make
		// more sense later, when we are sending multiple back to back
		// requests across the bus, but we&#39;ll leave this gate here
		// as a placeholder until then.
		if ((!i_wb_stall)&amp;amp;&amp;amp;(i_wb_ack))
			o_wb_cyc &amp;lt;= 1&#39;b0;
	end else if (o_wb_cyc)
	begin
		//
		// BUS WAIT
		//
		if (i_wb_ack)
			// Once the slave acknowledges our request, we are done.
			o_wb_cyc &amp;lt;= 1&#39;b0;
	end else begin
		//
		// IDLE state
		//
		if (i_cmd_bus)
		begin
			// We&#39;ve been asked to start a bus cycle from our
			// command word, either RD or WR
			o_wb_cyc &amp;lt;= 1&#39;b1;
			o_wb_stb &amp;lt;= 1&#39;b1;
		end
	end

	// For now, we&#39;ll use the bus cycle line as an indication of whether
	// or not we are too busy to accept anything else from the command
	// port.  This will change if we want to accept multiple write
	// commands per bus cycle, but that will be a bus master that&#39;s
	// not nearly so simple.
	assign	o_cmd_busy = o_wb_cyc;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h3 id=&quot;the-write-line&quot;&gt;The write line&lt;/h3&gt;
&lt;p&gt;We can significantly simplify the output bus write enable line.  Since we only
accept commands when we are in the idle state, and we only transition to
the bus request state on a read (or write) command, we can just simply leave
this as:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(posedge i_clk)
		if (!o_wb_cyc)
			o_wb_we &amp;lt;= (i_cmd_wr);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Notice how much we just simplified this.&lt;/p&gt;

&lt;p&gt;The consequence of this simplification (and the many others like it) is that
our code will be harder to read.
The positive: because this line now uses fewer FPGA resources, there will
be less logic between clocks, allowing you to (possibly) run your clock a 
touch faster, and there will be fewer LUTs used to generate this line, allowing
you to place more of what you care about onto your FPGA.&lt;/p&gt;

&lt;h3 id=&quot;the-address-lines&quot;&gt;The Address Lines&lt;/h3&gt;

&lt;p&gt;We remove the address lines from the big block simply because there’s no reason
why the address line logic needs to depend upon the reset line.  On reset, we
can allow the address (and the increment) to both come up undefined.  We’ll
also keep our own internal new address variable in this block as well.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	//
	// The bus ADDRESS lines
	//
	initial	newaddr = 1&#39;b0;
	always @(posedge i_clk)
	begin
		if ((i_cmd_addr)&amp;amp;&amp;amp;(!o_cmd_busy))
		begin
			// If we are in the idle state, we accept address
			// setting commands.  Specifically, we&#39;ll allow the
			// user to either set the address, or add a difference
			// to our address.  The difference may not make sense
			// now, but if we ever wish to compress our command bus,
			// sending an address difference can drastically cut
			// down the number of bits required in a set address
			// request.
			if (!i_cmd_word[31])
				o_wb_addr &amp;lt;= i_cmd_word[29:0];
			else
				o_wb_addr &amp;lt;= i_cmd_word[29:0] + o_wb_addr;

			//
			// We&#39;ll allow that bus requests can either increment
			// the address, or leave it the same.  One bit in the
			// command word will tell us which, and we&#39;ll set this
			// bit on any set address command.
			inc &amp;lt;= i_cmd_word[30];
		end else if ((o_wb_stb)&amp;amp;&amp;amp;(!i_wb_stall))
			// The address lines are used while the bus is active,
			// and referenced any time STB &amp;amp;&amp;amp; !STALL are true.
			//
			// However, once STB and !STALL are both true, then the
			// bus is ready to move to the next request.  Hence,
			// we add our increment (one or zero) here.
			o_wb_addr &amp;lt;= o_wb_addr + , inc};


		// We&#39;d like to respond to the bus with any address we just
		// set.  The goal here is that, upon any read from the bus,
		// we should be able to know what address the bus was set to.
		// For this reason, we want to return the bus address up the
		// command stream.
		//
		// The problem is that the add (above) when setting the address
		// takes a clock to do.  Hence, we&#39;ll use &quot;newaddr&quot; as a flag
		// that o_wb_addr has a new value in it that needs to be
		// returned via the command link.
		newaddr &amp;lt;= ((i_cmd_addr)&amp;amp;&amp;amp;(!o_cmd_busy));
	end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h3 id=&quot;the-output-data-lines&quot;&gt;The output data lines&lt;/h3&gt;

&lt;p&gt;Those output data lines can be set just like the write enable line.  Only,
this time, we don’t care what the lines are set to when we are reading.
Hence, we’ll set them upon any request.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(posedge i_clk)
	begin
		// This may look a touch confusing ... what&#39;s important is that:
		//
		// 1. No one cares what the bus data lines are, unless we are
		//	in the middle of a write cycle.
		// 2. Even during a write cycle, these lines are don&#39;t cares
		//	if the STB line is low, indicating no more requests
		// 3. When a request is received to write, and so we transition
		//	to a bus write cycle, that request will come with data.
		// 4. Hence, we set the data words in the IDLE state on the
		//	same clock we go to BUS REQUEST.  While in BUS REQUEST,
		//	these lines cannot change until the slave has accepted
		//	our inputs.
		//
		// Thus we force these lines to be constant any time STB and
		// STALL are both true, but set them otherwise.
		//
		if ((!o_wb_stb)||(!i_wb_stall))
			o_wb_data &amp;lt;= i_cmd_word[31:0];
	end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Since we are setting 32 outputs, the logic savings is much greater than the
savings from simplifying just the one &lt;strong&gt;o_wb_we&lt;/strong&gt; line.&lt;/p&gt;

&lt;h3 id=&quot;the-output-result&quot;&gt;The output result&lt;/h3&gt;

&lt;p&gt;We also need to return a result back up the command chain.  This result will
be dependent upon what has taken place.  It could be:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;An acknowledgement of a bus reset request&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;A notification of a bus error&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;An acknowledgement of a new address, or a value that has been written&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Or (finally) the result of any data  read from the bus.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Because of all of these possibilities, it takes a bit of logic to set this
right.  Remember, &lt;strong&gt;o_cmd_stb&lt;/strong&gt; will be true any time &lt;strong&gt;o_cmd_word&lt;/strong&gt; has valid
information, and that the &lt;strong&gt;o_cmd_word&lt;/strong&gt; wires are don’t cares any time
&lt;strong&gt;o_cmd_stb&lt;/strong&gt; is low.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	if (i_reset)
	begin
		o_cmd_stb &amp;lt;= 1&#39;b1;
		o_cmd_word &amp;lt;= `RSP_RESET;
	end else if (i_wb_err)
	begin
		o_cmd_stb &amp;lt;= 1&#39;b1;
		o_cmd_word &amp;lt;= `RSP_BUS_ERROR;
	end else if (o_wb_cyc) begin
		//
		// We&#39;re either in the BUS REQUEST or BUS WAIT states
		//
		// Either way, we want to return a response on our command
		// channel if anything gets ack&#39;d
		o_cmd_stb &amp;lt;= (i_wb_ack);
		//
		//
		if (o_wb_we)
			o_cmd_word &amp;lt;= `RSP_WRITE_ACKNOWLEDGEMENT;
		else
			o_cmd_word &amp;lt;= { 2&#39;b01, i_wb_data };
	end else begin
		//
		// We are in the IDLE state.
		//
		// Echo any new addresses back up the command chain
		//
		o_cmd_stb  &amp;lt;= newaddr;
		o_cmd_word &amp;lt;= { 2&#39;b10, 2&#39;b00, o_wb_addr };
	end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h2 id=&quot;a-not-so-simplified-wishbone-master&quot;&gt;A Not-So Simplified Wishbone Master&lt;/h2&gt;

&lt;p&gt;If you’ve along so far, you may notice we’ve left a lot of capabilities
we want in our bus master on the floor:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;There’s no means for sending multiple write commands without dropping CYC
between them.  This will break our flash controller, so we’ll have to come
back and fix this.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;There’s no means for reading from (or writing to) multiple consecutive
addresses in one
transaction.  That’s really useful for getting us on and off the bus
quickly.  We’ll need to come back to this later.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;There are a lot of times when the bits in our 34-bit codeword are going
unused.  For example, why transmit 34-bits to our device just to send
a reset, when only six of those 34 bits are ever used to decode a reset?
Why send a 30’bit address offset, when you are just adding it to the current
address?&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;If we want a really good wishbone master interface that’s fully featured,
we’ll need to come back and fix these things.  For now, let’s move on to the
next piece in our command wishbone bridge.&lt;/p&gt;

&lt;h2 id=&quot;examples&quot;&gt;Examples&lt;/h2&gt;

&lt;p&gt;Now that you know the basic pieces of any wishbone bus master, here’s a list
of some example wishbone bus master’s that I’ve built that you might find
worth referencing:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Instruction fetch: &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/prefetch.v&quot;&gt;one word at a
time&lt;/a&gt;,
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/dblfetch.v&quot;&gt;two at a
time&lt;/a&gt;, and
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/pfcache.v&quot;&gt;using a
cache&lt;/a&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;CPU memory stage: &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/memops.v&quot;&gt;one word at a time
time&lt;/a&gt;, and
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/pipemem.v&quot;&gt;pipelined&lt;/a&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;A &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/wbdmac.v&quot;&gt;direct memory access (DMA)
controller&lt;/a&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;A [similar UART-WB bridge](
(https://github.com/ZipCPU/zbasic/blob/master/rtl/wbuexec.v).&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;next-steps&quot;&gt;Next Steps&lt;/h2&gt;

&lt;p&gt;You can find prior posts in this series on the &lt;a href=&quot;/topics.html&quot;&gt;site
topics&lt;/a&gt; page.  You can also see from 
&lt;a href=&quot;/topics.html&quot;&gt;that page&lt;/a&gt; where I’m hoping to go next.&lt;/p&gt;

</description>
        <pubDate>Thu, 08 Jun 2017 00:00:00 -0400</pubDate>
        <link>http://zipcpu.com/blog/2017/06/08/simple-wb-master.html</link>
        <guid isPermaLink="true">http://zipcpu.com/blog/2017/06/08/simple-wb-master.html</guid>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>Building A Simple In-Circuit Logic Analyzer</title>
        <description>&lt;p&gt;If you’ve never built your own &lt;a href=&quot;https://en.wikipedia.org/wiki/Logic_analyzer&quot;&gt;logic
scope&lt;/a&gt; to “see” what’s going
on within an FPGA, it’s not really that hard to do.  There are a couple of
steps required to do it, but not really all that more.&lt;/p&gt;

&lt;p&gt;Over time, I’ve built several logic scopes–each for a different environment
that I’ve been running in.  Somewhere around rebuilding the wheel for the
third time, and for a different customer each time, I decided to build
my own–so that I could have a scope that I legally owned and controlled,
and that I could bring with me to any new FPGA job.&lt;/p&gt;

&lt;p&gt;Here in this post, we’ll walk through all the steps of building a basic
&lt;a href=&quot;https://en.wikipedia.org/wiki/Logic_analyzer&quot;&gt;logic scope&lt;/a&gt;.  We’ll reserve
until later how to go about turning this scope’s results into a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Value_change_dump&quot;&gt;VCD file&lt;/a&gt;
for &lt;a href=&quot;http://gtkwave.sourceforge.net&quot;&gt;GTKWave&lt;/a&gt; viewing–but only because I was
using the scope successfully for many years before I ever even discovered
&lt;a href=&quot;http://gtkwave.sourceforge.net&quot;&gt;GTKWave&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;how-it-works&quot;&gt;How it works&lt;/h2&gt;

&lt;p&gt;Before we get into the Verilog code necessary to build one of these things,
let’s discuss what we want it to do.&lt;/p&gt;

&lt;p&gt;We’d like three capabilities from our scope.  First, whenever something goes
wrong within our design, we’d like to be able to look back into the past and see
what happened, as in Fig. 1.&lt;/p&gt;

&lt;table align=&quot;center&quot;&gt;&lt;caption&gt;Fig. 1: Looking back into the past&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/scope-past.svg&quot; alt=&quot;A scope that looks back in time&quot; width=&quot;400&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Of course, this ability to look back in time will be limited by the size of our
scope’s memory.&lt;/p&gt;

&lt;p&gt;We’d also like the ability to debug an interaction that we are in the
process of designing.  For example, if you want to read from &lt;a href=&quot;http://opencores.org/project,qspiflash&quot;&gt;flash
memory&lt;/a&gt;,
it might be valid to look at the flash data lines together with some of your
internal &lt;a href=&quot;http://opencores.org/project,qspiflash&quot;&gt;flash control&lt;/a&gt; state.  In
this case, you would want to start capturing at the time of your read request. 
This capability would look something like Fig 2.&lt;/p&gt;

&lt;table align=&quot;center&quot;&gt;&lt;caption&gt;Fig. 2: After the trigger&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/scope-now.svg&quot; alt=&quot;Using a scope to see what&#39;s happening now&quot; width=&quot;400&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Continuing the our &lt;a href=&quot;http://opencores.org/project,qspiflash&quot;&gt;flash controller&lt;/a&gt;
example, what if you wanted to know what happened
when the flash finished its program or erase cycle?  You’d then want to know
what was happening some distance from your trigger, often a known amount of
time later in relation to the trigger.  In that case, what you want will look
something like Fig 3.&lt;/p&gt;

&lt;table align=&quot;center&quot;&gt;&lt;caption&gt;Fig. 3: A future event&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/scope-future.svg&quot; alt=&quot;Examining logic lines some time in the future&quot; width=&quot;400&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;We can handle all three of these needs by counting a programmable number
of clock cycles from the scope’s trigger until we stop recording (Fig 4.)&lt;/p&gt;

&lt;table align=&quot;center&quot;&gt;&lt;caption&gt;Fig. 4: Trigger Logic&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/scope-trigger.svg&quot; alt=&quot;How the holdoff works&quot; width=&quot;400&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;There remains one other feature we are going to need and that is that we will
need to ensure our memory is initialized before we ever stop recording.
In particular, you really don’t want to find yourself chasing some “bug” in
your design, something that doesn’t make any sense, only to find out later
that the data you were reading from the scope wasn’t valid.  For this
reason, we need make sure all of the scope’s memory is initialized before it can
be triggered.&lt;/p&gt;

&lt;p&gt;This leads to the rough timing diagram shown in Fig 5.&lt;/p&gt;

&lt;table&gt;&lt;caption&gt;Fig. 5: Scope timing&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/simple-scope.svg&quot; alt=&quot;The stages of a scope&#39;s capture&quot; width=&quot;800&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;In particular, following any scope reset, we’ll insist on setting all of the
values in memory before permitting the scope to be triggered.&lt;/p&gt;

&lt;p&gt;Okay, now that we know what we want to do, let’s look into how to do it.&lt;/p&gt;

&lt;h2 id=&quot;filling-the-scope&quot;&gt;Filling the scope&lt;/h2&gt;

&lt;p&gt;The first step to building a scope is to load your data into the scope.  There
are two parts to this.  The first is keeping track of the address you are
writing within your block RAM, and the second part is actually writing to that
memory.  Both parts are quite simple.&lt;/p&gt;

&lt;p&gt;We’ll use a register, &lt;strong&gt;waddr&lt;/strong&gt; to contain the address we wish to write to.
We’ll insist that this address start at zero only so we can tell if the
scope’s memory was ever fully initialized.  This address will quietly wrap
around the limits of the memory, whatever those limits might be, as we write.
We’ll also increment this address every time we receive a valid data sample
until the scope stops.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	if (i_reset)
		waddr &amp;lt;= 0;
	else if ((i_ce)&amp;amp;&amp;amp;(!stopped))
		waddr &amp;lt;= waddr + 1&#39;b1;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Writing to memory is even simpler: On any clock when we’ve got valid data,
we write to the scope’s memory–up until the point where we stop the scope.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	if ((i_ce)&amp;amp;&amp;amp;(!stopped))
		mem[waddr] &amp;lt;= i_data;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;If you’ve never used block RAM within an FPGA before, the various synthesis
tools can be finicky.  In general, if you have too much logic within the same
always block as the memory write, they won’t recognize the block RAM.  That’s
why we keep our memory write logic &lt;em&gt;simple&lt;/em&gt;.  (Ref
&lt;a href=&quot;https://www.xilinx.com/support/documentation/white_papers/wp231.pdf&quot;&gt;[1]&lt;/a&gt;)&lt;/p&gt;

&lt;p&gt;We also write to our memory on every clock up until we are stopped.  This is
how we guarantee that, when we get a trigger, we can have a valid capture of
whatever it was that lead up to the trigger.&lt;/p&gt;

&lt;p&gt;The final piece to our scope’s write logic is the detection of when the scope
was filled.  Since we started the write address at zero, we’ll know we have
filled the scope on the same clock that we both write to it, and write to it
with the address equal to all ones.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	if (i_reset)
		primed &amp;lt;= 1&#39;b0;
	else if ((i_ce)&amp;amp;&amp;amp;(!primed))
		primed &amp;lt;= &amp;amp;waddr;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;With this simple logic, you’ve now created your first
&lt;a href=&quot;https://en.wikipedia.org/wiki/Logic_analyzer&quot;&gt;scope&lt;/a&gt;.  Now let’s look
at how to stop it, and then how to get the results out of it.&lt;/p&gt;

&lt;h2 id=&quot;triggering-the-scope&quot;&gt;Triggering the scope&lt;/h2&gt;

&lt;p&gt;A quick examination of Fig. 4 above should make plain what we wish to do.&lt;/p&gt;

&lt;p&gt;First, from reset until we’ve been triggered, the scope runs and records
normally.  Once we receive a trigger, and only then, do we move on to the
next step.  Hence, we need to know when we’ve been triggered.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	if (i_reset)
		triggered &amp;lt;= 1&#39;b0;
	else if ((i_trigger)&amp;amp;&amp;amp;(primed))
		triggered &amp;lt;= 1&#39;b0;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;You might notice that this trigger doesn’t depend upon &lt;strong&gt;i_ce&lt;/strong&gt;, even though
all of the data reads and writes do.  This was done on purpose so that
any trigger that takes place between &lt;strong&gt;i_ce&lt;/strong&gt;’s will still get noticed by
the scope.&lt;/p&gt;

&lt;p&gt;The next step is to count some programmable number of clocks from the trigger
until we stop.  We’ll call this counter the &lt;strong&gt;holdoff_counter&lt;/strong&gt;, and
we’ll start it counting as soon as we are triggered.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_ck)
	if ((i_reset)||(!triggered))
		holdoff_counter &amp;lt;= 0;
	else if (i_ce)
		holdoff_counter &amp;lt;= holdoff_counter + 1&#39;b1;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Once the holdoff counter reaches the user holdoff, we then set a flag to
indicate we have stopped.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_ck)
	if ((i_reset)||(!triggered))
		stopped &amp;lt;= 0;
	else if ((i_ce)&amp;amp;&amp;amp;(!stopped))
		stopped &amp;lt;= (holdoff_counter &amp;gt;= user_holdoff);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The only tricky part about all of these controls is lining them all up so that
the last data sample is the sample that produced the trigger.  For now, we’ll
leave as an exercise for the student.&lt;/p&gt;

&lt;p&gt;The last step will be to read the results out of your local
&lt;a href=&quot;http://opencores.org/opencores,wishbone&quot;&gt;wishbone bus&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;reading-the-results&quot;&gt;Reading the results&lt;/h2&gt;

&lt;p&gt;When it comes to reading results, there are just a couple of tricks required. 
Most of these are involved with unwrapping the RAM memory, and the rest of
what is required is straight forward.&lt;/p&gt;

&lt;p&gt;Remember how we just wrote to successive memory locations until we stopped?
We’re going to need to unwrap all of that.&lt;/p&gt;

&lt;p&gt;The first step is to calculate the offset we need into the memory array.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	if (i_reset)
		raddr &amp;lt;= 0;
	else if ((i_wb_stb)&amp;amp;&amp;amp;(!i_wb_we)&amp;amp;&amp;amp;(i_wb_addr))
		raddr &amp;lt;= raddr + 1&#39;b1;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;We’ll then add this offset to the write address to get the address we need from
the scope’s memory.  The trick is that this operation has now taken an
extra clock.  If we want to support a throughput of one read per bus clock,
we’re going to need to add one extra unit to keep up with the bus clock.
In other words, we’ll pre-compute the next read address if we are in the middle
of a read, but otherwise have only the offset plus the last write address.&lt;/p&gt;

&lt;p&gt;Will this address calculation wrap around the end of the memory back to the
beginning?  Most definitely.  We are counting upon that.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	if ((i_wb_stb)&amp;amp;&amp;amp;(!i_wb_we)&amp;amp;&amp;amp;(i_wb_addr))
		this_addr &amp;lt;= raddr + waddr + 1&#39;b1;
	else
		this_addr &amp;lt;= raddr + waddr;
end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Now that we have our read address, referenced from the beginning of memory
rather than from the beginning of of the capture we are reporting, we can
now read from the scope’s memory.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	data &amp;lt;= mem[this_addr];&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;As you examine this, remember that block RAM logic is special, whether read or
write–it must
fit the form of what the synthesizer is expecting, or the memory will be
implemented in logic instead of RAM.  It is for that reason that we keep our
memory read as simple as possible and don’t try to merge it with the
output case statement below.&lt;/p&gt;

&lt;p&gt;The final step is to place this value onto the bus.  We hold onto our address
for one clock, so that we can align our data read with the bus request, and
make certain that we are always returning the right value on the right clock.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	last_bus_addr &amp;lt;= i_wb_addr;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;We do the same thing for our acknowledgement line, delaying it for one clock,
to give us time to actually read from the bus.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	pre_ack &amp;lt;= i_wb_stb;
always @(posedge i_clk)
	o_wb_ack &amp;lt;= pre_ack;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Otherwise reading from this scope is just as simple as reading from any
address from any other simple peripheral.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	case(last_bus_addr)
	1&#39;b0: o_wb_data &amp;lt;= { 1&#39;b0, stopped, triggered, 1&#39;b0,
			3&#39;h0, LGMEMLEN, user_holdoff };

	1&#39;b1: o_wb_data &amp;lt;= data;
	endcase&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;That’s it!  There’s not all that much to it.  A scope requires writing to
memory, stopping based upon some trigger, and then reading the data back
out later.  You’ve now seen all of these pieces.&lt;/p&gt;

&lt;h2 id=&quot;zipcpus-wishbone-scope&quot;&gt;ZipCPU’s Wishbone Scope&lt;/h2&gt;

&lt;p&gt;Now that you know how one of these scopes works, and even better how to build
your own, you might wish to check out my own version of a &lt;a href=&quot;https://github.com/ZipCPU/wbscope&quot;&gt;wishbone
scope&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;There are a couple of differences between that my own &lt;a href=&quot;https://github.com/ZipCPU/wbscope&quot;&gt;wishbone
scope&lt;/a&gt;, name wbscope and found on GitHub,
and the scope we’ve just outlined above, although not that many.  Here’s a
quick list of differences:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/ZipCPU/wbscope&quot;&gt;wbscope&lt;/a&gt; allows you to use two
asynchronous clocks, if you need them: one for the data and another
for the bus.&lt;/p&gt;

    &lt;p&gt;I needed this capability when testing the &lt;a href=&quot;https://github.com/ZipCPU/openarty/blob/master/rtl/enetpackets.v&quot;&gt;RMII ethernet
controller&lt;/a&gt;
within the &lt;a href=&quot;https://github.com/ZipCPU/openarty&quot;&gt;OpenArty project&lt;/a&gt; for the
&lt;a href=&quot;http://store.digilentinc.com/arty-artix-7-fpga-development-board-for-makers-and-hobbyists&quot;&gt;Arty board&lt;/a&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Data capture within our &lt;a href=&quot;https://github.com/ZipCPU/wbscope&quot;&gt;wishbone scope&lt;/a&gt;
has been carefully calibrated so that a hold off of zero will place the
trigger in exactly the last location in memory.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The &lt;a href=&quot;https://github.com/ZipCPU/wbscope&quot;&gt;wishbone scope&lt;/a&gt; in the repo adds
a couple extra bus directed capabilities.  These include&lt;/p&gt;

    &lt;p&gt;o an interrupt output for an on-board CPU,&lt;/p&gt;

    &lt;p&gt;o the ability to manually disable the scope’s trigger, or even&lt;/p&gt;

    &lt;p&gt;o the ability to manually trigger the scope from the bus independent of the
  trigger wired into the scope.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;I’ve also built a &lt;a href=&quot;https://github.com/ZipCPU/wbscope/blob/master/rtl/wbscopc.v&quot;&gt;compressed version of the
scope&lt;/a&gt; that
applies
&lt;a href=&quot;https://en.wikipedia.org/wiki/Run-length_encoding&quot;&gt;run length encoding&lt;/a&gt;
to the data, to allow recording events over a long period of time.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Further, there’s even a &lt;a href=&quot;https://github.com/ZipCPU/wbscope/blob/master/rtl/axi4lscope.v&quot;&gt;AXI-lite version of the
scope&lt;/a&gt;, although
since I don’t use the AXI bus, that version has not been tested very much–so
I can’t assure you that it works.&lt;/p&gt;

&lt;h2 id=&quot;next-steps&quot;&gt;Next Steps&lt;/h2&gt;

&lt;p&gt;We’ll still queue up for later how to actually create a
&lt;a href=&quot;http://opencores.org/opencores,wishbone&quot;&gt;wishbone bus master&lt;/a&gt; that can
be commanded from from a local host PC, as well as instructions for how to
turn these results into a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Value_change_dump&quot;&gt;VCD file&lt;/a&gt;
that you can view with &lt;a href=&quot;http://gtkwave.sourceforge.net&quot;&gt;GTKWave&lt;/a&gt;.&lt;/p&gt;

</description>
        <pubDate>Thu, 08 Jun 2017 00:00:00 -0400</pubDate>
        <link>http://zipcpu.com/blog/2017/06/08/simple-scope.html</link>
        <guid isPermaLink="true">http://zipcpu.com/blog/2017/06/08/simple-scope.html</guid>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>Nearest Neighbor Interpolation</title>
        <description>&lt;p&gt;One of the most common things any DSP implementation needs to do is
interpolation.  Here, let’s just discuss how to handle nearest neighbour
interpolation.&lt;/p&gt;

&lt;p&gt;Among all interpolants, the nearest neighbour interpolator is probably the
worst one you could use with respect to signal quality.  Better interpolators
exist: linear interpolation, quadratic interpolation, etc.  These all require
multiplies, careful attention to detail to avoid overflow, and more.  If you
want to build an interpolator, though, the nearest neighbour interpolator
is the place to start learning.&lt;/p&gt;

&lt;p&gt;As you read below, you’ll see why a nearest neighbour interpolator is the
simplest interpolator you could build.&lt;/p&gt;

&lt;h2 id=&quot;problem-setup&quot;&gt;Problem Setup&lt;/h2&gt;

&lt;p&gt;The first step to interpolation is to set up the problem properly.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Your input is an &lt;strong&gt;i_data&lt;/strong&gt; bus which will be valid any time &lt;strong&gt;i_stb&lt;/strong&gt;
is true.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Your output is an &lt;strong&gt;o_data&lt;/strong&gt; bus, together with an &lt;strong&gt;o_stb&lt;/strong&gt; qualifier.
Whenever the &lt;strong&gt;o_stb&lt;/strong&gt; line is true, the &lt;strong&gt;o_data&lt;/strong&gt; bus will have valid
data within it.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;generating-the-output-clock&quot;&gt;Generating the Output Clock&lt;/h2&gt;

&lt;p&gt;The next step is to handle your clock.  Here, you have two options.  You
can generate a &lt;a href=&quot;/blog/2017/06/02/generating-timing.html&quot;&gt;fractional
clock&lt;/a&gt; based upon
your system clock, or you could do the same based upon the input sampling clock.
The two options will look nearly identical.&lt;/p&gt;

&lt;p&gt;Here’s how you would generate your output timing based upon the system clock:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	{ o_stb, counter } &amp;lt;= counter + fractional_system_clock_divider;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;In this case, the &lt;strong&gt;fractional_system_clock_divider&lt;/strong&gt; is given by
two raised to the clock width, times the output clock rate you would like,
divided by the system clock rate.  The units of the two clock rates don’t
matter, just as long as they are consistent.&lt;/p&gt;

&lt;p&gt;And here’s how you would generate the output clock based upon the incoming
sample clock:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	if (i_stb)
		{ o_stb, counter } &amp;lt;= counter + fractional_sample_clock_divider;
	else
		o_stb &amp;lt;= 1&#39;b0;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;In this case, the clock is set nearly identically, but the fractional divider
is instead calculated with respect to the input clock rate, rather than the
output clock rate.&lt;/p&gt;

&lt;h2 id=&quot;handling-the-data-signals&quot;&gt;Handling the Data Signals&lt;/h2&gt;

&lt;p&gt;On every input clock, we create a copy of the data.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	if (i_stb)
		neighbour &amp;lt;= i_data;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;On every output clock, we copy that data to the output.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	if (o_stb)
		o_data &amp;lt;= neighbour;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Might the incoming data change multiple times between the incoming sample and
the outgoing sample?  Yes.  Won’t this cause a problem?  Yes it will.  The
problem this would create is called
&lt;a href=&quot;https://en.wikipedia.org/wiki/Aliasing&quot;&gt;aliasing&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;You can solve the aliasing problem by filtering your input signal before
it comes into the resampler.&lt;/p&gt;

&lt;h2 id=&quot;does-anyone-really-use-this&quot;&gt;Does anyone really use this?&lt;/h2&gt;

&lt;p&gt;Nearest neighbour interpolators have a lot of problems.  It’s not hard to
find or see these problems.  If they are so poor, are they ever used?&lt;/p&gt;

&lt;p&gt;Yes.&lt;/p&gt;

&lt;p&gt;Have I ever used one?&lt;/p&gt;

&lt;p&gt;Yes.&lt;/p&gt;

&lt;p&gt;I used a nearest neighbour interpolator once when I needed to resample a signal
with an 1024/1023 resampler.  To make it work, though, I first insisted that the
signal was oversampled (8x in my case) at the output of the anti-aliasing
filter.  When I later compared the result with a linear interpolator,
the nearest neighbour interpolator worked “good enough” for my application, and
so I dropped the linear interpolator alternative for this simpler one.&lt;/p&gt;

&lt;p&gt;The other place you may see this getting used is in a waveform transmitter
when the input clock is just slower than the output clock.  In this case,
if a new sample isn’t presented to the transmitter by the next sample clock,
the last sample can be repeated.  You can see this approach used in both the
&lt;a href=&quot;https://github.com/ZipCPU/wbpwmaudio/blob/master/rtl/wbpwmaudio.v&quot;&gt;PWM audio&lt;/a&gt;,
and the &lt;a href=&quot;https://github.com/ZipCPU/wbfmtx/blob/master/rtl/wbfmtxhack.v&quot;&gt;FM transmitter
(hack)&lt;/a&gt;
controllers I’ve put together.&lt;/p&gt;

&lt;h2 id=&quot;for-further-study&quot;&gt;For Further Study&lt;/h2&gt;

&lt;p&gt;If you are interested in knowing more about interpolation, you can find a
document describing how to do arbitrary digital interpolation
&lt;a href=&quot;https://github.com/ZipCPU/interpolation/blob/master/interpolation.pdf&quot;&gt;here&lt;/a&gt;.
In this blog, we’ll focus not on the generics of interpolation, but rather on
how to build an interpolator.&lt;/p&gt;

</description>
        <pubDate>Tue, 06 Jun 2017 00:00:00 -0400</pubDate>
        <link>http://zipcpu.com/dsp/2017/06/06/simple-interpolator.html</link>
        <guid isPermaLink="true">http://zipcpu.com/dsp/2017/06/06/simple-interpolator.html</guid>
        
        
        <category>dsp</category>
        
      </item>
    
      <item>
        <title>An Overview of a Wishbone-UART Bridge</title>
        <description>&lt;p&gt;I’ve now tried to write about how to convert a UART stream to a wishbone master
several times over, and … each time the result has been too complex to
explain within a simple blog post.&lt;/p&gt;

&lt;p&gt;So, in good engineering fashion, let’s decompose the problem.  Instead of
presenting an entire wishbone controller, let me instead present you with an
overview of the RTL side of a &lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/rtl/wbubus.v&quot;&gt;working UART to wishbone
bridge&lt;/a&gt; that I’ve
now used for many of my projects.  When we build a new/simpler on this blog,
we’ll need to include many of these design elements, so it’s worth taking a
look at.&lt;/p&gt;

&lt;p&gt;You can see an outline overview of the parts and pieces I’ve used before
in Fig. 1.&lt;/p&gt;

&lt;table style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 1: WB-UART Overview&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/wb-uart-ovw.svg&quot; alt=&quot;Block Diagram of a Working Wishbone to UART converter&quot; width=&quot;240&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;h2 id=&quot;the-transport-end&quot;&gt;The Transport End&lt;/h2&gt;

&lt;p&gt;At the top of this figure are the receiver and transmitter. In this design, the
transport layer is a generic 8-bit interface.&lt;/p&gt;

&lt;p&gt;Because the transport layer is so generic, it can be provided by either a
&lt;a href=&quot;https://github.com/ZipCPU/openarty/blob/master/rtl/toplevel.v&quot;&gt;serial port&lt;/a&gt;,
&lt;a href=&quot;https://github.com/ZipCPU/xulalx25soc/blob/master/rtl/jtagser.v&quot;&gt;JTAG port&lt;/a&gt;,
or even a &lt;a href=&quot;https://store.digilentinc.com&quot;&gt;Digilent&lt;/a&gt; DEPP channel, such as the
&lt;a href=&quot;https://github.com/ZipCPU/s6soc/blob/master/rtl/deppbyte.v&quot;&gt;S6SoC&lt;/a&gt; uses.
Indeed, even my work on the &lt;a href=&quot;https://github.com/ZipCPU/icozip/blob/master/rtl/pptest/pport.v&quot;&gt;ICO
board&lt;/a&gt; will
use a fairly generic 8-bit parallel port interface.&lt;/p&gt;

&lt;p&gt;There’s one additional requirement to this interface, necessary when the
interface runs over something similar to a SPI port: there must be an idle
character.  That way when a character &lt;em&gt;must&lt;/em&gt; be sent, such as when the SPI port
must transmit in order to receive, the idle character can be sent.  To date,
I’ve used an 8’hff for this purpose–but only if I’ve needed it.  That
character can be generated by the transmitter, or quietly dropped in the
receiver.&lt;/p&gt;

&lt;h2 id=&quot;the-bus-master-end&quot;&gt;The Bus Master End&lt;/h2&gt;

&lt;p&gt;On the other end of the UART to wishbone bridge is the &lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/rtl/wbuexec.v&quot;&gt;wishbone bus
master&lt;/a&gt; that
commands the entire bus interface to the chip.  Any peripheral can be hung off
of such a bus:
&lt;a href=&quot;http://opencores.org/project,qspiflash&quot;&gt;flash&lt;/a&gt;,
&lt;a href=&quot;https://github.com/ZipCPU/xulalx25soc/blob/master/rtl/wbsdram.v&quot;&gt;SDRAM&lt;/a&gt;,
&lt;a href=&quot;https://github.com/ZipCPU/wb2axip&quot;&gt;an AXI bus&lt;/a&gt;,
&lt;a href=&quot;https://github.com/ZipCPU/openarty/blob/master/rtl/enetpackets.v&quot;&gt;network interface&lt;/a&gt;,
an LED/switch/button interface,
&lt;a href=&quot;https://github.com/ZipCPU/rtcclock&quot;&gt;real–time clock&lt;/a&gt;,
GPIO,
&lt;a href=&quot;https://github.com/ZipCPU/openarty/blob/master/rtl/wboled.v&quot;&gt;OLEDRgb controller&lt;/a&gt;,
&lt;a href=&quot;https://github.com/ZipCPU/wbuart32/blob/master/rtl/wbuart.v&quot;&gt;UART controller&lt;/a&gt;,
PS/2 mouse controller, and more.&lt;/p&gt;

&lt;p&gt;In this case, the bus master accepts commands in the form of 36-bit words. 
These 36-bit words specify to the bus:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;What address to use (one word),&lt;/li&gt;
  &lt;li&gt;Whether to write one word,&lt;/li&gt;
  &lt;li&gt;Whether to stop writing, or&lt;/li&gt;
  &lt;li&gt;Whether to read multiple words.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The read/write commands also include a bit indicating whether the address
should increment between bus accesses, or whether all of the accesses will
be to the same bus address.&lt;/p&gt;

&lt;p&gt;Three specific capabilities of that can be hung off of this bus are worth
mentioning.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;The first is the &lt;a href=&quot;http://opencores.org/project,qspiflash&quot;&gt;flash controller&lt;/a&gt;.
Because I can control the flash over
a &lt;a href=&quot;https://github.com/ZipCPU/wbuart32&quot;&gt;UART port&lt;/a&gt;, I can read, erase, and
program the flash.  That means that I can reconfigure the entire FPGA over
&lt;a href=&quot;https://github.com/ZipCPU/wbuart32&quot;&gt;UART&lt;/a&gt;.  Even better, if you connect
one of &lt;a href=&quot;https://github.com/ZipCPU/wbicapetwo&quot;&gt;Xilinx’s ICAPE2 interfaces to the
bus&lt;/a&gt;,
you can then load and reload the FPGA’s configuration–without JTAG access.&lt;/p&gt;

    &lt;p&gt;The flash interface itself creates a unique requirement of this bus:  When
writing to the flash, the flash controller uses the end of the wishbone
cycle (CYC line goes low) as the signal to start programming the flash.  For
this reason, when writing a series of values, we cannot drop the wishbone
cycle line (CYC) until the last value is written.  Dropping the CYC line is
then the indication to the flash chip that it can start programming.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Since I’ve spent much of my time building a
   &lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;CPU&lt;/a&gt;, I’m particularly interested in
   being able to start, step, halt, and reboot the
   &lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;CPU&lt;/a&gt; from a debug port controlled by
   this interface.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Finally, for the purposes of this blog, this wishbone interface is useful
because you can now control a 
&lt;a href=&quot;https://github.com/ZipCPU/wbscope&quot;&gt;Wishbone Scope&lt;/a&gt;, whether it be a
&lt;a href=&quot;https://github.com/ZipCPU/wbscope/blob/master/rtl/wbscope.v&quot;&gt;traditional
scope&lt;/a&gt; or an
&lt;a href=&quot;https://github.com/ZipCPU/wbscope/blob/master/rtl/wbscopc.v&quot;&gt;RLE compressed
scope&lt;/a&gt; which
you can then use to debug any other part of your design.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;That’s how powerful the wishbone bus master is.&lt;/p&gt;

&lt;h2 id=&quot;characters-to-bits&quot;&gt;Characters to Bits&lt;/h2&gt;

&lt;p&gt;Since this was my first interface (although now in its 3rd generation), I
needed to be able to read what was going
on.  To accomplish this, I insisted that the interface run over printable
ASCII characters: 0-9, A-Z, a-z, @ and %.  The result is that, if necessary,
I can read the interface by eye and understand what is being sent–although
it does require a (not so secret) decoder ring to do it.&lt;/p&gt;

&lt;p&gt;Newlines are treated as out of band characters, and used to end writes that may
currently be in progress.  This keeps us from using a 6-bit interface.&lt;/p&gt;

&lt;p&gt;Hence, the first level beneath the transport layer
&lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/rtl/wbutohex.v&quot;&gt;converts printable ASCII into 6-bit
words&lt;/a&gt;
and &lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/rtl/wbusixchar.v&quot;&gt;back again&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;This also slows down the speed of the transport, since the transport
layer can handle 8-bit bytes and we’re only using six of those 8-bit bytes.&lt;/p&gt;

&lt;p&gt;Perhaps we can build a better one on this blog as time progresses?&lt;/p&gt;

&lt;h2 id=&quot;assembling-into-lines&quot;&gt;Assembling into lines&lt;/h2&gt;

&lt;p&gt;While perhaps not required, the interface does &lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/rtl/wbucompactlines.v&quot;&gt;assemble responses into
lines&lt;/a&gt;.
To do this, it inserts line breaks at the end of any response, or any time the
line would otherwise overflow.&lt;/p&gt;

&lt;p&gt;From a user’s standpoint, this makes it a lot easier to synchronize your eyes
to the beginning of commands and responses–especially when/if you need to
debug this interface.&lt;/p&gt;

&lt;h2 id=&quot;packing-bytes-into-words&quot;&gt;Packing Bytes into Words&lt;/h2&gt;

&lt;p&gt;Any wishbone bus command requires first knowing whether you wish to read or
write, a bus address, and possible a 32-bit data word.&lt;/p&gt;

&lt;p&gt;To do all of these things, you need to be able to assemble 8-bit bytes into
words that are at least 32-bits in length.  That length is the minimum to hold
a 32-bit data word that you wish to write, but by itself it’s not enough.  The
interface must also be able to indicate the type of transaction that is being
requested.&lt;/p&gt;

&lt;p&gt;In the example we’ve been following, we &lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/rtl/wbureadcw.v&quot;&gt;convert six 6-bit characters into a
36-bit word&lt;/a&gt; and
&lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/rtl/wbudeword.v&quot;&gt;back again&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;While 36-bits works, it may be overkill for what we need.  Perhaps we can
drop this down to a 35-bit word?&lt;/p&gt;

&lt;h2 id=&quot;compression&quot;&gt;Compression&lt;/h2&gt;

&lt;p&gt;UARTs are slow.  Reading an FPGA’s configuration from a flash, so you know
whether or not it needs to be reflashed, over a slow UART link can be &lt;em&gt;painful&lt;/em&gt;.
To speed things up, I added compression to this example bridge.
For reading and writing, we use a simple compression scheme based upon a
table of the most recently sent values.  Addresses get compressed based
upon either the difference between them and the last address, or perhaps just
the low order bits of the address might be sent.&lt;/p&gt;

&lt;p&gt;You can see the table look up and address decoding logic within the
&lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/wbudecompress.v&quot;&gt;decompression
module&lt;/a&gt;, or the
logic to see if a codeword to be sent can be found within
a table lookup
&lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/wbucompress.v&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;resets-and-interrupts&quot;&gt;Resets and Interrupts&lt;/h2&gt;

&lt;p&gt;As a final step, the bus interface needs to handle a couple extra pieces:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;When the bus is idle, the interface should send something periodically so that  you know the FPGA is active on the other end.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;If ever an interrupt occurs, you want that information inserted into the
data stream&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;This logic is captured in the &lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/wbuidleint.v&quot;&gt;idle-int
module&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Finally, you need some form of fault tolerance, so that if a peripheral
doesn’t respond to the bus, the bus can detect that fact, reset the bus,
and return an error across the channel.  We use the same error code for a bus
time out as any generic bus error coming from the bus itself, although
we can usually tell the difference between them.&lt;/p&gt;

&lt;p&gt;This watchdog capability is handled in the &lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/wbubus.v&quot;&gt;top
level&lt;/a&gt; of the UART
to wishbone bridge.&lt;/p&gt;

&lt;h2 id=&quot;performance&quot;&gt;Performance&lt;/h2&gt;

&lt;p&gt;Since this bus communicates reads and writes of 32–bit words packed into
six 8-bit bytes and transmitted over an 8-bit channel, it takes 60 UART baud
cycles (8N1 encoding) to write one word across the bus (ignoring compression).&lt;/p&gt;

&lt;p&gt;If you switch to 7N1 encoding, you can increase your speed by about 10%,
since we were only ever using 7-bits of an 8-bit interface.&lt;/p&gt;

&lt;p&gt;Stick with us and we’ll try to beat this number.  Specifically, if we abandon a
6-bits within 8-bit interface and switch to a full 8-bit interface, we should
be able to get down to about 46 baud per word–a 30% speed increase.&lt;/p&gt;

&lt;p&gt;On the other hand, if we wish to multiplex a console port onto the channel,
we may need to stick with a 7-bit interface.  In that case, perhaps we can
use all seven bits, instead of only 65 of the 128 values?&lt;/p&gt;

&lt;h2 id=&quot;not-shown&quot;&gt;Not Shown&lt;/h2&gt;

&lt;p&gt;What isn’t shown in this diagram is the structure of the &lt;a href=&quot;https://github.com/ZipCPU/openarty/blob/master/sw/host/ttybus.cpp&quot;&gt;C++
software&lt;/a&gt;
necessary to encode and decode words to send across this bus.&lt;/p&gt;

&lt;p&gt;Still, if we can keep the interface to any redesigned bus as simple as the
&lt;a href=&quot;https://github.com/ZipCPU/openarty/blob/master/sw/host/devbus.h&quot;&gt;devbus
interface&lt;/a&gt;
that all of our interface software uses, then any software we’ve already
written to use that interface will need to be relinked with the new interface
library, but no other changes will be required.&lt;/p&gt;

&lt;h2 id=&quot;a-minimal-interface&quot;&gt;A minimal interface&lt;/h2&gt;

&lt;p&gt;On this blog, we’re going to rebuild this interface.  Our goal will be to
design it in a manner so simple that any college student can build one.
This may mean that we throw out any unused or unnecessary parts and pieces.
We’ll also see if we can’t get our newer, better interface to run faster
than this current one.&lt;/p&gt;

&lt;p&gt;The result should be a simpler WB to UART bridge, such as the one shown in
Fig 2.&lt;/p&gt;

&lt;table style=&quot;float: left&quot;&gt;&lt;caption&gt;Fig 2: WB-UART Simplified&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/wb-uart-smpl.svg&quot; alt=&quot;Block Diagram of a Simpler Wishbone to UART converter&quot; width=&quot;360&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Before we can build one of these, though, we’re going to need to spend some
time learning how to build a wishbone bus master — similar to the &lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/rtl/wbuexec.v&quot;&gt;last
one&lt;/a&gt;,
but simpler.  Simple enough that it can be understood by the student,
and simple enough that it requires very few hardware resources.  That lesson
will then inform the rest our work redesigning the interface itself.&lt;/p&gt;
</description>
        <pubDate>Mon, 05 Jun 2017 00:00:00 -0400</pubDate>
        <link>http://zipcpu.com/blog/2017/06/05/wb-bridge-overview.html</link>
        <guid isPermaLink="true">http://zipcpu.com/blog/2017/06/05/wb-bridge-overview.html</guid>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>Campus Sidewalks and FPGA Design</title>
        <description>&lt;p&gt;I once heard a fascinating answer to the question of where to place sidewalks
on campus after building a new building: Wait a year first.  After a year of
using the new building, the students and faculty will have created paths
to and from your new building.  These dirt paths then tell you where to
build your official sidewalks.&lt;/p&gt;

&lt;p&gt;This has been my experience with the &lt;a href=&quot;https://github.com/ZipCPU/wbscope/blob/master/rtl/wbscopc.v&quot;&gt;compressed wishbone
scope&lt;/a&gt; I built
years ago.&lt;/p&gt;

&lt;p&gt;The &lt;a href=&quot;https://github.com/ZipCPU/wbscope/blob/master/rtl/wbscopc.v&quot;&gt;compressed 
scope&lt;/a&gt;
wasn’t my first bus scope.  The &lt;a href=&quot;https://github.com/ZipCPU/wbscope/blob/master/rtl/wbscope.v&quot;&gt;first
scope&lt;/a&gt; was more of
a traditional scope that captured every sample based upon a trigger.  It’s
designed to be a slave on a &lt;a href=&quot;http://opencores.org/opencores,wishbone&quot;&gt;wishbone
bus&lt;/a&gt;, and so it fits nicely as a
component of a design.&lt;/p&gt;

&lt;p&gt;With just a touch of logic, it wasn’t very hard to add a &lt;a href=&quot;https://en.wikipedia.org/wiki/Run-length_encoding&quot;&gt;run-length
compression&lt;/a&gt;
feature to the front end of the &lt;a href=&quot;https://github.com/ZipCPU/wbscope/blob/master/rtl/wbscope.v&quot;&gt;traditional
scope&lt;/a&gt;.
Although this worked okay, it didn’t handle the trigger properly.  I
ignored this problem, and used the compressed scope anyway.&lt;/p&gt;

&lt;p&gt;I used it to debug a &lt;a href=&quot;http://store.digilentinc.com/pmod-gps-gps-receiver/&quot;&gt;GPS
interface&lt;/a&gt;, looking
for where the PPS signal took place with respect to the UART NMEA stream.&lt;/p&gt;

&lt;p&gt;I used it to debug a &lt;a href=&quot;http://opencores.org/opencores,wishbone&quot;&gt;wishbone bus&lt;/a&gt;,
so I could skip the idle times or even times when the slave I was debugging
wasn’t selected.&lt;/p&gt;

&lt;p&gt;More recently, I used it to debug the &lt;a href=&quot;https://github.com/ZipCPU/wbi2c&quot;&gt;I2C
portion&lt;/a&gt; of an HDMI interface.&lt;/p&gt;

&lt;p&gt;In all of these, the
&lt;a href=&quot;https://github.com/ZipCPU/wbscope/blob/master/rtl/wbscopc.v&quot;&gt;compressed scope&lt;/a&gt;
proved its worth particularly for slow
interfaces where the scope would allow longer snapshots than could fit in block
memory.  Indeed, I’m not sure I could have debugged these interfaces without a
&lt;a href=&quot;https://github.com/ZipCPU/wbscope/blob/master/rtl/wbscopc.v&quot;&gt;compressed scope&lt;/a&gt;.
But, now that I’ve done so, I’ve learned enough to go
back and add in some necessary features.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;The &lt;a href=&quot;https://github.com/ZipCPU/wbscope/blob/master/rtl/wbscopc.v&quot;&gt;scope&lt;/a&gt;
needs to have a known trigger point.  Given the output stream,
and the holdoff you configured the scope with, you should be able to know
exactly where the trigger will be in that output stream.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;If nothing is changing, the
&lt;a href=&quot;https://github.com/ZipCPU/wbscope/blob/master/rtl/wbscopc.v&quot;&gt;scope&lt;/a&gt;
should have a maximum run length, so that
it doesn’t lock up and give you no information.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The last piece of memory within the
&lt;a href=&quot;https://github.com/ZipCPU/wbscope/blob/master/rtl/wbscopc.v&quot;&gt;scope&lt;/a&gt;’s
buffer must be a data point, even if it was part of a run.  It cannot be
left as part of a run.  This is a necessary part of knowing exactly where,
within the buffer, the trigger took place.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;As with the
&lt;a href=&quot;https://github.com/ZipCPU/wbscope/blob/master/rtl/wbscope.v&quot;&gt;regular scope&lt;/a&gt;,
the
&lt;a href=&quot;https://github.com/ZipCPU/wbscope/blob/master/rtl/wbscopc.v&quot;&gt;compressed scope&lt;/a&gt;
should have the option for working off of both a data clock and a bus clock.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Timing is important.  Working at high speed is valuable.  The debugger
(i.e. scope) must be able to keep up with your logic when your logic is at
high speed.  This means that all debug/scope logic should be broken up into
pieces small enough to run at the highest speed necessary.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Hence, I just laid my metaphorical sidewalks, and rebuilt the 
&lt;a href=&quot;https://github.com/ZipCPU/wbscope/blob/master/rtl/wbscopc.v&quot;&gt;compressed scope&lt;/a&gt;
according to my needs–now that I knew what they were.&lt;/p&gt;

&lt;p&gt;If you have a &lt;a href=&quot;http://opencores.org/opencores,wishbone&quot;&gt;wishbone bus&lt;/a&gt; within
your design, then feel free to try it out and let me know how (or if) it works
for you.&lt;/p&gt;

&lt;p&gt;If you don’t have a wishbone bus within your design, then &lt;a href=&quot;/topics.html&quot;&gt;stick
around&lt;/a&gt; and we’ll discuss how to build one.&lt;/p&gt;

</description>
        <pubDate>Sat, 03 Jun 2017 00:00:00 -0400</pubDate>
        <link>http://zipcpu.com/blog/2017/06/03/building-sidewalks.html</link>
        <guid isPermaLink="true">http://zipcpu.com/blog/2017/06/03/building-sidewalks.html</guid>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>Controlling Timing within an FPGA</title>
        <description>&lt;p&gt;Within an FPGA, everything is based upon event based timing.  SPI controllers
require a logic generated clock, I2C controllers have some maximum limit they
can communicate at, UART controllers run at some user defined baud rate …
everything wants to communicate at a carefully controlled speed.&lt;/p&gt;

&lt;p&gt;Here we’ll discuss a couple ways to create the timing you need.&lt;/p&gt;

&lt;h2 id=&quot;the-power-of-two-clock-divider&quot;&gt;The Power of Two Clock Divider&lt;/h2&gt;

&lt;p&gt;The first approach I will use to timing events is usually a clock divider.
It’s just too simple and too easy to build to ignore.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;reg	[(N-1):0]	counter;
always @(posedge i_clk)
	counter &amp;lt;= counter + 1&#39;b1;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Using this approach, your clock will be nicely divided by an even 2^N.
Hence, if you attach an LED to &lt;strong&gt;counter[(N-1)]&lt;/strong&gt; you’ll have the slower clock
you need.&lt;/p&gt;

&lt;h2 id=&quot;the-simple-clock-divider&quot;&gt;The Simple Clock Divider&lt;/h2&gt;

&lt;p&gt;A very common beginners task is to create a 1kHz, 100Hz, or even a 10 Hz clock
from your input clock.  Since these are not the result of dividing your clock
by 2^N, a different approach is necessary.&lt;/p&gt;

&lt;p&gt;Suppose for example that your system clock were at 100MHz.  You’d then need to
divide it by 10M if you wanted to get a 10Hz clock.  This is easily done with
a more generic clock divider circuit.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;reg	[(N-1):0]	counter;
always @(posedge i_clk)
	if (counter &amp;lt; THRESHOLD-1&#39;b1)
		counter &amp;lt;= counter + 1&#39;b1;
	else
		counter &amp;lt;= 0;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;As before, you can then use &lt;strong&gt;counter[N-1]&lt;/strong&gt; as an LED driver, and you will
have divided your clock by whatever value you set THRESHOLD to be.&lt;/p&gt;

&lt;h2 id=&quot;the-strobe-signal&quot;&gt;The Strobe Signal&lt;/h2&gt;

&lt;p&gt;The problem with the simple clock dividers above is that the clock signal is N
bits wide, and the top bit may be one for many clocks and zero for many clocks.
How shall you make your logic work only once in all those clocks?&lt;/p&gt;

&lt;p&gt;As a first rule, &lt;em&gt;do not drive your logic like this&lt;/em&gt;:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge counter[N-1])
	begin
		// DON&#39;T DO THIS
	end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This will cause you all kinds of grief, either leading you to an unreliable
design, or forcing you to deal with multiple clock domains, clock domain
transfers, and worse.  Unless you really know what you are doing … don’t
use this approach.&lt;/p&gt;

&lt;p&gt;When I first started building FPGA designs, I would check for zero within
whatever state machine logic I had that was going to rely upon my new clock.
As a result, I tended to use something like this instead:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	if (counter == 0)
	begin
		// Don&#39;t do this
	end else if (some_other_condition)
	begin
		// Other logic goes here
	end else if ...&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;My problem was that I then needed to come back later and rebuild all this
logic.  While it worked, it required more LUTs than was actually necessary, and
it couldn’t be clocked at any high speed.&lt;/p&gt;

&lt;p&gt;So … don’t do it this way either.&lt;/p&gt;

&lt;p&gt;One way to understand the problem with this approach is to count the cost of
your logic.  This cost may be estimated by
the number of inputs necessary to create any of your logic registers. 
The larger the number of inputs, the more LUTs will be required to implement
it, the slower the logic will take.  Having
an N-bit wide clock driving a lot of logic just adds N-1 unnecessary bits to
complicate things.  As a result, while this approach will work (and did for me
for many years), it’ll only work for FPGA logic with a slow &lt;strong&gt;i_clk&lt;/strong&gt;
frequency.&lt;/p&gt;

&lt;p&gt;The better alternative is even simpler, and there’s no reason not to use it.&lt;/p&gt;

&lt;p&gt;Instead of testing for (counter == 0) within your logic, create a
strobe signal.  We’ll call our strobe signal &lt;strong&gt;ck_stb&lt;/strong&gt;:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	ck_stb &amp;lt;= (counter == THRESHOLD-1&#39;b1);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;What makes this signal so useful is that it will only ever be on for one clock
period at a time, and that one clock period will be the period that you need to
do something.  As a result, you will then only need to check whether or not
&lt;strong&gt;ck_stb&lt;/strong&gt; is true whenever you need to do something, rather than all
&lt;strong&gt;N&lt;/strong&gt; bits of &lt;strong&gt;counter&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;The next step is to build your logic so that it transitions on this strobe:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	if (ck_stb)
	begin
		// Build your logic this way instead
	end else if (some_other_condition)
	begin
	end else if ...&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;You can find an example of this within my &lt;a href=&quot;https://github.com/ZipCPU/wbuart32/tree/master/rtl&quot;&gt;WBUART cores&lt;/a&gt;.  Look for the variables &lt;strong&gt;baud_counter&lt;/strong&gt;
and &lt;strong&gt;zero_baud_counter&lt;/strong&gt; within either the transmitter or receiver
modules.&lt;/p&gt;

&lt;h2 id=&quot;the-fractional-clock-divider&quot;&gt;The Fractional Clock Divider&lt;/h2&gt;

&lt;p&gt;What if you need to divide your clock by 3.1415926535…?  Not a problem.
You can accomplish this using a fractional clock divider.  The result will
look something like:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;reg	[15:0]	counter;
always @(posedge i_clk)
	{ ck_stb, counter } &amp;lt;= counter + 16&#39;h517d;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Ok, so … there’s a couple pieces to doing this that are worth discussing in order to understand it.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;How does this work?  Well, consider what happens after 2^16 clocks … you’ll have 16’h517d transitions.  Hence, you’ve divided your clock by 16’h517d or &lt;em&gt;about&lt;/em&gt; by pi.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The &lt;strong&gt;ck_stb&lt;/strong&gt; signal will be set anytime this counter rolls over.  Because &lt;strong&gt;ck_stb&lt;/strong&gt; isn’t used to calculate the next counter, but only used as the output of this equation, &lt;strong&gt;ck_stb&lt;/strong&gt; becomes a logic signal you can use to drive your logic at the rate you want.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Notice that this clock register is 16 bits wide rather than N-bits wide.  Because of how the clock width couples with the fractional division number, I had to make this width a constant instead of a generic.  You can still change it to whatever you need it to be.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;As for the 16’h517d, this number is given by 2^16 divided by PI.  Where does the 16 come from?  It’s the width of your counter.  Does it need to be 16?  The more bits you have, the closer you’ll get to the actual frequency you wish to create.  I’ve often used 48-bits within my &lt;a href=&quot;https://github.com/ZipCPU/rtcclock&quot;&gt;Real-Time Clock Core&lt;/a&gt;, but what you choose should be a matter of your design needs and choices.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;You can also use the &lt;strong&gt;ck_stb&lt;/strong&gt; signal within your code to do things every 1/pi’th clock, just like we used the &lt;strong&gt;ck_stb&lt;/strong&gt; before.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;What if you need to generate an actual clock signal, and not just a clocked strobe?  You can use the top bit of this counter as a clock signal that you can send to peripherals if you need to.  Just … don’t use it as a clock signal within your own logic unless you really know what you are doing.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;What is the actual clock period of this clock?  Well, because we are dividing by PI, you will find either three or four ticks between &lt;strong&gt;ck_stb&lt;/strong&gt; signals, never more, never less.  This is going to create some &lt;em&gt;phase noise&lt;/em&gt; in your &lt;em&gt;clock&lt;/em&gt;.  It can cause problems with some systems, so make sure you check the spec of whatever system you might be working with in order to know what is acceptable.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;You can find a simple example of this fractional divider in &lt;a href=&quot;https://github.com/ZipCPU/icozip/blob/master/rtl/basic/clktest.v&quot;&gt;this version of
blinky&lt;/a&gt; for
the &lt;a href=&quot;http://icoboard.org&quot;&gt;ICO board&lt;/a&gt;.  I used this code to test and measure the
speed of the input clock to my &lt;a href=&quot;http://icoboard.org&quot;&gt;ICO board&lt;/a&gt;.  By using
this approach, I was able to prove that the incoming clock was 100MHz, as
opposed to the 25MHz oscillator listed in the schematic (Oops!).&lt;/p&gt;

&lt;p&gt;As a fun example, I used this same fractional clock generator approach to
create a &lt;a href=&quot;https://github.com/ZipCPU/wbfmtxhack&quot;&gt;single bit FM signal&lt;/a&gt; that I
then “transmitted” out of my GPIO ports.  Sure, it was an ugly signal, but it
was enough to lock a FM receiver to it and listen to Queen on “the radio”.&lt;/p&gt;

&lt;h2 id=&quot;the-divided-counter&quot;&gt;The Divided Counter&lt;/h2&gt;

&lt;p&gt;If your counter is so long that you can’t meet timing, there’s usually no cost
to splitting the counter into a higher word and a lower word:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;reg	low_stb, ck_stb;
reg	[(N-1):0]	low_counter, hi_counter;
always @(posedge i_clk)
	{ low_stb, low_counter } &amp;lt;= low_counter + 1&#39;b1;
always @(posedge i_clk)
	if (low_stb)
		{ ck_stb, counter } &amp;lt;= counter + 1&#39;b1;
	else
		ck_stb &amp;lt;= 1&#39;b0;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Sure, the two words may not be synchronized, but … this is still a very
doable approach.&lt;/p&gt;

&lt;h2 id=&quot;the-divided-fractional-clock-divider&quot;&gt;The Divided Fractional Clock Divider&lt;/h2&gt;

&lt;p&gt;What if you are using a fractional divider?  If you can’t meet timing with your fractional division clock, you can also divide that one into two words, both upper and lower:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;reg	[(N-1):0]	low_counter, hi_counter;
always @(posedge i_clk)
	{ low_pps, low_counter } &amp;lt;= low_counter + LOW_STEP;
always @(posedge i_clk)
	{ ck_stb, counter } &amp;lt;= counter + HIGH_STEP + low_pps;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;As before, the two counters are not in lock step with each other.  If you want to actually have a synchronized timer, you might need to delay the lower counter ‘till they line up:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;reg	[(N-1):0]	low_counter, hi_counter, dly_counter;
wire	[(2\*N-1):0]	full_counter;
always @(posedge i_clk)
	{ low_pps, low_counter } &amp;lt;= low_counter + LOW_STEP;
always @(posedge i_clk)
	dly_counter &amp;lt;= low_counter;
always @(posedge i_clk)
	{ ck_stb, counter } &amp;lt;= counter + HIGH_STEP + low_pps;
assign	full_counter = { counter, dly_counter };&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;As you can see from the many different examples above, dividing your input clock down to a rate that you can then use for your logic is fairly easy.  Given the many ways of doing this wrong, we have now at least showed you several methods for doing this “right”.&lt;/p&gt;

&lt;p&gt;Try it!  Let me know how these techniques work for you.&lt;/p&gt;
</description>
        <pubDate>Fri, 02 Jun 2017 00:00:00 -0400</pubDate>
        <link>http://zipcpu.com/blog/2017/06/02/generating-timing.html</link>
        <guid isPermaLink="true">http://zipcpu.com/blog/2017/06/02/generating-timing.html</guid>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>The Actual FPGA Design Process</title>
        <description>&lt;p&gt;As I’ve been watching students and others request help on the &lt;a href=&quot;https://forum.digilentinc.com&quot;&gt;Digilent
Forums&lt;/a&gt;, it has become apparent to me that
there’s quite a difference between the design process college students are using
and the one reality has driven me to.&lt;/p&gt;

&lt;p&gt;Perhaps pointing this out will serve as a warning to the young FPGA engineer
to start their task early, and to not underestimate the amount of work
required.&lt;/p&gt;

&lt;h2 id=&quot;the-students-fpga-design-process&quot;&gt;The Student’s FPGA Design Process&lt;/h2&gt;

&lt;p&gt;Most of the student’s I’ve seen on the forum show up about a week before
their project is due.  They want to get things done quickly, and they want
to take the fastest path they can take to get to the goal. 
Indeed, they are following the design process shown in Fig. 1.&lt;/p&gt;

&lt;table style=&quot;float: right&quot;&gt;&lt;caption&gt;Figure 1: The Student&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/student-design-process.svg&quot; alt=&quot;Student FPGA Design Process Figure&quot; width=&quot;140&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;ol&gt;
  &lt;li&gt;The student builds his design in Verilog&lt;/li&gt;
  &lt;li&gt;He then implements it on an FPGA, adjusting his design as necessary to meet
timing and build requirements&lt;/li&gt;
  &lt;li&gt;The design is then placed onto the FPGA for a test, and …&lt;/li&gt;
  &lt;li&gt;The student can’t figure out why it isn’t working.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Perhaps these students are coming from the software world.  When I program
software, I can usually debug a program using the “debug by printf” method.
If things get difficult, moving to the debugger is easy.  Either way, at any
point in my program, I can look at and examine any variable at any time and
understand what is going on within it.&lt;/p&gt;

&lt;p&gt;If you expect to do this with hardware, and particularly with FPGA’s, you are
going to end up with the other students in your class at the end of the semester
wondering what happened.  You just don’t get that much visibility into an FPGA
design.&lt;/p&gt;

&lt;p&gt;Plan for it.&lt;/p&gt;

&lt;h2 id=&quot;the-experts-design-process&quot;&gt;The Expert’s Design Process&lt;/h2&gt;

&lt;p&gt;Now, if you instead turn around and ask an expert about their design process,
they will discuss something like Fig. 2 with you.&lt;/p&gt;

&lt;table style=&quot;float: right&quot;&gt;&lt;caption&gt;Figure 2: The Expert&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img width=&quot;240&quot; src=&quot;/img/expert-design-process.svg&quot; alt=&quot;The Expert&#39;s FPGA Design Process Figure&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;If you don’t have an instructor, you have to find the specifications for
whatever chip you are going to work with.  This applies to both the FPGA’s
you work with, as well as any peripherals.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Once you think you understand how the device you wish to interface with
works, you’ll build your design to interface with that device.&lt;/p&gt;

    &lt;p&gt;I make
a particular point at this stage in my design process to document, at the
top of any Verilog files I build, how that Verilog file is going to connect
to the rest of any design.  While all of my files tend to use the
&lt;a href=&quot;http://opencores.org/opencores,wishbone&quot;&gt;Wishbone Bus&lt;/a&gt;,
I still need to define the various registers on that bus, as well
as what each of the bits within those registers means, whether the registers
are read/write, etc.&lt;/p&gt;

    &lt;p&gt;As I build my design, these become my notes and
reference.  I keep them up to date–especially before any spec sheet is ever
written.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The next step is to build a simulator for the device.  This will allow your
simulated logic to think it is talking to the actual device.&lt;/p&gt;

    &lt;p&gt;Have I skipped this step before?  Absolutely!  What was the result?  I’ve
almost always had to come back, retrace my steps, and build this simulator.
(I’m currently needing to do that with an HDMI interface I’m building.)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Once you have your logic, and a simulator in place, you can now build a test
bench that will exercise your logic against the simulator and see whether
or not your logic works.&lt;/p&gt;

    &lt;p&gt;Have I skipped this step before?  You bet!  The result?  I just got burned
this last week.&lt;/p&gt;

    &lt;p&gt;The story has to do with a &lt;a href=&quot;http://opencores.org/project,qspiflash&quot;&gt;flash
controller&lt;/a&gt; I had built.
I was recently trying to squeeze every last LUT out of my
&lt;a href=&quot;https://github.com/ZipCPU/s6soc&quot;&gt;S6SoC design&lt;/a&gt;, and
made changes to it.  I then changed it in another design, and again, and
eventually I had four different flash controllers and couldn’t tell which
worked and which didn’t.  I needed a test bench to prove that my changes
still left me with a working controller.&lt;/p&gt;

    &lt;p&gt;I had no choice, but to backtrack and build the test bench I should’ve built
in the first place.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Only after things work on the test bench, will the expert place them onto
the FPGA.  Changes made in this process (usually because something just
doesn’t quite meet timing) will still be validated through the
simulator and the test bench.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Then the expert applies his design for its first Hardware in the Loop (HITL)
test.  If the hardware he’s working with doesn’t match his simulation,
he goes back and adjusts the simulation, his design, and the test bench.&lt;/p&gt;

    &lt;p&gt;If I can, I like to use the same software for bench testing as I do for
hardware in the loop testing.  While this is not always possible, it can be
used to save a step … if you can.  That’s actually the reason why I like
to use a &lt;a href=&quot;https://github.com/ZipCPU/openarty/blob/master/sw/host/netuart.cpp&quot;&gt;TCP/IP
connection&lt;/a&gt; to connect to my boards–because you can never
tell, then, whether you are connecting to the real thing or a simulation.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Only after any design passes unit testing, is it fully integrated with the
rest of whatever the expert wishes to do.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Finally, the entire unit is tested as a whole.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The expert will also firmly scold the student for not following this form
exactly.  Sorry, students, it always happens.&lt;/p&gt;

&lt;h2 id=&quot;the-actual-design-process&quot;&gt;The Actual Design Process&lt;/h2&gt;

&lt;p&gt;The problem with this description of the expert’s design process is that the
expert isn’t telling the whole story.&lt;/p&gt;

&lt;table style=&quot;float: right&quot;&gt;&lt;caption&gt;Figure 3: Reality&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img width=&quot;400&quot; src=&quot;/img/actual-design-process.svg&quot; alt=&quot;What the Expert actually does&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Because this isn’t his first design, he has already built up a small library
of routines–most of them surrounding how to communicate with an FPGA and how
to get diagnostics from the FPGA.  Indeed, his design flow is perhaps more
appropriately characterized by Fig 3.&lt;/p&gt;

&lt;p&gt;The result is that the expert can draw values and hence insights from the logic
running within the FPGA, while the student is still stuck wondering what
happened.&lt;/p&gt;

&lt;p&gt;In my case, this scaffolding consists of both my
open source &lt;a href=&quot;https://github.com/ZipCPU/wbscope&quot;&gt;Wishbone Scope&lt;/a&gt; that works 
with &lt;a href=&quot;https://gtkwave.sourceforge.net&quot;&gt;GTK Wave&lt;/a&gt;, and 2) my open source
&lt;a href=&quot;https://github.com/ZipCPU/openarty/blob/master/rtl/wbubus.v&quot;&gt;UART to wishbone&lt;/a&gt;
converter which gives you access to that
&lt;a href=&quot;http://opencores.org/opencores,wishbone&quot;&gt;Wishbone Bus&lt;/a&gt;, to include the 
&lt;a href=&quot;https://github.com/ZipCPU/wbscope&quot;&gt;wishbone scope&lt;/a&gt; that I place on that bus.
Of course, when I first started I didn’t have
&lt;a href=&quot;https://gtkwave.sourceforge.net&quot;&gt;GTK Wave&lt;/a&gt; support–but that just illustrates
how an expert’s toolset can grow to become more useful over time.&lt;/p&gt;

&lt;h2 id=&quot;what-the-student-should-have-done&quot;&gt;What the Student should have done&lt;/h2&gt;

&lt;p&gt;What the student should have done was to take some time, between the simple
&lt;a href=&quot;/blog/2017/05/19/blinky.html&quot;&gt;blinky&lt;/a&gt; and
&lt;a href=&quot;/blog/2017/05/24/serial-port.html&quot;&gt;UART&lt;/a&gt;
projects but before the more complex projects, to build some scaffolding.
Specifically, he needs to build a means of evaluating logic from within the
FPGA, and of learning how to discover whether or not the device he’s working
with responds the way he thinks it should or not.&lt;/p&gt;

&lt;p&gt;The typical curricula doesn’t lead the student to this approach.
Instead, the typical curricula works from
&lt;a href=&quot;/blog/2017/05/19/blinky.html&quot;&gt;blinky&lt;/a&gt; to more and more
complex projects, but never focuses on how to build scaffolding out of these
projects that is necessary to be truly competent at the more complex tasks.&lt;/p&gt;

&lt;p&gt;The problem with this approach is that 1) few students know that this is a
requirement on their road to success, and 2) few students allocate time for
failure along the way.&lt;/p&gt;

&lt;p&gt;This is why student’s stumble on their complex FPGA design projects.&lt;/p&gt;

&lt;p&gt;If this has been your experience, please write to me.  I’d love to share any
lessons you’ve learned from your design projects here on this blog.&lt;/p&gt;
</description>
        <pubDate>Fri, 02 Jun 2017 00:00:00 -0400</pubDate>
        <link>http://zipcpu.com/blog/2017/06/02/design-process.html</link>
        <guid isPermaLink="true">http://zipcpu.com/blog/2017/06/02/design-process.html</guid>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>Building a simple wishbone slave</title>
        <description>&lt;p&gt;If you’ve never written bus logic before, the
&lt;a href=&quot;http://opencores.org/opencores,wishbone&quot;&gt;wishbone bus&lt;/a&gt; is a good place to
start.  Although other busses have more features to them, 
the &lt;a href=&quot;http://opencores.org/opencores,wishbone&quot;&gt;wishbone bus&lt;/a&gt; can be simplified
into an extremely easy bus to work with.&lt;/p&gt;

&lt;p&gt;For our purpose, we’ll be using the
&lt;a href=&quot;http://opencores.org/cdn/downloads/wbspec_b4.pdf&quot;&gt;B4 version of the specification&lt;/a&gt;,
and specifically the pipelined mode within it.&lt;/p&gt;

&lt;h2 id=&quot;wishbone-bus-components&quot;&gt;Wishbone bus components&lt;/h2&gt;

&lt;p&gt;The first step, though, is to simplify the wishbone bus for our discussion.
As with the other logic I have presented, I prefix ports with &lt;strong&gt;i_&lt;/strong&gt; if they
are inputs, and &lt;strong&gt;o_&lt;/strong&gt; if they are outputs.  Further, because these inputs
and outputs to our bus slave are wishbone connected, I’ll adjust their
prefixes to read &lt;strong&gt;i_wb_&lt;/strong&gt; for inputs and &lt;strong&gt;o_wb_&lt;/strong&gt; for outputs.&lt;/p&gt;

&lt;p&gt;Using this notation, the
&lt;a href=&quot;http://opencores.org/cdn/downloads/wbspec_b4.pdf&quot;&gt;wishbone specification&lt;/a&gt;
defines the following wires from the perspective of a slave:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;i_wb_cyc&lt;/strong&gt; is true any time a wishbone transaction is taking place.  It
 needs to become true on (or before) the first &lt;strong&gt;i_wb_stb&lt;/strong&gt; clock,
 and generally stays true until the last &lt;strong&gt;o_wb_ack&lt;/strong&gt;.&lt;/p&gt;

    &lt;p&gt;We’re going to assume that the &lt;strong&gt;i_wb_cyc&lt;/strong&gt; line is high during our
 transaction, and that the logic necessary to insure this has already been
 taken care of within the bus master.  Therefore, we’ll ignore this wire.&lt;/p&gt;

    &lt;p&gt;Incidentally, the &lt;a href=&quot;http://opencores.org/cdn/downloads/wbspec_b4.pdf&quot;&gt;specification&lt;/a&gt;
 isn’t clear regarding whether or not this signal can be ignored by the slave.
 (It cannot be ignored by the interconnect …)  If you
 are dealing with a master you aren’t certain of, you can &lt;em&gt;and&lt;/em&gt; your
 &lt;strong&gt;i_wb_stb&lt;/strong&gt; line with your &lt;strong&gt;i_wb_cyc&lt;/strong&gt; signal and do just as well.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;i_wb_stb&lt;/strong&gt; is true for any bus transaction request.  While &lt;strong&gt;i_wb_stb&lt;/strong&gt;
 is true, the other wishbone slave inputs (&lt;strong&gt;i_wb_we&lt;/strong&gt;, &lt;strong&gt;i_wb_addr&lt;/strong&gt;,
 &lt;strong&gt;i_wb_data&lt;/strong&gt;, and &lt;strong&gt;i_wb_sel&lt;/strong&gt;) are valid and reference the same
 transaction.  The transaction is accepted by the slave any time
 &lt;strong&gt;i_wb_stb&lt;/strong&gt; is true at the same time as &lt;strong&gt;o_wb_stall&lt;/strong&gt; is false.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;i_wb_we&lt;/strong&gt; is true for any write requests&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;i_wb_addr&lt;/strong&gt; contains the address of the request&lt;/p&gt;

    &lt;p&gt;From the perspective of
 the wishbone slave that we are working with, this address contains only the
 address lines of relevance to the slave.  Hence, while the bus may have 32
 address lines, the slave might only be interested in might have anywhere
 between no address lines and all 32 address lines.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;i_wb_data&lt;/strong&gt; contains the data we wish to write.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;o_wb_ack&lt;/strong&gt; is a response from the slave, indicating that the request has
 been completed.  For every request given to the slave, there must be one
 and only one clock cycle with &lt;strong&gt;o_wb_ack&lt;/strong&gt; high&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;o_wb_stall&lt;/strong&gt; is used to control the flow of data into the slave.  It will
 be true on any cycle when the master &lt;em&gt;cannot&lt;/em&gt; accept data from the slave,
 and false any time data can be accepted.  This allows the slave to control
 the flow of requests being given to it.&lt;/p&gt;

    &lt;p&gt;For our simple example, we’ll just set this line to zero.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;o_wb_data&lt;/strong&gt; is the data returned by the slave to the bus master as a 
 result of any read request.  It is valid whenever &lt;strong&gt;o_wb_ack&lt;/strong&gt; is true,
 and it’s value may be ignored any time &lt;strong&gt;o_wb_ack&lt;/strong&gt; is false.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;While &lt;a href=&quot;http://opencores.org/cdn/downloads/wbspec_b4.pdf&quot;&gt;the spec&lt;/a&gt;,
defines other wires that may be a part of this interface, we’ll ignore these
and instead focus on the minimum required logic
necessary to get a simplified demonstration up and running.&lt;/p&gt;

&lt;h2 id=&quot;writes-to-the-slave&quot;&gt;Writes to the slave&lt;/h2&gt;

&lt;p&gt;You may remember from our discussion on how to write to a 
&lt;a href=&quot;/zipcpu/2017/05/23/simplebus.html&quot;&gt;very simple bus&lt;/a&gt; that we based all of
our logic off of an &lt;strong&gt;i_wr&lt;/strong&gt; line.  Whenever this line was true, we would
read from the bus.  As a review,
the &lt;a href=&quot;/zipcpu/2017/05/23/simplebus.html&quot;&gt;simple bus&lt;/a&gt; write logic was written as,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	if (i_wr)
		memory[i_addr] &amp;lt;= i_data;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Moving from this simple example to the wishbone is quite easy.  In particular,
&lt;em&gt;all&lt;/em&gt; we need to do is to adjust the &lt;strong&gt;i_wr&lt;/strong&gt; logic for the wishbone bus.
Once done, the interaction should look identical:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	if ((i_wb_stb)&amp;amp;&amp;amp;(i_wb_we)&amp;amp;&amp;amp;(!o_wb_stall))
	begin
		// Your write logic here, such as
		// memory[i_addr] &amp;lt;= i_data;
	end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Simple, huh?&lt;/p&gt;

&lt;h2 id=&quot;reads-from-the-slave&quot;&gt;Reads from the slave&lt;/h2&gt;

&lt;p&gt;Reading from the port is fairly easy as well.  The first step is to create a
response for every address given to us, as we did before.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	//
	// Basically o_wb_data &amp;lt;= memory[i_wb_addr];
	//
	// If you aren&#39;t implementing a memory, your
	// result will instead look like ...
	case(i_wb_addr)
	4&#39;h0: o_wb_data &amp;lt;= some_register;
	// ...
	default: o_wb_data &amp;lt;= some_default response;
	end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;One more step is required for both reading and writing: we need to return an
acknowledgement back to the bus that this transaction has been completed, and
that the data on the bus is now valid.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	o_wb_ack &amp;lt;= ((i_wb_stb)&amp;amp;&amp;amp;(!o_wb_stall));&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;For some peripherals, the answer is known before you request it.  In that
case, you might just &lt;em&gt;assign&lt;/em&gt; the &lt;strong&gt;o_wb_ack&lt;/strong&gt; signal instead of waiting for
the positive edge of the clock.&lt;/p&gt;

&lt;p&gt;Other peripherals may need to delay the acknowledgement by another clock.  Two examples of this would be the &lt;a href=&quot;https://github.com/ZipCPU/wbscope&quot;&gt;wishbone scope&lt;/a&gt; and the &lt;a href=&quot;https://github.com/ZipCPU/wbuart/blob/master/wbuart.v&quot;&gt;wbuart serial port&lt;/a&gt; controller.  Both of these examples require one clock to calculate an output,
and then another clock to select between possible outputs.&lt;/p&gt;

&lt;p&gt;The other key piece to any wishbone interaction is the stall line.  For our
simple interaction, we’ll just hold this line zero.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;assign	o_wb_stall = 1&#39;b0;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;What that means is that we are able to accept a wishbone request on every
clock cycle, and that our transaction rate will be as fast as the clock rate.
This works well for many peripherals, although some peripherals such as
&lt;a href=&quot;http://opencores.org/project,qspiflash&quot;&gt;flash&lt;/a&gt;
or &lt;a href=&quot;http://github.com/ZipCPU/xulalx25/blob/master/rtl/wbsdram.v&quot;&gt;SDRAM&lt;/a&gt; may
need to adjust this line if they cannot accept a new request every
clock cycle.&lt;/p&gt;

&lt;h2 id=&quot;what-if-you-can-only-accept-requests--sometimes&quot;&gt;What if you can only accept requests … sometimes?&lt;/h2&gt;

&lt;p&gt;So … what if your peripheral cannot accept requests on every clock cycle?&lt;/p&gt;

&lt;p&gt;Here’s an example set of logic where the peripheral starts a state machine
upon any request, and only returns a result once the state machine becomes
idle.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;reg	busy;

always @(posedge i_clk)
	if ((i_wb_stb)&amp;amp;&amp;amp;(!o_wb_stall))
	begin
		state &amp;lt;= SOME_NEW_STATE;
		local_data &amp;lt;= i_wb_data;
		busy &amp;lt;= 1&#39;b1;
	end else case(state)
	SOME_NEW_STATE: begin
		// Your logic here ...
		if (some_condition)
			state &amp;lt;= SOME_NEXT_STATE;
		end
	...
	SOME_FINAL_STATE: begin
		state &amp;lt;= IDLE_STATE;
		busy &amp;lt;= 1&#39;b0;
		ack  &amp;lt;= 1&#39;b1;
		o_data &amp;lt;= any_read_data_response;
	enddcase

assign	o_wb_stall &amp;lt;= busy;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Examples of this in practice include the
&lt;a href=&quot;https://github.com/ZipCPU/wbicapetwo&quot;&gt;wishbone ICAPE2 controller&lt;/a&gt;,
and a &lt;a href=&quot;http://opencores.org/project,qspiflash&quot;&gt;QSPI flash controller&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;what-can-you-use-this-interface-for&quot;&gt;What can you use this interface for?&lt;/h2&gt;

&lt;p&gt;What can you use this for?  Anything!  Feel free to look over our
&lt;a href=&quot;/projects.html&quot;&gt;projects page&lt;/a&gt; for some example peripheral components that
use this simple interaction.&lt;/p&gt;

&lt;p&gt;In particular, I intend to follow up this article with the idea of using a
wishbone interface to create an interface whereby
&lt;a href=&quot;https://github.com/ZipCPU/wbscope&quot;&gt;a scope&lt;/a&gt; may be read for improved
debugging purposes.&lt;/p&gt;
</description>
        <pubDate>Mon, 29 May 2017 00:00:00 -0400</pubDate>
        <link>http://zipcpu.com/zipcpu/2017/05/29/simple-wishbone.html</link>
        <guid isPermaLink="true">http://zipcpu.com/zipcpu/2017/05/29/simple-wishbone.html</guid>
        
        
        <category>zipcpu</category>
        
      </item>
    
      <item>
        <title>Bus Select Lines</title>
        <description>&lt;p&gt;In a previous post, I discussed how to build a &lt;a href=&quot;/zipcpu/2017/05/29/simple-wishbone.html&quot;&gt;simple wishbone bus
slave&lt;/a&gt;.  That post
eliminated a lot of the bus lines so as to make building a simple bus slave
easy.&lt;/p&gt;

&lt;p&gt;As a result, that bus as built could not handle 8-bit bytes.&lt;/p&gt;

&lt;p&gt;This post will describe how to add the appearance of 8-bit addressing to a
wishbone bus slave.&lt;/p&gt;

&lt;h2 id=&quot;bus-word-size&quot;&gt;Bus Word Size&lt;/h2&gt;

&lt;p&gt;The word size of any bus is given by by the number of data lines contained
within that bus.  The speed of the bus is constrained to be one transaction
per clock, at most, and hence any bus design can at most read (or write)
one bus word at a time.  Hence, increasing the width of the bus will increase
the throughput of that bus.&lt;/p&gt;

&lt;p&gt;The consequence of this, though, is that addresses on the bus don’t reference
octets (8-bit bytes), but rather words.  Instead, a wider bus represents an
array of words, not an array of bytes.&lt;/p&gt;

&lt;p&gt;The problem with word references is that most software is built with the
legacy understanding that memory exists as a series of octets (8-bit bytes).&lt;/p&gt;

&lt;p&gt;So … although the bus exists as an array of words, modern computer software
considers it to be an array of octets.&lt;/p&gt;

&lt;p&gt;How shall this illusion be kept?&lt;/p&gt;

&lt;h2 id=&quot;select-lines&quot;&gt;Select lines&lt;/h2&gt;

&lt;p&gt;The answer to the question of how to make an array of words look like an array
of bytes is the bus select lines.&lt;/p&gt;

&lt;p&gt;Remember how we defined how a memory would access a bus &lt;a href=&quot;/zipcpu/2017/05/23/simplebus.html&quot;&gt;earlier&lt;/a&gt;?&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	if (i_wr)
		memory[i_addr] &amp;lt;= i_data;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Or how &lt;a href=&quot;/zipcpu/2017/05/29/simple-wishbone.html&quot;&gt;we discussed&lt;/a&gt; what this would look like for the &lt;a href=&quot;http://opencores.org/cdn/downloads/wbspec_b4.pdf&quot;&gt;wishbone bus&lt;/a&gt;?&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	if ((i_wb_stb)&amp;amp;&amp;amp;(i_wb_we))
		memory[i_addr] &amp;lt;= i_data;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Adding select lines to this transaction is fairly easy.  In particular, the
four select lines indicate which byte on the bus has valid data within it.
What we do, therefore, is to gate each of the individual byte writes by this
select line:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	reg	[(BUS_WIDTH-1):0]	mem	[(0:((1&amp;lt;&amp;lt;(ADDRESS_WIDTH)-1)];
	always @(posedge i_clk)
	begin
		if ((i_wb_stb)&amp;amp;&amp;amp;(i_wb_we)&amp;amp;&amp;amp;(w_sel[3]))
			mem[i_wb_addr][31:24] &amp;lt;= i_wb_data[31:24];
		if ((i_wb_stb)&amp;amp;&amp;amp;(i_wb_we)&amp;amp;&amp;amp;(w_sel[2]))
			mem[i_wb_addr][23:16] &amp;lt;= i_wb_data[23:16];
		if ((i_wb_stb)&amp;amp;&amp;amp;(i_wb_we)&amp;amp;&amp;amp;(w_sel[1]))
			mem[i_wb_addr][15: 8] &amp;lt;= i_wb_data[15:8];
		if ((i_wb_stb)&amp;amp;&amp;amp;(i_wb_we)&amp;amp;&amp;amp;(w_sel[0]))
			mem[i_wb_addr][ 7: 0] &amp;lt;= i_wb_data[7:0];
	end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Format here is important.  Just a subtle change in this formula, and the
synthesis tool may no longer infer a block RAM.  If this happens, your LUT
usage is likely to massively increase.  To deal with this issue, know where
to find the guide that specifies how block RAM’s are inferred.  For example,
&lt;a href=&quot;https://www.xilinx.com/support/documentation/white_papers/wp231.pdf&quot;&gt;here’s a link&lt;/a&gt; to the guide for Xilinx.&lt;/p&gt;

&lt;p&gt;If you can’t get your synthesis tool to recognize a memory with select lines,
you may have to do this final bus decoding yourself:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;reg	[(7-1):0]	mem_a	[(0:((1&amp;lt;&amp;lt;(ADDRESS_WIDTH)-1)];
reg	[(7-1):0]	mem_b	[(0:((1&amp;lt;&amp;lt;(ADDRESS_WIDTH)-1)];
reg	[(7-1):0]	mem_c	[(0:((1&amp;lt;&amp;lt;(ADDRESS_WIDTH)-1)];
reg	[(7-1):0]	mem_d	[(0:((1&amp;lt;&amp;lt;(ADDRESS_WIDTH)-1)];

always @(posedge i_clk)
begin
	if ((i_wb_stb)&amp;amp;&amp;amp;(i_wb_we)&amp;amp;&amp;amp;(w_sel[3]))
		mem_a[i_wb_addr] &amp;lt;= i_wb_data[31:24];
	if ((i_wb_stb)&amp;amp;&amp;amp;(i_wb_we)&amp;amp;&amp;amp;(w_sel[2]))
		mem_b[i_wb_addr] &amp;lt;= i_wb_data[23:16];
	if ((i_wb_stb)&amp;amp;&amp;amp;(i_wb_we)&amp;amp;&amp;amp;(w_sel[1]))
		mem_c[i_wb_addr] &amp;lt;= i_wb_data[15:8];
	if ((i_wb_stb)&amp;amp;&amp;amp;(i_wb_we)&amp;amp;&amp;amp;(w_sel[0]))
		mem_d[i_wb_addr] &amp;lt;= i_wb_data[7:0];
end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;If you have to do this decoding yourself, reading from the bus would also
change to:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	o_wb_data &amp;lt;= { mem_a[i_wb_addr], mem_b[i_wb_addr],
		mem_c[i_wb_addr], mem_d[i_wb_addr] };&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;But I tend to avoid this approach if at all possible–it just seems and feels
messier.&lt;/p&gt;

&lt;h2 id=&quot;what-about-reading-from-the-bus&quot;&gt;What about reading from the bus?&lt;/h2&gt;

&lt;p&gt;The only time you need to worry about the select lines when reading from a 
wishbone bus is when you are the master and you want to decode the result
from the bus.  Hence, the bus master will just read a whole word, and then
grab the byte (or bytes) necessary when the bus request returns its data.&lt;/p&gt;

&lt;p&gt;In other words, nothing changes in the slave when you read less than a word
size from the bus.&lt;/p&gt;

&lt;h2 id=&quot;do-all-peripherals-need-to-offers-8-bit-support&quot;&gt;Do all peripherals need to offers 8-bit support?&lt;/h2&gt;

&lt;p&gt;Not at all.  If you read through device specification sheets, it’s not uncommon
for the designer to say that accesses of less than a word size are not
supported, and that their results are undefined.  This is the hardware
designer’s way of saying that the select lines may not be relied upon.&lt;/p&gt;

&lt;p&gt;In other words: when building your peripheral, you don’t need to provide select
line support.&lt;/p&gt;

&lt;p&gt;However, in order for the various string libraries to work, memory peripherals
&lt;em&gt;must&lt;/em&gt; have select line support.&lt;/p&gt;

&lt;h2 id=&quot;examples&quot;&gt;Examples&lt;/h2&gt;

&lt;p&gt;Few of my generic peripherals support memory byte selection, but all of my
memory peripherals now do.  You can find an example block RAM memory device 
&lt;a href=&quot;https://github.com/ZipCPU/openarty/blob/master/rtl/memdev.v&quot;&gt;here&lt;/a&gt;, showing
all the required pieces of what it takes to interact with a bus slave.&lt;/p&gt;

&lt;p&gt;If this is interesting to you, then stick around: discussing how to build a
wishbone bus master is next!&lt;/p&gt;
</description>
        <pubDate>Mon, 29 May 2017 00:00:00 -0400</pubDate>
        <link>http://zipcpu.com/zipcpu/2017/05/29/select-lines.html</link>
        <guid isPermaLink="true">http://zipcpu.com/zipcpu/2017/05/29/select-lines.html</guid>
        
        
        <category>zipcpu</category>
        
      </item>
    
  </channel>
</rss>
