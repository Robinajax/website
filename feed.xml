<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>The ZipCPU by Gisselquist Technology</title>
    <description>The ZipCPU blog, featuring how to discussions of FPGA and soft-core CPU design.  This site will be focused on Verilog solutions, using exclusively OpenSource IP products for FPGA design.  Particular focus areas include topics often left out of more mainstreeam FPGA design courses such as how to debug an FPGA design.
</description>
    <link>http://zipcpu.com/</link>
    <atom:link href="http://zipcpu.com/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Sat, 16 Sep 2017 06:36:29 -0400</pubDate>
    <lastBuildDate>Sat, 16 Sep 2017 06:36:29 -0400</lastBuildDate>
    <generator>Jekyll v3.0.1</generator>
    <image>
      <url>http://zipcpu.com/img/gt-rss.png</url>
      <title></title>
      <link></link>
    </image>
    
      <item>
        <title>Demonstrating the improved PWM waveform</title>
        <description>&lt;p&gt;This post follows our prior post titled
&lt;a href=&quot;/dsp/2017/09/04/pwm-reinvention.html&quot;&gt;Reinventing PWM&lt;/a&gt;.
A reader has commented to me that I hadn’t posted any test bench or other
method to prove that this module works.  Since I also think that such a test
would be beneficial, I’ve created a &lt;a href=&quot;https://github.com/ZipCPU/wbpwmaudio/tree/master/demo-rtl&quot;&gt;test bench and
demonstration&lt;/a&gt;
which we will examine below.&lt;/p&gt;

&lt;p&gt;Most of the parts and pieces of our test code, and certainly the methodology,
could easily be applied to test just about any &lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_signal_processing&quot;&gt;Digital Signal Processing
(DSP)&lt;/a&gt;
system.  In short, we’ll put a test signal into the design, make some
predictions about how we think that test signal will behave, and then
measure the response to see how well it does and whether or not the
results match our predictions.&lt;/p&gt;

&lt;p&gt;The classic test signals for any signal processing application are
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sine_wave&quot;&gt;sine waves&lt;/a&gt;
and
&lt;a href=&quot;https://en.wikipedia.org/wiki/Dirac_delta_function&quot;&gt;impulses&lt;/a&gt;.  For
our purposes today, we’ll focus on just the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sine_wave&quot;&gt;sine wave&lt;/a&gt; input.
Specifically, let’s look at both a constant frequency and a swept frequency
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sine_wave&quot;&gt;sine wave&lt;/a&gt; input, and measure
the result the hardware provides.  We’ll also adjust our approach for both
sampling rates and volume variations.&lt;/p&gt;

&lt;p&gt;To do this, we’ll build a test design of the form shown in Fig 1.&lt;/p&gt;

&lt;table style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 1: Test Setup&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/pwmtb-setup.svg&quot; alt=&quot;Block diagram of a PDM vs PWM test&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;The test-suite design will consist not only of &lt;a href=&quot;https://github.com/ZipCPU/wbpwmaudio/blob/master/demo-rtl/toplevel.v&quot;&gt;Verilog based
logic&lt;/a&gt;,
but also a C++ &lt;a href=&quot;https://github.com/ZipCPU/wbpwmaudio/blob/master/demo-rtl/pdmdemo.cpp&quot;&gt;test bench
driver&lt;/a&gt;
that can be used to run the
&lt;a href=&quot;https://www.veripool.org/wiki/verilator&quot;&gt;Verilator&lt;/a&gt; based simulation.  This
&lt;a href=&quot;https://github.com/ZipCPU/wbpwmaudio/blob/master/demo-rtl/pdmdemo.cpp&quot;&gt;C++
portion&lt;/a&gt;
will be used to
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt; and
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sample_rate_conversion&quot;&gt;resample&lt;/a&gt;
the 100MHz
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
output pin values in order to create a file which can easily be ingested
and inspected within &lt;a href=&quot;https://www.gnu.org/software/octave/&quot;&gt;Octave&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;To control this design, we’ll have the sweep and frequency control selected
from a table at the top of each second over an 8-second repeating test
interval.  Over these 8-seconds, we’ll apply the following test cases to
demonstrate the &lt;a href=&quot;/dsp/2017/09/04/pwm-reinvention.html&quot;&gt;improved
PWM&lt;/a&gt; generator:&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Second&lt;/th&gt;
      &lt;th&gt;On/Off&lt;/th&gt;
      &lt;th&gt;Test Description&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;0-2&lt;/td&gt;
      &lt;td&gt;ON&lt;/td&gt;
      &lt;td&gt;Swept tone from 110Hz to 27.3kHz&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;off&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;4-5&lt;/td&gt;
      &lt;td&gt;ON&lt;/td&gt;
      &lt;td&gt;440 Hz Tone&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;6-7&lt;/td&gt;
      &lt;td&gt;off&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;We’ll also run the sine wave initially at it’s full amplitude, just to
demonstrate that there are no problems with the internal comparisons as
a function of range.  We’ll later adjust to &lt;code class=&quot;highlighter-rouge&quot;&gt;1/256&lt;/code&gt;th of that amount to
demonstrate that the method works reasonably for small amplitudes as well.&lt;/p&gt;

&lt;p&gt;We’ll use a physical switch input to select between which of the two outputs
we send to a &lt;a href=&quot;https://store.digilentinc.com/pmod-amp2-audio-amplifier&quot;&gt;PMod
AMP2&lt;/a&gt;
(should you happen to have one, and should you wish to try this in actual
hardware).&lt;/p&gt;

&lt;p&gt;Finally, we’ll place all the code for this test
&lt;a href=&quot;https://github.com/ZipCPU/wbpwmaudio/tree/master/demo-rtl&quot;&gt;online&lt;/a&gt;
within the
&lt;a href=&quot;https://github.com/ZipCPU/wbpwmaudio&quot;&gt;wbpwmaudio&lt;/a&gt;
repository.  This will allow you to repeat the experiment, and verify the
results for yourself should you wish to do so.&lt;/p&gt;

&lt;h2 id=&quot;test-results&quot;&gt;Test Results&lt;/h2&gt;

&lt;p&gt;Let’s walk through both the test and the results.
In simulation, we’ll measure the results with a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Spectrogram&quot;&gt;Spectrogram&lt;/a&gt;.  (Wikipedia’s
article on the &lt;a href=&quot;https://en.wikipedia.org/wiki/Periodogram&quot;&gt;Periodogram&lt;/a&gt; is
also applicable to the time slices of the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Spectrogram&quot;&gt;Spectrogram&lt;/a&gt;.)
A &lt;a href=&quot;https://en.wikipedia.org/wiki/Spectrogram&quot;&gt;Spectrogram&lt;/a&gt;
is a two-dimensional image with the
two axes being time and frequency.  Time will go from left to right, and
frequency will go from zero at the top down to the maximum at the bottom.
Spectral energy comes out of the image in a third axis.
You can see the &lt;a href=&quot;https://www.gnu.org/software/octave&quot;&gt;Octave&lt;/a&gt;
code for calculating the
&lt;a href=&quot;https://github.com/ZipCPU/wbpwmaudio/blob/master/demo-rtl/showspectrogram.m&quot;&gt;spectrogram here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The scale on the z-axes, representing signal strength will be presented in
color ranging (in &lt;a href=&quot;https://en.wikipedia.org/wiki/Decibel&quot;&gt;decibels&lt;/a&gt;)
from -80dB to 0dB relative to the maximum point in the image.
The maximum value will be held to zero dB and colored white.  We’ll
artificially cut the &lt;a href=&quot;https://en.wikipedia.org/wiki/Spectrogram&quot;&gt;spectrogram&lt;/a&gt;
off at -80dB below this maximum value, and color anything at or below this
level in black.  Hence we should expect our tone to be a brightly colored,
nearly white line, across a black (or nearly black) background.
All of this minor processing code is posted
&lt;a href=&quot;https://github.com/ZipCPU/wbpwmaudio/blob/master/demo-rtl/showspectrogram.m&quot;&gt;here&lt;/a&gt;.
You can even find the code defining these false colormap
&lt;a href=&quot;https://github.com/ZipCPU/wbpwmaudio/blob/master/demo-rtl/mymap.m&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Given the tests described above, let’s think for a moment about what we
are going to expect to see from the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Spectrogram&quot;&gt;spectrogram&lt;/a&gt; of the
audio output.  First, one would expect a slanted line, representing the
initial swept tone, ranging from zero time and 110Hz frequency to three
seconds and just past 27.3kHz in frequency.  Further, once this swept tone
reaches the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Nyquist_frequency&quot;&gt;Nyquist frequency&lt;/a&gt;
associated with the underlying sample rate, whether 4kHz or 16kHz (half the
sample rate), we should expect to see an “X” shape as the tone
&lt;a href=&quot;https://en.wikipedia.org/wiki/Aliasing&quot;&gt;aliases&lt;/a&gt; back below the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Nyquist_frequency&quot;&gt;Nyquist limit&lt;/a&gt;.  Second,
when displaying the result of the 440Hz tone, in an ideal system we would see
nothing more than a white horizontal line centered at 440Hz.
&lt;a href=&quot;https://en.wikipedia.org/wiki/Aliasing&quot;&gt;Aliasing&lt;/a&gt; effects will appear at
440Hz plus or minus multiples of the sample rate.
Third, any sudden transition will spread its energy across frequency.
Hence, any transition or hiccup in the signal, such as when the transmitter
starts or stops, should appear on our
&lt;a href=&quot;https://en.wikipedia.org/wiki/Spectrogram&quot;&gt;spectrogram&lt;/a&gt; as a (rough) vertical
line.&lt;/p&gt;

&lt;p&gt;We’ll run our first test with a 32kHz sample rate, and the second test with an
8kHz sample rate.  The sample rate will also control the period of the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Pulse-width_modulation&quot;&gt;PWM&lt;/a&gt;
waveform.  One would therefore expect silence, or near silence, to produce
a series of harmonic tones starting at this frequency when using
&lt;a href=&quot;https://en.wikipedia.org/wiki/Pulse-width_modulation&quot;&gt;PWM&lt;/a&gt;.  The
&lt;a href=&quot;https://en.wikipedia.org/wiki/Pulse-density_modulation&quot;&gt;PDM&lt;/a&gt; system
should have no such feature.  The third and final test will drop the sample
rate to &lt;code class=&quot;highlighter-rouge&quot;&gt;1/256&lt;/code&gt;th of the original sample rate.  This should allow us to see
any spectral features created while the signal tries to output values near
“zero”.&lt;/p&gt;

&lt;p&gt;These are the results that we will expect from a “perfect” system.&lt;/p&gt;

&lt;p&gt;We’ll start by examining the
&lt;a href=&quot;https://github.com/ZipCPU/wbpwmaudio/blob/master/demo-rtl/traditionalpwm.v&quot;&gt;traditional&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Pulse-width_modulation&quot;&gt;PWM&lt;/a&gt; result in Fig 2.
In this case, the sample rate was set to 32kHz–which will also drive the
period of the
&lt;a href=&quot;https://github.com/ZipCPU/wbpwmaudio/blob/master/demo-rtl/traditionalpwm.v&quot;&gt;traditional&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Pulse-width_modulation&quot;&gt;PWM&lt;/a&gt;
waveform generator.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 2: Test Results for a PWM Generator&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/pwm32k.png&quot; alt=&quot;Test Results, PWM, 32kHz sample rate&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Because the sample interval is based about 32kHz, one would expect
&lt;a href=&quot;https://en.wikipedia.org/wiki/Spectrogram&quot;&gt;spectrogram&lt;/a&gt;
content above 16kHz to be a (rough) mirror image of the content below it, and
this is what we see in the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Spectrogram&quot;&gt;spectrogram&lt;/a&gt; figure.
Although this mirroring will continue on up to 32kHz, the image is cut off
at 22kHz–the &lt;a href=&quot;https://en.wikipedia.org/wiki/Nyquist_frequency&quot;&gt;Nyquist
frequency&lt;/a&gt;
of the resampler, and the &lt;a href=&quot;https://en.wikipedia.org/wiki/Hearing_range&quot;&gt;upper end of the human hearing frequency
range&lt;/a&gt;.
If you’ve never seen this mirroring effect, it &lt;a href=&quot;http://www.dtic.mil/dtic/tr/fulltext/u2/a423141.pdf&quot;&gt;can be derived from first
principles&lt;/a&gt; under no
other assumptions than the fact that the output is a sampled real valued
signal rather than a complex one.&lt;/p&gt;

&lt;p&gt;I also expect the mirror images above the 
&lt;a href=&quot;https://en.wikipedia.org/wiki/Nyquist_frequency&quot;&gt;Nyquist frequency&lt;/a&gt;
to decay slowly with a rough
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sinc_funtion&quot;&gt;sinc shape&lt;/a&gt;,
due to the underlying &lt;a href=&quot;/dsp/2017/06/06/simple-interpolator&quot;&gt;Nearest Neighbor
interpolation&lt;/a&gt;
but I haven’t examined the results close enough to see if this is the case.&lt;/p&gt;

&lt;p&gt;As a final item of note, the swept frequency portion of the test didn’t
produce just a single swept tone line in this
&lt;a href=&quot;https://en.wikipedia.org/wiki/Spectrogram&quot;&gt;spectrogram&lt;/a&gt;,
but rather a series of slanted lines.
The lines appear to converge with the swept tone test signal at zero
frequency and spread out from there.  Put simply, the swept tone
we desired to produce didn’t come out as a pure audio tone following the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Pulse-width_modulation&quot;&gt;PWM&lt;/a&gt;.
Instead, it producesd something still periodic but slightly different from a
sine wave.  These extra swept lines represent
&lt;a href=&quot;https://en.wikipedia.org/wiki/Harmonic&quot;&gt;harmonics&lt;/a&gt; of the desired waveform,
running at roughly two, three, and four times the frequency of the swept tone.
(There’s even a fifth &lt;a href=&quot;https://en.wikipedia.org/wiki/Harmonic&quot;&gt;harmonic&lt;/a&gt;
that you can see if you look close enough.)  These represent undesired and
unwanted distortions, caused by the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Pulse-width_modulation&quot;&gt;PWM&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/wbpwmaudio/blob/master/demo-rtl/traditionalpwm.v&quot;&gt;generator&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Now let’s compare that result with the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Pulse-density_modulation&quot;&gt;PDM&lt;/a&gt; (&lt;a href=&quot;/dsp/2017/09/04/pwm-reinvention.html&quot;&gt;improved
PWM&lt;/a&gt;)
waveform in Fig 3.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 3: Test Results for the Improved Signal Generator&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/pdm32k.png&quot; alt=&quot;Test Results, PDM, 32kHz sample rate&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;From here you can see that the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Pulse-density_modulation&quot;&gt;PDM&lt;/a&gt;
waveform roughly matches what one would expect, while the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Pulse-width_modulation&quot;&gt;PWM&lt;/a&gt;
waveform in Fig 2 has all kinds of
&lt;a href=&quot;https://en.wikipedia.org/wiki/Harmonic&quot;&gt;harmonic&lt;/a&gt;
distortions.&lt;/p&gt;

&lt;table style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 4: Resampler aliasing&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/pdm32k-zoom.png&quot; alt=&quot;Figure showing the resampler aliasing and falloff&quot; width=&quot;240&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;If you look closely at Fig 3, you can even start to see some additional
aliasing effects in the swept tone near the very bottom of the image (22kHz).
Fig 4 zooms in one one of these components, so you can see what I’m talking
about.  These show the transition band of the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Anti-aliasing_filter&quot;&gt;anti-aliasing filter&lt;/a&gt;
that was used within the &lt;a href=&quot;https://github.com/ZipCPU/wbpwmaudio/blob/master/demo-rtl/pdmdemo.cpp&quot;&gt;C++ test
harness&lt;/a&gt;.
They also show the utility of having such an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Anti-aliasing_filter&quot;&gt;anti-aliasing filter&lt;/a&gt;
in the design.  Without it, there would be further swept-tone “X”s within
the design, caused by the aliased components above 22kHz sweeping back into
band.  We’ll see these additional “X” components in the next test(s).&lt;/p&gt;

&lt;p&gt;Let’s now repeat the above test using an 8kHz sample rate, but without
providing an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Anti-aliasing_filter&quot;&gt;anti-aliasing filter&lt;/a&gt;
for points above 4kHz.&lt;/p&gt;

&lt;p&gt;Without this &lt;a href=&quot;https://en.wikipedia.org/wiki/Anti-aliasing_filter&quot;&gt;anti-aliasing
filter&lt;/a&gt;, we should
expect to see &lt;a href=&quot;https://en.wikipedia.org/wiki/Aliasing&quot;&gt;aliasing&lt;/a&gt; components
above 4kHz instead of above 32kHz.  (Remember the &lt;a href=&quot;https://github.com/ZipCPU/wbpwmaudio/blob/master/demo-rtl/pdmdemo.cpp&quot;&gt;demo
software&lt;/a&gt;
only applies
&lt;a href=&quot;https://en.wikipedia.org/wiki/Anti-aliasing_filter&quot;&gt;the anti-aliasing filter&lt;/a&gt;
for frequencies above 22kHz.)  You’d expect these
&lt;a href=&quot;https://en.wikipedia.org/wiki/Aliasing&quot;&gt;aliasing&lt;/a&gt;
products above 4kHz to create something where frequencies between 0-4kHz were
mirrored from 4kHz to 8kHz, and then the 0-8kHz range should be repeated
above 8kHz.  This is what we might expect.&lt;/p&gt;

&lt;p&gt;The &lt;a href=&quot;https://github.com/ZipCPU/wbpwmaudio/blob/master/demo-rtl/traditionalpwm.v&quot;&gt;traditional&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Pulse-width_modulation&quot;&gt;PWM&lt;/a&gt;
signal, however, might also be expected to have additional distortions since
the &lt;a href=&quot;https://en.wikipedia.org/wiki/Pulse-width_modulation&quot;&gt;PWM&lt;/a&gt;
interval is now within audio range.  These can be seen in Fig 5.  Of the
tests shown, the affect appears to be the most pronounced surrounding
the 440Hz tone.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 5: Test Results for a PWM Generator with an 8kHz based interval&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/pwm8k.png&quot; alt=&quot;Test Results, PWM, 8kHz interval rate&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;What’s not shown is that this result is quite unpleasant upon the ears.&lt;/p&gt;

&lt;p&gt;The corresponding 
&lt;a href=&quot;https://github.com/ZipCPU/wbpwmaudio/blob/master/rtl/wbpwmaudio.v&quot;&gt;improved&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Pulse-density_modulation&quot;&gt;PDM&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Spectrogram&quot;&gt;spectrogram&lt;/a&gt;.
is shown in Fig 6.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 6: Test Results for the improved signal generator, with an 8kHz based interval&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/pdm8k.png&quot; alt=&quot;Test Results, PDM, 8kHz interval rate&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;This &lt;a href=&quot;https://en.wikipedia.org/wiki/Spectrogram&quot;&gt;spectrogram&lt;/a&gt;
actually shows much of what you would expect: aliasing products from sampling
at a rate less than 40kHz with no
&lt;a href=&quot;https://en.wikipedia.org/wiki/Anti-aliasing_filter&quot;&gt;anti-aliasing filter&lt;/a&gt;.
(The 40kHz number comes from twice the frequency at the top of the &lt;a href=&quot;https://en.wikipedia.org/wiki/Hearing_range&quot;&gt;human
hearing range&lt;/a&gt;.)&lt;/p&gt;

&lt;p&gt;When comparing Fig 5 with Fig 6, the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Pulse-width_modulation&quot;&gt;PWM&lt;/a&gt;
output clearly has more distortion within it.  Not only does it have the same
&lt;a href=&quot;https://en.wikipedia.org/wiki/Harmonic&quot;&gt;harmonic&lt;/a&gt;
distortions it had at the 32kHz sample rate, but there are
also many other distortions associated with the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Pulse-width_modulation&quot;&gt;PWM&lt;/a&gt; waveform interval
at 8kHz.  This helps to demonstrate that the &lt;a href=&quot;https://github.com/ZipCPU/wbpwmaudio/blob/master/rtl/wbpwmaudio.v&quot;&gt;improved PWM
generator&lt;/a&gt;
solves many of the problems that &lt;a href=&quot;https://en.wikipedia.org/wiki/Pulse-width_modulation&quot;&gt;traditional
PWM&lt;/a&gt;
signals struggle with.&lt;/p&gt;

&lt;p&gt;You might be surprised in Fig 5 that the
&lt;a href=&quot;https://github.com/ZipCPU/wbpwmaudio/blob/master/demo-rtl/traditionalpwm.v&quot;&gt;traditional&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Pulse-width_modulation&quot;&gt;PWM&lt;/a&gt;
generator did not produce an 8kHz tone during the silence period.  Such an
annoying tone during silence should be expected, should it not?  The reason
that there’s no annoying tone during this silence period is simply because
the design is considered to be controlling a
&lt;a href=&quot;https://store.digilentinc.com/pmod-amp2-audio-amplifier&quot;&gt;PMod AMP2&lt;/a&gt;.
The &lt;a href=&quot;https://store.digilentinc.com/pmod-amp2-audio-amplifier&quot;&gt;AMP2&lt;/a&gt;
has both gain and shutdown controls, and so the simulator artificially turns
the output off during those regions based upon these control outputs.&lt;/p&gt;

&lt;p&gt;Our last comparison, then, will be focused on examining how these two
waveform generators handle very weak signals.  Specifically, we’ll lower
the amplitude from full scale (or actually just nearly full scale) down to
&lt;code class=&quot;highlighter-rouge&quot;&gt;1/256&lt;/code&gt;th of that amount and then repeat the 8kHz test.&lt;/p&gt;

&lt;p&gt;The &lt;a href=&quot;https://en.wikipedia.org/wiki/Pulse-width_modulation&quot;&gt;PWM&lt;/a&gt;
output can be found in Fig 7.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 7: PWM Test Results, 8kHz sampling, 1/256 of full scale&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/pwm8k-weak.png&quot; alt=&quot;Figure: test results at 1/256th the amplitude for the PWM signal&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;The &lt;a href=&quot;/dsp/2017/09/04/pwm-reinvention.html&quot;&gt;improved&lt;/a&gt;
output can be found in Fig 8.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 8: PDM Test Results, 8kHz sampling, 1/256 of full scale&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/pdm8k-weak.png&quot; alt=&quot;Figure: test results at 1/256th the amplitude for the PDM signal&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Notice the difference in the background between the two images.  There you will
notice that Fig 8 has a blue background instead of a black background.  This
is an artifact of how we have chosen to plot the signal–showing the maximum
&lt;a href=&quot;https://en.wikipedia.org/wiki/Spectrogram&quot;&gt;spectrogram&lt;/a&gt; value over the
course of the test as white, and the black being defined as 80dB below that.
In the case of Fig 7, you’ll notice that
the &lt;a href=&quot;https://en.wikipedia.org/wiki/Pulse-width_modulation&quot;&gt;PWM&lt;/a&gt;’s output is
dominated, not by the swept tone or the 440Hz tone, but rather the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Pulse-width_modulation&quot;&gt;PWM&lt;/a&gt; switching
signal at 8kHz.  This annoying signaling artifact sets the numeric value
associated with the 0dB color (white).  The
&lt;a href=&quot;/dsp/2017/09/04/pwm-reinvention.html&quot;&gt;improved signal&lt;/a&gt;
has no such annoying tone setting its maximum value, and hence 80dB below its
maximum value is into the &lt;a href=&quot;https://en.wikipedia.org/wiki/Quantization_(signal_processing)&quot;&gt;quantization
noise&lt;/a&gt;
of this system, which is showing up as a blue background.&lt;/p&gt;

&lt;p&gt;Perhaps a time slice from the 440Hz tone region would help to explain this
better.  We’ll remove the arbitrary image scaling, so as to show this time
slice shown below in Fig 9.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 9: Comparing 440Hz tone generations&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/pwm-v-pdm-weak.png&quot; alt=&quot;Figure: comparing PWM vs PDM when producing a 440Hz tone&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;In this figure, you can see the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Pulse-width_modulation&quot;&gt;PWM&lt;/a&gt;
plotted in red, and the
&lt;a href=&quot;/dsp/2017/09/04/pwm-reinvention.html&quot;&gt;improved PWM signal&lt;/a&gt;
shown in blue.&lt;/p&gt;

&lt;p&gt;The first thing to notice is that the PWM signal has a tone in the center
of it that is 40+dB higher than the signal of interest.  Likewise, the
background values of both are nearly identical, although the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Pulse-width_modulation&quot;&gt;PWM&lt;/a&gt;
implementation is showing some stronger artifacts.&lt;/p&gt;

&lt;h2 id=&quot;comparing-the-results-against-expectations&quot;&gt;Comparing the results against expectations&lt;/h2&gt;

&lt;p&gt;Now that you’ve seen the results, were they what you expected?  My answer
to that is &lt;em&gt;somewhat&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;I expected the &lt;a href=&quot;https://en.wikipedia.org/wiki/Pulse-width_modulation&quot;&gt;PWM&lt;/a&gt;
signal to have some problems, but I’ll admit I wasn’t expecting the strong
&lt;a href=&quot;https://en.wikipedia.org/wiki/Harmonic&quot;&gt;harmonic&lt;/a&gt;
distortion.  While I might be tempted to believe this is caused by my test
setup, the
&lt;a href=&quot;/dsp/2017/09/04/pwm-reinvention.html&quot;&gt;improved approach&lt;/a&gt;
didn’t have any such distortions.  Further, after
reviewing the traditional &lt;a href=&quot;https://github.com/ZipCPU/wbpwmaudio/blob/master/demo-rtl/traditionalpwm.v&quot;&gt;PWM generation
code&lt;/a&gt;
I can’t find anything that would cause this.&lt;/p&gt;

&lt;p&gt;I was expecting the
&lt;a href=&quot;https://github.com/ZipCPU/wbpwmaudio/blob/master/demo-rtl/traditionalpwm.v&quot;&gt;PWM generated&lt;/a&gt;
tone in Fig 7, though.&lt;/p&gt;

&lt;p&gt;Some of the comments I’ve received online have suggested that the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Two&#39;s_complement&quot;&gt;two’s complement&lt;/a&gt;
to &lt;a href=&quot;https://en.wikipedia.org/wiki/Offset_binary&quot;&gt;offset binary&lt;/a&gt; conversion
discussed within the &lt;a href=&quot;/dsp/2017/09/04/pwm-reinvention.html&quot;&gt;improved
PWM&lt;/a&gt;
article and used in the &lt;a href=&quot;https://github.com/ZipCPU/wbpwmaudio/blob/master/rtl/wbpwmaudio.v&quot;&gt;demonstration waveform
generator&lt;/a&gt;
was in error.  Had this been the case, the 
&lt;a href=&quot;https://en.wikipedia.org/wiki/Pulse-density_modulation&quot;&gt;PDM&lt;/a&gt;
signal above would have had some seriously annoying harmonics of the desired
tone as well–particulary for full-range sample values.  That it does not
proves that the method, and the conversions, work as stated.&lt;/p&gt;

&lt;p&gt;Does this prove that the
&lt;a href=&quot;/dsp/2017/09/04/pwm-reinvention.html&quot;&gt;improved PWM&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/wbpwmaudio/blob/master/rtl/wbpwmaudio.v&quot;&gt;generator&lt;/a&gt;
is better?  I’ll leave that to your judgment.&lt;/p&gt;

&lt;h2 id=&quot;if-you-want-to-try-this-yourself&quot;&gt;If you want to try this yourself&lt;/h2&gt;

&lt;p&gt;In case you want to try this test and compare the waveforms yourself, you’ll
need to have both &lt;a href=&quot;https://www.veripool.org/wiki/verilator&quot;&gt;Verilator&lt;/a&gt; and
&lt;a href=&quot;https://www.gnu.org/software/octave/&quot;&gt;Octave&lt;/a&gt; installed.  On a
&lt;a href=&quot;https://www.debian.org&quot;&gt;Debian&lt;/a&gt; based system, such as
&lt;a href=&quot;https://www.ubuntu.com&quot;&gt;Ubuntu&lt;/a&gt;, you can install these packages via:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;sudo apt-get install verilator octave&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Once you have these two packages, you can download and build the
&lt;a href=&quot;https://github.com/ZipCPU/wbpwmaudio/tree/master/rtl/demo-rtl&quot;&gt;demo package&lt;/a&gt;.
Start by cloning the &lt;a href=&quot;https://github.com/ZipCPU/wbpwmaudio&quot;&gt;wbpwmaudio&lt;/a&gt;
repository.  Then change into the 
&lt;a href=&quot;https://github.com/ZipCPU/wbpwmaudio&quot;&gt;demo-rtl&lt;/a&gt; directory, and
then type “make”.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;git clone https://github.com/ZipCPU/wbpwmaudio.git
&lt;span class=&quot;nb&quot;&gt;cd &lt;/span&gt;wbpwmaudio/demo-rtl
make&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;On a Windows system, you may need to follow the
&lt;a href=&quot;https://www.cygwin.com&quot;&gt;Cygwin&lt;/a&gt;
&lt;a href=&quot;/blog/2017/07/28/cygwin-fpga.html&quot;&gt;instructions found here&lt;/a&gt;.
(I don’t use these often, so please tell me if you struggle with them at all.)&lt;/p&gt;

&lt;p&gt;You can then run the test (for a given switch setting) by running &lt;a href=&quot;https://github.com/ZipCPU/wbpwmaudio/blob/master/demo-rtl/pdmdemo.cpp&quot;&gt;pdmdemo&lt;/a&gt;:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;./pdmdemo&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;To view the results that
&lt;a href=&quot;https://github.com/ZipCPU/wbpwmaudio/blob/master/demo-rtl/pdmdemo.cpp&quot;&gt;pdmdemo&lt;/a&gt;
creates, start up &lt;a href=&quot;https://www.gnu.org/software/octave/&quot;&gt;Octave&lt;/a&gt;
and run the &lt;a href=&quot;https://github.com/ZipCPU/wbpwmaudio/blob/master/demo-rtl/showspectrogram.m&quot;&gt;script provided&lt;/a&gt;
on the &lt;code class=&quot;highlighter-rouge&quot;&gt;wavfp.dbl&lt;/code&gt; file that
&lt;a href=&quot;https://github.com/ZipCPU/wbpwmaudio/blob/master/demo-rtl/pdmdemo.cpp&quot;&gt;pdmdemo&lt;/a&gt;
generates:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span class=&quot;gp&quot;&gt;&amp;gt; &lt;/span&gt;octave -q --no-gui
&lt;span class=&quot;gp&quot;&gt;% &lt;/span&gt;showspectrogram&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&#39;wavfp.dbl&#39;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;If you run this test in a separate window, while the
&lt;a href=&quot;https://github.com/ZipCPU/wbpwmaudio/blob/master/demo-rtl/pdmdemo.cpp&quot;&gt;pdmdemo&lt;/a&gt;
is still running, you should be able to see the program’s progress as it runs
through the demo.&lt;/p&gt;

&lt;p&gt;If you want to repeat the test for the
&lt;a href=&quot;https://github.com/ZipCPU/wbpwmaudio/blob/master/demo-rtl/traditionalpwm.v&quot;&gt;traditional&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Pulse-width_modulation&quot;&gt;PWM&lt;/a&gt;
generator, you’ll need
to edit the &lt;a href=&quot;https://github.com/ZipCPU/wbpwmaudio/blob/master/pdmdemo.cpp&quot;&gt;pdmdemo.cpp&lt;/a&gt; C++ file and set the &lt;code class=&quot;highlighter-rouge&quot;&gt;traditiona_pwm&lt;/code&gt; boolean value in the &lt;code class=&quot;highlighter-rouge&quot;&gt;main()&lt;/code&gt;
function to &lt;code class=&quot;highlighter-rouge&quot;&gt;true&lt;/code&gt;.  This will set the simulated hardware switch value to true.
Alternatively, you can try this design in hardware and just toggle the switch.&lt;/p&gt;

&lt;p&gt;If you would like, you are also welcome to generate a
&lt;a href=&quot;/blog/2017/07/31/vcd.html&quot;&gt;VCD file&lt;/a&gt; via the
&lt;a href=&quot;https://www.veripool.org/wiki/verilator&quot;&gt;Verilator&lt;/a&gt;
based &lt;a href=&quot;https://github.com/ZipCPU/wbpwmaudio/blob/master/demo-rtl/pdmdemo.cpp&quot;&gt;simulation&lt;/a&gt;
as well.  Should you wish to do this, you’ll want to uncomment
the &lt;code class=&quot;highlighter-rouge&quot;&gt;tb-&amp;gt;opentrace(&quot;pdmdemo.vcd&quot;);&lt;/code&gt; line within
&lt;a href=&quot;https://github.com/ZipCPU/wbpwmaudio/blob/master/pdmdemo.cpp&quot;&gt;pdmdemo.cpp&lt;/a&gt;.
Be aware if you do this, though, that the
&lt;a href=&quot;/blog/2017/07/31/vcd.html&quot;&gt;VCD file&lt;/a&gt;
can grow to many GB very quickly.  While I’ve been successful using
&lt;a href=&quot;/blog/2017/07/31/vcd.html&quot;&gt;VCD file&lt;/a&gt;,
of more than a GB, &lt;a href=&quot;https://gtkwave.sourceforge.net&quot;&gt;gtkwave&lt;/a&gt; complains when
I do so.  As a result, I’ve generally tried to avoid using
&lt;a href=&quot;/blog/2017/07/31/vcd.html&quot;&gt;VCD file&lt;/a&gt;,
greater than 10GB in in size.  A Control-C should stop the
&lt;a href=&quot;https://github.com/ZipCPU/wbpwmaudio/blob/master/pdmdemo.cpp&quot;&gt;pdmdemo&lt;/a&gt;
program prior to completion if you choose to go this road.&lt;/p&gt;

&lt;h2 id=&quot;staring-closely&quot;&gt;Staring Closely&lt;/h2&gt;

&lt;p&gt;This is actually a fun opportunity to see if there’s anything to learn by
staring really closely at the data.&lt;/p&gt;

&lt;p&gt;If you’ve never used a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Window_function&quot;&gt;window function&lt;/a&gt; before, the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Spectrogram&quot;&gt;spectrogram&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/wbpwmaudio/blob/master/demo-rtl/showspectrogram.m&quot;&gt;code&lt;/a&gt;
creates its results using a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Hann_function&quot;&gt;Hanning window&lt;/a&gt;.
This window was responsible for the rough triangle shape of our signals
as shown in Fig 9 above.&lt;/p&gt;

&lt;p&gt;Suppose we used a
&lt;a href=&quot;/dsp/freq-teaser.html&quot;&gt;better window&lt;/a&gt;
instead?&lt;/p&gt;

&lt;p&gt;Figure 10, below, shows the same chart as Fig 9 above, but this time with an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Fast_Fourier_transform&quot;&gt;FFT&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Window_function&quot;&gt;window&lt;/a&gt;
having &lt;a href=&quot;/dsp/freq-teaser.html&quot;&gt;much better spectral
resolution&lt;/a&gt; than the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Hann_function&quot;&gt;Hanning window&lt;/a&gt;.
used above.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 10: Comparing spectral resolution, 440Hz tone, 8kHz sampling, weak tone&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/pwm-v-pdm-hires.png&quot; alt=&quot;Image Showing High Resolution Spectral Estimation&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;The biggest thing to notice is the difference in the resolution of the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Pulse-width_modulation&quot;&gt;PWM&lt;/a&gt;
generation found at 8kHz.  Indeed, Fig 10 shows that the interference
has very little spectral width to it.  This is as we would expect, although
not as Fig 9 above displayed.  This is also a common problem found in many
spectral estimation tools: the tool artificially distorts the results.&lt;/p&gt;

&lt;p&gt;Let’s also look at the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Spectrogram&quot;&gt;spectrogram&lt;/a&gt;
of the &lt;a href=&quot;https://en.wikipedia.org/wiki/Pulse-width_modulation&quot;&gt;PWM&lt;/a&gt;
tone, shown in Fig 7 above, but this time using the
&lt;a href=&quot;/dsp/freq-teaser.html&quot;&gt;high resolution frequency window&lt;/a&gt;
and shown in Fig 11 below.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 11: High Resolution Spectrogram, PWM signal, 8kHz, weak amplitude&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/pwm8k-weak-hires.png&quot; alt=&quot;Image Showing High Resolution Spectral Estimation of the PWM 8kHz weak signal&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Here you might notice the difference in line thickness of the interfering
&lt;a href=&quot;https://en.wikipedia.org/wiki/Pulse-width_modulation&quot;&gt;PWM&lt;/a&gt;
tonal artifact.  In Fig 11, the artifact appears much sharper and
has better frequency resolution.  However, this difference only follows from
the individual cuts such as we showed above and its not nearly as pronounced
in this view.&lt;/p&gt;

&lt;p&gt;We could also zoom in and examine the higher power swept tone, such as was
shown in the top left corner of Fig 3 above.  This comparison is now shown
below, with &lt;a href=&quot;https://en.wikipedia.org/wiki/Hann_function&quot;&gt;Hanning window&lt;/a&gt; on
the left and the &lt;a href=&quot;/dsp/freq-teaser.html&quot;&gt;higher resolution
window&lt;/a&gt; result on the right.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 11: Comparing Spectral Resolution&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/pwm-spectro-hanning.png&quot; alt=&quot;Spectrogram using Hanning Window&quot; width=&quot;350&quot; /&gt;&lt;/td&gt;&lt;td&gt;&lt;img src=&quot;/img/pwm-spectro-sharp.png&quot; alt=&quot;A better/sharper Spectrogram&quot; width=&quot;350&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td align=&quot;center&quot;&gt;Hanning Window&lt;/td&gt;&lt;td align=&quot;center&quot;&gt;Higher Resolution Window&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Should you be interested in
&lt;a href=&quot;/dsp/freq-teaser.html&quot;&gt;high resolution frequency windowing&lt;/a&gt;,
this is one of &lt;a href=&quot;/about/gisselquist-technology.html&quot;&gt;Gisselquist
Technology&lt;/a&gt;’s
&lt;a href=&quot;/about/products.html&quot;&gt;commercial products&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;out-of-order&quot;&gt;Out of Order&lt;/h2&gt;

&lt;p&gt;Today’s test set demonstrates a lot of technology that we’ve haven’t yet had
the opportunity to work through within &lt;a href=&quot;http://zipcpu.com/&quot;&gt;this
blog&lt;/a&gt;.  I hope to come back and
do so, and only apologize for presenting concepts out of order. 
Missing background topics include:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;The test-bench for the
&lt;a href=&quot;https://github.com/ZipCPU/cordic&quot;&gt;CORDIC&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/cordic/tree/master/sw&quot;&gt;core generator&lt;/a&gt;
that we’ve built.&lt;/p&gt;

    &lt;p&gt;The trick to this test bench is that the rounding taking place within the
&lt;a href=&quot;https://github.com/ZipCPU/cordic&quot;&gt;CORDIC&lt;/a&gt; has consequences in the
output.  This creates some variability in the output, variability that is
a function of the parameters used when generating the
&lt;a href=&quot;https://github.com/ZipCPU/cordic&quot;&gt;CORDIC&lt;/a&gt;.
Predicting these consequences, to know whether or not the
&lt;a href=&quot;https://github.com/ZipCPU/cordic&quot;&gt;CORDIC&lt;/a&gt; is producing the correct output,
is taking me some work.  It’s also why I haven’t posted the
&lt;a href=&quot;https://github.com/ZipCPU/cordic&quot;&gt;CORDIC&lt;/a&gt; test bench yet.&lt;/p&gt;

    &lt;p&gt;Sadly, the result is that this
&lt;a href=&quot;https://github.com/ZipCPU/cordic&quot;&gt;CORDIC&lt;/a&gt; test bench post
(once I finish it) is likely going to delve deeper into
&lt;a href=&quot;https://en.wikipedia.org/wiki/Probability&quot;&gt;probability&lt;/a&gt; than
I would like to do on &lt;a href=&quot;http://zipcpu.com/&quot;&gt;this blog&lt;/a&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;We haven’t really discussed how to create tone generators yet, nor have
we discussed swept tone generators.&lt;/p&gt;

    &lt;p&gt;These really aren’t all that hard–especially once you have a working
&lt;a href=&quot;/dsp/2017/08/30/cordic.html&quot;&gt;CORDIC&lt;/a&gt;.
They depend upon sending an incrementing
&lt;a href=&quot;/dsp/2017/06/15/no-pi-for-you.html&quot;&gt;phase angle&lt;/a&gt;
into the &lt;a href=&quot;/dsp/2017/08/30/cordic.html&quot;&gt;CORDIC&lt;/a&gt; module,
but we can come back and discuss the topic more as we have opportunity.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;We also haven’t discussed how to implement a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sample-rate_conversion&quot;&gt;downsampling filter&lt;/a&gt;.&lt;/p&gt;

    &lt;p&gt;This was a necessary part of the 100MHz to 44.1MHz &lt;a href=&quot;https://en.wikipedia.org/wiki/Sample-rate_conversion&quot;&gt;sample rate
converter&lt;/a&gt;
within the
&lt;a href=&quot;https://github.com/ZipCPU/wbpwmaudio/blob/master/pdmdemo.cpp&quot;&gt;C++ portion&lt;/a&gt;
of today’s
&lt;a href=&quot;https://github.com/ZipCPU/wbpwmaudio/tree/master/demo-rtl&quot;&gt;demonstration&lt;/a&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;We haven’t discussed how to generate a good
&lt;a href=&quot;https://en.wikipedia.org/wiki/Low-pass_filter&quot;&gt;lowpass filter&lt;/a&gt; for a very
small bandwidth signal.&lt;/p&gt;

    &lt;p&gt;The &lt;a href=&quot;https://en.wikipedia.org/wiki/Sample-rate_conversion&quot;&gt;resampler&lt;/a&gt; within
&lt;a href=&quot;https://github.com/ZipCPU/wbpwmaudio/blob/master/pdmdemo.cpp&quot;&gt;pdmdemo&lt;/a&gt;
doesn’t really have a “good”
&lt;a href=&quot;https://en.wikipedia.org/wiki/Low-pass_filter&quot;&gt;lowpass filter&lt;/a&gt;
within it since it is far from optimized.  A better
&lt;a href=&quot;https://en.wikipedia.org/wiki/Low-pass_filter&quot;&gt;lowpass filter&lt;/a&gt;
would have fewer taps and fewer operations.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;These are all topics that we’ll need to come back and address again later on
&lt;a href=&quot;http://zipcpu.com/&quot;&gt;this blog&lt;/a&gt; as time and opportunity are
available and provided the &lt;a href=&quot;https://www.blueletterbible.org/kjv/jas/4/15/s_1150015&quot;&gt;LORD is
willing&lt;/a&gt;.&lt;/p&gt;

&lt;hr /&gt;&lt;p&gt;&lt;em&gt;Salt is good: but if the salt have lost his savour, wherewith shall it be seasoned?&lt;/em&gt;</description>
        <pubDate>Sat, 16 Sep 2017 00:00:00 -0400</pubDate>
        <link>http://zipcpu.com/dsp/2017/09/16/pwm-demo.html</link>
        <guid isPermaLink="true">http://zipcpu.com/dsp/2017/09/16/pwm-demo.html</guid>
        
        
        <category>dsp</category>
        
      </item>
    
      <item>
        <title>Building a high speed Finite Impulse Response (FIR) Digital Filter</title>
        <description>&lt;p&gt;Some time ago, an individual posted on &lt;a href=&quot;https://forum.digilentinc.com&quot;&gt;Digilent’s
forum&lt;/a&gt; that he wasn’t able to get
&lt;a href=&quot;https://www.xilinx.com&quot;&gt;Xilinx&lt;/a&gt;’s
&lt;a href=&quot;https://en.wikipedia.org/wiki/Finite_impulse_response&quot;&gt;Finite Impulse Response (FIR)&lt;/a&gt;
filter
&lt;a href=&quot;https://www.xilinx.com/support/documentation/ip_documentation/fir_compiler/v7_1/pg149-fir-compiler.pdf&quot;&gt;compiler&lt;/a&gt;
generated code to work.  While I can understand that there are good reasons
for using a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Finite_impulse_response&quot;&gt;FIR&lt;/a&gt;
&lt;a href=&quot;https://www.xilinx.com/support/documentation/ip_documentation/fir_compiler/v7_1/pg149-fir-compiler.pdf&quot;&gt;compiler&lt;/a&gt;,
this individual was attempting to
&lt;a href=&quot;https://en.wikipedia.org/wiki/Low-pass_filter&quot;&gt;low-pass filter&lt;/a&gt;
a signal with less than a handful of taps.&lt;/p&gt;

&lt;p&gt;No wonder why he was getting frustrated when he didn’t see much difference
in the filtered signal.&lt;/p&gt;

&lt;p&gt;He’s not alone.  Indeed, I was answering forum posts from a similar individual
on another forum just this morning.  It seems like requests for help with
the vendor supplied &lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;digital
filtering&lt;/a&gt;
libraries are fairly common place, while many of those asking for help
don’t necessarily understand what goes on within a typical
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;digital filter&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;If you would like to apply a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;digital filter&lt;/a&gt;
to a signal, I am going to suggest that you should first learn what a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;digital filter&lt;/a&gt;
is.  I’m also going to suggest that you learn how the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency_response&quot;&gt;frequency response&lt;/a&gt;
of a &lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;
is defined, to the point where you can calculate the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency_response&quot;&gt;frequency response&lt;/a&gt;
yourself and so know what to expect from your any
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;digital filter&lt;/a&gt;
implementation.&lt;/p&gt;

&lt;p&gt;When you think you are ready to learn how to implement a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;digital filter&lt;/a&gt;,
then let me welcome you to continue reading.&lt;/p&gt;

&lt;p&gt;Today, let’s look at what’s required to implement an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Finite_impulse_response&quot;&gt;FIR&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;digital filter&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;uses-for-digital-filters&quot;&gt;Uses for Digital Filters&lt;/h2&gt;

&lt;p&gt;Years ago I asked a math professor why I should be interested in
&lt;a href=&quot;https://en.wikipedia.org/wiki/Linear_algebra&quot;&gt;Linear Algebra&lt;/a&gt;.
He was rather flabbergasted and floored by the question.
&lt;a href=&quot;https://en.wikipedia.org/wiki/Linear_algebra&quot;&gt;Linear Algebra&lt;/a&gt;,
he tried to explain, underpinned so much of mathematics that it was
hard to define just one use.&lt;/p&gt;

&lt;p&gt;The same is true of 
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;digital filtering&lt;/a&gt;–which
just so happens to be one of those many uses of &lt;a href=&quot;https://en.wikipedia.org/wiki/Linear_algebra&quot;&gt;Linear
Algebra&lt;/a&gt; that my instructor
didn’t reference.  &lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;Digital
filters&lt;/a&gt;
are used in so many &lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_signal_processing&quot;&gt;Digital Signal Processing
(DSP)&lt;/a&gt;
applications within digital logic, such as
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;’s,
that it’s hard to identify just one application to use when arguing
for their relevance.&lt;/p&gt;

&lt;p&gt;The following, though, are some common uses of the sorts of
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;digital filters&lt;/a&gt;
you can create within an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Emphasis_(telecommunications)&quot;&gt;Audio pre/post emphasis&lt;/a&gt;, often used in commercial audio transmission channels&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Radio-receiver&quot;&gt;Channel separation and selection&lt;/a&gt;,
such as your radio receiver might do.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Echo_suppression_and_cancellation&quot;&gt;Echo cancellation&lt;/a&gt;
in telephony&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Equalization_(audio)&quot;&gt;Audio equalization&lt;/a&gt;,
such as you might find on any higher quality stereo set&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Matched_filter&quot;&gt;Matched Filtering&lt;/a&gt;
to maximize SNR, often used within digital communications&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Pulse_shaping&quot;&gt;Pulse Shaping&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/intersymbol_interference&quot;&gt;Intersymbol Interference&lt;/a&gt;
mitigation in digital communications&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Anti-aliasing_filter&quot;&gt;Anti-aliasing filters&lt;/a&gt;,
so that you can process your signals at a slower rate without distortion&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;In &lt;a href=&quot;https://en.wikipedia.org/wiki/Hearing_aid&quot;&gt;hearing aids&lt;/a&gt;, to clean
up audio signals so that they may be understood again&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Indeed, as I’m putting this list together, I feel like I’ve only started
to touch the surface on the uses of 
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;digital filters&lt;/a&gt;.  Their
usage has become quite ubiquitous, even if they are not well understood by all
who design and use them.&lt;/p&gt;

&lt;p&gt;Today, let’s build some &lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/genericfir.v&quot;&gt;generic filter
logic&lt;/a&gt; that
can be used for any or all of the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;digital filtering&lt;/a&gt; tasks listed
above.  It may not be the best implementation, nor the most practical
implementation, for such tasks, but it will at least be a valid implementation.&lt;/p&gt;

&lt;p&gt;First, though, let’s briefly discuss what a 
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;digital filtering&lt;/a&gt; is.&lt;/p&gt;

&lt;h2 id=&quot;what-is-an-fir-filter&quot;&gt;What is an FIR Filter&lt;/h2&gt;

&lt;p&gt;If you start with the only requirement that you want to apply a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Linear_map&quot;&gt;linear mathematical operation&lt;/a&gt;
to an infinite set of equidistant input samples (i.e.
a sampled data stream), and then insist that this operation be
&lt;a href=&quot;https://en.wikipedia.org/wiki/Time-invariant_system&quot;&gt;shift invariant&lt;/a&gt;,
you will discover a &lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;linear
filter&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Such
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;’s
are completely characterized by their
&lt;a href=&quot;https://en.wikipedia.org/wiki/Impulse_response&quot;&gt;impulse response&lt;/a&gt;.
That is, if you feed the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;
a single non-zero value (i.e. an impulse), then the response the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;
produces is called its
&lt;a href=&quot;https://en.wikipedia.org/wiki/Impulse_response&quot;&gt;impulse response&lt;/a&gt;.
If the response is only finite in duration, then the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;
is said to be a &lt;a href=&quot;https://en.wikipedia.org/wiki/Finite_impulse_response&quot;&gt;Finite Impulse
Response (FIR)&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;.
If the response is not finite in duration, the filter is said to be an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Infinite_impulse_response&quot;&gt;Infinite Impulse Response
(IIR)&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;If you allow the function &lt;code class=&quot;highlighter-rouge&quot;&gt;h[k]&lt;/code&gt; to represent the response of this
filter, then the mathematical operation that describes how the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;
applies to an input sequence &lt;code class=&quot;highlighter-rouge&quot;&gt;x[n]&lt;/code&gt; is a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Convolution&quot;&gt;convolution&lt;/a&gt;, and defined by the
equation:&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/convolution.png&quot; alt=&quot;x o h = SUM_k h[k] x[n-k]&quot; width=&quot;540&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;If &lt;code class=&quot;highlighter-rouge&quot;&gt;h[k]&lt;/code&gt; is zero for all &lt;code class=&quot;highlighter-rouge&quot;&gt;k&amp;lt;0&lt;/code&gt;, as well as all &lt;code class=&quot;highlighter-rouge&quot;&gt;k&amp;gt;=N&lt;/code&gt;, then &lt;code class=&quot;highlighter-rouge&quot;&gt;h[k]&lt;/code&gt; can be
used to define a &lt;em&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Causal_filter&quot;&gt;causal&lt;/a&gt;&lt;/em&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Finite_impulse_response&quot;&gt;FIR&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;digital filter&lt;/a&gt;.
The importance of this distinction is that &lt;em&gt;only&lt;/em&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Causal_filter&quot;&gt;causal&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filters&lt;/a&gt;
can be implemented in hardware.  Hence if you wish to implement an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Finite_impulse_response&quot;&gt;FIR&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;, causality is
a good first assumption.  The operation of a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Causal_filter&quot;&gt;causal&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Finite_impulse_response&quot;&gt;FIR&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;
can be simplified and represented by:&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/fir-convolution.png&quot; alt=&quot;y[n] = SUM_k=0^N-1 h[k] x[n-k]&quot; width=&quot;380&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;where &lt;code class=&quot;highlighter-rouge&quot;&gt;x[n]&lt;/code&gt; is again the input sequence, &lt;code class=&quot;highlighter-rouge&quot;&gt;h[n]&lt;/code&gt; is the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Impulse_response&quot;&gt;impulse response&lt;/a&gt;
of this &lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;digital filter&lt;/a&gt;, and
&lt;code class=&quot;highlighter-rouge&quot;&gt;y[n]&lt;/code&gt; is the output of the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;That’s the operation of a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;digital filter&lt;/a&gt;.
Any and every
&lt;a href=&quot;https://en.wikipedia.org/wiki/Causal_filter&quot;&gt;causal&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Finite_impulse_response&quot;&gt;FIR&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt; will have this form,
and will need to carry out this operation.&lt;/p&gt;

&lt;p&gt;Let’s spend some time discussing how to build this type of
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;digital FIR filter&lt;/a&gt;
within an &lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;.
The full topic of how to generate and implement one of 
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;these filters&lt;/a&gt;
is way too big to fit in one post.  So, we’ll try to break it down into
several.  However, these several posts are likely to depend upon each other
to do.  For example, we already discussed how to generate two of the simplest
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filters&lt;/a&gt;.
Today we’ll discuss how to build a very generic
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;tap-coefficient-selection&quot;&gt;Tap Coefficient Selection&lt;/h2&gt;

&lt;p&gt;Often, the first task in generating an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Finite_impulse_response&quot;&gt;FIR filter&lt;/a&gt;
is to determine the &lt;code class=&quot;highlighter-rouge&quot;&gt;h[n]&lt;/code&gt;
values referenced above.  These are known as the &lt;em&gt;coefficients&lt;/em&gt; of the filter.
They completely define and characterize any 
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;digital filter&lt;/a&gt;.
If you’ve never had to select
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt; coefficients
before, then know that there is a real science behind the process.
The most generic filter design algorithm that I like to recommend is the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Parks-McClellan_filter_design_algorithm&quot;&gt;Parks-McClellan filter design
method&lt;/a&gt;.
It tends to produce &lt;em&gt;optimal&lt;/em&gt; filters, in that the coefficients produced
minimize the maximum error between the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;’s
&lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency_response&quot;&gt;frequency response&lt;/a&gt;
and the design criteria.&lt;/p&gt;

&lt;p&gt;The &lt;a href=&quot;https://en.wikipedia.org/wiki/Parks-McClellan_filter_design_algorithm&quot;&gt;Parks-McClellan filter design
method&lt;/a&gt;
isn’t anything new.  It’s been around long enough that many implementations
of it exist.  For example, here’s an 
&lt;a href=&quot;http://t-filter.engineeringjs.com&quot;&gt;online version&lt;/a&gt;
that you can use to design your filter coefficients.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Parks-McClellan_filter_design_algorithm&quot;&gt;The Parks-McClellan filter design algorithm&lt;/a&gt;,
however, creates coefficients with no practical
&lt;a href=&quot;https://en.wikipedia.org/wiki/Quantization_(signal_processing)&quot;&gt;quantization&lt;/a&gt;
limit to their precision.  What I mean by that is that most
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
implementations don’t need the double-precision floating point values that the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Parks-McClellan_filter_design_algorithm&quot;&gt;Parks-McClellan filter design algorithm&lt;/a&gt;
can create, not that double-precision floating point numbers have unlimited
precision.  &lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
based &lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;s,
on the other hand, need to represent their filter coefficients within a
finite number of bits—usually much less than a double-precision floating
point number.  This is for cost and performance reasons.  As a result,
a conversion needs to take place from abundant precision to a finite bit
precision.&lt;/p&gt;

&lt;p&gt;As with generating the coefficients, generating or converting them to a
smaller number of bits is also quite the science.  Many papers have been
written on the topic of how to carefully select the proper quantized
coefficients for a &lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;digital
filter&lt;/a&gt;
[&lt;a href=&quot;http://ieeexplore.ieee.org/document/365314&quot;&gt;Ref&lt;/a&gt;].  However,
for our purposes today, these papers are beyond the limits of what we can
discuss here in a simple blog post.  Therefore, I am going to share an ad-hoc
technique instead for today’s discussion.  I offer no promises of optimality,
rather only the suggestion that this approach should work for many purposes.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;The first step is to know your sample rate, and the passband, &lt;code class=&quot;highlighter-rouge&quot;&gt;f_p&lt;/code&gt; and
stopband, &lt;code class=&quot;highlighter-rouge&quot;&gt;f_s&lt;/code&gt;, frequencies your application can handle.  Most problems
also define how small the response is supposed to be during the stop-band
(&lt;code class=&quot;highlighter-rouge&quot;&gt;f&amp;gt;f_s&lt;/code&gt;), as well as how tightly the passband (&lt;code class=&quot;highlighter-rouge&quot;&gt;f&amp;lt;f_p&lt;/code&gt;) filter response
must hold to unity.&lt;/p&gt;

    &lt;p&gt;Figure 1 shows a chart illustrating these regions as defined for a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Low-pass_filter&quot;&gt;lowpass filter&lt;/a&gt;.&lt;/p&gt;

    &lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 1: Lowpass filter design criteria&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/fir-lpf-design.png&quot; alt=&quot;Lowpass filter design criteria chart, showing relationship between fp and fs&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

    &lt;p&gt;Indeed, this is a good chart for understanding filter design in general.
Your goal as a designer will be to create a filter whose
&lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency_response&quot;&gt;frequency response&lt;/a&gt;
(the blue line) fits within your criteria (the white region).  Your
application will typically define this white region, although the tighter
this region is the more your filter is likely to &lt;em&gt;cost&lt;/em&gt; in terms of
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
resources.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Once you know your design criteria, the next step is to determine the number
of taps, &lt;code class=&quot;highlighter-rouge&quot;&gt;N&lt;/code&gt;, that your
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;
will require, as well as an identified number of bits, &lt;code class=&quot;highlighter-rouge&quot;&gt;M&lt;/code&gt;, to use to
represent the coefficients of these taps.  Too many taps or too many bits
and your
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;
will not fit on your
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;.
Too few, and your
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;
will not match your design criteria above.  As a result,
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;
design is often a give and take between requirements and
cost–much like any other engineering task.&lt;/p&gt;

    &lt;p&gt;You may find that the inverse of the normalized transition bandwidth,
i.e. &lt;code class=&quot;highlighter-rouge&quot;&gt;1/(f_s-f_p)&lt;/code&gt;,
is often linearly related to how many coefficients you will need.  Two
to four times this number, when using normalized frequency units,
(i.e. &lt;code class=&quot;highlighter-rouge&quot;&gt;0&amp;lt;f&amp;lt;1/2&lt;/code&gt;) is often
a good starting place for how many taps your
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;
will require.  As a result of this relationship, any time you
drop the transition width by a factor of two, you can expect to need twice
as many coefficients for the same cutoff transition bandwidth.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Design a set of filter
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;
coefficients using the &lt;a href=&quot;https://en.wikipedia.org/wiki/Parks-McClellan_filter_design_algorithm&quot;&gt;Parks-McClellan filter design
algorithm&lt;/a&gt;
or similar.  &lt;a href=&quot;http://t-filter.engineerjs.com&quot;&gt;Canned filter design
methods&lt;/a&gt; are usually not hard to find
that will generate the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;
coefficients you need.&lt;/p&gt;

    &lt;p&gt;Once designed, then examine the pass band, stop band, and transition band
performance to to see how well the resulting
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;
approximates your design criteria.  Adjust as appropriate.  More
taps for the same criteria can be used to deepen the stopband and tighten
up the pass band.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;These first steps are common to any
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;Digital&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Finite_impulse_response&quot;&gt;FIR filter&lt;/a&gt;
design problem.  The next steps, though, are required in order to try to
reduce your bit-width from double-precision floating point to something that
can be implemented on an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Multiply each tap by &lt;code class=&quot;highlighter-rouge&quot;&gt;(2^(M-1) -1) / max h[n]&lt;/code&gt; so that the maximum
tap coefficient becomes the maximum positive &lt;a href=&quot;https://en.wikipedia.org/wiki/Two&#39;s_complement&quot;&gt;two’s
complement&lt;/a&gt; number
that can be represented in your bit-width.&lt;/p&gt;

    &lt;p&gt;Since most
&lt;a href=&quot;https://en.wikipedia.org/wiki/Finite_impulse_response&quot;&gt;FIR&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filters&lt;/a&gt;
tend to follow the shape of a &lt;a href=&quot;https://en.wikipedia.org/wiki/Sinc_function&quot;&gt;sinc
function&lt;/a&gt;, the biggest
coefficient will be in the center of the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;.
That largest value becomes, by this multiplication algorithm, &lt;code class=&quot;highlighter-rouge&quot;&gt;2^(M-1)-1&lt;/code&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Round the rest of the coefficients to the nearest integer.&lt;/p&gt;

    &lt;p&gt;If we’ve done this right, no coefficients will be greater than &lt;code class=&quot;highlighter-rouge&quot;&gt;2^(M-1)-1&lt;/code&gt;
in magnitude.&lt;/p&gt;

    &lt;p&gt;This will also adjust the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;’s
&lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency_response&quot;&gt;frequency response&lt;/a&gt;.
You may wish to go back and measure your
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;’s
&lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency_response&quot;&gt;frequency response&lt;/a&gt;
at this point to ensure that it’s still within any bounds you application
requires.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;If this approach seems ad-hoc, that’s because it is.  There are more
scientific methods to do this.
[&lt;a href=&quot;http://ieeexplore.ieee.org/document/365314&quot;&gt;Ref&lt;/a&gt;]&lt;/p&gt;

&lt;p&gt;These steps should be sufficient to generate the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;
coefficients you will need.&lt;/p&gt;

&lt;h2 id=&quot;bit-growth&quot;&gt;Bit Growth&lt;/h2&gt;

&lt;p&gt;Once you have the coefficients, the next step is to allocate any bits you need
throughout the design.  We discussed
&lt;a href=&quot;/dsp/2017/07/21/bit-growth.md&quot;&gt;bit growth&lt;/a&gt;
some time ago,  so we can use those principles for this step.
For the purpose of this discussion, we’ll let &lt;code class=&quot;highlighter-rouge&quot;&gt;IW&lt;/code&gt; be the number of bits
in the input samples, &lt;code class=&quot;highlighter-rouge&quot;&gt;TW&lt;/code&gt; be the number of bits in the individual coefficients
(we called this &lt;code class=&quot;highlighter-rouge&quot;&gt;M&lt;/code&gt; above), and &lt;code class=&quot;highlighter-rouge&quot;&gt;OW&lt;/code&gt; be the output width and the width
of the accumulator.  These will then be the names we’ll use to define these
values in Verilog parameters later when we actually implement our
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;From our 
&lt;a href=&quot;/dsp/2017/07/21/bit-growth.md&quot;&gt;discussion of bit growth&lt;/a&gt;,
you know that the multiplication step of the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;,
the step that calculates &lt;code class=&quot;highlighter-rouge&quot;&gt;h[k]x[n-k]&lt;/code&gt;, will need to be allocated more bits
to represent the desired outcome than either input.  The number of bits
will be the number of bits in the input, &lt;code class=&quot;highlighter-rouge&quot;&gt;IW&lt;/code&gt;, plus the number of bits in the
coefficients, &lt;code class=&quot;highlighter-rouge&quot;&gt;TW&lt;/code&gt;.  Hence, following the multiply you will need &lt;code class=&quot;highlighter-rouge&quot;&gt;TW+IW&lt;/code&gt; bits
to hold the output product from one multiply.&lt;/p&gt;

&lt;p&gt;Also from the
&lt;a href=&quot;/dsp/2017/07/21/bit-growth.md&quot;&gt;same discussion&lt;/a&gt;,
you know that the number of bits required to add &lt;code class=&quot;highlighter-rouge&quot;&gt;N&lt;/code&gt; values of &lt;code class=&quot;highlighter-rouge&quot;&gt;TW+IW&lt;/code&gt; bits
together is going to go with the log of &lt;code class=&quot;highlighter-rouge&quot;&gt;N&lt;/code&gt;.  This means that you will
nominally need &lt;code class=&quot;highlighter-rouge&quot;&gt;TW+IW+log_2(N)&lt;/code&gt; bits to hold your result.&lt;/p&gt;

&lt;p&gt;This number, though, is often still too many.  You can often get by with less
than &lt;code class=&quot;highlighter-rouge&quot;&gt;log_2(N)&lt;/code&gt; bits for the accumulation section simply because most of the
taps will be much less than their maximum value, many of them being a factor
of two (or more) less than that maximum
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;
coefficient.&lt;/p&gt;

&lt;p&gt;One way to figure out how many additional accumulator bits you will need for
adding the multiplication
results together is to try running a sample signal through the design.  The
most stressing case is to let every input have the maximum value,
&lt;code class=&quot;highlighter-rouge&quot;&gt;2^(IW-1)-1&lt;/code&gt;, and the sign of the corresponding &lt;code class=&quot;highlighter-rouge&quot;&gt;h[k]&lt;/code&gt; tap that it will be
multiplied by.  You can then adjust the accumulation width as necessary
to be certain to avoid overflow.&lt;/p&gt;

&lt;p&gt;With this as background, we are now ready to consider building our design.
We’ll pause first, though, before we get into the Verilog code to discuss
our design goals.&lt;/p&gt;

&lt;h2 id=&quot;rtl-design-goals&quot;&gt;RTL Design Goals&lt;/h2&gt;

&lt;p&gt;For the purpose of the design presented below, we are going to build the most
general purpose high speed
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;
that we can.  By “high speed” I mean running at the speed of your system
clock—whatever that may be.  By “general purpose” I mean three things:
First, the number of taps and their values will be arbitrary.  They will be
fixed at implementation time, but easily adjusted post implementation.  Second,
I intend to make this
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;
a reconfigurable filter, so that the values of the various coefficients can
be reloaded post-synthesis as the application may require.  Third, I intend
to create and present
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/genericfir.v&quot;&gt;a design&lt;/a&gt;
that can easily (within limits) be adjusted to accommodate more taps, or to
adjust tap, data, or output widths, to the design with little change.&lt;/p&gt;

&lt;p&gt;Put together, these goals are:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Easily reconfigured&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Adjustable length and variable widths (at design time)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Adjustable coefficients (at runtime)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Runs at the system clock rate, one input sample per system clock&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The sad consequence of these choices is that this is also likely to be
one of the more expensive
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;digital filters&lt;/a&gt;
you will ever build.  However,
we shall build it anyway and later discuss methods which may be used to
reduce this cost.  Indeed, such discussions may form the basis of many
posts to come.&lt;/p&gt;

&lt;h2 id=&quot;chosen-structure&quot;&gt;Chosen Structure&lt;/h2&gt;

&lt;p&gt;If you look into a text book that describes how an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Finite_impulse_response&quot;&gt;FIR filter&lt;/a&gt;
should be implemented, you are likely to find a picture looking like Fig 2:&lt;/p&gt;

&lt;table style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 2: Filter Implementation&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/fir-form.svg&quot; alt=&quot;Generic FIR implementation structure&quot; width=&quot;380&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;From this figure, you can see conceptually how each incoming data element
goes into a “tapped delay-line” structure (the bar across the top).  On ever
clock a new sample comes in, and all the samples within this structure shift
to the right.  Also, during that clock, every sample in the delay-line is
multiplied by the respective
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;
coefficient, &lt;code class=&quot;highlighter-rouge&quot;&gt;h[k]&lt;/code&gt;, and the results
are summed together.  The result of this summation is the output of the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;,
&lt;code class=&quot;highlighter-rouge&quot;&gt;y[n]&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The number of “taps”, &lt;code class=&quot;highlighter-rouge&quot;&gt;N&lt;/code&gt;, in this figure is easily identified by the number of
stages in the tapped delay line.&lt;/p&gt;

&lt;p&gt;What Figure 2 doesn’t show is the second operand, &lt;code class=&quot;highlighter-rouge&quot;&gt;h[k]&lt;/code&gt;, to each of the
multiplies (they wouldn’t fit in the image).  These are given by the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;’s
&lt;a href=&quot;https://en.wikipedia.org/wiki/Impulse_response&quot;&gt;impulse response&lt;/a&gt;.
values–the coefficients that we discussed above.&lt;/p&gt;

&lt;p&gt;Were you to try to implement the
filter shown in the diagram, you would
quickly discover that the accumulator can easily cost many system clock ticks
to implement (depending upon the speed of your system clock).  Your design may
well fail timing as a result.  This would be unsatisfactory.&lt;/p&gt;

&lt;table style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 3: A Single FIR Tap&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/fir-tap-single.svg&quot; alt=&quot;A Single FIR tap&quot; width=&quot;240&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Therefore, we shall consider a different approach.  Let’s instead separate
the circuitry of one tap from the circuitry of the next, as shown in Fig 3.&lt;/p&gt;

&lt;p&gt;The neat thing about this approach is that we can keep the various stages
of this
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;
within a localized area on the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;.
While that makes
timing easier, it still hasn’t fundamentally solved the problem of adding
many values together within a single clock.  Indeed, the only way to
get our clock frequency back up to speed will be to add a clock tick (or more)
within this string of taps.  The simplest place to do that is between pairs
of taps in the accumulator.  This leaves us with tap logic shown in Fig 4.&lt;/p&gt;

&lt;table style=&quot;float: left&quot;&gt;&lt;caption&gt;Fig 4: Adding an extra delay per tap&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/fir-tap-w-delay.svg&quot; alt=&quot;Figure: Tap structure with an extra delay per tap&quot; width=&quot;240&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;This &lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/firtap.v&quot;&gt;tap structure&lt;/a&gt;
is actually quite unusual.  With this approach, the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;
delay line now requires not &lt;code class=&quot;highlighter-rouge&quot;&gt;N&lt;/code&gt; stages but &lt;code class=&quot;highlighter-rouge&quot;&gt;2N&lt;/code&gt;, with the multiplies only
being applied every other stage.  Further, it’s not clear from this structure
that all of the additions are being applied to the right values in the
accumulation chain.&lt;/p&gt;

&lt;p&gt;For now, I’ll present as a hand-waving evidence that this works the fact
that both tap output and accumulator output have been delayed together.
When we present the test bench for this design, you’ll see that this is
indeed the case.
Later, when we convert this filtering structure into something that can
handle a &lt;a href=&quot;https://en.wikipedia.org/wiki/Linear_phase&quot;&gt;symmetric filter&lt;/a&gt;,
we’ll have to examine how we came up with this approach and explain it in
more detail.&lt;/p&gt;

&lt;p&gt;For now, notice that by using this
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/firtap.v&quot;&gt;tap structure&lt;/a&gt;,
we can &lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/genericfir.v&quot;&gt;string several of these taps
together&lt;/a&gt;.
An overall view of this &lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/genericfir.v&quot;&gt;strung out
design&lt;/a&gt;
is shown in Fig 5 below.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 5: A filter is a sequence of taps&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/fir-generic.svg&quot; alt=&quot;Figure: Creating a generic FIR from a series of tap structures&quot; width=&quot;480&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Indeed, using this approach, we can string any arbitrary number of taps
together–subject only to the timing and logic capacity of your
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The amount of resources this
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;
will use is likely to become a thorn in our side in a moment, but we’ll
ignore that today–for the sake of building the most &lt;em&gt;generic&lt;/em&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Finite_impulse_response&quot;&gt;FIR filter&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Before leaving this section, I must acknowledge all of those experts that might
also read this blog.  Having gotten this far, I am certain that many of
these experts are &lt;em&gt;cringing&lt;/em&gt; at the design choices we have just made.
If you get a chance to chat with them, they will wisely declare that
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filtering&lt;/a&gt;
at the full speed of the system clock is resource intensive–it shouldn’t be
done &lt;em&gt;if&lt;/em&gt; it can be avoided.  They will also loudly proclaim that a
shift-register accumulator structure is a waste of resources–an accumulator
tree might make more sense.  Finally, they’ll point out that variable filter
coefficients can cost of lot of logic.  In deference to these experts, I will
first acknowledge the wisdom of their words and then beg their pardon.
Today, though, I am trying to keep the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;
implementation simple and completely generic.&lt;/p&gt;

&lt;p&gt;We can come back to [this
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/genericfir.v&quot;&gt;filter&lt;/a&gt;
later to improve upon it.  All of these improvements just mentioned, and
perhaps others as well, are fair game for that later discussion.&lt;/p&gt;

&lt;p&gt;In the meantime, let’s examine how to build these two components: the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Finite_impulse_response&quot;&gt;FIR&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/firtap.v&quot;&gt;tap structure&lt;/a&gt;
itself, as well as the &lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/genericfir.v&quot;&gt;tapped delay line
structure&lt;/a&gt;
holding these taps together.&lt;/p&gt;

&lt;h2 id=&quot;a-simple-fir-tap&quot;&gt;A simple FIR tap&lt;/h2&gt;

&lt;p&gt;The first component of our
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;
that we shall discuss is the
structure](https://github.com/ZipCPU/dspfilters/blob/master/rtl/genericfir.v)
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/firtap.v&quot;&gt;tap structure&lt;/a&gt;.
Remember that our goal is to &lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/genericfir.v&quot;&gt;string
together&lt;/a&gt;
many &lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/firtap.v&quot;&gt;taps with the same code and
structure&lt;/a&gt;
to them.  Further, you may also remember that the logic necessary for this
tap (Fig 4 above) is primarily multiplying by a filter coefficient, &lt;code class=&quot;highlighter-rouge&quot;&gt;h[k]&lt;/code&gt;,
and accumulating the result.  So, that’s what we’ll do here.&lt;/p&gt;

&lt;p&gt;We’ll start with the multiply.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	if (i_reset)
		product &amp;lt;= 0;
	else if (i_ce)
		product &amp;lt;= o_tap * i_sample;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Don’t forget to declare both &lt;code class=&quot;highlighter-rouge&quot;&gt;o_tap&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;i_sample&lt;/code&gt; as signed
values, as the results of a signed digital multiply are different from those
of an unsigned multiply.&lt;/p&gt;

&lt;p&gt;On the next clock (multiplies can be slow), we’ll add the result of the
multiply to a partial accumulator value that has been passed to us in
&lt;code class=&quot;highlighter-rouge&quot;&gt;i_partial_acc&lt;/code&gt;.  This will create our tap’s output, &lt;code class=&quot;highlighter-rouge&quot;&gt;o_acc&lt;/code&gt;.  After the last
tap, this will be the final output of the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	if (i_reset)
		o_acc &amp;lt;= 0;
	else if (i_ce)
		o_acc &amp;lt;= i_partial_acc
			+ { {(OW-(TW+IW)){product[(TW+IW-1)]}},
					product };&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;You may notice in this example that both of these always blocks used a
synchronous reset input.  This allows all of the logic to clear, together
with any memory within the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;,
on any reset.  If you don’t need the reset structure, just set the value
to a constant &lt;code class=&quot;highlighter-rouge&quot;&gt;1&#39;b0&lt;/code&gt; and the synthesizer should remove it.  The other thing
to notice is that we are using a &lt;a href=&quot;/blog/2017/08/14/strategies-for-pipelining.html&quot;&gt;global CE based pipelining
strategy&lt;/a&gt;.
Under that strategy, nothing is allowed to change unless the CE is true.  This
is why all of the subsequent logic is gated by &lt;code class=&quot;highlighter-rouge&quot;&gt;i_ce&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;It is worth mentioning that some
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;’s
architectures can combine the high speed multiply with the accumulation
step into one operation.  Feel free to design for your hardware as you see
fit.&lt;/p&gt;

&lt;p&gt;The next required step, though, is to forward the input sample data through
a series of registers.  At a first glance, this might look simply like,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
if (i_reset)
	o_sample &amp;lt;= 0;
else if (i_ce)
	o_sample &amp;lt;= i_sample;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This simple sample in to sample out structure would implement the tap
structure shown in Fig 3 above.
However, were we to keep this logic as is, the outputs from the individual
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/firtap.v&quot;&gt;filter taps&lt;/a&gt;.
wouldn’t line up with the accumulator’s output chain.  Both would
move through the process at the same speed, and so you’d end up accumulating
&lt;code class=&quot;highlighter-rouge&quot;&gt;H(0)x[n]&lt;/code&gt; instead of the desired
&lt;a href=&quot;https://en.wikipedia.org/wiki/Convolution&quot;&gt;convolution&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;So, instead, we’ll add an extra delay, &lt;code class=&quot;highlighter-rouge&quot;&gt;delayed_sample&lt;/code&gt;, between the
samples–as we discussed with Fig 4 above.
This will allow the partial accumulator structure to remain aligned with the
data as they both work their way through the
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/firtap.v&quot;&gt;tap structures&lt;/a&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
if (i_reset)
	begin
		delayed_sample &amp;lt;= 0;
		o_sample &amp;lt;= 0;
	end else if (i_ce)
	begin
		delayed_sample &amp;lt;= i_sample;
		o_sample &amp;lt;= delayed_sample;
	end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;That leaves one piece of logic remaining in our
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/firtap.v&quot;&gt;generic tap&lt;/a&gt;:
how to set the coefficients in the first place.  We’ll choose to do this in
one of two ways, dependent upon the logic parameter &lt;code class=&quot;highlighter-rouge&quot;&gt;FIXED_TAPS&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;If &lt;code class=&quot;highlighter-rouge&quot;&gt;FIXED_TAPS&lt;/code&gt; is true (not zero), then &lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/genericfir.v&quot;&gt;parent
module&lt;/a&gt;
will feed us our tap
values and we don’t need to do anything with them but use them.  While my
preference would be to set each tap via a &lt;code class=&quot;highlighter-rouge&quot;&gt;parameter&lt;/code&gt;, this causes a problem
in the &lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/genericfir.v&quot;&gt;parent
module&lt;/a&gt;
which would like to set all of the tap values at the
same time via a &lt;code class=&quot;highlighter-rouge&quot;&gt;$readmemh&lt;/code&gt;.  Instead, we allow our taps coefficients, the
&lt;code class=&quot;highlighter-rouge&quot;&gt;h[k]&lt;/code&gt; values we discussed above, to be set from wires passed to this
module.  This allows the
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/genericfir.v&quot;&gt;parent module&lt;/a&gt;
(to be discussed next) to set all of the filter coefficients
via a single &lt;code class=&quot;highlighter-rouge&quot;&gt;$readmemh&lt;/code&gt; command within an initial statement.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;generate
if (FIXED_TAPS)
	assign	o_tap = i_tap;
else ...&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This works well for fixed coefficients, but we still need the logic for
our variable coefficient capability.&lt;/p&gt;

&lt;p&gt;For variable coefficients, we’ll set &lt;code class=&quot;highlighter-rouge&quot;&gt;FIXED_TAPS&lt;/code&gt; to false (i.e. &lt;code class=&quot;highlighter-rouge&quot;&gt;1&#39;b0&lt;/code&gt;).
We’ll also create logic to set our taps dynamically.
Further, each tap will start with an &lt;code class=&quot;highlighter-rouge&quot;&gt;INITIAL_VALUE&lt;/code&gt; (typically zero).  Then,
during any design run, on any clock where the user is setting taps we’ll just
shift each tap down the line.  We’ll use the input &lt;code class=&quot;highlighter-rouge&quot;&gt;i_tap_wr&lt;/code&gt; to indicate that
we need to shift the tap value down the line.&lt;/p&gt;

&lt;p&gt;This leads us to the following code to set the taps within our design.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;...
else begin
	reg	[(TW-1):0]	tap;

	initial	tap = INITIAL_VALUE;
	always @(posedge i_clk)
		if (i_tap_wr)
			tap &amp;lt;= i_tap;
	assign o_tap = tap;
end endgenerate&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Notice that here’s no reset in this structure.  That allows us to reset
the sample values separate from the coefficients.  This also allows us to
set the coefficients while holding the rest of the filter in reset.&lt;/p&gt;

&lt;p&gt;I should warn you: this code can be expensive in terms of logic resources.
Should we count logic resources, you may notice that this requires no LUTs.
The &lt;code class=&quot;highlighter-rouge&quot;&gt;i_tap_wr&lt;/code&gt; line can be connected directly to the CE input of the for
tap, and no further logic is required.  However, this structure &lt;em&gt;will&lt;/em&gt; require
one flip flop per bit per tap in your design.  Hence a 256-tap
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;
with 16-bit values will cost you 4096 flip-flops.&lt;/p&gt;

&lt;p&gt;The other problem with this dynamic tap coefficient approach is that your
synthesis tool cannot optimize any of the multiplies.  Logic that multiplying
input samples by zero cannot be optimized.  Small number multiplies cannot be
trimmed.  Neither is it possible to reduce the logic when multiplying by a
power of two.  Hence, there is a cost for such a dynamic implementation.&lt;/p&gt;

&lt;p&gt;As a homework project, try this:  Look at how much logic gets used on a per
tap, per bit basis.  Then turn on &lt;code class=&quot;highlighter-rouge&quot;&gt;FIXED_TAPS&lt;/code&gt;, apply the same coefficients,
and see what changes.&lt;/p&gt;

&lt;h2 id=&quot;stringing-the-taps-together-into-a-filter&quot;&gt;Stringing the taps together into a filter&lt;/h2&gt;

&lt;p&gt;Now that we’ve defined our
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/firtap.v&quot;&gt;tap structures&lt;/a&gt;,
all that remains is to &lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/genericfir.v&quot;&gt;string them
together&lt;/a&gt;
as in Fig 5 above.  This will entail connecting the data inputs
from one tap to the next in a streaming fashion, as well as connecting the
tap values–should the user wish to change them.  Finally, we’ll need to
pull our final accumulator value together to return to the rest of the design.&lt;/p&gt;

&lt;p&gt;The first step, though, is going to be setting the tap coefficients for
the case where they are fixed.  We’d like to do this via a &lt;code class=&quot;highlighter-rouge&quot;&gt;$readmemh&lt;/code&gt;
command–since it’s the simplest to do.  So, if we have &lt;code class=&quot;highlighter-rouge&quot;&gt;FIXED_TAPS&lt;/code&gt;, we’ll
use a &lt;code class=&quot;highlighter-rouge&quot;&gt;$readmemh&lt;/code&gt; to set the &lt;code class=&quot;highlighter-rouge&quot;&gt;h[k]&lt;/code&gt; inputs to the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/firtap.v&quot;&gt;tap structures&lt;/a&gt;.
On the other hand, if &lt;code class=&quot;highlighter-rouge&quot;&gt;FIXED_TAPS&lt;/code&gt; is not true, we’ll only set the first tap
and then let the
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/firtap.v&quot;&gt;tap-modules&lt;/a&gt;
push the taps down the line.&lt;/p&gt;

&lt;p&gt;We’re also going to use a &lt;code class=&quot;highlighter-rouge&quot;&gt;generate&lt;/code&gt; statement, since this will allow us to
use a &lt;code class=&quot;highlighter-rouge&quot;&gt;for&lt;/code&gt; loop in a moment.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;genvar	k;
generate
if(FIXED_TAPS)
begin
	initial $readmemh(&quot;taps.hex&quot;, tap);

	assign	tap_wr = 1&#39;b0;
end else begin
	assign	tap_wr = i_tap_wr;
	assign	tap[0] = i_tap;
end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;At this point I feel like I’m teaching a drawing class.  I’ve outlined two
items, and then I’m about to tell the class to just fill in the details.
That’s about what happens next.&lt;/p&gt;

&lt;p&gt;This next step is to create a for loop where we instantiate each of the
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/firtap.v&quot;&gt;taps&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;This loop first sets the parameters of
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/firtap.v&quot;&gt;each tap structure&lt;/a&gt;
to match our overall
parameters: the input data width, &lt;code class=&quot;highlighter-rouge&quot;&gt;IW&lt;/code&gt;, the output width, &lt;code class=&quot;highlighter-rouge&quot;&gt;OW&lt;/code&gt;, the width of
the taps, &lt;code class=&quot;highlighter-rouge&quot;&gt;TW&lt;/code&gt;, etc.  Then we apply the rest of the logic.  Each
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/firtap.v&quot;&gt;tap-module&lt;/a&gt; is
given an input &lt;code class=&quot;highlighter-rouge&quot;&gt;h[k]&lt;/code&gt; coefficient and then connected to an &lt;code class=&quot;highlighter-rouge&quot;&gt;h[k+1]&lt;/code&gt; value to
be sent to the next tap.
Each &lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/firtap.v&quot;&gt;tap-module&lt;/a&gt;
is also passed a sample, and it produces the next sample
to be passed down the sample line.  Finally, we pass the partial accumulator
from one
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/firtap.v&quot;&gt;tap-module&lt;/a&gt;
to the next.&lt;/p&gt;

&lt;p&gt;You can see all three of these steps below.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;for(k=0; k&amp;lt;NTAPS; k=k+1)&amp;gt;
begin: FILTER

	firtap #(.FIXED_TAPS(FIXED_TAPS),
			.IW(IW), .OW(OW), .TW(TW),
			.INITIAL_VALUE(0))
		tapk(i_clk, i_reset,
			// Tap update circuitry
			tap_wr, tap[k], tapout[k+1],
			// Sample delay line
			i_ce, sample[k], sample[k+1],
			// The output accumulation line
			result[k], result[k+1]);

	if (!FIXED_TAPS)
		assign	tap[k+1] = tapout[k+1];
end endgenerate&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;When all is said and done, all that remains is to produce our
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;
output value and we are done.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	assign	o_result = result[NTAPS];&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;That’s all that it takes to build a
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/genericfir.v&quot;&gt;generic&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Finite_impulse_response&quot;&gt;FIR filter&lt;/a&gt;.
You don’t need a core generator to do this.  You don’t need a GUI.  You just
need to understand what an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Finite_impulse_response&quot;&gt;FIR filter&lt;/a&gt;
is, how it operates, and then just a touch of Verilog code.  In this case,
you can find the code for the &lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/firtap.v&quot;&gt;tap module
here&lt;/a&gt;, and the
code for the &lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/genericfir.v&quot;&gt;overall generic filter module
here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;We’ll save the test bench for another post, as this one is long enough
already.&lt;/p&gt;

&lt;h2 id=&quot;how-did-we-do&quot;&gt;How did we do?&lt;/h2&gt;

&lt;p&gt;While this is a &lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/genericfir.v&quot;&gt;basic
generic&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;digital filter&lt;/a&gt;,
and while the approach behind it will work for the general filtering case,
it isn’t a very powerful
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;.
The reason is not that this Verilog code
cannot describe an arbitrarily long
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;,
nor is it because this code cannot describe the taps with enough fidelity to
create a truly powerful
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;digital filter&lt;/a&gt;.
Instead, what I mean to say is that this approach to
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;
implementation tends to be too resource expensive for powerful
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filters&lt;/a&gt;: it is likely to cost
too many LUT’s, too many multiplies, and in general too much of your precious
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;’s
resources.  This may force you to buy a more expensive
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;,
or keep you from having as much free space to do other things on your current
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;.
As a result, we’ll need to do better.&lt;/p&gt;

&lt;p&gt;Indeed, we can often build better
&lt;a href=&quot;https://en.wikipedia.org/wiki/Finite_impulse_response&quot;&gt;FIR filters&lt;/a&gt;
than this.&lt;/p&gt;

&lt;p&gt;Here are some basic improvements that we can make to &lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/genericfir.v&quot;&gt;this filter
design&lt;/a&gt;:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;We could use an addition tree.&lt;/p&gt;

    &lt;p&gt;An addition tree would start by adding adjacent values together, then add
the results of those adjacent sums and so on rather than adding values
together in a long line.  This will allow us to use the log base two of
the number of additions.&lt;/p&gt;

    &lt;p&gt;Doing this would remove all the extra data stages, as well as trimming
the number of accumulator stages.  It would also increase the wire length
necessary to send the addition results from one place to the next–but this
may be negligible for low enough clock speeds.  The problem is that such
addition trees aren’t easily reconfigured for different filter lengths–not
that they aren’t valuable, useful, or less expensive.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;We could exploit the structure of the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt; coefficients.&lt;/p&gt;

    &lt;p&gt;Most filter design methods, to include the &lt;a href=&quot;https://en.wikipedia.org/wiki/Parks-McClellan_filter_design_algorithm&quot;&gt;Parks-McClellan filter design
algorithm&lt;/a&gt;,
produce &lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filters&lt;/a&gt;
with &lt;a href=&quot;https://en.wikipedia.org/wiki/Linear_phase&quot;&gt;linear phase&lt;/a&gt;.
Such &lt;a href=&quot;https://en.wikipedia.org/wiki/Linear_phase&quot;&gt;linear phase&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filters&lt;/a&gt;
have coefficients that are symmetric about some mid-point.  As a result,
these can be implemented using only half as many multiplies.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;We could also choose a filter, or combination of filters, that is easier to
implement.&lt;/p&gt;

    &lt;p&gt;For example, a block average is easier to implement than a
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/genericfir.v&quot;&gt;generic&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Finite_impulse_response&quot;&gt;FIR filter&lt;/a&gt;.
Much easier in fact.  A series of block averages, one after another,
&lt;em&gt;might&lt;/em&gt; be able to implement a filter of the type you might need or want.
It might also fit nicely as a component of a larger
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;We could fix the filter coefficients&lt;/p&gt;

    &lt;p&gt;For the &lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/genericfir.v&quot;&gt;design presented
above&lt;/a&gt;,
this is as simple as adjusting the &lt;code class=&quot;highlighter-rouge&quot;&gt;FIXED_TAPS&lt;/code&gt; parameter and
creating a hex file containing the coefficients for &lt;code class=&quot;highlighter-rouge&quot;&gt;$readmemh&lt;/code&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;We could use multirate techniques&lt;/p&gt;

    &lt;p&gt;By “multirate techniques”, I mean that we might include an &lt;a href=&quot;https://en.wikipedia.org/wiki/Sample-rate_conversion&quot;&gt;upsampler or
downsampler&lt;/a&gt; as
part of our filter design and implementation.  If we could,
for example, downsample the incoming data stream sufficiently, then it might
be possible to use a block RAM based tapped-delay line and a single shared
multiply for a tremendous resource savings.&lt;/p&gt;

    &lt;p&gt;These techniques can often form the basis of some of the cheapest
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filtering&lt;/a&gt;
approaches, especially when small bandwidths are of interest.&lt;/p&gt;

    &lt;p&gt;We’ll need to come back and examine these, though we will by no means be
able to exhaust this approach to
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filtering&lt;/a&gt;.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The one thing we haven’t done in this post is to generate a test bench for
this &lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/genericfir.v&quot;&gt;generic
filter&lt;/a&gt;.
We’ll save that task for a later post.&lt;/p&gt;

&lt;p&gt;Since writing this post, a friend has shown me an even faster, better, cheaper
method of creating a generic high-frequency filter.   Hence, while the
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/genericfir.v&quot;&gt;code presented
above&lt;/a&gt;
works, the task could be done without the input sample delay line.  We’ll
have to come back to that later, therefore, and examine this alternative
implementation.&lt;/p&gt;
&lt;hr /&gt;&lt;p&gt;&lt;em&gt;And before him shall be gathered all nations: and he shall separate them one from another, as a shepherd divideth his sheep from the goats (Matt 25:32)&lt;/em&gt;</description>
        <pubDate>Fri, 15 Sep 2017 00:00:00 -0400</pubDate>
        <link>http://zipcpu.com/dsp/2017/09/15/fastfir.html</link>
        <guid isPermaLink="true">http://zipcpu.com/dsp/2017/09/15/fastfir.html</guid>
        
        
        <category>dsp</category>
        
      </item>
    
      <item>
        <title>Even I get stuck in FPGA Hell</title>
        <description>&lt;p&gt;&lt;a href=&quot;http://zipcpu.com/&quot;&gt;This site&lt;/a&gt; is dedicated to keeping
students and other digital design developers
out of &lt;a href=&quot;/fpga-hell.html&quot;&gt;FPGA Hell&lt;/a&gt;: that state in the design
process where your design doesn’t work, and you have absolutely no clue why
not.&lt;/p&gt;

&lt;p&gt;I’d like to present myself
as immune from ever having that problem.  How else shall I be respected as a
teacher of others who can teach students how to avoid this problem?&lt;/p&gt;

&lt;p&gt;Today, though, I have a confession to make: I get stuck in
&lt;a href=&quot;/fpga-hell.html&quot;&gt;FPGA Hell&lt;/a&gt; from time to time as well.&lt;/p&gt;

&lt;p&gt;By the grace of the Almighty, I’ve recently received three reprieves, so that I
can now tell you both how I got stuck, and how I got unstuck.&lt;/p&gt;

&lt;h2 id=&quot;hdmi-video&quot;&gt;HDMI Video&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;The background&lt;/strong&gt;:
One of my ongoing projects is an HDMI Video project.  This project has two
components.  The first is the receiver.  This component is supposed to
receive an HDMI signal and stuff the pixels into memory.  The second
component is the transmitter.  This component is supposed to read an image
frame from memory, and transmit it to my monitor.  The ultimate goal of this
project is to be able to process the HDMI signals associated with
3D head-sets, such as the &lt;a href=&quot;https://www.oculus.com/rift/&quot;&gt;Oculus Rift&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;I’m doing my development on a
&lt;a href=&quot;https://store.digilentinc.com&quot;&gt;Digilent&lt;/a&gt;
&lt;a href=&quot;https://store.digilentinc.com/nexys-video-artix-7-fpga-trainer-board-for-multimedia-applications/&quot;&gt;Nexys-Video board&lt;/a&gt;.  This board has not only the required
HDMI input and output ports, but also enough memory to tackle the data
transfer.  (We can talk later about memory bandwidth, which for this
application will require some creative solutions.)&lt;/p&gt;

&lt;p&gt;I had the project working some time ago to the point where I could lock on to
the received HDMI signal and calculate it’s pixel clock rate, frame rate,
and even the number of lines per frame, pixels per line, horizontal sync
length, vertical sync length, front porches, back porches, etc.  In other
words, from the incoming data, I can calculate all of the required video
parameters to set an associated &lt;a href=&quot;https://en.wikipedia.org/wiki/XFree86_Modeline&quot;&gt;mode
line&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;I can also read and process the EDID information using the
&lt;a href=&quot;https://github.com/ZipCPU/wbi2c&quot;&gt;wbi2c&lt;/a&gt; project.&lt;/p&gt;

&lt;p&gt;Then I tore the project apart so that I could incorporate the
512MB &lt;a href=&quot;https://en.wikipedia.org/wiki/DDR3_SDRAM&quot;&gt;DDR3 SDRAM&lt;/a&gt;
memory into the design.&lt;/p&gt;

&lt;table style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 1: Broken HDMI&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/hdmi-bug.svg&quot; alt=&quot;HDMI input bug&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;&lt;strong&gt;The symptoms&lt;/strong&gt;: Since finishing the restructuring changes necessary to get
the &lt;a href=&quot;https://en.wikipedia.org/wiki/DDR3_SDRAM&quot;&gt;DDR3 SDRAM&lt;/a&gt; memory to work,
I hadn’t been able to get the incoming video to
lock at all, and I’ve been struggling to figure out what was wrong.
Fig 1 shows my test setup.  I was using my &lt;a href=&quot;https://github.com/ZipCPU/wbscope&quot;&gt;wishbone
scope&lt;/a&gt; to capture frames of video
data.  I could then use these with a home-made HDMI simulator to
&lt;a href=&quot;/blob/2017/06/21/looking-at-verilator.html&quot;&gt;simulate my
code&lt;/a&gt;.
The resulting code just didn’t contain the synchronization pattern that I
knew was there.  The data was somehow wrong, but I just couldn’t figure
out what logical transformation would correct it.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;The problem&lt;/strong&gt;: Just this week, I figured out what was going on.&lt;/p&gt;

&lt;table style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 2: Broken HDMI bug found&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/hdmi-bug-found.svg&quot; alt=&quot;HDMI input bug found&quot; width=&quot;380&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Since adding the &lt;a href=&quot;https://en.wikipedia.org/wiki/DDR3_SDRAM&quot;&gt;SDRAM&lt;/a&gt;,
I had changed my system clock from the incoming
100MHz clock rate, to the 100MHz clock used by the Xilinx MIG generated
&lt;a href=&quot;https://en.wikipedia.org/wiki/DDR3_SDRAM&quot;&gt;SDRAM&lt;/a&gt;
controller.  (I’d still like to use my own
&lt;a href=&quot;https://en.wikipedia.org/wiki/DDR3_SDRAM&quot;&gt;DDR3 SDRAM&lt;/a&gt; controller,
but &lt;a href=&quot;http://opencores.org/project,wbddr3&quot;&gt;that project&lt;/a&gt; is currently on
hold.)  This controller clock is subtly different from the 100MHz input clock,
even though the two are at the same frequency: it takes some time for the PLL
to settle, and there’s a phase difference due to the distribution network.
(These are only the differences I know of.)&lt;/p&gt;

&lt;p&gt;You can see what the broken configuration looked like in Fig 2.&lt;/p&gt;

&lt;p&gt;These differences were apparently enough that a reset line I was setting with
logic on the 100MHz clock, was failing to reset the ISERDESE2 component on the
148.5MHz HDMI pixel clock.&lt;/p&gt;

&lt;table style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 3: Broken HDMI bug fixed&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/hdmi-bug-fixed.svg&quot; alt=&quot;HDMI input bug fixed&quot; width=&quot;380&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;&lt;strong&gt;How did I find the problem?&lt;/strong&gt;  The worst way to find a problem like this is
by desk-checking your code.  It is, however, how I ended up finding it.  I
knew, from pixel captures, that the problem had to be in the ISERDESE2
component.  I had traced it there via my
&lt;a href=&quot;https://github.com/ZipCPU/wbscope&quot;&gt;wishbone scope&lt;/a&gt;.  Then, thanks to the
Almighty, in one sudden piece of inspiration I realized the problem.&lt;/p&gt;

&lt;p&gt;The code in question now includes an asynchronous reset, with a synchronous
release, such as is shown in Fig 3.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;wire		async_reset;
reg	[2:0]	reset_pipe;
always @(posedge i_clk, negedge i_ce)
	// The !i_ce signal is our reset indication
	if (!i_ce)
		reset_pipe[2:0] &amp;lt;= 3&#39;h7;
	else
		reset_pipe[2:0] &amp;lt;= { reset_pipe[1:0], 1&#39;b0 };
assign	async_reset = reset_pipe[2];&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;I also added a separate piece of logic to “synchronize” the CE signal to
the HDMI pixel clock:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;wire		lcl_ce;
reg	[1:0]	syncd_ce;
always @(posedge i_clk)
	syncd_ce &amp;lt;= { syncd_ce[0], i_ce };
assign	lcl_ce = syncd_ce[1];&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;These two changes fixed the problem.&lt;/p&gt;

&lt;p&gt;This, by the way, is one of those reasons why
&lt;a href=&quot;https://en.wikipedia.org/wiki/Metastability_in_electronics&quot;&gt;metastability&lt;/a&gt;
can be so problematic.  The symptoms of
&lt;a href=&quot;https://en.wikipedia.org/wiki/Metastability_in_electronics&quot;&gt;metastability&lt;/a&gt;
tend not to make any sense.  They draw you away from looking for
clock domain transfer problems, convincing you that your logic is somehow
strangely at fault.  In the end, I’ve only ever found
&lt;a href=&quot;https://en.wikipedia.org/wiki/Metastability_in_electronics&quot;&gt;metastability&lt;/a&gt;
and other clock-domain crossing related problems by desk-checking my code.
(If you know of another way, please feel free to share …)&lt;/p&gt;

&lt;h2 id=&quot;ico-board-parallel-port&quot;&gt;ICO Board Parallel Port&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;The background&lt;/strong&gt;:
The second problem I was struggling with was on my
&lt;a href=&quot;http://www.icoboard.org&quot;&gt;ICO Board&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/icozip&quot;&gt;project&lt;/a&gt;.  The
&lt;a href=&quot;http://www.icoboard.org&quot;&gt;ICO Board&lt;/a&gt; is designed to demonstrate the utility of
a full open-source tool-chain for
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
development.  It is based upon an
ICE40
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
with &lt;a href=&quot;http://www.mouser.com/ds/2/225/iCE40FamilyHandbook-311139.pdf&quot;&gt;8k logic
gates&lt;/a&gt;.
My goal with this project was to create a series of beginner demonstration
designs that others could reference.  Indeed, the board was given to me by
the project team as a gift for that purpose.&lt;/p&gt;

&lt;p&gt;My problem was that I’ve been struggling to get a
&lt;a href=&quot;/blog/2017/06/16/dbg-bus-forest.html&quot;&gt;debugging bus&lt;/a&gt;
running over the parallel port between the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
and the
&lt;a href=&quot;https://www.raspberrypi.org/products/raspberry-pi-2-model-b/&quot;&gt;Raspberry Pi&lt;/a&gt;
for some time.&lt;/p&gt;

&lt;p&gt;You can see how far I had gotten in Fig 4 below.&lt;/p&gt;

&lt;table style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 4: Broken IcoZip Project&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/ico-bug.svg&quot; alt=&quot;ICO parallel port&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;&lt;strong&gt;The symptoms&lt;/strong&gt;: The bus worked fine in simulation, but somehow struggled any
time I tried to actually place it on the board.  I placed an extra
&lt;a href=&quot;https://store.digilentinc.com/pmod-8ld-eight-high-brightness-leds&quot;&gt;8-LED’s&lt;/a&gt;
onto the board, but still couldn’t figure out what was going wrong.
In particular, I couldn’t tell if it was that the
&lt;a href=&quot;https://www.raspberrypi.org/products/raspberry-pi-2-model-b/&quot;&gt;Raspberry Pi&lt;/a&gt;
was talking too fast, or whether something was wrong within the
&lt;a href=&quot;http://www.icoboard.org&quot;&gt;ICO Board&lt;/a&gt;.  At one time I was afraid I was creating
a short across the parallel port interface, and so somehow the
&lt;a href=&quot;http://www.icoboard.org&quot;&gt;ICO Board&lt;/a&gt; was losing power in the middle of a
transaction.&lt;/p&gt;

&lt;p&gt;I even went so far as to connect a &lt;a href=&quot;https://store.digilentinc.com/pmod-usbuart-usb-to-uart-interface/&quot;&gt;PMod
USBUART&lt;/a&gt;
to the board, so that I could use &lt;em&gt;a known working
&lt;a href=&quot;https://github.com/ZipCPU/dbgbus/tree/master/hexbus&quot;&gt;debug-bus&lt;/a&gt;&lt;/em&gt;,
based upon my &lt;em&gt;proven &lt;a href=&quot;https://github.com/ZipCPU/wbuart32&quot;&gt;UART&lt;/a&gt;&lt;/em&gt; code,
to find the fault, and … even my proven code didn’t work right.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;How did I find the problem?&lt;/strong&gt;  In this case, a heart-felt thank you goes
out to both the Almighty, and to the
&lt;a href=&quot;https://store.digilentinc.com&quot;&gt;Digilent&lt;/a&gt;
sales team, who were looking for some feedback on their &lt;a href=&quot;https://store.digilentinc.com/digital-discovery-portable-logic-analyzer-and-digital-pattern-generator/&quot;&gt;Digital
Discovery&lt;/a&gt;
device, shown in Fig 5.&lt;/p&gt;
&lt;table style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 5: A Digital Discovery logic analyzer&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/digital-discovery-top-130.png&quot; alt=&quot;Digilent&#39;s Digital Discovery&quot; width=&quot;280&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;Out of the blue, they asked if I’d like to review the
device for them, and send them back my thoughts.  Of course I’d be interested,
I said.&lt;/p&gt;

&lt;p&gt;If you aren’t familiar with the
&lt;a href=&quot;https://store.digilentinc.com/digital-discovery-portable-logic-analyzer-and-digital-pattern-generator/&quot;&gt;Digital Discovery&lt;/a&gt;
it’s an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
based external
logic analyzer.
&lt;a href=&quot;https://store.digilentinc.com&quot;&gt;Digilent&lt;/a&gt; sells the device for $200 USD.
It boasts the ability to capture and analyze data signals at up to 800MHz.
However, my &lt;a href=&quot;https://github.com/ZipCPU/icozip&quot;&gt;ICO board design&lt;/a&gt; was only
running at &lt;a href=&quot;https://github.com/ZipCPU/icozip/blob/master/auto-data/clock.txt&quot;&gt;40MHz–a slow clock
rate&lt;/a&gt; since I
couldn’t tell what was wrong with the design, and I wasn’t certain
how well I could trust my
&lt;a href=&quot;http://www.clifford.at/icestorm&quot;&gt;timing analyzer&lt;/a&gt;.  (In the end, the timing
analyzer wasn’t the problem, and I could’ve trusted the
&lt;a href=&quot;http://www.clifford.at/icestorm&quot;&gt;icestorm tools&lt;/a&gt; just fine.)&lt;/p&gt;

&lt;p&gt;To use this device, I connected one of the PMod ports of the
&lt;a href=&quot;http://www.icoboard.org&quot;&gt;ICO Board&lt;/a&gt; to the
&lt;a href=&quot;https://store.digilentinc.com/digital-discovery-portable-logic-analyzer-and-digital-pattern-generator/&quot;&gt;Digital Discovery&lt;/a&gt;,
and started making and examining captures.&lt;/p&gt;

&lt;p&gt;One particular capture showed one of my logic signals holding a value for
less than 10ns.  This didn’t make any sense, since the clock period was
&lt;em&gt;supposed&lt;/em&gt; to be 25ns.  Further, it didn’t make sense as a spurious value that
hadn’t yet settled yet, since the design then continued as though this
value had been high for a full clock cycle.  (To the extent that I could
tell anything about what this erratic design was doing …)  That left me
wondering what the actual clock rate was, so I decided to dump the system
clock to one of the output pins and examine it.&lt;/p&gt;

&lt;p&gt;You can see the final test setup in Fig 5 below.  It was enough to see
the problem.&lt;/p&gt;

&lt;table style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 5: IcoZip Problem found&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/ico-bug-found.svg&quot; alt=&quot;IcoZip problem found&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;&lt;strong&gt;The Problem&lt;/strong&gt;:
As with the HDMI problem, this problem also turned out to
be clock related.  In this case, I had given the wrong parameters to the
&lt;a href=&quot;http://www.mouser.com/ds/2/225/iCE40FamilyHandbook-311139.pdf&quot;&gt;iCE40&lt;/a&gt;’s
&lt;a href=&quot;http://www.latticesemi.com/view_document?document_id=47778&quot;&gt;PLL&lt;/a&gt;
primitive.  Sure, I read through
&lt;a href=&quot;http://www.latticesemi.com/view_document?document_id=47778&quot;&gt;the manual&lt;/a&gt;,
but
&lt;a href=&quot;http://www.latticesemi.com/view_document?document_id=47778&quot;&gt;the manual&lt;/a&gt;
didn’t explain all of the configuration parameters very well.  As a result, I
hadn’t set all of the PLL parameters correctly.  The &lt;a href=&quot;http://www.latticesemi.com/view_document?document_id=47778&quot;&gt;iCE40
documentation&lt;/a&gt;,
recommends using their
proprietary wizard.  However, since I never managed to get their proprietary
software installed, I was using the &lt;a href=&quot;https://en.wikipedia.org/wiki/ISC_license&quot;&gt;open
source&lt;/a&gt;
&lt;a href=&quot;https://www.clifford.at/yosys&quot;&gt;yosys toolchain&lt;/a&gt; instead and
instantiating the primitive directly.&lt;/p&gt;

&lt;p&gt;The result was that the
&lt;a href=&quot;http://www.mouser.com/ds/2/225/iCE40FamilyHandbook-311139.pdf&quot;&gt;iCE40&lt;/a&gt;’s
&lt;a href=&quot;http://www.latticesemi.com/view_document?document_id=47778&quot;&gt;PLL&lt;/a&gt;
primitive (SB_PLL) wasn’t locking, and so my system clock was unstable.&lt;/p&gt;

&lt;p&gt;Eventually, I found the
&lt;a href=&quot;https://github.com/cliffordwolf/icestorm/tree/master/icepll&quot;&gt;icepll&lt;/a&gt;
open-source program which told me what the
&lt;a href=&quot;http://www.latticesemi.com/view_document?document_id=47778&quot;&gt;PLL&lt;/a&gt;
parameters needed to be set to in order to get a stable clock.&lt;/p&gt;

&lt;p&gt;Now that I have my
&lt;a href=&quot;https://github.com/ZipCPU/dbgbus/tree/master/hexbus&quot;&gt;debugging bus&lt;/a&gt;
up and running within my &lt;a href=&quot;http://www.icoboard.org&quot;&gt;ICO Board&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/icozip&quot;&gt;project&lt;/a&gt; over the
&lt;a href=&quot;https://github.com/ZipCPU/icozip/tree/master/pport&quot;&gt;parallel port&lt;/a&gt;,
I can now start to add (and debug) other capabilities.  This will include
the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
implementation for the board, the SRAM, as well as (hopefully) the flash on
the board.  My goal is to get the point where I can play
&lt;a href=&quot;https://github.com/ZipCPU/tttt&quot;&gt;4x4x4 tic-tac-toe&lt;/a&gt;
on the board, using only the
&lt;a href=&quot;https://sourceware.org/newlib/&quot;&gt;standard C-library&lt;/a&gt;.
Others, I imagine, will be more interested in the extensibility offered by an
&lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt;
based platform making it easy to add and remove functionality from the design.&lt;/p&gt;

&lt;h2 id=&quot;arbitrary-clock-rate-generator&quot;&gt;Arbitrary clock rate generator&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;The background&lt;/strong&gt;:
The third design that I got stuck on is an arbitrary clock rate generator.
This is an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
only design, requiring no external clock, save only the 100MHz clock already
provided to the board.  It is also one of those designs that demonstrates
something few people think possible–the ability to create a suitable
clock signal from logic alone.&lt;/p&gt;

&lt;p&gt;Indeed, I wasn’t certain if it was possible myself.&lt;/p&gt;

&lt;p&gt;For those interested, the design is based upon the &lt;a href=&quot;/blog/2017/06/02/generating-timing.html&quot;&gt;logic presented
here&lt;/a&gt;.
Using that logic, together with the input 100MHz clock, I can request a clock
frequency within 0.2Hz or so of any desired clock frequency, and then create
a clock that accurately matches that frequency.  Further, if I use the &lt;a href=&quot;https://store.digilentinc.com/pmod-gps-gps-receiver&quot;&gt;PMod
GPS&lt;/a&gt;,
I should be able to generate a clock frequency with absolutely stability at
any known frequency.  (“Should be able to” means I haven’t tried to yet.)&lt;/p&gt;

&lt;p&gt;As with the HDMI project above, the hardware I was using was the
&lt;a href=&quot;https://store.digilentinc.com&quot;&gt;Digilent&lt;/a&gt;
&lt;a href=&quot;https://store.digilentinc.com/nexys-video-artix-7-fpga-trainer-board-for-multimedia-applications/&quot;&gt;Nexys-Video board&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;My goal with this project was to be able to create an output pixel clock,
to be sent via the HDMI output port, of an arbitrary frequency so that it
could support any reasonable display timing.&lt;/p&gt;

&lt;table style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 6: Broken arbitrary clock generator&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/genclk-bug.svg&quot; alt=&quot;Broken arbitrary clock generator&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;&lt;strong&gt;Symptoms&lt;/strong&gt;: Normally, I wouldn’t think twice if this design didn’t work.
It requires that I can get my hardware to work in a way that it wasn’t designed
to work in, and so I was never certain it could work in the first place.
However, the first time I fired up the design it appeared to work.  Then, after
making several changes (without git backups), I lost that appearance of
working and …  I struggled to understand why.&lt;/p&gt;

&lt;p&gt;Indeed, the clock would appear to lock onto frequencies such as 50MHz, 75MHz,
100MHz, 125MHz, and so forth, but never lock onto the frequency I was
requesting, such as 131.415928MHz.&lt;/p&gt;

&lt;p&gt;I was stuck.  I desk-checked and desk-checked my code.  I read through
the Xilinx clocking guide.  I found and fixed several “problems”, but never
fixed &lt;em&gt;the&lt;/em&gt; problem.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Definition: &lt;strong&gt;Voodoo computing&lt;/strong&gt;.
A noun describing the process of fixing what isn’t broken in an attempt to
find and fix what is.  It is usually characterized by a complete lack of
understanding as to what is causing the problem, and so the “fixes” applied
tend to be quite irrelevant to the actual problem at hand.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;How did I find the problem&lt;/strong&gt;:  In this case, I turned again to the
&lt;a href=&quot;https://store.digilentinc.com/digital-discovery-portable-logic-analyzer-and-digital-pattern-generator/&quot;&gt;Digital Discovery&lt;/a&gt;.
As with the &lt;a href=&quot;https://github.com/ZipCPU/icozip&quot;&gt;icozip&lt;/a&gt; project, I routed my
generated clock signal to a PMod port.&lt;/p&gt;

&lt;p&gt;Much to my surprise, my code wasn’t generating the clock that I thought it
was generating.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;The problem&lt;/strong&gt;:  This sent me back to my clock generation code, where I was
able to find the problem.  In this case, my problem was associated
with the Xilinx OSERDESE2 primitive.  The primitive was mis-configured.
(I had set the &lt;code class=&quot;highlighter-rouge&quot;&gt;DATA_RATE_TQ&lt;/code&gt; parameter to “DDR” instead of “SDR”, for a
functionality &lt;em&gt;I wasn’t using&lt;/em&gt;.)  Once fixed, the whole design started working.&lt;/p&gt;

&lt;p&gt;As a result, I can now create arbitrary clock frequencies within my
&lt;a href=&quot;https://store.digilentinc.com/nexys-video-artix-7-fpga-trainer-board-for-multimedia-applications/&quot;&gt;Nexys-Video board&lt;/a&gt;, without requiring any additional
hardware.&lt;/p&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;In each of these examples, the easiest part of the design to get right was the
logic.  The hardest part, the part which had sent me to
&lt;a href=&quot;/fpga-hell.html&quot;&gt;FPGA Hell&lt;/a&gt; in the first place,
was dealing with those parts and components of my design which I could not
simulate.  Further, in two out of three of these examples, an external logic
analyzer,
&lt;a href=&quot;https://store.digilentinc.com&quot;&gt;Digilent&lt;/a&gt;’s
&lt;a href=&quot;https://store.digilentinc.com/digital-discovery-portable-logic-analyzer-and-digital-pattern-generator/&quot;&gt;Digital Discovery&lt;/a&gt;,
rescued me.&lt;/p&gt;

&lt;p&gt;My point, though, is simply this: even those who have been designing digital
logic for years can still get stuck.  If you work with an old hand, ask for
some of their stories over lunch time.  You might find that lunch can actually
be entertaining—without discussing either religion or politics.&lt;/p&gt;

&lt;p&gt;Perhaps next time I’ll know to check the PLL-locked output signal, though,
rather than assuming that any PLL will always lock.&lt;/p&gt;

&lt;p&gt;The code for all three projects is available for those sufficiently
interested.  The
&lt;a href=&quot;http://www.icoboard.org&quot;&gt;ICO Board&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/icozip&quot;&gt;project&lt;/a&gt;, together with its
&lt;a href=&quot;https://github.com/ZipCPU/icozip/tree/master/hexbus&quot;&gt;debugging bus&lt;/a&gt;
and support infrastructure, can be found on
&lt;a href=&quot;https://github.com/ZipCPU/icozip&quot;&gt;Github&lt;/a&gt;.
The clock generation core is available upon request for any of my
Patreon sponsors who supports me for $10 USD or more, and will probably be
eventually included within the HDMI video project.  It’s not well documented
(yet), but with sufficient interest in it that can be changed.  (It’s only
about 300 lines of code or so …)&lt;/p&gt;

&lt;p&gt;The HDMI video project, though, needs sponsors in order to bring it to
completion.  It still needs more development work
before it will be released on &lt;a href=&quot;https://github.com/ZipCPU&quot;&gt;Github&lt;/a&gt;, and that
work isn’t (yet) paid for.  If you are interested in this project, please
consider &lt;a href=&quot;https://www.patreon.com/ZipCPU&quot;&gt;supporting me on Patreon&lt;/a&gt;, and then
sending me a note to let me know that it is a project you are interested in.&lt;/p&gt;

&lt;hr /&gt;&lt;p&gt;&lt;em&gt;Wherefore let him that thinketh he standeth take heed lest he fall.  (1Cor 10:12)&lt;/em&gt;</description>
        <pubDate>Thu, 14 Sep 2017 00:00:00 -0400</pubDate>
        <link>http://zipcpu.com/blog/2017/09/14/even-i-get-stuck.html</link>
        <guid isPermaLink="true">http://zipcpu.com/blog/2017/09/14/even-i-get-stuck.html</guid>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>Glad I went to ORCONF</title>
        <description>&lt;p&gt;Just a quick post today to thank the individuals who made
&lt;a href=&quot;https://orconf.org&quot;&gt;ORCONF&lt;/a&gt; this year
such a great success!  The staff did a wonderful job setting up the conference,
and I learned a &lt;em&gt;lot&lt;/em&gt; from all those present with whom I had a chance to talk.&lt;/p&gt;

&lt;p&gt;When it came my turn, I presented both an &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/doc/orconf2017.pdf&quot;&gt;update on the
ZipCPU&lt;/a&gt;, as
well as &lt;a href=&quot;https://github.com/ZipCPU/autofpga/blob/master/doc/orconf17.pdf&quot;&gt;telling everyone about
AutoFPGA&lt;/a&gt;.
I’ve also posted the final slides for both projects on line, in case you
weren’t able to go and would like to see what I presented.  The &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/doc/orconf2017.pdf&quot;&gt;ZipCPU update
slides can be found
here&lt;/a&gt;,
whereas the &lt;a href=&quot;https://github.com/ZipCPU/autofpga/blob/master/doc/orconf17.pdf&quot;&gt;AutoFPGA slides can be found
here&lt;/a&gt;.
(For some reason, the first several slides in either presentation aren’t
displaying properly within my browser, so you may need to download
the file(s) to view all of the slides.)
I’m expecting the videos of the presentations to be posted on
&lt;a href=&quot;https://youtube.com&quot;&gt;youtube&lt;/a&gt;,
so we’ll watch for them.  (You can find a video of last year’s
presentation on the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;
&lt;a href=&quot;https://youtube.com/watch?v=uVSRTgy-Ui0&quot;&gt;here&lt;/a&gt;,
together with the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/orconf.pdf&quot;&gt;slides for it here&lt;/a&gt;–although those slides are now out of date.)&lt;/p&gt;

&lt;p&gt;For those who may be interested in trying
out &lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt;, I’m probably going to take
some time out from these general FPGA based posts to present several 
&lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt; examples and basic tutorials.
The first such tutorial will likely be a rewrite of our original
&lt;a href=&quot;https://github.com/ZipCPU/dbgbus&quot;&gt;debugging bus&lt;/a&gt; project, but this time
using &lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt;.  From there, we can
demo the &lt;a href=&quot;https://github.com/ZipCPU/debouncer&quot;&gt;button debouncing project&lt;/a&gt;
again, showing how easy it is to reconfigure the original project in order
to add &lt;a href=&quot;https://github.com/ZipCPU/debouncer/blob/master/rtl/debouncer.v&quot;&gt;a button
debouncer&lt;/a&gt;
and a &lt;a href=&quot;https://github.com/ZipCPU/wbscope&quot;&gt;scope&lt;/a&gt; into the project using
&lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt;.  If all goes well, we’ll
then use &lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt; to build any further
demonstrations from there.&lt;/p&gt;

&lt;p&gt;For those who have never been to &lt;a href=&quot;https://orconf.org&quot;&gt;ORCONF&lt;/a&gt;, please allow
me to tell you a bit about the conference.  First, the conference tends to be
very informal.  (I may have been the only one there wearing a suit.)
The conference also tends to be small.  You will not be lost
in a sea of thousands of individuals, but may instead get a chance to meet
every individual who attends.  Reconnecting with the friends I had made
&lt;a href=&quot;https://orconf.org/2017/&quot;&gt;last year&lt;/a&gt; was an encouragement for me.  Discovering
the history of what others had done before me was also a treat.&lt;/p&gt;

&lt;p&gt;Between now and next-time, though, I’ll probably muse on what direction I
should take to move the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;
forward.  I could …&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Dig into the code and make it truly the smallest 32-bit machine out there.
At 1,350–2,500 LUT’s, the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;
isn’t the smallest design out there, despite that being it’s ostensible
purpose.  At 600 LUT’s it would be a lot closer.  Such a CPU would also
be a lot faster as well.  Many thanks to Jan for sharing with me how to
get the logic count down that low.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Finish integrating the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/zipmmu.v&quot;&gt;Memory Management
Unit&lt;/a&gt;
and the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/dcache.v&quot;&gt;data
cache&lt;/a&gt;.
This would bring the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt; that much closer to running
&lt;a href=&quot;https://www.kernel.org&quot;&gt;Linux&lt;/a&gt;, even though
it will probably slow down the CPU’s memory interactions somewhat.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;em&gt;Formally&lt;/em&gt; verify that the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;
code faithfully executes its instruction set.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Continue to work on building peripherals that can be used with the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;. I’m still working on building
up an &lt;a href=&quot;https://en.wikipedia.org/wiki/HDMI&quot;&gt;HDMI&lt;/a&gt; capability, although
building a &lt;a href=&quot;https://en.wikipedia.org/wiki/Brushless_DC_electric_motor&quot;&gt;brushless DC
motor&lt;/a&gt; controller
might be fun to do as well.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Here on &lt;a href=&quot;http://zipcpu.com&quot;&gt;this blog&lt;/a&gt; we’re probably going to continue
pressing towards building some &lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;digital
filter&lt;/a&gt;s and testing them.  This
includes building a proper test bench for the &lt;a href=&quot;/2017/08/30/cordic.html&quot;&gt;CORDIC cores we’ve
built&lt;/a&gt;.
I’ve also been asked by one individual to release a test bench showing the
improvements possible via the
&lt;a href=&quot;/2017/09/04/pwm-reinvention.md&quot;&gt;PWM scheme&lt;/a&gt; presented
the other day.  If anyone else is interested, I may move forward on that as
well.&lt;/p&gt;

&lt;p&gt;For me, in the end,
&lt;a href=&quot;https://orconf.org&quot;&gt;ORCONF&lt;/a&gt;
was a success because of all that I learned there.  For that I thank not
only those who helped to organize the conference, but also all of those who
attended and took the time with me to teach me about open source hardware
from their individual perspectives.&lt;/p&gt;

&lt;p&gt;Thank you.&lt;/p&gt;
&lt;hr /&gt;&lt;p&gt;&lt;em&gt;Iron sharpeneth iron; so a man sharpeneth the countenance of his friend. (Prov 27:17)&lt;/em&gt;</description>
        <pubDate>Tue, 12 Sep 2017 00:00:00 -0400</pubDate>
        <link>http://zipcpu.com/blog/2017/09/12/orconf-2017-return-home.html</link>
        <guid isPermaLink="true">http://zipcpu.com/blog/2017/09/12/orconf-2017-return-home.html</guid>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>Off to ORCONF-2017!</title>
        <description>&lt;p&gt;After a year of waiting, it’s time for &lt;a href=&quot;https://orconf.org&quot;&gt;ORCONF&lt;/a&gt;.
If you are not familiar with &lt;a href=&quot;https://orconf.org&quot;&gt;ORCONF&lt;/a&gt;,
then allow me to encourage you to examine &lt;a href=&quot;https://orconf.org&quot;&gt;their web-page&lt;/a&gt;,
and look over the &lt;a href=&quot;https://orconf.org/#presentations&quot;&gt;abstracts of the
presentations&lt;/a&gt; that will be given this year.
Looks like it will be quite the lineup.&lt;/p&gt;

&lt;p&gt;This year, I’ll be giving two presentations.&lt;/p&gt;

&lt;p&gt;My first presentation will be a quick
update on the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;.
Since &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/doc/orconf.pdf&quot;&gt;last year&lt;/a&gt;,
the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; has been updated so as to
support …&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;8-bit byte-level access across the 32-bit bus.&lt;/p&gt;

    &lt;p&gt;Prior to this redesign, the 
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
was one of a few rare 32-bit byte machines.&lt;/p&gt;

    &lt;p&gt;Now, the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; fully supports
8-bit bytes instead of the 32-bit bytes it supported before.&lt;/p&gt;

    &lt;p&gt;This required a bit of instruction set redesign.  Opcodes were re-ordered.
Rotate left &lt;code class=&quot;highlighter-rouge&quot;&gt;ROL&lt;/code&gt; and population count &lt;code class=&quot;highlighter-rouge&quot;&gt;POPC&lt;/code&gt; instructions have been removed.
The load and store instructions have been renamed load word &lt;code class=&quot;highlighter-rouge&quot;&gt;LW&lt;/code&gt; and store
word &lt;code class=&quot;highlighter-rouge&quot;&gt;SW&lt;/code&gt; instructions.  Four basic instructions have been added as well:
load half-word &lt;code class=&quot;highlighter-rouge&quot;&gt;LH&lt;/code&gt;, store halfword &lt;code class=&quot;highlighter-rouge&quot;&gt;SH&lt;/code&gt;, load byte &lt;code class=&quot;highlighter-rouge&quot;&gt;LB&lt;/code&gt; and store byte &lt;code class=&quot;highlighter-rouge&quot;&gt;SB&lt;/code&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;A compressed instruction set (CIS).&lt;/p&gt;

    &lt;p&gt;The &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; has always had a CIS,
although it was previously mis-named as a &lt;a href=&quot;https://en.wikipedia.org/wiki/Very_long_instruction_word&quot;&gt;Very Long Instruction Word
(VLIW)&lt;/a&gt;
set of instructions–which it never really was.  The CIS instruction set
allows you to integrate pairs of 16-bit instructions together with the
32-bit instructions.  It provides some increased code density as a result.&lt;/p&gt;

    &lt;p&gt;Over the last year, I’ve had the opportunity to test the CIS instructions on
the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; and work out the bugs
within them.  The &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/tree/master/sw&quot;&gt;current
toolchain&lt;/a&gt; builds with CIS
instructions enabled by default.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Nearly the same number of LUTs&lt;/p&gt;

    &lt;p&gt;Despite all of these changes, the number of LUTs used by the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; remains roughly the same.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;As a result of these changes, the &lt;a href=&quot;https://sourceware.org/newlib&quot;&gt;newlib&lt;/a&gt;
C-library now runs on the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;–something it didn’t do before.
That means you can now play &lt;a href=&quot;https://github.com/ZipCPU/tttt&quot;&gt;4x4x4 Tic-Tac-Toe&lt;/a&gt;
on the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;!&lt;/p&gt;

&lt;p&gt;My &lt;a href=&quot;https://github.com/ZipCPU/autofpga/blob/master/doc/orconf17.pdf&quot;&gt;second
presentation&lt;/a&gt;
will be an overview of &lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt;.
Here’s the abstract:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Placing a &lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;
into a new environment can be a daunting task.  Components
need to be selected, resources allocated, addresses given, interrupts
assigned, and peripherals configured–not only in the HDL code, but also for
all of the software support.  The problem with this approach to designing
hardware is that it works very well for one-off solutions, but not as well
for quickly creating generic solutions to new problems.  This is where
&lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt; comes in.&lt;/p&gt;

  &lt;p&gt;Given a &lt;a href=&quot;https://github.com/zipCPU/autofpga/tree/master/auto-data&quot;&gt;set of
components&lt;/a&gt;,
&lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt;
builds the &lt;a href=&quot;https://github.com/ZipCPU/autofpga/tree/master/demo-out/&quot;&gt;boiler plate
files&lt;/a&gt;, the &lt;a href=&quot;https://github.com/ZipCPU/autofpga/blob/master/demo-out/toplevel.v&quot;&gt;top
level&lt;/a&gt;
and &lt;a href=&quot;https://github.com/ZipCPU/autofpga/blob/master/demo-out/main.v&quot;&gt;main&lt;/a&gt;
design files, the &lt;a href=&quot;/doc/wbspec_b4.pdf&quot;&gt;Wishbone&lt;/a&gt;
interconnect, and the &lt;a href=&quot;https://github.com/ZipCPU/autofpga/blob/master/demo-out/board.h&quot;&gt;software header
file&lt;/a&gt;s
necessary for software support within that design.  As a result, I can
reconfigure a project with new hardware in a matter of minutes, rather
than the days it took before.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;When I get back, I’ll post about my experiences and thoughts.  When the
presentation video’s are posted on youtube, I intend to post those links
here as well.&lt;/p&gt;
&lt;hr /&gt;&lt;p&gt;&lt;em&gt;For the kingdom ofheaven is as a man travelling into a far country, who called his own servants, and delivered unto them his goods.  (Matt 25:14)&lt;/em&gt;</description>
        <pubDate>Wed, 06 Sep 2017 00:00:00 -0400</pubDate>
        <link>http://zipcpu.com/blog/2017/09/06/orconf-2017.html</link>
        <guid isPermaLink="true">http://zipcpu.com/blog/2017/09/06/orconf-2017.html</guid>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>Reinventing PWM</title>
        <description>&lt;p&gt;A common &lt;a href=&quot;http://www.fpga4fun.com/PWM_DAC.html&quot;&gt;beginners FPGA&lt;/a&gt; task is to
build a &lt;a href=&quot;https://en.wikipedia.org/wiki/Pulse-width_modulation&quot;&gt;Pulse Width
Modulated (PWM)&lt;/a&gt;
signal.  Such signals, when fed into an &lt;a href=&quot;store.digilentinc.com/pmod-amp2-audio-amplifier/&quot;&gt;appropriately modified
amplifier&lt;/a&gt;, can
be used to create an audio signal that can then be heard.&lt;/p&gt;

&lt;p&gt;Indeed, you might think of this as a poor man’s digital to analog converter,
since the circuitry required to turn a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Pulse-width_modulation&quot;&gt;PWM&lt;/a&gt; signal into
an audio signal is quite minimal.  Likewise,
&lt;a href=&quot;https://en.wikipedia.org/wiki/Pulse-width_modulation&quot;&gt;PWM&lt;/a&gt;
&lt;a href=&quot;https://store.digilentinc.com/pmod-amp2-audio-amplifier/&quot;&gt;audio hardware&lt;/a&gt;
($10 USD) can be cheaper than the corresponding
&lt;a href=&quot;https://en.wikipedia.org/wiki/I2S&quot;&gt;I2S&lt;/a&gt;
&lt;a href=&quot;https://store.digilentinc.com/pmod-i2s-stereo-audio-output/&quot;&gt;based Digital to Analog Converter&lt;/a&gt; ($15 USD).&lt;/p&gt;

&lt;p&gt;Today, let’s add some additional functionality and performance to this
&lt;a href=&quot;http://www.fpga4fun.com/PWM_DAC.html&quot;&gt;traditional beginner’s project&lt;/a&gt;.
Even better, let’s make this a simple &lt;em&gt;no cost&lt;/em&gt; improvement to the
traditional audio output–one that solves several common problems commonly
associated with the traditional
&lt;a href=&quot;https://en.wikipedia.org/wiki/Pulse-width_modulation&quot;&gt;PWM&lt;/a&gt;
development.
Our result will have the quality of a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Pulse-density_modulation&quot;&gt;PDM&lt;/a&gt;
signal, but without the painful cost of generating one.&lt;/p&gt;

&lt;h2 id=&quot;the-traditional-development&quot;&gt;The traditional development&lt;/h2&gt;

&lt;p&gt;Let’s start by outlining the basics of a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Pulse-width_modulation&quot;&gt;PWM&lt;/a&gt;
signal.  A &lt;a href=&quot;https://en.wikipedia.org/wiki/Pulse-width_modulation&quot;&gt;PWM&lt;/a&gt;
signal is simply a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_signal&quot;&gt;digital signal&lt;/a&gt;
that gets used in an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Analog_signal&quot;&gt;analog&lt;/a&gt;
context.  You can think of the
&lt;a href=&quot;https://store.digilentinc.com/pmod-amp2-audio-amplifier&quot;&gt;PModAMP2&lt;/a&gt;
as a good hardware example for this discussion, although the discussion
is much more general than just the
&lt;a href=&quot;https://store.digilentinc.com/pmod-amp2-audio-amplifier&quot;&gt;PModAMP2&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The definition of a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Pulse-width_modulation&quot;&gt;PWM&lt;/a&gt;
signal revolves around an time interval, &lt;code class=&quot;highlighter-rouge&quot;&gt;T&lt;/code&gt;.  During that
interval, the output signal starts as a logic one.  After some period of
time, determined by the desired but approximate output voltage, the signal
transitions to zero. 
A minimum output voltage is created by transitioning immediately to zero.
A maximum output voltage is created by waiting to the end of the interval
before transitioning to a logic zero.&lt;/p&gt;

&lt;p&gt;Pictorially, this might look like Fig 1.&lt;/p&gt;

&lt;table style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 1: A PWM waveform sample&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/pwm-example-defn.png&quot; alt=&quot;Setting up a CORDIC&quot; width=&quot;868&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;In this figure, the 
&lt;a href=&quot;https://en.wikipedia.org/wiki/Pulse-width_modulation&quot;&gt;PWM&lt;/a&gt;
signal is shown in red.  The current time this waveform is positive is given
by &lt;code class=&quot;highlighter-rouge&quot;&gt;tau&lt;/code&gt;.  The information within the waveform is captured by moving the
transition time back and forth with respect to the center of the period.&lt;/p&gt;

&lt;p&gt;With a signal description that simple, generating a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Pulse-width_modulation&quot;&gt;PWM modulator&lt;/a&gt;
is as simple as any good beginner’s assignment should be.&lt;/p&gt;

&lt;p&gt;First, you will need a counter.  This will count from the beginning to the end
of the interval, and then start over.  If we use the &lt;a href=&quot;/blog/2017/08/14/strategies-for-pipelining.html&quot;&gt;handshake pipeline
signaling&lt;/a&gt;
strategy, then we’ll need an &lt;code class=&quot;highlighter-rouge&quot;&gt;o_busy&lt;/code&gt; (a.k.a. stall) signal to slow down any
logic that is feeding our pipeline.  Hence, if we allow for a constant length
interval of &lt;code class=&quot;highlighter-rouge&quot;&gt;COUNTS_PER_INTERVAL&lt;/code&gt; clock ticks, the first part of our code
will look like:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	if (counter &amp;gt;= COUNTS_PER_INTERVAL-1)
	begin
		counter &amp;lt;= 0;
		sample &amp;lt;= i_sample;
	end else
		counter &amp;lt;= counter + 1&#39;b1;

always @(posedge i_clk)
	o_busy &amp;lt;= (counter == COUNTS_PER_INTERVAL-2);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Note that we need to compare the counter against &lt;code class=&quot;highlighter-rouge&quot;&gt;COUNTS_PER_INTERVAL-1&lt;/code&gt;
to make certain that we have an interval &lt;code class=&quot;highlighter-rouge&quot;&gt;COUNTS_PER_INTERVAL&lt;/code&gt; long.  Likewise,
we want the &lt;code class=&quot;highlighter-rouge&quot;&gt;o_busy&lt;/code&gt; signal to be true for the one clock when
&lt;code class=&quot;highlighter-rouge&quot;&gt;counts == COUNTS_PER_INTERVAL-1&lt;/code&gt;, and to do that we need to set it one
clock earlier.&lt;/p&gt;

&lt;p&gt;The last step, that of determining whether or not our pin should be on or off,
is determined by the simplest comparison:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	o_pin &amp;lt;= (counter &amp;lt; sample);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;That’s how you build an audio
&lt;a href=&quot;https://en.wikipedia.org/wiki/Pulse-width_modulation&quot;&gt;PWM&lt;/a&gt;
peripheral.&lt;/p&gt;

&lt;p&gt;The problem wih this approach is that audio sounds horrible.&lt;/p&gt;

&lt;h2 id=&quot;problems-with-the-traditional-development&quot;&gt;Problems with the traditional development&lt;/h2&gt;

&lt;p&gt;Let’s spend a moment and discuss all of the problems associated with generating
a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Pulse-width_modulation&quot;&gt;PWM&lt;/a&gt;
signal in this fashion.  This will help guide our solution later.&lt;/p&gt;

&lt;p&gt;The first problem with this algorithm is that the samples need to range
between one and &lt;code class=&quot;highlighter-rouge&quot;&gt;COUNTS_PER_INTERVAL-1&lt;/code&gt;.  Commonly, samples are represented as
&lt;a href=&quot;https://en.wikipedia.org/wiki/Twos_complement&quot;&gt;two’s complement&lt;/a&gt;
integers ranging from between &lt;code class=&quot;highlighter-rouge&quot;&gt;-2^(N-1)&lt;/code&gt; to &lt;code class=&quot;highlighter-rouge&quot;&gt;2^(N-1)-1&lt;/code&gt;.
Converting from
&lt;a href=&quot;https://en.wikipedia.org/wiki/Twos_complement&quot;&gt;two’s complement&lt;/a&gt;
to the samples this algorithm would require is going to require
multiplying by &lt;code class=&quot;highlighter-rouge&quot;&gt;(COUNTS_PER_INTERVAL-2)/2^N&lt;/code&gt; and then flipping the sign bit.
While the divide by &lt;code class=&quot;highlighter-rouge&quot;&gt;2^N&lt;/code&gt; can be accomplished just dropping the lower
&lt;code class=&quot;highlighter-rouge&quot;&gt;N&lt;/code&gt; bits, this still requires a multiply by
&lt;code class=&quot;highlighter-rouge&quot;&gt;COUNTS_PER_INTERVAL-2&lt;/code&gt;.
It would be nice to have an alternative that doesn’t require any multiplies.&lt;/p&gt;

&lt;p&gt;The second problem with the standard
&lt;a href=&quot;https://en.wikipedia.org/wiki/Pulse-width_modulation&quot;&gt;PWM&lt;/a&gt;
development is that the only way to send a zero is to send a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Square_wave&quot;&gt;square wave&lt;/a&gt;
with a 50% duty cycle (tau is in the center of the interval).  Such a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Square_wave&quot;&gt;square wave&lt;/a&gt;
is a tone which can be heard when the audio is supposed to be silent, should
the &lt;code class=&quot;highlighter-rouge&quot;&gt;COUNTS_PER_INTERVAL&lt;/code&gt; be large enough.  Indeed, this “silent” tone can be
very obnoxious on the ears.&lt;/p&gt;

&lt;p&gt;The third problem with the development above is that the sample rate
&lt;em&gt;must&lt;/em&gt; be an integer divisor of the system sample rate.  This limits the
sample rates that can be created.&lt;/p&gt;

&lt;p&gt;Coupled with the sample rate is the difficulty of getting a high
&lt;a href=&quot;https://en.wikipedia.org/wiki/Dynamic_range&quot;&gt;dynamic range&lt;/a&gt;.
More output voltage resolution requires a slower sample rate.
However, a slower sample rate brings the nasty audio
&lt;a href=&quot;https://en.wikipedia.org/wiki/Harmonic&quot;&gt;harmonics&lt;/a&gt;
into the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Hearing_range&quot;&gt;audio range&lt;/a&gt;.
For this reason, it can appear impossible to get good sound quality
from a &lt;a href=&quot;https://en.wikipedia.org/wiki/Pulse-width_modulation&quot;&gt;PWM&lt;/a&gt;
output.  Perhaps this was the idea, but we’ll do better in a moment.&lt;/p&gt;

&lt;p&gt;The final problem with this means of creating an audio signal is that
it creates lots of unwanted
&lt;a href=&quot;https://en.wikipedia.org/wiki/Harmonic&quot;&gt;harmonics&lt;/a&gt;,
i.e. distortions, in the audio that you
wish to produce.  We’ll see these when we introduce our improvements in a
moment.  Our goal should be to reduce these distortions.&lt;/p&gt;

&lt;p&gt;Hang on, that’s coming up.&lt;/p&gt;

&lt;h2 id=&quot;how-a-pwm-fits-into-a-digital-audio-system&quot;&gt;How a PWM fits into a digital audio system&lt;/h2&gt;

&lt;table style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 2: Audio Hearing Range&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/pwm-hearing-range.svg&quot; alt=&quot;A PWM sinewave&quot; width=&quot;380&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;Before we can make an improvement, you need to understand that the &lt;a href=&quot;https://en.wikipedia.org/wiki/Hearing_range&quot;&gt;ear can
&lt;em&gt;only&lt;/em&gt; hear sounds between about 20Hz and
20kHz&lt;/a&gt;.  To be successful, the
period of the &lt;a href=&quot;https://en.wikipedia.org/wiki/Pulse-width_modulation&quot;&gt;PWM&lt;/a&gt;
signal will then need to be well above 20kHz—out of the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Hearing_range&quot;&gt;range of hearing&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Hence, a good
&lt;a href=&quot;https://store.digilentinc.com/pmod-amp2-audio-amplifier&quot;&gt;audio circuit&lt;/a&gt;
(audiophile’s please forgive me for calling this “good”), following
a &lt;a href=&quot;https://en.wikipedia.org/wiki/Pulse-width_modulation&quot;&gt;PWM&lt;/a&gt;
output, will place a filter on the output to remove anything above 20kHz.&lt;/p&gt;

&lt;p&gt;This means that if we can push any distortions towards higher frequency
components, then these distortions will get filtered out by the amplifier
circuitry (or your ear), and the result will sound more pleasing to the ear.&lt;/p&gt;

&lt;p&gt;Can this be done?&lt;/p&gt;

&lt;h2 id=&quot;a-better-pwm&quot;&gt;A better PWM&lt;/h2&gt;

&lt;p&gt;Ok, you’ve waited enough, here’s the technique: &lt;em&gt;Bit-reverse the counter&lt;/em&gt; before
comparing it with the sample.
Further, we’ll insist that our
&lt;a href=&quot;https://en.wikipedia.org/wiki/Pulse-width_modulation&quot;&gt;PWM&lt;/a&gt;
counter have a power of two length so that
the bit reversed counter will take on the same values that the counter would’ve
taken on in the first place.  The result is a waveform that is like
&lt;a href=&quot;https://en.wikipedia.org/wiki/Pulse-width_modulation&quot;&gt;PWM&lt;/a&gt;,
although technically not a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Pulse-width_modulation&quot;&gt;PWM&lt;/a&gt; signal.
It is more generally a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Pulse-density_modulation&quot;&gt;PDM&lt;/a&gt; signal,
but unlike the implementation of
&lt;a href=&quot;https://en.wikipedia.org/wiki/Pulse-density_modulation&quot;&gt;PDM&lt;/a&gt;
presented on &lt;a href=&quot;https://en.wikipedia.org/wiki/Pulse-density_modulation&quot;&gt;Wikipedia&lt;/a&gt;
this implementation is very easy to calculate.  Like both
&lt;a href=&quot;https://en.wikipedia.org/wiki/Pulse-width_modulation&quot;&gt;PWM&lt;/a&gt; and
&lt;a href=&quot;https://en.wikipedia.org/wiki/Pulse-density_modulation&quot;&gt;PDM&lt;/a&gt;
the result will nominally maintain the same number of output clock periods
that a &lt;a href=&quot;https://en.wikipedia.org/wiki/Pulse-width_modulation&quot;&gt;PWM&lt;/a&gt;
output would have been on.  Likewise, it will also be off for the same number
of clock periods that a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Pulse-width_modulation&quot;&gt;PWM&lt;/a&gt;
output would have been off.  (Assuming &lt;code class=&quot;highlighter-rouge&quot;&gt;2^N&lt;/code&gt; clocks per interva.)  It will
produce the same number of one’s, and
the same number of zero’s.  The only difference is that bit-reversing the
counter will cause these one’s and zero’s to be produced in a different order.&lt;/p&gt;

&lt;p&gt;I’m going to call this new signal type simply &lt;em&gt;bit-reversed
&lt;a href=&quot;https://en.wikipedia.org/wiki/Pulse-width_modulation&quot;&gt;PWM&lt;/a&gt;&lt;/em&gt;,
even though technically it’s not really a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Pulse-width_modulation&quot;&gt;PWM&lt;/a&gt; signal at all
any more.&lt;/p&gt;

&lt;p&gt;To understand what’s going on, let’s consider what the traditional
&lt;a href=&quot;https://en.wikipedia.org/wiki/Pulse-width_modulation&quot;&gt;PWM&lt;/a&gt;
output would be for a sine-wave (shown in Fig 3 below).&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 3: A PWM sinewave&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/pwm-sinewave.png&quot; alt=&quot;A PWM sinewave&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Now, let’s take a look at that same sine wave output, but this time we’ll
bit reverse the counter before creating our output signal.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 4: An improved PWM sinewave&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/pwm-sine-improved.png&quot; alt=&quot;An improved PWM sinewave&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;From this figure, you can see that there are &lt;em&gt;many&lt;/em&gt; more transitions in the
bit-reversed
&lt;a href=&quot;https://en.wikipedia.org/wiki/Pulse-width_modulation&quot;&gt;PWM&lt;/a&gt;
signal.  Another way of saying this is that the
bit-reversed
&lt;a href=&quot;https://en.wikipedia.org/wiki/Pulse-width_modulation&quot;&gt;PWM&lt;/a&gt;
signal has a lot more high frequency content.  This extra high frequency
content should be easier to filter out with cheap analog circuitry, and hence
the remaining audio quality should be better.&lt;/p&gt;

&lt;p&gt;Enough of the hand-waving, is this new approach actually better?  To answer
that question, let’s look at a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Fourier_transform&quot;&gt;Fourier transform&lt;/a&gt;
of the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Pulse-width_modulation&quot;&gt;PWM&lt;/a&gt;
encoded sine wave in Fig 3, and let’s compare it to the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Fourier_transform&quot;&gt;Fourier transform&lt;/a&gt;
of the bit-reversed
&lt;a href=&quot;https://en.wikipedia.org/wiki/Pulse-width_modulation&quot;&gt;PWM&lt;/a&gt; sinewave from
Fig 4.  We’ll place this frequency comparison into Fig 5 below.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 5: Comparing PWM frequency responses&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/pwm-harmonics.png&quot; alt=&quot;Comparing PWM frequency responses&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;In this Figure, the vertical bars are frequency components, running from just
above zero frequency at the left to higher frequencies at the right.  Their
height is given by the magnitude squared of the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Fourier_transform&quot;&gt;Fourier transform&lt;/a&gt;
output values.  These are not &lt;a href=&quot;https://en.wikipedia.orgg/wiki/Decibel&quot;&gt;decibel&lt;/a&gt;
 values.
The tone we want to create is represented by the tall
vertical bar near the y-axis line.  The
&lt;a href=&quot;https://en.wikipedia.org/wiki/Fourier_transform&quot;&gt;Fourier transform&lt;/a&gt;
of the original 
&lt;a href=&quot;https://en.wikipedia.org/wiki/Pulse-width_modulation&quot;&gt;PWM&lt;/a&gt;
scheme is represented in red, whereas the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Fourier_transform&quot;&gt;Fourier transform&lt;/a&gt;
of our modified bit-reversed
&lt;a href=&quot;https://en.wikipedia.org/wiki/Pulse-width_modulation&quot;&gt;PWM&lt;/a&gt;
sinewave is represented in green.&lt;/p&gt;

&lt;p&gt;Now that you understand the graph, notice the additional red bars to the
right of the bar associated with our audio signal (the sinewave).  These are
distortions.  Your
ear will hear these distortions, and the result won’t sound like the pleasant
tone you wanted.&lt;/p&gt;

&lt;p&gt;If you look further, you won’t see any green distortions to
speak of.  It’s not that they aren’t there, it’s just that they’ve been spread
out and spread across a much higher frequency range.  Those distortions in
green that do remain within the audio range are much smaller in magnitude.&lt;/p&gt;

&lt;p&gt;The next step, now that we know how to improve this
&lt;a href=&quot;https://en.wikipedia.org/wiki/Pulse-width_modulation&quot;&gt;PWM&lt;/a&gt;
development, is to build our improved signal and hear what it sounds like.&lt;/p&gt;

&lt;h2 id=&quot;building-the-updated-pwms-logic&quot;&gt;Building the updated PWM’s logic&lt;/h2&gt;

&lt;p&gt;Let’s now work through how to code this bit-reversed
&lt;a href=&quot;https://en.wikipedia.org/wiki/Pulse-width_modulation&quot;&gt;PWM&lt;/a&gt;
signal, and make an
&lt;a href=&quot;https://github.com/ZipCPU/wbpwmaudio&quot;&gt;audio controller&lt;/a&gt;
using the scheme.&lt;/p&gt;

&lt;p&gt;The first step to creating a more pleasing sounding
&lt;a href=&quot;https://en.wikipedia.org/wiki/Pulse-width_modulation&quot;&gt;PWM&lt;/a&gt;
audio waveform is to bit–reverse the counter.  If we let our counter be a
simple 16-bit number, we can reverse it with a for loop within a Verilog
generate statement.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;// The bit-reversed (br) counter
wire	[15:0]	br_counter;
genvar	k;
generate for(k=0; k&amp;lt;16; k=k+1)
begin : bit_reversal_loop
	assign br_counter[k] = pwm_counter[15-k];
end endgenerate&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The beginning
&lt;a href=&quot;https://en.wikipedia.org/wiki/Hardware_description_language&quot;&gt;HDL&lt;/a&gt;.
student should remember that for loops in Verilog &lt;em&gt;are not
like for loops in software&lt;/em&gt;.  This loop does nothing but rename the wires
within the original &lt;code class=&quot;highlighter-rouge&quot;&gt;pwm_counter&lt;/code&gt;.  It requires no
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;
instructions, nor
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Logic_block&quot;&gt;logic elements&lt;/a&gt;,
to be accomplished.  As a result,
there’s no time consumed by the logic this loop creates.&lt;/p&gt;

&lt;p&gt;This loop is actually the whole key to the algorithm, and the source of the
difference we are going to create.  If you’ve built
a &lt;a href=&quot;https://en.wikipedia.org/wiki/Pulse-width_modulation&quot;&gt;PWM&lt;/a&gt; based audio signal
before, you now understand how to build a better one.  We’ll keep going,
though, just for completeness.&lt;/p&gt;

&lt;p&gt;We can then create our output from comparing this bit-reversed counter to the
sample we would desire to output.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;// Create the PWM output
always @(posedge i_clk)
	o_pin &amp;lt;= (sample_out &amp;lt;= br_counter);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;You can find the code to create this type of waveform in my &lt;a href=&quot;https://github.com/ZipCPU/wbpwmaudio/blob/master/rtl/wbpwmaudio.v&quot;&gt;wbpwmaudio
repository&lt;/a&gt;
on &lt;a href=&quot;https://github.com/ZipCPU&quot;&gt;GitHub&lt;/a&gt;.  However, if you look over &lt;a href=&quot;https://github.com/ZipCPU/wbpwmaudio/blob/master/rtl/wbpwmaudio.v&quot;&gt;the
code&lt;/a&gt;
alone, you might find there’s a bit more to it than the code written above.&lt;/p&gt;

&lt;p&gt;The first thing missing is the timer to tell the
bit reversed
&lt;a href=&quot;https://en.wikipedia.org/wiki/Pulse-width_modulation&quot;&gt;PWM&lt;/a&gt;
audio driver when to switch samples.  Unlike our original development,
the &lt;a href=&quot;https://github.com/ZipCPU/wbpwmaudio/blob/master/rtl/wbpwmaudio.v&quot;&gt;wbpwmaudio
core&lt;/a&gt;
uses a user-configurable count-down timer.  This configurable value is placed
into &lt;code class=&quot;highlighter-rouge&quot;&gt;w_reload_value&lt;/code&gt;, allowing us to write our count-down timer as,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;initial	timer = DEFAULT_RELOAD;
initial	ztimer= 1&#39;b0;

// ztimer is true for one clock pulse any time the timer restarts.
always @(posedge i_clk)
	ztimer &amp;lt;= (timer == { {(TIMING_BITS-1){1&#39;b0}}, 1&#39;b1 });
always @(posedge i_clk)
	if (ztimer)
		timer &amp;lt;= w_reload_value;
	else
		timer &amp;lt;= timer - ,1&#39;b1};&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;You might find this code very similar to the count-down timer logic found
in our &lt;a href=&quot;/blog/2017/06/02/generating-timing.html&quot;&gt;timing
post&lt;/a&gt;.
The big thing you may find different is the parameterized number of bits in
the counter.  In this case, the number of bits in the timer counter is
defined by the parameter,&lt;code class=&quot;highlighter-rouge&quot;&gt;TIMING_BITS&lt;/code&gt;.  Why?  Because I needed to be able
to trim the logic within the
&lt;a href=&quot;https://github.com/ZipCPU/s6soc&quot;&gt;S6SoC&lt;/a&gt; project down until the project
&lt;a href=&quot;/blog/2017/06/12/minimizing-luts.html&quot;&gt;could fit&lt;/a&gt;
onto
&lt;a href=&quot;https://store.digilentinc.com&quot;&gt;Digilent&lt;/a&gt;’s &lt;a href=&quot;https://store.digilentinc.com/cmod-s6-breadboardable-spartan-6-fpga-module&quot;&gt;CMod
S6&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The other thing you may notice is that the timer reload value isn’t connected
to the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Pulse-width_modulation&quot;&gt;PWM&lt;/a&gt;
counter any more.  Heresy!  No, actually it makes a lot of sense.  Because the
output bit order is spread uniformly across the sample interval, chopping a
value off before it’s had enough time to send all of its bits isn’t something
the ear will notice.  Further, this allows us to use arbitrary audio
intervals, without suffering significant loss.&lt;/p&gt;

&lt;p&gt;Incidentally, this simple change renders genering samples easier.  Not only
can we feed this value
&lt;a href=&quot;https://en.wikipedia.org/wiki/Twos_complement&quot;&gt;two’s complement&lt;/a&gt;
values now, but we can do so at our
favorite rate.  What if there aren’t enough clocks to transmit all the bits
in this new value?  Not a problem, the algorithm will adjust so that it
transmits as many bits as you have time to transmit.&lt;/p&gt;

&lt;p&gt;In other words, that’s all it takes to generate this bit-reversed
&lt;a href=&quot;https://en.wikipedia.org/wiki/Pulse-width_modulation&quot;&gt;PWM&lt;/a&gt;
signal.&lt;/p&gt;

&lt;p&gt;Let’s go one step further, though.  Let’s connect this controller to a
&lt;a href=&quot;/doc/wbspec_b4.pdf&quot;&gt;Wishbone bus&lt;/a&gt;, so
that we can send values to our core across such an interface.&lt;/p&gt;

&lt;h2 id=&quot;adding-wishbone-control&quot;&gt;Adding Wishbone Control&lt;/h2&gt;

&lt;p&gt;Let’s now turn this into a fairly complete
&lt;a href=&quot;https://en.wikipedia.org/wiki/Pulse-width_modulation&quot;&gt;PWM&lt;/a&gt;
audio controller.  To do this, we’ll add a user configurable sample rate,
some registers to control the power control wires in the
&lt;a href=&quot;https://store.digilentinc.com/pmod-amp2-audio-amplifier&quot;&gt;PModAMP2&lt;/a&gt;,
and a means of sending audio samples to the controller.  Finally, we’ll add an
interrupt line to let the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;bus master&lt;/a&gt;
know that another sample is needed.&lt;/p&gt;

&lt;p&gt;A more capable controller would include a
&lt;a href=&quot;/blog/2017/07/29/fifo.html&quot;&gt;FIFO&lt;/a&gt;
so as to minimize the cost of servicing this controller, but I’ll leave that
as an exercise for the student.  For now, we’ll follow the development used
for the &lt;a href=&quot;https://github.com/ZipCPU/s6soc&quot;&gt;S6SoC&lt;/a&gt;,
where the whole goal was to &lt;a href=&quot;/blog/2017/06/12/minimizing-luts.html&quot;&gt;minimize the amount of the
logic&lt;/a&gt;, and leave the
&lt;a href=&quot;/blog/2017/07/29/fifo.html&quot;&gt;FIFO&lt;/a&gt; out.&lt;/p&gt;

&lt;p&gt;If you’ve never built a
&lt;a href=&quot;/doc/wbspec_b4.pdf&quot;&gt;wishbone&lt;/a&gt;
slave before, you might wish to read our
&lt;a href=&quot;/zipcpu/2017/05/29/simple-wishbone.md&quot;&gt;previous discussion&lt;/a&gt;
as a background reference first.&lt;/p&gt;

&lt;p&gt;Our first task is going to be creating a reconfigurable sample rate.  In a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Pulse-width_modulation&quot;&gt;PWM&lt;/a&gt;
system, the sample rate is determined by the number of clocks per sample
duration.  We’ll call this number of samples &lt;code class=&quot;highlighter-rouge&quot;&gt;w_reload_value&lt;/code&gt;–something you’ve
already seen above.  The
&lt;a href=&quot;https://github.com/ZipCPU/wbpwmaudio/blob/master/rtl/wbpwmaudio.v&quot;&gt;wbpwmaudio&lt;/a&gt;
code offers two methods of setting this value.  These two methods are selectable
at design time via the &lt;code class=&quot;highlighter-rouge&quot;&gt;VARIABLE_RATE&lt;/code&gt; parameter.  If &lt;code class=&quot;highlighter-rouge&quot;&gt;VARIABLE_RATE&lt;/code&gt; is zero
(false), then the timer will always reload its value from a fixed
parameter value, &lt;code class=&quot;highlighter-rouge&quot;&gt;DEFAULT_RELOAD&lt;/code&gt;, at the end of every interval.  If
&lt;code class=&quot;highlighter-rouge&quot;&gt;VARIABLE_RATE&lt;/code&gt; is true, on the other hand, then the timer will reload its
value from a programmable register.&lt;/p&gt;

&lt;p&gt;Since we are using &lt;a href=&quot;http://zipcpu.com/doc/wbspec_b4.pdf&quot;&gt;wishbone&lt;/a&gt; control,
this register will need to be set from the bus any time &lt;code class=&quot;highlighter-rouge&quot;&gt;(i_wb_stb)&lt;/code&gt; is high,
indicating a bus cycle, &lt;code class=&quot;highlighter-rouge&quot;&gt;(i_wb_we)&lt;/code&gt; is high, indicating a bus write cycle, and
&lt;code class=&quot;highlighter-rouge&quot;&gt;(i_wb_addr)&lt;/code&gt; is high, indicating we are writing to the second of two
registers–the timer reload register.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;generate if (VARIABLE_RATE != 0)
begin
	reg	[(TIMING_BITS-1):0]	r_reload_value;
	initial	r_reload_value = DEFAULT_RELOAD;
	always @(posedge i_clk) // Data write
		if ((i_wb_stb)&amp;amp;&amp;amp;(i_wb_addr)&amp;amp;&amp;amp;(i_wb_we))
			r_reload_value &amp;lt;= i_wb_data[(TIMING_BITS-1):0];
	assign	w_reload_value = r_reload_value;
end else begin
	assign	w_reload_value = DEFAULT_RELOAD;
end endgenerate&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;We’ve already seen above how this affects our timer: when the timer runs out,
it gets reset with this value.  Likewise, &lt;code class=&quot;highlighter-rouge&quot;&gt;ztimer&lt;/code&gt; is set to be true any
time the timer has run out.&lt;/p&gt;

&lt;p&gt;This is also going to control when the design accepts the next sample:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	if (ztimer)
		sample_out &amp;lt;= next_sample;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;next_sample&lt;/code&gt; is a one-sample buffer.  It allows the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt;
or any other
&lt;a href=&quot;/blog/2017/06/08/simple-wb-master.html&quot;&gt;bus master&lt;/a&gt;ing
audio controller
a full sample interval in order to reload the value.&lt;/p&gt;

&lt;p&gt;Setting this one-sample buffer will be our next step.  In this case, we’ll
set it any time a bus write takes place &lt;code class=&quot;highlighter-rouge&quot;&gt;(i_wb_stb)&amp;amp;&amp;amp;(i_wb_we)&lt;/code&gt; to the
zero address of this port &lt;code class=&quot;highlighter-rouge&quot;&gt;(!i_wb_addr)&lt;/code&gt;.
Alternatively, if we are using a fixed sample rate, we’ll ignore the address
and just set the sample.  In this case, we’ll set the sample based upon the
16-bit sample value on the input
&lt;a href=&quot;/doc/wbspec_b4..pdf&quot;&gt;wishbone bus&lt;/a&gt;
data lines.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;initial	next_valid = 1&#39;b1;
initial	next_sample = 16&#39;h8000;
always @(posedge i_clk) // Data write
	if ((i_wb_stb)&amp;amp;&amp;amp;(i_wb_we)
			&amp;amp;&amp;amp;((!i_wb_addr)||(VARIABLE_RATE==0)))
	begin
		// Write with two&#39;s complement data, convert it
		// internally to binary offset
		next_sample &amp;lt;= { !i_wb_data[15], i_wb_data[14:0] };
		next_valid &amp;lt;= 1&#39;b1;
		if (i_wb_data[16])
			o_aux &amp;lt;= i_wb_data[(NAUX+20-1):20];
	end else if (ztimer)
		next_valid &amp;lt;= 1&#39;b0;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;There’s a couple things to notice here.  First, notice the negation of bit
fifteen–a 16-bit sample’s most significant bit.  This is the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Twos_complement&quot;&gt;two’s complement&lt;/a&gt;
sign bit.  Flipping the sign bit is the way to convert
&lt;a href=&quot;https://en.wikipedia.org/wiki/Twos_complement&quot;&gt;two’s complement&lt;/a&gt; values,
ranging from &lt;code class=&quot;highlighter-rouge&quot;&gt;-2^(N-1)&lt;/code&gt; to &lt;code class=&quot;highlighter-rouge&quot;&gt;2^(N-1)-1&lt;/code&gt; to the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Offset_binary&quot;&gt;offset binary&lt;/a&gt; values, ranging
from &lt;code class=&quot;highlighter-rouge&quot;&gt;0&lt;/code&gt; to &lt;code class=&quot;highlighter-rouge&quot;&gt;2^N-1&lt;/code&gt;, that a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Pulse-width_modulation&quot;&gt;PWM&lt;/a&gt;
modulator needs.  Second, you’ll want to notice the &lt;code class=&quot;highlighter-rouge&quot;&gt;next_valid&lt;/code&gt; logic.
This logic tells us whether or not the sample in our buffer is a valid
sample or not.  Upon any write, this value is set high to indicate we have a
valid sample in our buffer.  Whereas
any time the sample is moved from the one-sample buffer into the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Pulse-width_modulation&quot;&gt;PWM&lt;/a&gt;
modulation code as &lt;code class=&quot;highlighter-rouge&quot;&gt;sample_out&lt;/code&gt;, the &lt;code class=&quot;highlighter-rouge&quot;&gt;next_valid&lt;/code&gt; bit will be cleared to
indicate that there’s no valid sample in the buffer.&lt;/p&gt;

&lt;p&gt;In this code, &lt;code class=&quot;highlighter-rouge&quot;&gt;next_sample&lt;/code&gt; is set any time an audio sample is written to the
controller.  This is then fed to our output-sample value when the period
ends.  We’ll also note, upon setting this value, that the value is
valid (&lt;code class=&quot;highlighter-rouge&quot;&gt;next_valid&lt;/code&gt;).  We’ll keep this valid signal true until our &lt;code class=&quot;highlighter-rouge&quot;&gt;next_sample&lt;/code&gt;
value moves into the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Pulse-width_modulation&quot;&gt;PWM&lt;/a&gt;
output processing stage (above) as &lt;code class=&quot;highlighter-rouge&quot;&gt;sample_out&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;You may also notice the &lt;code class=&quot;highlighter-rouge&quot;&gt;o_aux&lt;/code&gt; value above.  I use the bits in &lt;code class=&quot;highlighter-rouge&quot;&gt;o_aux&lt;/code&gt; to
control two bits which can then be used to control the gain and shutdown pins
from within this controller.  So that we can choose whether or not to send
samples or updated control pins, we require that bit sixteen be set if you
want to update the control pins, otherwise we leave the control pins alone.&lt;/p&gt;

&lt;p&gt;At this point, we can move on and examine the values this controller
returns from the bus.  As in our &lt;a href=&quot;/zipcpu/2017/05/29/simple-wishbone.html&quot;&gt;first discussion of how to make a wishbone
peripheral&lt;/a&gt;,
we’ll set the bus output lines no matter whether we are writing or reading.
It just simplifies the logic.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;generate if (VARIABLE_RATE == 0)
begin
	assign o_wb_data = { {(12-NAUX){1&#39;b0}}, o_aux,
				3&#39;h0, o_int, sample_out };
end else begin
	reg	[31:0]	r_wb_data;
	always @(posedge i_clk)
		if (i_wb_addr)
			r_wb_data &amp;lt;= w_reload_value;
		else
			r_wb_data &amp;lt;= { {(12-NAUX){1&#39;b0}}, o_aux,
					3&#39;h0, o_int, sample_out };
	assign	o_wb_data = r_wb_data;
end endgenerate&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Selecting between which register to output took us one clock, so we’ll wait
one clock before acknowledge the clock in order to keep the acknowledgement
aligned with the data.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;initial	o_wb_ack = 1&#39;b0;
always @(posedge i_clk)
	o_wb_ack &amp;lt;= (i_wb_stb);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Further, the value(s) returned by this routine are always ready.  This routine
never has a reason to stall the bus.  (Repeated writes to the data register
will just over-write the buffer value.)  So, we’ll just keep the stall line low.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;assign	o_wb_stall = 1&#39;b0;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Finally, we’ll add in one further flair: an interrupt line to tell the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt;
when the buffer is no longer valid and can be refilled.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;assign	o_int &amp;lt;= (!next_valid);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;While I suppose
&lt;a href=&quot;/doc/wbspec_b4.pdf&quot;&gt;wishbone&lt;/a&gt;
support isn’t necessary for every core we present, this core already has it
and it was fun to present how a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Pulse-width_modulation&quot;&gt;PWM&lt;/a&gt;
generator might be created as a bus slave.&lt;/p&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;That just about wraps up this post!&lt;/p&gt;

&lt;p&gt;We’ve now gone over and discussed the traditional
&lt;a href=&quot;https://en.wikipedia.org/wiki/Pulse-width_modulation&quot;&gt;PWM&lt;/a&gt;
development, presenting how a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Pulse-width_modulation&quot;&gt;PWM&lt;/a&gt;
signal can be used as a cheap
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital-to-analog_converter&quot;&gt;digital to analog converter&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;We then presented a new approach to 
&lt;a href=&quot;https://en.wikipedia.org/wiki/Pulse-width_modulation&quot;&gt;PWM&lt;/a&gt;
that we called the “bit-reversed
&lt;a href=&quot;https://en.wikipedia.org/wiki/Pulse-width_modulation&quot;&gt;PWM&lt;/a&gt;”
approach.  We pointed out how this approach spreads the unwanted
&lt;a href=&quot;https://en.wikipedia.org/wiki/Pulse-width_modulation&quot;&gt;PWM&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Harmonic&quot;&gt;harmonic&lt;/a&gt;
energy into higher frequencies, relieving some of the stress on
the anti-aliasing filter.  This approach also separated the timer
determining the edges of the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Pulse-width_modulation&quot;&gt;PWM&lt;/a&gt;
signal from the sample generator, with the purpose of removing some of the
noise associated with the periodic signal associated with no signal.&lt;/p&gt;

&lt;p&gt;I have personally listened to the quality of the output of this amplifier.
My test signal has been a doorbell sound.  The doorbell comes out sounding
pure, with no noticable audio distortions.&lt;/p&gt;

&lt;p&gt;No, I’m not suggesting this is “professional” audio quality, but it is better
than the alternative.&lt;/p&gt;

&lt;p&gt;Perhaps I may encourage you to try &lt;a href=&quot;https://github.com/ZipCPU/wbpwmaudio&quot;&gt;this component
IP&lt;/a&gt;
yourself, to hear how it sounds?&lt;/p&gt;

&lt;p&gt;Hmm … perhaps I should show you instead how this component may be
simply and easily be integrated into a basic debugging bus, so that you
can hear the sound quality for yourself?  That will have to remain, though,
as a lesson for another day.&lt;/p&gt;

&lt;hr /&gt;&lt;p&gt;&lt;em&gt;And whosoever shall fall on this stone shall be broken: but on whomsoever it shall fall, it will grind him to powder.&lt;/em&gt;</description>
        <pubDate>Mon, 04 Sep 2017 00:00:00 -0400</pubDate>
        <link>http://zipcpu.com/dsp/2017/09/04/pwm-reinvention.html</link>
        <guid isPermaLink="true">http://zipcpu.com/dsp/2017/09/04/pwm-reinvention.html</guid>
        
        
        <category>dsp</category>
        
      </item>
    
      <item>
        <title>Big Money Engineering Integrity</title>
        <description>&lt;p&gt;Every now and then, the &lt;a href=&quot;&quot;&gt;ZipCPU blog&lt;/a&gt; includes a short
discussion on engineering ethics.  Our last post challenged you with the
question, &lt;a href=&quot;/blog/2017/08/12/caused-to-lie.html&quot;&gt;what would cause you to
lie&lt;/a&gt;?  Below is a
discussion from some of my own experience, illustrating the extent to which
an integrity problem can destroy the foundation of solid engineering.&lt;/p&gt;

&lt;p&gt;Before I started &lt;a href=&quot;/about/gisselquist-technology.html&quot;&gt;Gisselquist
Technology&lt;/a&gt;,
I had my own moral strength and integrity challenged.&lt;/p&gt;

&lt;p&gt;Many years ago, I was asked to join the government team managing a
multibillion dollar contract.  To protect the innocent, we’ll leave the name
of the project and the name of the office supporting it nameless.  Suffice
to say that I was working for a government procurement office.&lt;/p&gt;

&lt;p&gt;The director of my office asked me to examine the product that he was
responsible for procuring on behalf of the US government.  I was not asked
because it was my current job (I had been working on another team), but
rather
because of some heated disagreements over whether or not the product actually
worked.  Since my academic background was in a nearly related field, I was
deemed to be uniquely suited to evaluate the product that was being produced.&lt;/p&gt;

&lt;h2 id=&quot;what-my-research-revealed&quot;&gt;What my research revealed&lt;/h2&gt;

&lt;p&gt;As I started researching this program, its requirements and history, I quickly
discovered that the history of the program was quite colored.&lt;/p&gt;

&lt;table style=&quot;float: right&quot;&gt;&lt;caption&gt;Liar&#39;s Dilemma&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/integrity-big-money-liars-dilemma.svg&quot; alt=&quot;The liar&#39;s dilemma&quot; width=&quot;320&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;Interviews with the contractor revealed a history of employees getting
re-assigned or fired for telling the government procurement lead that the
product didn’t or wouldn’t work.  Those that remained, the ones I was able to
talk to, were very aware that remaining on the contract, indeed their very
job and livelihood, would only be possible if they said nothing about any
problems the system had.&lt;/p&gt;

&lt;p&gt;Those who worked for the contractor were both scared and morally scarred.
They were living under a lie and they knew it and didn’t like it.  However,
they felt trapped.  If they spoke up, they knew that they lose their jobs
and how would they then feed their family?&lt;/p&gt;

&lt;p&gt;The corruption wasn’t limited to the one office.  Rather, it spread throughout
the contractor’s facility, throughout the government procurement office, and
even into the leadership of those who were supposed to use this product.&lt;/p&gt;

&lt;p&gt;For example, all of the official program briefs presented glowing numbers
showing the amount of data the system could process.  The quantity was
deemed to make the program a success.  The program manager was very quick
to display all kinds of figures showing the massive amounts of data this
system produced.  However, he had no means of proving that any one of those
outputs were in fact correct.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Two views of whether or not the system worked&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/integrity-big-money-does-it-work.svg&quot; alt=&quot;Does it work?&quot; width=&quot;680&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;The actual user’s of the program, on the other hand, would present example
upon example demonstrating
the failures of the program.  However, without maintaining the data set that
created those failures, the failures could never be reproduced.  Since the
failures couldn’t be reproduced, they couldn’t be used as test cases and formed
ambiguous requests for improvement within the program office.  Further,
since the system was never tested against known inputs in conditions similar
to those that had caused known failures, it was impossible to know if the
failures were common behaviors, or just the one in a million rare example.&lt;/p&gt;

&lt;p&gt;The result was that any time the two offices got together, the meetings
could easily devolve into shouting matches.  It works!  It’s broken!
With no truth under-girding either argument, the two sides might just as well
have been arguing: &lt;a href=&quot;http://www.sportsonearth.com/article/63816024&quot;&gt;Taste’s great!  Less
filling!&lt;/a&gt;  There would have
been no difference in the result.&lt;/p&gt;

&lt;p&gt;This is the sad result of what happens when sound engineering practice is
abandoned.&lt;/p&gt;

&lt;p&gt;Rather than treating this as the integrity problem it was, the problem was
officially characterized as “political”.  By management fiat, I was instructed
and told that the problem had nothing to do with sound engineering practice.&lt;/p&gt;

&lt;p&gt;However, the problem was not “political” as my boss had instructed me.  The
problem was the result of the loss of the Godly integrity that forms the
foundation of sound engineering practice.&lt;/p&gt;

&lt;table style=&quot;float: right&quot;&gt;&lt;caption&gt;Does it work?&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/integrity-big-money-venn.svg&quot; alt=&quot;A Venn Diagram of Performance&quot; width=&quot;360&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;In the digital design world, we might say that the project didn’t include
any representative test-benches.  How was it tested, you ask, without
test-benches?  By comparing the system’s results before any software changes
to the results after the improvements.  But … which of those results were
actually correct?  No one knew.&lt;/p&gt;

&lt;p&gt;No one was placing known inputs into the device to measure whether or not it
was producing the correctly expected outputs.  This is the idea behind a
“ground truth” test.  Known inputs are measured against what should be known
outputs.  Differences are recorded, quantified, and reported on.&lt;/p&gt;

&lt;h2 id=&quot;ground-truth-testing&quot;&gt;Ground truth testing&lt;/h2&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;A Ground Truth Test&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/integrity-big-money-ground-truth.svg&quot; alt=&quot;Ground truth methodology outline&quot; width=&quot;680&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;A “ground truth” testing program that compared the output of this product
against an expected or “correct” output was called for.  Further, a library
of “ground truth” test cases having known inputs needed to be assembled that
would highlight any problems, and also allow the development team to fix
them.  The program basically needed test benches with physically realistic
inputs.&lt;/p&gt;

&lt;p&gt;With this goal in mind, I quickly assembled a small team and secured funding
for a project that would help to determine how the system actually performed
against known inputs.  We called it a “ground truth” testing program.  To my
surprise, the idea of “ground truth” testing program was not universally
acclaimed as good engineering.  Indeed, it was my own office that
considered the idea “controversial.”  I was told that such testing would be
a waste of precious dollars, and that it wouldn’t prove anything to those
that “didn’t like” the system.&lt;/p&gt;

&lt;p&gt;While this “ground truth” testing program was underway, a senior leadership
“taskforce” was appointed to fix all the system’s problems.  Management gave
them ninety days to be successful.  Reality,
though, is that years of engineering integrity problems are not easily fixed
in ninety days.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Project Timelines&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/integrity-big-money-timeline.svg&quot; alt=&quot;A timeline showing events&quot; width=&quot;680&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Think about that one: what would you do if &lt;em&gt;you&lt;/em&gt; were the one appointed to
a ninety day task force, and tasked with fixing problems that were the
result of years of integrity neglect?&lt;/p&gt;

&lt;p&gt;While I was not personally involved in this “taskforce”, I read with great
interest their results and conclusions.&lt;/p&gt;

&lt;p&gt;Much as one might expect, the “taskforce” declared the system fixed.
Had they compared the output of the system against known inputs?  No.&lt;/p&gt;

&lt;p&gt;Did the “task force” collect examples of inputs causing “known failures”,
apply fixes, and then run those same examples again to see if the result
got better?
No.  They applied fixes and tested the system with new data which may or may
not have had the original problem within it.  There was no
way to know if the fixes even worked.  Indeed, all those who weren’t
part of the senior leadership team were instructed to accept that the
problems had been fixed–independent of any real facts.&lt;/p&gt;

&lt;p&gt;This is not how you fix such a system.&lt;/p&gt;

&lt;p&gt;What the “task force” should have done would have been to first find data sets
that would have reproduced the problems, and then replayed those data sets
through the system later to see if any of the “fixes” worked.  Further,
their data sets needed to come with known answers–such as the “ground truth”
testing approach was working to create.&lt;/p&gt;

&lt;p&gt;When I saw the results of this senior leadership “taskforce”, I spoke up.  I
sent an internal memo to the rest of the procurement team outlining how the
process was broken.  I explained that the senior leadership “taskforce” hadn’t
demonstrated that they had fixed anything, since they had abandoned sound
engineering practice.  As I’m sure you can imagine, my office manager wasn’t
pleased with my views.  When he read this memo, he then called me into his
office and threatened me.  “You pull another stunt like this, and you will be
fired.”&lt;/p&gt;

&lt;p&gt;During this time, the ground truth testing effort continued.&lt;/p&gt;

&lt;p&gt;To illustrate how bad the environment was at the contractor’s facility,
they were making bets over when the ground truth project was going to be
killed by my management (in the procurement office).&lt;/p&gt;

&lt;p&gt;The procurement management team never liked the “ground truth” testing
approach, probably because they didn’t feel like they could control it’s
results.  Measurements are pesky things, and comparisons between system
outputs and known “correct” answers are hard to spin.  Indeed, the “ground
truth” testing project was nearly terminated once when the procurement
manager, whom I worked for, realized what I was up to.  (It was also nearly
terminated when he read the memo I referenced above.)&lt;/p&gt;

&lt;p&gt;As you might expect, testing a product in a way that it has never been tested
before will likely yield unexpected results.  This is normal.  This was the
result of the “ground truth” tests.&lt;/p&gt;

&lt;p&gt;The product itself was not irreversibly broken.  Sound engineering process,
built upon true engineering and integrity, would’ve fixed it.  The real
problem was that no one was using sound engineering principles because of the
lies and the fear involved.  True God given engineering integrity had been
lost.&lt;/p&gt;

&lt;p&gt;Sure enough, when the procurement manager read the “ground truth” report,
he didn’t like its results.  He then directed me to withhold these results
from the people who were going to use this product.&lt;/p&gt;

&lt;h2 id=&quot;the-aftermath&quot;&gt;The aftermath&lt;/h2&gt;

&lt;p&gt;This was about where the office’s &lt;a href=&quot;https://en.wikipedia.org/wiki/Office_of_Inspector_General_(United_States)&quot;&gt;Inspector General (IG)&lt;/a&gt; got involved.&lt;/p&gt;

&lt;p&gt;This was also the point where I learned the legal definition of the word
“fraud”.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Fraud is generally defined in the law as an intentional misrepresentation
of material existing fact made by one person
to another with knowledge of its falsity and for the
purpose of inducing the other person to act,
and upon which the other person relies with resulting injury
or damage.  Fraud may also be made by an omission or purposeful failure
to state material facts, which nondisclosure makes other statements
misleading.  &lt;a href=&quot;https://definitions.uslegal.com/fraud&quot;&gt;uslegal.com&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Let’s break this down into simpler terms.  I had created for my office a
“material fact”: the ground truth testing report.  By withholding this
fact from the operations office (fraud by omission) that was supposed to
accept our product, they had suffered “damage”: they were forced to accept
as operational a system that never passed a valid test.  This met the
legal definition of fraud.&lt;/p&gt;

&lt;p&gt;Following the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Office_of_Inspector_General_(United_States)&quot;&gt;IG&lt;/a&gt;’s
report, the program had a change of leadership.  Some individuals lost their
jobs.  Several individuals were quietly forced to retire.  I was also given my
one and only chance to brief the US Congress.  I would have rather had my
opportunity under more pleasurable circumstances.  However, I knew my duty.&lt;/p&gt;

&lt;p&gt;I also chose to leave that community and seek other work, so as to avoid
any ethical or whistle-blower issues.&lt;/p&gt;

&lt;p&gt;Since then, I have kept up with members of contractor’s office.  I have
thus kept track of what has happened after my departure.  A new management
team has been assigned to replace the old.  The new management team, though,
kept the same advisors from the last team.  The sad result is that the old
advisors convinced them to follow the same crooked path that had led them
into the mess in the first place.  As a result, this product is still built
upon lies, having no sound engineering integrity within it.&lt;/p&gt;

&lt;h2 id=&quot;breaking-the-liars-dilemma&quot;&gt;Breaking the Liar’s Dilemma&lt;/h2&gt;

&lt;p&gt;Throughout this whole process, I would constantly explain to my team that
your actions should all depend upon your judge.  If the boss is your judge,
do as he tells you to do.  If the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Office_of_Inspector_General_(United_States)&quot;&gt;IG&lt;/a&gt;
or Congress will be your judge, act so as to impress them.  On the otherhand,
if anticipate that God will be your judge, then don’t worry about the boss, the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Office_of_Inspector_General_(United_States)&quot;&gt;IG&lt;/a&gt;,
or Congress: focus your life on pleasing God.&lt;/p&gt;

&lt;p&gt;What about the liar’s dilemma?&lt;/p&gt;

&lt;p&gt;Jesus provides some clear guidance:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Therefore take no thought, saying, What shall we eat? or, What shall we
drink? or, Wherewithal shall we be clothed? (For after all these things
do the Gentiles seek:) for your heavenly Father knoweth that ye have
need of all these things.  But seek ye first the kingdom of God, and his
righteousness; and all these things shall be added unto you.
Take therefore no thought for the morrow: for the morrow shall take thought
for the things of itself. Sufficient unto the day is the evil thereof.
(&lt;a href=&quot;https://www.blueletterbible.org/kjv/mat/6/33&quot;&gt;Matt 6:31-34&lt;/a&gt;)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Indeed, this guidance breaks the trap of the liar’s dilemma.  In this verse,
Jesus promises that God will provide and all we need to do is to “seek first
the kingdom of God”.  The big problem with the liar’s dilemma is that
those caught within it believe that their life will be worse, if not even
destroyed, if they do not lie.  Yet for those willing to trust Jesus at His
word, they will learn that this is never the case.&lt;/p&gt;

&lt;p&gt;I read these verses many times during my work on this project.&lt;/p&gt;

&lt;p&gt;Yes, I have left that job and that twisted work environment.  No, I am not
making the “big bucks” today, but I did manage to leave with my integrity.
Thanks be to God.&lt;/p&gt;
&lt;hr /&gt;&lt;p&gt;&lt;em&gt;Better is the poor that walketh in his integrity, than he that is perverse in his lips, and is a fool.&lt;/em&gt;</description>
        <pubDate>Sat, 02 Sep 2017 00:00:00 -0400</pubDate>
        <link>http://zipcpu.com/blog/2017/09/02/big-money-integrity.html</link>
        <guid isPermaLink="true">http://zipcpu.com/blog/2017/09/02/big-money-integrity.html</guid>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>CORDIC part two: rectangular to polar conversion</title>
        <description>&lt;p&gt;We’ve now discussed three methods of generating sine waves: &lt;a href=&quot;/dsp/2017/07/11/simplest-sinewave-generator.html&quot;&gt;a simple table
lookup
approach&lt;/a&gt;,
&lt;a href=&quot;/dsp/2017/08/26/quarterwave.html&quot;&gt;a quarter wave table
lookup approach&lt;/a&gt;,
and most recently
&lt;a href=&quot;/dsp/2017/08/30/cordic.html&quot;&gt;a CORDIC approach&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Today, let’s take another look at the
&lt;a href=&quot;/dsp/2017/08/30/cordic.html&quot;&gt;CORDIC&lt;/a&gt;
approach.  In particular, the
&lt;a href=&quot;/dsp/2017/08/30/cordic.html&quot;&gt;CORDIC&lt;/a&gt;
algorithm can also be used in “reverse”–not to rotate a
vector by some amount, but rather to find out what angular rotation that
vector has as in Fig 1.&lt;/p&gt;

&lt;table style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 1: Using a CORDIC for rectangular to polar conversion&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/topolar-problem-setup.svg&quot; alt=&quot;Using a CORDIC for rectangular to polar conversion&quot; width=&quot;320&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;This “reverse” CORDIC can be used as a complex signal magnitude detector,
as well as an arctangent calculator.  This arctangent calculator can be used
as a &lt;a href=&quot;https://en.wikipedia.org/wiki/Phase_detector&quot;&gt;phase-detector&lt;/a&gt; within a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Phase-locked_loop&quot;&gt;phase locked loop&lt;/a&gt;.
Indeed, today’s 
&lt;a href=&quot;https://en.wikipedia.org/wiki/CORDIC&quot;&gt;CORDIC&lt;/a&gt;
algorithm can be an important part of any
&lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency_modulation&quot;&gt;FM&lt;/a&gt;,
or &lt;a href=&quot;https://en.wikipedia.org/wiki/Amplitude_modulation&quot;&gt;AM&lt;/a&gt;
signal &lt;a href=&quot;https://en.wikipedia.org/wiki/Demodulation&quot;&gt;demodulator&lt;/a&gt;.
You might even use this approach to build an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Electronic_tuner&quot;&gt;audio tuner&lt;/a&gt;–so that you can
tell if your musical instrument’s are “in tune”.&lt;/p&gt;

&lt;p&gt;To get there, though, we’re going to need to learn how to run the
&lt;a href=&quot;https://en.wikipedia.org/wiki/CORDIC&quot;&gt;CORDIC&lt;/a&gt;
in the rectangular to polar conversion mode.&lt;/p&gt;

&lt;p&gt;We’ll use the same
&lt;a href=&quot;https://en.wikipedia.org/wiki/CORDIC&quot;&gt;CORDIC&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Rotation_matrix&quot;&gt;rotation matrices&lt;/a&gt;
&lt;a href=&quot;/dsp/2017/08/30/cordic.html&quot;&gt;as before&lt;/a&gt;.
Indeed, many parts and pieces of today’s algorithm are nearly identical
to &lt;a href=&quot;/dsp/2017/08/30/cordic.html&quot;&gt;our last discussion&lt;/a&gt;:
we’ll need to expand our variables by one bit as before (to &lt;code class=&quot;highlighter-rouge&quot;&gt;e_xval&lt;/code&gt; and
&lt;code class=&quot;highlighter-rouge&quot;&gt;e_yval&lt;/code&gt;),
we’ll need to declare variables for every stage (&lt;code class=&quot;highlighter-rouge&quot;&gt;xv&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;yv&lt;/code&gt;, and &lt;code class=&quot;highlighter-rouge&quot;&gt;ph&lt;/code&gt;),
we’ll need to calculate  our &lt;code class=&quot;highlighter-rouge&quot;&gt;cordic_angle&lt;/code&gt;s and CORDIC gain as before (we
can even use the same &lt;a href=&quot;https://github.com/ZipCPU/cordic/blob/master/sw/cordiclib.cpp&quot;&gt;C++
code&lt;/a&gt;,
and we’ll offer to insert some “traveling CE” &lt;a href=&quot;/blog/2017/08/14/strategies-for-pipelining.html&quot;&gt;pipeline
logic&lt;/a&gt;
just as before.
If you aren’t familiar with any of these parts of the algorithm, please check
out our &lt;a href=&quot;/dsp/2017/08/30/cordic.html&quot;&gt;last post&lt;/a&gt; for reference.&lt;/p&gt;

&lt;p&gt;Today we’ll focus on the differences between this application of the
&lt;a href=&quot;https://en.wikipedia.org/wiki/CORDIC&quot;&gt;CORDIC&lt;/a&gt;
and
&lt;a href=&quot;/dsp/2017/08/30/cordic.html&quot;&gt;our last one&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Indeed, there are really only three things we need to do different.
We’ll start off our discussion with a brief recap of how the process works
in general.  Then we’ll get into the three basic changes, illustrating the
changes with examples of
&lt;a href=&quot;https://github.com/ZipCPU/cordic/blob/master/rtl/topolar.v&quot;&gt;working code&lt;/a&gt;.
The first change will be how we map our input to plus or minus forty five
degrees in a different fashion from before.  The second change will be 
adjusting how the
&lt;a href=&quot;https://en.wikipedia.org/wiki/CORDIC&quot;&gt;CORDIC&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Rotation_matrix&quot;&gt;rotations&lt;/a&gt;
are applied, based upon a different method of choosing which rotation.
Finally, the variable(s) that need to be
&lt;a href=&quot;/dsp/2017/07/22/rounding.html&quot;&gt;rounded&lt;/a&gt;
will change at the end as well.&lt;/p&gt;

&lt;h2 id=&quot;how-the-process-works&quot;&gt;How the process works&lt;/h2&gt;

&lt;p&gt;When we used the
&lt;a href=&quot;https://en.wikipedia.org/wiki/CORDIC&quot;&gt;CORDIC&lt;/a&gt;
algorithm
&lt;a href=&quot;/dsp/2017/08/30/cordic.html&quot;&gt;before&lt;/a&gt;,
we were given a two-dimensional vector, &lt;code class=&quot;highlighter-rouge&quot;&gt;i_xval&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;i_yval&lt;/code&gt;, and tasked
with rotating it in the Counter-Clockwise (CCW) direction by some given
&lt;a href=&quot;/dsp/2017/06/15/no-pi-for-you.html&quot;&gt;phase&lt;/a&gt;,
&lt;code class=&quot;highlighter-rouge&quot;&gt;i_phase&lt;/code&gt;.  For today’s conversion, we’ll start with a given
two-dimensional vector again, but this time we’re going to measure how far this
vector needs to be rotated in the clockwise (CW) direction until it lies on the
positive x-axis as shown in Fig 1 above.  The
&lt;a href=&quot;/dsp/2017/06/15/no-pi-for-you.html&quot;&gt;angle&lt;/a&gt;
we measure will then be produced on the output, and called &lt;code class=&quot;highlighter-rouge&quot;&gt;o_phase&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Hence, any time our vector is below the x-axis, &lt;code class=&quot;highlighter-rouge&quot;&gt;yv &amp;lt; 0&lt;/code&gt;, we’ll rotate our
vector in the CCW direction.  In a similar fashion, any
time our vector is at or above the x-axis, &lt;code class=&quot;highlighter-rouge&quot;&gt;yv &amp;gt;= 0&lt;/code&gt;, we’ll rotate in the CW
direction.  In both cases, we’ll adjust the
&lt;a href=&quot;/dsp/2017/06/15/no-pi-for-you.html&quot;&gt;phase&lt;/a&gt;
accumulator, &lt;code class=&quot;highlighter-rouge&quot;&gt;ph&lt;/code&gt;, but unlike
&lt;a href=&quot;/dsp/2017/08/30/cordic.html&quot;&gt;before&lt;/a&gt;
we won’t use the
&lt;a href=&quot;/dsp/2017/06/15/no-pi-for-you.html&quot;&gt;phase&lt;/a&gt;
to determine which direction to rotate.&lt;/p&gt;

&lt;p&gt;You may recall from our
&lt;a href=&quot;/dsp/2017/08/30/cordic.html&quot;&gt;previous post&lt;/a&gt;
that the
&lt;a href=&quot;https://en.wikipedia.org/wiki/CORDIC&quot;&gt;CORDIC&lt;/a&gt;
transformation matrix is given by,&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/eqn-bare-cordic-transform.png&quot; alt=&quot;EQN for a bare cordic stage&quot; width=&quot;281&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;This transformation matrix has the unique property that it can be applied
to an x and y coordinate vector without requiring any hardware multiplies
to calculate the result.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/eqn-cordic-eqns.png&quot; alt=&quot;Cordic equations&quot; width=&quot;350&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;We’ve also &lt;a href=&quot;/dsp/2017/08/30/cordic.html&quot;&gt;discussed&lt;/a&gt;
how this coordinate transformation can be rearranged to look like a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Rotation_matrix&quot;&gt;rotation matrix&lt;/a&gt;,&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/eqn-cordic-transform-simplified.png&quot; alt=&quot;Eqn for the cordic stage, after simplification&quot; width=&quot;459&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;where&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/eqn-cordic-phase.png&quot; alt=&quot;Cordic rotation phase&quot; width=&quot;168&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Likewise, if you switch the sign of the
&lt;a href=&quot;/dsp/2017/06/15/no-pi-for-you.html&quot;&gt;angle&lt;/a&gt;, the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Rotation_matrix&quot;&gt;rotation&lt;/a&gt;
is easily reversed.  The resulting transform looks almost identical, save
for a couple of sign differences,&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/eqn-cordic-negative-transform.png&quot; alt=&quot;Eqn for the cordic stage, negated angle, after simplification&quot; width=&quot;459&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;For this algorithm, we’ll apply a series of
&lt;a href=&quot;https://en.wikipedia.org/wiki/CORDIC&quot;&gt;CORDIC&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Rotation_matrix&quot;&gt;rotation matrices&lt;/a&gt;
to our input vector until the &lt;code class=&quot;highlighter-rouge&quot;&gt;y&lt;/code&gt; value lies on the x-axis.
If you’d like, you can follow along the discussion that follows while
looking at the Verilog &lt;a href=&quot;https://github.com/ZipCPU/cordic/blob/master/rtl/topolar.v&quot;&gt;code for this operation
here&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;the-preliminary-stage&quot;&gt;The preliminary stage&lt;/h2&gt;

&lt;p&gt;You may remember from
&lt;a href=&quot;/dsp/2017/08/30/cordic.html&quot;&gt;before&lt;/a&gt;
that the maximum
&lt;a href=&quot;https://en.wikipedia.org/wiki/CORDIC&quot;&gt;CORDIC&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Rotation_matrix&quot;&gt;rotation&lt;/a&gt;
is +/- 45 degrees.  We’d like to create an algorithm that works
for all
&lt;a href=&quot;/dsp/2017/06/15/no-pi-for-you.html&quot;&gt;angles&lt;/a&gt;.
That means we’re going to need to a preliminary rotation step to bring us to
within +/- 45 degrees of the x-axis, as shown in Fig 2.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 2: Pre-rotation results&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/topolar-prerotation.svg&quot; alt=&quot;The CORDIC pre-rotation step, converting to +/- 45 degrees&quot; width=&quot;520&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;table style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 3: Pre-rotation to +/- 45 degrees&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/topolar-prequadrants.svg&quot; alt=&quot;Using a CORDIC for rectangular to polar conversion&quot; width=&quot;320&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;Unlike &lt;a href=&quot;/dsp/2017/08/30/cordic.html&quot;&gt;the last time&lt;/a&gt;,
we can’t use the &lt;code class=&quot;highlighter-rouge&quot;&gt;i_phase&lt;/code&gt;
&lt;a href=&quot;/dsp/2017/06/15/no-pi-for-you.html&quot;&gt;angle&lt;/a&gt;
to define this initial rotation, since the
&lt;a href=&quot;/dsp/2017/06/15/no-pi-for-you.html&quot;&gt;phase&lt;/a&gt;
is something we are trying to calculate.
Instead, we’ll use the signs of the initial vector, &lt;code class=&quot;highlighter-rouge&quot;&gt;i_xval, i_yval&lt;/code&gt; to
determine our pre-rotation coordinate conversion.  This leads us to a
pre-rotation step that looks like Fig 3.&lt;/p&gt;

&lt;p&gt;Notice from the figures that our initial rotation areas are aligned on
multiples of ninety degrees.  This is a result of starting with the signs of
&lt;code class=&quot;highlighter-rouge&quot;&gt;i_xval&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;i_yval&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;You may find that the
&lt;a href=&quot;https://github.com/ZipCPU/cordic/blob/master/rtl/topolar.v&quot;&gt;code&lt;/a&gt;
for this initial rotation looks very similar to the
&lt;a href=&quot;https://github.com/ZipCPU/cordic/blob/master/rtl/cordic.v&quot;&gt;code&lt;/a&gt; we presented
in our &lt;a href=&quot;/dsp/2017/08/30/cordic.html&quot;&gt;original CORDIC post&lt;/a&gt;.
Unlike &lt;a href=&quot;/dsp/2017/08/30/cordic.html&quot;&gt;the last time&lt;/a&gt;,
this pre-rotation requires &lt;em&gt;adding&lt;/em&gt; the (potentially 
negated) &lt;code class=&quot;highlighter-rouge&quot;&gt;x&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;y&lt;/code&gt; values together to accomplish the rotation.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;// First stage, map to within +/- 45 degrees
always @(posedge i_clk)
if (i_ce)
	case({i_xval[IW-1], i_yval[IW-1]})
	2&#39;b01: begin // Rotate by -315 degrees
		xv[0] &amp;lt;=  e_xval - e_yval;
		yv[0] &amp;lt;=  e_xval + e_yval;
		ph[0] &amp;lt;= 19&#39;h70000;
		end
	2&#39;b10: begin // Rotate by -135 degrees
		xv[0] &amp;lt;= -e_xval + e_yval;
		yv[0] &amp;lt;= -e_xval - e_yval;
		ph[0] &amp;lt;= 19&#39;h30000;
		end
	2&#39;b11: begin // Rotate by -225 degrees
		xv[0] &amp;lt;= -e_xval - e_yval;
		yv[0] &amp;lt;=  e_xval - e_yval;
		ph[0] &amp;lt;= 19&#39;h50000;
		end
	// 2&#39;b00:
	default: begin // Rotate by -45 degrees
		xv[0] &amp;lt;=  e_xval + e_yval;
		yv[0] &amp;lt;= -e_xval + e_yval;
		ph[0] &amp;lt;= 19&#39;h10000;
		end
	endcase&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;That’s the pre-rotation step.  We’re now within forty five degrees of the
final “correct” answer.&lt;/p&gt;

&lt;h2 id=&quot;rotating-the-vector-towards-zero&quot;&gt;Rotating the vector towards zero&lt;/h2&gt;

&lt;p&gt;Having accomplished the pre-rotation step, it’s now time for the guts of the
algorithm.  The algorithm starts out identical to the last time, with a
generate statement and a for loop across stages.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;genvar	i;
generate for(i=0; i&amp;lt;NSTAGES; i=i+1) begin : TOPOLARloop
	always @(posedge i_clk)&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;When you get to the actual implementation of the
&lt;a href=&quot;https://en.wikipedia.org/wiki/CORDIC&quot;&gt;CORDIC&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Rotation_matrix&quot;&gt;rotations&lt;/a&gt;
themselves, the big difference between this section of code and the previous
one is the dependence upon the sign of &lt;code class=&quot;highlighter-rouge&quot;&gt;yv&lt;/code&gt; rather than the sign of the
remaining
&lt;a href=&quot;/dsp/2017/06/15/no-pi-for-you.html&quot;&gt;phase angle&lt;/a&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;ph&lt;/code&gt;.  If the sign is negative, apply the
&lt;a href=&quot;https://en.wikipedia.org/wiki/CORDIC&quot;&gt;CORDIC&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Rotation_matrix&quot;&gt;rotation&lt;/a&gt;
in the CCW direction,
otherwise rotate CW.  In both cases, we’ll accumulate the rotation amount
in the
&lt;a href=&quot;/dsp/2017/06/15/no-pi-for-you.html&quot;&gt;phase&lt;/a&gt;
variable, &lt;code class=&quot;highlighter-rouge&quot;&gt;ph&lt;/code&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	if (i_ce)
	begin
		if (yv[i][(WW-1)]) // Below the axis
		begin
			// If the vector is below the x-axis, rotate by
			// the CORDIC angle in a positive direction.
			xv[i+1] &amp;lt;= xv[i] - (yv[i]&amp;gt;&amp;gt;&amp;gt;(i+1));
			yv[i+1] &amp;lt;= yv[i] + (xv[i]&amp;gt;&amp;gt;&amp;gt;(i+1));
			ph[i+1] &amp;lt;= ph[i] - cordic_angle[i];
		end else begin
			// On the other hand, if the vector is above the
			// x-axis, then rotate in the other direction
			xv[i+1] &amp;lt;= xv[i] + (yv[i]&amp;gt;&amp;gt;&amp;gt;(i+1));
			yv[i+1] &amp;lt;= yv[i] - (xv[i]&amp;gt;&amp;gt;&amp;gt;(i+1));
			ph[i+1] &amp;lt;= ph[i] + cordic_angle[i];
		end
	end
end endgenerate&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;When we are all done, the amount of
&lt;a href=&quot;/dsp/2017/06/15/no-pi-for-you.html&quot;&gt;phase&lt;/a&gt;
rotation that we’ve applied can be
found in &lt;code class=&quot;highlighter-rouge&quot;&gt;ph&lt;/code&gt;, while the magnitude of the resulting vector can be found in
&lt;code class=&quot;highlighter-rouge&quot;&gt;xv&lt;/code&gt;.  The y-value, &lt;code class=&quot;highlighter-rouge&quot;&gt;yv&lt;/code&gt;, for the final stage should also be zero or nearly
so, making it irrelevant.  Our next step will be to round this value to the
desired number of output bits, and return the result.&lt;/p&gt;

&lt;h2 id=&quot;rounding-the-result&quot;&gt;Rounding the result&lt;/h2&gt;

&lt;p&gt;Some time back, we discussed the &lt;a href=&quot;/dsp/2017/07/22/rounding.html&quot;&gt;serious problems that can be associated
with truncation&lt;/a&gt;.  Ever
since, &lt;a href=&quot;/dsp/2017/07/22/rounding.html&quot;&gt;I’ve recommended convergent
convergent rounding&lt;/a&gt;
whenever the number of bits in a value needs to be lowered.  Therefore, as a
last step, we’ll apply
convergent rounding
to our magnitude value, &lt;code class=&quot;highlighter-rouge&quot;&gt;xv&lt;/code&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;assign	pre_mag = xv[NSTAGES] + { {(OW){1&#39;b0} },
			xv[NSTAGES][(WW-OW)],
			{(WW-OW-1){!xv[NSTAGES][WW-OW]}}};

always @(posedge i_clk)
if (i_ce)
begin
	o_mag   &amp;lt;= pre_mag[(WW-1):(WW-OW)];
	o_phase &amp;lt;= ph[NSTAGES];
end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Notice that we didn’t apply any
&lt;a href=&quot;/dsp/2017/07/22/rounding.html&quot;&gt;rounding&lt;/a&gt;
to our
&lt;a href=&quot;/dsp/2017/06/15/no-pi-for-you.html&quot;&gt;phase angle&lt;/a&gt;
result.  That’s because we’ve never dropped bits in the
&lt;a href=&quot;/dsp/2017/06/15/no-pi-for-you.html&quot;&gt;phase angle&lt;/a&gt;.
Indeed, the number of
&lt;a href=&quot;/dsp/2017/06/15/no-pi-for-you.html&quot;&gt;phase&lt;/a&gt;
bits has been constant at &lt;code class=&quot;highlighter-rouge&quot;&gt;PW&lt;/code&gt; throughout the algorithm.&lt;/p&gt;

&lt;p&gt;This is the last of the three differences between today’s development and the
&lt;a href=&quot;/dsp/2017/08/30/cordic.html&quot;&gt;CORDIC agorithm&lt;/a&gt;
we presented last time.  At this point, our development is complete.
As with the basic
&lt;a href=&quot;/dsp/2017/08/30/cordic.html&quot;&gt;CORDIC agorithm&lt;/a&gt;,
this one will also use a
&lt;a href=&quot;https://github.com/ZipCPU/cordic/tree/master/sw&quot;&gt;core generator&lt;/a&gt;–however
the changes necessary to make that
&lt;a href=&quot;https://github.com/ZipCPU/cordic/tree/master/sw&quot;&gt;core generator&lt;/a&gt;–however
work were just presented above.&lt;/p&gt;

&lt;p&gt;Feel free to check out the
&lt;a href=&quot;https://github.com/ZipCPU/cordic/tree/master/sw&quot;&gt;core generator&lt;/a&gt;
as well as the &lt;a href=&quot;https://github.com/ZipCPU/cordic/tree/master/rtl&quot;&gt;examples of the code it
produces&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;Now that we’ve gone through and explained the differences between
the &lt;a href=&quot;/dsp/2017/08/30/cordic.html&quot;&gt;CORDIC rotation agorithm&lt;/a&gt;
and this rectangular to polar converter,
we’ve now finished presenting the basic uses of the
&lt;a href=&quot;https://en.wikipedia.org/wiki/CORDIC&quot;&gt;CORDIC&lt;/a&gt;
algorithm.&lt;/p&gt;

&lt;p&gt;While we haven’t discussed the code generator for this rectangular to polar
converter, it follows from the discussion above.  You can find the &lt;a href=&quot;https://github.com/ZipCPU/cordic/blob/master/sw/topolar.cpp&quot;&gt;completed
core generator on
github&lt;/a&gt;, as
part of the &lt;a href=&quot;https://github.com/ZipCPU/cordic&quot;&gt;CORDIC repository&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;If you refer back to
&lt;a href=&quot;http://www.andraka.com/files/crdcsrvy.pdf&quot;&gt;Ray Andraka’s paper&lt;/a&gt;,
Andraka shows several other uses for a basic
&lt;a href=&quot;https://en.wikipedia.org/wiki/CORDIC&quot;&gt;CORDIC&lt;/a&gt;
algorithmic approach: 
arcsine and arccosine generation, calculating hyperbolic trigonometric
functions and more.  Feel free to do some research should you need algorithms
for any of these other functions.&lt;/p&gt;

&lt;p&gt;Our development, though, is by no means complete.  Our next step in this
development will be to build a test bench for these routines.  We may even
go as far as to connect our sine/cosine generator to an
&lt;a href=&quot;https://store.digilentinc.com/pmod-amp2-audio-amplifier&quot;&gt;audio amplifier&lt;/a&gt;,
but we’ll see how the direction works out.  Our eventual goal, though, is
going to be to use the
&lt;a href=&quot;/dsp/2017/08/30/cordic.html&quot;&gt;sine and cosine generation&lt;/a&gt;
capability of the
&lt;a href=&quot;https://en.wikipedia.org/wiki/CORDIC&quot;&gt;CORDIC&lt;/a&gt;
as part of a test bench for the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;digital filter&lt;/a&gt;s
I’d like to present and demonstrate.&lt;/p&gt;
&lt;hr /&gt;&lt;p&gt;&lt;em&gt;For the eyes of the LORD run to and fro throughout the whole earth, to shew himself strong in the behalf of them whose heart is perfect toward him. Herein thou hast done foolishly: therefore from henceforth thou shalt have wars. (1 Chron 16:9)&lt;/em&gt;</description>
        <pubDate>Fri, 01 Sep 2017 00:00:00 -0400</pubDate>
        <link>http://zipcpu.com/dsp/2017/09/01/topolar.html</link>
        <guid isPermaLink="true">http://zipcpu.com/dsp/2017/09/01/topolar.html</guid>
        
        
        <category>dsp</category>
        
      </item>
    
      <item>
        <title>Using a CORDIC to calculate sines and cosines in an FPGA</title>
        <description>&lt;p&gt;We’ve now presented two separate algorithms that can be used for calculating
a sine wave: a &lt;a href=&quot;/dsp/2017/07/11/simplest-sinewave-generator.html&quot;&gt;very simple sinewave table
lookup&lt;/a&gt;,
and a &lt;a href=&quot;/dsp/2017/08/26/quarterwave.html&quot;&gt;more complicated quarter-wave table lookup
method&lt;/a&gt;.  Both of these
approaches used only a minimum number of clocks, although their precision
was somewhat limited.&lt;/p&gt;

&lt;p&gt;Today, let’s look at how to implement a
&lt;a href=&quot;https://en.wikipedia.org/wiki/CORDIC&quot;&gt;&lt;strong&gt;CO&lt;/strong&gt;ordinate &lt;strong&gt;R&lt;/strong&gt;otation &lt;strong&gt;DI&lt;/strong&gt;gital &lt;strong&gt;C&lt;/strong&gt;omputer
(CORDIC)&lt;/a&gt;
algorithm within an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;.&lt;/p&gt;

&lt;table style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 1: The CORDIC problem description&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/cordic-problem-setup.svg&quot; alt=&quot;Setting up a CORDIC&quot; width=&quot;320&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;If you’ve never worked with a
&lt;a href=&quot;https://en.wikipedia.org/wiki/CORDIC&quot;&gt;CORDIC&lt;/a&gt;
algorithm before, the algorithms are all
based around specific
&lt;a href=&quot;https://en.wikipedia.org/wiki/Rotation_matrix&quot;&gt;rotation matrices&lt;/a&gt;
which we will explain first.  These rotation matrices can be strung together
to accomplish many digital logic purposes.  For today’s discussion, though,
we will be rotating a two-dimensional vector by a requested counter-clockwise
angle.  Thus, the inputs will be x and y values, &lt;code class=&quot;highlighter-rouge&quot;&gt;i_xval&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;i_yval&lt;/code&gt;,
together with a requested phase rotation, &lt;code class=&quot;highlighter-rouge&quot;&gt;i_phase&lt;/code&gt;, whereas the outputs
will just be a rotated x and y value, &lt;code class=&quot;highlighter-rouge&quot;&gt;o_xval&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;o_yval&lt;/code&gt;–as shown in
Fig 1.&lt;/p&gt;

&lt;h1 id=&quot;the-cordic-rotation&quot;&gt;The CORDIC rotation&lt;/h1&gt;

&lt;p&gt;But, just what is a
&lt;a href=&quot;https://en.wikipedia.org/wiki/CORDIC&quot;&gt;CORDIC&lt;/a&gt;
rotation?  Well, since all of these algorithms are built around a
&lt;a href=&quot;https://en.wikipedia.org/wiki/CORDIC&quot;&gt;CORDIC&lt;/a&gt;
rotation, let’s start by answering that question.  We’ll start with the
concept of a simple two-dimensional
&lt;a href=&quot;https://en.wikipedia.org/wiki/Rotation_matrix&quot;&gt;rotation matrix&lt;/a&gt;,
and then work from there to how that can be turned into a
&lt;a href=&quot;https://en.wikipedia.org/wiki/CORDIC&quot;&gt;CORDIC&lt;/a&gt;
rotation.&lt;/p&gt;

&lt;p&gt;A simple two-dimensional
&lt;a href=&quot;https://en.wikipedia.org/wiki/Rotation_matrix&quot;&gt;rotation matrix&lt;/a&gt;
is given by:&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/eqn-2d-rotation.png&quot; alt=&quot;Equation for a 2D rotation&quot; width=&quot;302&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;This rotation can be used to rotate a complex vector &lt;code class=&quot;highlighter-rouge&quot;&gt;exp(j*phi)&lt;/code&gt; and turn it
into another one, &lt;code class=&quot;highlighter-rouge&quot;&gt;exp(j*(phi+theta))&lt;/code&gt;, if the real value is the first value
in the given vector, and the would-be imaginary value the second (i.e. strip off
the &lt;code class=&quot;highlighter-rouge&quot;&gt;j&lt;/code&gt;).  Further, if the original vector is
simply the real number one, &lt;code class=&quot;highlighter-rouge&quot;&gt;1+j0&lt;/code&gt;, then we will have just created
&lt;code class=&quot;highlighter-rouge&quot;&gt;sin(theta)&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;cos(theta)&lt;/code&gt; in this process.&lt;/p&gt;

&lt;p&gt;This is what we are going to try to do: apply a rotation like this one.&lt;/p&gt;

&lt;p&gt;We could apply this rotation using &lt;a href=&quot;/dsp/2017/06/15/no-pi-for-you.html&quot;&gt;angles more
suited&lt;/a&gt;
for an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;,&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/eqn-no-pi-rotation.png&quot; alt=&quot;Eqn for a 2D rotation in FPGA units&quot; width=&quot;364&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;but this still leaves us with the problem that the sine and cosine aren’t
easy to calculate, leaving this rotation difficult to accomplish.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 1: CORDIC Rotation Vectors&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/cordic-rotations.svg&quot; alt=&quot;Cordic rotation vectors&quot; width=&quot;240&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;The
&lt;a href=&quot;https://en.wikipedia.org/wiki/CORDIC&quot;&gt;CORDIC&lt;/a&gt;
approach is to replace the cosine portion of this rotation matrix with a &lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt;,
and the sine portion with a &lt;code class=&quot;highlighter-rouge&quot;&gt;2^-k&lt;/code&gt;.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/eqn-bare-cordic-transform.png&quot; alt=&quot;EQN for a bare cordic stage&quot; width=&quot;281&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;You can think of this as a series of complex rotation vectors,
indexed by &lt;code class=&quot;highlighter-rouge&quot;&gt;k&lt;/code&gt;, such as those are shown in Fig 1.  Notice from the figure
that these vectors are not on the unit circle, but rather just outside the
unit circle, and they get closer and closer to the unit circle the higher
&lt;code class=&quot;highlighter-rouge&quot;&gt;k&lt;/code&gt; becomes.&lt;/p&gt;

&lt;p&gt;In other words, &lt;code class=&quot;highlighter-rouge&quot;&gt;T&lt;/code&gt; is approximately a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Rotation_matrix&quot;&gt;rotation matrix&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;T&lt;/code&gt; is also something that is easy to calculate within an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;.
It requires only adds, subtracts, and shifts.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/eqn-cordic-eqns.png&quot; alt=&quot;Cordic equations&quot; width=&quot;350&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;This can all be done with simple integer math–no multiplies or divides are
required.&lt;/p&gt;

&lt;p&gt;Of course, this transform is not a true rotation matrix.  Instead, it is a
scaled &lt;a href=&quot;https://en.wikipedia.org/wiki/Rotation_matrix&quot;&gt;rotation matrix&lt;/a&gt;.
To see this, first calculate the angles of the vectors in Fig 1 above:&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/eqn-cordic-phase.png&quot; alt=&quot;Cordic rotation phase&quot; width=&quot;168&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Then also calculate and normalize by their their lengths.  The resulting
transform, &lt;code class=&quot;highlighter-rouge&quot;&gt;T&lt;/code&gt;, is shown below:&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/eqn-cordic-transform-simplified.png&quot; alt=&quot;Eqn for the cordic stage, after simplification&quot; width=&quot;459&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;From here you can see that this is most definitely a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Rotation_matrix&quot;&gt;rotation matrix&lt;/a&gt;
with an amplitude increase associated with it.&lt;/p&gt;

&lt;p&gt;Further, as you may have guessed from Fig 1 above, we can apply a similar
rotation going in the opposite direction:&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/eqn-cordic-negative-transform.png&quot; alt=&quot;Eqn for the cordic stage, negated angle, after simplification&quot; width=&quot;459&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;These two (nearly) &lt;a href=&quot;https://en.wikipedia.org/wiki/Rotation_matrix&quot;&gt;rotation
matrices&lt;/a&gt;
form the basis of the
&lt;a href=&quot;https://en.wikipedia.org/wiki/CORDIC&quot;&gt;CORDIC&lt;/a&gt;
algorithm.&lt;/p&gt;

&lt;p&gt;The basic idea behind the
&lt;a href=&quot;https://en.wikipedia.org/wiki/CORDIC&quot;&gt;CORDIC&lt;/a&gt;
algorithm is that we can string many of these
&lt;a href=&quot;https://en.wikipedia.org/wiki/Rotation_matrix&quot;&gt;rotation matrices&lt;/a&gt;
together–either rotating by a positive &lt;code class=&quot;highlighter-rouge&quot;&gt;theta_k&lt;/code&gt; or a
negative &lt;code class=&quot;highlighter-rouge&quot;&gt;theta_k&lt;/code&gt; in each matrix.  As an example, suppose you rotated
[1, 0] by +26.57 degrees (k=1), then by 14.03 degrees (k=2), then backwards
by 7.12 degrees (k=3).  You would then
have a vector that has been rotated by 30.48 degrees.  Other than
the slight amplitude increase, that means that your resulting vector now
approximates a thirty degree phasor–and you didn’t have to do anything that
significant to get there.&lt;/p&gt;

&lt;p&gt;Further, the more of these rotation matrices you string together, the smaller
the remaining rotation becomes, and hence the closer the result will come
(in angular distance) to any desired rotation.&lt;/p&gt;

&lt;p&gt;This is what we are going to try to build today.&lt;/p&gt;

&lt;h2 id=&quot;rotating-into-range&quot;&gt;Rotating into range&lt;/h2&gt;

&lt;p&gt;The first step in building this rotation, though, is that massage the problem
so that the rotation desired is less than 45 degrees.  This comes from the
fact that the largest rotation the
&lt;a href=&quot;https://en.wikipedia.org/wiki/CORDIC&quot;&gt;CORDIC&lt;/a&gt;
rotation above can accomplish is a 45 degree rotation.  Angles beyond
45 degrees just get smaller.  Therefore, the
&lt;a href=&quot;https://en.wikipedia.org/wiki/CORDIC&quot;&gt;CORDIC&lt;/a&gt;
rotation requires an initial angular request, &lt;code class=&quot;highlighter-rouge&quot;&gt;i_phase&lt;/code&gt;, to be less than 45
degrees.  Our first problem, therefore is going to be rotating our incoming
vector so that any remaining rotation amount is 45 degrees or less.&lt;/p&gt;

&lt;p&gt;As a preliminary step, we’ll start our algorithm off by expanding the two
input values from their initial width, &lt;code class=&quot;highlighter-rouge&quot;&gt;IW&lt;/code&gt;, to a wider working width, &lt;code class=&quot;highlighter-rouge&quot;&gt;WW&lt;/code&gt;.
Because the
&lt;a href=&quot;https://en.wikipedia.org/wiki/CORDIC&quot;&gt;CORDIC&lt;/a&gt;
algorithm will also increase the magnitude of the input, this process adds one
more bit on the left–to allow for a touch of width expansion.  It also adds
a user selectable number of bits (captured as part of &lt;code class=&quot;highlighter-rouge&quot;&gt;WW&lt;/code&gt;) to the right so as
to minimize any distortion’s caused by
&lt;a href=&quot;/dsp/2017/07/22/rounding.html&quot;&gt;truncation effects&lt;/a&gt;
within the rotation.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;wire	signed [(WW-1):0]	e_xval, e_yval;
assign	e_xval = { {i_xval[(IW-1)]}, i_xval, {(WW-IW-1){1&#39;b0}} };
assign	e_yval = { {i_yval[(IW-1)]}, i_yval, {(WW-IW-1){1&#39;b0}} };&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Further, we’re going to declare our intermediate values
to be an array of &lt;code class=&quot;highlighter-rouge&quot;&gt;WW&lt;/code&gt; bits each for the intermediate &lt;code class=&quot;highlighter-rouge&quot;&gt;xv&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;yv&lt;/code&gt; values,
and an array of phase width, &lt;code class=&quot;highlighter-rouge&quot;&gt;PW&lt;/code&gt;, number of bits for the phase.  Since the
&lt;a href=&quot;https://en.wikipedia.org/wiki/CORDIC&quot;&gt;CORDIC&lt;/a&gt;
operation takes place in stages, we’ll declare &lt;code class=&quot;highlighter-rouge&quot;&gt;NSTAGES+1&lt;/code&gt; of these
values–that will create variables to hold not only the input values,
but the outputs as well.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;// Declare variables for all of the separate stages
reg	signed	[(WW-1):0]	xv	[0:(NSTAGES)];
reg	signed	[(WW-1):0]	yv	[0:(NSTAGES)];
reg		[(PW-1):0]	ph	[0:(NSTAGES)];&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The beginner needs to understand that this is not the definition of a memory,
although it might look very similar to a block RAM definition.  Rather, this
is a simplified definition of &lt;code class=&quot;highlighter-rouge&quot;&gt;NSTAGES&lt;/code&gt; of values in flip-flops.&lt;/p&gt;

&lt;p&gt;Declarations aside, that brings us to the actual logic of the
pre-&lt;a href=&quot;https://en.wikipedia.org/wiki/CORDIC&quot;&gt;CORDIC&lt;/a&gt;
section.  The goal of this section is to rotate the input by some number
of ninety-degree intervals until the remaining phase is between -45 and 45.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 2: Initial rotation&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/cordic-prerotation.svg&quot; alt=&quot;Result of the pre-CORDIC rotation&quot; width=&quot;420&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Since this is a signal processing algorithm, the “global CE” &lt;a href=&quot;/blog/2017/08/14/strategies-for-pipelining.html&quot;&gt;pipeline
strategy&lt;/a&gt;
may make the most sense.  We’ll also create logic for the &lt;a href=&quot;/blog/2017/08/14/strategies-for-pipelining.html&quot;&gt;traveling CE strategy
strategy&lt;/a&gt;
later.  For now, remember that the global CE strategy requires that nothing
changes unless a CE line is true.  Therefore, our transform begins by
checking the &lt;code class=&quot;highlighter-rouge&quot;&gt;i_ce&lt;/code&gt; line.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
if (i_ce)&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Next, we’ll want to walk through the actual rotations.&lt;/p&gt;

&lt;table style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 3: Rotation by quadrant&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/cordic-prequadrants.svg&quot; alt=&quot;Split the pre-rotation up by quadrant&quot; width=&quot;280&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;In order to get 
everything into +/- 45 degrees, we’ll want to check not only which quadrant
our phase request is within, but also which 45 degree segment of that quadrant
the angle is in, as shown in Fig 3.
Hence, we’ll check the top three bits of &lt;code class=&quot;highlighter-rouge&quot;&gt;i_phase&lt;/code&gt;, and apply a rotation
based upon them.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	case(i_phase[(PW-1):(PW-3)])&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Each rotation opportunity will set &lt;code class=&quot;highlighter-rouge&quot;&gt;xv[0]&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;yv[0]&lt;/code&gt;, and &lt;code class=&quot;highlighter-rouge&quot;&gt;ph[0]&lt;/code&gt;.  These are
the initial values of x, y, and the remaining phase to rotate through.  The
options for &lt;code class=&quot;highlighter-rouge&quot;&gt;xv[0]&lt;/code&gt; are &lt;code class=&quot;highlighter-rouge&quot;&gt;+/- e_xval&lt;/code&gt; or &lt;code class=&quot;highlighter-rouge&quot;&gt;+/- e_yval&lt;/code&gt; and likewise for &lt;code class=&quot;highlighter-rouge&quot;&gt;yv[0]&lt;/code&gt;.
Further, because these rotations are all by multiples of ninety degrees,
there’s no need to do any additions.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	3&#39;b000: begin	// 0 .. 45, No change
		xv[0] &amp;lt;= e_xval;
		yv[0] &amp;lt;= e_yval;
		ph[0] &amp;lt;= i_phase;
		end
	3&#39;b001: begin	// 45 .. 90
		xv[0] &amp;lt;= -e_yval;
		yv[0] &amp;lt;= e_xval;
		ph[0] &amp;lt;= i_phase - 18&#39;h10000;
		end
	3&#39;b010: begin	// 90 .. 135
		xv[0] &amp;lt;= -e_yval;
		yv[0] &amp;lt;= e_xval;
		ph[0] &amp;lt;= i_phase - 18&#39;h10000;
		end
	3&#39;b011: begin	// 135 .. 180
		xv[0] &amp;lt;= -e_xval;
		yv[0] &amp;lt;= -e_yval;
		ph[0] &amp;lt;= i_phase - 18&#39;h20000;
		end
	3&#39;b100: begin	// 180 .. 225
		xv[0] &amp;lt;= -e_xval;
		yv[0] &amp;lt;= -e_yval;
		ph[0] &amp;lt;= i_phase - 18&#39;h20000;
		end
	3&#39;b101: begin	// 225 .. 270
		xv[0] &amp;lt;= e_yval;
		yv[0] &amp;lt;= -e_xval;
		ph[0] &amp;lt;= i_phase - 18&#39;h30000;
		end
	3&#39;b110: begin	// 270 .. 315
		xv[0] &amp;lt;= e_yval;
		yv[0] &amp;lt;= -e_xval;
		ph[0] &amp;lt;= i_phase - 18&#39;h30000;
		end
	3&#39;b111: begin	// 315 .. 360, No change
		xv[0] &amp;lt;= e_xval;
		yv[0] &amp;lt;= e_yval;
		ph[0] &amp;lt;= i_phase;
		end
	endcase&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Remember: we are rotating the &lt;code class=&quot;highlighter-rouge&quot;&gt;xv&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;yv&lt;/code&gt; vector counter-clockwise, so
that the rotation remaining, &lt;code class=&quot;highlighter-rouge&quot;&gt;ph&lt;/code&gt;, is less than &lt;code class=&quot;highlighter-rouge&quot;&gt;+/- 45&lt;/code&gt; degrees.  Hence we
are rotating &lt;code class=&quot;highlighter-rouge&quot;&gt;xv&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;yv&lt;/code&gt; in a counter-clockwise direction, while the
remaining phase angle will decrease in what will look like a clock-wise
direction.&lt;/p&gt;

&lt;p&gt;This sets up the actual
&lt;a href=&quot;https://en.wikipedia.org/wiki/CORDIC&quot;&gt;CORDIC&lt;/a&gt;:
&lt;code class=&quot;highlighter-rouge&quot;&gt;xv[0]&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;yv[0]&lt;/code&gt; now need to be rotated
through &lt;code class=&quot;highlighter-rouge&quot;&gt;ph[0]&lt;/code&gt; remaining &lt;a href=&quot;/dsp/2017/06/15/no-pi-for-you.html&quot;&gt;angular
units&lt;/a&gt;.  We’ve also
guaranteed that &lt;code class=&quot;highlighter-rouge&quot;&gt;|ph[0]|&lt;/code&gt; is less than or equal to 45 degrees.&lt;/p&gt;

&lt;h2 id=&quot;rotating-to-zero&quot;&gt;Rotating to zero&lt;/h2&gt;

&lt;p&gt;The next step is to rotate the &lt;code class=&quot;highlighter-rouge&quot;&gt;xv[0]&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;yv[0]&lt;/code&gt; values through the remaining
phase angle, &lt;code class=&quot;highlighter-rouge&quot;&gt;ph[0]&lt;/code&gt;.  To do this, we’re going to check whether or not the
remaining phase is negative or positive.  If the phase is negative, we’ll
rotate by a positive &lt;code class=&quot;highlighter-rouge&quot;&gt;cordic_angle[i]&lt;/code&gt;.  If the remaining phase is positive,
we’ll rotate in the opposite direction but by the same amount.&lt;/p&gt;

&lt;p&gt;Software programmers like to look at &lt;code class=&quot;highlighter-rouge&quot;&gt;for&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;while&lt;/code&gt; loops in Verilog and
think of them like their &lt;code class=&quot;highlighter-rouge&quot;&gt;for&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;while&lt;/code&gt; counterparts in software.  HDL
loops, however, are &lt;em&gt;nothing&lt;/em&gt; like software loops.  Software loops repeat the
same instruction, one after another in time.  HDL loops on the other hand
repeat the instruction in space on the chip by creating multiple copies of
the same logic, all of which will be executed in parallel.&lt;/p&gt;

&lt;p&gt;This is one of those rare cases where a &lt;code class=&quot;highlighter-rouge&quot;&gt;for&lt;/code&gt; loop makes sense in Verilog.  The
&lt;a href=&quot;https://en.wikipedia.org/wiki/CORDIC&quot;&gt;CORDIC&lt;/a&gt;
algorithm repeats nearly the same logic &lt;code class=&quot;highlighter-rouge&quot;&gt;NSTAGES&lt;/code&gt; times over.  Hence, this
loop generates &lt;code class=&quot;highlighter-rouge&quot;&gt;NSTAGES&lt;/code&gt; pieces of logic, each of which advances the
prior stage by one clock.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;genvar	i;
generate for(i=0; i&amp;lt;NSTAGES; i=i+1) begin : CORDICops&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Within this for loop, we’ll create several always blocks.  Each block
first makes sure that nothing changes, except when the global CE signal, &lt;code class=&quot;highlighter-rouge&quot;&gt;i_ce&lt;/code&gt;
is high.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(posedge i_clk)
	// Reset logic can be placed here, but it isnt required
	if (i_ce)
	begin&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Once these last preliminaries have been taken care of, we can finally apply the
&lt;a href=&quot;https://en.wikipedia.org/wiki/CORDIC&quot;&gt;CORDIC&lt;/a&gt;
rotation/transform.
Note that we first check the sign of the remaining phase to know which
direction to rotate, but otherwise the operations you see here should match
the transform we discussed earlier.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;		// You can check for cord[i] == 0 here if you would like
		if (ph[i][(PW-1)]) // Negative phase
		begin
			// If the phase is negative, rotate by the
			// CORDIC angle in a clockwise direction.
			xv[i+1] &amp;lt;= xv[i] + (yv[i]&amp;gt;&amp;gt;&amp;gt;(i+1));
			yv[i+1] &amp;lt;= yv[i] - (xv[i]&amp;gt;&amp;gt;&amp;gt;(i+1));
			ph[i+1] &amp;lt;= ph[i] + cordic_angle[i];

		end else begin
			// On the other hand, if the phase is
			// positive ... rotate in the
			// counter-clockwise direction
			xv[i+1] &amp;lt;= xv[i] - (yv[i]&amp;gt;&amp;gt;&amp;gt;(i+1));
			yv[i+1] &amp;lt;= yv[i] + (xv[i]&amp;gt;&amp;gt;&amp;gt;(i+1));
			ph[i+1] &amp;lt;= ph[i] - cordic_angle[i];

		end
	end
endgenerate&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;While this is the core of the
&lt;a href=&quot;https://en.wikipedia.org/wiki/CORDIC&quot;&gt;CORDIC&lt;/a&gt;
algorithm, now that we have put it together we are by no means done.  We still
need to generate the &lt;a href=&quot;https://en.wikipedia.org/wiki/CORDIC&quot;&gt;CORDIC&lt;/a&gt;
angles, listed as array elements of &lt;code class=&quot;highlighter-rouge&quot;&gt;cordic_angle&lt;/code&gt; above, any traveling
CE &lt;a href=&quot;/blog/2017/08/14/strategies-for-pipelining.html&quot;&gt;pipeline
logic&lt;/a&gt;,
&lt;a href=&quot;/dsp/2017/07/22/rounding.html&quot;&gt;drop any excess bits&lt;/a&gt;
we’ve accumulated,
and figure out what the gain of the algorithm is in case we wish to compensate
for it.&lt;/p&gt;

&lt;h2 id=&quot;using-a-core-generator-in-c-to-get-the-angles&quot;&gt;Using a core-generator in C++ to get the angles&lt;/h2&gt;

&lt;p&gt;One difficulty associated with building a “generic”
&lt;a href=&quot;https://en.wikipedia.org/wiki/CORDIC&quot;&gt;CORDIC&lt;/a&gt;
HDL core is that some of the components of the core cannot be generalized
very easily.  A good example of this problem is the VHDL
&lt;a href=&quot;https://en.wikipedia.org/wiki/CORDIC&quot;&gt;CORDIC&lt;/a&gt;
&lt;a href=&quot;http://github.com/freecores/cordic/blob/master/polar2rect/p2r_Cordic_pipe.vhd&quot;&gt;core&lt;/a&gt; found on
&lt;a href=&quot;http://opencores.org/project,cordic&quot;&gt;OpenCores&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://github.com/freecores/cordic/blob/master/polar2rect/p2r_Cordic_pipe.vhd&quot;&gt;This open-cores
core&lt;/a&gt;
is built with a fixed precision.  While the data width can ostensibly be
adjusted, there are a fixed number of internal arc-tangent results, each created
with a fixed width and a fixed value.  (Well, that and you can’t &lt;a href=&quot;/blog/2017/06/21/looking-at-verilator.html&quot;&gt;simulate the
core&lt;/a&gt; within
&lt;a href=&quot;https://www.veripool.org/wiki/verilator&quot;&gt;Verilator&lt;/a&gt; because someone chose to
write it within &lt;em&gt;VHDL&lt;/em&gt;.)  The only way to prevent this bit-width problem
associated with a one-size fits all solution is to
use a software program, sometimes called a core generator or
&lt;a href=&quot;https://www.xilinx.com/products/design-tools/coregen.html&quot;&gt;coregen&lt;/a&gt;, to
tailor the &lt;a href=&quot;https://en.wikipedia.org/wiki/CORDIC&quot;&gt;CORDIC&lt;/a&gt;
to a specifically requested precision.  This piece of software needs to
calculate the phase rotation angles.  We’ll also use the software to calculate
the required number of stages, the number of input or output bits required,
the number of phase bits, etc., etc.&lt;/p&gt;

&lt;p&gt;Such a core generator will be our approach
&lt;a href=&quot;https://github.com/ZipCPU/cordic/tree/master/sw&quot;&gt;here&lt;/a&gt;.  You can find the
basic &lt;a href=&quot;https://github.com/ZipCPU/cordic/blob/master/sw/basiccordic.v&quot;&gt;core generator
here&lt;/a&gt;,
within my &lt;a href=&quot;https://github.com/ZipCPU/cordic&quot;&gt;cordic repository&lt;/a&gt;.
For now, let’s discuss calculating the
&lt;a href=&quot;https://en.wikipedia.org/wiki/CORDIC&quot;&gt;CORDIC&lt;/a&gt;
angles.&lt;/p&gt;

&lt;p&gt;Starting from above, the cordic angles are defined as&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/eqn-cordic-phase.png&quot; alt=&quot;Cordic rotation phase&quot; width=&quot;168&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;but in our &lt;a href=&quot;/dsp/2017/06/15/no-pi-for-you.html&quot;&gt;normalized integer units of
phase&lt;/a&gt;,
the value we will want is going to be&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/eqn-cordic-tblangle.png&quot; alt=&quot;Cordic rotation phase&quot; width=&quot;342&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;This value can easily be computed in C++ or any other higher level language
for that matter.  We’ll use C++ for this exercise.&lt;/p&gt;

&lt;p&gt;We’ll need to calculate one angle for each of the
&lt;a href=&quot;https://en.wikipedia.org/wiki/CORDIC&quot;&gt;CORDIC&lt;/a&gt;
stages.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;for(unsigned k=0; k&amp;lt;(unsigned)nstages; k++) {
	double		x, deg;
	unsigned	phase_value;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The angle is given by the arctangent of our rotation vector, &lt;code class=&quot;highlighter-rouge&quot;&gt;1+j2^-k&lt;/code&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	x = atan2(1., pow(2,k));&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;(Remember, atan2 accepts the y argument first.  Hence our arguments of
&lt;code class=&quot;highlighter-rouge&quot;&gt;x=2^k&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;y=1&lt;/code&gt; represent an equivalent representation to our angle of
interest.)&lt;/p&gt;

&lt;p&gt;We’ll keep track of the value of this angle in degrees as well as
&lt;a href=&quot;/dsp/2017/06/15/no-pi-for-you.html&quot;&gt;FPGA units&lt;/a&gt;,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	deg = x * 180.0 / M_PI;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;For all other purposes, though, we’ll convert our angle to a &lt;a href=&quot;/dsp/2017/06/15/no-pi-for-you.html&quot;&gt;normalized
integer phase&lt;/a&gt;,
value we can use in an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
algorithm,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	x *= (4.0 * (1ul&amp;lt;&amp;lt;(phase_bits-2))) / (M_PI * 2.0);
	phase_value = (unsigned)x;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;We can then print this value to our resulting Verilog file.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	fprintf(fp, &quot;\tassign\tcordic_angle[%2d] = %2d\&#39;h%0*x; //%11.6f deg\n&quot;,
		k, phase_bits, (phase_bits+3)/4, phase_value,
		deg);
}&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;(I know this is the old-style C I/O — while I’ve used the C++ I/O, I’ve
never really fallen in-love with it.)&lt;/p&gt;

&lt;p&gt;After applying this calculation to a problem set with an &lt;code class=&quot;highlighter-rouge&quot;&gt;18-bit&lt;/code&gt; phase
requirement, the code above generated the following table,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;assign	cordic_angle[ 0] = 18&#39;h0_4b90; //  26.565051 deg
assign	cordic_angle[ 1] = 18&#39;h0_27ec; //  14.036243 deg
assign	cordic_angle[ 2] = 18&#39;h0_1444; //   7.125016 deg
assign	cordic_angle[ 3] = 18&#39;h0_0a2c; //   3.576334 deg
assign	cordic_angle[ 4] = 18&#39;h0_0517; //   1.789911 deg
assign	cordic_angle[ 5] = 18&#39;h0_028b; //   0.895174 deg
assign	cordic_angle[ 6] = 18&#39;h0_0145; //   0.447614 deg
assign	cordic_angle[ 7] = 18&#39;h0_00a2; //   0.223811 deg
assign	cordic_angle[ 8] = 18&#39;h0_0051; //   0.111906 deg
assign	cordic_angle[ 9] = 18&#39;h0_0028; //   0.055953 deg
assign	cordic_angle[10] = 18&#39;h0_0014; //   0.027976 deg
assign	cordic_angle[11] = 18&#39;h0_000a; //   0.013988 deg
assign	cordic_angle[12] = 18&#39;h0_0005; //   0.006994 deg
assign	cordic_angle[13] = 18&#39;h0_0002; //   0.003497 deg&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The number of stages and the number of bits in each stage can both be defined
based upon arguments to the &lt;a href=&quot;https://github.com/ZipCPU/cordic/blob/master/sw/main.cpp&quot;&gt;core generator
program&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;We still have several steps remaining.  In particular, we need to set up the
“traveling CE” &lt;a href=&quot;/blog/2017/08/14/strategies-for-pipelining.html&quot;&gt;pipeline strategy
logic&lt;/a&gt;,
&lt;a href=&quot;/dsp/2017/07/22/rounding.html&quot;&gt;round&lt;/a&gt;
the final result, and discuss on how to deal with
the amplitude distortion produced by the
&lt;a href=&quot;https://en.wikipedia.org/wiki/CORDIC&quot;&gt;CORDIC&lt;/a&gt;
algorithm.&lt;/p&gt;

&lt;h2 id=&quot;auxiliary-logic&quot;&gt;Auxiliary Logic&lt;/h2&gt;

&lt;p&gt;I mentioned earlier that we could use the “traveling CE” &lt;a href=&quot;/blog/2017/08/14/strategies-for-pipelining.html&quot;&gt;pipeline
strategy&lt;/a&gt;
if desired.  That strategy requires that for every strobe input, the output
associated with that input also needs to have a high strobe output.&lt;/p&gt;

&lt;p&gt;We’ll use our C++ code to build this as well, since in C++ we have control
over when to place this logic into the code, as well as how much of this
logic needs to be placed into
&lt;a href=&quot;https://github.com/ZipCPU/cordic/blob/master/rtl/cordic.v&quot;&gt;our core&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;To do this, we’ll teach the &lt;a href=&quot;https://github.com/ZipCPU/cordic/blob/master/sw/main.cpp&quot;&gt;main core generator
program&lt;/a&gt;
to accept a &lt;code class=&quot;highlighter-rouge&quot;&gt;-a&lt;/code&gt; option.  We’ll then use this to create an &lt;code class=&quot;highlighter-rouge&quot;&gt;aux&lt;/code&gt;iliary bit
to contain the “traveling CE” bit.&lt;/p&gt;

&lt;p&gt;The actual logic required to implement this “traveling CE” is just a simple
shift register:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	if (i_reset)
		ax &amp;lt;= {(NSTAGES+1){1&#39;b0}};
	else if (i_ce)
		ax &amp;lt;= { ax[(NSTAGES-1):0], i_aux };

always @(posedge i_clk)
	o_aux &amp;lt;= ax[NSTAGES];&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Were we to get rid of the reset, then all of this logic could fit within
one shift register logic block on a 7-Series Xilinx
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;.
With the reset, this will require 1-FF per stage.&lt;/p&gt;

&lt;p&gt;Placing this logic within the core generator makes certain that no matter
what logic takes place within the core, the output &lt;code class=&quot;highlighter-rouge&quot;&gt;o_aux&lt;/code&gt; bit remains lined
up with the output data associated with any input data that had the &lt;code class=&quot;highlighter-rouge&quot;&gt;i_aux&lt;/code&gt;
bit.&lt;/p&gt;

&lt;h2 id=&quot;dropping-the-last-number-of-bits&quot;&gt;Dropping the last number of bits&lt;/h2&gt;

&lt;p&gt;When we get to the end, we’ll want to drop some bits.  We
&lt;a href=&quot;/dsp/2017/07/22/rounding.html&quot;&gt;discussed some time ago&lt;/a&gt;
how to go about this via
&lt;a href=&quot;/dsp/2017/07/22/rounding.html&quot;&gt;rounding&lt;/a&gt;.  We also discussed
several different types of
&lt;a href=&quot;/dsp/2017/07/22/rounding.html&quot;&gt;rounding&lt;/a&gt; at that same time.
Here, we follow the convergent rounding approach to drop any excess bits.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	// Round our result towards even
	wire	[(WW-1):0]	pre_xval, pre_yval;

	assign	pre_xval = xv[NSTAGES] + ,
				xv[NSTAGES][(WW-OW)],
				{(WW-OW-1){!xv[NSTAGES][WW-OW]}}};
	assign	pre_yval = yv[NSTAGES] + ,
				yv[NSTAGES][(WW-OW)],
				{(WW-OW-1){!yv[NSTAGES][WW-OW]}}};

	always @(posedge i_clk)
	begin
		o_xval &amp;lt;= pre_xval[(WW-1):(WW-OW)];
		o_yval &amp;lt;= pre_yval[(WW-1):(WW-OW)];
	end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;That marks the end of our basic
&lt;a href=&quot;https://en.wikipedia.org/wiki/CORDIC&quot;&gt;CORDIC&lt;/a&gt;
algorithm.  We still need to discuss what to do about the amplitude
gain we’ve accumulated, so that will be next.&lt;/p&gt;

&lt;h2 id=&quot;dealing-with-amplitude&quot;&gt;Dealing with Amplitude&lt;/h2&gt;

&lt;p&gt;As you’ll recall from the beginning of our discussion, the
&lt;a href=&quot;https://en.wikipedia.org/wiki/CORDIC&quot;&gt;CORDIC&lt;/a&gt;
algorithm has a gain associated with it.  Our task here will be to calculate
that gain.  We’ll do this within our C++ generator program, since it has
all the details and capability to do so.&lt;/p&gt;

&lt;p&gt;Below is a copy of the &lt;a href=&quot;https://github.com/ZipCPU/cordic/blob/master/sw/cordiclib.cpp&quot;&gt;C++ code used to calculate the cordic
gain&lt;/a&gt;.
It basically calculates the product of all of the gains of the various
stages in our algorithm.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt;	&lt;span class=&quot;nf&quot;&gt;cordic_gain&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nstages&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;phase_bits&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;gain&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;1.0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

	&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nstages&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt;		&lt;span class=&quot;n&quot;&gt;dgain&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

		&lt;span class=&quot;n&quot;&gt;dgain&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;1.0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pow&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;2.0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;2.&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;dgain&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sqrt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dgain&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;gain&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;gain&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dgain&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

	&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;gain&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This, however, only tells us how much gain will be applied to our input.  That
is, it quantifies our amplitude distortion.  We’ll capture this with a
comment line added to the end of the list of &lt;code class=&quot;highlighter-rouge&quot;&gt;cordic_angles&lt;/code&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;// Gain is 1.646760&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Not all applications need gain compensation.  Some can ignore the
gain.  In the case of those applications, the task is done.&lt;/p&gt;

&lt;p&gt;Other applications use a
CORDIC
for calculating sines and cosines.  These applications would nominally send
&lt;code class=&quot;highlighter-rouge&quot;&gt;(1,0)&lt;/code&gt; into the algorithm as an input.  For these applications, the way to
compensate for the gain is to send a different number as an input.  Instead
of &lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt; (or really &lt;code class=&quot;highlighter-rouge&quot;&gt;2^n&lt;/code&gt; for an &lt;code class=&quot;highlighter-rouge&quot;&gt;n&lt;/code&gt;-bit input), these algorithms will want
to send one divided by the gain into the algorithm.  If we calculate the
right constant to replace the &lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt; with, then we still won’t need any
multiplies.  To help you figure this out, the algorithm calculates
&lt;code class=&quot;highlighter-rouge&quot;&gt;2^32/cordic_gain&lt;/code&gt;, and places this into the comments following the
calculation of the &lt;code class=&quot;highlighter-rouge&quot;&gt;cordic_angle&lt;/code&gt;s as well.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;// You can annihilate this gain by multiplying by 32&#39;h9b74edae
// and right shifting by 32 bits.&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;That allows you to pick the number of most-significant bits that you need,
for the precision you want.&lt;/p&gt;

&lt;p&gt;Other applications use the
CORDIC
to actually rotate the input vector.  For these applications, the same
32-bit value can be used as an annihilator, post
CORDIC
application.  If you multiply by this annihilator, and shift right, then the
CORDIC
gain will be removed.&lt;/p&gt;

&lt;h2 id=&quot;conclusions&quot;&gt;Conclusions&lt;/h2&gt;

&lt;p&gt;Now that you’ve seen what goes into making a working
&lt;a href=&quot;https://en.wikipedia.org/wiki/CORDIC&quot;&gt;CORDIC&lt;/a&gt;
core, perhaps you are as amazed as I am at how many parts and pieces this
&lt;em&gt;simple&lt;/em&gt; sine and cosine wave generator has.  We started out by discussing the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Rotation_matrix&quot;&gt;rotation matrices&lt;/a&gt;
used by the
&lt;a href=&quot;https://en.wikipedia.org/wiki/CORDIC&quot;&gt;CORDIC&lt;/a&gt;
algorithm.  This is usually where most academic
&lt;a href=&quot;https://en.wikipedia.org/wiki/CORDIC&quot;&gt;CORDIC&lt;/a&gt;
development’s stop.&lt;/p&gt;

&lt;p&gt;However, when you want to make a working
&lt;a href=&quot;https://en.wikipedia.org/wiki/CORDIC&quot;&gt;CORDIC&lt;/a&gt;
core, you have to go further.  You need to rotate the original vector by
some multiple of ninety degree angles until the remaining rotation angle is
less than forty five degrees.  Only then can you apply the
&lt;a href=&quot;https://en.wikipedia.org/wiki/CORDIC&quot;&gt;CORDIC&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Rotation_matrix&quot;&gt;rotation&lt;/a&gt;.
Doing so, though, requires the
&lt;a href=&quot;https://en.wikipedia.org/wiki/CORDIC&quot;&gt;CORDIC&lt;/a&gt;
angles, which we needed to calculate based upon the desired precision of the
output.  As a final step, we calculated both the
&lt;a href=&quot;https://en.wikipedia.org/wiki/CORDIC&quot;&gt;CORDIC&lt;/a&gt;
gain and it’s associated annihilator (inverse).&lt;/p&gt;

&lt;p&gt;If only this were all that was required of a
&lt;a href=&quot;https://en.wikipedia.org/wiki/CORDIC&quot;&gt;CORDIC&lt;/a&gt;
core.  It’s not.  We still need to build a test bench for this core–so our
work isn’t over yet.
Before doing so, however, I think we’ll present the
&lt;a href=&quot;/dsp/2017/09/01/topolar.md&quot;&gt;other basic type&lt;/a&gt;
of &lt;a href=&quot;https://en.wikipedia.org/wiki/CORDIC&quot;&gt;CORDIC&lt;/a&gt;
algorithm:
the &lt;a href=&quot;/dsp/2017/09/01/topolar.html&quot;&gt;CORDIC arctan&lt;/a&gt;
arctan, sometimes called the &lt;a href=&quot;/dsp/2017/09/01/topolar.html&quot;&gt;rectangular to polar
conversion&lt;/a&gt;,
before diving into the bench test.&lt;/p&gt;

&lt;p&gt;If you are interested in further reading on the topic,
Ray Andraka has written an excellent &lt;a href=&quot;http://www.andraka.com/files/crdcsrvy.pdf&quot;&gt;survey of CORDIC
algorithms&lt;/a&gt; that you might find
valuable.&lt;/p&gt;
&lt;hr /&gt;&lt;p&gt;&lt;em&gt;O ye simple, understand wisdom: and, ye fools, be ye of an understanding heart.  (Prov 8:5)&lt;/em&gt;</description>
        <pubDate>Wed, 30 Aug 2017 00:00:00 -0400</pubDate>
        <link>http://zipcpu.com/dsp/2017/08/30/cordic.html</link>
        <guid isPermaLink="true">http://zipcpu.com/dsp/2017/08/30/cordic.html</guid>
        
        
        <category>dsp</category>
        
      </item>
    
      <item>
        <title>Building a quarter sine-wave lookup table</title>
        <description>&lt;p&gt;The last time &lt;a href=&quot;/dsp/2017/07/11/simplest-sinewave-generator.html&quot;&gt;we discussed how to create a
sinewave&lt;/a&gt;,
we discussed the way to make a very simple
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sine_wave&quot;&gt;sinewave&lt;/a&gt;.
from a &lt;a href=&quot;/blog/2017/06/12/minimizing-luts.html&quot;&gt;LUT&lt;/a&gt;-based
table lookup.  We limited that
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sine_wave&quot;&gt;sinewave&lt;/a&gt;.
to an 8-bit table for simplicity, although it could easily be extended to a
much larger table.&lt;/p&gt;

&lt;p&gt;Today, let’s expand this concept to a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sine_wave&quot;&gt;sinewave&lt;/a&gt;.
that uses a quarter wave table
made from Block &lt;a href=&quot;https://en.wikipedia.org/wiki/Random-access_memory&quot;&gt;RAM&lt;/a&gt;.  Such a table uses only a fourth of the block &lt;a href=&quot;https://en.wikipedia.org/wiki/Random-access_memory&quot;&gt;RAM&lt;/a&gt;
resources required by a full table, although it does require some extra logic
to handle making things look like the full table.&lt;/p&gt;

&lt;p&gt;Let’s also build this as an example of how to create pipelined
&lt;a href=&quot;https://en.wikipedia.org/wiki/Hardware_description_language&quot;&gt;HDL&lt;/a&gt; logic.&lt;/p&gt;

&lt;p&gt;We’ll start by describing the algorithm in general, and then build the
algorithm through a series of stages.&lt;/p&gt;

&lt;h2 id=&quot;the-algorithm&quot;&gt;The Algorithm&lt;/h2&gt;

&lt;p&gt;The first step is always stepping back and assessing the problem.
If you look at a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sine_wave&quot;&gt;sinewave&lt;/a&gt;,
such as Fig 1. below, you can separate the full
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sine_wave&quot;&gt;sinewave&lt;/a&gt;
period into four sections, one quarter wavelength each.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 1: Sinewave Symmetry&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/sin-symmetry.png&quot; alt=&quot;Sinewave symmetry&quot; width=&quot;580&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;We’ll leave the first section alone.  This will become our quarter-wave
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sine_wave&quot;&gt;sinewave&lt;/a&gt;
table.
The second section is identical to the first, only in a backwards order.
Hence, if we reverse our index, we should be able to recover anything from
this quarter wave of the table.  The third and fourth sections are identical
to the first two, only their results will need to be negated afterwards.&lt;/p&gt;

&lt;p&gt;Since we are splitting the full wavelength into four sections, the top two
&lt;a href=&quot;/dsp/2017/06/15/no-pi-for-you.html&quot;&gt;phase&lt;/a&gt; bits can be
used to determine which of the four sections we are in.  If the most significant
bit is set, then we’ll want to negate the result.  If the next significant bit
is set, we’ll want to read backwards out of the table.&lt;/p&gt;

&lt;p&gt;This quarter wave table runs into a bit of a problem with
&lt;a href=&quot;/dsp/2017/06/15/no-pi-for-you.html&quot;&gt;phase&lt;/a&gt;
quantization, though.  Consider a
&lt;a href=&quot;/dsp/2017/06/15/no-pi-for-you.html&quot;&gt;phase&lt;/a&gt;
quantized table with only 16 entries, such as shown in Fig 2.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 2: Sampled Sinewave&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/sin-qtrbroken.png&quot; alt=&quot;Sinewave symmetry broken by sampling&quot; width=&quot;580&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;This table has lost the symmetry that was originally present in the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sine_wave&quot;&gt;sinewave&lt;/a&gt;.
In particular, table[4]’s value is not present in table[0:3].
If we were to use table[3] to represent the missing table[4] value, we
might get a &lt;a href=&quot;https://en.wikipedia.org/wiki/Sine_wave&quot;&gt;sinewave&lt;/a&gt;
looking like Fig 3. below.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 3: Symmetry can be broken by quantization&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/sin-qtrmisshapen.png&quot; alt=&quot;Fixing the broken symmetry by shifting a half a sample in phase&quot; width=&quot;580&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Notice how flat the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sine_wave&quot;&gt;sinewave&lt;/a&gt;
is every time it crosses zero.  It’s not
supposed to be this flat.  The slope of a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sine_wave&quot;&gt;sinewave&lt;/a&gt;
is supposed to be at
a maximum when it crosses zero–not flat. This shape distortion will create
harmonics that we are not expecting if we don’t fix it.&lt;/p&gt;

&lt;p&gt;If we instead advance the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sine_wave&quot;&gt;sinewave&lt;/a&gt;
table entries by a half of a sample of phase each, the result
will have less harmonic distortion. (i.e., it’ll be closer to the right shape,
even if shifted left a touch).  The result would then look like Fig 4.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 4: Fixing Symmetry by slipping a half a sample in phase&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/sin-qtrfixed.png&quot; alt=&quot;Fixing the broken symmetry by shifting a half a sample in phase&quot; width=&quot;580&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;The resulting equation for this table is also shown in Fig 4.&lt;/p&gt;

&lt;p&gt;The algorithm we want to build will take the first quarter of this
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sine_wave&quot;&gt;sinewave&lt;/a&gt;,
place it into a table, and then use that same table to generate
the other four quarters of the wavelength.&lt;/p&gt;

&lt;h2 id=&quot;building-the-algorithm&quot;&gt;Building the Algorithm&lt;/h2&gt;

&lt;p&gt;It’s now time to build this algorithm.  Although the algorithm itself is
quite simple, I’m going to build it in stages and use this as an opportunity
to discuss how to build a pipelined algorithm in general.  This will allow us
to compare several different implementations, and judge between good an bad
approaches.&lt;/p&gt;

&lt;p&gt;Our first draft for this algorithm uses a giant case statement:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
begin
	case({ i_phase[(PW-1):PW-2] })
	2&#39;b00:	o_val &amp;lt;=  tbl[ i_phase[(PW-3):0]];
	2&#39;b01:	o_val &amp;lt;=  tbl[~i_phase[(PW-3):0]];
	2&#39;b10:	o_val &amp;lt;= -tbl[ i_phase[(PW-3):0]];
	2&#39;b11:	o_val &amp;lt;= -tbl[~i_phase[(PW-3):0]];
	endcase
end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;In this piece of code, &lt;code class=&quot;highlighter-rouge&quot;&gt;i_phase&lt;/code&gt; is the input
&lt;a href=&quot;/dsp/2017/06/15/no-pi-for-you.html&quot;&gt;phase&lt;/a&gt;
request, &lt;code class=&quot;highlighter-rouge&quot;&gt;tbl&lt;/code&gt; is the quarter wave
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sine_wave&quot;&gt;sinewave&lt;/a&gt;
table, and &lt;code class=&quot;highlighter-rouge&quot;&gt;o_val&lt;/code&gt; is the output
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sine_wave&quot;&gt;sinewave&lt;/a&gt;.
PW is the
&lt;a href=&quot;/dsp/2017/06/15/no-pi-for-you.html&quot;&gt;phase&lt;/a&gt;
width, or equivalently the number of bits in &lt;code class=&quot;highlighter-rouge&quot;&gt;i_phase&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;You may notice that I haven’t used &lt;code class=&quot;highlighter-rouge&quot;&gt;TBLLEN/4-1-i_phase&lt;/code&gt; at all when reversing
the table entries.  Instead, &lt;code class=&quot;highlighter-rouge&quot;&gt;~i_phase&lt;/code&gt; accomplishes the same effect.  To know
why this is relevant, remember the two steps to negating a two’s complement
number: invert all the bits and add one.  In this case, we’d subtract one
after adding one, so we can just invert the bits.  As an example, then, if
&lt;code class=&quot;highlighter-rouge&quot;&gt;i_phase&lt;/code&gt; counts from 0 to 15, &lt;code class=&quot;highlighter-rouge&quot;&gt;~i_phase&lt;/code&gt; would count from 15 back down to 0.&lt;/p&gt;

&lt;p&gt;The problem with this big case statement approach is that most block &lt;a href=&quot;https://en.wikipedia.org/wiki/Random-access_memory&quot;&gt;RAM&lt;/a&gt;’s
are &lt;a href=&quot;https://www.xilinx.com/support/documentation/white_papers/wp231.pdf&quot;&gt;very particular about how they are
accessed&lt;/a&gt;.
Extra logic on the index is not allowed, neither is extra logic on the output.
Adding logic in either place can interfere with the synthesis tool and keep
it from recognizing your table as a block &lt;a href=&quot;https://en.wikipedia.org/wiki/Random-access_memory&quot;&gt;RAM&lt;/a&gt; (or &lt;a href=&quot;https://en.wikipedia.org/wiki/Read-only_memory&quot;&gt;ROM&lt;/a&gt; in this case).
When dealing with this, I have found the following form to be reliable
among the various hardware’s I have worked with.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	if (i_ce)
		tblvalue &amp;lt;= tbl[index];&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Perhaps this is simpler than it needs to be, but it does work across
vendors’ tool-suites.&lt;/p&gt;

&lt;p&gt;This may also be the time to discuss our pipeline strategy.  Looking over the
&lt;a href=&quot;/blog/2017/08/14/strategies-for-pipelining.html&quot;&gt;various pipeline
strategies&lt;/a&gt;
we posted about earlier, this already looks like the beginning of the
“global CE” approach.  If we look up the examples of where the “global CE”
pipeline strategy makes the most sense, you may recall that
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_signal_processing&quot;&gt;DSP&lt;/a&gt;
logic was one of the common applications of this approach.  Since that’s what
we are building today, we’ll keep the &lt;code class=&quot;highlighter-rouge&quot;&gt;i_ce&lt;/code&gt;
line, and add it into the rest of our logic.&lt;/p&gt;

&lt;p&gt;Working the simplicity of this block
&lt;a href=&quot;https://en.wikipedia.org/wiki/Random-access_memory&quot;&gt;RAM&lt;/a&gt; access into our
logic, though, will take some work.  We’ll need to spend a clock to calculate
the index, and another clock after that to deal with the negation.&lt;/p&gt;

&lt;p&gt;This brings us to our second approach to our logic.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
if (i_ce)
begin
	// First, calculate the table index
	if (i_phase[(PW-2)])
		index &amp;lt;= ~i_phase[(PW-3):0];
	else
		index &amp;lt;=  i_phase[(PW-3):0];

	// Use the index to access Block RAM
	tblvalue &amp;lt;= table[index];

	// Handle the negation afterwards
	if (i_phase[(PW-1)])
		o_val &amp;lt;= -tblvalue;
	else
		o_val &amp;lt;=  tblvalue;
end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This approach still has some hazards to it.  Perhaps if we drew a data
flow diagram, such as Fig 5 below, these hazards will become be more apparent.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 5: Initial Data Flow Diagram&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/qtrwave-preschedule.svg&quot; alt=&quot;Initial data flow diagram&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Let’s work with this flow diagram for a moment.  First, it helps to
separate the data flow variables into clock transitions regions.  (We’ll
show this in Fig 6 below in a moment.)
&lt;code class=&quot;highlighter-rouge&quot;&gt;i_phase&lt;/code&gt; would be in the first clock.  We’ll call this the input clock.
&lt;code class=&quot;highlighter-rouge&quot;&gt;index&lt;/code&gt; is in the next clock, etc.  Once you separate these variables, then
you can see the problem with the negation logic.  This negation flag
needs to come from the
high bit of &lt;code class=&quot;highlighter-rouge&quot;&gt;i_phase[(PW-1)]&lt;/code&gt;, but it has to be available after the table
look up.  To make this problem more apparent, draw vertical lines through
the diagram, dilineating the processing clocks.  Data flows should not cross
through such lines, without being clocked into a new register–else you’ll
have a pipeline bug.&lt;/p&gt;

&lt;p&gt;The solution to this problem is to &lt;em&gt;schedule&lt;/em&gt; the pipeline logic.
Specifically, we’ll create a register to hold &lt;code class=&quot;highlighter-rouge&quot;&gt;i_phase[(PW-1)]&lt;/code&gt; while
the table index is calculated and the table value is looked up.  We can
implement this with a two stage shift register, captured by &lt;code class=&quot;highlighter-rouge&quot;&gt;negate[0]&lt;/code&gt; and
&lt;code class=&quot;highlighter-rouge&quot;&gt;negate[1]&lt;/code&gt;:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
if (i_ce)
begin
	negate[0] &amp;lt;= i_phase[(PW-1)];
	// ...
	negate[1] &amp;lt;= negate[0];
	if (negate[1])
		// ...
end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;A new data flow diagram for this modified algorithm might look like Fig 6.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 6: Scheduled data flow&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/qtrwave-scheduled.svg&quot; alt=&quot;Data flow diagram, with all logic scheduled&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Notice how each variable is now associated with a clock period in the pipeline.&lt;/p&gt;

&lt;p&gt;Written out, our logic now looks like:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;// Initialize the quarter-wave table
initial	$readmemh(&quot;quarterwav.hex&quot;, quartertable);

always @(posedge i_clk)
	if (i_ce)
	begin
		// Clock one
		negate[0] &amp;lt;= i_phase[(PW-1)];
		index  &amp;lt;= i_phase[(PW-2)]
				? ~i_phase[(PW-3):0]
				:  i_phase[(PW-3):0];

		// Clock two
		negate[1] &amp;lt;= negate[0];
		tblvalue &amp;lt;= table[index];

		// Output clock
		if (negate[1])
			o_val &amp;lt;= -tblvalue;
		else
			o_val &amp;lt;=  tblvalue;
	end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;You can also find a &lt;a href=&quot;https://github.com/ZipCPU/cordic/blob/master/rtl/quarterwav.v&quot;&gt;full example of this logic
here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;At this point, we are almost done.  All that’s left is to create a hex
file to be used to crate this table.  This can be done from a simple
&lt;a href=&quot;https://github.com/ZipCPU/cordic/blob/master/sw/sintable.cpp&quot;&gt;C++ program&lt;/a&gt;,
where the relevant portion is shown below:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;tbl_entries&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lgtable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;maxv&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ow&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tbl_entries&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;dv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ph&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;ph&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;2.0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;M_PI&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tbl_entries&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;ph&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt;       &lt;span class=&quot;n&quot;&gt;M_PI&lt;/span&gt;             &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tbl_entries&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;dv&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;maxv&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ph&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;8&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;fprintf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;hexfp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;%s@%08x &quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;?&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;fprintf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;hexfp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;%0*x &quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ow&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ow&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fprintf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;hexfp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Well, not quite.  The problem with this approach is that the table generator
is closely associtated with the Verilog code itself.  In particular, you
can’t change the number of table entries, or for that matter the width of
the table entries, without also adjusting the &lt;a href=&quot;https://github.com/ZipCPU/cordic/blob/master/rtl/quarterwav.v&quot;&gt;Verilog
code&lt;/a&gt;.
For this reason, the
&lt;a href=&quot;https://github.com/ZipCPU/cordic/blob/master/sw/sintable.cpp&quot;&gt;C++ generator&lt;/a&gt;
program creates both the
&lt;a href=&quot;https://github.com/ZipCPU/cordic/blob/master/rtl/quarterwav.v&quot;&gt;Verilog code&lt;/a&gt;
and the
&lt;a href=&quot;https://github.com/ZipCPU/cordic/blob/master/rtl/quarterwav.hex&quot;&gt;hex table&lt;/a&gt;
at the same time.&lt;/p&gt;

&lt;p&gt;That’s it!  We’ve now made a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sine_wave&quot;&gt;sinewave&lt;/a&gt;
generator from just a quarter wave
table.  We’re still going to need to come back to test this table, to build
a test bench and prove that it works, but that’s the basics of the algorithm.&lt;/p&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;This post is one in a small series of posts discussing how to generate a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sine_wave&quot;&gt;sinewave&lt;/a&gt;.
We’ve already discussed a &lt;a href=&quot;/dsp/2017/07/11/simplest-sinewave-generator.md&quot;&gt;very simple sinewave
generator&lt;/a&gt;,
and we are well on our way to creating and explaining a full blown
&lt;a href=&quot;https://en.wikipedia.org/wiki/CORDIC&quot;&gt;CORDIC&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sine_wave&quot;&gt;sinewave&lt;/a&gt; implementation.&lt;/p&gt;

&lt;p&gt;These &lt;a href=&quot;https://en.wikipedia.org/wiki/Sine_wave&quot;&gt;sinewave&lt;/a&gt;
generators will then form the basis for testing the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;digital filters&lt;/a&gt;
that I intend to discuss and demonstrate as well.&lt;/p&gt;

&lt;p&gt;So, while this is the end of this post, in many ways it is only one step
forward in building &lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_signal_processing&quot;&gt;Digital Signal
Proccessing&lt;/a&gt;
algorithms within an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;.
Stick around, there’s a lot you can do with a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sine_wave&quot;&gt;sinewave&lt;/a&gt;.&lt;/p&gt;
&lt;hr /&gt;&lt;p&gt;&lt;em&gt;But he went out, and began to publish it much, and to blaze abroad the matter, insomuch that Jesus could no more openly enter into the city, but was without in desert places: and they came to him from every quarter.  (Mark 1:45)&lt;/em&gt;</description>
        <pubDate>Sat, 26 Aug 2017 00:00:00 -0400</pubDate>
        <link>http://zipcpu.com/dsp/2017/08/26/quarterwave.html</link>
        <guid isPermaLink="true">http://zipcpu.com/dsp/2017/08/26/quarterwave.html</guid>
        
        
        <category>dsp</category>
        
      </item>
    
  </channel>
</rss>
