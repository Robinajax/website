<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>The ZipCPU by Gisselquist Technology</title>
    <description>The ZipCPU blog, featuring how to discussions of FPGA and soft-core CPU design.  This site will be focused on Verilog solutions, using exclusively OpenSource IP products for FPGA design.  Particular focus areas include topics often left out of more mainstreeam FPGA design courses such as how to debug an FPGA design.
</description>
    <link>http://zipcpu.com/</link>
    <atom:link href="http://zipcpu.com/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Wed, 31 Jan 2018 14:06:09 -0500</pubDate>
    <lastBuildDate>Wed, 31 Jan 2018 14:06:09 -0500</lastBuildDate>
    <generator>Jekyll v3.0.1</generator>
    <image>
      <url>http://zipcpu.com/img/gt-rss.png</url>
      <title></title>
      <link></link>
    </image>
    
      <item>
        <title>ZipCPU toolchain and initial test</title>
        <description>&lt;p&gt;Please accept my apologies for taking so long to put this article together.
I’ve made a lot of changes to the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
in order to &lt;a href=&quot;/zipcpu/2018/01/22/formal-progress.html&quot;&gt;formally
prove&lt;/a&gt;
the components.  I’ve also cleaned out all of the issues in the issue-tracker
on &lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;Github&lt;/a&gt;.  These changes have now been
integrated into &lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;the baseline&lt;/a&gt;.
They have been confirmed to build within
&lt;a href=&quot;http://www.clifford.at/yosys/&quot;&gt;yosys&lt;/a&gt;,
&lt;a href=&quot;https://www.xilinx.com/products/design-tools/ise-design-suite.html&quot;&gt;ISE&lt;/a&gt;,
&lt;a href=&quot;https://www.xilinx.com/products/design-tools/vivado.html&quot;&gt;Vivado&lt;/a&gt;,
and
&lt;a href=&quot;https://veripool.org/wiki/verilator&quot;&gt;Verilator&lt;/a&gt;.
Further, the new changes have been proven on the
&lt;a href=&quot;https://github.com/ZipCPU/zbasic&quot;&gt;ZBasic&lt;/a&gt; distribution–just not within an
actual &lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
(yet).  Further, when measuring the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Logic_block&quot;&gt;LUT&lt;/a&gt;
usage impact of the changes that
have been made, they appear to require no more than four extra
&lt;a href=&quot;https://en.wikipedia.org/wiki/Logic_block&quot;&gt;LUT&lt;/a&gt;s–suggesting the 
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
remains on target to be a low-logic
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Integration with
&lt;a href=&quot;https://github.com/olofk/fusesoc&quot;&gt;FuseSoC&lt;/a&gt;
is still now, perhaps more firmly than ever, on my to-do list.&lt;/p&gt;

&lt;p&gt;With that aside, let’s look into how you might get started.&lt;/p&gt;

&lt;h2 id=&quot;introduction&quot;&gt;Introduction&lt;/h2&gt;

&lt;p&gt;Let’s spend a couple of posts discussing how to fire up the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
and run it.  Our goal will be to show how the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
can be used to control a signal processing application.  That, however,
will take a couple of posts to get to.  For this first post, let’s
just discuss how to get the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
tool chain up and running, and then how to test and know that the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt;
itself works.&lt;/p&gt;

&lt;p&gt;If you look at the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;’s
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/README.md&quot;&gt;README file&lt;/a&gt;, you’ll
read that the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
is only one component of a (potentially) much larger system.  For example,
consider the
&lt;a href=&quot;https://github.com/ZipCPU/zbasic&quot;&gt;ZBasic&lt;/a&gt;
system in the figure below.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 1. ZBasic Components and Peripherals&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/zbasic-blok.svg&quot; alt=&quot;&quot; width=&quot;730&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/ZipCPU/zbasic&quot;&gt;This system&lt;/a&gt;
was designed to be a generic system that could demonstrate the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;’s
capabilities.  If you notice, the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
is only a small part of this full system.  Likewise, the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/zipsystem.v&quot;&gt;ZipSystem&lt;/a&gt;,
a container for the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
with some peripherals connected close to the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt;,
is still only a small portion of any full design.  To make a full design from
just a &lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt;, the
&lt;a href=&quot;https://github.com/ZipCPU/zbasic&quot;&gt;ZBasic&lt;/a&gt;
project also contains a
&lt;a href=&quot;https://github.com/ZipCPU/wbuart32&quot;&gt;serial port&lt;/a&gt;, a &lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/rtl/memdev.v&quot;&gt;block
RAM&lt;/a&gt;, a &lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/rtl/wbqspiflash.v&quot;&gt;flash (ROM)
controller&lt;/a&gt;,
an (optional)
&lt;a href=&quot;https://github.com/ZipCPU/sdspi&quot;&gt;SPI-mode SD-Card controller&lt;/a&gt;, and
(currently) a
&lt;a href=&quot;https://github.com/ZipCPU/wbscope&quot;&gt;scope&lt;/a&gt; for the
&lt;a href=&quot;https://github.com/ZipCPU/sdspi&quot;&gt;SD-card controller&lt;/a&gt;
as well.  There are also some smaller components, such as a
&lt;a href=&quot;https://github.com/ZipCPU/rtcclock&quot;&gt;real-time clock&lt;/a&gt;, a
&lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/auto-data/pwrcount.txt&quot;&gt;counter-since-power
up&lt;/a&gt;,
a second &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/icontrol.v&quot;&gt;interrupt
controller&lt;/a&gt;,
the &lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/auto-data/version.txt&quot;&gt;date of the last time the system was
built&lt;/a&gt;
 and so forth.&lt;/p&gt;

&lt;p&gt;As with all of my designs, the &lt;a href=&quot;https://github.com/ZipCPU/zbasic&quot;&gt;ZBasic design&lt;/a&gt;
also has a &lt;a href=&quot;/blog/2017/06/05/wb-bridge-overview.html&quot;&gt;debugging bus
controller&lt;/a&gt;
that can be used to control the bus within the core from an external
&lt;a href=&quot;https://github.com/ZipCPU/wbuart32&quot;&gt;serial port&lt;/a&gt;.  This version of the
debugging bus controller, however, multiplexes two 7-bit
channels onto an 8-bit serial port channel–unlike the &lt;a href=&quot;/blog/2017/06/05/wb-bridge-overview.html&quot;&gt;one we discussed
earlier&lt;/a&gt;.
This creates a
&lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/rtl/wbconsole.v&quot;&gt;console port&lt;/a&gt;
for the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt;, in addition to the
&lt;a href=&quot;/blog/2017/06/05/wb-bridge-overview.html&quot;&gt;debugging bus controller&lt;/a&gt;.
This makes it possible to experiment with the
&lt;a href=&quot;https://github.com/ZipCPU/zbasic&quot;&gt;ZBasic&lt;/a&gt;
module on any
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
board having only a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Serial_Peripheral_Interface_Bus&quot;&gt;QSPI&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt; and a
&lt;a href=&quot;https://github.com/ZipCPU/wbuart32&quot;&gt;serial port&lt;/a&gt;.  The
&lt;a href=&quot;https://github.com/ZipCPU/sdspi&quot;&gt;SDCard&lt;/a&gt; port is optional, and by using
&lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt;, the block RAM can easily be
resized.&lt;/p&gt;

&lt;p&gt;Our eventual goal in this series of articles will be to show how to run
this &lt;a href=&quot;https://github.com/ZipCPU/zbasic&quot;&gt;ZBasic design&lt;/a&gt;,
while simulating all of the components, from within
&lt;a href=&quot;/blog/2017/06/21/looking-at-verilator.html&quot;&gt;Verilator&lt;/a&gt;.  As
part of this goal, we’ll also add a
&lt;a href=&quot;https://github.com/ZipCPU/wbpmic&quot;&gt;MEMs based audio A/D&lt;/a&gt;
and may possibly even add an &lt;a href=&quot;https://github.com/ZipCPU/xulalx25soc/blob/master/rtl/wbsdram.v&quot;&gt;SDRAM
controller&lt;/a&gt;.
We’ll even use the &lt;a href=&quot;https://sourceware.org/newlib&quot;&gt;C-library&lt;/a&gt; to demonstrate a
&lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/sw/board/hello.c&quot;&gt;Hello World
example&lt;/a&gt;,
and possibly even to play &lt;a href=&quot;https://github.com/ZipCPU/tttt&quot;&gt;4x4x4 Tic-Tac-Toe&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;That will be the goal of this series.&lt;/p&gt;

&lt;p&gt;Today’s goal, however, will just be to examine the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
by itself.  To do so, we’ll trace a piece
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; history,
and run the very first piece of software ever written for the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;the-initial-zipcpu-test-software&quot;&gt;The Initial ZipCPU Test Software&lt;/h2&gt;

&lt;p&gt;The very first  piece of software I wrote for the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
just demonstrated each of the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt;’s
instructions, and its ability to execute them.&lt;/p&gt;

&lt;p&gt;The initial version of this test was created by a test generator piece of
software that at one time wrote a couple of machine code instructions
into a binary file which would then describe the block RAM memory image
for the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt;.
I was so excited to get this simple code to work!  Little did I know how
much more work would be involved in finding all the corner cases within any
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;.
This piece of code, however, is now only relic-ware.  Indeed, it is not only
a couple of &lt;a href=&quot;/zipcpu/2018/01/01/zipcpu-isa.html&quot;&gt;instruction set
architecture&lt;/a&gt;
versions out of date, but since it was causing build errors for users it has
since been removed from the repository entirely.&lt;/p&gt;

&lt;p&gt;With the introduction of the first
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/tree/master/sw/zasm&quot;&gt;assembler&lt;/a&gt;,
the program that generated machine code was replaced with an &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/bench/asm/simtest.s&quot;&gt;assembly
file&lt;/a&gt;.
Even though that
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/tree/master/sw/zasm&quot;&gt;initial assembler&lt;/a&gt;
has now also become relic-ware, the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/bench/asm/simtest.s&quot;&gt;assembly
file&lt;/a&gt;
test has been maintained to the point that it can still
be assembled using the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/sw/gas-zippatch.patch&quot;&gt;version of
binutils&lt;/a&gt;.
Unlike the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/tree/master/sw/zasm&quot;&gt;original assembler&lt;/a&gt;,
&lt;a href=&quot;https://www.gnu.org/software/binutils&quot;&gt;binutils&lt;/a&gt;
provides several valuable capabilities–such as the ability to link multiple
files together, the ability to follow a script describing where memory and/or
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt;
are located, the ability to place an initial RAM image in
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt;,
and even the ability to integrate with &lt;a href=&quot;https://gcc.gnu.org&quot;&gt;GCC&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;This &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/bench/asm/simtest.s&quot;&gt;remaining piece of
software/testware&lt;/a&gt;
starts with a branch-always followed by break test–just to make certain the
&lt;a href=&quot;/zipcpu/2017/08/23/cpu-pipeline.html&quot;&gt;pipeline&lt;/a&gt;
works.  It then continues by testing some basic register setting commands.
It was meant to be run within a &lt;a href=&quot;/zipcpu/2017/07/26/cpu-sim-debugger.html&quot;&gt;monitor
program&lt;/a&gt;.
Using this program, you can step through this software one clock cycle at a
time–just like &lt;a href=&quot;/zipcpu/2017/07/26/cpu-sim-debugger.html&quot;&gt;we discussed
earlier&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Let’s build and run
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/bench/asm/simtest.s&quot;&gt;this program&lt;/a&gt;
today, to give us some confidence that the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt;
itself continues to work.&lt;/p&gt;

&lt;h2 id=&quot;building-the-tools&quot;&gt;Building the tools&lt;/h2&gt;

&lt;p&gt;The first step in converting any
&lt;a href=&quot;https://en.wikipedia.org/wiki/Assembly_language&quot;&gt;assembly file&lt;/a&gt; into &lt;a href=&quot;https://en.wikipedia.org/wiki/Machine_code&quot;&gt;machine
code&lt;/a&gt;
is to acquire (or build) an &lt;a href=&quot;https://www.gnu.org/software/binutils&quot;&gt;assembler and
linker&lt;/a&gt;.  The
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
has backend support for &lt;a href=&quot;https://www.gnu.org/software/binutils&quot;&gt;binutils (assembler and
linker)&lt;/a&gt;, the
&lt;a href=&quot;https://gcc.gnu.org&quot;&gt;GCC C-compiler&lt;/a&gt;, and
&lt;a href=&quot;https://sourcewaire.org/newlib&quot;&gt;newlib&lt;/a&gt;.  Although only
&lt;a href=&quot;https://www.gnu.org/software/binutils&quot;&gt;binutils&lt;/a&gt;
is required for this &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/bench/asm/simtest.s&quot;&gt;testing
program&lt;/a&gt;,
all of the tools are built from the same command, so let’s build them together.&lt;/p&gt;

&lt;p&gt;To build the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
tool-suite, first make sure you have the prerequisites
for &lt;a href=&quot;https://gcc.gnu.org&quot;&gt;GCC&lt;/a&gt;.  For debian based systems, this will look like:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;sudo apt install flex bison libbison-dev libgmp-dev libmpfr-dev libmpc-dev bc&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;You’ll notice several &lt;code class=&quot;highlighter-rouge&quot;&gt;*-dev&lt;/code&gt; components.  These are different from their non
&lt;code class=&quot;highlighter-rouge&quot;&gt;-dev&lt;/code&gt; counterparts, in that they allow you to build components using these
libraries rather than just using binary components already built.  In other
words, installing &lt;code class=&quot;highlighter-rouge&quot;&gt;gmp&lt;/code&gt; isn’t good enough, you’ll need to install &lt;code class=&quot;highlighter-rouge&quot;&gt;libgmp-dev&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;You are also going to need &lt;a href=&quot;https://www.veripool.org/wiki/verilator&quot;&gt;Verilator&lt;/a&gt;
to translate
the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;’s Verilog source code into
the C++ necessary to simulate it,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;sudo apt install verilator&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The &lt;a href=&quot;/zipcpu/2017/07/26/cpu-sim-debugger.html&quot;&gt;simulation&lt;/a&gt;
driver needs
&lt;a href=&quot;http://www.mr511.de/software/english.html&quot;&gt;libelf&lt;/a&gt; in order to know
where to load programs and program components into memory,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;sudo apt install libelf-dev&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Please note that, as with the earlier components, this package is the
development version of
&lt;a href=&quot;http://www.mr511.de/software/english.html&quot;&gt;libelf&lt;/a&gt;.  We’ll need that version
to build a program that uses it that can read and process an ELF file.&lt;/p&gt;

&lt;p&gt;Many of my distributions depend upon &lt;a href=&quot;http://ctags.sourceforge.net&quot;&gt;ctags&lt;/a&gt;,
and the &lt;a href=&quot;/zipcpu/2017/07/26/cpu-sim-debugger.html&quot;&gt;simulation control
program&lt;/a&gt;
is written using
&lt;a href=&quot;https://www.gnu.org/software/ncurses&quot;&gt;ncurses&lt;/a&gt;, so let’s get those as well:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;sudo apt install ncurses-dev ctags&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;If you are using Windows,
&lt;a href=&quot;/blog/2017/07/28/cygwin-fpga.html&quot;&gt;these instructions&lt;/a&gt;
should get you started using these tools via &lt;a href=&quot;https://cygwin.com&quot;&gt;cygwin&lt;/a&gt;.
Since I’m not using Windows regularly, please let me know if you have any
problems building with &lt;a href=&quot;https://cygwin.com&quot;&gt;cygwin&lt;/a&gt;–I’ll probably never notice
the problem otherwise.&lt;/p&gt;

&lt;p&gt;One you have these prerequisites, it is now time to actually clone
the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
repository,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;git clone --depth 1 https://github.com/ZipCPU/zipcpu
&lt;span class=&quot;nb&quot;&gt;cd &lt;/span&gt;zipcpu&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;While you may have cloned repositories without the &lt;code class=&quot;highlighter-rouge&quot;&gt;depth&lt;/code&gt; command, doing so
with the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;repository&lt;/a&gt; will also download a history
containing several versions of &lt;a href=&quot;https://gcc.gnu.org&quot;&gt;GCC&lt;/a&gt;.  In other words,
you’ll be spending a lot of bandwidth downloading more of the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;repository&lt;/a&gt; than you need.&lt;/p&gt;

&lt;p&gt;At this point, you &lt;em&gt;should&lt;/em&gt; be able to just type “make”.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;make&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This will orchestrate a
&lt;a href=&quot;https://www.veripool.org/wiki/verilator&quot;&gt;Verilator&lt;/a&gt;-based
make of the “&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/tree/master/rtl&quot;&gt;rtl/&lt;/a&gt;”
directory, and a build of the simulation
directory, “&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/tree/master/sim/verilator&quot;&gt;sim/verilator&lt;/a&gt;”.  It will also trigger a build of the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
tool-suite that we’ll need to turn the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/bench/asm/simtest.s&quot;&gt;simulation test
file&lt;/a&gt;
from &lt;a href=&quot;/zipcpu/2018/01/01/zipcpu-isa.html&quot;&gt;assembly&lt;/a&gt; into
&lt;a href=&quot;https://en.wikipedia.org/wiki/Machine_code&quot;&gt;object code&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The current version of the tools will be built and placed into a “sw/install”
directory within the cloned repository of the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;.
Before going further, you will need to make certain that this directory
is a part of your path.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span class=&quot;nb&quot;&gt;export &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;PATH&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$PATH&lt;/span&gt;:&amp;lt;your-path-to-zipcpu&amp;gt;/sw/install/cross-tools/bin&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;I am very interested in any struggles you may have during this process.
Please create an issue on
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;GitHub&lt;/a&gt; if you have any errors up to this
point.&lt;/p&gt;

&lt;h2 id=&quot;running-the-test-file&quot;&gt;Running the test file&lt;/h2&gt;

&lt;p&gt;Now that you have the tool suite, and now that your &lt;code class=&quot;highlighter-rouge&quot;&gt;PATH&lt;/code&gt; environment
variable has been modified so that &lt;code class=&quot;highlighter-rouge&quot;&gt;zip-as&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;zip-cpp&lt;/code&gt; are in
your path, then it is now time to build the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/bench/asm/simtest.s&quot;&gt;simulation test
file&lt;/a&gt;.
For this, we’ll change into the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/bench/asm&quot;&gt;bench/asm&lt;/a&gt;,
and run &lt;code class=&quot;highlighter-rouge&quot;&gt;make simtest&lt;/code&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span class=&quot;nb&quot;&gt;cd &lt;/span&gt;bench/asm
make simtest&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;You can also build a disassembly file of the result, in case you are ever
interested in what the original instructions actually build into, by&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;make simtest.txt&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Once built, we can change into the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/tree/master/sim/verilator/&quot;&gt;Verilator based simulation
directory&lt;/a&gt;,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span class=&quot;nb&quot;&gt;cd&lt;/span&gt; ../..
&lt;span class=&quot;nb&quot;&gt;cd &lt;/span&gt;sim/verilator&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;From here, you can run the automated tests.  There are two such tests,
both based off of the same &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/bench/asm/simtest.s&quot;&gt;simulated test&lt;/a&gt; instructions.&lt;/p&gt;

&lt;p&gt;The first automated test just runs the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/bench/asm/simtest.s&quot;&gt;test&lt;/a&gt;
file, using the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;’s
&lt;a href=&quot;/zipcpu/2017/85/25/hw-debugging.html&quot;&gt;debug interface&lt;/a&gt;
and particularly the &lt;em&gt;step&lt;/em&gt; instruction provided by that interface–the
same &lt;em&gt;step&lt;/em&gt; control that the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt;
would use were it placed on actual hardware.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;./zipsys_tb -s ../../bench/asm/simtest&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;To know when the test is complete, the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/bench/asm/simtest.s&quot;&gt;test file&lt;/a&gt;
has been designed to “end” in one of two states.  It will either end with
1) a halt instruction (successful exit), or 2) a BUSY instruction (error exit).
The &lt;a href=&quot;/zipcpu/2017/07/26/cpu-sim-debugger.html&quot;&gt;simulator&lt;/a&gt;
will detect this interface, and return an appropriate value to the shell.&lt;/p&gt;

&lt;p&gt;The second automated test simulates how the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt; would run if it were actually
running on the device without the
&lt;a href=&quot;/zipcpu/2017/85/25/hw-debugging.html&quot;&gt;debugging interface&lt;/a&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;./zipsys_tb -a ../../bench/asm/simtest&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;These two tests are so valuable to me, that I have a make target set up
just to run both of them,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;make &lt;span class=&quot;nb&quot;&gt;test&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;There’s a third way to run the test as well–the interactive test.  Although
starting the run is just as simple,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;make itest&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;there are more details involved in commanding it, which we’ll get into in the
next section.&lt;/p&gt;

&lt;p&gt;Further, no matter how you run this
&lt;a href=&quot;/zipcpu/2017/07/26/cpu-sim-debugger.html&quot;&gt;simulator&lt;/a&gt;,
it will (currently) always create a
&lt;a href=&quot;/blog/2017/07/31/vcd.html&quot;&gt;VCD trace file&lt;/a&gt;.  You are
welcome to open this file in a waveform viewer to see the internal signals
within the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; if you would like.
This isn’t true of the 
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
&lt;a href=&quot;/zipcpu/2017/07/26/cpu-sim-debugger.html&quot;&gt;simulator&lt;/a&gt;
within the
&lt;a href=&quot;https://github.com/ZipCPU/zbasic&quot;&gt;ZBasic&lt;/a&gt; repository–since the trace files
for &lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/sim/verilated/automaster_tb.cpp&quot;&gt;that simulator&lt;/a&gt;
can easily grow to many Gigabytes in length, that one is turned off by default.
In this case, though, the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/bench/asm/simtest.s&quot;&gt;simtest
file&lt;/a&gt;
is short enough that the
&lt;a href=&quot;/blog/2017/07/31/vcd.html&quot;&gt;VCD trace file&lt;/a&gt;
should remain within a reasonable size.&lt;/p&gt;

&lt;h2 id=&quot;interactive-commands&quot;&gt;Interactive Commands&lt;/h2&gt;

&lt;p&gt;Now that you know how to start the &lt;a href=&quot;/zipcpu/2017/07/26/cpu-sim-debugger.html&quot;&gt;simulation based
debugger&lt;/a&gt;
let’s spend some time describing how to work operate it.  As you’ll recall
from the last section, starting the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
&lt;a href=&quot;/zipcpu/2017/07/26/cpu-sim-debugger.html&quot;&gt;simulation based
debugger&lt;/a&gt; is easy.
Just run&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;make itest&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;from the “&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/tree/master/sim/verilated&quot;&gt;sim/verilated&lt;/a&gt;”
subdirectory.&lt;/p&gt;

&lt;p&gt;This will apply the
&lt;a href=&quot;/zipcpu/2017/07/26/cpu-sim-debugger.html&quot;&gt;simulation&lt;/a&gt;
to the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/bench/asm/simtest.s&quot;&gt;simtest
file&lt;/a&gt;.
To start it with another file you can run,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;./zipsys_tb &amp;lt;your-executable-file&amp;gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Knowing what to do next isn’t quite as simple.  Sure, either hitting the
escape key or ‘q’ will exit, but you can do a lot more.  Here’s a cheat sheet
so you’ll know what to do.  Specifically, the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
&lt;a href=&quot;/zipcpu/2017/07/26/cpu-sim-debugger.html&quot;&gt;simulator&lt;/a&gt;
understands the following command keys:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;‘h’ Halts the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;‘g’ tells the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt;
to &lt;em&gt;go&lt;/em&gt; until given another command.&lt;/li&gt;
  &lt;li&gt;‘G’ does the same thing, but only updates the screen any time a user types
a character.  It’s useful for moving quickly through a long simulation if
necessary.&lt;/li&gt;
  &lt;li&gt;‘r’ gives the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt; the reset command,
sending it back to supervisor mode and the reset address&lt;/li&gt;
  &lt;li&gt;’s’ &lt;em&gt;steps&lt;/em&gt; the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt; using the
&lt;a href=&quot;/zipcpu/2017/08/25/hw-debugging.html&quot;&gt;debugging interface&lt;/a&gt;
that will exist within the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
implementation&lt;/li&gt;
  &lt;li&gt;‘t’ &lt;em&gt;ticks&lt;/em&gt; the clock.  It steps the
&lt;a href=&quot;/blog/2017/06/21/looking-at-verilator.html&quot;&gt;Verilator&lt;/a&gt;
&lt;a href=&quot;/zipcpu/2017/07/26/cpu-sim-debugger.html&quot;&gt;simulation&lt;/a&gt;
by one clock tick, but done in such a fashion that the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt;’s
Verilog logic doesn’t know it’s being stepped.&lt;/li&gt;
  &lt;li&gt;‘T’ releases the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt;
from the &lt;a href=&quot;/zipcpu/2017/08/25/hw-debugging.html&quot;&gt;hardware debugging
mode&lt;/a&gt;.  This is
useful if you’ve been giving it the &lt;em&gt;step&lt;/em&gt; command (separate from ticking
the clock), and you want the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt; to continue without being given
explicit &lt;em&gt;step&lt;/em&gt; instructions.&lt;/li&gt;
  &lt;li&gt;‘q’ quits the simulation&lt;/li&gt;
  &lt;li&gt;Ctrl-L redraws the screen.  This used to be really important when running
a &lt;a href=&quot;https://www.gnu.org/software/ncurses&quot;&gt;curses&lt;/a&gt;
program over a modem connection–any time someone else in the house
would pick up the phone, you’d get a bunch of garbage on the screen and your
computer would need to re-sync.  While it’s not as necessary today, I did
find it necessary to add this capability in–specifically for the case
where I have
&lt;a href=&quot;https://gtkwave.sourceforge.net&quot;&gt;GTKWave&lt;/a&gt;
running in the background spewing warnings over my screen anytime I
update the display.&lt;/li&gt;
  &lt;li&gt;‘u’ switches the performance times to show user mode performance&lt;/li&gt;
  &lt;li&gt;‘m’ switches the performance times to show global machine performance&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;If this is your first experience with the
&lt;a href=&quot;/zipcpu/2017/07/26/cpu-sim-debugger.html&quot;&gt;simulator&lt;/a&gt;,
just remember three
characters: ‘t’ steps it forward, ‘r’ restarts it, and ‘q’ exits.  You might
just wish to press ‘t’ several times and watch what happens.  If that gets
boring, try typing ‘g’–you can stop the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
anytime by typing ‘t’ later to return to single-clock-tick mode.&lt;/p&gt;

&lt;p&gt;The &lt;a href=&quot;/zipcpu/2017/07/26/cpu-sim-debugger.html&quot;&gt;simulator&lt;/a&gt;
also has the ability to adjust and change registers.  You
can move around the display using the arrow keys.  When you get to a register
you wish to adjust, press the enter key, type the new number, and then press
enter (to set the value) or escape (to leave the mode).&lt;/p&gt;

&lt;h2 id=&quot;understanding-the-interactive-display&quot;&gt;Understanding the Interactive Display&lt;/h2&gt;

&lt;p&gt;So let’s look at what this interface tells us.&lt;/p&gt;

&lt;p&gt;When you initially start the
&lt;a href=&quot;/zipcpu/2017/07/26/cpu-sim-debugger.html&quot;&gt;simulator&lt;/a&gt;,
you’ll see a screen looking like Fig 2 below.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 2, Initial Simulator Screen&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/zipsim-initial.png&quot; alt=&quot;&quot; width=&quot;562&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Let’s break down the components of this view, so that you can understand what’s
going on.  Fig 3. therefore shows the basic sections of the
&lt;a href=&quot;/zipcpu/2017/07/26/cpu-sim-debugger.html&quot;&gt;simulation&lt;/a&gt;
screen.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 3. Components of the simulation screen&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/zipsim-overview.svg&quot; alt=&quot;&quot; width=&quot;562&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Starting at the top are two lines describing the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/zipsystem.v&quot;&gt;ZipSystem&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/tree/master/peripherals&quot;&gt;peripherals&lt;/a&gt;.  These
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/tree/master/peripherals&quot;&gt;peripherals&lt;/a&gt;
are shown in the blue box of Fig 1 above, they consist of an &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/icontrol.v&quot;&gt;interrupt
controller (PIC)&lt;/a&gt;, a
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/ziptimer.v&quot;&gt;watchdog timer (WDT)&lt;/a&gt;, a
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/wbwatchdog.v&quot;&gt;bus watchdog (WBUS)&lt;/a&gt;, and the second
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/icontrol.v&quot;&gt;interrupt control register (PIC2)&lt;/a&gt;.  Judging from these
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/tree/master/peripherals&quot;&gt;peripherals&lt;/a&gt;,
you can tell if (for example) interrupts are enabled, or an interrupt is
pending.  On the next line are the three
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/ziptimer.v&quot;&gt;count-down timers (TMRA-TMRC)&lt;/a&gt;, and
a &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/zipjiffies.v&quot;&gt;Jiffies&lt;/a&gt;
peripheral for controlling absolute rather than relative programmable
interrupt timing.  (This would be useful for real-time task scheduling.)&lt;/p&gt;

&lt;p&gt;The next line, starting with &lt;code class=&quot;highlighter-rouge&quot;&gt;MTSK&lt;/code&gt;, shows the values of four
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/peripherals/zipcounter.v&quot;&gt;performance counters&lt;/a&gt;.  The first counts the number clock ticks, and the last counts
the number of instructions retired.  The two in the middle count how often the
operands stage of the
&lt;a href=&quot;/zipcpu/2017/08/23/cpu-pipeline.html&quot;&gt;pipeline&lt;/a&gt; is stalled,
and how often the
&lt;a href=&quot;/zipcpu/2017/11/18/wb-prefetch.html&quot;&gt;prefetch&lt;/a&gt;
is stalled.  These are global counters.  They count whether the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt;
is in &lt;a href=&quot;/zipcpu/2018/01/01/zipcpu-isa.html&quot;&gt;supervisor mode or user
mode&lt;/a&gt;.  There’s a
second set of identical
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/peripherals/zipcounter.v&quot;&gt;counters&lt;/a&gt;,
revealed by typing &lt;code class=&quot;highlighter-rouge&quot;&gt;u&lt;/code&gt; within the
&lt;a href=&quot;/zipcpu/2017/07/26/cpu-sim-debugger.html&quot;&gt;simulation&lt;/a&gt;,
showing the same basic values–but this second set only increments
while in user mode.  This makes it possible to measure per user-task statistics.&lt;/p&gt;

&lt;p&gt;Further information regarding these
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/tree/master/peripherals&quot;&gt;peripherals&lt;/a&gt;,
and the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/peripherals/zipcounter.v&quot;&gt;performance
counters&lt;/a&gt;
may be found within the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/raw/master/doc/spec.pdf&quot;&gt;reference manual&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The third section of the display in Fig 3 is the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt;
register section.  As you may
&lt;a href=&quot;/zipcpu/2018/01/01/zipcpu-isa.html&quot;&gt;recall&lt;/a&gt;, the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
has two sets of sixteen 32-bit registers.  These are shown in this section.
The registers range from R0 to R12, and then the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Stack_register&quot;&gt;stack pointer (SP)&lt;/a&gt;,
&lt;a href=&quot;https://en.wikipedia.org/wiki/Status_register&quot;&gt;condition codes register (CC)&lt;/a&gt;,
and &lt;a href=&quot;https://en.wikipedia.org/wiki/Program_counter&quot;&gt;program counter (PC)&lt;/a&gt;.
The supervisor set is shown on top, the user set underneath.  The set that
is highlighted indicates which mode the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt;
is currently in–in this case, the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt;
is in supervisor mode.&lt;/p&gt;

&lt;p&gt;The fourth section, coming down from the top, tells you about the bus.
The &lt;code class=&quot;highlighter-rouge&quot;&gt;PF BUS&lt;/code&gt; line gives you information about the
&lt;a href=&quot;/zipcpu/2017/11/18/wb-prefetch.html&quot;&gt;prefetch&lt;/a&gt;
unit, and the &lt;code class=&quot;highlighter-rouge&quot;&gt;MEMBUS&lt;/code&gt; line tells you about the memory module.  The third line
shows the result of the output of the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/aux/wbdblpriarb.v&quot;&gt;arbiter&lt;/a&gt;,
and which of these units actually has access to the bus.&lt;/p&gt;

&lt;p&gt;The final section shows the &lt;a href=&quot;/zipcpu/2017/08/23/cpu-pipeline.html&quot;&gt;instruction
pipeline&lt;/a&gt;.  As you may
&lt;a href=&quot;/zipcpu/2017/08/23/cpu-pipeline.html&quot;&gt;remember&lt;/a&gt;, the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
has a basic five stage &lt;a href=&quot;/zipcpu/2017/08/23/cpu-pipeline.html&quot;&gt;pipeline&lt;/a&gt;.  The bottom of the display shows only four
lines.  These are the output of the
&lt;a href=&quot;/zipcpu/2017/11/18/wb-prefetch.html&quot;&gt;prefetch&lt;/a&gt; (&lt;code class=&quot;highlighter-rouge&quot;&gt;I&lt;/code&gt;), the
output of the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/idecode.v&quot;&gt;instruction
decoder&lt;/a&gt;
(&lt;code class=&quot;highlighter-rouge&quot;&gt;Dc)&lt;/code&gt;, the output of the read operands section (&lt;code class=&quot;highlighter-rouge&quot;&gt;Op&lt;/code&gt;) and the result of the
&lt;a href=&quot;/zipcpu/2017/08/11/simple-alu.html&quot;&gt;ALU&lt;/a&gt; (&lt;code class=&quot;highlighter-rouge&quot;&gt;Al&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;Indeed, this section is &lt;em&gt;so&lt;/em&gt; important for understanding how the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt; works, that we should take a deeper
look at it.  If you hold and press the ‘t’ key for a while, you’ll come across
the state shown in Fig 4 below.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 4, Instruction Pipeline&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/zipsim-insns.png&quot; alt=&quot;&quot; width=&quot;662&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;The first two columns on the left will show &lt;code class=&quot;highlighter-rouge&quot;&gt;Ck&lt;/code&gt; to indicate that the &lt;a href=&quot;/zipcpu/2017/08/23/cpu-pipeline.html&quot;&gt;pipeline&lt;/a&gt;
stage’s &lt;code class=&quot;highlighter-rouge&quot;&gt;CE&lt;/code&gt; line is high, or &lt;code class=&quot;highlighter-rouge&quot;&gt;Stl&lt;/code&gt;, to show that the particular stage is
&lt;em&gt;stalled&lt;/em&gt;.  Most instructions will be followed by a &lt;code class=&quot;highlighter-rouge&quot;&gt;:&lt;/code&gt;, although the first
half of any compressed instruction will be followed by a &lt;code class=&quot;highlighter-rouge&quot;&gt;/&lt;/code&gt;.  Following
the decode stage, either an &lt;code class=&quot;highlighter-rouge&quot;&gt;A&lt;/code&gt; (ALU), &lt;code class=&quot;highlighter-rouge&quot;&gt;M&lt;/code&gt; (memory), or &lt;code class=&quot;highlighter-rouge&quot;&gt;I&lt;/code&gt; (illegal)
character may follow the &lt;code class=&quot;highlighter-rouge&quot;&gt;;&lt;/code&gt; (or &lt;code class=&quot;highlighter-rouge&quot;&gt;/&lt;/code&gt;).  Immediately after this (optional)
character, is the address the instruction was read from.&lt;br /&gt;
If an instruction follows, as with all of the stages in Fig 4
above, then the particular
&lt;a href=&quot;/zipcpu/2017/08/23/cpu-pipeline.html&quot;&gt;pipeline&lt;/a&gt;
stage has valid values within it.
If the instruction is highlighted, its being run in supervisor mode.
These instructions, therefore, are being run from user mode.&lt;/p&gt;

&lt;p&gt;Is this making any sense?  Perhaps you might then be interested in the homework
section that follows.&lt;/p&gt;

&lt;h2 id=&quot;interactive-homework&quot;&gt;Interactive Homework&lt;/h2&gt;

&lt;p&gt;One of the really fun parts of
&lt;a href=&quot;/zipcpu/2017/07/26/cpu-sim-debugger.html&quot;&gt;this simulation&lt;/a&gt;.
is watching how the performance
of the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt;
is impacted by how well the
&lt;a href=&quot;/zipcpu/2017/11/18/wb-prefetch.html&quot;&gt;prefetch&lt;/a&gt;
mechanism works.  This is primarily controlled by some &lt;code class=&quot;highlighter-rouge&quot;&gt;define&lt;/code&gt;s within the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/cpudefs.v&quot;&gt;cpudefs.v&lt;/a&gt; file.&lt;/p&gt;

&lt;p&gt;Since you’ve already looked at how the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt;
operates in its default configuration with a
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/pfcache.v&quot;&gt;prefetch and cache&lt;/a&gt;
enabled,
let’s see how it does with some other
&lt;a href=&quot;/zipcpu/2017/11/18/wb-prefetch.html&quot;&gt;prefetch&lt;/a&gt;
module’s enabled.  Hence, for a second test, let’s uncomment the
&lt;code class=&quot;highlighter-rouge&quot;&gt;OPT_DOUBLE_FETCH&lt;/code&gt; define within
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/cpudefs.v&quot;&gt;cpudefs.v&lt;/a&gt;,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilator&quot; data-lang=&quot;verilator&quot;&gt;define OPT_DOUBLE_FETCH&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;You will then need to re-run make in the
“&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/tree/master/rtl&quot;&gt;rtl/&lt;/a&gt;” directory,
as well as the
“&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/tree/master/sim/verilated&quot;&gt;sim/verilated&lt;/a&gt;”
directory.&lt;/p&gt;

&lt;p&gt;This will switch the CPU from using the
&lt;a href=&quot;/zipcpu/2017/11/18/wb-prefetch.html&quot;&gt;prefetch&lt;/a&gt; and
&lt;a href=&quot;https://en.wikipedia.org/wiki/CPU_cache&quot;&gt;I-cache&lt;/a&gt;
of the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/pfcache.v&quot;&gt;pfcache&lt;/a&gt;
module, to using a module that fetches two instructions at a time:
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/dblfetch.v&quot;&gt;dblfetch&lt;/a&gt;.
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/dblfetch.v&quot;&gt;dblfetch&lt;/a&gt;
was designed to be a simpler
&lt;a href=&quot;/zipcpu/2017/11/18/wb-prefetch.html&quot;&gt;prefetch&lt;/a&gt;
than the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/pfcache.v&quot;&gt;pfcache&lt;/a&gt;
module, but also to have better performance than the single instruction at a
time &lt;a href=&quot;/zipcpu/2017/11/18/wb-prefetch.html&quot;&gt;prefetch&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/prefetch.v&quot;&gt;module&lt;/a&gt;–especially
when reading instructions from
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;flash&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Speaking of the
&lt;a href=&quot;/zipcpu/2017/11/18/wb-prefetch.html&quot;&gt;single prefetch&lt;/a&gt;
module, why don’t we give that one a try?
To see how the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt;
performs with a
&lt;a href=&quot;/zipcpu/2017/11/18/wb-prefetch.html&quot;&gt;prefetch&lt;/a&gt;
module that only retrieves one instruction at a time, go ahead and uncomment
the &lt;code class=&quot;highlighter-rouge&quot;&gt;OPT_SINGLE_FETCH&lt;/code&gt; line from within
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/cpudefs.v&quot;&gt;cpudefs.v&lt;/a&gt;,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilator&quot; data-lang=&quot;verilator&quot;&gt;define OPT_SINGLE_FETCH&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;and then rerun make in the
“&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/tree/master/rtl&quot;&gt;rtl/&lt;/a&gt;” directory,
and
“&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/tree/master/sim/verilated&quot;&gt;sim/verilated&lt;/a&gt;”
directories again.&lt;/p&gt;

&lt;p&gt;See the difference?&lt;/p&gt;

&lt;p&gt;With the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/pfcache.v&quot;&gt;prefetch + cache&lt;/a&gt;, the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt;
has to pause any time the
&lt;a href=&quot;https://en.wikipedia.org/wiki/CPU_cache&quot;&gt;cache&lt;/a&gt;
line needs to be re-filled.  This is particularly pronounced at the beginning
of the
&lt;a href=&quot;/zipcpu/2017/07/26/cpu-sim-debugger.html&quot;&gt;simulation&lt;/a&gt;
where you have to wait many clocks for the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt;
to fill the
&lt;a href=&quot;https://en.wikipedia.org/wiki/CPU_cache&quot;&gt;cache&lt;/a&gt;.
You may also notice the effects of
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/pfcache.v&quot;&gt;this prefetch&lt;/a&gt;
any time the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt;
hits a
branch instruction, whether a
&lt;a href=&quot;/zipcpu/2018/01/01/zipcpu-isa.html&quot;&gt;branch always &lt;code class=&quot;highlighter-rouge&quot;&gt;BRA&lt;/code&gt;&lt;/a&gt;
or a conditional branch
(&lt;a href=&quot;/zipcpu/2018/01/01/zipcpu-isa.html&quot;&gt;nominally a conditional ADD
instruction&lt;/a&gt;)–the
two will have different effects within the
&lt;a href=&quot;/zipcpu/2017/07/26/cpu-sim-debugger.html&quot;&gt;simulator&lt;/a&gt;.
The
&lt;a href=&quot;/zipcpu/2018/01/01/zipcpu-isa.html&quot;&gt;branch always&lt;/a&gt;
instruction will suffer a single stall, and then (appear to) replace the
branch instruction moving through the
&lt;a href=&quot;/zipcpu/2017/08/23/cpu-pipeline.html&quot;&gt;pipeline&lt;/a&gt; with the
instruction prior to the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Branch_(computer_science)&quot;&gt;branch&lt;/a&gt;
target.  This is primarily an effect within the
&lt;a href=&quot;/zipcpu/2017/07/26/cpu-sim-debugger.html&quot;&gt;simulator viewer&lt;/a&gt;,
the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt;
doesn’t actually execute this other instruction, but it does send the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Branch_(computer_science)&quot;&gt;branch&lt;/a&gt;’s
target address through the
&lt;a href=&quot;/zipcpu/2017/08/23/cpu-pipeline.html&quot;&gt;pipeline&lt;/a&gt;–leading to
the misleading view.  The
&lt;a href=&quot;/zipcpu/2018/01/01/zipcpu-isa.html&quot;&gt;conditional branch&lt;/a&gt;,
on the other hand, will clear the
&lt;a href=&quot;/zipcpu/2017/08/23/cpu-pipeline.html&quot;&gt;pipeline&lt;/a&gt;
anytime it is taken.  If the result is in the
&lt;a href=&quot;https://en.wikipedia.org/wiki/CPU_cache&quot;&gt;cache&lt;/a&gt;,
then the new instructions will start filling the (now empty)
&lt;a href=&quot;/zipcpu/2017/08/23/cpu-pipeline.html&quot;&gt;pipeline&lt;/a&gt;
following the branch.&lt;/p&gt;

&lt;p&gt;On the other hand, with the
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;single prefetch&lt;/a&gt;
module, the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt;
is unable to fill its
&lt;a href=&quot;/zipcpu/2017/08/23/cpu-pipeline.html&quot;&gt;pipeline&lt;/a&gt;.
It seems to be forever fetching the next instruction, while spending
very little time actually executing instructions.&lt;/p&gt;

&lt;p&gt;When I first saw this difference, I suddenly learned a lot about how
important the
&lt;a href=&quot;https://en.wikipedia.org/wiki/CPU_cache&quot;&gt;cache&lt;/a&gt;
is to
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;
performance.  It was for this purpose that I wanted to share
this demonstration with you–I just found it very valuable.&lt;/p&gt;

&lt;h2 id=&quot;next-time&quot;&gt;Next Time&lt;/h2&gt;

&lt;p&gt;Our next step, now that you’ve built the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
toolchain, will be to run the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/sw/board/cputest.c&quot;&gt;test program&lt;/a&gt;
program from within the
&lt;a href=&quot;https://github.com/ZipCPU/zbasic&quot;&gt;ZBasic&lt;/a&gt;
repository.  This goes beyond testing just the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt;–it involves testing a
&lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/sw/verilated/qspiflashsim.cpp&quot;&gt;simulated flash&lt;/a&gt;
and a &lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/sw/verilated/dbluartsim.cpp&quot;&gt;simulated serial
port&lt;/a&gt;–together
with their controllers.  If time permits, I’ll even add the instructions
to play &lt;a href=&quot;https://github.com/ZipCPU/tttt&quot;&gt;4x4x4 tic-tac-toe&lt;/a&gt;
within that demonstration–it’s a fun game and a nice way to relieve the
stress of getting something new working.&lt;/p&gt;

&lt;p&gt;Beyond that, I’ve still got a couple of blogging articles planned along
this line.  The next article I have planned will show how to add a
&lt;a href=&quot;https://github.com/ZipCPU/wbpmic&quot;&gt;microphone controller&lt;/a&gt;
component to
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;wishbone bus&lt;/a&gt;
within the
&lt;a href=&quot;https://github.com/ZipCPU/zbasic&quot;&gt;ZBasic&lt;/a&gt;
implementation using
&lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt;.  I’d also like to show
how you can profile a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;
running
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;Dhrystone&lt;/a&gt;
within a
&lt;a href=&quot;/zipcpu/2017/07/26/cpu-sim-debugger.html&quot;&gt;simulator&lt;/a&gt;,
using a capability similar to the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;’s
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/sim/verilated/pdump.cpp&quot;&gt;pdump&lt;/a&gt;
program.  This was also very instructive to me, since it helped me
understand where and when the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt;
ended up stalling, and what it would stall for under a reasonable load.&lt;/p&gt;

&lt;p&gt;So, stick around, there’s more coming!&lt;/p&gt;
&lt;hr /&gt;&lt;p&gt;&lt;em&gt;Shall the axe boast itself against him that heweth therewith? or shall the saw magnify itself against him that shaketh it? as if the rod should shake itself against them that lift it up, or as if the staff should lift up itself, as if it were no wood. (Isaiah 10:15)&lt;/em&gt;</description>
        <pubDate>Wed, 31 Jan 2018 00:00:00 -0500</pubDate>
        <link>http://zipcpu.com/zipcpu/2018/01/31/cpu-build.html</link>
        <guid isPermaLink="true">http://zipcpu.com/zipcpu/2018/01/31/cpu-build.html</guid>
        
        
        <category>zipcpu</category>
        
      </item>
    
      <item>
        <title>Updating ZipCPU files</title>
        <description>&lt;p&gt;Several of you have asked me, following the
&lt;a href=&quot;/zipcpu/2018/01/01/zipcpu-isa.html&quot;&gt;ZipCPU ISA introduction&lt;/a&gt;
article,
to present instructions for building and trying out the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; for yourselves. 
I would like to do that.  Indeed, I’m planning on it.  If the Lord is willing,
this will be my next article.  If I get stuck along the way and it takes too
long to get there, then I might just pause and describe a &lt;a href=&quot;https://github.com/ZipCPU/interpolation/blob/master/rtl/quadratic/quadinterp.v&quot;&gt;quadratic
interpolator&lt;/a&gt;
first, but if the Lord remains willing we’ll still get there.&lt;/p&gt;

&lt;p&gt;This week, however, I’ve gotten stuck into the “just-one-more” (fill in the
blank) change loop.  Most of these changes have centered around
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal verifying&lt;/a&gt;
that the various components of the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
works as designed.&lt;/p&gt;

&lt;p&gt;At first the task was easy–I just started building
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal verification&lt;/a&gt;
proofs for the little components within the 
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;–you know, the peripherals that
just &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/zipcounter.v&quot;&gt;count
instructions&lt;/a&gt;,
or the one that justs &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/zipcounter.v&quot;&gt;counts down to zero and then creates an
interrupt&lt;/a&gt;.
In each case, I’ve gotten to the point where I think I’m ready to post the
“here’s how to get started article”, and I think to myself, “Just one more
proof.”
I mean, how hard can a &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/ziptimer.v&quot;&gt;simple
timer&lt;/a&gt;
be, for example?&lt;/p&gt;

&lt;p&gt;Well, that &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/ziptimer.v&quot;&gt;simple timer&lt;/a&gt;
was harder to
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formally verify&lt;/a&gt;
than I expected.&lt;/p&gt;

&lt;p&gt;Then, after I wrote up the chart below, things started to become a challenge.
Surely I could
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formally verify&lt;/a&gt; the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/wbdmac.v&quot;&gt;DMA controller&lt;/a&gt;, right?
I wouldn’t want to present the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; to others if there was a subtle
bug within the 
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/wbdmac.v&quot;&gt;DMA
controller&lt;/a&gt; that 
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal methods&lt;/a&gt;
could find, right?
The &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/wbdmac.v&quot;&gt;DMA
controller&lt;/a&gt;,
I told myself, should be easy: I’ve already put together the set of &lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;formal
Wishbone properties&lt;/a&gt;
necessary to make certain it works, the hard work has been done, right?&lt;/p&gt;

&lt;p&gt;One day later, I have a &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/wbdmac.v&quot;&gt;wonderful
proof&lt;/a&gt;
that my &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/wbdmac.v&quot;&gt;DMA
controller&lt;/a&gt;
works, but I’m no closer to writing the getting started article.
Of course, it didn’t help that I adjusted how I expressed the
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;wishbone properties&lt;/a&gt;,
and so other components–notably the (yet to be integrated)
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/zipmmu.v&quot;&gt;MMU&lt;/a&gt;
had to be adjusted to work with this new property description as well …&lt;/p&gt;

&lt;p&gt;However, with everyone of these projects, I’m getting closer and closer to
being able to &lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formally
verify&lt;/a&gt;
the &lt;em&gt;entire &lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt;&lt;/em&gt;.  Even further, I
intended to do a full proof, including not only bounded model checking but
induction as well.&lt;/p&gt;

&lt;p&gt;Just so you see how far I’ve gotten, here’s a list of the RTL components
in the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt; project,
together with whether or not I’ve managed to finish
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formally verifying&lt;/a&gt;
the component or not.&lt;/p&gt;

&lt;table class=&quot;bordered-table&quot;&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Project&lt;/th&gt;
      &lt;th&gt;Component&lt;/th&gt;
      &lt;th&gt;Purpose&lt;/th&gt;
      &lt;th&gt;Status&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/prefetch.v&quot;&gt;prefetch&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;Single Insn Prefetch&lt;/td&gt;
      &lt;td&gt;&lt;em&gt;Proven&lt;/em&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/dblfetch.v&quot;&gt;dblfetch&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;Two Insn Pipelind Prefetch&lt;/td&gt;
      &lt;td&gt;&lt;em&gt;Proven&lt;/em&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/pfcache.v&quot;&gt;pfcache&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;Prefetch and integrated instruction cache&lt;/td&gt;
      &lt;td&gt;&lt;em&gt;Proven&lt;/em&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/idecode.v&quot;&gt;idecode&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;Instruction decoder&lt;/td&gt;
      &lt;td&gt;&lt;em&gt;Proven&lt;/em&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/div.v&quot;&gt;div&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;Divide module&lt;/td&gt;
      &lt;td&gt;&lt;em&gt;Proven&lt;/em&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/memops.v&quot;&gt;memops&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;Memory Interface Module&lt;/td&gt;
      &lt;td&gt;&lt;em&gt;Proven&lt;/em&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/pipemem.v&quot;&gt;pipemem&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;Memory Module, supporting pipelind mem access&lt;/td&gt;
      &lt;td&gt;&lt;em&gt;Proven&lt;/em&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/icontrol.v&quot;&gt;icontrol&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;Interrupt controller&lt;/td&gt;
      &lt;td&gt;&lt;em&gt;Proven&lt;/em&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/zipjiffies.v&quot;&gt;zipjiffies&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;I/O Scheduling peripheral&lt;/td&gt;
      &lt;td&gt;&lt;em&gt;Proven&lt;/em&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/zipcounter.v&quot;&gt;zipcounter&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;Performance counter&lt;/td&gt;
      &lt;td&gt;&lt;em&gt;Proven&lt;/em&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/ziptimer.v&quot;&gt;ziptimer&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;Count-down timer&lt;/td&gt;
      &lt;td&gt;&lt;em&gt;Proven&lt;/em&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/wbdmac.v&quot;&gt;wbdmac&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;CPU DMA Controller&lt;/td&gt;
      &lt;td&gt;&lt;em&gt;Proven&lt;/em&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/zipmmu.v&quot;&gt;zipmmu&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;External MMU peripheral&lt;/td&gt;
      &lt;td&gt;&lt;em&gt;Proven&lt;/em&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/aux/busdelay.v&quot;&gt;busdelay&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;A timing saving bus delay&lt;/td&gt;
      &lt;td&gt;&lt;em&gt;Proven&lt;/em&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/aux/wbpriarbiter.v&quot;&gt;wbpriarbiter&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;A wishbone priority arbiter&lt;/td&gt;
      &lt;td&gt;&lt;em&gt;Proven&lt;/em&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/aux/wbdblpriarb.v&quot;&gt;wbdblpriarb&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;A priority arbiter for a pair of shared wishbone interfaces&lt;/td&gt;
      &lt;td&gt;&lt;em&gt;Proven&lt;/em&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/cpuops.v&quot;&gt;cpuops&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;ALU component&lt;/td&gt;
      &lt;td&gt;(Not started)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;zipcpu&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;Master CPU controller&lt;/td&gt;
      &lt;td&gt;(Not started)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/zipbones.v&quot;&gt;zipbones&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;CPU Container&lt;/td&gt;
      &lt;td&gt;(Not started)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/zipsystem.v&quot;&gt;zipsystem&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;CPU Container with Peripherals&lt;/td&gt;
      &lt;td&gt;(Not started)&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 1. Components of a ZipSystem&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/zipsystem.svg&quot; alt=&quot;&quot; width=&quot;420&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;Pictorially, you can see most of these components in the diagram of the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/zipsystem.v&quot;&gt;ZipSystem&lt;/a&gt;
shown to the right in Fig 1.  I’ve proven all of the
peripheral components shown in boxes on the right, as well as all of the
sub-components within the CPU in the yellow box on the left.  (The
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
still doesn’t have an FPU component, and the
&lt;a href=&quot;/zipcpu/2017/08/11/simple-alu.html&quot;&gt;ALU&lt;/a&gt; was forgotten
when I initially built the table above.) The large yellow box on the left
that is the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
within the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/zipsystem.v&quot;&gt;ZipSystem&lt;/a&gt;
still remains to be proven, as does the area with
the blue background known as the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/zipsystem.v&quot;&gt;ZipSystem&lt;/a&gt;.
However, I’m getting a lot closer–having now proved all but one of the
components within these two aggregate components.&lt;/p&gt;

&lt;p&gt;Indeed, if you just judge from the table (and figure) above, I’ve got the
entire
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt; periphery proven, just not the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;core module&lt;/a&gt;
itself or the two container modules–the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipsystem.v&quot;&gt;zipsystem&lt;/a&gt;,
or the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipbones.v&quot;&gt;zipbones&lt;/a&gt;.
As for the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;main CPU
component&lt;/a&gt;,
I’ve started working on it–but haven’t tried it to see how far I could
get.  My biggest fear there is that there’s some pipeline bug still lying
dormant within the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
that I will only discover via
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formal verification&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;I’ve certainly found several subtle bugs along the way.  For example, just
the right sequence of commands and the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/wbdmac.v&quot;&gt;DMA
controller&lt;/a&gt;
would try to initiate a bus transaction of zero length–violating a primary
assertion.  As another example, that &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/ziptimer.v&quot;&gt;simple count-down
timer&lt;/a&gt;
would “break” if just the right series of commands were given to it.  Or worse,
the (soon to be integrated)
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/zipmmu.v&quot;&gt;MMU&lt;/a&gt;
component would sometimes place the last physical page address on the bus
instead of the one appropriate for the current bus request.&lt;/p&gt;

&lt;p&gt;I’m hoping to present these proven components here on
&lt;a href=&quot;http://zipcpu.com/&quot;&gt;this blog&lt;/a&gt; in time.  If
you are interested in the proofs before then, you should be able to find some
of those proofs in the development branch of the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/tree/dev&quot;&gt;ZipCPU repository&lt;/a&gt;, otherwise feel
free to write if you don’t find what you are looking for.  It will take
me some time to integrate these components and then to write the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
getting started “how-to” instructions, since I want to make certain that
the test benches within the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/tree/dev&quot;&gt;ZipCPU
repository&lt;/a&gt;
still work (I think I broke one or two), that the &lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/sw/board/cputest.c&quot;&gt;CPU
test&lt;/a&gt;
within the &lt;a href=&quot;https://github.com/ZipCPU/zbasic&quot;&gt;ZBasic repository&lt;/a&gt;
continues to work, as well as making certain that the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt;
still builds within both &lt;a href=&quot;https://www.xilinx.com&quot;&gt;Xilinx&lt;/a&gt;’s
&lt;a href=&quot;https://www.xilinx.com/products/design-tools/ise-design-suite.html&quot;&gt;ISE&lt;/a&gt;
(i.e. the &lt;a href=&quot;https://github.com/ZipCPU/xulalx25soc&quot;&gt;XuLA2-LX25 SoC repository&lt;/a&gt;)
and &lt;a href=&quot;https://www.xilinx.com/products/design-tools/vivado.html&quot;&gt;Vivado&lt;/a&gt;
(i.e. either the &lt;a href=&quot;https://github.com/ZipCPU/videozip&quot;&gt;VideoZip&lt;/a&gt;
or the &lt;a href=&quot;https://github.com/ZipCPU/openarty&quot;&gt;OpenArty&lt;/a&gt; repository).&lt;/p&gt;

&lt;p&gt;Getting these components to build for five separate synthesis engines,
&lt;a href=&quot;https://veripool.org/wiki/verilator&quot;&gt;Verilator&lt;/a&gt;,
&lt;a href=&quot;http://www.clifford.at/yosys/&quot;&gt;yosys&lt;/a&gt;,
&lt;a href=&quot;https://www.xilinx.com/products/design-tools/ise-design-suite.html&quot;&gt;ISE&lt;/a&gt;,
&lt;a href=&quot;https://www.xilinx.com/products/design-tools/vivado.html&quot;&gt;Vivado&lt;/a&gt;, and (now
hopefully)
&lt;a href=&quot;https://www.altera.com/products/design-software/fpga-design/quartus-prime/overview.html&quot;&gt;Quartus&lt;/a&gt;,
has become such a hassle, that I’ve asked among my friends in the
&lt;a href=&quot;https://openrisc.io&quot;&gt;OpenRISC&lt;/a&gt;
world for some ideas to help, and I’ve been told that
&lt;a href=&quot;https://github.com/olofk/fusesoc&quot;&gt;FuseSoC&lt;/a&gt;
can handle testing builds for all of these different synthesis tools
with one configuration.  I think I’m going to need to try that.&lt;/p&gt;

&lt;h2 id=&quot;other-components&quot;&gt;Other Components&lt;/h2&gt;

&lt;p&gt;I’ve also slowly been
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formally verifying&lt;/a&gt;
many of the peripherals I’ve been working with.  Below, therefore, are some
other important components that I’ve managed to
&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;formally verify&lt;/a&gt; as
well:&lt;/p&gt;

&lt;table class=&quot;bordered-table&quot;&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Project&lt;/th&gt;
      &lt;th&gt;Component&lt;/th&gt;
      &lt;th&gt;Purpose&lt;/th&gt;
      &lt;th&gt;Status&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;a href=&quot;https://github.com/ZipCPU/xulalx25soc&quot;&gt;XuLA2-LX25&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;https://github.com/ZipCPU/xulalx25soc/blob/master/rtl/wbsdram.v&quot;&gt;wbsdram&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;SDRAM controller&lt;/td&gt;
      &lt;td&gt;&lt;em&gt;Proven&lt;/em&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;a href=&quot;https://github.com/ZipCPU/wb2axip&quot;&gt;wb2axip&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;https://github.com/ZipCPU/wb2axip/blob/master/rtl/wbm2axisp.v&quot;&gt;wbm2axip&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;Pipelined WB to AXI converter&lt;/td&gt;
      &lt;td&gt;&lt;em&gt;Proven&lt;/em&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;a href=&quot;https://github.com/ZipCPU/vgasim&quot;&gt;vgasim&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;https://github.com/ZipCPU/vgasim/blob/master/rtl/llvga.v&quot;&gt;llvga&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;Low-level VGA Controller&lt;/td&gt;
      &lt;td&gt;&lt;em&gt;Proven&lt;/em&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;a href=&quot;https://github.com/ZipCPU/wbpmic&quot;&gt;wbpmic&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;https://github.com/ZipCPU/wbpmic/blob/master/rtl/wbsmpladc.v&quot;&gt;wbsmpladc&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;Simple WB A/D Controller&lt;/td&gt;
      &lt;td&gt;&lt;em&gt;Proven&lt;/em&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;https://github.com/ZipCPU/wbpmic/blob/master/rtl/smplfifo.v&quot;&gt;smplfifo&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;A/D Converter’s FIFO&lt;/td&gt;
      &lt;td&gt;&lt;em&gt;Proven&lt;/em&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;https://github.com/ZipCPU/wbpmic/blob/master/rtl/smpladc.v&quot;&gt;smpladc&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;SPI based A/D Converter&lt;/td&gt;
      &lt;td&gt;&lt;em&gt;Proven&lt;/em&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;a href=&quot;https://github.com/ZipCPU/wbuart32&quot;&gt;wbuart&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;https://github.com/ZipCPU/wbuart32/blob/master/rtl/ufifo.v&quot;&gt;ufifo&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;Generic FIFO for serial ports&lt;/td&gt;
      &lt;td&gt;&lt;em&gt;Proven&lt;/em&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;a href=&quot;https://github.com/ZipCPU/wbuart32&quot;&gt;wbuart&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;https://github.com/ZipCPU/wbuart32/blob/master/rtl/txuartlite.v&quot;&gt;txuartlite&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;Bare bones serial port transmitter&lt;/td&gt;
      &lt;td&gt;&lt;em&gt;Proven&lt;/em&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;a href=&quot;https://github.com/ZipCPU/dspfilters&quot;&gt;dspfilters&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/lfsr.v&quot;&gt;lfsr&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;Generic LFSR&lt;/td&gt;
      &lt;td&gt;&lt;em&gt;Proven&lt;/em&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;a href=&quot;https://github.com/ZipCPU/dspfilters&quot;&gt;dspfilters&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/delayw.v&quot;&gt;delayw&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;Signal delay module&lt;/td&gt;
      &lt;td&gt;&lt;em&gt;Proven&lt;/em&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;a href=&quot;http://opencores.org/project,qspiflash&quot;&gt;qspiflash&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;https://opencores.org/websvn,filedetails?repname=qspiflash&amp;amp;path=%2Fqspiflash%2Ftrunk%2Frtl%2Fllqspi.v&quot;&gt;llqspi&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;Low level QSPI flash driver&lt;/td&gt;
      &lt;td&gt;&lt;em&gt;Proven&lt;/em&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;Each of these components has a story to tell.  For example, I found the subtlest
of bugs in the &lt;a href=&quot;https://github.com/ZipCPU/xulalx25soc/blob/master/rtl/wbsdram.v&quot;&gt;SDRAM memory
controller&lt;/a&gt;,
a bug that in rare cases would have caused the &lt;a href=&quot;https://github.com/ZipCPU/xulalx25soc/blob/master/rtl/wbsdram.v&quot;&gt;memory
controller&lt;/a&gt;
to read or write the wrong memory address (i.e., the right column but the
wrong row).  I’ll admit, I was a bit surprised to find this, as I’ve now been
using this
&lt;a href=&quot;https://github.com/ZipCPU/xulalx25soc/blob/master/rtl/wbsdram.v&quot;&gt;memory controller&lt;/a&gt;
for years now and haven’t hit that bug.  (Not all of these proofs have been
pushed to their respective repositories yet …)&lt;/p&gt;

&lt;p&gt;All of the items listed above are candidates for future blog articles–both
the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; and its components as well
as the peripherals listed above.  Not only do I think they might be of interest
to some, but blogging about them will also give me the opportunity to clean up
the code a bit following this last mad dash to prove the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Oh, by the way, if you want to get started with the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; before I write my getting
started article, you can find some &lt;a href=&quot;/zipcpu/2017/08/23/cpu-pipeline.html&quot;&gt;simple getting-started instructions
here&lt;/a&gt;–just to get you
going until I write up something prettier.&lt;/p&gt;
&lt;hr /&gt;&lt;p&gt;&lt;em&gt;So likewise ye, when ye shall have done all those things which are commanded you, say, We are unprofitable servants: we have done that which was our duty to do.  (Luke 17:10)&lt;/em&gt;</description>
        <pubDate>Mon, 22 Jan 2018 00:00:00 -0500</pubDate>
        <link>http://zipcpu.com/blog/2018/01/22/formal-progress.html</link>
        <guid isPermaLink="true">http://zipcpu.com/blog/2018/01/22/formal-progress.html</guid>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>Interpolation is just a special type of convolution</title>
        <description>&lt;p&gt;The most profound lessons I’ve learned regarding
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolation&lt;/a&gt;
were that first,
&lt;a href=&quot;https://en.wikipedia.org/wiki/Shift-invariant_system&quot;&gt;shift invariant&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolators&lt;/a&gt;
existed, and second that the effects of a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Shift-invariant_system&quot;&gt;shift invariant&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;
can be described in the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency_domain&quot;&gt;frequency domain&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;But let’s back up a step to tell this story from the beginning.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;Interpolation&lt;/a&gt;
refers to a class of methods or algorithms for reconstructing a waveform’s
value &lt;em&gt;between&lt;/em&gt; given sample points.
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;Interpolation&lt;/a&gt; is
an important part of any sample rate conversion algorithm.
As a result, it is studied as part of both
&lt;a href=&quot;https://en.wikipedia.org/wiki/Numerical_analysis&quot;&gt;numerical analysis&lt;/a&gt; is
as well as &lt;a href=&quot;https://en.wikipedia.org/wiki/Sample-rate_conversion&quot;&gt;mutirate digital signal
processing&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;As part of &lt;a href=&quot;http://zipcpu.com/&quot;&gt;this blog&lt;/a&gt;,
we’ve already discussed &lt;a href=&quot;/dsp/2017/06/06/simple-interpolator.html&quot;&gt;nearest-neighbour
interpolation&lt;/a&gt; and
&lt;a href=&quot;/dsp/2017/07/29/series-linear-interpolation.html&quot;&gt;linear interpolation&lt;/a&gt;.  Going further, though, requires a bit of a background
understanding.  Since the necessary background wasn’t something I learned
when I last studied
&lt;a href=&quot;https://en.wikipedia.org/wiki/Numerical_analysis&quot;&gt;numerical analysis&lt;/a&gt;,
I figured you might be interested as well.&lt;/p&gt;

&lt;p&gt;Today, therefore, let’s look beyond &lt;a href=&quot;/dsp/2017/07/29/series-linear-interpolation.html&quot;&gt;linear
interpolation&lt;/a&gt;
and lay the ground work for better
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
based &lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial&quot;&gt;polynomial&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolation&lt;/a&gt; algorithms.&lt;/p&gt;

&lt;h2 id=&quot;my-own-history-with-interpolation&quot;&gt;My own history with interpolation&lt;/h2&gt;

&lt;p&gt;I first became seriously interested in
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolation&lt;/a&gt;
when I tried to follow and recreate &lt;a href=&quot;https://ieeexplore.ieee.org/document/134480/&quot;&gt;William Gardner’s cyclostationary
signal processing results&lt;/a&gt;
as part of my &lt;a href=&quot;http://www.dtic.mil/dtic/tr/fulltext/u2/a423141.pdf&quot;&gt;Ph.D.
Research&lt;/a&gt;.
Gardner &lt;a href=&quot;https://ieeexplore.ieee.org/document/134480/&quot;&gt;had stated&lt;/a&gt; that by using
&lt;a href=&quot;https://en.wikipedia.org/wiki/Cyclostationary_process&quot;&gt;cyclostationary&lt;/a&gt;
methods, his &lt;a href=&quot;https://en.wikipedia.org/wiki/Multilateration&quot;&gt;time difference of arrival
(TDOA)&lt;/a&gt; algorithm could
outperform all others.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;These new algorithms are tolerant to both interfering signals and noise,
and they can outperform conventional algorithms that achieve the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Cramer-Rao_bound&quot;&gt;Cramer-Rao&lt;/a&gt;
lower bound on variance for stationary signals because the signals considered
here are nonstationary
(&lt;a href=&quot;https://en.wikipedia.org/wiki/Cyclostationary_process&quot;&gt;cyclostationary&lt;/a&gt;)
and the algorithms expoit the nonstationarity to discriminate against noise
and interference.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;A &lt;a href=&quot;https://en.wikipedia.org/wiki/Multilateration&quot;&gt;TDOA&lt;/a&gt; estimator,
for those not familiar with the algorithm, takes two input signals, where one
is nominally the other delayed by some amount of time, runs a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Cross-correlation&quot;&gt;cross-correlation&lt;/a&gt;
between them, and then finds the location of the maximum value that results.
[&lt;a href=&quot;http://theduchy.ualr.edu/wordpress/wp-content/uploads/2017/06/scan0007.pdf&quot;&gt;Ref&lt;/a&gt;]&lt;/p&gt;

&lt;p&gt;Gardner, however, had insisted in his problem setup that the two simulated
signals were to be delayed with respect to
each other by an &lt;em&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Integer&quot;&gt;integer&lt;/a&gt;
number of samples&lt;/em&gt;, and then &lt;em&gt;assumed the peak
would lie on a sample point&lt;/em&gt;.  This process skipped the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;
that would be necessary for any real life application, and so his
estimation errors suddenly (and artificially) dropped to zero.  This erroneous
result then overinflated the performance of his algorithm.&lt;/p&gt;

&lt;p&gt;This lead me to study the question of which
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;
is better when peak finding?&lt;/p&gt;

&lt;p&gt;Peak finding in &lt;a href=&quot;https://en.wikipedia.org/wiki/Multilateration&quot;&gt;TDOA&lt;/a&gt;
estimation, however, is only one purpose of an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;.
Other purposes for
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolation&lt;/a&gt;
aren’t hard to come by:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;Interpolators&lt;/a&gt;
are commonly needed to process audio signals.  They are used to &lt;a href=&quot;https://en.wikipedia.org/wiki/Sample-rate_conversion&quot;&gt;change
sampling rates&lt;/a&gt;, such
as from an 8kHz sample rate to a 44.1kHz sample rate, or from a 44.1kHz
sample rate to a 48kHz sample rate.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;Interpolators&lt;/a&gt; are used within
video display devices having a fixed resolution, to allow them to
display other resolutions.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;When I was working with
&lt;a href=&quot;https://en.wikipedia.org/wiki/Global_Positioning_System&quot;&gt;GPS&lt;/a&gt;
signals years ago, the digitizer would sample some
&lt;a href=&quot;https://en.wikipedia.org/wiki/Integer&quot;&gt;integer&lt;/a&gt;
number of samples per chip.  However, in order to use
&lt;a href=&quot;https://en.wikipedia.org/wiki/Fast_Fourier_transform&quot;&gt;Fast Fourier transform&lt;/a&gt;
signal processing methods, the data needs to be resampled from the 1023N
samples per block that came from the digitizer to &lt;code class=&quot;highlighter-rouge&quot;&gt;1024*2^M&lt;/code&gt;
samples per block–a power of two.  This requires an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Upsampling&quot;&gt;upsampling&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolation&lt;/a&gt;
rate of 1024/1023—a difficult ratio to achieve using
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sample-rate_conversion&quot;&gt;rational resampling&lt;/a&gt;
methods.  (In the end, we actually downsampled the signal by 8192/1023 …)&lt;/p&gt;

    &lt;p&gt;Indeed, &lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolation&lt;/a&gt; in a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Global_Positioning_System&quot;&gt;GPS&lt;/a&gt;
processing system isn’t limited to the front end (re)sampler.  It’s also
an important part of picking the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Cross-correlation&quot;&gt;correlation&lt;/a&gt;
peak that is part of the measurement used to determine your location as well.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Many &lt;a href=&quot;https://en.wikipedia.org/wiki/Sine_wave&quot;&gt;sine wave&lt;/a&gt;
implementations are based around a &lt;a href=&quot;/dsp/2017/07/11/simplest-sinewave-generator.html&quot;&gt;table
lookup&lt;/a&gt;.
If you want to control the distortion in the resulting
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sine_wave&quot;&gt;sine wave&lt;/a&gt;, knowing how the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt; responds is
important to evaluating how good your &lt;a href=&quot;/dsp/2017/07/11/simplest-sinewave-generator.html&quot;&gt;table
lookup&lt;/a&gt;
method is.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Most satellite &lt;a href=&quot;https://en.wikipedia.org/wiki/Orbit&quot;&gt;orbits&lt;/a&gt;
are communicated with sampled positions from a special
&lt;a href=&quot;https://en.wikipedia.org/wiki/Orbit&quot;&gt;orbital&lt;/a&gt;
propagator.  However,
&lt;a href=&quot;https://en.wikipedia.org/wiki/Satellite_navigation&quot;&gt;satellite navigation&lt;/a&gt;
work, such as
&lt;a href=&quot;https://en.wikipedia.org/wiki/Global_Positioning_System&quot;&gt;GPS&lt;/a&gt;, requires
knowing the satellite’s position often on nanosecond level timesteps.
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;Interpolation&lt;/a&gt; is used to
address the problem of determining what happens between the points.&lt;/p&gt;

    &lt;p&gt;Even better, as we’ll touch on below, if you can quantify the error in your
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;, such as by
using &lt;a href=&quot;https://en.wikipedia.org/wiki/Fourier_analysis&quot;&gt;Fourier analysis&lt;/a&gt;,
you can also quantify the error in your navigation system.  You might even
be able to relax the requirements of your numerical satellite propagation
engine with a sufficiently powerful
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;When I built a suite of tools for &lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_signal_processing&quot;&gt;digital signal
processing&lt;/a&gt;
and display years ago, I used an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt; as part of the
GUI to allow the user to zoom in on any signal by an arbitrary amount.  Even
better, by using a quadratic
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;,
the signal lost most of the obvious evidences of being sampled in the first
place.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;When presenting the &lt;a href=&quot;/dsp/2017/09/16/pwm-demo.html&quot;&gt;demonstration of the improved
PWM&lt;/a&gt; signal, we only used a
&lt;a href=&quot;/dsp/2017/06/06/simple-interpolator.html&quot;&gt;nearest-neighbour&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt; to go from the
audio sample rate to output samples.  Because we didn’t use a good
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;,
our test waveform had many &lt;a href=&quot;https://en.wikipedia.org/wiki/Aliasing&quot;&gt;aliasing&lt;/a&gt;
artifacts in addition to the artifacts due to the
&lt;a href=&quot;/dsp/2017/09/04/pwm-reinvention&quot;&gt;PWM&lt;/a&gt;
modulation.&lt;/p&gt;

    &lt;p&gt;Replacing the
&lt;a href=&quot;/dsp/2017/06/06/simple-interpolator.html&quot;&gt;nearest-neighbour&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;
with either a
&lt;a href=&quot;/dsp/2017/07/29/series-linear-interpolation.html&quot;&gt;linear&lt;/a&gt;
or quadratic
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;
would’ve removed most of those extra artifacts.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;While the description above highlights my own personal background and reasons
for studying
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolation&lt;/a&gt; theory after
my graduate studies, these few examples can hardly do justice to the number
of times and places where a good
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt; is required.
Hence, when it comes time for you to choose a good 
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;, you’ll want to
remember the lessons we are about to discuss.&lt;/p&gt;

&lt;h2 id=&quot;key-assumptions&quot;&gt;Key Assumptions&lt;/h2&gt;

&lt;p&gt;The field of &lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolation&lt;/a&gt;
is fairly well established with lots of approaches and “solutions”.  To limit
our discussion, therefore, we’ll need to make some assumptions about what
types of &lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolators&lt;/a&gt;
are appropriate for
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_signal_processing&quot;&gt;signal processing&lt;/a&gt;
on an &lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;.
You may wish to read this section carefully, though, because the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolation&lt;/a&gt; theory and
conclusions I’ll present later will be driven by these assumptions.&lt;/p&gt;

&lt;p&gt;The first couple of assumptions are quite basic to &lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_signal_processing&quot;&gt;digital signal
processing&lt;/a&gt; in general:
the input is assumed to be a
&lt;em&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;sampled&lt;/a&gt;
data stream&lt;/em&gt; that is formed from
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;sampling&lt;/a&gt;:
an &lt;em&gt;infinite signal source&lt;/em&gt; (in time) at &lt;em&gt;equidistant samples&lt;/em&gt;.
An example of such a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;sampled&lt;/a&gt;
signal is shown below in Fig 1.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 1. Sampled data, the beginning of any interpolation problem&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/sampled-data.png&quot; alt=&quot;This figure shows a picture of a swept frequency sine wave, that has been sampled.  The samples are represented by impulses, the original sinewave by a dotted curve&quot; width=&quot;595&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;In the figure above, you can see the sampled points represented by green
circles, and the original waveform in dotted gray.  The purpose of the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;
is to estimate or recover the signal between the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;sample&lt;/a&gt;
points.&lt;/p&gt;

&lt;p&gt;The waveform shown in Fig 1 above also makes a wonderful example waveform:
it is a swept frequency tone.  Hence, the frequency of the tone on the
left is lower than that on the right.  As a result, and as we’ll discuss,
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolating&lt;/a&gt;
the signal on the left side is easy, but it gets harder on the right.  Indeed,
you might notice within the figure
how &lt;a href=&quot;https://en.wikipedia.org/wiki/Aliasing&quot;&gt;aliasing&lt;/a&gt;
starts to dominate on the far right.  Indeed, this figure works as such a good
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolation&lt;/a&gt;
test, that I used it throughout the
&lt;a href=&quot;https://github.com/ZipCPU/interpolation/raw/master/tutorial.pdf&quot;&gt;tutorial slides&lt;/a&gt;
I built to discuss this the topic.  We can return to this later.&lt;/p&gt;

&lt;p&gt;For now, let’s introduce two further key assumptions.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;The first of these key assumptions is that we are looking for a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Linear_map&quot;&gt;linear operator&lt;/a&gt;.
Adding two
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;sample&lt;/a&gt;
streams together before applying the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;
should therefore produce an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolation&lt;/a&gt;
of their sum signal.  Multiplying the incoming signal by a constant (scalar)
should produce a scaled output signal.&lt;/p&gt;

    &lt;p&gt;While
&lt;a href=&quot;/dsp/2017/09/27/quantization.html&quot;&gt;quantization&lt;/a&gt;
will have an effect on these two properties of
&lt;a href=&quot;https://en.wikipedia.org/wiki/Linear_map&quot;&gt;linearity&lt;/a&gt;, let’s ignore it
for now and just focus on
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolating&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Real_number&quot;&gt;real&lt;/a&gt; signals.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The second and final key assumption is that that the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolation&lt;/a&gt;
approach we are interested in today is
&lt;em&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Shift-invariant_system&quot;&gt;shift invariant&lt;/a&gt;&lt;/em&gt;.
&lt;a href=&quot;https://en.wikipedia.org/wiki/Shift-invariant_system&quot;&gt;Shift invariance&lt;/a&gt;
in this case is a subtly different from the classic definition simply
because the input is a
&lt;em&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;sampled&lt;/a&gt;&lt;/em&gt;
data stream, defined over the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Domain_of_a_function&quot;&gt;domain&lt;/a&gt;
of all &lt;a href=&quot;https://en.wikipedia.org/wiki/Integer&quot;&gt;integers&lt;/a&gt;,
and the output is a signal defined over the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Domain_of_a_function&quot;&gt;domain&lt;/a&gt;
of &lt;a href=&quot;https://en.wikipedia.org/wiki/Real_number&quot;&gt;real numbers&lt;/a&gt;.  Therefore,
by shift invariant I mean that if you shift the incoming
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;sample&lt;/a&gt; stream
left or right by some &lt;a href=&quot;https://en.wikipedia.org/wiki/Integer&quot;&gt;integer&lt;/a&gt;
number of samples, &lt;code class=&quot;highlighter-rouge&quot;&gt;k&lt;/code&gt;, then the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolated&lt;/a&gt;
output stream (defined over the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Domain_of_a_function&quot;&gt;domain&lt;/a&gt;
of &lt;a href=&quot;https://en.wikipedia.org/wiki/Real_number&quot;&gt;real numbers&lt;/a&gt;) will
also shift by the same &lt;a href=&quot;https://en.wikipedia.org/wiki/Integer&quot;&gt;integer&lt;/a&gt;
amount.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;That’s not so hard, is it?&lt;/p&gt;

&lt;p&gt;The goal of any
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolation algorithm&lt;/a&gt;
is to estimate or recover the signal between the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;sample&lt;/a&gt;
points.  If you think about
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolation&lt;/a&gt;
in terms of Fig 1 above, the goal is to recover the gray dotted
line given only the green points.&lt;/p&gt;

&lt;p&gt;The above assumptions also drive the form of the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolation&lt;/a&gt;
solution.&lt;/p&gt;

&lt;p&gt;To see how this is the case, let’s start with a mathematical representation of
our &lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;sampled&lt;/a&gt;
signal, &lt;code class=&quot;highlighter-rouge&quot;&gt;x[n]&lt;/code&gt;, re-expressed as a series of
&lt;a href=&quot;https://en.wikipedia.org/wiki/Direc_delta_function&quot;&gt;Dirac delta functions&lt;/a&gt;
over the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Domain_of_a_function&quot;&gt;domain&lt;/a&gt;
of &lt;a href=&quot;https://en.wikipedia.org/wiki/Real_number&quot;&gt;real numbers&lt;/a&gt;.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/interp-x-made-continuous.png&quot; alt=&quot;x(t)=SUM x[n]d(t-n)&quot; width=&quot;277&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;In this representation, the function &lt;code class=&quot;highlighter-rouge&quot;&gt;x(t)&lt;/code&gt; is created from the discrete-time
input sequence &lt;code class=&quot;highlighter-rouge&quot;&gt;x[n]&lt;/code&gt; by a sum of scaled and offset
&lt;a href=&quot;https://en.wikipedia.org/wiki/Direc_delta_function&quot;&gt;Dirac delta functions&lt;/a&gt;.
Indeed, this was the meaning of the red impulses shown in Fig 1 above.  Each
&lt;a href=&quot;https://en.wikipedia.org/wiki/Direc_delta_function&quot;&gt;impulse&lt;/a&gt;
represents a scaled
&lt;a href=&quot;https://en.wikipedia.org/wiki/Direc_delta_function&quot;&gt;Dirac delta function&lt;/a&gt;,
at the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;sample&lt;/a&gt;
height, &lt;code class=&quot;highlighter-rouge&quot;&gt;x[n]&lt;/code&gt;, and location, &lt;code class=&quot;highlighter-rouge&quot;&gt;n&lt;/code&gt;, just as this equation describes.  These
&lt;a href=&quot;https://en.wikipedia.org/wiki/Direc_delta_function&quot;&gt;Dirac delta functions&lt;/a&gt;
are used to bridge the difference between the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;sampled&lt;/a&gt;
representation of a signal, &lt;code class=&quot;highlighter-rouge&quot;&gt;x[n]&lt;/code&gt;, and its continuous time equivalent,
&lt;code class=&quot;highlighter-rouge&quot;&gt;x(t)&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;We also know that every
&lt;a href=&quot;https://en.wikipedia.org/wiki/Linear_map&quot;&gt;linear&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Time-invariant_system&quot;&gt;time-invariant system&lt;/a&gt;
producing an output &lt;code class=&quot;highlighter-rouge&quot;&gt;y(t)&lt;/code&gt; from its input &lt;code class=&quot;highlighter-rouge&quot;&gt;x(t)&lt;/code&gt; can be represented by a
continuous-time
&lt;a href=&quot;https://en.wikipedia.org/wiki/Convolution&quot;&gt;convolution&lt;/a&gt;, such as the one
shown below.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/continuous-convolution.png&quot; alt=&quot;y(t)=INT h(tau)x(t-tau)&quot; width=&quot;300&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;At this point in our discussion, the form of the &lt;code class=&quot;highlighter-rouge&quot;&gt;h(t)&lt;/code&gt; that describes this
system is completely arbitrary.  It’s just a function of the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Real_number&quot;&gt;real numbers&lt;/a&gt;, producing a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Real_number&quot;&gt;real numbered&lt;/a&gt; output.  We’ll
come back later and pick a particular form to work with, but for now consider
&lt;code class=&quot;highlighter-rouge&quot;&gt;h(t)&lt;/code&gt; to be an arbitrary
&lt;a href=&quot;https://en.wikipedia.org/wiki/Real_number&quot;&gt;real&lt;/a&gt;
valued function.&lt;/p&gt;

&lt;p&gt;Since we’ve represented our original
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;sampled&lt;/a&gt;
signal, &lt;code class=&quot;highlighter-rouge&quot;&gt;x[n]&lt;/code&gt;, with a representation, &lt;code class=&quot;highlighter-rouge&quot;&gt;x(t)&lt;/code&gt;, composed of a set of scaled and
offset
&lt;a href=&quot;https://en.wikipedia.org/wiki/Direc_delta_function&quot;&gt;Dirac delta functions&lt;/a&gt;,
we can then substitute &lt;code class=&quot;highlighter-rouge&quot;&gt;x(t)&lt;/code&gt;
into this formula,&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/interp-xn-convolved.png&quot; alt=&quot;y(t)=INT h(tau) SUM x[n] d(t-tau-n)&quot; width=&quot;464&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;and then pull the summation out front,&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/interp-xn-convolved-2.png&quot; alt=&quot;y(t)=SUM x[n] INT h(tau) d(t-tau-n)&quot; width=&quot;440&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;The result is a 
&lt;a href=&quot;https://en.wikipedia.org/wiki/Convolution&quot;&gt;convolution&lt;/a&gt;
that we can evaluate.  Given the properties of the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Direc_delta_function&quot;&gt;Dirac delta functions&lt;/a&gt;,
any product of a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Direc_delta_function&quot;&gt;Dirac delta functions&lt;/a&gt;
and a function that is continuous near the region where the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Direc_delta_function&quot;&gt;Dirac delta functions&lt;/a&gt;
is non-zero, yet integrated over the point where the argument of the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Direc_delta_function&quot;&gt;Dirac delta functions&lt;/a&gt;
is goes through zero will simply yield the value of that other function at
that point.  In other words,&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/interp-is-convolution.png&quot; alt=&quot;y(t)=SUM x[n] INT h(tau) d(t-tau-n)&quot; width=&quot;278&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;and we’ve just proved that, under the assumptions we listed above,
&lt;em&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolation&lt;/a&gt;
is just another form of a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Convolution&quot;&gt;convolution&lt;/a&gt;.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;To see what I mean by this, consider Fig 2 below.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 2. Interpolation by Superposition&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/interpolation-superposition.png&quot; alt=&quot;&quot; width=&quot;810&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;In this figure, you can see the operation of the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Convolution&quot;&gt;convolution&lt;/a&gt;
taking place.  The figure shows the incoming
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;samples&lt;/a&gt;,
as green dots.  For each incoming
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;sample&lt;/a&gt;,
there is a scaled and weighted &lt;code class=&quot;highlighter-rouge&quot;&gt;h(t)&lt;/code&gt; function shown in gray.  Note how
this &lt;code class=&quot;highlighter-rouge&quot;&gt;h(t)&lt;/code&gt; function was designed so that the each gray line touches one
green circle, and yet goes through zero for the other circles.  Then, when
you sum all of these weighted and shifted &lt;code class=&quot;highlighter-rouge&quot;&gt;h(t)&lt;/code&gt; functions together, you get
the &lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolation&lt;/a&gt;
result shown in red.&lt;/p&gt;

&lt;p&gt;This conclusion has some major consequences for
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_signal_processing&quot;&gt;signal processing&lt;/a&gt;.
Among other things, it means we can use
&lt;a href=&quot;https://en.wikipedia.org/wiki/Fourier_analysis&quot;&gt;Fourier analysis&lt;/a&gt;
techniques to evaluate
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolators&lt;/a&gt;–just as we use
&lt;a href=&quot;https://en.wikipedia.org/wiki/Fourier_analysis&quot;&gt;Fourier analysis&lt;/a&gt; to evaluate
any other &lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filtering&lt;/a&gt;
operation.&lt;/p&gt;

&lt;p&gt;In particular, we can treat an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt; as nothing
more than an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Upsampling&quot;&gt;upsampling&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;.
Everything you’ve learned about
&lt;a href=&quot;https://en.wikipedia.org/wiki/Aliasing&quot;&gt;aliasing&lt;/a&gt; and
&lt;a href=&quot;https://en.wikipedia.org/wiki/Nyquist_rate&quot;&gt;Nyquist&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;sampling&lt;/a&gt;
applies now as it would with any other
&lt;a href=&quot;https://en.wikipedia.org/wiki/Upsampling&quot;&gt;upsampling&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Sadly, apart from the modern development of
&lt;a href=&quot;http://ieeexplore.ieee.org/document/15483/&quot;&gt;Farrow filters&lt;/a&gt;,
it seems that only a few
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolation&lt;/a&gt;
developments start from these assumptions.  We’ll discuss the consequences
of other choices quickly in the next section.&lt;/p&gt;

&lt;p&gt;Without loss of (too much) generality, we can use a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Piecewise&quot;&gt;piecewise&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial&quot;&gt;polynomial&lt;/a&gt;
to represent the &lt;code class=&quot;highlighter-rouge&quot;&gt;h(t)&lt;/code&gt; function above.  Doing so allows us to turn our
incoming
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;sampled&lt;/a&gt;
signal, &lt;code class=&quot;highlighter-rouge&quot;&gt;x[n]&lt;/code&gt;, into a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Piecewise&quot;&gt;piecewise&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial&quot;&gt;polynomial&lt;/a&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;y(t)&lt;/code&gt;, meaning
that what happens between
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;samples&lt;/a&gt;, i.e. the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;
result, can now be represented as a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Piecewise&quot;&gt;piecewise&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial&quot;&gt;polynomial&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Two &lt;a href=&quot;https://en.wikipedia.org/wiki/Piecewise&quot;&gt;piecewise&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial&quot;&gt;polynomial&lt;/a&gt;
forms are convenient for this purpose: those centered around the points
where the signal is defined, &lt;code class=&quot;highlighter-rouge&quot;&gt;[k-0.5,k+0.5)&lt;/code&gt; for
&lt;a href=&quot;https://en.wikipedia.org/wiki/Integer&quot;&gt;integers&lt;/a&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;k&lt;/code&gt;, and those defined between points
in a signal, such as &lt;code class=&quot;highlighter-rouge&quot;&gt;[k, k+1)&lt;/code&gt;.  We’ll come back to this more in a moment.&lt;/p&gt;

&lt;p&gt;So, to summarize, here were our assumptions:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;The incoming signal was
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;sampled&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;This will be the case with almost all
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_signal_processing&quot;&gt;DSP&lt;/a&gt;
applications.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The incoming signal is infinite in length.&lt;/p&gt;

    &lt;p&gt;While one might argue that this is never quite true, it is true that for most
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_signal_processing&quot;&gt;signal processing&lt;/a&gt;
applications there is often more data available than can be operated on at
any point in time.  For these applications, the difference between a signal
of truly infinite length and the perspective of the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_signal_processing&quot;&gt;signal processing&lt;/a&gt;
engine applied to a signal of finite length is quite irrelevant.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;All &lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;sample&lt;/a&gt;
times are equidistant&lt;/p&gt;

    &lt;p&gt;This is also true for most, although not all,
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_signal_processing&quot;&gt;DSP&lt;/a&gt;
applications.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The &lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;
must be
&lt;a href=&quot;https://en.wikipedia.org/wiki/Linear_map&quot;&gt;linear&lt;/a&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The resulting
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;
must also be shift invariant&lt;/p&gt;

    &lt;p&gt;This may be the &lt;em&gt;most significant assumption&lt;/em&gt; we’ve made along the way.
Indeed, it is this assumption that renders most of the other
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolation&lt;/a&gt;
developments inappropriate going forward–since they don’t preserve this
property.&lt;/p&gt;

    &lt;p&gt;It is also this assumption that makes
&lt;a href=&quot;https://en.wikipedia.org/wiki/Fourier_analysis&quot;&gt;Fourier analysis&lt;/a&gt; of
the &lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt; possible.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The &lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;’s
interpolation function, &lt;code class=&quot;highlighter-rouge&quot;&gt;h(t)&lt;/code&gt;, is formed from a set of
&lt;a href=&quot;https://en.wikipedia.org/wiki/Piecewise&quot;&gt;piecewise&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial&quot;&gt;polynomial&lt;/a&gt;s.&lt;/p&gt;

    &lt;p&gt;I’m sure there must be other useful
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolation&lt;/a&gt;
functions that are not formed from
&lt;a href=&quot;https://en.wikipedia.org/wiki/Piecewise&quot;&gt;piecewise&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial&quot;&gt;polynomial&lt;/a&gt;s.  However,
&lt;a href=&quot;https://en.wikipedia.org/wiki/Piecewise&quot;&gt;piecewise&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial&quot;&gt;polynomial&lt;/a&gt;s form a nice, easy
set to work with when implementing
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolators&lt;/a&gt; within
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;s–or
even &lt;a href=&quot;https://en.wikipedia.org/wiki/Embedded_system&quot;&gt;embedded&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;s for that
matter.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;For the most part, these are all quite common &lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_signal_processing&quot;&gt;digital signal
processing&lt;/a&gt;
assumptions, so I wouldn’t expect anyone to be surprised or shocked
at any of them.  What has surprised me was how rare these assumptions
are in the &lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolation&lt;/a&gt;
developments I’ve studied in the past.&lt;/p&gt;

&lt;h2 id=&quot;many-other-approaches-are-not-shift-invariant&quot;&gt;Many other approaches are not shift invariant&lt;/h2&gt;

&lt;p&gt;Since the assumptions above are not common
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolation&lt;/a&gt;
assumptions, let’s take a moment and investigate the significance of some
of them.&lt;/p&gt;

&lt;p&gt;Traditional &lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolation&lt;/a&gt;
approaches are commonly applied to only a &lt;em&gt;finite&lt;/em&gt; set of
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;sample&lt;/a&gt;
points found within a single, fixed, finite window of time.  This includes
most &lt;a href=&quot;https://en.wikipedia.org/wiki/Spline_interpolation&quot;&gt;spline interpolation&lt;/a&gt;
developments (these were always my favorites), &lt;a href=&quot;https://en.wikipedia.org/wiki/Chebyshev_polynomials&quot;&gt;Chebyshev polynomial
interpolation&lt;/a&gt;,
&lt;a href=&quot;https://en.wikipedia.org/wiki/Lagrange_polynomial&quot;&gt;Lagrange interpolation&lt;/a&gt;,
&lt;a href=&quot;https://en.wikipedia.org/wiki/Legendre_polynomials&quot;&gt;Legendre polynomial
interpolation&lt;/a&gt;
and more.&lt;/p&gt;

&lt;p&gt;These approaches, however, become less than ideal when applied to a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;sample&lt;/a&gt;
stream that is much longer than their finite time window.  Therefore, to make
these approaches viable, the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;sample&lt;/a&gt;
data stream is split into windows in time and the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;
is applied to each window.&lt;/p&gt;

&lt;p&gt;The problem with this sliding window approach revolves around what happens
at the edges where the algorithm transitions from one window to the next.
Because these
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolation&lt;/a&gt;
routines do nothing to guarantee that the result has controlled properties
between one window and the next, the transition region often suffers
from distortions not present in the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;’s
development.&lt;/p&gt;

&lt;p&gt;Nowhere is this more apparent than when combining a series of
&lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial_regression&quot;&gt;quadratic fit&lt;/a&gt;s
between
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;sample&lt;/a&gt;
points together to create a new
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolated&lt;/a&gt;
signal, such as is shown in Fig 3.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 3. The result of applying a series of sliding quadratic fits as an interpolation method&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/interpolation-discontinuous-quadratic.png&quot; alt=&quot;&quot; width=&quot;603&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;In this figure, every set of three adjacent sample points was used to create a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial_regression&quot;&gt;quadratic&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolation&lt;/a&gt;
function surrounding the middle sample.  The
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolation&lt;/a&gt;
function is only valid for plus or minus a half sample surrounding the
middle of those three points.  Outside of that region, a new
set of three samples is used to generate the next
&lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial_regression&quot;&gt;quadratic fit&lt;/a&gt;.
The resulting signal, shown in Fig 3 above, contains many unwanted
discontinuities that result from this sliding fit-window approach.&lt;/p&gt;

&lt;p&gt;Further, our desire to create an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolation&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;
that can be implemented within an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
will tend to push us away from other common
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt; structures,
such as &lt;a href=&quot;https://en.wikipedia.org/wiki/Trigonometric_interpolation&quot;&gt;trigonometric
interpolation&lt;/a&gt;,
or even &lt;a href=&quot;https://en.wikipedia.org/wiki/Rational_function&quot;&gt;rational function&lt;/a&gt;
evaluation, since these
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolators&lt;/a&gt;
depend upon functions that are more difficult to calculate within
&lt;a href=&quot;https://en.wikipedia.org/wiki/Hardware_deescription_language&quot;&gt;RTL logic&lt;/a&gt;.
That leaves us stuck with
&lt;a href=&quot;https://en.wikipedia.org/wiki/Piecewise&quot;&gt;piecewise&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial&quot;&gt;polynomial&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolation&lt;/a&gt;
functions.&lt;/p&gt;

&lt;p&gt;Not all of the other approaches avoid
&lt;a href=&quot;https://en.wikipedia.org/wiki/Shift-invariant_system&quot;&gt;shift invariance&lt;/a&gt;.
For example, the &lt;a href=&quot;https://en.wikipedia.org/wiki/Whittaker-Shannon_interpolation_formula&quot;&gt;Whittaker-Shannon&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolation&lt;/a&gt;
approach creates a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Shift-invariant_system&quot;&gt;shift invariant&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;
that can be applied to the infinite sample sets discussed above.  However, the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sinc_function&quot;&gt;sinc functions&lt;/a&gt;
it is based upon render &lt;code class=&quot;highlighter-rouge&quot;&gt;h(t)&lt;/code&gt; infinite in length, making this approach
difficult to implement.&lt;/p&gt;

&lt;p&gt;As a result, this leaves us with only one practical
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt; choice,
which we shall discuss in the next section.&lt;/p&gt;

&lt;h2 id=&quot;farrow-filters&quot;&gt;Farrow Filters&lt;/h2&gt;

&lt;p&gt;The only viable
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolation&lt;/a&gt;
alternative remaining within this set of assumptions is a
&lt;a href=&quot;http://ieeexplore.ieee.org/document/15483/&quot;&gt;Farrow filter&lt;/a&gt;.  Indeed, the
assumptions we’ve arrived at so far force us towards a
&lt;a href=&quot;http://ieeexplore.ieee.org/document/15483/&quot;&gt;Farrow filter&lt;/a&gt;, leaving us no
other alternative.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 4. A Piecewise Polynomial interpolation filter&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/interpolation-piecewise-poly.png&quot; alt=&quot;&quot; width=&quot;431&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;When using the &lt;a href=&quot;http://ieeexplore.ieee.org/document/15483/&quot;&gt;Farrow filter&lt;/a&gt;
approach, the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolation&lt;/a&gt;
function, &lt;code class=&quot;highlighter-rouge&quot;&gt;h(t)&lt;/code&gt;, is formed from a set of
&lt;a href=&quot;https://en.wikipedia.org/wiki/Piecewise&quot;&gt;piecewise&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial&quot;&gt;polynomials&lt;/a&gt;.  An example of one
such filter composed of
&lt;a href=&quot;https://en.wikipedia.org/wiki/Piecewise&quot;&gt;piecewise&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial&quot;&gt;quadratics&lt;/a&gt;
is shown in Fig 4 on the right.&lt;/p&gt;

&lt;p&gt;According to
&lt;a href=&quot;http://ieeexplore.ieee.org/document/15483/&quot;&gt;Farrow’s paper&lt;/a&gt;, the actual
“amount of delay”, i.e. the &lt;code class=&quot;highlighter-rouge&quot;&gt;t&lt;/code&gt; value when calculating the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolation&lt;/a&gt;
result, need not be calculated until it is needed.  This
is perfect for what we might wish to accomplish within an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The only question remaining is, what
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolation&lt;/a&gt;
function, &lt;code class=&quot;highlighter-rouge&quot;&gt;h(t)&lt;/code&gt;, shall we use?&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://ieeexplore.ieee.org/document/00679201/&quot;&gt;Fred Harris&lt;/a&gt; presents a
solution to
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolation&lt;/a&gt;
function generation based upon first designing a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;discrete-time filter&lt;/a&gt;
of many taps, and then approximating that function with a higher order
&lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial&quot;&gt;polynomial&lt;/a&gt;.
You may find this approach a valid solution to your
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolation&lt;/a&gt;
needs.  It is actually commonly used.&lt;/p&gt;

&lt;p&gt;I just haven’t found &lt;a href=&quot;http://ieeexplore.ieee.org/document/00679201/&quot;&gt;Harris’s ad-hoc filter derivation
method&lt;/a&gt;
personally very satisfying.  Ever since finding
&lt;a href=&quot;http://ieeexplore.ieee.org/document/00679201/&quot;&gt;Harris&lt;/a&gt;’s work, I’ve wanted
to know if there were a more rigorous and less ad-hoc approach to generating
these coefficients.  Is there some way, therefore, that an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;
can be developed using this technique and yet still meeting some
optimality properties?&lt;/p&gt;

&lt;p&gt;The answer is, yes there is, but also that we won’t get that far today. 
Instead, we’ll just lay the ground work for understanding and analyzing
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filters&lt;/a&gt;
of &lt;a href=&quot;http://ieeexplore.ieee.org/document/15483/&quot;&gt;this type&lt;/a&gt;.
Then, later, we’ll use this approach in order to develop &lt;em&gt;optimal&lt;/em&gt;
(in some sense)
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolation&lt;/a&gt; functions and their
&lt;a href=&quot;https://en.wikipedia.org/wiki/Piecewise&quot;&gt;piecewise&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial&quot;&gt;polynomial&lt;/a&gt;
coefficients.&lt;/p&gt;

&lt;h2 id=&quot;some-example-filters&quot;&gt;Some example filters&lt;/h2&gt;

&lt;p&gt;For now, let’s demonstrate some example
&lt;a href=&quot;http://ieeexplore.ieee.org/document/15483/&quot;&gt;Farrow filters&lt;/a&gt;.
Our examples will have a much lower order than those either
&lt;a href=&quot;http://ieeexplore.ieee.org/document/15483/&quot;&gt;Farrow&lt;/a&gt;
or &lt;a href=&quot;http://ieeexplore.ieee.org/document/00679201/&quot;&gt;Harris&lt;/a&gt; used, but the lower
order might help to make
&lt;a href=&quot;http://ieeexplore.ieee.org/document/15483/&quot;&gt;these filters&lt;/a&gt;
more understandable.&lt;/p&gt;

&lt;h3 id=&quot;sample-and-hold&quot;&gt;Sample and hold&lt;/h3&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 5. Sample and Hold&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/interpolation-fig-shold.png&quot; alt=&quot;&quot; width=&quot;325&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;The first &lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;
we discussed on
&lt;a href=&quot;http://zipcpu.com/&quot;&gt;this blog&lt;/a&gt;
was a sample and hold function.  While this may not seem like much of an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;,
it can be shown to have the form shown in Fig 5 on the right, and in
the equation below:&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/interpolation-eqn-shold.png&quot; alt=&quot;h(t) = 1, for 0&amp;lt;t&amp;lt;1, 0 ow&quot; width=&quot;250&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;This is actually a common
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolation&lt;/a&gt;
function in many mixed signal components, so it is worth recognizing.&lt;/p&gt;

&lt;p&gt;While this a common
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolation&lt;/a&gt;
function in many practical mixed signal
components, I’d like to do better.  Let’s keep looking, therefore.&lt;/p&gt;

&lt;h3 id=&quot;nearest-neighbour&quot;&gt;Nearest Neighbour&lt;/h3&gt;

&lt;p&gt;A similar &lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolation&lt;/a&gt;
function is the
&lt;a href=&quot;/dsp/2017/06/06/simple-interpolator.html&quot;&gt;nearest neighbor&lt;/a&gt;
function.  This has
an almost identical form for &lt;code class=&quot;highlighter-rouge&quot;&gt;h(t)&lt;/code&gt; as the sample-and-hold function above,
save that this time &lt;code class=&quot;highlighter-rouge&quot;&gt;h(t)&lt;/code&gt; is centered about the y-axis.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/interpolation-eqn-nnbor.png&quot; alt=&quot;h(t) = 1, for |t|&amp;lt;1/2, 0 ow&quot; width=&quot;252&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;It isn’t all that difficult to prove that the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Fourier_transform&quot;&gt;Fourier&lt;/a&gt;
transform of this function is a familiar
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sinc_funtion&quot;&gt;sinc function&lt;/a&gt;, which decays
out of band at a rate of &lt;code class=&quot;highlighter-rouge&quot;&gt;1/f&lt;/code&gt;.  Fig 6 below shows both this &lt;code class=&quot;highlighter-rouge&quot;&gt;h(t)&lt;/code&gt; function,
on the left, as well as its
&lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency_response&quot;&gt;frequency response&lt;/a&gt;
on the right.  Also shown on the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency_response&quot;&gt;frequency response&lt;/a&gt;
chart is a &lt;code class=&quot;highlighter-rouge&quot;&gt;1/f&lt;/code&gt; asymptote.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 6. Nearest Neighbor interpolation function and frequency response&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/interpolation-fig-nnbor.png&quot; alt=&quot;&quot; width=&quot;730&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;The asymptotic performance can be controlled in
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;
design to achieve specific performance measures, if desired.  You’ll be able
to see this as we continue.&lt;/p&gt;

&lt;h3 id=&quot;linear-interpolation&quot;&gt;Linear interpolation&lt;/h3&gt;

&lt;p&gt;If you &lt;a href=&quot;https://en.wikipedia.org/wiki/Convolution&quot;&gt;convolve&lt;/a&gt;
the &lt;a href=&quot;https://en.wikipedia.org/wiki/Rectangular_function&quot;&gt;rectangle function&lt;/a&gt;
that is the
&lt;a href=&quot;/dsp/2017/06/06/simple-interpolator.html&quot;&gt;nearest neighbor&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;
with itself, you will get a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Triangle_function&quot;&gt;triangle functions&lt;/a&gt;,&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/interpolation-eqn-linear.png&quot; alt=&quot;h(t) = 1-|t|^2, for |t|&amp;lt;1/2&quot; width=&quot;297&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Since
&lt;a href=&quot;https://en.wikipedia.org/wiki/Convolution&quot;&gt;convolution&lt;/a&gt;
in time is multiplication in frequency, the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Fourier_transform&quot;&gt;Fourier&lt;/a&gt;
transform of this function is simply a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sinc_funtion&quot;&gt;sinc function&lt;/a&gt; squared.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 7. Linear interpolation function and frequency response&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/interpolation-fig-linear.png&quot; alt=&quot;&quot; width=&quot;730&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;This creates a &lt;code class=&quot;highlighter-rouge&quot;&gt;1/f^2&lt;/code&gt; asymptote, shown above.  As a result, any out of band
&lt;a href=&quot;https://en.wikipedia.org/wiki/Aliasing&quot;&gt;aliasing&lt;/a&gt;
artifacts are further attenuated by this filter.&lt;/p&gt;

&lt;h3 id=&quot;quadratic-fit&quot;&gt;Quadratic Fit&lt;/h3&gt;

&lt;p&gt;With a little bit of work, the typical quadratic fit function, the one
producing the result in Fig 3 above, can also be
represented in this form.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/interpolation-eqn-qfit.png&quot; alt=&quot;Quadratic fit eqn&quot; width=&quot;396&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 8. Quadratic fit function&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/interpolation-fig-qfit.png&quot; alt=&quot;&quot; width=&quot;325&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;This function, however, isn’t continuous at all.  Indeed, when you plot it
out, as in Fig 8 to the right, you’ll get a feel for why the quadratic fit
in Fig 3 above looked as horrible as it did.&lt;/p&gt;

&lt;p&gt;But, what happened?  Why does this look nothing like a quadratic fit?&lt;/p&gt;

&lt;p&gt;Well, actually, it does.  If you extend the middle section on both sides,
you can see that it comes down and hits the axis at &lt;code class=&quot;highlighter-rouge&quot;&gt;x=-1&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;x=1&lt;/code&gt;.  In
a similar fashion, if you extend either of the wings out, you’ll see they
hit &lt;code class=&quot;highlighter-rouge&quot;&gt;y(0)=1&lt;/code&gt; and either &lt;code class=&quot;highlighter-rouge&quot;&gt;y(-2)=0&lt;/code&gt; or &lt;code class=&quot;highlighter-rouge&quot;&gt;y(2)=0&lt;/code&gt; respectively.  We created
exactly what we tried to create, but by moving from one fitting window
to the next we also created the discontinuous artifacts shown in Fig 8.&lt;/p&gt;

&lt;p&gt;This really shouldn’t be surprising.  When we created our quadratic fit,
we did nothing to control the transitions from one fitting region to another.
Fig 8 just shows the effects of such a choice on the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;
that results.&lt;/p&gt;

&lt;h3 id=&quot;smoothed-quadratic&quot;&gt;Smoothed quadratic&lt;/h3&gt;

&lt;p&gt;If &lt;a href=&quot;https://en.wikipedia.org/wiki/Convolution&quot;&gt;convolving&lt;/a&gt;
a &lt;a href=&quot;https://en.wikipedia.org/wiki/Rectangular_function&quot;&gt;rectangle&lt;/a&gt;
with itself generated a nice &lt;a href=&quot;/dsp/2017/07/29/series-linear-interpolation.html&quot;&gt;linear
interpolation&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Triangle_function&quot;&gt;triangle function&lt;/a&gt;,
what do you think you would you get from
&lt;a href=&quot;https://en.wikipedia.org/wiki/Convolution&quot;&gt;convolving&lt;/a&gt; a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Triangle_function&quot;&gt;triangle function&lt;/a&gt;
with that same
&lt;a href=&quot;https://en.wikipedia.org/wiki/Rectangular_function&quot;&gt;rectangle&lt;/a&gt;?  You will
get a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Piecewise&quot;&gt;piecewise&lt;/a&gt;
quadratic
&lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial&quot;&gt;polynomial&lt;/a&gt;
function whose
&lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency_response&quot;&gt;frequency response&lt;/a&gt;
decays at &lt;code class=&quot;highlighter-rouge&quot;&gt;1/f^3&lt;/code&gt;–as fast or faster than any other
&lt;a href=&quot;https://en.wikipedia.org/wiki/Piecewise&quot;&gt;piecewise&lt;/a&gt;
quadratic
&lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial&quot;&gt;polynomial&lt;/a&gt;
function.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/interpolation-eqn-rectcubed.png&quot; alt=&quot;Quadratic eqn for the quadratic created by convolving a rectangle with itself three times&quot; width=&quot;402&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;The only problem with this function is that it is no longer a true
&lt;a href=&quot;/dsp/2017/07/29/series-linear-interpolation.html&quot;&gt;interpolator&lt;/a&gt;.
By that I mean that if you were to
&lt;a href=&quot;https://en.wikipedia.org/wiki/Convolution&quot;&gt;convolve&lt;/a&gt;
your sampled data, &lt;code class=&quot;highlighter-rouge&quot;&gt;x[n]&lt;/code&gt;, with this function, then the continuous output
function, &lt;code class=&quot;highlighter-rouge&quot;&gt;y(t)&lt;/code&gt;, that would result would no longer necessarily match
&lt;code class=&quot;highlighter-rouge&quot;&gt;x[n]&lt;/code&gt; whenever &lt;code class=&quot;highlighter-rouge&quot;&gt;t=n&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;This is a result of the fact that &lt;code class=&quot;highlighter-rouge&quot;&gt;h(n)&lt;/code&gt; doesn’t equal zero for all
&lt;a href=&quot;https://en.wikipedia.org/wiki/Integer&quot;&gt;integers&lt;/a&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;n&lt;/code&gt;, where &lt;code class=&quot;highlighter-rouge&quot;&gt;n != 0&lt;/code&gt;.
You can see from Fig 9 below that this
function certainly doesn’t go through zero at &lt;code class=&quot;highlighter-rouge&quot;&gt;t=1&lt;/code&gt; as just one example.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 9. Smoother Quadratic function and frequency response&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/interpolation-fig-rcubd.png&quot; alt=&quot;&quot; width=&quot;730&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;The good news, though, is that the &lt;code class=&quot;highlighter-rouge&quot;&gt;1/f^3&lt;/code&gt; falloff was one of the best we’ve
seen yet–as shown by the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency_response&quot;&gt;frequency response&lt;/a&gt;
function on the right of Fig 9 above.&lt;/p&gt;

&lt;p&gt;Since we are trying to create
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolators&lt;/a&gt;,
a function that isn’t an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;
isn’t very acceptable.  Therefore let’s remember this function
while looking for an better alternative.&lt;/p&gt;

&lt;h3 id=&quot;ideal-interpolator&quot;&gt;Ideal Interpolator&lt;/h3&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 10. Ideal interpolator&#39;s frequency response&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/interpolation-fig-ideal.png&quot; alt=&quot;&quot; width=&quot;370&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Much as it is possible with traditional
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filtering&lt;/a&gt;
methods to specify an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sinc_filter&quot;&gt;ideal filter&lt;/a&gt;,
the same can be done with
&lt;a href=&quot;http://ieeexplore.ieee.org/document/15483/&quot;&gt;interpolation filters&lt;/a&gt;
as well.&lt;/p&gt;

&lt;p&gt;Shown in Fig 10 at the right is the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency_response&quot;&gt;frequency response&lt;/a&gt;
of an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sinc_filter&quot;&gt;ideal&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolation&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;.
As you might expect, this function passes all frequencies below the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Nyquist_rate&quot;&gt;Nyquist&lt;/a&gt;
frequency, and stops all frequencies above that.&lt;/p&gt;

&lt;p&gt;However, as with the development of more traditional
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filters&lt;/a&gt;,
this
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;
is also infinite in length, doesn’t fit nicely into a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Piecewise&quot;&gt;piecewise&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial&quot;&gt;polynomial&lt;/a&gt;
representation, and thus isn’t very suitable for practical work.&lt;/p&gt;

&lt;p&gt;It is suitable, however, for discussing the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sinc_filter&quot;&gt;ideal&lt;/a&gt;
that we would like our practical
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filters&lt;/a&gt;
to approach in terms of performance.  Therefore, we shall judge that the
closer an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolation&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter’s&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency_response&quot;&gt;frequency response&lt;/a&gt;
approximates this
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sinc_filter&quot;&gt;ideal&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;,
the better the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolation&lt;/a&gt;
will be.&lt;/p&gt;

&lt;h3 id=&quot;better-quadratic&quot;&gt;Better Quadratic&lt;/h3&gt;

&lt;p&gt;With a bit more work, we can come up with a better quadratic
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolation&lt;/a&gt;
function.  This function, shown in Fig 11 below, has a much wider
“&lt;a href=&quot;https://en.wikipedia.org/wiki/Passband&quot;&gt;passband&lt;/a&gt;”,
while still maintaining the &lt;code class=&quot;highlighter-rouge&quot;&gt;1/f^2&lt;/code&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Stopband&quot;&gt;stopband&lt;/a&gt;
fall off that the &lt;a href=&quot;/dsp/2017/07/29/series-linear-interpolation.html&quot;&gt;linear
interpolator&lt;/a&gt; had.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 11. A better quadratic interpolator function and frequency response&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/interpolation-fig-betterq.png&quot; alt=&quot;&quot; width=&quot;730&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Not only that, but this
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;
comes closer to the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sinc_filter&quot;&gt;ideal&lt;/a&gt;
in both
&lt;a href=&quot;https://en.wikipedia.org/wiki/Passband&quot;&gt;passband&lt;/a&gt; and
&lt;a href=&quot;https://en.wikipedia.org/wiki/Stopband&quot;&gt;stopband&lt;/a&gt;
then our last attempt did.  Hence, while maintaining the asymptotic
performance of a
&lt;a href=&quot;/dsp/2017/07/29/series-linear-interpolation.html&quot;&gt;linear interpolator&lt;/a&gt;,
we’ve achieved better performance at lower frequencies.  Further, the nulls
are deeper and wider than the
&lt;a href=&quot;/dsp/2017/07/29/series-linear-interpolation.html&quot;&gt;linear interpolator&lt;/a&gt; shown in Fig 7 above.&lt;/p&gt;

&lt;p&gt;For these reasons, this will be the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;
we’ll implement and demonstrate when we come back and look at quadratic
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolation&lt;/a&gt;
performance in a later post.&lt;/p&gt;

&lt;h3 id=&quot;can-we-do-better&quot;&gt;Can we do better?&lt;/h3&gt;

&lt;p&gt;I think the answer to this question is, yes, we can do even better than this.
However, I have yet to see the formal theory behind optimally generating
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolation&lt;/a&gt;
functions such as these.&lt;/p&gt;

&lt;p&gt;For now, consider this question: can the ad-hoc
&lt;a href=&quot;http://ieeexplore.ieee.org/document/15483/&quot;&gt;Farrow&lt;/a&gt; filter functions that
&lt;a href=&quot;http://ieeexplore.ieee.org/document/00679201/&quot;&gt;Harris&lt;/a&gt; espouses be
rewritten as discrete
&lt;a href=&quot;https://en.wikipedia.org/wiki/Convolution&quot;&gt;convolutions&lt;/a&gt;
of functions which are formed by
&lt;a href=&quot;https://en.wikipedia.org/wiki/Convolution&quot;&gt;convolving&lt;/a&gt; a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Rectangular_function&quot;&gt;rectangle&lt;/a&gt;
rectangle with itself many times?  If so, you could choose the rate at
which the stop band falls off, whether &lt;code class=&quot;highlighter-rouge&quot;&gt;1/f&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;1/f^2&lt;/code&gt;, etc, by choosing
which subset of these functions you wish to use when generating your
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolation&lt;/a&gt;
function.&lt;/p&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;Selecting a “good”
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolation&lt;/a&gt;
method for your signal processing application
starts with the right set of assumptions.  Indeed, the single most critical
assumption required for good
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;
development is that the resulting
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolation&lt;/a&gt;
method must be shift invariant.
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;Interpolation&lt;/a&gt;
routines chosen without this property are likely to suffer uncontrolled
effects as the interval defining the function changes with time.&lt;/p&gt;

&lt;p&gt;This, however, is only the beginning of the study of
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolation&lt;/a&gt;
for
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_signal_processing&quot;&gt;DSP&lt;/a&gt;
applications within
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;s.
While it opens up the topic by providing the necessary background, more
remains to be covered.  For example:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;It is possible, although perhaps not all that practical, to create a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Spline_interpolation&quot;&gt;spline&lt;/a&gt;
development under these assumptions.  Although the typical
&lt;a href=&quot;https://en.wikipedia.org/wiki/Spline_interpolation&quot;&gt;spline&lt;/a&gt;
development depends upon a difficult matrix inversion, an alternative
&lt;a href=&quot;https://en.wikipedia.org/wiki/Spline_interpolation&quot;&gt;spline&lt;/a&gt;
development exists which doesn’t depend upon any real-time matrix inversion.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Using this approach, we can now build some very useful and generic
quadratic
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolators&lt;/a&gt;.
Two in particular will be worth discussing: a quadratic
&lt;a href=&quot;https://en.wikipedia.org/wiki/Upsampling&quot;&gt;upsampling&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;
which may be used for
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sample-rate_conversion&quot;&gt;resampling&lt;/a&gt;
or tracking applications, and an improved
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sine_wave&quot;&gt;sine wave&lt;/a&gt; &lt;a href=&quot;/dsp/2017/07/11/simplest-sinewave-generator.html&quot;&gt;table
lookup&lt;/a&gt;
method.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Finally, it might be fun to see if it is possible to generate an &lt;em&gt;optimum&lt;/em&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolator&lt;/a&gt;
by some measure of optimality.&lt;/p&gt;

&lt;p&gt;While I intend to come back to this topic, if you are
interested in more information about the types of
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpolation&quot;&gt;interpolators&lt;/a&gt;
discussed above before that time, feel free to check out my &lt;a href=&quot;https://github.com/ZipCPU/interpolation/raw/master/tutorial.pdf&quot;&gt;tutorial
slides&lt;/a&gt;
on the topic.&lt;/p&gt;
&lt;hr /&gt;&lt;p&gt;&lt;em&gt;Is it fit to say to a king, Thou art wicked? and to princes, Ye are ungodly?  (Job 34:18)&lt;/em&gt;</description>
        <pubDate>Tue, 16 Jan 2018 00:00:00 -0500</pubDate>
        <link>http://zipcpu.com/dsp/2018/01/16/interpolation-is-convolution.html</link>
        <guid isPermaLink="true">http://zipcpu.com/dsp/2018/01/16/interpolation-is-convolution.html</guid>
        
        
        <category>dsp</category>
        
      </item>
    
      <item>
        <title>A Quick Introduction to the ZipCPU Instruction Set</title>
        <description>&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 1: The ZipCPU&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/zipcpu.png&quot; alt=&quot;&quot; width=&quot;360&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;If you aren’t familiar with the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;, then you should know that it
is my attempt at improving the publicly available
&lt;a href=&quot;https://en.wikipedia.org/wiki/Soft_microprocessor&quot;&gt;softcore CPU&lt;/a&gt;
architectures.  It has been designed from the ground up to be a truly
&lt;a href=&quot;https://en.wikipedia.org/wiki/Reduced_instruction_set_computer&quot;&gt;&lt;em&gt;Reduced&lt;/em&gt; instruction set computer, or
RISC&lt;/a&gt;
machine, to have
a simple
&lt;a href=&quot;https://en.wikipedia.org/wiki/Instruction_pipelining&quot;&gt;pipeline&lt;/a&gt;
implementation, and yet to be able to run a multi-tasking
&lt;a href=&quot;https://en.wikipedia.org/wiki/Operating_System&quot;&gt;operating system&lt;/a&gt;
if desired.  Unlike many of the other more common
&lt;a href=&quot;https://en.wikipedia.org/wiki/Soft_microprocessor&quot;&gt;soft-core CPU&lt;/a&gt;s,
such as
&lt;a href=&quot;https://www.xilinx.com/support/documentation/sw_manuals/mb_ref_guide.pdf&quot;&gt;MicroBlaze&lt;/a&gt;
or the &lt;a href=&quot;https://www.altera.com/literature/hb/nios2/n2cpu_nii5v1.pdf&quot;&gt;NiosII&lt;/a&gt;,
the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; has been created in a
completely open source fashion.&lt;/p&gt;

&lt;p&gt;The &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; was also designed to
run on the cheaper, more commodity,
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
hardware platforms.
Indeed, in many ways this has always been the philosophy behind the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;: be small and simple, yet
fully and completely functional.  I judged, as I built it this way, that not
only would it be easier to build and debug a simpler
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;,
but also that it would be easier to add to an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
project as an afterthought if it was small.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: left&quot;&gt;&lt;caption&gt;Fig 2: A Cheaper CPU: Teensy LC&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;a href=&quot;https://www.pjrc.com/teensy/&quot;&gt;&lt;img src=&quot;/img/teensy.jpg&quot; alt=&quot;A Picture of the Teensy CPU&quot; width=&quot;120&quot; /&gt;&lt;/a&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;Consider, for a moment: if you bought an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;,
you did so for a purpose.  If you wanted a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;
instead then there are many other
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;’s
that you could have bought that would have run faster, and cost less, than
the &lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
you purchased.  As an example, Fig 2 shows a picture of the &lt;a href=&quot;https://www.pjrc.com/teensy&quot;&gt;TeensyLC&lt;/a&gt;–a small
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;
that sells for only $15USD.  Since you didn’t purchase a
&lt;a href=&quot;https://www.pjrc.com/teensy&quot;&gt;TeensyLC&lt;/a&gt;, you must have purchased that
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
for a reason–to perform a task that you couldn’t do with an off-the-shelf
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;.
Indeed, I would imagine you want as much of your
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
available to complete that task as possible.
If, in the process, you find yourself needing a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt; on the same
chip as your
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;–then
you want that
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;
to stay out of the way, and to consume as few resources as possible.&lt;/p&gt;

&lt;p&gt;This is, and was, the purpose of the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;We’ve already discussed several of the parts and pieces of the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; across many articles over
the last year.  For example, we discussed the divide unit when we discussed
&lt;a href=&quot;/blog/2017/06/12/minimizing-luts.html&quot;&gt;minimizing FPGA resource
allocation&lt;/a&gt;.
We discussed the
&lt;a href=&quot;/zipcpu/2017/08/11/simple-alu.html&quot;&gt;ALU&lt;/a&gt;
unit when describing how a &lt;a href=&quot;/zipcpu/2017/08/11/simple-alu.html&quot;&gt;simple ALU might be
structured&lt;/a&gt;.
We discussed the &lt;a href=&quot;/zipcpu/2017/07/14/cpu-debugging-needs.html&quot;&gt;debugging needs of a
CPU&lt;/a&gt; in general,
as well as how to meet those needs in both
&lt;a href=&quot;/zipcpu/2017/07/26/cpu-sim-debugger.html&quot;&gt;simulation&lt;/a&gt; and
in the &lt;a href=&quot;/zipcpu/2017/08/25/hw-debugging.html&quot;&gt;hardware&lt;/a&gt;.  More
recently, we &lt;a href=&quot;/zipcpu/2017/11/18/wb-prefetch.html&quot;&gt;presented and formally verified a simple prefetch
engine&lt;/a&gt; for the
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;wishbone bus&lt;/a&gt;.  Indeed,
my recent post about the &lt;a href=&quot;/zipcpu/2017/12/28/ugliest-bug.html&quot;&gt;ugliest
bug&lt;/a&gt;
I’ve ever encountered was also based upon my experiences with the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Today, let’s take a look at how the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/raw/master/spec.pdf&quot;&gt;instruction set&lt;/a&gt; is
laid out, and discuss a few of the ways it is different from some of the
other, more common,
&lt;a href=&quot;https://en.wikipedia.org/wiki/Soft_microprocessor&quot;&gt;soft-core CPU&lt;/a&gt;s
of today.  Our intention will by no means be to present a complete description
of the &lt;a href=&quot;https://en.wikipedia.org/wiki/Instruction_set_architecture&quot;&gt;ISA&lt;/a&gt;,
but rather an overview.  The
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/raw/master/doc/spec.pdf&quot;&gt;ZipCPU specification&lt;/a&gt;should provide any missing details–if not, please let me know if you find
something missing and I can add it in.&lt;/p&gt;

&lt;h2 id=&quot;the-basic-operations&quot;&gt;The Basic Operations&lt;/h2&gt;

&lt;p&gt;The &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; was designed around a set
of instructions all having the very simple form,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-asm&quot; data-lang=&quot;asm&quot;&gt;	OP.X #+Rb,Ra&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 3: Generic ZipCPU Instruction Operation&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/zipcpu-op-logic.svg&quot; alt=&quot;Ra &amp;lt;= (if X) Ra (op) #+Rb&quot; width=&quot;480&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;You can read this generic instruction as: if &lt;code class=&quot;highlighter-rouge&quot;&gt;X&lt;/code&gt; is true, then &lt;code class=&quot;highlighter-rouge&quot;&gt;OP&lt;/code&gt; is applied
to the number &lt;code class=&quot;highlighter-rouge&quot;&gt;#&lt;/code&gt; plus the value of register &lt;code class=&quot;highlighter-rouge&quot;&gt;Rb&lt;/code&gt;, and the register &lt;code class=&quot;highlighter-rouge&quot;&gt;Ra&lt;/code&gt;,
and the result is placed into &lt;code class=&quot;highlighter-rouge&quot;&gt;Ra&lt;/code&gt;.  Here I’m using &lt;code class=&quot;highlighter-rouge&quot;&gt;#&lt;/code&gt; to refer to an
immediate value–a fixed number encoded within the instruction stream.&lt;/p&gt;

&lt;p&gt;Fig 3 attempts to show this operation graphically.  Two registers are read
from the register file, noted here as &lt;code class=&quot;highlighter-rouge&quot;&gt;Ra&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;Rb&lt;/code&gt;.  An immediate is added
to register &lt;code class=&quot;highlighter-rouge&quot;&gt;Rb&lt;/code&gt;, or alternatively the immediate replaces &lt;code class=&quot;highlighter-rouge&quot;&gt;Rb&lt;/code&gt; entirely,
and the result joins &lt;code class=&quot;highlighter-rouge&quot;&gt;Ra&lt;/code&gt; to be operated upon.&lt;/p&gt;

&lt;p&gt;For &lt;a href=&quot;/zipcpu/2017/08/11/simple-alu.html&quot;&gt;ALU&lt;/a&gt;
instructions, the result is only written back if the condition is
true.&lt;/p&gt;

&lt;p&gt;Memory instructions are just a touch different.  In the case of a memory
instruction, the &lt;code class=&quot;highlighter-rouge&quot;&gt;#+Rb&lt;/code&gt; value (immediate number plus the value of register
&lt;code class=&quot;highlighter-rouge&quot;&gt;Rb&lt;/code&gt;) is used as the address for the memory operation.  Further, the
operation only begins if the condition is true.  &lt;code class=&quot;highlighter-rouge&quot;&gt;Ra&lt;/code&gt; is used as the
data source for a store operation, or the data result of a load operation.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 4: ZipCPU Instruction Format(s)&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/zipcpu-insn-form.png&quot; alt=&quot;1&#39;b0, 4&#39;b Ra, 5&#39;b Op, etc.&quot; width=&quot;633&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;The encoding for this and other &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; instructions are shown
in Fig 4 on the right.  Four bits are used to encode the destination register,
&lt;code class=&quot;highlighter-rouge&quot;&gt;Ra&lt;/code&gt;, five bits are used to encode the opcode, &lt;code class=&quot;highlighter-rouge&quot;&gt;OP&lt;/code&gt;, three bits are used to
encode the condition, &lt;code class=&quot;highlighter-rouge&quot;&gt;X&lt;/code&gt;, and the remaining bits are used to encode whether
or not &lt;code class=&quot;highlighter-rouge&quot;&gt;Rb&lt;/code&gt; is used and what immediate offset is used by the instruction.&lt;/p&gt;

&lt;p&gt;Two instructions have special formats: the &lt;code class=&quot;highlighter-rouge&quot;&gt;MOV&lt;/code&gt; (move) and &lt;code class=&quot;highlighter-rouge&quot;&gt;LDI&lt;/code&gt; (load
immediate) instructions, we’ll come back to these further on.&lt;/p&gt;

&lt;p&gt;The &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; can also support
compressed instructions, with their format shown at the bottom of Fig 4.
While we’ll only touch on the &lt;em&gt;Compressed Instruction Set&lt;/em&gt;
today, you can read all about these two-for-one instructions in the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/raw/master/doc/spec.pdf&quot;&gt;specification&lt;/a&gt; if you are
interested.&lt;/p&gt;

&lt;p&gt;Indeed, the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; &lt;a href=&quot;https://en.wikipedia.org/wiki/Instruction_set_architecture&quot;&gt;instruction set
architecture&lt;/a&gt;
 is just about that simple.  Still, let’s dig into some more details.&lt;/p&gt;

&lt;h2 id=&quot;the-basic-operations-in-more-detail&quot;&gt;The Basic Operations, in more detail&lt;/h2&gt;

&lt;p&gt;Most &lt;a href=&quot;https://en.wikipedia.org/wiki/Reduced_instruction_set_computer&quot;&gt;RISC&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;s
today tend to support a six bit opcode or larger.  This allows
these machines to support up to 64 basic instructions–or even more.
Not the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; was designed to be a truly
&lt;a href=&quot;https://en.wikipedia.org/wiki/Reduced_instruction_set_computer&quot;&gt;&lt;em&gt;Reduced&lt;/em&gt; instruction set
computer&lt;/a&gt;.
As a result, it doesn’t have nearly as many instructions as its competitors:
the &lt;a href=&quot;http://www.latticesemi.com/~/media/LatticeSemi/Documents/UserManuals/JL/LatticeMico32ProcessorReferenceManual37.pdf&quot;&gt;lm32 processor&lt;/a&gt;,
&lt;a href=&quot;https://raw.githubusercontent.com/openrisc/doc/master/archive/openrisc_arch.pdf&quot;&gt;OpenRISC&lt;/a&gt;,
&lt;a href=&quot;https://riscv.org&quot;&gt;RISC-V&lt;/a&gt;,
&lt;a href=&quot;https://www.altera.com/literature/hb/nios2/n2cpu_nii5v1.pdf&quot;&gt;NiosII&lt;/a&gt;,
and &lt;a href=&quot;https://www.xilinx.com/support/documentation/sw_manuals/mb_ref_guide.pdf&quot;&gt;MicroBlaze&lt;/a&gt;.  We can go over some of these differences later.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 5: ZipCPU Instructions&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/zipcpu-insns.png&quot; alt=&quot;(A chart of the [ZipCPU](/about/zipcpu.html) instructions)&quot; width=&quot;378&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;For now, let’s take a quick look at the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; instruction cheat sheet, shown
in Fig 5.  From here, you can see that the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; supports 25 basic
instructions.
It has four special instructions, &lt;code class=&quot;highlighter-rouge&quot;&gt;BREAK&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;LOCK&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;NOOP&lt;/code&gt;, and &lt;code class=&quot;highlighter-rouge&quot;&gt;SIM&lt;/code&gt;,
and another six instructions reserved for a floating point co-processor–these
are the &lt;code class=&quot;highlighter-rouge&quot;&gt;FP&lt;/code&gt; instructions.  Further, eight instructions have been chosen to
also have a compressed representation.&lt;/p&gt;

&lt;p&gt;That’s it.  There are no more or hidden instructions, although a lot of
the instructions within this list have some special functionality.&lt;/p&gt;

&lt;p&gt;Shall we walk through these instructions, and discuss what each does in turn?&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;SUB&lt;/strong&gt;tract, subtracts &lt;code class=&quot;highlighter-rouge&quot;&gt;#+Rb&lt;/code&gt; from the value in &lt;code class=&quot;highlighter-rouge&quot;&gt;Ra&lt;/code&gt;, leaving the result in
&lt;code class=&quot;highlighter-rouge&quot;&gt;Ra&lt;/code&gt;.&lt;/p&gt;

    &lt;p&gt;I’ll write this as &lt;code class=&quot;highlighter-rouge&quot;&gt;Ra &amp;lt;= Ra - (#+Rb)&lt;/code&gt; to facilitate a simpler notation,
since just about all of the instructions will have this form.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;AND&lt;/strong&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;Ra &amp;lt;= Ra &amp;amp; (#+Rb)&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;ADD&lt;/strong&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;Ra &amp;lt;= Ra + (#+Rb)&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;OR&lt;/strong&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;Ra &amp;lt;= Ra | (#+Rb)&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;XOR&lt;/strong&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;Ra &amp;lt;= Ra ^ (#+Rb)&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;LSR&lt;/strong&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;Ra &amp;lt;= Ra &amp;gt;&amp;gt; (#+Rb)&lt;/code&gt; (assumes Ra is unsigned)&lt;/p&gt;

    &lt;p&gt;In all of the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;’s
shift instructions, the last bit shifted out of &lt;code class=&quot;highlighter-rouge&quot;&gt;Ra&lt;/code&gt; is placed into the
Carry flag.&lt;/p&gt;

    &lt;p&gt;Further, these shift instructions accept requests for shifts outside of the
reasonable bounds &lt;code class=&quot;highlighter-rouge&quot;&gt;0--31&lt;/code&gt;, permitting instead any shift amount between
&lt;code class=&quot;highlighter-rouge&quot;&gt;0&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;2^31&lt;/code&gt;–not that you’d need these extra amounts.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;LSL&lt;/strong&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;Ra &amp;lt;= Ra &amp;lt;&amp;lt; (#+Rb)&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;ASR&lt;/strong&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;Ra &amp;lt;= Ra &amp;gt;&amp;gt; (#+Rb)&lt;/code&gt;&lt;/p&gt;

    &lt;p&gt;This instruction implements an &lt;a href=&quot;https://en.wikipedia.org/wiki/Arithmetic_shift&quot;&gt;Arithmetic right
shift&lt;/a&gt;.  This is
done by first assuming that &lt;code class=&quot;highlighter-rouge&quot;&gt;Ra&lt;/code&gt; is
signed, and then propagating the sign bit from the MSB down.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;BREV&lt;/strong&gt;, This is the “bit-reverse” instruction.  For this instruction,
&lt;code class=&quot;highlighter-rouge&quot;&gt;Ra&lt;/code&gt; is assigned the value of &lt;code class=&quot;highlighter-rouge&quot;&gt;(#+Rb)&lt;/code&gt; but not until &lt;code class=&quot;highlighter-rouge&quot;&gt;(#+Rb)&lt;/code&gt; has been
“bit-reversed”.  That is, bit 0 of &lt;code class=&quot;highlighter-rouge&quot;&gt;(#+Rb)&lt;/code&gt; becomes bit 31 of &lt;code class=&quot;highlighter-rouge&quot;&gt;Ra&lt;/code&gt;,
bit 1 becomes bit 30, etc.&lt;/p&gt;

    &lt;p&gt;This instruction is very unique to the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;, and yet it is also very
fundamental to how the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; operates.  By using a &lt;strong&gt;BREV&lt;/strong&gt; instruction,
the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; can load any
18-bit value into the upper bits of a register.  If it is then followed by
a &lt;strong&gt;LDILO&lt;/strong&gt;, the pair of instructions can then load any 32-bit value into
a register.&lt;/p&gt;

    &lt;p&gt;The &lt;strong&gt;BREV&lt;/strong&gt; instruction is also very useful for bit-reversed addressing and
bit-manipulation functions–such as counting trailing zeros in a number.
It’s also used for the &lt;strong&gt;CLR&lt;/strong&gt; (clear register) derived instruction.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;LDILO&lt;/strong&gt;, or Load Immediate Lo, assigns the lower 16 bits of &lt;code class=&quot;highlighter-rouge&quot;&gt;Ra&lt;/code&gt; to the
lower 16 bits of &lt;code class=&quot;highlighter-rouge&quot;&gt;(#+Rb)&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;MPYUHI&lt;/strong&gt;, or multiply unsigned values and return the upper 32-bits, sets
&lt;code class=&quot;highlighter-rouge&quot;&gt;Ra&lt;/code&gt; to &lt;code class=&quot;highlighter-rouge&quot;&gt;(Ra*(#+Rb)) &amp;gt;&amp;gt;32&lt;/code&gt;.  The multiplication involved assumes both
&lt;code class=&quot;highlighter-rouge&quot;&gt;Ra&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;(#+Rb)&lt;/code&gt; are unsigned numbers.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;MPYSHI&lt;/strong&gt;, or multiply signed values and return the upper 32-bits, is
identical to &lt;code class=&quot;highlighter-rouge&quot;&gt;MPYUHI&lt;/code&gt;, with the exception that the multiplication is done
assuming both &lt;code class=&quot;highlighter-rouge&quot;&gt;Ra&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;(#+Rb)&lt;/code&gt; are signed numbers.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;MPY&lt;/strong&gt;, a 32x32-bit multiply which returns the lower bits of the result.
Basically, this is given by &lt;code class=&quot;highlighter-rouge&quot;&gt;Ra &amp;lt;= Ra * (#+Rb)&lt;/code&gt;, with the exception that
&lt;code class=&quot;highlighter-rouge&quot;&gt;Ra&lt;/code&gt; is set to the lower 32-bits of the product.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;DIVU&lt;/strong&gt;, a 32x32-bit unsigned divide.  &lt;code class=&quot;highlighter-rouge&quot;&gt;Ra &amp;lt;= Ra / (#+Rb)&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;DIVS&lt;/strong&gt;, a 32x32-bit signed divide. &lt;code class=&quot;highlighter-rouge&quot;&gt;Ra &amp;lt;= Ra / (#+Rb)&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;CMP&lt;/strong&gt;, Compare.  Sets the flags according to &lt;code class=&quot;highlighter-rouge&quot;&gt;Ra - (#+Rb)&lt;/code&gt;.  This
instruction is implemented identically to the &lt;strong&gt;SUB&lt;/strong&gt; instruction above,
save that &lt;em&gt;only&lt;/em&gt; the flags are affected by a &lt;strong&gt;CMP&lt;/strong&gt; instruction.  &lt;code class=&quot;highlighter-rouge&quot;&gt;Ra&lt;/code&gt;
is not written back to the register file.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;TEST&lt;/strong&gt;, is identical to the &lt;strong&gt;AND&lt;/strong&gt; instruction, save that like the &lt;strong&gt;CMP&lt;/strong&gt;
instruction, &lt;strong&gt;TEST&lt;/strong&gt; only sets the flags register and leaves &lt;code class=&quot;highlighter-rouge&quot;&gt;Ra&lt;/code&gt; untouched.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Two more basic instructions have subtly different forms.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;MOV&lt;/strong&gt;, a move instruction, &lt;code class=&quot;highlighter-rouge&quot;&gt;Ra &amp;lt;= (#+Rb)&lt;/code&gt;.  In this case, the move
instruction always has an &lt;code class=&quot;highlighter-rouge&quot;&gt;Rb&lt;/code&gt; register.  If you want to move just the
constant into a register, then use the &lt;strong&gt;LDI&lt;/strong&gt; instruction instead.&lt;/p&gt;

    &lt;p&gt;The &lt;strong&gt;MOV&lt;/strong&gt; instruction has the additional capability of moving values
between register sets–something we’ll need to get to later.  As a result,
the range of the immediate values supported by the move instruction (13-bits)
is not quite as many as those supported by the rest of the instructions
above (either 14-bits or 18-bits).&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;LDI&lt;/strong&gt;, or load immediate, has a little bit of a different form.  The
&lt;strong&gt;LDI&lt;/strong&gt; instruction has no &lt;code class=&quot;highlighter-rouge&quot;&gt;Rb&lt;/code&gt; register option.  It is used for loading
arbitrary values into &lt;code class=&quot;highlighter-rouge&quot;&gt;Ra&lt;/code&gt;, and written as &lt;code class=&quot;highlighter-rouge&quot;&gt;Ra &amp;lt;= #&lt;/code&gt;.&lt;/p&gt;

    &lt;p&gt;This instruction has
also been stripped to its bare essentials to be able to load the largest
value into a register as possible.  As a result, it can load any 23-bit
signed value into a register.  Anything more requires a combination of a
&lt;code class=&quot;highlighter-rouge&quot;&gt;BREV&lt;/code&gt; instruction and an &lt;code class=&quot;highlighter-rouge&quot;&gt;LDILO&lt;/code&gt; instruction.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The next six instructions are memory instructions.  These are written a little
differently, but they still read from left to right.  For example,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-asm&quot; data-lang=&quot;asm&quot;&gt;	SW.X Ra,#(Rb)&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;stores the value of &lt;code class=&quot;highlighter-rouge&quot;&gt;Ra&lt;/code&gt; into the address given by &lt;code class=&quot;highlighter-rouge&quot;&gt;#&lt;/code&gt; plus the &lt;code class=&quot;highlighter-rouge&quot;&gt;Rb&lt;/code&gt; register,
while&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-asm&quot; data-lang=&quot;asm&quot;&gt;	LW.X #(Rb),Ra&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;loads the value of &lt;code class=&quot;highlighter-rouge&quot;&gt;Ra&lt;/code&gt; based upon the contents of memory given by the address
in &lt;code class=&quot;highlighter-rouge&quot;&gt;Rb&lt;/code&gt; plus the offset, &lt;code class=&quot;highlighter-rouge&quot;&gt;#&lt;/code&gt;.  Both of these can be executed conditionally,
if the condition &lt;code class=&quot;highlighter-rouge&quot;&gt;X&lt;/code&gt; is true.  (More on that later.)&lt;/p&gt;

&lt;p&gt;Both of these instructions operate on a word, hence their mnemonic is
&lt;em&gt;store word&lt;/em&gt; or &lt;em&gt;load word&lt;/em&gt; respectively.  The &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; supports four other
memory instructions:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;LH&lt;/strong&gt; or load halfword.  This instruction loads a 16-bit value from memory
into &lt;code class=&quot;highlighter-rouge&quot;&gt;Ra&lt;/code&gt; and then clears the upper 16-bits to get the result to fit
into 32-bits.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;SH&lt;/strong&gt; or store halfword.  This instruction stores the bottom 16-bits of a
register into memory.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;LB&lt;/strong&gt; or load byte.  The upper 24-bits are cleared.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;SB&lt;/strong&gt; or store byte&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;These are all of the basic &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; instructions.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: left&quot;&gt;&lt;caption&gt;Fig 6: ZipCPU Instructions&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/zipcpu-insns-derived.png&quot; alt=&quot;(A chart of several of the ZipCPU&#39;s derived instructions)&quot; width=&quot;454&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;See anything missing?  If you are familiar with other
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;s,
you may notice &lt;em&gt;a lot&lt;/em&gt; of missing instructions.  None of these,
however, are truly required as combinations of the instructions
above can be used to implement almost any
instruction you might need.  For example, Fig 6 shows several examples of
instructions the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Assembly_language#Assembler&quot;&gt;assembler&lt;/a&gt;
understands, yet whose implementation is derived from the instructions above.&lt;/p&gt;

&lt;p&gt;Let’s back up a bit, though, and discuss the registers on the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;the-basic-zipcpu-register-set&quot;&gt;The Basic ZipCPU Register Set&lt;/h2&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 7: ZipCPU Register Set&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/zipcpu-registers.png&quot; alt=&quot;[ZipCPU](/about/zipcpu.html) registers: R0 (or LR), R1-R11, R12 (or FP), SP, CC, and PC.  There are two sets of these, one prefixed with u for user, the other prefixed with s for supervisor&quot; width=&quot;360&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;The &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; supports sixteen 32-bit registers in two sets, but
we’ll come back to issue of the different register sets later.  For now,
each set of sixteen registers is organized into registers &lt;code class=&quot;highlighter-rouge&quot;&gt;R0&lt;/code&gt;-&lt;code class=&quot;highlighter-rouge&quot;&gt;R15&lt;/code&gt;.  From
the hardware standpoint, all but the last two are general purpose, whereas
the compiler treats all but four of these registers as general purpose
registers.&lt;/p&gt;

&lt;p&gt;Of these sixteen registers, the hardware treats the last two as special purpose
registers.  &lt;code class=&quot;highlighter-rouge&quot;&gt;R15&lt;/code&gt; is the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Program_counter&quot;&gt;program counter&lt;/a&gt;,
or &lt;code class=&quot;highlighter-rouge&quot;&gt;PC&lt;/code&gt;.  This register maintains
the address of the next instruction the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; will execute within it.
&lt;code class=&quot;highlighter-rouge&quot;&gt;R14&lt;/code&gt; also has a special purpose–it is the &lt;a href=&quot;https://en.wikipedia.org/wiki/Status_register&quot;&gt;condition code and
status register&lt;/a&gt;,
or &lt;code class=&quot;highlighter-rouge&quot;&gt;CC&lt;/code&gt;.  Flags, such as whether or not the result of the last
operation was zero or not, are stored in the bottom four bits of the &lt;code class=&quot;highlighter-rouge&quot;&gt;CC&lt;/code&gt;
register.&lt;/p&gt;

&lt;p&gt;While the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; instruction set
doesn’t have any
&lt;a href=&quot;https://en.wikipedia.org/wiki/Branch_(computer_science)&quot;&gt;branch&lt;/a&gt;
instructions per se, three of the basic instructions above can be
applied to the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Program_counter&quot;&gt;program counter&lt;/a&gt;
in order to create
&lt;a href=&quot;https://en.wikipedia.org/wiki/Branch_(computer_science)&quot;&gt;branch&lt;/a&gt;
instructions.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;LDI #,PC&lt;/code&gt; loads a 23’bit signed immediate value into the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Program_counter&quot;&gt;program counter&lt;/a&gt;,
&lt;code class=&quot;highlighter-rouge&quot;&gt;PC&lt;/code&gt;.  It can be used any time the absolute address of the destination
is known by the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Assembly_language#Assembler&quot;&gt;assembler&lt;/a&gt;
before linking–which isn’t very often.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ADD #,PC&lt;/code&gt; adds an amount to the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Program_counter&quot;&gt;program counter&lt;/a&gt;,
&lt;code class=&quot;highlighter-rouge&quot;&gt;PC&lt;/code&gt;.  This will execute
a local &lt;a href=&quot;https://en.wikipedia.org/wiki/Branch_(computer_science)&quot;&gt;branch&lt;/a&gt;,
causing the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt;
to read its next instruction &lt;code class=&quot;highlighter-rouge&quot;&gt;#&lt;/code&gt; words
earlier or later depending on the sign of &lt;code class=&quot;highlighter-rouge&quot;&gt;#&lt;/code&gt;.  Since this is such a common
instruction, this is often abbreviated with by a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Branch_(computer_science)&quot;&gt;branch&lt;/a&gt;
always instruction, &lt;code class=&quot;highlighter-rouge&quot;&gt;BRA &amp;lt;address label&amp;gt;&lt;/code&gt;.&lt;/p&gt;

    &lt;p&gt;The &lt;code class=&quot;highlighter-rouge&quot;&gt;BRA&lt;/code&gt; instruction is often used for jumping between locations within a
given function–such as when executing a loop or an if.  It is used anytime
the &lt;a href=&quot;https://en.wikipedia.org/wiki/Assembly_language#Assembler&quot;&gt;assembler&lt;/a&gt;
can tell that the distance to the target will fit within 18-bits.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;LW (PC),PC&lt;/code&gt; followed by a new address, reads a new value of the program
counter from the next
word in instruction memory.  This instruction is used heavily by the linker,
since the next address in memory can later be simply set to any value once
that value is known.  This is also known as a &lt;em&gt;long jump&lt;/em&gt; instruction,
and so the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Assembly_language#Assembler&quot;&gt;assembler&lt;/a&gt;
understands the &lt;code class=&quot;highlighter-rouge&quot;&gt;LJMP &amp;lt;address label&amp;gt;&lt;/code&gt; mnemonic,
where &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;address label&amp;gt;&lt;/code&gt; is an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Assembly_language#Assembler&quot;&gt;assembly&lt;/a&gt;
label of where you wish to jump to.&lt;/p&gt;

    &lt;p&gt;When the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; is built with the
early &lt;a href=&quot;https://en.wikipedia.org/wiki/Branch_(computer_science)&quot;&gt;branching&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/cpudefs.v&quot;&gt;option&lt;/a&gt;, for
a cost of about 80 LUTs, and the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/pfcache.v&quot;&gt;prefetch with instruction
cache&lt;/a&gt;,
this instruction only costs three clock cycles.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/sw/gcc-zippatch.patch&quot;&gt;port&lt;/a&gt;
of &lt;a href=&quot;https://www.gcc.org&quot;&gt;GCC&lt;/a&gt;
treats &lt;code class=&quot;highlighter-rouge&quot;&gt;R0&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;R14&lt;/code&gt;, and (sometimes) &lt;code class=&quot;highlighter-rouge&quot;&gt;R13&lt;/code&gt; as special registers.
&lt;code class=&quot;highlighter-rouge&quot;&gt;R0&lt;/code&gt; is known as the link register, &lt;code class=&quot;highlighter-rouge&quot;&gt;LR&lt;/code&gt;, where the return address to a
subroutine is kept.  This leads to two other instructions:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;MOV 8(PC),R0&lt;/code&gt; followed by &lt;code class=&quot;highlighter-rouge&quot;&gt;LJMP &amp;lt;function&amp;gt;&lt;/code&gt; is how the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; implements
a long jump to subroutine command, &lt;strong&gt;LJSR&lt;/strong&gt;–a shorter jump can be
implemented with the &lt;code class=&quot;highlighter-rouge&quot;&gt;BRA&lt;/code&gt; instruction–but only if the destination is
known at
&lt;a href=&quot;https://en.wikipedia.org/wiki/Assembly_language#Assembler&quot;&gt;assembly&lt;/a&gt;
time to be in range.  The
&lt;a href=&quot;https://en.wikipedia.org/wiki/Assembly_language#Assembler&quot;&gt;assembler&lt;/a&gt;
handles all of the constants, and selects between the instruction forms
for you, so you may find these instruction pairs written in
&lt;a href=&quot;https://en.wikipedia.org/wiki/Assembly_language&quot;&gt;assembly&lt;/a&gt;
as either &lt;code class=&quot;highlighter-rouge&quot;&gt;JSR &amp;lt;function&amp;gt;&lt;/code&gt; or &lt;code class=&quot;highlighter-rouge&quot;&gt;LJSR &amp;lt;function&amp;gt;&lt;/code&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;MOV R0,PC&lt;/code&gt; loads the link register back into the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Program_counter&quot;&gt;program counter&lt;/a&gt;.  This
is often the last instruction in any function.  Indeed, it is so common
that the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Assembly_language#Assembler&quot;&gt;assembler&lt;/a&gt;
will also accept the &lt;strong&gt;RETN&lt;/strong&gt; mnemonic for this instruction.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The &lt;a href=&quot;https://www.gcc.org&quot;&gt;GCC&lt;/a&gt; &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/sw/gcc-zippatch.patch&quot;&gt;back
end&lt;/a&gt;
uses &lt;code class=&quot;highlighter-rouge&quot;&gt;R14&lt;/code&gt; as the &lt;a href=&quot;https://en.wikipedia.org/wiki/Stack_register&quot;&gt;stack
pointer&lt;/a&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;SP&lt;/code&gt;.  Hence, you
might see &lt;code class=&quot;highlighter-rouge&quot;&gt;SW R0,(SP)&lt;/code&gt; which will store &lt;code class=&quot;highlighter-rouge&quot;&gt;R0&lt;/code&gt; onto the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Call_stack&quot;&gt;stack&lt;/a&gt;.
If you choose not to optimize your code, and sometimes even if you do,
the compiler will use &lt;code class=&quot;highlighter-rouge&quot;&gt;R13&lt;/code&gt; as a frame pointer, &lt;code class=&quot;highlighter-rouge&quot;&gt;FP&lt;/code&gt;.  This register is
similar to the &lt;a href=&quot;https://en.wikipedia.org/wiki/Stack_register&quot;&gt;stack pointer&lt;/a&gt;,
and used to reference local variables within a function.  In
general, I’ve tried to keep the compiler from using &lt;code class=&quot;highlighter-rouge&quot;&gt;R13&lt;/code&gt; as a frame
pointer though–since it further limits the 14 general purpose registers.&lt;/p&gt;

&lt;p&gt;It’s for these reasons that, at the beginning of any function, you’ll often
see code looking like:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-asm&quot; data-lang=&quot;asm&quot;&gt;function_name:
	SUB 12,SP
	SW  R0,(SP)
	SW  R1,4(SP)
	; etc&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This allocates three words on the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Call_stack&quot;&gt;stack&lt;/a&gt;.
of four bytes each, and then uses the first two of them
to store &lt;code class=&quot;highlighter-rouge&quot;&gt;R0&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;R1&lt;/code&gt; respectively–presumably because the compiled routine
is going to clobber those registers and wants to use their values or restore
them later.&lt;/p&gt;

&lt;p&gt;You may then find, at the end that function, code that looks like,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-asm&quot; data-lang=&quot;asm&quot;&gt;	LW  (SP),R0
	LW  4(SP),R1
	ADD 12,SP
	RETN	; Implemented as MOV R0,PC&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This code loads the original values of &lt;code class=&quot;highlighter-rouge&quot;&gt;R0&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;R1&lt;/code&gt; back from the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Call_stack&quot;&gt;stack&lt;/a&gt;,
restores the &lt;a href=&quot;https://en.wikipedia.org/wiki/Stack_register&quot;&gt;stack pointer&lt;/a&gt;,
to its original value, and then finally returns
to the place where it was called from.&lt;/p&gt;

&lt;h2 id=&quot;conditions&quot;&gt;Conditions&lt;/h2&gt;

&lt;p&gt;When I introduced the form of the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; instructions above, I mentioned
that almost all instructions had the form &lt;code class=&quot;highlighter-rouge&quot;&gt;OP.X #+Rb,Ra&lt;/code&gt;.  We’ve examined
the various operations, &lt;code class=&quot;highlighter-rouge&quot;&gt;OP&lt;/code&gt;, and the various registers that &lt;code class=&quot;highlighter-rouge&quot;&gt;Ra&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;Rb&lt;/code&gt;
can take on, but we haven’t discussed the conditions, &lt;code class=&quot;highlighter-rouge&quot;&gt;X&lt;/code&gt;.
It is the condition &lt;code class=&quot;highlighter-rouge&quot;&gt;X&lt;/code&gt; that allows almost every
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
instruction to be executed &lt;em&gt;conditionally&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;The &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; supports 8 conditions,
or possibly values for the &lt;code class=&quot;highlighter-rouge&quot;&gt;X&lt;/code&gt;, as shown in Fig 8.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 8: ZipCPU Conditions&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/zipcpu-conditions.png&quot; alt=&quot;[ZipCPU](/about/zipcpu.html) supports eight conditions: (none), if zero, if less than, if greater than or equal, if overflow, and negations of these for all but overflow&quot; width=&quot;360&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;If no condition is specified with the instruction, then the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; will always perform the
indicated instruction.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Z&lt;/code&gt;, or the zero condition, will cause an instruction to only execute if
the &lt;code class=&quot;highlighter-rouge&quot;&gt;Z&lt;/code&gt; flag in the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Status_register&quot;&gt;condition codes&lt;/a&gt; is set.&lt;/p&gt;

    &lt;p&gt;If you are not familiar with
&lt;a href=&quot;https://en.wikipedia.org/wiki/Status_register&quot;&gt;condition codes&lt;/a&gt;,
the basic idea is that if the
result of the last instruction was a &lt;code class=&quot;highlighter-rouge&quot;&gt;Z&lt;/code&gt;ero, then the &lt;code class=&quot;highlighter-rouge&quot;&gt;Z&lt;/code&gt; bit will be set.
Hence, if you compare (i.e. subtract) two registers and the result is zero,
then you know the registers are equal and you can use the &lt;code class=&quot;highlighter-rouge&quot;&gt;Z&lt;/code&gt; bit to
do logic assuming the registers were equal.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;LT&lt;/code&gt;, the less than condition, will cause an instruction to execute &lt;em&gt;only&lt;/em&gt;
if the result of the last instruction was less than zero.  This is a
signed comparison result, focusing on the &lt;code class=&quot;highlighter-rouge&quot;&gt;N&lt;/code&gt;egative bit in the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Status_register&quot;&gt;condition codes&lt;/a&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;C&lt;/code&gt;, will cause an instruction to execute only if the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Status_register&quot;&gt;carry bit&lt;/a&gt;
is set.&lt;/p&gt;

    &lt;p&gt;This is also how the &lt;a href=&quot;https://www.gcc.org&quot;&gt;compiler&lt;/a&gt;
implements an &lt;em&gt;unsigned less than&lt;/em&gt; condition.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;V&lt;/code&gt;, will cause an instruction to execute only if the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Status_register&quot;&gt;o&lt;code class=&quot;highlighter-rouge&quot;&gt;V&lt;/code&gt;erflow bit&lt;/a&gt;
is set.  The &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/sw/gcc-zippatch.patch&quot;&gt;port&lt;/a&gt;
of &lt;a href=&quot;https://www.gcc.org&quot;&gt;GCC&lt;/a&gt; doesn’t yet use this
&lt;a href=&quot;https://en.wikipedia.org/wiki/Status_register&quot;&gt;flag&lt;/a&gt;,
but it may do so in the future.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The last three
&lt;a href=&quot;https://en.wikipedia.org/wiki/Status_register&quot;&gt;flags&lt;/a&gt;
are just negations of the earlier
&lt;a href=&quot;https://en.wikipedia.org/wiki/Status_register&quot;&gt;flags&lt;/a&gt;.
There’s &lt;code class=&quot;highlighter-rouge&quot;&gt;NZ&lt;/code&gt;, or not zero, &lt;code class=&quot;highlighter-rouge&quot;&gt;GE&lt;/code&gt;, or greater than or equal to, and there’s
&lt;code class=&quot;highlighter-rouge&quot;&gt;NC&lt;/code&gt; to test if the carry bit is not set (i.e., unsigned greater than or
equal to).&lt;/p&gt;

&lt;p&gt;The most common use of these conditions is in
&lt;a href=&quot;https://en.wikipedia.org/wiki/Branch_(computer_science)&quot;&gt;branching&lt;/a&gt;
operators.  For
example, &lt;code class=&quot;highlighter-rouge&quot;&gt;ADD.Z #,PC&lt;/code&gt; will cause the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt;
to jump &lt;em&gt;only&lt;/em&gt; if the &lt;code class=&quot;highlighter-rouge&quot;&gt;Z&lt;/code&gt;ero bit is set.  Since this is also a
very common operation, the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Assembly_language#Assembler&quot;&gt;assembler&lt;/a&gt;
understands seven
&lt;a href=&quot;https://en.wikipedia.org/wiki/Branch_(computer_science)&quot;&gt;branch&lt;/a&gt;
instruction implementing &lt;code class=&quot;highlighter-rouge&quot;&gt;ADD.X&lt;/code&gt;: &lt;code class=&quot;highlighter-rouge&quot;&gt;BZ&lt;/code&gt;
(&lt;a href=&quot;https://en.wikipedia.org/wiki/Branch_(computer_science)&quot;&gt;branch&lt;/a&gt;
if zero), &lt;code class=&quot;highlighter-rouge&quot;&gt;BNZ&lt;/code&gt;
(&lt;a href=&quot;https://en.wikipedia.org/wiki/Branch_(computer_science)&quot;&gt;branch&lt;/a&gt;
if not zero), &lt;code class=&quot;highlighter-rouge&quot;&gt;BLT&lt;/code&gt;
(&lt;a href=&quot;https://en.wikipedia.org/wiki/Branch_(computer_science)&quot;&gt;branch&lt;/a&gt;
if less than), &lt;code class=&quot;highlighter-rouge&quot;&gt;BGE&lt;/code&gt;
(&lt;a href=&quot;https://en.wikipedia.org/wiki/Branch_(computer_science)&quot;&gt;branch&lt;/a&gt;
if greater than or equal), &lt;code class=&quot;highlighter-rouge&quot;&gt;BC&lt;/code&gt;
(&lt;a href=&quot;https://en.wikipedia.org/wiki/Branch_(computer_science)&quot;&gt;branch&lt;/a&gt;
if carry is set), &lt;code class=&quot;highlighter-rouge&quot;&gt;BNC&lt;/code&gt;
(&lt;a href=&quot;https://en.wikipedia.org/wiki/Branch_(computer_science)&quot;&gt;branch&lt;/a&gt;
if carry is not set), and finally &lt;code class=&quot;highlighter-rouge&quot;&gt;BV&lt;/code&gt;
(&lt;a href=&quot;https://en.wikipedia.org/wiki/Branch_(computer_science)&quot;&gt;branch&lt;/a&gt;
on overflow).&lt;/p&gt;

&lt;p&gt;You can also use these conditions to test multiple things at once.  For
example, suppose you wanted to know if registers &lt;code class=&quot;highlighter-rouge&quot;&gt;R0&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;R1&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;R2&lt;/code&gt;, &lt;em&gt;and&lt;/em&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;R3&lt;/code&gt; were all zero, and you wish to
&lt;a href=&quot;https://en.wikipedia.org/wiki/Branch_(computer_science)&quot;&gt;branch&lt;/a&gt;
to some target if they are all zero.  In this case, you might write:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-asm&quot; data-lang=&quot;asm&quot;&gt;	CMP 0,R0
	CMP.Z 0,R1
	CMP.Z 0,R2
	CMP.Z 0,R3
	BZ all_zero&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;You could also do a test of whether or not just one of them was zero,
such as:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-asm&quot; data-lang=&quot;asm&quot;&gt;	CMP 0,R0
	CMP.NZ 0,R1
	CMP.NZ 0,R2
	CMP.NZ 0,R3
	BNZ one_of_these_is_nonzero&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;These work because the &lt;code class=&quot;highlighter-rouge&quot;&gt;CMP&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;TST&lt;/code&gt; instructions &lt;em&gt;always&lt;/em&gt; set the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Status_register&quot;&gt;condition codes&lt;/a&gt;–even
when executed conditionally.  Other instructions,
when executed conditionally, don’t affect the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Status_register&quot;&gt;condition codes&lt;/a&gt;–allowing
strings of conditional instructions to all depend upon the same condition.&lt;/p&gt;

&lt;p&gt;A good example of multiple instructions depending upon a single condition
would be an integer absolute value calculation.
Suppose you wanted to calculate the absolute value of &lt;code class=&quot;highlighter-rouge&quot;&gt;R0&lt;/code&gt; and leave the
result in &lt;code class=&quot;highlighter-rouge&quot;&gt;R0&lt;/code&gt;.  You might then write,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-asm&quot; data-lang=&quot;asm&quot;&gt;	TEST R0
	XOR.LT -1,R0
	ADD.LT 1,R0&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The first instruction &lt;code class=&quot;highlighter-rouge&quot;&gt;AND&lt;/code&gt;’s &lt;code class=&quot;highlighter-rouge&quot;&gt;R0&lt;/code&gt; with &lt;code class=&quot;highlighter-rouge&quot;&gt;-1&lt;/code&gt;–the default value if no other
value is given to &lt;code class=&quot;highlighter-rouge&quot;&gt;TEST&lt;/code&gt;.  Since this is a &lt;code class=&quot;highlighter-rouge&quot;&gt;TEST&lt;/code&gt; instruction, &lt;code class=&quot;highlighter-rouge&quot;&gt;R0&lt;/code&gt; is
left unchanged and only the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Status_register&quot;&gt;flags&lt;/a&gt; are affected.
In this case, the &lt;code class=&quot;highlighter-rouge&quot;&gt;N&lt;/code&gt; flag will be set if &lt;code class=&quot;highlighter-rouge&quot;&gt;R0&lt;/code&gt; is negative.  We can then
complement every bit and add one to &lt;code class=&quot;highlighter-rouge&quot;&gt;R0&lt;/code&gt; to negate it.
Notice how, in this process, the &lt;code class=&quot;highlighter-rouge&quot;&gt;XOR&lt;/code&gt; instruction didn’t affect the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Status_register&quot;&gt;flags&lt;/a&gt;, making it possible
to string the &lt;code class=&quot;highlighter-rouge&quot;&gt;ADD&lt;/code&gt; function to this chain as well–all operating only if
&lt;code class=&quot;highlighter-rouge&quot;&gt;R0&lt;/code&gt; was negative.&lt;/p&gt;

&lt;p&gt;Why are conditional instructions a good thing?  There is a real method and
purpose to this madness.  Conditional
&lt;a href=&quot;https://en.wikipedia.org/wiki/Branch_(computer_science)&quot;&gt;branches&lt;/a&gt;
on the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
cost about 5-clocks, whereas conditionally executed
&lt;a href=&quot;/zipcpu/2017/08/11/simple-alu.html&quot;&gt;ALU&lt;/a&gt;
instructions still cost only one clock.  Hence, the absolute value calculation
above costs 3-clocks (ignoring
&lt;a href=&quot;/zipcpu/2017/11/18/wb-prefetch.html&quot;&gt;prefetch&lt;/a&gt;
stalls), whereas the alternative&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;	&lt;span class=&quot;n&quot;&gt;TEST&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;R0&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;BGE&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;dont_negate&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;XOR&lt;/span&gt;	&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;R0&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;ADD&lt;/span&gt;	&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;R0&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;dont_negate&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;would cost four clocks if &lt;code class=&quot;highlighter-rouge&quot;&gt;R0&lt;/code&gt; needed to be negated, and six clocks if it
didn’t.  This is in comparison to the three clocks for both conditions
presented above.&lt;/p&gt;

&lt;p&gt;You may notice that for all of the extra functionality in this section and
the last, the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; still only offers the same basic 25-instructions.
&lt;a href=&quot;https://en.wikipedia.org/wiki/Branch_(computer_science)&quot;&gt;Branches&lt;/a&gt;,
jumps, and subroutine calls are just special cases of these same
instructions.&lt;/p&gt;

&lt;p&gt;There are also some subtle details here as well.  For example, some
instructions aren’t allowed to set the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Status_register&quot;&gt;condition codes&lt;/a&gt;.
These include &lt;code class=&quot;highlighter-rouge&quot;&gt;MOV&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;BREV&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;LDILO&lt;/code&gt; instructions and anything that
writes to the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Program_counter&quot;&gt;program counter&lt;/a&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;PC&lt;/code&gt; or the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Status_register&quot;&gt;condition code register&lt;/a&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;CC&lt;/code&gt;.
In a similar fashion, any conditionally executed instruction, with the
exception of &lt;code class=&quot;highlighter-rouge&quot;&gt;CMP&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;TEST&lt;/code&gt;, will not affect thew
&lt;a href=&quot;https://en.wikipedia.org/wiki/Status_register&quot;&gt;condition codes&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Well, not quite.  The &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; does
have four more &lt;em&gt;special&lt;/em&gt; instructions that we need to discuss in the next
section.&lt;/p&gt;

&lt;h2 id=&quot;special-instructions&quot;&gt;Special Instructions&lt;/h2&gt;

&lt;p&gt;The &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; also supports four special
instructions: &lt;code class=&quot;highlighter-rouge&quot;&gt;BREAK&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;LOCK&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;SIM&lt;/code&gt;, and &lt;code class=&quot;highlighter-rouge&quot;&gt;NOOP&lt;/code&gt;.&lt;br /&gt;
Other special instructions, such as &lt;code class=&quot;highlighter-rouge&quot;&gt;RTU&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;STEP&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;WAIT&lt;/code&gt;, or &lt;code class=&quot;highlighter-rouge&quot;&gt;HALT&lt;/code&gt;, are
derived instructions from the basic instructions listed above.  We’ll
come back to the &lt;code class=&quot;highlighter-rouge&quot;&gt;RTU&lt;/code&gt; instruction in the next section when we discuss
the purpose for the two separate register sets.&lt;/p&gt;

&lt;p&gt;The &lt;code class=&quot;highlighter-rouge&quot;&gt;BREAK&lt;/code&gt; instruction was built for the
&lt;a href=&quot;/zipcpu/2017/08/25/hw-debugging.html&quot;&gt;debugger&lt;/a&gt;.
By replacing any instruction with a &lt;code class=&quot;highlighter-rouge&quot;&gt;BREAK&lt;/code&gt; instruction, the currently
running code will halt at that instruction–without executing it.  This will
leave the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt;
in a state where the debugger can then examine what’s going on within it,
single step over the break, and then continue until the next break.&lt;/p&gt;

&lt;p&gt;The &lt;code class=&quot;highlighter-rouge&quot;&gt;LOCK&lt;/code&gt; instruction is used to support
&lt;a href=&quot;https://en.wikipedia.org/wiki/Linearizability&quot;&gt;atomic&lt;/a&gt; accesses.
&lt;a href=&quot;https://en.wikipedia.org/wiki/Linearizability&quot;&gt;Atomic&lt;/a&gt;
instructions are ones where you want to read something from the bus, operate
upon it, and then return the modified value.  For example, an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Linearizability&quot;&gt;atomic&lt;/a&gt;
increment might look like,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-asm&quot; data-lang=&quot;asm&quot;&gt;	LOCK
	LW	(R0),R1
	ADD	1,R1
	SW	R1,(R0)&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The &lt;code class=&quot;highlighter-rouge&quot;&gt;LOCK&lt;/code&gt; function works by disabling
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interrupt&quot;&gt;interrupts&lt;/a&gt;
and then making sure that
the &lt;a href=&quot;/doc/wbspec_b4.pdf&quot;&gt;wishbone&lt;/a&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;CYC&lt;/code&gt; line is not
lowered between the &lt;code class=&quot;highlighter-rouge&quot;&gt;LW&lt;/code&gt; (load word) and &lt;code class=&quot;highlighter-rouge&quot;&gt;SW&lt;/code&gt; (store word) instructions.
After three instructions, the number shown above, the lock is released.&lt;/p&gt;

&lt;p&gt;The &lt;code class=&quot;highlighter-rouge&quot;&gt;NOOP&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;SIM&lt;/code&gt; instructions are very similar, although they look
different on the surface.  &lt;code class=&quot;highlighter-rouge&quot;&gt;NOOP&lt;/code&gt; is a simple
no-operation instruction–an instruction that doesn’t do anything.  When the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; encounters a &lt;code class=&quot;highlighter-rouge&quot;&gt;NOOP&lt;/code&gt; instruction,
it does nothing.  When the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
encounters a &lt;code class=&quot;highlighter-rouge&quot;&gt;SIM&lt;/code&gt; instruction, while running in hardware, the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; halts with an illegal
instruction exception.&lt;/p&gt;

&lt;p&gt;These two instructions have some other capabilities when used within the
simulator: they can be used to send values to the simulation terminal via
either &lt;code class=&quot;highlighter-rouge&quot;&gt;SOUT&lt;/code&gt; (a SIM) or &lt;code class=&quot;highlighter-rouge&quot;&gt;NOUT&lt;/code&gt; (a NOOP).
For example, you can print either a single character to the terminal,
&lt;code class=&quot;highlighter-rouge&quot;&gt;NOUT &#39;c&#39;&lt;/code&gt;, a register’s value, &lt;code class=&quot;highlighter-rouge&quot;&gt;NDUMP R0&lt;/code&gt;, or even the full register bank to
the terminal, &lt;code class=&quot;highlighter-rouge&quot;&gt;NDUMP&lt;/code&gt;, using the
lower bits of these commands.  The
&lt;a href=&quot;https://en.wikipedia.org/wiki/Assembly_language#Assembler&quot;&gt;assembler&lt;/a&gt;
also understands mnemonics allowing you to string together multiple
characters into a single
&lt;a href=&quot;https://en.wikipedia.org/wiki/Assembly_language&quot;&gt;assembly&lt;/a&gt;
command, either &lt;code class=&quot;highlighter-rouge&quot;&gt;NSTR&lt;/code&gt; or &lt;code class=&quot;highlighter-rouge&quot;&gt;SSTR&lt;/code&gt;, to print to the terminal.&lt;/p&gt;

&lt;p&gt;In the case of the &lt;code class=&quot;highlighter-rouge&quot;&gt;NOOP&lt;/code&gt; instructions, once placed onto the actual hardware
these simulation only capabilities will be quietly ignored.&lt;/p&gt;

&lt;h2 id=&quot;interrupts&quot;&gt;Interrupts&lt;/h2&gt;

&lt;p&gt;Let’s now come back to those two register sets, since they are used to
help the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; handle
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interrupt&quot;&gt;interrupts&lt;/a&gt;.
Indeed, the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; has a fairly
unique &lt;a href=&quot;https://en.wikipedia.org/wiki/Interrupt&quot;&gt;interrupt&lt;/a&gt;
architecture.  For example, the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
only recognizes one type of
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interrupt&quot;&gt;interrupt&lt;/a&gt;.
When the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
recognizes an &lt;a href=&quot;https://en.wikipedia.org/wiki/Interrupt&quot;&gt;interrupt&lt;/a&gt;,
the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; just switches from user
to supervisor register sets.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 9: ZipCPU Operating Modes&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/zipcpu-modes.svg&quot; alt=&quot;Reset -&amp;gt; [ supervisor -&amp;gt; user ]*&quot; width=&quot;360&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Basically, it works like this: upon any reboot, the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; boots into
&lt;em&gt;supervisor&lt;/em&gt; mode.  This mode uses one set of sixteen registers—the
supervisor set.  When the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
is ready to enable &lt;a href=&quot;https://en.wikipedia.org/wiki/Interrupt&quot;&gt;interrupt&lt;/a&gt;s,
it switches to &lt;em&gt;user&lt;/em&gt; mode where the other set of registers are used—the
user set.  Then, on any
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interrupt&quot;&gt;interrupt&lt;/a&gt;, user trap,
or &lt;a href=&quot;https://en.wikipedia.org/wiki/Trap_(computing)&quot;&gt;processing exception&lt;/a&gt;,
the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
returns to supervisor mode.&lt;/p&gt;

&lt;p&gt;To make this possible, the &lt;code class=&quot;highlighter-rouge&quot;&gt;MOV&lt;/code&gt; instruction has been given a special
capability.  It can be used to &lt;code class=&quot;highlighter-rouge&quot;&gt;MOV&lt;/code&gt; registers between the two register
sets–but only when the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
is in supervisor mode.&lt;/p&gt;

&lt;p&gt;This means that
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interrupt&quot;&gt;interrupts&lt;/a&gt;
for the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; are handled
differently from other processors as well, and so programming the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
is a little different for that reason as well.&lt;/p&gt;

&lt;p&gt;For example, on most processors, an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interrupt&quot;&gt;interrupt&lt;/a&gt;
will:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Automatically place a couple of user registers
(the &lt;a href=&quot;https://en.wikipedia.org/wiki/Program_counter&quot;&gt;program counter&lt;/a&gt;,
&lt;a href=&quot;https://en.wikipedia.org/wiki/Stack_register&quot;&gt;stack pointer&lt;/a&gt;,
etc.) into a special place.  This may either be onto the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Call_stack&quot;&gt;stack&lt;/a&gt;,
in older &lt;a href=&quot;https://en.wikipedia.org/wiki/Instruction_set_architecture&quot;&gt;ISA&lt;/a&gt;s,
or in a couple of special purpose registers–as on more recent
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;s.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The address of an &lt;a href=&quot;https://en.wikipedia.org/wiki/Interrupt_handler&quot;&gt;interrupt service routine
(ISR)&lt;/a&gt;
is then loaded from an &lt;a href=&quot;https://en.wikipedia.org/wiki/Interrupt_vector_table&quot;&gt;interrupt
table&lt;/a&gt;, and the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;
jumps to this address.&lt;/p&gt;

    &lt;p&gt;This &lt;a href=&quot;https://en.wikipedia.org/wiki/Interrupt_vector_table&quot;&gt;table&lt;/a&gt;
needs to be carefully set by a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Microcontroller&quot;&gt;microcontroller&lt;/a&gt;,
often in a special memory location or special purpose register.  Any
mistake in this process and the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;
will try to execute instructions from a non-existent memory address.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;An &lt;a href=&quot;https://en.wikipedia.org/wiki/Interrupt_handler&quot;&gt;interrupt service
routine&lt;/a&gt; then runs to
“handle” the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interrupt&quot;&gt;interrupt&lt;/a&gt;.&lt;/p&gt;

    &lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Interrupt_handler&quot;&gt;These routines&lt;/a&gt;
are often built with very special rules.  This often
forces these routines to be built in
&lt;a href=&quot;https://en.wikipedia.org/wiki/Assembly_language&quot;&gt;assembly&lt;/a&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;A special instruction such as an IRET instruction (interrupt return) is
issued at the end of the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interrupt_handler&quot;&gt;ISR&lt;/a&gt;
to return to the previously running program.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;This is not how
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interrupt&quot;&gt;interrupts&lt;/a&gt;
work on the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;, nor does it
reflect how the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; is programmed.&lt;/p&gt;

&lt;p&gt;As shown above in Fig 9, the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
starts its processing in supervisor mode.  Before the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt;
can switch to user mode, it creates a set of registers for
user mode.  These are either loaded via
the &lt;a href=&quot;https://en.wikipedia.org/wiki/Assembly_language&quot;&gt;assembly&lt;/a&gt;.
&lt;code class=&quot;highlighter-rouge&quot;&gt;MOV&lt;/code&gt; instructions, or by the &lt;code class=&quot;highlighter-rouge&quot;&gt;zip_restore_context(int *)&lt;/code&gt; C-language
built-in.  This latter function call loads and sets all of the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; registers from a memory array.
It can then switch to user mode via an &lt;code class=&quot;highlighter-rouge&quot;&gt;RTU&lt;/code&gt; instruction.  The &lt;code class=&quot;highlighter-rouge&quot;&gt;RTU&lt;/code&gt;
instruction itself is implemented by an &lt;code class=&quot;highlighter-rouge&quot;&gt;OR&lt;/code&gt; instruction that just sets the
global &lt;a href=&quot;https://en.wikipedia.org/wiki/Interrupt&quot;&gt;interrupt&lt;/a&gt;
enable (&lt;code class=&quot;highlighter-rouge&quot;&gt;GIE&lt;/code&gt;) bit in the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Status_register&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;CC&lt;/code&gt; register&lt;/a&gt;.
A C-language built-in, &lt;code class=&quot;highlighter-rouge&quot;&gt;zip_rtu()&lt;/code&gt;, can also be used to execute this jump
from C.&lt;/p&gt;

&lt;p&gt;Once the &lt;code class=&quot;highlighter-rouge&quot;&gt;RTU&lt;/code&gt; instruction is issued, the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; starts executing instructions
using the user register set.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;If an &lt;a href=&quot;https://en.wikipedia.org/wiki/Interrupt&quot;&gt;interrupt&lt;/a&gt;
takes place while the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; is
in user mode, it will automatically switch back to supervisor mode.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;If an &lt;a href=&quot;https://en.wikipedia.org/wiki/Interrupt&quot;&gt;interrupt&lt;/a&gt;
is pending in supervisor mode, the &lt;code class=&quot;highlighter-rouge&quot;&gt;RTU&lt;/code&gt; instruction will have no effect
and will leave the 
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
in supervisor mode.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;If the user program needs to return to supervisor mode, it can can clear
the &lt;code class=&quot;highlighter-rouge&quot;&gt;GIE&lt;/code&gt; bit with either an &lt;code class=&quot;highlighter-rouge&quot;&gt;AND&lt;/code&gt; or an &lt;code class=&quot;highlighter-rouge&quot;&gt;LDI&lt;/code&gt; instruction.  This will send
the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; back into supervisor mode
as well.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Other program errors, such as
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_error&quot;&gt;bus errors&lt;/a&gt;, illegal
instructions, division by zero exceptions, etc.,  encountered in user
mode will also return the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
to supervisor mode.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The special &lt;code class=&quot;highlighter-rouge&quot;&gt;WAIT&lt;/code&gt; instruction will cause the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
to enter into user mode (if it isn’t in user mode already), but then
sleep until the next interrupt.  This instruction is also implemented
via a basic &lt;code class=&quot;highlighter-rouge&quot;&gt;OR&lt;/code&gt; instruction.  The &lt;code class=&quot;highlighter-rouge&quot;&gt;HALT&lt;/code&gt; instruction acts in an identical
fashion when executed in user mode.  When executed in supervisor mode it
will actually &lt;code class=&quot;highlighter-rouge&quot;&gt;HALT&lt;/code&gt; the CPU.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Once the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;
returns from user mode, it will return to the supervisor
code where it left off.  You can see this in the multi-tasking code
found in the &lt;a href=&quot;https://github.com/ZipCPU/s6soc&quot;&gt;S6Soc&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/s6soc/blob/master/sw/zipos/kernel.c&quot;&gt;kernel&lt;/a&gt;
software.  From a high level, that code looks like:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;kernel_entry&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;// ...
&lt;/span&gt;	&lt;span class=&quot;c1&quot;&gt;// Set up a series of user tasks, and initialize their registers.
&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;tasklist&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ksetup&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;

	&lt;span class=&quot;c1&quot;&gt;// Pick a current task, and load its registers into the user
&lt;/span&gt;	&lt;span class=&quot;c1&quot;&gt;// register set
&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;current&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tasklist&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;restore_context&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;current&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

	&lt;span class=&quot;c1&quot;&gt;// Enable interrupts ...
&lt;/span&gt;	&lt;span class=&quot;c1&quot;&gt;// ...
&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;do&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;c1&quot;&gt;// ....
&lt;/span&gt;		&lt;span class=&quot;n&quot;&gt;SET_WATCHDOG&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;zip_rtu&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;

		&lt;span class=&quot;c1&quot;&gt;// Get interrupt information
&lt;/span&gt;		&lt;span class=&quot;n&quot;&gt;pic&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_sys&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;io_pic&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pix&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x8000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
			&lt;span class=&quot;c1&quot;&gt;// We came here because of an interrupt
&lt;/span&gt;			&lt;span class=&quot;c1&quot;&gt;// ...
&lt;/span&gt;			&lt;span class=&quot;c1&quot;&gt;// Handle any interrupts
&lt;/span&gt;			&lt;span class=&quot;c1&quot;&gt;// ...
&lt;/span&gt;		&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

		&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;zip_ucc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CC_TRAPBIT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
			&lt;span class=&quot;c1&quot;&gt;// The user program has made a system call
&lt;/span&gt;			&lt;span class=&quot;c1&quot;&gt;// ...
&lt;/span&gt;			&lt;span class=&quot;c1&quot;&gt;// Handle any system calls
&lt;/span&gt;			&lt;span class=&quot;c1&quot;&gt;// ...
&lt;/span&gt;		&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;zip_ucc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CC_EXCEPTION&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
			&lt;span class=&quot;c1&quot;&gt;// The user task encountered an exception
&lt;/span&gt;			&lt;span class=&quot;c1&quot;&gt;// ...
&lt;/span&gt;			&lt;span class=&quot;c1&quot;&gt;// Deal with any user exceptions
&lt;/span&gt;			&lt;span class=&quot;c1&quot;&gt;// ...
&lt;/span&gt;		&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

		&lt;span class=&quot;c1&quot;&gt;// Check if we need to switch tasks
&lt;/span&gt;		&lt;span class=&quot;c1&quot;&gt;// ...
&lt;/span&gt;		&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;current&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;context&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;last_context&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
			&lt;span class=&quot;c1&quot;&gt;// If so, swap contexts
&lt;/span&gt;			&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;context_has_been_saved&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
				&lt;span class=&quot;n&quot;&gt;save_context&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;last_context&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;restore_context&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;current&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
		&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Wow!  Did you catch that?  That’s the core code of a multi-tasking
&lt;a href=&quot;https://en.wikipedia.org/wiki/Operating_System&quot;&gt;operating system&lt;/a&gt;!
Not only that, it was all written in C–no
&lt;a href=&quot;https://en.wikipedia.org/wiki/Assembly_language&quot;&gt;assembly&lt;/a&gt;
instructions were required in the task swapping code above.&lt;/p&gt;

&lt;p&gt;Did you notice where the return to userspace &lt;code class=&quot;highlighter-rouge&quot;&gt;RTU&lt;/code&gt; instruction was?  That
was the &lt;code class=&quot;highlighter-rouge&quot;&gt;zip_rtu()&lt;/code&gt; instruction.  Between when this instruction is issued
and when it returns, any user space program might run.&lt;/p&gt;

&lt;p&gt;How about &lt;a href=&quot;https://en.wikipedia.org/wiki/Interrupt&quot;&gt;interrupts&lt;/a&gt;?
Did you notice where the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interrupt&quot;&gt;interrupts&lt;/a&gt;
were handled?
&lt;code class=&quot;highlighter-rouge&quot;&gt;pic = _sys-&amp;gt;io_pic&lt;/code&gt; grabbed the current state of the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/icontrol.v&quot;&gt;interrupt controller&lt;/a&gt;
(an external module), which could then be queried to see if the reason for
&lt;code class=&quot;highlighter-rouge&quot;&gt;zip_rtu()&lt;/code&gt; returning was because of an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Interrupt&quot;&gt;interrupt&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Indeed, once I realized how easy it was to swap between different tasks
in a multi-task concept, I found myself personally rather excited by the
possibilities that the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
offered for studying
&lt;a href=&quot;https://en.wikipedia.org/wiki/Operating_System&quot;&gt;Operating System&lt;/a&gt;
fundamentals from C.&lt;/p&gt;

&lt;p&gt;Now, if I could just get enough time to finish integrating the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/zipmmu.v&quot;&gt;MMU&lt;/a&gt;,
I might manage to even run a full
&lt;a href=&quot;https://en.wikipedia.org/wiki/Operating_System&quot;&gt;O/S&lt;/a&gt;
on the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;.
&lt;a href=&quot;https://en.wikipedia.org/wiki/Linux&quot;&gt;Linux&lt;/a&gt;
anyone?&lt;/p&gt;

&lt;h2 id=&quot;differences-between-other-cpus&quot;&gt;Differences between other CPU’s&lt;/h2&gt;

&lt;p&gt;Okay, so that’s what the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; instruction set looks like.  But how does
it compare to other
&lt;a href=&quot;https://en.wikipedia.org/wiki/Soft_microprocessor&quot;&gt;soft processors&lt;/a&gt;?
In particular, the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
instruction set could easily be compared to many other
&lt;a href=&quot;https://en.wikipedia.org/wiki/Soft_microprocessor&quot;&gt;soft-core CPU&lt;/a&gt;s,
such as the &lt;a href=&quot;http://www.latticesemi.com/~/media/LatticeSemi/Documents/UserManuals/JL/LatticeMico32ProcessorReferenceManual37.pdf&quot;&gt;lm32 processor&lt;/a&gt;,
&lt;a href=&quot;https://raw.githubusercontent.com/openrisc/doc/master/archive/openrisc_arch.pdf&quot;&gt;OpenRISC&lt;/a&gt;,
&lt;a href=&quot;https://www.altera.com/literature/hb/nios2/n2cpu_nii5v1.pdf&quot;&gt;NiosII&lt;/a&gt;,
and &lt;a href=&quot;https://www.xilinx.com/support/documentation/sw_manuals/mb_ref_guide.pdf&quot;&gt;MicroBlaze&lt;/a&gt;.
Let’s take a look at some of the key differences between the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
and some of these other processors.&lt;/p&gt;

&lt;p&gt;The first big difference is that the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; does not support three operand
instructions.  An example of such an instruction might be to set register
&lt;code class=&quot;highlighter-rouge&quot;&gt;Rd&lt;/code&gt; to the sum of &lt;code class=&quot;highlighter-rouge&quot;&gt;Ra&lt;/code&gt; plus &lt;code class=&quot;highlighter-rouge&quot;&gt;Rb&lt;/code&gt;, or &lt;code class=&quot;highlighter-rouge&quot;&gt;ADD Rd,Ra,Rb&lt;/code&gt;.  Did you notice how
this instruction read right to left?  This is common with other instruction
sets as well.&lt;/p&gt;

&lt;p&gt;Why doesn’t the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; offer three operand instructions?  Simply because
it would complicate the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/idecode.v&quot;&gt;instruction
decode&lt;/a&gt;
logic.
In particular, you’d need to decode more than just the four basic instruction
formats above.  Most of these processors, for example, have instructions that
take zero operands, instructions that take one operand and an immediate
(&lt;code class=&quot;highlighter-rouge&quot;&gt;LDI&lt;/code&gt;), instructions that take two registers and an immediate, and
instructions that take three registers and then have barely any room
for any immediate values (11’bits).&lt;/p&gt;

&lt;p&gt;The next thing you’ll notice is that the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; has a 5-bit opcode
to select among the various instructions.  These other processors use a
6-bit opcode, and when that isn’t enough they steal bits (as in the case
of the &lt;a href=&quot;https://www.xilinx.com/support/documentation/sw_manuals/mb_ref_guide.pdf&quot;&gt;MicroBlaze&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;)
from their immediate space.  The resulting reality is that
the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; actually has a more
&lt;a href=&quot;https://en.wikipedia.org/wiki/Reduced_instruction_set_computer&quot;&gt;&lt;em&gt;Reduced&lt;/em&gt; instruction set&lt;/a&gt;
than these other processors.&lt;/p&gt;

&lt;p&gt;When it comes to special registers, the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; is actually very unique.
In contrast to
&lt;a href=&quot;https://www.xilinx.com/support/documentation/sw_manuals/mb_ref_guide.pdf&quot;&gt;MicroBlaze&lt;/a&gt;’s
25 special registers, or the 65+ special registers of either
&lt;a href=&quot;https://openrisc.io&quot;&gt;OpenRISC&lt;/a&gt; or
&lt;a href=&quot;https://riscv.org&quot;&gt;RISC-V&lt;/a&gt;,
the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; has only two special
hardware registers–the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Program_counter&quot;&gt;program counter&lt;/a&gt;
and the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Status_register&quot;&gt;condition codes register&lt;/a&gt;.
Other functionality, such as the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/icontrol.v&quot;&gt;interrupt controller&lt;/a&gt;,
or even the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/wbdmac.v&quot;&gt;direct memory access (DMA) engine&lt;/a&gt;’s
control registers, are placed on an &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/zipsystem.v&quot;&gt;external bus
near&lt;/a&gt;
the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;,
so that these pieces may be added (or removed) according to the
needs (and logic scarcity) of your particular environment and application.&lt;/p&gt;

&lt;p&gt;A fifth way the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; is unique is in the number of registers.  The &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
offers 14 general purpose registers to user space.  Most of these other
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;s
offer 32 registers–but only with a lot of caveats.
For example, you can’t use &lt;code class=&quot;highlighter-rouge&quot;&gt;R0&lt;/code&gt; since the compiler
depends upon it to be equal to zero.  Another register may be used to form
constants in the assembler, and so its off limits to the compiler.  By the
time you drill down further, you’ll discover that perhaps only 24 registers
are available.  Of these 24, a rough half of them are assumed to be clobbered
on any function call and need to be saved on the stack anyway.  Further,
saving registers to the stack is really the limiting factor in any choice of
register size.  As a result, the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;’s
14 general purpose registers really don’t limit the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;’s performance significantly
in comparison to these other
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;s.&lt;/p&gt;

&lt;p&gt;When you start looking at actual instructions, the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; might initially appear
less capable.  For example, 
the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; 
has no &lt;code class=&quot;highlighter-rouge&quot;&gt;ADDC&lt;/code&gt; or &lt;code class=&quot;highlighter-rouge&quot;&gt;SUBC&lt;/code&gt; instructions (add or
subtract with carry), neither does the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; offer any &lt;code class=&quot;highlighter-rouge&quot;&gt;RSUB&lt;/code&gt; reverse
subtract instruction, &lt;code class=&quot;highlighter-rouge&quot;&gt;SEXT&lt;/code&gt; sign extension instructions, &lt;code class=&quot;highlighter-rouge&quot;&gt;CLZ&lt;/code&gt; count leading
(or trailing) zero instructions, &lt;code class=&quot;highlighter-rouge&quot;&gt;ROL&lt;/code&gt; rotate
left (or right) instructions and more.  However, these are all fairly rare
instructions and workarounds are easy to come by.  Indeed, the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
once had a rotate left instruction.  That instruction was later removed
because 1) the compiler never used it, 2) very simple alternative
instruction combinations were already available, and
the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; needed to support
8-bit bytes in order to be POSIX compliant.&lt;/p&gt;

&lt;p&gt;Of course, the next place the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; shines is with
its simplified bus architecture.  I’m not sure if you saw
&lt;a href=&quot;https://forum.digilentinc.com/topic/4930-arty-microblaze-speed-question&quot;&gt;this thread&lt;/a&gt;
or not, but it shows that the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;–even without a data cache,
can still outperform a
&lt;a href=&quot;https://www.xilinx.com/support/documentation/sw_manuals/mb_ref_guide.pdf&quot;&gt;MicroBlaze&lt;/a&gt;
simply due to (what I believe is) its simplified bus architecture.&lt;/p&gt;

&lt;h2 id=&quot;next-lesson&quot;&gt;Next Lesson&lt;/h2&gt;

&lt;p&gt;There are actually many other features contained with the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;, and even
other differences between it and other
&lt;a href=&quot;https://en.wikipedia.org/wiki/Soft_microprocessor&quot;&gt;softcore CPU&lt;/a&gt;s,
then this simple post could discuss.  For example, the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; can
&lt;a href=&quot;/zipcpu/2017/08/25/hw-debugging.html&quot;&gt;single step code&lt;/a&gt;
from either supervisor or user mode and more.&lt;/p&gt;

&lt;p&gt;Further, time wouldn’t permit discussing the various I/O peripherals that
can be optionally added to the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;–peripherals such as an
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/icontrol.v&quot;&gt;interrupt controller&lt;/a&gt;,
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/zipcounter.v&quot;&gt;performance counters&lt;/a&gt;, a
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/wbdmac.v&quot;&gt;DMA controller&lt;/a&gt;,
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/ziptimer.v&quot;&gt;simplified timers&lt;/a&gt;,
and more.  At least, time today won’t permit it.  These components are all
fair game for future blog posts.&lt;/p&gt;

&lt;p&gt;Some parts of the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;,
however, remain a work in progress.  For example, while an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Memory_management_unit&quot;&gt;MMU&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/zipmmu.v&quot;&gt;exists&lt;/a&gt;,
I have yet to integrate it into the rest of the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v&quot;&gt;CPU&lt;/a&gt;.
In particular, the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/pfcache.v&quot;&gt;prefetch cache&lt;/a&gt;
will need to know when to invalidate cache lines due to writes, something
I haven’t gotten to yet.  Likewise, while a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Cache_(computing)&quot;&gt;data cache&lt;/a&gt; &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/dcache.v&quot;&gt;implementation
exists&lt;/a&gt;, it
also has yet to be integrated and has since become a touch out of date.  Once
those two are integrated, my next plan is to host
&lt;a href=&quot;https://en.wikipedia.org/wiki/Linux&quot;&gt;Linux&lt;/a&gt;
from the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;–I just haven’t
gotten that far yet.  Perhaps the reason is … I haven’t needed to.&lt;/p&gt;

&lt;p&gt;The &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; “as is” is already a
very capable &lt;a href=&quot;https://en.wikipedia.org/wiki/Microcontroller&quot;&gt;microcontroller&lt;/a&gt;,
just as it was designed to be.&lt;/p&gt;
&lt;hr /&gt;&lt;p&gt;&lt;em&gt;Know ye not, that to whom ye yield yourselves servants to obey, his servants ye are to whom ye obey; whether of sin unto death, or of obedience unto righteousness? (Rom 6:16)&lt;/em&gt;</description>
        <pubDate>Mon, 01 Jan 2018 00:00:00 -0500</pubDate>
        <link>http://zipcpu.com/zipcpu/2018/01/01/zipcpu-isa.html</link>
        <guid isPermaLink="true">http://zipcpu.com/zipcpu/2018/01/01/zipcpu-isa.html</guid>
        
        
        <category>zipcpu</category>
        
      </item>
    
      <item>
        <title>Top 10 ZipCPU blog posts for 2017</title>
        <description>&lt;p&gt;Happy New Year everyone!&lt;/p&gt;

&lt;p&gt;It’s now 2018.  Shall we take a quick look at the
top 10 posts from 2017?  In case you missed them, here’s a recap:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;/blog/2017/08/04/debouncing.html&quot;&gt;How to eliminate button bounces with digital logic&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;This page, showing how to handle debouncing buttons, received &lt;strong&gt;1,178&lt;/strong&gt;
hits in 2017.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;/dsp/2017/09/15/fastfir.html&quot;&gt;Building a high speed Finite Impulse Response Digital Filter&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;This page may have been the first real introduction to FIR filtering on
&lt;a href=&quot;http://zipcpu.com/&quot;&gt;ZipCPU.com&lt;/a&gt;, offering more details
than the &lt;a href=&quot;/dsp/2017/08/19/simple-filter.html&quot;&gt;initial, two-simple
filters&lt;/a&gt;
article presented.  It described how to build a generic FIR filter within an
FPGA.&lt;/p&gt;

    &lt;p&gt;Although the blog has since moved on to discuss &lt;a href=&quot;/dsp.html&quot;&gt;many other filtering
implementations&lt;/a&gt;, this basic article was a
winner that received &lt;strong&gt;1,284&lt;/strong&gt; page views in 2017.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;/dsp/2017/08/30/cordic.html&quot;&gt;Using a CORDIC to calculate sines and cosines in an FPGA&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;Although the CORDIC algorithm really isn’t anything new, this was still
a winning article as it helped to explain to many how a CORDIC operates.
As a result, this article received &lt;strong&gt;1,347&lt;/strong&gt; page views in 2017.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;/blog/2017/05/19/fpga-hell.html&quot;&gt;FPGA Hell&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;This simple and short essay describes the reality that many FPGA developers
have found themselves within: the code builds, it synthesizes, it can be
placed onto an FPGA, but once there it doesn’t work.  It also offers some
approaches for getting out of FPGA Hell as well.  This well loved
article received &lt;strong&gt;1,375&lt;/strong&gt; page views in 2017.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;/blog/2017/10/13/fpga-v-asic.html&quot;&gt;FPGAs vs ASICs&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;Thanks to a conversation with a friend at
&lt;a href=&quot;https://orconf.org&quot;&gt;ORCONF&lt;/a&gt;
this year, I learned that ASIC development is very different from FPGA
development.  Sure, they both share Verilog or VHDL as a base language,
and they
both use digital logic, but they are also &lt;em&gt;very different&lt;/em&gt; disciplines.
This article focuses on and describes those differences.  It received
&lt;strong&gt;1,427&lt;/strong&gt; page views in 2017.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;/zipcpu/2017/11/18/wb-prefetch.html&quot;&gt;Building a prefetch module for the ZipCPU&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;I guess I wasn’t expecting this article to end up on the top-ten list this
year when I wrote it.  It only describes a very simple prefetch module
for the ZipCPU, not the fastest or the best prefetch module.  Perhaps it
was because it showed how a prefetch module could interact with a CPU,
or perhaps it was because it showed how a prefetch module could be
formally verified.  Either way, this article ends up at number 6, with
&lt;strong&gt;2,003&lt;/strong&gt; page views during 2017.&lt;/p&gt;

    &lt;p&gt;Indeed, since this topic was so well received, I am looking forward to
posting about the ZipCPU’s &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/pfcache.v&quot;&gt;prefetch and cache
module&lt;/a&gt;,
and how that module may also be formally proven, in 2018.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;/blog/2017/10/20/cdc.html&quot;&gt;Some Simple Clock-Domain Crossing Solutions&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;This post discusses several different approaches to simple clock domain
crossings.  It discusses what clock domain crossings is, and when you need
a clock domain crossing solution in the first place.  This article received
&lt;strong&gt;2,152&lt;/strong&gt; page views.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;My first experience with Formal Methods&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;This post discusses my first experiences with using formal methods via the
open source &lt;a href=&quot;http://www.clifford.at/yosys&quot;&gt;yosys&lt;/a&gt; program and the
associated yosys-smtbmc program.  I applied these methods to a FIFO.  Much
to my surprise, the formal methods found bugs in my “working” FIFO
implementation that I had never found using a traditional test bench
methodology.&lt;/p&gt;

    &lt;p&gt;This post received &lt;strong&gt;5,936&lt;/strong&gt; page views in 2017.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;/blog/2017/08/21/rules-for-newbies.html&quot;&gt;Rules for new FPGA designers&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;At the beginning of the fall 2017 semester, I put together a list of
“rules” and pieces of advice for new FPGA designers.  While these rules
were hotly debated on the Hacker News website, they will still help to
keep new FPGA designers out of a lot of debugging troubles.&lt;/p&gt;

    &lt;p&gt;This post received &lt;strong&gt;11,530&lt;/strong&gt; page views.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;/blog/2017/09/18/clocks-for-sw-engineers.html&quot;&gt;Clocks for Software Engineers&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;The one post that received more page views than any other was the &lt;a href=&quot;/blog/2017/09/18/clocks-for-sw-engineers.html&quot;&gt;Clocks for
Software Engineers&lt;/a&gt;
post.  This post examines many of the common problems that software
engineers have when trying to “program” in Verilog or VHDL.  It discusses
the impact of for loops, and why the clock is so important.&lt;/p&gt;

    &lt;p&gt;In general, I make it a point not to post any of my articles to any news
aggregators.  This is based upon the Bible verse:&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;Let another man praise thee, and not thine own mouth; a stranger, and
not thine own lips. (&lt;a href=&quot;https://www.blueletterbible.org/kjv/pro/27/2&quot;&gt;Prov 27:2&lt;/a&gt;)&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;p&gt;Doing this also allows me to evaluate how well a particular article was, or
was not received.  If someone feels that the article was well written enough
to post to an aggregator, then that tells me something about my audience.&lt;/p&gt;

    &lt;p&gt;It may have been about four days after I posted this article when someone
read it and posted it on Hacker News.  I was sitting at my desk at the time
watching Google Analytics while doing other work when suddenly the number
of page views spiked from 0-3 at a time to upwards of 700 views at once.
(It’s probably more accurately a block average over a minute or two, but it
shows on the screen as though they were all at once.)  I then looked to find
the article on Hacker News: it was &lt;em&gt;the top article&lt;/em&gt; for several hours that
night.  Since then, it has often remained the top article people have read
on a week by week basis.&lt;/p&gt;

    &lt;p&gt;This article tops the zipcpu.com charts at &lt;strong&gt;57,033&lt;/strong&gt; page views in 2017.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;If you find you’ve missed any of these articles, feel free to go back and read
what others have enjoyed so much this year.&lt;/p&gt;

&lt;p&gt;From my standpoint, I find these top ten articles, together with any
e-mails from my &lt;a href=&quot;https://patreon.com/ZipCPU&quot;&gt;Patreon supporters&lt;/a&gt;, are a guide
to what topics might interest FPGA developers in the future.
For example, based upon this list I’ll probably discuss some other
(better?) approaches to sine-wave generation in this new year, how to build
(and verify) a prefetch with an integrated cache, an asynchronous FIFO
implementation, how to &lt;a href=&quot;https://github.com/ZipCPU/vgasim&quot;&gt;simulate a display&lt;/a&gt;
using Verilator, and much more–but only if the
&lt;a href=&quot;https://www.blueletterbible.org/kjv/jas/4/15&quot;&gt;Lord is willing&lt;/a&gt;.&lt;/p&gt;
&lt;hr /&gt;&lt;p&gt;&lt;em&gt;Say not thou, What is the cause that the former days were better than these? for thou dost not enquire wisely concerning this. (Eccl 7:10)&lt;/em&gt;</description>
        <pubDate>Mon, 01 Jan 2018 00:00:00 -0500</pubDate>
        <link>http://zipcpu.com/blog/2018/01/01/top-ten.html</link>
        <guid isPermaLink="true">http://zipcpu.com/blog/2018/01/01/top-ten.html</guid>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>A better filter implementation for slower signals</title>
        <description>&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 1. A Generic filter implementation&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/fir-form.svg&quot; alt=&quot;&quot; width=&quot;480&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;We’ve slowly been working through several
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_signal_processing&quot;&gt;DSP&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/tree/master/rtl&quot;&gt;implementations&lt;/a&gt; on
&lt;a href=&quot;http://zipcpu.com/&quot;&gt;this blog&lt;/a&gt;.  Each of these
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/tree/master/rtl&quot;&gt;implementations&lt;/a&gt;
includes the logic necessary to evaluate a typical
&lt;a href=&quot;https://en.wikipedia.org/wiki/Convolution&quot;&gt;convolution&lt;/a&gt;,
such as the one shown in Fig 1 on the right.&lt;/p&gt;

&lt;p&gt;We’ve presented both a
&lt;a href=&quot;/dsp/2017/09/15/fastfir.html&quot;&gt;fairly generic FIR filter implementation&lt;/a&gt;
for high rate data signals, as well as a
&lt;a href=&quot;/dsp/2017/09/29/cheaper-fast-fir.html&quot;&gt;simple modification to that implementation&lt;/a&gt;
that uses fewer resources but has a higher fanout.  We’ve also discussed a
&lt;a href=&quot;/dsp/2017/11/04/genfil-tb.html&quot;&gt;generic test harness&lt;/a&gt;
that can be used to test and prove some of
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters&quot;&gt;these filters&lt;/a&gt;,
and even showed &lt;a href=&quot;/dsp/2017/12/06/fastfir-tb.html&quot;&gt;how that harness might be
applied&lt;/a&gt;.
Further, we’ve discussed the usefulness of a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;’s
&lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency_response&quot;&gt;frequency response&lt;/a&gt;,
as well as
&lt;a href=&quot;/dsp/2017/11/22/fltr-response.html&quot;&gt;how to measure it&lt;/a&gt;
using the
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/bench/cpp/filtertb.cpp&quot;&gt;same test harness&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;However, if you want to try any of these initial filter implementations
on signals with a slower sample rate, such as audio signals, you’ll
quickly find these &lt;em&gt;faster&lt;/em&gt; filtering implementations to be very resource
intensive.&lt;/p&gt;

&lt;p&gt;For example, if you want to apply a 2047 tap filter to a 48kHz audio
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;,
while running your
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
at a 100MHz system clock, then the
&lt;a href=&quot;/dsp/2017/09/15/fastfir.html&quot;&gt;generic filter implementation&lt;/a&gt;
will cost you 2047 hardware multiplies.  This will force you to the most
expensive and feature rich Virtex-7 FPGA, the
&lt;a href=&quot;https://www.digikey.com/product-detail/en/xilinx-inc/XC7VH870T-1FLG1932C/XC7VH870T-1FLG1932C-ND/5247347&quot;&gt;XC7VH870T&lt;/a&gt;–a chip that will cost
you a minimum of $18k USD today on
&lt;a href=&quot;https://www.digikey.com&quot;&gt;Digikey&lt;/a&gt;.  On the other hand, if you used the
implementation presented below, you might still be able to use an
&lt;a href=&quot;https://www.digikey.com/product-detail/en/xilinx-inc/XC7A15T-1FTG256C/122-1930-ND/5248117&quot;&gt;Artix-7 priced at less than $26&lt;/a&gt; on
&lt;a href=&quot;https://www.digikey.com&quot;&gt;Digikey&lt;/a&gt;, and available as part of many hobby
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
boards for fairly reasonable prices (about $100USD).
&lt;a href=&quot;https://store.digilentinc.com/basys-3-artix-7-fpga-trainer-board-recommended-for-introductory-users/&quot;&gt;[1]&lt;/a&gt;
&lt;a href=&quot;https://store.digilentinc.com/arty-artix-7-fpga-development-board-for-makers-and-hobbyists/&quot;&gt;[2]&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;For all of these reasons, it’s important to know how to build a
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/slowfil.v&quot;&gt;filter&lt;/a&gt;
that re-uses its hardware multiplies to the maximum extent possible.  The
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/slowfil.v&quot;&gt;filter&lt;/a&gt;
that we’ll present below, for example, uses only one hardware
multiply–although that will limit the number of coefficients this
&lt;a href=&quot;https://en.wikipedia.org/wiki/Finite_impulse_response&quot;&gt;FIR&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/slowfil.v&quot;&gt;implementation&lt;/a&gt;
can handle.&lt;/p&gt;

&lt;p&gt;Let’s take a look at what how this
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;
will need to operate, and then look at how to
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/slowfil.v&quot;&gt;implement&lt;/a&gt;
it.  Once implemented, we’ll show how easy it is
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/bench/cpp/slowfil_tb.cpp&quot;&gt;to test&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/slowfil.v&quot;&gt;this filter&lt;/a&gt;
using the
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/bench/cpp/filtertb.cpp&quot;&gt;test harness&lt;/a&gt;
we built some time ago.&lt;/p&gt;

&lt;h2 id=&quot;the-operation&quot;&gt;The Operation&lt;/h2&gt;

&lt;p&gt;If you’ve gone through the posts above, then you are already aware that a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;digital filter&lt;/a&gt;
evaluates a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Convolution&quot;&gt;convolution&lt;/a&gt;.
For example, if &lt;code class=&quot;highlighter-rouge&quot;&gt;x[n]&lt;/code&gt; were our input, &lt;code class=&quot;highlighter-rouge&quot;&gt;y[n]&lt;/code&gt; our output, and &lt;code class=&quot;highlighter-rouge&quot;&gt;h[n]&lt;/code&gt; a
series of coefficients, then we might write that,&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/fir-convolution.png&quot; alt=&quot;&quot; width=&quot;255&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Pictorially, this equation describes the operation shown in Fig 1 above.&lt;/p&gt;

&lt;p&gt;Today’s &lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/slowfil.v&quot;&gt;filter
implementation&lt;/a&gt;
will follow directly from a straight-forward evaluation of the summation
in the equation above.  In other words, we’ll start by setting an
accumulator to the first value,&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/fir-slowfil-acc-zero.png&quot; alt=&quot;&quot; width=&quot;205&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Then, on each subsequent clock we’ll add the next value to it,&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/fir-slowfil-acc-step.png&quot; alt=&quot;&quot; width=&quot;409&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 2. A Time Multiplexed filter implementation&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/fir-slow-form.svg&quot; alt=&quot;&quot; width=&quot;480&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Fig 2 on the right shows a diagram of how this approach might look.
Basically, at every step we’ll read both an &lt;code class=&quot;highlighter-rouge&quot;&gt;h[k]&lt;/code&gt; value and an &lt;code class=&quot;highlighter-rouge&quot;&gt;x[n-k]&lt;/code&gt;
value from separate memories, multiply the two together, and add the product
together with the value from an accumulator.  Once all the values have
been added together, we’ll use this accumulated result as our output.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/fir-slowfil-acc-done.png&quot; alt=&quot;&quot; width=&quot;204&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;In Verilog, this might look something like the following.  On the first
clock, we’d read one tap from the tap (coefficient) memory, and multiply
it by our incoming data sample, &lt;code class=&quot;highlighter-rouge&quot;&gt;i_sample&lt;/code&gt;.  The result of that product
could then be used to initialize an accumulator, &lt;code class=&quot;highlighter-rouge&quot;&gt;r_acc&lt;/code&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
if (i_ce)
begin
	// first clock
	tap &amp;lt;= tapmem[0];

	// second clock
	product &amp;lt;= tap * i_sample;

	// third clock
	r_acc &amp;lt;= product;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Sounds simple so far, right?  Okay, so we’ve ignored any pipeline scheduling
(&lt;code class=&quot;highlighter-rouge&quot;&gt;i_ce&lt;/code&gt; will only be true for one clock in &lt;code class=&quot;highlighter-rouge&quot;&gt;N&lt;/code&gt;), but let’s come back to that
in a moment.&lt;/p&gt;

&lt;p&gt;Further, we’re going to need to read from block RAM memory on every clock
following.  This means we’ll need to place this new sample value into
memory, and then increment the write pointer.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	// Write the new data to memory, then increment the memory pointer
	dmem[dwidx] &amp;lt;= i_sample;
	dwidx &amp;lt;= dwidx + 1&#39;b1;	// increment the memory write pointer&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;We’re also going to want to be able to read the coefficient index pointer
and the data index pointer on the next clock, so let’s set these as part
of the same clock that the new data shows in on.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	// Still on i_ce
	tidx &amp;lt;= 1;
	didx &amp;lt;= dwidx;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;After the accumulator has been given an initial value, we’ll then need to read
both the coefficient values and the data values from an on-chip block RAM
memory.  Placing
the data into a data memory to make this happen will require a memory write
and some memory address manipulation.  That means that the second part of
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/slowfil.v&quot;&gt;this algorithm&lt;/a&gt;
might look like:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;end else if (!done)
begin
	// Now, between clocks, we&#39;ll need to read the data and the coefficient
	data &amp;lt;= dmem[didx];	// Read data from the sample memory, x[n-k]
	tap &amp;lt;= tapmem[tidx];	// Read from the coefficient memory, h[k]

	// Update the pointers to each.  Notice that the coefficient index,
	// tidx increases while the data index decreases--just as we have
	// above.
	didx &amp;lt;= didx - 1&#39;b1;
	tidx &amp;lt;= tidx + 1&#39;b1;

	// and calculate the product
	product &amp;lt;= tap * data;

	// Use the product to update the accumulator
	r_acc &amp;lt;= r_acc + product&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Once we are done with all of the above, we’ll set the &lt;a href=&quot;/blog/2017/08/14/strategies-for-pipelining.html&quot;&gt;traveling
CE&lt;/a&gt;
values associated with the output, &lt;code class=&quot;highlighter-rouge&quot;&gt;o_ce&lt;/code&gt;, and set the output 
value according to the last &lt;code class=&quot;highlighter-rouge&quot;&gt;r_acc&lt;/code&gt; value.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;end else // if (done)
begin
	o_ce &amp;lt;= 1&#39;b1;
	o_result &amp;lt;= r_acc;
end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;That’s the general gist of what we need to do.  Sadly, however, the code above
has multiple timing errors and pipeline scheduling conflicts within it.
For example, there should
be a clock delay between reading from memory and using the result, and another
clock delay between multiplying two numbers together and using that result.
As a result, the logic above will never work, but as a simple first draft
it should be able to convey (roughly) what it is we hope to do.&lt;/p&gt;

&lt;h2 id=&quot;the-basic-filter-written-in-c&quot;&gt;The basic filter, written in C++&lt;/h2&gt;

&lt;p&gt;Perhaps if you have a software background, you might appreciate seeing this
code written out in C++.  The following is an excerpt from an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Finite_impulse_response&quot;&gt;FIR&lt;/a&gt;
implementation found in my own personal signal processing library.  The code
uses double’s instead of fixed point, but it’s still basically the same thing.&lt;/p&gt;

&lt;p&gt;This C++ algorithm depends upon an array of &lt;code class=&quot;highlighter-rouge&quot;&gt;m_len&lt;/code&gt; coefficients, &lt;code class=&quot;highlighter-rouge&quot;&gt;m_coeff&lt;/code&gt;.
This array will be initialized with the coefficients associated with the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;
before starting.&lt;/p&gt;

&lt;p&gt;It also needs an array of data, &lt;code class=&quot;highlighter-rouge&quot;&gt;m_data&lt;/code&gt;, of the same length.  Rather than
moving all the data through the array at every point in time, we’ll just
keep track of the address of the last data element in the tapped delay line,
&lt;code class=&quot;highlighter-rouge&quot;&gt;m_loc&lt;/code&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt;	&lt;span class=&quot;nc&quot;&gt;FIR&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;m_len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;	&lt;span class=&quot;c1&quot;&gt;// Number of taps in the filter
&lt;/span&gt;	&lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt;	&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_coeff&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

	&lt;span class=&quot;c1&quot;&gt;// ...
&lt;/span&gt;	&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;m_loc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;		&lt;span class=&quot;c1&quot;&gt;// Location of the last sample in the buffer
&lt;/span&gt;	&lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt;	&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;	&lt;span class=&quot;c1&quot;&gt;// Data buffer, double[m_len]
&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;// ...
&lt;/span&gt;	&lt;span class=&quot;c1&quot;&gt;// Declare our operator
&lt;/span&gt;	&lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;apply&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i_sample&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Were this written in Verilog, such as we will do in the next section, these two
arrays would be captured in block RAMs.&lt;/p&gt;

&lt;p&gt;To evaluate the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Convolution&quot;&gt;convolution&lt;/a&gt; via the
equation above, we’ll run the following code when given a new sample,
&lt;code class=&quot;highlighter-rouge&quot;&gt;i_sample&lt;/code&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;FIR&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;apply&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i_sample&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;             &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ln&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;acc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Our first step will be to record the new sample into the data memory.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;	&lt;span class=&quot;n&quot;&gt;m_data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_loc&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dat&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_loc&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m_len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;m_loc&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;After this point, we’ll enter a loop whereby we grab one sample from
data memory and one coefficient from the coefficient memory, multiply the
two together, and accumulate the result into an accumulator, &lt;code class=&quot;highlighter-rouge&quot;&gt;acc&lt;/code&gt;.  We’ll
start the accumulator at zero.  Further, after each sample,
we’ll increase the address in coefficient memory, and decrease the address
in data memory–just as the formula above indicated.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;	&lt;span class=&quot;n&quot;&gt;acc&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;d&lt;/span&gt;   &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_loc&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;   &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_coeff&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;ln&lt;/span&gt;  &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m_loc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ln&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;acc&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The fact that the data memory isn’t centered makes this a touch more
complicated.  What that means is that if you start reading backwards
from the middle of memory (where the most recent sample was), you
will eventually run off the beginning of the memory.  Fig 3 shows this below.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 3. Data memory contains both old and new data&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/fir-slow-memory.svg&quot; alt=&quot;&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;In this figure, you can see the location &lt;code class=&quot;highlighter-rouge&quot;&gt;m_loc&lt;/code&gt; (just right of the center
of the figure) which is one past where
the new data, &lt;code class=&quot;highlighter-rouge&quot;&gt;i_sample&lt;/code&gt;, has just been written.  You can also see how
the &lt;code class=&quot;highlighter-rouge&quot;&gt;x[n-k]&lt;/code&gt; sequence extends to the left of this location.  Once this
data sequence runs off the end of memory to the left, a second pass is
required to get the rest of the data coming from the far end on the right.
This second pass continues back to where we started, making sure every data
sample in memory, and every coefficient value, is used exactly once.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;	&lt;span class=&quot;n&quot;&gt;d&lt;/span&gt;   &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m_data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_len&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;ln&lt;/span&gt;  &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ln&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_loc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ln&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;acc&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Once all of the multiplies have been completed, the result is returned.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;	&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;acc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This is the basic algorithm we will write in Verilog below.  There will be
some differences though.  The first and most obvious difference is the fact
that several parts of this algorithm will run in parallel–this is &lt;a href=&quot;/blog/2017/09/18/clocks-for-sw-engineers.html&quot;&gt;running in
hardware&lt;/a&gt;
after all.  The next, not
quite so obvious difference, is that if the memory address is limited to
some finite number of bits, then we won’t need to pay any attention to the
memory break shown above in Fig 3.  Finally, the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;
algorithm &lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/slowfil.v&quot;&gt;implemented in
Verilog&lt;/a&gt;
will be written using fixed point numbers instead of the &lt;code class=&quot;highlighter-rouge&quot;&gt;double&lt;/code&gt;-precision
floating point numbers that are so easy to use in the C++ above.&lt;/p&gt;

&lt;p&gt;Before moving on, I should make one point about the code above.  This C/C++
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;
implementation is only practical for
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;s
with &lt;a href=&quot;https://en.wikipedia.org/wiki/Impulse_response&quot;&gt;impulse responses&lt;/a&gt;
shorter than about 64 samples.  Anything more than 64 samples and you’ll
want to use an &lt;a href=&quot;https://en.wikipedia.org/wiki/Fast_Fourier_transform&quot;&gt;FFT&lt;/a&gt;
based
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filtering&lt;/a&gt;
approach.  The differences between the two approaches will become
particularly stark after double the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;
length only a few times.&lt;/p&gt;

&lt;h2 id=&quot;verilog&quot;&gt;Verilog&lt;/h2&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 4. Test Harness Filter Interface&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/fir-ports.svg&quot; alt=&quot;&quot; width=&quot;240&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;You may remember from our
&lt;a href=&quot;/dsp/2017/11/04/genfil-tb.html&quot;&gt;test harness discussion&lt;/a&gt;
that as long as a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;
implementation has the ports we discussed then, and shown again here in
Fig 4 at the right, that we can continue using our &lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/bench/cpp/filtertb.cpp&quot;&gt;generic filtering test
harness&lt;/a&gt;.
While we’ll be able to
&lt;a href=&quot;https://en.wikipedia.org/wiki/Inheritance_(object-oriented_programming)&quot;&gt;inherit&lt;/a&gt;
and modify
the &lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/bench/cpp/filtertb.cpp&quot;&gt;test harness&lt;/a&gt;
with additional functionality in the next section, we’ll 
need to start out this section by remembering that our
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;
implementation will need to have a reset, and the ability to load
taps, in addition to samples coming in and going out.&lt;/p&gt;

&lt;p&gt;We’ll start with the ability to set our
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;
coefficients.  As with many of our
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/tree/master/rtl&quot;&gt;other filters&lt;/a&gt;,
we’ll allow a parameter &lt;code class=&quot;highlighter-rouge&quot;&gt;FIXED_TAPS&lt;/code&gt; to express whether or not this
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;
has a tap-update capability at all.  If the coefficients are fixed, then
we’ll &lt;code class=&quot;highlighter-rouge&quot;&gt;$readmemh&lt;/code&gt; them from a &lt;code class=&quot;highlighter-rouge&quot;&gt;.hex&lt;/code&gt; file whose name is given in
&lt;code class=&quot;highlighter-rouge&quot;&gt;INITIAL_COEFFS&lt;/code&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	generate if (FIXED_TAPS)
	begin
		initial $readmemh(INITIAL_COEFFS, tapmem);
		// ...
	end else begin&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;On the other hand, if our
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;
coefficients are not fixed, &lt;code class=&quot;highlighter-rouge&quot;&gt;FIXED_TAPS&lt;/code&gt; will be false, and we’ll need
to load our coefficients into memory.  To do this, we’ll start with a
memory index, &lt;code class=&quot;highlighter-rouge&quot;&gt;tapwidx&lt;/code&gt;, or tap writing index.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;		reg	[(LGNTAPS-1):0]	tapwidx;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;We’ll set this index to zero initially, and to return to zero upon any reset.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;		initial	tapwidx = 0;
		always @(posedge i_clk)
			if(i_reset)
				tapwidx &amp;lt;= 0;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Otherwise, anytime the &lt;code class=&quot;highlighter-rouge&quot;&gt;i_tap_wr&lt;/code&gt; signal is high, a new coefficient is present
in &lt;code class=&quot;highlighter-rouge&quot;&gt;i_tap&lt;/code&gt; which we’ll write to coefficient memory.  We’ll also need to
increment this index.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;			else if (i_tap_wr)
				tapwidx &amp;lt;= tapwidx + 1&#39;b1;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Here’s where we actually use the tap (coefficient) writing index, &lt;code class=&quot;highlighter-rouge&quot;&gt;tapwidx&lt;/code&gt;
to write into the coefficient memory, &lt;code class=&quot;highlighter-rouge&quot;&gt;tapmem&lt;/code&gt;.  This is also the section
of the code to specify any memory initialization, so we’ll initialize the
memory if the &lt;code class=&quot;highlighter-rouge&quot;&gt;INITIAL_COEFFS&lt;/code&gt; file name is empty.  Note that the &lt;code class=&quot;highlighter-rouge&quot;&gt;if&lt;/code&gt;
statement is &lt;em&gt;outside&lt;/em&gt; of the &lt;code class=&quot;highlighter-rouge&quot;&gt;initial&lt;/code&gt; block.  That will keep the
synthesizer from looking for this file if the name hasn’t been given.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;		if (INITIAL_COEFFS != 0)
			initial $readmemh(INITIAL_COEFFS, tapmem);
		always @(posedge i_clk)
			if (i_tap_wr)
				tapmem[tapwidx] &amp;lt;= i_tap;
	end endgenerate&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;That’s all that’s required for dynamically setting or adjusting coefficient
memory.  We started with an &lt;code class=&quot;highlighter-rouge&quot;&gt;i_reset&lt;/code&gt; signal to clear the index, and then
wrote one coefficient and stepped the index on any clock where &lt;code class=&quot;highlighter-rouge&quot;&gt;i_tap_wr&lt;/code&gt; was
true.&lt;/p&gt;

&lt;p&gt;So let’s now turn our attention to the &lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/slowfil.v&quot;&gt;filter
implementation&lt;/a&gt;
itself.&lt;/p&gt;

&lt;p&gt;We’ll start with updating the data memory, herein called &lt;code class=&quot;highlighter-rouge&quot;&gt;dmem&lt;/code&gt;.  We’ll
use a data memory write index, &lt;code class=&quot;highlighter-rouge&quot;&gt;dwidx&lt;/code&gt; to do this.  Hence, on every &lt;code class=&quot;highlighter-rouge&quot;&gt;i_ce&lt;/code&gt;
value, we’ll increment the data memory write index,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	initial	dwidx = 0;
	always @(posedge i_clk)
		if (i_ce)
			dwidx &amp;lt;= dwidx + 1&#39;b1;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;and write the new sample into the data memory.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(posedge i_clk)
		if (i_ce)
			dmem[dwidx] &amp;lt;= i_sample;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;That may be about as simple as any logic could get!&lt;/p&gt;

&lt;p&gt;That said, there is a subtlety associated with this approach.
Notice in this process how the data memory update process is &lt;em&gt;independent&lt;/em&gt;
of the &lt;code class=&quot;highlighter-rouge&quot;&gt;i_reset&lt;/code&gt; signal.  It is dependent upon new sample data
only.  Further, this will allow the
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/slowfil.v&quot;&gt;filter&lt;/a&gt;
to immediately start with valid data following any reset.&lt;/p&gt;

&lt;p&gt;This &lt;em&gt;feature&lt;/em&gt;, however, will become a thorn in our side when we build our
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/bench/cpp/slowfil_tb.cpp&quot;&gt;test bench&lt;/a&gt;.
The basic problem is that we’ll want to apply test vectors to the
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/slowfil.v&quot;&gt;filter&lt;/a&gt;
that assume the memory is clear (all zeros).  While the preferred solution
might be to clear all memory elements any time &lt;code class=&quot;highlighter-rouge&quot;&gt;i_reset&lt;/code&gt; is asserted, this
isn’t how most memories are built.  That means that, when we wish to clear
this memory later, we’ll need to write as many zeros to it as are necessary
to fill it with zeros.&lt;/p&gt;

&lt;p&gt;Those two parts, loading tap coefficients and incoming data, are the easy
parts of the algorithm, though.  The next step is to calculate
the indices to be used for both reading from coefficient and data memories.
Since this gets into scheduling, let’s take a moment to start scribbling
a draft pipeline schedule.&lt;/p&gt;

&lt;p&gt;Usually, when I build a pipeline schedule, I start by writing out my code and
marking each line with the appropriate clock.  Doing this might result in
pseudocode looking something like the following.&lt;/p&gt;

&lt;p&gt;The first clock would set the memory reading indexes.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	// Clock 1 -- i_ce and i_sample are true, tidx and didx are set
	if (i_ce)
	begin
		tidx &amp;lt;= 0;
		didx &amp;lt;= dwidx;
	end else begin
		tidx &amp;lt;= tidx + 1&#39;b1;
		didx &amp;lt;= didx - 1&#39;b1;
	end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Notice how we are using the &lt;code class=&quot;highlighter-rouge&quot;&gt;i_ce&lt;/code&gt; signal as an indication of when to reset
the indices for the data and coefficient memories, &lt;code class=&quot;highlighter-rouge&quot;&gt;didx&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;tidx&lt;/code&gt;,
to the beginning of our run.  At the same time, we’ll write the new data
sample into memory–we discussed that above.  That’s the first clock.&lt;/p&gt;

&lt;p&gt;The second clock would read from memory,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	// Clock 2.
	tap &amp;lt;= tapmem[tidx];
	data &amp;lt;= dmem[didx];&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This will give us the information we need to calculate &lt;code class=&quot;highlighter-rouge&quot;&gt;h[k][x[n-k]&lt;/code&gt;, hence
we can multiply these two values together on the third clock cycle,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	// Clock 3.
	product &amp;lt;= tap * data;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Once the product is available, we’d add it to our accumulator.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	// Clock 4.
	if (new_product_data)
		acc &amp;lt;= product;
	else if (subsequent_product_data)
		acc &amp;lt;= acc + product;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The final step would be to create our output.  This will need to take place
some time into the future–at a time we’ll need to come back to and determine
later.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	// Clock ... some distance into the future
	if (new_product_data)
	begin
		o_ce &amp;lt;= 1&#39;b1;
		o_result &amp;lt;= acc;
	end else
		o_ce &amp;lt;= 1&#39;b0;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Before moving on, I tried to draw this basic pipeline schedule out in Fig 5
below for reference.  You should know, though, that whenever
I build an algorithm like this I usually just start by writing
the clock numbers in my code as we just did above.  I find these diagrams,
like Fig 5 below, are most useful to me when telling someone else about one
of my designs, such as I am doing now, then they are when I write them.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 5. Initial draft pipeline schedule&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/fir-slow-schedule-one.svg&quot; alt=&quot;&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;If you aren’t familiar with this sort of table, I use it to communicate
when variables are &lt;em&gt;valid&lt;/em&gt; within a design.  In this case, on the clock that
any new data is present, i.e.  &lt;a href=&quot;/blog/2017/08/14/strategies-for-pipelining.html&quot;&gt;the clock where &lt;code class=&quot;highlighter-rouge&quot;&gt;i_ce&lt;/code&gt; is
high&lt;/a&gt;,
the write
index for the data memory will also be valid.  These clock numbers are off by
one from the ones above, simply because variables set on one clock (as shown
in the code above) will be valid on the next clock–as shown in Fig 5.&lt;/p&gt;

&lt;p&gt;So, that’s generally what we wish to do.  To make this happen, though, let’s
add some
&lt;a href=&quot;/blog/2017/08/14/strategies-for-pipelining.html&quot;&gt;traveling valid flags&lt;/a&gt;
to this pipeline.  Specifically, we are going to want to know when to reset
the accumulator with a new product, and when to add other products into the
accumulator.  We’re also going to need to know when to set &lt;code class=&quot;highlighter-rouge&quot;&gt;o_ce&lt;/code&gt; and
&lt;code class=&quot;highlighter-rouge&quot;&gt;o_result.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;The first &lt;a href=&quot;/blog/2017/08/14/strategies-for-pipelining.html&quot;&gt;traveling valid
flag&lt;/a&gt;
we’ll call &lt;code class=&quot;highlighter-rouge&quot;&gt;pre_acc_ce&lt;/code&gt;–or the pre clock
enable for the accumulator.  We’ll use a shift register for this purpose.
Hence, on the first clock we’ll set &lt;code class=&quot;highlighter-rouge&quot;&gt;pre_acc_ce[0]&lt;/code&gt; to let us know that the
indices will be valid on the next clock.  On that next clock, we’ll set
&lt;code class=&quot;highlighter-rouge&quot;&gt;pre_acc_ce[1]&lt;/code&gt; to indicate that the memory reads are valid.  Finally, we’ll
set &lt;code class=&quot;highlighter-rouge&quot;&gt;pre_acc_ce[2]&lt;/code&gt; to indicate that the product is valid.  Further, we’ll
clear &lt;code class=&quot;highlighter-rouge&quot;&gt;pre_acc_ce[0]&lt;/code&gt; as soon as the last tap has been read.  This will then
be the indicator needed to know when to stop accumulating values.&lt;/p&gt;

&lt;p&gt;The only real trick in this logic chain is knowing when to shut &lt;code class=&quot;highlighter-rouge&quot;&gt;pre_acc_ce[0]&lt;/code&gt;
off.  In particular, it needs to be shut off once we have exhausted all of the
coefficients in the
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/slowfil.v&quot;&gt;filter&lt;/a&gt;.
We’ll come back to this in a moment, but for now
we are talking about a simple piece of scheduling logic such as,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	wire	last_tap_index;
	// ...
	reg	[2:0]	pre_acc_ce;
	initial	pre_acc_ce = 3&#39;h0;
	always @(posedge i_clk)
		if (i_reset)
			pre_acc_ce[0] &amp;lt;= 1&#39;b0;
		else if (i_ce)
			pre_acc_ce[0] &amp;lt;= 1&#39;b1;
		else if ((pre_acc_ce[0])&amp;amp;&amp;amp;(last_tap_index))
			pre_acc_ce[0] &amp;lt;= 1&#39;b1;
		else
			pre_acc_ce[0] &amp;lt;= 1&#39;b0;
	// ...

	always @(posedge i_clk)
		if (i_reset)
			pre_acc_ce[2:1] &amp;lt;= 2&#39;b0;
		else
			pre_acc_ce[2:1] &amp;lt;= pre_acc_ce[1:0];&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Once &lt;code class=&quot;highlighter-rouge&quot;&gt;i_ce&lt;/code&gt; is valid, the memory index will be valid on the next clock–so
we’ll set &lt;code class=&quot;highlighter-rouge&quot;&gt;pre_ce_acc[0]&lt;/code&gt; to true.  We’ll leave it true until we get to the
last tap index.  Likewise the values will flow through this structure just
like a shift register.&lt;/p&gt;

&lt;p&gt;But when shall we cut it off?  It needs to be cut off such that, when
the coefficient index, &lt;code class=&quot;highlighter-rouge&quot;&gt;tidx&lt;/code&gt;, is referencing the last coefficient,
&lt;code class=&quot;highlighter-rouge&quot;&gt;pre_acc_ce[0]&lt;/code&gt; will be false on the next clock.  Since our coefficient index
is counting from &lt;code class=&quot;highlighter-rouge&quot;&gt;0&lt;/code&gt; to &lt;code class=&quot;highlighter-rouge&quot;&gt;NTAPS-1&lt;/code&gt;, this can be expressed as,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	assign	last_tap_index = (NTAPS[LGNTAPS-1:0]-tidx &amp;lt;= 1);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The neat thing about this piece of logic, as you’ll see as we move forward,
is that it keeps the
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/slowfil.v&quot;&gt;filter&lt;/a&gt;
from outputting an invalid answer any time
too many clocks are given between &lt;code class=&quot;highlighter-rouge&quot;&gt;i_ce&lt;/code&gt; values.  Hence, if you have a
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/slowfil.v&quot;&gt;filter&lt;/a&gt;
with &lt;code class=&quot;highlighter-rouge&quot;&gt;NTAPS&lt;/code&gt; coefficients, yet there are more than &lt;code class=&quot;highlighter-rouge&quot;&gt;NTAPS&lt;/code&gt; clocks between
samples, then the accumulator will only pay attention to the first
&lt;code class=&quot;highlighter-rouge&quot;&gt;NTAPS&lt;/code&gt; products.&lt;/p&gt;

&lt;p&gt;This brings us to our next step: the block RAM read indices.  Upon any new
value, the
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/slowfil.v&quot;&gt;filter&lt;/a&gt;
starts accumulating from the product of coefficient zero
and the most recent data sample.  Coefficients then work forwards in their
array, while the data indexes work backwards–just like they did in the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Convolution&quot;&gt;convolution&lt;/a&gt;
formula we started with.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	initial	didx = 0;
	initial	tidx = 0;
	always @(posedge i_clk)
		if (i_ce)
		begin
			didx &amp;lt;= dwidx;
			tidx &amp;lt;= 0;
		end else begin
			didx &amp;lt;= didx - 1&#39;b1;
			tidx &amp;lt;= tidx + 1&#39;b1;
		end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Indeed, this logic is essentially identical to our last draft.&lt;/p&gt;

&lt;p&gt;We’ll also follow the clocks through the pipeline with a second
&lt;a href=&quot;/blog/2017/08/14/strategies-for-pipelining.html&quot;&gt;traveling CE&lt;/a&gt;
approach that will use a &lt;a href=&quot;/blog/2017/08/14/strategies-for-pipelining.html&quot;&gt;couple of other CE
signals&lt;/a&gt;.
The first of these, &lt;code class=&quot;highlighter-rouge&quot;&gt;m_ce&lt;/code&gt; is memory
index valid signal,
indicating that the first indices is valid.  As you follow through the code,
you’ll see other similar CE signals, such as the &lt;code class=&quot;highlighter-rouge&quot;&gt;d_ce&lt;/code&gt; signal to indicate
the first set of data and coefficient values are valid and &lt;code class=&quot;highlighter-rouge&quot;&gt;p_ce&lt;/code&gt; to indicate
the first product is valid.  We’ll use these in a moment to determine when to
load the accumulator vs adding a new value to it.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	// m_ce is valid when the first index is valid
	initial	m_ce = 1&#39;b0;
	always @(posedge i_clk)
		m_ce &amp;lt;= (i_ce)&amp;amp;&amp;amp;(!i_reset);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;On every clock cycle, we’ll read two values from block RAM–a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Impulse_response&quot;&gt;coefficient value&lt;/a&gt;
and a data value.  Note how the block RAM reading code below is explicitly
kept very simple.  This is to make certain that the tools recognize these as
reads from block RAM’s, rather than more complex logic such as one would need
to implement via a
&lt;a href=&quot;/blog/2017/06/12/minimizing-luts.html&quot;&gt;look-up-tables&lt;/a&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	initial	tap = 0;
	always @(posedge i_clk)
		tap &amp;lt;= tapmem[tidx[(LGNTAPS-1):0]];

	initial	data = 0;
	always @(posedge i_clk)
		data &amp;lt;= dmem[didx];&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Once read, we’ll set a data CE, or &lt;code class=&quot;highlighter-rouge&quot;&gt;d_ce&lt;/code&gt;, to indicate that the first data
value is now valid.  This will follow the first memory indices are valid
CE, &lt;code class=&quot;highlighter-rouge&quot;&gt;m_ce&lt;/code&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	initial	d_ce = 0;
	always @(posedge i_clk)
		d_ce &amp;lt;= (m_ce)&amp;amp;&amp;amp;(!i_reset);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;After all this work, we
can now calculate the product of &lt;code class=&quot;highlighter-rouge&quot;&gt;h[k]x[n-k]&lt;/code&gt;, herein referenced as just
&lt;code class=&quot;highlighter-rouge&quot;&gt;tap * data&lt;/code&gt;.  Another &lt;a href=&quot;/blog/2017/08/14/strategies-for-pipelining.html&quot;&gt;traveling CE
value&lt;/a&gt;,
this time &lt;code class=&quot;highlighter-rouge&quot;&gt;p_ce&lt;/code&gt;, denotes when this first product is valid.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	initial	p_ce = 1&#39;b0;
	always @(posedge i_clk)
		p_ce &amp;lt;= (d_ce)&amp;amp;&amp;amp;(!i_reset);

	initial	product = 0;
	always @(posedge i_clk)
		product &amp;lt;= tap * data;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Only now can we can finally get to the accumulator at the penultimate
stage of this chain.  On the first value given to it, that is
any time &lt;code class=&quot;highlighter-rouge&quot;&gt;p_ce&lt;/code&gt; is true–which will be true with the first product value,
&lt;code class=&quot;highlighter-rouge&quot;&gt;h[0]x[n]&lt;/code&gt;, the accumulator is set to the result of that first product.
Otherwise, any time a subsequent product is valid–as noted by
&lt;code class=&quot;highlighter-rouge&quot;&gt;pre_acc_ce[2]&lt;/code&gt; being high, the accumulator value is increased
by that clock’s &lt;code class=&quot;highlighter-rouge&quot;&gt;h[k]x[n-k]&lt;/code&gt; value.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	initial	r_acc = 0;
	always @(posedge i_clk)
		if (p_ce)
			r_acc &amp;lt;={ {(OW-(IW+TW)){product[(IW+TW-1)]}}, product };
		else if (pre_acc_ce[2])
			r_acc &amp;lt;= r_acc + { {(OW-(IW+TW)){product[(IW+TW-1)]}},
						product };&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This almost looks like the draft code we created to work out pipeline
scheduling.  The biggest difference is that we’ve done some sign extension
work above to make sure this works across multiple synthesis tools and
lint checkers.&lt;/p&gt;

&lt;p&gt;On the same clock we place a new value into the accumulator, we can also read
the last value out.  Hence we set &lt;code class=&quot;highlighter-rouge&quot;&gt;o_result&lt;/code&gt; to the output of the accumulator
on that same clock, and &lt;code class=&quot;highlighter-rouge&quot;&gt;o_ce&lt;/code&gt; to indicate this result is valid.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	initial	o_result = 0;
	always @(posedge i_clk)
		if (p_ce)
			o_result &amp;lt;= r_acc;

	initial	o_ce = 1&#39;b0;
	always @(posedge i_clk)
		o_ce &amp;lt;= (p_ce)&amp;amp;&amp;amp;(!i_reset);
endmodule&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Note that, as a consequence of this approach, &lt;code class=&quot;highlighter-rouge&quot;&gt;o_ce&lt;/code&gt; will always be true a
fixed number of clock ticks from &lt;code class=&quot;highlighter-rouge&quot;&gt;i_ce&lt;/code&gt;.  Hence, if the data stops coming, the
last accumulator value will not be read out.  Likewise, if the &lt;code class=&quot;highlighter-rouge&quot;&gt;i_ce&lt;/code&gt; values
come with fewer than &lt;code class=&quot;highlighter-rouge&quot;&gt;NTAPS&lt;/code&gt; steps between them, then the &lt;code class=&quot;highlighter-rouge&quot;&gt;o_ce&lt;/code&gt; values will
only report partial
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;
products.  There is no error detection or correction here–but you can feel
free to add it if you would like.&lt;/p&gt;

&lt;p&gt;Still, that’s what it takes to generate a
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/slowfil.v&quot;&gt;slow&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Finite_impulse_response&quot;&gt;FIR&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;
in Verilog for an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;.  Sadly,
though, the code is complex enough that we are going to lean heavily on our
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/bench/cpp/slowfil_tb.cpp&quot;&gt;test bench&lt;/a&gt;
code to know if it works or not.&lt;/p&gt;

&lt;h2 id=&quot;test-bench&quot;&gt;Test bench&lt;/h2&gt;

&lt;p&gt;When it comes time to building a
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/bench/cpp/slowfil_tb.cpp&quot;&gt;test bench&lt;/a&gt; for
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/slowfil.v&quot;&gt;this filter&lt;/a&gt;,
we’ve really already done most of the work in the &lt;a href=&quot;/dsp/2017/11/04/genfil-tb.html&quot;&gt;generic filtering
test harness&lt;/a&gt;
we built for the
&lt;a href=&quot;/dsp/2017/09/15/fastfir.html&quot;&gt;generic filter&lt;/a&gt;’s
&lt;a href=&quot;/dsp/2017/12/06/fastfir-tb.html&quot;&gt;test bench&lt;/a&gt;.
As a result, testing
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/slowfil.v&quot;&gt;this filter&lt;/a&gt;
only requires making a couple of small changes.  Indeed, if you run a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Diff_utility&quot;&gt;diff&lt;/a&gt;
between the original
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/bench/cpp/genericfir_tb.cpp&quot;&gt;test bench for a generic filter&lt;/a&gt;
and the
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/bench/cpp/slowfil_tb.cpp&quot;&gt;test bench&lt;/a&gt; for
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/slowfil.v&quot;&gt;this filter&lt;/a&gt;,
you’ll see the changes we are about to discuss below.  You might even be
surprised at how much code is in common between the two.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/slowfil.v&quot;&gt;This&lt;/a&gt;
will, however, be the first
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;
that will test the fixed number of clocks
per input clock enable, &lt;code class=&quot;highlighter-rouge&quot;&gt;i_ce&lt;/code&gt;  associated with the sample value.  As it
turns out, we did a good job
&lt;a href=&quot;/dsp/2017/11/04/genfil-tb.html&quot;&gt;building the initial&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/bench/cpp/filtertb.cpp&quot;&gt;test harness&lt;/a&gt;,
so there’s not much that needs to be changed there.&lt;/p&gt;

&lt;p&gt;Second, unlike the
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/bench/cpp/genfil_tb.cpp&quot;&gt;prior filter&lt;/a&gt;, resetting this one so that all the memory is
zero requires more work than just setting the reset flag.  In particular,
the way block RAM’s are built, they cannot be cleared in a single clock.
As a result, we’ll need to write a routine to explicitly write zero samples to
the filter’s internal memory so that any test vector generator can start
from a known state.&lt;/p&gt;

&lt;p&gt;With those two caveats aside, let’s start looking at the code.&lt;/p&gt;

&lt;p&gt;As with any code using our &lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/bench/cpp/filtertb.cpp&quot;&gt;basic filtering test
bench&lt;/a&gt;,
it starts out be declaring constants shared between the
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/bench/cpp/filtertb.cpp&quot;&gt;test bench code&lt;/a&gt;
and the
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/slowfil.v&quot;&gt;filter&lt;/a&gt;
itself.  These include the number of bits in the input, the
coefficients, the output, the number of coefficients, the delay between
input and the first output resulting from that input, and the number of
clocks per input sample.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt;	&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;IW&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;16&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;TW&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;16&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;OW&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;IW&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;TW&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;7&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;NTAPS&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;110&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;DELAY&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;CKPCE&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NTAPS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;These values are not only declared as constants at the beginning of the
test bench, but they are also used to when initializing our test bench
class.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt;	&lt;span class=&quot;nc&quot;&gt;SLOWFIL&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_TB&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;FILTERTB&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Vslowfil&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;bool&lt;/span&gt;		&lt;span class=&quot;n&quot;&gt;m_done&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

	&lt;span class=&quot;n&quot;&gt;SLOWFIL_TB&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;IW&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;IW&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;TW&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;TW&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;OW&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;OW&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;NTAPS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NTAPS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;DELAY&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;DELAY&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;CKPCE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CKPCE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This is just normal setup though.  Now we need to get into the actual
details of the test bench changes.&lt;/p&gt;

&lt;p&gt;The first change that needs to be made is to the &lt;code class=&quot;highlighter-rouge&quot;&gt;test()&lt;/code&gt; routine.  This
routine, as you &lt;a href=&quot;/dsp/2017/11/04/genfil-tb.html&quot;&gt;may
remember&lt;/a&gt;,
takes an input data stream, applies the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;,
and returns the result.  It also depends upon the filter having a zero
internal state.  Since clearing the state in this
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/bench/cpp/filtertb.cpp&quot;&gt;test bench&lt;/a&gt;
is a little more awkward, we’ll make certain to call a function to make
certain the state is cleared before calling the &lt;code class=&quot;highlighter-rouge&quot;&gt;test()&lt;/code&gt; function in the
&lt;a href=&quot;/dsp/2017/11/04/genfil-tb.html&quot;&gt;test harness&lt;/a&gt;
itself.  The neat part of this change, though, is that by
&lt;a href=&quot;https://en.wikipedia.org/wiki/Method_overriding&quot;&gt;overloading&lt;/a&gt;,
this &lt;code class=&quot;highlighter-rouge&quot;&gt;test()&lt;/code&gt; operator and using
&lt;a href=&quot;https://en.wikipedia.org/wiki/Inheritance_(object-oriented_programming)&quot;&gt;inheritance&lt;/a&gt;,
this change only requires the following four lines of code.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;	&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;	&lt;span class=&quot;nf&quot;&gt;test&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nlen&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;clear_filter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;FILTERTB&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Vslowfil&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;test&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nlen&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Unlike the
&lt;a href=&quot;/dsp/2017/12/06/fastfir-tb.html&quot;&gt;other filters&lt;/a&gt;
we’ve tested, this one requires a reset prior to loading any
new &lt;a href=&quot;https://en.wikipedia.org/wiki/Impulse_response&quot;&gt;coefficients&lt;/a&gt;.  As
you may recall from above, resetting
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/slowfil.v&quot;&gt;this filter&lt;/a&gt;
sets the index into the coefficient memory back to zero, so it is an
important part of loading a new set of
&lt;a href=&quot;https://en.wikipedia.org/wiki/Impulse_response&quot;&gt;coefficients&lt;/a&gt;.  Just a
slight modification to the
&lt;a href=&quot;/dsp/2017/11/04/genfil-tb.html&quot;&gt;test bench&lt;/a&gt;,
and this change has now been made as well.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;	&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;	&lt;span class=&quot;nf&quot;&gt;load&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nlen&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;reset&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;FILTERTB&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Vslowfil&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;load&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nlen&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Perhaps the most important change, though, is the function that we need to
write to clear the data memory within
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/slowfil.v&quot;&gt;this filter&lt;/a&gt;.
We’ll call this function &lt;code class=&quot;highlighter-rouge&quot;&gt;clear_filter()&lt;/code&gt;.  It will work by
providing one clock with &lt;code class=&quot;highlighter-rouge&quot;&gt;i_ce&lt;/code&gt; high and &lt;code class=&quot;highlighter-rouge&quot;&gt;i_sample&lt;/code&gt; set to zero per element
in the memory array.  Since the array will always be a length given by a power
of two, the internal memory may also be longer than the number of
taps, &lt;code class=&quot;highlighter-rouge&quot;&gt;NTAPS()&lt;/code&gt; in
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/slowfil.v&quot;&gt;this filter&lt;/a&gt;.
For this reason, we’ll round up to the next power of two using &lt;code class=&quot;highlighter-rouge&quot;&gt;nextlg()&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;What may surprise you, though, is that we are going to hit
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/slowfil.v&quot;&gt;this filter&lt;/a&gt;
with one new sample per clock, while ignoring the output.  The result of this
will be that the output of this run will be invalid, although the new data will
loaded into he memory as desired.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;	&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;	&lt;span class=&quot;nf&quot;&gt;clear_filter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;m_core&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i_tap_wr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

		&lt;span class=&quot;c1&quot;&gt;// ..
&lt;/span&gt;		&lt;span class=&quot;n&quot;&gt;m_core&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i_ce&lt;/span&gt;     &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;m_core&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i_sample&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nextlg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NTAPS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;());&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;tick&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;As one final step, once the memory has been loaded, we’ll let the last sample
propagate through
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/slowfil.v&quot;&gt;the filter&lt;/a&gt;,
so as to make certain
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/slowfil.v&quot;&gt;the filter&lt;/a&gt;
is in a usable state when we apply our test vectors.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;		&lt;span class=&quot;n&quot;&gt;m_core&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i_ce&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CKPCE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;tick&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;At this point, all we need to do is switch our main program to running the
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/bench/cpp/slowfil_tb.cpp&quot;&gt;test bench&lt;/a&gt;
created for this new code, and everything is roughly the same as before.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;n&quot;&gt;SLOWFIL_TB&lt;/span&gt;	&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tb&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;	&lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;argc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;**&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;argv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;Verilated&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;commandArgs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;argc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;argv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;tb&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SLOWFIL_TB&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;How’s that for fairly simple?  Indeed, implementing the
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/slowfil.v&quot;&gt;filter itself&lt;/a&gt;
was harder than this
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/bench/cpp/slowfil_tb.cpp&quot;&gt;test bench&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Of course, it’s only that simple because of the work we’ve already done,
but that just underscores the power of
&lt;a href=&quot;https://en.wikipedia.org/wiki/Object-oriented_programming&quot;&gt;Object Oriented Programming (OOP)&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;example-traces&quot;&gt;Example Traces&lt;/h2&gt;

&lt;p&gt;If you’d like to see a trace of how this all works, there’s a commented line
in the
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/bench/cpp/slowfil_tb.cpp&quot;&gt;test bench&lt;/a&gt;,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;	&lt;span class=&quot;o&quot;&gt;//&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tb&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;opentrace&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;trace.vcd&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;which, if uncommented, will create a
&lt;a href=&quot;/blog/2017/07/31/vcd.html&quot;&gt;VCD file&lt;/a&gt;
containing a trace of what
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/slowfil.v&quot;&gt;this filter&lt;/a&gt;
does in response to the
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/bench/cpp/slowfil_tb.cpp&quot;&gt;test bench&lt;/a&gt;’s
stimulus.  Be careful–the trace can quickly
become hundreds of megabytes, if not several gigabytes, in length.&lt;/p&gt;

&lt;p&gt;Still, let’s turn that on to see if we can get a feel for how
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/slowfil.v&quot;&gt;this filter&lt;/a&gt;
works.  We’ll stop the
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/bench/cpp/slowfil_tb.cpp&quot;&gt;test bench&lt;/a&gt;
after the
&lt;a href=&quot;/blog/2017/07/31/vcd.html&quot;&gt;trace file&lt;/a&gt;
gets to about 28MB–which is still more than we need for this demo.  We
can then use
&lt;a href=&quot;https://gtkwave.sourceforge.net&quot;&gt;GTKwave&lt;/a&gt;
to display the results.  You can see a screen capture of the result
in Fig 6 below.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 6. Trace of the First Impulse Test&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/fir-slowfil-trace.png&quot; alt=&quot;&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;The figure shows several key steps in the
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/bench/cpp/slowfil_tb.cpp&quot;&gt;test bench&lt;/a&gt;.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;First, at the far left, &lt;code class=&quot;highlighter-rouge&quot;&gt;i_tap_wr&lt;/code&gt; is high for many clocks as the
coefficients (&lt;code class=&quot;highlighter-rouge&quot;&gt;i_tap&lt;/code&gt;) are loaded into the
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/slowfil.v&quot;&gt;filter&lt;/a&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The &lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/slowfil.v&quot;&gt;filter&lt;/a&gt;
is then &lt;em&gt;cleared&lt;/em&gt; by writing a series of (roughly) &lt;code class=&quot;highlighter-rouge&quot;&gt;NTAPS()&lt;/code&gt;
zeros into the memory.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The &lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/bench/cpp/slowfil_tb.cpp&quot;&gt;test bench&lt;/a&gt;
then applies an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Kronecker_delta&quot;&gt;impulse&lt;/a&gt; to the
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/slowfil.v&quot;&gt;filter&lt;/a&gt;,
to verify the &lt;a href=&quot;https://en.wikipedia.org/wiki/Impulse_response&quot;&gt;response&lt;/a&gt;.
Both &lt;a href=&quot;https://en.wikipedia.org/wiki/Kronecker_delta&quot;&gt;impulse&lt;/a&gt;
and coefficient value are negative maximums, to see if the
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/slowfil.v&quot;&gt;filter&lt;/a&gt;
will overflow as a result.  What that means, though, is that the
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/slowfil.v&quot;&gt;filter&lt;/a&gt;’s
output given these coefficients and this input will be a
single positive
&lt;a href=&quot;https://en.wikipedia.org/wiki/Kronecker_delta&quot;&gt;impulse&lt;/a&gt;,
as shown in the figure above.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Suppose we zoomed in some more on how
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/slowfil.v&quot;&gt;this filter&lt;/a&gt;
operated?  In this case, see Fig 7 below.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 7. Zooming in on the first test vector&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/fir-slowfil-trace-zoom.png&quot; alt=&quot;&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;At this zoom level, you can see how the various &lt;code class=&quot;highlighter-rouge&quot;&gt;CE&lt;/code&gt;s (really misnamed
valid signals) make their way through the system until the final &lt;code class=&quot;highlighter-rouge&quot;&gt;o_ce&lt;/code&gt; and
&lt;code class=&quot;highlighter-rouge&quot;&gt;o_result&lt;/code&gt; are valid.  You can also see the &lt;code class=&quot;highlighter-rouge&quot;&gt;pre_acc_ce[2:0]&lt;/code&gt; shift register
note when the tap index and data index became valid, &lt;code class=&quot;highlighter-rouge&quot;&gt;m_ce&lt;/code&gt;, when the memory
reads were valid, &lt;code class=&quot;highlighter-rouge&quot;&gt;d_ce&lt;/code&gt;, and when the products became valid, &lt;code class=&quot;highlighter-rouge&quot;&gt;p_ce&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The point here is, even if you are struggling to understand the code itself
above, sometimes a trace becomes easier to make sense of.&lt;/p&gt;

&lt;h2 id=&quot;conclusions&quot;&gt;Conclusions&lt;/h2&gt;

&lt;p&gt;This filtering approach is really quite powerful.  Not only were we able
to reduce the number of multiplies required in order to implement
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/slowfil.v&quot;&gt;this filter&lt;/a&gt;,
but we were also able to prove it using little more than the &lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/bench/cpp/filtertb.cpp&quot;&gt;test harness
code&lt;/a&gt;
we’ve already built.&lt;/p&gt;

&lt;p&gt;Remember the discussion we started out with regarding a 2047 tap
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;?
Such a &lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;
would be sufficient to generate a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Low-pass_filter&quot;&gt;lowpass&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;
with a 480Hz
&lt;a href=&quot;https://en.wikipedia.org/wiki/Passband&quot;&gt;passband&lt;/a&gt;,
a 176Hz transition band, and a 70dB stop band.  That’s probably
good enough for any audio work you might wish to do.&lt;/p&gt;

&lt;p&gt;That doesn’t mean
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/slowfil.v&quot;&gt;this&lt;/a&gt;
is the best (or worst)
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;
out there, just one to place into your tool box.  It has a purpose, and it
works well in its own niche.&lt;/p&gt;

&lt;p&gt;What other approaches might we have tried?&lt;/p&gt;

&lt;p&gt;I’ve mentioned for some time that I’d like to build and demonstrate a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Linear_phase&quot;&gt;symmetrical filter&lt;/a&gt;.
At high speed, that filter is now built and just waiting
for a good blog post.  Similarly, a fun challenge might be to modify
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/slowfil.v&quot;&gt;this filter&lt;/a&gt;
to handle
&lt;a href=&quot;https://en.wikipedia.org/wiki/Linear_phase&quot;&gt;symmetric coefficients&lt;/a&gt;,
something that would allow it to run twice as many coefficients at once.&lt;/p&gt;

&lt;p&gt;Another future
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;
that will be fun to present is what I’m going to call
a cascaded
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;.
By cascaded
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;, I mean one that
is basically identical to
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/slowfil.v&quot;&gt;this filter&lt;/a&gt;,
except that it allows multiple
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;s
of this type to be cascaded together in order to effectively create a &lt;em&gt;much&lt;/em&gt;
longer &lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;.
In many ways, this may seem like the holy grail of generic
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;
implementation–a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;
that can be adjusted to use only as many hardware multiplies
as it is required to use given the incoming data rate.&lt;/p&gt;

&lt;p&gt;Perhaps the ultimate
&lt;a href=&quot;https://en.wikipedia.org/wiki/Low-pass_filter&quot;&gt;lowpass&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;,
however, is the multirate implementation of a 
&lt;a href=&quot;https://en.wikipedia.org/wiki/Low-pass_filter&quot;&gt;lowpass&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;.
Using multirate techniques, it should be possible to apply a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Low-pass_filter&quot;&gt;lowpass&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt; of
any bandwidth to full speed data for a cost of only 10-12 multiplies.&lt;/p&gt;

&lt;p&gt;But these are all topics for another day.&lt;/p&gt;
&lt;hr /&gt;&lt;p&gt;&lt;em&gt;Then took Mary a pound of ointment of spikenard, very costly, and anointed the feet of Jesus, and wiped his feet with her hair: and the house was filled with the odour of the ointment. (John 12:3)&lt;/em&gt;</description>
        <pubDate>Sat, 30 Dec 2017 00:00:00 -0500</pubDate>
        <link>http://zipcpu.com/dsp/2017/12/30/slowfil.html</link>
        <guid isPermaLink="true">http://zipcpu.com/dsp/2017/12/30/slowfil.html</guid>
        
        
        <category>dsp</category>
        
      </item>
    
      <item>
        <title>Mystery post: The ugliest bug I&#39;ve ever encountered</title>
        <description>&lt;p&gt;I’ve been working with software most of my life–since long before I ever
went to &lt;a href=&quot;https://wp.stolaf.edu&quot;&gt;college&lt;/a&gt;.  Now, after several decades of
working with software, I’d like to think I may have learned something about
fixing bugs in software.&lt;/p&gt;

&lt;p&gt;I’ve learned to debug bugs by their patterns, and the more often I see the
same error lead to the same bug the more these patters are enforced in my mind.
Hence, any time the symptoms of a bug match a pattern I’ve seen before, I know
exactly where to look for the bug.  When younger programmers ask me why
their code isn’t working, I just match what’s going on to a pattern I’ve seen
in the past, and I can usually find any problem they might have quite quickly.&lt;/p&gt;

&lt;p&gt;I’ve got to believe I’m not alone in this approach, and that others have also
used this approach to debugging software as well.&lt;/p&gt;

&lt;p&gt;While this approach has served me well over time, there was one bug I
encountered recently that didn’t match &lt;em&gt;any&lt;/em&gt; of the patterns I’ve learned over
my many decades.&lt;/p&gt;

&lt;h2 id=&quot;the-symptoms&quot;&gt;The Symptoms&lt;/h2&gt;

&lt;p&gt;Are you ready to see if you can recognize this bug?  Think you can do it?
Here’s what I was looking at.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 1. Writing past the end of memory&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/past-end-of-memory.svg&quot; alt=&quot;&quot; width=&quot;320&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;The code crashed with a
  &lt;em&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_error&quot;&gt;bus error&lt;/a&gt;&lt;/em&gt;,
created by trying to access a non-existent memory address using the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Stack_register&quot;&gt;stack pointer&lt;/a&gt;.&lt;/p&gt;

    &lt;p&gt;This isn’t the first time I’ve ever had a computer program do the wrong
thing.  As a result, I design my
&lt;a href=&quot;/blog/2017/06/22/simple-wb-interconnect.html&quot;&gt;wishbone interconnects&lt;/a&gt;
to both return an &lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_error&quot;&gt;error&lt;/a&gt;
upon any attempt to read from a non-existent address, as well as to
record the address created the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_error&quot;&gt;error&lt;/a&gt;.
For this reason, I knew the address the
&lt;a href=&quot;/blog/2017/06/22/simple-wb-interconnect.html&quot;&gt;interconnect&lt;/a&gt;
was seeing–and it was indeed beyond the end of memory.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;If you looked through and followed the code, there should never have been a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_error&quot;&gt;bus error&lt;/a&gt;.
&lt;a href=&quot;http://www.gcc.org&quot;&gt;GCC&lt;/a&gt; had put the proper logic into the
code to calculate the correct address.  For some reason, the correct
address wasn’t getting calculated.  Indeed, if you examined the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt; state following the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_error&quot;&gt;bus error&lt;/a&gt;, the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Stack_register&quot;&gt;stack pointer&lt;/a&gt; wasn’t
pointing to the right value.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;If I used the
&lt;a href=&quot;/zipcpu/2017/08/25/hw-debugging.html&quot;&gt;debugger&lt;/a&gt;
to step through the code, there would be no error.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Any attempt to add a debugging statement prior to the bug would keep the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt; from getting a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_error&quot;&gt;bus error&lt;/a&gt; at that instruction.&lt;/p&gt;

    &lt;p&gt;This includes both the &lt;code class=&quot;highlighter-rouge&quot;&gt;BREAK&lt;/code&gt; instruction as well any instructions which
might have been used to trigger the
&lt;a href=&quot;https://github.com/ZipCPU/wbscope&quot;&gt;wishbone scope&lt;/a&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;In my frustration at one point while I was trying to figure out what the
problem was, I decided to try Voodoo computing.&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;Defn: Voodoo computing, verb: The process of fixing what isn’t broken in 
an attempt to fix what is.  It is similar to &lt;a href=&quot;https://en.wikipedia.org/wiki/Cargo_cult&quot;&gt;Cargo
Cult&lt;/a&gt; programming.&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;p&gt;So I restarted the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; from
the beginning of the program.  (This was a warm reboot, not a cold one from
no power.)  On this second program start, the code executed as designed and
the program failed elsewhere.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Confused yet?  I certainly was.  Let me show you what the code looked like.&lt;/p&gt;

&lt;h2 id=&quot;the-software-in-question&quot;&gt;The Software in Question&lt;/h2&gt;

&lt;p&gt;The code that failed was the very first function call following a reboot.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 2. Initial stack pointer&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/initial-stack-pointer.svg&quot; alt=&quot;&quot; width=&quot;240&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;The &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; would start
at the reset address and it would load the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Stack_register&quot;&gt;stack pointer&lt;/a&gt;
with a reference to the end of memory.  While both of these are configurable
addresses within the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; infrastructure, inspecting
the code confirmed that the &lt;a href=&quot;http://www.gnu.org/software/binutils/&quot;&gt;assembler and
linker&lt;/a&gt; had done their jobs correctly.
After a couple of other instructions upon
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt; startup, the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt; would then jump to this
&lt;code class=&quot;highlighter-rouge&quot;&gt;first_subroutine&lt;/code&gt; and quickly fail.&lt;/p&gt;

&lt;p&gt;Here’s what those first few instructions looked like,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-assembly&quot; data-lang=&quot;assembly&quot;&gt;reset_address:
	; Load the stack pointer with the address of the very last location
	; in memory.  (LDI = load immediate, SP = stack pointer)
	LDI	#end_of_memory,SP
	; ... some other setup lines
	JSR	first_subroutine
	; ... code continues&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The &lt;code class=&quot;highlighter-rouge&quot;&gt;LDI&lt;/code&gt; instruction within the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
can load an arbitrary value into any register over the course of up to two
instructions.  Specifically, it takes one instruction for anything up to
23-bits, and two instructions for anything longer.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 3. The first Stack Frame&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/initial-stack-frame.svg&quot; alt=&quot;&quot; width=&quot;240&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;The program then jumped to a subroutine.  This involves copying the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Program_counter&quot;&gt;program counter&lt;/a&gt;,
&lt;code class=&quot;highlighter-rouge&quot;&gt;PC&lt;/code&gt;, into the &lt;code class=&quot;highlighter-rouge&quot;&gt;R0&lt;/code&gt; general purpose register, and then jumping to the address
given–in this case the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt;
jumped to &lt;code class=&quot;highlighter-rouge&quot;&gt;first_subroutine&lt;/code&gt;.  (I’ve since forgotten the subroutine’s actual
name.)&lt;/p&gt;

&lt;p&gt;The first several instructions in the &lt;code class=&quot;highlighter-rouge&quot;&gt;first_subroutine&lt;/code&gt; were much like any
other subroutine.  They created a stack frame by subtracting a value from the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Stack_register&quot;&gt;stack pointer&lt;/a&gt;–adjusting
it to point earlier in memory.  This creates an area in memory where the
program can hold local variables, commonly called
a &lt;a href=&quot;https://en.wikipedia.org/wiki/Call_stack&quot;&gt;stack frame&lt;/a&gt;.  The program
then attempted to save some registers to this new
&lt;a href=&quot;https://en.wikipedia.org/wiki/Call_stack&quot;&gt;stack frame&lt;/a&gt;.
In assembly, this looked like,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;first_subroutine:
	SUB	16,SP	; Create a stack fromm, subtracting 16 from SP
	SW	R0,(SP)	; Store R0 into the first position in the stack frame
	SW	R1,4(SP); BUS ERROR HERE!!!!&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;If you’ve never seen
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
assembly before, it reads from left to right, with the destination of the
instruction on the right.  Hence &lt;code class=&quot;highlighter-rouge&quot;&gt;SUB 16,SP&lt;/code&gt; subtracts sixteen from the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Stack_register&quot;&gt;stack pointer&lt;/a&gt;
and places the result back into the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Stack_register&quot;&gt;stack pointer&lt;/a&gt;.
Likewise &lt;code class=&quot;highlighter-rouge&quot;&gt;SW R0,(SP)&lt;/code&gt; stores the value of &lt;code class=&quot;highlighter-rouge&quot;&gt;R0&lt;/code&gt; into the address given by the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Stack_register&quot;&gt;stack pointer&lt;/a&gt;,
and &lt;code class=&quot;highlighter-rouge&quot;&gt;SW R1,4(SP)&lt;/code&gt; does roughly the same thing, with the
exception that &lt;code class=&quot;highlighter-rouge&quot;&gt;R1&lt;/code&gt; is saved into the location four bytes later.  Of these
three instructions, only the &lt;code class=&quot;highlighter-rouge&quot;&gt;SUB&lt;/code&gt;tract instruction modifies the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Stack_register&quot;&gt;stack pointer&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;If I pulled the code up in a
&lt;a href=&quot;/zipcpu/2017/08/25/hw-debugging.html&quot;&gt;debugger&lt;/a&gt; following
this &lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_error&quot;&gt;bus error&lt;/a&gt;,
the &lt;a href=&quot;https://en.wikipedia.org/wiki/Stack_register&quot;&gt;stack pointer&lt;/a&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;SP&lt;/code&gt;
would have the value given by the &lt;code class=&quot;highlighter-rouge&quot;&gt;end_of_memory&lt;/code&gt; value it was initially
loaded with.  It was as though the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Call_stack&quot;&gt;stack frame&lt;/a&gt;
was never created, despite the &lt;code class=&quot;highlighter-rouge&quot;&gt;SUB 16,SP&lt;/code&gt; instruction.&lt;/p&gt;

&lt;p&gt;When the 
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; then tried to write into this
&lt;a href=&quot;https://en.wikipedia.org/wiki/Call_stack&quot;&gt;stack frame&lt;/a&gt;,
it would write past the end of memory.
Depending on whether &lt;code class=&quot;highlighter-rouge&quot;&gt;end_of_memory&lt;/code&gt; pointed to the last address
in memory (where I commonly set it), or just past the end of memory would
then determine whether storing &lt;code class=&quot;highlighter-rouge&quot;&gt;R0&lt;/code&gt; to the location in the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Stack_register&quot;&gt;stack pointer&lt;/a&gt;
caused the &lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_error&quot;&gt;bus error&lt;/a&gt;
or whether it was storing &lt;code class=&quot;highlighter-rouge&quot;&gt;R1&lt;/code&gt; to the location 4 bytes later
that caused the &lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_error&quot;&gt;bus error&lt;/a&gt;.
Either way, the code caused a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_error&quot;&gt;bus error&lt;/a&gt;
and none of it made any sense to me.&lt;/p&gt;

&lt;p&gt;Before reading any further, think about the description above, and then ask
yourself: does this match any bug pattern you’ve ever seen before?  The program
fails the first time it is tried, but not the second–but then it would fail
on the third time.  Any attempt to add debugging code kept this error from
happening.&lt;/p&gt;

&lt;p&gt;Oh, and let me give you a hint: I was running my own code, on my own
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;, within an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Any ideas?&lt;/p&gt;

&lt;h2 id=&quot;what-was-it&quot;&gt;What was it?&lt;/h2&gt;

&lt;p&gt;In many ways, I was at a loss to figure out the problem until I started
up the program in a &lt;a href=&quot;https://www.veripool.org/wiki/verilator&quot;&gt;Verilator&lt;/a&gt;
&lt;a href=&quot;/blog/2017/06/21/looking-at-verilator.html&quot;&gt;based&lt;/a&gt;
&lt;a href=&quot;/zipcpu/2017/07/26/cpu-sim-debugger.html&quot;&gt;simulation&lt;/a&gt;.
(Yes, I know, I was running code that I hadn’t &lt;a href=&quot;/blog/2017/06/23/my-dbg-philosophy.html&quot;&gt;simulated first&lt;/a&gt;–&lt;a href=&quot;/blog/2017/06/02/design-process.html&quot;&gt;shame
on me&lt;/a&gt;.)  Once
I saw the bug take place within the
&lt;a href=&quot;/zipcpu/2017/07/26/cpu-sim-debugger.html&quot;&gt;simulator&lt;/a&gt;,
I knew I could find it quickly.&lt;/p&gt;

&lt;p&gt;As it turned out, the problem lied in the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/pfcache.v&quot;&gt;prefetch and instruction cache
module&lt;/a&gt;.  This
module was declaring that an
&lt;a href=&quot;/zipcpu/2017/11/18/wb-prefetch.html&quot;&gt;instruction was valid&lt;/a&gt;
one clock cycle before the cache logic had finished writing that instruction
into the cache.  In this case, there was often a &lt;code class=&quot;highlighter-rouge&quot;&gt;NOOP&lt;/code&gt; in the cache
instead of the &lt;code class=&quot;highlighter-rouge&quot;&gt;SUB 16,SP&lt;/code&gt; instruction.  Hence, when the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt; was erroneously given the
&lt;code class=&quot;highlighter-rouge&quot;&gt;NOOP&lt;/code&gt; instruction, the &lt;a href=&quot;https://en.wikipedia.org/wiki/Stack_register&quot;&gt;stack
pointer&lt;/a&gt;,
&lt;code class=&quot;highlighter-rouge&quot;&gt;SP&lt;/code&gt;, remained where it was–pointing to the end of memory.  The subsequent
&lt;code class=&quot;highlighter-rouge&quot;&gt;SW&lt;/code&gt; (store word) instruction then wrote past the end of memory, which then
triggered the &lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_error&quot;&gt;bus error&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;I’ve tried to draw this in Fig 4 below.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 4. Reading from the cache one clock too early&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/ugliest-bug.svg&quot; alt=&quot;&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;The figure shows a single
&lt;a href=&quot;https://en.wikipedia.org/wiki/CPU_cache#CACHE-LINES&quot;&gt;cache line&lt;/a&gt;.  The
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/pfcache.v&quot;&gt;prefetch/i-cache&lt;/a&gt;
module was filling that cache line with valid instructions.  It had filled
all but the last instruction, when it then declared the instruction was
valid.  Then, as it filled that last instruction with &lt;code class=&quot;highlighter-rouge&quot;&gt;SUB 16,SP&lt;/code&gt;, the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt;
read the &lt;code class=&quot;highlighter-rouge&quot;&gt;NOOP&lt;/code&gt; instruction that had been there one clock earlier, hence
leading to the bug.&lt;/p&gt;

&lt;p&gt;Had the subroutine’s first instruction landed anywhere else in the cache line,
being one clock early wouldn’t have mattered–since those locations would’ve
already been filled by the cache logic at that point.  This particular location
in the cache line made this appear to be one of those “phantom” bugs–bugs
that manifest at some times but not at others.  It also made it harder to
discover–as discussed above.&lt;/p&gt;

&lt;p&gt;So let’s go back through those symptoms and explain what happened, shall we?&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;We just explained why the 
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_error&quot;&gt;bus error&lt;/a&gt; took place–the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Stack_register&quot;&gt;stack pointer&lt;/a&gt; never
got updated, and so the program tried to write off the end of memory.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Although the &lt;code class=&quot;highlighter-rouge&quot;&gt;SUB 16,SP&lt;/code&gt; instruction was present in the code, the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/pfcache.v&quot;&gt;prefetch&lt;/a&gt;
returned a no operation instruction (&lt;code class=&quot;highlighter-rouge&quot;&gt;NOOP&lt;/code&gt;) to the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt;,
so this subtract was never executed–leaving the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Stack_register&quot;&gt;stack pointer&lt;/a&gt; pointing
to the end of memory.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The &lt;a href=&quot;/zipcpu/2017/08/25/hw-debugging.html&quot;&gt;debugger&lt;/a&gt; never
had a problem because it it operated at a much slower speed than the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt; was capable of operating.  This
gave the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt; in single stepping
mode enough time to load the cache before trying to read from the last
address in the
&lt;a href=&quot;https://en.wikipedia.org/wiki/CPU_cache#CACHE-LINES&quot;&gt;cache line&lt;/a&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;If I placed another instruction anywhere before the subtract in the
program’s instruction stream, then the &lt;code class=&quot;highlighter-rouge&quot;&gt;SUB 16,SP&lt;/code&gt; instruction would no
longer be the last element in a
&lt;a href=&quot;https://en.wikipedia.org/wiki/CPU_cache#CACHE-LINES&quot;&gt;cache line&lt;/a&gt;,
and there wouldn’t be any timing error.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;If I restarted the computer after this failure, the &lt;code class=&quot;highlighter-rouge&quot;&gt;SUB 16,SP&lt;/code&gt; instruction
would already be in the cache.  Hence, when the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/pfcache.v&quot;&gt;prefetch&lt;/a&gt;
declared the instruction to be valid one clock too early, it would still
read what was in the cache from the last time, i.e. the &lt;code class=&quot;highlighter-rouge&quot;&gt;SUB 16,SP&lt;/code&gt;
instruction.&lt;/p&gt;

    &lt;p&gt;That the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt; then failed somewhere
else should come as no surprise, when there is a bug of this type within
its code.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;This bug was so strange, and so different, that I though it would be fun to
share here.  I hope you enjoyed it.&lt;/p&gt;

&lt;h2 id=&quot;lessons-learned&quot;&gt;Lessons Learned&lt;/h2&gt;

&lt;p&gt;So what are some of the lessons I learned from this bug?&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;I learned the value of the
&lt;a href=&quot;/zipcpu/2017/07/26/cpu-sim-debugger.html&quot;&gt;simulator&lt;/a&gt;.
&lt;a href=&quot;/blog/2017/07/08/getting-started-with-wbscope.html&quot;&gt;Traces&lt;/a&gt;
taken using the
&lt;a href=&quot;https://github.com/ZipCPU/wbscope&quot;&gt;wishbone scope&lt;/a&gt;
just didn’t have enough information within them to permit me to recognize
the bug quickly.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;I (re)learned the fact that &lt;a href=&quot;/blog/2017/10/19/formal-intro.html&quot;&gt;not all test benches will
catch all bugs&lt;/a&gt;..
This bug was not caught by my &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/sim/verilator/pfcache_tb.cpp&quot;&gt;prefetch testbench&lt;/a&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;I learned to place several cache testing pieces of code into my
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt; &lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/sw/board/cputest.c&quot;&gt;testing
program&lt;/a&gt;.
As a result, were this bug ever to show again, I’d detect it early on.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Even after all of this, I never quite trusted my &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/pfcache.v&quot;&gt;prefetch and cache
code&lt;/a&gt;
until some time later when I formally proved that it worked.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Perhaps you’d like to see that formal proof?  I’d love to share it!  However,
that will have to wait for another day and another post.&lt;/p&gt;
&lt;hr /&gt;&lt;p&gt;&lt;em&gt;Be thou diligent to know the state of thy flocks, and look well to thy herds.  (Prov 27:23)&lt;/em&gt;</description>
        <pubDate>Thu, 28 Dec 2017 00:00:00 -0500</pubDate>
        <link>http://zipcpu.com/zipcpu/2017/12/28/ugliest-bug.html</link>
        <guid isPermaLink="true">http://zipcpu.com/zipcpu/2017/12/28/ugliest-bug.html</guid>
        
        
        <category>zipcpu</category>
        
      </item>
    
      <item>
        <title>Arrow&#39;s Max-1000: A gem for all the wrong reasons</title>
        <description>&lt;p&gt;I’ll have to admit, I can be jealous of the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;
world.  When I consider the fact that I can purchase a
&lt;a href=&quot;https://www.pjrc.com/store/teensylc.html&quot;&gt;Teensy LC&lt;/a&gt; board with an
&lt;a href=&quot;https://en.wikipedia.org/wiki/ARM_architecture&quot;&gt;ARM Cortex-M0+&lt;/a&gt;
processor running at 48MHz, 62K of flash and 8K of RAM for
&lt;a href=&quot;https://www.pjrc.com/store/teensylc.html&quot;&gt;for only $12&lt;/a&gt;
from my &lt;a href=&quot;http://www.microcenter.com/product/449970/Teensy_LC_-_Low_Cost&quot;&gt;local hardware convenience
store&lt;/a&gt;,
it makes me wonder at times why I am working in an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
world where the cheapest
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
designs sell for &lt;a href=&quot;http://store.digilentinc.com/cmod-a7-breadboardable-artix-7-fpga-module/&quot;&gt;around
$75&lt;/a&gt;
or so.  Ok, so the &lt;a href=&quot;https://hackaday.io/project/12930-blackice-low-cost-open-hardware-fpga-dev-board&quot;&gt;Black ICE&lt;/a&gt;
board is a touch cheaper at $50, but this is still a far cry from the
&lt;a href=&quot;https://www.pjrc.com/store/teensylc.html&quot;&gt;$12 Teensy&lt;/a&gt;.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 1. The Max 1000&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/max1k-picture.png&quot; alt=&quot;&quot; width=&quot;320&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;Well, now there’s a new player in the ultra low-cost market.  You can now
purchase an &lt;a href=&quot;https://www.arrow.com/en/products/max1000/arrow-development-tools&quot;&gt;Arrow FPGA IoT Maker Board, the
MAX1000&lt;/a&gt;
for just $30.&lt;/p&gt;

&lt;p&gt;As I was recently asked to do some work with the
&lt;a href=&quot;https://www.arrow.com/en/products/max1000/arrow-development-tools&quot;&gt;MAX1000&lt;/a&gt;,
I thought I might share some of my first experiences and impressions with you
here.&lt;/p&gt;

&lt;p&gt;Before I get started though, you should know that I am not getting paid by
either &lt;a href=&quot;https://www.arrow.com&quot;&gt;Arrow&lt;/a&gt; or
&lt;a href=&quot;https://www.trenz-electronic.de&quot;&gt;Trenz&lt;/a&gt; to write this review.
Neither am I getting paid by &lt;a href=&quot;https://www.digilentinc.com&quot;&gt;Digilent&lt;/a&gt; for that
matter.  Rather, I’ve been asked to demonstrate that
&lt;a href=&quot;http://www.clifford.at/yosys&quot;&gt;yosys&lt;/a&gt; can be used to build a design on an
&lt;a href=&quot;httpss://www.altera.com&quot;&gt;Intel (Altera)&lt;/a&gt; platform—something I’m still
working on.&lt;/p&gt;

&lt;h2 id=&quot;the-good&quot;&gt;The Good&lt;/h2&gt;

&lt;p&gt;If you are looking for a low-priced
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
board to get started with, the
&lt;a href=&quot;https://www.arrow.com/en/products/max1000/arrow-development-tools&quot;&gt;MAX1000&lt;/a&gt;
&lt;em&gt;should&lt;/em&gt; fit the bill nicely.  Indeed, it has just about all of the basic
components within it that you should need to do
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt; work.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 2. Max 1000 peripherals&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/max-1000.svg&quot; alt=&quot;&quot; width=&quot;480&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;It has an
&lt;a href=&quot;https://www.winbond.com/resource-files/w74m64fv%20revb.pdf&quot;&gt;8MB flash&lt;/a&gt;
and, unlike the &lt;a href=&quot;https://store.digilentinc.com/cmod-s6-breadboardable-spartan-6-fpga-module&quot;&gt;CMod
S6&lt;/a&gt;
I worked with before, the
&lt;a href=&quot;https://www.arrow.com/en/products/max1000/arrow-development-tools&quot;&gt;MAX1000&lt;/a&gt;
actually has some decent RAM to work with – an
&lt;a href=&quot;https://www.winbond.com/resource-files/w9864g6jt_a03_20170331.pdf&quot;&gt;8MB SDRAM&lt;/a&gt;.
These two items are the basics you will need for any
&lt;a href=&quot;https://en.wikipedia.org/wiki/Soft_microprocessor&quot;&gt;soft CPU&lt;/a&gt;
work you wish to do.  Of course, you’ll also need an LED or two, and the
&lt;a href=&quot;https://www.arrow.com/en/products/max1000/arrow-development-tools&quot;&gt;MAX1000&lt;/a&gt;
has a nice complement of eight of them.  The
&lt;a href=&quot;http://www.st.com/content/ccc/resource/technical/document/datasheet/3c/ae/50/85/d6/b1/46/fe/CD00274221.pdf/files/CD00274221.pdf/jcr:content/translations/en.CD00274221.pdf&quot;&gt;motion sensor&lt;/a&gt;
on top is also fun bonus not normally found on most
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
boards.  Further, the 
&lt;a href=&quot;http://www.st.com/content/ccc/resource/technical/document/datasheet/3c/ae/50/85/d6/b1/46/fe/CD00274221.pdf/files/CD00274221.pdf/jcr:content/translations/en.CD00274221.pdf&quot;&gt;motion sensor&lt;/a&gt;
also contains an
&lt;a href=&quot;http://www.st.com/content/ccc/resource/technical/document/datasheet/3c/ae/50/85/d6/b1/46/fe/CD00274221.pdf/files/CD00274221.pdf/jcr:content/translations/en.CD00274221.pdf&quot;&gt;accelerometer&lt;/a&gt;
capability, so a fun project might be to create an electronic level.
Even better, the
&lt;a href=&quot;http://www.st.com/content/ccc/resource/technical/document/datasheet/3c/ae/50/85/d6/b1/46/fe/CD00274221.pdf/files/CD00274221.pdf/jcr:content/translations/en.CD00274221.pdf&quot;&gt;auxilliary A/D&lt;/a&gt;
that comes as a part of this
&lt;a href=&quot;http://www.st.com/content/ccc/resource/technical/document/datasheet/3c/ae/50/85/d6/b1/46/fe/CD00274221.pdf/files/CD00274221.pdf/jcr:content/translations/en.CD00274221.pdf&quot;&gt;MEMS motion sensor&lt;/a&gt;
 chip will spare a lot of designers the need to integrate their own
digitizer onto board.&lt;/p&gt;

&lt;p&gt;While I’m not too excited about the 12MHz oscillator, an on-board PLL
turns this nicely into a 100MHz clock for whatever your application might
require.&lt;/p&gt;

&lt;p&gt;You can even connect your own power supply to the board through its through-hole
connectors, in case you wish to run from something other than USB.&lt;/p&gt;

&lt;p&gt;Nice, huh?&lt;/p&gt;

&lt;p&gt;So what’s missing?  Your application.  That’s why I said this has &lt;em&gt;just about&lt;/em&gt;
all of the basic components you will need.  However, it has a nice host
of GPIO through-holes, and even a place where you might solder in a PMod or
perhaps just a PMod header.&lt;/p&gt;

&lt;p&gt;What makes this even nicer?  The price is &lt;em&gt;only&lt;/em&gt; $30.  This will make the board
a nice entry board for hobbyists who aren’t sure they want to do more, and
for classroom instructors who need to purchase a large number of boards to
teach with.  (You may need to teach soldering at the same time, since the board
has only through hole connectors, however.)&lt;/p&gt;

&lt;p&gt;The final item that I like about the board is the form factor.  I don’t know,
maybe it’s just me, but I tend to like &lt;em&gt;really small&lt;/em&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
boards.  Perhaps
its because they are easier to integrate into other applications.  Perhaps
it is some other reason.  Either way, I love the form factor.  Even if you
don’t like small thin boards like I do, though, you will like the fact that
there are very few bulky components to get caught on things and ripped off of
the board.&lt;/p&gt;

&lt;p&gt;Indeed, this board has the makings of being a very nice entry level
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt; board.
No, you aren’t going to learn how to process video with this board.  However,
the possibilities of what you might do with the board remain limited more
by your imagination and the size of the MAX-10
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
than anything else.  What would you like to do with it?&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 3. The ZipCPU&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/zipcpu.png&quot; alt=&quot;The ZipCPU&#39;s pipelined architecture&quot; width=&quot;320&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Personally? I might like to place a
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
onto this board.  I think I already have just about every thing I need for that.
I’ve got a full featured &lt;a href=&quot;https://opencores.org/project,qspiflash&quot;&gt;QSPI flash
controller&lt;/a&gt;, and even an &lt;a href=&quot;https://github.com/ZipCPU/xulalx25soc/blob/master/rtl/wbsdram.v&quot;&gt;SDRAM
controller&lt;/a&gt;
from &lt;a href=&quot;https://github.com/ZipCPU/xulalx25soc/blob/master/rtl/wbsdram.v&quot;&gt;another
project&lt;/a&gt;.  I
should be good to go, right?&lt;/p&gt;

&lt;h2 id=&quot;the-bad&quot;&gt;The Bad&lt;/h2&gt;

&lt;p&gt;While I love the
&lt;a href=&quot;https://www.arrow.com/en/products/max1000/arrow-development-tools&quot;&gt;MAX1000&lt;/a&gt;’s
design and the opportunities built into the circuit board,
and while the sales sheet looks beautiful, building with
this board has already taken more work than I had expected.  The primary
difficulty I’ve had so far, other than the &lt;em&gt;Ugly&lt;/em&gt; section below, has been
finding the documentation.&lt;/p&gt;

&lt;p&gt;The first part of working with any circuit board is always finding the
documentation.  This means finding a board’s
&lt;a href=&quot;https://www.trenz-electronic.de/fileadmin/docs/Trenz_Electronic/TEI0001/REV02/Documents/SCH-TEI0001-02-08-C8.PDF&quot;&gt;schematic&lt;/a&gt;,
its &lt;a href=&quot;https://www.trenz-electronic.de/fileadmin/docs/Trenz_Electronic/TEI0001/User_Guide/MAX1000%20User%20Guide.pdf&quot;&gt;User Guide&lt;/a&gt;,
and any data sheets for the parts on the board.
In this regard, I may be spoiled by
&lt;a href=&quot;https://www.digilentinc.com&quot;&gt;Digilent&lt;/a&gt;–their documentation is always found
from a link on the sales page, and it is usually quite complete.
For the
&lt;a href=&quot;https://www.arrow.com/en/products/max1000/arrow-development-tools&quot;&gt;MAX1000&lt;/a&gt;,
however, I had to struggle for quite some time to find its documentation.
I couldn’t find it linked anywhere from &lt;a href=&quot;https://www.arrow.com/en/products/max1000/arrow-development-tools&quot;&gt;Arrow’s sales
page&lt;/a&gt;,
nor was their &lt;a href=&quot;https://www.arrow.com/en/products/max1000/arrow-development-tools&quot;&gt;sales documentation&lt;/a&gt;
anything I could build with.  To make matters worse, searching
&lt;a href=&quot;https://www.arrow.com/en/products/max1000/arrow-development-tools&quot;&gt;Arrow’s&lt;/a&gt;
data sheets was quite fruitless–and yet they are selling this board.&lt;/p&gt;

&lt;p&gt;To spare you the trouble, I’ll post the links I finally found below.
(Thank you &lt;a href=&quot;https://google.com&quot;&gt;Google&lt;/a&gt;.) The support for the
&lt;a href=&quot;https://www.arrow.com/en/products/max1000/arrow-development-tools&quot;&gt;MAX1000&lt;/a&gt;
comes from 
&lt;a href=&quot;https://forum.trenz-electronic.de/&quot;&gt;Trenz Electronic&lt;/a&gt;, who has built both a
&lt;a href=&quot;https://shop.trenz-electronic.de/en/path?=Trenz_Electronic/TE10001&quot;&gt;wiki&lt;/a&gt;
page for the board, as well as hosting a
&lt;a href=&quot;https://forum.trenz-electronic.de/&quot;&gt;forum&lt;/a&gt; for any problems you might have.
Indeed, you can find these links from &lt;a href=&quot;https://shop.trenz-electronic.de/en/TEI0001-02-08-C8-MAX1000-IoT-Maker-Board&quot;&gt;Trenz’s sales
page&lt;/a&gt;
for the
&lt;a href=&quot;https://www.arrow.com/en/products/max1000/arrow-development-tools&quot;&gt;MAX1000&lt;/a&gt;.
(Well done &lt;a href=&quot;https://shop.trenz-electronic.de&quot;&gt;Trenz&lt;/a&gt;!)&lt;/p&gt;

&lt;p&gt;Hence, with a little work I was able to find the
&lt;a href=&quot;https://www.trenz-electronic.de/fileadmin/docs/Trenz_Electronic/TEI0001/REV02/Documents/SCH-TEI0001-02-08-C8.PDF&quot;&gt;schematic&lt;/a&gt;
and even a &lt;a href=&quot;https://www.trenz-electronic.de/fileadmin/docs/Trenz_Electronic/TEI0001/User_Guide/MAX1000%20User%20Guide.pdf&quot;&gt;User Guide&lt;/a&gt;.  From the
&lt;a href=&quot;https://www.trenz-electronic.de/fileadmin/docs/Trenz_Electronic/TEI0001/REV02/Documents/SCH-TEI0001-02-08-C8.PDF&quot;&gt;schematic&lt;/a&gt;
I could google the data sheet for any part on the board.  Indeed, you’ll
find many of the links within this article point to the data sheets that
I was able to find.&lt;/p&gt;

&lt;p&gt;The &lt;a href=&quot;https://shop.trenz-electronic.de/en/path?=Trenz_Electronic/TE10001&quot;&gt;wiki&lt;/a&gt;
also offered several example designs that I might use.  However, as I looked
through each of them, none of them had any HDL code–whether Verilog or VHDL.&lt;/p&gt;

&lt;p&gt;Worse, although the
&lt;a href=&quot;https://www.trenz-electronic.de/fileadmin/docs/Trenz_Electronic/TEI0001/REV02/Documents/SCH-TEI0001-02-08-C8.PDF&quot;&gt;schematic&lt;/a&gt;
described what pins were connected to which part, and even described which
pins were available for external connections, it offered nothing to tell me
which pins corresponded to which GPIO’s.&lt;/p&gt;

&lt;p&gt;For example, consider what the
&lt;a href=&quot;https://www.trenz-electronic.de/fileadmin/docs/Trenz_Electronic/TEI0001/REV02/Documents/SCH-TEI0001-02-08-C8.PDF&quot;&gt;schematic&lt;/a&gt;
has to say about the GPIO’s on the
left and right sides of the board, shown in Fig 3.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 3. GPIO&#39;s&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/max1k-schematic-gpio.png&quot; alt=&quot;GPIO picture from the Schematic&quot; width=&quot;615&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Now, looking at that figure, can you tell me which pins will be which?  Are the
pins on “top” the ones closest to the USB connector on the board?  Are both
rows organized in the same fashion?  It doesn’t say.  This means that I will
need to spend time probing and reverse engineering just to orient the
&lt;a href=&quot;https://www.trenz-electronic.de/fileadmin/docs/Trenz_Electronic/TEI0001/REV02/Documents/SCH-TEI0001-02-08-C8.PDF&quot;&gt;schematic&lt;/a&gt;
to the board.&lt;/p&gt;

&lt;p&gt;The problem isn’t limited to the two rows of GPIO pins.  The
&lt;a href=&quot;https://www.trenz-electronic.de/fileadmin/docs/Trenz_Electronic/TEI0001/REV02/Documents/SCH-TEI0001-02-08-C8.PDF&quot;&gt;schematic&lt;/a&gt;
also has the same problem when describing the PMod port.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 4. GPIO&#39;s&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/max1k-schematic-pmod.png&quot; alt=&quot;PMod picture from the Schematic&quot; width=&quot;450&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;In both examples, the schematic
makes it clear that the pins are available for use, but still leaves a lot
for granted in how these pins are mapped to the actual device.  For example,
is pin 1 closer to the USB port, or is pin 5?  Which side are the 3.3V and
ground pins on, left or right?  And which way constitutes “left” or “right”?&lt;/p&gt;

&lt;p&gt;Perhaps I’m spoiled.  I was considering connecting the
&lt;a href=&quot;https://www.arrow.com/en/products/max1000/arrow-development-tools&quot;&gt;MAX1000&lt;/a&gt;
to a &lt;a href=&quot;http://www.microcenter.com/product/449970/Teensy_LC_-_Low_Cost&quot;&gt;Teensy
LC&lt;/a&gt;,
and looking at the &lt;a href=&quot;https://www.pjrc.com/teenhttps://www.pjrc.com/teensy/teensylc_front_pinout.pngsy/teensyLC.html&quot;&gt;Teensy
LC’s&lt;/a&gt;
&lt;a href=&quot;https://www.pjrc.com/teensy/teensylc_front_pinout.png&quot;&gt;I/O diagrams&lt;/a&gt; it was
easy to correlate their physical I/O pins to both their I/O pin numbers and
their associated functionality.&lt;/p&gt;

&lt;p&gt;Unfortunately, the
&lt;a href=&quot;https://www.arrow.com/en/products/max1000/arrow-development-tools&quot;&gt;MAX1000&lt;/a&gt;
doesn’t have a simple picture showing how the pins are connected.&lt;/p&gt;

&lt;p&gt;While such a diagram should be easy enough to create, I couldn’t find
anything mapping pins to I/O’s on the board.  The closest I could find were
the (in order) pin numbers on the
&lt;a href=&quot;https://www.trenz-electronic.de/fileadmin/docs/Trenz_Electronic/TEI0001/REV02/Documents/SCH-TEI0001-02-08-C8.PDF&quot;&gt;schematic&lt;/a&gt;
for each of the headers.  However, this wasn’t enough for me to determine
header orientation, etc.&lt;/p&gt;

&lt;p&gt;So while I like the hardware design and build, I’d strike a mark from the board
for its (currently) poor documentation set.&lt;/p&gt;

&lt;h2 id=&quot;the-ugly&quot;&gt;The ugly&lt;/h2&gt;

&lt;p&gt;Okay, now for the really ugly part: I bought my 
&lt;a href=&quot;https://www.arrow.com/en/products/max1000/arrow-development-tools&quot;&gt;MAX1000&lt;/a&gt;
only to discover on the 
&lt;a href=&quot;https://shop.trenz-electronic.de/en/path?=Trenz_Electronic/TE10001&quot;&gt;wiki&lt;/a&gt;
that they hadn’t finished building their Linux driver yet, so they hadn’t
yet posted it for download.&lt;/p&gt;

&lt;p&gt;Please, guys, can’t you hold off selling an item until the driver’s needed to
support it are built and tested?&lt;/p&gt;

&lt;p&gt;A month later, now, they finally have a
&lt;a href=&quot;https://shop.trenz-electronic.de/en/Download/?path=Trenz_Electronic/TEI0001/Driver/Arrow_USB_Blaster&quot;&gt;Linux driver posted&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The problem is … it doesn’t work.&lt;/p&gt;

&lt;p&gt;Sure, they have directions for installing their driver, directions which
clearly tell you how to set it up.  These directions have two problems.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;First, they tell me that I need to disable (blacklist) the linux
&lt;code class=&quot;highlighter-rouge&quot;&gt;ftdi_sio&lt;/code&gt; kernel module.  This is the very same kernel module that I am
using quite successfully and extensively with my other
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
projects.  Blacklisting this kernel module will likely impact my other work
in a negative fashion.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;If this wasn’t unworkable enough on its own, the second problem is that even
after following their instructions I still couldn’t get Quartus’s JTAG
loader to acknowledge that my hardware even existed.
(See section 6.1.4 of the &lt;a href=&quot;https://www.trenz-electronic.de/fileadmin/docs/Trenz_Electronic/TEI0001/User_Guide/MAX1000%20User%20Guide.pdf&quot;&gt;User Guide&lt;/a&gt;
to know where this first failed for me.)&lt;/p&gt;

    &lt;p&gt;To make matters worse, neither the &lt;a href=&quot;https://www.trenz-electronic.de/fileadmin/docs/Trenz_Electronic/TEI0001/User_Guide/MAX1000%20User%20Guide.pdf&quot;&gt;User
Guide&lt;/a&gt;
nor the &lt;a href=&quot;https://shop.trenz-electronic.de/en/Download/?path=Trenz_Electronic/TEI0001/Driver/Arrow_USB_Blaster&quot;&gt;Linux driver installation
instructions&lt;/a&gt;
offer any help in troubleshooting any potential problems.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;My best guess is that there’s something missing in their instructions that
they’ve overlooked, but I’m not sure what it might be.  Perhaps they sold
the device with the wrong
&lt;a href=&quot;http://www.st.com/resource/en/datasheet/CD00001142.pdf&quot;&gt;EEPROM&lt;/a&gt;
settings for the “USB blaster” (i.e. the
&lt;a href=&quot;http://www.ftdichip.com/Support/Documents/DataSheets/ICs/DS_FT2232H.pdf&quot;&gt;FT2232&lt;/a&gt;).&lt;/p&gt;

&lt;h2 id=&quot;the-redeeming&quot;&gt;The Redeeming&lt;/h2&gt;

&lt;p&gt;Here’s the really neat and redeeming part to this whole story: while the
&lt;a href=&quot;https://shop.trenz-electronic.de/en/Download/?path=Trenz_Electronic/TEI0001/Driver/Arrow_USB_Blaster&quot;&gt;Trenz driver&lt;/a&gt;
doesn’t work (yet), I can still configure my
&lt;a href=&quot;https://www.arrow.com/en/products/max1000/arrow-development-tools&quot;&gt;MAX1000&lt;/a&gt;
just fine using the open source &lt;a href=&quot;http://www.clifford.at/libxsvf&quot;&gt;libxvsf&lt;/a&gt;
driver.  No, it’s not point-and-click.  No, I haven’t (yet)
tried it with more than one device on my system–I need to experiment
with that still.  However, I didn’t need to blacklist my working
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
serial port driver to use it.&lt;/p&gt;

&lt;p&gt;To use this tool, you’ll want to download
&lt;a href=&quot;https://en.wikipedia.org/wiki/Universal_asynchronous_receiver/transmitter&quot;&gt;libxsvf&lt;/a&gt;
and build it.  I know there’s got to be an easier way to clone an svn
repository, but I ended up just copying the files in the repository one by
one to my computer.  I then built the package using &lt;code class=&quot;highlighter-rouge&quot;&gt;make all&lt;/code&gt;.  In hindsight,
this is a bit of overkill since i only needed the &lt;code class=&quot;highlighter-rouge&quot;&gt;xsvftool-ft232h&lt;/code&gt; program.
You will need to have the &lt;a href=&quot;https://www.intra2net.com/en/developer/libftdi/&quot;&gt;open source FTDI
library&lt;/a&gt;
and &lt;code class=&quot;highlighter-rouge&quot;&gt;pthreads&lt;/code&gt; installed on your system.&lt;/p&gt;

&lt;p&gt;I was a little concerned about whether this would work with the device I was
using or not, so I then proceeded slowly for the next several steps—just
to make sure I knew what I was doing (and so I didn’t destroy any of my
hardware).&lt;/p&gt;

&lt;p&gt;Hence the first thing I did was to unplug all of my other USB controlled
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
devices.  This probably isn’t technically required, but it does limit the
number of things can go wrong.&lt;/p&gt;

&lt;p&gt;I then issued a command to check the JTAG chain.  I did this to get some
assurance that the tool worked as advertised.  Since I already knew that my
&lt;a href=&quot;https://www.arrow.com/en/products/max1000/arrow-development-tools&quot;&gt;MAX1000&lt;/a&gt;
had a USB ID of &lt;code class=&quot;highlighter-rouge&quot;&gt;0403:6010&lt;/code&gt;, this command was:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;xsvftool-ft232h -D i:0x403:0x6010 -C A -c&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The result was a rather cryptic error that &lt;code class=&quot;highlighter-rouge&quot;&gt;xsvftool-ft2232h&lt;/code&gt; couldn’t open my
device.  Hence, I quickly peppered the &lt;code class=&quot;highlighter-rouge&quot;&gt;xsvftool-ft2232h.c&lt;/code&gt; code with
&lt;a href=&quot;http://www.cplusplus.com/reference/cstdio/perror&quot;&gt;perror()&lt;/a&gt;
statements anytime an O/S call might fail.  (Don’t you just love
open source?)  As a result, I learned that I didn’t have the permission
to execute this command.&lt;/p&gt;

&lt;p&gt;Next, I tried:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;sudo xsvftool-ft232h -D i:0x403:0x6010 -C A -c&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;and this seemed to work.  The result was the simple line,&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;idcode=0x031820dd, revision=0x0, part=0x3182, manufactor=0x06e&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;After looking up the manufacturer’s ID code, I confirmed that &lt;code class=&quot;highlighter-rouge&quot;&gt;6e&lt;/code&gt; is indeed
the manufacturer code for
&lt;a href=&quot;httpss://www.altera.com&quot;&gt;Altera&lt;/a&gt;.  Further, &lt;a href=&quot;httpss://www.altera.com&quot;&gt;Altera&lt;/a&gt;’s
JTAG documentation identifies that the &lt;code class=&quot;highlighter-rouge&quot;&gt;0x031820dd&lt;/code&gt; device is indeed the MAX-10
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
I am working with.&lt;/p&gt;

&lt;p&gt;Ok, so now I know I’m talking to the right chip.&lt;/p&gt;

&lt;p&gt;I then tried reading the
&lt;a href=&quot;http://www.ftdichip.com/Support/Documents/DataSheets/ICs/DS_FT2232H.pdf&quot;&gt;FT2232&lt;/a&gt;’s
&lt;a href=&quot;http://www.st.com/resource/en/datasheet/CD00001142.pdf&quot;&gt;EEPROM&lt;/a&gt;
from the device.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;sudo xsvftool-ft232h -D i:0x403:0x6010 -C A -R ftdi.eeprom&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The result was an error that the
&lt;a href=&quot;http://www.st.com/resource/en/datasheet/CD00001142.pdf&quot;&gt;EEPROM&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Cyclic_redundancy_check&quot;&gt;CRC&lt;/a&gt;
didn’t match.  (I may have to look into that some more.)  However, the
command also produced a file that, when dumped in hex, looked like:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;0000000 01 08 03 04 10 60 00 07 80 fa 08 00 41 44 9a 0c
0000020 a6 24 ca 12 00 00 00 00 66 00 00 00 00 00 00 00
0000040 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
*
0000200&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The third through sixth bytes of this file, &lt;code class=&quot;highlighter-rouge&quot;&gt;03 04 10 60&lt;/code&gt;, caught my
attention.  Knowing that
&lt;a href=&quot;http://www.ftdichip.com/Support/Documents/DataSheets/ICs/DS_FT2232H.pdf&quot;&gt;FT2232&lt;/a&gt;
chips keep their USB identifiers in their
&lt;a href=&quot;http://www.st.com/resource/en/datasheet/CD00001142.pdf&quot;&gt;EEPROM&lt;/a&gt;
memory, I immediately recognized these bytes as the
USB ID of &lt;code class=&quot;highlighter-rouge&quot;&gt;0403:6010&lt;/code&gt;–exactly what I expected from &lt;code class=&quot;highlighter-rouge&quot;&gt;lsusb&lt;/code&gt;, the udev
configuration file I was told to install, and more.&lt;/p&gt;

&lt;p&gt;The next task was to load my
&lt;a href=&quot;https://www.arrow.com/en/products/max1000/arrow-development-tools&quot;&gt;MAX1000&lt;/a&gt;
with my just-built configuration.  For this, I opened up the “Program Device”
dialog, and clicked on “Create JAM, JBC, SVF or ISC File…” from the file
menu.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 3. Quartus Programming Tool Dialog&#39;s File Menu Option&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/quartus-pgm-file-menu.png&quot; alt=&quot;Creating an SVF file in Quartus&quot; width=&quot;320&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;From here, I could save my design in the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Serial_Vector_Format&quot;&gt;Serial Vector Format (SVF)&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Universal_asynchronous_receiver/transmitter&quot;&gt;libxsvf&lt;/a&gt;
required.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 4. Max 1000 peripherals&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/quartus-svf-dialog.png&quot; alt=&quot;Creating an SVF file in Quartus&quot; width=&quot;320&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;I then ran,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;sudo xsvftool-ft232h  -D i:0x403:0x6010 -C A -s quartus/toplevel.svf&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;and &lt;em&gt;my design loaded and worked&lt;/em&gt;!!&lt;/p&gt;

&lt;p&gt;But perhaps I haven’t made clear the significance of this.&lt;/p&gt;

&lt;p&gt;One common question on the
&lt;a href=&quot;https://www.digilentinc.com&quot;&gt;Digilent&lt;/a&gt;
&lt;a href=&quot;https://forum.digilentinc.com&quot;&gt;forum&lt;/a&gt;
is how to do things with the &lt;a href=&quot;http://www.ftdichip.com/Support/Documents/DataSheets/ICs/DS_FT2232H.pdf&quot;&gt;FT2232H FTDI
chip&lt;/a&gt;
on &lt;a href=&quot;https://www.digilentinc.com&quot;&gt;their&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt; boards.
&lt;a href=&quot;https://www.digilentinc.com&quot;&gt;Digilent&lt;/a&gt;’s
answer has always been that the circuitry and configurations associated with the
&lt;a href=&quot;http://www.ftdichip.com/Support/Documents/DataSheets/ICs/DS_FT2232H.pdf&quot;&gt;FT2232&lt;/a&gt;
JTAG loader is a proprietary part of the board.
For those who “accidentally” erase the firmware on their board, the issue
is taken off forum and the poster is quietly given instructions (and software)
to reload the firmware (i.e. the
&lt;a href=&quot;http://www.ftdichip.com/Support/Documents/DataSheets/ICs/DS_FT2232H.pdf&quot;&gt;FT2232&lt;/a&gt;’s
&lt;a href=&quot;http://www.st.com/resource/en/datasheet/CD00001142.pdf&quot;&gt;EEPROM&lt;/a&gt;).&lt;/p&gt;

&lt;p&gt;However, using &lt;a href=&quot;http://www.clifford.at/libxsvf&quot;&gt;libxvsf&lt;/a&gt;,
you can both read the firmware before playing with it, and you can
(or at least should be able to) reconfigure it yourself.  Want to see what
the &lt;a href=&quot;https://www.digilentinc.com&quot;&gt;Digilent&lt;/a&gt;
&lt;a href=&quot;https://store.digilentinc.com/arty-artix-7-fpga-development-board-for-makers-and-hobbyists/&quot;&gt;Arty&lt;/a&gt;
&lt;a href=&quot;http://www.ftdichip.com/Support/Documents/DataSheets/ICs/DS_FT2232H.pdf&quot;&gt;FT2232H&lt;/a&gt;
configuration looks like?&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;0000000 01 08 03 04 10 60 00 07 80 fa 08 00 00 00 9a 12
0000020 ac 28 d4 1a 00 00 00 00 56 00 01 00 c7 92 6a 35
0000040 51 01 00 02 41 72 74 79 00 00 00 00 00 00 00 00
0000060 00 00 00 00 00 44 69 67 69 6c 65 6e 74 20 41 72
0000100 74 79 00 00 00 00 00 00 00 00 00 00 00 00 00 00
0000120 00 00 01 00 00 00 00 00 00 00 00 00 00 00 00 00
0000140 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
*
0000200&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;If you do an &lt;code class=&quot;highlighter-rouge&quot;&gt;od -c&lt;/code&gt; instead of an &lt;code class=&quot;highlighter-rouge&quot;&gt;od -t x1&lt;/code&gt; on the
&lt;a href=&quot;https://store.digilentinc.com/arty-artix-7-fpga-development-board-for-makers-and-hobbyists/&quot;&gt;Arty&lt;/a&gt;’s configuration file,
you get the following:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;0000000 001  \b 003 004 020 140  \0  \a 200 372  \b  \0  \0  \0 232 022
0000020 254   ( 324 032  \0  \0  \0  \0   V  \0 001  \0 307 222   j   5
0000040   Q 001  \0 002   A   r   t   y  \0  \0  \0  \0  \0  \0  \0  \0
0000060  \0  \0  \0  \0  \0   D   i   g   i   l   e   n   t       A   r
0000100   t   y  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0
0000120  \0  \0 001  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0
0000140  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0
*
0000200&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;So, if I want to try my own
&lt;a href=&quot;http://www.ftdichip.com/Support/Documents/DataSheets/ICs/DS_FT2232H.pdf&quot;&gt;FT2232H&lt;/a&gt;
configuration and things don’t work out, I just need to return the device
to this configuration.&lt;/p&gt;

&lt;p&gt;It gets better.&lt;/p&gt;

&lt;p&gt;Should you wish to build your own own design using the
&lt;a href=&quot;http://www.ftdichip.com/Support/Documents/DataSheets/ICs/DS_FT2232H.pdf&quot;&gt;FT2232H&lt;/a&gt;
chip, the
&lt;a href=&quot;https://www.arrow.com/en/products/max1000/arrow-development-tools&quot;&gt;MAX1000&lt;/a&gt;
&lt;a href=&quot;https://www.trenz-electronic.de/fileadmin/docs/Trenz_Electronic/TEI0001/REV02/Documents/SCH-TEI0001-02-08-C8.PDF&quot;&gt;schematic&lt;/a&gt;
offers an example design, showing how to hook it up.  As a result, there’s no
need to ask for the proprietary portion of any
&lt;a href=&quot;https://www.digilentinc.com&quot;&gt;Digilent&lt;/a&gt; schematic if you want an example.
It’s already published for the
&lt;a href=&quot;https://www.arrow.com/en/products/max1000/arrow-development-tools&quot;&gt;MAX1000&lt;/a&gt;
as part of their &lt;a href=&quot;https://www.trenz-electronic.de/fileadmin/docs/Trenz_Electronic/TEI0001/REV02/Documents/SCH-TEI0001-02-08-C8.PDF&quot;&gt;schematic&lt;/a&gt; (see page 5).&lt;/p&gt;

&lt;p&gt;This is all kind of nice and rather neat, but we aren’t done yet.&lt;/p&gt;

&lt;p&gt;The &lt;a href=&quot;http://www.ftdichip.com/Support/Documents/DataSheets/ICs/DS_FT2232H.pdf&quot;&gt;FT2232H FTDI
chip&lt;/a&gt;
found on so many
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
boards offers more than just a USB to
&lt;a href=&quot;https://en.wikipedia.org/wiki/Universal_asynchronous_receiver-transmitter&quot;&gt;UART&lt;/a&gt;
interface mode.  It also offers a USB to
“&lt;a href=&quot;http://www.ftdichip.com/Support/Documents/DataSheets/ICs/DS_FT2232H.pdf&quot;&gt;Fast Serial Interface&lt;/a&gt;”
mode.  This is a simplex, bidirectional interface–with one direction of that
interface shown in Fig 5 below.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 5. Outgoing Fast Serial Data using the FT2232 chip&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/ftdi-fast-serial.png&quot; alt=&quot;&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;As you can see from the figure, this mode works much like a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Universal_asynchronous_receiver-transmitter&quot;&gt;UART&lt;/a&gt;,
with the exception of a clock that can run at up to 50MHz.  That means that
it should be possible to communicate to/from your board
at 5MBps (that’s mega-&lt;em&gt;BYTES&lt;/em&gt; per second), rather than the maximum
&lt;a href=&quot;https://en.wikipedia.org/wiki/Universal_asynchronous_receiver-transmitter&quot;&gt;UART&lt;/a&gt;
rate which is about 200kBps (2MBaud).
Even better, should you wish to play with this mode, the
&lt;a href=&quot;http://www.ftdichip.com/Support/Documents/DataSheets/ICs/DS_FT2232H.pdf&quot;&gt;FT2232 datasheet&lt;/a&gt;
provides all the information you need: from pin assignments to configuration
and more.&lt;/p&gt;

&lt;p&gt;Interested in a 25x speed increase anyone?&lt;/p&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;I suppose at the end of any review I should offer a recommendation: should
someone buy this board or not?  To that question I would answer that it depends
upon the someone.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;If you are willing to do some soldering, and you aren’t afraid of
working without the best documentation then you might find this a nicely
built, well-designed
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
board to work with.&lt;/p&gt;

    &lt;p&gt;It certainly offers more capabilities than the 
&lt;a href=&quot;https://store.digilentinc.com/cmod-s6-breadboardable-spartan-6-fpga-module&quot;&gt;CMod S6&lt;/a&gt;,
at a much lower price point, although you will need to do some soldering
if you want to connect the
&lt;a href=&quot;https://www.arrow.com/en/products/max1000/arrow-development-tools&quot;&gt;MAX1000&lt;/a&gt;
to a breadboard.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;In a similar fashion, if you want to do some experimentation with the
&lt;a href=&quot;http://www.ftdichip.com/Support/Documents/DataSheets/ICs/DS_FT2232H.pdf&quot;&gt;FT2232&lt;/a&gt;
interface found on many
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
boards, the documentation and
&lt;a href=&quot;http://www.clifford.at/libxsvf&quot;&gt;libxvsf&lt;/a&gt;
should give you a clear enough starting point.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;On the other hand, if you’ve never done any
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
design before and just want a beginner’s board, this probably isn’t (yet)
the board you want to start out with.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;As for me, finding an open source
&lt;a href=&quot;http://www.ftdichip.com/Support/Documents/DataSheets/ICs/DS_FT2232H.pdf&quot;&gt;FT2232&lt;/a&gt;
interface and
&lt;a href=&quot;https://www.trenz-electronic.de/fileadmin/docs/Trenz_Electronic/TEI0001/REV02/Documents/SCH-TEI0001-02-08-C8.PDF&quot;&gt;schematic&lt;/a&gt;
makes it all worth while.  Indeed, I’m still drooling over the opportunity
to fire up and test that 5MBps fast serial I/O link.&lt;/p&gt;
&lt;hr /&gt;&lt;p&gt;&lt;em&gt;He that withholdeth corn, the people shall curse him: but blessing shall be upon the head of him that selleth it.  (Prov 11:26)&lt;/em&gt;</description>
        <pubDate>Sat, 16 Dec 2017 00:00:00 -0500</pubDate>
        <link>http://zipcpu.com/blog/2017/12/16/max1k.html</link>
        <guid isPermaLink="true">http://zipcpu.com/blog/2017/12/16/max1k.html</guid>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>Building a Simple Logic PLL</title>
        <description>&lt;p&gt;There’s one signal processing component that has always felt like a black
art to me, and that is a &lt;a href=&quot;https://en.wikipedia.org/wiki/Phase-locked_loop&quot;&gt;Phase Locked Loop or
PLL&lt;/a&gt;.
If you aren’t familiar with
&lt;a href=&quot;https://en.wikipedia.org/wiki/Phase-locked_loop&quot;&gt;PLL&lt;/a&gt;s, a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Phase-locked_loop&quot;&gt;PLL&lt;/a&gt; is a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Feedback&quot;&gt;closed loop&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Control_system&quot;&gt;control system&lt;/a&gt;
designed to match an incoming
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sine_wave&quot;&gt;sine wave&lt;/a&gt; with a reconstructed
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sine_wave&quot;&gt;sine wave&lt;/a&gt; that tracks both the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Instantaneous_phase&quot;&gt;phase&lt;/a&gt; and (optionally) the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency&quot;&gt;frequency&lt;/a&gt;
of an incoming
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sine_wave&quot;&gt;sine wave&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Phase-locked_loop&quot;&gt;PLL&lt;/a&gt;s are important parts
of many
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_signal_processing&quot;&gt;Digital Signal Processing
(DSP)&lt;/a&gt;
systems, including (but not limited to):&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Recovering the implicit (or explicit) clock from an incoming signal.
Inside digital logic, clock recovery
becomes very important when you are trying to transfer data between two
components.  Even components that have two independent clocks, each supposedly
tuned to “the same” clock
&lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency&quot;&gt;frequency&lt;/a&gt;,
will likely have their clocks wander in
&lt;a href=&quot;https://en.wikipedia.org/wiki/Instantaneous_phase&quot;&gt;phase&lt;/a&gt;
with respect to each other.&lt;/p&gt;

    &lt;p&gt;You may be familiar
with the hard &lt;a href=&quot;https://en.wikipedia.org/wiki/Phase-locked_loop&quot;&gt;PLL&lt;/a&gt;
components on your board which are used to do this exact thing.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;New clock signal generation.  For example, a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Phase-locked_loop&quot;&gt;PLL&lt;/a&gt; can often be used
to create a clock &lt;code class=&quot;highlighter-rouge&quot;&gt;N&lt;/code&gt; times faster or slower than an incoming reference
clock.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;In a commercial &lt;a href=&quot;https://en.wikipedia.org/wiki/FM_broadcasting&quot;&gt;broadcast FM
signal&lt;/a&gt;,
a &lt;a href=&quot;https://en.wikipedia.org/wiki/Phase-locked_loop&quot;&gt;PLL&lt;/a&gt; is often used
to undo the &lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency_modulation&quot;&gt;FM
modulation&lt;/a&gt;.  This may
also include a separate
&lt;a href=&quot;https://en.wikipedia.org/wiki/Phase-locked_loop&quot;&gt;PLL&lt;/a&gt; component used to
lock onto the stereo component of the signal–and even to determine if
it is present.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Amplitude_modulation&quot;&gt;AM demodulation&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Of course, my favorite use for a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Phase-locked_loop&quot;&gt;PLL&lt;/a&gt;
is to lock onto the &lt;a href=&quot;https://en.wikipedia.org/wiki/Baud&quot;&gt;baud rate&lt;/a&gt;
and &lt;a href=&quot;https://en.wikipedia.org/wiki/Carrier_recovery&quot;&gt;carrier phase&lt;/a&gt;
of a &lt;a href=&quot;https://en.wikipedia.org/wiki/Data_transmission&quot;&gt;digital communications
waveform&lt;/a&gt;.
The &lt;a href=&quot;https://en.wikipedia.org/wiki/Baud&quot;&gt;baud&lt;/a&gt;
clock recovery portion of this circuit in the receiver is used to determine
the sampling point (the middle) of any received bits.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;My own first experience with
&lt;a href=&quot;https://en.wikipedia.org/wiki/Phase-locked_loop&quot;&gt;PLL&lt;/a&gt;s came as part of
an “Everything you need to know about
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_signal_processing&quot;&gt;DSP&lt;/a&gt;”
type of course offered at my workplace.  In this course, the instructor
presented two very simple
&lt;a href=&quot;https://en.wikipedia.org/wiki/Phase-locked_loop&quot;&gt;PLL&lt;/a&gt; structures that have
served me well ever since.&lt;/p&gt;

&lt;p&gt;If &lt;a href=&quot;https://www.blueletterbible.org/kjv/jas/4/15&quot;&gt;the Lord permits&lt;/a&gt;, I
may have the opportunity to share some of these same fundamental
&lt;a href=&quot;https://en.wikipedia.org/wiki/Phase-locked_loop&quot;&gt;PLL&lt;/a&gt; structures here
with you here on &lt;a href=&quot;http://zipcpu.com/&quot;&gt;this blog&lt;/a&gt;.  I’ll try
to keep them as simple as I can.  For example, the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Phase-locked_loop&quot;&gt;PLL&lt;/a&gt;
I’ll present below has only about 84 lines of logic to its implementation.
Sound simple enough?&lt;/p&gt;

&lt;p&gt;Since that first class, though, I decided that I didn’t know enough about this
black art, and that I wanted to learn more about
&lt;a href=&quot;https://en.wikipedia.org/wiki/Phase-locked_loop&quot;&gt;PLL&lt;/a&gt;s.  After a bit of
browsing on &lt;a href=&quot;https://www.amazon.com&quot;&gt;Amazon&lt;/a&gt;, I came across
&lt;a href=&quot;https://www.amazon.com/Phaselock-Techniques-Floyd-M-Gardner/dp/0471430633/&quot;&gt;Floyd M. Gardner’s book, &lt;em&gt;Phaselock Techniques&lt;/em&gt;&lt;/a&gt;.
One particular comment in his introductory chapter caught my eye, and I’d
like to repeat it for you here:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Every &lt;a href=&quot;https://en.wikipedia.org/wiki/Phase-locked_loop&quot;&gt;PLL&lt;/a&gt; is
&lt;a href=&quot;https://en.wikipedia.org/wiki/Nonlinear_system&quot;&gt;nonlinear&lt;/a&gt;.
Tools for analysis of
&lt;a href=&quot;https://en.wikipedia.org/wiki/Nonlinear_system&quot;&gt;nonlinear system&lt;/a&gt;s are
exceedingly cumbersome and provide meager benefits compared to the powerful
analytical tools available for
&lt;a href=&quot;https://en.wikipedia.org/wiki/Linear_system&quot;&gt;linear system&lt;/a&gt;s.  Fortunately,
most (but not all) &lt;a href=&quot;https://en.wikipedia.org/wiki/Phase-locked_loop&quot;&gt;PLL&lt;/a&gt;s
of interest can be analyzed by
&lt;a href=&quot;https://en.wikipedia.org/wiki/Linear_system&quot;&gt;linear&lt;/a&gt; techniques
when in their locked condition.  This book argues throughout that
&lt;a href=&quot;https://en.wikipedia.org/wiki/Linear_system&quot;&gt;linear&lt;/a&gt; methods are
sufficient for the bulk of the analysis and initial design of most
&lt;a href=&quot;https://en.wikipedia.org/wiki/Phase-locked_loop&quot;&gt;PLL&lt;/a&gt;s.
Therefore, linear approximations are employed wherever feasible.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;I was instantly sold!  I’ve not regretted this purchase since then, for Mr.
Gardner was true to his word and I have learned much from &lt;a href=&quot;https://www.amazon.com/Phaselock-Techniques-Floyd-M-Gardner/dp/0471430633/&quot;&gt;his
book&lt;/a&gt;.
That said, I’ve never taken any academic classes studying
&lt;a href=&quot;https://en.wikipedia.org/wiki/Phase-locked_loop&quot;&gt;PLL&lt;/a&gt; design or analysis,
so I can’t really comment on whether or not other books are better or worse
than &lt;a href=&quot;https://www.amazon.com/Phaselock-Techniques-Floyd-M-Gardner/dp/0471430633/&quot;&gt;Gardner’s&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;So today let’s talk about how to build a really simple
&lt;a href=&quot;https://en.wikipedia.org/wiki/Phase-locked_loop&quot;&gt;PLL&lt;/a&gt;.  I’m going to call
this a &lt;a href=&quot;https://github.com/ZipCPU/dpll/blob/master/rtl/sdpll.v&quot;&gt;logic PLL&lt;/a&gt;
for the simple reason that it will take as an input a logical
(&lt;a href=&quot;https://en.wikipedia.org/wiki/Boolean_algebra&quot;&gt;boolean&lt;/a&gt;)
clock signal (&lt;code class=&quot;highlighter-rouge&quot;&gt;0&lt;/code&gt; or &lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt;).  Internally, the
&lt;a href=&quot;https://github.com/ZipCPU/dpll/blob/master/rtl/sdpll.v&quot;&gt;logic PLL&lt;/a&gt;
will use only simple &lt;a href=&quot;https://en.wikipedia.org/wiki/Boolean_algebra&quot;&gt;boolean&lt;/a&gt;
logic–there will be no &lt;code class=&quot;highlighter-rouge&quot;&gt;N&lt;/code&gt;-bit samples or even
any &lt;a href=&quot;https://en.wikipedia.org/wiki/Sine_wave&quot;&gt;sine wave&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/cordic&quot;&gt;generation&lt;/a&gt;
within the logic below.  Indeed, you might need to look carefully if you want
to find the multiplies.&lt;/p&gt;

&lt;h2 id=&quot;components-of-a-pll&quot;&gt;Components of a PLL&lt;/h2&gt;

&lt;p&gt;The basic form of a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Phase-locked_loop&quot;&gt;PLL&lt;/a&gt;
is that of a &lt;a href=&quot;https://en.wikipedia.org/wiki/Feedback&quot;&gt;control loop&lt;/a&gt;.  The
input to this loop is a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sine_wave&quot;&gt;sine wave&lt;/a&gt;.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 1. PLL feedback&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/dpll-block-diagram.svg&quot; alt=&quot;Components of a PLL&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Outputs can be taken from any number of locations, depending upon the purpose
of the &lt;a href=&quot;https://en.wikipedia.org/wiki/Phase-locked_loop&quot;&gt;PLL&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The loop begins with an incoming &lt;a href=&quot;https://en.wikipedia.org/wiki/Sine_wave&quot;&gt;sine
wave&lt;/a&gt; that is passed into a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Phase_detector&quot;&gt;phase detector&lt;/a&gt;.
The &lt;a href=&quot;https://en.wikipedia.org/wiki/Phase_detector&quot;&gt;phase detector&lt;/a&gt;
is used to compare the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Instantaneous_phase&quot;&gt;phase&lt;/a&gt;
of the incoming &lt;a href=&quot;https://en.wikipedia.org/wiki/Sine_wave&quot;&gt;sine
wave&lt;/a&gt; against a reconstructed
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sine_wave&quot;&gt;sine wave&lt;/a&gt;
produced internally.  The output of this
&lt;a href=&quot;https://en.wikipedia.org/wiki/Phase_detector&quot;&gt;phase detector&lt;/a&gt;
is an error signal.  This error signal is then optionally filtered, and fed
into two portions of the circuit: one to track
&lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency&quot;&gt;frequency&lt;/a&gt;
and the other to track
&lt;a href=&quot;https://en.wikipedia.org/wiki/Instantaneous_phase&quot;&gt;phase&lt;/a&gt;.
These two portions combine within a
&lt;a href=&quot;/dsp/2017/12/09/nco.html&quot;&gt;Numerically Controlled Oscillator (NCO)&lt;/a&gt;
to create a new
&lt;a href=&quot;https://en.wikipedia.org/wiki/Instantaneous_phase&quot;&gt;phase&lt;/a&gt; for the reconstructed
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sine_wave&quot;&gt;sine wave&lt;/a&gt;.
That &lt;a href=&quot;https://en.wikipedia.org/wiki/Instantaneous_phase&quot;&gt;phase&lt;/a&gt; is then used
as an input to a &lt;a href=&quot;https://en.wikipedia.org/wiki/Sine_wave&quot;&gt;sine wave&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/cordic&quot;&gt;generator&lt;/a&gt; to create a reconstructed
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sine_wave&quot;&gt;sine wave&lt;/a&gt;, which is then used as the
second input to the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Phase_detector&quot;&gt;phase detector&lt;/a&gt;
and the loop repeats.&lt;/p&gt;

&lt;p&gt;The &lt;a href=&quot;https://github.com/ZipCPU/dpll/blob/master/rtl/sdpll.v&quot;&gt;PLL presented
below&lt;/a&gt;
will contain all of these basic components, with the exception that
the incoming &lt;a href=&quot;https://en.wikipedia.org/wiki/Sine_wave&quot;&gt;sine wave&lt;/a&gt; will be
represented by a 1-bit clock signal, and the reconstructed
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sine_wave&quot;&gt;sine wave&lt;/a&gt; will have only a
1-bit amplitude.  Put together, these two changes will allow us to keep the
&lt;a href=&quot;/blog/2017/06/12/minimizing-luts.html&quot;&gt;logic count&lt;/a&gt;
of this “logic &lt;a href=&quot;https://en.wikipedia.org/wiki/Phase-locked_loop&quot;&gt;PLL&lt;/a&gt;”
quite low.  Since low
&lt;a href=&quot;/blog/2017/06/12/minimizing-luts.html&quot;&gt;logic count&lt;/a&gt;
often correlates with high
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
speed, these two changes should allow this
&lt;a href=&quot;https://en.wikipedia.org/wiki/Phase-locked_loop&quot;&gt;PLL&lt;/a&gt;
to run at a high internal speed within an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;a-basic-pll-interface&quot;&gt;A Basic PLL interface&lt;/h2&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 2. PLL interface&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/pll-block-component.svg&quot; alt=&quot;Components of a PLL&quot; width=&quot;360&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;A typical &lt;a href=&quot;https://en.wikipedia.org/wiki/Phase-locked_loop&quot;&gt;PLL&lt;/a&gt;
component might have a component I/O diagram like the one in Fig 2 to the right.
Indeed, today’s &lt;a href=&quot;https://github.com/ZipCPU/dpll/blob/master/rtl/sdpll.v&quot;&gt;logic
PLL&lt;/a&gt;
will implement most of this interface–with the exception of the lock indicator
output.&lt;/p&gt;

&lt;p&gt;The basic signals are:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;An incoming clock signal, &lt;code class=&quot;highlighter-rouge&quot;&gt;i_clk&lt;/code&gt;.  While not shown in Fig 2, today’s logic
is going to be
&lt;a href=&quot;https://en.wikipedia.org/wiki/Synchronous_circuit&quot;&gt;synchronous&lt;/a&gt;,
and hence everything will take place on clock edges.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;A means of setting the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency&quot;&gt;frequency&lt;/a&gt;
of the internal &lt;a href=&quot;/dsp/2017/12/09/nco.html&quot;&gt;NCO&lt;/a&gt;
component.  In this case, any time the &lt;em&gt;load new frequency&lt;/em&gt; flag is true,
we’ll call this &lt;code class=&quot;highlighter-rouge&quot;&gt;i_ld&lt;/code&gt; below, the internal
&lt;a href=&quot;https://en.wikipedia.org/wiki/Instantaneous_phase&quot;&gt;phase&lt;/a&gt;
increment of the
&lt;a href=&quot;/dsp/2017/12/09/nco.html&quot;&gt;NCO&lt;/a&gt;
will be forced to the &lt;em&gt;frequency control&lt;/em&gt; value, &lt;code class=&quot;highlighter-rouge&quot;&gt;i_step&lt;/code&gt;.  While &lt;code class=&quot;highlighter-rouge&quot;&gt;i_ld&lt;/code&gt; is
high, the &lt;a href=&quot;https://github.com/ZipCPU/dpll/blob/master/rtl/sdpll.v&quot;&gt;logic PLL&lt;/a&gt;
will not track any &lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency&quot;&gt;frequency&lt;/a&gt;
changes.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The bandwidth of this control loop will be set via the &lt;em&gt;loop bandwidth
control&lt;/em&gt; input, &lt;code class=&quot;highlighter-rouge&quot;&gt;i_lgcoeff&lt;/code&gt; which I may reference as &lt;code class=&quot;highlighter-rouge&quot;&gt;LGCOEFF&lt;/code&gt; below, so that
the internal loop gain is set to &lt;code class=&quot;highlighter-rouge&quot;&gt;2^(-LGCOEFF)&lt;/code&gt;.  This will control how
fast the loop locks on to an incoming clock signal.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;This leaves the incoming
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sine_wave&quot;&gt;sine wave&lt;/a&gt;,
&lt;code class=&quot;highlighter-rouge&quot;&gt;i_input&lt;/code&gt;.  We’ll assume this is either on
or off, much like any logical clock signal.  We’ll also use the &lt;a href=&quot;/blog/2017/08/14/strategies-for-pipelining.html&quot;&gt;“global CE”
strategy&lt;/a&gt;,
captured by the clock enable (CE) line, referenced below as &lt;code class=&quot;highlighter-rouge&quot;&gt;i_ce&lt;/code&gt;.  Under
this
&lt;a href=&quot;/blog/2017/08/14/strategies-for-pipelining.html&quot;&gt;strategy&lt;/a&gt;,
both &lt;code class=&quot;highlighter-rouge&quot;&gt;i_input&lt;/code&gt; and the outputs &lt;code class=&quot;highlighter-rouge&quot;&gt;o_phase&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;o_err&lt;/code&gt; will need to be valid
any time &lt;code class=&quot;highlighter-rouge&quot;&gt;i_ce&lt;/code&gt; is true, and should only change at that time.&lt;/p&gt;

    &lt;p&gt;From a timing standpoint, we’ll want to be able to handle the case where
&lt;code class=&quot;highlighter-rouge&quot;&gt;i_ce&lt;/code&gt; is held at one, so as to make this a high speed
&lt;a href=&quot;https://en.wikipedia.org/wiki/Phase-locked_loop&quot;&gt;PLL&lt;/a&gt;
implementation.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;There are two basic outputs of
&lt;a href=&quot;https://github.com/ZipCPU/dpll/blob/master/rtl/sdpll.v&quot;&gt;this PLL&lt;/a&gt;:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;The error signal coming out of the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Phase_detector&quot;&gt;phase detector&lt;/a&gt;.&lt;/p&gt;

    &lt;p&gt;Changes in this
&lt;a href=&quot;https://en.wikipedia.org/wiki/Instantaneous_phase&quot;&gt;phase&lt;/a&gt;
error signal, since they will be proportional to
&lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency&quot;&gt;frequency&lt;/a&gt;, are often used within an
&lt;a href=&quot;https://en.wikipedia.org/wiki/FM_broadcasting&quot;&gt;FM&lt;/a&gt; demodulator.&lt;/p&gt;

    &lt;p&gt;You could also use this error signal to create a locked indication if you
wanted.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;We’ll also produce the basic
&lt;a href=&quot;https://en.wikipedia.org/wiki/Instantaneous_phase&quot;&gt;phase&lt;/a&gt;
of the internal oscillator, &lt;code class=&quot;highlighter-rouge&quot;&gt;o_phase&lt;/code&gt;.
This signal is the same as the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Instantaneous_phase&quot;&gt;phase&lt;/a&gt;
counter we used in our
&lt;a href=&quot;/dsp/2017/12/09/nco.html&quot;&gt;NCO&lt;/a&gt; discussion.&lt;/p&gt;

    &lt;p&gt;Because this
&lt;a href=&quot;https://en.wikipedia.org/wiki/Instantaneous_phase&quot;&gt;phase&lt;/a&gt;
tracks the incoming signal, it can also be used as an indication of when
to sample an incoming data bit.&lt;/p&gt;

    &lt;p&gt;Further, since we’ll be matching the most-significant bit of this
&lt;a href=&quot;https://en.wikipedia.org/wiki/Instantaneous_phase&quot;&gt;phase&lt;/a&gt;
value to the incoming clock signal, this also creates a stable clock output.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Put together, you can see the prototype for our
&lt;a href=&quot;https://github.com/ZipCPU/dpll/blob/master/rtl/sdpll.v&quot;&gt;logic PLL&lt;/a&gt;
written out in Verilog below.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;module	sdpll(i_clk, i_ld, i_step, i_ce, i_input, i_lgcoeff, o_phase, o_err);
	parameter		PHASE_BITS = 32;
	parameter	[0:0]	OPT_TRACK_FREQUENCY = 1&#39;b1;
	localparam		MSB=PHASE_BITS-1;
	//
	input	wire	i_clk;
	//
	input	wire			i_ld;
	input	wire	[(MSB-1):0]	i_step;
	//
	input	wire			i_ce;
	input	wire			i_input;
	input	wire	[4:0]		i_lgcoeff;
	output	wire	[PHASE_BITS-1:0] o_phase;
	output	reg	[1:0]		o_err;
	//&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;One item to note is that 
&lt;a href=&quot;https://github.com/ZipCPU/dpll/blob/master/rtl/sdpll.v&quot;&gt;this PLL&lt;/a&gt; design can
be set to optionally track
&lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency&quot;&gt;frequency&lt;/a&gt;, as well as
&lt;a href=&quot;https://en.wikipedia.org/wiki/Instantaneous_phase&quot;&gt;phase&lt;/a&gt;,
by just setting the &lt;code class=&quot;highlighter-rouge&quot;&gt;OPT_TRACK_FREQUENCY&lt;/code&gt; flag above.&lt;/p&gt;

&lt;p&gt;As discussed above, the goal of
&lt;a href=&quot;https://github.com/ZipCPU/dpll/blob/master/rtl/sdpll.v&quot;&gt;this PLL&lt;/a&gt;
is to track the incoming signal, &lt;code class=&quot;highlighter-rouge&quot;&gt;i_input&lt;/code&gt;, and to produce a reconstructed clock
signal.  This reconstructed clock signal will be captured by the most
significant bit of the output, &lt;code class=&quot;highlighter-rouge&quot;&gt;o_phase&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Further, while we are not creating a &lt;em&gt;lock&lt;/em&gt; signal today, we could easily
create one later by using the &lt;code class=&quot;highlighter-rouge&quot;&gt;o_err&lt;/code&gt; signal if we wanted to.  Indeed, such
a &lt;em&gt;lock&lt;/em&gt; signal isn’t really all that hard to create: just pass the
&lt;code class=&quot;highlighter-rouge&quot;&gt;(o_err == 2&#39;b00)&lt;/code&gt; signal into a &lt;a href=&quot;/dsp/2017-08-19-simple-filter.html&quot;&gt;recursive
average&lt;/a&gt;.
Once the output of such a &lt;a href=&quot;/dsp/2017-08-19-simple-filter.html&quot;&gt;recursive
average&lt;/a&gt;
falls below a threshold, the loop may be assumed to be &lt;em&gt;locked&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;These, though, are the basic components of any
&lt;a href=&quot;https://en.wikipedia.org/wiki/Phase-locked_loop&quot;&gt;PLL&lt;/a&gt;, and specifically the
components we will implement as part of &lt;a href=&quot;https://github.com/ZipCPU/dpll/blob/master/rtl/sdpll.v&quot;&gt;our
module&lt;/a&gt; today.&lt;/p&gt;

&lt;h2 id=&quot;the-logic-based-nco&quot;&gt;The Logic Based NCO&lt;/h2&gt;

&lt;p&gt;We discussed &lt;a href=&quot;/dsp/2017/12/09/nco.html&quot;&gt;how to build an
NCO&lt;/a&gt; in an
&lt;a href=&quot;/dsp/2017/12/09/nco.html&quot;&gt;earlier article&lt;/a&gt;.
Today, we are going to use nearly the same logic to create a clock signal,
and we’ll then approximate the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sine_wave&quot;&gt;sine wave&lt;/a&gt;
generator with the most significant bit of the
&lt;a href=&quot;/dsp/2017/12/09/nco.html&quot;&gt;NCO&lt;/a&gt;’s
&lt;a href=&quot;https://en.wikipedia.org/wiki/Instantaneous_phase&quot;&gt;phase&lt;/a&gt;
accumulator.&lt;/p&gt;

&lt;p&gt;This is also the same logic used by the &lt;em&gt;fractional counter&lt;/em&gt; timing approach
&lt;a href=&quot;/blog/2017/06/02/generating-timing.html&quot;&gt;we discussed
earlier&lt;/a&gt;.
As you may recall from
&lt;a href=&quot;/blog/2017/06/02/generating-timing.html&quot;&gt;that discussion&lt;/a&gt;,
a clock of an arbitrary
&lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency&quot;&gt;frequency&lt;/a&gt;
may be generated by just examining the most significant bit of a counter.&lt;/p&gt;

&lt;p&gt;That means we’ll be starting with logic that looks like the following.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	initial	ctr = 0;
	always @(posedge i_clk)
		if (i_ce)
			ctr &amp;lt;= ctr + r_step;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;In this case, the &lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency&quot;&gt;frequency&lt;/a&gt; of the
clock generated by this counter will be given by the product of the counter’s
&lt;a href=&quot;/dsp/2017/12/09/nco.html&quot;&gt;phase step&lt;/a&gt; (divided by
&lt;code class=&quot;highlighter-rouge&quot;&gt;2^(PHASE_BITS)&lt;/code&gt;) times the overall clock rate.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/dpll-frequency-step.png&quot; alt=&quot;f = r_step * f_clk / 2^(PHASE_BITS)&quot; width=&quot;228&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Feel free to reference the
&lt;a href=&quot;/dsp/2017/12/09/nco.html&quot;&gt;NCO&lt;/a&gt; article if any of this
doesn’t look familiar to you here.&lt;/p&gt;

&lt;p&gt;Setting the &lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency&quot;&gt;frequency&lt;/a&gt; of this
&lt;a href=&quot;/dsp/2017/12/09/nco.html&quot;&gt;phase accumulator&lt;/a&gt;
(really a &lt;em&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Instantaneous_phase&quot;&gt;phase&lt;/a&gt;
step&lt;/em&gt;) is as simple as setting the &lt;code class=&quot;highlighter-rouge&quot;&gt;r_step&lt;/code&gt; value any time the user
wishes to adjust the &lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency&quot;&gt;frequency&lt;/a&gt;
of the basic &lt;a href=&quot;/dsp/2017/12/09/nco.html&quot;&gt;NCO&lt;/a&gt;,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(posedge i_clk)
		if (i_ld)
			r_step &amp;lt;= { 1&#39;b0, i_step };&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This is just our starting point, however, as both of these blocks will need
some adjustment if we wish to track the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Instantaneous_phase&quot;&gt;phase&lt;/a&gt; and (optionally) the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency&quot;&gt;frequency&lt;/a&gt;
of an incoming &lt;a href=&quot;https://en.wikipedia.org/wiki/Sine_wave&quot;&gt;sine wave&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;As we work through the logic of
&lt;a href=&quot;https://github.com/ZipCPU/dpll/blob/master/rtl/sdpll.v&quot;&gt;this&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Phase-locked_loop&quot;&gt;PLL&lt;/a&gt;,
you’ll find this
&lt;a href=&quot;https://en.wikipedia.org/wiki/Instantaneous_phase&quot;&gt;phase&lt;/a&gt;
&lt;a href=&quot;/dsp/2017/12/09/nco.html&quot;&gt;accumulator&lt;/a&gt; value,
&lt;code class=&quot;highlighter-rouge&quot;&gt;ctr&lt;/code&gt;, comes back again and again.&lt;/p&gt;

&lt;h2 id=&quot;a-logic-phase-detector&quot;&gt;A Logic Phase Detector&lt;/h2&gt;

&lt;p&gt;The goal of the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Phase_detector&quot;&gt;phase detector&lt;/a&gt;
is to create a signal that is proportional to how far the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Phase-locked_loop&quot;&gt;PLL&lt;/a&gt;
needs to be made faster or slowed down.  Traditionally, a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Phase_detector&quot;&gt;phase detector&lt;/a&gt;
is created by taking a product of the input
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sine_wave&quot;&gt;(co)sine wave&lt;/a&gt;
with a reconstructed
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sine_wave&quot;&gt;sine wave&lt;/a&gt;
separated by ninety degrees.  The resulting
&lt;a href=&quot;https://en.wikipedia.org/wiki/Instantaneous_phase&quot;&gt;phase&lt;/a&gt;
error signal is then proportional to how far the
&lt;a href=&quot;/dsp/2017/12/09/nco.html&quot;&gt;phase accumulator&lt;/a&gt;
is from the incoming signal.&lt;/p&gt;

&lt;p&gt;This is not going to be our chosen approach today.  Instead, we’ll use an
&lt;em&gt;ad-hoc&lt;/em&gt; approach–one that generates a two-bit
&lt;a href=&quot;https://en.wikipedia.org/wiki/Instantaneous_phase&quot;&gt;phase&lt;/a&gt;
error signal indicating not
only the presence of an error but also the direction the internal counter
needs to be adjusted.  This will not be proportional, since we are only going to
capture a two bit
&lt;a href=&quot;https://en.wikipedia.org/wiki/Instantaneous_phase&quot;&gt;phase&lt;/a&gt;
error signal, but rather somewhat
nonlinear–perfect, though, for
a &lt;a href=&quot;https://en.wikipedia.org/wiki/Boolean_algebra&quot;&gt;boolean&lt;/a&gt;
logic implementation.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: left&quot;&gt;&lt;caption&gt;Fig 3. The regenerated clock leads the input&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/dpll-lead.svg&quot; alt=&quot;The regenerated clock leads the incoming clock&quot; width=&quot;360&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Let’s consider how this
&lt;a href=&quot;https://en.wikipedia.org/wiki/Phase_detector&quot;&gt;phase detector&lt;/a&gt;
needs to work.  If the regenerated
clock changes before the incoming clock, as shown in Fig 3, then we’ll say
that this regenerated clock &lt;em&gt;leads&lt;/em&gt; the input.  Such a &lt;em&gt;leading&lt;/em&gt; situation
will create a negative
&lt;a href=&quot;https://en.wikipedia.org/wiki/Instantaneous_phase&quot;&gt;phase&lt;/a&gt; error,
indicating that we will want to slow down
&lt;a href=&quot;https://github.com/ZipCPU/dpll/blob/master/rtl/sdpll.v&quot;&gt;our PLL&lt;/a&gt;.
Further, any time the two signals, both the incoming clock and the
regenerated one, are identical we’ll design our
&lt;a href=&quot;https://en.wikipedia.org/wiki/Phase_detector&quot;&gt;phase detector&lt;/a&gt;
to indicate zero
&lt;a href=&quot;https://en.wikipedia.org/wiki/Instantaneous_phase&quot;&gt;phase&lt;/a&gt; error.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 4. The regenerated clock lags (doesn&#39;t lead) the input&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/dpll-lag.svg&quot; alt=&quot;The regenerated clock lags behind the incoming clock&quot; width=&quot;360&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;On the other hand, if the regenerated clock changes &lt;em&gt;after&lt;/em&gt; the incoming clock,
such as is shown in Fig 4, then our reconstructed clock isn’t transitioning
fast enough.  We’ll say in this case that the regenerated clock &lt;em&gt;lags&lt;/em&gt; the
input.  To correct this, we’ll want to speed up our internal clock to “catch
up” to the incoming clock, hence we want to create a &lt;em&gt;positive&lt;/em&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Instantaneous_phase&quot;&gt;phase&lt;/a&gt; error in this case.
As before, though, any time the two signals agree we’ll want to keep the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Instantaneous_phase&quot;&gt;phase&lt;/a&gt; error at zero.&lt;/p&gt;

&lt;p&gt;But how shall we tell whether we are leading or lagging?&lt;/p&gt;

&lt;p&gt;We’ll start by keeping track of the input sign from the last time the input
and reconstructed signal agree.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	initial	agreed_output = 0;
	always @(posedge i_clk)
	if (i_ce)
	begin
		if ((i_input)&amp;amp;&amp;amp;(ctr[MSB]))
			agreed_output &amp;lt;= 1&#39;b1;
		else if ((!i_input)&amp;amp;&amp;amp;(!ctr[MSB]))
			agreed_output &amp;lt;= 1&#39;b0;
	end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Whether or not we are &lt;em&gt;leading&lt;/em&gt; the incoming clock, can then be determined
with respsct to this last agreed upon output.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(*)
		if (agreed_output)
			// We were last high.  Lead is true now
			// if the counter goes low before the input
			lead = (!ctr[MSB])&amp;amp;&amp;amp;(i_input);
		else
			// The last time we agreed, both the counter
			// and the input were low.   This will be
			// true if the counter goes high before the input
			lead = (ctr[MSB])&amp;amp;&amp;amp;(!i_input);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Since the above logic didn’t capture whether or not the current regenerated
bit, &lt;code class=&quot;highlighter-rouge&quot;&gt;ctr[MSB]&lt;/code&gt; matched the &lt;code class=&quot;highlighter-rouge&quot;&gt;i_input&lt;/code&gt;, we’ll capture that in an internal
&lt;code class=&quot;highlighter-rouge&quot;&gt;phase_err&lt;/code&gt; exists signal.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	// Any disagreement between the high order counter bit and the input
	// is a phase error that we will need to correct
	assign	phase_err = (ctr[MSB] != i_input);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;We can put these two values together, &lt;code class=&quot;highlighter-rouge&quot;&gt;phase_err&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;lead&lt;/code&gt;, to create a
2-bit output error value, representing either &lt;code class=&quot;highlighter-rouge&quot;&gt;-1&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;0&lt;/code&gt;, or &lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	initial	o_err = 2&#39;h0;
	always @(posedge i_clk)
	if (i_ce)
		o_err &amp;lt;= (!phase_err) ? 2&#39;b00 : ((lead) ? 2&#39;b11 : 2&#39;b01);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;We won’t actually use this value internally, but rather the &lt;code class=&quot;highlighter-rouge&quot;&gt;phase_err&lt;/code&gt; and
&lt;code class=&quot;highlighter-rouge&quot;&gt;lead&lt;/code&gt; signals.  However, the &lt;code class=&quot;highlighter-rouge&quot;&gt;o_err&lt;/code&gt; signal should make it easier to understand
the &lt;code class=&quot;highlighter-rouge&quot;&gt;phase_err&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;lead&lt;/code&gt; signals.&lt;/p&gt;

&lt;h2 id=&quot;a-logic-pll-type-1&quot;&gt;A Logic PLL: Type 1&lt;/h2&gt;

&lt;p&gt;A “Type 1”
&lt;a href=&quot;https://en.wikipedia.org/wiki/Phase-locked_loop&quot;&gt;PLL&lt;/a&gt;
is one that tracks &lt;a href=&quot;https://en.wikipedia.org/wiki/Instantaneous_phase&quot;&gt;phase&lt;/a&gt;,
but not &lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency&quot;&gt;frequency&lt;/a&gt;.  This portion of a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Phase-locked_loop&quot;&gt;PLL&lt;/a&gt;
accepts as an input the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Instantaneous_phase&quot;&gt;phase&lt;/a&gt;
error, (optionally) &lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filters&lt;/a&gt;
it, and then corrects the internal
&lt;a href=&quot;/dsp/2017/12/09/nco.html&quot;&gt;phase accumulator&lt;/a&gt;,
&lt;code class=&quot;highlighter-rouge&quot;&gt;ctr&lt;/code&gt;, based upon the result.  In general, this involves applying some sort
of linear operator to the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Instantaneous_phase&quot;&gt;phase&lt;/a&gt;
error signal, and then adding the result of that operator to the
&lt;a href=&quot;/dsp/2017/12/09/nco.html&quot;&gt;phase accumulator&lt;/a&gt;.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 5. The type-1 open loop transform&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/pll-type-1-open-loop.svg&quot; alt=&quot;The open loop transform function of a type-1 system&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Today’s
&lt;a href=&quot;https://github.com/ZipCPU/dpll/blob/master/rtl/sdpll.v&quot;&gt;logic PLL&lt;/a&gt;
is no different.  In this case, though, we’ll skip the optional
&lt;a href=&quot;https://en.wikipedia.org/wiki/Low-pass_filter&quot;&gt;lowpass filter&lt;/a&gt;
and just multiply our incoming
&lt;a href=&quot;https://en.wikipedia.org/wiki/Instantaneous_phase&quot;&gt;phase&lt;/a&gt;
error by a constant before adding it to our
&lt;a href=&quot;/dsp/2017/12/09/nco.html&quot;&gt;phase accumulator&lt;/a&gt;.
Even better, because the incoming error was either -1, 0, or 1, no real
multiplication is required–we can use a nested &lt;code class=&quot;highlighter-rouge&quot;&gt;if&lt;/code&gt; instead.&lt;/p&gt;

&lt;p&gt;As for the constant, what constant shall we use?  As we suggested above, we’ll
use the absolutely simplest constant we can pick: &lt;code class=&quot;highlighter-rouge&quot;&gt;2^(-LGCOEFF)&lt;/code&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	initial	phase_correction = 0;
	always @(posedge i_clk)
		phase_correction &amp;lt;= {1&#39;b1,{(MSB){1&#39;b0}}} &amp;gt;&amp;gt; i_lgcoeff;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;We’ll show some charts later on illustrating how this coefficient changes
things.  In general, the larger &lt;code class=&quot;highlighter-rouge&quot;&gt;2^(-LGCOEFF)&lt;/code&gt; is,
the faster the loop will track any changes.  At the same time, larger values of
&lt;code class=&quot;highlighter-rouge&quot;&gt;2^(-LGCOEFF)&lt;/code&gt; will also cause the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Phase-locked_loop&quot;&gt;PLL&lt;/a&gt;
to pass any jitters in the incoming clock directly into the reconstructed
signal.&lt;/p&gt;

&lt;p&gt;Now with this information, we can adjust our
&lt;a href=&quot;https://en.wikipedia.org/wiki/Instantaneous_phase&quot;&gt;phase&lt;/a&gt;
value, &lt;code class=&quot;highlighter-rouge&quot;&gt;ctr&lt;/code&gt;, using what we now know.&lt;/p&gt;

&lt;p&gt;First, if there is no
&lt;a href=&quot;https://en.wikipedia.org/wiki/Instantaneous_phase&quot;&gt;phase&lt;/a&gt;
error, then all we need to do is to continue to step our
&lt;a href=&quot;https://en.wikipedia.org/wiki/Instantaneous_phase&quot;&gt;phase&lt;/a&gt;
forward at the &lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency&quot;&gt;frequency&lt;/a&gt; rate
&lt;a href=&quot;/dsp/2017/12/09/nco.html&quot;&gt;set by &lt;code class=&quot;highlighter-rouge&quot;&gt;r_step&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	initial	ctr = 0;
	always @(posedge i_clk)
		if (i_ce)
		begin
			// ...
			if (!phase_err)
				ctr &amp;lt;= ctr + r_step;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Otherwise, if &lt;code class=&quot;highlighter-rouge&quot;&gt;phase_err != 0&lt;/code&gt;, then the incoming and regenerated clocks didn’t
match.  In this case we’ll need to bump our counter a little more forward than
just a normal
&lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency&quot;&gt;frequency&lt;/a&gt;
step, or slow it down by a little less than the normal
&lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency&quot;&gt;frequency&lt;/a&gt;
step.  The difference between these two is going to be
based upon whether or not the &lt;code class=&quot;highlighter-rouge&quot;&gt;lead&lt;/code&gt; flag is true–as we discussed above.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;			else if (lead)
				ctr &amp;lt;= ctr + r_step - phase_correction;
			// ...
			else
				ctr &amp;lt;= ctr + r_step + phase_correction;
		end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;As a final step, we’ll place this counter on the output for examination
and/or re-use as desired.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	assign	o_phase = ctr;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;That’s all there is to the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Instantaneous_phase&quot;&gt;phase&lt;/a&gt;
correction step!  There’s no more black magic to it than the logic above.
Indeed, if you wanted to we could stop here and have a fully functional
&lt;a href=&quot;https://en.wikipedia.org/wiki/Phase-locked_loop&quot;&gt;PLL&lt;/a&gt;.
If the &lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency&quot;&gt;frequency&lt;/a&gt;
step, &lt;code class=&quot;highlighter-rouge&quot;&gt;r_step&lt;/code&gt;,
of that &lt;a href=&quot;https://en.wikipedia.org/wiki/Phase-locked_loop&quot;&gt;PLL&lt;/a&gt;
was close enough to the right value, then nothing more would need to be
done–this &lt;a href=&quot;https://en.wikipedia.org/wiki/Phase-locked_loop&quot;&gt;PLL&lt;/a&gt; would track
the &lt;a href=&quot;https://en.wikipedia.org/wiki/Instantaneous_phase&quot;&gt;phase&lt;/a&gt;
an incoming 1-bit clock signal.&lt;/p&gt;

&lt;p&gt;On the other hand, if you need (or want) to discover what
&lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency&quot;&gt;frequency&lt;/a&gt;
&lt;a href=&quot;/dsp/2017/12/09/nco.html&quot;&gt;step&lt;/a&gt;
to use (within reason, from a good initial guess), then you’ll want to add the
type-2 &lt;a href=&quot;https://en.wikipedia.org/wiki/Phase-locked_loop&quot;&gt;PLL&lt;/a&gt;
logic in the next section to the logic we just discussed above.&lt;/p&gt;

&lt;h2 id=&quot;a-logic-pll-type-2&quot;&gt;A Logic PLL: Type 2&lt;/h2&gt;

&lt;p&gt;In many cases when using a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Phase-locked_loop&quot;&gt;PLL&lt;/a&gt;,
you will want to track both the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency&quot;&gt;frequency&lt;/a&gt;
of the incoming signal as well as its
&lt;a href=&quot;https://en.wikipedia.org/wiki/Instantaneous_phase&quot;&gt;phase&lt;/a&gt;.
As we discussed in our
&lt;a href=&quot;/dsp/2017/12/09/nco.html&quot;&gt;NCO&lt;/a&gt;
article,
&lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency&quot;&gt;frequency&lt;/a&gt;
is represented as a regular change of
&lt;a href=&quot;https://en.wikipedia.org/wiki/Instantaneous_phase&quot;&gt;phase&lt;/a&gt;.
You may have noticed how we kept track of this above in &lt;code class=&quot;highlighter-rouge&quot;&gt;r_step&lt;/code&gt;.  If you want
to track
&lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency&quot;&gt;frequency&lt;/a&gt;
as well as
&lt;a href=&quot;https://en.wikipedia.org/wiki/Instantaneous_phase&quot;&gt;phase&lt;/a&gt;,
then you’ll want to adjust this &lt;code class=&quot;highlighter-rouge&quot;&gt;r_step&lt;/code&gt; value based upon the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Instantaneous_phase&quot;&gt;phase&lt;/a&gt;
error as well.  Such a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Phase-locked_loop&quot;&gt;PLL&lt;/a&gt;
that tracks
&lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency&quot;&gt;frequency&lt;/a&gt;
as well as
&lt;a href=&quot;https://en.wikipedia.org/wiki/Instantaneous_phase&quot;&gt;phase&lt;/a&gt;
is called a type-2
&lt;a href=&quot;https://en.wikipedia.org/wiki/Phase-locked_loop&quot;&gt;PLL&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The basic means of extending the type-1
&lt;a href=&quot;https://en.wikipedia.org/wiki/Phase-locked_loop&quot;&gt;PLL&lt;/a&gt;
into a type-2
&lt;a href=&quot;https://en.wikipedia.org/wiki/Phase-locked_loop&quot;&gt;PLL&lt;/a&gt;
is to multiply the
(optionally) &lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filtered&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Instantaneous_phase&quot;&gt;phase&lt;/a&gt;
error by a constant and then adjust the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Instantaneous_phase&quot;&gt;phase&lt;/a&gt;
step due to &lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency&quot;&gt;frequency&lt;/a&gt;, i.e.
the &lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency&quot;&gt;frequency&lt;/a&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;r_step&lt;/code&gt;, by that amount.  This basic logic is shown below in addition
to the type-1 logic we developed above.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 6. The additional type-2 frequency tracking logic&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/pll-type-2-open-loop.svg&quot; alt=&quot;&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Up until this point, there hasn’t been much black magic.  We’ve just pushed
a counter forward or backwards by some nominal amount based upon the sign of
a measured &lt;a href=&quot;https://en.wikipedia.org/wiki/Instantaneous_phase&quot;&gt;phase&lt;/a&gt;
error.  Here, though, I’m going to introduce the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency&quot;&gt;frequency&lt;/a&gt;
adjustment coefficient, &lt;code class=&quot;highlighter-rouge&quot;&gt;1/4 2^(-2LGCOEFF)&lt;/code&gt;, that I’m not going to derive
today.  This particular coefficient is designed to make sure this
&lt;a href=&quot;https://en.wikipedia.org/wiki/Phase-locked_loop&quot;&gt;PLL&lt;/a&gt;
is &lt;a href=&quot;https://en.wikipedia.org/wiki/Damping_ratio&quot;&gt;critically damped&lt;/a&gt;.
Practically, this just means that this
&lt;a href=&quot;https://en.wikipedia.org/wiki/Phase-locked_loop&quot;&gt;PLL&lt;/a&gt;
will converge faster than any other
&lt;a href=&quot;https://en.wikipedia.org/wiki/Phase-locked_loop&quot;&gt;PLL&lt;/a&gt;
having a &lt;a href=&quot;https://en.wikipedia.org/wiki/Instantaneous_phase&quot;&gt;phase&lt;/a&gt;
correction coefficient of &lt;code class=&quot;highlighter-rouge&quot;&gt;2^(-LGCOEFF)&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;That’s a good thing.&lt;/p&gt;

&lt;p&gt;Hence, our &lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency&quot;&gt;frequency&lt;/a&gt;
correction constant is given by,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	initial	freq_correction = 0;
	always @(posedge i_clk)
		freq_correction &amp;lt;= { 3&#39;b001, {(MSB-2){1&#39;b0}} } &amp;gt;&amp;gt; (2*i_lgcoeff);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;So, how shall we update our step?  First, we’ll allow this number to be
loaded–so that you can set what
&lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency&quot;&gt;frequency&lt;/a&gt;
you expect
&lt;a href=&quot;https://github.com/ZipCPU/dpll/blob/master/rtl/sdpll.v&quot;&gt;this PLL&lt;/a&gt;
to converge around.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(posedge i_clk)
		if (i_ld)
			r_step &amp;lt;= { 1&#39;b0, i_step };&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Likewise, we’ll use the parameter,
&lt;code class=&quot;highlighter-rouge&quot;&gt;OPT_TRACK_FREQUENCY&lt;/code&gt;, to control whether or not
&lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency&quot;&gt;frequency&lt;/a&gt;
tracking is enabled.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;		else if ((OPT_TRACK_FREQUENCY)&amp;amp;&amp;amp;(phase_err))
		begin&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Beyond that, any time we need to slow down, we’ll subtract this
&lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency&quot;&gt;frequency&lt;/a&gt;
correction value and any time we need to speed up we’ll add this
&lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency&quot;&gt;frequency&lt;/a&gt;
correction value.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;			if (lead)
				r_step &amp;lt;= r_step - freq_correction;
			else
				r_step &amp;lt;= r_step + freq_correction;
		end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;You can find all of this code in the
&lt;a href=&quot;https://github.com/ZipCPU/dpll/blob/master/rtl/sdpll.v&quot;&gt;sdpll.v&lt;/a&gt;
file within my new repository holding demonstration
&lt;a href=&quot;https://en.wikipedia.org/wiki/Phase-locked_loop&quot;&gt;PLL&lt;/a&gt;
implementations.&lt;/p&gt;

&lt;h2 id=&quot;performance&quot;&gt;Performance&lt;/h2&gt;

&lt;p&gt;Shall we see how well
&lt;a href=&quot;https://github.com/ZipCPU/dpll/blob/master/rtl/sdpll.v&quot;&gt;this PLL&lt;/a&gt;
performs?&lt;/p&gt;

&lt;p&gt;You can find a
&lt;a href=&quot;https://veripool.org/wiki/verilator&quot;&gt;Verilator&lt;/a&gt;
based
&lt;a href=&quot;/blog/2017/06/21/looking-at-verilator.html&quot;&gt;test bench&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/dpll/blob/master/bench/cpp/sdpll_tb.cpp&quot;&gt;here, called sdpll_tb.cpp&lt;/a&gt;.
This &lt;a href=&quot;https://github.com/ZipCPU/dpll/blob/master/bench/cpp/sdpll_tb.cpp&quot;&gt;test bench
code&lt;/a&gt;
primarily
works by starting with a set of initial conditions and then running the
&lt;a href=&quot;https://github.com/ZipCPU/dpll/blob/master/rtl/sdpll.v&quot;&gt;PLL&lt;/a&gt;
to see what happens.  Unlike most of my test benches, there’s no &lt;code class=&quot;highlighter-rouge&quot;&gt;SUCCESS&lt;/code&gt;
output at the end of
&lt;a href=&quot;https://github.com/ZipCPU/dpll/blob/master/bench/cpp/sdpll_tb.cpp&quot;&gt;this test bench&lt;/a&gt;
to indicate that it &lt;em&gt;worked&lt;/em&gt;.  Instead, the
&lt;a href=&quot;https://github.com/ZipCPU/dpll/blob/master/bench/cpp/sdpll_tb.cpp&quot;&gt;test bench&lt;/a&gt;
will print &lt;code class=&quot;highlighter-rouge&quot;&gt;Simulation complete&lt;/code&gt; to indicate that it
to completion–you’ll still need to check the results produced by &lt;a href=&quot;https://github.com/ZipCPU/dpll/blob/master/bench/cpp/sdpll_tb.cpp&quot;&gt;the
simulation&lt;/a&gt;
to know if it worked.&lt;/p&gt;

&lt;p&gt;For our purpose today, I’ve chosen to use a random
&lt;a href=&quot;https://en.wikipedia.org/wiki/Instantaneous_phase&quot;&gt;phase&lt;/a&gt;.
for our initial condition, together with a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency&quot;&gt;frequency&lt;/a&gt;
that’s about five system clocks per input clock.  Where the
test setup gets interesting is the fact that we’ll start by loading the
&lt;a href=&quot;https://github.com/ZipCPU/dpll/blob/master/rtl/sdpll.v&quot;&gt;PLL&lt;/a&gt;
with a &lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency&quot;&gt;frequency&lt;/a&gt;
that’s too fast by about 12%.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;	&lt;span class=&quot;n&quot;&gt;tb&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i_lgcoeff&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;6&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;lclphase&lt;/span&gt;     &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rand&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;lclstep&lt;/span&gt;      &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x31415928&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;tb&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i_step&lt;/span&gt;    &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lclstep&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lclstep&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Too fast
&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;tb&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i_ld&lt;/span&gt;      &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;tb&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i_clk&lt;/span&gt;     &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;tb&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i_ce&lt;/span&gt;      &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Then, within the
&lt;a href=&quot;https://veripool.org/wiki/verilator&quot;&gt;Verilator&lt;/a&gt;
per-clock loop,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;	&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;65536&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;32&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;tb&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;eval&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;tfp&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dump&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;8&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;tb&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i_clk&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;tb&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;eval&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;tfp&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dump&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;tb&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i_clk&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;tb&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;eval&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;tfp&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dump&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;15&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;we’ll record several performance numbers.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;		&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
			&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;od&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;6&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;od&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lclphase&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;od&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tb&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v__DOT__r_step&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;od&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tb&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i_input&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;od&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tb&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;o_err&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
			&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;od&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
				&lt;span class=&quot;n&quot;&gt;od&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;od&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tb&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v__DOT__ctr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;od&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tb&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v__DOT__ctr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lclphase&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;od&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;6&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tb&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;o_dbg&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;32&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;od&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;6&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;32&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

			&lt;span class=&quot;n&quot;&gt;fwrite&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;od&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;7&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;intfp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;These are …&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;The local simulation
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sine_wave&quot;&gt;sine wave&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Instantaneous_phase&quot;&gt;phase&lt;/a&gt;
that’s driving &lt;a href=&quot;https://github.com/ZipCPU/dpll/blob/master/bench/cpp/sdpll_tb.cpp&quot;&gt;the
test&lt;/a&gt;,
&lt;code class=&quot;highlighter-rouge&quot;&gt;lclphase&lt;/code&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The &lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency&quot;&gt;frequency&lt;/a&gt;
step from within the
&lt;a href=&quot;https://github.com/ZipCPU/dpll/blob/master/rtl/sdpll.v&quot;&gt;the PLL&lt;/a&gt;,
&lt;code class=&quot;highlighter-rouge&quot;&gt;r_step&lt;/code&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The incoming input signal to
&lt;a href=&quot;https://github.com/ZipCPU/dpll/blob/master/rtl/sdpll.v&quot;&gt;the PLL&lt;/a&gt;,
&lt;code class=&quot;highlighter-rouge&quot;&gt;i_input&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The error signal, &lt;code class=&quot;highlighter-rouge&quot;&gt;o_err&lt;/code&gt;, created by
&lt;a href=&quot;https://github.com/ZipCPU/dpll/blob/master/rtl/sdpll.v&quot;&gt;the PLL&lt;/a&gt;,
and interpreted here as a signed value&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The internal
&lt;a href=&quot;https://github.com/ZipCPU/dpll/blob/master/rtl/sdpll.v&quot;&gt;PLL&lt;/a&gt;
counter, &lt;code class=&quot;highlighter-rouge&quot;&gt;ctr&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The difference between the internal
&lt;a href=&quot;https://github.com/ZipCPU/dpll/blob/master/rtl/sdpll.v&quot;&gt;PLL&lt;/a&gt;
counter, &lt;code class=&quot;highlighter-rouge&quot;&gt;ctr&lt;/code&gt; and the
&lt;a href=&quot;https://github.com/ZipCPU/dpll/blob/master/bench/cpp/sdpll_tb.cpp&quot;&gt;simulation&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Instantaneous_phase&quot;&gt;phase&lt;/a&gt;,
&lt;code class=&quot;highlighter-rouge&quot;&gt;lclphase&lt;/code&gt;, truncated to the number of
&lt;a href=&quot;https://en.wikipedia.org/wiki/Instantaneous_phase&quot;&gt;phase&lt;/a&gt;
error bits (32)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Finally, a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filtered&lt;/a&gt;
error output signal, &lt;code class=&quot;highlighter-rouge&quot;&gt;o_dbg&lt;/code&gt;.  This signal isn’t really part of our
&lt;a href=&quot;https://github.com/ZipCPU/dpll/blob/master/rtl/sdpll.v&quot;&gt;PLL&lt;/a&gt;
implementation, but since I already had
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/boxcar.v&quot;&gt;the filter&lt;/a&gt;
lying around from a
&lt;a href=&quot;/dsp/2017/10/16/boxcar.html&quot;&gt;previous post&lt;/a&gt;
it made sense to re-use it here.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;At the end of the loop, and so once per clock, we’ll update our
&lt;a href=&quot;https://github.com/ZipCPU/dpll/blob/master/bench/cpp/sdpll_tb.cpp&quot;&gt;simulation&lt;/a&gt;
&lt;a href=&quot;/dsp/2017/12/09/nco.html&quot;&gt;phase accumulator&lt;/a&gt;,
&lt;code class=&quot;highlighter-rouge&quot;&gt;lclphase&lt;/code&gt;, and create the next input for &lt;a href=&quot;https://github.com/ZipCPU/dpll/blob/master/rtl/sdpll.v&quot;&gt;the
PLL&lt;/a&gt;
to act upon.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;		&lt;span class=&quot;n&quot;&gt;tb&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i_ld&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;tb&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i_clk&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;lclphase&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lclstep&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;tb&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i_input&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lclphase&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;31&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Now that we have 
&lt;a href=&quot;https://github.com/ZipCPU/dpll/blob/master/rtl/sdpll.v&quot;&gt;this PLL&lt;/a&gt;
instrumented, we can answer the question of,
how well does &lt;a href=&quot;https://github.com/ZipCPU/dpll/blob/master/rtl/sdpll.v&quot;&gt;this PLL&lt;/a&gt;
work?&lt;/p&gt;

&lt;p&gt;While we could look at the error output of the PLL, as shown in Fig 7,&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 7. Output phase error&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/dpll-chart-oerr.png&quot; alt=&quot;&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;the result isn’t really all that meaningful.&lt;/p&gt;

&lt;p&gt;Sadly, because the error is a discretized signal of -1, 0, or 1, it’s rather
difficult to get a good feel for what is going on.  Clearly there’s more
error on the left side, but by how much?&lt;/p&gt;

&lt;p&gt;So, instead, let’s compare the difference between the
&lt;a href=&quot;https://github.com/ZipCPU/dpll/blob/master/bench/cpp/sdpll_tb.cpp&quot;&gt;simulation&lt;/a&gt;’s
internal &lt;code class=&quot;highlighter-rouge&quot;&gt;lclphase&lt;/code&gt; variable and the
&lt;a href=&quot;https://github.com/ZipCPU/dpll/blob/master/rtl/sdpll.v&quot;&gt;reconstructed&lt;/a&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;ctr&lt;/code&gt; value.  This is shown in Fig 8 as the &lt;em&gt;actual phase error&lt;/em&gt;.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 8. Actual phase error&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/dpll-chart-actual-perr.png&quot; alt=&quot;&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;This is more revealing.  Here we can see that the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Instantaneous_phase&quot;&gt;phase&lt;/a&gt; difference on the
left side of the chart is wandering all over the place.  Why?  Because
&lt;a href=&quot;https://github.com/ZipCPU/dpll/blob/master/rtl/sdpll.v&quot;&gt;the PLL&lt;/a&gt;
has yet to lock.  Eventually, it comes to a locked position and then the
error settles out into a steady state.&lt;/p&gt;

&lt;p&gt;Where this gets fascinating, though, is if you evaluate the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Instantaneous_phase&quot;&gt;phase&lt;/a&gt;
error of
&lt;a href=&quot;https://github.com/ZipCPU/dpll/blob/master/rtl/sdpll.v&quot;&gt;the PLL&lt;/a&gt;
across multiple coefficient choices.  We’ll try
&lt;code class=&quot;highlighter-rouge&quot;&gt;i_lgcoeff&lt;/code&gt; ranging from &lt;code class=&quot;highlighter-rouge&quot;&gt;4&lt;/code&gt; to &lt;code class=&quot;highlighter-rouge&quot;&gt;6&lt;/code&gt;, and plot the results in Fig 9.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 9. Actual phase error&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/dpll-chart-actual-perr2.png&quot; alt=&quot;&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;There’s a couple of things to notice in Fig 9.  First, the larger the
coefficient (i.e. the smaller &lt;code class=&quot;highlighter-rouge&quot;&gt;i_lgcoeff&lt;/code&gt;), the faster
&lt;a href=&quot;https://github.com/ZipCPU/dpll/blob/master/rtl/sdpll.v&quot;&gt;the PLL&lt;/a&gt;
converges.  However,
&lt;a href=&quot;https://github.com/ZipCPU/dpll/blob/master/rtl/sdpll.v&quot;&gt;the PLL&lt;/a&gt;
doesn’t settle as nicely when &lt;code class=&quot;highlighter-rouge&quot;&gt;i_lgcoeff&lt;/code&gt; is &lt;code class=&quot;highlighter-rouge&quot;&gt;4&lt;/code&gt; compared to how it settles
when &lt;code class=&quot;highlighter-rouge&quot;&gt;i_lgcoeff&lt;/code&gt; is &lt;code class=&quot;highlighter-rouge&quot;&gt;6&lt;/code&gt;.  On the other hand, even though the smaller
values of &lt;code class=&quot;highlighter-rouge&quot;&gt;2^(-i_lgcoeff)&lt;/code&gt; take longer to converge, once they do converge
the remaining residual error is much smaller.&lt;/p&gt;

&lt;p&gt;We can also return to
&lt;a href=&quot;https://github.com/ZipCPU/dpll/blob/master/rtl/sdpll.v&quot;&gt;the PLL&lt;/a&gt;’s
&lt;a href=&quot;https://en.wikipedia.org/wiki/Instantaneous_phase&quot;&gt;phase&lt;/a&gt;
error output and average it using a 3839 point
&lt;a href=&quot;/dsp/2017/10/16/boxcar.html&quot;&gt;boxcar filter&lt;/a&gt;.
(There is no particular significance to this number, 3839.  Feel free to
try other amounts if you would like.)
This will help to accumulate the errors long enough to draw a conclusion
from them.  You can see this result in Fig 10.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 10. Filtered Phase Error&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/dpll-chart-averr2.png&quot; alt=&quot;&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;The first conclusion to draw from Fig 10 is that we
&lt;a href=&quot;/dsp/2017/10/16/boxcar.html&quot;&gt;averaged&lt;/a&gt;
too many sample points together for &lt;code class=&quot;highlighter-rouge&quot;&gt;i_lgcoeff=4&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;i_lgcoeff=5&lt;/code&gt;.  This is
seen by the fact that the filtered error signals appear like negative rectangle
functions.  In spite of this artifact, you can see that the
&lt;code class=&quot;highlighter-rouge&quot;&gt;i_lgcoeff=6&lt;/code&gt; trace accumulates a much larger error before it finally locks.
Further, when each of these traces gets to the locked condition, they &lt;em&gt;suddenly&lt;/em&gt;
go to zero.  Finally, as before with the residual error, the &lt;code class=&quot;highlighter-rouge&quot;&gt;i_lgcoeff=6&lt;/code&gt; ends
up with smaller residual error.  (This is harder to see on the chart.)&lt;/p&gt;

&lt;p&gt;The last variable to consider is the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency&quot;&gt;frequency&lt;/a&gt;
step size.  Remember, we started
&lt;a href=&quot;https://github.com/ZipCPU/dpll/blob/master/rtl/sdpll.v&quot;&gt;this PLL&lt;/a&gt;
with a &lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency&quot;&gt;frequency&lt;/a&gt;
value that was about 12% too fast.  Hence, the step size
needs to come down a bit.  In Fig 11, you can see the step size, &lt;code class=&quot;highlighter-rouge&quot;&gt;r_step&lt;/code&gt;,
coming down for all three traces until the respective
&lt;a href=&quot;https://github.com/ZipCPU/dpll/blob/master/rtl/sdpll.v&quot;&gt;PLL&lt;/a&gt;’s
lock.  Once lock has been achieved, the traces appear to flatten out.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 11. Frequency Step&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/dpll-chart-fstep2.png&quot; alt=&quot;&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;However, as before, the &lt;code class=&quot;highlighter-rouge&quot;&gt;i_lgcoeff=4&lt;/code&gt; trace has the most noise on it following
convergence, whereas the &lt;code class=&quot;highlighter-rouge&quot;&gt;i_lgcoeff=6&lt;/code&gt; trace has less noise.&lt;/p&gt;

&lt;p&gt;Together, these charts should be sufficient to not only demonstrate that
&lt;a href=&quot;https://github.com/ZipCPU/dpll/blob/master/rtl/sdpll.v&quot;&gt;this PLL&lt;/a&gt;
implementation “works”, but also to give you an indication as to &lt;em&gt;how well&lt;/em&gt;
it works.&lt;/p&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;Building a &lt;a href=&quot;https://en.wikipedia.org/wiki/Phase-locked_loop&quot;&gt;PLL&lt;/a&gt; doesn’t
need to be the black art I once thought it was.  All of the parts and pieces
have fairly simple definitions, and
&lt;a href=&quot;https://github.com/ZipCPU/dpll/blob/master/rtl/sdpll.v&quot;&gt;the implementation&lt;/a&gt;
of this simple
&lt;a href=&quot;https://en.wikipedia.org/wiki/Phase-locked_loop&quot;&gt;PLL&lt;/a&gt;
really wasn’t all that complex.  Even better, since I’ve posted
&lt;a href=&quot;https://github.com/ZipCPU/dpll/blob/master/rtl/sdpll.v&quot;&gt;this code&lt;/a&gt;
on &lt;a href=&quot;https://github.com/ZipCPU&quot;&gt;GitHub&lt;/a&gt;, you are welcome to try it out yourself
to see how well (or poorly) it works for your problem set.&lt;/p&gt;

&lt;p&gt;Of course, I haven’t exhausted the topic of
either &lt;a href=&quot;https://en.wikipedia.org/wiki/Phase-locked_loop&quot;&gt;PLL&lt;/a&gt; design or
analysis–I’ve just presented a single 
&lt;a href=&quot;https://en.wikipedia.org/wiki/Phase-locked_loop&quot;&gt;PLL&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/dpll/blob/master/rtl/sdpll.v&quot;&gt;implementation&lt;/a&gt;
that has worked well for me over many years.  As examples of some of the things
we haven’t discussed:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;There’s a real reason and theory behind why we chose the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency&quot;&gt;frequency&lt;/a&gt;
correction value we did.  Perhaps if someone is interested, I could go
through this theory.  Be prepared, though, it depends upon a solid
understanding of &lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency&quot;&gt;&lt;em&gt;Z&lt;/em&gt; transforms&lt;/a&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;You may also remember that I skipped the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Instantaneous_phase&quot;&gt;phase&lt;/a&gt; error
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;s
in this implementation.  While a simple
&lt;a href=&quot;/dsp/2017/08/19/simple-filter.html&quot;&gt;recursive average&lt;/a&gt;
filter works nicely, the
&lt;a href=&quot;/dsp/2017/08/19/simple-filter.html&quot;&gt;recursive average&lt;/a&gt;
coefficient couples with the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Instantaneous_phase&quot;&gt;phase&lt;/a&gt;
and &lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency&quot;&gt;frequency&lt;/a&gt;
correction coefficients of the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Phase-locked_loop&quot;&gt;PLL&lt;/a&gt;,
necessitating a change to how these coefficients need to be calculated
should you go this route.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The actual study and analysis of
&lt;a href=&quot;https://en.wikipedia.org/wiki/Phase-locked_loop&quot;&gt;PLL&lt;/a&gt;s
includes a study of how to predict many of the charts I presented above
in Figures 7-11.  While it’s a valuable study that I would commend to anyone
interested, it’s not required to understand any of the figures.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Further, I know I said
that &lt;a href=&quot;https://en.wikipedia.org/wiki/Phase-locked_loop&quot;&gt;PLL&lt;/a&gt;s could be used for
clock recovery.  While
&lt;a href=&quot;https://github.com/ZipCPU/dpll/blob/master/rtl/sdpll.v&quot;&gt;today’s logic PLL&lt;/a&gt;
implements a valuable circuit that can handle that task,
you may find that the hardware implemented 
&lt;a href=&quot;https://en.wikipedia.org/wiki/Phase-locked_loop&quot;&gt;PLL&lt;/a&gt;s within your
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
are much more appropriate for this purpose than the
&lt;a href=&quot;https://github.com/ZipCPU/dpll/blob/master/rtl/sdpll.v&quot;&gt;PLL we designed today&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Finally, this isn’t the last word on
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Phase-locked_loop&quot;&gt;PLL&lt;/a&gt; implementation.
Other &lt;a href=&quot;https://en.wikipedia.org/wiki/Phase-locked_loop&quot;&gt;PLL&lt;/a&gt; implementations
are also valuable, such as the more traditional
(non-&lt;a href=&quot;https://en.wikipedia.org/wiki/Boolean_algebra&quot;&gt;binary&lt;/a&gt;)
&lt;a href=&quot;https://en.wikipedia.org/wiki/Phase-locked_loop&quot;&gt;PLL&lt;/a&gt; implementations,
or even logic &lt;a href=&quot;https://en.wikipedia.org/wiki/Phase-locked_loop&quot;&gt;PLL&lt;/a&gt;s
designed to run at many samples per clock.  These will need to remain a
topic for future posts.&lt;/p&gt;
&lt;hr /&gt;&lt;p&gt;&lt;em&gt;But the men marvelled, saying, What manner of man is this, that even the winds and the sea obey him! (Matt 8:24)&lt;/em&gt;</description>
        <pubDate>Thu, 14 Dec 2017 00:00:00 -0500</pubDate>
        <link>http://zipcpu.com/dsp/2017/12/14/logic-pll.html</link>
        <guid isPermaLink="true">http://zipcpu.com/dsp/2017/12/14/logic-pll.html</guid>
        
        
        <category>dsp</category>
        
      </item>
    
      <item>
        <title>Building a Numerically Controlled Oscillator</title>
        <description>&lt;p&gt;Many &lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_signal_processing&quot;&gt;signal
processing&lt;/a&gt;
applications require a &lt;a href=&quot;https://en.wikipedia.org/wiki/Sine_wave&quot;&gt;sine wave&lt;/a&gt;
at some point.  If the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Instantaneous_phase&quot;&gt;phase&lt;/a&gt;
or
&lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency&quot;&gt;frequency&lt;/a&gt;
of this
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sine_wave&quot;&gt;sine wave&lt;/a&gt;
is controlled within the design, then it is often called a &lt;a href=&quot;https://en.wikipedia.org/wiki/Numerically_controlled_oscillator&quot;&gt;Numerically
Controlled Oscillator
(NCO)&lt;/a&gt;. 
Let’s spend some time today looking into how you might build
one of these within an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;.  We’ll
also present a C++ implementation at the end as well, which may be used
in embedded &lt;a href=&quot;https://en.wikipedia.org/wiki/Embedded_system&quot;&gt;embedded&lt;/a&gt;
applications.&lt;/p&gt;

&lt;p&gt;Since we’ve already studied how to generate a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sine_wave&quot;&gt;sine wave&lt;/a&gt;
on an &lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;,
most of our work is already done: We’ve discussed a &lt;a href=&quot;/dsp/2017/07/11/simplest-sinewave-generator.html&quot;&gt;table lookup
method&lt;/a&gt;,
a &lt;a href=&quot;/dsp/2017/08/26/quarterwave.html&quot;&gt;quarter wave table
lookup&lt;/a&gt;,
method, and even how to generate both
a &lt;a href=&quot;https://en.wikipedia.org/wiki/Sine_wave&quot;&gt;sine wave&lt;/a&gt; and a cosine wave using a
&lt;a href=&quot;/dsp/2017/08/30/cordic.html&quot;&gt;CORDIC&lt;/a&gt;.
The subtle difference to describe to day is really how to turn such a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sine_wave&quot;&gt;sine wave&lt;/a&gt;
generator into a 
&lt;a href=&quot;https://en.wikipedia.org/wiki/Numerically_controlled_oscillator&quot;&gt;NCO&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Before we dive into the details, though, let’s spend a moment thinking about
how you might use such an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Numerically_controlled_oscillator&quot;&gt;NCO&lt;/a&gt;.
My own reason for presenting this today is twofold.  First, I know of a student
struggling to understand how to build something like this as part of a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Data_transmission&quot;&gt;digital communications&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Demodulation&quot;&gt;demodulator&lt;/a&gt;.
There is a small trick involved–one that appears to be well known among those
who do this sort of thing for a living, but not so well known among students and
I’d like to share it here.  Indeed, I think we might even build a better
&lt;a href=&quot;https://en.wikipedia.org/wiki/Numerically_controlled_oscillator&quot;&gt;NCO&lt;/a&gt; below
than &lt;a href=&quot;https://stackoverflow.com/questions/13466623/how-to-look-up-sine-of-different-frequencies-from-a-fixed-size-lookup-table&quot;&gt;this stackoverflow article&lt;/a&gt;
recommends.  My second reason for writing today is that I’d like to write about
how to build a &lt;a href=&quot;https://en.wikipedia.org/wiki/Phase-locked_loop&quot;&gt;Phase Locked Loop
(PLL)&lt;/a&gt;
within an &lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
on &lt;a href=&quot;http://zipcpu.com/&quot;&gt;this blog&lt;/a&gt;,
and every &lt;a href=&quot;https://en.wikipedia.org/wiki/Phase-locked_loop&quot;&gt;PLL&lt;/a&gt;
I’ve ever built has always included the basic
&lt;a href=&quot;https://en.wikipedia.org/wiki/Numerically_controlled_oscillator&quot;&gt;NCO&lt;/a&gt;
logic as part of &lt;a href=&quot;https://github.com/ZipCPU/dpll/blob/master/rtl/sdpll.v&quot;&gt;its
implementation&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;But this hardly scratches the surface of what you might do with an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Numerically_controlled_oscillator&quot;&gt;NCO&lt;/a&gt;.
Consider as an example that …&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Any linear signal processing system is completely characterized by its
&lt;a href=&quot;/dsp/2017/11/22/fltr-response.html&quot;&gt;frequency response&lt;/a&gt;.
As a result, I’ve used an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Numerically_controlled_oscillator&quot;&gt;NCO&lt;/a&gt;
in time past, together with a scope of some type, to evaluate whether the
digital input to a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_signal_processing&quot;&gt;signal processing&lt;/a&gt;
algorithm was being handled properly.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;We used an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Numerically_controlled_oscillator&quot;&gt;NCO&lt;/a&gt;
earlier as part of
&lt;a href=&quot;/dsp/2017/09/16/pwm-demo.html&quot;&gt;our demonstration&lt;/a&gt;
that the &lt;a href=&quot;/dsp/2017/09/04/pwm-reinvention.html&quot;&gt;improved PWM
generator&lt;/a&gt;
worked better than a traditional
&lt;a href=&quot;https://en.wikipedia.org/wiki/Pulse-width_modulation&quot;&gt;PWM&lt;/a&gt; for audio
signal generation.  While we didn’t discuss the details of the tone generator
at the time, we’ll explain many of those details today.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;You can also use an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Numerically_controlled_oscillator&quot;&gt;NCO&lt;/a&gt;
to move a signal around in
&lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency&quot;&gt;frequency&lt;/a&gt;–either bringing it
down from some
&lt;a href=&quot;https://en.wikipedia.org/wiki/Intermediate_frequency&quot;&gt;intermediate frequency (IF)&lt;/a&gt;
to a &lt;a href=&quot;https://en.wikipedia.org/wiki/Baseband&quot;&gt;baseband&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency&quot;&gt;frequency&lt;/a&gt;
where you can process it in
a &lt;a href=&quot;https://en.wikipedia.org/wiki/Radio_receiver&quot;&gt;receiver&lt;/a&gt;,
or the same in the other direction as part of a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Transmitter&quot;&gt;transmission&lt;/a&gt; algorithm.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;You can also use an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Numerically_controlled_oscillator&quot;&gt;NCO&lt;/a&gt;
as part of either a digital communications
&lt;a href=&quot;https://en.wikipedia.org/wiki/Modulation&quot;&gt;modulator&lt;/a&gt;
or &lt;a href=&quot;https://en.wikipedia.org/wiki/Demodulation&quot;&gt;demodulator&lt;/a&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;You can use an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Numerically_controlled_oscillator&quot;&gt;NCO&lt;/a&gt; to
create an &lt;a href=&quot;https://en.wikipedia.org/wiki/Amplitude_modulation&quot;&gt;Amplitude
Modulated (AM)&lt;/a&gt;
signal, or even a &lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency_modulation&quot;&gt;Frequency
Modulated (FM)&lt;/a&gt; signal.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Another common use is to generate musical notes via
an &lt;a href=&quot;https://en.wikipedia.org/wiki/Synthesizer&quot;&gt;additive synthesizer&lt;/a&gt;.  Indeed,
the &lt;a href=&quot;https://en.wikipedia.org/wiki/Instantaneous_phase&quot;&gt;phase&lt;/a&gt; accumulator
portion of the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Numerically_controlled_oscillator&quot;&gt;NCO&lt;/a&gt;
we’ll develop below can even be used in
&lt;a href=&quot;https://en.wikipedia.org/wiki/Synthesizer&quot;&gt;subtractive synthesis&lt;/a&gt;–it’s quite
generic.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Finally, because you as the designer have &lt;em&gt;complete&lt;/em&gt; control over the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency&quot;&gt;frequency&lt;/a&gt; output of the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Numerically_controlled_oscillator&quot;&gt;NCO&lt;/a&gt;,
you can even do some more exotic things–such as building a &lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency-hopping_spread_spectrum&quot;&gt;frequency
hopping&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Spread_spectrum&quot;&gt;spread spectrum&lt;/a&gt;
signal–should this be what you wish to do.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Indeed, &lt;a href=&quot;https://en.wikipedia.org/wiki/Numerically_controlled_oscillator&quot;&gt;NCO&lt;/a&gt;s
are such fundamental components of &lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_signal_processing&quot;&gt;Digital Signal Processing
(DSP)&lt;/a&gt;
algorithms that it is difficult to enumerate &lt;em&gt;all&lt;/em&gt; the things they can
be used for here.&lt;/p&gt;

&lt;h2 id=&quot;what-is-an-nco&quot;&gt;What is an NCO?&lt;/h2&gt;

&lt;table style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 1. NCO&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/nco-block.svg&quot; alt=&quot;NCO transforms a frequency input into a sinewave&quot; width=&quot;360&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;For our purpose today, a &lt;a href=&quot;https://en.wikipedia.org/wiki/Numerically_controlled_oscillator&quot;&gt;Numerically Controlled
Oscillator&lt;/a&gt;
is simply an oscillator created from digital logic that you have complete
control over digitally.
Nominally, such an oscillator will receive as an input the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency&quot;&gt;frequency&lt;/a&gt;
you wish to produce and it will produce a digitally sampled
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sine_wave&quot;&gt;sine wave&lt;/a&gt;
at that &lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency&quot;&gt;frequency&lt;/a&gt;.
Should you choose to use an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Numerically_controlled_oscillator&quot;&gt;NCO&lt;/a&gt;
within a &lt;a href=&quot;https://en.wikipedia.org/wiki/Phase-locked_loop&quot;&gt;PLL&lt;/a&gt;,
then you will also be adjusting the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Instantaneous_phase&quot;&gt;phase&lt;/a&gt;
of this &lt;a href=&quot;https://en.wikipedia.org/wiki/Sine_wave&quot;&gt;sine wave&lt;/a&gt;
generator.  For now, however, consider an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Numerically_controlled_oscillator&quot;&gt;NCO&lt;/a&gt;
to be a simple digital logic circuit that takes a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency&quot;&gt;frequency&lt;/a&gt;
input and produces a sampled
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sine_wave&quot;&gt;sine wave&lt;/a&gt;
as an output.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 2. Block Diagram&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/nco-components.svg&quot; alt=&quot;The components of a basic NCO&quot; width=&quot;540&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Internally, the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Numerically_controlled_oscillator&quot;&gt;NCO&lt;/a&gt;
keeps track of the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Instantaneous_phase&quot;&gt;phase&lt;/a&gt; of the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sine_wave&quot;&gt;sine wave&lt;/a&gt;
it produces, and it increments this
&lt;a href=&quot;https://en.wikipedia.org/wiki/Instantaneous_phase&quot;&gt;phase&lt;/a&gt;
at each sample point.&lt;/p&gt;

&lt;p&gt;Let’s walk through a little bit of trigonometry, to see how this works.&lt;/p&gt;

&lt;p&gt;We’ll start with the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sine_wave&quot;&gt;sine wave&lt;/a&gt;
that we want to produce, such as the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sine_wave&quot;&gt;sine wave&lt;/a&gt;
shown in Fig 3,&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 3. A pure sinewave&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/nco-pure-tone.png&quot; alt=&quot;Picture of x(t) = sine(2pi ft)&quot; width=&quot;540&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;and is given by the equation,&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/eqn-sinewave-xt.png&quot; alt=&quot;x(t) = sin(2pi ft)&quot; width=&quot;189&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Since digital implementations can only work on
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;sampled signals&lt;/a&gt;,
we’ll need to sample this &lt;a href=&quot;https://en.wikipedia.org/wiki/Sine_wave&quot;&gt;sine wave&lt;/a&gt;
every &lt;code class=&quot;highlighter-rouge&quot;&gt;Ts&lt;/code&gt; seconds.  To keep our notation straight,
we’ll now index this &lt;a href=&quot;https://en.wikipedia.org/wiki/Sine_wave&quot;&gt;sine wave&lt;/a&gt;
output by &lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;sample&lt;/a&gt;
number, &lt;code class=&quot;highlighter-rouge&quot;&gt;n&lt;/code&gt;, rather than by time, &lt;code class=&quot;highlighter-rouge&quot;&gt;t&lt;/code&gt;.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/eqn-sinewave-xnts.png&quot; alt=&quot;x[n] = sin(2pi (nTs) f)&quot; width=&quot;241&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;I personally find it easier to work with the &lt;em&gt;sample rate&lt;/em&gt; of the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital-to-analog_converter&quot;&gt;digitizer&lt;/a&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;fs&lt;/code&gt;
rather than the &lt;em&gt;time between samples&lt;/em&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;Ts&lt;/code&gt;.  &lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency&quot;&gt;These are reciprocals of each
other&lt;/a&gt;, so &lt;code class=&quot;highlighter-rouge&quot;&gt;fs = 1/Ts&lt;/code&gt;.  We can then
express this same equation as,&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/eqn-sinewave-xnffs.png&quot; alt=&quot;x[n] = sin(2pi n f/fs)&quot; width=&quot;218&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;and plot the sampled function in Fig 4.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 4. A sampled sinewave&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/nco-sampled-tone.png&quot; alt=&quot;Picture of x[n] = sine(2pi f/fs n)&quot; width=&quot;540&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;In this figure, the samples are shown in circles.  They are each separated by
a phase of &lt;code class=&quot;highlighter-rouge&quot;&gt;2pi f/fs&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Our entire focus in this algorithm, though, is going to be on the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Instantaneous_phase&quot;&gt;phase&lt;/a&gt;
of this expression–the argument of the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sine_wave&quot;&gt;sine wave&lt;/a&gt;.  In the expression
above, this
&lt;a href=&quot;https://en.wikipedia.org/wiki/Instantaneous_phase&quot;&gt;phase&lt;/a&gt;
is given by &lt;code class=&quot;highlighter-rouge&quot;&gt;n&lt;/code&gt; times the &lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency&quot;&gt;frequency&lt;/a&gt;
ratio, &lt;code class=&quot;highlighter-rouge&quot;&gt;f/fs&lt;/code&gt;, times &lt;code class=&quot;highlighter-rouge&quot;&gt;2pi&lt;/code&gt;.  We’ll call this changing
&lt;a href=&quot;https://en.wikipedia.org/wiki/Instantaneous_phase&quot;&gt;phase&lt;/a&gt;
value &lt;code class=&quot;highlighter-rouge&quot;&gt;phi[n]&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;To build an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Numerically_controlled_oscillator&quot;&gt;NCO&lt;/a&gt;,
we are going to need to transform this
&lt;a href=&quot;https://en.wikipedia.org/wiki/Instantaneous_phase&quot;&gt;phase&lt;/a&gt; value, &lt;code class=&quot;highlighter-rouge&quot;&gt;phi[n]&lt;/code&gt;,
into an input our &lt;a href=&quot;https://en.wikipedia.org/wiki/Sine_wave&quot;&gt;sine wave&lt;/a&gt;
generator can handle.&lt;/p&gt;

&lt;p&gt;We’ll start by rewriting our
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sine_wave&quot;&gt;sine wave&lt;/a&gt; using this
&lt;a href=&quot;https://en.wikipedia.org/wiki/Instantaneous_phase&quot;&gt;phase&lt;/a&gt; value, &lt;code class=&quot;highlighter-rouge&quot;&gt;phi[n]&lt;/code&gt;,
so that it captures the internals of this
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sine_wave&quot;&gt;sine wave&lt;/a&gt;–with
the exception of the &lt;code class=&quot;highlighter-rouge&quot;&gt;2pi&lt;/code&gt; portion.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/eqn-sinewave-xphi.png&quot; alt=&quot;x[n] = sin(2pi phi[n])&quot; width=&quot;210&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Specifically, this
&lt;a href=&quot;https://en.wikipedia.org/wiki/Instantaneous_phase&quot;&gt;phase&lt;/a&gt;
value is defined by,&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/eqn-sinewave-phi.png&quot; alt=&quot;phi[n] = n(f/fs)&quot; width=&quot;136&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;table style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 5. Unit circle rotations&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/dphase-unit-circle.svg&quot; alt=&quot;A picture of the unit circle&quot; width=&quot;180&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;It represents the number of times our
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sine_wave&quot;&gt;sine wave&lt;/a&gt;
has gone around the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Unit_circle&quot;&gt;unit circle&lt;/a&gt;–the number of
rotations if you will.  For example, a &lt;code class=&quot;highlighter-rouge&quot;&gt;phi[n]&lt;/code&gt; of 1.0, applied internally
to our &lt;a href=&quot;https://en.wikipedia.org/wiki/Sine_wave&quot;&gt;sine wave&lt;/a&gt;,
would lead to a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Instantaneous_phase&quot;&gt;phase&lt;/a&gt; argument to our
sine function of &lt;code class=&quot;highlighter-rouge&quot;&gt;2pi&lt;/code&gt;–suggesting we had gone around the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Unit_circle&quot;&gt;unit circle&lt;/a&gt;
once.  A &lt;code class=&quot;highlighter-rouge&quot;&gt;phi[n]&lt;/code&gt; of 2.0 would yield the same value, but represent
instead that the &lt;a href=&quot;https://en.wikipedia.org/wiki/Instantaneous_phase&quot;&gt;phase&lt;/a&gt;
had traveled around the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Unit_circle&quot;&gt;unit circle&lt;/a&gt;
twice.  Fractions then will indicate partial angles from the x-axis around
the &lt;a href=&quot;https://en.wikipedia.org/wiki/Unit_circle&quot;&gt;unit circle&lt;/a&gt;,
hence a &lt;code class=&quot;highlighter-rouge&quot;&gt;phi[n]&lt;/code&gt; of &lt;code class=&quot;highlighter-rouge&quot;&gt;0.5&lt;/code&gt; would represent going halfway round
this &lt;a href=&quot;https://en.wikipedia.org/wiki/Unit_circle&quot;&gt;circle&lt;/a&gt;,
while &lt;code class=&quot;highlighter-rouge&quot;&gt;0.25&lt;/code&gt; would represent a quarter of the way around the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Unit_circle&quot;&gt;circle&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Let’s keep working with this value for a bit.  We can define this
&lt;a href=&quot;https://en.wikipedia.org/wiki/Instantaneous_phase&quot;&gt;phase&lt;/a&gt;
recursively based upon the prior
&lt;a href=&quot;https://en.wikipedia.org/wiki/Instantaneous_phase&quot;&gt;phase&lt;/a&gt;.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/eqn-sinewave-phibyphi.png&quot; alt=&quot;phi[n]=phi[n-1]+f/fs&quot; width=&quot;226&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;This simple modification accomplishes two purposes.  First, it allows us to
avoid a multiply by &lt;code class=&quot;highlighter-rouge&quot;&gt;n&lt;/code&gt;, turning the calculation of the next
&lt;a href=&quot;https://en.wikipedia.org/wiki/Instantaneous_phase&quot;&gt;phase&lt;/a&gt;
from the past
&lt;a href=&quot;https://en.wikipedia.org/wiki/Instantaneous_phase&quot;&gt;phase&lt;/a&gt;
into an operation requiring an addition alone.  Second, because this newer
version is no longer tied to the distance from &lt;code class=&quot;highlighter-rouge&quot;&gt;n=0&lt;/code&gt;, this subtle change
allows us to maintain any accumulated
&lt;a href=&quot;https://en.wikipedia.org/wiki/Instantaneous_phase&quot;&gt;phase&lt;/a&gt;
offsets in our
&lt;a href=&quot;https://en.wikipedia.org/wiki/Numerically_controlled_oscillator&quot;&gt;NCO&lt;/a&gt;
as well–not just
&lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency&quot;&gt;frequencies&lt;/a&gt;
with zero phase at zero time.&lt;/p&gt;

&lt;p&gt;This sounds fairly straight-forward so far.  What’s the trick?&lt;/p&gt;

&lt;h2 id=&quot;the-trick-to-building-an-nco&quot;&gt;The “Trick” to building an NCO&lt;/h2&gt;

&lt;p&gt;The “trick” in building an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Numerically_controlled_oscillator&quot;&gt;NCO&lt;/a&gt;
lies in the units of &lt;code class=&quot;highlighter-rouge&quot;&gt;phi[n]&lt;/code&gt;.  The units of &lt;code class=&quot;highlighter-rouge&quot;&gt;phi[n]&lt;/code&gt;, presented above, are
a number of cycles (or rotations) around the &lt;a href=&quot;https://en.wikipedia.org/wiki/Unit_circle&quot;&gt;unit
circle&lt;/a&gt;.  As a result, a
&lt;code class=&quot;highlighter-rouge&quot;&gt;phi[n]&lt;/code&gt; of 1.0 represents once around the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Unit_circle&quot;&gt;unit circle&lt;/a&gt;,
and a &lt;code class=&quot;highlighter-rouge&quot;&gt;phi[n]&lt;/code&gt; of 2.0 represents twice around the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Unit_circle&quot;&gt;unit circle&lt;/a&gt;, etc.&lt;/p&gt;

&lt;p&gt;However, within most
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_signal_processing&quot;&gt;signal processing&lt;/a&gt;
logic (&lt;a href=&quot;/dsp/2017/07/19/linear-upsampling.html&quot;&gt;not
quite all&lt;/a&gt;),
you don’t care how many &lt;em&gt;integer&lt;/em&gt; times a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sine_wave&quot;&gt;sine wave&lt;/a&gt; goes around the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Unit_circle&quot;&gt;unit circle&lt;/a&gt;,
you only care about the angular fraction.
Let’s therefore examine this number in terms of both it’s integer and
fractional portions.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/eqn-sinewave-phi-fraction.png&quot; alt=&quot;phi[n]=INT.FRACTION(...)&quot; width=&quot;258&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Specifically, let’s separate it into an integer portion, and the first
&lt;code class=&quot;highlighter-rouge&quot;&gt;W&lt;/code&gt; bits past the decimal point as shown below.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/phase-bits.svg&quot; alt=&quot;phi[n] separates into integer components and W fractional components&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Pictorially, dropping the integer portion might look like Fig 6 below.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 6. Phase function&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/nco-sampled-phase.png&quot; alt=&quot;A picture of the sampled phase function&quot; width=&quot;540&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Notice how the phase jumps back to zero in Fig 6 at the same point as where the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sine_wave&quot;&gt;sine wave&lt;/a&gt;
starts to repeat.  Sure, you didn’t need to bring this value back down
to zero, but doing so creates a limited range in &lt;code class=&quot;highlighter-rouge&quot;&gt;y&lt;/code&gt; that we can then
split among a fixed number of bits, &lt;code class=&quot;highlighter-rouge&quot;&gt;W&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Since we didn’t care about the integer number of times we’ve gone around the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Unit_circle&quot;&gt;unit circle&lt;/a&gt;,
we can subtract from &lt;code class=&quot;highlighter-rouge&quot;&gt;phi[n]&lt;/code&gt; its integer portion to recover the
fraction alone–just like we did in Fig 6 above.  We can then multiply the
result by &lt;code class=&quot;highlighter-rouge&quot;&gt;2^W&lt;/code&gt;, so as to get a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Fixed_point_(mathematics)&quot;&gt;fixed-point&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Instantaneous_phase&quot;&gt;phase&lt;/a&gt;
representation that will fit within a word of &lt;code class=&quot;highlighter-rouge&quot;&gt;W&lt;/code&gt; bits long.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/eqn-sinewave-usable-phi-defn.png&quot; alt=&quot;PHI[n]=2^W (phi[n] - floor(phi[n]))&quot; width=&quot;299&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Just to finish this off, we’ll only keep the integer portion of this
value, representing the top &lt;code class=&quot;highlighter-rouge&quot;&gt;W&lt;/code&gt; bits of our fractional
&lt;a href=&quot;https://en.wikipedia.org/wiki/Instantaneous_phase&quot;&gt;phase&lt;/a&gt;,
and we’ll ignore any further bits beyond the decimal point.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/eqn-sinewave-usable-fraction.png&quot; alt=&quot;PHI[n]~=FRACTION&quot; width=&quot;212&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Hence &lt;code class=&quot;highlighter-rouge&quot;&gt;PHI[n]&lt;/code&gt; is now a number between &lt;code class=&quot;highlighter-rouge&quot;&gt;0&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;2^W-1&lt;/code&gt; representing a fractional
rotation around the &lt;a href=&quot;https://en.wikipedia.org/wiki/Unit_circle&quot;&gt;unit circle&lt;/a&gt;,
a value between &lt;code class=&quot;highlighter-rouge&quot;&gt;0&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;That’s the first part of our “trick.”&lt;/p&gt;

&lt;p&gt;For the second part of this “trick”, let’s use the top &lt;code class=&quot;highlighter-rouge&quot;&gt;P&lt;/code&gt; bits of our
&lt;a href=&quot;https://en.wikipedia.org/wiki/Instantaneous_phase&quot;&gt;phase&lt;/a&gt;,
&lt;code class=&quot;highlighter-rouge&quot;&gt;PHI[n]&lt;/code&gt;, as the input to our
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sine_wave&quot;&gt;sine wave&lt;/a&gt;
generator, whether a
&lt;a href=&quot;/dsp/2017/07/11/simplest-sinewave-generator.html&quot;&gt;table lookup&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sine_wave&quot;&gt;sine wave&lt;/a&gt; generator, or even the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Instantaneous_phase&quot;&gt;phase&lt;/a&gt;
input phase value of a 
&lt;a href=&quot;/dsp/2017/08/30/cordic.html&quot;&gt;CORDIC&lt;/a&gt; algorithm.&lt;/p&gt;

&lt;p&gt;But what about the rest of the &lt;code class=&quot;highlighter-rouge&quot;&gt;W&lt;/code&gt; bits of our
&lt;a href=&quot;https://en.wikipedia.org/wiki/Fixed_point_(mathematics)&quot;&gt;fixed-point&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Instantaneous_phase&quot;&gt;phase&lt;/a&gt;
representation?&lt;/p&gt;

&lt;p&gt;These can be used for one of two purposes.  First, they can be used as a
fractional table index, accumulating over time to adjust our table index.
An example of this is shown below in Fig 7.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 7. Fractional phase accumulation&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/phase-tbl-index.svg&quot; alt=&quot;phi[n] separates into integer components and W fractional components&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;If you look carefully at this figure, you can see how the phase pointer
moves a little bit more than one table position at a time.  Eventually this
extra accumulated fraction causes the table index to
skip a table position entirely (position 6).&lt;/p&gt;

&lt;p&gt;This will allow you to represent and create 
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sine_wave&quot;&gt;sine wave&lt;/a&gt;s at
&lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency&quot;&gt;frequencies&lt;/a&gt;
not formed by integer steps through your table.  Such
&lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency&quot;&gt;frequencies&lt;/a&gt;
may involve jumping across table entries, as shown above in Fig 7, or even
repeating entries if necessary.  Yes, jumping entries will likely cause a
distortion in your output, but it will also help you maintain better
&lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency&quot;&gt;frequency&lt;/a&gt;
resolution than the first &lt;code class=&quot;highlighter-rouge&quot;&gt;P&lt;/code&gt; bits alone would allow.&lt;/p&gt;

&lt;p&gt;A second use for the bottom &lt;code class=&quot;highlighter-rouge&quot;&gt;W-P&lt;/code&gt; bits would be as part of an
interpolation
scheme to reduce the &lt;a href=&quot;https://en.wikipedia.org/wiki/Phase_noise&quot;&gt;phase noise&lt;/a&gt;
associated with any table representation.
This is such an important possibility that we may have
to come back to it and write about it more in a later article.&lt;/p&gt;

&lt;p&gt;But, what about overflow?&lt;/p&gt;

&lt;p&gt;This is an important question, so let’s walk through an example and see what
happens.  Consider what would happen if we were keeping track of
&lt;a href=&quot;https://en.wikipedia.org/wiki/Instantaneous_phase&quot;&gt;phase&lt;/a&gt;
in an 8-bit word, and one of our additions overflowed.  For example,
suppose you wanted to take four steps to go around a circle, starting at
&lt;code class=&quot;highlighter-rouge&quot;&gt;PHI[n]=8&#39;h20&lt;/code&gt; (45 degrees).  You’d then add to it &lt;code class=&quot;highlighter-rouge&quot;&gt;8&#39;h40&lt;/code&gt; (90 degrees) on
each clock.  The resulting sequence would then be, &lt;code class=&quot;highlighter-rouge&quot;&gt;8&#39;h20&lt;/code&gt; (45 degrees),
&lt;code class=&quot;highlighter-rouge&quot;&gt;8&#39;h60&lt;/code&gt; (135 degrees), &lt;code class=&quot;highlighter-rouge&quot;&gt;8&#39;ha0&lt;/code&gt; (225 degrees), &lt;code class=&quot;highlighter-rouge&quot;&gt;8&#39;he0&lt;/code&gt; (315 degrees),
&lt;code class=&quot;highlighter-rouge&quot;&gt;8&#39;h20&lt;/code&gt; (45 degrees).&lt;/p&gt;

&lt;p&gt;Did you catch what just happened?  The
&lt;a href=&quot;https://en.wikipedia.org/wiki/Instantaneous_phase&quot;&gt;phase&lt;/a&gt;
accumulator just overflowed between 315 degrees and 45 degrees, and yet the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Instantaneous_phase&quot;&gt;phase&lt;/a&gt;
representation just “did the right thing”!  What that means is that you can
ignore any overflow in your
&lt;a href=&quot;https://en.wikipedia.org/wiki/Instantaneous_phase&quot;&gt;phase&lt;/a&gt;–it’s
just going to wrap around the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Unit_circle&quot;&gt;unit circle&lt;/a&gt;
anyway, and the &lt;a href=&quot;https://en.wikipedia.org/wiki/Sine_wave&quot;&gt;sine wave&lt;/a&gt;
generator is only interested in the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Instantaneous_phase&quot;&gt;phase&lt;/a&gt;
fraction anyway.&lt;/p&gt;

&lt;h2 id=&quot;example-source-code&quot;&gt;Example Source Code&lt;/h2&gt;

&lt;p&gt;So, how would this look in practice?  Let’s look at an example of what this
would look like in both C++ and Verilog.&lt;/p&gt;

&lt;p&gt;We’ll start with a C++ example.  We’ll make a C++
&lt;a href=&quot;https://en.wikipedia.org/wiki/Numerically_controlled_oscillator&quot;&gt;NCO&lt;/a&gt;
class incorporating these principles.  There are three basic parts
to this class.  The first is the class declaration and table generation.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;NCO&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
	&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;m_lglen&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m_len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m_mask&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m_phase&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m_dphase&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;kt&quot;&gt;float&lt;/span&gt;		&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_table&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

	&lt;span class=&quot;n&quot;&gt;NCO&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lgtblsize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;c1&quot;&gt;// We&#39;ll use a table 2^(lgtblize) in length.  This is
&lt;/span&gt;		&lt;span class=&quot;c1&quot;&gt;// non-negotiable, as the rest of this algorithm depends upon
&lt;/span&gt;		&lt;span class=&quot;c1&quot;&gt;// this property.
&lt;/span&gt;		&lt;span class=&quot;n&quot;&gt;m_lglen&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lgtblsize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;m_len&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lgtblsize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

		&lt;span class=&quot;c1&quot;&gt;// m_mask is 1 for any bit used in the index, zero otherwise
&lt;/span&gt;		&lt;span class=&quot;n&quot;&gt;m_mask&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m_len&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;We’ll build the table itself with the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sine_wave&quot;&gt;sine wave&lt;/a&gt;
values at the left-edge of any interval.  This isn’t optimal, since it will
force the error to zero on the left edge and likely make it a maximum on the
right side of the interval, but it will yield us a decent capability quickly.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;		&lt;span class=&quot;n&quot;&gt;m_table&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;float&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;m_table&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;2.&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;M_PI&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;We may come back to this in a later post to minimize the maximum error
in this lookup.&lt;/p&gt;

&lt;p&gt;The last part of this initialization is to provide initial values for our
&lt;a href=&quot;https://en.wikipedia.org/wiki/Instantaneous_phase&quot;&gt;phase&lt;/a&gt;
accumulator  (&lt;code class=&quot;highlighter-rouge&quot;&gt;PHI[n]&lt;/code&gt;) and the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Instantaneous_phase&quot;&gt;phase&lt;/a&gt;
step necessary to create a known
&lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency&quot;&gt;frequency&lt;/a&gt; output.
In this case, we’ll initialize this step so that it will produce a zero
&lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency&quot;&gt;frequency&lt;/a&gt;–not
very exciting, but fixing that will be our next step.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;		&lt;span class=&quot;c1&quot;&gt;// m_phase is the variable holding our PHI[n] function from
&lt;/span&gt;		&lt;span class=&quot;c1&quot;&gt;// above.
&lt;/span&gt;		&lt;span class=&quot;c1&quot;&gt;// We&#39;ll initialize our initial phase and frequency to zero
&lt;/span&gt;		&lt;span class=&quot;n&quot;&gt;m_phase&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;m_dphase&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

	&lt;span class=&quot;c1&quot;&gt;// On any object deletion, make sure we delete the table as well
&lt;/span&gt;	&lt;span class=&quot;o&quot;&gt;~&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NCO&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;delete&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m_table&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The second part of this implementation is the function that sets the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency&quot;&gt;frequency&lt;/a&gt;.
This is captured within the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Numerically_controlled_oscillator&quot;&gt;NCO&lt;/a&gt; object
by the &lt;a href=&quot;https://en.wikipedia.org/wiki/Instantaneous_phase&quot;&gt;phase&lt;/a&gt;
step, &lt;code class=&quot;highlighter-rouge&quot;&gt;m_dphase&lt;/code&gt;.  As discussed above, this is the difference between &lt;code class=&quot;highlighter-rouge&quot;&gt;PHI[n]&lt;/code&gt;
and &lt;code class=&quot;highlighter-rouge&quot;&gt;PHI[n-1]&lt;/code&gt;.  Further, if you create a &lt;code class=&quot;highlighter-rouge&quot;&gt;SAMPLE_RATE&lt;/code&gt; value in
&lt;a href=&quot;https://en.wikipedia.org/wiki/Hertz&quot;&gt;Hertz&lt;/a&gt;,
then &lt;code class=&quot;highlighter-rouge&quot;&gt;f&lt;/code&gt; can be given to this routine in
&lt;a href=&quot;https://en.wikipedia.org/wiki/Hertz&quot;&gt;Hertz&lt;/a&gt;.  Otherwise, you can keep
&lt;code class=&quot;highlighter-rouge&quot;&gt;SAMPLE_RATE&lt;/code&gt; set to &lt;code class=&quot;highlighter-rouge&quot;&gt;1.0&lt;/code&gt; and then the &lt;code class=&quot;highlighter-rouge&quot;&gt;f&lt;/code&gt; value accepted by this routine will 
be set in terms of a normalized
&lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency&quot;&gt;frequency&lt;/a&gt; ranging from &lt;code class=&quot;highlighter-rouge&quot;&gt;0.0&lt;/code&gt; to the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Nyquist_frequency&quot;&gt;Nyquist frequency&lt;/a&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;0.5&lt;/code&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;	&lt;span class=&quot;c1&quot;&gt;// Adjust the sample rate for your implementation as necessary
&lt;/span&gt;	&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt;	&lt;span class=&quot;kt&quot;&gt;float&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;SAMPLE_RATE&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;1.0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt;	&lt;span class=&quot;kt&quot;&gt;float&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;ONE_ROTATION&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;2.0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1u&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;8&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;

	&lt;span class=&quot;kt&quot;&gt;float&lt;/span&gt;	&lt;span class=&quot;nf&quot;&gt;frequency&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;float&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;c1&quot;&gt;// Convert the frequency to a fractional difference in phase
&lt;/span&gt;		&lt;span class=&quot;n&quot;&gt;m_dphase&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ONE_ROTATION&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SAMPLE_RATE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;As a matter of personal practice, I never make the &lt;code class=&quot;highlighter-rouge&quot;&gt;SAMPLE_RATE&lt;/code&gt; a part of
my &lt;a href=&quot;https://en.wikipedia.org/wiki/Numerically_controlled_oscillator&quot;&gt;NCO&lt;/a&gt;
implementations.  That way one
&lt;a href=&quot;https://en.wikipedia.org/wiki/Numerically_controlled_oscillator&quot;&gt;NCO&lt;/a&gt;
implementation can work across multiple projects.&lt;/p&gt;

&lt;p&gt;You may find that the most confusing part of the logic above is the
&lt;code class=&quot;highlighter-rouge&quot;&gt;ONE_ROTATION&lt;/code&gt; value.  This is the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Instantaneous_phase&quot;&gt;phase&lt;/a&gt;
value representing once around the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Unit_circle&quot;&gt;unit circle&lt;/a&gt;.  It is given by
&lt;code class=&quot;highlighter-rouge&quot;&gt;2^W&lt;/code&gt;.  We have to go through a bit of a hoop to set this value, though, since
the &lt;code class=&quot;highlighter-rouge&quot;&gt;ONE_ROTATION&lt;/code&gt; value doesn’t fit within the &lt;code class=&quot;highlighter-rouge&quot;&gt;unsigned&lt;/code&gt; integer we are using
to hold &lt;code class=&quot;highlighter-rouge&quot;&gt;PHI[n]&lt;/code&gt; (&lt;code class=&quot;highlighter-rouge&quot;&gt;m_phase&lt;/code&gt;).  Alternatively, we might’ve set &lt;code class=&quot;highlighter-rouge&quot;&gt;ONE_ROTATION&lt;/code&gt; to
&lt;code class=&quot;highlighter-rouge&quot;&gt;pow(2,sizeof(unsigned)*8)&lt;/code&gt;, but the approach above makes it easier for the
compiler to recognize that this value is a constant, rather than needing to
call the &lt;code class=&quot;highlighter-rouge&quot;&gt;pos()&lt;/code&gt; math library function.&lt;/p&gt;

&lt;p&gt;The final part of this class steps the index into the table forward by one
step, and then returns the value of the table at the index given by the top
&lt;code class=&quot;highlighter-rouge&quot;&gt;P&lt;/code&gt; bits in the &lt;code class=&quot;highlighter-rouge&quot;&gt;m_phase&lt;/code&gt; word.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;	&lt;span class=&quot;kt&quot;&gt;float&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;operator&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;()(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

		&lt;span class=&quot;c1&quot;&gt;// Increment the phase by an amount dictated by our frequency
&lt;/span&gt;		&lt;span class=&quot;c1&quot;&gt;// m_phase was our PHI[n] value above
&lt;/span&gt;		&lt;span class=&quot;n&quot;&gt;m_phase&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m_dphase&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// PHI[n] = PHI[n-1] + (2^32 * f/fs)
&lt;/span&gt;
		&lt;span class=&quot;c1&quot;&gt;// Grab the top m_lglen bits of this phase word
&lt;/span&gt;		&lt;span class=&quot;n&quot;&gt;index&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m_phase&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;8&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_lglen&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

		&lt;span class=&quot;c1&quot;&gt;// Insist that this index be found within 0... (m_len-1)
&lt;/span&gt;		&lt;span class=&quot;n&quot;&gt;index&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m_mask&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

		&lt;span class=&quot;c1&quot;&gt;// Finally return the table lookup value
&lt;/span&gt;		&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m_table&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;You may notice that I’ve chosen to use single precision &lt;code class=&quot;highlighter-rouge&quot;&gt;float&lt;/code&gt;s, rather
than &lt;code class=&quot;highlighter-rouge&quot;&gt;double&lt;/code&gt; precision floating point numbers.  I did this for 
two reasons.&lt;/p&gt;

&lt;p&gt;First, I wanted to encourage you to ask the question of just how much precision
do you actually need?&lt;/p&gt;

&lt;p&gt;Second, I wanted to point out that the single precision &lt;code class=&quot;highlighter-rouge&quot;&gt;float&lt;/code&gt; representation
only has a 24-bit mantissa.  Most
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;s
today allow integers of 32-bits.  As a result, the integer
&lt;a href=&quot;https://en.wikipedia.org/wiki/Instantaneous_phase&quot;&gt;phase&lt;/a&gt;
accumulator &lt;em&gt;has more precision than a &lt;code class=&quot;highlighter-rouge&quot;&gt;float&lt;/code&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Instantaneous_phase&quot;&gt;phase&lt;/a&gt;
accumulator&lt;/em&gt;.  You can see this pictorially in Fig 8.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 8. Floating vs Fixed point phase&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/nco-fixed-v-float.svg&quot; alt=&quot;Comparing Fixed vs Floating point phase representations&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;If you are not familiar with single precision IEEE floats, the first bit,
&lt;code class=&quot;highlighter-rouge&quot;&gt;S&lt;/code&gt;, is a sign bit, and the next seven, &lt;code class=&quot;highlighter-rouge&quot;&gt;E&lt;/code&gt;, are exponent bits.  The final
24-bits, &lt;code class=&quot;highlighter-rouge&quot;&gt;M&lt;/code&gt;, are mantissa bits.  Put together, these items represent a
number sort of like, &lt;code class=&quot;highlighter-rouge&quot;&gt;(-1)^S * 2^E * M&lt;/code&gt;.  (Yes, I’m skipping some details
here.)&lt;/p&gt;

&lt;p&gt;Unlike IEEE floats, our fixed point
&lt;a href=&quot;https://en.wikipedia.org/wiki/Instantaneous_phase&quot;&gt;phase&lt;/a&gt;
representation is simply &lt;code class=&quot;highlighter-rouge&quot;&gt;32&lt;/code&gt; mantissa bits,
having a value ranging from &lt;code class=&quot;highlighter-rouge&quot;&gt;0&lt;/code&gt; to &lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Which one do you think will have more precision?&lt;/p&gt;

&lt;p&gt;In a similar fashion, if you were to use an &lt;code class=&quot;highlighter-rouge&quot;&gt;unsigned long&lt;/code&gt; for your
accumulator instead of an &lt;code class=&quot;highlighter-rouge&quot;&gt;unsigned&lt;/code&gt; value, then the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Instantaneous_phase&quot;&gt;phase&lt;/a&gt;
accumulator would have more precision than a &lt;code class=&quot;highlighter-rouge&quot;&gt;double&lt;/code&gt; precision float would
allow.&lt;/p&gt;

&lt;p&gt;In both cases the reason why this
&lt;a href=&quot;https://en.wikipedia.org/wiki/Instantaneous_phase&quot;&gt;phase&lt;/a&gt;
accumulator out-performs a floating point
&lt;a href=&quot;https://en.wikipedia.org/wiki/Instantaneous_phase&quot;&gt;phase&lt;/a&gt;
accumulator is simple because our representation has a fixed
decimal location, rather than a &lt;em&gt;floating&lt;/em&gt; decimal point.  That allows
more bits per word to be allocated to the mantissa, since the floating
point representation needed to allocate extra bits for both a sign
bit and the exponent.&lt;/p&gt;

&lt;p&gt;Were you to build an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Numerically_controlled_oscillator&quot;&gt;NCO&lt;/a&gt;
implementation within Verilog, the code is almost identical.
The biggest differences are first the fact that we require the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency&quot;&gt;frequency&lt;/a&gt;
given to be already be converted into the appropriate units, and second that
the bit select is simpler than before.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;module	nco(i_clk, i_ld, i_dphase, o_val);
	parameter	LGTBL = 9, // Log, base two, of the table size
			W = 32, // Word-size
			OW = 8; // Output width
	localparam	P = LGTBL;
	//
	input	wire		i_clk;
	//
	input	wire		i_ld;
	input	wire		i_dphase;
	//
	input	wire		i_ce
	output	wire [OW-1:0]	o_val;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Any time a new
&lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency&quot;&gt;frequency&lt;/a&gt;
is requested, the &lt;code class=&quot;highlighter-rouge&quot;&gt;i_ld&lt;/code&gt; signal will be set high
and the new frequency placed into &lt;code class=&quot;highlighter-rouge&quot;&gt;i_dphase&lt;/code&gt;.  This
&lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency&quot;&gt;frequency&lt;/a&gt;
value is in the units of &lt;code class=&quot;highlighter-rouge&quot;&gt;m_dphase&lt;/code&gt; in the C++ code above.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	reg	[W-1:0]	r_step;

	initial	r_step = 0;
	always @(posedge i_clk)
	if (i_ld)
		r_step &amp;lt;= i_dphase; // = 2^W * f/fs&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Likewise, on any clock where &lt;a href=&quot;/blog/2017/08/14/strategies-for-pipelining.html&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;i_ce&lt;/code&gt; is
high&lt;/a&gt;,
we’ll step the &lt;a href=&quot;https://en.wikipedia.org/wiki/Instantaneous_phase&quot;&gt;phase&lt;/a&gt;
forward by this same frequency-dependent amount.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	reg	[W-1:0]	r_phase;

	initial	r_phase = 0;
	always @(posedge i_clk)
	if (i_ce)
		// PHI[n] = PHI[n-1] + 2^W * f / fs
		r_phase &amp;lt;= r_phase + r_step;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Finally, the top &lt;code class=&quot;highlighter-rouge&quot;&gt;P&lt;/code&gt; bits of &lt;code class=&quot;highlighter-rouge&quot;&gt;r_phase&lt;/code&gt; are used in our &lt;a href=&quot;/dsp/2017/07/11/simplest-sinewave-generator.html&quot;&gt;table
lookup&lt;/a&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	sintable // #(.PW(P), .OW(OW))
		stbl(i_clk, 1&#39;b0, i_ce, 1&#39;b0, r_phase[(W-1):(W-P)],
		o_val, ignored);
endmodule&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;You may notice that both the C++ and Verilog implementations are quite similar.
They are both low logic implementations showing the basics of what is required
to create an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Numerically_controlled_oscillator&quot;&gt;NCO&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;future-posts&quot;&gt;Future Posts&lt;/h2&gt;

&lt;p&gt;We’ve just presented the logic behind building a basic
&lt;a href=&quot;https://en.wikipedia.org/wiki/Numerically_controlled_oscillator&quot;&gt;NCO&lt;/a&gt;.
While the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sine_wave&quot;&gt;sine wave&lt;/a&gt;
generated by this approach isn’t perfect, it may well be &lt;em&gt;good enough&lt;/em&gt;
for your project.  Should you need a higher quality
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sine_wave&quot;&gt;sine wave&lt;/a&gt;,
you may wish to know that there &lt;em&gt;are&lt;/em&gt; other/better
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sine_wave&quot;&gt;sine wave&lt;/a&gt;
generators out there beyond the &lt;a href=&quot;/dsp/2017/07/11/simplest-sinewave-generator.html&quot;&gt;simple table
lookup&lt;/a&gt;
method we’ve discussed before.&lt;/p&gt;

&lt;p&gt;As one example of doing better, you may wish to note that we’ve done nothing
to minimize the maximum error for any given table index.&lt;/p&gt;

&lt;p&gt;In a similar manner, we’ve done nothing with the rest of the &lt;code class=&quot;highlighter-rouge&quot;&gt;W-P&lt;/code&gt; fractional
bits in our &lt;code class=&quot;highlighter-rouge&quot;&gt;W&lt;/code&gt; bit
&lt;a href=&quot;https://en.wikipedia.org/wiki/Instantaneous_phase&quot;&gt;phase&lt;/a&gt;
accumulator.  These bits can be used to
&lt;a href=&quot;https://github.com/ZipCPU/interpolation/blob/master/tutorial.pdf&quot;&gt;interpolate&lt;/a&gt;
between table entries, either
&lt;a href=&quot;/dsp/2017/07/29/series-linear-interpolation.html&quot;&gt;linearly&lt;/a&gt;,
quadratically, or more as desired for better performance.&lt;/p&gt;

&lt;p&gt;These, however, will need to be left for discussions on some other day.&lt;/p&gt;
&lt;hr /&gt;&lt;p&gt;&lt;em&gt;And said, Hitherto shalt thou come, but no further: and here shall thy proud waves be stayed?  Job 38:11&lt;/em&gt;</description>
        <pubDate>Sat, 09 Dec 2017 00:00:00 -0500</pubDate>
        <link>http://zipcpu.com/dsp/2017/12/09/nco.html</link>
        <guid isPermaLink="true">http://zipcpu.com/dsp/2017/12/09/nco.html</guid>
        
        
        <category>dsp</category>
        
      </item>
    
  </channel>
</rss>
