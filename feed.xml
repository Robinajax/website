<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>The ZipCPU by Gisselquist Technology</title>
    <description>The ZipCPU blog, featuring how to discussions of FPGA and soft-core CPU design.  This site will be focused on Verilog solutions, using exclusively OpenSource IP products for FPGA design.  Particular focus areas include topics often left out of more mainstreeam FPGA design courses such as how to debug an FPGA design.
</description>
    <link>http://zipcpu.com/</link>
    <atom:link href="http://zipcpu.com/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Thu, 05 Oct 2017 10:43:14 -0400</pubDate>
    <lastBuildDate>Thu, 05 Oct 2017 10:43:14 -0400</lastBuildDate>
    <generator>Jekyll v3.0.1</generator>
    <image>
      <url>http://zipcpu.com/img/gt-rss.png</url>
      <title></title>
      <link></link>
    </image>
    
      <item>
        <title>A Brief Introduction to AutoFPGA</title>
        <description>&lt;p&gt;You may have heard about
&lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt;.  Perhaps you’ve found it on
&lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;github&lt;/a&gt;.  Perhaps you’ve read about it
on my &lt;a href=&quot;/projects.html&quot;&gt;projects&lt;/a&gt; page.  Perhaps you had a
chance to hear me &lt;a href=&quot;https://github.com/ZipCPU/autofpga/blob/master/doc/orconf17.pdf&quot;&gt;describe it
at&lt;/a&gt;
&lt;a href=&quot;https://orconf.org&quot;&gt;ORCONF, 2017&lt;/a&gt; or looked over
&lt;a href=&quot;https://github.com/ZipCPU/autofpga/blob/master/doc/orconf17.pdf&quot;&gt;my slides&lt;/a&gt;.
It only seems fitting that I should share it with my readers
&lt;a href=&quot;http://zipcpu.com/&quot;&gt;here&lt;/a&gt; as well.&lt;/p&gt;

&lt;p&gt;Today, therefore, I’d like to discuss why I created
&lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt;, and some of the problems with
the alternatives.  I’ll briefly discuss the goals of
&lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt;, and the license it is released
under.  When done, I’ll discuss a &lt;a href=&quot;https://github.com/ZipCPU/autofpga-demo&quot;&gt;new
project&lt;/a&gt; I just created based upon 
&lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt;, which I’m hoping to use in the
future to explain how
&lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt; works.&lt;/p&gt;

&lt;h2 id=&quot;why-autofpga--the-backstory&quot;&gt;Why AutoFPGA?  The backstory&lt;/h2&gt;

&lt;p&gt;I started working on
&lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt;
after creating several independent
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; based projects, and getting
annoyed that it felt like I kept rebuilding the wheel.  Each project needed
to have a bus designed for it, it needed to have interrupts defined and
assigned, peripherals needed to be integrated, and all these things changed
from project to project.&lt;/p&gt;

&lt;p&gt;Perhaps an overview of these projects might help make this clear.&lt;/p&gt;

&lt;p&gt;The first &lt;a href=&quot;/doc/wbspec_b4.pdf&quot;&gt;wishbone&lt;/a&gt; based project I
worked on was based around &lt;a href=&quot;https://store.digilentinc.com&quot;&gt;Digilent&lt;/a&gt;’s
&lt;a href=&quot;https://store.digilentinc.com/basys-3-artix-7-fpga-trainer-board-recommended-for-introductory-users/&quot;&gt;Basys3&lt;/a&gt;
board.  You can see the basic outline of the project in Fig 1, from before
I added the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; to it.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 1: Basys 3 design&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/basys3.svg&quot; alt=&quot;Basys3 Design outline&quot; width=&quot;480&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;My purpose was to learn about how to do hardware design &lt;em&gt;on my own&lt;/em&gt;, without
the office support team that I had when I first started learning
hardware design.  You know, the difference between relying on the experience
of other members of your team, versus needing to have that experience yourself?&lt;/p&gt;

&lt;p&gt;Since it was my first design as part of
&lt;a href=&quot;/about/gisselquist-technology.html&quot;&gt;Gisselquist Technology&lt;/a&gt;,
there were a lot of new parts and pieces.  To highlight this new work, I’ve
outlined it in blue within Fig 1 above.  Basically everything was new.&lt;/p&gt;

&lt;p&gt;It was on the
&lt;a href=&quot;https://store.digilentinc.com/basys-3-artix-7-fpga-trainer-board-recommended-for-introductory-users/&quot;&gt;Basys3&lt;/a&gt;
that I first built a
&lt;a href=&quot;https://opencores.org/project,qspiflash&quot;&gt;flash controller&lt;/a&gt;,
a &lt;a href=&quot;https://github.com/ZipCPU/wbuart32&quot;&gt;UART&lt;/a&gt;, a VGA controller, and much more.
Eventually, I built the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
on the
&lt;a href=&quot;https://store.digilentinc.com/basys-3-artix-7-fpga-trainer-board-recommended-for-introductory-users/&quot;&gt;Basys3&lt;/a&gt;,
even though it’s not shown in Fig 1.&lt;/p&gt;

&lt;p&gt;However, I wanted to try working on a
&lt;a href=&quot;https://github.com/ZipCPU/xulalx25soc&quot;&gt;project&lt;/a&gt; that required an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
with a small form factor.  Previous designs I had worked on involved both a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;
and an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
working together, and I was curious to know if I could do all of the work
within a bigger
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;I considered the
&lt;a href=&quot;https://store.digilentinc.com/cmod-s6-breadboardable-spartan-6-fpga-module&quot;&gt;CMod S6&lt;/a&gt;,
but ultimately chose to try
&lt;a href=&quot;http://www.xess.com&quot;&gt;Xess.com&lt;/a&gt;’s
&lt;a href=&quot;http://www.xess.com/shop/product/xula2-lx25&quot;&gt;XuLA2-LX25&lt;/a&gt;
board. (I bought the &lt;a href=&quot;https://store.digilentinc.com/cmod-s6-breadboardable-spartan-6-fpga-module&quot;&gt;CMod
S6&lt;/a&gt;
later.)  The &lt;a href=&quot;http://www.xess.com/shop/product/xula2-lx25&quot;&gt;XuLA2-LX25&lt;/a&gt;
had more capability, more logic within its
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;,
had an &lt;a href=&quot;https://en.wikipedia.org/wiki/Secure_Digital&quot;&gt;SD card&lt;/a&gt; socket, and
even &lt;a href=&quot;https://en.wikipedia.org/wiki/Synchronous_dynamic_random-access_memory&quot;&gt;SDRAM
memory&lt;/a&gt;.
In the end,
&lt;a href=&quot;https://github.com/ZipCPU/xulalx25soc&quot;&gt;the design&lt;/a&gt; looked something like Fig 2.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 2: XuLA2 LX25 SoC Design&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/xula.svg&quot; alt=&quot;XuLA2-LX25 SoC Design outline&quot; width=&quot;480&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;You can still find the &lt;a href=&quot;https://github.com/ZipCPU/xulalx25soc&quot;&gt;project
here&lt;/a&gt;, should you be interested in it.
It does contain an
&lt;a href=&quot;https://github.com/ZipCPU/xulalx25soc/blob/master/sdspi.v&quot;&gt;SD-Card controller&lt;/a&gt;,
and an &lt;a href=&quot;https://github.com/ZipCPU/xulalx25soc/blob/master/wbsdram.v&quot;&gt;SDRAM
controller&lt;/a&gt;.
You can see the other components of the design in Fig 2 above.
It was the first full project that I released under an open-source license.
(Unfortunately, it’s poorly documented, despite documentation existing for all
the components.)&lt;/p&gt;

&lt;p&gt;The good news was that, when building the
&lt;a href=&quot;https://github.com/ZipCPU/xulalx25soc&quot;&gt;XuLA project&lt;/a&gt;, I
was able to re-use a lot of the components I had initially built for
my &lt;a href=&quot;https://store.digilentinc.com/basys-3-artix-7-fpga-trainer-board-recommended-for-introductory-users/&quot;&gt;Basys3&lt;/a&gt;.  Still, looking at the amount of stuff
in blue, there was still a lot of work involved in building the new design.&lt;/p&gt;

&lt;p&gt;I also decided to toy around with the idea of seeing if I could
“broadcast” on a local &lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency_modulation&quot;&gt;FM&lt;/a&gt;
channel using the board, as I had &lt;a href=&quot;https://www.raspberrypi.org/magpi/raspberry-pi-fm-transmitter&quot;&gt;seen a friend
do&lt;/a&gt; with
his &lt;a href=&quot;https://www.raspberrypi.org/&quot;&gt;Raspberry Pi&lt;/a&gt;.  (It’s always fun to one-up
a &lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt; developer with
your &lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
design.) So, I created an
&lt;a href=&quot;https://github.com/ZipCPU/wbfmtx&quot;&gt;WB FM transmitter hack&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;While the &lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency_modulation&quot;&gt;FM&lt;/a&gt; transmission
approach worked like a charm, integrating it into
&lt;a href=&quot;https://github.com/ZipCPU/xulalx25soc&quot;&gt;the project&lt;/a&gt; on
a whim and then taking it out later was pretty annoying.  There was a lot
of work involved, and several files that needed to be changed, and did I get
it all done properly?  I think you get the idea.  If that wasn’t bad enough,
what if I wanted to try the design again later, or demonstrate it for others?&lt;/p&gt;

&lt;p&gt;When it was time to move forward with my next design, I wanted to try building
something in an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;,
logic limited environment–just to prove that the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
would work on one of the &lt;em&gt;small architectures&lt;/em&gt; it had been built for.
Could it really fit in the smallest
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
development board I could find?  So, I bought a &lt;a href=&quot;https://store.digilentinc.com/cmod-s6-breadboardable-spartan-6-fpga-module&quot;&gt;CMod
S6&lt;/a&gt;
featuring a
Spartan 6LX4–the smallest
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
that &lt;a href=&quot;https://www.xilinx.com&quot;&gt;Xilinx&lt;/a&gt; sells in its the Spartan 6 line.
The challenge with this design was to make something &lt;em&gt;small&lt;/em&gt;.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 3: S6-SoC Design&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/s6soc.svg&quot; alt=&quot;Outline of the S6SoC&quot; width=&quot;480&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;For &lt;a href=&quot;https://github.com/ZipCPU/s6soc&quot;&gt;this project&lt;/a&gt;, I was able to reuse a lot
of the components I had already built.  Looking in Fig 3, you’ll see only a
small amount of development outlined in blue.  The biggest challenge to the
&lt;a href=&quot;https://github.com/ZipCPU/s6soc&quot;&gt;design&lt;/a&gt; was both building the bus logic, and
keeping everything small.&lt;/p&gt;

&lt;p&gt;This was also the first
&lt;a href=&quot;https://github.com/ZipCPU/s6soc&quot;&gt;project&lt;/a&gt; I ever built with time-slicing,
but that’s another story.&lt;/p&gt;

&lt;p&gt;Since I had never worked with
&lt;a href=&quot;https://opencores.org/project,wbddr3&quot;&gt;DDR3 SDRAM&lt;/a&gt; before,
I chose to work with
&lt;a href=&quot;https://store.digilentinc.com&quot;&gt;Digitlent&lt;/a&gt;’s
&lt;a href=&quot;https://store.digilentinc.com/arty-artix-7-fpga-development-board-for-makers-and-hobbyists/&quot;&gt;Arty&lt;/a&gt;
for my next project so that I might learn about it.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 4: OpenArty Design Overview&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/openarty.svg&quot; alt=&quot;Outline of the S6SoC&quot; width=&quot;480&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;The majority of the new work in this design was for the ethernet, the
&lt;a href=&quot;https://opencores.org/project,wbddr3&quot;&gt;DDR3 SDRAM&lt;/a&gt; controller,
the &lt;a href=&quot;https://github.com/ZipCPU/openarty/blob/master/rtl/wboled.v&quot;&gt;OLEDrgb&lt;/a&gt;,
and the &lt;a href=&quot;https://github.com/ZipCPU/openarty/blob/master/rtl/busmaster.v&quot;&gt;bus&lt;/a&gt;
(&lt;em&gt;again&lt;/em&gt;).  (Eventually, I had to shelve
&lt;a href=&quot;https://opencores.org/project,wbddr3&quot;&gt;DDR3 SDRAM&lt;/a&gt; controller, choosing instead
to use a &lt;a href=&quot;https://github.com/ZipCPU/wb2axip&quot;&gt;Wishbone to AXI4 bridge&lt;/a&gt;.
There was also a lot of work to raise the clock speed to 200MHz, but since
the &lt;a href=&quot;https://www.xilinx.com&quot;&gt;Xilinx&lt;/a&gt; MIG core could only run at 82MHz on the
&lt;a href=&quot;https://store.digilentinc.com/arty-artix-7-fpga-development-board-for-makers-and-hobbyists/&quot;&gt;Arty&lt;/a&gt;,
this work was shelved.)&lt;/p&gt;

&lt;p&gt;When it came time to build an
&lt;a href=&quot;https://en.wikipedia.org/wiki/HDMI&quot;&gt;HDMI video&lt;/a&gt;
processor, I chose to use the
&lt;a href=&quot;https://store.digilentinc.com/nexys-video-artix-7-fpga-trainer-board-for-multimedia-applications/&quot;&gt;Nexys Video&lt;/a&gt;.
By this point in time, I had finally had enough of rebuilding the wheel on
every design.&lt;/p&gt;

&lt;p&gt;For every design up until that point, I had &lt;em&gt;hand-crafted&lt;/em&gt; an interconnect to
connect all the components into the design.  (This is the horizontal blue line
in each of the figures above.)  This interconnect would connect
components to an internal &lt;a href=&quot;/doc/wbspec_b4.pdf&quot;&gt;Wishbone
bus&lt;/a&gt;, and it would connect interrupts
together from the various peripheral components to one of a couple of interrupt
controllers.  You can see examples of my interconnects for the &lt;a href=&quot;https://github.com/ZipCPU/xulalx25soc/blob/master/busmaster.v&quot;&gt;XuLA2-LX25
here&lt;/a&gt;,
the &lt;a href=&quot;https://github.com/ZipCPU/s6soc/blob/master/busmaster.v&quot;&gt;CMod S6 here&lt;/a&gt;,
and the &lt;a href=&quot;https://github.com/ZipCPU/openarty/blob/master/busmaster.v&quot;&gt;Arty here&lt;/a&gt;.
Addresses needed to be assigned, interrupts needed to be assigned,
they both needed to be documented, and these things were just taking too much
of my time.&lt;/p&gt;

&lt;p&gt;To make matters worse, anytime I adjusted the number of addresses a specific
peripheral might require, I might need to adjust its location in the address
space I was creating.  This made for a lot of work.  As you may recall, I
like to access my designs via a &lt;a href=&quot;/blog/2017/06/16/dbg-bus/forest.html&quot;&gt;bus based external controller from
software&lt;/a&gt;,
and that &lt;a href=&quot;/blog/2017/06/29/sw-dbg-interface.html&quot;&gt;software needs to know where things are located on the
bus&lt;/a&gt;.
The &lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt; also needs to know not only
where things are located on the bus, but &lt;em&gt;if&lt;/em&gt; particular peripherals are a
part of the design or not.&lt;/p&gt;

&lt;p&gt;I’ve already discussed how annoying this was when (temporarily) integrating
the &lt;a href=&quot;https://github.com/ZipCPU/wbfmtx&quot;&gt;FM transmitter hack&lt;/a&gt; into my
&lt;a href=&quot;https://github.com/ZipCPU/xulalx25soc&quot;&gt;XuLA2-LX25 SoC design&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The need for a reconfiguration assistant also came up when I was working on my
&lt;a href=&quot;https://en.wikipedia.org/wiki/HDMI&quot;&gt;HDMI video&lt;/a&gt; design.  At the time, I was
struggling to understand what was going on within my (broken)
&lt;a href=&quot;https://en.wikipedia.org/wiki/HDMI&quot;&gt;HDMI video&lt;/a&gt; stream.  I had decided that
I needed to capture some of the video stream to block RAM via a
&lt;a href=&quot;https://github.com/ZipCPU/wbscope&quot;&gt;wishbone scope&lt;/a&gt;, after which I was going to
read the results back to find out what was going wrong with my design.  The
problem with this was that video is a memory hog.  Therefore, my
&lt;a href=&quot;https://github.com/ZipCPU/wbscope&quot;&gt;wishbone scope&lt;/a&gt; needed a large block RAM.
This meant that I needed to adjust the size of the block RAM that the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt;
was using.  This necessitated changing the bus interconnect, the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt; loader, the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/sw/board/board.ld&quot;&gt;linker script&lt;/a&gt;,
the &lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/sim/verilated/main_tb.cpp&quot;&gt;simulation
driver&lt;/a&gt;
that will load the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;CPU&lt;/a&gt;
into simulated memory, and more—and all of this just to
get the results of a one-time Video capture test.&lt;/p&gt;

&lt;p&gt;This was why I wanted a capability like
&lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt;.
&lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt; simplifies the number of
changes that need to be made to a design when reconfiguring it, working
like a secretary (not a designer) to automatically connect things together,
and then let you know what it did.&lt;/p&gt;

&lt;h2 id=&quot;lessons-from-other-aggregators&quot;&gt;Lessons from Other Aggregators&lt;/h2&gt;

&lt;p&gt;I think &lt;a href=&quot;/blog/2017/05/17/welcome.html&quot;&gt;I’ve mentioned that I’ve spent a lot of time answering
questions&lt;/a&gt; on
&lt;a href=&quot;https://store.digilentinc.com&quot;&gt;Digilent&lt;/a&gt;’s
&lt;a href=&quot;https://forum.digilentinc.com&quot;&gt;forums&lt;/a&gt;.
Many students will come to the &lt;a href=&quot;https://forum.digilentinc.com&quot;&gt;forum&lt;/a&gt;
declaring that they want to build a design
in &lt;em&gt;&lt;a href=&quot;https://www.xilinx.com/products/design-tools/vivado.html&quot;&gt;Vivado&lt;/a&gt;&lt;/em&gt;,
but what they really mean is that they want to build a design using the
graphical design method
&lt;a href=&quot;https://www.xilinx.com/products/design-tools/vivado.html&quot;&gt;Vivado&lt;/a&gt; supports.
Interacting with these individuals has given me a lot of insight into the
problems many students are struggling with as they work to create (and debug)
their own designs.
From my standpoint, it seems like the biggest problem these new
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
students are struggling with &lt;em&gt;is&lt;/em&gt; the graphical design flow that they are so
eager to learn.&lt;/p&gt;

&lt;p&gt;Why is this?&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;The design flow &lt;em&gt;hides&lt;/em&gt; a lot of configuration detail.  It allows you to
connect blocks together, but yet each block needs a lot of internal
configuration that isn’t immediately visible once configured.  It takes a
bit of digging to even get at this configuration information.&lt;/p&gt;

    &lt;p&gt;As an example, I just recently helped one individual who was struggling to
get his &lt;a href=&quot;https://en.wikipedia.org/wiki/HDMI&quot;&gt;HDMI video&lt;/a&gt; data lined up with
his clock.  (He didn’t realize this was his problem until it was fixed.)
The particular configurations necessary were hidden within both
the SelectIO wizard and the clocking wizard, but neither wizard made the
users choices available upon a cursory view of the project.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The design flows aren’t textual.  You can’t do a “diff” between two designs.&lt;/p&gt;

    &lt;p&gt;This makes it hard to answer the question of “how is my design different
from the example/reference design.”&lt;/p&gt;

    &lt;p&gt;Indeed, I was actually rather surprised, when I
&lt;a href=&quot;https://github.com/ZipCPU/autofpga/blob/master/doc/orconf17.pdf&quot;&gt;presented&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt;
at &lt;a href=&quot;https://orconf.org&quot;&gt;ORCONF&lt;/a&gt; this year
that I got cheers when I declared the whole processing flow to be
“textual”, and said that you could run it from within a
&lt;a href=&quot;https://www.gnu.org/software/make/&quot;&gt;Makefile&lt;/a&gt;.  (The same audience groaned
during another presentation, when that presenter explained that his tool
&lt;em&gt;only&lt;/em&gt; had a &lt;a href=&quot;https://en.wikipedia.org/wiki/Graphical_user_interface&quot;&gt;Graphical User Interface
(GUI)&lt;/a&gt;.)&lt;/p&gt;

    &lt;p&gt;I guess I hadn’t realized how much of a drag many of the modern graphical
tools were becoming to the professional designer.
This may be because
&lt;a href=&quot;https://en.wikipedia.org/wiki/Graphical_user_interface&quot;&gt;GUI&lt;/a&gt;’s tend to
start up slowly.  It may be because
&lt;a href=&quot;https://en.wikipedia.org/wiki/Graphical_user_interface&quot;&gt;GUI&lt;/a&gt;’s tend to
limit your design options to the
&lt;a href=&quot;https://www.blueletterbible.org/kjv/mat/7/13&quot;&gt;road most people travel upon&lt;/a&gt;.
However, for me the problem is twofold:  First, a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Graphical_user_interface&quot;&gt;GUI&lt;/a&gt;
forces me to slow down and use a mouse.  Second, building a design can take
a lot of work: I like the option of using
&lt;a href=&quot;https://www.gnu.org/software/make/&quot;&gt;make&lt;/a&gt; to build &lt;em&gt;only&lt;/em&gt; those portions
of the design that have changed.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;It isn’t clear how to place a scope or a probe into such a design, to see
and understand what is going on within it.  For example, if you have
component &lt;code class=&quot;highlighter-rouge&quot;&gt;A&lt;/code&gt; connected to component &lt;code class=&quot;highlighter-rouge&quot;&gt;B&lt;/code&gt;, and the output of component &lt;code class=&quot;highlighter-rouge&quot;&gt;B&lt;/code&gt;
is somehow wrong, how shall you know which of the two is
misconfigured?&lt;/p&gt;

    &lt;p&gt;Going back to the individual struggling to get
&lt;a href=&quot;https://en.wikipedia.org/wiki/HDMI&quot;&gt;HDMI video&lt;/a&gt; working, he didn’t have
any clear locations within his design where he could &lt;a href=&quot;/blog/2017/06/08/simple-scope.html&quot;&gt;create a tap and
see the problem&lt;/a&gt;.&lt;/p&gt;

    &lt;p&gt;Sure, he could examine some wires via
&lt;a href=&quot;https://www.xilinx.com&quot;&gt;Xilinx&lt;/a&gt;’s
&lt;a href=&quot;https://www.xilinx.com/products/intellectual-property/ila.html&quot;&gt;ILA&lt;/a&gt;,
but what if you need to create an ad-hoc computer program to comprehend
the output of the scope?  It wasn’t clear how to do this with the
proprietary
&lt;a href=&quot;https://www.xilinx.com/products/intellectual-property/ila.html&quot;&gt;ILA&lt;/a&gt;.
Without it, it wasn’t clear how to identify where in the
processing chain the problem was at.&lt;/p&gt;

    &lt;p&gt;This, by the way, is one of the reasons that Open Source
&lt;a href=&quot;https://github.com/ZipCPU/wbscope&quot;&gt;scopes&lt;/a&gt; are so necessary: their measured
output values can easily be ingested into your own specialized debugging
software to be processed as you see fit.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;At one time, when I asked some other users about graphical design methods,
an online acquaintance noted that there doesn’t seem to be any way to “take
the training wheels off” of these methods, so as to be able to dig down
into the nuts and bolts of a design once you were ready to do so.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Finally, the &lt;a href=&quot;https://www.xilinx.com&quot;&gt;Xilinx&lt;/a&gt; toolchain in particular has
created a horrendous problem for 
&lt;a href=&quot;https://store.digilentinc.com&quot;&gt;Digilent&lt;/a&gt;’s support staff, in that every
new version of
&lt;a href=&quot;https://www.xilinx.com/products/design-tools/vivado.html&quot;&gt;Vivado&lt;/a&gt; breaks
their demonstration projects.&lt;/p&gt;

    &lt;p&gt;I’m not sure if this is because they rebuild or reconfigure their component
libraries from  one version to the next, or if it is because they rebuild
their TCL scripting interface, or what.  Indeed, I’ve
struggled with the problem myself when I tried rebuilding my
&lt;a href=&quot;https://github.com/ZipCPU/openarty&quot;&gt;OpenArty&lt;/a&gt; design with a newer version
of &lt;a href=&quot;https://www.xilinx.com/products/design-tools/vivado.html&quot;&gt;Vivado&lt;/a&gt;.
The result of my effort was an error so obscure that not even the
&lt;a href=&quot;https://www.xilinx.com&quot;&gt;Xilinx&lt;/a&gt; support staff on &lt;a href=&quot;https://forums.xilinx.com&quot;&gt;their
forum&lt;/a&gt; could identify.  (This is why you won’t
find any of the
&lt;a href=&quot;https://www.xilinx.com/products/design-tools/vivado.html&quot;&gt;Vivado&lt;/a&gt;
output files/products in the
&lt;a href=&quot;https://github.com/ZipCPU/openarty&quot;&gt;OpenArty&lt;/a&gt; repository.)&lt;/p&gt;

    &lt;p&gt;As a result, &lt;a href=&quot;/digilent/2017/05/18/most-common-digilent-support-requests.html&quot;&gt;I watch students&lt;/a&gt;
on the &lt;a href=&quot;https://store.digilentinc.com&quot;&gt;Digilent&lt;/a&gt;
&lt;a href=&quot;https://forum.digilentinc.com&quot;&gt;forum&lt;/a&gt; struggling to build the example
designs provided for them unless they have the exact same version of
&lt;a href=&quot;https://www.xilinx.com/products/design-tools/vivado.html&quot;&gt;Vivado&lt;/a&gt;.
Indeed, telling the student which version of
&lt;a href=&quot;https://www.xilinx.com/products/design-tools/vivado.html&quot;&gt;Vivado&lt;/a&gt; to use
to build an example/demo is a &lt;a href=&quot;/digilent/2017/05/18/most-common-digilent-support-requests.html&quot;&gt;common Digilent support request
response&lt;/a&gt;.&lt;/p&gt;

    &lt;p&gt;Wouldn’t you rather be able to separate your component library updates
from your tool updates, so that what works with one tool will work
with others?&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;All of this leads me to the conclusion that, if I wanted to create an
alternative, it would need to be OpenSource, and it would need to not take
any of the design decisions away from the designer: all of the Verilog files
would need to be available for view.&lt;/p&gt;

&lt;p&gt;Indeed, I wanted something that would generate Verilog (and c++, and Make)
project files that I could then inspect and understand–not something that
would hide details that would become difficult to debug later.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Any design flow or tool suite that hides “useless” or “irrelevant” details
will also hide the location of your bug.  (&lt;a href=&quot;https://twitter.com/zipcpu&quot;&gt;ZipCPU tweet&lt;/a&gt;)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;autofpgas-design-goals&quot;&gt;AutoFPGA’s Design Goals&lt;/h2&gt;

&lt;p&gt;My goal for
&lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt;
was simple: to be able to run
&lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt;
with a list of peripherals, and have it automatically connect those
peripherals together in a manner prescribed by their configuration files.
Indeed, if you look in an &lt;a href=&quot;https://github.com/ZipCPU/autofpga-demo/blob/master/auto-data/Makefile&quot;&gt;example
Makefile&lt;/a&gt;
that calls
&lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt;,
you’ll find a line that just calls
&lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt;
with a list of components.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;autofpga global.txt bkram.txt buserr.txt clock.txt hexbus.txt		&lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
	fixdata.txt pwrcount.txt rawreg.txt simhalt.txt	version.txt spio.txt&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;“&lt;a href=&quot;https://www.gnu.org/software/make/&quot;&gt;Make&lt;/a&gt;“able&lt;/p&gt;

    &lt;p&gt;To keep things simple, I’d like to type
“&lt;a href=&quot;https://www.gnu.org/software/make&quot;&gt;make&lt;/a&gt;” in a &lt;a href=&quot;https://github.com/ZipCPU/autofpga-demo/blob/master/Makefile&quot;&gt;top level
directory&lt;/a&gt;,
have &lt;a href=&quot;https://www.gnu.org/software/make&quot;&gt;make&lt;/a&gt;
recurse as necessary into any sub-directories to process &lt;a href=&quot;https://github.com/ZipCPU/autofpga-demo/tree/master/auto-data/&quot;&gt;component
configuration
files&lt;/a&gt;, build
&lt;a href=&quot;https://github.com/ZipCPU/autofpga-demo/tree/master/auto-generated/&quot;&gt;design files&lt;/a&gt;,
assemble those files together, and build a project all from one
&lt;a href=&quot;https://www.gnu.org/software/make&quot;&gt;make&lt;/a&gt; command.&lt;/p&gt;

    &lt;p&gt;Okay, so … I don’t know how to do this with the proprietary vendor based
tools (yet), and I don’t want to use a broken Tcl toolflow, but I do know
how to do this much with both
&lt;a href=&quot;http://www.clifford.at/yosys/&quot;&gt;yosys&lt;/a&gt;
and
&lt;a href=&quot;https://www.veripool.org/wiki/verilator&quot;&gt;Verilator&lt;/a&gt;.&lt;/p&gt;

    &lt;p&gt;(No, I’m not saying that Tcl is broken, but rather that many of the tools
that use it are–for the reasons discussed above.)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;No new language&lt;/p&gt;

    &lt;p&gt;Further, I don’t really want to create a new language for component
interaction and connection.  While I understand that other tools exist,
such as &lt;a href=&quot;https://en.wikipedia.org/wiki/IP-XACT&quot;&gt;IP-XACT&lt;/a&gt;,
&lt;a href=&quot;https://myhdl.org&quot;&gt;MyHDL&lt;/a&gt;, or
&lt;a href=&quot;https://github.com/m-labs/migen&quot;&gt;Migen&lt;/a&gt;, I didn’t want to require the
developer to learn a knew language (XML, Python,
&lt;a href=&quot;https://github.com/m-labs/migen/blob/master/fhdl.rst&quot;&gt;FHDL&lt;/a&gt;, etc.)
in order to interact with
&lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt;.  I also didn’t want to build
a compiler.  I wanted
&lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt; to be a
product that I could use to create a production system, and I
didn’t want to slow down too much to get there.&lt;/p&gt;

    &lt;p&gt;For this reason, 
&lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt; is primarily a
Copy and Paste utility.  The configuration files will identify what
things need to be copied and pasted where to create the desired output
files.  As an example, a &lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/auto-data/flash.txt&quot;&gt;Quad SPI flash
component&lt;/a&gt;
doesn’t just need to connect to a
&lt;a href=&quot;/doc/wbspec_b4.pdf&quot;&gt;wishbone bus&lt;/a&gt;, it also needs a little
bit of tri-state code inserted at the top design level.  (It’s actually worse:
since the flash clock line is shared with the load circuitry, a special
&lt;a href=&quot;https://www.xilinx.com&quot;&gt;Xilinx&lt;/a&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;STARTUPE2&lt;/code&gt; component is often required
at the top design level as
well.)&lt;/p&gt;

    &lt;p&gt;I’ll need to leave it open for debate as to whether or not I created a
“new language”, since the configuration files are neither Verilog nor are
they C++, and they are definitely not Python.  Instead, the files consist
of a simple series of “@KEY=VALUE” pairs, where the &lt;code class=&quot;highlighter-rouge&quot;&gt;VALUE&lt;/code&gt;s can take
multiple lines–often containing pieces of Verilog or C++ code.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;No hidden design components&lt;/p&gt;

    &lt;p&gt;&lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt; just creates text files.
Since 
&lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt; is primarily a copy and
paste utility, comments within the 
&lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt; configuration files will just
get copied into their respective places.&lt;/p&gt;

    &lt;p&gt;What this means is, when you have a problem with the design of one of your
components, you can look back into that components configuration file and
see what got copied and adjust it.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;While I like to think that
&lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt;
has met all of these goals and more, I’ll leave it to you and time to be the
ultimate judge.&lt;/p&gt;

&lt;h2 id=&quot;license&quot;&gt;License&lt;/h2&gt;

&lt;p&gt;If you are wondering if you can legally use
&lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt; for your project, the answer is
that you can.  &lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt; is a software
program licensed under the
&lt;a href=&quot;https://www.gnu.org/licenses/gpl.html&quot;&gt;GPLv3&lt;/a&gt;.  If you make changes to it,
or improve it, I would love to have those changes returned to the
&lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt; repository for others to use.&lt;/p&gt;

&lt;p&gt;This license doesn’t cover &lt;em&gt;your&lt;/em&gt; intellectual property, only the
&lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt; program itself.  Indeed, I
consider &lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt;
to be a piece of software similar to a compiler.  As a result,
&lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt; asserts no particular license
on the files it creates, or the projects that use it.&lt;/p&gt;

&lt;p&gt;Going one step further, all of my
&lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt; projects specify their own
license.  What I mean is that I require
&lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt; created design files to have
a license statement within them.  The license statement chosen if specified
by the global &lt;code class=&quot;highlighter-rouge&quot;&gt;@LEGAL&lt;/code&gt; tag, such as you might find in one of my
&lt;a href=&quot;https://github.com/ZipCPU/autofpga-demo/blob/master/auto-data/global.txt&quot;&gt;global configuration file&lt;/a&gt;s.
&lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt; then copies &lt;a href=&quot;https://github.com/ZipCPU/autofpga-demo/blob/master/auto-data/legalgen.txt&quot;&gt;this
license&lt;/a&gt;
into the files it generates–adjusting the filename and project name as
appropriate.  Hence while &lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt;
is released under &lt;a href=&quot;https://www.gnu.org/licenses/gpl.html&quot;&gt;GPLv3&lt;/a&gt;, I can choose
to release (or not) any project that uses it.  Feel free to adjust the &lt;code class=&quot;highlighter-rouge&quot;&gt;@LEGAL&lt;/code&gt;
tag to reference the license appropriate for your project.&lt;/p&gt;

&lt;h2 id=&quot;a-simple-autofpga-design&quot;&gt;A Simple AutoFPGA Design&lt;/h2&gt;

&lt;p&gt;Given all of that as background, I’d like to spend some time introducing
&lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt;
and discussing how to add (or remove) peripherals to(/from) a project.
I’ve created a new project, 
an &lt;a href=&quot;https://github.com/ZipCPU/autofpga-demo&quot;&gt;AutoFPGA Demo&lt;/a&gt;, which contains
a series of simple peripherals that can easily become a part of any project
using &lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt;.  This should be
simple enough for any new student to learn how to build and integrate
components together using
&lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;I have more complicated demonstrations as well, such as the
&lt;a href=&quot;https://github.com/ZipCPU/zbasic&quot;&gt;ZBasic&lt;/a&gt; project.
&lt;a href=&quot;https://github.com/ZipCPU/zbasic&quot;&gt;ZBasic&lt;/a&gt; contains a basic
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;, together with some simple
peripherals and several bus structures.  Once we exhaust the lessons from the
basic &lt;a href=&quot;https://github.com/ZipCPU/autofpga-demo&quot;&gt;AutoFPGA Demo&lt;/a&gt; project,
we may turn there for some more examples to draw demonstrations from.&lt;/p&gt;

&lt;p&gt;We’ll use &lt;a href=&quot;https://github.com/ZipCPU/autofpga-demo&quot;&gt;this example project&lt;/a&gt;
project, as a demonstration over the next couple of posts, showing what can be
done with &lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt;.&lt;/p&gt;

&lt;hr /&gt;&lt;p&gt;&lt;em&gt;And his disciples asked him, saying, 'Master, who did sin, this man, or his parents, that he was born blind?'&lt;/em&gt;</description>
        <pubDate>Thu, 05 Oct 2017 00:00:00 -0400</pubDate>
        <link>http://zipcpu.com/zipcpu/2017/10/05/autofpga-intro.html</link>
        <guid isPermaLink="true">http://zipcpu.com/zipcpu/2017/10/05/autofpga-intro.html</guid>
        
        
        <category>zipcpu</category>
        
      </item>
    
      <item>
        <title>A CORDIC testbench</title>
        <description>&lt;p&gt;Some time ago, I presented a
&lt;a href=&quot;/dsp/2017/08/30/cordic.html&quot;&gt;CORDIC algorithm&lt;/a&gt;
on
&lt;a href=&quot;http://zipcpu.com/&quot;&gt;this blog&lt;/a&gt;.
This &lt;a href=&quot;/dsp/2017/08/30/cordic.html&quot;&gt;CORDIC algorithm&lt;/a&gt;
makes it possible to generate sine and cosines using
normalized integers as phase angles and only additions and shifts.
The &lt;a href=&quot;/dsp/2017/08/30/cordic.html&quot;&gt;CORDIC algorithm&lt;/a&gt;
is unique because of the simple fact that it does not require any multiplies
to calculate these
&lt;a href=&quot;https://en.wikipedia.org/wiki/Trigonometry&quot;&gt;trigonometric&lt;/a&gt; values.&lt;/p&gt;

&lt;p&gt;Since that time, we’ve demonstrated the utility of
&lt;a href=&quot;/dsp/2017/08/30/cordic.html&quot;&gt;this algorithm&lt;/a&gt;
when &lt;a href=&quot;/dsp/2017/09/16/pwm-demo.html&quot;&gt;testing&lt;/a&gt;
a &lt;a href=&quot;/dsp/2017/09/04/pwm-reinvention.html&quot;&gt;proposed/modified PWM
algorithm&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;This is only the beginnings of what a
&lt;a href=&quot;/dsp/2017/08/30/cordic.html&quot;&gt;CORDIC algorithm&lt;/a&gt;
can be used for.  You can also modulate baseband signals to
intermediate/carrier frequencies, and downconvert them back to base band,
using the same approach.  It is really quite versatile.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/dsp/2017/08/30/cordic.html&quot;&gt;CORDIC&lt;/a&gt;’s
can also be used for generating test functions for
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
based &lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filters&lt;/a&gt;.
This is particularly where I’d like to go with the technology
on &lt;a href=&quot;http://zipcpu.com/&quot;&gt;this blog&lt;/a&gt;.
This means that our filtering test bench will depend upon this
&lt;a href=&quot;/dsp/2017/08/30/cordic.html&quot;&gt;CORDIC&lt;/a&gt; algorithm, and hence
any failure in the
&lt;a href=&quot;/dsp/2017/08/30/cordic.html&quot;&gt;CORDIC&lt;/a&gt; will have a ripple
affect into our future articles.&lt;/p&gt;

&lt;p&gt;For this reason, we need to get the
&lt;a href=&quot;/dsp/2017/08/30/cordic.html&quot;&gt;CORDIC&lt;/a&gt; &lt;a href=&quot;https://github.com/ZipCPU/cordic/blob/master/bench/cpp/cordic_tb.cpp&quot;&gt;test
bench&lt;/a&gt;
right.&lt;/p&gt;

&lt;p&gt;It also turns out that we made our problem more difficult by creating a
core generator approach to our
&lt;a href=&quot;/dsp/2017/08/30/cordic.html&quot;&gt;CORDIC algorithm&lt;/a&gt;.
Because of the core generation approach, our
&lt;a href=&quot;/dsp/2017/08/30/cordic.html&quot;&gt;CORDIC&lt;/a&gt; &lt;a href=&quot;https://github.com/ZipCPU/cordic/blob/master/bench/cpp/cordic_tb.cpp&quot;&gt;test
bench&lt;/a&gt;
will need to run across all manner of parameters: number of stages, input
data width, phase bit-width, extra internal bits, and output bit width.  So
that we could handle this extra variability, we took a pause in our
development in order to present some &lt;a href=&quot;/dsp/2017/09/27/quantization.html&quot;&gt;probabilistic quantities related to
quantization&lt;/a&gt;
which we can now use to predict the performance we expect so as to measure
how well we do in comparison to it.&lt;/p&gt;

&lt;p&gt;Building this &lt;a href=&quot;https://github.com/ZipCPU/cordic/blob/master/bench/cpp/cordic_tb.cpp&quot;&gt;test
bench&lt;/a&gt;
is going to take several steps.  The first several of those will estimate
how close we can expect the
&lt;a href=&quot;/dsp/2017/08/30/cordic.html&quot;&gt;CORDIC algorithm&lt;/a&gt;
to get to the right result.  This is important, because it will then form the
basis for any performance thresholds we might create to know if
&lt;a href=&quot;https://github.com/ZipCPU/cordic/blob/master/rtl/cordic.v&quot;&gt;our implementation&lt;/a&gt;
works.  These results can also be used as an estimate of how well the
&lt;a href=&quot;/dsp/2017/08/30/cordic.html&quot;&gt;CORDIC algorithm&lt;/a&gt;
will perform for arbitrary input parameters.&lt;/p&gt;

&lt;p&gt;Hence, after discussing both what
&lt;a href=&quot;/dsp/2017/09/27/quantization.html&quot;&gt;quantization&lt;/a&gt;
and phase &lt;a href=&quot;https://en.wikipedia.org/wiki/Variance&quot;&gt;variance&lt;/a&gt;
one might expect, we’ll turn our attention to building the actual &lt;a href=&quot;https://github.com/ZipCPU/cordic/blob/master/bench/cpp/cordic_tb.cpp&quot;&gt;test
bench&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;theorem-rules&quot;&gt;Theorem Rules&lt;/h2&gt;

&lt;p&gt;A &lt;a href=&quot;/dsp/2017/09/27/quantization.html&quot;&gt;previous post&lt;/a&gt; put
together a couple of probabilistic formula’s and
&lt;a href=&quot;https://en.wikipedia.org/wiki/Variance&quot;&gt;variance&lt;/a&gt;
rules.  Let’s just reiterate these for background here.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;/dsp/2017/09/27/quantization.html&quot;&gt;Quantization noise&lt;/a&gt;
has a &lt;a href=&quot;https://en.wikipedia.org/wiki/Variance&quot;&gt;variance&lt;/a&gt;
given by &lt;code class=&quot;highlighter-rouge&quot;&gt;1/12&lt;/code&gt;th of a perfect &lt;a href=&quot;https://en.wikipedia.org/wiki/Analog-to-digital_converter&quot;&gt;Analog to Digital Converter
(ADC)&lt;/a&gt;’s step
size.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The &lt;a href=&quot;https://en.wikipedia.org/wiki/Variance&quot;&gt;variance&lt;/a&gt;
of a &lt;a href=&quot;https://en.wikipedia.org/wiki/Random_variable&quot;&gt;random variable&lt;/a&gt;
multiplied by a constant is given by the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Variance&quot;&gt;variance&lt;/a&gt; of that
&lt;a href=&quot;https://en.wikipedia.org/wiki/Random_variable&quot;&gt;variable&lt;/a&gt;
times the constant squared.&lt;/p&gt;

    &lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/eqn-variance-scale.png&quot; alt=&quot;Equation showing how scale affects variance&quot; width=&quot;193&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

    &lt;p&gt;This applies to all
&lt;a href=&quot;https://en.wikipedia.org/wiki/Random_variable&quot;&gt;random variables&lt;/a&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;We’ll assume that any
&lt;a href=&quot;https://en.wikipedia.org/wiki/Random_variable&quot;&gt;random variables&lt;/a&gt;
we deal with are
&lt;a href=&quot;https://en.wikipedia.org/wiki/Independence_(probability_theory)&quot;&gt;independent&lt;/a&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The &lt;a href=&quot;https://en.wikipedia.org/wiki/Variance&quot;&gt;variance&lt;/a&gt; of the sum of two
&lt;a href=&quot;https://en.wikipedia.org/wiki/Random_variable&quot;&gt;random variables&lt;/a&gt; is given
by the sum of the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Variance&quot;&gt;variances&lt;/a&gt;:&lt;/p&gt;

    &lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/eqn-variance-sum.png&quot; alt=&quot;Equation showing the variance of the sum of two values&quot; width=&quot;283&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

    &lt;p&gt;This follows from our assumption that the two
&lt;a href=&quot;https://en.wikipedia.org/wiki/Random_variable&quot;&gt;random variables&lt;/a&gt;,
&lt;code class=&quot;highlighter-rouge&quot;&gt;X&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;Y&lt;/code&gt;, are
&lt;a href=&quot;https://en.wikipedia.org/wiki/Independence_(probability_theory)&quot;&gt;independent&lt;/a&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The
&lt;a href=&quot;https://en.wikipedia.org/wiki/Standard_deviation&quot;&gt;standard deviation&lt;/a&gt; of a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Random_variable&quot;&gt;random variable&lt;/a&gt;
is given by the square root of the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Variance&quot;&gt;variance&lt;/a&gt;.&lt;/p&gt;

    &lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/eqn-defn-stdev.png&quot; alt=&quot;Equation defining the standard deviation of a random variable&quot; width=&quot;145&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;These will form the basis of the error estimation work that follows.  Indeed,
we’ll use several of these properties at every step.&lt;/p&gt;

&lt;h2 id=&quot;from-core-generator-to-test-bench&quot;&gt;From Core Generator to Test Bench&lt;/h2&gt;

&lt;p&gt;One of the hassles of any test bench for a core generated algorithm is
communicating information from the core generator to other parts of the
design, such as the &lt;a href=&quot;https://github.com/ZipCPU/cordic/blob/master/bench/cpp/cordic_tb.cpp&quot;&gt;test
bench&lt;/a&gt;.
The problem has a simple solution.&lt;/p&gt;

&lt;p&gt;The approach we’ll take for dealing with this problem is to have the
&lt;a href=&quot;https://github.com/ZipCPU/cordic/tree/master/sw/&quot;&gt;core generator&lt;/a&gt; generate
not only the &lt;a href=&quot;https://github.com/ZipCPU/cordic/blob/master/rtl/cordic.v&quot;&gt;CORDIC&lt;/a&gt;
code itself, but also a
&lt;a href=&quot;https://github.com/ZipCPU/cordic/blob/master/rtl/cordic.h&quot;&gt;C header file&lt;/a&gt;
describing the relevant choices that were made in the
&lt;a href=&quot;https://github.com/ZipCPU/cordic/tree/master/sw/&quot;&gt;core generator&lt;/a&gt;.
The &lt;a href=&quot;https://github.com/ZipCPU/cordic/tree/master/sw&quot;&gt;core generator&lt;/a&gt;
will create &lt;a href=&quot;https://github.com/ZipCPU/cordic/blob/master/rtl/cordic.h&quot;&gt;this C header
file&lt;/a&gt;
any time the command line parameter &lt;code class=&quot;highlighter-rouge&quot;&gt;-c&lt;/code&gt; is given to it.&lt;/p&gt;

&lt;p&gt;The basic information found within &lt;a href=&quot;https://github.com/ZipCPU/cordic/blob/master/rtl/cordic.h&quot;&gt;this
file&lt;/a&gt;
includes the bit widths of the input (&lt;code class=&quot;highlighter-rouge&quot;&gt;IW&lt;/code&gt;), output (&lt;code class=&quot;highlighter-rouge&quot;&gt;OW&lt;/code&gt;), and phase (&lt;code class=&quot;highlighter-rouge&quot;&gt;PW&lt;/code&gt;).
It also includes the number of extra bits, &lt;code class=&quot;highlighter-rouge&quot;&gt;NEXTRA&lt;/code&gt;,
used in the &lt;a href=&quot;/dsp/2017/08/30/cordic.html&quot;&gt;CORDIC&lt;/a&gt;
computations, as well as the number of
&lt;a href=&quot;/dsp/2017/08/30/cordic.html&quot;&gt;CORDIC&lt;/a&gt;
stages, &lt;code class=&quot;highlighter-rouge&quot;&gt;NSTAGES&lt;/code&gt;.  Finally, this
&lt;a href=&quot;https://github.com/ZipCPU/cordic/blob/master/rtl/cordic.h&quot;&gt;header file&lt;/a&gt;
will contain information regarding whether or not the reset wire
or the &lt;a href=&quot;/blog/2017/08/14/strategies-for-pipelining.html&quot;&gt;traveling
CE&lt;/a&gt;
wire (&lt;code class=&quot;highlighter-rouge&quot;&gt;aux&lt;/code&gt;) were included within the design.&lt;/p&gt;

&lt;p&gt;We’ll add to this basic information some probabilistic prediction information
we’ll develop below.&lt;/p&gt;

&lt;p&gt;You can see an example of such a
&lt;a href=&quot;https://github.com/ZipCPU/cordic/blob/master/rtl/cordic.h&quot;&gt;C header file&lt;/a&gt;,
produced by our &lt;a href=&quot;https://github.com/ZipCPU/cordic/blob/master/sw/basiccordic.cpp&quot;&gt;core
generator&lt;/a&gt;,
&lt;a href=&quot;https://github.com/ZipCPU/cordic/blob/master/rtl/cordic.h&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;input-quantization&quot;&gt;Input Quantization&lt;/h2&gt;

&lt;p&gt;Now let’s start our run through the various errors or noise sources within the
&lt;a href=&quot;/dsp/2017/08/30/cordic.html&quot;&gt;CORDIC&lt;/a&gt; algorithm.&lt;/p&gt;

&lt;p&gt;The first noise source is the
&lt;a href=&quot;/dsp/2017/09/27/quantization.html&quot;&gt;quantization&lt;/a&gt;
of the input samples.  We can assume that both &lt;code class=&quot;highlighter-rouge&quot;&gt;i_xval&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;i_yval&lt;/code&gt; come with
an input &lt;a href=&quot;/dsp/2017/09/27/quantization.html&quot;&gt;quantization
variance&lt;/a&gt;
of &lt;code class=&quot;highlighter-rouge&quot;&gt;1/12&lt;/code&gt;th–as we &lt;a href=&quot;/dsp/2017/09/27/quantization.html&quot;&gt;discussed in our last
post&lt;/a&gt;.  Likewise, the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Variance&quot;&gt;variance&lt;/a&gt; of the phase is &lt;code class=&quot;highlighter-rouge&quot;&gt;1/12&lt;/code&gt;th of
the lowest phase unit squared.&lt;/p&gt;

&lt;p&gt;In our
&lt;a href=&quot;/dsp/2017/08/30/cordic.html&quot;&gt;CORDIC algorithm&lt;/a&gt;,
though, our first step was to multiply these input values by a programmable
number of extra bits.  The number of these extra bits was used to create a
working width, &lt;code class=&quot;highlighter-rouge&quot;&gt;WW&lt;/code&gt;, used below,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;// WW is the number of XTRA bits plus the maximum of IW and OW
// These lines therefore add XTRA bits to our values
//
wire	signed [(WW-1):0]	e_xval, e_yval;
assign	e_xval = { {i_xval[(IW-1)]}, i_xval, {(WW-IW-1){1&#39;b0}} };
assign	e_yval = { {i_yval[(IW-1)]}, i_yval, {(WW-IW-1){1&#39;b0}} };&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;To express this mathematically, we’ll let &lt;code class=&quot;highlighter-rouge&quot;&gt;x_i&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;y_i&lt;/code&gt; represent the
inputs to the algorithm, and &lt;code class=&quot;highlighter-rouge&quot;&gt;x_0&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;y_0&lt;/code&gt; represent the inputs to the first
rotation.  Since the precision of these values is not affected by the
pre-rotation step, no additional error is inserted there.  Hence, we have the
following representation for the inputs to our first rotation:&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/eqn-cordic-premul.png&quot; alt=&quot;Eqn for the pre-multiplication step&quot; width=&quot;281&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;In this equation, &lt;code class=&quot;highlighter-rouge&quot;&gt;e_xi&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;e_yi&lt;/code&gt; are any errors associated with the
inputs &lt;code class=&quot;highlighter-rouge&quot;&gt;x_i&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;y_i&lt;/code&gt;.  Once the multiply has been accomplished, we’ll
express the output as a sum of both the desired output &lt;code class=&quot;highlighter-rouge&quot;&gt;x_0&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;y_0&lt;/code&gt;,
together with the differences from perfection, &lt;code class=&quot;highlighter-rouge&quot;&gt;e_x0&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;e_y0&lt;/code&gt;.  These latter
two &lt;a href=&quot;https://en.wikipedia.org/wiki/Random_variable&quot;&gt;random values&lt;/a&gt;
are the errors in our precision following this step.&lt;/p&gt;

&lt;p&gt;Using our &lt;a href=&quot;https://en.wikipedia.org/wiki/Variance&quot;&gt;variance&lt;/a&gt;
rule for multiplying an input by a constant, the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Variance&quot;&gt;variance&lt;/a&gt;
of these two error terms, &lt;code class=&quot;highlighter-rouge&quot;&gt;e_x0&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;e_y0&lt;/code&gt;, is then given by,&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/eqn-cordic-premul-variance.png&quot; alt=&quot;Variance adjustment from the pre-multiplication step&quot; width=&quot;212&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;This is the then &lt;a href=&quot;https://en.wikipedia.org/wiki/Variance&quot;&gt;variance&lt;/a&gt;
at the input to our &lt;a href=&quot;/dsp/2017/08/30/cordic.html&quot;&gt;CORDIC rotation
stages&lt;/a&gt;.`
From here we’ll move to the rotation steps themselves.&lt;/p&gt;

&lt;h2 id=&quot;internal-truncation-error&quot;&gt;Internal Truncation Error&lt;/h2&gt;

&lt;p&gt;The next source of error within our &lt;a href=&quot;https://github.com/ZipCPU/cordic/blob/master/rtl/cordic.v&quot;&gt;CORDIC
implementation&lt;/a&gt;
may be found within the
&lt;a href=&quot;/dsp/2017/08/30/cordic.html&quot;&gt;CORDIC rotation stages&lt;/a&gt;
themselves.&lt;/p&gt;

&lt;p&gt;As you may recall, each
&lt;a href=&quot;/dsp/2017/08/30/cordic.html&quot;&gt;CORDIC stage&lt;/a&gt;
rotates the previous &lt;code class=&quot;highlighter-rouge&quot;&gt;x,y&lt;/code&gt; values using a transform matrix using the equations:&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/eqn-cordic-eqns-pm.png&quot; alt=&quot;Cordic equations&quot; width=&quot;350&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;There was also a corollary transform for when we wished to rotate in the
other direction.  To represent both, we used the plus-or-minus
character above.  Further, the minus-or-plus character above captures the fact
that two separate signs need to change together, but that they need to be
opposites of each other.&lt;/p&gt;

&lt;p&gt;However, while this was the rotation equation
&lt;a href=&quot;/dsp/2017/08/30/cordic.html&quot;&gt;we presented&lt;/a&gt;,
it wasn’t quite what our
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/cordic/blob/master/rtl/cordic.v&quot;&gt;code&lt;/a&gt;
accomplished within our
&lt;a href=&quot;https://github.com/ZipCPU/cordic/blob/master/rtl/cordic.v&quot;&gt;implementation&lt;/a&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;if (ph[i][(PW-1)]) // Negative phase
begin
	// If the phase is negative, rotate by the
	// CORDIC angle in a clockwise direction.
	xv[i+1] &amp;lt;= xv[i] + (yv[i]&amp;gt;&amp;gt;&amp;gt;(i+1));
	yv[i+1] &amp;lt;= yv[i] - (xv[i]&amp;gt;&amp;gt;&amp;gt;(i+1));
	ph[i+1] &amp;lt;= ph[i] + cordic_angle[i];
end else begin
	// On the other hand, if the phase is
	// positive ... rotate in the
	// counter-clockwise direction
	xv[i+1] &amp;lt;= xv[i] - (yv[i]&amp;gt;&amp;gt;&amp;gt;(i+1));
	yv[i+1] &amp;lt;= yv[i] + (xv[i]&amp;gt;&amp;gt;&amp;gt;(i+1));
	ph[i+1] &amp;lt;= ph[i] - cordic_angle[i];
end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Within our
&lt;a href=&quot;https://github.com/ZipCPU/cordic/blob/master/rtl/cordic.v&quot;&gt;implementation&lt;/a&gt;,
we truncated the values of &lt;code class=&quot;highlighter-rouge&quot;&gt;x_k&lt;/code&gt; and
&lt;code class=&quot;highlighter-rouge&quot;&gt;y_k&lt;/code&gt; after shifting them to the right.  This is equivalent to adding
&lt;a href=&quot;https://en.wikipedia.org/wiki/Random_variable&quot;&gt;random variable&lt;/a&gt;s,
&lt;code class=&quot;highlighter-rouge&quot;&gt;d_xk&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;d_yk&lt;/code&gt; to each of the &lt;code class=&quot;highlighter-rouge&quot;&gt;x_{k+1}&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;y_{k+1}&lt;/code&gt;
values in addition to the error terms brought to this stage from the prior
stage.  We can separate the desired result, &lt;code class=&quot;highlighter-rouge&quot;&gt;x_(k+1)&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;y_(k+1)&lt;/code&gt; from the
accumulated errors in the result, &lt;code class=&quot;highlighter-rouge&quot;&gt;e_x(k+1)&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;e_y(k+1)&lt;/code&gt; and re-represent
this as,&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/eqn-cordic-stage-w-err-terms.png&quot; alt=&quot;Cordic equations with noise&quot; width=&quot;617&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Using our addition of
&lt;a href=&quot;https://en.wikipedia.org/wiki/Variance&quot;&gt;variances&lt;/a&gt;
rule, together with the scale rule, we can calculate a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Variance&quot;&gt;variance&lt;/a&gt;
for the error term at the end of this stage.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/eqn-cordic-stage-variance.png&quot; alt=&quot;V[e_x] = (1+2^(-2k))*v[e_k]+V[d_k]&quot; width=&quot;393&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;At this point, we know &lt;code class=&quot;highlighter-rouge&quot;&gt;V[e_k]&lt;/code&gt; from the previous stage, and with the
exception of &lt;code class=&quot;highlighter-rouge&quot;&gt;V[d_k]&lt;/code&gt; we can calculate &lt;code class=&quot;highlighter-rouge&quot;&gt;V[e_(k+1)]&lt;/code&gt; for the next stage.
But … what is &lt;code class=&quot;highlighter-rouge&quot;&gt;V[d_k]&lt;/code&gt;?&lt;/p&gt;

&lt;p&gt;Unlike the
&lt;a href=&quot;/dsp/2017/09/27/quantization.html&quot;&gt;quantization&lt;/a&gt;
error we calculated earlier, truncation error is neither zero
&lt;a href=&quot;https://en.wikipedia.org/wiki/Mean#Mean_of_a_probability_distribution&quot;&gt;mean&lt;/a&gt;
nor does it have a &lt;code class=&quot;highlighter-rouge&quot;&gt;1/12&lt;/code&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Variance&quot;&gt;variance&lt;/a&gt;.
However, if we assume that the choice of direction is made randomly,
with a probability of one half for each rotation direction, then the truncation
error becomes zero
&lt;a href=&quot;https://en.wikipedia.org/wiki/Mean#Mean_of_a_probability_distribution&quot;&gt;mean&lt;/a&gt;.
(Half the time the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Mean#Mean_of_a_probability_distribution&quot;&gt;mean&lt;/a&gt;
is negative by one half, half the time it is positive by one half, etc.)
The &lt;a href=&quot;https://en.wikipedia.org/wiki/Variance&quot;&gt;variance&lt;/a&gt;,
though, is given by &lt;code class=&quot;highlighter-rouge&quot;&gt;1/3&lt;/code&gt; since we need to integrate from
&lt;code class=&quot;highlighter-rouge&quot;&gt;0&lt;/code&gt; to &lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt; instead of from &lt;code class=&quot;highlighter-rouge&quot;&gt;-1/2&lt;/code&gt; to &lt;code class=&quot;highlighter-rouge&quot;&gt;1/2&lt;/code&gt;:&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/eqn-cordic-truncation-variance.png&quot; alt=&quot;Truncation Variance = 1/3&quot; width=&quot;341&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Well, okay, that’s close but not quite right.  In reality, the truncation
error associated with truncating an already
&lt;a href=&quot;/dsp/2017/09/27/quantization.html&quot;&gt;quantizated&lt;/a&gt;
number requires an analysis of a &lt;a href=&quot;https://en.wikipedia.org/wiki/Probability_distribution#Discrete_probability_distribution&quot;&gt;discrete probability
distribution&lt;/a&gt;.
If we suppose that a finite number of bits, &lt;code class=&quot;highlighter-rouge&quot;&gt;k&lt;/code&gt;, are dropped in the
truncation then the variance is not &lt;code class=&quot;highlighter-rouge&quot;&gt;1/3&lt;/code&gt;rd but&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/eqn-cordic-discrete-truncation-variance.png&quot; alt=&quot;Discrete truncation variance only approximates 1/3&quot; width=&quot;380&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;The proof of this doesn’t fit on a single line, however, so we’ll leave the
details as an exercise for the student.&lt;/p&gt;

&lt;p&gt;After the
&lt;a href=&quot;/dsp/2017/08/30/cordic.html&quot;&gt;CORDIC rotation stages&lt;/a&gt;,
we rounded the result and produced an ouput.  That step, therefore, is next.&lt;/p&gt;

&lt;h2 id=&quot;output-variance&quot;&gt;Output Variance&lt;/h2&gt;

&lt;p&gt;The last step in calculating the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Variance&quot;&gt;variance&lt;/a&gt;
of the
&lt;a href=&quot;/dsp/2017/08/30/cordic.html&quot;&gt;CORDIC&lt;/a&gt;’s
output, is to adjust the resulting output
&lt;a href=&quot;https://en.wikipedia.org/wiki/Variance&quot;&gt;variance&lt;/a&gt;
due to the last rounding step:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;assign	pre_xval = xv[NSTAGES] + { {(OW){1&#39;b0}},
			xv[NSTAGES][(WW-OW)],
			{(WW-OW-1){!xv[NSTAGES][WW-OW]}}};
assign	pre_yval = yv[NSTAGES] + { {(OW){1&#39;b0}},
			yv[NSTAGES][(WW-OW)],
			{(WW-OW-1){!yv[NSTAGES][WW-OW]}}};

always @(posedge i_clk)
begin
	o_xval &amp;lt;= pre_xval[(WW-1):(WW-OW)];
	o_yval &amp;lt;= pre_yval[(WW-1):(WW-OW)];
	o_aux &amp;lt;= ax[NSTAGES];
end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;As you may recall, &lt;code class=&quot;highlighter-rouge&quot;&gt;WW&lt;/code&gt; was the working width we were using for the
&lt;a href=&quot;/dsp/2017/08/30/cordic.html&quot;&gt;CORDIC&lt;/a&gt;
transform stages, and &lt;code class=&quot;highlighter-rouge&quot;&gt;OW&lt;/code&gt; is the output width.  If &lt;code class=&quot;highlighter-rouge&quot;&gt;WW&lt;/code&gt; is greater than &lt;code class=&quot;highlighter-rouge&quot;&gt;OW&lt;/code&gt;,
then this stage drops bits and rounds the result.  This rounding step also
adds some more
&lt;a href=&quot;/dsp/2017/09/27/quantization.html&quot;&gt;quantization&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Variance&quot;&gt;variance&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Mathematically, we might write what is taking place with,&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/eqn-cordic-final-transform-step.png&quot; alt=&quot;The final CORDIC rounding step&quot; width=&quot;360&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;At this point, we know the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Variance&quot;&gt;variance&lt;/a&gt;
of just about all of the components.
&lt;code class=&quot;highlighter-rouge&quot;&gt;x_k&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;y_k&lt;/code&gt; are fixed values (not random), so their
&lt;a href=&quot;https://en.wikipedia.org/wiki/Variance&quot;&gt;variance&lt;/a&gt; is zero.
The &lt;a href=&quot;https://en.wikipedia.org/wiki/Variance&quot;&gt;variance&lt;/a&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;e_xk&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;e_yk&lt;/code&gt; were both calculated in the last step.
Using our
&lt;a href=&quot;/dsp/2017/09/27/quantization.html&quot;&gt;scale and addition rules&lt;/a&gt;,
we can express the final
&lt;a href=&quot;https://en.wikipedia.org/wiki/Variance&quot;&gt;variance&lt;/a&gt; as,&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/eqn-cordic-final-transform-variance.png&quot; alt=&quot;The final CORDIC transform variance&quot; width=&quot;361&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;The &lt;a href=&quot;https://en.wikipedia.org/wiki/Variance&quot;&gt;variance&lt;/a&gt;
of &lt;code class=&quot;highlighter-rouge&quot;&gt;d_xo&lt;/code&gt; is the only thing left to discuss.  This is the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Variance&quot;&gt;variance&lt;/a&gt;
associated with our rounding step.  If we treat the value as continuous, then
the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Variance&quot;&gt;variance&lt;/a&gt;
of &lt;code class=&quot;highlighter-rouge&quot;&gt;d_xo&lt;/code&gt; would be &lt;code class=&quot;highlighter-rouge&quot;&gt;1/12&lt;/code&gt;th.  This isn’t quite the case, since
&lt;code class=&quot;highlighter-rouge&quot;&gt;d_xo&lt;/code&gt; is quantized, but it makes a decent approximation.  (The actual number
starts at &lt;code class=&quot;highlighter-rouge&quot;&gt;1/8&lt;/code&gt; for dropping one bit, and asymptotes at &lt;code class=&quot;highlighter-rouge&quot;&gt;1/12&lt;/code&gt; for dropping
an infinite number of bits.)&lt;/p&gt;

&lt;p&gt;We can now use this value to calculate the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Variance&quot;&gt;variance&lt;/a&gt;
both at the end of each
&lt;a href=&quot;/dsp/2017/08/30/cordic.html&quot;&gt;CORDIC&lt;/a&gt;
stage, as well as at the end of the entire algorithm.
We’ll place the code to calculate this value within our generic
&lt;a href=&quot;https://github.com/ZipCPU/cordic/blob/master/sw/cordiclib.cpp&quot;&gt;CORDIC library&lt;/a&gt;:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;&lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt;	&lt;span class=&quot;nf&quot;&gt;transform_quantization_variance&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nstages&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;xtrabits&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dropped_bits&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;current_variance&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

	&lt;span class=&quot;n&quot;&gt;current_variance&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pow&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;xtrabits&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;12.&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

	&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nstages&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;current_variance&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pow&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;current_variance&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;3.&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

	&lt;span class=&quot;c1&quot;&gt;// If we drop bits from this on the output, then we add more variance
&lt;/span&gt;	&lt;span class=&quot;c1&quot;&gt;// in the process.  This is rounding variance, so the variance is
&lt;/span&gt;	&lt;span class=&quot;c1&quot;&gt;// (roughly) 1/12th.
&lt;/span&gt;	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dropped_bits&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;current_variance&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pow&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dropped_bits&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;current_variance&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;12.&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;current_variance&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The result of this calculation will be passed to the &lt;a href=&quot;https://github.com/ZipCPU/cordic/blob/master/bench/cpp/cordic_tb.cpp&quot;&gt;test
bench&lt;/a&gt;
by passing a &lt;code class=&quot;highlighter-rouge&quot;&gt;QUANTIZATION_VARIANCE&lt;/code&gt; value to the &lt;a href=&quot;https://github.com/ZipCPU/cordic/blob/master/bench/cpp/cordic_tb.cpp&quot;&gt;test
bench&lt;/a&gt;
within our core-generated
&lt;a href=&quot;https://github.com/ZipCPU/cordic/blob/master/rtl/cordic.h&quot;&gt;header file&lt;/a&gt;:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;QUANTIZATION_VARIANCE&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;actual&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;goes&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;here&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;//&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Units&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;^&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This will then inform our &lt;a href=&quot;https://github.com/ZipCPU/cordic/blob/master/bench/cpp/cordic_tb.cpp&quot;&gt;test bench
code&lt;/a&gt;
the average sum of square errors that it can expect.&lt;/p&gt;

&lt;p&gt;At this point, we’re almost done with our pre-work.  We have only one step
left, and that is looking into any
&lt;a href=&quot;https://en.wikipedia.org/wiki/Variance&quot;&gt;variance&lt;/a&gt;
associated with the phase accumulator.&lt;/p&gt;

&lt;h2 id=&quot;phase-error&quot;&gt;Phase Error&lt;/h2&gt;

&lt;p&gt;There’s one last component to the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Variance&quot;&gt;variance&lt;/a&gt;
of our result, and that’s the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Variance&quot;&gt;variance&lt;/a&gt;
associated with the phase accumulator.  You may recall that, at each
stage of our
&lt;a href=&quot;/dsp/2017/08/30/cordic.html&quot;&gt;CORDIC algorithm&lt;/a&gt;, we added
or subtracted an amount of phase to a phase accumulator.  We calculated
these phase values within
&lt;a href=&quot;https://github.com/ZipCPU/cordic/blob/master/sw/cordiclib.cpp&quot;&gt;cordiclib.cpp&lt;/a&gt;
and placed these values into the &lt;code class=&quot;highlighter-rouge&quot;&gt;cordic_angle&lt;/code&gt; array within our &lt;a href=&quot;https://github.com/ZipCPU/cordic/blob/master/rtl/cordic.v&quot;&gt;generated
routine&lt;/a&gt;.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/eqn-cordic-phase.png&quot; alt=&quot;theta_k = atan(2^{-k})&quot; width=&quot;168&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;The problem with this array is that the phase values had to be
&lt;a href=&quot;/dsp/2017/09/27/quantization.html&quot;&gt;quantized&lt;/a&gt;
in order to be placed into this integer array.  This quantization can be
found within our
&lt;a href=&quot;https://github.com/ZipCPU/cordic/blob/master/sw/cordiclib.cpp&quot;&gt;CORDIC library&lt;/a&gt;:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;	&lt;span class=&quot;nf&quot;&gt;cordic_angles&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;FILE&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nstages&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;phase_bits&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;// ...
&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nstages&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt;		&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;phase_value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

		&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;atan2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;1.&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pow&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
		&lt;span class=&quot;c1&quot;&gt;// ...
&lt;/span&gt;		&lt;span class=&quot;c1&quot;&gt;// Convert this value from radians to our integer phase units
&lt;/span&gt;		&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;4.0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1ul&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;phase_bits&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)))&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;M_PI&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;2.0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

		&lt;span class=&quot;c1&quot;&gt;// Here&#39;s where we truncate our phase from a double to an
&lt;/span&gt;		&lt;span class=&quot;c1&quot;&gt;// integer.
&lt;/span&gt;		&lt;span class=&quot;n&quot;&gt;phase_value&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;c1&quot;&gt;// ...
&lt;/span&gt;	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;// ...
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This means that though we intended to rotate by one angle,
we ended up rotating by an approximation of that angle.  If we let
&lt;code class=&quot;highlighter-rouge&quot;&gt;gamma&lt;/code&gt; reference the
&lt;a href=&quot;/dsp/2017/08/30/cordic.html&quot;&gt;CORDIC&lt;/a&gt;
gain, &lt;code class=&quot;highlighter-rouge&quot;&gt;R(theta)&lt;/code&gt; represent the rotation we
wanted to accomplish, and &lt;code class=&quot;highlighter-rouge&quot;&gt;e_ox&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;e_oy&lt;/code&gt; be the algorithm errors we’ve
been discussing so far, then our result should be:&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/eqn-cordic-desired.png&quot; alt=&quot;[X,Y] = gR(theta)+errs&quot; width=&quot;337&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;The problem with this representation is that it doesn’t acknowledge any of these
phase errors.  In other words, because we’ve only &lt;em&gt;approximated&lt;/em&gt; the
phase errors with integers, we ended up rotating by a different phase–one
that was &lt;em&gt;close&lt;/em&gt; to what we wanted to rotate by:&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/eqn-cordic-err-rotation.png&quot; alt=&quot;[X,Y] = gR(theta+eta)+errs&quot; width=&quot;375&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;If we separate the rotation into two rotations, one by the rotation we want,
&lt;code class=&quot;highlighter-rouge&quot;&gt;R(theta)&lt;/code&gt;, and the other by the rotation we didn’t want, &lt;code class=&quot;highlighter-rouge&quot;&gt;R(eta)&lt;/code&gt;, we can
rewrite this as:&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/eqn-cordic-rotation-separated.png&quot; alt=&quot;[X,Y] = gR(theta)R(eta)+errs&quot; width=&quot;544&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Finally, if we use a small angle approximation for &lt;code class=&quot;highlighter-rouge&quot;&gt;eta&lt;/code&gt;, then this can be
rewritten as something a touch more useful:&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/eqn-cordic-rotation-variance.png&quot; alt=&quot;EQN approximating eta with a small angle formula&quot; width=&quot;446&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;At this point, our results are separated between the results we want, together
with an additive “noise” term that we didn’t want.  From here, then, we can use
our &lt;a href=&quot;/dsp/2017/09/27/quantization.html&quot;&gt;scale and addition
rules&lt;/a&gt;
to determine the &lt;a href=&quot;https://en.wikipedia.org/wiki/Variance&quot;&gt;variance&lt;/a&gt;
of the result.  This is given by first the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Variance&quot;&gt;variance&lt;/a&gt;
we worked out in the last session, &lt;code class=&quot;highlighter-rouge&quot;&gt;V[e_o]&lt;/code&gt;, as well as a new term
associated with the rotation error.  This new term consists of a couple
of scalar values, both the known
&lt;a href=&quot;/dsp/2017/08/30/cordic.html&quot;&gt;CORDIC&lt;/a&gt;
gain, &lt;code class=&quot;highlighter-rouge&quot;&gt;gamma&lt;/code&gt; and the outputs of our algorithm, &lt;code class=&quot;highlighter-rouge&quot;&gt;x_k&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;y_k&lt;/code&gt;.  It also
consists of the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Variance&quot;&gt;variance&lt;/a&gt;
of our random phase variable, &lt;code class=&quot;highlighter-rouge&quot;&gt;eta&lt;/code&gt;.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/eqn-cordic-rotation-err-variance.png&quot; alt=&quot;V[ghx+ey]=g^2x^2V[h]+V[ey]&quot; width=&quot;363&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;That’s how random phase errors are going to affect our output.&lt;/p&gt;

&lt;p&gt;But, what is this last phase
&lt;a href=&quot;https://en.wikipedia.org/wiki/Variance&quot;&gt;variance&lt;/a&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;V[eta]&lt;/code&gt;?&lt;/p&gt;

&lt;p&gt;To understand that, let’s go back and look through the logic for the
&lt;a href=&quot;/dsp/2017/08/30/cordic.html&quot;&gt;CORDIC&lt;/a&gt;
stages again.  At each stage, we approximated a phase with an integer
(quantized) value.  Unlike before, where the difference between the true value
and the quantized value was unknown,
in this case we know the difference between the original phase
value and its truncated representation.  Hence, with a probability of one
half that this difference should be positive, and one half that it is
negative, we can calculate the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Variance&quot;&gt;variance&lt;/a&gt;
of the accumulated phase.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;&lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt;	&lt;span class=&quot;nf&quot;&gt;phase_variance&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nstages&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;phase_bits&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;RAD_TO_PHASE&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1ul&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;phase_bits&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)))&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;M_PI&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;variance&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

	&lt;span class=&quot;c1&quot;&gt;// Start with an initial quantization variance, before we do anything
&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;variance&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;1.&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;12.&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nstages&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt;		&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;err&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;phase_value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

		&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;atan2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;1.&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pow&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;RAD_TO_PHASE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;phase_value&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;c1&quot;&gt;// Calculate the error between the phase we want, and our
&lt;/span&gt;		&lt;span class=&quot;c1&quot;&gt;// integer phase representation
&lt;/span&gt;		&lt;span class=&quot;n&quot;&gt;err&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;phase_value&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;c1&quot;&gt;// Square it to turn it into a variance.
&lt;/span&gt;		&lt;span class=&quot;n&quot;&gt;err&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;err&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;c1&quot;&gt;// Accumulate it with the rest of the variance(s)
&lt;/span&gt;		&lt;span class=&quot;c1&quot;&gt;// from the cordic angles
&lt;/span&gt;		&lt;span class=&quot;n&quot;&gt;variance&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;err&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

	&lt;span class=&quot;c1&quot;&gt;// Convert the calculated variance back to radians
&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;variance&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pow&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;RAD_TO_PHASE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;2.&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;variance&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;We’ll calculate and place this rotation phase error into its own value
within our core-generated
&lt;a href=&quot;https://github.com/ZipCPU/cordic/blob/master/rtl/cordic.h&quot;&gt;C header file&lt;/a&gt;:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;PHASE_VARIANCE_RAD&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;actual&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;goes&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;here&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;//&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Radians&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;^&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;So, at this point we’ve worked out the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Variance&quot;&gt;variance&lt;/a&gt;
associated with our
&lt;a href=&quot;/dsp/2017/08/30/cordic.html&quot;&gt;CORDIC rotation&lt;/a&gt;s,
and now we’ve worked out the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Variance&quot;&gt;variance&lt;/a&gt;
associated with truncated our phase accumulator values.  With these values, we
can now begin to put our &lt;a href=&quot;https://github.com/ZipCPU/cordic/blob/master/bench/cpp/cordic_tb.cpp&quot;&gt;test
bench&lt;/a&gt;
together.&lt;/p&gt;

&lt;h2 id=&quot;building-the-test-bench&quot;&gt;Building the Test Bench&lt;/h2&gt;

&lt;p&gt;This has taken a lot of background, but it’s now time to build our &lt;a href=&quot;https://github.com/ZipCPU/cordic/blob/master/bench/cpp/cordic_tb.cpp&quot;&gt;test
bench&lt;/a&gt;.
Our test bench will be based around the idea of rotating a fixed, maximal
valued, input through all of the possible phase rotations.&lt;/p&gt;

&lt;p&gt;To start, we’ll define some helper values, both the log (based two) of the
number of test samples as well as the number of test samples, that the
rest of our code here can reference.  Since we’re going to go through one
wavelength of a sine wave, these are determined by the phase width parameter,
&lt;code class=&quot;highlighter-rouge&quot;&gt;PW&lt;/code&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;LGNSAMPLES&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;PW&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;NSAMPLES&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1ul&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;LGNSAMPLES&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;We’ll also set our sine wave’s amplitude to the maximum value that will not
overflow,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;&lt;span class=&quot;n&quot;&gt;m_core&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i_xval&lt;/span&gt;  &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1ul&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;IW&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;m_core&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i_yval&lt;/span&gt;  &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This value will be necessary to maximize our
&lt;a href=&quot;https://en.wikipedia.org/wiki/Carrier-to-noise_ratio&quot;&gt;Carrier-to-noise ratio&lt;/a&gt;
in the face of a fixed amount of background noise.&lt;/p&gt;

&lt;p&gt;With this as background, we can create &lt;code class=&quot;highlighter-rouge&quot;&gt;NSAMPLES&lt;/code&gt; test cases, pushing the
inputs into our
&lt;a href=&quot;/dsp/2017/08/30/cordic.html&quot;&gt;CORDIC algorithm&lt;/a&gt;’s
&lt;a href=&quot;https://github.com/ZipCPU/cordic/blob/master/rt/cordic.v&quot;&gt;HDL routine&lt;/a&gt;.
The difference from one test to the next will be the phase rotation.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;	&lt;span class=&quot;n&quot;&gt;idx&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NSAMPLES&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;shift&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;PW&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;LGNSAMPLES&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;shift&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
			&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;sv&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
			&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1ul&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;shift&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)))&lt;/span&gt;
				&lt;span class=&quot;c1&quot;&gt;// Odd value, round down
&lt;/span&gt;				&lt;span class=&quot;n&quot;&gt;sv&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1ul&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;shift&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
			&lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;
				&lt;span class=&quot;n&quot;&gt;sv&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1ul&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;shift&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;tb&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_core&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i_phase&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sv&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;shift&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
		&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;tb&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_core&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i_phase&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;shift&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;pdata&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tb&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_core&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i_phase&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;ixval&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tb&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_core&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i_xval&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;iyval&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tb&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_core&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i_yval&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;tb&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_core&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i_aux&lt;/span&gt;   &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;tb&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tick&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;

		&lt;span class=&quot;o&quot;&gt;//&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;We’re also going to insist that this algorithm uses the &lt;a href=&quot;/blog/2017/08/14/strategies-for-pipelining.html&quot;&gt;travelling
CE&lt;/a&gt;
form of pipeline management.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;	&lt;span class=&quot;n&quot;&gt;assert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;HAS_AUX&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This means that we set &lt;code class=&quot;highlighter-rouge&quot;&gt;i_aux&lt;/code&gt; on any input
with a valid value, and anytime &lt;code class=&quot;highlighter-rouge&quot;&gt;o_aux&lt;/code&gt; is true on the output we’ll have a
valid output value.  So that we can work on all these values at the same
time, we’ll place the output values into an array as they become valid.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;		&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tb&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_core&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;o_aux&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;shift&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;8&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;OW&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
			&lt;span class=&quot;c1&quot;&gt;// Make our values signed..
&lt;/span&gt;			&lt;span class=&quot;n&quot;&gt;xval&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;idx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tb&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_core&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;o_xval&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;shift&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;yval&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;idx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tb&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_core&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;o_yval&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;shift&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;xval&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;idx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;shift&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;yval&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;idx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;shift&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
			&lt;span class=&quot;c1&quot;&gt;// printf(&quot;%08x&amp;lt;&amp;lt;%d: %08x %08x\n&quot;, (unsigned)pdata[i], shift, xval[idx], yval[idx]);
&lt;/span&gt;			&lt;span class=&quot;n&quot;&gt;idx&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;You may notice how &lt;code class=&quot;highlighter-rouge&quot;&gt;idx&lt;/code&gt; is used to separate the actual loop variable, &lt;code class=&quot;highlighter-rouge&quot;&gt;i&lt;/code&gt;,
from the array index associated with the return values.  This allows us to
compensate for whatever delay the algorithm might have.&lt;/p&gt;

&lt;p&gt;Since the
&lt;a href=&quot;/dsp/2017/08/30/cordic.html&quot;&gt;CORDIC&lt;/a&gt;
takes a couple clocks to process its results, our last output will likely
not be available to us as soon as we provide our last input.  Hence, we’ll need
to flush these last results out.  To do this, we set the input &lt;a href=&quot;/blog/2017/08/14/strategies-for-pipelining.html&quot;&gt;traveling
CE&lt;/a&gt;
bit, &lt;code class=&quot;highlighter-rouge&quot;&gt;i_aux&lt;/code&gt;, to zero and wait till the output CE bit, &lt;code class=&quot;highlighter-rouge&quot;&gt;o_aux&lt;/code&gt; goes to zero
as well.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;	&lt;span class=&quot;n&quot;&gt;tb&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_core&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i_aux&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tb&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_core&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;o_aux&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;shift&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;8&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;OW&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;tb&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_core&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i_aux&lt;/span&gt;   &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;tb&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tick&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;

		&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tb&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_core&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;o_aux&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;xval&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;idx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tb&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_core&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;o_xval&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;shift&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;yval&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;idx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tb&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_core&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;o_yval&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;shift&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;xval&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;idx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;shift&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;yval&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;idx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;shift&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
			&lt;span class=&quot;c1&quot;&gt;// printf(&quot;%08x %08x\n&quot;, xval[idx], yval[idx]);
&lt;/span&gt;			&lt;span class=&quot;n&quot;&gt;idx&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;assert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;idx&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NSAMPLES&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
		&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Finally, let’s pull all these results together and examine them.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;	&lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;mxerr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;averr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mag&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;imag&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sumxy&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;sumsq&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sumd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NSAMPLES&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;shift&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;ph&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dxval&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dyval&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;err&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

		&lt;span class=&quot;o&quot;&gt;//&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The first step in evaluating these results is going to be determine the
answers that the &lt;a href=&quot;/dsp/2017/08/30/cordic.html&quot;&gt;CORDIC&lt;/a&gt;
algorithm was &lt;em&gt;supposed&lt;/em&gt; to produce.  In other words,
what angle was given to it, what rectangular coordinates were given to it,
and therefore what values, &lt;code class=&quot;highlighter-rouge&quot;&gt;dxval&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;dyval&lt;/code&gt;, &lt;em&gt;should’ve&lt;/em&gt; been returned.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;		&lt;span class=&quot;n&quot;&gt;ph&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pdata&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;ph&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ph&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;M_PI&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;2.0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1u&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;PW&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;dxval&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cos&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ph&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ixval&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ph&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;iyval&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;dyval&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ph&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ixval&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cos&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ph&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;iyval&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The &lt;a href=&quot;/dsp/2017/08/30/cordic.html&quot;&gt;CORDIC algorithm&lt;/a&gt;
applied a gain to our inputs, as we
&lt;a href=&quot;/dsp/2017/08/30/cordic.html&quot;&gt;discussed earlier&lt;/a&gt;.
Hence, the output is not just the rotated input, but that rotated result needs
to be multiplied by the
&lt;a href=&quot;/dsp/2017/08/30/cordic.html&quot;&gt;CORDIC&lt;/a&gt;
gain before we can tell if it was done right or not.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;		&lt;span class=&quot;n&quot;&gt;dxval&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GAIN&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;dyval&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GAIN&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;As a last step in trying to figure out what our answer &lt;em&gt;should&lt;/em&gt; be, we’ll need
to compensate our &lt;em&gt;perfect&lt;/em&gt; answer for any change in word width.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;		&lt;span class=&quot;n&quot;&gt;shift&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;IW&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;OW&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;IW&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;OW&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;dxval&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*=&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;1.&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1u&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;shift&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;dyval&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*=&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;1.&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1u&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;shift&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
		&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;OW&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;IW&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;dxval&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*=&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;1.&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1u&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;shift&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;dyval&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*=&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;1.&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1u&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;shift&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
		&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Now that we know the value we wanted the
&lt;a href=&quot;/dsp/2017/08/30/cordic.html&quot;&gt;CORDIC algorithm&lt;/a&gt;
to produce,
let’s compare it to the value that was produced.  We’ll estimate the
squared differences between what we think the algorithm should produce
and what it actually produced in the variable, &lt;code class=&quot;highlighter-rouge&quot;&gt;err&lt;/code&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;		&lt;span class=&quot;c1&quot;&gt;// The error between the value requested and the value resulting
&lt;/span&gt;		&lt;span class=&quot;n&quot;&gt;err&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dxval&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;xval&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dxval&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;xval&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]);&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;err&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dyval&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;yval&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dyval&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;yval&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;We can even calculate an average of this squared error, by accumulating these
square values into &lt;code class=&quot;highlighter-rouge&quot;&gt;averr&lt;/code&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;		&lt;span class=&quot;n&quot;&gt;averr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;err&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;As a final value to examine, let’s keep track of the maximum difference
between our expected and returned values.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;		&lt;span class=&quot;n&quot;&gt;err&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sqrt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;err&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;err&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mxerr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;mxerr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;err&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;To turn the sum of the squared errors into an estimated
&lt;a href=&quot;https://en.wikipedia.org/wiki/Standard_deviation&quot;&gt;standard deviation&lt;/a&gt;,
we’ll need to divide by the number of samples and take the square root of the
result.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;	&lt;span class=&quot;n&quot;&gt;averr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NSAMPLES&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;averr&lt;/span&gt;  &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sqrt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;averr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;We can check whether or not this average squared error is within bounds, and
fail if not.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;averr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;1.5&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sqrt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;QUANTIZATION_VARIANCE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;failed&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The &lt;a href=&quot;https://en.wikipedia.org/wiki/Magic_number_(programming)&quot;&gt;magic number&lt;/a&gt;
in this comparison, &lt;code class=&quot;highlighter-rouge&quot;&gt;1.5&lt;/code&gt;, is simply a heuristic that has worked for me so far.
While a threshold could be calculated from a proper &lt;a href=&quot;https://en.wikipedia.org/wiki/Statistical_hypothesis_testing&quot;&gt;statistical hypothesis
test&lt;/a&gt; basis, this
number has worked well enough for me.&lt;/p&gt;

&lt;p&gt;In a similar fashion, the maximum error should lie within a fixed number
of &lt;a href=&quot;https://en.wikipedia.org/wiki/Standard_deviation&quot;&gt;standard deviation&lt;/a&gt;s
from zero.  The
&lt;a href=&quot;https://en.wikipedia.org/wiki/Magic_number_(programming)&quot;&gt;magic number&lt;/a&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;5.2&lt;/code&gt; below is a heuristic, though, since we haven’t done the proper
statistical analysis to make this exact.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mxerr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;5.2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sqrt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;expected_err&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;ERR: Maximum error is out of bounds&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;failed&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Perhaps a more useful result is the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Carrier-to-noise_ratio&quot;&gt;Carrier-to-noise ratio&lt;/a&gt;
that can be achieved.  This should be given by the energy in the sine wave
input, times the
&lt;a href=&quot;/dsp/2017/08/30/cordic.html&quot;&gt;CORDIC&lt;/a&gt;
gain, squared and then divided by the estimated
&lt;a href=&quot;https://en.wikipedia.org/wiki/Variance&quot;&gt;variance&lt;/a&gt;.  Since we already have the
sine wave magnitude times the
&lt;a href=&quot;/dsp/2017/08/30/cordic.html&quot;&gt;CORDIC&lt;/a&gt;
gain captured by our &lt;code class=&quot;highlighter-rouge&quot;&gt;scale&lt;/code&gt; variable, we can just square this to get our
&lt;a href=&quot;/dsp/2017/08/30/cordic.html&quot;&gt;CORDIC&lt;/a&gt;
carrier energy.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;	&lt;span class=&quot;n&quot;&gt;scale&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GAIN&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;CNR    : %.2f dB&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;10.0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;scale&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;scale&lt;/span&gt;
			&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;averr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;averr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;10.0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;As a last test of whether or not this
&lt;a href=&quot;/dsp/2017/08/30/cordic.html&quot;&gt;CORDIC algorithm&lt;/a&gt;
works, let’s check out the &lt;a href=&quot;https://en.wikipedia.org/wiki/Spurious-free_dynamic_range&quot;&gt;Spurious Free Dynamic Range
(SFDR)&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;We’ll use the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Fast_Fourier_transform&quot;&gt;FFT&lt;/a&gt;
of the core’s output to find the maximum spur energy for our
&lt;a href=&quot;https://en.wikipedia.org/wiki/Spurious-free_dynamic_range&quot;&gt;SFDR&lt;/a&gt;
estimate.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;PW&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;26&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NSAMPLES&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1ul&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PW&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)))&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;typedef&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;complex&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;COMPLEX&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;COMPLEX&lt;/span&gt;	&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;outpt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt;	&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;FFTLEN&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1ul&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;PW&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

		&lt;span class=&quot;n&quot;&gt;outpt&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;COMPLEX&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;FFTLEN&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;

		&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;FFTLEN&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;outpt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;real&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;xval&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;outpt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;imag&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;yval&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
		&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

		&lt;span class=&quot;c1&quot;&gt;// Now we need to do an FFT
&lt;/span&gt;		&lt;span class=&quot;n&quot;&gt;cfft&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;outpt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;FFTLEN&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;We’ll then use the energy in the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Fast_Fourier_transform&quot;&gt;FFT&lt;/a&gt;
output bin related to our signal for our signal’s energy, while using the
maximum output bin energy across the rest of the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Fast_Fourier_transform&quot;&gt;FFT&lt;/a&gt;
for the maximum spur energy.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;		&lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;master&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;spur&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tmp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

		&lt;span class=&quot;c1&quot;&gt;// Master is the energy in the signal of interest
&lt;/span&gt;		&lt;span class=&quot;n&quot;&gt;master&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;norm&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;outpt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]);&lt;/span&gt;

		&lt;span class=&quot;c1&quot;&gt;// SPUR is the energy in any other FFT bin output
&lt;/span&gt;		&lt;span class=&quot;n&quot;&gt;spur&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;norm&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;outpt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]);&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;FFTLEN&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;tmp&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;norm&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;outpt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]);&lt;/span&gt;
			&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tmp&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;spur&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
				&lt;span class=&quot;n&quot;&gt;spur&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tmp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The ratio of these two values is the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Spurious-free_dynamic_range&quot;&gt;SFDR&lt;/a&gt;,
another indication of the quality of how well this algorithm works.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;		&lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;SPFR = %7.2f dBc&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
			&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;master&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;spur&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;10.&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Unlike the average error, though, which we could calculate from the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Expected_value&quot;&gt;expected&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Variance&quot;&gt;variance&lt;/a&gt;
above, predicting the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Spurious-free_dynamic_range&quot;&gt;SFDR&lt;/a&gt;
isn’t as simple.  Therefore, we’ll only calculate it as part of our &lt;a href=&quot;https://github.com/ZipCPU/cordic/blob/master/bench/cpp/cordic_tb.cpp&quot;&gt;test
bench&lt;/a&gt;
and leave you to decide whether it is good enough.&lt;/p&gt;

&lt;h2 id=&quot;performance-numbers&quot;&gt;Performance Numbers&lt;/h2&gt;

&lt;p&gt;We can now measure both &lt;em&gt;if&lt;/em&gt; our
&lt;a href=&quot;/dsp/2017/08/30/cordic.html&quot;&gt;CORDIC algorithm&lt;/a&gt; works,
as well as how well it works.&lt;/p&gt;

&lt;p&gt;So … how well &lt;em&gt;does&lt;/em&gt; it work?&lt;/p&gt;

&lt;p&gt;Just to find out, I ran the
&lt;a href=&quot;/dsp/2017/08/30/cordic.html&quot;&gt;CORDIC&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/cordic/tree/master/sw/&quot;&gt;core generator software&lt;/a&gt;,
and tested the
&lt;a href=&quot;/dsp/2017/08/30/cordic.html&quot;&gt;CORDIC algorithm&lt;/a&gt;
for a variety of bit widths and phase bit widths.  Shown below, in Table 1,
are the &lt;a href=&quot;https://en.wikipedia.org/wiki/Carrier-to-noise_ratio&quot;&gt;Carrier-to-noise ratio
(CNR)&lt;/a&gt; and &lt;a href=&quot;https://en.wikipedia.org/wiki/Spurious-free_dynamic_range&quot;&gt;Spurious Free
Dynamic Range&lt;/a&gt;
measurements the &lt;a href=&quot;https://github.com/ZipCPU/cordic/blob/master/bench/cpp/cordic_tb.cpp&quot;&gt;test
bench&lt;/a&gt;
recorded.&lt;/p&gt;

&lt;table align=&quot;center&quot; border=&quot;&quot;&gt;&lt;tr&gt;&lt;th&gt;IW, OW Bits&lt;/th&gt;&lt;th&gt;Phase bits&lt;/th&gt;&lt;th&gt;Xtra Bits&lt;/th&gt;&lt;th&gt;CNR&lt;/th&gt;&lt;th&gt;SFDR&lt;/th&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt; 8&lt;/td&gt;&lt;td&gt;13&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;42&lt;/td&gt;&lt;td&gt;43&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt; 8&lt;/td&gt;&lt;td&gt;14&lt;/td&gt;&lt;td&gt;2&lt;/td&gt;&lt;td&gt;46&lt;/td&gt;&lt;td&gt;57&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt; 8&lt;/td&gt;&lt;td&gt;15&lt;/td&gt;&lt;td&gt;3&lt;/td&gt;&lt;td&gt;49&lt;/td&gt;&lt;td&gt;62&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt; 8&lt;/td&gt;&lt;td&gt;16&lt;/td&gt;&lt;td&gt;4&lt;/td&gt;&lt;td&gt;50&lt;/td&gt;&lt;td&gt;64&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;12&lt;/td&gt;&lt;td&gt;17&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;65&lt;/td&gt;&lt;td&gt;69&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;12&lt;/td&gt;&lt;td&gt;18&lt;/td&gt;&lt;td&gt;2&lt;/td&gt;&lt;td&gt;69&lt;/td&gt;&lt;td&gt;82&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;12&lt;/td&gt;&lt;td&gt;19&lt;/td&gt;&lt;td&gt;3&lt;/td&gt;&lt;td&gt;73&lt;/td&gt;&lt;td&gt;88&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;12&lt;/td&gt;&lt;td&gt;20&lt;/td&gt;&lt;td&gt;4&lt;/td&gt;&lt;td&gt;74&lt;/td&gt;&lt;td&gt;94&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;16&lt;/td&gt;&lt;td&gt;21&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;87&lt;/td&gt;&lt;td&gt;92&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;16&lt;/td&gt;&lt;td&gt;22&lt;/td&gt;&lt;td&gt;2&lt;/td&gt;&lt;td&gt;92&lt;/td&gt;&lt;td&gt;106&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;16&lt;/td&gt;&lt;td&gt;23&lt;/td&gt;&lt;td&gt;3&lt;/td&gt;&lt;td&gt;96&lt;/td&gt;&lt;td&gt;112&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;16&lt;/td&gt;&lt;td&gt;24&lt;/td&gt;&lt;td&gt;4&lt;/td&gt;&lt;td&gt;98&lt;/td&gt;&lt;td&gt;117&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;24&lt;/td&gt;&lt;td&gt;29&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;(136)&lt;/td&gt;&lt;td&gt;N/A&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;24&lt;/td&gt;&lt;td&gt;30&lt;/td&gt;&lt;td&gt;2&lt;/td&gt;&lt;td&gt;(140)&lt;/td&gt;&lt;td&gt;N/A&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;24&lt;/td&gt;&lt;td&gt;31&lt;/td&gt;&lt;td&gt;3&lt;/td&gt;&lt;td&gt;(144)&lt;/td&gt;&lt;td&gt;N/A&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;24&lt;/td&gt;&lt;td&gt;32&lt;/td&gt;&lt;td&gt;4&lt;/td&gt;&lt;td&gt;(146)&lt;/td&gt;&lt;td&gt;N/A&lt;/td&gt;&lt;/tr&gt;
&lt;caption&gt;Table 1: Test-bench test results (simulation)&lt;/caption&gt;&lt;/table&gt;

&lt;p&gt;As you can see from the table, the
&lt;a href=&quot;/dsp/2017/08/30/cordic.html&quot;&gt;CORDIC algorithm&lt;/a&gt;’s
performance improves, for a given bit width, as the number of extra
internal bits increases until these get to about four.  At this point,
the improvement settles out, and little further gain can be had.&lt;/p&gt;

&lt;p&gt;One common estimate of &lt;a href=&quot;https://en.wikipedia.org/wiki/Quantization_(signal_processing)&quot;&gt;quantization noise is that you can achieve 6-dB of
performance per bit of sample
width&lt;/a&gt;.
By this measure, we might expect a 48 dB
&lt;a href=&quot;https://en.wikipedia.org/wiki/Carrier-to-noise_ratio&quot;&gt;CNR&lt;/a&gt;
for an 8-bit output, a 72 dB
&lt;a href=&quot;https://en.wikipedia.org/wiki/Carrier-to-noise_ratio&quot;&gt;CNR&lt;/a&gt;
for a 12-bit output, 96 dB
&lt;a href=&quot;https://en.wikipedia.org/wiki/Carrier-to-noise_ratio&quot;&gt;CNR&lt;/a&gt;
for a 16-bit output, and 144 dB
&lt;a href=&quot;https://en.wikipedia.org/wiki/Carrier-to-noise_ratio&quot;&gt;CNR&lt;/a&gt;
for a 24-bit output.  Our measured results are roughly consistent
with this rule, so they appear to be reasonably accurate.&lt;/p&gt;

&lt;p&gt;Likewise the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Spurious-free_dynamic_range&quot;&gt;SFDR&lt;/a&gt;
measurements showed a clear increase in performance as the bit
widths involved increased.&lt;/p&gt;

&lt;p&gt;Digging further, the predicted
&lt;a href=&quot;https://en.wikipedia.org/wiki/Carrier-to-noise_ratio&quot;&gt;CNR&lt;/a&gt; values matched
the &lt;a href=&quot;https://github.com/ZipCPU/cordic/blob/master/bench/cpp/cordic_tb.cpp&quot;&gt;test
bench&lt;/a&gt;
measured values within a &lt;a href=&quot;https://en.wikipedia.org/wiki/Decibel&quot;&gt;dB&lt;/a&gt; or two.&lt;/p&gt;

&lt;p&gt;The &lt;a href=&quot;https://github.com/ZipCPU/cordic/blob/master/bench/cpp/cordic_tb.cpp&quot;&gt;test
bench&lt;/a&gt;,
however, failed when it got to the larger phase widths: 29 and above.  In
particular, the test bench failed for all of the phase widths appropriate for
the 24-bit samples.  The error given, that of a memory allocation error,
illustrates a weakness in a test methodology that works by first recording all
of the answers into memory and then processes those results.&lt;/p&gt;

&lt;p&gt;Because the &lt;a href=&quot;https://github.com/ZipCPU/cordic/blob/master/bench/cpp/cordic_tb.cpp&quot;&gt;test
bench&lt;/a&gt;
failed for the 24-bit case, the &lt;em&gt;expected&lt;/em&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Carrier-to-noise_ratio&quot;&gt;CNR&lt;/a&gt;
values are shown (in parentheses) rather than any &lt;em&gt;measured&lt;/em&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Carrier-to-noise_ratio&quot;&gt;CNR&lt;/a&gt; values.
Since these expected values were consistent with the predicted
&lt;a href=&quot;https://en.wikipedia.org/wiki/Carrier-to-noise_ratio&quot;&gt;CNR&lt;/a&gt; values for
the rest of the test (comparison not shown), they are at least an indication
of what one might expect when using this routine for larger bit-widths.&lt;/p&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;It’s taken us a lot of work to get to this point, where we can estimate the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Carrier-to-noise_ratio&quot;&gt;CNR&lt;/a&gt; performance that a
&lt;a href=&quot;/dsp/2017/08/30/cordic.html&quot;&gt;CORDIC algorithm&lt;/a&gt;
will achieve, and then verify that it has that performance.  Indeed, the math
wasn’t pretty, and I’d be surprised if a large number of folks made it this
far.&lt;/p&gt;

&lt;p&gt;Please accept my apologies.  I would like to keep this blog as simple as the
RTL code I’m sharing, and this was not that simple.&lt;/p&gt;

&lt;p&gt;The problem that lead us to this point, though, is simple: how do you know
when an algorithm’s results are “good enough.”  It was this particular
question that sent us this deep into the (hard-to-follow) mathematics above and
in our &lt;a href=&quot;/dsp/2017/09/27/quantization.html&quot;&gt;prior post&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Further, despite the complexity of this development today, we still didn’t
solve &lt;em&gt;all&lt;/em&gt; of the mathematical problems associated with a &lt;a href=&quot;https://github.com/ZipCPU/cordic/blob/master/bench/cpp/cordic_tb.cpp&quot;&gt;test
bench&lt;/a&gt;
of this type.  In particular, we didn’t apply any proper statistical
bases to the &lt;a href=&quot;https://en.wikipedia.org/wiki/Statistical_hypothesis_testing&quot;&gt;hypothesis
test&lt;/a&gt;s within
our test bench.  As a result, we cannot be certain that this &lt;a href=&quot;https://github.com/ZipCPU/cordic/blob/master/rtl/cordic.v&quot;&gt;CORDIC
implementation&lt;/a&gt;
is as good as it can be.&lt;/p&gt;

&lt;p&gt;Still, this should be &lt;em&gt;good enough&lt;/em&gt; to move forward.&lt;/p&gt;

&lt;p&gt;Using these results, we now have some confidence that not only does the
&lt;a href=&quot;/dsp/2017/08/30/cordic.html&quot;&gt;CORDIC algorithm&lt;/a&gt; work,
but we also have the confidence that given the right parameters it will work
well enough for our purposes.&lt;/p&gt;

&lt;p&gt;What purposes might that be?  That question, my friend, we’ll have to answer
in another post.  This one has been too long already.&lt;/p&gt;
&lt;hr /&gt;&lt;p&gt;&lt;em&gt;In the beginning was the Word, and the Word was with God, and the Word was God. (John 1:1)&lt;/em&gt;</description>
        <pubDate>Mon, 02 Oct 2017 00:00:00 -0400</pubDate>
        <link>http://zipcpu.com/dsp/2017/10/02/cordic-tb.html</link>
        <guid isPermaLink="true">http://zipcpu.com/dsp/2017/10/02/cordic-tb.html</guid>
        
        
        <category>dsp</category>
        
      </item>
    
      <item>
        <title>A Cheaper Fast FIR Filter</title>
        <description>&lt;p&gt;Since we last put a generic
&lt;a href=&quot;/dsp/2017/09/15/fastfir.html&quot;&gt;high speed FIR together&lt;/a&gt;,
a friend showed me another
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
structure which can be used to create a high-speed
&lt;a href=&quot;https://en.wikipedia.org/wiki/Finite_impulse_response&quot;&gt;FIR&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;As you may recall from
&lt;a href=&quot;/dsp/2017/09/15/fastfir.html&quot;&gt;our last discussion&lt;/a&gt;,
a &lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;
is typically represented by the logic illustrated in Fig 1.&lt;/p&gt;

&lt;table style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 1: Traditional Filter Implementation&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/fir-form.svg&quot; alt=&quot;Generic FIR implementation structure&quot; width=&quot;380&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;In our &lt;a href=&quot;/dsp/2017/09/15/fastfir.html&quot;&gt;last presentation&lt;/a&gt;,
we noted that the accumulation step at the bottom of Fig 1 requires
a number of clocks to be successful.  Hence, every addition in that presentation
required a clock.  We then lined everything up by placing an extra delay
between the input data stages.&lt;/p&gt;

&lt;p&gt;Today, let’s take a look at a simpler structure for
&lt;a href=&quot;https://en.wikipedia.org/wiki/Finite_impulse_response&quot;&gt;FIR&lt;/a&gt;
evaluation.  By simpler,
I mean one that doesn’t require any of the double-delay structures we used
in our &lt;a href=&quot;/dsp/2017/09/15/fastfir.html&quot;&gt;last filter
implementation&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;simpler-structure&quot;&gt;Simpler Structure&lt;/h2&gt;

&lt;p&gt;This new simpler structure works by taking the delay line from the input
samples, and places it on the output accumulation line.  This concept is
notionally shown in Fig 2.&lt;/p&gt;

&lt;table style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 2: Simpler Filter Implementation&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/fir-dsp-structure.svg&quot; alt=&quot;Cheaper FIR implementation structure&quot; width=&quot;480&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Unlike Fig 1, there is no input delay line.  That delay line was moved to the
accumulation structure.  Another difference is that the taps are in a
reverse order.  Instead of running from &lt;code class=&quot;highlighter-rouge&quot;&gt;h[0]&lt;/code&gt; to &lt;code class=&quot;highlighter-rouge&quot;&gt;h[N-1]&lt;/code&gt; in Fig 1, the
taps in Fig 1 run from &lt;code class=&quot;highlighter-rouge&quot;&gt;h[N-1]&lt;/code&gt; to &lt;code class=&quot;highlighter-rouge&quot;&gt;h[0]&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The code for this simpler structure is &lt;em&gt;almost identical&lt;/em&gt; to the structure
we used before.  Indeed, the two are so similar, we could almost present the
code difference as a simple &lt;a href=&quot;https://en.wikipedia.org/wiki/Diff_utility&quot;&gt;diff&lt;/a&gt;.
We’ll choose to maintain a touch more context, though, and encourage you to try
a &lt;a href=&quot;https://en.wikipedia.org/wiki/Diff_utility&quot;&gt;diff&lt;/a&gt; between the two
components,
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/genericfir.v&quot;&gt;old&lt;/a&gt;
and &lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/fastfir.v&quot;&gt;new&lt;/a&gt;,
yourself.&lt;/p&gt;

&lt;p&gt;The first difference is that this simpler
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;
needs the same sample
value sent to all of the multiplies at once.  Hence, we’ll send
&lt;code class=&quot;highlighter-rouge&quot;&gt;sample[0]&lt;/code&gt; to all of the
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/firtap.v&quot;&gt;tap structures&lt;/a&gt;.
We’ll depend upon the synthesis tool to
clean up the unused delayed sample output still found within the
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/firtap.v&quot;&gt;tap structures&lt;/a&gt;.
This will generate some warnings, but should still work well.&lt;/p&gt;

&lt;p&gt;The second difference is that the taps of the
&lt;a href=&quot;/dsp/2017/09/15/fastfir.html&quot;&gt;prior generic FIR&lt;/a&gt;,
needed to be given to it in reverse order.  For this
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/fastfir.v&quot;&gt;new filter&lt;/a&gt;,
the taps are fed into
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/fastfir.v&quot;&gt;the filter&lt;/a&gt;
from &lt;code class=&quot;highlighter-rouge&quot;&gt;h[0]&lt;/code&gt; to &lt;code class=&quot;highlighter-rouge&quot;&gt;h[N_k-1]&lt;/code&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;for(k=0; k&amp;lt;NTAPS; k=k+1)
begin: FILTER

	firtap #(.FIXED_TAPS(FIXED_TAPS),
			.IW(IW), .OW(OW), .TW(TW),
			.INITIAL_VALUE(0))
		tapk(i_clk, i_reset,
			// Tap update circuitry
			tap_wr, tap[k], tapout[k+1], // !!!!!
			// Sample delay line
			// Well let the optimizer trim away sample[k+1]
			i_ce, sample[0], sample[k+1], // !!!!!
			// The output accumulator
			result[k], result[k+1]);

	if (!FIXED_TAPS)
		assign	tap[k+1] = tapout[k+1]; // !!!!!

	// ...
end endgenerate&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;I’ve placed exclamation points in-line following each of the changed
lines in the code above, so you can see where the changes are.&lt;/p&gt;

&lt;p&gt;You can find the code for &lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/fastfir.v&quot;&gt;this modified filter
here&lt;/a&gt;
next to the &lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/genericfir.v&quot;&gt;original filter&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;cost-comparison&quot;&gt;Cost Comparison&lt;/h2&gt;

&lt;p&gt;The cost of
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/fastfir.v&quot;&gt;this filter&lt;/a&gt;
is &lt;em&gt;almost&lt;/em&gt; exactly one DSP per tap–plus one
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flip-flop_(electronics)&quot;&gt;flip-flop&lt;/a&gt; per
stage per bit.&lt;/p&gt;

&lt;p&gt;There are two aspects of this design keeping this from being one DSP per tap.&lt;/p&gt;

&lt;p&gt;The first is that the &lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/firtap.v&quot;&gt;tap component
module&lt;/a&gt;
separates the addition from the multiplication.  This addition &lt;em&gt;could&lt;/em&gt; have
been subsumed, together with the multiply, into the DSP to make a multiply
and accumulate structure.  Instead, each of the &lt;code class=&quot;highlighter-rouge&quot;&gt;(N-1)&lt;/code&gt; additions still require
(roughly) two
&lt;a href=&quot;/blog/2017/06/12/minimizing-luts.html&quot;&gt;3-LUTs&lt;/a&gt; per output
bit.  The inputs to these
&lt;a href=&quot;/blog/2017/06/12/minimizing-luts.html&quot;&gt;3-LUTs&lt;/a&gt; are the
two inputs for the addition, plus the carry bit.  The output of the
&lt;a href=&quot;/blog/2017/06/12/minimizing-luts.html&quot;&gt;first LUT&lt;/a&gt;
is the addition output, and the &lt;a href=&quot;/blog/2017/06/12/minimizing-luts.html&quot;&gt;second
LUT&lt;/a&gt; the carry output.
Using &lt;a href=&quot;https://www.xilinx.com&quot;&gt;Xilinx&lt;/a&gt;
&lt;a href=&quot;https://www.xilinx.com/support/documentation/user_guides/ug474_7Series_CLB.pdf&quot;&gt;7-Series&lt;/a&gt;
devices, this addition can be &lt;a href=&quot;/blog/2017/06/12/minimizing-luts.html&quot;&gt;accomplished in one 6-LUT
per bit&lt;/a&gt; per tap.&lt;/p&gt;

&lt;p&gt;The second item keeping this from costing a single DSP per tap is the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flip-flop_(electronics)&quot;&gt;flip-flop&lt;/a&gt;
structure containing the tap values, &lt;code class=&quot;highlighter-rouge&quot;&gt;h[k]&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;When compared to the &lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/genericfir.v&quot;&gt;generic
filter&lt;/a&gt; we
&lt;a href=&quot;/dsp/2017/09/15/fastfir.html&quot;&gt;presented last time&lt;/a&gt;, the
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/genericfir.v&quot;&gt;last filter&lt;/a&gt;
included two
&lt;a href=&quot;https://en.wikipedia.org/wiki/Flip-flop_(electronics)&quot;&gt;flip-flop&lt;/a&gt;s
per stage per bit in the input as well in addition to the rest of the logic
that remains in the &lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/fastfir.v&quot;&gt;newer
implementation&lt;/a&gt;.
These extra &lt;a href=&quot;https://en.wikipedia.org/wiki/Flip-flop_(electronics)&quot;&gt;flip-flop&lt;/a&gt;s
are gone in this &lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/fastfir.v&quot;&gt;updated
implementation&lt;/a&gt;,
rendering the &lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/fastfir.v&quot;&gt;updated
implementation&lt;/a&gt;
cheaper than the
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/genericfir.v&quot;&gt;last one&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;You might still choose to use the &lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/fastfir.v&quot;&gt;previous
implementation&lt;/a&gt;,
though.  In particular, the &lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/fastfir.v&quot;&gt;prior
implementation&lt;/a&gt;
doesn’t struggle with the fan-out issue this &lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/fastfir.v&quot;&gt;newer
implementation&lt;/a&gt;
has.  As a result, the &lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/fastfir.v&quot;&gt;previous
implementation&lt;/a&gt;
may be able to run at higher speeds.&lt;/p&gt;

&lt;h2 id=&quot;next-steps&quot;&gt;Next Steps&lt;/h2&gt;

&lt;p&gt;As I mentioned in the &lt;a href=&quot;/dsp/2017/09/15/fastfir.html&quot;&gt;last filtering
post&lt;/a&gt;,
there are many ways to implement
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filters&lt;/a&gt;
within &lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;’s
and there are many ways to simplify even this &lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/fastfir.v&quot;&gt;filter
implementation&lt;/a&gt;.
Should your application permit it, sharper
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filters&lt;/a&gt;
(i.e.  &lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filters&lt;/a&gt; with more taps)
may be possible.  For example:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Many filters are &lt;a href=&quot;https://en.wikipedia.org/wiki/Linear_phase&quot;&gt;symmetric
(linear-phase)&lt;/a&gt;.  A carefully
built &lt;a href=&quot;https://en.wikipedia.org/wiki/Linear_phase&quot;&gt;symmetric filter&lt;/a&gt; will
drop the number of required hardware multiplies in half.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Half-band_filter&quot;&gt;Half-band filters&lt;/a&gt; can be
built using only every other tap, dropping the number of hardware multiplies
required in half again.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Hilbert_transform&quot;&gt;Hilbert transforms&lt;/a&gt;,
are another special type of filter.  Both the 
&lt;a href=&quot;https://en.wikipedia.org/wiki/Half-band_filter&quot;&gt;half-band filter&lt;/a&gt; and the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Linear_phase&quot;&gt;symmetric filter&lt;/a&gt; optimizations
apply to &lt;a href=&quot;https://en.wikipedia.org/wiki/Hilbert_transform&quot;&gt;Hilbert
transforms&lt;/a&gt;, 
even though &lt;a href=&quot;https://en.wikipedia.org/wiki/Hilbert_transform&quot;&gt;Hilbert
transforms&lt;/a&gt; are neither
&lt;a href=&quot;https://en.wikipedia.org/wiki/Half-band_filter&quot;&gt;half-band&lt;/a&gt; nor
&lt;a href=&quot;https://en.wikipedia.org/wiki/Linear_phase&quot;&gt;symmetric filters&lt;/a&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;Filters&lt;/a&gt;
combined with
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sample-rate_conversion&quot;&gt;down-samplers&lt;/a&gt;
can also be accomplished with fewer hardware multiplies as well.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Once we finish or
&lt;a href=&quot;/dsp/2017/08/30/cordic.html&quot;&gt;CORDIC&lt;/a&gt; test bench
(it’s almost ready, although it’s not going to be simple), we’ll start
building a generic &lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filtering&lt;/a&gt;
test bench, prove these generic
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filtering&lt;/a&gt;
structures, and then come back and continue looking at some of the
optimizations outlined above.&lt;/p&gt;

&lt;hr /&gt;&lt;p&gt;&lt;em&gt;And a stranger will they not follow, but will flee from him: for they know not the voice of strangers. (John 10:5)&lt;/em&gt;</description>
        <pubDate>Fri, 29 Sep 2017 00:00:00 -0400</pubDate>
        <link>http://zipcpu.com/dsp/2017/09/29/cheaper-fast-fir.html</link>
        <guid isPermaLink="true">http://zipcpu.com/dsp/2017/09/29/cheaper-fast-fir.html</guid>
        
        
        <category>dsp</category>
        
      </item>
    
      <item>
        <title>Understanding the effects of Quantization</title>
        <description>&lt;p&gt;Some time ago, I described on
&lt;a href=&quot;http://zipcpu.com/&quot;&gt;this blog&lt;/a&gt; how to use a
&lt;a href=&quot;/dsp/2017/08/30/cordic.html&quot;&gt;CORDIC algorithm to rotate &lt;code class=&quot;highlighter-rouge&quot;&gt;x,y&lt;/code&gt;
vectors&lt;/a&gt;
by an arbitrary &lt;a href=&quot;/dsp/2017/06/15/no-pi-for-you.html&quot;&gt;angle&lt;/a&gt;
and &lt;a href=&quot;/dsp/2017/09/01/topolar.html&quot;&gt;how to build a
rectangular to polar conversion&lt;/a&gt;
using the same basic methods.
What I didn’t post was a
&lt;a href=&quot;/dsp/10/02/cordic-tb.html&quot;&gt;test bench&lt;/a&gt; for those two
routines.  As a result, the
presentations are really incomplete.  While I have &lt;em&gt;declared&lt;/em&gt; that they work,
I have not &lt;em&gt;proven&lt;/em&gt; that they work.  Neither have I demonstrated how well they
work.&lt;/p&gt;

&lt;p&gt;What makes matters even more difficult is that proving that a &lt;a href=&quot;/dsp/2017/08/30/cordic.html&quot;&gt;(core generated)
CORDIC algorithm&lt;/a&gt;
works is not trivial.  While generating a straight-forward
&lt;a href=&quot;/dsp/10/02/cordic-tb.html&quot;&gt;test bench&lt;/a&gt;
may be simple for one set of
&lt;a href=&quot;/dsp/2017/08/30/cordic.html&quot;&gt;CORDIC parameters&lt;/a&gt;,
the same
&lt;a href=&quot;/dsp/10/02/cordic-tb.html&quot;&gt;test bench&lt;/a&gt;
may not work for all parameters.  In particular, the arbitrary parameters of
input, phase, internal accumulator, and output bit widths are all going to
have an affect on the performance of the overall
&lt;a href=&quot;/dsp/2017/08/30/cordic.html&quot;&gt;CORDIC algorithm&lt;/a&gt;.
How shall we understand how well
&lt;a href=&quot;https://github.com/ZipCPU/cordic/blob/master/rtl/cordic.v&quot;&gt;this algorithm&lt;/a&gt;
works for any &lt;a href=&quot;https://github.com/ZipCPU/cordic/blob/master/rtl/cordic.h&quot;&gt;particular set of
parameters&lt;/a&gt;?&lt;/p&gt;

&lt;p&gt;To answer these questions, let’s examine
&lt;a href=&quot;https://en.wikipedia.org/wiki/Quantization_(signal_processing)&quot;&gt;quantization&lt;/a&gt;
effects.  We’ll start by reviewing the definitions of some
&lt;a href=&quot;https://en.wikipedia.org/wiki/Probability&quot;&gt;probabilistic&lt;/a&gt;
quantities: the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Mean#Mean_of_a_probability_distribution&quot;&gt;mean&lt;/a&gt;,
&lt;a href=&quot;https://en.wikipedia.org/wiki/Variance&quot;&gt;variance&lt;/a&gt;, and &lt;a href=&quot;https://en.wikipedia.org/wiki/Standard_deviation&quot;&gt;standard
deviation&lt;/a&gt;.
We’ll then examine
&lt;a href=&quot;https://en.wikipedia.org/wiki/Quantization_(signal_processing)&quot;&gt;quantization&lt;/a&gt;
noise according to these properties.
Using these results, we can then draw some very general rules of thumb that we
can then use in a
&lt;a href=&quot;/dsp/10/02/cordic-tb.html&quot;&gt;later post&lt;/a&gt;
to build a &lt;a href=&quot;https://github.com/ZipCPU/cordic/blob/master/bench/cpp/cordic_tb.cpp&quot;&gt;test
bench&lt;/a&gt;
for our &lt;a href=&quot;/dsp/2017/08/30/cordic.html&quot;&gt;CORDIC algorithm&lt;/a&gt;.
Indeed, the results presented below will be generic enough that we may apply
them to many other algorithms as well.&lt;/p&gt;

&lt;h2 id=&quot;some-quick-statistics&quot;&gt;Some quick statistics&lt;/h2&gt;

&lt;p&gt;Understanding
&lt;a href=&quot;https://en.wikipedia.org/wiki/Quantization_(signal_processing)&quot;&gt;quantization&lt;/a&gt;
effects requires a very basic understanding of
&lt;a href=&quot;https://en.wikipedia.org/wiki/Probability&quot;&gt;probability&lt;/a&gt;.
&lt;a href=&quot;https://en.wikipedia.org/wiki/Probability&quot;&gt;Probability&lt;/a&gt; involves the study
of &lt;a href=&quot;https://en.wikipedia.org/wiki/Random_variable&quot;&gt;random variables&lt;/a&gt;, and
how they behave.&lt;/p&gt;

&lt;p&gt;In the study of &lt;a href=&quot;https://en.wikipedia.org/wiki/Probability&quot;&gt;probability&lt;/a&gt;,
&lt;a href=&quot;https://en.wikipedia.org/wiki/Random_variable&quot;&gt;random variables&lt;/a&gt; are
characterized by their &lt;a href=&quot;https://en.wikipedia.org/wiki/Probability_distribution&quot;&gt;probability
distribution&lt;/a&gt;.
A &lt;a href=&quot;https://en.wikipedia.org/wiki/Probability_distribution&quot;&gt;probability
distribution&lt;/a&gt;
is basically a function that can be used to define the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Probability&quot;&gt;probability&lt;/a&gt;
that a &lt;a href=&quot;https://en.wikipedia.org/wiki/Random_variable&quot;&gt;random variable&lt;/a&gt;
attains a particular value.  The two requirements on a &lt;a href=&quot;https://en.wikipedia.org/wiki/Probability_distribution&quot;&gt;probability
distribution&lt;/a&gt;
function are first that all of the elements are non-negative,
and second that the sum of all of the elements must be one.&lt;/p&gt;

&lt;p&gt;There are two basic types of
&lt;a href=&quot;https://en.wikipedia.org/wiki/Probability_distribution&quot;&gt;probability functions&lt;/a&gt;:
&lt;a href=&quot;https://en.wikipedia.org/wiki/Probability_mass_function&quot;&gt;probability mass functions
(PMF)&lt;/a&gt; and
&lt;a href=&quot;https://en.wikipedia.org/wiki/Probability_density_function&quot;&gt;probability density functions
(PDF)&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;For &lt;a href=&quot;https://en.wikipedia.org/wiki/Random_variable&quot;&gt;random variables&lt;/a&gt; drawn
from a discrete set of values, the &lt;a href=&quot;https://en.wikipedia.org/wiki/Probability_distribution&quot;&gt;probability
distribution&lt;/a&gt;
is described by a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Probability_mass_function&quot;&gt;PMF&lt;/a&gt;.
The &lt;a href=&quot;https://en.wikipedia.org/wiki/Probability_mass_function&quot;&gt;PMF&lt;/a&gt;
describes the probability of a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Random_variable&quot;&gt;random variables&lt;/a&gt;
equalling a specific
value from a discrete set.&lt;/p&gt;

&lt;p&gt;One discrete set that will interest us within the
&lt;a href=&quot;/dsp/2017/08/30/cordic.html&quot;&gt;CORDIC&lt;/a&gt; algorithm
is the set of two possibilities, each of which may be selected with equal
probability.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/eqn-bicordic-probability.png&quot; alt=&quot;PMF for the CORDIC probability of rotation direction&quot; width=&quot;285&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;The other type of
&lt;a href=&quot;https://en.wikipedia.org/wiki/Probability_distribution&quot;&gt;probability function&lt;/a&gt;
describes a &lt;em&gt;continuous random variable&lt;/em&gt;.
This is the type we shall focus on today.  Continuous probability distributions
are defined by a &lt;a href=&quot;https://en.wikipedia.org/wiki/Probability_density_function&quot;&gt;probability density
function (PDF)&lt;/a&gt;.
Unlike the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Probability_mass_function&quot;&gt;PMF&lt;/a&gt;
discussed above,
&lt;a href=&quot;https://en.wikipedia.org/wiki/Probability_density_function&quot;&gt;PDF&lt;/a&gt;’s
are used to determine whether or not a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Random_variable&quot;&gt;random number&lt;/a&gt;
falls within a range of values, as in:&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/eqn-range-probability.png&quot; alt=&quot;Probability of a random variable landing within a continuous variable range&quot; width=&quot;310&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;These two functions, whether the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Probability_mass_function&quot;&gt;PMF&lt;/a&gt;
or the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Probability_density_function&quot;&gt;PDF&lt;/a&gt;
as appropriate, completely characterize
how a &lt;a href=&quot;https://en.wikipedia.org/wiki/Random_variable&quot;&gt;random variable&lt;/a&gt;
is selected from among the possible values it may obtain.&lt;/p&gt;

&lt;p&gt;Now that we can describe a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Random_variable&quot;&gt;random variable&lt;/a&gt;,
the next step is to draw some conclusions from it.  To keep
things simple, we’ll examine three functions of a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Random_variable&quot;&gt;random variable&lt;/a&gt;.  The first
is the &lt;a href=&quot;https://en.wikipedia.org/wiki/Expected_value&quot;&gt;expected value&lt;/a&gt;.
From there, we can define the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Mean#Mean_of_a_probability_distribution&quot;&gt;mean&lt;/a&gt;,
&lt;a href=&quot;https://en.wikipedia.org/wiki/Variance&quot;&gt;variance&lt;/a&gt;, and even the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Standard_deviation&quot;&gt;standard
deviation&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The &lt;a href=&quot;https://en.wikipedia.org/wiki/Expected_value&quot;&gt;expected value&lt;/a&gt;
of a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Random_variable&quot;&gt;random variable&lt;/a&gt;
is defined as the sum, taken over all values the variable might assume, of the
product of the probability of the variable taking on that value and whatever
the expectation function is.  While that sounds pretty confusing, the equation
itself for an &lt;a href=&quot;https://en.wikipedia.org/wiki/Expected_value&quot;&gt;expected
value&lt;/a&gt; is simpler
than the description I just gave.  For a continuous probability distribution
over the &lt;a href=&quot;https://en.wikipedia.org/wiki/Real_number&quot;&gt;real number&lt;/a&gt; system
the &lt;a href=&quot;https://en.wikipedia.org/wiki/Expected_value&quot;&gt;expectation&lt;/a&gt; is defined by,&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/eqn-expected-value-fn.png&quot; alt=&quot;Equation defining the expected value of a random variable&quot; width=&quot;320&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;where &lt;code class=&quot;highlighter-rouge&quot;&gt;X&lt;/code&gt; is our
&lt;a href=&quot;https://en.wikipedia.org/wiki/Random_variable&quot;&gt;random variable&lt;/a&gt;,
&lt;code class=&quot;highlighter-rouge&quot;&gt;g(X)&lt;/code&gt; is an arbitrary function of the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Random_variable&quot;&gt;random variable&lt;/a&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;X&lt;/code&gt;,
&lt;code class=&quot;highlighter-rouge&quot;&gt;f(X)&lt;/code&gt; is the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Probability_density_function&quot;&gt;PDF&lt;/a&gt; associated
with this &lt;a href=&quot;https://en.wikipedia.org/wiki/Random_variable&quot;&gt;random variable&lt;/a&gt;,
and the integral is taken over all
&lt;a href=&quot;https://en.wikipedia.org/wiki/Real_number&quot;&gt;real number&lt;/a&gt;s.
We’ll use this expression to define the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Expected_value&quot;&gt;expected value&lt;/a&gt;
of a function, &lt;code class=&quot;highlighter-rouge&quot;&gt;g(X)&lt;/code&gt;, which we’ll then note as &lt;code class=&quot;highlighter-rouge&quot;&gt;E{g(X)}&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Even this appears more complicated than it need be, since in our discussions
below we’ll let &lt;code class=&quot;highlighter-rouge&quot;&gt;g(X)&lt;/code&gt; be simple things such as &lt;code class=&quot;highlighter-rouge&quot;&gt;X&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;X^2&lt;/code&gt; or even the sum
of two &lt;a href=&quot;https://en.wikipedia.org/wiki/Random_variable&quot;&gt;random variables&lt;/a&gt;,
&lt;code class=&quot;highlighter-rouge&quot;&gt;X+Y&lt;/code&gt;.  We’re also going to let &lt;code class=&quot;highlighter-rouge&quot;&gt;f(X)&lt;/code&gt; be something as simple as the constant
&lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt; between &lt;code class=&quot;highlighter-rouge&quot;&gt;-1/2&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;1/2&lt;/code&gt;, and zero other wise.  In other words, don’t
let the formula scare you: it’s easier than it looks.&lt;/p&gt;

&lt;p&gt;Further, because the 
&lt;a href=&quot;https://en.wikipedia.org/wiki/Probability_density_function&quot;&gt;PDF&lt;/a&gt;
is unitless, the units of the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Expected_value&quot;&gt;expected value&lt;/a&gt;
are the same as the units of &lt;code class=&quot;highlighter-rouge&quot;&gt;g(X)&lt;/code&gt;.  Hence, if &lt;code class=&quot;highlighter-rouge&quot;&gt;g(X)&lt;/code&gt; is &lt;code class=&quot;highlighter-rouge&quot;&gt;X^2&lt;/code&gt;, and &lt;code class=&quot;highlighter-rouge&quot;&gt;X&lt;/code&gt; is
a voltage, then the units would be voltage squared.&lt;/p&gt;

&lt;p&gt;From this definition of the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Expected_value&quot;&gt;expectation&lt;/a&gt;
we can now define the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Mean#Mean_of_a_probability_distribution&quot;&gt;mean&lt;/a&gt;.
The
&lt;a href=&quot;https://en.wikipedia.org/wiki/Mean#Mean_of_a_probability_distribution&quot;&gt;mean&lt;/a&gt;
is defined
as the &lt;a href=&quot;https://en.wikipedia.org/wiki/Expected_value&quot;&gt;expected value&lt;/a&gt; of the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Random_variable&quot;&gt;random variable&lt;/a&gt; itself,
&lt;code class=&quot;highlighter-rouge&quot;&gt;E{X}&lt;/code&gt;.  We’ll use the Greek character &lt;em&gt;mu&lt;/em&gt; to represent it, sometimes
noting it as a &lt;code class=&quot;highlighter-rouge&quot;&gt;u&lt;/code&gt;.  If we just use the equation for
&lt;a href=&quot;https://en.wikipedia.org/wiki/Expected_value&quot;&gt;expectation&lt;/a&gt;
presented above, then this
&lt;a href=&quot;https://en.wikipedia.org/wiki/Mean#Mean_of_a_probability_distribution&quot;&gt;mean&lt;/a&gt;
is calculated from,&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/eqn-defn-mean.png&quot; alt=&quot;Equation defining the mean of a random variable&quot; width=&quot;202&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;You may be familiar with the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Statistics&quot;&gt;statistical&lt;/a&gt;
process of
&lt;a href=&quot;https://en.wikipedia.org/wiki/Average&quot;&gt;averaging&lt;/a&gt;.
a set of measured values in order to estimate a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Average#Statistical_location&quot;&gt;mean&lt;/a&gt;.
This is subtly different from the definition of the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Mean#Mean_of_a_probability_distribution&quot;&gt;mean&lt;/a&gt;
of a &lt;a href=&quot;https://en.wikipedia.org/wiki/Probability_distribution&quot;&gt;probability
distribution&lt;/a&gt; that we
just presented above.  In the case of the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Statistics&quot;&gt;statistical&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Average#Statistical_location&quot;&gt;mean&lt;/a&gt;,
a set of samples are drawn from a random distribution, and then averaged.
The result of this method is a new
&lt;a href=&quot;https://en.wikipedia.org/wiki/Random_variable&quot;&gt;random variable&lt;/a&gt;, which is
often used to infer information about the &lt;a href=&quot;https://en.wikipedia.org/wiki/Probability_distribution&quot;&gt;probability
distribution&lt;/a&gt; of the
set of &lt;a href=&quot;https://en.wikipedia.org/wiki/Random_variable&quot;&gt;random variable&lt;/a&gt;s
from which the &lt;a href=&quot;https://en.wikipedia.org/wiki/Statistics&quot;&gt;statistical&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Average#Statistical_location&quot;&gt;mean&lt;/a&gt;
was computed.  The
&lt;a href=&quot;https://en.wikipedia.org/wiki/Mean#Mean_of_a_probability_distribution&quot;&gt;mean&lt;/a&gt;
defined above, however, is completely characterized by the (assumed known)
&lt;a href=&quot;https://en.wikipedia.org/wiki/Probability_distribution&quot;&gt;probability
distribution&lt;/a&gt;
of the &lt;a href=&quot;https://en.wikipedia.org/wiki/Random_variable&quot;&gt;random variable&lt;/a&gt;
in question.&lt;/p&gt;

&lt;p&gt;The next useful quantity we will be interested in is the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Variance&quot;&gt;variance&lt;/a&gt;
of a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Random_variable&quot;&gt;random number&lt;/a&gt;.
This is defined by the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Expected_value&quot;&gt;expected value&lt;/a&gt;
of the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Random_variable&quot;&gt;random variable&lt;/a&gt;,
minus its
&lt;a href=&quot;https://en.wikipedia.org/wiki/Mean#Mean_of_a_probability_distribution&quot;&gt;mean&lt;/a&gt;,
squared.  We’ll represent this value with a &lt;code class=&quot;highlighter-rouge&quot;&gt;V[X]&lt;/code&gt;, to note that it is the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Variance&quot;&gt;variance&lt;/a&gt; of the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Random_variable&quot;&gt;random value&lt;/a&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;X&lt;/code&gt;.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/eqn-defn-variance.png&quot; alt=&quot;Equation defining the variance of a random variable&quot; width=&quot;477&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;We’ll use this definition of the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Variance&quot;&gt;variance&lt;/a&gt;
later to analyze the errors within our
&lt;a href=&quot;/dsp/2017/08/30/cordic.html&quot;&gt;CORDIC calculation&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The third useful quantity is the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Standard_deviation&quot;&gt;standard deviation&lt;/a&gt;.
The &lt;a href=&quot;https://en.wikipedia.org/wiki/Standard_deviation&quot;&gt;standard deviation&lt;/a&gt;
is defined by the square root of the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Variance&quot;&gt;variance&lt;/a&gt;.  We’ll use the Greek
letter &lt;em&gt;sigma&lt;/em&gt; to represent this quantity.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/eqn-defn-stdev.png&quot; alt=&quot;Equation defining the standard deviation of a random variable&quot; width=&quot;145&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Perhaps you noticed above that the units of
&lt;a href=&quot;https://en.wikipedia.org/wiki/Variance&quot;&gt;variance&lt;/a&gt;
were the units of &lt;code class=&quot;highlighter-rouge&quot;&gt;X&lt;/code&gt; squared.  (&lt;code class=&quot;highlighter-rouge&quot;&gt;f(X)&lt;/code&gt; has no units)
The reason why we even need a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Standard_deviation&quot;&gt;standard deviation&lt;/a&gt;
at all is so that we can have a value that represents the spread of a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Random_variable&quot;&gt;random variable&lt;/a&gt;,
but with the same units as &lt;code class=&quot;highlighter-rouge&quot;&gt;X&lt;/code&gt;.  This will make it easier to talk about and
reason about the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Variance&quot;&gt;variance&lt;/a&gt;, even though the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Standard_deviation&quot;&gt;standard deviation&lt;/a&gt;
measure itself doesn’t fundamentally offer any new information beyond
what is already contained within the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Variance&quot;&gt;variance&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The above discussion may well be the shortest discussion of
&lt;a href=&quot;https://en.wikipedia.org/wiki/Probability&quot;&gt;probability&lt;/a&gt;
you will ever come across.  As such, it’s rather incomplete.  I would
encourage anyone interested to either read the wikipedia articles cited above,
or to take courses in both
&lt;a href=&quot;https://en.wikipedia.org/wiki/Probability&quot;&gt;probability&lt;/a&gt;
and
&lt;a href=&quot;https://en.wikipedia.org/wiki/Statistics&quot;&gt;statistics&lt;/a&gt;
to learn more.  It’s a fun field.&lt;/p&gt;

&lt;p&gt;For now, we now have the basics of what we need to examine
&lt;a href=&quot;https://en.wikipedia.org/wiki/Quantization_(signal_processing)&quot;&gt;quantization&lt;/a&gt;
effects.&lt;/p&gt;

&lt;h2 id=&quot;quantization-noise&quot;&gt;Quantization Noise&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Quantization_(signal_processing)&quot;&gt;Quantization&lt;/a&gt;
is the process that takes a continuous value and representing
that value by a single value from a discrete set.  Electrically, perhaps the
most classic example of
&lt;a href=&quot;https://en.wikipedia.org/wiki/Quantization_(signal_processing)&quot;&gt;quantization&lt;/a&gt;
is an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Analog-to-digital_converter&quot;&gt;analog to digital converter (ADC)&lt;/a&gt;.
&lt;a href=&quot;https://en.wikipedia.org/wiki/Analog-to-digital_converter&quot;&gt;Such a converter&lt;/a&gt;
takes an input voltage, which may best be represented as a
continuous value, and turns it into one of a number of
discrete values.  Fig 1 below shows an example of this.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 1: Converting a continuous waveform into discrete values&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/quantized-sine.png&quot; alt=&quot;Figure showing an example quantized sinewave&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;In this example, the blue sinewave was the original value, and the discontinuous
red lines represent a set of discrete values that each of the voltages within
the sinewave were mapped on to.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Analog-to-digital_converter&quot;&gt;ADC&lt;/a&gt;’s
also
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;&lt;em&gt;sample&lt;/em&gt;&lt;/a&gt;
signals. 
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;Sampled&lt;/a&gt;
signals are also discrete in time, and not just in value.
For our purposes in this post, we’ll postpone the study of
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sampling_(signal_processing)&quot;&gt;sampling&lt;/a&gt;
for later, and just focus on the 
&lt;a href=&quot;https://en.wikipedia.org/wiki/Quantization_(signal_processing)&quot;&gt;quantization&lt;/a&gt;
effects.&lt;/p&gt;

&lt;table style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 2: An example quantization function&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/quantized-fun.png&quot; alt=&quot;Notional quantization function&quot; width=&quot;240&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;In general, the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Quantization_(signal_processing)&quot;&gt;quantizater&lt;/a&gt;
within an &lt;a href=&quot;https://en.wikipedia.org/wiki/Analog-to-digital_converter&quot;&gt;ADC&lt;/a&gt;
may be considered to be a function
with a continuous input, &lt;code class=&quot;highlighter-rouge&quot;&gt;x&lt;/code&gt;, and a discrete output, &lt;code class=&quot;highlighter-rouge&quot;&gt;y&lt;/code&gt;.  One such function
is shown in Fig 2 at right.  A well built
&lt;a href=&quot;https://en.wikipedia.org/wiki/Analog-to-digital_converter&quot;&gt;ADC&lt;/a&gt;
will have evenly spaced discrete sample samples, &lt;code class=&quot;highlighter-rouge&quot;&gt;y&lt;/code&gt;, and it will map all
voltages, &lt;code class=&quot;highlighter-rouge&quot;&gt;x&lt;/code&gt;, to their nearest sample value, &lt;code class=&quot;highlighter-rouge&quot;&gt;y&lt;/code&gt;.  What
this means is that the difference between a sample value and the value it
represents, &lt;code class=&quot;highlighter-rouge&quot;&gt;y-x&lt;/code&gt;, will always be half the distance between samples or less.&lt;/p&gt;

&lt;p&gt;Of course,
&lt;a href=&quot;https://en.wikipedia.org/wiki/Quantization_(signal_processing)&quot;&gt;quantizing&lt;/a&gt;
any signal will distort the signal.  This is easily seen by the
simple fact that the red and blue lines in Fig 1 above are &lt;em&gt;different&lt;/em&gt;.  The
desired value was shown in blue, the reality at the output of the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Analog-to-digital_converter&quot;&gt;ADC&lt;/a&gt;
is shown in red.  It is the difference between the two signals forms
the topic of our discussion below.&lt;/p&gt;

&lt;p&gt;Let’s define the difference between the original voltage and its quantized
representation
&lt;a href=&quot;https://en.wikipedia.org/wiki/Quantization_(signal_processing)&quot;&gt;quantization&lt;/a&gt;
error.  As an example, the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Quantization_(signal_processing)&quot;&gt;quantization&lt;/a&gt;
error associated with Fig 1 above is shown below in dark green in Fig 3 below.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 3: Quantization error, shown in green&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/quantized-err.png&quot; alt=&quot;Showing the quantization error associated with a sine wave&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;This means that we can consider any received waveform to be the sum of two
signals.  The first is the signal of interest, shown in blue above.  The
second is the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Quantization_(signal_processing)&quot;&gt;quantization&lt;/a&gt;
error signal shown in green in Fig 3.&lt;/p&gt;

&lt;p&gt;Our goal will be to understand the statistics of this
&lt;a href=&quot;https://en.wikipedia.org/wiki/Quantization_(signal_processing)&quot;&gt;quantization&lt;/a&gt;
error.&lt;/p&gt;

&lt;p&gt;To analyze this error, we’ll first notice that for a single sample, the
difference between the analog voltage and the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Analog-to-digital_converter&quot;&gt;ADC&lt;/a&gt;
result lies between
&lt;code class=&quot;highlighter-rouge&quot;&gt;-1/2&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;1/2&lt;/code&gt; of a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Quantization_(signal_processing)&quot;&gt;quantization&lt;/a&gt;
level.  In Fig 3 above, there are two thin lines running
horizontally at &lt;code class=&quot;highlighter-rouge&quot;&gt;-1/2&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;1/2&lt;/code&gt;.  These lines illustrate the bounds of this
error.&lt;/p&gt;

&lt;p&gt;We’re going to treat this error as a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Random_variable&quot;&gt;random variable&lt;/a&gt;
and assume that all of these differences are both
&lt;a href=&quot;https://en.wikipedia.org/wiki/Independence_(probability_theory)&quot;&gt;independent&lt;/a&gt;
and identically distributed.  As one final assumption, we’ll assume that these
&lt;a href=&quot;https://en.wikipedia.org/wiki/Quantization_(signal_processing)&quot;&gt;quantization&lt;/a&gt;
errors are &lt;a href=&quot;https://en.wikipedia.org/wiki/Uniform_distribution_(continuous)&quot;&gt;uniformly
distributed&lt;/a&gt;
between &lt;code class=&quot;highlighter-rouge&quot;&gt;-1/2&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;1/2&lt;/code&gt;, with the same units as our sampled values have.
(You &lt;em&gt;could&lt;/em&gt; do this in units of Voltage, it’s just a touch more complex.)&lt;/p&gt;

&lt;p&gt;That gives us our
&lt;a href=&quot;https://en.wikipedia.org/wiki/Probability_density_function&quot;&gt;PDF&lt;/a&gt;,&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/eqn-quantization-pdf.png&quot; alt=&quot;The PDF of quantization noise&quot; width=&quot;263&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;and allows us to characterize our
&lt;a href=&quot;https://en.wikipedia.org/wiki/Quantization_(signal_processing)&quot;&gt;quantization&lt;/a&gt;
“noise”.  It also greatly simplifies any math we’ll need to do in order to
calculate &lt;a href=&quot;https://en.wikipedia.org/wiki/Expected_value&quot;&gt;expectations&lt;/a&gt;,
since we can now drop the &lt;code class=&quot;highlighter-rouge&quot;&gt;f(X)&lt;/code&gt; function and then only need to integrate from
&lt;code class=&quot;highlighter-rouge&quot;&gt;-1/2&lt;/code&gt; to &lt;code class=&quot;highlighter-rouge&quot;&gt;1/2&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;For example, using this
&lt;a href=&quot;https://en.wikipedia.org/wiki/Probability_density_function&quot;&gt;PDF&lt;/a&gt;,
we can now prove that the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Mean#Mean_of_a_probability_distribution&quot;&gt;mean&lt;/a&gt;
of this error is zero.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/eqn-mean-quantization-develop.png&quot; alt=&quot;Proving quantization noise is zero mean&quot; width=&quot;296&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;In many ways, though, this proof is backwards.  If all you did was to &lt;em&gt;look&lt;/em&gt;
at Fig 3 above, you could visually &lt;em&gt;see&lt;/em&gt; that the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Mean#Mean_of_a_probability_distribution&quot;&gt;mean&lt;/a&gt;
of any
&lt;a href=&quot;https://en.wikipedia.org/wiki/Quantization_(signal_processing)&quot;&gt;quantization&lt;/a&gt;
error &lt;em&gt;should&lt;/em&gt; be zero.  The amount of time the green line is above zero
can be seen to be equal to the amount of time it spends below zero.  Therefore,
this mathematical proof really only (partially) validates our &lt;a href=&quot;https://en.wikipedia.org/wiki/Uniform_distribution_(continuous)&quot;&gt;choice of
distribution&lt;/a&gt;,
rather than telling us anything new about our error.&lt;/p&gt;

&lt;p&gt;A zero
&lt;a href=&quot;https://en.wikipedia.org/wiki/Mean#Mean_of_a_probability_distribution&quot;&gt;mean&lt;/a&gt;
distribution will make our
&lt;a href=&quot;https://en.wikipedia.org/wiki/Variance&quot;&gt;variance&lt;/a&gt;
calculation simpler, since we no longer need to the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Mean#Mean_of_a_probability_distribution&quot;&gt;mean&lt;/a&gt;
as part of the calculation.  With a zero
&lt;a href=&quot;https://en.wikipedia.org/wiki/Mean#Mean_of_a_probability_distribution&quot;&gt;mean&lt;/a&gt;,
we now have&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/eqn-variance-nomean.png&quot; alt=&quot;Equation for variance with no mean&quot; width=&quot;296&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;for our
&lt;a href=&quot;https://en.wikipedia.org/wiki/Variance&quot;&gt;variance&lt;/a&gt;.  In other words, the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Variance&quot;&gt;variance&lt;/a&gt; of this
&lt;a href=&quot;https://en.wikipedia.org/wiki/Quantization_(signal_processing)&quot;&gt;quantization&lt;/a&gt;
noise is simply given by the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Expected_value&quot;&gt;expected value&lt;/a&gt;
of &lt;code class=&quot;highlighter-rouge&quot;&gt;X^2&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;We can now evaluate the integral, and quantify the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Variance&quot;&gt;variance&lt;/a&gt;
of any
&lt;a href=&quot;https://en.wikipedia.org/wiki/Quantization_(signal_processing)&quot;&gt;quantization&lt;/a&gt;
error:&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/eqn-quantization-variance-dev.png&quot; alt=&quot;Equation for variance with no mean&quot; width=&quot;375&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;If you look at the units of this
&lt;a href=&quot;https://en.wikipedia.org/wiki/Variance&quot;&gt;variance&lt;/a&gt;,
you’ll notice that they are the units of &lt;code class=&quot;highlighter-rouge&quot;&gt;X&lt;/code&gt; squared.  (&lt;code class=&quot;highlighter-rouge&quot;&gt;f(X)&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;dX&lt;/code&gt; are
unitless.)  For this reason, it
doesn’t make sense to compare values of &lt;code class=&quot;highlighter-rouge&quot;&gt;X&lt;/code&gt; against this
&lt;a href=&quot;https://en.wikipedia.org/wiki/Variance&quot;&gt;variance&lt;/a&gt; at all.  For example,
to ask whether or not the results of the
&lt;a href=&quot;/dsp/2017/08/30/cordic.html&quot;&gt;CORDIC&lt;/a&gt;
are within some number of &lt;a href=&quot;https://en.wikipedia.org/wiki/Variance&quot;&gt;variance&lt;/a&gt;’s
from the right answer would involve a units mismatch.
The &lt;a href=&quot;https://en.wikipedia.org/wiki/Standard_deviation&quot;&gt;standard deviation&lt;/a&gt;,
however, captures this same information while maintaining the same units that
&lt;code class=&quot;highlighter-rouge&quot;&gt;X&lt;/code&gt; had.  Since it’s just the square root of the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Variance&quot;&gt;variance&lt;/a&gt;, the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Standard_deviation&quot;&gt;standard deviation&lt;/a&gt; of any
&lt;a href=&quot;https://en.wikipedia.org/wiki/Quantization_(signal_processing)&quot;&gt;quantization&lt;/a&gt;
error is simply the square root of &lt;code class=&quot;highlighter-rouge&quot;&gt;1/12&lt;/code&gt; or equivalently&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/eqn-quantization-stdev.png&quot; alt=&quot;Equation for variance with no mean&quot; width=&quot;176&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Although this is the “proper” mathematical form for this
&lt;a href=&quot;https://en.wikipedia.org/wiki/Standard_deviation&quot;&gt;standard deviation&lt;/a&gt;,
I still tend to think of it as the square root of one over twelve.&lt;/p&gt;

&lt;p&gt;These results, both for the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Variance&quot;&gt;variance&lt;/a&gt; and the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Standard_deviation&quot;&gt;standard deviation&lt;/a&gt; of
&lt;a href=&quot;https://en.wikipedia.org/wiki/Quantization_(signal_processing)&quot;&gt;quantization&lt;/a&gt;
error, are the fundamental results of this section.
We’re going to need these results as we try to calculate the errors we might
expect from a
&lt;a href=&quot;/dsp/2017/08/30/cordic.html&quot;&gt;CORDIC&lt;/a&gt;–or any other
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_signal_processing&quot;&gt;DSP&lt;/a&gt;
algorithm for that matter.  First, though, let’s look at what happens to this
&lt;a href=&quot;https://en.wikipedia.org/wiki/Quantization_(signal_processing)&quot;&gt;quantization&lt;/a&gt;
and its &lt;a href=&quot;https://en.wikipedia.org/wiki/Variance&quot;&gt;variance&lt;/a&gt;
when we apply a mathematical algorithm to our signal–such as we will within the
&lt;a href=&quot;/dsp/2017/08/30/cordic.html&quot;&gt;CORDIC&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;rules-for-thumb&quot;&gt;Rules for thumb&lt;/h2&gt;

&lt;p&gt;Two rules of thumb will help us facilitate using the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Variance&quot;&gt;variance&lt;/a&gt;
of the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Quantization_(signal_processing)&quot;&gt;quantization&lt;/a&gt;
error to estimate algorithmic performance.  These two rules regard how
multiplying by a constant affects the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Variance&quot;&gt;variance&lt;/a&gt;,
as well as how adding two
&lt;a href=&quot;https://en.wikipedia.org/wiki/Random_variable&quot;&gt;random values&lt;/a&gt;
together affects the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Variance&quot;&gt;variance&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The first rule deals with multiplying a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Random_variable&quot;&gt;random variable&lt;/a&gt;
by a constant number.  This operation increases the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Variance&quot;&gt;variance&lt;/a&gt; in the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Random_variable&quot;&gt;random variable&lt;/a&gt;
by the square of the constant.  This follows from the definition of
&lt;a href=&quot;https://en.wikipedia.org/wiki/Variance&quot;&gt;variance&lt;/a&gt;:&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/eqn-variance-scale-dev.png&quot; alt=&quot;Equation showing how scale affects variance&quot; width=&quot;593&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;For our second rule, we’d like to add two
&lt;a href=&quot;https://en.wikipedia.org/wiki/Random_variable&quot;&gt;random variable&lt;/a&gt;’s together.
We’ll insist on two assumptions.  The first is that the two
&lt;a href=&quot;https://en.wikipedia.org/wiki/Random_variable&quot;&gt;random variables&lt;/a&gt; are
continuous and &lt;a href=&quot;https://en.wikipedia.org/wiki/Independence_(probability_theory)&quot;&gt;independently
distributed&lt;/a&gt;,
and the second is that they both have zero
&lt;a href=&quot;https://en.wikipedia.org/wiki/Mean#Mean_of_a_probability_distribution&quot;&gt;mean&lt;/a&gt;.
From there, let’s look at the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Variance&quot;&gt;variance&lt;/a&gt;
of the sum of two
&lt;a href=&quot;https://en.wikipedia.org/wiki/Random_variable&quot;&gt;random variables&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The proof of our property is a touch more complex than the last one since any
time you have two
&lt;a href=&quot;https://en.wikipedia.org/wiki/Random_variable&quot;&gt;random variables&lt;/a&gt;
you have to deal with a joint
&lt;a href=&quot;https://en.wikipedia.org/wiki/Probability_distribution&quot;&gt;distribution&lt;/a&gt;.
In general, the joint
&lt;a href=&quot;https://en.wikipedia.org/wiki/Probability_distribution&quot;&gt;distribution&lt;/a&gt;s
is a bi-variate
&lt;a href=&quot;https://en.wikipedia.org/wiki/Probability_density_function&quot;&gt;PDF&lt;/a&gt;,
such as &lt;code class=&quot;highlighter-rouge&quot;&gt;f(X,Y)&lt;/code&gt;.  Further, the single integral now becomes a double integral
over both &lt;code class=&quot;highlighter-rouge&quot;&gt;X&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;Y&lt;/code&gt;.  However, since we assumed that these two &lt;a href=&quot;https://en.wikipedia.org/wiki/Random_variable&quot;&gt;random
variables&lt;/a&gt; would be
&lt;a href=&quot;https://en.wikipedia.org/wiki/Independence_(probability_theory)&quot;&gt;independent&lt;/a&gt;,
their combined
&lt;a href=&quot;https://en.wikipedia.org/wiki/Probability_distribution&quot;&gt;distribution&lt;/a&gt;
can be expressed as a product of the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Probability_distribution&quot;&gt;distribution&lt;/a&gt;
for &lt;code class=&quot;highlighter-rouge&quot;&gt;X&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;f(X)&lt;/code&gt;, and the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Probability_distribution&quot;&gt;distribution&lt;/a&gt;
for &lt;code class=&quot;highlighter-rouge&quot;&gt;Y&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;g(Y)&lt;/code&gt;.  &lt;code class=&quot;highlighter-rouge&quot;&gt;g(Y)&lt;/code&gt; in this case is a different function from the &lt;code class=&quot;highlighter-rouge&quot;&gt;g(X)&lt;/code&gt;
above, since in this case it is the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Probability_distribution&quot;&gt;distribution&lt;/a&gt;
function for the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Random_variable&quot;&gt;random variable&lt;/a&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;Y&lt;/code&gt;.
We’ll still need to integrate over both &lt;code class=&quot;highlighter-rouge&quot;&gt;X&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;Y&lt;/code&gt;, but
this simplification will help us split the double integral into two separate
single integrals.&lt;/p&gt;

&lt;p&gt;Now that we have our terms, we can now develop an expression for the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Variance&quot;&gt;variance&lt;/a&gt;
of the sum of two
&lt;a href=&quot;https://en.wikipedia.org/wiki/Random_variable&quot;&gt;random variables&lt;/a&gt;:&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/eqn-variance-sum-dev.png&quot; alt=&quot;Deriving the variance of the sum of two random variables&quot; width=&quot;688&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;In sum, the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Variance&quot;&gt;variance&lt;/a&gt;
of the sum of two
&lt;a href=&quot;https://en.wikipedia.org/wiki/Independence_(probability_theory)&quot;&gt;independent&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Random_variable&quot;&gt;random variables&lt;/a&gt;, such as the
&lt;code class=&quot;highlighter-rouge&quot;&gt;X&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;Y&lt;/code&gt; above,
is the sum of their individual
&lt;a href=&quot;https://en.wikipedia.org/wiki/Variance&quot;&gt;variances&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Just for completeness then, here are the two properties we’ll need later.&lt;/p&gt;

&lt;p&gt;The first property is how scale affects
&lt;a href=&quot;https://en.wikipedia.org/wiki/Variance&quot;&gt;variance&lt;/a&gt;:&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/eqn-variance-scale.png&quot; alt=&quot;Equation showing how scale affects variance&quot; width=&quot;193&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;To generate this property, we assumed that the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Random_variable&quot;&gt;random variable&lt;/a&gt; had zero
&lt;a href=&quot;https://en.wikipedia.org/wiki/Mean#Mean_of_a_probability_distribution&quot;&gt;mean&lt;/a&gt;.
The property actually holds of
&lt;a href=&quot;https://en.wikipedia.org/wiki/Random_variable&quot;&gt;random variables&lt;/a&gt; with non-zero
&lt;a href=&quot;https://en.wikipedia.org/wiki/Mean#Mean_of_a_probability_distribution&quot;&gt;mean&lt;/a&gt;s
as well, but I’ll leave that as an exercise for the student.&lt;/p&gt;

&lt;p&gt;The second property was the &lt;a href=&quot;https://en.wikipedia.org/wiki/Variance&quot;&gt;variance&lt;/a&gt;
of the sum of two
&lt;a href=&quot;https://en.wikipedia.org/wiki/Random_variable&quot;&gt;random numbers&lt;/a&gt;:&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/eqn-variance-sum.png&quot; alt=&quot;Equation showing the variance of the sum of two values&quot; width=&quot;283&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;This property was dependent upon the assumptions of zero
&lt;a href=&quot;https://en.wikipedia.org/wiki/Mean#Mean_of_a_probability_distribution&quot;&gt;mean&lt;/a&gt;,
and
&lt;a href=&quot;https://en.wikipedia.org/wiki/Independence_(probability_theory)&quot;&gt;independent&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Probability_distribution&quot;&gt;distribution&lt;/a&gt;s.
However, as with the first property, the zero
&lt;a href=&quot;https://en.wikipedia.org/wiki/Mean#Mean_of_a_probability_distribution&quot;&gt;mean&lt;/a&gt;
assumption only simplified our proof–it wasn’t required.&lt;/p&gt;

&lt;p&gt;Using these two properties, we can now return to our
&lt;a href=&quot;/dsp/2017/08/30/cordic.html&quot;&gt;CORDIC&lt;/a&gt; algorithm(s) and
consider the question of whether or not the algorithm(s) even work.&lt;/p&gt;

&lt;h2 id=&quot;coming-up&quot;&gt;Coming up&lt;/h2&gt;

&lt;p&gt;As we look forward to future posts, I’ll try to keep those discussions simpler.
I apologize for depth of this discussion, but if you want to
&lt;a href=&quot;/dsp/2017/10/02/cordic-tb.html&quot;&gt;prove how good an algorithm&lt;/a&gt;
such as the
&lt;a href=&quot;/dsp/2017/08/30/cordic.html&quot;&gt;CORDIC algorithm&lt;/a&gt; is, you are
going to need some of this math.  (If you know another way, let me know.)
From here on out, I’m going to try to &lt;a href=&quot;/dsp/2017/10/02/cordic-tb.html&quot;&gt;just use these
results&lt;/a&gt; rather than
rehashing today’s lessons.&lt;/p&gt;

&lt;table style=&quot;float: right&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/from-quantization.svg&quot; alt=&quot;Roadmap forward from this quantization discussion&quot; width=&quot;283&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;If you found these lessons informative, then that’s wonderful!  If you’ve
never heard any of this before and it actually makes sense today, then I’m
flattered.  The concepts aren’t necessarily that simple.&lt;/p&gt;

&lt;p&gt;On the other hand, if you are not familiar with the study of
&lt;a href=&quot;https://en.wikipedia.org/wiki/Probability&quot;&gt;probability&lt;/a&gt; at all, then you
may have found that the proofs and discussions above, regarding &lt;a href=&quot;https://en.wikipedia.org/wiki/Probability_distribution&quot;&gt;probability
distributions&lt;/a&gt; and
&lt;a href=&quot;https://en.wikipedia.org/wiki/Quantization_(signal_processing)&quot;&gt;quantization&lt;/a&gt;
error, read like a foreign language.  If you feel like that is you, then let
me commend to you the study of
&lt;a href=&quot;https://en.wikipedia.org/wiki/Probability&quot;&gt;probability&lt;/a&gt;.  I found the
coursework to be a lot of fun, and enjoyed the study myself.&lt;/p&gt;

&lt;p&gt;This lesson, though, sets us up to &lt;a href=&quot;/dsp/10/02/cordic-tb.html&quot;&gt;build the
test bench&lt;/a&gt;
that we need to put together for our
&lt;a href=&quot;/dsp/2017/08/30/cordic.html&quot;&gt;CORDIC algorithm&lt;/a&gt;.
Once we have proven the
&lt;a href=&quot;/dsp/2017/08/30/cordic.html&quot;&gt;CORDIC&lt;/a&gt;’s
capabilities, we can then turn around and use it to create a generic
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filtering&lt;/a&gt;
test bench.  With a generic filtering test bench, we can then build and test
several
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;digital filtering&lt;/a&gt;
approaches that can be used within an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;If the Lord wills, then that’s where we’ll go next.&lt;/p&gt;
&lt;hr /&gt;&lt;p&gt;&lt;em&gt;Behold, this have I found, saith the preacher, counting one by one, to find the account (Eccl 7:27)&lt;/em&gt;</description>
        <pubDate>Wed, 27 Sep 2017 00:00:00 -0400</pubDate>
        <link>http://zipcpu.com/dsp/2017/09/27/quantization.html</link>
        <guid isPermaLink="true">http://zipcpu.com/dsp/2017/09/27/quantization.html</guid>
        
        
        <category>dsp</category>
        
      </item>
    
      <item>
        <title>Clocks for Software Engineers</title>
        <description>&lt;p&gt;If you have a software background and you want to pick up digital design,
then one of the first things you need to learn about early on is the concept
of the clock.  To many software engineers turned beginning
&lt;a href=&quot;https://en.wikipedia.org/wiki/Hardware_description_language&quot;&gt;Hardware Description Language
(HDL)&lt;/a&gt;
designers, the concept of a clock is an annoyance.  Without using a
clock, they can turn
&lt;a href=&quot;https://en.wikipedia.org/wiki/Hardware_description_language&quot;&gt;HDL&lt;/a&gt;
into a programming language–with $display’s, &lt;code class=&quot;highlighter-rouge&quot;&gt;if&lt;/code&gt;’s,
and &lt;code class=&quot;highlighter-rouge&quot;&gt;for&lt;/code&gt; loops like any other programming language.  Yet the clock that these
beginning designers ignore is often the most fundamental part of any digital
design.&lt;/p&gt;

&lt;p&gt;This difficulty is never more present then when reviewing some of the first
designs that beginning
&lt;a href=&quot;https://en.wikipedia.org/wiki/Hardware_description_language&quot;&gt;HDL&lt;/a&gt;
developers produce.  I’ve now talked with several of these individuals who
have posted questions on the forums I participate within.  When I’ve then
drilled down into what they are doing, I’ve had to cringe at what I’ve found.&lt;/p&gt;

&lt;p&gt;As an example, one student came to me struggling to understand why no one
on-line seemed to think much of his
&lt;a href=&quot;https://en.wikipedia.org/wiki/Advanced_Encryption_Standard&quot;&gt;Advanced Encryption Standard (AES)&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Hardware_description_language&quot;&gt;HDL&lt;/a&gt;
implementation.
I’ll spare him the embarrassment of being named, or of linking to his project.
Instead, I’m just going to call him a &lt;em&gt;student&lt;/em&gt;.  (No, &lt;a href=&quot;/about&quot;&gt;I’m not a
professor&lt;/a&gt;.)
This “student” had created a Verilog design to do not one round of
&lt;a href=&quot;https://en.wikipedia.org/wiki/Advanced_Encryption_Standard&quot;&gt;AES&lt;/a&gt;
encryption, but &lt;em&gt;every round&lt;/em&gt;, &lt;em&gt;all in combinatorial logic with no clocks&lt;/em&gt; in
between.  I can’t remember if he was doing
&lt;a href=&quot;https://en.wikipedia.org/wiki/Advanced_Encryption_Standard&quot;&gt;AES&lt;/a&gt;-128,
&lt;a href=&quot;https://en.wikipedia.org/wiki/Advanced_Encryption_Standard&quot;&gt;AES&lt;/a&gt;-192, or
&lt;a href=&quot;https://en.wikipedia.org/wiki/Advanced_Encryption_Standard&quot;&gt;AES&lt;/a&gt;-256,
but &lt;a href=&quot;https://en.wikipedia.org/wiki/Advanced_Encryption_Standard&quot;&gt;AES&lt;/a&gt;
requires between 10 and 14 rounds.  As I recall, his encryption engine
worked perfectly in the simulator, yet it only used one clock to encrypt or
decrypt his data.  He was proud of his work, but couldn’t understand why
those who looked at it told him he was thinking like a software engineer,
and not like a hardware designer.&lt;/p&gt;

&lt;table style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 1: Software is Sequential&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/sw-is-serial.svg&quot; alt=&quot;Software runs serially&quot; width=&quot;128&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;Indeed, I’ve now had the opportunity to counsel many of these software
engineers, new to
&lt;a href=&quot;https://en.wikipedia.org/wiki/Hardware_description_language&quot;&gt;HDL&lt;/a&gt;,
like this “student”.  Many of them like to treat
&lt;a href=&quot;https://en.wikipedia.org/wiki/Hardware_description_language&quot;&gt;HDL&lt;/a&gt; like
just another &lt;em&gt;software programming&lt;/em&gt; language.  Having programmed before, they
go and look for the basics in any software programming language: how to
declare variables, how to make an if statement, a case statement, how to write
loops, etc.  They then write their code like a computer program–where
everything needs to run sequentially (Fig 1), yet completely ignoring the
reality of digital design which is that everything runs in parallel.&lt;/p&gt;

&lt;p&gt;Sometimes these programmers will find a simulator, such as
&lt;a href=&quot;https://www.veripool.org/wiki/verilator&quot;&gt;Verilator&lt;/a&gt;,
&lt;a href=&quot;http://iverilog.icarus.com&quot;&gt;iverilog&lt;/a&gt;,
or the 
&lt;a href=&quot;https://www.edaplayground.com/&quot;&gt;EDA playground&lt;/a&gt;.
They’ll then use a bunch of &lt;code class=&quot;highlighter-rouge&quot;&gt;$display&lt;/code&gt; commands in their logic, treat them like
sequential “printf”s and use them to get their code to work–&lt;em&gt;without using
a clock&lt;/em&gt;.  Their design then “runs” in the simulator using combinatorial logic
alone.&lt;/p&gt;

&lt;p&gt;These students then describe their designs to me, and explain to me that their
design “works without a clock”.&lt;/p&gt;

&lt;p&gt;Say what?&lt;/p&gt;

&lt;p&gt;The reality is that no digital logic design can work “without a clock”.
There is always some physical process creating the
inputs.  These inputs must all be valid at some start time–this time forms the
first clock “tick” in their design.  Likewise, the outputs are then required
from those inputs some time later.  The time when all the outputs are
valid given for a given set of inputs forms the next “clock” in a “clockless”
design.  Perhaps the first clock “tick” is when the set the last switch on
their board is adjusted and the last clock “tick” is when their eye reads the
result.  It doesn’t matter: there is a clock.&lt;/p&gt;

&lt;p&gt;The result is that someone who claims that their design “has no clock” is
either stating that he is using the simulator in an unrealistic fashion, or
that the design has an external clock setting the inputs and reading the
outputs–which is another way of saying that the design really &lt;em&gt;does&lt;/em&gt; have
a clock.&lt;/p&gt;

&lt;p&gt;If you find yourself struggling to understand the necessity of having a clock
when working in digital logic, or if you know someone who might be struggling
with this concept, then this post is for you.&lt;/p&gt;

&lt;p&gt;Let’s spend a moment or two discussing the clock, and why it is so important
to build and design your logic around a clock.&lt;/p&gt;

&lt;h2 id=&quot;lesson-1-hardware-design-is-parallel-design&quot;&gt;Lesson #1: Hardware design is parallel design&lt;/h2&gt;

&lt;p&gt;The first and perhaps most difficult part of learning hardware design is
to learn that all hardware design is parallel design.  Things don’t take
place serially, as in one instruction after another (Fig 1), like they do in a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;computer&lt;/a&gt;.
Instead, everything happens at once, as in Fig 2.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 2: Hardware logic runs in Parallel&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/hw-is-parallel.svg&quot; alt=&quot;Hardware runs in parallel&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;This changes a &lt;em&gt;lot&lt;/em&gt; of things.&lt;/p&gt;

&lt;table style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 3: A software loop&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/sw-loop.svg&quot; alt=&quot;Figure of a software loop&quot; width=&quot;200&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;The first thing that changes needs to be the developer.  You need to &lt;a href=&quot;/blog/2017/08/21/rules-for-newbies.html&quot;&gt;learn to
&lt;em&gt;think&lt;/em&gt; in
parallel&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Perhaps a good example of this difference would be a hardware loop.&lt;/p&gt;

&lt;p&gt;In software, a loop consists of a series of
instructions, as Fig 3 illustrates.  These instructions create a set of
initial conditions.  Logic is then performed within the loop.  Then a loop
variable is used to make and define this logic, and it is often incremented
each time through the loop.  Until the
loop variable reaches the termination condition, the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;
continues to repeat
the instructions and logic within the loop.  The more times the loop runs,
the longer it takes to run the program.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Hardware_description_language&quot;&gt;HDL&lt;/a&gt;
based hardware loops are not like this at all.  Instead, the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Hardware_description_language&quot;&gt;HDL&lt;/a&gt;
synthesis
tool uses the loop description to make several copies of the logic all
running in parallel.  The logic used to create the loop, such as the index,
to increment that index, to check the index against the final condition, etc.,
doesn’t need to be synthesized–so it is usually removed.  Further, since
the synthesis tool is creating physical wires and logic blocks, the number
of times through the loop cannot change after synthesis time.  After that
time, the amount of hardware is fixed and can no longer be changed.&lt;/p&gt;

&lt;p&gt;The structure that results, shown in Fig 4 below, is &lt;em&gt;very&lt;/em&gt; different from
the structure of a software loop in Fig 3 above.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 4: An HDL generated loop&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/hw-loop.svg&quot; alt=&quot;Figure of an HDL generated loop&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;This has several consequences.  For example, loop iterations can’t necessarily
depend upon the output of prior loop iterations like they could in software.
As a result, it’s hard to run a loop of logic across all of the data in a set
have an answer in the next clock.&lt;/p&gt;

&lt;p&gt;But … now we’ve come back to the concept of the clock again.&lt;/p&gt;

&lt;p&gt;The clock is central to any
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
design.  Everything revolves around it.
Indeed, I would argue that all of your logic development should &lt;em&gt;start&lt;/em&gt; with
the clock.  It’s not an afterthought, but rather the clock forms the
structure of how you think about digital design in the first place.&lt;/p&gt;

&lt;h2 id=&quot;why-the-clock-is-important&quot;&gt;Why the clock is important&lt;/h2&gt;

&lt;p&gt;Step one is to understand that everything within a digital logic design takes
time to do in hardware.  Not only that, but
different operations take different amounts of time.  Traveling from one
part of the chip to another also takes time.&lt;/p&gt;

&lt;p&gt;Perhaps the way to visualize this is with a chart.  Let’s place the
inputs to our algorithm on the top, the logic in the middle, and the outputs
on the bottom.  Time, as an axis, will run from top to bottom, from one clock
to the next.  The result of this visualization might look something like
Fig 5, below.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 5: Logic takes time, three operations&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/clk-poor-design.svg&quot; alt=&quot;Figure showing several logic operations, and their impact on the clock rate&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Fig 5 shows several different operations: an addition, a multiply, and several
rounds of
&lt;a href=&quot;https://en.wikipedia.org/wiki/Advanced_Encryption_Standard&quot;&gt;AES&lt;/a&gt;–although
for discussion purposes it could be several rounds of any algorithm.
I’ve used the size of the operation boxes, in the vertical direction, to
indicate notionally how much time each operation might require.  Further,
operations that depend upon other operations stack up.  Hence, if you want
to do many rounds of
&lt;a href=&quot;https://en.wikipedia.org/wiki/Advanced_Encryption_Standard&quot;&gt;AES&lt;/a&gt; within
one clock, you’ll need to know that the second round cannot begin until
the first is complete.  Fitting this logic in, therefore, will increase the
amount of time between clock ticks and slow down your overall clock rate.&lt;/p&gt;

&lt;p&gt;Now let’s look at the pink boxes.&lt;/p&gt;

&lt;p&gt;The pink boxes represent the wasted capacity in your hardware
circuit–times when you might have been able to do something,
but since you had to wait for the clock, or perhaps wait for your inputs
to be processed first, you couldn’t do anything.  For example, in our notional
diagram above the multiply doesn’t take as long as one round of
&lt;a href=&quot;https://en.wikipedia.org/wiki/Advanced_Encryption_Standard&quot;&gt;AES&lt;/a&gt;,
neither does the addition.  However, you can’t do anything with the results
of those two operations while the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Advanced_Encryption_Standard&quot;&gt;AES&lt;/a&gt;
calculations are taking place since those operations need to wait for
the next clock to get their next inputs.  This is what the “pink” boxes
represent in Fig 5: idle circuitry.  Further, because all of the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Advanced_Encryption_Standard&quot;&gt;AES&lt;/a&gt;
rounds are pushing the next clock into the distance, there’s a lot of
idle circuitry presented in Fig 5.  This design, therefore, will not run as
fast as the hardware would allow.&lt;/p&gt;

&lt;p&gt;If all we did was pipeline the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Advanced_Encryption_Standard&quot;&gt;AES&lt;/a&gt;
algorithm, so that one round could be calculated on every clock, we could
then get the entire design to run faster with less wasted capacity.&lt;/p&gt;

&lt;p&gt;Fig 6 shows this idea.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 6: Breaking up the operations speeds up the clock&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/clk-aes-better.svg&quot; alt=&quot;Figure: several operations, with immediate results between each&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;As a result of breaking our operation up into smaller operations, each of
which could be accomplished between clock ticks, our design now has much
less wasted capacity.  Even better, instead of encrypting only one block
of data at a time, we can pipeline the encryption algorithm.  The resulting
logic won’t encrypt a single block any faster than Fig 5 above, but if you
can keep the pipeline full you should be able to increase your
&lt;a href=&quot;https://en.wikipedia.org/wiki/Advanced_Encryption_Standard&quot;&gt;AES&lt;/a&gt;
encryption throughput by somewhere between 10-14x faster.&lt;/p&gt;

&lt;p&gt;This is therefore a better design.&lt;/p&gt;

&lt;p&gt;Can we do better?  Indeed we could!  If you are familiar with
&lt;a href=&quot;https://en.wikipedia.org/wiki/Advanced_Encryption_Standard&quot;&gt;AES&lt;/a&gt;,
then you know that each round of
&lt;a href=&quot;https://en.wikipedia.org/wiki/Advanced_Encryption_Standard&quot;&gt;AES&lt;/a&gt;,
has discrete steps within it.  These
can be broken up, allowing us to increase our clock speed until the 
&lt;a href=&quot;https://en.wikipedia.org/wiki/Advanced_Encryption_Standard&quot;&gt;AES&lt;/a&gt;
round logic takes less time than the multiply.  This will increase the number
of adds and multiplies you can do, as well as micro-pipelining your
encryption engine so that you can run even more data through it on a per
clock basis.&lt;/p&gt;

&lt;p&gt;Not bad.&lt;/p&gt;

&lt;p&gt;Fig 6 above, though, shows a couple of other things as well.&lt;/p&gt;

&lt;p&gt;First, let’s consider the
arrows to be routing delays.  (The figure is &lt;em&gt;not&lt;/em&gt; drawn to scale.  It is an
illustration for a notional discussion only.) Every piece of logic needs to
have the results of the last piece of logic routed to it.  This means that
even if a piece of logic requires no time to accomplish–such as if it just
reorders wires or some such, moving the logic from one end of the
chip to another will still take time.  Hence, even if you make your operations
as simple as possible, there will still be delays for moving the data around.&lt;/p&gt;

&lt;p&gt;Second, you may notice
that none of the arrows actually started at the clock tick.  Neither did
any of them go all the way right up to the next clock tick.  This was
to illustrate the concept of &lt;a href=&quot;https://en.wikipedia.org/Flip-flop_(electronics)#Timing_considerations&quot;&gt;setup and hold timing&lt;/a&gt;.
&lt;a href=&quot;https://en.wikipedia.org/Flip-flop_(electronics)&quot;&gt;Flip-flops&lt;/a&gt;, the structures
that capture and synchronize your data to the clock, need some amount of time
prior to the arrival of the clock, where the data is already constant and
determined.  In addition, despite the fact that the clock is often considered
to be instantaneous, it never is.  It arrives at different parts of your chip
at different times.  This again requires a bit of a buffer between operations.&lt;/p&gt;

&lt;p&gt;So what conclusions can we draw from this lesson?&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Logic takes time to accomplish&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;More logic takes more time&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Your clock speed is limited by the amount of time it takes to accomplish
whatever logic you place between clocks ticks (plus routine delays,
&lt;a href=&quot;https://en.wikipedia.org/Flip-flop_(electronics)#Timing_considerations&quot;&gt;setup and hold timing&lt;/a&gt;, clock uncertainty, etc.)&lt;/p&gt;

    &lt;p&gt;The more logic you stuff between your clocks, the slower your clock rate
will be.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The speed of your fastest operation will be limited by the clock speed
required to accomplish your slowest operation.&lt;/p&gt;

    &lt;p&gt;This was the example of the addition above.  While it could run faster than
the multiply and any single round of
&lt;a href=&quot;https://en.wikipedia.org/wiki/Advanced_Encryption_Standard&quot;&gt;AES&lt;/a&gt;,
the add was slowed down by the rest of the logic within the design.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;There is a hardware defined limit to clock speed.  Even operations
requiring no logic still take time.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Hence, a balanced design tries to place roughly the same amount of logic
between clocks all the way across the design.&lt;/p&gt;

&lt;h2 id=&quot;how-much-logic-to-place-between-clocks&quot;&gt;How much logic to place between clocks?&lt;/h2&gt;

&lt;p&gt;So now that you know that you have to deal with a clock, how should you modify
or build your design in light of this information?  The answer is that you
should limit the amount of logic between clock ticks.  But, by how much, and
how will you know that answer?&lt;/p&gt;

&lt;p&gt;One way is to know how much logic you can do between clock ticks is to set
your clock speed to an arbitrary rate, and then to build your design within
a tool-suite that understands your hardware.  Anytime your design fails to
meet its timing requirements, you will need to either go back and split up the
components within your design, or slow down your clock rate.  You should be
able to use your design tools to find this longest path.&lt;/p&gt;

&lt;p&gt;If you do this, you will learn for yourself a series of heuristic rules
that you can then use to figure out how much logic you can place between
clocks on the hardware you are designing for.&lt;/p&gt;

&lt;p&gt;For example, I’ve tended to build my designs for 100MHz clock rates within
the Xilinx 7-series parts.  These designs then typically run at about 80MHz
within a Spartan-6, or 50MHz within an iCE40–although these are not hard
and fast relationships.  What works on one chip may have excess capacity on
another, or it might fail its timing checks on another.&lt;/p&gt;

&lt;p&gt;Here are some rough heuristics I’ve used regarding clock usage.  Since they
are only heuristics, they are not likely to be appropriate for all designs:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;I can usually do a 32-bit addition, together with a mux of 4-8 items within
a clock.&lt;/p&gt;

    &lt;p&gt;Were you to use a faster clock, such as a 200MHz clock, you may then need
to separate the addition(s) from the multiplexer.&lt;/p&gt;

    &lt;p&gt;The &lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;’s longest path actually
runs from the &lt;a href=&quot;/zipcpu/2017/08/11/simple-alu.html&quot;&gt;ALU&lt;/a&gt;
output to the
&lt;a href=&quot;/zipcpu/2017/08/11/simple-alu.html&quot;&gt;ALU&lt;/a&gt;
input.&lt;/p&gt;

    &lt;p&gt;This sounds simple enough.  It even matches the heuristic above as well.&lt;/p&gt;

    &lt;p&gt;The problem the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt; struggles with,
at higher speeds, is routing this output back into the 
&lt;a href=&quot;/zipcpu/2017/08/11/simple-alu.html&quot;&gt;ALU&lt;/a&gt;.&lt;/p&gt;

    &lt;p&gt;Let’s trace that path for a moment:
Following the &lt;a href=&quot;/zipcpu/2017/08/11/simple-alu.html&quot;&gt;ALU&lt;/a&gt;,
the logic path first goes through a 4-way multiplexer to decide whether the
&lt;a href=&quot;/zipcpu/2017/08/11/simple-alu.html&quot;&gt;ALU&lt;/a&gt;,
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/memops.v&quot;&gt;memory&lt;/a&gt;, or
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/div.v&quot;&gt;divide&lt;/a&gt;
output needs to be written back.  This write-back result is then fed into
a bypass circuit to determine if it needs to be immediately fed into the
&lt;a href=&quot;/zipcpu/2017/08/11/simple-alu.html&quot;&gt;ALU&lt;/a&gt; as one of its
two inputs.
Only at the end of this multiplexer and bypass path does the
&lt;a href=&quot;/zipcpu/2017/08/11/simple-alu.html&quot;&gt;ALU&lt;/a&gt; operation and
multiplexer take place.  Hence, all of these logic steps can stress the path
through the &lt;a href=&quot;/zipcpu/2017/08/11/simple-alu.html&quot;&gt;ALU&lt;/a&gt;.
However, because of the 
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;’s construction, any clocks
placed into this path will likely slow the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt; proportionally.  This means that
this longest path is likely to remain the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;’s longest path for some time.&lt;/p&gt;

    &lt;p&gt;Were I interested in running the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt; at a higher speed, this is the
first logic path that I would attempt to break up and optimize.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;16x16-bit Multiplies take one clock.&lt;/p&gt;

    &lt;p&gt;Sometimes, on some hardware, I can get 32x32-bit multiplies to take place
on a single clock.  On other hardware, I need to break these in pieces.
For this reason, if I ever need a signed 32x32-bit multiply, I use a
&lt;a href=&quot;https://github.com/ZipCPU/openarty/blob/master/rtl/bigsmpy.v&quot;&gt;pipelined
routine&lt;/a&gt;
I built for that purpose.  The
&lt;a href=&quot;https://github.com/ZipCPU/openarty/blob/master/rtl/bigsmpy.v&quot;&gt;routine&lt;/a&gt;
contains several
multiplication approaches within it, allowing me to select from the
options appropriate for the hardware I’m currently working on.&lt;/p&gt;

    &lt;p&gt;Your hardware may also support 18x18-bit multiplies natively as well.
Some &lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;’s
also supports a multiply and accumulate within one
optimized hardware clock.  Know your hardware, and you’ll know what you
can do here.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Any block RAM access takes one clock.  Avoid adjusting the index during
that clock period if you can.  Likewise, avoid doing anything with the
output during this clock as well.&lt;/p&gt;

    &lt;p&gt;While I’m going to argue that this is a good rule, I have violated both
parts of it successfully and without (serious) consequence
at 100MHz on a Xilinx 7-series device.  (iCE40 devices have problems with
this.)&lt;/p&gt;

    &lt;p&gt;For example, the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;
reads from its registers, adds an immediate to the result, and then
selects from between whether the result should’ve been the register plus
the immediate, the PC plus the immediate, or the condition code register
plus the immediate–all in one clock.&lt;/p&gt;

    &lt;p&gt;As another example, for a long time the &lt;a href=&quot;https://github.com/ZipCPU/wbscope&quot;&gt;Wishbone
Scope&lt;/a&gt; determined the address for
reading back from within it’s buffer based upon whether or not a read from
memory was taking place on the current clock or not.  Breaking it from this
dependency required adding another clock of latency, so the &lt;a href=&quot;https://github.com/ZipCPU/wbscope/blob/master/rtl/wbscope.v&quot;&gt;current
version&lt;/a&gt;
doesn’t break this (self-imposed) rule any more.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;These rules are no more than heuristics that I have used over time to gauge
how much logic can take place between clock ticks.  They are device and clock
speed dependent, so they may not work for your application.  My recommendation
would be that you develop your own heuristics for what you can do between
clock periods.&lt;/p&gt;

&lt;h2 id=&quot;next-steps&quot;&gt;Next Steps&lt;/h2&gt;

&lt;p&gt;Perhaps the best closing advice I can offer to any new
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
developer is to recommend that you learn
&lt;a href=&quot;https://en.wikipedia.org/wiki/Hardware_description_language&quot;&gt;HDL&lt;/a&gt;
while practicing on real hardware rather than just within a simulation.
The tools associated with actual hardware components are known for their
ability to check your code and the timing it requires.  Further, while building
your design for a high speed clock is good, it isn’t the end-all for hardware
design.&lt;/p&gt;

&lt;p&gt;Remember, hardware design is parallel.
It all starts with the clock.&lt;/p&gt;

&lt;p&gt;Finally, feel free to &lt;a href=&quot;&amp;#109;&amp;#097;&amp;#105;&amp;#108;&amp;#116;&amp;#111;:&amp;#122;&amp;#105;&amp;#112;&amp;#099;&amp;#112;&amp;#117;&amp;#064;&amp;#103;&amp;#109;&amp;#097;&amp;#105;&amp;#108;&amp;#046;&amp;#099;&amp;#111;&amp;#109;&quot;&gt;write me&lt;/a&gt; and let me know if
this helps you understand
&lt;a href=&quot;https://en.wikipedia.org/wiki/Hardware_description_language&quot;&gt;HDL&lt;/a&gt;
better, or even if it leaves you more confused.  That will help me know if I
need to come back and address this topic again at a later date.  Thanks!&lt;/p&gt;
&lt;hr /&gt;&lt;p&gt;&lt;em&gt;To everything there is a season, and a time to every purpose under the heaven (Eccl 3:1)&lt;/em&gt;</description>
        <pubDate>Mon, 18 Sep 2017 00:00:00 -0400</pubDate>
        <link>http://zipcpu.com/blog/2017/09/18/clocks-for-sw-engineers.html</link>
        <guid isPermaLink="true">http://zipcpu.com/blog/2017/09/18/clocks-for-sw-engineers.html</guid>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>Demonstrating the improved PWM waveform</title>
        <description>&lt;p&gt;This post follows our prior post titled
&lt;a href=&quot;/dsp/2017/09/04/pwm-reinvention.html&quot;&gt;Reinventing PWM&lt;/a&gt;.
A reader has commented to me that I hadn’t posted any test bench or other
method to prove that this module works.  Since I also think that such a test
would be beneficial, I’ve created a &lt;a href=&quot;https://github.com/ZipCPU/wbpwmaudio/tree/master/demo-rtl&quot;&gt;test bench and
demonstration&lt;/a&gt;
which we will examine below.&lt;/p&gt;

&lt;p&gt;Most of the parts and pieces of our test code, and certainly the methodology,
could easily be applied to test just about any &lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_signal_processing&quot;&gt;Digital Signal Processing
(DSP)&lt;/a&gt;
system.  In short, we’ll put a test signal into the design, make some
predictions about how we think that test signal will behave, and then
measure the response to see how well it does and whether or not the
results match our predictions.&lt;/p&gt;

&lt;p&gt;The classic test signals for any signal processing application are
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sine_wave&quot;&gt;sine waves&lt;/a&gt;
and
&lt;a href=&quot;https://en.wikipedia.org/wiki/Dirac_delta_function&quot;&gt;impulses&lt;/a&gt;.  For
our purposes today, we’ll focus on just the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sine_wave&quot;&gt;sine wave&lt;/a&gt; input.
Specifically, let’s look at both a constant frequency and a swept frequency
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sine_wave&quot;&gt;sine wave&lt;/a&gt; input, and measure
the result the hardware provides.  We’ll also adjust our approach for both
sampling rates and volume variations.&lt;/p&gt;

&lt;p&gt;To do this, we’ll build a test design of the form shown in Fig 1.&lt;/p&gt;

&lt;table style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 1: Test Setup&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/pwmtb-setup.svg&quot; alt=&quot;Block diagram of a PDM vs PWM test&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;The test-suite design will consist not only of &lt;a href=&quot;https://github.com/ZipCPU/wbpwmaudio/blob/master/demo-rtl/toplevel.v&quot;&gt;Verilog based
logic&lt;/a&gt;,
but also a C++ &lt;a href=&quot;https://github.com/ZipCPU/wbpwmaudio/blob/master/demo-rtl/pdmdemo.cpp&quot;&gt;test bench
driver&lt;/a&gt;
that can be used to run the
&lt;a href=&quot;https://www.veripool.org/wiki/verilator&quot;&gt;Verilator&lt;/a&gt; based simulation.  This
&lt;a href=&quot;https://github.com/ZipCPU/wbpwmaudio/blob/master/demo-rtl/pdmdemo.cpp&quot;&gt;C++
portion&lt;/a&gt;
will be used to
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt; and
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sample-rate_conversion&quot;&gt;resample&lt;/a&gt;
the 100MHz
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
output pin values in order to create a file which can easily be ingested
and inspected within &lt;a href=&quot;https://www.gnu.org/software/octave/&quot;&gt;Octave&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;To control this design, we’ll have the sweep and frequency control selected
from a table at the top of each second over an 8-second repeating test
interval.  Over these 8-seconds, we’ll apply the following test cases to
demonstrate the &lt;a href=&quot;/dsp/2017/09/04/pwm-reinvention.html&quot;&gt;improved
PWM&lt;/a&gt; generator:&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Second&lt;/th&gt;
      &lt;th&gt;On/Off&lt;/th&gt;
      &lt;th&gt;Test Description&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;0-2&lt;/td&gt;
      &lt;td&gt;ON&lt;/td&gt;
      &lt;td&gt;Swept tone from 110Hz to 27.3kHz&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;off&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;4-5&lt;/td&gt;
      &lt;td&gt;ON&lt;/td&gt;
      &lt;td&gt;440 Hz Tone&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;6-7&lt;/td&gt;
      &lt;td&gt;off&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;We’ll also run the sine wave initially at it’s full amplitude, just to
demonstrate that there are no problems with the internal comparisons as
a function of range.  We’ll later adjust to &lt;code class=&quot;highlighter-rouge&quot;&gt;1/256&lt;/code&gt;th of that amount to
demonstrate that the method works reasonably for small amplitudes as well.&lt;/p&gt;

&lt;p&gt;We’ll use a physical switch input to select between which of the two outputs
we send to a &lt;a href=&quot;https://store.digilentinc.com/pmod-amp2-audio-amplifier&quot;&gt;PMod
AMP2&lt;/a&gt;
(should you happen to have one, and should you wish to try this in actual
hardware).&lt;/p&gt;

&lt;p&gt;Finally, we’ll place all the code for this test
&lt;a href=&quot;https://github.com/ZipCPU/wbpwmaudio/tree/master/demo-rtl&quot;&gt;online&lt;/a&gt;
within the
&lt;a href=&quot;https://github.com/ZipCPU/wbpwmaudio&quot;&gt;wbpwmaudio&lt;/a&gt;
repository.  This will allow you to repeat the experiment, and verify the
results for yourself should you wish to do so.&lt;/p&gt;

&lt;h2 id=&quot;test-results&quot;&gt;Test Results&lt;/h2&gt;

&lt;p&gt;Let’s walk through both the test and the results.
In simulation, we’ll measure the results with a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Spectrogram&quot;&gt;Spectrogram&lt;/a&gt;.  (Wikipedia’s
article on the &lt;a href=&quot;https://en.wikipedia.org/wiki/Periodogram&quot;&gt;Periodogram&lt;/a&gt; is
also applicable to the time slices of the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Spectrogram&quot;&gt;Spectrogram&lt;/a&gt;.)
A &lt;a href=&quot;https://en.wikipedia.org/wiki/Spectrogram&quot;&gt;Spectrogram&lt;/a&gt;
is a two-dimensional image with the
two axes being time and frequency.  Time will go from left to right, and
frequency will go from zero at the top down to the maximum at the bottom.
Spectral energy comes out of the image in a third axis.
You can see the &lt;a href=&quot;https://www.gnu.org/software/octave&quot;&gt;Octave&lt;/a&gt;
code for calculating the
&lt;a href=&quot;https://github.com/ZipCPU/wbpwmaudio/blob/master/demo-rtl/showspectrogram.m&quot;&gt;spectrogram here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The scale on the z-axes, representing signal strength will be presented in
color ranging (in &lt;a href=&quot;https://en.wikipedia.org/wiki/Decibel&quot;&gt;decibels&lt;/a&gt;)
from -80dB to 0dB relative to the maximum point in the image.
The maximum value will be held to zero dB and colored white.  We’ll
artificially cut the &lt;a href=&quot;https://en.wikipedia.org/wiki/Spectrogram&quot;&gt;spectrogram&lt;/a&gt;
off at -80dB below this maximum value, and color anything at or below this
level in black.  Hence we should expect our tone to be a brightly colored,
nearly white line, across a black (or nearly black) background.
All of this minor processing code is posted
&lt;a href=&quot;https://github.com/ZipCPU/wbpwmaudio/blob/master/demo-rtl/showspectrogram.m&quot;&gt;here&lt;/a&gt;.
You can even find the code defining these false colormap
&lt;a href=&quot;https://github.com/ZipCPU/wbpwmaudio/blob/master/demo-rtl/mymap.m&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Given the tests described above, let’s think for a moment about what we
are going to expect to see from the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Spectrogram&quot;&gt;spectrogram&lt;/a&gt; of the
audio output.  First, one would expect a slanted line, representing the
initial swept tone, ranging from zero time and 110Hz frequency to three
seconds and just past 27.3kHz in frequency.  Further, once this swept tone
reaches the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Nyquist_frequency&quot;&gt;Nyquist frequency&lt;/a&gt;
associated with the underlying sample rate, whether 4kHz or 16kHz (half the
sample rate), we should expect to see an “X” shape as the tone
&lt;a href=&quot;https://en.wikipedia.org/wiki/Aliasing&quot;&gt;aliases&lt;/a&gt; back below the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Nyquist_frequency&quot;&gt;Nyquist limit&lt;/a&gt;.  Second,
when displaying the result of the 440Hz tone, in an ideal system we would see
nothing more than a white horizontal line centered at 440Hz.
&lt;a href=&quot;https://en.wikipedia.org/wiki/Aliasing&quot;&gt;Aliasing&lt;/a&gt; effects will appear at
440Hz plus or minus multiples of the sample rate.
Third, any sudden transition will spread its energy across frequency.
Hence, any transition or hiccup in the signal, such as when the transmitter
starts or stops, should appear on our
&lt;a href=&quot;https://en.wikipedia.org/wiki/Spectrogram&quot;&gt;spectrogram&lt;/a&gt; as a (rough) vertical
line.&lt;/p&gt;

&lt;p&gt;We’ll run our first test with a 32kHz sample rate, and the second test with an
8kHz sample rate.  The sample rate will also control the period of the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Pulse-width_modulation&quot;&gt;PWM&lt;/a&gt;
waveform.  One would therefore expect silence, or near silence, to produce
a series of harmonic tones starting at this frequency when using
&lt;a href=&quot;https://en.wikipedia.org/wiki/Pulse-width_modulation&quot;&gt;PWM&lt;/a&gt;.  The
&lt;a href=&quot;https://en.wikipedia.org/wiki/Pulse-density_modulation&quot;&gt;PDM&lt;/a&gt; system
should have no such feature.  The third and final test will drop the sample
rate to &lt;code class=&quot;highlighter-rouge&quot;&gt;1/256&lt;/code&gt;th of the original sample rate.  This should allow us to see
any spectral features created while the signal tries to output values near
“zero”.&lt;/p&gt;

&lt;p&gt;These are the results that we will expect from a “perfect” system.&lt;/p&gt;

&lt;p&gt;We’ll start by examining the
&lt;a href=&quot;https://github.com/ZipCPU/wbpwmaudio/blob/master/demo-rtl/traditionalpwm.v&quot;&gt;traditional&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Pulse-width_modulation&quot;&gt;PWM&lt;/a&gt; result in Fig 2.
In this case, the sample rate was set to 32kHz–which will also drive the
period of the
&lt;a href=&quot;https://github.com/ZipCPU/wbpwmaudio/blob/master/demo-rtl/traditionalpwm.v&quot;&gt;traditional&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Pulse-width_modulation&quot;&gt;PWM&lt;/a&gt;
waveform generator.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 2: Test Results for a PWM Generator&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/pwm32k.png&quot; alt=&quot;Test Results, PWM, 32kHz sample rate&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Because the sample interval is based about 32kHz, one would expect
&lt;a href=&quot;https://en.wikipedia.org/wiki/Spectrogram&quot;&gt;spectrogram&lt;/a&gt;
content above 16kHz to be a (rough) mirror image of the content below it, and
this is what we see in the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Spectrogram&quot;&gt;spectrogram&lt;/a&gt; figure.
Although this mirroring will continue on up to 32kHz, the image is cut off
at 22kHz–the &lt;a href=&quot;https://en.wikipedia.org/wiki/Nyquist_frequency&quot;&gt;Nyquist
frequency&lt;/a&gt;
of the resampler, and the &lt;a href=&quot;https://en.wikipedia.org/wiki/Hearing_range&quot;&gt;upper end of the human hearing frequency
range&lt;/a&gt;.
If you’ve never seen this mirroring effect, it &lt;a href=&quot;http://www.dtic.mil/dtic/tr/fulltext/u2/a423141.pdf&quot;&gt;can be derived from first
principles&lt;/a&gt; under no
other assumptions than the fact that the output is a sampled real valued
signal rather than a complex one.&lt;/p&gt;

&lt;p&gt;I also expect the mirror images above the 
&lt;a href=&quot;https://en.wikipedia.org/wiki/Nyquist_frequency&quot;&gt;Nyquist frequency&lt;/a&gt;
to decay slowly with a rough
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sinc_funtion&quot;&gt;sinc shape&lt;/a&gt;,
due to the underlying &lt;a href=&quot;/dsp/2017/06/06/simple-interpolator&quot;&gt;Nearest Neighbor
interpolation&lt;/a&gt;
but I haven’t examined the results close enough to see if this is the case.&lt;/p&gt;

&lt;p&gt;As a final item of note, the swept frequency portion of the test didn’t
produce just a single swept tone line in this
&lt;a href=&quot;https://en.wikipedia.org/wiki/Spectrogram&quot;&gt;spectrogram&lt;/a&gt;,
but rather a series of slanted lines.
The lines appear to converge with the swept tone test signal at zero
frequency and spread out from there.  Put simply, the swept tone
we desired to produce didn’t come out as a pure audio tone following the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Pulse-width_modulation&quot;&gt;PWM&lt;/a&gt;.
Instead, it producesd something still periodic but slightly different from a
sine wave.  These extra swept lines represent
&lt;a href=&quot;https://en.wikipedia.org/wiki/Harmonic&quot;&gt;harmonics&lt;/a&gt; of the desired waveform,
running at roughly two, three, and four times the frequency of the swept tone.
(There’s even a fifth &lt;a href=&quot;https://en.wikipedia.org/wiki/Harmonic&quot;&gt;harmonic&lt;/a&gt;
that you can see if you look close enough.)  These represent undesired and
unwanted distortions, caused by the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Pulse-width_modulation&quot;&gt;PWM&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/wbpwmaudio/blob/master/demo-rtl/traditionalpwm.v&quot;&gt;generator&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Now let’s compare that result with the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Pulse-density_modulation&quot;&gt;PDM&lt;/a&gt; (&lt;a href=&quot;/dsp/2017/09/04/pwm-reinvention.html&quot;&gt;improved
PWM&lt;/a&gt;)
waveform in Fig 3.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 3: Test Results for the Improved Signal Generator&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/pdm32k.png&quot; alt=&quot;Test Results, PDM, 32kHz sample rate&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;From here you can see that the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Pulse-density_modulation&quot;&gt;PDM&lt;/a&gt;
waveform roughly matches what one would expect, while the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Pulse-width_modulation&quot;&gt;PWM&lt;/a&gt;
waveform in Fig 2 has all kinds of
&lt;a href=&quot;https://en.wikipedia.org/wiki/Harmonic&quot;&gt;harmonic&lt;/a&gt;
distortions.&lt;/p&gt;

&lt;table style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 4: Resampler aliasing&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/pdm32k-zoom.png&quot; alt=&quot;Figure showing the resampler aliasing and falloff&quot; width=&quot;240&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;If you look closely at Fig 3, you can even start to see some additional
aliasing effects in the swept tone near the very bottom of the image (22kHz).
Fig 4 zooms in one one of these components, so you can see what I’m talking
about.  These show the transition band of the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Anti-aliasing_filter&quot;&gt;anti-aliasing filter&lt;/a&gt;
that was used within the &lt;a href=&quot;https://github.com/ZipCPU/wbpwmaudio/blob/master/demo-rtl/pdmdemo.cpp&quot;&gt;C++ test
harness&lt;/a&gt;.
They also show the utility of having such an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Anti-aliasing_filter&quot;&gt;anti-aliasing filter&lt;/a&gt;
in the design.  Without it, there would be further swept-tone “X”s within
the design, caused by the aliased components above 22kHz sweeping back into
band.  We’ll see these additional “X” components in the next test(s).&lt;/p&gt;

&lt;p&gt;Let’s now repeat the above test using an 8kHz sample rate, but without
providing an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Anti-aliasing_filter&quot;&gt;anti-aliasing filter&lt;/a&gt;
for points above 4kHz.&lt;/p&gt;

&lt;p&gt;Without this &lt;a href=&quot;https://en.wikipedia.org/wiki/Anti-aliasing_filter&quot;&gt;anti-aliasing
filter&lt;/a&gt;, we should
expect to see &lt;a href=&quot;https://en.wikipedia.org/wiki/Aliasing&quot;&gt;aliasing&lt;/a&gt; components
above 4kHz instead of above 32kHz.  (Remember the &lt;a href=&quot;https://github.com/ZipCPU/wbpwmaudio/blob/master/demo-rtl/pdmdemo.cpp&quot;&gt;demo
software&lt;/a&gt;
only applies
&lt;a href=&quot;https://en.wikipedia.org/wiki/Anti-aliasing_filter&quot;&gt;the anti-aliasing filter&lt;/a&gt;
for frequencies above 22kHz.)  You’d expect these
&lt;a href=&quot;https://en.wikipedia.org/wiki/Aliasing&quot;&gt;aliasing&lt;/a&gt;
products above 4kHz to create something where frequencies between 0-4kHz were
mirrored from 4kHz to 8kHz, and then the 0-8kHz range should be repeated
above 8kHz.  This is what we might expect.&lt;/p&gt;

&lt;p&gt;The &lt;a href=&quot;https://github.com/ZipCPU/wbpwmaudio/blob/master/demo-rtl/traditionalpwm.v&quot;&gt;traditional&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Pulse-width_modulation&quot;&gt;PWM&lt;/a&gt;
signal, however, might also be expected to have additional distortions since
the &lt;a href=&quot;https://en.wikipedia.org/wiki/Pulse-width_modulation&quot;&gt;PWM&lt;/a&gt;
interval is now within audio range.  These can be seen in Fig 5.  Of the
tests shown, the affect appears to be the most pronounced surrounding
the 440Hz tone.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 5: Test Results for a PWM Generator with an 8kHz based interval&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/pwm8k.png&quot; alt=&quot;Test Results, PWM, 8kHz interval rate&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;What’s not shown is that this result is quite unpleasant upon the ears.&lt;/p&gt;

&lt;p&gt;The corresponding 
&lt;a href=&quot;https://github.com/ZipCPU/wbpwmaudio/blob/master/rtl/wbpwmaudio.v&quot;&gt;improved&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Pulse-density_modulation&quot;&gt;PDM&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Spectrogram&quot;&gt;spectrogram&lt;/a&gt;.
is shown in Fig 6.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 6: Test Results for the improved signal generator, with an 8kHz based interval&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/pdm8k.png&quot; alt=&quot;Test Results, PDM, 8kHz interval rate&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;This &lt;a href=&quot;https://en.wikipedia.org/wiki/Spectrogram&quot;&gt;spectrogram&lt;/a&gt;
actually shows much of what you would expect: aliasing products from sampling
at a rate less than 40kHz with no
&lt;a href=&quot;https://en.wikipedia.org/wiki/Anti-aliasing_filter&quot;&gt;anti-aliasing filter&lt;/a&gt;.
(The 40kHz number comes from twice the frequency at the top of the &lt;a href=&quot;https://en.wikipedia.org/wiki/Hearing_range&quot;&gt;human
hearing range&lt;/a&gt;.)&lt;/p&gt;

&lt;p&gt;When comparing Fig 5 with Fig 6, the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Pulse-width_modulation&quot;&gt;PWM&lt;/a&gt;
output clearly has more distortion within it.  Not only does it have the same
&lt;a href=&quot;https://en.wikipedia.org/wiki/Harmonic&quot;&gt;harmonic&lt;/a&gt;
distortions it had at the 32kHz sample rate, but there are
also many other distortions associated with the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Pulse-width_modulation&quot;&gt;PWM&lt;/a&gt; waveform interval
at 8kHz.  This helps to demonstrate that the &lt;a href=&quot;https://github.com/ZipCPU/wbpwmaudio/blob/master/rtl/wbpwmaudio.v&quot;&gt;improved PWM
generator&lt;/a&gt;
solves many of the problems that &lt;a href=&quot;https://en.wikipedia.org/wiki/Pulse-width_modulation&quot;&gt;traditional
PWM&lt;/a&gt;
signals struggle with.&lt;/p&gt;

&lt;p&gt;You might be surprised in Fig 5 that the
&lt;a href=&quot;https://github.com/ZipCPU/wbpwmaudio/blob/master/demo-rtl/traditionalpwm.v&quot;&gt;traditional&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Pulse-width_modulation&quot;&gt;PWM&lt;/a&gt;
generator did not produce an 8kHz tone during the silence period.  Such an
annoying tone during silence should be expected, should it not?  The reason
that there’s no annoying tone during this silence period is simply because
the design is considered to be controlling a
&lt;a href=&quot;https://store.digilentinc.com/pmod-amp2-audio-amplifier&quot;&gt;PMod AMP2&lt;/a&gt;.
The &lt;a href=&quot;https://store.digilentinc.com/pmod-amp2-audio-amplifier&quot;&gt;AMP2&lt;/a&gt;
has both gain and shutdown controls, and so the simulator artificially turns
the output off during those regions based upon these control outputs.&lt;/p&gt;

&lt;p&gt;Our last comparison, then, will be focused on examining how these two
waveform generators handle very weak signals.  Specifically, we’ll lower
the amplitude from full scale (or actually just nearly full scale) down to
&lt;code class=&quot;highlighter-rouge&quot;&gt;1/256&lt;/code&gt;th of that amount and then repeat the 8kHz test.&lt;/p&gt;

&lt;p&gt;The &lt;a href=&quot;https://en.wikipedia.org/wiki/Pulse-width_modulation&quot;&gt;PWM&lt;/a&gt;
output can be found in Fig 7.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 7: PWM Test Results, 8kHz sampling, 1/256 of full scale&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/pwm8k-weak.png&quot; alt=&quot;Figure: test results at 1/256th the amplitude for the PWM signal&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;The &lt;a href=&quot;/dsp/2017/09/04/pwm-reinvention.html&quot;&gt;improved&lt;/a&gt;
output can be found in Fig 8.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 8: PDM Test Results, 8kHz sampling, 1/256 of full scale&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/pdm8k-weak.png&quot; alt=&quot;Figure: test results at 1/256th the amplitude for the PDM signal&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Notice the difference in the background between the two images.  There you will
notice that Fig 8 has a blue background instead of a black background.  This
is an artifact of how we have chosen to plot the signal–showing the maximum
&lt;a href=&quot;https://en.wikipedia.org/wiki/Spectrogram&quot;&gt;spectrogram&lt;/a&gt; value over the
course of the test as white, and the black being defined as 80dB below that.
In the case of Fig 7, you’ll notice that
the &lt;a href=&quot;https://en.wikipedia.org/wiki/Pulse-width_modulation&quot;&gt;PWM&lt;/a&gt;’s output is
dominated, not by the swept tone or the 440Hz tone, but rather the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Pulse-width_modulation&quot;&gt;PWM&lt;/a&gt; switching
signal at 8kHz.  This annoying signaling artifact sets the numeric value
associated with the 0dB color (white).  The
&lt;a href=&quot;/dsp/2017/09/04/pwm-reinvention.html&quot;&gt;improved signal&lt;/a&gt;
has no such annoying tone setting its maximum value, and hence 80dB below its
maximum value is into the &lt;a href=&quot;https://en.wikipedia.org/wiki/Quantization_(signal_processing)&quot;&gt;quantization
noise&lt;/a&gt;
of this system, which is showing up as a blue background.&lt;/p&gt;

&lt;p&gt;Perhaps a time slice from the 440Hz tone region would help to explain this
better.  We’ll remove the arbitrary image scaling, so as to show this time
slice shown below in Fig 9.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 9: Comparing 440Hz tone generations&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/pwm-v-pdm-weak.png&quot; alt=&quot;Figure: comparing PWM vs PDM when producing a 440Hz tone&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;In this figure, you can see the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Pulse-width_modulation&quot;&gt;PWM&lt;/a&gt;
plotted in red, and the
&lt;a href=&quot;/dsp/2017/09/04/pwm-reinvention.html&quot;&gt;improved PWM signal&lt;/a&gt;
shown in blue.&lt;/p&gt;

&lt;p&gt;The first thing to notice is that the PWM signal has a tone in the center
of it that is 40+dB higher than the signal of interest.  Likewise, the
background values of both are nearly identical, although the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Pulse-width_modulation&quot;&gt;PWM&lt;/a&gt;
implementation is showing some stronger artifacts.&lt;/p&gt;

&lt;h2 id=&quot;comparing-the-results-against-expectations&quot;&gt;Comparing the results against expectations&lt;/h2&gt;

&lt;p&gt;Now that you’ve seen the results, were they what you expected?  My answer
to that is &lt;em&gt;somewhat&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;I expected the &lt;a href=&quot;https://en.wikipedia.org/wiki/Pulse-width_modulation&quot;&gt;PWM&lt;/a&gt;
signal to have some problems, but I’ll admit I wasn’t expecting the strong
&lt;a href=&quot;https://en.wikipedia.org/wiki/Harmonic&quot;&gt;harmonic&lt;/a&gt;
distortion.  While I might be tempted to believe this is caused by my test
setup, the
&lt;a href=&quot;/dsp/2017/09/04/pwm-reinvention.html&quot;&gt;improved approach&lt;/a&gt;
didn’t have any such distortions.  Further, after
reviewing the traditional &lt;a href=&quot;https://github.com/ZipCPU/wbpwmaudio/blob/master/demo-rtl/traditionalpwm.v&quot;&gt;PWM generation
code&lt;/a&gt;
I can’t find anything that would cause this.&lt;/p&gt;

&lt;p&gt;I was expecting the
&lt;a href=&quot;https://github.com/ZipCPU/wbpwmaudio/blob/master/demo-rtl/traditionalpwm.v&quot;&gt;PWM generated&lt;/a&gt;
tone in Fig 7, though.&lt;/p&gt;

&lt;p&gt;Some of the comments I’ve received online have suggested that the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Two&#39;s_complement&quot;&gt;two’s complement&lt;/a&gt;
to &lt;a href=&quot;https://en.wikipedia.org/wiki/Offset_binary&quot;&gt;offset binary&lt;/a&gt; conversion
discussed within the &lt;a href=&quot;/dsp/2017/09/04/pwm-reinvention.html&quot;&gt;improved
PWM&lt;/a&gt;
article and used in the &lt;a href=&quot;https://github.com/ZipCPU/wbpwmaudio/blob/master/rtl/wbpwmaudio.v&quot;&gt;demonstration waveform
generator&lt;/a&gt;
was in error.  Had this been the case, the 
&lt;a href=&quot;https://en.wikipedia.org/wiki/Pulse-density_modulation&quot;&gt;PDM&lt;/a&gt;
signal above would have had some seriously annoying harmonics of the desired
tone as well–particulary for full-range sample values.  That it does not
proves that the method, and the conversions, work as stated.&lt;/p&gt;

&lt;p&gt;Does this prove that the
&lt;a href=&quot;/dsp/2017/09/04/pwm-reinvention.html&quot;&gt;improved PWM&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/wbpwmaudio/blob/master/rtl/wbpwmaudio.v&quot;&gt;generator&lt;/a&gt;
is better?  I’ll leave that to your judgment.&lt;/p&gt;

&lt;h2 id=&quot;if-you-want-to-try-this-yourself&quot;&gt;If you want to try this yourself&lt;/h2&gt;

&lt;p&gt;In case you want to try this test and compare the waveforms yourself, you’ll
need to have both &lt;a href=&quot;https://www.veripool.org/wiki/verilator&quot;&gt;Verilator&lt;/a&gt; and
&lt;a href=&quot;https://www.gnu.org/software/octave/&quot;&gt;Octave&lt;/a&gt; installed.  On a
&lt;a href=&quot;https://www.debian.org&quot;&gt;Debian&lt;/a&gt; based system, such as
&lt;a href=&quot;https://www.ubuntu.com&quot;&gt;Ubuntu&lt;/a&gt;, you can install these packages via:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;sudo apt-get install verilator octave&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Once you have these two packages, you can download and build the
&lt;a href=&quot;https://github.com/ZipCPU/wbpwmaudio/tree/master/rtl/demo-rtl&quot;&gt;demo package&lt;/a&gt;.
Start by cloning the &lt;a href=&quot;https://github.com/ZipCPU/wbpwmaudio&quot;&gt;wbpwmaudio&lt;/a&gt;
repository.  Then change into the 
&lt;a href=&quot;https://github.com/ZipCPU/wbpwmaudio&quot;&gt;demo-rtl&lt;/a&gt; directory, and
then type “make”.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;git clone https://github.com/ZipCPU/wbpwmaudio.git
&lt;span class=&quot;nb&quot;&gt;cd &lt;/span&gt;wbpwmaudio/demo-rtl
make&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;On a Windows system, you may need to follow the
&lt;a href=&quot;https://www.cygwin.com&quot;&gt;Cygwin&lt;/a&gt;
&lt;a href=&quot;/blog/2017/07/28/cygwin-fpga.html&quot;&gt;instructions found here&lt;/a&gt;.
(I don’t use these often, so please tell me if you struggle with them at all.)&lt;/p&gt;

&lt;p&gt;You can then run the test (for a given switch setting) by running &lt;a href=&quot;https://github.com/ZipCPU/wbpwmaudio/blob/master/demo-rtl/pdmdemo.cpp&quot;&gt;pdmdemo&lt;/a&gt;:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;./pdmdemo&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;To view the results that
&lt;a href=&quot;https://github.com/ZipCPU/wbpwmaudio/blob/master/demo-rtl/pdmdemo.cpp&quot;&gt;pdmdemo&lt;/a&gt;
creates, start up &lt;a href=&quot;https://www.gnu.org/software/octave/&quot;&gt;Octave&lt;/a&gt;
and run the &lt;a href=&quot;https://github.com/ZipCPU/wbpwmaudio/blob/master/demo-rtl/showspectrogram.m&quot;&gt;script provided&lt;/a&gt;
on the &lt;code class=&quot;highlighter-rouge&quot;&gt;wavfp.dbl&lt;/code&gt; file that
&lt;a href=&quot;https://github.com/ZipCPU/wbpwmaudio/blob/master/demo-rtl/pdmdemo.cpp&quot;&gt;pdmdemo&lt;/a&gt;
generates:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span class=&quot;gp&quot;&gt;&amp;gt; &lt;/span&gt;octave -q --no-gui
&lt;span class=&quot;gp&quot;&gt;% &lt;/span&gt;showspectrogram&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&#39;wavfp.dbl&#39;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;If you run this test in a separate window, while the
&lt;a href=&quot;https://github.com/ZipCPU/wbpwmaudio/blob/master/demo-rtl/pdmdemo.cpp&quot;&gt;pdmdemo&lt;/a&gt;
is still running, you should be able to see the program’s progress as it runs
through the demo.&lt;/p&gt;

&lt;p&gt;If you want to repeat the test for the
&lt;a href=&quot;https://github.com/ZipCPU/wbpwmaudio/blob/master/demo-rtl/traditionalpwm.v&quot;&gt;traditional&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Pulse-width_modulation&quot;&gt;PWM&lt;/a&gt;
generator, you’ll need
to edit the &lt;a href=&quot;https://github.com/ZipCPU/wbpwmaudio/blob/master/pdmdemo.cpp&quot;&gt;pdmdemo.cpp&lt;/a&gt; C++ file and set the &lt;code class=&quot;highlighter-rouge&quot;&gt;traditiona_pwm&lt;/code&gt; boolean value in the &lt;code class=&quot;highlighter-rouge&quot;&gt;main()&lt;/code&gt;
function to &lt;code class=&quot;highlighter-rouge&quot;&gt;true&lt;/code&gt;.  This will set the simulated hardware switch value to true.
Alternatively, you can try this design in hardware and just toggle the switch.&lt;/p&gt;

&lt;p&gt;If you would like, you are also welcome to generate a
&lt;a href=&quot;/blog/2017/07/31/vcd.html&quot;&gt;VCD file&lt;/a&gt; via the
&lt;a href=&quot;https://www.veripool.org/wiki/verilator&quot;&gt;Verilator&lt;/a&gt;
based &lt;a href=&quot;https://github.com/ZipCPU/wbpwmaudio/blob/master/demo-rtl/pdmdemo.cpp&quot;&gt;simulation&lt;/a&gt;
as well.  Should you wish to do this, you’ll want to uncomment
the &lt;code class=&quot;highlighter-rouge&quot;&gt;tb-&amp;gt;opentrace(&quot;pdmdemo.vcd&quot;);&lt;/code&gt; line within
&lt;a href=&quot;https://github.com/ZipCPU/wbpwmaudio/blob/master/pdmdemo.cpp&quot;&gt;pdmdemo.cpp&lt;/a&gt;.
Be aware if you do this, though, that the
&lt;a href=&quot;/blog/2017/07/31/vcd.html&quot;&gt;VCD file&lt;/a&gt;
can grow to many GB very quickly.  While I’ve been successful using
&lt;a href=&quot;/blog/2017/07/31/vcd.html&quot;&gt;VCD file&lt;/a&gt;,
of more than a GB, &lt;a href=&quot;https://gtkwave.sourceforge.net&quot;&gt;gtkwave&lt;/a&gt; complains when
I do so.  As a result, I’ve generally tried to avoid using
&lt;a href=&quot;/blog/2017/07/31/vcd.html&quot;&gt;VCD file&lt;/a&gt;,
greater than 10GB in in size.  A Control-C should stop the
&lt;a href=&quot;https://github.com/ZipCPU/wbpwmaudio/blob/master/pdmdemo.cpp&quot;&gt;pdmdemo&lt;/a&gt;
program prior to completion if you choose to go this road.&lt;/p&gt;

&lt;h2 id=&quot;staring-closely&quot;&gt;Staring Closely&lt;/h2&gt;

&lt;p&gt;This is actually a fun opportunity to see if there’s anything to learn by
staring really closely at the data.&lt;/p&gt;

&lt;p&gt;If you’ve never used a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Window_function&quot;&gt;window function&lt;/a&gt; before, the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Spectrogram&quot;&gt;spectrogram&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/wbpwmaudio/blob/master/demo-rtl/showspectrogram.m&quot;&gt;code&lt;/a&gt;
creates its results using a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Hann_function&quot;&gt;Hanning window&lt;/a&gt;.
This window was responsible for the rough triangle shape of our signals
as shown in Fig 9 above.&lt;/p&gt;

&lt;p&gt;Suppose we used a
&lt;a href=&quot;/dsp/freq-teaser.html&quot;&gt;better window&lt;/a&gt;
instead?&lt;/p&gt;

&lt;p&gt;Figure 10, below, shows the same chart as Fig 9 above, but this time with an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Fast_Fourier_transform&quot;&gt;FFT&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Window_function&quot;&gt;window&lt;/a&gt;
having &lt;a href=&quot;/dsp/freq-teaser.html&quot;&gt;much better spectral
resolution&lt;/a&gt; than the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Hann_function&quot;&gt;Hanning window&lt;/a&gt;.
used above.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 10: Comparing spectral resolution, 440Hz tone, 8kHz sampling, weak tone&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/pwm-v-pdm-hires.png&quot; alt=&quot;Image Showing High Resolution Spectral Estimation&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;The biggest thing to notice is the difference in the resolution of the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Pulse-width_modulation&quot;&gt;PWM&lt;/a&gt;
generation found at 8kHz.  Indeed, Fig 10 shows that the interference
has very little spectral width to it.  This is as we would expect, although
not as Fig 9 above displayed.  This is also a common problem found in many
spectral estimation tools: the tool artificially distorts the results.&lt;/p&gt;

&lt;p&gt;Let’s also look at the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Spectrogram&quot;&gt;spectrogram&lt;/a&gt;
of the &lt;a href=&quot;https://en.wikipedia.org/wiki/Pulse-width_modulation&quot;&gt;PWM&lt;/a&gt;
tone, shown in Fig 7 above, but this time using the
&lt;a href=&quot;/dsp/freq-teaser.html&quot;&gt;high resolution frequency window&lt;/a&gt;
and shown in Fig 11 below.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 11: High Resolution Spectrogram, PWM signal, 8kHz, weak amplitude&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/pwm8k-weak-hires.png&quot; alt=&quot;Image Showing High Resolution Spectral Estimation of the PWM 8kHz weak signal&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Here you might notice the difference in line thickness of the interfering
&lt;a href=&quot;https://en.wikipedia.org/wiki/Pulse-width_modulation&quot;&gt;PWM&lt;/a&gt;
tonal artifact.  In Fig 11, the artifact appears much sharper and
has better frequency resolution.  However, this difference only follows from
the individual cuts such as we showed above and its not nearly as pronounced
in this view.&lt;/p&gt;

&lt;p&gt;We could also zoom in and examine the higher power swept tone, such as was
shown in the top left corner of Fig 3 above.  This comparison is now shown
below, with &lt;a href=&quot;https://en.wikipedia.org/wiki/Hann_function&quot;&gt;Hanning window&lt;/a&gt; on
the left and the &lt;a href=&quot;/dsp/freq-teaser.html&quot;&gt;higher resolution
window&lt;/a&gt; result on the right.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 11: Comparing Spectral Resolution&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/pwm-spectro-hanning.png&quot; alt=&quot;Spectrogram using Hanning Window&quot; width=&quot;350&quot; /&gt;&lt;/td&gt;&lt;td&gt;&lt;img src=&quot;/img/pwm-spectro-sharp.png&quot; alt=&quot;A better/sharper Spectrogram&quot; width=&quot;350&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td align=&quot;center&quot;&gt;Hanning Window&lt;/td&gt;&lt;td align=&quot;center&quot;&gt;Higher Resolution Window&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Should you be interested in
&lt;a href=&quot;/dsp/freq-teaser.html&quot;&gt;high resolution frequency windowing&lt;/a&gt;,
this is one of &lt;a href=&quot;/about/gisselquist-technology.html&quot;&gt;Gisselquist
Technology&lt;/a&gt;’s
&lt;a href=&quot;/about/products.html&quot;&gt;commercial products&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;out-of-order&quot;&gt;Out of Order&lt;/h2&gt;

&lt;p&gt;Today’s test set demonstrates a lot of technology that we’ve haven’t yet had
the opportunity to work through within &lt;a href=&quot;http://zipcpu.com/&quot;&gt;this
blog&lt;/a&gt;.  I hope to come back and
do so, and only apologize for presenting concepts out of order. 
Missing background topics include:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;The &lt;a href=&quot;/dsp/2017/10/02/cordic-tb.html&quot;&gt;test-bench for the&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/cordic&quot;&gt;CORDIC&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/cordic/tree/master/sw&quot;&gt;core generator&lt;/a&gt;
that we’ve built.&lt;/p&gt;

    &lt;p&gt;The &lt;a href=&quot;/dsp/2017/10/02/cordic-tb.html&quot;&gt;trick to this test
bench&lt;/a&gt;
is that the rounding and truncation taking place within the
&lt;a href=&quot;https://github.com/ZipCPU/cordic&quot;&gt;CORDIC&lt;/a&gt; has consequences in the
output.  This creates some variability in the output, variability that is
a function of the parameters used when generating the
&lt;a href=&quot;https://github.com/ZipCPU/cordic&quot;&gt;CORDIC&lt;/a&gt;.  &lt;a href=&quot;/dsp/2017/10/02/cordic-tb.html&quot;&gt;Predicting these
consequences&lt;/a&gt;,
to know whether or not the
&lt;a href=&quot;https://github.com/ZipCPU/cordic&quot;&gt;CORDIC&lt;/a&gt; is producing the correct output,
is &lt;a href=&quot;/dsp/2017/10/02/cordic-tb.html&quot;&gt;taking me some work&lt;/a&gt;.
It’s also why I haven’t posted the &lt;a href=&quot;https://github.com/ZipCPU/cordic&quot;&gt;CORDIC&lt;/a&gt;
&lt;a href=&quot;/dsp/2017/10/02/cordic-tb.html&quot;&gt;test bench&lt;/a&gt; yet.&lt;/p&gt;

    &lt;p&gt;Sadly, the result is that this
&lt;a href=&quot;https://github.com/ZipCPU/cordic&quot;&gt;CORDIC&lt;/a&gt; &lt;a href=&quot;/dsp/2017/10/02/cordic-tb.html&quot;&gt;test bench
post&lt;/a&gt;
is going to delve deeper into
&lt;a href=&quot;https://en.wikipedia.org/wiki/Probability&quot;&gt;probability&lt;/a&gt; than
I would like to do on &lt;a href=&quot;http://zipcpu.com/&quot;&gt;this blog&lt;/a&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;We haven’t really discussed how to create tone generators yet, nor have
we discussed swept tone generators.&lt;/p&gt;

    &lt;p&gt;These really aren’t all that hard–especially once you have a working
&lt;a href=&quot;/dsp/2017/08/30/cordic.html&quot;&gt;CORDIC&lt;/a&gt;.
They depend upon sending an incrementing
&lt;a href=&quot;/dsp/2017/06/15/no-pi-for-you.html&quot;&gt;phase angle&lt;/a&gt;
into the &lt;a href=&quot;/dsp/2017/08/30/cordic.html&quot;&gt;CORDIC&lt;/a&gt; module,
but we can come back and discuss the topic more as we have opportunity.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;We also haven’t discussed how to implement a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Sample-rate_conversion&quot;&gt;downsampling filter&lt;/a&gt;.&lt;/p&gt;

    &lt;p&gt;This was a necessary part of the 100MHz to 44.1MHz &lt;a href=&quot;https://en.wikipedia.org/wiki/Sample-rate_conversion&quot;&gt;sample rate
converter&lt;/a&gt;
within the
&lt;a href=&quot;https://github.com/ZipCPU/wbpwmaudio/blob/master/pdmdemo.cpp&quot;&gt;C++ portion&lt;/a&gt;
of today’s
&lt;a href=&quot;https://github.com/ZipCPU/wbpwmaudio/tree/master/demo-rtl&quot;&gt;demonstration&lt;/a&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;We haven’t discussed how to generate a good
&lt;a href=&quot;https://en.wikipedia.org/wiki/Low-pass_filter&quot;&gt;lowpass filter&lt;/a&gt; for a very
small bandwidth signal.&lt;/p&gt;

    &lt;p&gt;The &lt;a href=&quot;https://en.wikipedia.org/wiki/Sample-rate_conversion&quot;&gt;resampler&lt;/a&gt; within
&lt;a href=&quot;https://github.com/ZipCPU/wbpwmaudio/blob/master/pdmdemo.cpp&quot;&gt;pdmdemo&lt;/a&gt;
doesn’t really have a “good”
&lt;a href=&quot;https://en.wikipedia.org/wiki/Low-pass_filter&quot;&gt;lowpass filter&lt;/a&gt;
within it since it is far from optimized.  A better
&lt;a href=&quot;https://en.wikipedia.org/wiki/Low-pass_filter&quot;&gt;lowpass filter&lt;/a&gt;
would have fewer taps and fewer operations.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;These are all topics that we’ll need to come back and address again later on
&lt;a href=&quot;http://zipcpu.com/&quot;&gt;this blog&lt;/a&gt; as time and opportunity are
available and provided the &lt;a href=&quot;https://www.blueletterbible.org/kjv/jas/4/15/s_1150015&quot;&gt;LORD is
willing&lt;/a&gt;.&lt;/p&gt;

&lt;hr /&gt;&lt;p&gt;&lt;em&gt;Salt is good: but if the salt have lost his savour, wherewith shall it be seasoned?&lt;/em&gt;</description>
        <pubDate>Sat, 16 Sep 2017 00:00:00 -0400</pubDate>
        <link>http://zipcpu.com/dsp/2017/09/16/pwm-demo.html</link>
        <guid isPermaLink="true">http://zipcpu.com/dsp/2017/09/16/pwm-demo.html</guid>
        
        
        <category>dsp</category>
        
      </item>
    
      <item>
        <title>Building a high speed Finite Impulse Response (FIR) Digital Filter</title>
        <description>&lt;p&gt;Some time ago, an individual posted on &lt;a href=&quot;https://forum.digilentinc.com&quot;&gt;Digilent’s
forum&lt;/a&gt; that he wasn’t able to get
&lt;a href=&quot;https://www.xilinx.com&quot;&gt;Xilinx&lt;/a&gt;’s
&lt;a href=&quot;https://en.wikipedia.org/wiki/Finite_impulse_response&quot;&gt;Finite Impulse Response (FIR)&lt;/a&gt;
filter
&lt;a href=&quot;https://www.xilinx.com/support/documentation/ip_documentation/fir_compiler/v7_1/pg149-fir-compiler.pdf&quot;&gt;compiler&lt;/a&gt;
generated code to work.  While I can understand that there are good reasons
for using a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Finite_impulse_response&quot;&gt;FIR&lt;/a&gt;
&lt;a href=&quot;https://www.xilinx.com/support/documentation/ip_documentation/fir_compiler/v7_1/pg149-fir-compiler.pdf&quot;&gt;compiler&lt;/a&gt;,
this individual was attempting to
&lt;a href=&quot;https://en.wikipedia.org/wiki/Low-pass_filter&quot;&gt;low-pass filter&lt;/a&gt;
a signal with less than a handful of taps.&lt;/p&gt;

&lt;p&gt;No wonder why he was getting frustrated when he didn’t see much difference
in the filtered signal.&lt;/p&gt;

&lt;p&gt;He’s not alone.  Indeed, I was answering forum posts from a similar individual
on another forum just this morning.  It seems like requests for help with
the vendor supplied &lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;digital
filtering&lt;/a&gt;
libraries are fairly common place, while many of those asking for help
don’t necessarily understand what goes on within a typical
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;digital filter&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;If you would like to apply a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;digital filter&lt;/a&gt;
to a signal, I am going to suggest that you should first learn what a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;digital filter&lt;/a&gt;
is.  I’m also going to suggest that you learn how the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency_response&quot;&gt;frequency response&lt;/a&gt;
of a &lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;
is defined, to the point where you can calculate the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency_response&quot;&gt;frequency response&lt;/a&gt;
yourself and so know what to expect from your any
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;digital filter&lt;/a&gt;
implementation.&lt;/p&gt;

&lt;p&gt;When you think you are ready to learn how to implement a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;digital filter&lt;/a&gt;,
then let me welcome you to continue reading.&lt;/p&gt;

&lt;p&gt;Today, let’s look at what’s required to implement an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Finite_impulse_response&quot;&gt;FIR&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;digital filter&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;uses-for-digital-filters&quot;&gt;Uses for Digital Filters&lt;/h2&gt;

&lt;p&gt;Years ago I asked a math professor why I should be interested in
&lt;a href=&quot;https://en.wikipedia.org/wiki/Linear_algebra&quot;&gt;Linear Algebra&lt;/a&gt;.
He was rather flabbergasted and floored by the question.
&lt;a href=&quot;https://en.wikipedia.org/wiki/Linear_algebra&quot;&gt;Linear Algebra&lt;/a&gt;,
he tried to explain, underpinned so much of mathematics that it was
hard to define just one use.&lt;/p&gt;

&lt;p&gt;The same is true of 
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;digital filtering&lt;/a&gt;–which
just so happens to be one of those many uses of &lt;a href=&quot;https://en.wikipedia.org/wiki/Linear_algebra&quot;&gt;Linear
Algebra&lt;/a&gt; that my instructor
didn’t reference.  &lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;Digital
filters&lt;/a&gt;
are used in so many &lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_signal_processing&quot;&gt;Digital Signal Processing
(DSP)&lt;/a&gt;
applications within digital logic, such as
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;’s,
that it’s hard to identify just one application to use when arguing
for their relevance.&lt;/p&gt;

&lt;p&gt;The following, though, are some common uses of the sorts of
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;digital filters&lt;/a&gt;
you can create within an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Emphasis_(telecommunications)&quot;&gt;Audio pre/post emphasis&lt;/a&gt;, often used in commercial audio transmission channels&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Radio-receiver&quot;&gt;Channel separation and selection&lt;/a&gt;,
such as your radio receiver might do.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Echo_suppression_and_cancellation&quot;&gt;Echo cancellation&lt;/a&gt;
in telephony&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Equalization_(audio)&quot;&gt;Audio equalization&lt;/a&gt;,
such as you might find on any higher quality stereo set&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Matched_filter&quot;&gt;Matched Filtering&lt;/a&gt;
to maximize SNR, often used within digital communications&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Pulse_shaping&quot;&gt;Pulse Shaping&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/intersymbol_interference&quot;&gt;Intersymbol Interference&lt;/a&gt;
mitigation in digital communications&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Anti-aliasing_filter&quot;&gt;Anti-aliasing filters&lt;/a&gt;,
so that you can process your signals at a slower rate without distortion&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;In &lt;a href=&quot;https://en.wikipedia.org/wiki/Hearing_aid&quot;&gt;hearing aids&lt;/a&gt;, to clean
up audio signals so that they may be understood again&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Indeed, as I’m putting this list together, I feel like I’ve only started
to touch the surface on the uses of 
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;digital filters&lt;/a&gt;.  Their
usage has become quite ubiquitous, even if they are not well understood by all
who design and use them.&lt;/p&gt;

&lt;p&gt;Today, let’s build some &lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/genericfir.v&quot;&gt;generic filter
logic&lt;/a&gt; that
can be used for any or all of the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;digital filtering&lt;/a&gt; tasks listed
above.  It may not be the best implementation, nor the most practical
implementation, for such tasks, but it will at least be a valid implementation.&lt;/p&gt;

&lt;p&gt;First, though, let’s briefly discuss what a 
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;digital filtering&lt;/a&gt; is.&lt;/p&gt;

&lt;h2 id=&quot;what-is-an-fir-filter&quot;&gt;What is an FIR Filter&lt;/h2&gt;

&lt;p&gt;If you start with the only requirement that you want to apply a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Linear_map&quot;&gt;linear mathematical operation&lt;/a&gt;
to an infinite set of equidistant input samples (i.e.
a sampled data stream), and then insist that this operation be
&lt;a href=&quot;https://en.wikipedia.org/wiki/Time-invariant_system&quot;&gt;shift invariant&lt;/a&gt;,
you will discover a &lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;linear
filter&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Such
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;’s
are completely characterized by their
&lt;a href=&quot;https://en.wikipedia.org/wiki/Impulse_response&quot;&gt;impulse response&lt;/a&gt;.
That is, if you feed the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;
a single non-zero value (i.e. an impulse), then the response the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;
produces is called its
&lt;a href=&quot;https://en.wikipedia.org/wiki/Impulse_response&quot;&gt;impulse response&lt;/a&gt;.
If the response is only finite in duration, then the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;
is said to be a &lt;a href=&quot;https://en.wikipedia.org/wiki/Finite_impulse_response&quot;&gt;Finite Impulse
Response (FIR)&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;.
If the response is not finite in duration, the filter is said to be an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Infinite_impulse_response&quot;&gt;Infinite Impulse Response
(IIR)&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;If you allow the function &lt;code class=&quot;highlighter-rouge&quot;&gt;h[k]&lt;/code&gt; to represent the response of this
filter, then the mathematical operation that describes how the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;
applies to an input sequence &lt;code class=&quot;highlighter-rouge&quot;&gt;x[n]&lt;/code&gt; is a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Convolution&quot;&gt;convolution&lt;/a&gt;, and defined by the
equation:&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/convolution.png&quot; alt=&quot;x o h = SUM_k h[k] x[n-k]&quot; width=&quot;540&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;If &lt;code class=&quot;highlighter-rouge&quot;&gt;h[k]&lt;/code&gt; is zero for all &lt;code class=&quot;highlighter-rouge&quot;&gt;k&amp;lt;0&lt;/code&gt;, as well as all &lt;code class=&quot;highlighter-rouge&quot;&gt;k&amp;gt;=N&lt;/code&gt;, then &lt;code class=&quot;highlighter-rouge&quot;&gt;h[k]&lt;/code&gt; can be
used to define a &lt;em&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Causal_filter&quot;&gt;causal&lt;/a&gt;&lt;/em&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Finite_impulse_response&quot;&gt;FIR&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;digital filter&lt;/a&gt;.
The importance of this distinction is that &lt;em&gt;only&lt;/em&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Causal_filter&quot;&gt;causal&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filters&lt;/a&gt;
can be implemented in hardware.  Hence if you wish to implement an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Finite_impulse_response&quot;&gt;FIR&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;, causality is
a good first assumption.  The operation of a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Causal_filter&quot;&gt;causal&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Finite_impulse_response&quot;&gt;FIR&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;
can be simplified and represented by:&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/fir-convolution.png&quot; alt=&quot;y[n] = SUM_k=0^N-1 h[k] x[n-k]&quot; width=&quot;380&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;where &lt;code class=&quot;highlighter-rouge&quot;&gt;x[n]&lt;/code&gt; is again the input sequence, &lt;code class=&quot;highlighter-rouge&quot;&gt;h[n]&lt;/code&gt; is the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Impulse_response&quot;&gt;impulse response&lt;/a&gt;
of this &lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;digital filter&lt;/a&gt;, and
&lt;code class=&quot;highlighter-rouge&quot;&gt;y[n]&lt;/code&gt; is the output of the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;That’s the operation of a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;digital filter&lt;/a&gt;.
Any and every
&lt;a href=&quot;https://en.wikipedia.org/wiki/Causal_filter&quot;&gt;causal&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Finite_impulse_response&quot;&gt;FIR&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt; will have this form,
and will need to carry out this operation.&lt;/p&gt;

&lt;p&gt;Let’s spend some time discussing how to build this type of
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;digital FIR filter&lt;/a&gt;
within an &lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;.
The full topic of how to generate and implement one of 
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;these filters&lt;/a&gt;
is way too big to fit in one post.  So, we’ll try to break it down into
several.  However, these several posts are likely to depend upon each other
to do.  For example, we already discussed how to generate two of the simplest
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filters&lt;/a&gt;.
Today we’ll discuss how to build a very generic
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;tap-coefficient-selection&quot;&gt;Tap Coefficient Selection&lt;/h2&gt;

&lt;p&gt;Often, the first task in generating an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Finite_impulse_response&quot;&gt;FIR filter&lt;/a&gt;
is to determine the &lt;code class=&quot;highlighter-rouge&quot;&gt;h[n]&lt;/code&gt;
values referenced above.  These are known as the &lt;em&gt;coefficients&lt;/em&gt; of the filter.
They completely define and characterize any 
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;digital filter&lt;/a&gt;.
If you’ve never had to select
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt; coefficients
before, then know that there is a real science behind the process.
The most generic filter design algorithm that I like to recommend is the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Parks-McClellan_filter_design_algorithm&quot;&gt;Parks-McClellan filter design
method&lt;/a&gt;.
It tends to produce &lt;em&gt;optimal&lt;/em&gt; filters, in that the coefficients produced
minimize the maximum error between the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;’s
&lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency_response&quot;&gt;frequency response&lt;/a&gt;
and the design criteria.&lt;/p&gt;

&lt;p&gt;The &lt;a href=&quot;https://en.wikipedia.org/wiki/Parks-McClellan_filter_design_algorithm&quot;&gt;Parks-McClellan filter design
method&lt;/a&gt;
isn’t anything new.  It’s been around long enough that many implementations
of it exist.  For example, here’s an 
&lt;a href=&quot;http://t-filter.engineeringjs.com&quot;&gt;online version&lt;/a&gt;
that you can use to design your filter coefficients.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Parks-McClellan_filter_design_algorithm&quot;&gt;The Parks-McClellan filter design algorithm&lt;/a&gt;,
however, creates coefficients with no practical
&lt;a href=&quot;https://en.wikipedia.org/wiki/Quantization_(signal_processing)&quot;&gt;quantization&lt;/a&gt;
limit to their precision.  What I mean by that is that most
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
implementations don’t need the double-precision floating point values that the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Parks-McClellan_filter_design_algorithm&quot;&gt;Parks-McClellan filter design algorithm&lt;/a&gt;
can create, not that double-precision floating point numbers have unlimited
precision.  &lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
based &lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;s,
on the other hand, need to represent their filter coefficients within a
finite number of bits—usually much less than a double-precision floating
point number.  This is for cost and performance reasons.  As a result,
a conversion needs to take place from abundant precision to a finite bit
precision.&lt;/p&gt;

&lt;p&gt;As with generating the coefficients, generating or converting them to a
smaller number of bits is also quite the science.  Many papers have been
written on the topic of how to carefully select the proper quantized
coefficients for a &lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;digital
filter&lt;/a&gt;
[&lt;a href=&quot;http://ieeexplore.ieee.org/document/365314&quot;&gt;Ref&lt;/a&gt;].  However,
for our purposes today, these papers are beyond the limits of what we can
discuss here in a simple blog post.  Therefore, I am going to share an ad-hoc
technique instead for today’s discussion.  I offer no promises of optimality,
rather only the suggestion that this approach should work for many purposes.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;The first step is to know your sample rate, and the passband, &lt;code class=&quot;highlighter-rouge&quot;&gt;f_p&lt;/code&gt; and
stopband, &lt;code class=&quot;highlighter-rouge&quot;&gt;f_s&lt;/code&gt;, frequencies your application can handle.  Most problems
also define how small the response is supposed to be during the stop-band
(&lt;code class=&quot;highlighter-rouge&quot;&gt;f&amp;gt;f_s&lt;/code&gt;), as well as how tightly the passband (&lt;code class=&quot;highlighter-rouge&quot;&gt;f&amp;lt;f_p&lt;/code&gt;) filter response
must hold to unity.&lt;/p&gt;

    &lt;p&gt;Figure 1 shows a chart illustrating these regions as defined for a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Low-pass_filter&quot;&gt;lowpass filter&lt;/a&gt;.&lt;/p&gt;

    &lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 1: Lowpass filter design criteria&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/fir-lpf-design.png&quot; alt=&quot;Lowpass filter design criteria chart, showing relationship between fp and fs&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

    &lt;p&gt;Indeed, this is a good chart for understanding filter design in general.
Your goal as a designer will be to create a filter whose
&lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency_response&quot;&gt;frequency response&lt;/a&gt;
(the blue line) fits within your criteria (the white region).  Your
application will typically define this white region, although the tighter
this region is the more your filter is likely to &lt;em&gt;cost&lt;/em&gt; in terms of
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
resources.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Once you know your design criteria, the next step is to determine the number
of taps, &lt;code class=&quot;highlighter-rouge&quot;&gt;N&lt;/code&gt;, that your
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;
will require, as well as an identified number of bits, &lt;code class=&quot;highlighter-rouge&quot;&gt;M&lt;/code&gt;, to use to
represent the coefficients of these taps.  Too many taps or too many bits
and your
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;
will not fit on your
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;.
Too few, and your
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;
will not match your design criteria above.  As a result,
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;
design is often a give and take between requirements and
cost–much like any other engineering task.&lt;/p&gt;

    &lt;p&gt;You may find that the inverse of the normalized transition bandwidth,
i.e. &lt;code class=&quot;highlighter-rouge&quot;&gt;1/(f_s-f_p)&lt;/code&gt;,
is often linearly related to how many coefficients you will need.  Two
to four times this number, when using normalized frequency units,
(i.e. &lt;code class=&quot;highlighter-rouge&quot;&gt;0&amp;lt;f&amp;lt;1/2&lt;/code&gt;) is often
a good starting place for how many taps your
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;
will require.  As a result of this relationship, any time you
drop the transition width by a factor of two, you can expect to need twice
as many coefficients for the same cutoff transition bandwidth.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Design a set of filter
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;
coefficients using the &lt;a href=&quot;https://en.wikipedia.org/wiki/Parks-McClellan_filter_design_algorithm&quot;&gt;Parks-McClellan filter design
algorithm&lt;/a&gt;
or similar.  &lt;a href=&quot;http://t-filter.engineerjs.com&quot;&gt;Canned filter design
methods&lt;/a&gt; are usually not hard to find
that will generate the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;
coefficients you need.&lt;/p&gt;

    &lt;p&gt;Once designed, then examine the pass band, stop band, and transition band
performance to to see how well the resulting
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;
approximates your design criteria.  Adjust as appropriate.  More
taps for the same criteria can be used to deepen the stopband and tighten
up the pass band.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;These first steps are common to any
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;Digital&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Finite_impulse_response&quot;&gt;FIR filter&lt;/a&gt;
design problem.  The next steps, though, are required in order to try to
reduce your bit-width from double-precision floating point to something that
can be implemented on an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Multiply each tap by &lt;code class=&quot;highlighter-rouge&quot;&gt;(2^(M-1) -1) / max h[n]&lt;/code&gt; so that the maximum
tap coefficient becomes the maximum positive &lt;a href=&quot;https://en.wikipedia.org/wiki/Two&#39;s_complement&quot;&gt;two’s
complement&lt;/a&gt; number
that can be represented in your bit-width.&lt;/p&gt;

    &lt;p&gt;Since most
&lt;a href=&quot;https://en.wikipedia.org/wiki/Finite_impulse_response&quot;&gt;FIR&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filters&lt;/a&gt;
tend to follow the shape of a &lt;a href=&quot;https://en.wikipedia.org/wiki/Sinc_function&quot;&gt;sinc
function&lt;/a&gt;, the biggest
coefficient will be in the center of the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;.
That largest value becomes, by this multiplication algorithm, &lt;code class=&quot;highlighter-rouge&quot;&gt;2^(M-1)-1&lt;/code&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Round the rest of the coefficients to the nearest integer.&lt;/p&gt;

    &lt;p&gt;If we’ve done this right, no coefficients will be greater than &lt;code class=&quot;highlighter-rouge&quot;&gt;2^(M-1)-1&lt;/code&gt;
in magnitude.&lt;/p&gt;

    &lt;p&gt;This will also adjust the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;’s
&lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency_response&quot;&gt;frequency response&lt;/a&gt;.
You may wish to go back and measure your
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;’s
&lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency_response&quot;&gt;frequency response&lt;/a&gt;
at this point to ensure that it’s still within any bounds you application
requires.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;If this approach seems ad-hoc, that’s because it is.  There are more
scientific methods to do this.
[&lt;a href=&quot;http://ieeexplore.ieee.org/document/365314&quot;&gt;Ref&lt;/a&gt;]&lt;/p&gt;

&lt;p&gt;These steps should be sufficient to generate the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;
coefficients you will need.&lt;/p&gt;

&lt;h2 id=&quot;bit-growth&quot;&gt;Bit Growth&lt;/h2&gt;

&lt;p&gt;Once you have the coefficients, the next step is to allocate any bits you need
throughout the design.  We discussed
&lt;a href=&quot;/dsp/2017/07/21/bit-growth.html&quot;&gt;bit growth&lt;/a&gt;
some time ago,  so we can use those principles for this step.
For the purpose of this discussion, we’ll let &lt;code class=&quot;highlighter-rouge&quot;&gt;IW&lt;/code&gt; be the number of bits
in the input samples, &lt;code class=&quot;highlighter-rouge&quot;&gt;TW&lt;/code&gt; be the number of bits in the individual coefficients
(we called this &lt;code class=&quot;highlighter-rouge&quot;&gt;M&lt;/code&gt; above), and &lt;code class=&quot;highlighter-rouge&quot;&gt;OW&lt;/code&gt; be the output width and the width
of the accumulator.  These will then be the names we’ll use to define these
values in Verilog parameters later when we actually implement our
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;From our 
&lt;a href=&quot;/dsp/2017/07/21/bit-growth.html&quot;&gt;discussion of bit growth&lt;/a&gt;,
you know that the multiplication step of the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;,
the step that calculates &lt;code class=&quot;highlighter-rouge&quot;&gt;h[k]x[n-k]&lt;/code&gt;, will need to be allocated more bits
to represent the desired outcome than either input.  The number of bits
will be the number of bits in the input, &lt;code class=&quot;highlighter-rouge&quot;&gt;IW&lt;/code&gt;, plus the number of bits in the
coefficients, &lt;code class=&quot;highlighter-rouge&quot;&gt;TW&lt;/code&gt;.  Hence, following the multiply you will need &lt;code class=&quot;highlighter-rouge&quot;&gt;TW+IW&lt;/code&gt; bits
to hold the output product from one multiply.&lt;/p&gt;

&lt;p&gt;Also from the
&lt;a href=&quot;/dsp/2017/07/21/bit-growth.html&quot;&gt;same discussion&lt;/a&gt;,
you know that the number of bits required to add &lt;code class=&quot;highlighter-rouge&quot;&gt;N&lt;/code&gt; values of &lt;code class=&quot;highlighter-rouge&quot;&gt;TW+IW&lt;/code&gt; bits
together is going to go with the log of &lt;code class=&quot;highlighter-rouge&quot;&gt;N&lt;/code&gt;.  This means that you will
nominally need &lt;code class=&quot;highlighter-rouge&quot;&gt;TW+IW+log_2(N)&lt;/code&gt; bits to hold your result.&lt;/p&gt;

&lt;p&gt;This number, though, is often still too many.  You can often get by with less
than &lt;code class=&quot;highlighter-rouge&quot;&gt;log_2(N)&lt;/code&gt; bits for the accumulation section simply because most of the
taps will be much less than their maximum value, many of them being a factor
of two (or more) less than that maximum
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;
coefficient.&lt;/p&gt;

&lt;p&gt;One way to figure out how many additional accumulator bits you will need for
adding the multiplication
results together is to try running a sample signal through the design.  The
most stressing case is to let every input have the maximum value,
&lt;code class=&quot;highlighter-rouge&quot;&gt;2^(IW-1)-1&lt;/code&gt;, and the sign of the corresponding &lt;code class=&quot;highlighter-rouge&quot;&gt;h[k]&lt;/code&gt; tap that it will be
multiplied by.  You can then adjust the accumulation width as necessary
to be certain to avoid overflow.&lt;/p&gt;

&lt;p&gt;With this as background, we are now ready to consider building our design.
We’ll pause first, though, before we get into the Verilog code to discuss
our design goals.&lt;/p&gt;

&lt;h2 id=&quot;rtl-design-goals&quot;&gt;RTL Design Goals&lt;/h2&gt;

&lt;p&gt;For the purpose of the design presented below, we are going to build the most
general purpose high speed
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;
that we can.  By “high speed” I mean running at the speed of your system
clock—whatever that may be.  By “general purpose” I mean three things:
First, the number of taps and their values will be arbitrary.  They will be
fixed at implementation time, but easily adjusted post implementation.  Second,
I intend to make this
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;
a reconfigurable filter, so that the values of the various coefficients can
be reloaded post-synthesis as the application may require.  Third, I intend
to create and present
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/genericfir.v&quot;&gt;a design&lt;/a&gt;
that can easily (within limits) be adjusted to accommodate more taps, or to
adjust tap, data, or output widths, to the design with little change.&lt;/p&gt;

&lt;p&gt;Put together, these goals are:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Easily reconfigured&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Adjustable length and variable widths (at design time)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Adjustable coefficients (at runtime)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Runs at the system clock rate, one input sample per system clock&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The sad consequence of these choices is that this is also likely to be
one of the more expensive
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;digital filters&lt;/a&gt;
you will ever build.  However,
we shall build it anyway and later discuss methods which may be used to
reduce this cost.  Indeed, such discussions may form the basis of many
posts to come.&lt;/p&gt;

&lt;h2 id=&quot;chosen-structure&quot;&gt;Chosen Structure&lt;/h2&gt;

&lt;p&gt;If you look into a text book that describes how an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Finite_impulse_response&quot;&gt;FIR filter&lt;/a&gt;
should be implemented, you are likely to find a picture looking like Fig 2:&lt;/p&gt;

&lt;table style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 2: Filter Implementation&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/fir-form.svg&quot; alt=&quot;Generic FIR implementation structure&quot; width=&quot;380&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;From this figure, you can see conceptually how each incoming data element
goes into a “tapped delay-line” structure (the bar across the top).  On ever
clock a new sample comes in, and all the samples within this structure shift
to the right.  Also, during that clock, every sample in the delay-line is
multiplied by the respective
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;
coefficient, &lt;code class=&quot;highlighter-rouge&quot;&gt;h[k]&lt;/code&gt;, and the results
are summed together.  The result of this summation is the output of the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;,
&lt;code class=&quot;highlighter-rouge&quot;&gt;y[n]&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The number of “taps”, &lt;code class=&quot;highlighter-rouge&quot;&gt;N&lt;/code&gt;, in this figure is easily identified by the number of
stages in the tapped delay line.&lt;/p&gt;

&lt;p&gt;What Figure 2 doesn’t show is the second operand, &lt;code class=&quot;highlighter-rouge&quot;&gt;h[k]&lt;/code&gt;, to each of the
multiplies (they wouldn’t fit in the image).  These are given by the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;’s
&lt;a href=&quot;https://en.wikipedia.org/wiki/Impulse_response&quot;&gt;impulse response&lt;/a&gt;.
values–the coefficients that we discussed above.&lt;/p&gt;

&lt;p&gt;Were you to try to implement the
filter shown in the diagram, you would
quickly discover that the accumulator can easily cost many system clock ticks
to implement (depending upon the speed of your system clock).  Your design may
well fail timing as a result.  This would be unsatisfactory.&lt;/p&gt;

&lt;table style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 3: A Single FIR Tap&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/fir-tap-single.svg&quot; alt=&quot;A Single FIR tap&quot; width=&quot;240&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Therefore, we shall consider a different approach.  Let’s instead separate
the circuitry of one tap from the circuitry of the next, as shown in Fig 3.&lt;/p&gt;

&lt;p&gt;The neat thing about this approach is that we can keep the various stages
of this
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;
within a localized area on the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;.
While that makes
timing easier, it still hasn’t fundamentally solved the problem of adding
many values together within a single clock.  Indeed, the only way to
get our clock frequency back up to speed will be to add a clock tick (or more)
within this string of taps.  The simplest place to do that is between pairs
of taps in the accumulator.  This leaves us with tap logic shown in Fig 4.&lt;/p&gt;

&lt;table style=&quot;float: left&quot;&gt;&lt;caption&gt;Fig 4: Adding an extra delay per tap&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/fir-tap-w-delay.svg&quot; alt=&quot;Figure: Tap structure with an extra delay per tap&quot; width=&quot;240&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;This &lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/firtap.v&quot;&gt;tap structure&lt;/a&gt;
is actually quite unusual.  With this approach, the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;
delay line now requires not &lt;code class=&quot;highlighter-rouge&quot;&gt;N&lt;/code&gt; stages but &lt;code class=&quot;highlighter-rouge&quot;&gt;2N&lt;/code&gt;, with the multiplies only
being applied every other stage.  Further, it’s not clear from this structure
that all of the additions are being applied to the right values in the
accumulation chain.&lt;/p&gt;

&lt;p&gt;For now, I’ll present as a hand-waving evidence that this works the fact
that both tap output and accumulator output have been delayed together.
When we present the test bench for this design, you’ll see that this is
indeed the case.
Later, when we convert this filtering structure into something that can
handle a &lt;a href=&quot;https://en.wikipedia.org/wiki/Linear_phase&quot;&gt;symmetric filter&lt;/a&gt;,
we’ll have to examine how we came up with this approach and explain it in
more detail.&lt;/p&gt;

&lt;p&gt;For now, notice that by using this
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/firtap.v&quot;&gt;tap structure&lt;/a&gt;,
we can &lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/genericfir.v&quot;&gt;string several of these taps
together&lt;/a&gt;.
An overall view of this &lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/genericfir.v&quot;&gt;strung out
design&lt;/a&gt;
is shown in Fig 5 below.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 5: A filter is a sequence of taps&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/fir-generic.svg&quot; alt=&quot;Figure: Creating a generic FIR from a series of tap structures&quot; width=&quot;480&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Indeed, using this approach, we can string any arbitrary number of taps
together–subject only to the timing and logic capacity of your
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The amount of resources this
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;
will use is likely to become a thorn in our side in a moment, but we’ll
ignore that today–for the sake of building the most &lt;em&gt;generic&lt;/em&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Finite_impulse_response&quot;&gt;FIR filter&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Before leaving this section, I must acknowledge all of those experts that might
also read this blog.  Having gotten this far, I am certain that many of
these experts are &lt;em&gt;cringing&lt;/em&gt; at the design choices we have just made.
If you get a chance to chat with them, they will wisely declare that
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filtering&lt;/a&gt;
at the full speed of the system clock is resource intensive–it shouldn’t be
done &lt;em&gt;if&lt;/em&gt; it can be avoided.  They will also loudly proclaim that a
shift-register accumulator structure is a waste of resources–an accumulator
tree might make more sense.  Finally, they’ll point out that variable filter
coefficients can cost of lot of logic.  In deference to these experts, I will
first acknowledge the wisdom of their words and then beg their pardon.
Today, though, I am trying to keep the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;
implementation simple and completely generic.&lt;/p&gt;

&lt;p&gt;We can come back to [this
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/genericfir.v&quot;&gt;filter&lt;/a&gt;
later to improve upon it.  All of these improvements just mentioned, and
perhaps others as well, are fair game for that later discussion.&lt;/p&gt;

&lt;p&gt;In the meantime, let’s examine how to build these two components: the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Finite_impulse_response&quot;&gt;FIR&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/firtap.v&quot;&gt;tap structure&lt;/a&gt;
itself, as well as the &lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/genericfir.v&quot;&gt;tapped delay line
structure&lt;/a&gt;
holding these taps together.&lt;/p&gt;

&lt;h2 id=&quot;a-simple-fir-tap&quot;&gt;A simple FIR tap&lt;/h2&gt;

&lt;p&gt;The first component of our
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;
that we shall discuss is the
structure](https://github.com/ZipCPU/dspfilters/blob/master/rtl/genericfir.v)
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/firtap.v&quot;&gt;tap structure&lt;/a&gt;.
Remember that our goal is to &lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/genericfir.v&quot;&gt;string
together&lt;/a&gt;
many &lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/firtap.v&quot;&gt;taps with the same code and
structure&lt;/a&gt;
to them.  Further, you may also remember that the logic necessary for this
tap (Fig 4 above) is primarily multiplying by a filter coefficient, &lt;code class=&quot;highlighter-rouge&quot;&gt;h[k]&lt;/code&gt;,
and accumulating the result.  So, that’s what we’ll do here.&lt;/p&gt;

&lt;p&gt;We’ll start with the multiply.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	if (i_reset)
		product &amp;lt;= 0;
	else if (i_ce)
		product &amp;lt;= o_tap * i_sample;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Don’t forget to declare both &lt;code class=&quot;highlighter-rouge&quot;&gt;o_tap&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;i_sample&lt;/code&gt; as signed
values, as the results of a signed digital multiply are different from those
of an unsigned multiply.&lt;/p&gt;

&lt;p&gt;On the next clock (multiplies can be slow), we’ll add the result of the
multiply to a partial accumulator value that has been passed to us in
&lt;code class=&quot;highlighter-rouge&quot;&gt;i_partial_acc&lt;/code&gt;.  This will create our tap’s output, &lt;code class=&quot;highlighter-rouge&quot;&gt;o_acc&lt;/code&gt;.  After the last
tap, this will be the final output of the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	if (i_reset)
		o_acc &amp;lt;= 0;
	else if (i_ce)
		o_acc &amp;lt;= i_partial_acc
			+ { {(OW-(TW+IW)){product[(TW+IW-1)]}},
					product };&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;You may notice in this example that both of these always blocks used a
synchronous reset input.  This allows all of the logic to clear, together
with any memory within the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;,
on any reset.  If you don’t need the reset structure, just set the value
to a constant &lt;code class=&quot;highlighter-rouge&quot;&gt;1&#39;b0&lt;/code&gt; and the synthesizer should remove it.  The other thing
to notice is that we are using a &lt;a href=&quot;/blog/2017/08/14/strategies-for-pipelining.html&quot;&gt;global CE based pipelining
strategy&lt;/a&gt;.
Under that strategy, nothing is allowed to change unless the CE is true.  This
is why all of the subsequent logic is gated by &lt;code class=&quot;highlighter-rouge&quot;&gt;i_ce&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;It is worth mentioning that some
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;’s
architectures can combine the high speed multiply with the accumulation
step into one operation.  Feel free to design for your hardware as you see
fit.&lt;/p&gt;

&lt;p&gt;The next required step, though, is to forward the input sample data through
a series of registers.  At a first glance, this might look simply like,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
if (i_reset)
	o_sample &amp;lt;= 0;
else if (i_ce)
	o_sample &amp;lt;= i_sample;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This simple sample in to sample out structure would implement the tap
structure shown in Fig 3 above.
However, were we to keep this logic as is, the outputs from the individual
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/firtap.v&quot;&gt;filter taps&lt;/a&gt;.
wouldn’t line up with the accumulator’s output chain.  Both would
move through the process at the same speed, and so you’d end up accumulating
&lt;code class=&quot;highlighter-rouge&quot;&gt;H(0)x[n]&lt;/code&gt; instead of the desired
&lt;a href=&quot;https://en.wikipedia.org/wiki/Convolution&quot;&gt;convolution&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;So, instead, we’ll add an extra delay, &lt;code class=&quot;highlighter-rouge&quot;&gt;delayed_sample&lt;/code&gt;, between the
samples–as we discussed with Fig 4 above.
This will allow the partial accumulator structure to remain aligned with the
data as they both work their way through the
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/firtap.v&quot;&gt;tap structures&lt;/a&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
if (i_reset)
	begin
		delayed_sample &amp;lt;= 0;
		o_sample &amp;lt;= 0;
	end else if (i_ce)
	begin
		delayed_sample &amp;lt;= i_sample;
		o_sample &amp;lt;= delayed_sample;
	end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;That leaves one piece of logic remaining in our
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/firtap.v&quot;&gt;generic tap&lt;/a&gt;:
how to set the coefficients in the first place.  We’ll choose to do this in
one of two ways, dependent upon the logic parameter &lt;code class=&quot;highlighter-rouge&quot;&gt;FIXED_TAPS&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;If &lt;code class=&quot;highlighter-rouge&quot;&gt;FIXED_TAPS&lt;/code&gt; is true (not zero), then &lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/genericfir.v&quot;&gt;parent
module&lt;/a&gt;
will feed us our tap
values and we don’t need to do anything with them but use them.  While my
preference would be to set each tap via a &lt;code class=&quot;highlighter-rouge&quot;&gt;parameter&lt;/code&gt;, this causes a problem
in the &lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/genericfir.v&quot;&gt;parent
module&lt;/a&gt;
which would like to set all of the tap values at the
same time via a &lt;code class=&quot;highlighter-rouge&quot;&gt;$readmemh&lt;/code&gt;.  Instead, we allow our taps coefficients, the
&lt;code class=&quot;highlighter-rouge&quot;&gt;h[k]&lt;/code&gt; values we discussed above, to be set from wires passed to this
module.  This allows the
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/genericfir.v&quot;&gt;parent module&lt;/a&gt;
(to be discussed next) to set all of the filter coefficients
via a single &lt;code class=&quot;highlighter-rouge&quot;&gt;$readmemh&lt;/code&gt; command within an initial statement.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;generate
if (FIXED_TAPS)
	assign	o_tap = i_tap;
else ...&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This works well for fixed coefficients, but we still need the logic for
our variable coefficient capability.&lt;/p&gt;

&lt;p&gt;For variable coefficients, we’ll set &lt;code class=&quot;highlighter-rouge&quot;&gt;FIXED_TAPS&lt;/code&gt; to false (i.e. &lt;code class=&quot;highlighter-rouge&quot;&gt;1&#39;b0&lt;/code&gt;).
We’ll also create logic to set our taps dynamically.
Further, each tap will start with an &lt;code class=&quot;highlighter-rouge&quot;&gt;INITIAL_VALUE&lt;/code&gt; (typically zero).  Then,
during any design run, on any clock where the user is setting taps we’ll just
shift each tap down the line.  We’ll use the input &lt;code class=&quot;highlighter-rouge&quot;&gt;i_tap_wr&lt;/code&gt; to indicate that
we need to shift the tap value down the line.&lt;/p&gt;

&lt;p&gt;This leads us to the following code to set the taps within our design.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;...
else begin
	reg	[(TW-1):0]	tap;

	initial	tap = INITIAL_VALUE;
	always @(posedge i_clk)
		if (i_tap_wr)
			tap &amp;lt;= i_tap;
	assign o_tap = tap;
end endgenerate&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Notice that here’s no reset in this structure.  That allows us to reset
the sample values separate from the coefficients.  This also allows us to
set the coefficients while holding the rest of the filter in reset.&lt;/p&gt;

&lt;p&gt;I should warn you: this code can be expensive in terms of logic resources.
Should we count logic resources, you may notice that this requires no LUTs.
The &lt;code class=&quot;highlighter-rouge&quot;&gt;i_tap_wr&lt;/code&gt; line can be connected directly to the CE input of the for
tap, and no further logic is required.  However, this structure &lt;em&gt;will&lt;/em&gt; require
one flip flop per bit per tap in your design.  Hence a 256-tap
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;
with 16-bit values will cost you 4096 flip-flops.&lt;/p&gt;

&lt;p&gt;The other problem with this dynamic tap coefficient approach is that your
synthesis tool cannot optimize any of the multiplies.  Logic that multiplying
input samples by zero cannot be optimized.  Small number multiplies cannot be
trimmed.  Neither is it possible to reduce the logic when multiplying by a
power of two.  Hence, there is a cost for such a dynamic implementation.&lt;/p&gt;

&lt;p&gt;As a homework project, try this:  Look at how much logic gets used on a per
tap, per bit basis.  Then turn on &lt;code class=&quot;highlighter-rouge&quot;&gt;FIXED_TAPS&lt;/code&gt;, apply the same coefficients,
and see what changes.&lt;/p&gt;

&lt;h2 id=&quot;stringing-the-taps-together-into-a-filter&quot;&gt;Stringing the taps together into a filter&lt;/h2&gt;

&lt;p&gt;Now that we’ve defined our
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/firtap.v&quot;&gt;tap structures&lt;/a&gt;,
all that remains is to &lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/genericfir.v&quot;&gt;string them
together&lt;/a&gt;
as in Fig 5 above.  This will entail connecting the data inputs
from one tap to the next in a streaming fashion, as well as connecting the
tap values–should the user wish to change them.  Finally, we’ll need to
pull our final accumulator value together to return to the rest of the design.&lt;/p&gt;

&lt;p&gt;The first step, though, is going to be setting the tap coefficients for
the case where they are fixed.  We’d like to do this via a &lt;code class=&quot;highlighter-rouge&quot;&gt;$readmemh&lt;/code&gt;
command–since it’s the simplest to do.  So, if we have &lt;code class=&quot;highlighter-rouge&quot;&gt;FIXED_TAPS&lt;/code&gt;, we’ll
use a &lt;code class=&quot;highlighter-rouge&quot;&gt;$readmemh&lt;/code&gt; to set the &lt;code class=&quot;highlighter-rouge&quot;&gt;h[k]&lt;/code&gt; inputs to the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/firtap.v&quot;&gt;tap structures&lt;/a&gt;.
On the other hand, if &lt;code class=&quot;highlighter-rouge&quot;&gt;FIXED_TAPS&lt;/code&gt; is not true, we’ll only set the first tap
and then let the
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/firtap.v&quot;&gt;tap-modules&lt;/a&gt;
push the taps down the line.&lt;/p&gt;

&lt;p&gt;We’re also going to use a &lt;code class=&quot;highlighter-rouge&quot;&gt;generate&lt;/code&gt; statement, since this will allow us to
use a &lt;code class=&quot;highlighter-rouge&quot;&gt;for&lt;/code&gt; loop in a moment.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;genvar	k;
generate
if(FIXED_TAPS)
begin
	initial $readmemh(&quot;taps.hex&quot;, tap);

	assign	tap_wr = 1&#39;b0;
end else begin
	assign	tap_wr = i_tap_wr;
	assign	tap[0] = i_tap;
end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;At this point I feel like I’m teaching a drawing class.  I’ve outlined two
items, and then I’m about to tell the class to just fill in the details.
That’s about what happens next.&lt;/p&gt;

&lt;p&gt;This next step is to create a for loop where we instantiate each of the
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/firtap.v&quot;&gt;taps&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;This loop first sets the parameters of
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/firtap.v&quot;&gt;each tap structure&lt;/a&gt;
to match our overall
parameters: the input data width, &lt;code class=&quot;highlighter-rouge&quot;&gt;IW&lt;/code&gt;, the output width, &lt;code class=&quot;highlighter-rouge&quot;&gt;OW&lt;/code&gt;, the width of
the taps, &lt;code class=&quot;highlighter-rouge&quot;&gt;TW&lt;/code&gt;, etc.  Then we apply the rest of the logic.  Each
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/firtap.v&quot;&gt;tap-module&lt;/a&gt; is
given an input &lt;code class=&quot;highlighter-rouge&quot;&gt;h[k]&lt;/code&gt; coefficient and then connected to an &lt;code class=&quot;highlighter-rouge&quot;&gt;h[k+1]&lt;/code&gt; value to
be sent to the next tap.
Each &lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/firtap.v&quot;&gt;tap-module&lt;/a&gt;
is also passed a sample, and it produces the next sample
to be passed down the sample line.  Finally, we pass the partial accumulator
from one
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/firtap.v&quot;&gt;tap-module&lt;/a&gt;
to the next.&lt;/p&gt;

&lt;p&gt;You can see all three of these steps below.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;for(k=0; k&amp;lt;NTAPS; k=k+1)&amp;gt;
begin: FILTER

	firtap #(.FIXED_TAPS(FIXED_TAPS),
			.IW(IW), .OW(OW), .TW(TW),
			.INITIAL_VALUE(0))
		tapk(i_clk, i_reset,
			// Tap update circuitry
			tap_wr, tap[NTAPS-1-k], tapout[k],
			// Sample delay line
			i_ce, sample[k], sample[k+1],
			// The output accumulation line
			result[k], result[k+1]);

	if (!FIXED_TAPS)
		assign	tap[NTAPS-1-k] = tapout[k+1];
end endgenerate&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;When all is said and done, all that remains is to produce our
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;
output value and we are done.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	assign	o_result = result[NTAPS];&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;That’s all that it takes to build a
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/genericfir.v&quot;&gt;generic&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Finite_impulse_response&quot;&gt;FIR filter&lt;/a&gt;.
You don’t need a core generator to do this.  You don’t need a GUI.  You just
need to understand what an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Finite_impulse_response&quot;&gt;FIR filter&lt;/a&gt;
is, how it operates, and then just a touch of Verilog code.  In this case,
you can find the code for the &lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/firtap.v&quot;&gt;tap module
here&lt;/a&gt;, and the
code for the &lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/genericfir.v&quot;&gt;overall generic filter module
here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;We’ll save the test bench for another post, as this one is long enough
already.&lt;/p&gt;

&lt;h2 id=&quot;how-did-we-do&quot;&gt;How did we do?&lt;/h2&gt;

&lt;p&gt;While this is a &lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/genericfir.v&quot;&gt;basic
generic&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;digital filter&lt;/a&gt;,
and while the approach behind it will work for the general filtering case,
it isn’t a very powerful
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;.
The reason is not that this Verilog code
cannot describe an arbitrarily long
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;,
nor is it because this code cannot describe the taps with enough fidelity to
create a truly powerful
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;digital filter&lt;/a&gt;.
Instead, what I mean to say is that this approach to
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;
implementation tends to be too resource expensive for powerful
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filters&lt;/a&gt;: it is likely to cost
too many LUT’s, too many multiplies, and in general too much of your precious
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;’s
resources.  This may force you to buy a more expensive
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;,
or keep you from having as much free space to do other things on your current
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;.
As a result, we’ll need to do better.&lt;/p&gt;

&lt;p&gt;Indeed, we can often build better
&lt;a href=&quot;https://en.wikipedia.org/wiki/Finite_impulse_response&quot;&gt;FIR filters&lt;/a&gt;
than this.&lt;/p&gt;

&lt;p&gt;Here are some basic improvements that we can make to &lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/genericfir.v&quot;&gt;this filter
design&lt;/a&gt;:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;We could use an addition tree.&lt;/p&gt;

    &lt;p&gt;An addition tree would start by adding adjacent values together, then add
the results of those adjacent sums and so on rather than adding values
together in a long line.  This will allow us to use the log base two of
the number of additions.&lt;/p&gt;

    &lt;p&gt;Doing this would remove all the extra data stages, as well as trimming
the number of accumulator stages.  It would also increase the wire length
necessary to send the addition results from one place to the next–but this
may be negligible for low enough clock speeds.  The problem is that such
addition trees aren’t easily reconfigured for different filter lengths–not
that they aren’t valuable, useful, or less expensive.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;We could exploit the structure of the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt; coefficients.&lt;/p&gt;

    &lt;p&gt;Most filter design methods, to include the &lt;a href=&quot;https://en.wikipedia.org/wiki/Parks-McClellan_filter_design_algorithm&quot;&gt;Parks-McClellan filter design
algorithm&lt;/a&gt;,
produce &lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filters&lt;/a&gt;
with &lt;a href=&quot;https://en.wikipedia.org/wiki/Linear_phase&quot;&gt;linear phase&lt;/a&gt;.
Such &lt;a href=&quot;https://en.wikipedia.org/wiki/Linear_phase&quot;&gt;linear phase&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filters&lt;/a&gt;
have coefficients that are symmetric about some mid-point.  As a result,
these can be implemented using only half as many multiplies.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;We could also choose a filter, or combination of filters, that is easier to
implement.&lt;/p&gt;

    &lt;p&gt;For example, a block average is easier to implement than a
&lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/genericfir.v&quot;&gt;generic&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Finite_impulse_response&quot;&gt;FIR filter&lt;/a&gt;.
Much easier in fact.  A series of block averages, one after another,
&lt;em&gt;might&lt;/em&gt; be able to implement a filter of the type you might need or want.
It might also fit nicely as a component of a larger
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;We could fix the filter coefficients&lt;/p&gt;

    &lt;p&gt;For the &lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/genericfir.v&quot;&gt;design presented
above&lt;/a&gt;,
this is as simple as adjusting the &lt;code class=&quot;highlighter-rouge&quot;&gt;FIXED_TAPS&lt;/code&gt; parameter and
creating a hex file containing the coefficients for &lt;code class=&quot;highlighter-rouge&quot;&gt;$readmemh&lt;/code&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;We could use multirate techniques&lt;/p&gt;

    &lt;p&gt;By “multirate techniques”, I mean that we might include an &lt;a href=&quot;https://en.wikipedia.org/wiki/Sample-rate_conversion&quot;&gt;upsampler or
downsampler&lt;/a&gt; as
part of our filter design and implementation.  If we could,
for example, downsample the incoming data stream sufficiently, then it might
be possible to use a block RAM based tapped-delay line and a single shared
multiply for a tremendous resource savings.&lt;/p&gt;

    &lt;p&gt;These techniques can often form the basis of some of the cheapest
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filtering&lt;/a&gt;
approaches, especially when small bandwidths are of interest.&lt;/p&gt;

    &lt;p&gt;We’ll need to come back and examine these, though we will by no means be
able to exhaust this approach to
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filtering&lt;/a&gt;.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The one thing we haven’t done in this post is to generate a test bench for
this &lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/genericfir.v&quot;&gt;generic
filter&lt;/a&gt;.
We’ll save that task for a later post–after we’ve created the &lt;a href=&quot;/dsp/2017/10/02/cordic-tb.html&quot;&gt;test bench
for our&lt;/a&gt;
&lt;a href=&quot;/dsp/2017/08/30/cordic.html&quot;&gt;CORDIC algorithm&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Since writing this post, a friend has shown me an &lt;a href=&quot;/dsp/2017/09/29/cheaper-fast-fir.html&quot;&gt;even better, cheaper
method&lt;/a&gt; of creating a
generic high-frequency
&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;filter&lt;/a&gt;.
Hence, while the &lt;a href=&quot;https://github.com/ZipCPU/dspfilters/blob/master/rtl/genericfir.v&quot;&gt;code presented
above&lt;/a&gt;
works, the task could be done without the input sample delay line.  We’ll
have to &lt;a href=&quot;/dsp/2017/09/29/cheaper-fast-fir.html&quot;&gt;come back to that
later&lt;/a&gt;, 
therefore, and examine &lt;a href=&quot;/dsp/2017/09/29/cheaper-fast-fir.html&quot;&gt;this alternative
implementation&lt;/a&gt;.&lt;/p&gt;
&lt;hr /&gt;&lt;p&gt;&lt;em&gt;And before him shall be gathered all nations: and he shall separate them one from another, as a shepherd divideth his sheep from the goats (Matt 25:32)&lt;/em&gt;</description>
        <pubDate>Fri, 15 Sep 2017 00:00:00 -0400</pubDate>
        <link>http://zipcpu.com/dsp/2017/09/15/fastfir.html</link>
        <guid isPermaLink="true">http://zipcpu.com/dsp/2017/09/15/fastfir.html</guid>
        
        
        <category>dsp</category>
        
      </item>
    
      <item>
        <title>Even I get stuck in FPGA Hell</title>
        <description>&lt;p&gt;&lt;a href=&quot;http://zipcpu.com/&quot;&gt;This site&lt;/a&gt; is dedicated to keeping
students and other digital design developers
out of &lt;a href=&quot;/fpga-hell.html&quot;&gt;FPGA Hell&lt;/a&gt;: that state in the design
process where your design doesn’t work, and you have absolutely no clue why
not.&lt;/p&gt;

&lt;p&gt;I’d like to present myself
as immune from ever having that problem.  How else shall I be respected as a
teacher of others who can teach students how to avoid this problem?&lt;/p&gt;

&lt;p&gt;Today, though, I have a confession to make: I get stuck in
&lt;a href=&quot;/fpga-hell.html&quot;&gt;FPGA Hell&lt;/a&gt; from time to time as well.&lt;/p&gt;

&lt;p&gt;By the grace of the Almighty, I’ve recently received three reprieves, so that I
can now tell you both how I got stuck, and how I got unstuck.&lt;/p&gt;

&lt;h2 id=&quot;hdmi-video&quot;&gt;HDMI Video&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;The background&lt;/strong&gt;:
One of my ongoing projects is an HDMI Video project.  This project has two
components.  The first is the receiver.  This component is supposed to
receive an HDMI signal and stuff the pixels into memory.  The second
component is the transmitter.  This component is supposed to read an image
frame from memory, and transmit it to my monitor.  The ultimate goal of this
project is to be able to process the HDMI signals associated with
3D head-sets, such as the &lt;a href=&quot;https://www.oculus.com/rift/&quot;&gt;Oculus Rift&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;I’m doing my development on a
&lt;a href=&quot;https://store.digilentinc.com&quot;&gt;Digilent&lt;/a&gt;
&lt;a href=&quot;https://store.digilentinc.com/nexys-video-artix-7-fpga-trainer-board-for-multimedia-applications/&quot;&gt;Nexys-Video board&lt;/a&gt;.  This board has not only the required
HDMI input and output ports, but also enough memory to tackle the data
transfer.  (We can talk later about memory bandwidth, which for this
application will require some creative solutions.)&lt;/p&gt;

&lt;p&gt;I had the project working some time ago to the point where I could lock on to
the received HDMI signal and calculate it’s pixel clock rate, frame rate,
and even the number of lines per frame, pixels per line, horizontal sync
length, vertical sync length, front porches, back porches, etc.  In other
words, from the incoming data, I can calculate all of the required video
parameters to set an associated &lt;a href=&quot;https://en.wikipedia.org/wiki/XFree86_Modeline&quot;&gt;mode
line&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;I can also read and process the EDID information using the
&lt;a href=&quot;https://github.com/ZipCPU/wbi2c&quot;&gt;wbi2c&lt;/a&gt; project.&lt;/p&gt;

&lt;p&gt;Then I tore the project apart so that I could incorporate the
512MB &lt;a href=&quot;https://en.wikipedia.org/wiki/DDR3_SDRAM&quot;&gt;DDR3 SDRAM&lt;/a&gt;
memory into the design.&lt;/p&gt;

&lt;table style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 1: Broken HDMI&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/hdmi-bug.svg&quot; alt=&quot;HDMI input bug&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;&lt;strong&gt;The symptoms&lt;/strong&gt;: Since finishing the restructuring changes necessary to get
the &lt;a href=&quot;https://en.wikipedia.org/wiki/DDR3_SDRAM&quot;&gt;DDR3 SDRAM&lt;/a&gt; memory to work,
I hadn’t been able to get the incoming video to
lock at all, and I’ve been struggling to figure out what was wrong.
Fig 1 shows my test setup.  I was using my &lt;a href=&quot;https://github.com/ZipCPU/wbscope&quot;&gt;wishbone
scope&lt;/a&gt; to capture frames of video
data.  I could then use these with a home-made HDMI simulator to
&lt;a href=&quot;/blob/2017/06/21/looking-at-verilator.html&quot;&gt;simulate my
code&lt;/a&gt;.
The resulting code just didn’t contain the synchronization pattern that I
knew was there.  The data was somehow wrong, but I just couldn’t figure
out what logical transformation would correct it.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;The problem&lt;/strong&gt;: Just this week, I figured out what was going on.&lt;/p&gt;

&lt;table style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 2: Broken HDMI bug found&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/hdmi-bug-found.svg&quot; alt=&quot;HDMI input bug found&quot; width=&quot;380&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Since adding the &lt;a href=&quot;https://en.wikipedia.org/wiki/DDR3_SDRAM&quot;&gt;SDRAM&lt;/a&gt;,
I had changed my system clock from the incoming
100MHz clock rate, to the 100MHz clock used by the Xilinx MIG generated
&lt;a href=&quot;https://en.wikipedia.org/wiki/DDR3_SDRAM&quot;&gt;SDRAM&lt;/a&gt;
controller.  (I’d still like to use my own
&lt;a href=&quot;https://en.wikipedia.org/wiki/DDR3_SDRAM&quot;&gt;DDR3 SDRAM&lt;/a&gt; controller,
but &lt;a href=&quot;http://opencores.org/project,wbddr3&quot;&gt;that project&lt;/a&gt; is currently on
hold.)  This controller clock is subtly different from the 100MHz input clock,
even though the two are at the same frequency: it takes some time for the PLL
to settle, and there’s a phase difference due to the distribution network.
(These are only the differences I know of.)&lt;/p&gt;

&lt;p&gt;You can see what the broken configuration looked like in Fig 2.&lt;/p&gt;

&lt;p&gt;These differences were apparently enough that a reset line I was setting with
logic on the 100MHz clock, was failing to reset the ISERDESE2 component on the
148.5MHz HDMI pixel clock.&lt;/p&gt;

&lt;table style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 3: Broken HDMI bug fixed&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/hdmi-bug-fixed.svg&quot; alt=&quot;HDMI input bug fixed&quot; width=&quot;380&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;&lt;strong&gt;How did I find the problem?&lt;/strong&gt;  The worst way to find a problem like this is
by desk-checking your code.  It is, however, how I ended up finding it.  I
knew, from pixel captures, that the problem had to be in the ISERDESE2
component.  I had traced it there via my
&lt;a href=&quot;https://github.com/ZipCPU/wbscope&quot;&gt;wishbone scope&lt;/a&gt;.  Then, thanks to the
Almighty, in one sudden piece of inspiration I realized the problem.&lt;/p&gt;

&lt;p&gt;The code in question now includes an asynchronous reset, with a synchronous
release, such as is shown in Fig 3.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;wire		async_reset;
reg	[2:0]	reset_pipe;
always @(posedge i_clk, negedge i_ce)
	// The !i_ce signal is our reset indication
	if (!i_ce)
		reset_pipe[2:0] &amp;lt;= 3&#39;h7;
	else
		reset_pipe[2:0] &amp;lt;= { reset_pipe[1:0], 1&#39;b0 };
assign	async_reset = reset_pipe[2];&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;I also added a separate piece of logic to “synchronize” the CE signal to
the HDMI pixel clock:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;wire		lcl_ce;
reg	[1:0]	syncd_ce;
always @(posedge i_clk)
	syncd_ce &amp;lt;= { syncd_ce[0], i_ce };
assign	lcl_ce = syncd_ce[1];&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;These two changes fixed the problem.&lt;/p&gt;

&lt;p&gt;This, by the way, is one of those reasons why
&lt;a href=&quot;https://en.wikipedia.org/wiki/Metastability_in_electronics&quot;&gt;metastability&lt;/a&gt;
can be so problematic.  The symptoms of
&lt;a href=&quot;https://en.wikipedia.org/wiki/Metastability_in_electronics&quot;&gt;metastability&lt;/a&gt;
tend not to make any sense.  They draw you away from looking for
clock domain transfer problems, convincing you that your logic is somehow
strangely at fault.  In the end, I’ve only ever found
&lt;a href=&quot;https://en.wikipedia.org/wiki/Metastability_in_electronics&quot;&gt;metastability&lt;/a&gt;
and other clock-domain crossing related problems by desk-checking my code.
(If you know of another way, please feel free to share …)&lt;/p&gt;

&lt;h2 id=&quot;ico-board-parallel-port&quot;&gt;ICO Board Parallel Port&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;The background&lt;/strong&gt;:
The second problem I was struggling with was on my
&lt;a href=&quot;http://www.icoboard.org&quot;&gt;ICO Board&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/icozip&quot;&gt;project&lt;/a&gt;.  The
&lt;a href=&quot;http://www.icoboard.org&quot;&gt;ICO Board&lt;/a&gt; is designed to demonstrate the utility of
a full open-source tool-chain for
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
development.  It is based upon an
ICE40
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
with &lt;a href=&quot;http://www.mouser.com/ds/2/225/iCE40FamilyHandbook-311139.pdf&quot;&gt;8k logic
gates&lt;/a&gt;.
My goal with this project was to create a series of beginner demonstration
designs that others could reference.  Indeed, the board was given to me by
the project team as a gift for that purpose.&lt;/p&gt;

&lt;p&gt;My problem was that I’ve been struggling to get a
&lt;a href=&quot;/blog/2017/06/16/dbg-bus-forest.html&quot;&gt;debugging bus&lt;/a&gt;
running over the parallel port between the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
and the
&lt;a href=&quot;https://www.raspberrypi.org/products/raspberry-pi-2-model-b/&quot;&gt;Raspberry Pi&lt;/a&gt;
for some time.&lt;/p&gt;

&lt;p&gt;You can see how far I had gotten in Fig 4 below.&lt;/p&gt;

&lt;table style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 4: Broken IcoZip Project&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/ico-bug.svg&quot; alt=&quot;ICO parallel port&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;&lt;strong&gt;The symptoms&lt;/strong&gt;: The bus worked fine in simulation, but somehow struggled any
time I tried to actually place it on the board.  I placed an extra
&lt;a href=&quot;https://store.digilentinc.com/pmod-8ld-eight-high-brightness-leds&quot;&gt;8-LED’s&lt;/a&gt;
onto the board, but still couldn’t figure out what was going wrong.
In particular, I couldn’t tell if it was that the
&lt;a href=&quot;https://www.raspberrypi.org/products/raspberry-pi-2-model-b/&quot;&gt;Raspberry Pi&lt;/a&gt;
was talking too fast, or whether something was wrong within the
&lt;a href=&quot;http://www.icoboard.org&quot;&gt;ICO Board&lt;/a&gt;.  At one time I was afraid I was creating
a short across the parallel port interface, and so somehow the
&lt;a href=&quot;http://www.icoboard.org&quot;&gt;ICO Board&lt;/a&gt; was losing power in the middle of a
transaction.&lt;/p&gt;

&lt;p&gt;I even went so far as to connect a &lt;a href=&quot;https://store.digilentinc.com/pmod-usbuart-usb-to-uart-interface/&quot;&gt;PMod
USBUART&lt;/a&gt;
to the board, so that I could use &lt;em&gt;a known working
&lt;a href=&quot;https://github.com/ZipCPU/dbgbus/tree/master/hexbus&quot;&gt;debug-bus&lt;/a&gt;&lt;/em&gt;,
based upon my &lt;em&gt;proven &lt;a href=&quot;https://github.com/ZipCPU/wbuart32&quot;&gt;UART&lt;/a&gt;&lt;/em&gt; code,
to find the fault, and … even my proven code didn’t work right.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;How did I find the problem?&lt;/strong&gt;  In this case, a heart-felt thank you goes
out to both the Almighty, and to the
&lt;a href=&quot;https://store.digilentinc.com&quot;&gt;Digilent&lt;/a&gt;
sales team, who were looking for some feedback on their &lt;a href=&quot;https://store.digilentinc.com/digital-discovery-portable-logic-analyzer-and-digital-pattern-generator/&quot;&gt;Digital
Discovery&lt;/a&gt;
device, shown in Fig 5.&lt;/p&gt;
&lt;table style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 5: A Digital Discovery logic analyzer&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/digital-discovery-top-130.png&quot; alt=&quot;Digilent&#39;s Digital Discovery&quot; width=&quot;280&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;Out of the blue, they asked if I’d like to review the
device for them, and send them back my thoughts.  Of course I’d be interested,
I said.&lt;/p&gt;

&lt;p&gt;If you aren’t familiar with the
&lt;a href=&quot;https://store.digilentinc.com/digital-discovery-portable-logic-analyzer-and-digital-pattern-generator/&quot;&gt;Digital Discovery&lt;/a&gt;
it’s an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
based external
logic analyzer.
&lt;a href=&quot;https://store.digilentinc.com&quot;&gt;Digilent&lt;/a&gt; sells the device for $200 USD.
It boasts the ability to capture and analyze data signals at up to 800MHz.
However, my &lt;a href=&quot;https://github.com/ZipCPU/icozip&quot;&gt;ICO board design&lt;/a&gt; was only
running at &lt;a href=&quot;https://github.com/ZipCPU/icozip/blob/master/auto-data/clock.txt&quot;&gt;40MHz–a slow clock
rate&lt;/a&gt; since I
couldn’t tell what was wrong with the design, and I wasn’t certain
how well I could trust my
&lt;a href=&quot;http://www.clifford.at/icestorm&quot;&gt;timing analyzer&lt;/a&gt;.  (In the end, the timing
analyzer wasn’t the problem, and I could’ve trusted the
&lt;a href=&quot;http://www.clifford.at/icestorm&quot;&gt;icestorm tools&lt;/a&gt; just fine.)&lt;/p&gt;

&lt;p&gt;To use this device, I connected one of the PMod ports of the
&lt;a href=&quot;http://www.icoboard.org&quot;&gt;ICO Board&lt;/a&gt; to the
&lt;a href=&quot;https://store.digilentinc.com/digital-discovery-portable-logic-analyzer-and-digital-pattern-generator/&quot;&gt;Digital Discovery&lt;/a&gt;,
and started making and examining captures.&lt;/p&gt;

&lt;p&gt;One particular capture showed one of my logic signals holding a value for
less than 10ns.  This didn’t make any sense, since the clock period was
&lt;em&gt;supposed&lt;/em&gt; to be 25ns.  Further, it didn’t make sense as a spurious value that
hadn’t yet settled yet, since the design then continued as though this
value had been high for a full clock cycle.  (To the extent that I could
tell anything about what this erratic design was doing …)  That left me
wondering what the actual clock rate was, so I decided to dump the system
clock to one of the output pins and examine it.&lt;/p&gt;

&lt;p&gt;You can see the final test setup in Fig 5 below.  It was enough to see
the problem.&lt;/p&gt;

&lt;table style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 5: IcoZip Problem found&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/ico-bug-found.svg&quot; alt=&quot;IcoZip problem found&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;&lt;strong&gt;The Problem&lt;/strong&gt;:
As with the HDMI problem, this problem also turned out to
be clock related.  In this case, I had given the wrong parameters to the
&lt;a href=&quot;http://www.mouser.com/ds/2/225/iCE40FamilyHandbook-311139.pdf&quot;&gt;iCE40&lt;/a&gt;’s
&lt;a href=&quot;http://www.latticesemi.com/view_document?document_id=47778&quot;&gt;PLL&lt;/a&gt;
primitive.  Sure, I read through
&lt;a href=&quot;http://www.latticesemi.com/view_document?document_id=47778&quot;&gt;the manual&lt;/a&gt;,
but
&lt;a href=&quot;http://www.latticesemi.com/view_document?document_id=47778&quot;&gt;the manual&lt;/a&gt;
didn’t explain all of the configuration parameters very well.  As a result, I
hadn’t set all of the PLL parameters correctly.  The &lt;a href=&quot;http://www.latticesemi.com/view_document?document_id=47778&quot;&gt;iCE40
documentation&lt;/a&gt;,
recommends using their
proprietary wizard.  However, since I never managed to get their proprietary
software installed, I was using the &lt;a href=&quot;https://en.wikipedia.org/wiki/ISC_license&quot;&gt;open
source&lt;/a&gt;
&lt;a href=&quot;https://www.clifford.at/yosys&quot;&gt;yosys toolchain&lt;/a&gt; instead and
instantiating the primitive directly.&lt;/p&gt;

&lt;p&gt;The result was that the
&lt;a href=&quot;http://www.mouser.com/ds/2/225/iCE40FamilyHandbook-311139.pdf&quot;&gt;iCE40&lt;/a&gt;’s
&lt;a href=&quot;http://www.latticesemi.com/view_document?document_id=47778&quot;&gt;PLL&lt;/a&gt;
primitive (SB_PLL) wasn’t locking, and so my system clock was unstable.&lt;/p&gt;

&lt;p&gt;Eventually, I found the
&lt;a href=&quot;https://github.com/cliffordwolf/icestorm/tree/master/icepll&quot;&gt;icepll&lt;/a&gt;
open-source program which told me what the
&lt;a href=&quot;http://www.latticesemi.com/view_document?document_id=47778&quot;&gt;PLL&lt;/a&gt;
parameters needed to be set to in order to get a stable clock.&lt;/p&gt;

&lt;p&gt;Now that I have my
&lt;a href=&quot;https://github.com/ZipCPU/dbgbus/tree/master/hexbus&quot;&gt;debugging bus&lt;/a&gt;
up and running within my &lt;a href=&quot;http://www.icoboard.org&quot;&gt;ICO Board&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/icozip&quot;&gt;project&lt;/a&gt; over the
&lt;a href=&quot;https://github.com/ZipCPU/icozip/tree/master/pport&quot;&gt;parallel port&lt;/a&gt;,
I can now start to add (and debug) other capabilities.  This will include
the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
implementation for the board, the SRAM, as well as (hopefully) the flash on
the board.  My goal is to get the point where I can play
&lt;a href=&quot;https://github.com/ZipCPU/tttt&quot;&gt;4x4x4 tic-tac-toe&lt;/a&gt;
on the board, using only the
&lt;a href=&quot;https://sourceware.org/newlib/&quot;&gt;standard C-library&lt;/a&gt;.
Others, I imagine, will be more interested in the extensibility offered by an
&lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt;
based platform making it easy to add and remove functionality from the design.&lt;/p&gt;

&lt;h2 id=&quot;arbitrary-clock-rate-generator&quot;&gt;Arbitrary clock rate generator&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;The background&lt;/strong&gt;:
The third design that I got stuck on is an arbitrary clock rate generator.
This is an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
only design, requiring no external clock, save only the 100MHz clock already
provided to the board.  It is also one of those designs that demonstrates
something few people think possible–the ability to create a suitable
clock signal from logic alone.&lt;/p&gt;

&lt;p&gt;Indeed, I wasn’t certain if it was possible myself.&lt;/p&gt;

&lt;p&gt;For those interested, the design is based upon the &lt;a href=&quot;/blog/2017/06/02/generating-timing.html&quot;&gt;logic presented
here&lt;/a&gt;.
Using that logic, together with the input 100MHz clock, I can request a clock
frequency within 0.2Hz or so of any desired clock frequency, and then create
a clock that accurately matches that frequency.  Further, if I use the &lt;a href=&quot;https://store.digilentinc.com/pmod-gps-gps-receiver&quot;&gt;PMod
GPS&lt;/a&gt;,
I should be able to generate a clock frequency with absolutely stability at
any known frequency.  (“Should be able to” means I haven’t tried to yet.)&lt;/p&gt;

&lt;p&gt;As with the HDMI project above, the hardware I was using was the
&lt;a href=&quot;https://store.digilentinc.com&quot;&gt;Digilent&lt;/a&gt;
&lt;a href=&quot;https://store.digilentinc.com/nexys-video-artix-7-fpga-trainer-board-for-multimedia-applications/&quot;&gt;Nexys-Video board&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;My goal with this project was to be able to create an output pixel clock,
to be sent via the HDMI output port, of an arbitrary frequency so that it
could support any reasonable display timing.&lt;/p&gt;

&lt;table style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 6: Broken arbitrary clock generator&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/genclk-bug.svg&quot; alt=&quot;Broken arbitrary clock generator&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;&lt;strong&gt;Symptoms&lt;/strong&gt;: Normally, I wouldn’t think twice if this design didn’t work.
It requires that I can get my hardware to work in a way that it wasn’t designed
to work in, and so I was never certain it could work in the first place.
However, the first time I fired up the design it appeared to work.  Then, after
making several changes (without git backups), I lost that appearance of
working and …  I struggled to understand why.&lt;/p&gt;

&lt;p&gt;Indeed, the clock would appear to lock onto frequencies such as 50MHz, 75MHz,
100MHz, 125MHz, and so forth, but never lock onto the frequency I was
requesting, such as 131.415928MHz.&lt;/p&gt;

&lt;p&gt;I was stuck.  I desk-checked and desk-checked my code.  I read through
the Xilinx clocking guide.  I found and fixed several “problems”, but never
fixed &lt;em&gt;the&lt;/em&gt; problem.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Definition: &lt;strong&gt;Voodoo computing&lt;/strong&gt;.
A noun describing the process of fixing what isn’t broken in an attempt to
find and fix what is.  It is usually characterized by a complete lack of
understanding as to what is causing the problem, and so the “fixes” applied
tend to be quite irrelevant to the actual problem at hand.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;How did I find the problem&lt;/strong&gt;:  In this case, I turned again to the
&lt;a href=&quot;https://store.digilentinc.com/digital-discovery-portable-logic-analyzer-and-digital-pattern-generator/&quot;&gt;Digital Discovery&lt;/a&gt;.
As with the &lt;a href=&quot;https://github.com/ZipCPU/icozip&quot;&gt;icozip&lt;/a&gt; project, I routed my
generated clock signal to a PMod port.&lt;/p&gt;

&lt;p&gt;Much to my surprise, my code wasn’t generating the clock that I thought it
was generating.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;The problem&lt;/strong&gt;:  This sent me back to my clock generation code, where I was
able to find the problem.  In this case, my problem was associated
with the Xilinx OSERDESE2 primitive.  The primitive was mis-configured.
(I had set the &lt;code class=&quot;highlighter-rouge&quot;&gt;DATA_RATE_TQ&lt;/code&gt; parameter to “DDR” instead of “SDR”, for a
functionality &lt;em&gt;I wasn’t using&lt;/em&gt;.)  Once fixed, the whole design started working.&lt;/p&gt;

&lt;p&gt;As a result, I can now create arbitrary clock frequencies within my
&lt;a href=&quot;https://store.digilentinc.com/nexys-video-artix-7-fpga-trainer-board-for-multimedia-applications/&quot;&gt;Nexys-Video board&lt;/a&gt;, without requiring any additional
hardware.&lt;/p&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;In each of these examples, the easiest part of the design to get right was the
logic.  The hardest part, the part which had sent me to
&lt;a href=&quot;/fpga-hell.html&quot;&gt;FPGA Hell&lt;/a&gt; in the first place,
was dealing with those parts and components of my design which I could not
simulate.  Further, in two out of three of these examples, an external logic
analyzer,
&lt;a href=&quot;https://store.digilentinc.com&quot;&gt;Digilent&lt;/a&gt;’s
&lt;a href=&quot;https://store.digilentinc.com/digital-discovery-portable-logic-analyzer-and-digital-pattern-generator/&quot;&gt;Digital Discovery&lt;/a&gt;,
rescued me.&lt;/p&gt;

&lt;p&gt;My point, though, is simply this: even those who have been designing digital
logic for years can still get stuck.  If you work with an old hand, ask for
some of their stories over lunch time.  You might find that lunch can actually
be entertaining—without discussing either religion or politics.&lt;/p&gt;

&lt;p&gt;Perhaps next time I’ll know to check the PLL-locked output signal, though,
rather than assuming that any PLL will always lock.&lt;/p&gt;

&lt;p&gt;The code for all three projects is available for those sufficiently
interested.  The
&lt;a href=&quot;http://www.icoboard.org&quot;&gt;ICO Board&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/icozip&quot;&gt;project&lt;/a&gt;, together with its
&lt;a href=&quot;https://github.com/ZipCPU/icozip/tree/master/hexbus&quot;&gt;debugging bus&lt;/a&gt;
and support infrastructure, can be found on
&lt;a href=&quot;https://github.com/ZipCPU/icozip&quot;&gt;Github&lt;/a&gt;.
The clock generation core is available upon request for any of my
Patreon sponsors who supports me for $10 USD or more, and will probably be
eventually included within the HDMI video project.  It’s not well documented
(yet), but with sufficient interest in it that can be changed.  (It’s only
about 300 lines of code or so …)&lt;/p&gt;

&lt;p&gt;The HDMI video project, though, needs sponsors in order to bring it to
completion.  It still needs more development work
before it will be released on &lt;a href=&quot;https://github.com/ZipCPU&quot;&gt;Github&lt;/a&gt;, and that
work isn’t (yet) paid for.  If you are interested in this project, please
consider &lt;a href=&quot;https://www.patreon.com/ZipCPU&quot;&gt;supporting me on Patreon&lt;/a&gt;, and then
sending me a note to let me know that it is a project you are interested in.&lt;/p&gt;

&lt;hr /&gt;&lt;p&gt;&lt;em&gt;Wherefore let him that thinketh he standeth take heed lest he fall.  (1Cor 10:12)&lt;/em&gt;</description>
        <pubDate>Thu, 14 Sep 2017 00:00:00 -0400</pubDate>
        <link>http://zipcpu.com/blog/2017/09/14/even-i-get-stuck.html</link>
        <guid isPermaLink="true">http://zipcpu.com/blog/2017/09/14/even-i-get-stuck.html</guid>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>Glad I went to ORCONF</title>
        <description>&lt;p&gt;Just a quick post today to thank the individuals who made
&lt;a href=&quot;https://orconf.org&quot;&gt;ORCONF&lt;/a&gt; this year
such a great success!  The staff did a wonderful job setting up the conference,
and I learned a &lt;em&gt;lot&lt;/em&gt; from all those present with whom I had a chance to talk.&lt;/p&gt;

&lt;p&gt;When it came my turn, I presented both an &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/doc/orconf2017.pdf&quot;&gt;update on the
ZipCPU&lt;/a&gt;, as
well as &lt;a href=&quot;https://github.com/ZipCPU/autofpga/blob/master/doc/orconf17.pdf&quot;&gt;telling everyone about
AutoFPGA&lt;/a&gt;.
I’ve also posted the final slides for both projects on line, in case you
weren’t able to go and would like to see what I presented.  The &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/doc/orconf2017.pdf&quot;&gt;ZipCPU update
slides can be found
here&lt;/a&gt;,
whereas the &lt;a href=&quot;https://github.com/ZipCPU/autofpga/blob/master/doc/orconf17.pdf&quot;&gt;AutoFPGA slides can be found
here&lt;/a&gt;.
(For some reason, the first several slides in either presentation aren’t
displaying properly within my browser, so you may need to download
the file(s) to view all of the slides.)
I’m expecting the videos of the presentations to be posted on
&lt;a href=&quot;https://youtube.com&quot;&gt;youtube&lt;/a&gt;,
so we’ll watch for them.  (You can find a video of last year’s
presentation on the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;
&lt;a href=&quot;https://youtube.com/watch?v=uVSRTgy-Ui0&quot;&gt;here&lt;/a&gt;,
together with the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/orconf.pdf&quot;&gt;slides for it here&lt;/a&gt;–although those slides are now out of date.)&lt;/p&gt;

&lt;p&gt;For those who may be interested in trying
out &lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt;, I’m probably going to take
some time out from these general FPGA based posts to present several 
&lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt; examples and basic tutorials.
The first such tutorial will likely be a rewrite of our original
&lt;a href=&quot;https://github.com/ZipCPU/dbgbus&quot;&gt;debugging bus&lt;/a&gt; project, but this time
using &lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt;.  From there, we can
demo the &lt;a href=&quot;https://github.com/ZipCPU/debouncer&quot;&gt;button debouncing project&lt;/a&gt;
again, showing how easy it is to reconfigure the original project in order
to add &lt;a href=&quot;https://github.com/ZipCPU/debouncer/blob/master/rtl/debouncer.v&quot;&gt;a button
debouncer&lt;/a&gt;
and a &lt;a href=&quot;https://github.com/ZipCPU/wbscope&quot;&gt;scope&lt;/a&gt; into the project using
&lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt;.  If all goes well, we’ll
then use &lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt; to build any further
demonstrations from there.&lt;/p&gt;

&lt;p&gt;For those who have never been to &lt;a href=&quot;https://orconf.org&quot;&gt;ORCONF&lt;/a&gt;, please allow
me to tell you a bit about the conference.  First, the conference tends to be
very informal.  (I may have been the only one there wearing a suit.)
The conference also tends to be small.  You will not be lost
in a sea of thousands of individuals, but may instead get a chance to meet
every individual who attends.  Reconnecting with the friends I had made
&lt;a href=&quot;https://orconf.org/2017/&quot;&gt;last year&lt;/a&gt; was an encouragement for me.  Discovering
the history of what others had done before me was also a treat.&lt;/p&gt;

&lt;p&gt;Between now and next-time, though, I’ll probably muse on what direction I
should take to move the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;
forward.  I could …&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Dig into the code and make it truly the smallest 32-bit machine out there.
At 1,350–2,500 LUT’s, the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;
isn’t the smallest design out there, despite that being it’s ostensible
purpose.  At 600 LUT’s it would be a lot closer.  Such a CPU would also
be a lot faster as well.  Many thanks to Jan for sharing with me how to
get the logic count down that low.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Finish integrating the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/zipmmu.v&quot;&gt;Memory Management
Unit&lt;/a&gt;
and the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/dcache.v&quot;&gt;data
cache&lt;/a&gt;.
This would bring the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt; that much closer to running
&lt;a href=&quot;https://www.kernel.org&quot;&gt;Linux&lt;/a&gt;, even though
it will probably slow down the CPU’s memory interactions somewhat.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;em&gt;Formally&lt;/em&gt; verify that the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;
code faithfully executes its instruction set.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Continue to work on building peripherals that can be used with the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;. I’m still working on building
up an &lt;a href=&quot;https://en.wikipedia.org/wiki/HDMI&quot;&gt;HDMI&lt;/a&gt; capability, although
building a &lt;a href=&quot;https://en.wikipedia.org/wiki/Brushless_DC_electric_motor&quot;&gt;brushless DC
motor&lt;/a&gt; controller
might be fun to do as well.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Here on &lt;a href=&quot;http://zipcpu.com&quot;&gt;this blog&lt;/a&gt; we’re probably going to continue
pressing towards building some &lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_filter&quot;&gt;digital
filter&lt;/a&gt;s and testing them.  This
includes building a proper test bench for the &lt;a href=&quot;/2017/08/30/cordic.html&quot;&gt;CORDIC cores we’ve
built&lt;/a&gt;.
I’ve also been asked by one individual to release a test bench showing the
improvements possible via the
&lt;a href=&quot;/2017/09/04/pwm-reinvention.html&quot;&gt;PWM scheme&lt;/a&gt; presented
the other day.  If anyone else is interested, I may move forward on that as
well.&lt;/p&gt;

&lt;p&gt;For me, in the end,
&lt;a href=&quot;https://orconf.org&quot;&gt;ORCONF&lt;/a&gt;
was a success because of all that I learned there.  For that I thank not
only those who helped to organize the conference, but also all of those who
attended and took the time with me to teach me about open source hardware
from their individual perspectives.&lt;/p&gt;

&lt;p&gt;Thank you.&lt;/p&gt;
&lt;hr /&gt;&lt;p&gt;&lt;em&gt;Iron sharpeneth iron; so a man sharpeneth the countenance of his friend. (Prov 27:17)&lt;/em&gt;</description>
        <pubDate>Tue, 12 Sep 2017 00:00:00 -0400</pubDate>
        <link>http://zipcpu.com/blog/2017/09/12/orconf-2017-return-home.html</link>
        <guid isPermaLink="true">http://zipcpu.com/blog/2017/09/12/orconf-2017-return-home.html</guid>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>Off to ORCONF-2017!</title>
        <description>&lt;p&gt;After a year of waiting, it’s time for &lt;a href=&quot;https://orconf.org&quot;&gt;ORCONF&lt;/a&gt;.
If you are not familiar with &lt;a href=&quot;https://orconf.org&quot;&gt;ORCONF&lt;/a&gt;,
then allow me to encourage you to examine &lt;a href=&quot;https://orconf.org&quot;&gt;their web-page&lt;/a&gt;,
and look over the &lt;a href=&quot;https://orconf.org/#presentations&quot;&gt;abstracts of the
presentations&lt;/a&gt; that will be given this year.
Looks like it will be quite the lineup.&lt;/p&gt;

&lt;p&gt;This year, I’ll be giving two presentations.&lt;/p&gt;

&lt;p&gt;My first presentation will be a quick
update on the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;.
Since &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/master/doc/orconf.pdf&quot;&gt;last year&lt;/a&gt;,
the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; has been updated so as to
support …&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;8-bit byte-level access across the 32-bit bus.&lt;/p&gt;

    &lt;p&gt;Prior to this redesign, the 
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
was one of a few rare 32-bit byte machines.&lt;/p&gt;

    &lt;p&gt;Now, the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; fully supports
8-bit bytes instead of the 32-bit bytes it supported before.&lt;/p&gt;

    &lt;p&gt;This required a bit of instruction set redesign.  Opcodes were re-ordered.
Rotate left &lt;code class=&quot;highlighter-rouge&quot;&gt;ROL&lt;/code&gt; and population count &lt;code class=&quot;highlighter-rouge&quot;&gt;POPC&lt;/code&gt; instructions have been removed.
The load and store instructions have been renamed load word &lt;code class=&quot;highlighter-rouge&quot;&gt;LW&lt;/code&gt; and store
word &lt;code class=&quot;highlighter-rouge&quot;&gt;SW&lt;/code&gt; instructions.  Four basic instructions have been added as well:
load half-word &lt;code class=&quot;highlighter-rouge&quot;&gt;LH&lt;/code&gt;, store halfword &lt;code class=&quot;highlighter-rouge&quot;&gt;SH&lt;/code&gt;, load byte &lt;code class=&quot;highlighter-rouge&quot;&gt;LB&lt;/code&gt; and store byte &lt;code class=&quot;highlighter-rouge&quot;&gt;SB&lt;/code&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;A compressed instruction set (CIS).&lt;/p&gt;

    &lt;p&gt;The &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; has always had a CIS,
although it was previously mis-named as a &lt;a href=&quot;https://en.wikipedia.org/wiki/Very_long_instruction_word&quot;&gt;Very Long Instruction Word
(VLIW)&lt;/a&gt;
set of instructions–which it never really was.  The CIS instruction set
allows you to integrate pairs of 16-bit instructions together with the
32-bit instructions.  It provides some increased code density as a result.&lt;/p&gt;

    &lt;p&gt;Over the last year, I’ve had the opportunity to test the CIS instructions on
the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; and work out the bugs
within them.  The &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/tree/master/sw&quot;&gt;current
toolchain&lt;/a&gt; builds with CIS
instructions enabled by default.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Nearly the same number of LUTs&lt;/p&gt;

    &lt;p&gt;Despite all of these changes, the number of LUTs used by the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; remains roughly the same.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;As a result of these changes, the &lt;a href=&quot;https://sourceware.org/newlib&quot;&gt;newlib&lt;/a&gt;
C-library now runs on the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;–something it didn’t do before.
That means you can now play &lt;a href=&quot;https://github.com/ZipCPU/tttt&quot;&gt;4x4x4 Tic-Tac-Toe&lt;/a&gt;
on the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;!&lt;/p&gt;

&lt;p&gt;My &lt;a href=&quot;https://github.com/ZipCPU/autofpga/blob/master/doc/orconf17.pdf&quot;&gt;second
presentation&lt;/a&gt;
will be an overview of &lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt;.
Here’s the abstract:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Placing a &lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;
into a new environment can be a daunting task.  Components
need to be selected, resources allocated, addresses given, interrupts
assigned, and peripherals configured–not only in the HDL code, but also for
all of the software support.  The problem with this approach to designing
hardware is that it works very well for one-off solutions, but not as well
for quickly creating generic solutions to new problems.  This is where
&lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt; comes in.&lt;/p&gt;

  &lt;p&gt;Given a &lt;a href=&quot;https://github.com/zipCPU/autofpga/tree/master/auto-data&quot;&gt;set of
components&lt;/a&gt;,
&lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;AutoFPGA&lt;/a&gt;
builds the &lt;a href=&quot;https://github.com/ZipCPU/autofpga/tree/master/demo-out/&quot;&gt;boiler plate
files&lt;/a&gt;, the &lt;a href=&quot;https://github.com/ZipCPU/autofpga/blob/master/demo-out/toplevel.v&quot;&gt;top
level&lt;/a&gt;
and &lt;a href=&quot;https://github.com/ZipCPU/autofpga/blob/master/demo-out/main.v&quot;&gt;main&lt;/a&gt;
design files, the &lt;a href=&quot;/doc/wbspec_b4.pdf&quot;&gt;Wishbone&lt;/a&gt;
interconnect, and the &lt;a href=&quot;https://github.com/ZipCPU/autofpga/blob/master/demo-out/board.h&quot;&gt;software header
file&lt;/a&gt;s
necessary for software support within that design.  As a result, I can
reconfigure a project with new hardware in a matter of minutes, rather
than the days it took before.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;When I get back, I’ll post about my experiences and thoughts.  When the
presentation video’s are posted on youtube, I intend to post those links
here as well.&lt;/p&gt;
&lt;hr /&gt;&lt;p&gt;&lt;em&gt;For the kingdom ofheaven is as a man travelling into a far country, who called his own servants, and delivered unto them his goods.  (Matt 25:14)&lt;/em&gt;</description>
        <pubDate>Wed, 06 Sep 2017 00:00:00 -0400</pubDate>
        <link>http://zipcpu.com/blog/2017/09/06/orconf-2017.html</link>
        <guid isPermaLink="true">http://zipcpu.com/blog/2017/09/06/orconf-2017.html</guid>
        
        
        <category>blog</category>
        
      </item>
    
  </channel>
</rss>
