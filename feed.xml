<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>The ZipCPU by Gisselquist Technology</title>
    <description>The ZipCPU blog, featuring how to discussions of FPGA and CPU design. This site will be focused on Verilog solutions, using exclusively OpenSource IP products for FPGA design.
</description>
    <link>http://zipcpu.com/</link>
    <atom:link href="http://zipcpu.com/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Fri, 19 May 2017 12:55:55 -0400</pubDate>
    <lastBuildDate>Fri, 19 May 2017 12:55:55 -0400</lastBuildDate>
    <generator>Jekyll v3.0.1</generator>
    
      <item>
        <title>FPGA Hell</title>
        <description>&lt;p&gt;The worst place to be in digital design is where you load the design onto your
device, it doesn’t work, and you don’t know why.&lt;/p&gt;

&lt;p&gt;I call this: &lt;em&gt;FPGA Hell&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;If you find yourself deskcheck your code and not knowing what to look for, you
may be in FPGA Hell.  Weeks and months can spent in there, and you will make no
progress towards your goal while you are there.&lt;/p&gt;

&lt;p&gt;Time is money.  FPGA Hell will cost you dearly.  Avoid FPGA Hell at &lt;em&gt;all&lt;/em&gt; cost.&lt;/p&gt;

&lt;h2 id=&quot;the-solution&quot;&gt;The solution&lt;/h2&gt;

&lt;p&gt;The solution to FPGA Hell is twofold.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;First, simulate everything.  If you don’t have a simulation to describe
the hardware you are working with, make one.&lt;/p&gt;

    &lt;p&gt;As an example, &lt;a href=&quot;https://github.com/ZipCPU/wbuart32/blob/master/bench/cpp/uartsim.cpp&quot;&gt;here is&lt;/a&gt; a simulation of a UART port.  It turns a UART port into either your
standard input and output FILE streams, or into a TCP/IP port that you can
stream your data in and out of.  I built the simulation from an &lt;a href=&quot;https://en.wikipedia.org/wiki/Universal_asynchronous_receiver/transmitter&quot;&gt;online
description&lt;/a&gt; of how a UART works.  I then use the simulation to debug any Verilog
code someone posts to &lt;a href=&quot;http://forum.digilentinc.com&quot;&gt;Digilent’s forums&lt;/a&gt;, but
now that you know my secrets, you can do it too.&lt;/p&gt;

    &lt;p&gt;The problem with this first step is: what happens if your understanding of
the device you just built a simulator doesn’t match reality?  For that, you
need a scope.  Specifically, you need to measure reality and learn what’s
actually happening, and then you need to adjust your simulation to match
reality.  This leads us to the second part of the solution: using a scope.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Use a scope.  Measure what’s really going on.  Watch your code interact with
the real hardware, and use what you learn to find where reality and your
simulation disconnect.&lt;/p&gt;

    &lt;p&gt;A good example of this is my first attempt to build an &lt;a href=&quot;https://github.com/ZipCPU/wbi2c&quot;&gt;I2C
controller&lt;/a&gt;.  For that project, I built
two controllers, &lt;a href=&quot;https://github.com/ZipCPU/wbi2c/blob/master/rtl/wbi2cslave.v&quot;&gt;one a
slave&lt;/a&gt; and &lt;a href=&quot;https://github.com/ZipCPU/wbi2c/blob/master/rtl/wbi2cmaster.v&quot;&gt;the
other a
master&lt;/a&gt;.
I then built simulations for both &lt;a href=&quot;https://github.com/ZipCPU/wbi2c/blob/master/bench/cpp/wbi2cs_tb.cpp&quot;&gt;the
slave&lt;/a&gt;
and &lt;a href=&quot;https://github.com/ZipCPU/wbi2c/blob/master/bench/cpp/wbi2cm_tb.cpp&quot;&gt;the
master&lt;/a&gt;,
and then worked with the simulations until my code worked.  Once my code
worked, I placed it onto the device and … my code didn’t work.&lt;/p&gt;

    &lt;p&gt;To get past the problem, I placed a
&lt;a href=&quot;https://github.com/ZipCPU/wbscope/blob/master/rtl/wbscopc.v&quot;&gt;scope&lt;/a&gt; into my
design, allowing me to “see” what was going on.  What I learned was that the
hardware I was talking to (my monitor) wasn’t doing what I thought it should.
I then had to find &lt;a href=&quot;https://www.i2c-bus.org/specification&quot;&gt;a better
description&lt;/a&gt; of how an I2C port
works, rebuild my simulation, get the simulation working again, and then
test on the hardware.&lt;/p&gt;

    &lt;p&gt;You can find a discussion of the result, together with pictures of what I was
looking at,
&lt;a href=&quot;https://github.com/ZipCPU/wbscope/tree/master/doc/examples/hdmi-eddc&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;If you cannot use a scope, modify &lt;a href=&quot;blinky.html&quot;&gt;blinky&lt;/a&gt; to get the
information you need.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Hopefully this helps you avoid FPGA Hell.  If not, watch this space.  I intend
to write more articles here about how to debug an FPGA design.&lt;/p&gt;
</description>
        <pubDate>Fri, 19 May 2017 00:00:00 -0400</pubDate>
        <link>http://zipcpu.com/blog/2017/05/19/fpga-hell.html</link>
        <guid isPermaLink="true">http://zipcpu.com/blog/2017/05/19/fpga-hell.html</guid>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>Blinky</title>
        <description>&lt;p&gt;In C, the first program a person writes is often known  as a
&lt;a href=&quot;https://en.wikipedia.org/wiki/&amp;quot;Hello,_World!&amp;quot;_program&quot;&gt;“Hello, World!”&lt;/a&gt;
program.  It does nothing but print “Hello, World!” to the screen and exit.
While this is a wonderful first program for the C programmer, it is wholly
inappropriate for either the FPGA programmer or the embedded programmer.&lt;/p&gt;

&lt;p&gt;The FPGA or embedded programmer must work to get the serial port or the
C-library working, if he has either.  Instead, he has a simple LED to work with.
Hence the first program, &lt;a href=&quot;https://hackaday.io/project/7982-cat-board/log/37305-getting-to-blinky-cat-board-style&quot;&gt;blinky&lt;/a&gt;, simply blinks that LED.&lt;/p&gt;

&lt;h2 id=&quot;why-blinky&quot;&gt;Why blinky?&lt;/h2&gt;

&lt;p&gt;Blinky is a very important program: it proves that you can 1) program the
FPGA, that you 2) have a working clock, and that 3) you have a working LED.
These are very important steps in programming a new board.  Indeed, they are
so profound, I still run blinky as my first program on any FPGA board today.
Even after your first configuration, blinky is still important, because it can
tell you if the problem is your design versus the ability to load the board.&lt;/p&gt;

&lt;h2 id=&quot;what-is-blinky&quot;&gt;What is blinky?&lt;/h2&gt;

&lt;p&gt;Below is a very simple version of the blinky program, written in Verilog.
Remember, simple is better at this point.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;//
`default_nettype none
//
module blinky(i_clk, o_led);
  input wire i_clk;
  output wire o_led;

reg	[25:0]	counter;
always @(posedge i_clk)
  counter &amp;lt;= counter + 1&#39;b1;
assign o_led = counter[25];

endmodule&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;While there’s not much to the design, the “not much” that is there is important.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Notice that I mark my inputs with the prefix i_, and my outputs with the prefix o_.  You’ll find this consistent notation through all of my work.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Notice the default_nettype directive.  We’ll come back to it later.  For now, I highly recommend every Verilog design you build start with it.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Notice the counter.  Many beginners place an LED in their design without the counter, and then wonder why things don’t work.  An FPGA runs faster than your eye can see.  Without the counter, you wouldn’t be able to see this LED blink.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;I have 26 bits in my counter (25+1).  This is just about right for most of the projects I’ve worked on.  It divides the clock by 2^26, creating a clock rate at around one Hertz.  If you pick a number too low, you won’t see the LED blink.  If you pick a number too high, you’ll get bored waiting for the LED to blink while wondering if your FPGA works.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;a-better-blinky&quot;&gt;A better blinky&lt;/h2&gt;

&lt;p&gt;With no more than just a clock and an LED, can you figure out how fast your
clock is running?&lt;/p&gt;

&lt;p&gt;This was a challenge of mine when first firing up my
&lt;a href=&quot;http://icoboard.org&quot;&gt;icoboard&lt;/a&gt;.  The
&lt;a href=&quot;https://drive.google.com/file/d/0By-zY9AlHqXIcXZ6ZWdBR2dPXzg/view&quot;&gt;schematic&lt;/a&gt;
for that board initially identified the
clock as being at 25MHz, the examples identified it as being at 100MHz.  (The
team has since fixed the schematic, to properly reflect the 100MHz clock.)  How
should I tell which of the two was the right answer?&lt;/p&gt;

&lt;p&gt;Here was my solution:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;//
`default_nettype none
//
module clktest(i_clk, o_led);
  input wire i_clk;
  output wire o_led;

// We use a larger, 32-bit, counter here so as to get some better time
// precision.
reg	[31:0]	counter;
always @(posedge i_clk)
  counter &amp;lt;= counter + 32&#39;d43; // Valid if clk rate = 100MHz

// Blink the LED sharply at the top of each second, so that
// it remains on for a quarter of a second only before turning
// off
assign o_led = (counter[31:30] == 2&#39;b00);

endmodule&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Did you notice the 32’d43 value?  This value is set to 2^32 divided by the
clock rate.  Since the clock rate on this board is 100 MHz, 2^32 divided by
100 MHz is about 43.  Hence, if the counter starts at zero, then after
100 million clock ticks, the counter should equal 2^32 and roll over to zero
again.  In this case, though, since 2^32/100M isn’t exactly 43, our clock will
run about 5% too fast.  Still … it should be close enough that we can use a
stop watch to verify that we are in about the right clock range.&lt;/p&gt;

&lt;p&gt;If you are interested, this method of clock division is also used within the
&lt;a href=&quot;https://github.com/ZipCPU/rtcclock&quot;&gt;Real-Time Clock&lt;/a&gt; project used by the
ZipCPU.  The project, though, uses a 48-bit counter to get much better 
time accuracy–assuming that the oscillator is that good.&lt;/p&gt;

&lt;h2 id=&quot;using-blinky-for-debugging&quot;&gt;Using blinky for debugging&lt;/h2&gt;

&lt;p&gt;If you ever find yourself debugging with nothing but an LED, you can use the
LED for your debugging.  It’s not the best means of debugging: it can only
return one bit of information, and sometimes not even that, but it may be
the only means you have.&lt;/p&gt;

&lt;p&gt;The basic idea is to set the LED to on any time some condition takes place.
The trick is … you need to reset the LED so that you can see if that
condition takes place again later, and you need to make certain that the
condition (whatever it is) takes place so rarely that you can understand
what’s going on.&lt;/p&gt;

&lt;p&gt;Here’s an updated blinky, therefore, that can be used within a design to help
debug it:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;reg	[24:0]	counter;
always @(posedge i_clk)
  if (debug_event)
    counter &amp;lt;= 0;
  else if (!&amp;amp;counter)
    counter &amp;lt;= counter + 1&#39;b1;

assign o_led = counter[24];&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;As before, the choice of the length of the counter is important.&lt;/p&gt;

&lt;p&gt;This time, though, we’ve used “debug_event”, a variable coming from elsewhere
in the design, to check to see if something ever happens.&lt;/p&gt;

&lt;p&gt;While better approaches exist, most of those require more logic that needs to
be debugged first.  As a result, I’ve used this approach to debug my 
&lt;a href=&quot;https://github.com/ZipCPU/wbuart32/&quot;&gt;serial port controller&lt;/a&gt;, since most of my
debugging logic depends upon a working serial port.  I’ve also used this
approach to track how much time the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;
is spending in &lt;a href=&quot;https://github.com/ZipCPU/s6soc/blob/master/sw/zipos/kernel.c#L118&quot;&gt;interrupts&lt;/a&gt;, and if
and when the ZipCPU &lt;a href=&quot;https://github.com/ZipCPU/s6soc/blob/master/rtl/busmaster.v#L448&quot;&gt;has frozen&lt;/a&gt; in &lt;a href=&quot;https://github.com/ZipCPU/s6soc&quot;&gt;designs&lt;/a&gt; that are too tight
to fit a &lt;a href=&quot;https://github.com/ZipCPU/wbscope&quot;&gt;better debugging infrastructure&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;what-next&quot;&gt;What next?&lt;/h2&gt;

&lt;p&gt;Once you have blinky running, it’s time to move on to other tasks.  These tasks, though, will be easier because you have a clock and an LED that works.  Indeed, you can use blinky to your advantage as you struggle to get those newer tasks running.&lt;/p&gt;

</description>
        <pubDate>Fri, 19 May 2017 00:00:00 -0400</pubDate>
        <link>http://zipcpu.com/blog/2017/05/19/blinky.html</link>
        <guid isPermaLink="true">http://zipcpu.com/blog/2017/05/19/blinky.html</guid>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>Most common Digilent FPGA support requests</title>
        <description>&lt;p&gt;I’ve been watching the &lt;a href=&quot;https://forum.digientinc.com&quot;&gt;Digilent Forum’s&lt;/a&gt;, and
I’ve now seen some very common requests for FPGA help that keep coming back
over and over again.  I’ll separate these into three groups, and share them
here with you.  They are actual hardware problems, beginner problems, and
Vivado problems.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Actual Hardware Problems&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;Device not found.
&lt;a href=&quot;https://forum.digilentinc.com/topic/4095-cmod-a7-comms-problem/&quot;&gt;[1]&lt;/a&gt;
&lt;a href=&quot;https://forum.digilentinc.com/topic/3564-problem-with-detecting-arty-on-linux/&quot;&gt;[2]&lt;/a&gt;
&lt;a href=&quot;https://forum.digilentinc.com/topic/3749-programming-flash-cmod-a7/&quot;&gt;[3]&lt;/a&gt;&lt;/p&gt;

        &lt;p&gt;User’s seem to have a problem getting their tools set up properly.  I
certainly did.  One particular problem is basically, “I just plugged in
my device and my computer doesn’t recognize it.”  This is commonly caused
by an invalid or incomplete tool-suite setup.  However, it can be caused
by a bad USB cable.  So, usually, if the device &lt;em&gt;was&lt;/em&gt; working, it tends to
be instead a bad USB cable.  Strangely enough, bad USB cables a rather
common occurrence on the forums.&lt;/p&gt;

        &lt;p&gt;&lt;strong&gt;The solution&lt;/strong&gt;: It depends on the problem&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;There’s the FTDI request. 
&lt;a href=&quot;https://forum.digilentinc.com/topic/3658-digilent-nexys-video-ft2232-eeprom/&quot;&gt;[1]&lt;/a&gt;&lt;/p&gt;

        &lt;p&gt;Many individuals have tried, either by accident or on purpose, reflashing
the FTDI interface chip on their board and, as a result, have broken their
board so badly that it no longer responds to configuration commands.  The
solution to this problem is that the Digilent staff will send this user a
private message with the correct software to reload onto their device.&lt;/p&gt;

        &lt;p&gt;The strange part of this request is that I am aware of one user who
has successfully reprogrammed the FT2232 chip on his board, and
achieved much higher data throughput as a result.&lt;/p&gt;

        &lt;p&gt;&lt;strong&gt;The solution&lt;/strong&gt;: The Digilent staff provides a private message containing
instructions and/or data to fix this problem.&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Beginner problems&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;I need to build (some instructor’s problem statement).  Please help me.
&lt;a href=&quot;https://forum.digilentinc.com/topic/4110-ise-design-suite/&quot;&gt;[1]&lt;/a&gt;
&lt;a href=&quot;https://forum.digilentinc.com/topic/4104-basys-3/&quot;&gt;[2]&lt;/a&gt;&lt;/p&gt;

        &lt;p&gt;This request gets the least help from members on the forum.  The response
is usually a kind pointer to where the user documentation is at and
nothing more.&lt;/p&gt;

        &lt;p&gt;&lt;strong&gt;The solution&lt;/strong&gt;:  The student needs to do his own homework.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;Help me, my design doesn’t work.
&lt;a href=&quot;https://forum.digilentinc.com/topic/3991-usb-keyboard-on-basys3/&quot;&gt;[1]&lt;/a&gt;
&lt;a href=&quot;https://forum.digilentinc.com/topic/3731-nexys-4-to-pc-uart-communication/&quot;&gt;[2]&lt;/a&gt;
&lt;a href=&quot;https://forum.digilentinc.com/topic/3706-not-receiving-packets-in-echo-server-example-in-nexys-4-ddr-getting-started-with-microblaze-servers/&quot;&gt;[3]&lt;/a&gt;
&lt;a href=&quot;https://forum.digilentinc.com/topic/3666-artix-nexys-4-and-keyboard/&quot;&gt;[4]&lt;/a&gt;
&lt;a href=&quot;https://forum.digilentinc.com/topic/3675-arty-display-uart-data-on-leds/&quot;&gt;[5]&lt;/a&gt;&lt;/p&gt;

        &lt;p&gt;I’ll come back to this in a moment, but many students think that
an experienced engineer can just deskcheck their work and find the bug.
While I enjoy the challenge, and while I can often do this, it
certainly wasn’t how I became an &lt;em&gt;experienced&lt;/em&gt; engineer when working
with FPGAs.  I got there through simulation to make sure my logic
worked, and using a scope (or scopes) to make sure my simulation
matched the device.&lt;/p&gt;

        &lt;p&gt;&lt;strong&gt;The solution&lt;/strong&gt;: The solution is to simulate the design together with a
simulated peripheral.  This is often how I find bugs in students serial
port designs, for example.  I’ll connect their design to a &lt;a href=&quot;https://github.com/ZipCPU/wbuart32/blob/master/bench/cpp/uartsim.cpp&quot;&gt;serial port
simulator&lt;/a&gt;,
create a &lt;a href=&quot;https://en.wikipedia.org/wiki/Value_change_dump&quot;&gt;.vcd file&lt;/a&gt; for
viewing in &lt;a href=&quot;http://gtkwave.sourceforge.net&quot;&gt;gtkwave&lt;/a&gt;, and write back about
what I found.  There’s no reason why the student couldn’t have done this.&lt;/p&gt;

        &lt;p&gt;Perhaps I’ll post these results for the next student I help?&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;Asynchronous Reset
&lt;a href=&quot;https://forum.digilentinc.com/topic/3702-pc-to-basys3-via-uart-not-working-correctly/&quot;&gt;[1]&lt;/a&gt;&lt;/p&gt;

        &lt;p&gt;While Xilinx devices support an asynchronous reset to the logic, it’s so
unreliable that &lt;a href=&quot;https://forums.xilinx.com/t5/PLD-Blog/That-Dangerous-Asynchronous-Reset/ba-p/12856&quot;&gt;they recommend users not use it&lt;/a&gt;.  This is usually a
student’s first project on an actual FPGA, and a beginner’s mistake.&lt;/p&gt;

        &lt;p&gt;&lt;strong&gt;The solution&lt;/strong&gt;: Get rid of the &lt;em&gt;negedge&lt;/em&gt; &lt;em&gt;reset&lt;/em&gt; from any always block
dependencies.  Replace these with a combination of &lt;em&gt;initial&lt;/em&gt; statements and
(if necessary) synchronous resets.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;The logic Clock
&lt;a href=&quot;https://forum.digilentinc.com/topic/681-creating-a-25-mhz-clock-on-the-basys-3/&quot;&gt;[1]&lt;/a&gt;&lt;/p&gt;

        &lt;p&gt;Many new FPGA users aren’t quite aware the clocks are special things.
They then create logic wires internal to their design which they wish
to use to divide this clock rate.  While not a problem, such logic
wires don’t have the reliability of a clock, and transitioning on their
edges doesn’t produce the result you will want.  Where the problem comes
into play is when the student wants their logic to transition on the
positive (or worse negative) edge of this clock.&lt;/p&gt;

        &lt;p&gt;&lt;strong&gt;The solution&lt;/strong&gt;: &lt;a href=&quot;https://www.quora.com/What-is-the-function-of-a-strobe-function-in-digital-system&quot;&gt;a logic strobe&lt;/a&gt;.&lt;/p&gt;

        &lt;p&gt;This solution finds a lot of application in 1. beginning FPGA student
designs, and then again in 2. signal processing designs, where the
device’s clock speed is not synchronized to the FPGA’s clock, and hence
the data comes in from the sensor at a slower speed than the devices
clock speed.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;The student who hasn’t simulated their design&lt;/p&gt;

        &lt;p&gt;In this case, someone new to FPGA design has created some design and it
doesn’t work.  They don’t know why.  This one is similar to the Vivado
library component problem: they have no idea what’s going on internal
to the FPGA to answer the “why won’t my program work” question.&lt;/p&gt;

        &lt;p&gt;The solution they want to this problem is not the industry solution.
What these students want is for some kind soul on the forum to look at
their code and tell them what they are doing wrong.&lt;/p&gt;

        &lt;p&gt;&lt;strong&gt;The industry solution&lt;/strong&gt; to this problem is to simulate the code and any
peripherals it might be working with, and then as part of that to verify
that the logic works as intended.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;They don’t know how to simulate their problem
&lt;a href=&quot;https://forum.digilentinc.com/topic/3992-something-simple-is-apparently-impossible-incrdec-number/&quot;&gt;[1]&lt;/a&gt;&lt;/p&gt;

        &lt;p&gt;Sometimes the user is trying to work with a piece of hardware they’ve
never worked with before.  As a result, they have no simulation for this
hardware because they just aren’t all that familiar with how it works.
(A user button is a good example of this, since bouncing isn’t something
most people place into simulators.) In this case, their design doesn’t work
on the real hardware and, again, they don’t know why.&lt;/p&gt;

        &lt;p&gt;&lt;strong&gt;The solution&lt;/strong&gt; to this problem is twofold.  First, build a simulator that
encapsulates your understaning of the hardware from the diagrams and
specifications you have.  Second, when that first part fails, use some
form of a  scope to measure what is actually going on across the wires
to/from the hardware.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;Crossing clock domains&lt;/p&gt;

        &lt;p&gt;Few students have ever heard of &lt;a href=&quot;https://en.wikipedia.org/wiki/Metastability_in_electronics&quot;&gt;metastability
problems&lt;/a&gt;.  As
a result, they write code that crosses clock domains realizing that there
might be a problem associated with doing so.&lt;/p&gt;

        &lt;p&gt;&lt;strong&gt;The solution&lt;/strong&gt;: The simple solution is to clock every input at the new
clock twice before using it.  This works for some things, though not all.
A more complete discussion of how to deal with crossing from one clock
can be found in &lt;a href=&quot;http://www.sunburst-design.com/papers/CummingsSNUG2008Boston_CDC.pdf&quot;&gt;this
article&lt;/a&gt;.&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Vivado problems&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;The demo doesn’t build
&lt;a href=&quot;https://forum.digilentinc.com/topic/4090-error-with-pmod-oledrgb-demo/&quot;&gt;[1]&lt;/a&gt;&lt;/p&gt;

        &lt;p&gt;Typically this is caused by the user trying to build the demo design
using one version of Vivado, while the demo was instead built with
another version of Vivado.&lt;/p&gt;

        &lt;p&gt;&lt;strong&gt;The solution&lt;/strong&gt;: The Digilent staff share what version of Vivado was used
to build the demo.  Sometimes the demo has gotten old, and the Digilent
staff need to update it.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;They’ve integrated some component from the Vivado library into their design
and “it’s not working”
&lt;a href=&quot;https://forum.digilentinc.com/topic/4011-how-to-easily-implement-a-basic-low-pass-filter-using-fir-compiler-on-nexys-4-ddr/&quot;&gt;[1]&lt;/a&gt;
&lt;a href=&quot;https://forum.digilentinc.com/topic/3735-dds-compiler-60-ip-core-for-audible-sinewave/&quot;&gt;[2]&lt;/a&gt;&lt;/p&gt;

        &lt;p&gt;Of all the times I’ve seen this problem, it has yet to be that the
Xilinx provided IP component doesn’t work.  It’s more often that the
user isn’t feeding the component properly, or using the results from
the component properly.  Making the problem worse, rarely has the user
taken the time to instrument what is going on, so they have no clue
where their problem lies.&lt;/p&gt;

        &lt;p&gt;&lt;strong&gt;The solution&lt;/strong&gt;: a good internal scope, such as the
&lt;a href=&quot;https://github.com/ZipCPU/wbscope&quot;&gt;wishbone scope&lt;/a&gt; or the &lt;a href=&quot;https://github.com/ZipCPU/wbscope/blob/master/rtl/axi4lscope.v&quot;&gt;AXI-Lite
scope&lt;/a&gt;&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;The user can’t figure out how to add custom IP to the Vivado flow
&lt;a href=&quot;https://forum.digilentinc.com/topic/3961-how-to-add-own-logic-to-arty-board-flow/&quot;&gt;[1]&lt;/a&gt;&lt;/p&gt;

        &lt;p&gt;&lt;strong&gt;The solution&lt;/strong&gt;: Well, I might be biased here, but … my solution to
this problem has been not to use the broken Vivado design flow.
I’m sure I’ll discuss more of my problems with there processing flow
as time goes on.&lt;/p&gt;

        &lt;p&gt;One of the pleasant things about the &lt;a href=&quot;https://forum.digilentinc.com&quot;&gt;Digilent
forums&lt;/a&gt; is that these common requests
are dealt with in a friendly manner–even though I’m certain someone
must be rolling their eyes at seeing the same request &lt;em&gt;again&lt;/em&gt;.&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;I think I’ll come back to this over time, adding references to this this post
of Digilent Forum posts that illustrate my points here.&lt;/p&gt;
</description>
        <pubDate>Thu, 18 May 2017 00:00:00 -0400</pubDate>
        <link>http://zipcpu.com/digilent/2017/05/18/most-common-digilent-support-requests.html</link>
        <guid isPermaLink="true">http://zipcpu.com/digilent/2017/05/18/most-common-digilent-support-requests.html</guid>
        
        
        <category>digilent</category>
        
      </item>
    
      <item>
        <title>Cannot be done</title>
        <description>&lt;p&gt;One common request on Digilent is the, “Can I do XYZ on board ABC”?&lt;/p&gt;

&lt;p&gt;I really dislike answering questions of this type.  I’ve been surprised too many
times by someone doing what I thought was impossible.  Indeed, I’ve also had my
own opportunities to surprise others by doing things they thought were
impossible.&lt;/p&gt;

&lt;p&gt;A couple examples should illustrate this point:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;I gave up early on the idea of building a Video game on a &lt;a href=&quot;https://store.digilentinc.com/basys-3-artix-7-fpga-trainer-board-recommended-for-introductory-users/&quot;&gt;Basys-3
 board&lt;/a&gt;.
 I figured the task was just plain impossible: although you can make
 a 128kB of block RAM on the board, there wasn’t enough memory on
 the board for a 640x480 piece of video memory, with a bare minimum of four
 bits per pixel (256kB required) and the Basys-3 &lt;em&gt;only&lt;/em&gt; has the
 block RAM on board.&lt;/p&gt;

    &lt;p&gt;Since giving up, I discovered some individuals had done it.  Digging
 into those who were willing to share, I learned how they had done it. 
 They took the video stream, and wrote characters directly on the stream
 using FPGA hardware.  That way, there was no storage requirement.  I
 had already done something similar to place a mouse on the screen, so
 I shouldn’t have been as surprised as I was.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;When presenting at &lt;a href=&quot;https://orconf.org/2016/&quot;&gt;ORCONF&lt;/a&gt; some time ago, I had
 the opportunity to meet my first Digilent employee.  When I shared with him
 what &lt;a href=&quot;https://github.com/ZipCPU/s6soc&quot;&gt;I had done&lt;/a&gt; with their
 &lt;a href=&quot;https://store.digilentinc.com/store.digilentinc.com/cmod-s6-breadboardable-spartan-6-fpga-module&quot;&gt;CMod S6&lt;/a&gt;, and specifically how I had managed
 to place a multi-tasking O/S (as I called it) on the board, he was
 exceptionally impressed.  Particularly since he had written off the board as
 being unfit for this type of task.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The only question left, therefore, is where the next surprise is coming from.&lt;/p&gt;
</description>
        <pubDate>Thu, 18 May 2017 00:00:00 -0400</pubDate>
        <link>http://zipcpu.com/digilent/2017/05/18/cannnot-be-done.html</link>
        <guid isPermaLink="true">http://zipcpu.com/digilent/2017/05/18/cannnot-be-done.html</guid>
        
        
        <category>digilent</category>
        
      </item>
    
      <item>
        <title>Welcome to the ZipCPU blog!</title>
        <description>&lt;p&gt;Hello, and welcome to the ZipCPU blog!  This is my first blog post, and so it is
a chance to introduce myself, the ZipCPU, and some of the insights I’ve come 
across while
&lt;a href=&quot;https://forum.digilentinc.com/profile/1454-dn/&quot;&gt;answering help requests&lt;/a&gt;
on the &lt;a href=&quot;https://forum.digilentinc.com&quot;&gt;Digilent forums&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Since this is also my first blog, please feel free to &lt;a href=&quot;&amp;#109;&amp;#097;&amp;#105;&amp;#108;&amp;#116;&amp;#111;:&amp;#122;&amp;#105;&amp;#112;&amp;#099;&amp;#112;&amp;#117;&amp;#064;&amp;#103;&amp;#109;&amp;#097;&amp;#105;&amp;#108;&amp;#046;&amp;#099;&amp;#111;&amp;#109;&quot;&gt;write to
me&lt;/a&gt; regarding any errors you find in this web-site:
broken links, broken web code, etc.&lt;/p&gt;

&lt;p&gt;I am the owner of a small company, Gisselquist Technology, LLC, a services based
company focused on providing superior Computer Engineering and Signal Processing
Services to our customers.  I am also a 20 year veteran of the U.S. Air Force.
While in the Air Force, I sought out and worked on the most difficult
engineering challenges our nation faced.  Now, after a Ph.D. and 20 years of
service, I have focused my energies on the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt; and the environment,
toolsuite, and &lt;a href=&quot;https://github.com/ZipCPU&quot;&gt;peripherals&lt;/a&gt; necessary to support
both it and any customer applications.&lt;/p&gt;

&lt;p&gt;I’d like to use this blog to share some of the lessons I have learned over the
years.  These include both Digital Signal Processing topics, as well as FPGA
design topics.  While some of these topics may be self serving, such as how to
set up the ZipCPU, I’d like to address other topics which are often the subject
of Digilent forum requests.  I’m planning on my first topic being &lt;em&gt;how&lt;/em&gt; &lt;em&gt;to&lt;/em&gt;
&lt;em&gt;debug&lt;/em&gt; &lt;em&gt;an&lt;/em&gt; &lt;em&gt;FPGA&lt;/em&gt; &lt;em&gt;design&lt;/em&gt;, especially since so many junior engineering
students writing in to &lt;a href=&quot;https://forum.digilentinc.com&quot;&gt;Digilent’s forums&lt;/a&gt;
don’t seem to know how to do that.&lt;/p&gt;

&lt;p&gt;Over time, I’d also like to answer the question of how to achieve &lt;a href=&quot;https://forum.digilentinc.com/topic/4131-just-for-fun-frequency-resolution-challenge/&quot;&gt;very clear
frequency resolution&lt;/a&gt; when doing FFT processing, or &lt;a href=&quot;https://github.com/ZipCPU/interpolation/blob/master/tutorial.pdf&quot;&gt;how to build
a universal resampler&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Dan&lt;/p&gt;
</description>
        <pubDate>Wed, 17 May 2017 00:00:00 -0400</pubDate>
        <link>http://zipcpu.com/blog/2017/05/17/welcome.html</link>
        <guid isPermaLink="true">http://zipcpu.com/blog/2017/05/17/welcome.html</guid>
        
        
        <category>blog</category>
        
      </item>
    
  </channel>
</rss>
