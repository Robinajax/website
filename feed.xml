<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>The ZipCPU by Gisselquist Technology</title>
    <description>The ZipCPU blog, featuring how to discussions of FPGA and CPU design. This site will be focused on Verilog solutions, using exclusively OpenSource IP products for FPGA design.
</description>
    <link>http://zipcpu.com/</link>
    <atom:link href="http://zipcpu.com/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Wed, 19 Jul 2017 08:13:27 -0400</pubDate>
    <lastBuildDate>Wed, 19 Jul 2017 08:13:27 -0400</lastBuildDate>
    <generator>Jekyll v3.0.1</generator>
    
      <item>
        <title>A Basic Upsampling Linear Interpolator</title>
        <description>&lt;p&gt;Our &lt;a href=&quot;/dsp/2017/06/06/simple-interpolator.html&quot;&gt;last post on
interpolation&lt;/a&gt;
discussed how to &lt;a href=&quot;https://en.wikipedia.org/wiki/Sample_rate_conversion&quot;&gt;change the data
rate&lt;/a&gt; of a signal within
a system from one rate to another by using a &lt;a href=&quot;/dsp/2017/06/06/simple-interpolator.html&quot;&gt;sample and hold
interpolator&lt;/a&gt;.
If you’ve spent much time working with Digital Signal Processing (DSP)
algorithms, you’ll understand that this approach offers absolutely no
&lt;a href=&quot;https://en.wikipedia.org/wiki/Aliasing&quot;&gt;antialiasing protection&lt;/a&gt;.
Sure, it works, but it’s not necessarily how you will want to build a quality
system.&lt;/p&gt;

&lt;p&gt;As an example, let’s consider a simple waveform, drawn below in blue.&lt;/p&gt;

&lt;table style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 1: The Original (Sampled) Signal&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/original.png&quot; alt=&quot;Original (Sampled) Signal&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;This waveform has been sampled at the green dot locations.&lt;/p&gt;

&lt;p&gt;If we now used the &lt;a href=&quot;/dsp/2017/06/06/simple-interpolator.html&quot;&gt;sample and
hold&lt;/a&gt;
algorithm to resample this signal, we’d get
a result looking like the red dots in Fig 2.&lt;/p&gt;

&lt;table style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 2: Sample and Hold&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/sample-and-hold.png&quot; alt=&quot;Sample and Hold Resampling&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;While we could center the diagram, and thereby do a nearest neighbour
interpolation (Fig 3),&lt;/p&gt;

&lt;table style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 3: Nearest Neighbour&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/nearest-neighbour.png&quot; alt=&quot;Nearest Neighbour Resampling&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;the result just doesn’t look much better.  It still doesn’t look anything like
our original signal, shown in blue.&lt;/p&gt;

&lt;p&gt;For this post, let’s try to do one better.  Let’s build a upsampling
interpolator, that will &lt;a href=&quot;https://en.wikipedia.org/wiki/Linear_interpolation&quot;&gt;linearly
interpolate&lt;/a&gt; between two
data points.&lt;/p&gt;

&lt;h2 id=&quot;what-is-a-linear-interpolator&quot;&gt;What is a Linear Interpolator&lt;/h2&gt;

&lt;p&gt;Linear interpolators are very similar to the child’s “dot-to-dot” method of
drawing, where a picture is given with numbered dots, and the child must
draw a line from one dot to the next.  The resulting waveform might look
very much like Fig 2 below.&lt;/p&gt;

&lt;table style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 4: Linear Upsampling&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/dot-to-dot.png&quot; alt=&quot;Linear Upsampling&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;If we now sample this waveform, using an upsampler, we should get the black
dots shown in Fig 5.&lt;/p&gt;

&lt;table style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 5: Linear Resampling&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/linear-up.png&quot; alt=&quot;Linear Resampler&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Or, if you have a higher oversampling rate (i.e. more green dots), it might
look like Fig 3 below:&lt;/p&gt;

&lt;table style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 6: Linear Resampling, lower frequency signal&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/hslinear-up.png&quot; alt=&quot;Figure of Linear Resampler applied to a lower frequency signal&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;At this point, you can see how our sampler starts to track the incoming signal
a lot better.&lt;/p&gt;

&lt;p&gt;The equation for a linear upsampler, one that generates a line between two
given sample points, is straightforward:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;n = floor(t/Ts);
y(t/Ts) = x[n] + (t/Ts-n)(x[n+1]-x[n]);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;where samples are spaced by &lt;code class=&quot;highlighter-rouge&quot;&gt;Ts&lt;/code&gt; seconds apart.&lt;/p&gt;

&lt;p&gt;To get a feel for this equation, consider what happens when &lt;code class=&quot;highlighter-rouge&quot;&gt;t=nTs&lt;/code&gt;.  In
that case, the linear term drops to zero and the result is &lt;code class=&quot;highlighter-rouge&quot;&gt;x[n]&lt;/code&gt;.  On the
other hand, if &lt;code class=&quot;highlighter-rouge&quot;&gt;t&lt;/code&gt; is infinitesimally less than &lt;code class=&quot;highlighter-rouge&quot;&gt;t=(n+1)Ts&lt;/code&gt;, then &lt;code class=&quot;highlighter-rouge&quot;&gt;t/Ts-n&lt;/code&gt;
will evaluate to &lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;y(t/Ts)&lt;/code&gt; will evaluate the &lt;code class=&quot;highlighter-rouge&quot;&gt;x[n+1]&lt;/code&gt;.  In other
words, this equation simply describes a series of line segments connecting
&lt;code class=&quot;highlighter-rouge&quot;&gt;x[n]&lt;/code&gt; to &lt;code class=&quot;highlighter-rouge&quot;&gt;x[n+1]&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The linear sampler we are going to build today will return the values
&lt;code class=&quot;highlighter-rouge&quot;&gt;y(kV/Ts)&lt;/code&gt;, for some new sample interval &lt;code class=&quot;highlighter-rouge&quot;&gt;V &amp;lt; Ts&lt;/code&gt;, just likes Figs 5 and 6 above
demonstrate.&lt;/p&gt;

&lt;p&gt;This leaves us with two challenges:  The first is evaluating the equation for
upsampling, and the second problem is figuring how how to do this evaluation
every &lt;code class=&quot;highlighter-rouge&quot;&gt;V&lt;/code&gt; seconds to produce an output.&lt;/p&gt;

&lt;h2 id=&quot;handling-the-incoming-clock&quot;&gt;Handling the incoming clock&lt;/h2&gt;

&lt;p&gt;The first step towards building this interpolator is to calculate &lt;code class=&quot;highlighter-rouge&quot;&gt;n&lt;/code&gt; and
&lt;code class=&quot;highlighter-rouge&quot;&gt;(k (V/Ts)-n)&lt;/code&gt;.  Well, not quite.  Practically, there is no need to know
&lt;code class=&quot;highlighter-rouge&quot;&gt;n&lt;/code&gt; itself.  Indeed, without an absolute time to reference everything to,
&lt;code class=&quot;highlighter-rouge&quot;&gt;n&lt;/code&gt; is quite arbitrary.  That leaves &lt;code class=&quot;highlighter-rouge&quot;&gt;k (V/Ts) -n&lt;/code&gt;.  Let’s call this number
&lt;code class=&quot;highlighter-rouge&quot;&gt;dt&lt;/code&gt; to facilitate our discussion.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;dt&lt;/code&gt; is a number whose value goes from zero to one, and then suddenly back
to zero again.&lt;br /&gt;
In other words, we can keep track of this number in a similar manner to the
way we kept track of the &lt;a href=&quot;/dsp/2017/06/15/no-pi-for-you.html&quot;&gt;phase of a sine
wave&lt;/a&gt; earlier.  To
do this, we’ll keep track of a number between 0 and 2^N-1, which is given by
&lt;code class=&quot;highlighter-rouge&quot;&gt;2^N dt&lt;/code&gt;.
To this number, on each clock, we’ll add &lt;code class=&quot;highlighter-rouge&quot;&gt;2^N(V/Ts)&lt;/code&gt; to it (rounded to the
nearest integer, of course).  Then, when this
number overflows &lt;code class=&quot;highlighter-rouge&quot;&gt;N&lt;/code&gt; bits, we’ll wait for the next sample (i.e. for &lt;code class=&quot;highlighter-rouge&quot;&gt;floor(t)&lt;/code&gt;
to go from &lt;code class=&quot;highlighter-rouge&quot;&gt;n&lt;/code&gt; to &lt;code class=&quot;highlighter-rouge&quot;&gt;n+1&lt;/code&gt;, before using the new phase.&lt;/p&gt;

&lt;p&gt;Let’s define a register, &lt;code class=&quot;highlighter-rouge&quot;&gt;i_counter&lt;/code&gt;, to hold the integer portion of this
number, &lt;code class=&quot;highlighter-rouge&quot;&gt;2^N dt&lt;/code&gt;.  You can make &lt;code class=&quot;highlighter-rouge&quot;&gt;N&lt;/code&gt; as big as you need to in order to make
this work.  Likewise, we’ll define &lt;code class=&quot;highlighter-rouge&quot;&gt;i_step&lt;/code&gt; to hold the delta 2^N(V/Ts).&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;i_step = 2^N (int)(V/Ts)&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Now, with these two values, we can calculate the offset from the top
of the last sample:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	pre_ce &amp;lt;= i_ce;

always @(posedge i_clk)
	if (i_ce)
		// r_ovfl will get set on any overflow
		{ r_ovfl, r_counter } &amp;lt;= r_counter + i_step;
	else if (!r_ovfl)
		{ r_ovfl, r_counter } &amp;lt;= r_counter + i_step;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Notice how, when any new sample arrives, we update our counter (and produce
an output).  Likewise, until the update overflows, we’ll keep updating the
counter and producing an output.&lt;/p&gt;

&lt;p&gt;This sounds confusing.&lt;/p&gt;

&lt;p&gt;Perhaps a picture might help.  See Fig 7 below.&lt;/p&gt;

&lt;table style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 7: Resampling clock&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/upsampling-clock.svg&quot; alt=&quot;Upsampling clock described&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;This figure shows incoming samples coming in at one sample every four
system clocks.  In this example, the output clocks take place every three
system clocks.  Hence, the output “clock” (really a logic pulse) must be
separated by 3/4 distance between input samples.  Let’s trace this distance
from the incoming clock from where the two are minimally aligned:
0, 3/4, (next input sample) 1/2,
(next input sample) 1/4, (next input sample) 0, and then it repeats.  One
trick to building this upsampler will be waiting for the next sample when
we need a next sample, or otherwise creating a new sample if we don’t need to
wait.  That’s what’s going on with &lt;code class=&quot;highlighter-rouge&quot;&gt;r_ovfl&lt;/code&gt; above.&lt;/p&gt;

&lt;p&gt;Fig 8 below shows another figure for you to consider.  In this case, each
incoming sample
takes 8 system clocks, and we want to upsample that amount to create an
output every 3 system clocks.  Feel free to work out the math, although
in the end it’s roughly the same as the previous math.&lt;/p&gt;

&lt;table style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 8: Higher rate upsampling&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/faster-upsampling-clock.svg&quot; alt=&quot;Higher rate upsampling clock described&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;h2 id=&quot;the-incoming-samples&quot;&gt;The Incoming Samples&lt;/h2&gt;

&lt;p&gt;When an incoming sample comes in, we’ll need to keep track of not only
&lt;code class=&quot;highlighter-rouge&quot;&gt;x[n]&lt;/code&gt;, but also the slope, &lt;code class=&quot;highlighter-rouge&quot;&gt;x[n+1]-x[n]&lt;/code&gt;, between our samples.  This
implies that within an FPGA, we’ll need to keep track of &lt;code class=&quot;highlighter-rouge&quot;&gt;x[n+1]&lt;/code&gt; as the
latest sample (&lt;code class=&quot;highlighter-rouge&quot;&gt;r_next&lt;/code&gt;), and set our “current” sample, &lt;code class=&quot;highlighter-rouge&quot;&gt;x[n]&lt;/code&gt;, to the last
value of &lt;code class=&quot;highlighter-rouge&quot;&gt;x[n+1]&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Indeed, this part is just that simple:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
if (i_ce)
begin
	r_next &amp;lt;= i_data;		// r_next = x[n+1]
	r_last &amp;lt;= r_next;		// r_last = x[n]
	r_slope &amp;lt;= i_data - r_next;	// r_slope = x[n+1] - x[n]
end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;We’re also going to need to know if an output value needs to be produced.
Remember from before how some input samples produced multiple outputs, while
others produced only a single output?
In the case of what we are up to, every sample moves us forward by a fraction
of the incoming sample.  Once the counter overflows, then it’s time for a new
incoming sample.  Between the time when the first sample shows up, and the
last sample gets produced, we’ll produce an output.&lt;/p&gt;

&lt;p&gt;Let’s capture the logic of when we’ll need to produce an output, and
keep it synchronized with our input logic (&lt;code class=&quot;highlighter-rouge&quot;&gt;r_next&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;r_last&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;r_slope&lt;/code&gt;, etc.)
above.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	r_ce &amp;lt;= ((pre_ce)||(!r_ovfl));&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h2 id=&quot;doing-the-multiply&quot;&gt;Doing the multiply&lt;/h2&gt;

&lt;p&gt;At this point we have our last input value, &lt;code class=&quot;highlighter-rouge&quot;&gt;r_last&lt;/code&gt;, and our slope &lt;code class=&quot;highlighter-rouge&quot;&gt;r_slope&lt;/code&gt;.
We also have our offset:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	if (r_ce)
		r_offset &amp;lt;= r_counter;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;From these two pieces of information, we should be able to create our
new output point:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;n&quot;&gt;output&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r_offset&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r_slope&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r_last&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The problem is that hardware multiplies are usually the most expensive and
time consuming operation on an FPGA and so they tend to define the overall
clock speed.  Hence, it can be difficult to multiply &lt;em&gt;and&lt;/em&gt; add in the same
clock.  Therefore, for this next clock, we’ll simply do the multiply and copy
&lt;code class=&quot;highlighter-rouge&quot;&gt;r_last&lt;/code&gt; for adding to the result on the next clock.&lt;/p&gt;

&lt;p&gt;We’ll also copy our last data value, &lt;code class=&quot;highlighter-rouge&quot;&gt;r_last&lt;/code&gt; so that it is available to
us on the next clock cycle.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	always @(posedge i_clk)
	if (r_ce)
	begin
		x_base   &amp;lt;= r_last;	// x[n]
		x_offset &amp;lt;= r_slope * r_offset; // (t-n)*(x[n+1]-x[n])
	end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Our output from this stage will be valid any time our inputs are valid, or
more realistically any time we were intending to produce an output.  We’ll
push that timing signal forward for the next clock.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	x_ce &amp;lt;= r_ce;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h2 id=&quot;creating-the-final-result&quot;&gt;Creating the final result&lt;/h2&gt;

&lt;p&gt;Now that we have our last sample and the product of the slope times the
time delta, we can calculate an output by adding these two values together.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	if (x_ce)
		o_value &amp;lt;= x_base + x_offset;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;We can also create a signal letting us know when this result will be valid.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	o_ce &amp;lt;= x_ce;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;That’s the basics of the algorithm.  How hard can it be?&lt;/p&gt;

&lt;h2 id=&quot;the-missing-details&quot;&gt;The Missing Details&lt;/h2&gt;

&lt;p&gt;How hard can it be?  A &lt;em&gt;lot&lt;/em&gt; harder.  Indeed, I had to work with the code
for about two days before I eventually got it working.&lt;/p&gt;

&lt;p&gt;We’ll come back to this post, therefore, and discuss:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Bit growth: how adds and multiplies increase the number of bits in a value&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Signed vs Unsigned multiplication&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;How to drop bits.  In other words, if you have 16-bit samples in, this
routine might give you 32-bit samples out … if you don’t drop some bits.
How exactly to do this, without creating artifacts, isn’t as simple as it
sounds.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;How to debug a DSP design (hint: you’ll want to use something like
Matlab or (my OpenSource favorite) GNU octave&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;For now, hold your finger on this design.  We’ll come back to it.&lt;/p&gt;

</description>
        <pubDate>Wed, 19 Jul 2017 00:00:00 -0400</pubDate>
        <link>http://zipcpu.com/dsp/2017/07/19/linear-upsampling.html</link>
        <guid isPermaLink="true">http://zipcpu.com/dsp/2017/07/19/linear-upsampling.html</guid>
        
        
        <category>dsp</category>
        
      </item>
    
      <item>
        <title>Verilator doesn&#39;t find everything (today)</title>
        <description>&lt;p&gt;So, my thought from last week was that I might be able to post something about
using push-buttons on an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;,
and the problems they struggle with. 
Specifically, I wanted to discuss
&lt;a href=&quot;https://en.wikipedia.org/wiki/Switch#Contact_bounce&quot;&gt;bouncing&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The &lt;a href=&quot;https://github.com/ZipCPU/dbgbus&quot;&gt;debugging bus&lt;/a&gt;
&lt;a href=&quot;/blog/2017/06/29/sw-dbg-interface.html&quot;&gt;we just created&lt;/a&gt;
provides the perfect environment for evaluating button
&lt;a href=&quot;https://en.wikipedia.org/wiki/Switch#Contact_bounce&quot;&gt;bouncing&lt;/a&gt;,
and so I started to put a post together on the topic.  But … I
wanted to add something more on the topic beyond what I had read of this
phenomena.  I wanted to add scope/traces of signals
&lt;a href=&quot;https://en.wikipedia.org/wiki/Switch#Contact_bounce&quot;&gt;bouncing&lt;/a&gt;,
and even share the code so that anyone could download it and try it and see
how their own development board responded when a button was pressed.&lt;/p&gt;

&lt;p&gt;Sounds neat, right?&lt;/p&gt;

&lt;p&gt;But doing this required I run the debugging
&lt;a href=&quot;https://github.com/ZipCPU/dbgbus/blob/master/bench/rtl/testbus.v&quot;&gt;test bus&lt;/a&gt;
(with modifications for catching
&lt;a href=&quot;https://en.wikipedia.org/wiki/Switch#Contact_bounce&quot;&gt;bouncing&lt;/a&gt;
components), on my hardware.  In this case, I was going to use the &lt;a href=&quot;http://store.digilentinc.com/arty-artix-7-fpga-development-board-for-makers-and-hobbyists&quot;&gt;Digilent
Arty&lt;/a&gt;,
for a demonstration,
although the test should run on any
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;,
with a UART and I may try out some
others to see if the button performance I am getting is any different.&lt;/p&gt;

&lt;p&gt;My first surprise came when I tried building the new/modified project
using Vivado: I was quickly reminded that things that work with
&lt;a href=&quot;https://www.veripool.org/wiki/verilator&quot;&gt;Verilator&lt;/a&gt;
may not always always work with your build tools.&lt;/p&gt;

&lt;h2 id=&quot;what-was-different&quot;&gt;What was different&lt;/h2&gt;

&lt;p&gt;I found a couple differences between
&lt;a href=&quot;https://www.veripool.org/wiki/verilator&quot;&gt;Verilator&lt;/a&gt; and Vivado this week:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://www.veripool.org/wiki/verilator&quot;&gt;Verilator&lt;/a&gt;
doesn’t detect when a wire (or register) is being set in multiple places.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://www.veripool.org/wiki/verilator&quot;&gt;Verilator&lt;/a&gt;
can’t always tell the difference between wires and registers.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;I am aware of a third difference as well: in Xilinx, all unspecified flip
flops start initially with a value of &lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt;. 
&lt;a href=&quot;https://www.veripool.org/wiki/verilator&quot;&gt;Verilator&lt;/a&gt;
starts with what appears to be random values.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Given that &lt;a href=&quot;https://www.veripool.org/wiki/verilator&quot;&gt;Verilator&lt;/a&gt; is an open
source project, and that posts on the web (like this one) seem to live forever,
these differences may be gone by the time you read this post.&lt;/p&gt;

&lt;p&gt;I’ve since &lt;a href=&quot;https://github.com/ZipCPU/dbgbus/commits/master&quot;&gt;updated&lt;/a&gt; the
&lt;a href=&quot;https://github.com/ZipCPU/dbgbus&quot;&gt;debugging bus project&lt;/a&gt; with these changes,
so that it now works.  I also found a bug or two in the software support.  Those
have also been changed, and so the whole now works on real hardware (i.e., on
my &lt;a href=&quot;http://store.digilentinc.com/arty-artix-7-fpga-development-board-for-makers-and-hobbyists&quot;&gt;Digilent
Arty&lt;/a&gt;).&lt;/p&gt;

&lt;p&gt;If you’d like to see the changes, please feel free to browse the project’s
&lt;a href=&quot;https://github.com/ZipCPU/dbgbus/commits/master&quot;&gt;GitHub log&lt;/a&gt;.
There you’ll find a set of six changes that were made to the debugging bus
in order to get it to synthesize and work.&lt;/p&gt;

&lt;h2 id=&quot;i-still-love-verilator&quot;&gt;I still love Verilator&lt;/h2&gt;

&lt;p&gt;These differences aren’t deterring me from using
&lt;a href=&quot;https://www.veripool.org/wiki/verilator&quot;&gt;Verilator&lt;/a&gt;.
How could they?
&lt;a href=&quot;https://www.veripool.org/wiki/verilator&quot;&gt;Verilator&lt;/a&gt;
still finds most of the bugs in any design in the time it takes Vivado
to &lt;em&gt;start&lt;/em&gt; synthesizing my code.  It can also find bugs that Vivado doesn’t
find (bus width mis-match, for example).  So I still love
&lt;a href=&quot;https://www.veripool.org/wiki/verilator&quot;&gt;Verilator&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;My point is that, as of today, it doesn’t find everything.  Things that work in
&lt;a href=&quot;https://www.veripool.org/wiki/verilator&quot;&gt;Verilator&lt;/a&gt;
will &lt;em&gt;usually&lt;/em&gt; work in your hardware, but not always.&lt;/p&gt;

&lt;p&gt;But … that’s one of the purposes of a
&lt;a href=&quot;blog/2017/06/08/simple-scope.html&quot;&gt;logic scope&lt;/a&gt;, right? 
Such a scope will help you debug what’s going on within your design when the
simulation and the hardware don’t act the same.&lt;/p&gt;

</description>
        <pubDate>Mon, 17 Jul 2017 00:00:00 -0400</pubDate>
        <link>http://zipcpu.com/blog/2017/07/17/debugging-dbgbus.html</link>
        <guid isPermaLink="true">http://zipcpu.com/blog/2017/07/17/debugging-dbgbus.html</guid>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>Design Needs when Debugging a SoftCore CPU</title>
        <description>&lt;p&gt;Building your own &lt;a href=&quot;https://en.wikipedia.org/wiki/Soft_microprocessor&quot;&gt;soft
core&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt; within an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
can be a tremendous learning experience.  Doing so will provide you with an
in-depth insight into how a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;
works that may be difficult to come by otherwise.&lt;/p&gt;

&lt;p&gt;As you consider the requirements of the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;
you would like to build, let
me also recommend that you consider what it will take to debug your
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt; early
on.  It might keep you from rebuilding parts and pieces of your
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt; later.&lt;/p&gt;

&lt;p&gt;Sure, there’s component testing to make sure the components of the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt; work,
but what will it take to actually debug the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;–in
both hardware &lt;em&gt;and&lt;/em&gt; software?&lt;/p&gt;

&lt;p&gt;Let’s look at this from two different standpoints.  First, what do you need
to debug a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;
in general, and specifically what operations will your debugger
need to be able to perform.  Second, what are the different contexts that you
will need in order to debug your
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;?&lt;/p&gt;

&lt;h2 id=&quot;debugging-needs&quot;&gt;Debugging needs&lt;/h2&gt;

&lt;p&gt;If you’ve ever used a debugger, the debugger typically offers you several things
you can do with your program.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Reboot&lt;/strong&gt;:  You can start or restart the program.  On an embedded
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt; that
doesn’t support multiple independent programs, this may mean issuing a
command to reboot
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Step&lt;/strong&gt;: The
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;
will then either start, or start in a stopped state.
While in this stopped state, you should be able to step your
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;
forward through its instructions.&lt;/p&gt;

    &lt;p&gt;This often means something different depending upon context.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Stop on Breakpoint&lt;/strong&gt;: Stepping through a long list of instructions,
such as a bootloader loading a program from ROM into RAM, before you get to
the logic you actually want to debug can be a real drag.  For this reason,
debuggers offer the capability to set and clear breakpoints within your
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;.&lt;/p&gt;

    &lt;p&gt;The idea is basically this: once a breakpoint is set, the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;
can be let loose to run.  When the CPU hits the breakpoint, it will halt
and bring up the debugger for you to examine where it is at.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Examine CPU State&lt;/strong&gt;: Any time the CPU, or the program the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt; is running,
is stopped, the user should then be able to examine the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;’s state.  This
may mean examining the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Processor_register&quot;&gt;registers&lt;/a&gt;
of a register based
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;,
or the stack of a &lt;a href=&quot;https://en.wikipedia.org/wiki/Stack_machine&quot;&gt;stack
based CPU&lt;/a&gt;—perhaps even both.&lt;/p&gt;

    &lt;p&gt;For example, on the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;,
the assembly level debugger brings up a view of all 32
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Processor_register&quot;&gt;registers&lt;/a&gt;,
and the current instruction sequence (See Figs 1 or 2 below).  One of the
two debugging views (Fig 2) also shows
a couple variables on the top of the stack as well.&lt;/p&gt;

    &lt;p&gt;When evaluating the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;
within simulation, you’ll also want to see internal
variables that aren’t typically considered an “official” part of the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;
state, but yet form a part of the state that you need in order to debug it.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Continue&lt;/strong&gt;: If you’ve stopped the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;,
you’ll also want the ability to
restart it after you’ve examined what is going on within the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Trace&lt;/strong&gt;: This isn’t normally a considered a debugger capability, and
probably won’t find this support within your typical debugger,
yet being able to get a trace of what’s going on within your
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;.
is an important part of fault diagnosis.&lt;/p&gt;

    &lt;p&gt;Creating a trace file on a fault is actually my only method of debugging the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;
when dealing with an interrupt context, simply because it can be &lt;em&gt;so&lt;/em&gt;
difficult to predict when an interrupt takes place, or to stop and examine
the &lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;
on that interrupt along the way.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Your debugging support will need at least one more item of support, and that
item isn’t really a debugging &lt;em&gt;operation&lt;/em&gt;.  Specifically, you’ll want some
way of reading the source code your
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;
is running as you debug your program.  Currently, the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
has disassembly support and not source level support.
The reason is simply this: it’s easier to build an assembly level debugger
than it is to build a source level debugger.&lt;/p&gt;

&lt;p&gt;These are the things I’ve found useful when trying to debug the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Keep in mind, this is by no means a comprehensive list of all the tools you
might want or need to debug your
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;.
However, you might find it to be a
sufficient list to get you started–particularly because certain items on
this list will require hardware support, and you may want to think about
this support early in your
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;.
design phase.&lt;/p&gt;

&lt;h2 id=&quot;debugging-contexts&quot;&gt;Debugging Contexts&lt;/h2&gt;

&lt;p&gt;From my own experience, I have found that there are three separate contexts
for debugging a computer program on a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;.  The
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
supports two of these contexts, and I have plans to support the third.&lt;/p&gt;

&lt;p&gt;These are listed below:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Simulator&lt;/strong&gt;: The first context you will want to debug your
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt; within
is within a simulator.  Sure, the simulator isn’t nearly as fast as the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;,
but within a simulator your debugger should be able to access the
values of &lt;em&gt;every&lt;/em&gt; internal variable within your design.&lt;/p&gt;

    &lt;table style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 1: Debugging ZipCPU under Verilator&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/zipdbg-simtest.png&quot; alt=&quot;The ZipCPU debugger under Verilator&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

    &lt;p&gt;The problem I struggled with is that there are only so many characters on the
screen.  As a result, some of the items on the screen tend to be somewhat
cryptic.  For example, consider the “PFCACH: v=0000007f” item below
the user registers.  This tells me that the seven lowest number instruction
&lt;a href=&quot;https://en.wikipedia.org/wiki/Cache_(computing)&quot;&gt;cache&lt;/a&gt;
lines are valid.  Cryptic, right?&lt;/p&gt;

    &lt;p&gt;Still, even through this view is somewhat cryptic, each item on the screen
was useful to me (at some time) to learn and know what was going on within
the &lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;.
In particular, these many items were really easy to add to the
screen when I needed them.&lt;/p&gt;

    &lt;p&gt;In spite of the cryptic information within the screen, you can still see
all of the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
registers: sR0 throught sPC, and uR0 through uPC.  You can
also see the instructions each of the various stages are working on,
as well as the fact that each stage is being clocked (Ck on the left).&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Hardware&lt;/strong&gt;: Once you place
your &lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;
initially onto a piece of hardware, you’ll want access to the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;
to debug it.  This means that you want to be
able to support all of your typical debugging actions, enumerated in the
last section, yet you’ll want to be able to invoke those operations from
an external computer connected to your
&lt;a href=&quot;https://en.wikipedia.org/wiki/Soft_microprocessor&quot;&gt;soft-core&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;.&lt;/p&gt;

    &lt;p&gt;Remember the &lt;a href=&quot;https://github.com/ZipCPU/dbgbus&quot;&gt;debugging bus&lt;/a&gt; we put
together?  I use a similar &lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/rtl/wbubus.v&quot;&gt;debugging
bus&lt;/a&gt; to debug the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;.&lt;/p&gt;

    &lt;p&gt;Of course, some things of necessity will change when you debug things in
hardware.  Two examples will prove this point: First, you are not likely to
have access to every wire within your design  when you wish to examine your
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;
state.  For this reason, the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; debugger,
&lt;a href=&quot;https://github.com/ZipCPU/openarty/blob/master/sw/zipdbg.cpp&quot;&gt;zipdbg&lt;/a&gt;,
provides access to all 32-registers within the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;,
but not all that much more.  Second, your peripherals may not take well to
stepping them by individual clock ticks.  Hence memory interactions may
need to be stepped through, one interaction at a time.  For the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;,
this has meant that the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;
can only step by single instructions, rather
than by individual clock ticks, when debugging the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt; within the
hardware.&lt;/p&gt;

    &lt;table style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 2: Debugging ZipCPU on the Arty&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/zipdbg-arty-cputest.png&quot; alt=&quot;The ZipCPU debugger under Verilator&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Software&lt;/strong&gt;: What I mean by the &lt;em&gt;Software&lt;/em&gt; context is that of a debugger,
such as &lt;a href=&quot;https://www.gnu.org/software/dbg/&quot;&gt;gdb&lt;/a&gt;, running natively from
software within your
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;
and applied to debugging another process running on your
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;.&lt;/p&gt;

    &lt;p&gt;While this might take some work to build, it’s worth considering when you
design your processor whether or not you want your processor to eventually
support this type of capability.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;One thing that will throw a thorn in all of these context’s, though, is that
you may struggle to know what is happening on or within your
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt; when it
responds to an interrupt.  Sure, there’s a way to deal with this, but
interrupts can make debugging via either hardware or software less than
truly realistic.  This is where the capability of creating a full-speed
trace becomes important.&lt;/p&gt;

&lt;h2 id=&quot;all-together&quot;&gt;All together&lt;/h2&gt;

&lt;p&gt;To wrap this up, Figure 3 (below) places these ideas in a conceptual
graphic, to help draw this discussion to memory.  Notice that all of the
operations we’ve discussed are shown on the left, and the three separate
contexts are shown across the top.&lt;/p&gt;

&lt;table style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 3: Debugging Operations and Contexts&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/cpu-dbg-needs.svg&quot; alt=&quot;Types of CPU Debugger Support&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;One thing the chart doesn’t show is that the columns (contexts) aren’t totally
independent.  Before you leave your simulator debugging context, you’ll want
to make sure that you have proven that your hardware debugging interface works
within the simulator.  Likewise, before you move from the hardware debugging
context to work on software debugging, you’ll want to double check, via either
the hardware or simulator contexts, that the support you’ve placed within your
&lt;a href=&quot;https://en.wikipedia.org/wiki/Central_processing_unit&quot;&gt;CPU&lt;/a&gt;
for software debugging actually works.&lt;/p&gt;

&lt;p&gt;Perhaps I should mention that this is not my first attempt at putting this
post together.  On my first attempt, I tried to describe how to perform
&lt;em&gt;every&lt;/em&gt; one of the operations in &lt;em&gt;every&lt;/em&gt; one of the contexts shown in Fig 3.
The result was too much information for a single post.  For now, just realize
that there’s a different story behind each box on the chart, each choice of
context and operation.&lt;/p&gt;

</description>
        <pubDate>Fri, 14 Jul 2017 00:00:00 -0400</pubDate>
        <link>http://zipcpu.com/zipcpu/2017/07/14/cpu-debugging-needs.html</link>
        <guid isPermaLink="true">http://zipcpu.com/zipcpu/2017/07/14/cpu-debugging-needs.html</guid>
        
        
        <category>zipcpu</category>
        
      </item>
    
      <item>
        <title>The simplest sine wave generator within an FPGA</title>
        <description>&lt;p&gt;Ever need a sine wave when working within an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;?  When
you see the solution to this problem presented below, you may never use a
canned digital synthesizer again.&lt;/p&gt;

&lt;h2 id=&quot;digital-oscillator-phase&quot;&gt;Digital Oscillator phase&lt;/h2&gt;

&lt;p&gt;The first step to building this synthesizer is creating the phase input
for the sine wave you wish to create.&lt;/p&gt;

&lt;p&gt;We’ve already discussed the ideal units for phase within an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
&lt;a href=&quot;/dsp/2017/06/15/no-pi-for-you.html&quot;&gt;here&lt;/a&gt;.
Basically, you’ll want to keep track of phase in a digital unit that
naturally wraps at your word width, N.  (We’ll arbitrarily choose to use
&lt;code class=&quot;highlighter-rouge&quot;&gt;N=32&lt;/code&gt; for our examples below.)  To convert from radians to these digital
units, simply multiple by 2^N and divide by 2PI.  Likewise to convert from
degrees to these digital units, multiple by 2^N and divide by 360.&lt;/p&gt;

&lt;p&gt;Frequency in a digital synthesis system is nothing more than a
change in phase.  Hence, a phase can change by a small delta on
every clock cycle to create the frequency you need.  Something
like the following will work well.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;reg [31:0]	phase;
// The initial value is usually irrelevant
always @(posedge clock)
	// Allow for an D/A running at a lower speed from your FPGA
	if (sample_clock_ce)
		phase &amp;lt;= phase + frequency_step;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This assumes you have a signal (&lt;code class=&quot;highlighter-rouge&quot;&gt;sample_clock_ce&lt;/code&gt;) that is &lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt; anytime the DAC
needs an output, and &lt;code class=&quot;highlighter-rouge&quot;&gt;0&lt;/code&gt; otherwise.  This will allow you to work with
slower signal rates than your system clock rate if necessary.  You can
also just set the &lt;code class=&quot;highlighter-rouge&quot;&gt;sample_clock_ce&lt;/code&gt;
value to a constant &lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt; in order process samples at your
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;’s
clock rate.&lt;/p&gt;

&lt;p&gt;The right frequency step will depend upon your sample clock rate.
Note, this rate may be slower than your
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;’s
system clock rate.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;frequency_step = 2^N * frequency_hz / sample_clock_rate_hz&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;To make certain we have the formula right, consider a frequency which is
at the Nyquist sample rate of one half of your sample clock rate.  This
frequency should take two steps to wrap back to where it came from.
Looking at the frequency step above, in this case the frequency step would
become &lt;code class=&quot;highlighter-rouge&quot;&gt;2^(N-1)&lt;/code&gt; and two steps (&lt;code class=&quot;highlighter-rouge&quot;&gt;2*frequency_step&lt;/code&gt;) would indeed wrap back
around.  Smaller steps should naturally represent lower frequencies.&lt;/p&gt;

&lt;p&gt;Let’s assume a 100MHz sample clock rate for the sake of discussion.&lt;/p&gt;

&lt;p&gt;If you choose to represent both phase and frequency step with &lt;code class=&quot;highlighter-rouge&quot;&gt;N=32&lt;/code&gt; bits,
you can represent any frequency between zero and your sample clock rate
divided by two, with a precision given by:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;frequency_precision_hz = sample_clock_rate_hz / 2^N&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This is nothing more than solving for the frequency associated with the
difference between two steps.  Equivalently, this is the frequency associated
with a step of one, or the smallest frequency that this approach can generate.&lt;/p&gt;

&lt;p&gt;If our system has a 100MHz sample rate clock, a 32-bit frequency step would
allow us to represent &lt;em&gt;any&lt;/em&gt; frequency between zero and 50MHz in steps of
about 0.02 Hz.&lt;/p&gt;

&lt;p&gt;Not bad, but how about generating a sine wave from this phase?&lt;/p&gt;

&lt;h2 id=&quot;the-no-more-logic-solution&quot;&gt;The “No more logic” Solution&lt;/h2&gt;

&lt;p&gt;Since I offered this post as the “Simplest Sine Wave Generator”, I feel
compelled to provide the following solution:&lt;/p&gt;

&lt;p&gt;If you don’t want to use any more logic than your phase generator requires,
then just output the top bit of the phase accumulator.  That’ll give you a
square wave at the frequency you want — with 0.02Hz precision.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;assign	sinewave = phase[31];&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;As this isn’t really much of a sine wave, but rather a square wave, let’s
continue looking for a better alternative.&lt;/p&gt;

&lt;h2 id=&quot;digital-oscillator-frequency-output&quot;&gt;Digital Oscillator frequency output&lt;/h2&gt;

&lt;p&gt;Now that we know the phase of our outgoing digital oscillator, it’s time
to generate the sine wave itself.  Since an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
offers free lookup tables, let’s use them to generate our sine wave.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge clock)
	if (sample_clock_ce)
		sinewave &amp;lt;= sinewave_table[phase[31:24];&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Notice that we only used the top 8-bits from the phase.  This keeps our logic
simple, while still giving you the full 0.02 Hz resolution we had above.  While
we could use an 8-bit phase accumulator alone, that would’ve only given us
frequency steps in the 400kHz range.&lt;/p&gt;

&lt;p&gt;What happens with the 32-bit phase is that eventually the upper 8-bits will
repeat or skip steps as necessary to provide the frequency resolution you want.&lt;/p&gt;

&lt;p&gt;Gosh, that was so easy, we could end this post right there.  The task is done!&lt;/p&gt;

&lt;p&gt;Before leaving the topic, though, let’s examine two more items: First, let’s
look at the mechanics of setting the sinewave table above, and second let’s
make some rough estimates as to the cost and performance of the synthesizer.&lt;/p&gt;

&lt;h2 id=&quot;how-to-set-the-table&quot;&gt;How to set the table?&lt;/h2&gt;

&lt;p&gt;Since all of the logic is captured within that sinewave table, perhaps we
should spend some time working out how to set the values of the table.
In general, there are three basic approaches for setting the values of the
table.  All three are roughly equivalent in the functionality they will use.&lt;/p&gt;

&lt;p&gt;The first approach is to build a giant case statement:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge clock)
if (sample_clock_ce)
	case(phase[31:24])
	8&#39;h00:  sinewave &amp;lt;= 7&#39;h00;
	8&#39;h01:  sinewave &amp;lt;= 7&#39;h01;
	8&#39;h02:  sinewave &amp;lt;= 7&#39;h03;
	...
	8&#39;h40:  sinewave &amp;lt;= 7&#39;h3f;
	...
	8&#39;h80:  sinewave &amp;lt;= 7&#39;h00;
	...
	8&#39;hc0:  sinewave &amp;lt;= 7&#39;h41;
	...
	8&#39;hfe:  sinewave &amp;lt;= 7&#39;h7d;
	8&#39;hff:  sinewave &amp;lt;= 7&#39;h7f;
	endcase&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The synthesizer will turn the logic from this case statement into the table
lookup implementation we want.&lt;/p&gt;

&lt;p&gt;The second approach would be to use an actual table read-only register
array, and to set all of the values of the table with individual values
of the sine wave as we want it.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;reg	[6:0]	table [0:255];

initial table[0] = 7&#39;h00;
initial table[1] = 7&#39;h01;
initial table[2] = 7&#39;h03;
initial table[3] = 7&#39;h04;
initial table[4] = 7&#39;h06;
// etc.&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This approach, though, get’s old &lt;em&gt;really&lt;/em&gt; fast–especially if you are building
it by hand.  A better approach is to use $readmemh.  (Be aware, in my
experience Xilinx’s ISE can’t handle $readmemh.)&lt;/p&gt;

&lt;p&gt;Using $readmemh, you’ll create a hexadecimal text file first.  In our case,
it would probably look something like:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;@00000000 00 01 03 04 06 07 09 0a 0c 0d 0f 10 12 13 15 16 
@00000010 18 19 1a 1c 1d 1f 20 21 23 24 25 26 27 29 2a 2b 
@00000020 2c 2d 2e 2f 30 31 32 33 34 35 36 36 37 38 38 39 
@00000030 3a 3a 3b 3b 3c 3c 3d 3d 3d 3e 3e 3e 3e 3e 3e 3e 
@00000040 3f 3e 3e 3e 3e 3e 3e 3e 3d 3d 3d 3c 3c 3b 3b 3a 
@00000050 3a 39 38 38 37 36 36 35 34 33 32 31 30 2f 2e 2d 
@00000060 2c 2b 2a 29 27 26 25 24 23 21 20 1f 1d 1c 1a 19 
@00000070 18 16 15 13 12 10 0f 0d 0c 0a 09 07 06 04 03 01 
@00000080 00 7f 7d 7c 7a 79 77 76 74 73 71 70 6e 6d 6b 6a 
@00000090 68 67 66 64 63 61 60 5f 5d 5c 5b 5a 59 57 56 55 
@000000a0 54 53 52 51 50 4f 4e 4d 4c 4b 4a 4a 49 48 48 47 
@000000b0 46 46 45 45 44 44 43 43 43 42 42 42 42 42 42 42 
@000000c0 41 42 42 42 42 42 42 42 43 43 43 44 44 45 45 46 
@000000d0 46 47 48 48 49 4a 4a 4b 4c 4d 4e 4f 50 51 52 53 
@000000e0 54 55 56 57 59 5a 5b 5c 5d 5f 60 61 63 64 66 67 
@000000f0 68 6a 6b 6d 6e 70 71 73 74 76 77 79 7a 7c 7d 7f &lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The first part of the line indicates where in the array the coming values
will be placed, whereas the rest of the line consists of values to be placed
in the array separated by spaces.&lt;/p&gt;

&lt;p&gt;Then, to use this approach, you’ll need one more line within your
Verilog code to read and set your array:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;initial $readmemh(&quot;table.hex&quot;, table);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;where &lt;code class=&quot;highlighter-rouge&quot;&gt;table.hex&lt;/code&gt; is the name of your hexadecimal text file.&lt;/p&gt;

&lt;p&gt;Given that you are trying to make a sine wave, and that a sine is a rather
complex function, you might want to create this table via a C++ program
instead of by hand (I did).  Just remember: the maximum sine wave value needs
to be +/- 63 since it’s the maximum 7-bit value that has an identical positive
and negative integer value.&lt;/p&gt;

&lt;h2 id=&quot;estimating-the-cost-of-the-synthesizer&quot;&gt;Estimating the Cost of the Synthesizer&lt;/h2&gt;

&lt;p&gt;While we’re essentially done here, having presented how to generate a quick
and simple sine wave, let’s spend another moment or too looking at how many
table entries we want (32, 64, 128, or 256), as well as how many bits wide
the elements in the table should be.&lt;/p&gt;

&lt;p&gt;In general, this will cost us one look up table per output bit in for each
output sample our sinewave.
However, on the Xilinx architecture, two output bits can share a 6-LUT if
they share the same 5-bit inputs.  Likewise it takes two 6-LUTs to look up
a seven bit value, and four 6-LUTs to look up an 8-bit value. 
&lt;a href=&quot;/blog/2017/06/12/minimizing-luts.html&quot;&gt;[Ref]&lt;/a&gt; Let’s examine
the two ends of these possibilities therefore.&lt;/p&gt;

&lt;p&gt;If we were to use 5-bit lookup tables, we’d have only &lt;code class=&quot;highlighter-rouge&quot;&gt;2^5=32&lt;/code&gt; entries to the 
sine wave table.  A table size of 32 would allow us to divide the unit circle
up into steps separated by &lt;code class=&quot;highlighter-rouge&quot;&gt;11 degrees&lt;/code&gt;.
This means that your sinewave would jump by at most &lt;code class=&quot;highlighter-rouge&quot;&gt;0.195&lt;/code&gt; in value from one
phase to the next.  Representing something with this level of precision only
takes about 4 bits, so this lookup would cost two 6-LUTs total.&lt;/p&gt;

&lt;p&gt;That’s pretty cheap.  The 32-bit phase update logic would likely cost more
LUTs (16) than that.&lt;/p&gt;

&lt;p&gt;At the other end of the spectrum, suppose we wanted to use 8-bits of phase.
We’d then be able to represent things at &lt;code class=&quot;highlighter-rouge&quot;&gt;360/2^8=1.4 degree&lt;/code&gt; intervals.  The
biggest jump in the sine wave would be about &lt;code class=&quot;highlighter-rouge&quot;&gt;0.024&lt;/code&gt; units. Representing such
a number with that level of precision could easily be done with 7 bits. 
Hence, this approach would cost &lt;code class=&quot;highlighter-rouge&quot;&gt;28 6-LUTs&lt;/code&gt;.  That’s still pretty cheap,
although now it costs more than phase calculation.&lt;/p&gt;

&lt;h2 id=&quot;better-approaches-are-available&quot;&gt;Better Approaches are Available&lt;/h2&gt;

&lt;p&gt;Our focus today has been on what it takes to generate a &lt;em&gt;really&lt;/em&gt; cheap and
simple sine wave within an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;.
At &lt;code class=&quot;highlighter-rouge&quot;&gt;28 LUTs&lt;/code&gt; for the synthesizer and &lt;code class=&quot;highlighter-rouge&quot;&gt;16 LUTs&lt;/code&gt; to track phase, I think we did
just that.&lt;/p&gt;

&lt;p&gt;However, if you want to generate a higher quality sine wave, then you
might wish to switch from a simple table look up to a
&lt;a href=&quot;http://www.andraka.com/files/crdcsrvy.pdf&quot;&gt;CORDIC approach&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Perhaps we should come back and discuss that approach later?
&lt;a href=&quot;http://www.andraka.com/files/crdcsrvy.pdf&quot;&gt;CORDIC&lt;/a&gt;’s
aren’t that hard to build, and they make an excellent lesson for the
beginner in how to design
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
based algorithms.&lt;/p&gt;

</description>
        <pubDate>Tue, 11 Jul 2017 00:00:00 -0400</pubDate>
        <link>http://zipcpu.com/dsp/2017/07/11/simplest-sinewave-generator.html</link>
        <guid isPermaLink="true">http://zipcpu.com/dsp/2017/07/11/simplest-sinewave-generator.html</guid>
        
        
        <category>dsp</category>
        
      </item>
    
      <item>
        <title>Getting Started with the Wishbone Scope</title>
        <description>&lt;p&gt;Ever found yourself stuck with an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
design that didn’t work and no idea why not?  This seems to be a &lt;a href=&quot;/fpga-hell.html&quot;&gt;common
problem&lt;/a&gt; within
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
design.  Perhaps
the design works within a simulator.  Perhaps you don’t know how to simulate
the hardware component the design is working with.  Either way, you will
want to know how to somehow draw information out of the broken design to
see where it fails.&lt;/p&gt;

&lt;p&gt;We’ll show an example of how to do that here, using two primary components to
make this happen.  The first is any device or simulation imeplementing a
generic &lt;a href=&quot;https://github.com/ZipCPU/dbgbus/blob/master/sw/devbus.h&quot;&gt;DEVBUS&lt;/a&gt;
interface into a wishbone bus implemneted within your
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;.
If you don’t have such an interface as part of your design, the
&lt;a href=&quot;https://github.com/ZipCPU/dbgbus/tree/master/hexbus&quot;&gt;HEXBUS&lt;/a&gt;
interface should still suite your purposes nicely, although it will require
a serial port to communicate on.  The second necessary component is a
&lt;a href=&quot;https://github.com/ZipCPU/wbscope&quot;&gt;wishbone scope&lt;/a&gt;, which you can access
using the &lt;a href=&quot;https://github.com/ZipCPU/dbgbus/blob/master/sw/devbus.h&quot;&gt;DEVBUS&lt;/a&gt;
interface.&lt;/p&gt;

&lt;p&gt;There are two parts required to adding a
&lt;a href=&quot;https://github.com/ZipCPU/wbscope&quot;&gt;wishbone scope&lt;/a&gt; into your design, the 
&lt;a href=&quot;/blog/2017/06/22/simple-wb-interconnect.html&quot;&gt;Verilog
integration&lt;/a&gt;
and the &lt;a href=&quot;https://github.com/ZipCPU/dbgbus/blob/master/sw/memscope.cpp&quot;&gt;software
component&lt;/a&gt;.
The first part is to connect the scope to your design: both by selecting
wires from within your design that you wish to examine, as well as identifying
trigger logic within your design to know when to capture those wires.
(The block RAM used to capture a trace isn’t unlimited.)
The second part is the logic necessary to read that capture off of the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;,
and format it into a &lt;a href=&quot;https://en.wikipedia.org/wiki/Value_change_dump&quot;&gt;VCD file&lt;/a&gt;
that you can use to view your data on a clock for clock basis using
&lt;a href=&quot;http://gtkwave.sourceforge.net&quot;&gt;gtkwave&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;We’ll walk through the two steps separately, and then show an example
of using them to view a bus interaction.&lt;/p&gt;

&lt;h2 id=&quot;changes-to-your-design&quot;&gt;Changes to your design&lt;/h2&gt;

&lt;p&gt;There are only four basic changes to your design that you’ll need to make in
order to connect a
&lt;a href=&quot;https://github.com/ZipCPU/wbscope&quot;&gt;wishbone scope&lt;/a&gt; into your
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt; design.&lt;/p&gt;

&lt;p&gt;First, you’ll need to add the scope to your &lt;a href=&quot;https://github.com/ZipCPU/dbgbus/blob/master/bench/rtl/testbus.v&quot;&gt;wishbone
interconnect&lt;/a&gt;
within your design.  This involves six basic points of adjustment:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;You’ll need to decode the scope’s address.  I like to create an address
select line (not to be confused with the byte SELect linse), indicating
that the current address references the scope.  Make sure that ADDR[0]
is not a part of this computation, as the scope needs that line to
determine which internal register is being accessed.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;You’ll need to add the scope to the design, and wire the wishbone inputs
to the scope.  The STB line from the wishbone master needs to be gated
(anded) with the address select logic result.  The scope requires only
one ADDR bit, so no others need to be connected.  The wishbone outputs:
ACK, STALL, and DATA will be declared and connected.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The ACK line needs to be logically OR’d with other ACK lines within your
design.  This logic should already exist, if you have a working wishbone
interconnect, so follow along there and see what’s required.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;As with the ACK, the DATA line needs to be integrated into the bus
data return.  In particular, the bus data return to the master should
contain the scope’s data anytime time the scope’s ACK line is true.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Because the
&lt;a href=&quot;https://github.com/ZipCPU/wbscope&quot;&gt;wishbone scope&lt;/a&gt; will never stall the
bus, you can technically
ignore the STALL line.  For form and maintainability, though, you’ll
probably want to use this line to create the wishbone master’s STALL
return line.  This is usually created by a large OR of every device’s
address decode line AND’ed with their STALL line.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;I often use a touch of logic to determine whether or not many ACK’s are
begin returned at once, if more than one device is selected, or if no
devices are selected.  This logic will need to be adjusted as well.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;If you are going to use the scope that already exists within the
&lt;a href=&quot;https://github.com/ZipCPU/dbgbus/blob/master/rtl/testbus.v&quot;&gt;DBGBUS&lt;/a&gt;’s
test infrastructure, all of this logic has already been taken care of for you.
For more details, we also discussed how to do this in &lt;a href=&quot;/blog/06/22/simple-wb-interconnect.html&quot;&gt;the article on building
a simple wishbone
interconnect&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The second step is deciding what you wish to trigger on.  This is as simple
a piece of logic as you wish.  Within the
&lt;a href=&quot;https://github.com/ZipCPU/dbgbus/blob/master/rtl/testbus.v&quot;&gt;DBGBUS&lt;/a&gt;’s
implementation, you’ll find a line that looks like:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;assign scope_trigger = (mem_sel)&amp;amp;&amp;amp;(wb_stb);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This triggers the scope on any attempt to reference the block RAM peripheral
within the testbus, although what you choose to trigger on is up to you.
Want to trigger on any time the wishbone error is set as an example?  The
following logic would do that:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;assign scope_trigger = (wb_err);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;We’ll stick to the former, though.&lt;/p&gt;

&lt;p&gt;Third, you’ll want to select those wires that you want to capture and
record.  These wires can be anything you are interested in within your design.
In our case, we’re going to capture some signals from within the
wishbone bus’s interaction.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;assign	debug_data = { wb_cyc, wb_stb, wb_we, wb_ack, wb_stall,
		wb_addr[5:0], 1&#39;b1,
		wb_odata[9:0],
		wb_idata[9:0] };&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The &lt;a href=&quot;https://github.com/ZipCPU/wbscope&quot;&gt;wishbone scope&lt;/a&gt;
fixes this amount of debug data at 32-bits per clock, otherwise we might have
grabbed more of this bus interaction.  If you need more, you should be able to
using multiple &lt;a href=&quot;https://github.com/ZipCPU/wbscope&quot;&gt;scopes&lt;/a&gt;
at the same time to achieve a wider capture.&lt;/p&gt;

&lt;p&gt;As a final step, you can limit the
&lt;a href=&quot;https://github.com/ZipCPU/wbscope&quot;&gt;scope&lt;/a&gt; so that it only captures data any
time a particular bit is true within your design.  This capability is very
useful for digital signal processing applications, where the data of interest
may not exist on every clock.  This is the &lt;code class=&quot;highlighter-rouge&quot;&gt;i_ce&lt;/code&gt; input to the scope. 
For this simple example, we’ll keep this set to ‘1’.&lt;/p&gt;

&lt;p&gt;While we aren’t going to reconfigure the basic
&lt;a href=&quot;https://github.com/ZipCPU/wbscope&quot;&gt;wishbone scope&lt;/a&gt; for this example, there
are several configuration parameters that can be set.  These parameters
include:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;The log of the size of the memory within the scope, LGMEM.  By default, this
is set to 10, so by default the scope will use 2^10 words of block RAM.
Powers of two from anywhere between 2^2 and 2^31 are possible–with the
natural consequence being that your actual
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
hardware will limit how memory you can actually use.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Whether or not the scope is synchronous with your wishbone clock or not.
This is the SYNCHRONOUS flag.  It defaults to true (&lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt;).  If you ever need
to collect data on one clock and read it on another, then set this to
zero.  That will trigger the inclusion of a lot of clock transfer logic
within the design.&lt;/p&gt;

    &lt;p&gt;For our design, we’ll leave this at the default as a synchronous scope,
but that will also require the same &lt;code class=&quot;highlighter-rouge&quot;&gt;i_clk&lt;/code&gt; parameter being passed to the
core twice.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The default holdoff parameter sets the initial holdoff of the scope. 
This holdoff parameter may be changed at a later time by simply writing the
new holdoff to the control register.  Setting it within a parameter just
sets the initial value of the holdoff register.&lt;/p&gt;

    &lt;p&gt;If the holdoff is set to zero, the trigger will be aligned with the last
data sample in the scope’s memory.  As the holdoff time is increased,
the trigger location will move towards the beginning of the scope’s memory.&lt;/p&gt;

    &lt;p&gt;As another way to put it, once triggered, the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
waits for a number of
clocks given by the holdoff value before stopping its collect.  Hence, a
holdoff of zero can be used to capture any logic leading up to an event,
whereas a holdoff of the size of the buffer will capture any logic
immediately following an event.&lt;/p&gt;

    &lt;p&gt;The default parameter value for the default holdoff places the trigger
near the middle of the collect.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;That’s it!  That’s all you need to do to set up a
&lt;a href=&quot;https://github.com/ZipCPU/wbscope&quot;&gt;wishbone scope&lt;/a&gt; within the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
part of your design.&lt;/p&gt;

&lt;h2 id=&quot;the-software-controller&quot;&gt;The software controller&lt;/h2&gt;

&lt;p&gt;To use the &lt;a href=&quot;https://github.com/ZipCPU/wbscope&quot;&gt;Wishbone scope&lt;/a&gt;, you’ll also
want to set up a software controller to handle the communication between the
design, and to reformat the result into whatever you wish it to be.
This is the purpose of the
&lt;a href=&quot;https://github.com/ZipCPU/wbscope&quot;&gt;scope&lt;/a&gt;
software controller.  It is also specific to the logic you’ve chosen to
capture, so this section will show you how to set it up.&lt;/p&gt;

&lt;p&gt;When I initially used the &lt;a href=&quot;https://github.com/ZipCPU/wbscope&quot;&gt;Wishbone scope&lt;/a&gt;
in my earlier projects, all the scope controller ever did was to check that
the scope had indeed been triggered, and then dump every piece of data that
had been collected to the terminal.&lt;/p&gt;

&lt;p&gt;At one time, I wrote a new software controller every time I needed a scope
within my design.  If you wander through my designs, you can even find
examples of these older scope controllers, such as &lt;a href=&quot;https://github.com/ZipCPU/xulalx25soc/blob/master/sw/ramscope.cpp&quot;&gt;this
example&lt;/a&gt;
 that I used when debugging an &lt;a href=&quot;https://github.com/ZipCPU/xulalx25soc/blob/master/rtl/wbsdram.v&quot;&gt;SDRAM
controller&lt;/a&gt;.
These controller’s, though, all had the same logic:&lt;/p&gt;

&lt;p&gt;Step one: Check if the scope is ready to be read, and exit if not.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m_fpga&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;readio&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;R_SCOPE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mh&quot;&gt;0x60000000&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x60000000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Scope is not yet ready&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;exit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Step two: Calculate the size of the scope and allocate a buffer&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;n&quot;&gt;lglen&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;20&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x01f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;scoplen&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lgln&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;buf&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;DEVBUS&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;BUSW&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;scoplen&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Step three: Read the scope’s memory from the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;,
transferring it from the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
to a buffer on your local computer.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;n&quot;&gt;m_fpga&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;readz&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;R_SCOPD&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;scoplen&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;buf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Step four: Decode the scope’s data&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;scoplen&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;// Do something to printf buf[i] to the screen
&lt;/span&gt;	&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;After a while, though, I found myself cut/copy and pasting the same code
from one controller to the next. 
Just the code above created a &lt;em&gt;lot&lt;/em&gt; of boilerplate.&lt;/p&gt;

&lt;p&gt;To help get reduce the amount of boilerplate code, the scope now has a
&lt;a href=&quot;https://github.com/ZipCPU/wbscope/blob/master/sw/scopecls.cpp&quot;&gt;controller scope
class&lt;/a&gt;.
Since building that &lt;a href=&quot;https://github.com/ZipCPU/wbscope/blob/master/sw/scopecls.cpp&quot;&gt;scope control
class&lt;/a&gt;,
the scope’s capabilities have
significantly increased.  For example, the scope controller can now
create a &lt;a href=&quot;https://en.wikipedia.org/wiki/Value_change_dump&quot;&gt;VCD file&lt;/a&gt;.
It can now identify which sample produced the trigger
(thanks to some &lt;a href=&quot;https://github.com/ZipCPU/wbscope/blob/master/bench/cpp/wbscope_tb.cpp&quot;&gt;bench
testing&lt;/a&gt;, and so it can place the inferred
trigger into the &lt;a href=&quot;https://en.wikipedia.org/wiki/Value_change_dump&quot;&gt;VCD file&lt;/a&gt;
as well.  So let’s instead discuss how to interact with this &lt;a href=&quot;https://github.com/ZipCPU/wbscope/blob/master/sw/scopecls.cpp&quot;&gt;scope controller
object&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The first step to using this
&lt;a href=&quot;https://github.com/ZipCPU/wbscope/blob/master/sw/scopecls.cpp&quot;&gt;controller&lt;/a&gt;.
framework is to create your own
subclass of the
&lt;a href=&quot;https://github.com/ZipCPU/wbscope/blob/master/sw/scopecls.cpp&quot;&gt;controller&lt;/a&gt;.
to desccibe your particular wire choices within your RTL logic.&lt;/p&gt;

&lt;p&gt;For the example we are working with, we’ll call this controller subclass a
&lt;a href=&quot;https://github.com/ZipCPU/dbgbus/blob/master/sw/memscope.cpp&quot;&gt;MEMSCOPE&lt;/a&gt;–since
it’s going to look at interactions with the block RAM memory.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt;	&lt;span class=&quot;nc&quot;&gt;MEMSCOPE&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SCOPE&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;MEMSCOPE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;FPGA&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fpga&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;addr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SCOPE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fpga&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;addr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{};&lt;/span&gt;
	&lt;span class=&quot;o&quot;&gt;~&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;MEMSCOPE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The scope object is created with a pointer to the FPGA object implementing the
&lt;a href=&quot;https://github.com/ZipCPU/dbgbus/blob/master/sw/devbus.h&quot;&gt;DEVBUS&lt;/a&gt;
interface, together with the address of where this scope is within
our wishbone bus.&lt;/p&gt;

&lt;p&gt;Two virtual methods then need to be overloaded.  The first method, called
decode(), simply decodes the scope wires onto stdout.  This is where the
printf() interface I used to use ends up.  The difference, though, is that
the &lt;a href=&quot;https://github.com/ZipCPU/wbscope/blob/master/sw/scopecls.cpp&quot;&gt;class&lt;/a&gt;
takes care of reading from the &lt;a href=&quot;https://github.com/ZipCPU/wbscope&quot;&gt;scope&lt;/a&gt;,
calculating the memory
address, as well as marking where the trigger is.  To make this work,
be careful not to end any of the printf()’s within your decode function
with a newline.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;k&quot;&gt;virtual&lt;/span&gt;	&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;MEMSCOPE&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;decode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;DEVBUS&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;BUSW&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;val&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;cyc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stb&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;we&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ack&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stall&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;addr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;odata&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;idata&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

	&lt;span class=&quot;n&quot;&gt;cyc&lt;/span&gt;   &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;31&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;stb&lt;/span&gt;   &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;30&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;we&lt;/span&gt;    &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;29&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;ack&lt;/span&gt;   &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;28&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;stall&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;27&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;addr&lt;/span&gt;  &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;21&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;mh&quot;&gt;0x3f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;odata&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;mh&quot;&gt;0x3ff&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;idata&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;val&lt;/span&gt;      &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;mh&quot;&gt;0x3ff&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

	&lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;%s&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cyc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;?&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;CYC&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;   &quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot; %s&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;stb&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;?&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;STB&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;   &quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot; %s&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;we&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;?&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;W&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;R&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;[@....%02x]...%03x-&amp;gt;...%03x&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;addr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;odata&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;idata&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot; %s&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ack&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;?&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;ACK&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;   &quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot; %s&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;stall&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;?&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;(STALL)&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;       &quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The second method that needs to be overloaded is the define_traces() method.
This is where the connection is made between your design and the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Value_change_dump&quot;&gt;VCD file&lt;/a&gt;
the
&lt;a href=&quot;https://github.com/ZipCPU/wbscope/blob/master/sw/scopecls.cpp&quot;&gt;scope object&lt;/a&gt;
can generate.  To make this possible, the
&lt;a href=&quot;https://github.com/ZipCPU/wbscope/blob/master/sw/scopecls.cpp&quot;&gt;scope object&lt;/a&gt;
offers a register_trace() function.  register_trace() takes three arguments.
The first is the name of the wire or trace that’s being defined.
The second argument specifies how many bits the trace has of the 32 the
scope has captured.   The third and final argument
specifies which bit position this value starts at.
Hence, we can define all of our traces with a simple:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;k&quot;&gt;virtual&lt;/span&gt;	&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;MEMSCOPE&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;define_traces&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;register_trace&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;wb_cyc&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;    &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;31&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;register_trace&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;wb_stb&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;    &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;30&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;register_trace&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;wb_we&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;     &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;29&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;register_trace&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;wb_ack&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;    &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;28&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;register_trace&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;wb_stall&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;  &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;27&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;register_trace&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;wb_addr&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;   &lt;span class=&quot;mi&quot;&gt;6&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;21&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;register_trace&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;wb_odata&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;register_trace&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;wb_idata&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;  &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;All that remains is to create and run this &lt;a href=&quot;https://github.com/ZipCPU/dbgbus/blob/master/sw/memscope.cpp&quot;&gt;scope
controller&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Creating it is simple, after connecting to your
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
and creating an object supporting the
&lt;a href=&quot;https://github.com/ZipCPU/dbgbus/blob/master/sw/devbus.h&quot;&gt;DEVBUS interface&lt;/a&gt;,
you can just create the new scope from a pointer to the
&lt;a href=&quot;https://github.com/ZipCPU/dbgbus/blob/master/sw/devbus.h&quot;&gt;DEVBUS&lt;/a&gt;
and the &lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
address of &lt;a href=&quot;https://github.com/ZipCPU/wbscope&quot;&gt;the scope&lt;/a&gt;:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;n&quot;&gt;MEMSCOPE&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;scope&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MEMSCOPE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_fpga&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;R_SCOPE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;You can check whether or not
&lt;a href=&quot;https://github.com/ZipCPU/wbscope&quot;&gt;the scope&lt;/a&gt;
is ready to be read with a simple&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;scope&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ready&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Scope is not yet ready:&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Otherwise we’ll simply print our results, and write out a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Value_change_dump&quot;&gt;VCD file&lt;/a&gt;:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;scope&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;

	&lt;span class=&quot;n&quot;&gt;scope&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;writevcd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;scopd.vcd&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;That’s it!  That’s all the software required to use
&lt;a href=&quot;https://github.com/ZipCPU/wbscope&quot;&gt;the Wishbone scope&lt;/a&gt;
and to capture and output a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Value_change_dump&quot;&gt;VCD file&lt;/a&gt;
containing the scope information.&lt;/p&gt;

&lt;h2 id=&quot;trying-it-out&quot;&gt;Trying it out&lt;/h2&gt;

&lt;p&gt;Let’s use this with the
&lt;a href=&quot;https://github.com/ZipCPU/dbgbus&quot;&gt;debugging bus interface&lt;/a&gt; &lt;a href=&quot;https://github.com/ZipCPU/dbgbus/blob/master/bench/rtl/testbus.v&quot;&gt;example
design&lt;/a&gt;,
and show how we can pull the data we need out of the design.&lt;/p&gt;

&lt;p&gt;You’ll first need to build the example design.  To do this, you’ll need to
have &lt;a href=&quot;https://gcc.gnu.org&quot;&gt;g++&lt;/a&gt;,
&lt;a href=&quot;https://www.veripool.org/wiki/verilator&quot;&gt;Verilator&lt;/a&gt;,
&lt;a href=&quot;https://git-scm.com&quot;&gt;git&lt;/a&gt;, and
&lt;a href=&quot;http://gtkwave.sourceforge.net&quot;&gt;GTKWave&lt;/a&gt; installed.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;git clone https://github.com/ZipCPU/dbgbus
&lt;span class=&quot;nb&quot;&gt;cd &lt;/span&gt;dbgbus
make&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;We’ll demonstrate grabbing
&lt;a href=&quot;https://github.com/ZipCPU/wbscope&quot;&gt;the scope&lt;/a&gt;’s
output while running the
&lt;a href=&quot;https://www.veripool.org/wiki/verilator&quot;&gt;Verilator&lt;/a&gt;,
simulation, although you could use this with your
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
just as well.
Indeed, if your
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
is connected to the TCP/IP port that our
&lt;a href=&quot;https://www.veripool.org/wiki/verilator&quot;&gt;Verilator&lt;/a&gt;,
simulation is using, then you can interact with your
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
with no changes.
The first step will be to start the simulation in one window:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span class=&quot;nb&quot;&gt;cd &lt;/span&gt;bench/cpp
./testbus_tb&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Were you trying to do this on an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;,
you’d instead use the
&lt;a href=&quot;https://github.com/ZipCPU/dbgbus/blob/master/sw/netuart.cpp&quot;&gt;netuart&lt;/a&gt;
program to bridge a serial port on your FPGA to the TCP/IP port that our
&lt;a href=&quot;https://github.com/ZipCPU/dbgbus/blob/master/sw/devbus.h&quot;&gt;DEVBUS&lt;/a&gt;
software interface will interact with.&lt;/p&gt;

&lt;p&gt;Either way, your next step will be to move to another window and interact
with your &lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;.
If you are using the &lt;a href=&quot;https://github.com/ZipCPU/dbgbus/blob/master/bench/rtl/testbus.v&quot;&gt;DBGBUS
demo&lt;/a&gt;,
you’ll need to either read or write from the memory to trigger the scope:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span class=&quot;nb&quot;&gt;cd &lt;/span&gt;sw/
./wbregs mem 0xdeadbeef&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Now that the scope has finished its collection (even in simulation it’s
pretty quick from trigger to stop), let’s use our &lt;a href=&quot;https://github.com/ZipCPU/dbgbus/blob/master/sw/memscope.cpp&quot;&gt;scope
controller&lt;/a&gt;
to grab the result:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;./memscope&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This will take a couple of moments to read the data from the simulation.
(It’s a lot faster when using real hardware.)  On my computer it can take
close to a full minute, but that might be very CPU dependent.&lt;/p&gt;

&lt;p&gt;The result, though, will be a file &lt;code class=&quot;highlighter-rouge&quot;&gt;scopd.vcd&lt;/code&gt;.  To examine this, just type&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;gtkwave scopd.vcd&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;With a little work with gtkwave, here’s what our results look like:&lt;/p&gt;

&lt;table style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 1: Example Output using MEMSCOPE&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/memscope.png&quot; alt=&quot;Example Scope Output&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;h2 id=&quot;thats-it&quot;&gt;That’s it!&lt;/h2&gt;

&lt;p&gt;Did you see how easy that was?  The only hard part was
&lt;a href=&quot;/blog/2017/06/05/wb-bridge-overview.html&quot;&gt;building the means to communicate between the FPGA and your host
PC&lt;/a&gt;.  After that,
all that you really needed to do was to add the
&lt;a href=&quot;https://github.com/ZipCPU/wbscope&quot;&gt;wishbone scope&lt;/a&gt;
component to the wishbone bus within your design, and then define the traces
you wanted to follow in your subclass of the &lt;a href=&quot;https://github.com/ZipCPU/wbscope/blob/master/sw/scopecls.cpp&quot;&gt;software scope
controller&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Stick around, though.  &lt;a href=&quot;/about/gisselquist-technology.html&quot;&gt;Gisselquist
Technology&lt;/a&gt; is working
on a simpler way to connect your wishbone device components together using
&lt;a href=&quot;https://github.com/ZipCPU/autofpga&quot;&gt;autofpga&lt;/a&gt;.&lt;/p&gt;

</description>
        <pubDate>Sat, 08 Jul 2017 00:00:00 -0400</pubDate>
        <link>http://zipcpu.com/blog/2017/07/08/getting-started-with-wbscope.html</link>
        <guid isPermaLink="true">http://zipcpu.com/blog/2017/07/08/getting-started-with-wbscope.html</guid>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>Finishing off the debugging bus: building a software interface</title>
        <description>&lt;p&gt;Today’s post marks the end in a journey discussing what it takes to build
a very basic &lt;a href=&quot;https://github.com/ZipCPU/dbgbus&quot;&gt;debugging bus&lt;/a&gt; to provide
you with access to the internals of what’s going on within your FPGA.&lt;/p&gt;

&lt;p&gt;Looking at where we came from, we started by outlining what a &lt;a href=&quot;/blog/2017/06/05/wb-bridge-overview.html&quot;&gt;bus like this
might look like&lt;/a&gt;.
We used Fig 1 to illustrate this.&lt;/p&gt;

&lt;table style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 2: System Diagram&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/sample-interconnect.svg&quot; alt=&quot;An example WB interconnect&quot; width=&quot;420&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;We then walked through the steps necessary to build such a bus.  These steps
started with a discussion of what was necessary to build a &lt;a href=&quot;/blog/2017/06/08/simple-wb-master.html&quot;&gt;simple wishbone
bus master&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Then we stepped back and looked at how to initially create
&lt;a href=&quot;/blog/2017/06/14/creating-words-from-bytes.html&quot;&gt;bus command words from the serial port
bytes&lt;/a&gt;
sent to it.&lt;/p&gt;

&lt;p&gt;On the other side of the interface, we showed &lt;a href=&quot;/blog/2017/06/15/words-back-to-bytes.html&quot;&gt;how to turn the bus response
words back into
bytes&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;This made the basis of the interface.  To this, we
&lt;a href=&quot;/blog/2017/06/16/adding-ints.html&quot;&gt;added interrupts&lt;/a&gt;
to the interface, so we can tell if something has happened within the
device, as well as &lt;a href=&quot;/blog/2017/06/19/debug-idles.html&quot;&gt;bus idle
indications&lt;/a&gt;
to give us an assurance that we are connected to the right bus.&lt;/p&gt;

&lt;p&gt;We then put the &lt;a href=&quot;/blog/2017/06/20/dbg-put-together.html&quot;&gt;pieces of the bus
together&lt;/a&gt;
into a full blown debugging bus component core.&lt;/p&gt;

&lt;p&gt;The debugging bus needed a wishbone bus to command, so we outlined &lt;a href=&quot;/blog/2017/06/22/simple-wb-interconnect.html&quot;&gt;how to
build a basic wishbone
interconnect&lt;/a&gt;
that this bus could be connected to.  Together, this formed a fully functional
Verilog design.  The last post then discussed how to &lt;a href=&quot;/blog/2017/06/26/dbgbus-verilator.html&quot;&gt;build a fully functional
Verilator simulation&lt;/a&gt;
of our new design.&lt;/p&gt;

&lt;p&gt;We even tested the design and got some confidence that it worked.&lt;/p&gt;

&lt;p&gt;Today, we’re going to build a
&lt;a href=&quot;https://github.com/ZipCPU/dbgbus/tree/master/hexbus/sw&quot;&gt;software interface&lt;/a&gt;
that can be used to connect to this
&lt;a href=&quot;https://github.com/ZipCPU/dbgbus&quot;&gt;debugging bus component&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;software-interface-requirements&quot;&gt;Software Interface Requirements&lt;/h2&gt;

&lt;p&gt;Some time ago &lt;a href=&quot;/blog/2017/05/22/a-vision-for-controlling-fpgas.html&quot;&gt;we discussed&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/dbgbus/blob/master/sw/devbus.h&quot;&gt;the interface&lt;/a&gt;
we wanted to use to access this bus with.  Here, we’ll discuss some of the
components of making this interface work.&lt;/p&gt;

&lt;p&gt;The basic software components we are going to use are shown in Fig 2.
In general, this post will focus on the
&lt;a href=&quot;https://github.com/ZipCPU/dbgbus/tree/master/hexbus&quot;&gt;HEXBUS&lt;/a&gt; &lt;a href=&quot;https://github.com/ZipCPU/dbgbus/blob/master/hexbus/sw/hexbus.cpp&quot;&gt;software
interface component&lt;/a&gt;
which is specific to this interface standard.  This component, though, fits in
place between some other components, and it’s important to understand how
these parts and pieces are put together.&lt;/p&gt;

&lt;table style=&quot;float: left; padding: 15px&quot;&gt;&lt;caption&gt;Fig 2: Software Components&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/sw-dbg-components.svg&quot; alt=&quot;Debugging Bus Software Components&quot; width=&quot;240&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;We’ve already built the FPGA
&lt;a href=&quot;https://github.com/ZipCPU/dbgbus/tree/master/hexbus/rtl&quot;&gt;dbgbus interface&lt;/a&gt;. 
Further, &lt;a href=&quot;https://github.com/ZipCPU/dbgbus/blob/master/sw/netuart.cpp&quot;&gt;bridging such an
interface&lt;/a&gt;
from a serial port onto a TCP/IP stream isn’t that hard–although we may
come back and describe it in full later.&lt;/p&gt;

&lt;p&gt;The next step up in the stack is a generic low level O/S system interface
component
calls &lt;a href=&quot;https://github.com/ZipCPU/dbgbus/blob/master/sw/llcomms.h&quot;&gt;LLCOMMS&lt;/a&gt;.
This component provides read() and write() wrappers over the O/S system
calls, further abstracting the underlying transport the interface runs over.
In particular, the generic interface can be used to abstract whether or not
the interface is running over an O/S file descriptor (such as from
/dev/ttyUSB0)
or a network port (such as localhost:&amp;lt;port&amp;gt;).  Both interfaces are
found within the &lt;a href=&quot;https://github.com/ZipCPU/dbgbus/blob/master/sw/llcomms.cpp&quot;&gt;LLCOMMS
implementation&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;This gives us a bit of immunity against changes in the underlying transport
when moving from one device to another.  For example, the XuLA2 board has a
unique USB communication design.  Inheriting from the
&lt;a href=&quot;https://github.com/ZipCPU/dbgbus/blob/master/sw/llcomms.h&quot;&gt;LLCOMMS&lt;/a&gt;
interface, and replacing the critical portions with a &lt;a href=&quot;https://github.com/ZipCPU/xulalx25soc/blob/master/sw/usbi.h&quot;&gt;USB interface
component&lt;/a&gt;
will allow us to continue using &lt;a href=&quot;https://github.com/ZipCPU/dbgbus&quot;&gt;these dbgbus
components&lt;/a&gt;, despite the transport
having changed to support that unique interface.&lt;/p&gt;

&lt;p&gt;On the other side of the &lt;a href=&quot;https://github.com/ZipCPU/dbgbus/tree/master/hexbus/sw&quot;&gt;HEXBUS
interface&lt;/a&gt; is the 
&lt;a href=&quot;https://github.com/ZipCPU/dbgbus/blob/master/sw/wbregs.cpp&quot;&gt;wbregs&lt;/a&gt;
command line program.  This is a basic peek/poke type program which we’ll use
here as a demonstration program to show how to use the interface.  As a result,
the &lt;a href=&quot;https://github.com/ZipCPU/dbgbus/blob/master/sw/wbregs.cpp&quot;&gt;wbregs&lt;/a&gt;
program doesn’t really exercise the full limits of the debugging bus
capability.  Still, it makes for a nice example program that can be
used to illustrate the bus.&lt;/p&gt;

&lt;p&gt;It’s between these various other components that we’ll build our &lt;a href=&quot;https://github.com/ZipCPU/dbgbus/tree/master/hexbus/sw&quot;&gt;HEXBUS
software interface&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;the-hexbus-software-interface&quot;&gt;The HEXBUS software interface&lt;/h2&gt;

&lt;p&gt;It’s now time to get into the &lt;a href=&quot;https://github.com/ZipCPU/dbgbus/blob/master/hexbus/sw/hexbus.cpp&quot;&gt;HEXBUS software
interface&lt;/a&gt;.
As you may remember, this interface needs to match the generic
&lt;a href=&quot;https://github.com/ZipCPU/dbgbus/blob/master/sw/devbus.h&quot;&gt;devbus.h&lt;/a&gt;,
so you might wish to follow along in that file for reference.&lt;/p&gt;

&lt;p&gt;With a little simplification, the readio(), readz(), and readi()
requests can be mapped into a single internal readv() method.  This method
handles reading a variable number of values from the interface, given an
address and whether or not the address will increment between values.  A
similar simplification can be applied to the writeio(), writez(), and writei()
interface methods.  Hence, we’ll spend our time discussing how readv()
and writev() work.&lt;/p&gt;

&lt;p&gt;The first step to either readv() or writev() is to build a command that first
sends the address to the
component.  This is the purpose of the encode_address() method.
Because our interface is as simple as it is, encoding the address is
as simple as sprintf() call, writing “A” and then the hexadecimal
address to the buffer.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;	&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;HEXBUS&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;encode_address&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;HEXBUS&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;BUSW&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;// We&#39;ll write the address onto an internal command buffer, and then
&lt;/span&gt;	&lt;span class=&quot;c1&quot;&gt;// track a pointer to the end of the buffer
&lt;/span&gt;	&lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ptr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m_buf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ptr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;HEXB_ADDR&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;	&lt;span class=&quot;c1&quot;&gt;// Place an &quot;A&quot; at the beginning of our buffer
&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;sprintf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ptr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;%x&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;	&lt;span class=&quot;c1&quot;&gt;// encode the value in hex
&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;ptr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;strlen&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ptr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;	&lt;span class=&quot;c1&quot;&gt;// Adjust ptr to point to the end of the addr
&lt;/span&gt;	&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ptr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;		&lt;span class=&quot;c1&quot;&gt;// cmd, and return ptr
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;encode_address() returns a pointer to the end of the buffer, so that the
read or write command may be appended to it.&lt;/p&gt;

&lt;p&gt;This is the basics of the encode_address() command. Some additional
adjustments may also be found in the &lt;a href=&quot;https://github.com/ZipCPU/dbgbus/blob/master/hexbus/sw/hexbus.cpp&quot;&gt;HEXBUS interface
source&lt;/a&gt;,
so that we can avoid setting an address twice if we don’t need to.&lt;/p&gt;

&lt;p&gt;Both readv() and writev() call encode_address() as their basic first step:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;c1&quot;&gt;// encode_address stores its results in a local buffer, m_buf
// Remember the two LSB&#39;s are command indications that are not part of the
// address, and that setting the LSB will keep the address from
// incrementing between bus operations.  Hence, we examine whether or not
// we are incrementing, and adjust accordingly
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ptr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;encode_adress&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;inc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;?&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;After this, readv() and writev() diverge.  We’ll focus on readv() first,
and come back to writev() later.&lt;/p&gt;

&lt;p&gt;Within readv(), the command to read a value from the interface is a simple “R”,
terminated with a newline.  We’ll append this request to the address command,
and pass it to our &lt;a href=&quot;https://github.com/ZipCPU/dbgbus/blob/master/sw/llcomms.h&quot;&gt;lower level
communications&lt;/a&gt;
interface.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;c1&quot;&gt;// encode_address stores its results in a local buffer, m_buf
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ptr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;encode_adress&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;inc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;?&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nread&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ptr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;HEXB_READ&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ptr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;sc&quot;&gt;&#39;\n&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ptr&lt;/span&gt;   &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;sc&quot;&gt;&#39;\0&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

	&lt;span class=&quot;c1&quot;&gt;// Write this buffer to the lower level comms port
&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;m_dev&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;write&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_buf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ptr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_buf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;

	&lt;span class=&quot;c1&quot;&gt;// Read a word from the interface
&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;buf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nread&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;readword&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;

	&lt;span class=&quot;c1&quot;&gt;// Clear the command buffer so we can start over
&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;ptr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m_buf&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The loop operates over all of the requested words.  Within the loop, readv()
calls readword() to read individual words from the
interface, and write them into the given buffer.  This is then repeated until
all of the words have been read.&lt;/p&gt;

&lt;p&gt;The writev() code, on the other hand, sends a “W” followed by the hexadecimal
value which we wish to write.  That request is completed with a newline.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;nw&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nw&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;// Append the write command
&lt;/span&gt;	&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ptr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;sc&quot;&gt;&#39;W&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ptr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;sc&quot;&gt;&#39;\0&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;// If the value isn&#39;t zero, append it too.  End the command with
&lt;/span&gt;	&lt;span class=&quot;c1&quot;&gt;// a newline
&lt;/span&gt;	&lt;span class=&quot;c1&quot;&gt;// (The hardware assumes a value of zero if it isn&#39;t given
&lt;/span&gt;	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_buf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nw&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;sprintf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ptr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;%x&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;buf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nw&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;ptr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;strlen&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ptr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ptr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;sc&quot;&gt;&#39;\n&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ptr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;sc&quot;&gt;&#39;\0&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

	&lt;span class=&quot;n&quot;&gt;m_dev&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;write&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_buf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ptr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_buf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

	&lt;span class=&quot;n&quot;&gt;readidle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;

	&lt;span class=&quot;n&quot;&gt;nw&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;ptr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m_buf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Once the actual write command is sent to the lower level, we call readidle()
to read (and ignore) any acknowledgements.  This keeps the interface
synchronous–which is especially important given that there are no FIFO’s
yet built within it.&lt;/p&gt;

&lt;p&gt;We nown turn our attention to readword() and readidle().  The structure of
the two of these is quite similar.  Here, we’ll start with looking at how
readword() is composed.&lt;/p&gt;

&lt;p&gt;Since multiple words can be sent across the interface using the same
command word, we need a state variable to capture and remember the last
command word.  We’ll use m_cmd for that purpose.
It is retained from response to response, so that it need not be repeated.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;		&lt;span class=&quot;n&quot;&gt;nr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;word&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;bool&lt;/span&gt;		&lt;span class=&quot;n&quot;&gt;done&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// Initialize our response register to zero
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;word&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;do&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;// Read a character from the interface, block if necessary
&lt;/span&gt;	&lt;span class=&quot;k&quot;&gt;do&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;nr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lclreadcode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_buf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

	&lt;span class=&quot;c1&quot;&gt;// If the character is a lower case hexadecimal digit, shift our
&lt;/span&gt;	&lt;span class=&quot;c1&quot;&gt;// word by four bits and set the lower four bits with this
&lt;/span&gt;	&lt;span class=&quot;c1&quot;&gt;// value.
&lt;/span&gt;	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;isdigit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_buf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]))&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;word&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;word&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_buf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x0f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_buf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;sc&quot;&gt;&#39;a&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_buf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;sc&quot;&gt;&#39;f&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;word&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;word&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_buf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;sc&quot;&gt;&#39;a&#39;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;mh&quot;&gt;0x0f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;c1&quot;&gt;// Otherwise, if the word we&#39;ve received is an out-of-band
&lt;/span&gt;		&lt;span class=&quot;c1&quot;&gt;// character.  Such characters always end the current response.
&lt;/span&gt;		&lt;span class=&quot;c1&quot;&gt;// They can also be used to start a new response.  Here, we&#39;ll
&lt;/span&gt;		&lt;span class=&quot;c1&quot;&gt;// focus on the last command first.  That&#39;s what&#39;s in m_cmd,
&lt;/span&gt;		&lt;span class=&quot;c1&quot;&gt;// and also what&#39;s in our &quot;word&quot; buffer
&lt;/span&gt;		&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_cmd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;HEXB_READ&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
			&lt;span class=&quot;c1&quot;&gt;// On any read value, update the address pointer
&lt;/span&gt;			&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_inc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
				&lt;span class=&quot;n&quot;&gt;m_lastaddr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

			&lt;span class=&quot;c1&quot;&gt;// We&#39;ve found the word we need, so we are done
&lt;/span&gt;			&lt;span class=&quot;n&quot;&gt;done&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

			&lt;span class=&quot;c1&quot;&gt;// Copy the result into ... result
&lt;/span&gt;			&lt;span class=&quot;n&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;word&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_cmd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;HEXB_ACK&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
			&lt;span class=&quot;c1&quot;&gt;// On a write acknowledgement (might be left over
&lt;/span&gt;			&lt;span class=&quot;c1&quot;&gt;// unread from a previously unfinished transaction?)
&lt;/span&gt;			&lt;span class=&quot;c1&quot;&gt;// adjust the address pointer, and increment the number
&lt;/span&gt;			&lt;span class=&quot;c1&quot;&gt;// of acknowledgements received.
&lt;/span&gt;
			&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_inc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
				&lt;span class=&quot;n&quot;&gt;m_lastaddr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;m_nacks&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_cmd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;HEXB_INT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
			&lt;span class=&quot;c1&quot;&gt;// On an interrupt notification, just set the interrupt
&lt;/span&gt;			&lt;span class=&quot;c1&quot;&gt;// flag.
&lt;/span&gt;			&lt;span class=&quot;n&quot;&gt;m_interrupt_flag&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_cmd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;HEXB_ERR&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
			&lt;span class=&quot;c1&quot;&gt;// On a bus error, set the bus error flag, and
&lt;/span&gt;			&lt;span class=&quot;c1&quot;&gt;// throw a bus error in case anything wishes to catch
&lt;/span&gt;			&lt;span class=&quot;c1&quot;&gt;// and process it.
&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;m_bus_err&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
			&lt;span class=&quot;k&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;BUSERR&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_lastaddr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
		&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_cmd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;HEXB_IDLE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
			&lt;span class=&quot;c1&quot;&gt;// If we get multiple idles while waiting for a
&lt;/span&gt;			&lt;span class=&quot;c1&quot;&gt;// response, then our response has been lost.
&lt;/span&gt;			&lt;span class=&quot;c1&quot;&gt;// Throw a bus error
&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;abort_countdown&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
			&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;abort_countdown&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
				&lt;span class=&quot;k&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;BUSERR&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
		&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_cmd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;HEXB_ADDR&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
			&lt;span class=&quot;c1&quot;&gt;// On an address response from the debugging bus,
&lt;/span&gt;			&lt;span class=&quot;c1&quot;&gt;// set the address tracking reads to the value
&lt;/span&gt;			&lt;span class=&quot;c1&quot;&gt;// returned, as well as the m_inc to whether or not
&lt;/span&gt;			&lt;span class=&quot;c1&quot;&gt;// this indicates an incrementing address.
&lt;/span&gt;			&lt;span class=&quot;n&quot;&gt;m_addr_set&lt;/span&gt;  &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;m_inc&lt;/span&gt;       &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;word&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;m_lastaddr&lt;/span&gt;  &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;word&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_cmd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;HEXB_RESET&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
			&lt;span class=&quot;c1&quot;&gt;// On any bus reset, any address that was set is now
&lt;/span&gt;			&lt;span class=&quot;c1&quot;&gt;// invalid.  Mark it so.
&lt;/span&gt;			&lt;span class=&quot;n&quot;&gt;m_addr_set&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

		&lt;span class=&quot;c1&quot;&gt;// Any out of band character other than a newline is a
&lt;/span&gt;		&lt;span class=&quot;c1&quot;&gt;// new command that we start
&lt;/span&gt;		&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;isspace&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_buf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]))&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;m_cmd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m_buf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;

		&lt;span class=&quot;c1&quot;&gt;// Clear the register so we can receive the next word	
&lt;/span&gt;		&lt;span class=&quot;n&quot;&gt;word&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;done&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// Return any recovered/read result
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;readword() reads from the port one character at a time, by calling
lclreadcode().  lclreadcode() reads a single byte from the interface,
tossing out any device-not-ready bytes (0x7f or 0xff).  After that,
readword() is very similar to our &lt;a href=&quot;https://github.com/ZipCPU/dbgbus/blob/master/hexbus/rtl/hbpack.v&quot;&gt;bytes to words
component&lt;/a&gt;
within the
&lt;a href=&quot;https://github.com/ZipCPU/dbgbus/tree/master/hexbus/rtl&quot;&gt;HEXBUS RTL&lt;/a&gt; design.
Any command word (“R”, “W”, “A”, etc) coming
in is stored.  After that, words are built from assembling the hexadecimal
values together.  As soon as a non-hexadecimal character is received, the
word received is complete.&lt;/p&gt;

&lt;p&gt;The big difference between this logic and the logic of readidle() below is
that readidle() only loops while data is available to be read, and it doesn’t
return on any words read–since readidle() is called after &lt;em&gt;writing&lt;/em&gt; (not
reading) to the interface.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;c1&quot;&gt;// Start by clearing the register
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;word&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// Repeat as long as there are values to be read
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_dev&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;available&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;// Read one character from the interface
&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;nr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lclreadcode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_buf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

	&lt;span class=&quot;c1&quot;&gt;// If it&#39;s a hexadecimal digit, adjust our word register
&lt;/span&gt;	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;isdigit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_buf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]))&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;word&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;word&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_buf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x0f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_buf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;sc&quot;&gt;&#39;a&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_buf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;sc&quot;&gt;&#39;f&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;word&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;word&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_buf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;sc&quot;&gt;&#39;a&#39;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;mh&quot;&gt;0x0f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;c1&quot;&gt;// Any thing else identifies the beginning (or end)
&lt;/span&gt;		&lt;span class=&quot;c1&quot;&gt;// of a response word.  Deal with it based upon the
&lt;/span&gt;		&lt;span class=&quot;c1&quot;&gt;// last response m_cmd received.
&lt;/span&gt;		&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_cmd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;HEXB_ADDR&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
			&lt;span class=&quot;c1&quot;&gt;// Received an address word
&lt;/span&gt;			&lt;span class=&quot;n&quot;&gt;m_addr_set&lt;/span&gt;  &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;m_inc&lt;/span&gt;       &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;word&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;m_lastaddr&lt;/span&gt;  &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;word&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_cmd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;HEXB_READ&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
			&lt;span class=&quot;c1&quot;&gt;// Read data ... doesn&#39;t make sense in this
&lt;/span&gt;			&lt;span class=&quot;c1&quot;&gt;// context, so we&#39;ll just ignore it
&lt;/span&gt;			&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_inc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
				&lt;span class=&quot;n&quot;&gt;m_lastaddr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_cmd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;HEXB_INT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
			&lt;span class=&quot;c1&quot;&gt;// On an interrupt, just set the flag to note
&lt;/span&gt;			&lt;span class=&quot;c1&quot;&gt;// we&#39;ve received one.
&lt;/span&gt;			&lt;span class=&quot;n&quot;&gt;m_interrupt_flag&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_cmd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;HEXB_ACK&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
			&lt;span class=&quot;c1&quot;&gt;// Write acknowledgement.  writev() will check
&lt;/span&gt;			&lt;span class=&quot;c1&quot;&gt;// whether the correct number of
&lt;/span&gt;			&lt;span class=&quot;c1&quot;&gt;// acknoweledgments has been received before
&lt;/span&gt;			&lt;span class=&quot;c1&quot;&gt;// moving on.  Read and note it here.
&lt;/span&gt;			&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_inc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
				&lt;span class=&quot;n&quot;&gt;m_lastaddr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;m_nacks&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_cmd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;HEXB_ERR&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
			&lt;span class=&quot;c1&quot;&gt;// On an err, throw a BUSERR exception
&lt;/span&gt;			&lt;span class=&quot;n&quot;&gt;m_bus_err&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
			&lt;span class=&quot;k&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;BUSERR&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_lastaddr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
		&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_cmd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;HEXB_RESET&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
			&lt;span class=&quot;c1&quot;&gt;// On any reset, clear the address set flag
&lt;/span&gt;			&lt;span class=&quot;c1&quot;&gt;// and any unacknowledged bus error condition
&lt;/span&gt;			&lt;span class=&quot;n&quot;&gt;m_addr_set&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;m_bus_err&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

		&lt;span class=&quot;c1&quot;&gt;// Any out of band character other than a whitespace
&lt;/span&gt;		&lt;span class=&quot;c1&quot;&gt;// is a new command starting--keep track of which
&lt;/span&gt;		&lt;span class=&quot;c1&quot;&gt;// command it is.
&lt;/span&gt;		&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;isspace&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_buf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]))&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;m_cmd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m_buf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;word&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;While there are other details within the software interface, such as a
means of creating a log file that can be used to find interface errors,
or a means of querying whether or not an interface has taken place, we’ll
gloss over these in favor of simplifying our description today.  Feel free
to browse the software and see how they work.&lt;/p&gt;

&lt;h2 id=&quot;register-naming&quot;&gt;Register Naming&lt;/h2&gt;

&lt;p&gt;There’s another piece to our software which isn’t shown in Fig 2.  This
portion defines names, and then provides
a register name to address translation.  It starts by &lt;a href=&quot;https://github.com/ZipCPU/dbgbus/blob/master/sw/regdefs.h&quot;&gt;defining constant
values&lt;/a&gt; for all of
our register addresses.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;cp&quot;&gt;#define	R_VERSION       0x00002040
#define	R_SOMETHING	0x00002044
#define	R_BUSERR       	0x00002048
#define	R_PWRCOUNT	0x0000204c
#define	R_INT		0x00002050
#define	R_HALT		0x00002054
&lt;/span&gt;
&lt;span class=&quot;cp&quot;&gt;#define	R_SCOPE		0x00002080
#define	R_SCOPD		0x00002084
&lt;/span&gt;
&lt;span class=&quot;cp&quot;&gt;#define	R_MEM		0x00004000&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This will make it easy to say within your software something like,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;n&quot;&gt;variable&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m_fpga&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;readio_R_VERSION&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;as an example.&lt;/p&gt;

&lt;p&gt;To facilitate the command line register usage of tools like
&lt;a href=&quot;https://github.com/ZipCPU/dbgbus/blob/master/sw/wbregs.cpp&quot;&gt;wbregs&lt;/a&gt;,
we create a &lt;a href=&quot;https://github.com/ZipCPU/dbgbus/blob/master/sw/regdefs.cpp&quot;&gt;user name to constant mapping
function&lt;/a&gt;.
This is nothing more than a table of register address, register name pairs,
as is shown below:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;REGNAME&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;raw_bregs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;R_VERSION&lt;/span&gt;       &lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;	&lt;span class=&quot;s&quot;&gt;&quot;VERSION&quot;&lt;/span&gt; 	&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;R_BUSERR&lt;/span&gt;        &lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;	&lt;span class=&quot;s&quot;&gt;&quot;BUSERR&quot;&lt;/span&gt;  	&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;R_PWRCOUNT&lt;/span&gt;      &lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;	&lt;span class=&quot;s&quot;&gt;&quot;PWRCOUNT&quot;&lt;/span&gt;	&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;R_INT&lt;/span&gt;		  &lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;	&lt;span class=&quot;s&quot;&gt;&quot;int&quot;&lt;/span&gt;		&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;R_HALT&lt;/span&gt;	  &lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;	&lt;span class=&quot;s&quot;&gt;&quot;halt&quot;&lt;/span&gt;		&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;R_SCOPE&lt;/span&gt;         &lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;	&lt;span class=&quot;s&quot;&gt;&quot;SCOPE&quot;&lt;/span&gt;   	&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;R_SCOPD&lt;/span&gt;         &lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;	&lt;span class=&quot;s&quot;&gt;&quot;SCOPD&quot;&lt;/span&gt;   	&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;R_MEM&lt;/span&gt;           &lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;	&lt;span class=&quot;s&quot;&gt;&quot;RAM&quot;&lt;/span&gt;     	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;A short routine also decodes the register names and turns them into addresses,
which can then be used with readio() or writeio();&lt;/p&gt;

&lt;p&gt;From a software standpoint, this approach to register naming is very
important.  Because registers are given names, whether the C++ name
&lt;strong&gt;R_VERSION&lt;/strong&gt; or more human readable and case insensitive name
“&lt;strong&gt;VERSION&lt;/strong&gt;”, any software using
these names doesn’t need to be changed from one design to the next, nor
when the addresses change.  As examples, I can use the same software to control
the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;, whether to load a program into
memory or debug a running program,
on one board as I can on other boards.  Any changed addresses are taken care
of by recompiling the software for the new board.&lt;/p&gt;

&lt;h2 id=&quot;testing-it-all-out&quot;&gt;Testing it all out&lt;/h2&gt;

&lt;p&gt;If you are just joining the discussion at this point, you’ll want to have
&lt;a href=&quot;https://www.veripool.org/wiki/verilator&quot;&gt;Verilator&lt;/a&gt;,
&lt;a href=&quot;https://gcc.gnu.org&quot;&gt;g++&lt;/a&gt;, &lt;a href=&quot;http://gtkwave.sourceforge.net&quot;&gt;gtkwave&lt;/a&gt;,
and &lt;a href=&quot;https://git-scm.com&quot;&gt;git&lt;/a&gt; installed to test the interface out yourself.
Although many of these are Linux programs (I use
&lt;a href=&quot;https://www.ubuntu.com&quot;&gt;Ubuntu&lt;/a&gt; myself), I have instructions available for
doing this on a Windows platform using &lt;a href=&quot;https://www.cygwin.com&quot;&gt;Cygwin&lt;/a&gt;.
(Those instructions are available to anyone who wants to test them and let
me know how well they do (or don’t) work–just send me an e-mail asking for
them, and promising to tell me if they work for you.)  Then, once these
utilities are installed, you should be able to just download and build the
&lt;a href=&quot;https://www.veripool.org/wiki/verilator&quot;&gt;Verilator&lt;/a&gt;,
simulation of the &lt;a href=&quot;https://github.com/ZipCPU/dbgbus&quot;&gt;debugging bus&lt;/a&gt; we’ve
been working on.&lt;/p&gt;

&lt;p&gt;Cloning and building the project should be quite straightforward:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;cd ~/your/chosen/project/path
git clone https://github.com/ZipCPU/dbgbus
cd dbgbus
make&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Now that this is built, there are two steps to interacting with the simulation.
The first step is to run the simulation executable.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;cd bench/cpp
./testbus_tb&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Have a little caution when running this.  If the trace file generation is
turned on (look for opentrace(“trace.vcd”) in
&lt;a href=&quot;https://github.com/ZipCPU/dbgbus/blob/master/bench/cpp&quot;&gt;testbus_tb.cpp&lt;/a&gt;), it
may quickly write a &lt;em&gt;VERY LARGE&lt;/em&gt; file to your computer.
That file will be called trace.vcd, and it will be written in the same
directory as the testbus_tb program is called from.  If this is a problem,
feel free to comment out the trace generation line and run without generating
a trace.&lt;/p&gt;

&lt;p&gt;The second step, which you may wish to do in another terminal window, is to
run the &lt;a href=&quot;https://github.com/ZipCPU/dbgbus/blob/master/sw/wbregs.cpp&quot;&gt;wbregs&lt;/a&gt;
program to interact with this simulation.  I like to start any testing
session by just proving that I can read the internal version number from the
simulation:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;cd ~/your/chosen/project/path/dbgbus/sw
./wbregs VERSION&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/ZipCPU/dbgbus/blob/master/sw/wbregs.cpp&quot;&gt;wbregs&lt;/a&gt;
should return an 8-digit hexadecimal number looking like a date.
The current date within the repository is 0x20170622, but I may change that
later to indicate changes to the repository.&lt;/p&gt;

&lt;p&gt;We also placed a counter internal to the simulation.  Using this counter, we
can query how many ticks have passed since the simulation started.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;./wbregs PWRCOUNT&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;And again.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;./wbregs PWRCOUNT&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;You should get two different answers, and the number should increase between
the two.&lt;/p&gt;

&lt;p&gt;We can also check the status of the onboard
&lt;a href=&quot;https://github.com/ZipCPU/wbscope&quot;&gt;wishbone scope&lt;/a&gt;,
by reading from its control register.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;./wbregs SCOPE&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Look at the top nibble of the return word in response.  It’s a ‘1’.  That means
that the scope now has enough samples to fill its memory, but that it has yet
to be triggered.  We’ll come back to this in a moment.&lt;/p&gt;

&lt;p&gt;Let’s turn our attention to the block RAM memory.  Using
&lt;a href=&quot;https://github.com/ZipCPU/dbgbus/blob/master/sw/wbregs.cpp&quot;&gt;wbregs&lt;/a&gt;
we can write to the first location in memory:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;./wbregs MEM 0xdeadbeef&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;While we can read from and write to other locations in memory as well,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;./wbregs 0x4008 0xdeadbeef&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;only the first memory location has a name, MEM, associated with it.  To access
other locations, you will need to give
&lt;a href=&quot;https://github.com/ZipCPU/dbgbus/blob/master/sw/wbregs.cpp&quot;&gt;wbregs&lt;/a&gt;
the address in numeric (strtoul) format.&lt;/p&gt;

&lt;p&gt;If you recall, we built our design, though, in such a way that any
read or write command to memory would trigger the
&lt;a href=&quot;https://github.com/ZipCPU/wbscope&quot;&gt;scope&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Let’s see if it got triggered:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;./wbregs SCOPE&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Here, the scope returns a response having 7 in its high order nibble.  This
means that the scope has not only been triggered, but it’s also stopped
recording.  At this point, in your software code, you could issue a:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;n&quot;&gt;ctrl_register&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m_fpga&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;readio&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;R_SCOPE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;scopelen&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ctrl_register&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;20&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;mh&quot;&gt;0x1f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;buffer&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;uint32_t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;scopelen&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;m_fpga&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;readz&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;R_SCOPD&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;scopelen&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;buffer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This would read the state from the scope control register. 
Specifically, though, this would examine the scope control register to find
out how much internal RAM the scope has been built with.  Once determined, a
buffer can be built to read from the scope, and the read command can be issued.
All of this is simplified by the &lt;a href=&quot;https://github.com/ZipCPU/wbscope/blob/master/sw/scopecls.cpp&quot;&gt;scope helper
class&lt;/a&gt;,
but we’ll save that for another lesson for another day.&lt;/p&gt;

&lt;h2 id=&quot;what-can-you-use-this-for&quot;&gt;What can you use this for&lt;/h2&gt;

&lt;p&gt;This ends our series in how to build a bus that you can use for debugging
an FPGA.  While it’s taken a while to get here, interacting with an 
FPGA in this manner can be particularly valuable.  While we’ve focused on
the use case of being able to get scope information out of the design,
many other use cases exist.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Reading/writing video memory within the FPGA, such as reading the results
from a camera&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Reading, erasing, and programming the &lt;a href=&quot;http://opencores.org/project,qspiflash&quot;&gt;QSPI flash
memory&lt;/a&gt; within the FPGA&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Setting up a fallback design, using the
&lt;a href=&quot;https://github.com/ZipCPU/wbicapetwo&quot;&gt;internal configuration access port&lt;/a&gt;,
or even switching FPGA configurations without using the official JTAG port.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Grabbing data from a GPS receiver&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Controlling an
&lt;a href=&quot;https://github.com/ZipCPU/openarty/blob/master/rtl/wboled.v&quot;&gt;OLEDrgb&lt;/a&gt;, or
even a 2-line LCD, to make sure your controller works before trying to use
a CPU to run it.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Setting up the memory, either block RAM or SDRAM, within your design so that
it can be processed later.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Indeed, the possibilities are so numerous, it’s hard to list them all here.&lt;/p&gt;

&lt;p&gt;There is one thing, though, that this interface lacks: speed.  Speed can be
achieved by packing more bits per word than four, and by compressing this
interface.  Both of these capabilities are part of the 
&lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/rtl/wbubus.v&quot;&gt;WBUBUS&lt;/a&gt; I normally
use.  You are more than welcome to use this interface if you would like,
subject only to the conditions of the
&lt;a href=&quot;https://www.gnu.org/licenses/gpl-3.0.en.html&quot;&gt;GPL&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;That’s why I intend to to use this design and specifically the
&lt;a href=&quot;https://github.com/ZipCPU/dbgbus/blob/master/sw/devbus.h&quot;&gt;devbus&lt;/a&gt;,
interface it implements as a basis for moving forward with future articles
on this blog.&lt;/p&gt;

&lt;p&gt;Thoughts or comments?  Please feel free to share them below.&lt;/p&gt;

&lt;p&gt;Thanks!&lt;/p&gt;
</description>
        <pubDate>Thu, 29 Jun 2017 00:00:00 -0400</pubDate>
        <link>http://zipcpu.com/blog/2017/06/29/sw-dbg-interface.html</link>
        <guid isPermaLink="true">http://zipcpu.com/blog/2017/06/29/sw-dbg-interface.html</guid>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>Why you want a debug port into your FPGA</title>
        <description>&lt;p&gt;Using the tools within the &lt;a href=&quot;https://github.com/ZipCPU/dbgbus&quot;&gt;dbgbus project&lt;/a&gt;,
I was able to create the following scope output.&lt;/p&gt;

&lt;table style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 1: Example Output from DBGBUS&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/memscope.png&quot; alt=&quot;Example Scope Output&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;What’s keeping you from wanting to use an &lt;a href=&quot;https://www.gnu.org/licenses/lgpl-3.0.en.html&quot;&gt;open source&lt;/a&gt; capability like this?&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Are you trying to figure out how to deal with a flash memory, with an 
uncertain specification that you are struggling to understand?
&lt;a href=&quot;https://forum.digilentinc.com/topic/1965-how-to-readwrite-to-p30-parallel-flash-memory-on-digilent-genesys/&quot;&gt;[1]&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;If you use an integrated scope, such as the &lt;a href=&quot;https://github.com/ZipCPU/wbscope&quot;&gt;wishbone
scope&lt;/a&gt; this project uses, you’ll be able
to examine not only whether or not your code is producing the correct output
values, as well as seeing what the response is from the device.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Or is your problem trying to get an FFT to work?  Are you struggling to “know”
what data is going into the FFT and what data is coming out?
&lt;a href=&quot;https://forum.digilentinc.com/topic/3160-xadc-and-the-fft&quot;&gt;[2]&lt;/a&gt;
&lt;a href=&quot;/digilent/2017/05/29/fft-debugging.html&quot;&gt;[3]&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;You could use this approach to grab a copy of the data coming out of the
XADC, as well as data coming out of the FFT, and then see where your problem
is (if any).&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Are you hoping to connect your Basys3 board to an Arduino, and can’t figure
out why your design isn’t working?  &lt;a href=&quot;https://forum.digilentinc.com/topic/4233-spi-arduino-to-basys-3&quot;&gt;[4]&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;Wouldn’t it help to see what your logic is doing internally?  That’s the
purpose of this &lt;a href=&quot;https://github.com/ZipCPU/dbgbus&quot;&gt;debugging bus&lt;/a&gt; and
connected &lt;a href=&quot;https://github.com/ZipCPU/wbscope&quot;&gt;wishbone scope&lt;/a&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Do you want to know what button bouncing looks like?  How long a button
bounces before settling? &lt;a href=&quot;https://forum.digilentinc.com/topic/3992-something-simple-is-apparently-impossible-incrdecr-number/&quot;&gt;[5]&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;If your button processing code isn’t working, a
&lt;a href=&quot;https://github.com/ZipCPU/wbscope&quot;&gt;wishbone scope&lt;/a&gt; connected to a 
&lt;a href=&quot;https://github.com/ZipCPU/dbgbus&quot;&gt;debugging bus&lt;/a&gt; would show you why a simple
button push isn’t simply incrementing a counter like you might like.
You could &lt;em&gt;see&lt;/em&gt; what’s going on for yourself.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Struggling to debug why an FIR filter is or isn’t working? 
&lt;a href=&quot;https://forum.digilentinc.com/topic/3492-4-tap-fir-filter&quot;&gt;[6]&lt;/a&gt;
Do you know if your FPGA code works?  You can use this scope to find out.&lt;/p&gt;

    &lt;p&gt;We’ll be discussing within this blog how to go about debugging digital signal
processing using these tools as well.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Once the software interface to this debugging bus is added into the design,
you’ll be able to do any of the above.&lt;/p&gt;
</description>
        <pubDate>Wed, 28 Jun 2017 00:00:00 -0400</pubDate>
        <link>http://zipcpu.com/blog/2017/06/28/dbgbus-goal.html</link>
        <guid isPermaLink="true">http://zipcpu.com/blog/2017/06/28/dbgbus-goal.html</guid>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>Simulating an FPGA through the debugging interface</title>
        <description>&lt;p&gt;Today, let’s put some things together.  We’ve already built a debugging bus
approach that we can use to interact with an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
and draw information out of it.
&lt;a href=&quot;/blog/2017/06/05/wb-bridge-overview.html&quot;&gt;[1]&lt;/a&gt;
&lt;a href=&quot;/blog/2017/06/08/simple-wb-master.html&quot;&gt;[2]&lt;/a&gt;
&lt;a href=&quot;/blog/2017/06/14/creating-words-from-bytes.html&quot;&gt;[3]&lt;/a&gt;
&lt;a href=&quot;/blog/2017/06/15/words-back-to-bytes.html&quot;&gt;[4]&lt;/a&gt;
&lt;a href=&quot;/blog/2017/06/16/adding-ints.html&quot;&gt;[5]&lt;/a&gt;
&lt;a href=&quot;/blog/2017/06/16/dbg-bus-forest.html&quot;&gt;[6]&lt;/a&gt;
&lt;a href=&quot;/blog/2017/06/19/debug-idles.html&quot;&gt;[7]&lt;/a&gt;
&lt;a href=&quot;/blog/2017/06/20/dbg-put-together.html&quot;&gt;[8]&lt;/a&gt;
&lt;a href=&quot;/blog/2017/06/22/simple-wb-interconnect.html&quot;&gt;[9]&lt;/a&gt;
We’ve also talked about 
&lt;a href=&quot;https://www.veripool.org/wiki/verilator&quot;&gt;Verilator&lt;/a&gt;
and what 
&lt;a href=&quot;https://www.veripool.org/wiki/verilator&quot;&gt;Verilator&lt;/a&gt;
allows us to do in simulation.&lt;/p&gt;

&lt;p&gt;Suppose we spend the time today to build a
&lt;a href=&quot;https://www.veripool.org/wiki/verilator&quot;&gt;Verilator&lt;/a&gt;
based simulation of our
&lt;a href=&quot;https://en.wikipedia.org/wiki/Field-programmable_gate_array&quot;&gt;FPGA&lt;/a&gt;
design that can be controlled via this debugging
bus interface?&lt;/p&gt;

&lt;p&gt;While most of the difficult parts have already been accomplished, there are
still there are three basic components that we are going to need to work on to
do this.  The first is the
&lt;a href=&quot;https://github.com/ZipCPU/dbgbus/blob/master/bench/rtl/Makefile&quot;&gt;Makefile for our&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/dbgbus/blob/master/bench/rtl/testbus.v&quot;&gt;top level Verilog design&lt;/a&gt;.
The second is the &lt;a href=&quot;https://github.com/ZipCPU/dbgbus/blob/master/bench/cpp/testbus_tb.cpp&quot;&gt;C++ driver&lt;/a&gt; for our test bench.  We already discussed how to
generate a &lt;a href=&quot;https://github.com/ZipCPU/dbgbus/blob/master/bench/cpp/testb.h&quot;&gt;generic
driver&lt;/a&gt;
&lt;a href=&quot;/blog/2017/06/21/looking-at-verilator.html&quot;&gt;here&lt;/a&gt; and our
debugging philosophy in general
&lt;a href=&quot;/blog/2017/06/23/my-dbg-philosophy.html&quot;&gt;here&lt;/a&gt;,
so this discussion will only describe the differences between a &lt;a href=&quot;https://github.com/ZipCPU/dbgbus/blob/master/bench/cpp/testb.h&quot;&gt;generic test
bench driver&lt;/a&gt;
and the &lt;a href=&quot;https://github.com/ZipCPU/dbgbus/blob/master/bench/cpp/testbus_tb.cpp&quot;&gt;one we’re
building&lt;/a&gt;
for this project.
The last item we’ll need to figure out is how to build all the pieces
together–i.e. the final &lt;a href=&quot;https://github.com/ZipCPU/dbgbus/blob/master/bench/cpp/Makefile&quot;&gt;simulation
Makefile&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;When we finish, let’s run some tests on our “hardware” and see how it works!&lt;/p&gt;

&lt;h2 id=&quot;the-rtl-makefile&quot;&gt;The RTL Makefile&lt;/h2&gt;

&lt;p&gt;The RTL makefile needs to handle two things.  First, it needs to convert our
our &lt;a href=&quot;/blog/2017/06/22/simple-wb-interconnect.html&quot;&gt;Verilog test
bench&lt;/a&gt;
into a C++ class using
&lt;a href=&quot;https://www.veripool.org/wiki/verilator&quot;&gt;Verilator&lt;/a&gt;.  Then, the second step
directed by the RTL makefile will be to build that C++ class into a library
that can be linked with our &lt;a href=&quot;https://github.com/ZipCPU/dbgbus/blob/master/bench/cpp/testbus_tb.cpp&quot;&gt;C++
testbench&lt;/a&gt;
to create a fully functional simulation.&lt;/p&gt;

&lt;p&gt;We’ve &lt;a href=&quot;/blog/2017/06/21/looking-at-verilator.html&quot;&gt;already
discussed&lt;/a&gt;
the basics of how to run
&lt;a href=&quot;https://www.veripool.org/wiki/verilator&quot;&gt;Verilator&lt;/a&gt;.
In quick sum here, you can run
&lt;a href=&quot;https://www.veripool.org/wiki/verilator&quot;&gt;Verilator&lt;/a&gt; on a top level Verilog
file as in:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;verilate -Wall -trace -cc testbus.v&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Today, let’s just highlight some of the neat things that can be placed into
our rtl/Makefile in order to do it well.&lt;/p&gt;

&lt;p&gt;For example, I’d like to be able to use the test bench in the 
&lt;a href=&quot;https://github.com/ZipCPU/dbgbus&quot;&gt;dbgbus&lt;/a&gt; repository to test several
different debugging busses.  For this reason, I’m going to add,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-makefile&quot; data-lang=&quot;makefile&quot;&gt;&lt;span class=&quot;nv&quot;&gt;BUS&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt;&lt;span class=&quot;err&quot;&gt; hexbus&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;to the Makefile, and -y “../../$(BUS)/rtl” to the
&lt;a href=&quot;https://www.veripool.org/wiki/verilator&quot;&gt;Verilator&lt;/a&gt; command line.
That’ll cause Verilator to look for our sources in the
&lt;a href=&quot;https://github.com/ZipCPU/dbgbus/tree/master/hexbus/rtl&quot;&gt;hexbus&lt;/a&gt;
project subdirectory for any bus sources.&lt;/p&gt;

&lt;p&gt;Our top level Verilog file
&lt;a href=&quot;https://github.com/ZipCPU/dbgbus/blob/master/bench/rtl/testbench.v&quot;&gt;testbench.v&lt;/a&gt;
includes references to multiple files.  We’d like
to only re-run Verilator any time these files change.  Is there a way
to get dependency information for Verilog code in a fashion similar to
C++ code?  Yes, there is.  For this, we’ll add “–MMD” to the
&lt;a href=&quot;https://www.veripool.org/wiki/verilator&quot;&gt;Verilator&lt;/a&gt; command line,
and include the dependency file it generates at the end of
our Makefile:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-makefile&quot; data-lang=&quot;makefile&quot;&gt;&lt;span class=&quot;nv&quot;&gt;DEPS&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;wildcard &lt;span class=&quot;nv&quot;&gt;$(VDIRFB)&lt;/span&gt;/&lt;span class=&quot;se&quot;&gt;\*&lt;/span&gt;.d&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;err&quot;&gt;ifndeq&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;($(DEPS),)&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;$(DEPS)&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;endif&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;We’ll also set two more Makefile variables before we call Verilator.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-makefile&quot; data-lang=&quot;makefile&quot;&gt;&lt;span class=&quot;nv&quot;&gt;VERILATOR&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;?=&lt;/span&gt; verilator
&lt;span class=&quot;nv&quot;&gt;VFLAGS&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; -Wall --MMD -trace -y ../../&lt;span class=&quot;nv&quot;&gt;$(BUS)&lt;/span&gt;/rtl --Mdir &lt;span class=&quot;nv&quot;&gt;$(VDIRFB)&lt;/span&gt;&lt;span class=&quot;err&quot;&gt; -cc&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This will do two things.  First, it will allow you to run make with your
VERILATOR version defined in an environment variable.  Second, it will
simplify our Verilator call later.&lt;/p&gt;

&lt;p&gt;Now that we have these variables defined, we can create the “verilate”
target.  This target will build the C++ code.  Since the actual name of the
C++ code is somewhat obtuse, we’ll rename what we are building to “verilate”
and then forward that to what needs to be built.  Finally, we’ll actually
run our Verilator call–simplified by the VFLAGS we defined above.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-makefile&quot; data-lang=&quot;makefile&quot;&gt;&lt;span class=&quot;nl&quot;&gt;.PHONY&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;verilate&lt;/span&gt;
&lt;span class=&quot;nl&quot;&gt;verilate&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;$(VDIRFB)/Vtestbus.h&lt;/span&gt;
&lt;span class=&quot;nl&quot;&gt;$(VDIRFB)/Vtestbus.h&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
	&lt;span class=&quot;nv&quot;&gt;$(VERILATOR)&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$(VFLAGS)&lt;/span&gt;&lt;span class=&quot;err&quot;&gt; testbus.v&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The last step is to build the library.  This step is somewhat anticlimactic,
since
&lt;a href=&quot;https://www.veripool.org/wiki/verilator&quot;&gt;Verilator&lt;/a&gt;
did most of the work for us.  Building the library depends
upon the source files
&lt;a href=&quot;https://www.veripool.org/wiki/verilator&quot;&gt;Verilator&lt;/a&gt;
just built for us.  Making things even easier,
&lt;a href=&quot;https://www.veripool.org/wiki/verilator&quot;&gt;Verilator&lt;/a&gt;
just generated its own make file.  Hence,
we’ll just recursively call make on that make file to build all that’s left.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-makefile&quot; data-lang=&quot;makefile&quot;&gt;&lt;span class=&quot;nl&quot;&gt;.PHONY&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;library&lt;/span&gt;
&lt;span class=&quot;nl&quot;&gt;library&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;$(VDIRFB)/Vtestbus.h&lt;/span&gt;
	&lt;span class=&quot;nv&quot;&gt;$(SUBMAKE)&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$(VDIRFB)&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;/ -f Vtestbus.mk&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This recursively calls make in the $(VDIRFB) subdirectory, and it does so
with the “-f” argument specifying that it should use as its make file
$(VDIRFB)/Vtestbus.mk.&lt;/p&gt;

&lt;p&gt;That’s about it.  The &lt;a href=&quot;https://github.com/ZipCPU/dbgbus/blob/master/bench/rtl/Makefile&quot;&gt;RTL
Makefile&lt;/a&gt;
also contains a clean target, but in general that’s all that it takes to create
a Makefile that will run
&lt;a href=&quot;https://www.veripool.org/wiki/verilator&quot;&gt;Verilator&lt;/a&gt;
to build a simulatable library.&lt;/p&gt;

&lt;h2 id=&quot;the-cpp-testbench&quot;&gt;The CPP Testbench&lt;/h2&gt;

&lt;p&gt;As &lt;a href=&quot;/blog/2017/06/21/looking-at-verilator.html&quot;&gt;we discussed when
presenting&lt;/a&gt;
&lt;a href=&quot;https://www.veripool.org/wiki/verilator&quot;&gt;Verilator&lt;/a&gt;,
&lt;a href=&quot;https://www.veripool.org/wiki/verilator&quot;&gt;Verilator&lt;/a&gt;
needs a small C++ driver program to run the simulation.&lt;/p&gt;

&lt;p&gt;The driver we are going to use for this simulation, both the
&lt;a href=&quot;https://github.com/ZipCPU/dbgbus/blob/master/bench/cpp/testb.h&quot;&gt;generic one&lt;/a&gt;
and the &lt;a href=&quot;https://github.com/ZipCPU/dbgbus/blob/master/bench/cpp/testbus_tb.cpp&quot;&gt;specific simulation
one&lt;/a&gt;,
should look very similar to the ones we built during our &lt;a href=&quot;/blog/2017/06/21/looking-at-verilator.html&quot;&gt;prior
discussion&lt;/a&gt;.
Here, we’ll look at two differences.&lt;/p&gt;

&lt;p&gt;The first is that we have made the termination criteria a touch more
general than before.  For this test bench, we’ll terminate our simulation
either whenever the $final Verilog instruction is reached (which we didn’t
use in our Verilog code), or whenever the &lt;strong&gt;o_halt&lt;/strong&gt; GPIO is asserted.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;n&quot;&gt;bool&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;TESTBUS_TB&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;done&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_done&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Verilated&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;gotFinish&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;m_done&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_core&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;o_halt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;m_done&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m_done&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;That’ll allow us to control things from within the simulation (such as by
CPU software instruction) if we’d like.&lt;/p&gt;

&lt;p&gt;The other changes are the necessary parts of putting a UART interface
onto this test bench.  We’ll do that using the
&lt;a href=&quot;https://github.com/ZipCPU/dbgbus/blob/master/bench/cpp/uartsim.cpp&quot;&gt;uartsim&lt;/a&gt;
simulator found in the
&lt;a href=&quot;https://github.com/ZipCPU/wbuart32&quot;&gt;wbuart&lt;/a&gt; repository.  There just a couple
of steps there.&lt;/p&gt;

&lt;p&gt;First, we initialize the UART component module with a zero, indicating that
we want the UART to interact with us using stdin/stdout.  We’ll adjust that
later so that we can interact over TCP/IP.&lt;/p&gt;

&lt;p&gt;Second, the UART simulator needs to know the baud rate we are using to
communicate with.  This needs to be the same as the UART configuration
parameter found within our
&lt;a href=&quot;https://github.com/ZipCPU/dbgbus/blob/master/bench/rtl/testbus.v&quot;&gt;testbus.v&lt;/a&gt;.
If you wish to run this on your hardware, you may need to
adjust the parameter in the
&lt;a href=&quot;https://github.com/ZipCPU/dbgbus/blob/master/bench/rtl/testbus.v&quot;&gt;testbus.v&lt;/a&gt;
top level file, as well as in this file–to make sure you are communicating
at a common baud rate.  Otherwise, we’ll just assume that one baud is 25 clock
ticks.  You can check the &lt;a href=&quot;https://github.com/ZipCPU/wbuart32/blob/master/doc/spec.pdf&quot;&gt;UART component specification
document&lt;/a&gt; for more
information on how to understand this setup value.&lt;/p&gt;

&lt;p&gt;That’s it for setting up the C++ portion of the simulation!  All that’s left
is to build it and test it.&lt;/p&gt;

&lt;h2 id=&quot;the-cpp-makefile&quot;&gt;The CPP Makefile&lt;/h2&gt;

&lt;p&gt;For building our simulation executable, we return to the Makefile necessary
to do it.  What we want to do is really quite simple.  We’d like to issue
a command such as,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-makefile&quot; data-lang=&quot;makefile&quot;&gt;&lt;span class=&quot;nl&quot;&gt;testbus_tb&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
	&lt;span class=&quot;nv&quot;&gt;$(CXX)&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$(CFLAGS)&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$(OBJECTS)&lt;/span&gt;&lt;span class=&quot;err&quot;&gt; -o $@&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;where $(OBJECTS) are the object files we need, and $(CFLAGS) are whatever
flags we wish to build with.  Our final solution will be just about that simple.&lt;/p&gt;

&lt;p&gt;The questions remaining are, what flags, what objects, and how do we build
those objects.  The
&lt;a href=&quot;https://github.com/ZipCPU/dbgbus/blob/master/bench/cpp/Makefile&quot;&gt;Makefile&lt;/a&gt;
itself includes dependency generation, but we can leave that as a topic for
another day or perhaps even for another blog.&lt;/p&gt;

&lt;p&gt;For the first question, which flags shall we use, its in many ways up to you.
We’ll use the “-Og” flag to turn on the optimizer, although any optimizations
should really also be a flag to
&lt;a href=&quot;https://www.veripool.org/wiki/verilator&quot;&gt;Verilator&lt;/a&gt;
as well.  Here, we’ll also use the 
“-Wall” flag as well to see if we can encourage g++ to find any bugs in our
code.  We’ll also need to tell
the C++ compiler to look for the include files found both in our RTL/obj_dir
directory, as well as those found in the
&lt;a href=&quot;https://www.veripool.org/wiki/verilator&quot;&gt;Verilator&lt;/a&gt;
root include directory.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-makefile&quot; data-lang=&quot;makefile&quot;&gt;&lt;span class=&quot;c&quot;&gt;# Show make how to find our compiled verilated output
&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;RTLD&lt;/span&gt;  &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; ../rtl
&lt;span class=&quot;nv&quot;&gt;VOBJDR&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$(RTLD)&lt;/span&gt;/obj_dir
&lt;span class=&quot;c&quot;&gt;# Show make how to find Verilators support files
&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;VROOT&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$(VERILATOR_ROOT)&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;VINCD&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$(VROOT)&lt;/span&gt;/include
&lt;span class=&quot;c&quot;&gt;# Generate a full include list
&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;INCS&lt;/span&gt;  &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; -I&lt;span class=&quot;nv&quot;&gt;$(VINCD)&lt;/span&gt; -I&lt;span class=&quot;nv&quot;&gt;$(VOBJDR)&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;# Build our C-Flags
&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;CFLAGS&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; -Og -g -Wall &lt;span class=&quot;nv&quot;&gt;$(INCS)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;You might also wish to set the VERILATOR_ROOT directory.  On my system, this
is found in “/usr/share/verilator”, but that’s not the same among all systems.
At the encouragement of others who’ve tried my code, I’ve switched to:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-makefile&quot; data-lang=&quot;makefile&quot;&gt;&lt;span class=&quot;nv&quot;&gt;VERILATOR_ROOT&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;?=&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;$(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;shell&lt;/span&gt; bash -c &lt;span class=&quot;s1&quot;&gt;&#39;verilator -V|grep VERILATOR_ROOT | head -1 | sed -e &quot; s/^.*=\s*//&quot;&#39;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This will call a shell script, which will run “verilator -V” (try it!).  The
output is then searched for VERILATOR_ROOT.  Since
&lt;a href=&quot;https://www.veripool.org/wiki/verilator&quot;&gt;Verilator&lt;/a&gt;
produces two lines with this value within it, we
grab the first one and use it.  Further, we’ll only do so if VERILATOR_ROOT
isn’t already set–perhaps from a parent make file (that’s what the ?= does).&lt;/p&gt;

&lt;p&gt;The next question is, what objects do we need to include?  First, there’s
the obvious one, we’ll need to include testbus_tb.o.  We’ll also want to 
include the
&lt;a href=&quot;https://www.veripool.org/wiki/verilator&quot;&gt;Verilator&lt;/a&gt;
class definition library from Vtestbus__ALL.a.
Going one step further, we’ll want to include our &lt;a href=&quot;https://github.com/ZipCPU/dbgbus/blob/master/bench/cpp/uartsim.cpp&quot;&gt;UART
simulation&lt;/a&gt;
object file, uartsim.o.  Finally, we’ll want to include the tw
&lt;a href=&quot;https://www.veripool.org/wiki/verilator&quot;&gt;Verilator&lt;/a&gt;
files, verilated.cpp and verilated_vcd_c.cpp once compiled to object files.
This is as easy as:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-makefile&quot; data-lang=&quot;makefile&quot;&gt;&lt;span class=&quot;nv&quot;&gt;VSRCRAW&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; verilated.cpp verilated_vcd_c.cpp
&lt;span class=&quot;nv&quot;&gt;VSRC&lt;/span&gt;    &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;addprefix &lt;span class=&quot;nv&quot;&gt;$(VINCD)&lt;/span&gt;/,&lt;span class=&quot;nv&quot;&gt;$(VSRCRAW)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;VOBJ&lt;/span&gt;    &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;addprefix &lt;span class=&quot;nv&quot;&gt;$(OBJDIR)&lt;/span&gt;/,&lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;subst .cpp,.o,&lt;span class=&quot;nv&quot;&gt;$(VSRCRAW)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;SOURCES&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; testbus_tb.cpp uartsim.cpp
&lt;span class=&quot;nv&quot;&gt;OBJECTS&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;addprefix &lt;span class=&quot;nv&quot;&gt;$(OBJDIR)&lt;/span&gt;/,&lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;subst .cpp,.o,&lt;span class=&quot;nv&quot;&gt;$(SOURCES)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$(VOBJ)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;To build the sources into object files, we’ll add two generic build rules.
The first will apply for the objects built from this directory.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-makefile&quot; data-lang=&quot;makefile&quot;&gt;&lt;span class=&quot;nl&quot;&gt;$(OBJDIR)/%.o&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;%.cpp&lt;/span&gt;
	&lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;mk-objdir&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;nv&quot;&gt;$(CXX)&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$(CFLAGS)&lt;/span&gt;&lt;span class=&quot;err&quot;&gt; -c $&amp;lt; -o $@&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;If you are not as familiar with make files, the first line specifies a generic
pattern: files within the current directory and ending with .cpp can be
turned into object files in the $(OBJDIR)/ directory having the same name but
the .o suffix instead.&lt;/p&gt;

&lt;p&gt;The second line, $(mk-objdir), calls a function
that we’ll define elsewhere in our makefile that builds our object file
directory, $(OBJDIR).  While it’s not necessary to place your build products
in a separate object file directory, I find that it both cleans up the
main source directory, and it also provides options later in case you need
to build on multiple systems.&lt;/p&gt;

&lt;p&gt;The third line is used to call your C++ compiler,
to give it the CFLAGS variable, and to ask it to produce an object file (-c)
rather than a completed program.  Other make file variables include the name
of the source file that tripped the rule, $&amp;lt;, and tell it to place the output
(-o) into $@–the result the rule is supposed to produce.&lt;/p&gt;

&lt;p&gt;We repeat this for the
&lt;a href=&quot;https://www.veripool.org/wiki/verilator&quot;&gt;Verilator&lt;/a&gt;
source files in the
&lt;a href=&quot;https://www.veripool.org/wiki/verilator&quot;&gt;Verilator&lt;/a&gt;
include directory,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-makefile&quot; data-lang=&quot;makefile&quot;&gt;&lt;span class=&quot;nl&quot;&gt;$(OBJDIR)/%.o&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;$(VIND)/%.cpp&lt;/span&gt;
	&lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;mk-objdir&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;nv&quot;&gt;$(CXX)&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$(CFLAGS)&lt;/span&gt;&lt;span class=&quot;err&quot;&gt; -c $&amp;lt; -o $@&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Since we’ve already presented the final rule, that’s about all there is to
the makefile necessary to generate this simulation.&lt;/p&gt;

&lt;p&gt;Should you need to build a make file of your own, you might wish to start
from this one and just change the names of the files necessary to run your
simulation.&lt;/p&gt;

&lt;h2 id=&quot;simple-tests&quot;&gt;Simple Tests&lt;/h2&gt;

&lt;p&gt;We now have a
&lt;a href=&quot;https://github.com/ZipCPU/dbgbus/blob/master/bench/rtl/Makefile&quot;&gt;Makefile&lt;/a&gt; in
&lt;a href=&quot;https://github.com/ZipCPU/dbgbus/tree/master/bench/rtl&quot;&gt;bench/rtl&lt;/a&gt;
that will compile our debug bus and a test wishbone interconnect into
a C++ class.  We also have a
&lt;a href=&quot;https://github.com/ZipCPU/dbgbus/blob/master/bench/cpp/Makefile&quot;&gt;Makefile&lt;/a&gt; in
&lt;a href=&quot;https://github.com/ZipCPU/dbgbus/tree/master/bench/cpp&quot;&gt;bench/cpp&lt;/a&gt; that can
then be used to build the project into an executable.  Shall we run our
executable?&lt;/p&gt;

&lt;p&gt;Let’s try it out.  The only caution before starting is that this program as
written will generate megabytes of trace information very quickly.  That trace
file, if you aren’t careful, may very well fill up your hard drive.  So, don’t
leave the simulator running at the end of each test.&lt;/p&gt;

&lt;p&gt;With all that said, let’s run the program:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;./testbus_tb&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Now that it’s running, it’s waiting for an input.  So, let’s
try reading our constant address.  If you type,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;A2040R&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;your design will return “A00002040R20170622”.  The first number, A00002040,
indicates the address that we just changed the interface to.
The second number (starting with the R)
indicates the value we just read: 0x20170622.&lt;/p&gt;

&lt;p&gt;Let’s try another.  Let’s try reading that counter, and let’s do it
a couple of times.  The counter itself is at address 0x204c.  However, if you
remember from &lt;a href=&quot;/blog/2017/06/08/simple-wb-master.html&quot;&gt;when we built our simple bus
master&lt;/a&gt;
we chose to use the LSB as indication of whether or not the address should
increment between reads.  By setting it to zero, we’ll keep the address
constant between subsequent read commands.  For this reason, we can issue
an address command, followed by several read commands and they’ll all read
from the same address:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;A204dR
R
R
R&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Make sure you type the newlines between the R’s!  This bus isn’t yet robust
enough to handle more than one command given to it at once.  (It needs FIFO
support.)  Still, I get the response:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;A0000204dR000485b4
0005234b
0005cbf1
00068df3&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Not bad.  Looks like we’ve got something working.&lt;/p&gt;

&lt;p&gt;Can we trigger an interrupt?  You may remember that we had an interrupt
tied to the LSB of address 0x2050.  So, let’s write to 0x2051 to trigger,
clear, and then trigger this interrupt again
I’ll prefix the commands I typed with a “&amp;lt; “, so you can see the responses
in line.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&amp;lt; A2051RW1
A00002051R00000000K00000000I
&amp;lt; W0
K00000000
&amp;lt; W1
I
K00000000
&amp;lt; W0
K00000000&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Did you see the “I” response?  That tells us we triggered our interrupt
as desired.&lt;/p&gt;

&lt;p&gt;How about the
&lt;a href=&quot;https://github.com/ZipCPU/dbgbus/blob/master/bench/rtl/wbscope.v&quot;&gt;scope&lt;/a&gt;
we put &lt;a href=&quot;https://github.com/ZipCPU/dbgbus/blob/master/bench/rtl/testbus.v&quot;&gt;on
board&lt;/a&gt;?  Can
we trigger the scope?  Let’s first
read the scope’s control register, then write to a &lt;a href=&quot;https://github.com/ZipCPU/dbgbus/master/bench/rtl/memdev.v&quot;&gt;block
RAM&lt;/a&gt; memory address
(triggering the scope), and then read the
&lt;a href=&quot;https://github.com/ZipCPU/dbgbus/blob/master/bench/rtl/wbscope.v&quot;&gt;scope&lt;/a&gt;’s
control register again:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&amp;lt; A02080R
A00002080R12a001fc
&amp;lt; A4000Wdeadbeef
A00004000K00000000I
&amp;lt; A2080R
Z
A00002080R72a001fc
&amp;lt; A4000R
A00004000Rdeadbeef&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The first command (A02080R) reads from the scopes control register.  If you
look up 0x12a001fc in the &lt;a href=&quot;https://github.com/ZipCPU/wbscope/blob/master/doc/spec.pdf&quot;&gt;wishbone scope specification
document&lt;/a&gt;, you’ll
learn several things about the scope’s state as given by this number.  First,
the high order nibble of ‘1’ indicates that the scope is primed but hasn’t
triggered yet.  Second, the ‘2’ indicates that the DATA pointer within the
scope is set to the beginning of the scope’s memory (where we’d expect it). 
Third, the ‘a’ indicates that the scope has been configured for 2^10 samples of
memory.  Last, the ending 0x01fc tells us that the scope will wait 0x01fc
samples after the trigger, placing our event roughly within the center of
its collection window.&lt;/p&gt;

&lt;p&gt;The second command, A4000Wdeadbeef, writes 0xdeadbeef to the first location
in block RAM (address 0x4000).  Since we are also using wishbone accesses to
that location to
trigger our scope, an “I” is also returned together with the acknowledgement
(‘K’).  Incidentally, we’ll need to reset the scope in order for this interrupt
to clear, so don’t expect any more interrupt indications for a while.&lt;/p&gt;

&lt;p&gt;The third command, “A2080R” reads from the scope control register again.
It now has a value of 0x72a001fc.  Looking at the top nibble, the ‘7’
indicates that the scope has not only been triggered, but that it has also
stopped collecting.&lt;/p&gt;

&lt;p&gt;Shall we read from the scope as well?  Let’s read from address 0x2084, with
the increment bit set to prohibit address increments between reads (i.e.,
addres 0x2085):&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&amp;lt; A2080R
A00002080R12a001fc
&amp;lt; A4000Wdeadbeef
A00004000K00000000I
&amp;lt; A2080R
A00002080R72a001fc
&amp;lt; A2085R
A00002085R001b6c00
&amp;lt; R
R001b6c00
&amp;lt; R
R001b6c00
&amp;lt; R
R001b6c00
&amp;lt; R
R001b6c00&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;We’ve now read our first several values out of the scope!  All three values
were 0x1b6c00.  Sure, there’s more interesting information within the scope,
but we’ll have to dig further into the scope to get it.  The big problem
with getting there, though, is that typing 1024 “R”s to get through all the
values in this scope is going to get old &lt;em&gt;real fast&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;We’ve also found some annoying features in the protocol as well.  For example,
there’s no reason why a write acknowledgement should produce 8-zeros,
or why an address response to address 0x2080 should produce the extra four
leading zeros.  Another &lt;em&gt;really&lt;/em&gt; annoying feature of not having a FIFO is that
we can’t cut/copy/paste into our interface–that would be a nice feature. 
Still, having valid answers is a good first start!&lt;/p&gt;

&lt;p&gt;You can also look in your directory and find a trace.vcd file containing the
trace information we made.  Feel free to run “gtkwave trace.vcd” and explore
what took place after each interaction.&lt;/p&gt;

&lt;h2 id=&quot;next-in-the-series&quot;&gt;Next in the Series&lt;/h2&gt;

&lt;p&gt;As with many FPGA capabilities, building it just the way you want it can take
several iterations.  We’ve got some more iterations yet left in this design.&lt;/p&gt;

&lt;p&gt;We’re still missing two final capabilities before we put this series to rest
and move on to other topics.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;We’d like to have a &lt;a href=&quot;/blog/2017/06/16/dbg-bus-forest.html&quot;&gt;software
interface&lt;/a&gt;
to debug both our FPGA and our simulation.&lt;/p&gt;

    &lt;p&gt;If you haven’t noticed, typing hexadecimal commands and values, and
interpreting hexadecimal results isn’t very intuitive.  Indeed, it’s
out right &lt;em&gt;cryptic&lt;/em&gt;!  We’ll fix this by switching from this by-hand interface
to a software interface.&lt;/p&gt;

    &lt;p&gt;That software interface has been written, though not yet posted at this time.
(Any &lt;a href=&quot;https://www.patreon.com/ZipCPU&quot;&gt;Patreon supporters&lt;/a&gt; want to try an
early version?) You’ll find it a whole lot easier to interact with large
amounts of data over a software driven interface.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;We want to be able to debug our simulation just like we would debug the
hardware, by using a &lt;a href=&quot;/blog/why-network-debugging&quot;&gt;network enabled
interface&lt;/a&gt;.  The
&lt;a href=&quot;https://github.com/ZipCPU/dbgbus/blob/master/bench/cpp/uartsim.cpp&quot;&gt;UART simulator&lt;/a&gt; has this capability within it already.  Our hardware does not.
Hence, we’d like to take a program like the
&lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/sw/host/netuart.cpp&quot;&gt;netuart&lt;/a&gt;
from the &lt;a href=&quot;https://github.com/ZipCPU/zbasic&quot;&gt;basic ZipCPU&lt;/a&gt; repository and
incorporate it into this debugging bus.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;It may now be time to go back and consider the difference between the
&lt;a href=&quot;/blog/2017/06/02/design-process.html&quot;&gt;student’s design process and the expert’s design
process&lt;/a&gt;.  Consider
how much work it has taken to build this design, and then consider the typical
student project.  The difference helps to illustrate why what we are building
is a tool that a professional might use.  The reason is simply that building it
takes time.  In the case of the professional, the time is spent once, and the
tool used many times over.  In the case of the student who is trying to build
a design from start to finish within a semester, the student often doesn’t
realize the value of the tool he doesn’t have.&lt;/p&gt;
</description>
        <pubDate>Mon, 26 Jun 2017 00:00:00 -0400</pubDate>
        <link>http://zipcpu.com/blog/2017/06/26/dbgbus-verilator.html</link>
        <guid isPermaLink="true">http://zipcpu.com/blog/2017/06/26/dbgbus-verilator.html</guid>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>My own FPGA debugging philosophy</title>
        <description>&lt;p&gt;Many individuals have read my previous posts and have wondered what my debugging
philosophy actually is.  They’ve asked me how I would recommend debugging
a design.  This post attempts to outline the general approaches
I used to debug &lt;a href=&quot;https://github.com/ZipCPU&quot;&gt;my own FPGA designs&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;In quick sum:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Simulation&lt;/strong&gt;: I recommend using a simulator that allows allows you to
simulate all of the external components of your design in a fully
integrated fashion&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Hardware testing&lt;/strong&gt;: I recommend including some form of
integrated logic analyzer or scope within your design when you move
into hardware.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;While I tend to use open source products, I have nothing against commercial
products that will help a designer accomplish his purpose.&lt;/p&gt;

&lt;p&gt;That said, let’s take a look at my own debugging philosophy in more detail.&lt;/p&gt;

&lt;h2 id=&quot;simulation&quot;&gt;Simulation&lt;/h2&gt;

&lt;p&gt;Because implementing logic on an FPGA can take so long to do, I am a firm
believer in using a simulation.&lt;/p&gt;

&lt;table style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 1: Simulation&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/dbg-by-sim.svg&quot; alt=&quot;Parts of Debugging an FPGA via Simulation&quot; width=&quot;360&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;FPGA’s often need to communicate with external devices, though, and those
external devices need to respond to the simulated logic and the test designer
as though they were present in hardware.&lt;/p&gt;

&lt;p&gt;I recommend, therefore, for those components of an FPGA design that need to
interact with an external device, that the simulation facility provide an
external component simulator and interface validator &lt;em&gt;for each external
component&lt;/em&gt; the digital logic needs to interact with.  By component simulator,
I mean something that creates inputs and treats outputs like the real hardware
component would.  By interface validator, I mean something that will quickly
draw the developer’s attention to any violations in the interface protocol.&lt;/p&gt;

&lt;p&gt;This means that the minimum capability I would require of any simulation
capability is the ability to simulate &lt;em&gt;all&lt;/em&gt; of the external components on my design.
Were this a commercial capability, I would want to be able to integrate
my own external component simulations as well as any external component
simulations produced by multiple (possibly competing) vendors.&lt;/p&gt;

&lt;table style=&quot;float: left; padding: 15px&quot;&gt;&lt;caption&gt;Fig 2: Integrated Simulation&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/dbg-by-integrated-sim.svg&quot; alt=&quot;Integrating Sim Components into a Fullblown Simulator&quot; width=&quot;360&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;This minimum capability would allow me to simulate my entire, integrated design,
as shown in Fig 2.  That is, I should be able to integrate all of these
component simulators into an integrated design simulation.&lt;/p&gt;

&lt;p&gt;Does your design have a &lt;em&gt;UART&lt;/em&gt; within it?  Your simulation should then be able
to &lt;a href=&quot;https://github.com/ZipCPU/wbuart32/blob/master/bench/cpp/uartsim.cpp&quot;&gt;simulate a
UART&lt;/a&gt;. 
Your design should be able to create a UART waveform, and your external
component simulator should be able to process it and perhaps place the result
on your simulation terminal.  You should be able to type into that simulation
terminal anything and have it sent to your external UART simulator. 
The external component simulator should then translate anything it reads, and
send it into your design as a proper UART signal.&lt;/p&gt;

&lt;p&gt;Does your design have a flash component within it?  You should be able to start
up, erase, program, and read from that flash as a &lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/sim/verilated/qspiflashsim.cpp&quot;&gt;part of your
simulation&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Does your design include &lt;em&gt;buttons or switches&lt;/em&gt;?  You should be able to simulate
buttons and switches, and your simulations should be good enough to test any
debouncing capability you might have.&lt;/p&gt;

&lt;p&gt;Does your design have an &lt;em&gt;SD card&lt;/em&gt; within it?  You should be able to
communicate with the &lt;a href=&quot;https://github.com/ZipCPU/sdspi/blob/master/bench/cpp/sdspisim.cpp&quot;&gt;simulated SD card&lt;/a&gt;, and even have a simulation that can match the
SD card you wish to use in your design.&lt;/p&gt;

&lt;p&gt;Does your design have a &lt;em&gt;VGA&lt;/em&gt; within it?  Your simulation should then be able
decode your VGA output, to prove that you are producing the correct
synchronization signals, and then to draw the pixels to the screen in a way
that you can verify that your VGA code works.&lt;/p&gt;

&lt;p&gt;Does your design have an &lt;em&gt;EDID component&lt;/em&gt; to it?  Your simulator should &lt;a href=&quot;https://github.com/ZipCPU/wbi2c/blob/master/bench/cpp/i2csim.cpp&quot;&gt;be
able to communicate EDID
information&lt;/a&gt;
to your design over a proper I2C port.&lt;/p&gt;

&lt;p&gt;Does your design have &lt;em&gt;(DDRx) SDRAM&lt;/em&gt; within it?  Your simulator should be able
to match the &lt;a href=&quot;https://github.com/ZipCPU/openarty/blob/master/sim/verilated/memsim.cpp&quot;&gt;SDRAM’s
capability&lt;/a&gt; in a clock for clock fashion.  You might even wish to
debug any &lt;a href=&quot;http://opencores.org/project,wbddr3&quot;&gt;DDR3 SDRAM in detail&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Does your design have a &lt;em&gt;CPU&lt;/em&gt; within it?  Your simulator should be able to
simulate the CPU, it’s booting process (using flash, if that’s what you have),
and it should allow you to see what’s going inside the CPU as it boots.
You should be able to trace the instructions your CPU executes, together with
any logic used within your design.
Do you want to be able to run a program on your CPU?  You should be able to
do that within the CPU, and it should be able to interact with its environment
in a manner similar to its real environment.&lt;/p&gt;

&lt;p&gt;This is my philosophy on simulation.&lt;/p&gt;

&lt;p&gt;As you can see, I am a firm believer in simulating your &lt;em&gt;whole design&lt;/em&gt;, not
just the components.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.veripool.org/wiki/verilator/&quot;&gt;Verilator&lt;/a&gt; meets these requirements.
Do you know of any other capability that can?  Please feel free to comment
about it in the discussion at the end of this post.&lt;/p&gt;

&lt;h2 id=&quot;hardware-testing&quot;&gt;Hardware Testing&lt;/h2&gt;

&lt;p&gt;I’m also not so naive as to believe that a design will work the first time it’s
placed in an actual FPGA.  For this reason, I am a firm believer in testing
on the actual hardware as well.&lt;/p&gt;

&lt;table style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 3: Hardware in the Loop Testing&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/dbg-by-hitl.svg&quot; alt=&quot;Parts of Debugging an FPGA via Simulation&quot; width=&quot;360&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Hardware testing includes both component testing (externally
directed, often without the CPU), as well as integrated design testing.&lt;/p&gt;

&lt;p&gt;Using your hardware, you should be able to test components by:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Issuing individual commands to them, and verifying that individual
interactions work&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Then issuing more complex strings of commands&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;In both cases, you should be able to start from a (roughly) known condition,
command the hardware to begin the test, and then be able to measure the
results of the test.  Doing this necessitates some form of internal logic
analyzer, such as the &lt;a href=&quot;https://github.com/ZipCPU/wbscope&quot;&gt;wishbone scope&lt;/a&gt; that
I use.&lt;/p&gt;

&lt;p&gt;I like to issue commands over some form of debugging bus, such as the
&lt;a href=&quot;https://github.com/ZipCPU/dbgbus/tree/master/hexbus/rtl&quot;&gt;hexbus debugging bus&lt;/a&gt;
we’ve &lt;a href=&quot;/topics.html&quot;&gt;just built together&lt;/a&gt;.  This allows me
to command various tests, and to read information and status back out of the
FPGA.  If you have a CPU on board, such as the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt;, you may wish to
command your tests in a faster and more coordinated fashion from software.&lt;/p&gt;

&lt;p&gt;Trace data itself can be drawn from something as simple as your own
&lt;a href=&quot;/blog/2017/06/08/simple-scope.html&quot;&gt;user designed scope&lt;/a&gt;, or
&lt;a href=&quot;/about/gisselquist-technology.html&quot;&gt;Gisselquist Technology&lt;/a&gt;’s
&lt;a href=&quot;https://github.com/ZipCPU/wbscope&quot;&gt;wishbone scope&lt;/a&gt;.  We’ll be discussing
in the near future how you can add the capability to create a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Value_change_dump&quot;&gt;VCD&lt;/a&gt; file to your scope.
That will finish off the discussion on how to build your own debugging
facility.&lt;/p&gt;

&lt;p&gt;Commercial products exist that can record trace information from within your
chip.  &lt;a href=&quot;https://xilinx.com&quot;&gt;Xilinx&lt;/a&gt;, for example, includes their
&lt;a href=&quot;https://www.xilinx.com/support/documentation/ip_documentation/ila/v6_2/pg172-ila.pdf&quot;&gt;Integrated Logic Analyzer (ILA)&lt;/a&gt;
as part of the &lt;a href=&quot;https://www.xilinx.com/products/design-tools/vivado.html&quot;&gt;Vivado Design
Suite&lt;/a&gt;.
You’ll &lt;a href=&quot;https://forums.xilinx.com/t5/Installation-and-Licensing/WebPACK-and-ILA/td-p/558110&quot;&gt;need more than the free webpack
license&lt;/a&gt;,
though, in order to use it.  Given how easy such an analyzer is to build,
it’s probably not work the $3k necessary to pay for a full
&lt;a href=&quot;https://www.xilinx.com/products/design-tools/vivado.html&quot;&gt;Design Suite&lt;/a&gt;
license just to use this capability.&lt;/p&gt;

&lt;p&gt;One of the benefits of rolling your own, is that integrating your own logic
analyzer into your own logic can be done with your favorite interface.
For example, I’ve often used the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt; to trigger the scope or to examine
the outputs of it.  Further, unlike a commercial scope which may be restricted
to using the JTAG for control and output, I can get the outputs via whatever
debugging bus I’m already using.&lt;/p&gt;

&lt;h2 id=&quot;your-own-choices&quot;&gt;Your own choices&lt;/h2&gt;

&lt;p&gt;These two components outline the philosophy I use to debug my own FPGA
designs.&lt;/p&gt;

&lt;p&gt;I am a firm believer in simulation.&lt;/p&gt;

&lt;p&gt;I grew up testing on the hardware itself, and see no problems with it &lt;em&gt;as long
as you can get an internal trace from your hardware&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Do you have a different debugging philosophy?  Do you know of other or better
tools?  Feel free to post and discuss them below.&lt;/p&gt;
</description>
        <pubDate>Fri, 23 Jun 2017 00:00:00 -0400</pubDate>
        <link>http://zipcpu.com/blog/2017/06/23/my-dbg-philosophy.html</link>
        <guid isPermaLink="true">http://zipcpu.com/blog/2017/06/23/my-dbg-philosophy.html</guid>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>Building a very simple wishbone interconnect</title>
        <description>&lt;p&gt;Want to build a scope?  Seriously!  Want to turn your FPGA into a scope that
can measure anything internal to your logic, and then make that information
available to you upon request?  Even better, you could use this scope to
capture samples from an external analog to digital converter if you wanted to.&lt;/p&gt;

&lt;p&gt;It’s time to do build the Verilog to do it!&lt;/p&gt;

&lt;table style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 1: WB-UART Overview&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/wb-uart-smpl-2.svg&quot; alt=&quot;Block Diagram of a Simpler Wishbone to UART converter&quot; width=&quot;360&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Ok, here’s where we are at in this process: We now have all of the components
necessary to build a debugging bus interface.  We’ve now built &lt;em&gt;all&lt;/em&gt; of the
components outlined in Fig 1 to the right.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;We’ve presented an &lt;a href=&quot;/blog/2017/06/05/wb-bridge-overview.html&quot;&gt;overview of a UART to wishbone
bridge&lt;/a&gt;, that
can be used for debugging.  This overview presented not only how to
build such a bridge, but also showed examples from a working one that I use.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;We then jumped to the end to discuss how to build a &lt;a href=&quot;/blog/2017/06/08/simple-wb-master.html&quot;&gt;Simple Wishbone
Master&lt;/a&gt;.  While the
principles there can be applied to creating any
&lt;a href=&quot;https://opencores.org/opencores,wishbone&quot;&gt;Wishbone&lt;/a&gt; master interface,
we’ve shown how to use the &lt;a href=&quot;https://github.com/ZipCPU/dbgbus/blob/master/hexbus/rtl/hbexec.v&quot;&gt;code presented
there&lt;/a&gt;
as part of our own debugging interface.  In particular, it’s the
&lt;a href=&quot;https://opencores.org/opencores,wishbone&quot;&gt;Wishbone&lt;/a&gt; master
we’ll use today.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;We showed how you can use the inputs from a serial port to &lt;a href=&quot;/blog/2017/06/14/creating-words-from-bytes.html&quot;&gt;create bus
command words&lt;/a&gt;.  That finished out our discussion of the input to this bus.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;We then showed how to &lt;a href=&quot;/blog/2017/06/15/words-back-to-bytes.html&quot;&gt;turn the bus master responses back into a serial
stream&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Before we finished, we added &lt;a href=&quot;/blog/2017/06/16/adding-ints.html&quot;&gt;interrupt notifications to our
interface&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;And then we &lt;a href=&quot;/blog/2017/06/16/adding-ints.html&quot;&gt;added an idle indication&lt;/a&gt; to the interface as well, so that we can have some confidence
that the interface is running on any given serial port / transport.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The final post in the building the bus master interface was a post
describing &lt;a href=&quot;/blog/2017/06/20/dbg-put-together.html&quot;&gt;how to put it all
together&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Today, we’re going to build something that this interface can interact with.
When we’re done, the result won’t (yet) look like something a professional
tool might produce, but it’ll be enough for a demonstration.  We’ll
save the professional looking part for another lesson.&lt;/p&gt;

&lt;h2 id=&quot;our-components&quot;&gt;Our Components&lt;/h2&gt;

&lt;p&gt;If we want to build a bus that connects things together, the first step is going
to be collecting the components together that we want to interface with.
So, I’ve pulled several components from other designs that I have.
I’ve also adjusted their copyright so that, as part of this project, you can
have access to these components under the
&lt;a href=&quot;https://www.gnu.org/licenses/lgpl-3.0.en.html&quot;&gt;LGPL&lt;/a&gt;.  These
components include:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;A &lt;a href=&quot;https://github.com/ZipCPU/dbgbus/blob/master/bench/rtl/memdev.v&quot;&gt;block
RAM&lt;/a&gt;
  &lt;a href=&quot;https://opencores.org/opencores,wishbone&quot;&gt;Wishbone&lt;/a&gt; memory slave
drawn from the &lt;a href=&quot;https://github.com/ZipCPU/zbasic&quot;&gt;zbasic&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;ZipCPU&lt;/a&gt; repository.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;A &lt;a href=&quot;https://github.com/ZipCPU/dbgbus/blob/master/bench/rtl/wbscope.v&quot;&gt;wishbone scope&lt;/a&gt;.
drawn from the &lt;a href=&quot;https://github.com/ZipCPU/wbscope&quot;&gt;wbscope&lt;/a&gt; repository.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;A simplified UART
&lt;a href=&quot;https://github.com/ZipCPU/dbgbus/blob/master/bench/rtl/txuartlite.v&quot;&gt;transmitter&lt;/a&gt; and
&lt;a href=&quot;https://github.com/ZipCPU/dbgbus/blob/master/bench/rtl/rxuartlite.v&quot;&gt;receiver&lt;/a&gt;,
drawn from the &lt;a href=&quot;https://github.com/ZipCPU/wbuart32&quot;&gt;wbaurt32&lt;/a&gt; repository.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;As a legal note, the RTL designs these examples were taken from still remain
firmly under the &lt;a href=&quot;https://www.gnu.org/licenses/gpl-3.0.en.html&quot;&gt;GPL&lt;/a&gt;, only
these specific component files have been given a new copyright.&lt;/p&gt;

&lt;table style=&quot;float: left; padding: 15px&quot;&gt;&lt;caption&gt;Fig 2: System Diagram&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/sample-interconnect.svg&quot; alt=&quot;An example WB interconnect&quot; width=&quot;420&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Of course, we’ll also be using the &lt;a href=&quot;https://github.com/ZipCPU/dbgbus/tree/master/hexbus&quot;&gt;hexbus debugging
interface&lt;/a&gt; we’ve just
developed and presented as part of this blog.&lt;/p&gt;

&lt;p&gt;The basic design is going to be similar to Fig 1, but with the new components
added in as part of the bus, as shown in Fig 2.&lt;/p&gt;

&lt;p&gt;Of these new components, the only one we haven’t discussed is a simple
ad hoc component that we’ll discuss below, and that you can use to get access
to arbitrary values within your design, and so that you have a little bit of
an example of some of the things that can be done.&lt;/p&gt;

&lt;h2 id=&quot;connecting-the-components&quot;&gt;Connecting the components&lt;/h2&gt;

&lt;p&gt;There are three parts to connecting components to a
&lt;a href=&quot;https://opencores.org/opencores,wishbone&quot;&gt;Wishbone&lt;/a&gt; bus.
First, you must decode the components’ address, so that only the proper
component is addressed.
Second, you must merge the three basic
&lt;a href=&quot;https://opencores.org/opencores,wishbone&quot;&gt;Wishbone&lt;/a&gt;
slave outputs back into one
response to be returned to the master.  These include the &lt;strong&gt;_ack&lt;/strong&gt; line,
the &lt;strong&gt;_stall&lt;/strong&gt; line, and the return &lt;strong&gt;_data&lt;/strong&gt; line.
Third, although not required, painful prior errors have taught me to always
create a &lt;strong&gt;wb_err&lt;/strong&gt; return line, and to set that any time a non-existent
component is addressed.  Further, along those same lines, we’re going to
make sure that no components occupy the NULL address.&lt;/p&gt;

&lt;h3 id=&quot;wiring-up-the-bus-master&quot;&gt;Wiring up the bus master&lt;/h3&gt;

&lt;p&gt;Prior to the first step, though, we’ll need to wire up our UART receiver, our
debugging bus
&lt;a href=&quot;https://opencores.org/opencores,wishbone&quot;&gt;Wishbone&lt;/a&gt;
master, and our UART transmitter.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;rxuartlite #(UARTSETUP) rxtransport(i_clk,
				i_uart, rx_stb, rx_data);

hbbus	genbus(i_clk,
	// The receive transport wires
	rx_stb, rx_data,
	// The bus control output wires
	wb_cyc, wb_stb, wb_we, wb_addr, wb_odata, wb_sel,
	//	The return bus wires
	  wb_ack, wb_stall, wb_err, wb_idata,
	// An interrupt line
	bus_interrupt,
	// The return transport wires
	tx_stb, tx_data, tx_busy);

txuartlite #(UARTSETUP) txtransport(i_clk,
				tx_stb, tx_data, o_uart, tx_busy);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This is primarily an exercise in wire management: the outputs of the
&lt;a href=&quot;https://github.com/ZipCPU/wbuart32/blob/master/rtl/rxuartlite.v&quot;&gt;receiver&lt;/a&gt;
go into the &lt;a href=&quot;https://github.com/ZipCPU/dbgbus/tree/master/hexbus&quot;&gt;hexbus&lt;/a&gt;,
and the outputs from the
&lt;a href=&quot;https://github.com/ZipCPU/dbgbus/tree/master/hexbus&quot;&gt;hexbus&lt;/a&gt; decoder
go into the
&lt;a href=&quot;https://github.com/ZipCPU/wbuart32/blob/master/rtl/txuartlite.v&quot;&gt;transmitter&lt;/a&gt;
and control the wishbone bus. Still, one particular
parameter needs some attention: the &lt;strong&gt;UARTSETUP&lt;/strong&gt;.  This parameter is
defined within the &lt;a href=&quot;https://github.com/ZipCPU/wbuart32&quot;&gt;wbuart32&lt;/a&gt; project.
If we want to communicate using 8-bits per baud, no parity, and one
stop bit, (8N1) then we can set this parameter simply to the number of clocks
per baud.  Hence, if we want to run our interface at 4MBaud with a
100MHz clock, we should set this to (100MHz/4MBaud) or 25.&lt;/p&gt;

&lt;h3 id=&quot;the-address-select-lines&quot;&gt;The address select lines&lt;/h3&gt;

&lt;p&gt;Next, let’s handle our address select lines.  We’ll support three basic
components, and we’ll use the prefixes of &lt;strong&gt;smpl_&lt;/strong&gt; (for our ad-hoc
registers), &lt;strong&gt;mem_&lt;/strong&gt; (for our block RAM) and &lt;strong&gt;scop_&lt;/strong&gt; to describe them.
Handling address selection is done in two parts.  For the first part,
we just test whether or not the
&lt;a href=&quot;https://opencores.org/opencores,wishbone&quot;&gt;Wishbone&lt;/a&gt;
address matches the address we’ve given to this component:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;// Nothing should be assigned to the null page
assign	smpl_sel = (wb_addr[29:4] == 26&#39;h081);	// 0x00002040
assign	scop_sel = (wb_addr[29:4] == 26&#39;h082);	// 0x00002080
assign	mem_sel  = (wb_addr[29:12] ==18&#39;h1);	// 0x00004000&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;One caution is in order: our bus address lines reference 32-bit words, not
octets.   Address 0x810 above references one 32-bit word, while address
0x811 references
another 32-bit word.  Most people are more familiar with accessing a bus where
the address is in units of octets.  For this reason, we’ve written out the
octet equivalent of each address in the comment to the right.  This equivalent
is given by shifting the address up by two, as well as by the number of
unspecified bits (4 or 12) in the address.&lt;/p&gt;

&lt;p&gt;This is actually a good time to point out that there’s really a &lt;em&gt;lot&lt;/em&gt; more
work to be done to do address assignment properly than just these simple
decode lines above.
A specification document needs to be written outlining what addresses are
being used for what, the addresses need to be turned into C/C++ address
references for the &lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/sw/host/wbregs.cpp&quot;&gt;peek/poke by name
interface&lt;/a&gt; and
the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu&quot;&gt;CPU&lt;/a&gt;, and more.
Here, we’re just going to wave our hands and assign these three address groups
to peripherals.&lt;/p&gt;

&lt;p&gt;We’ll probably have to come back and fix this lack in the near future.&lt;/p&gt;

&lt;h3 id=&quot;bus-errors&quot;&gt;Bus Errors&lt;/h3&gt;

&lt;p&gt;I usually define a
&lt;a href=&quot;https://opencores.org/opencores,wishbone&quot;&gt;Wishbone&lt;/a&gt;
bus error as one of three things.  First, it is an error if &lt;em&gt;nothing is
selected&lt;/em&gt; during a
&lt;a href=&quot;https://opencores.org/opencores,wishbone&quot;&gt;Wishbone&lt;/a&gt;
operation.  Second, it is an
error if &lt;em&gt;more than one&lt;/em&gt; thing is ever selected.  Finally, it is an error if
&lt;em&gt;more than one acknowledgement&lt;/em&gt; is returned on any given clock.  For our
example purposes here, we’ll only set the error is nothing is selected.
That is, if the &lt;strong&gt;wb_stb&lt;/strong&gt; signal is high indicating a
&lt;a href=&quot;https://opencores.org/opencores,wishbone&quot;&gt;Wishbone&lt;/a&gt;
request, and yet the address in &lt;strong&gt;wb_addr&lt;/strong&gt; doesn’t reference any of our
components, then a bus error should be returned.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;// This will be true if nothing is selected
assign	none_sel = (!smpl_sel)&amp;amp;&amp;amp;(!scop_sel)&amp;amp;&amp;amp;(!mem_sel);

// The wishbone error signal is true for one clock only, and then it
// resets itself
always @(posedge i_clk)
	wb_err &amp;lt;= (wb_stb)&amp;amp;&amp;amp;(none_sel);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The &lt;a href=&quot;https://opencores.org/opencores,wishbone&quot;&gt;Wishbone&lt;/a&gt;
&lt;a href=&quot;https://opencores.org/cdn/downloads/wbspec_b4.pdf&quot;&gt;spec&lt;/a&gt;,
though, isn’t as particular regarding what constitutes a
bus error, and many masters want any error detected to be aligned with where
the acknowledgement would’ve come back–so that every request ends in either
an error or an acknowledgement.  That approach allows both slaves and the
interconnect to generate errors.  The interconnect we are building today,
though is simpler, and doesn’t do that.&lt;/p&gt;

&lt;p&gt;We’ll do one more thing with the bus error: we’ll grab a copy of any bus
error address, so we can report back later the bus address associated with
any error (if necessary):&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	if (wb_err)
		bus_err_address &amp;lt;= wb_addr;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;We’ll come back to logic required of the interconnect later, once we handle
the slave produced signals.&lt;/p&gt;

&lt;h3 id=&quot;slave-response-the-stall-line&quot;&gt;Slave response: The stall line&lt;/h3&gt;

&lt;p&gt;The first slave response logic we’ll look at is the stall logic.
The &lt;a href=&quot;https://opencores.org/opencores,wishbone&quot;&gt;Wishbone&lt;/a&gt;
&lt;a href=&quot;https://opencores.org/cdn/downloads/wbspec_b4.pdf&quot;&gt;spec&lt;/a&gt;,
recommends that this logic not be clocked, and that it be only combinatorial
in nature.  In particular, you’ll want to stall the bus any time you are
trying to make a request of a component whose stall line is high.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;assign	wb_stall = ((smpl_sel)&amp;amp;&amp;amp;(smpl_stall))
		||((scop_sel)&amp;amp;&amp;amp;(scop_stall))
		||((mem_sel)&amp;amp;&amp;amp;(mem_stall));&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;For this particular bus implementation, the stall lines are just a formality.
None of these &lt;a href=&quot;https://opencores.org/opencores,wishbone&quot;&gt;Wishbone&lt;/a&gt;
slave’s will ever stall the bus.  This line is therefore 
ripe for being removed by the optimizer within your toolflow.  Here, we keep
it in case we need to add components later that might stall the bus.&lt;/p&gt;

&lt;h3 id=&quot;slave-response-the-acknowledgement&quot;&gt;Slave response: The Acknowledgement&lt;/h3&gt;

&lt;p&gt;The second slave response line is the acknowledgement line.  This is the line
that the slave uses to indicate that the data it is providing on its data line
is valid.  We’ll handle this by creating a clocked line that is simply the &lt;em&gt;or&lt;/em&gt;
of all the acknowledgement lines.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	wb_ack &amp;lt;= (smpl_ack)||(scop_ack)||(mem_ack);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;If we use a clock while assigning our data, the two resulting responses,
both acknowledgement and data, will align as required.&lt;/p&gt;

&lt;h3 id=&quot;slave-response-return-data&quot;&gt;Slave response: Return data&lt;/h3&gt;

&lt;p&gt;The final slave responses are the data lines.  These are valid any time the
acknowledgement is valid.  Indeed, we’ll use the various slave acknowledgement
lines to know which slave has produced valid data, and thus to know what data
to return to the
&lt;a href=&quot;https://opencores.org/opencores,wishbone&quot;&gt;Wishbone&lt;/a&gt; master.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	if (smpl_ack)
		wb_idata &amp;lt;= smpl_data;
	else if (scop_ack)
		wb_idata &amp;lt;= scop_data;
	else if (mem_ack)
		wb_idata &amp;lt;= mem_data;
	else
		wb_idata &amp;lt;= 32&#39;h0;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;As a touch of flair, we’ll respond with all zeros if nothing acknowledges our
bus read, although this isn’t required and it can be removed if necessary
if you are struggling to &lt;a href=&quot;/blog/2017/06/12/minimizing-luts.html&quot;&gt;minimize your
logic&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&quot;slave-response-interrupts&quot;&gt;Slave response: Interrupts&lt;/h3&gt;

&lt;p&gt;Although it’s not really a part of connecting a device to a
&lt;a href=&quot;https://opencores.org/opencores,wishbone&quot;&gt;&lt;em&gt;Wishbone&lt;/em&gt; bus&lt;/a&gt;,
many bus slaves have interrupt lines.  We’ll create an interrupt
to send back to our debugging bus controller that is simply the &lt;em&gt;or&lt;/em&gt; of our
two interrupt producing components.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;assign	bus_interrupt = (smpl_interrupt) | (scop_int);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Given the way we implemented interrupts within our controller, this will
trigger on any positive edge–so it’ll need to be reset prior to being
able to trip again.  While it’s not necessarily the optimal or the best
approach, it may be sufficient for our purposes here.&lt;/p&gt;

&lt;h3 id=&quot;connecting-the-pre-existing-components&quot;&gt;Connecting the pre-existing components&lt;/h3&gt;

&lt;p&gt;We have three components to connect our interface to.  Two of these components
already exist and only need to be referenced from here as sub-modules.  These
are the &lt;a href=&quot;https://github.com/ZipCPU/dbgbus/blob/master/bench/rtl/memdev.v&quot;&gt;block
RAM&lt;/a&gt;
interface, and the &lt;a href=&quot;https://github.com/ZipCPU/dbgbus/blob/master/bench/rtl/wbscope.v&quot;&gt;wishbone
scope&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The &lt;a href=&quot;https://github.com/ZipCPU/dbgbus/blob/master/bench/rtl/memdev.v&quot;&gt;block RAM&lt;/a&gt;
needs very little additional configuration beyond what we’ve
already done, but it does need to to be told how big its memory area will be. 
We’ll create our
&lt;a href=&quot;https://github.com/ZipCPU/dbgbus/blob/master/bench/rtl/memdev.v&quot;&gt;block RAM&lt;/a&gt;
to have 2^14 octets, hence the &lt;strong&gt;14&lt;/strong&gt; parameter below.  We’ll
also use the select line, that we set above, &lt;strong&gt;mem_sel&lt;/strong&gt;, to modify the
slaves strobe line, so the memory knows that it has been selected–without
needing to have any more knowledge of any other peripherals that might be
on the bus.  This is different from the &lt;strong&gt;wb_sel&lt;/strong&gt; line which we’ve &lt;a href=&quot;/zipcpu/2017/05/29/select-lines.html&quot;&gt;used to
determine which octets in a word will be set in any
operation&lt;/a&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;memdev	#(14) blkram(i_clk,
	wb_cyc, (wb_stb)&amp;amp;&amp;amp;(mem_sel), wb_we, wb_addr[11:0],
		wb_odata, wb_sel,
	mem_ack, mem_stall, mem_data);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The next item we’ll want to place onto our bus is the
&lt;a href=&quot;https://github.com/ZipCPU/wbscope&quot;&gt;wishbone scope&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;To use the scope, you must decide on what you wish to examine, and then
what you want to use to trigger the scope.  In our case, let’s trigger
off of any &lt;a href=&quot;https://opencores.org/opencores,wishbone&quot;&gt;Wishbone&lt;/a&gt;
accesses to our block RAM.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;assign	scope_trigger = (mem_sel)&amp;amp;&amp;amp;(wb_stb);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;We’ll also select for our scope’s data several of the bus lines.  We’ll save
for a later date how to turn these wires into a proper VCD file.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;assign	debug_data    = { wb_cyc, wb_stb, wb_we, wb_ack, wb_stall,
		wb_addr[5:0], 1&#39;b1,
			wb_odata[9:0],
			wb_idata[9:0] };&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The scope has one more capability: it can sample data based upon a “when data
is valid” flag.  The flag can be &lt;em&gt;really&lt;/em&gt; useful if you are processing a
signal that isn’t valid on every clock–such as the output of a digitizer as
an example.  Today, we’ll just set that flag to one so that we can capture
on every clock.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;assign	scope_ce = 1&#39;b1;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Now that all of the preliminaries have been taken care of, you can now place
the scope within our file, and connect it to the bus as well.  As with the
memory, the biggest part of “hooking it up” is adjusting the strobe line by
&lt;em&gt;and&lt;/em&gt;ing it with the scope select line.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;wbscope	thescope(i_clk, scope_ce, scope_trigger, debug_data,
	i_clk, wb_cyc, (wb_stb)&amp;amp;&amp;amp;(scop_sel), wb_we, wb_addr[0],wb_odata,
	scop_ack, scop_stall, scop_data,
	scop_int);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Other things you might notice are the fact that this scope requires
two clocks, one for the data and one for the bus.  In this example
thee two are the same.  It
also requires the lowest of the address lines.  The result is that address
&lt;strong&gt;0x02080&lt;/strong&gt; will reference the scope control and status register, while
address &lt;strong&gt;0x2084&lt;/strong&gt; will reference the scope data register.&lt;/p&gt;

&lt;h3 id=&quot;building-an-ad-hoc-slave&quot;&gt;Building an Ad-Hoc Slave&lt;/h3&gt;

&lt;p&gt;You will very often find that you need to be able to report some logic result
back up the bus to your debug interface–something that is ad-hoc, and not
necessarily the part of any well-defined, prebuilt component.  In many ways,
this seems to be one of the most common requests: how to I get access to
(whatever) to see what my design has done?  Therefore, let’s make a simple
ad-hoc slave that does just that.&lt;/p&gt;

&lt;p&gt;Our slave will have six registers, although it occupies enough bus space
that it could have a full sixteen–so there’s plenty of room should you wish
to expand it.  Any more than that and you’ll need to adjust the address
decoding logic above.  Laying these registers out, we’ll have:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;A read only date register&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;A simple register that you can set and read back&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The address of the last bus error&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;A counter that starts from zero on startup&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;An experimental interrupt line, that you can use to turn an interrupt on or
off, so you can see how our interface deals with an interrupt&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;A GPIO output that you can use to communicate with the
&lt;a href=&quot;https://www.veripool.org/wiki/verilator/&quot;&gt;Verilator&lt;/a&gt; simulation.
In this case, we’ll use an &lt;strong&gt;o_halt&lt;/strong&gt; flag to indicate that its time for
the simulation to halt.  You can set that as part of the LSB of this
register.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Let’s first handle the write request.  On a write, to this peripheral,
we’ll:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Handle setting the simple register to whatever input was given&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Create (or clear) an interrupt depending on the low order bit if writing
to register four&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Adjust our &lt;strong&gt;o_halt&lt;/strong&gt; GPIO value with the LSB of anything written
to register five.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Since the other registers are read only, we can ignore them on any write
request.&lt;/p&gt;

&lt;p&gt;This is therefore our write request logic:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	// Determine if a write to this peripheral is taking place
	if ((wb_stb)&amp;amp;&amp;amp;(smpl_sel)&amp;amp;&amp;amp;(wb_we))
	begin // Split our logic between the registers
		case(wb_addr[3:0])
		4&#39;h1: smpl_register  &amp;lt;= wb_odata;
		4&#39;h4: smpl_interrupt &amp;lt;= wb_odata[0];
		4&#39;h5: o_halt         &amp;lt;= wb_odata[0];
		default: begin end
		endcase
	end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;In this case, pay close attention to the if at the top, and the case below.
These should match up with our &lt;a href=&quot;/blog/2017/06/21/simple-wb-interconnect.html&quot;&gt;lesson on how to build a simple wishbone
slave&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Before reading back from this interface, let’s deal with the “clocks since
power up” counter.  We’re going to use the initial command to set this
register to zero, then while running it will count up.  Once the MSB gets set,
we’ll leave it set so that we can tell if we’ve ever rolled over.  This will
give us an ever changing counter that we can use for relative timing, or
absolute timing if near when the chip starts up.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;// Start our clocks since power up counter from zero
initial power_counter = 0;
always @(posedge i_clk)
	// Count up from zero until the top bit is set
	if (!power_counter[31])
		power_counter &amp;lt;= power_counter + 1&#39;b1;
	else // once the top bit is set, keep it set forever
		power_counter[30:0] &amp;lt;= power_counter[30:0] + 1&#39;b1;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Now that we’ve created that logic, everything is ready for us to read.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;always @(posedge i_clk)
	case(wb_addr[3:0])
	4&#39;h0:    smpl_data &amp;lt;= 32&#39;h20170622;
	4&#39;h1:    smpl_data &amp;lt;= smpl_register;
	4&#39;h2:    smpl_data &amp;lt;= { bus_err_address, 2&#39;b00 };
	4&#39;h3:    smpl_data &amp;lt;= power_counter;
	4&#39;h4:    smpl_data &amp;lt;= { 31&#39;h0, smpl_interrupt };
	default: smpl_data &amp;lt;= 32&#39;h00;
	endcase&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Notice that read logic doesn’t depend upon any bus lines other than the
address.  Indeed, the fact that a read of this device has taken place is in
many ways irrelevant–only the data being produced is relevant.  We can
produce the right result for any address in our register space regardless. 
(This isn’t true for all peripherals.)  The zero address of our peripheral
returns a constant value (of the day when I posted this).  The first address
(address 4, really) just returns the register we set above.  The second
address gives us the address of the last bus error.  The third gives us the
value of our ticks since startup counter.  The final register, at address
position four (0x2050), just returns an LSB indicating whether or not our
interrupt is set.&lt;/p&gt;

&lt;p&gt;Since the last address in our interface only contains a halt request
indicator, it will never read anything but zero, so we’re not going to
include any special logic to read it.&lt;/p&gt;

&lt;p&gt;As a final and required part of our interface, we’ll need to acknowledge the
response from the bus, and create a stall line to indicate that this ad-hoc
interface never stalls.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;// Decoding an address takes one clock, so set the ACK to be true
// on the next clock
always @(posedge i_clk)
	smpl_ack &amp;lt;= ((wb_stb)&amp;amp;&amp;amp;(smpl_sel));

// This simple interface never stalls
assign smpl_stall &amp;lt;= 1&#39;b0;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;That’s it!  You just connected a (very) simple peripheral to our debugging
bus!  Indeed, if you wanted, you could now use this approach to
&lt;a href=&quot;/blog/2017/05/29/fft-debugging.html&quot;&gt;debug an FFT&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&quot;coming-up&quot;&gt;Coming up&lt;/h1&gt;

&lt;p&gt;The &lt;a href=&quot;https://github.com/ZipCPU/dbgbus&quot;&gt;full design&lt;/a&gt;, as we’ve now built it
should run on any FPGA.  A quick test, by giving the device an address and
read request,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;A2040R&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;or similarly a hex address and a write request,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;A4000Wdeadbeef&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;should work to read or write from your device using this interface.  Further,
if nothing is going on, you should be able to see “Z”s getting sent to your
screen.&lt;/p&gt;

&lt;p&gt;Not bad.&lt;/p&gt;

&lt;p&gt;We could even read from the scope’s control and status register with a
simple read command:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;A2080R&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Another read command, such as&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;A2085R&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;will return one data value from our scope.  You might wish to notice that we
set the LSB in this address.  As a result, subsequent R’s typed into the
interface will interpreted as read commands from &lt;em&gt;the same&lt;/em&gt; 
“scope data register” address.&lt;/p&gt;

&lt;p&gt;Ok, so … this works.  But it’s still really hard to use.  This, then, gives
us our roadmap forward:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Building a
&lt;a href=&quot;https://www.veripool.org/wiki/verilator/&quot;&gt;Verilator&lt;/a&gt;
&lt;a href=&quot;/blog/2017/06/26/dbgbus-verilator.html&quot;&gt;test bench&lt;/a&gt;
to use to experiment with this bus apart from any hardware&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Building a &lt;a href=&quot;/blog/2017/06/22/simple-wb-interconnect.html&quot;&gt;software interface&lt;/a&gt; to our debugging bus, so we can use
the host CPU to our advantage when working with the design&lt;/p&gt;

    &lt;p&gt;This software interface will also make it easier for us to get the results
of any scope interactions out of our debugging harness and into a VCD
type of format that we can then use to examine what was going on within the
FPGA.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;These then will be the topics we will queue up for a later day.&lt;/p&gt;

</description>
        <pubDate>Thu, 22 Jun 2017 00:00:00 -0400</pubDate>
        <link>http://zipcpu.com/blog/2017/06/22/simple-wb-interconnect.html</link>
        <guid isPermaLink="true">http://zipcpu.com/blog/2017/06/22/simple-wb-interconnect.html</guid>
        
        
        <category>blog</category>
        
      </item>
    
  </channel>
</rss>
