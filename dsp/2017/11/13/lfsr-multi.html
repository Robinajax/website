<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Generating more than one bit at a time with an LFSR</title>
  <meta name="description" content="This is now our third post on[Linear Feedback Shift Registers(LFSRs)](https://wikipedia.org/wiki/Linear-feedback_shift_register).Our[first post](/dsp/2017/10...">

  <link rel="shortcut icon" type="image/x-icon" href="/img/GT.ico">
  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="http://zipcpu.com/dsp/2017/11/13/lfsr-multi.html">
  <link rel="alternate" type="application/rss+xml" title="The ZipCPU by Gisselquist Technology" href="http://zipcpu.com/feed.xml">
</head>


  <body>

    <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-102570964-1', 'auto');
  ga('send', 'pageview');

</script>

    <header class="site-header">
  <div id="banner">
  <a href="/"><picture>
    <img height=120 id="site-logo" src="/img/fullgqtech.png" alt="Gisselquist Technology, LLC">
  </picture></A>
  </div>

  <div class="site-nav">
<ul>

<li><a HREF="/">Main/Blog</a>


<li><a HREF="/about/">About Us</a>


<li><a HREF="/fpga-hell.html">FPGA Hell</a>


<li><a HREF="/projects.html">Projects</a>


<li><a HREF="/topics.html">Site Index</a>

<li><a HREF="https://www.patreon.com/ZipCPU"><IMG SRC="/img/patreon_logomark_color_on_white.png" WIDTH="25"> Support</a>
</ul>
</div>


</header>


    <div class="page-content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">Generating more than one bit at a time with an LFSR</h1>
    <p class="post-meta"><time datetime="2017-11-13T00:00:00-05:00" itemprop="datePublished">Nov 13, 2017</time></p>
  </header>

  <div class="post-content" itemprop="articleBody">
    This is now our third post on
[Linear Feedback Shift Registers
(LFSRs)](https://wikipedia.org/wiki/Linear-feedback_shift_register).
Our
[first post](/dsp/2017/10/27/lfsr.html)
examined how to generate a
[Linear Feedback Shift Register
(LFSR)](https://wikipedia.org/wiki/Linear-feedback_shift_register)
in Verilog, and our
second post
walked through an example of a 5-bit
[LFSR](https://wikipedia.org/wiki/Linear-feedback_shift_register).
However, neither of these developments have solved the problem I had
initially.

<TABLE style="float: right"><caption>Fig 1: System Identification Setup</caption><TR><TD><IMG SRC="/img/chanid.svg" ALT="System setup for System ID: one FPGA creates a noise source, the other examines it" width="320"></TD></TR></TABLE>

As you may recall, I wanted to use an
[LFSR](https://wikipedia.org/wiki/Linear-feedback_shift_register)
to do [channel
estimation](https://en.wikipedia.org/wiki/System_identification).
My intention was to use a setup like Fig 1 to the right.  My plan is to
transmit [pseudorandom bits](https://en.wikipedia.org/wiki/Pseudorandomness)
out of an [FPGA](https://en.wikipedia.org/wiki/Field-programmable_gate_array)
output pin at the fastest speed I can:
[950 Mbps](https://www.xilinx.com/support/documentation/data_sheets/ds181_Artix_7_Data_Sheet.pdf)
on my
[Artix-7](https://www.xilinx.com/support/documentation/data_sheets/ds180_7Series_Overview.pdf)
[Arty](https://store.digilentinc.com/arty-artix-7-fpga-development-board-for-makers-and-hobbyists/)
[FPGA](https://en.wikipedia.org/wiki/Field-programmable_gate_array) board.
I'll then receive the bits at the other end of a
[12" pmod cable](https://store.digilentinc.com/pmod-cable-kit-12-pin)
representing my channel, and examine the waveform at the other end to get
an [estimate of the channel throughput and
distortion](https://en.wikipedia.org/wiki/System_identification).

Indeed, if all goes well I should be able to apply [Shannon's Capacity
theorem](https://en.wikipedia.org/wiki/Channel_capacity) to determine the
maximum speed of [the
channel](https://store.digilentinc.com/pmod-cable-kit-12-pin).

To do this, though, I need a source of
[pseudorandom bits](https://en.wikipedia.org/wiki/Pseudorandomness).
Worse, [our last attempt](/dsp/2017/10/27/lfsr.html)
at generating
[pseudorandom bits](https://en.wikipedia.org/wiki/Pseudorandomness) only
generated one bit per clock, and I will need several bits per clock in order
to drive an output serializer at high speed.

So let's return to our [Fibonacci LFSR
generator](https://github.com/ZipCPU/dspfilters/blob/master/rtl/lfsr_fib.v)
and see if we can [modify it to produce more than one output per clock
period](https://github.com/ZipCPU/dspfilters/blob/master/rtl/lfsr.v).
We'll keep the setup identical to
[our first post](/dsp/2017/10/27/lfsr.html),
so the only thing that needs to change today is the number of outputs
bits we need to generate.  We'll start with describing how we'll go about
getting these extra bits, and then discuss the code that implements this.
We'll also do one more: let's *formally prove* at the end of our development,
that our resulting implementation actually works.

## Getting that next bit

Our task is create an
[LFSR](https://wikipedia.org/wiki/Linear-feedback_shift_register)
that produces `WS` bits at a time--rather than just one.  (`WS`= Word Size)
The question, though, is how shall we do this?

<TABLE style="float: right"><caption>Fig 2: Example LFSR</caption><TR><TD><IMG SRC="/img/lfsr-fib5.svg" ALT="An example 5-tap LFSR" width="360"></TD></TR></TABLE>

We'll use the
[example](/dsp/2017/11/11/lfsr-example.html)
[LFSR](https://wikipedia.org/wiki/Linear-feedback_shift_register)
[we presented earlier](/dsp/2017/11/11/lfsr-example.html)
for discussion and as an example along the way.  You can see
[this example](/dsp/2017/11/11/lfsr-example.html)
in Fig 2 at the right.  It's a simple five stage
[LFSR](https://wikipedia.org/wiki/Linear-feedback_shift_register),
with a feedback equation defined by `TAPS=5'b00101`.

Let's begin our development by imagining an infinite stream of (constant)
bits in our shift register, `sreg`.  Each of these bits satisfies the
relationship given by the Fibonacci
[GF(2)](https://en.wikipedia.org/wiki/Finite_field) equation
we started with.  When we presented this equation, we had bits `MSB:0` defined
and we just needed to calculate the next bit, `MSB+1`,

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">sreg[MSB+1] = ^(sreg[MSB:0] &amp; TAPS);</code></pre></figure>

You may also remember, from the discussion of an
[example](/dsp/2017/11/11/lfsr-example.html)
[LFSR](https://wikipedia.org/wiki/Linear-feedback_shift_register), that these
`MSB:0` bits have no required relationship between them--save that they cannot
all be zero.

Now let's see what it will take to calculate bit `MSB+2`.  We can start with
our equation for the next bit, and apply it to bits `[MSB+1:1]` to get bit
`MSB+2`,

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">sreg[MSB+2]     = ^(sreg[MSB+1:1] &amp; TAPS);</code></pre></figure>

We'll have to get rid of the reference to `sreg[MSB+1]`, though, before this
equation will be useful for us.

To get there, let's split this new equation into two parts.

<TABLE style="float: right"><caption>Fig 3: One more bit</caption><TR><TD><IMG SRC="/img/lfsr-fib5-x1.svg" ALT="Getting one extra bit from a 5-tap LFSR" width="420"></TD></TR></TABLE>

The first part will be due to the bits in `sreg[MSB:1]`.  We can represent
this part as `sreg[MSB:0]&(TAPS<<1)`.  This represents the bits that we already
know.  You can see this how this would affect our
[example](/dsp/2017/11/11/lfsr-example.html)
[LFSR](https://wikipedia.org/wiki/Linear-feedback_shift_register)
in Fig 3.  If you compare Fig 3 with Fig 2, you can see how the taps to
generate the next bit are the same as the ones shown in Fig 2, save only that
they've been moved one stage to the left.

The [LFSR in our example](/dsp/2017/11/11/lfsr-example.html)
is simple enough that we can apply this same technique
to even get a second bit from the taps we were given, as Fig 4 below shows.

<TABLE align="center" style="float: none"><caption>Fig 4: Two more bits</caption><TR><TD><IMG SRC="/img/lfsr-fib5-x2.svg" ALT="The second extra bit" width="480"></TD></TR></TABLE>

Where the [example](/dsp/2017/11/11/lfsr-example.html)
falls apart is when you need to reference a bit that isn't present in the
original shift register.  For that, we need to move to the second part of
our equation.

This second part, `sreg[MSB+1]&TAPS[MSB]` will
need some work.  In this case, though, we already have an equation for
`sreg[MSB+1]` (above).  Therefore we can substitute that equation for
`sreg[MSB+1]` into our equation for `sreg[MSB+2]` in order to get a new
expression for `sreg[MSB+2]` that depends only upon `sreg[MSB:0]`,

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">sreg[MSB+2]     = ^(sreg &amp; (TAPS&lt;&lt;1)) ^ (TAPS[MSB]&amp;(sreg &amp; TAPS));</code></pre></figure>

Perhaps a picture will explain this better.  Consider Fig 5 below.

<TABLE align="center" style="float: none"><caption>Fig 5: Getting a third bit</caption><TR><TD><IMG SRC="/img/lfsr-fib5-x3.svg" ALT="Getting a bit not described by the initial register taps" width="540"></TD></TR></TABLE>

In this figure, you can see the remains of the taps that were being shifted
to the left, and a broken reference to a bit that isn't in our set from
`MSB:0`.  However, instead of adding the bit we don't have, we instead
add the equation for that bit.  The result is that our new bit, in this
[example](/dsp/2017/11/11/lfsr-example.html)
[LFSR](https://wikipedia.org/wiki/Linear-feedback_shift_register)
depends upon three bits from our shift register, instead of just the two.

Let's simplify this expression a touch further, though.
If we take another look at the equation above, we can now use the [distributive
property](https://en.wikipedia.org/wiki/Distributive_property)
to collect our terms.  Specifically, we'll factor out the `sreg` term to the
left, and the values multiplied by the `sreg` vector together into a new
term on the right,

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">sreg[MSB+2]     = ^(sreg &amp; ( (TAPS&lt;&lt;1) ^ (TAPS[MSB] ? TAPS : 0)));</code></pre></figure>

In this equation, the portion of our expression to the right of
the `&` looks very much like an expression similar to our expression for
`sreg[MSB+1]`.  Specifically, this right half expression looks like a vector
that, when taken as an inner product with `sreg`, produces our result--just
like the `TAPS` vector did for `sreg[MSB+1]`.  Even better, this vector
is a constant--depending only upon the `TAPS` parameter.  Let's use this.
We'll define `tapv[0]` to be our `TAPS`, and then `tapv[1]` to be this value.

We can then repeat this derivation.  Doing so will reveal a formula for
`tapv[k+1]` based upon `tapv[k]`.  In particular,

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">tapv[k+1] = (tapv[k] &lt;&lt;1) ^ (tapv[k][MSB] ? TAPS : 0)));</code></pre></figure>

This `tapv` array is the key we need to build our code below.

## A Multi-Step LFSR Implementation

Now that we have an equation for future output bits, it's time to
build our multi-step shift register.  Feel free to
follow along in the [code we're creating
here](https://github.com/ZipCPU/dspfilters/blob/master/rtl/lfsr.v), as
we'll only discuss the basic highlights below.

Our goal is to extend [our origianal
Fibonacci](https://github.com/ZipCPU/dspfilters/blob/master/rtl/lfsr_fib.v)
[LFSR](https://wikipedia.org/wiki/Linear-feedback_shift_register)
[code](https://github.com/ZipCPU/dspfilters/blob/master/rtl/lfsr_fib.v)
to output `WS` bits per clock, where `WS` is given by a parameter.
This means we'll need to calculate `WS-1` more bits than we did the
[last time](/dsp/2017/10/27/lfsr.html).  It also means
that our shift register, which only used to be `LN` bits long, will now need
to have `LN+(WS-1)` elements in it.  Of these, we'll use the bottom `WS` bits
as our output bits.

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	assign	o_word=sreg[WS-1:0];</code></pre></figure>

But I'm getting ahead of myself.  Before we can get to `o_word`, there's a
lot of other work to be done first.

We'll start with the equations we just worked out in the last section.  We'll
place these `tapv[]` values into an array of `WS` elements, each as
wide as our underlying
[LFSR](https://wikipedia.org/wiki/Linear-feedback_shift_register),
or `LN` bits long.

The first of these equations is the one we've used before, `tapv[0]`,

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	assign	tapv[0] = TAPS;</code></pre></figure>

From here we can use the recursive equation derived above to get the rest,

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	genvar	k;
	generate for(k=1; k&lt;WS; k=k+1)
	begin : PRECALCULATING_TAP_VALUE
		assign	tapv[k] = (tapv[k-1]&lt;&lt;1)^((tapv[k-1][(LN-1)])?TAPS:0);
	end endgenerate</code></pre></figure>

If you didn't manage to follow the development of these equations above,
don't worry.  We'll
"[prove](https://en.wikipedia.org/wiki/Formal_verification)"
these equations work below in the next section.

The next trick is the reset value.

You may remember before, when we had one new bit per time step, that we set
our state space to an `INITIAL_FILL` value.

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	assign	reset_value[(LN-1):0] = INITIAL_FILL;</code></pre></figure>

This reset value then dictated the first `LN` bits out of our device.

This won't quite work for our multi-step core.  First, the `INITIAL_FILL`
vector needs to have `WS-1` additional elements to it.  Then, to make matters
worse, all of those bits need to maintain the
[LFSR](https://wikipedia.org/wiki/Linear-feedback_shift_register)
relationship between them.  So while the statement above works for the first
`LN` bits, we'll still need to determine the next `WS-1` bits.

We can get these next several bits of the `reset_value` by running the first
several bits of the `reset_value` through [our
Fibonacci](https://github.com/ZipCPU/dspfilters/blob/master/rtl/lfsr_fib.v)
[LFSR](https://wikipedia.org/wiki/Linear-feedback_shift_register)
equation.  This is a zero cost operation: every part of this equation
is known and constant.  Therefore the synthesizer can simplify the code
before our core ever gets mapped to logic.

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	generate
	for(k=0; k&lt;WS-1; k=k+1)
	begin : CALC_RESET
		assign	reset_value[(LN+k)] = ^(reset_value[ k +: LN]&amp;TAPS);
	end endgenerate</code></pre></figure>

While this works well to develop `reset_value`, it doesn't work as well
as an initial value for our `sreg`.  We'd like to say,

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">initial	sreg = reset_value;</code></pre></figure>

However, this only works with some synthesizers, such as
[yosys](http://www.clifford.at/yosys),
and not with others, like
[Verilator](https://www.veripool.org/wiki/verilator).
For those others, we'll set `sreg` initially to
`INITIAL_FILL << (WS-1)`, and then
use `reset_value` for any subsequent resets.  This will still give us the
same sequence, with the only problem being that the first `WS-1` values
will be zero instead of those associated with the fill.

Now that we have our tap equations, `tapv[]`, and our `reset_value`, we can
now move on to the state register itself.  In the
[typical](https://github.com/ZipCPU/dspfilters/blob/master/rtl/lfsr_fib.v)
[LFSR](https://wikipedia.org/wiki/Linear-feedback_shift_register),
all but one bit of the new state register is known.  These known bits are
given by shifting the register one step to the right, whereas the last bit
is generated by the `TAPS` equation.

Let's do the same thing here and shift these known bits first,

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	always @(posedge i_clk)
		if (i_reset)
			sreg[(LN-2):0] &lt;= reset_value[(LN-2):0];
		else if (i_ce)
			sreg[(LN-2):0] &lt;= sreg[(LN+WS-2):WS];</code></pre></figure>

Those are the easy bits.

After those easy bits, our first next bit is determined by the
original Fibonacci
[LFSR](https://wikipedia.org/wiki/Linear-feedback_shift_register)
equation.  That's the one we built into our first [Fibonacci
LFSR](https://github.com/ZipCPU/dspfilters/blob/master/rtl/lfsr_fib.v) module.

<figure class="highlight"><pre><code class="language-text" data-lang="text">sreg[MSB] &lt;= ^(sreg &amp; TAPS);</code></pre></figure>

The rest of the bits are calculated in the same fashion, with the exception
that the equation for them, in particular the `tapv[k]` coefficients,
is different from one bit to the next.  So, our next step is then to
walk through those extra bits applying the `tapv[k]` equations as appropriate
to generate each new bit.

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	generate
	for(k=0; k&lt;WS; k = k+1)
	begin : RUN_LFSR
		always @(posedge i_clk)
			if (i_reset)
				sreg[LN+k-1] &lt;= reset_value[LN+k-1];
			else if (i_ce)
				sreg[(LN+k-1)] &lt;=
					^(sreg[(LN+WS-2):(WS-1)]&amp;tapv[k]);
	end endgenerate</code></pre></figure>

Did you notice how we also cycled through the various `tapv[k]` expressions?
This is just implementing the equations we calculated above.

That's it.  It's still simple, but there is just a little more simple involved
[in this version](https://github.com/ZipCPU/dspfilters/blob/master/rtl/lfsr.v)
over the [last
version](https://github.com/ZipCPU/dspfilters/blob/master/rtl/lfsr_fib.v).

Put together, we just calculated `LN+WS-1` bits.  `LN-1` of these are
calculated the same as before--by shifting the shift register.  The next bit
is still calculated by our original `TAPS` equation, just like we did with
[our initial Fibonacci implementation](https://github.com/ZipCPU/dspfilters/blob/master/rtl/lfsr_fib.v).
The last `WS-1` bits were then calculated in the
exact same way with the only exception being that the equation, `tapv[k]`,
changed on a bit-by-bit basis.

But, let's come back to our earlier question, will this really "work"?  Will
all these equations really produce the sequence we want?

To answer that question, let's see if we can get the computer to
"[prove](https://en.wikipedia.org/wiki/Formal_verification)"
that [this new
form](https://github.com/ZipCPU/dspfilters/blob/master/rtl/lfsr.v) works.

## Applying Formal Methods

I discussed the basics of using
[formal methods](https://en.wikipedia.org/wiki/Formal_verification)
using [yosys-smtbmc](https://www.clifford.at/yosys) in a
[previous post](/blog/2017/10/19/formal-intro.html).
The basic idea behind
[formal methods](https://en.wikipedia.org/wiki/Formal_verification)
is to define a state space, and within it the space of invalid states.
The state space is initially defined by all of the register values within
your design.  It is restricted further, made smaller that is, with `assume`
statements as necessary.  Invalid states are defined as well, but this time
using the `assert` statement.  We'll use these two statements, `assume` and
`assert` with the ultimate goal of
[proving](https://en.wikipedia.org/wiki/Formal_verification)
that the logic above will *never* enter into an illegal state.

[These formal methods](https://en.wikipedia.org/wiki/Formal_verification)
are particularly appropriate for this multi-bit
[LFSR](https://wikipedia.org/wiki/Linear-feedback_shift_register)
design, since
[LFSR](https://wikipedia.org/wiki/Linear-feedback_shift_register)'s
are so mathematically based.  In particular, the output of the
[LFSR](https://wikipedia.org/wiki/Linear-feedback_shift_register)
needs to strictly satisfy a mathematical equation--one that the
[formal equation solver](https://en.wikipedia.org/wiki/Formal_verification)
can verify for us.

As [before](/blog/2017/10/19/formal-intro.html),
we'll use [yosys](https://www.clifford.at/yosys)
to generate a list of properties in a
[format](http://stp.github.io/smt-input-language/) that
[yices](http://yices.csl.sri.com) can understand.  When processing a file in
this manner, [yosys](https://www.clifford.at/yosys) will define the `FORMAL`
pre-processor directive for us.  That allows us to begin our `FORMAL`
verification section with an `ifdef`,

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">`ifdef	FORMAL</code></pre></figure>

Our plan will be to then use [yosys-smtbmc](https://www.clifford.at/yosys)
to then drive the [yices](http://yices.csl.sri.com) theorem prover to prove
that our
[multi-step](https://github.com/ZipCPU/dspfilters/blob/master/rtl/lfsr.v)
[LFSR](https://wikipedia.org/wiki/Linear-feedback_shift_register) actually
works.

The first step is to restrict the search state space.

We'll use the [approach
we presented before](/blog/2017/10/19/formal-intro.html)
to create a clock, and an `f_past_valid` flag.  This latter flag will tell
us whenever the `$past()` directive will yield valid results.

Now using that assumed clock, our first
[LFSR](https://wikipedia.org/wiki/Linear-feedback_shift_register)
specific step will restrict the space of all possibilities by
simply assuming that `i_reset` is true on startup.

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	initial	assume(i_reset);</code></pre></figure>

Next, we'll assert that the bottom `LN` bits are equal to the `INITIAL_FILL`
on the clock following any reset.

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	always @(posedge i_clk)
		if ((f_past_valid)&amp;&amp;($past(i_reset)))
			assert(sreg[(LN-1):0] == INITIAL_FILL);</code></pre></figure>

Now that we've dealt with the `i_reset` case, we can move on to the regular
register bits.

The first test is whether or not the first of the new register bits,
bit `LN-1`, is valid.  This bit is the one produced via the
[original Fibonacci
configuration](https://github.com/ZipCPU/dspfilters/blob/master/rtl/lfsr_fib.v)
[we presented before](/dsp/2017/10/27/lfsr.html).
Here we'll just apply it to the values left in our
shift register, plus the one we just shifted out--the one still found in
`$past(sreg[WS-1])`.  Note that this wouldve been `$past(sreg[0])` in our
[previous
version](https://github.com/ZipCPU/dspfilters/blob/master/rtl/lfsr_fib.v), but
since we are now generating another `WS-1` bits, that last bit shifted out
is no longer the `0` bit from before.

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	always @(posedge i_clk)
		if ((f_past_valid)&amp;&amp;(!$past(i_reset))&amp;&amp;($past(i_ce)))
			assert(sreg[LN-1]
				== ^({sreg[(LN-2):0], $past(sreg[WS-1])}
					&amp; TAPS));</code></pre></figure>

Our new implementation also defines another `WS-1` bits that we want to
validate.  Because this is a very mathematically defined
[LFSR](https://wikipedia.org/wiki/Linear-feedback_shift_register),
there's a mathematical relationship between all of these bits.  All we
need to do to
[formally validate](/blog/2017/10/19/formal-intro.html)
[this code](https://github.com/ZipCPU/dspfilters/blob/master/rtl/lfsr.v)
is to check our current state bits against the equation that was supposed
to generate them one at a time.

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">generate
	for(k=0; k&lt;WS-1; k=k+1)
		always @(posedge i_clk)
			if ((f_past_valid)&amp;&amp;(!$past(i_reset)))
			assert(sreg[LN+k] == ^(sreg[(LN-1+k):k]&amp;TAPS));
	endgenerate</code></pre></figure>

This is the majority of the proof.  If this works, all of our `tapv[]` work
will be verified.

There is one more vital part to our proof: we need to prove that `sreg`
will never be equal to zero.  You may recall when we
[last discussed](/dsp/2017/10/27/lfsr.html)
[LFSR](https://wikipedia.org/wiki/Linear-feedback_shift_register)'s
that we highlighted the problem with a
zero register: once the register `sreg` becomes zero (if ever) then it will
cease to produce
[pseudorandom](https://en.wikipedia.org/wiki/Pseudorandomness)
numbers.  We'll allow the [theorem prover](http://yices.csl.sri.com)
to verify that this never happens.

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	always @(*)
		assert(sreg[(LN+WS-2):(WS-1)] != 0);</code></pre></figure>

That's the last of the file, and the last of the proof.

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">`endif	// FORMAL
endmodule</code></pre></figure>

All that's left is to run the
[theorem prover](https://www.clifford.at/yosys)
and see how we did!

In case you haven't been following along, you can find the example file we
just created
[here](https://github.com/ZipCPU/dspfilters/blob/master/rtl/lfsr.v).  You
can also find the [Makefile](https://github.com/ZipCPU/dspfilters/blob/master/bench/formal/Makefile)
and other files associated with driving the
[formal theorem prover](http://yices.csl.sri.com)
[here](https://github.com/ZipCPU/dspfilters/tree/master/bench/formal).

## Conclusion

Now that I have an
[LFSR](https://wikipedia.org/wiki/Linear-feedback_shift_register)
[implementation](https://github.com/ZipCPU/dspfilters/blob/master/rtl/lfsr.v)
that I can step 8-14 times per clock, I should be able to create a high speed
data stream from one
[FPGA](https://en.wikipedia.org/wiki/Field-programmable_gate_array)
and send it to another.  The difference between what the second
[FPGA](https://en.wikipedia.org/wiki/Field-programmable_gate_array)
observes and what was actually sent will be any channel effects.  In other
words, I'm now ready to move my
[channel identification](https://en.wikipedia.org/wiki/System_identification)
problem forward one step to measure just how much information can be reasonably
stuffed through this
[FPGA](https://en.wikipedia.org/wiki/Field-programmable_gate_array)
[I/O channel](https://store.digilentinc.com/pmod-cable-kit-12-pin).

  </div>


<div class "verse">
<HR align="center;" width="25%">
<P><em>For man also knoweth not his time: as the fishes that are taken in an evil net, and as the birds that are caught in the snare; so are the sons of men snared in an evil time, when it falleth suddenly upon them. (Eccl 9:12)</em>


</article>

      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading">The ZipCPU by Gisselquist Technology</h2>
    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <!-- <li></li> -->
          <li><a href="mailto:zipcpu@gmail.com">zipcpu@gmail.com</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="social-media-list">
          
          <li>
            <a href="https://github.com/ZipCPU"><span class="icon icon--github"><svg viewBox="0 0 16 16"><path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/></svg>
</span><span class="username">ZipCPU</span></a>

          </li>
          

          
          <li>
            <a href="https://twitter.com/zipcpu"><span class="icon icon--twitter"><svg viewBox="0 0 16 16"><path fill="#828282" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27 c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767 c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206 C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271 c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469 c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"/></svg>
</span><span class="username">zipcpu</span></a>

          </li>
          
          
          <li><A href="https://www.patreon.com/ZipCPU"><img src="/img/become_a_patron_button.png"></a></li>
          

        </ul>
      </div>

      <div class="footer-col footer-col-3">
        <p>The ZipCPU blog, featuring how to discussions of FPGA and soft-core CPU design.  This site will be focused on Verilog solutions, using exclusively OpenSource IP products for FPGA design.  Particular focus areas include topics often left out of more mainstreeam FPGA design courses such as how to debug an FPGA design.
</p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
